{"INMR01": {"INMLRECL": 80, "INMFNODE": "ISTE", "INMFUID": "GRPTDIR", "INMTNODE": "ISTE", "INMTUID": "GRPTDIR", "INMFTIME": "20140805212811000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 3644732, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 27998, "INMRECFM": "VB", "INMDIR": 58, "INMDSNAM": "SYS3.SPI.REXX", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 3644732, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 3644732, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SYS3.SPI.REXX": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27998, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 32760, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "140217", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x10'", "DS1LSTAR": "b'\\x00>\\x02'", "DS1TRBAL": "b'\\x948'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x89\\xa0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x89\\xa0\\xd8'", "b'X\\xfa.8\\x00\\x00\\x13\\x11\\x00\\x00\\x13\\x17\\x00\\x05\\x00`'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$COIBM": {"ttr": 12291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x16\\x01\\x06\\tO\\x01\\x06\\tO\\x14\\x02\\x00\\x01\\x00\\x01\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-04-04T00:00:00", "modifydate": "2006-04-04T14:02:16", "lines": 1, "newlines": 1, "modlines": 0, "user": "COA1DIR"}, "text": "hithere\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INSTALL": {"ttr": 8207, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x02\\x00)\\x00\\x99'/\\x01\\x03&_\\x08\\x14\\x00\\x12\\x00\\x0e\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@\"", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-09-29T00:00:00", "modifydate": "2003-09-22T08:14:29", "lines": 18, "newlines": 14, "modlines": 0, "user": "COA1DIR"}, "text": "Additional install instructions:\n1 - Message dataset creation.\n  To create and populate a syshelp formatted message dataset use the\n  MSGHELP REXX exec included in this library. Invoke the command\n  with the input dataset ( this libraries MSGS member ) and the\n  output dataset as arguments. As below:\n\n\n                                  The dsn to put the help members\n                                             |\n                   This dsn and msgs member  |\n                           |                 |\n                           |                 |\n    %FSDISP msghelp sys4.spi.source(msgs) my.help.pds\n\n2 -  The TSOBATCH proc is included in the parmlib, it should be copied\n  to a system proclib. As an alternative a JCLLIB statement can be\n  added tio the sample JCSOURCE member in the PARMLIB.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@RXEDIT": {"ttr": 271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x000\\x00\\x97\\x14\\x1f\\x00\\x97\\x14\\x1f\\x08Y\\x00\\x16\\x00\\x16\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1997-05-21T00:00:00", "modifydate": "1997-05-21T08:59:30", "lines": 22, "newlines": 22, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG NAME\nIF LENGTH(TSOCMD) = 0 THEN  DO\n  SAY 'RXBROWSE:   INVALID SYNTAX:'\n  SAY 'RXBROWSE:   SYNTAX IS RXBROWSE <SUFFIX>'\n  EXIT\nEND\nX=MSG('OFF')\nX=OUTTRAP(\"OUTLINE.\")\nUID = USERID()\nIF SUBSTR(NAME,1,1) \u00ac= \"'\" THEN NAME = \"'\"||NAME||\"'\"\n/* NAME = \"TECH.\"UID\".\"SUFFIX */\nOUTLINE.T = \"                                               \"\n\"ALLOC F(FS00001) DSN(\"NAME\")  SHR REUS\" ,\n/* --------------------------------------------------------------- */\n/* EXECUTE COMMAND                                                 */\n/* --------------------------------------------------------------- */\nADDRESS ISPEXEC 'LMINIT DATAID(DSN1) DDNAME(FS00001) ENQ(EXCLU)'\nADDRESS ISPEXEC 'EDIT DATAID(&DSN1)'\nADDRESS ISPEXEC 'LMFREE DATAID(&DSN1)'\nENDD:\n\"FREE F(FS00001)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@XBROWSE": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x000\\x00\\x97\\x14\\x1f\\x00\\x99\\x08\\x8f\\x13T\\x00\\x17\\x00\\x17\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1997-05-21T00:00:00", "modifydate": "1999-03-29T13:54:30", "lines": 23, "newlines": 23, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG NAME\nIF LENGTH(TSOCMD) = 0 THEN  DO\n  SAY 'RXBROWSE:   INVALID SYNTAX:'\n  SAY 'RXBROWSE:   SYNTAX IS RXBROWSE <SUFFIX>'\n  EXIT\nEND\nX=MSG('OFF')\nX=OUTTRAP(\"OUTLINE.\")\nUID = USERID()\nIF SUBSTR(NAME,1,1) \u00ac= \"'\" THEN NAME = \"'\"||NAME||\"'\"\n/* NAME = \"TECH.\"UID\".\"SUFFIX */\nOUTLINE.T = \"                                               \"\n WRKDD = \"WRK\" || RANDOM()               /* GENERATE UNIQUE DDNAME */\n\"ALLOC F(\"WRKDD\") DSN(\"NAME\")  SHR REUS\" ,\n/* --------------------------------------------------------------- */\n/* EXECUTE COMMAND                                                 */\n/* --------------------------------------------------------------- */\nADDRESS ISPEXEC \"LMINIT DATAID(DSN1) DDNAME(\"WRKDD\") ENQ(EXCLU)\"\nADDRESS ISPEXEC 'BROWSE DATAID(&DSN1)'\nADDRESS ISPEXEC 'LMFREE DATAID(&DSN1)'\nENDD:\n\"FREE F(\"WRKDD\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AA": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00#\\x00\\x99\\x10O\\x01\\x00\\x16_\\x13Y\\x00I\\x00I\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-04-14T00:00:00", "modifydate": "2000-06-13T13:59:23", "lines": 73, "newlines": 73, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX */\nARG ID\nADDRESS TSO \"ADDALIAS \"ID \"CATALOG.MVSICF1.VTSO001\",\n  \"CATALOG.MVSICFM.VCO2MC1 PWUPDATE\"\nsay \"T50ICOMP: in control with parms \" function acidlist\nsay \"T50ICOMP: Maint = \" maint\nsay \"T50ICOMP: retrieving profile variables \"\n    say \"T50ICOMP: calling jobcard function. \"\n  say \"Output DSN unusable, data written to screen \"\n  say \"Resource processing started\"\n    say \"T50ICOMP: bypass option specified, allocating input dsn\"\n    say \"T50ICOMP: total acids contained in input DSN is \" acidnum\n  say \"T50ICOMP: bypass option specified, allocating input dsn\"\n  say \"T50ICOMP: total acids contained in input DSN is \" acidnum\n    SAY  \"Unique ACID RDT not supported. Function aborted.\"\n        say \"T50ICOMP: Segment changed to \"segment \"for \" name\n      say \"In duplicate loop\" concat prev_type prev_resource hold\n        say \"T50ICOMP: Mult key \"name \"==>\" prev_type prev_resource hold\n      say \"T50ICOMP: Mult keys\" prev_type prev_resource \" is now \" tz1\n      say \"         \" prev_type prev_resource hold duplicat\n        say \"T50ICOMP: Concat rule \",\n    say \"LISTDUP:\"name \"duplicate keysets\" aciddup.name.0\n      say \" \"\n      say \" LISTDUP:\"name \"keyset=\" type resource\n      say \" LISTDUP: primary:\" prime\n        say listdup.dupnum\n    say \"T50ICOMP: starting to process ACID:\" x \">\"name\"<\"\n    say \"          Rules#:\" acidrul.name.0\n    say cvtcmd.z1\n  say \"T50ICOMP:  MODIFY starting to process ACID:\" name\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          say \"t50pmenu: secure routine failed access \"\n  say \"leaving modify\"\n    say cvtcmd.z1\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\n  say \"**NEWACID** \" name\n    say next\n      say \"hold =\"name type resource\n      say \"      \" hold\n      say \"hold1=\"otherid type resource\n      say \"      \" hold1\n    say compare.cmpnum\n    SAY \"*********************************************************\"\n    say \"T50ICOMP makeacid routine aborting due to lack of user type\"\n    SAY \"T50ICOMP : acid = \"name\n    SAY \"*********************************************************\"\n  say create.t1\nsay \"CONIN \"function segment \">\"||inline||\"<\"\n  say \"input       dsn line \"inline\n  say \"reformatted dsn line \"inline\n   say \"convert: type =\"type \"res=\"resource \"name=\"name\n   say \"convert: concat = \" hold\nsay \"Multi: =\" multi\nsay \"Stack: =\" stack\n  say \"convert: output is now :\" output\n  say  \"T50ICOMP: error in line \"sigl\n  say x\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\nsay secrc\n  say \"FATAL ERROR.\"\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\nsay secrc\nsay \"Dumping acidrul array for \" name\n  say out \"=\" next\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\nsay \"MODRULE:prepanel\" l\nsay \"Modrule: final conlist\" conlist\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDALIAZ": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x004\\x01\\x02\\x02\\x8f\\x01\\x02\\x02\\x8f\\x14\\x01\\x00\\x14\\x00\\x14\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-28T00:00:00", "modifydate": "2002-01-28T14:01:34", "lines": 20, "newlines": 20, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nSIGNAL OFF ERROR\n/*********************************/\n/* ADD AN ALIAS TO CATALOG       */\n/* PARMS :                       */\n/*         THE ALIAS             */\n/*         THE USERCATALOG       */\n/*         THE MASTERCATALOG     */\n/*         THE PASSWORD          */\n/*********************************/\nCALL OFF ERROR\nTRACE OFF\nARG ALIAS CAT MCAT PWD\nCMD = \" DEFINE ALIAS ( NAME('\"ALIAS\"') RELATE('\"CAT\"') )\"\nCMD = CMD \" CATALOG('\"MCAT\"'/\"PWD\")\"\n/* SAY CMD */\nADDRESS TSO  \"  \"CMD\nRCODE = RC\nSAY RCODE\nEXIT RCODE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDLOCAL": {"ttr": 7179, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00%\\x00\\x99\\x08\\x8f\\x01\\x03\\x05\\x1f\\x10V\\x00\\x06\\x00\\x06\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "2003-02-20T10:56:25", "lines": 6, "newlines": 6, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/* THIS IS A LOCAL PROCESSING REXX EXEC */\nARG ID DEPT\nADDRESS TSO \"%CBHALIAS \" ID\nADDRESS TSO \"%TSSAUDU \" ID\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTHRUN": {"ttr": 13071, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00G\\x00\\x99\\x14o\\x01\\x07\\x19\\x8f\\x11!\\x00*\\x00&\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1999-05-26T00:00:00", "modifydate": "2007-07-17T11:21:47", "lines": 42, "newlines": 38, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\narg dsname acid\nupper dsname\nhold = sysvar(sysuid)\nif index(dsname,\"BYPASS\") > 0 then\n  dsname = hold\".c2\"\ndsname = TRANSLATE(dsname,\"\",\"'\") /* REPLACE tics WITH nulls */\ndsname = strip(dsname)\ndscheck = sysdsn(\"'\"dsname\"'\")\nenv = sysvar(sysenv)\ntotal_code = 0\nif dscheck /= \"OK\" then do\n  secrc = \"TSA501E: DSN \"dsname\" is unavailable, status = \"dscheck\n  say secrc\n  if env = \"FORE\" then address ispexec \"vput secrc profile\"\n  exit 8\nend\nADDRESS TSO \"ALLOC DDN(SECDEF) DSN('\"dsname\"') SHR REUS\"\nADDRESS MVS \"EXECIO * DISKR SECDEF ( FINIS STEM SECDEF.)\"\nADDRESS TSO \"FREE DDN(SECDEF)\"\nsignal off error\n/******************************************************/\ndo t = 2 to secdef.0\n  if secdef.t = \" \" then iterate t\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \"TSA502I: Authrun $$ substitution string found in stream\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \"TSA502I: Authrun $DEPT$ substitution string found in stream\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n  end\n  say \"TSA503I: Authrun resolved command is \"secdef.t\n  say \"TSA504I: Authrun issuing command\"\n  address tso secdef.t\n  total_code = total_code + rc\nend\nsecrc =  \"TSA505I: Sum of all return codes is \" total_code\nsay secrc\nexit total_code\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COMPISPF": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x002\\x00\\x99\\x02\\x0f\\x00\\x99\\x02\\x0f\\x10\\x10\\x00\\x03\\x00\\x03\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-01-20T00:00:00", "modifydate": "1999-01-20T10:10:32", "lines": 3, "newlines": 3, "modlines": 0, "user": "*SPIV8*"}, "text": "PARSE VERSION V .\nIF LEFT(V,5) = \"REXXC\" THEN compiled = \"YES\"\nIf compiled = \"YES\" then say \"Compiled Version Running.\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELAL": {"ttr": 8455, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x04\\x05O\\x01\\x04\\x05O\\x13\\x03\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-23T00:00:00", "modifydate": "2004-02-23T13:03:52", "lines": 13, "newlines": 13, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\n/* VERY SIMPLE EXEC TO DELETE AN ALIAS FROM THE MCAT */\nSIGNAL OFF ERROR\nCALL OFF ERROR\nARG ALIAS MCAT PWD\nCMD = \" DELETE ('\"ALIAS\"') ALIAS\"\nCMD = CMD \" CATALOG('\"MCAT\"'/\"PWD\")\"\n/* CMD = \"DELETE ('\"ALIAS\"'/\"PWD\")\"*/\nSAY CMD\nADDRESS TSO  \"  \"CMD\nRCODE = RC\nSAY RCODE\nEXIT RCODE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELLOCAL": {"ttr": 291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x00\\x00\\x99\\x08\\x8f\\x00\\x99\\x08\\x8f\\x13S\\x00\\x04\\x00\\x04\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "1999-03-29T13:53:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/* THIS IS A LOCAL PROCESSING REXX EXEC */\nARG ACID DEPT\nEXIT 0\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DLOG": {"ttr": 3091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01.\\x00$\\x01\\x00\\x02\\x8f\\x01\\x00\\x03/\\x159\\x00\\t\\x00\\t\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.46", "flags": 0, "createdate": "2000-01-28T00:00:00", "modifydate": "2000-02-01T15:39:24", "lines": 9, "newlines": 9, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\ntrace  ir\nq = D1log(DEBUG,100,init)\nBEGIN_CPU = SYSVAR(SYSCPU)\nsay q\n  q = d1log('hi there 't)\ntotal_cpu = sysvar(syscpu) - begin_cpu\nsay total_cpu\nexit 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "EMSBADD": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x02\\x01\\x00\\x16\\x7f\\x01\\x00\\x16\\x7f\\x158\\x00\\xe4\\x00\\xe4\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2000-06-15T15:38:02", "lines": 228, "newlines": 228, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                **/\n/**        exec to batch update the EMSproc NVAS system **/\n/*********************************************************/\n/** to add this exec to your system include this line   **/\n/** in your SRCCMD DSN:                                 **/\n/** NVASUADD  %EMSBADD  1 1 0 5 ON 2 $1.acid DATA       **/\n/**                                                     **/\n/** Then:                                               **/\n/** add the cfileds variable to the T$$.... exec        **/\n/** add a vput statement for the cfileds in T$$....     **/\n/** update your SRCSCR dsn with a emsbadd entry         **/\n/** ISSUE a reinit command                              **/\n/*********************************************************/\naddress ispexec\nsignal on error name novar\narg func p1 p2\n/*********************************************************/\n/* the below variables must be set in TSSINI or T$$...   */\n/*********************************************************/\nispexec \"vget ds5 profile      \"\nispexec \"vget mode profile     \"\nispexec \"vget zSYSID\"\nispexec \"vget ds3 profile      \"\nispexec \"vget jcard profile    \"\nispexec \"vget srcjcl  profile  \"\n/*********************************************************/\n/* the above variables must be set in TSSINI or T$$...   */\n/*********************************************************/\npr = zsysid\nsysin. = \"\"\nif func = \"NVADDU\" then do\n  theid = p1\n  thegroup = p2\n  sysin.0 = 7\n  sysin.1 = \" ADD  USER,                                           \"\n  sysin.2 = \"      USER_ID=\"theid\",                                  \"\n  sysin.3 = \"      GROUP_NAME=\"thegroup\",                            \"\n  sysin.4 = \"      APPLICATION=*,                                    \"\n  sysin.5 = \"      DEFAULT_GROUP=Y,                                  \"\n  sysin.6 = \"      RECORD_AUTHORITY=YES,                             \"\n  sysin.7 = \"      TERMINAL_ASSUME=YES                               \"\nend\nif func = \"NVADDG\" then do\n  sysin.0 = 99\n  sysin.1 = \"  ADD GROUP,                                            \"\n  sysin.2 = \"       GROUP_NAME=\"p1\",                                 \"\n  sysin.3 = \"       GROUP_TYPE=EXTERNAL,                             \"\n  sysin.4 = \"       ACCOUNT_NUMBER=CSTONE,                           \"\n  sysin.5 = \"       NUMBER_OF_SESSIONS=20,                           \"\n  SYSIN.6 = \"       LOGON_REXX_EXEC=GLOGON,                          \"\n  sysin.7 = \"       MULTI_TERMINAL=Y,                                \"\n  sysin.8 = \"       ESCAPE_KEY=PF24,                                 \"\n  sysin.9 = \"       COMMAND_KEY=PF23,                                \"\n  sysin.10= \"       COPYFROM_BEGIN=PF02,                             \"\n  sysin.11= \"       COPYFROM_END=PF02,                               \"\n  sysin.12= \"       COPYTO=PF02,                                     \"\n  sysin.13= \"       COMMAND_PREFIX='\\'                               \"\n  sysin.14= \"                                                         \"\n  sysin.15= \"                                                         \"\n  sysin.16= \" ADD GROUP_APPLICATION,                                  \"\n  sysin.17= \"      GROUP_NAME=\"p1\",                                   \"\n  sysin.18= \"      APPLICATION=........,                              \"\n  sysin.19= \"      ACCESS_TYPE=RELAY,                                 \"\n  sysin.20= \"      LOGON_PROFILE=GROUP,                               \"\n  sysin.21= \"      AUTOMATIC_LOGON=YES,                               \"\n  sysin.22= \"      JUMP_KEY=PF23,vtam_logmode=snx32702,               \"\n  sysin.23= \"      SELECTION_ID=99,                                   \"\n  sysin.24= \"      VIRTUAL_TERMINAL=Y,                                \"\n  sysin.25= \"      APPLICATION_DESCRIPTION='Free Entry'               \"\n  sysin.26= \"*                                                        \"\n  sysin.27= \" ADD GROUP_APPLICATION,                                  \"\n  sysin.28= \"      GROUP_NAME=\"p1\",                                   \"\n  sysin.29= \"      APPLICATION=TSO,                                   \"\n  sysin.30= \"      SYSTEM_INTERNAL_NAME=TSO,                          \"\n  sysin.31= \"      ACCESS_TYPE=RELAY,                                 \"\n  sysin.32= \"      LOGON_PROFILE=GROUP,                               \"\n  sysin.33= \"      AUTOMATIC_LOGON=YES,                               \"\n  SYSIN.34= \"      JUMP_KEY=PF23,VTAM_LOGMODE=SNX32702,               \"\n  sysin.35= \"      SELECTION_ID=1,                                    \"\n  sysin.36= \"      VIRTUAL_TERMINAL=Y,                                \"\n  sysin.37= \"      APPLICATION_DESCRIPTION='OS390 TSO'                \"\n  sysin.38= \"*                                                        \"\n  sysin.39= \" ADD GROUP_APPLICATION,                                  \"\n  sysin.40= \"      GROUP_NAME=\"p1\",                                   \"\n  sysin.41= \"      APPLICATION=\"pr\"C10A,                              \"\n  sysin.42= \"      SYSTEM_INTERNAL_NAME=\"pr\"C10A,                     \"\n  sysin.43= \"      ACCESS_TYPE=RELAY,                                 \"\n  sysin.44= \"      LOGON_PROFILE=GROUP,                               \"\n  sysin.45= \"      AUTOMATIC_LOGON=YES,                               \"\n  sysin.46= \"      JUMP_KEY=PF23,VTAM_LOGMODE=SNX32702,               \"\n  sysin.47= \"      SELECTION_ID=2,                                    \"\n  sysin.48= \"      VIRTUAL_TERMINAL=Y,                                \"\n  sysin.49= \"     APPLICATION_DESCRIPTION='DIMENSION - CICS - AOR 10 '\"\n  sysin.50= \"*                                                        \"\n  sysin.51= \" ADD GROUP_APPLICATION,                                  \"\n  sysin.52= \"      GROUP_NAME=\"p1\",                                   \"\n  sysin.53= \"      APPLICATION=\"pr\"C10Q,                              \"\n  sysin.54= \"      SYSTEM_INTERNAL_NAME=\"pr\"C10Q,                     \"\n  sysin.55= \"      ACCESS_TYPE=RELAY,                                 \"\n  sysin.56= \"      LOGON_PROFILE=GROUP,                               \"\n  sysin.57= \"      AUTOMATIC_LOGON=YES,                               \"\n  sysin.58= \"      JUMP_KEY=PF23,VTAM_LOGMODE=SNX32702,               \"\n  sysin.59= \"      SELECTION_ID=3,                                    \"\n  sysin.60= \"      VIRTUAL_TERMINAL=Y,                                \"\n  sysin.61= \"      APPLICATION_DESCRIPTION='DIMENSION - CICS - QOR 10'\"\n  sysin.62= \"*                                                        \"\n  sysin.63= \" ADD GROUP_APPLICATION,                                  \"\n  sysin.64= \"      GROUP_NAME=\"p1\",                                   \"\n  sysin.65= \"      APPLICATION=\"pr\"C10T,                              \"\n  sysin.66= \"      SYSTEM_INTERNAL_NAME=\"pr\"C10T,                     \"\n  sysin.67= \"      ACCESS_TYPE=RELAY,                                 \"\n  sysin.68= \"      LOGON_PROFILE=GROUP,                               \"\n  sysin.69= \"      AUTOMATIC_LOGON=YES,                               \"\n  sysin.70= \"      JUMP_KEY=PF23,VTAM_LOGMODE=SNX32702,               \"\n  sysin.71= \"      SELECTION_ID=4,                                    \"\n  sysin.72= \"      VIRTUAL_TERMINAL=Y,                                \"\n  sysin.73= \"      APPLICATION_DESCRIPTION='DIMENSION - CICS - TOR 10'\"\n  sysin.74= \"*                                                        \"\n  sysin.75= \" ADD GROUP_APPLICATION,                                  \"\n  sysin.76= \"      GROUP_NAME=\"p1\",                                   \"\n  sysin.77= \"      APPLICATION=\"pr\"C20A,                              \"\n  sysin.78= \"      SYSTEM_INTERNAL_NAME=\"pr\"C20A,                     \"\n  sysin.79= \"      ACCESS_TYPE=RELAY,                                 \"\n  sysin.80= \"      LOGON_PROFILE=GROUP,                               \"\n  sysin.81= \"      AUTOMATIC_LOGON=YES,                               \"\n  sysin.82= \"      JUMP_KEY=PF23,VTAM_LOGMODE=SNX32702,               \"\n  sysin.83= \"      SELECTION_ID=5,                                    \"\n  sysin.84= \"      VIRTUAL_TERMINAL=Y,                                \"\n  sysin.85= \"      APPLICATION_DESCRIPTION='DIMENSION - CICS - AOR 20'\"\n  sysin.86= \"*                                                        \"\n  sysin.87= \" ADD GROUP_APPLICATION,                                  \"\n  sysin.88= \"      GROUP_NAME=\"p1\",                                   \"\n  sysin.89= \"      APPLICATION=\"pr\"C20T,                              \"\n  sysin.90= \"      SYSTEM_INTERNAL_NAME=\"pr\"C20T,                     \"\n  sysin.91= \"      ACCESS_TYPE=RELAY,                                 \"\n  sysin.92= \"      LOGON_PROFILE=GROUP,                               \"\n  sysin.93= \"      AUTOMATIC_LOGON=YES,                               \"\n  sysin.94= \"      JUMP_KEY=PF23,VTAM_LOGMODE=SNX32702,               \"\n  sysin.95= \"      SELECTION_ID=6,                                    \"\n  sysin.96= \"      VIRTUAL_TERMINAL=Y,                                \"\n  sysin.97= \"      APPLICATION_DESCRIPTION='DIMENSION - CICS - TOR 20'\"\n  sysin.98= \"*                                                        \"\nend\nsignal on error name seeya\ndisp = \"NEW,CATLG\"\nif sysdsn(cfileds) = \"OK\" then disp = \"SHR\"\noutds = ds5\nif mode = \"BATCH\" then outds = ds3\nid = sysvar(sysuid)\nqx = time()\nsn = zsysid\ntnum = substr(qx,1,2)||substr(qx,4,2)\njobname = \"EMSB\"tnum\nqueue \"//\"jobname \"JOB\" jcard\",typrun=hold\"\nqueue \"//*                                                     \"\nqueue \"//*                                                     \"\nqueue \"//******************************************************\"\nqueue \"//* MODULE NAME : EMSBLOAD                              \"\nqueue \"//* JCL from CORNERST.OS390290.NVAS.LIB                 \"\nqueue \"//* DESCRIPTION : NVAS Base Product Customization Job   \"\nqueue \"//*                                                     \"\nqueue \"//*                                                     \"\nqueue \"//*                                                     \"\nqueue \"//******************************************************\"\nqueue \"//**         Note: first time change UID=PUBUSER        \"\nqueue \"//******************************************************\"\nqueue \"//BATCHLO  EXEC PGM=EMSBXPMC,REGION=2M,                 \"\nqueue \"//         PARM='EXEC,UID=PUBUSER,UNLOCK'               \"\nqueue \"//*-----------------------------------------------------\"\nqueue \"//* NVAS load module library...:                        \"\nqueue \"//*-----------------------------------------------------\"\nqueue \"//STEPLIB   DD DSN=EMS.V2R1M1.SEMSLMD0,DISP=SHR         \"\nqueue \"//*-----------------------------------------------------\"\nqueue \"//* NVAS VSAM clusters...:                              \"\nqueue \"//*-----------------------------------------------------\"\nqueue \"//EMSBSRTS  DD DSN=\"sn\".EMS.V2R1M1.EMSSRTS,DISP=SHR     \"\nqueue \"//EMSBSRTG  DD DSN=\"sn\".EMS.V2R1M1.EMSSRTG,DISP=SHR     \"\nqueue \"//EMSBSRTU  DD DSN=\"sn\".EMS.V2R1M1.EMSSRTU,DISP=SHR     \"\nqueue \"//EMSBPLDT  DD DSN=\"sn\".EMS.V2R1M1.EMSPLDT,DISP=SHR     \"\nqueue \"//EMSBGPRF  DD DSN=\"sn\".EMS.V2R1M1.EMSGPRF,DISP=SHR     \"\nqueue \"//EMSBALLT  DD DSN=\"sn\".EMS.V2R1M1.EMSALLT,DISP=SHR     \"\nqueue \"//EMSBGAL   DD DSN=\"sn\".EMS.V2R1M1.EMSGAL,DISP=SHR      \"\nqueue \"//*-----------------------------------------------------\"\nqueue \"//* PRINT output data sets...:                          \"\nqueue \"//*-----------------------------------------------------\"\nqueue \"//SYSPRINT  DD SYSOUT=*,DCB=(LRECL=133,RECFM=FBA)       \"\nqueue \"//EMSBREPO  DD SYSOUT=*,DCB=(LRECL=133,RECFM=FBA)       \"\nqueue \"//EMSBLIST  DD SYSOUT=*,DCB=(LRECL=133,RECFM=FBA)       \"\nqueue \"//SYSUDUMP  DD SYSOUT=*                                 \"\nqueue \"//*-----------------------------------------------------\"\nqueue \"//* Sample Command Input for NVAS Batch Load program...:\"\nqueue \"//*-----------------------------------------------------\"\nqueue \"//EMSBCOMM  DD *                                        \"\ndo q = 1 to sysin.0\n  queue sysin.q\nend\nqueue \"/*                                                      \"\nif srcjcl = \"YES\" then do\n  lines = queued()\n  say \"lines is \"lines\n  do x = 1 to lines\n    pull thejcl.x\n  end\n  /***********************************************/\n  /** submit the job                            **/\n  /***********************************************/\n  address tso \"alloc ddn(outjcl) dsn(\"outds\") shr reus\"\n  address mvs \"execio \"lines\" diskw outjcl ( finis stem thejcl.)\"\n  address tso \"free ddn(outjcl)\"\n  address tso \"submit \"outds\n  secrc = jobname \"submitted, jcl saved in \"outds\n  \"vput secrc profile\"\nend\nelse do\n  queue \"$$                                                        \"\n  address tso \"SUBMIT * END($$)\"\n  secrc = jobname \"submitted dynamically no copy saved.\"\n  \"vput secrc profile\"\nend\nexit 0\nseeya: nop\nsecrc = \"emsbadd terminated abnormally, exit line was\" sigl\n\"vput secrc profile\"\nexit 4\nnovar: nop\nsecrc = \"emsbadd variable retrieval failed. line was\" sigl\n\"vput secrc profile\"\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ERROR1": {"ttr": 3089, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\"\\x01\\x00\\x03/\\x01\\x00\\x03/\\x11\\x19\\x00\\x05\\x00\\x05\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-01T00:00:00", "modifydate": "2000-02-01T11:19:22", "lines": 5, "newlines": 5, "modlines": 0, "user": "*SPIV8*"}, "text": "errorl: nop\neline = sigl\nbadline = sourceline(eline)\nsay \"line # \" eline caused an error\"\nsay badline\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXECIO": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x10\\x00\\x99\\x17?\\x00\\x99\\x17?\\t\\x00\\x00\\x01\\x00\\x01\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-06-22T00:00:00", "modifydate": "1999-06-22T09:00:10", "lines": 1, "newlines": 1, "modlines": 0, "user": "*SPIV8*"}, "text": "\"EXECIO * DISKR INPUT ( FINIS STEM HOLD.)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FILECHK": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x18\\x01\\x00\\x06\\x0f\\x01\\x00\\x11_\\t\\x14\\x00\\x19\\x00\\x19\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2000-02-29T00:00:00", "modifydate": "2000-04-24T09:14:18", "lines": 25, "newlines": 25, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\naddress ispexec vget \"filelist profile\"\nsignal off error\ncnt =  words(filelist)\ndo x = 1 to cnt\n  file = word(filelist,x)\n  address ispexec \"vget \"file \"profile\"\n  hold = value(file)\n  file = hold\n  if rc /= 0 then\n    say \"TSA101D: Variable \" file \"is not initialized\"\n  s = sysdsn(file)\n  say \"TSA101D: Checking DSN\" file\n  if s /= \"OK\" then do\n    quote = index(file,\"'\")\n    if quote = 0 then\n      nfile = sysdsn(\"'\"file\"'\")\n    if (quote = 0) & (nfile /= \"OK\") then\n      say \"TSA101D: Dataset \"file \" status not normal:\" s\n    if (quote = 0) & (nfile = \"OK\") then\n      say \"TSA101W: Dataset \"file \" found after quotes were added\"\n    if (nfile /= \"OK\") then\n      say \"TSA101D: Dataset \"file \" status not normal:\" s\n  end\nend\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FS": {"ttr": 4611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00)\\x00\\x98(\\x8f\\x01\\x00\\x10O\\x145\\x00+\\x00+\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1998-10-15T00:00:00", "modifydate": "2000-04-13T14:35:29", "lines": 43, "newlines": 43, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX PGM = FS       - FULL SCREEN VIEW                          */\n/*                                                                 */\n/* --------------------------------------------------------------- */\n/* STORE INPUT IN VARIABLE TSOCMD                                  */\n/* --------------------------------------------------------------- */\nARG TSOCMD\nIF LENGTH(TSOCMD) = 0 THEN\n   DO\n     SAY 'FS:   INVALID SYNTAX:'\n     SAY 'FS:   SYNTAX IS FS <TSO COMMAND>'\n     EXIT\n   END\nELSE NOP\nX=MSG('OFF')\nX=OUTTRAP(\"OUTLINE.\")\n/* BELOW 2 LINES OF CODE ADDED TO PREVENT POSSIBLE PROBLEMS    */\n/*   THAT CAN OCCUR IF TSOCMD DOES NOT RETURN ANY OUTPUT       */\nT = OUTLINE.0 + 1\nOUTLINE.T = \"                                               \"\n WRKDD = \"WRK\" || RANDOM()               /* GENERATE UNIQUE DDNAME */\n\"ALLOC F(\"WRKDD\") TRACKS SPACE(60 15) UNIT(VIO) NEW\",\n  \"DSORG(PS) LRECL(132) RECFM(F B) BLKSIZE(27984)\"\n/* --------------------------------------------------------------- */\n/* EXECUTE COMMAND                                                 */\n/* --------------------------------------------------------------- */\nIF INDEX(TSOCMD,\"|\") > 0 THEN DO\n    PARSE VAR TSOCMD CMD1 '|' CMD2\n    \"\"CMD1\"\"\n    \"\"CMD2\"\"\n  END\n  ELSE\n    \"\"TSOCMD\"\"\nIF RC < 0 THEN\n   DO\n      SAY WORD(TSOCMD,1) 'COMMAND NOT FOUND.'\n      SIGNAL ENDD\n   END\n\"EXECIO * DISKW \"WRKDD\" (FINIS STEM OUTLINE.\"\nADDRESS ISPEXEC \"LMINIT DATAID(DSN1) DDNAME(\"WRKDD\") ENQ(EXCLU)\"\nADDRESS ISPEXEC \"VIEW DATAID(&DSN1)\"\nADDRESS ISPEXEC \"LMFREE DATAID(&DSN1)\"\nENDD:\n\"FREE F(\"WRKDD\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FSDISP": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x07\\x00\\x98!\\x8f\\x01\\x00\\x10O\\x146\\x00,\\x00,\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1998-08-06T00:00:00", "modifydate": "2000-04-13T14:36:07", "lines": 44, "newlines": 44, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX PGM = FS       - FULL SCREEN VIEW                          */\n/*                                                                 */\n/* --------------------------------------------------------------- */\n/* STORE INPUT IN VARIABLE TSOCMD                                  */\n/* --------------------------------------------------------------- */\nARG TSOCMD\nIF LENGTH(TSOCMD) = 0 THEN\n   DO\n     SAY 'FS:   IMS.SYSTEM.CLIST'\n     SAY 'FS:   INVALID SYNTAX:'\n     SAY 'FS:   SYNTAX IS FS <TSO COMMAND>'\n     EXIT\n   END\nELSE NOP\nX=MSG('OFF')\nX=OUTTRAP(\"OUTLINE.\")\n/* BELOW 2 LINES OF CODE ADDED TO PREVENT POSSIBLE PROBLEMS    */\n/*   THAT CAN OCCUR IF TSOCMD DOES NOT RETURN ANY OUTPUT       */\nT = OUTLINE.0 + 1\nOUTLINE.T = \"                                               \"\n WRKDD = \"WRK\" || RANDOM()               /* GENERATE UNIQUE DDNAME */\n\"ALLOC F(\"WRKDD\") TRACKS SPACE(60 15) UNIT(VIO) NEW\",\n  \"DSORG(PS) LRECL(132) RECFM(F B) BLKSIZE(0)\"\n/* --------------------------------------------------------------- */\n/* EXECUTE COMMAND                                                 */\n/* --------------------------------------------------------------- */\nIF INDEX(TSOCMD,\"|\") > 0 THEN DO\n    PARSE VAR TSOCMD CMD1 '|' CMD2\n    \"\"CMD1\"\"\n    \"\"CMD2\"\"\n  END\n  ELSE\n    \"\"TSOCMD\"\"\nIF RC < 0 THEN\n   DO\n      SAY WORD(TSOCMD,1) 'COMMAND NOT FOUND.'\n      SIGNAL ENDD\n   END\n\"EXECIO * DISKW \"WRKDD\" (FINIS STEM OUTLINE.\"\nADDRESS ISPEXEC \"LMINIT DATAID(DSN1) DDNAME(\"WRKDD\") ENQ(EXCLU)\"\nADDRESS ISPEXEC \"VIEW DATAID(&DSN1)\"\nADDRESS ISPEXEC \"LMFREE DATAID(&DSN1)\"\nENDD:\n\"FREE F(\"WRKDD\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETBACKU": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x00\\x00V\\x00\\x99'\\x1f\\x00\\x99'\\x1f\\x12S\\x00/\\x00/\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-09-28T00:00:00", "modifydate": "1999-09-28T12:53:56", "lines": 47, "newlines": 47, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/* COPY DS1 TO DS2 WITH A REXX EXEC */\nARG DSN1 DSN2 DISP\nIF SUBSTR(DSN1,1,1) \u00ac= \"'\" THEN\n  DSN1 = \"'\"DSN1\"'\"\nIF SUBSTR(DSN2,1,1) \u00ac= \"'\" THEN\n  DSN2 = \"'\"DSN2\"'\"\nDSN1_FIRST = SYSDSN(DSN1)\nDSN2_FIRST = SYSDSN(DSN2)\nIF DSN1_FIRST /= \"OK\" THEN  DSN1 = STRIP(TRANSLATE(DSN1,\"\",\"'\"))\nIF DSN2_FIRST /= \"OK\" THEN  DSN2 = STRIP(TRANSLATE(DSN2,\"\",\"'\"))\nDSN1_SECOND = SYSDSN(DSN1)\nDSN2_SECOND = SYSDSN(DSN2)\nIF (DSN1_FIRST /= \"OK\" ) & (DSN1_SECOND /= \"OK\") THEN DO\n  IF SYSVAR(SYSENV) = \"FORE\" THEN DO\n    secrc = \"TSA512E: provided dataset invalid:\" dsn1\n    ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n    EXIT 8\n  END\nEND\nIF (DSN2_FIRST /= \"OK\" ) & (DSN2_SECOND /= \"OK\") THEN DO\n  IF SYSVAR(SYSENV) = \"FORE\" THEN DO\n    secrc = \"TSA512E: provided dataset invalid:\" dsn2\n    ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n    EXIT 8\n  END\nEND\nIF (DSN2_FIRST /= \"OK\" ) & (DSN2_SECOND /= \"OK\") THEN DO\nEND\nTRACE OFF\nSAY \"TSA101D: Getbackup DSNs are:\" dsn1 dsn2\nIF DISP = \" \" THEN DISP = \"SHR\"\n/******************************************************************/\n/* IF DISP = MOD AND A PDS IS THE OUTPUT DSN USE RXAPPEND NOT THIS*/\n/******************************************************************/\nADDRESS TSO \"ALLOC DDN(INFILE) DSN(\"DSN1\") SHR REUS\"\nADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DSN2\") \"DISP\" REUS\"\nADDRESS MVS \"EXECIO * DISKR INFILE (FINIS STEM LINE.)\"\nOUTNUM = LINE.0\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW OUTFILE (FINIS STEM LINE.)\"\nADDRESS TSO \" FREE DDN(INFILE)  \"\nADDRESS TSO \" FREE DDN(OUTFILE) \"\nIF SYSVAR(SYSENV) = \"FORE\" THEN DO\n  secrc = \"TSA513I: Backup data restored, resides in \" dsn2\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 0\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETOPID": {"ttr": 11021, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00V\\x01\\x03\\x05\\x1f\\x01\\x06\"/\\x10#\\x00\\x98\\x00\\x85\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-02-20T00:00:00", "modifydate": "2006-08-10T10:23:56", "lines": 152, "newlines": 133, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\nARG FNAME LNAME RUNTYPE\n/* new code below to remove an entry from the file that is inuse */\nif lname /= \"REMOVE\" then do\n  FNAME = SUBSTR(FNAME\"   \",1,1)\n  LNAME = SUBSTR(LNAME\"   \",1,1)\nend\nmemname = substr(fname\"   \",1,1)\n/** end of new code section.................................  **/\n/***************************************************************/\n/** Added opid remove function syntax below:                  **/\n/** GETOPID DR0 REMOVE LIVE/SIMULATE                          **/\n/** Also.....                                                 **/\n/** fixed logic which prevented removal of an opid from the   **/\n/** last line of a member. aug 9 2006 dir                     **/\n/***************************************************************/\n/* if runtype is simulate then dont remove anything!! */\n/* if runtype is live then provide opid and remove from file ! */\n/***************************************************************/\n/** this exec retrieves an opid from a pds for a top secret   **/\n/** user id creation.. dir 20 jan 93                          **/\n/** note: presently the $0,$1,$2 ..etc  members arent checked **/\n/**       maybe a future enhancement!!!                       **/\n/** this version will check 2 members for an opid (the more   **/\n/** members checked the better)    dir 25 jan 93              **/\n/***************************************************************/\nSECRC = \"ERROR IN GETOPID\"\nADDRESS ISPEXEC \"VGET OPIDDSN PROFILE\"\nIF SYSDSN(OPIDDSN) /= OK THEN\n  OPIDDSN = \"SYS4.SPI.OPIDS\"\n/*OPIDDSN = \"CHTS.DAVEPDS\" */\nBEGIN = FNAME||LNAME||9\nHOLD = \"\"\nTHEOPID = \"#\"\nINITS = FNAME||LNAME\nKILLWORD = 0\nKILLLINE = 0\nSIGNAL ON ERROR NAME ERRALLOC\n\"ALLOC DDN(INOPID) DSN('\"OPIDDSN\"(\"memname\")') SHR REUS\"\n\"EXECIO * DISKR INOPID ( FINIS STEM IN.)\"\nLEN = LENGTH(NAME)\nDO Z = 1 TO IN.0\n  IF KILLWORD < > 0 THEN LEAVE\n  PREVLINE = INLINE\n  NNUM = Z + 1\n  NEXT = IN.NNUM\n  INLINE = IN.Z\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\n  W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\n  /* new code below to remove an entry from the file that is inuse */\n  if lname = \"REMOVE\" then  do zz = 1 to 9\n    if fname = w.zz then do\n      KILLWORD = zz\n      theopid = fname\n      KILLLINE = Z\n      ITERATE Z\n    end\n  end\n  /* end of new code for remove function.......................... */\n  IF W.1 = \" \" THEN ITERATE Z\n  Q1 = WORD(INLINE,1)        /* first opid on this line */\n  next1 = WORD(NEXT,1)       /* first opid on next line */\n  /*\n  SAY\n  SAY \"THIS1 IS \" Q1    \".............\"\n  SAY \"NEXT1 IS \" next1 \".............\"\n  SAY \"BEGIN IS \" BEGIN \".............\"\n  */\n  if substr(next1,1,3) =\"IN.\" then next1 = 'FFFF'x\n  IF ( W.1 <= BEGIN ) & ( NEXT1 >> BEGIN ) THEN\n    DO WNM1 = 1 TO 25 /* THIS IS THE CORRECT LINE */\n      POS3 = SUBSTR(W.WNM1\"   \",3,1)\n/*    SAY POS3 IS \"POS3\" */\n      IF ( POS(INITS,W.WNM1) = 1 ) & (DATATYPE(POS3) = \"NUM\") THEN DO\n        THEOPID = W.WNM1 /* THE FIRST 2 CHARACTERS MATCH !*/\n        KILLWORD = WNM1  /* CLOSE ENOUGH FOR GOVT WORK    */\n        KILLLINE = Z\n        ITERATE Z\n      END\n    END\n  /* if we get here there were no opids that had a 2 chr match */\n  IF ( W.1 <= BEGIN ) & ( NEXT1 >> BEGIN ) THEN\n    DO WNUM = 1 TO 25 /* NO HIT SO FAR            */\n      IF POS(INITS,W.WNUM) < > 0 THEN DO\n        IF KILLWORD < > 0 THEN LEAVE\n        THEOPID = W.WNUM /* THE FIRST 2 CHARACTERS MATCH !*/\n        KILLWORD = WNUM  /* CLOSE ENOUGH FOR GOVT WORK    */\n        KILLLINE = Z\n        ITERATE Z\n      END\n  END\nEND\n/* new code below for remove function.  */\nif (killword= 0 & lname = \"REMOVE\") then do\n  secrc = \"The opid does not exist, remove function completed.\"\n  signal gotmsg\nend\n/* end new code                         */\nIF KILLWORD = 0 THEN DO\n  SAY \"INITIAL MEMBER SCAN UNSUCCESSFUL. RETRIEVING A NUMERIC VALUE\"\n  /*************************************************************/\n  /* WE FOUND NO MATCH FOR THE OPID IN THE DESIGNATED MEMBER!! */\n  /* SO WE GO TO THE NUMERIC MEMBER AND TAKE THE FIRST NUMBER  */\n  /* DIR 20 JAN 93                                             */\n  /*************************************************************/\n  \" FREE DDN(INOPID)\" /* IT WASNT IN THERE!! */\n  \"ALLOC DDN(INOPID) DSN('\"OPIDDSN\"($NUM)') SHR REUS\"\n  \"EXECIO * DISKR INOPID ( FINIS STEM IN.)\" /* READIN FOR DELOPID */\n  PARSE VAR IN.1   W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\n  W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\n  THEOPID = W.1\n  KILLWORD = 1\n  KILLLINE = 1\nEND\nDELOPID: NOP\n/***************************************************************/\n/* NOTE : YOU MUST HAVE THE STEM VARIABLE IN. FILLED WHEN      */\n/* YOU ARRIVE HERE. YOU ALSO MUST HAVE THE DDN INOPID ALLOCATED*/\n/* WITH THE PDS MEMBER THAT WILL RECEIVE THE NEW LOOK OPID     */\n/* MEMBER.                         DIR 20 JAN 93               */\n/***************************************************************/\nLINE = IN.KILLLINE\nPARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\nW.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\nDO X = 1 TO 25\n  IF X = KILLWORD THEN ITERATE X\n  HOLD = HOLD W.X\nEND\nIN.KILLLINE = HOLD\n/*SAY \"THE OPID IS \" THEOPID  */\n/*SAY \"KILLLINE IS\" KILLLINE  */\n/*SAY \"KILLWORD IS\" KILLWORD  */\n/*SAY \"NEWLINE IS \"           */\n/*SAY HOLD                    */\nTHEOPID = WORD(THEOPID,1)\nDATAAREA = THEOPID\n\"ISPEXEC VPUT DATAAREA PROFILE\"\nsecrc = \"The opid would be \"theopid\". it still exists on the file\"\nIF RUNTYPE = \"LIVE\" THEN DO\n  \"EXECIO * DISKW INOPID ( FINIS STEM IN.)\"\n  secrc = \"The opid is \"theopid\". it has been removed from file\"\nEND\ngotmsg: nop\n\"FREE DDN(INOPID)\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nSAY SECRC\nEXIT 0\nERRALLOC: NOP\nsecrc = \"Unable to obtain an enqueue on the opid dsn\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nSAY SECRC\nEXIT 2\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETOPIDO": {"ttr": 11019, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x06\"/\\x01\\x06\"/\\x10 \\x00\\x88\\x00\\x88\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-08-10T00:00:00", "modifydate": "2006-08-10T10:20:19", "lines": 136, "newlines": 136, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\nARG FNAME LNAME RUNTYPE\nFNAME = SUBSTR(FNAME\"   \",1,1)\nLNAME = SUBSTR(LNAME\"   \",1,1)\n/* IF RUNTYPE IS SIMULATE THEN DONT REMOVE ANYTHING!! */\n/* IF RUNTYPE IS LIVE THEN PROVIDE OPID AND REMOVE FROM FILE ! */\n/***************************************************************/\n/** THIS EXEC RETRIEVES AN OPID FROM A PDS FOR A TOP SECRET   **/\n/** USER ID CREATION.. DIR 20 JAN 93                          **/\n/** NOTE: PRESENTLY THE $0,$1,$2 ..ETC  MEMBERS ARENT CHECKED **/\n/**       MAYBE A FUTURE ENHANCEMENT!!!                       **/\n/** THIS VERSION WILL CHECK 2 MEMBERS FOR AN OPID (THE MORE   **/\n/** MEMBERS CHECKED THE BETTER)    DIR 25 JAN 93              **/\n/***************************************************************/\nSECRC = \"ERROR IN GETOPID\"\nADDRESS ISPEXEC \"VGET OPIDDSN PROFILE\"\nIF SYSDSN(OPIDDSN) /= OK THEN\n  OPIDDSN = \"SYS4.SPI.OPIDS\"\n/*OPIDDSN = \"CHTS.DAVEPDS\" */\nBEGIN = FNAME||LNAME||9\nHOLD = \"\"\nTHEOPID = \"#\"\nINITS = FNAME||LNAME\nKILLWORD = 0\nKILLLINE = 0\nSIGNAL ON ERROR NAME ERRALLOC\n\"ALLOC DDN(INOPID) DSN('\"OPIDDSN\"(\"FNAME\")') SHR REUS\"\n\"EXECIO * DISKR INOPID ( FINIS STEM IN.)\"\nLEN = LENGTH(NAME)\nDO Z = 1 TO IN.0\n  IF KILLWORD < > 0 THEN LEAVE\n  PREVLINE = INLINE\n  NNUM = Z + 1\n  NEXT = IN.NNUM\n  INLINE = IN.Z\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\n  W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\n/*IF Z = IN.0 THEN DO     LAST LINE */\n    /*SAY \"LAST LINE\"*/\n    /************************************************************/\n    /** THIS SECTION OF CODE ELIMINATED NOW  I USE A ROUTINE   **/\n    /**                   TO PULL A NUMERIC                    **/\n    /** VALUE FROM THE OPID DSN.........DIR 22 JAN 93          **/\n    /************************************************************/\n/*                          */\n/*  THEOPID = W.1           */\n/*  KILLWORD = 1            */\n/*  KILLLINE = Z            */\n/*  ITERATE Z               */\n/*END                       */\n  IF W.1 = \" \" THEN ITERATE Z\n  Q1 = WORD(INLINE,1)\n  next1 = WORD(NEXT,1)\n  /*\n  SAY\n  SAY \"THIS1 IS \" Q1    \".............\"\n  SAY \"NEXT1 IS \" next1 \".............\"\n  SAY \"BEGIN IS \" BEGIN \".............\"\n  */\n  if substr(next1,1,3) =\"IN.\" then next1 = 'FFFF'x\n  IF ( W.1 <= BEGIN ) & ( NEXT1 >> BEGIN ) THEN\n    DO WNM1 = 1 TO 25 /* THIS IS THE CORRECT LINE */\n      POS3 = SUBSTR(W.WNM1\"   \",3,1)\n/*    SAY POS3 IS \"POS3\" */\n      IF ( POS(INITS,W.WNM1) = 1 ) & (DATATYPE(POS3) = \"NUM\") THEN DO\n        THEOPID = W.WNM1 /* THE FIRST 2 CHARACTERS MATCH !*/\n        KILLWORD = WNM1  /* CLOSE ENOUGH FOR GOVT WORK    */\n        KILLLINE = Z\n        ITERATE Z\n      END\n    END\n  /* if we get here there were no opids that had a 2 chr match */\n  IF ( W.1 <= BEGIN ) & ( NEXT1 >> BEGIN ) THEN\n    DO WNUM = 1 TO 25 /* NO HIT SO FAR            */\n      IF POS(INITS,W.WNUM) < > 0 THEN DO\n        IF KILLWORD < > 0 THEN LEAVE\n        THEOPID = W.WNUM /* THE FIRST 2 CHARACTERS MATCH !*/\n        KILLWORD = WNUM  /* CLOSE ENOUGH FOR GOVT WORK    */\n        KILLLINE = Z\n        ITERATE Z\n      END\n  END\nEND\nIF KILLWORD = 0 THEN DO\n  SAY \"INITIAL MEMBER SCAN UNSUCCESSFUL. RETRIEVING A NUMERIC VALUE\"\n  /*************************************************************/\n  /* WE FOUND NO MATCH FOR THE OPID IN THE DESIGNATED MEMBER!! */\n  /* SO WE GO TO THE NUMERIC MEMBER AND TAKE THE FIRST NUMBER  */\n  /* DIR 20 JAN 93                                             */\n  /*************************************************************/\n  \" FREE DDN(INOPID)\" /* IT WASNT IN THERE!! */\n  \"ALLOC DDN(INOPID) DSN('\"OPIDDSN\"($NUM)') SHR REUS\"\n  \"EXECIO * DISKR INOPID ( FINIS STEM IN.)\" /* READIN FOR DELOPID */\n  PARSE VAR IN.1   W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\n  W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\n  THEOPID = W.1\n  KILLWORD = 1\n  KILLLINE = 1\nEND\nDELOPID: NOP\n/***************************************************************/\n/* NOTE : YOU MUST HAVE THE STEM VARIABLE IN. FILLED WHEN      */\n/* YOU ARRIVE HERE. YOU ALSO MUST HAVE THE DDN INOPID ALLOCATED*/\n/* WITH THE PDS MEMBER THAT WILL RECEIVE THE NEW LOOK OPID     */\n/* MEMBER.                         DIR 20 JAN 93               */\n/***************************************************************/\nLINE = IN.KILLLINE\nPARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\nW.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\nDO X = 1 TO 25\n  IF X = KILLWORD THEN ITERATE X\n  HOLD = HOLD W.X\nEND\nIN.KILLLINE = HOLD\n/*SAY \"THE OPID IS \" THEOPID  */\n/*SAY \"KILLLINE IS\" KILLLINE  */\n/*SAY \"KILLWORD IS\" KILLWORD  */\n/*SAY \"NEWLINE IS \"           */\n/*SAY HOLD                    */\nTHEOPID = WORD(THEOPID,1)\nDATAAREA = THEOPID\n\"ISPEXEC VPUT DATAAREA PROFILE\"\nsecrc = \"The opid would be \"theopid\". it still exists on the file\"\nIF RUNTYPE = \"LIVE\" THEN DO\n  \"EXECIO * DISKW INOPID ( FINIS STEM IN.)\"\n  secrc = \"The opid is \"theopid\". it has been removed from file\"\nEND\n\"FREE DDN(INOPID)\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nSAY SECRC\nEXIT 0\nERRALLOC: NOP\nsecrc = \"Unable to obtain an enqueue on the opid dsn\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nSAY SECRC\nEXIT 2\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GETSAVE": {"ttr": 11017, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x06\"\\x0f\\x01\\x06\"\\x0f\\x14X\\x00\\x85\\x00\\x85\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-08-08T00:00:00", "modifydate": "2006-08-08T14:58:37", "lines": 133, "newlines": 133, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\nARG FNAME LNAME RUNTYPE\nFNAME = SUBSTR(FNAME\"   \",1,1)\nLNAME = SUBSTR(LNAME\"   \",1,1)\n/* IF RUNTYPE IS SIMULATE THEN DONT REMOVE ANYTHING!! */\n/* IF RUNTYPE IS LIVE THEN PROVIDE OPID AND REMOVE FROM FILE ! */\n/***************************************************************/\n/** THIS EXEC RETRIEVES AN OPID FROM A PDS FOR A TOP SECRET   **/\n/** USER ID CREATION.. DIR 20 JAN 93                          **/\n/** NOTE: PRESENTLY THE $0,$1,$2 ..ETC  MEMBERS ARENT CHECKED **/\n/**       MAYBE A FUTURE ENHANCEMENT!!!                       **/\n/** THIS VERSION WILL CHECK 2 MEMBERS FOR AN OPID (THE MORE   **/\n/** MEMBERS CHECKED THE BETTER)    DIR 25 JAN 93              **/\n/***************************************************************/\nSECRC = \"ERROR IN GETOPID\"\nADDRESS ISPEXEC \"VGET OPIDDSN PROFILE\"\nIF SYSDSN(OPIDDSN) /= OK THEN\n  OPIDDSN = \"SYS4.SPI.OPIDS\"\n/*OPIDDSN = \"CHTS.DAVEPDS\" */\nBEGIN = FNAME||LNAME||9\nHOLD = \"\"\nTHEOPID = \"#\"\nINITS = FNAME||LNAME\nKILLWORD = 0\nKILLLINE = 0\nSIGNAL ON ERROR NAME ERRALLOC\n\"ALLOC DDN(INOPID) DSN('\"OPIDDSN\"(\"FNAME\")') SHR REUS\"\n\"EXECIO * DISKR INOPID ( FINIS STEM IN.)\"\nLEN = LENGTH(NAME)\nDO Z = 1 TO IN.0\n  IF KILLWORD < > 0 THEN LEAVE\n  PREVLINE = INLINE\n  NNUM = Z + 1\n  NEXT = IN.NNUM\n  INLINE = IN.Z\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\n  W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\n/*IF Z = IN.0 THEN DO     LAST LINE */\n    /*SAY \"LAST LINE\"*/\n    /************************************************************/\n    /** THIS SECTION OF CODE ELIMINATED NOW  I USE A ROUTINE   **/\n    /**                   TO PULL A NUMERIC                    **/\n    /** VALUE FROM THE OPID DSN.........DIR 22 JAN 93          **/\n    /************************************************************/\n/*                          */\n/*  THEOPID = W.1           */\n/*  KILLWORD = 1            */\n/*  KILLLINE = Z            */\n/*  ITERATE Z               */\n/*END                       */\n  IF W.1 = \" \" THEN ITERATE Z\n  Q1 = WORD(INLINE,1)\n  Q2 = WORD(NEXT,1)\n  SAY\n  SAY \"THIS1 IS \" Q1 \".............\"\n  SAY \"NEXT1 IS \" Q2 \".............\"\n  SAY \"BEGIN IS \" BEGIN \".............\"\n  IF ( W.1 <= BEGIN ) & ( WORD(NEXT,1) >> BEGIN ) THEN\n    DO WNM1 = 1 TO 25 /* THIS IS THE CORRECT LINE */\n      POS3 = SUBSTR(W.WNM1\"   \",3,1)\n/*    SAY POS3 IS \"POS3\" */\n      IF ( POS(INITS,W.WNM1) = 1 ) & (DATATYPE(POS3) = \"NUM\") THEN DO\n        THEOPID = W.WNM1 /* THE FIRST 2 CHARACTERS MATCH !*/\n        KILLWORD = WNM1  /* CLOSE ENOUGH FOR GOVT WORK    */\n        KILLLINE = Z\n        ITERATE Z\n      END\n    END\n  /* if we get here there were no opids that had a 2 chr match */\n  IF ( W.1 <= BEGIN ) & ( WORD(NEXT,1) >> BEGIN ) THEN\n    DO WNUM = 1 TO 25 /* NO HIT SO FAR            */\n      IF POS(INITS,W.WNUM) < > 0 THEN DO\n        IF KILLWORD < > 0 THEN LEAVE\n        THEOPID = W.WNUM /* THE FIRST 2 CHARACTERS MATCH !*/\n        KILLWORD = WNUM  /* CLOSE ENOUGH FOR GOVT WORK    */\n        KILLLINE = Z\n        ITERATE Z\n      END\n  END\nEND\nIF KILLWORD = 0 THEN DO\n  SAY \"INITIAL MEMBER SCAN UNSUCCESSFUL. RETRIEVING A NUMERIC VALUE\"\n  /*************************************************************/\n  /* WE FOUND NO MATCH FOR THE OPID IN THE DESIGNATED MEMBER!! */\n  /* SO WE GO TO THE NUMERIC MEMBER AND TAKE THE FIRST NUMBER  */\n  /* DIR 20 JAN 93                                             */\n  /*************************************************************/\n  \" FREE DDN(INOPID)\" /* IT WASNT IN THERE!! */\n  \"ALLOC DDN(INOPID) DSN('\"OPIDDSN\"($NUM)') SHR REUS\"\n  \"EXECIO * DISKR INOPID ( FINIS STEM IN.)\" /* READIN FOR DELOPID */\n  PARSE VAR IN.1   W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\n  W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\n  THEOPID = W.1\n  KILLWORD = 1\n  KILLLINE = 1\nEND\nDELOPID: NOP\n/***************************************************************/\n/* NOTE : YOU MUST HAVE THE STEM VARIABLE IN. FILLED WHEN      */\n/* YOU ARRIVE HERE. YOU ALSO MUST HAVE THE DDN INOPID ALLOCATED*/\n/* WITH THE PDS MEMBER THAT WILL RECEIVE THE NEW LOOK OPID     */\n/* MEMBER.                         DIR 20 JAN 93               */\n/***************************************************************/\nLINE = IN.KILLLINE\nPARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\nW.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\nDO X = 1 TO 25\n  IF X = KILLWORD THEN ITERATE X\n  HOLD = HOLD W.X\nEND\nIN.KILLLINE = HOLD\n/*SAY \"THE OPID IS \" THEOPID  */\n/*SAY \"KILLLINE IS\" KILLLINE  */\n/*SAY \"KILLWORD IS\" KILLWORD  */\n/*SAY \"NEWLINE IS \"           */\n/*SAY HOLD                    */\nTHEOPID = WORD(THEOPID,1)\nDATAAREA = THEOPID\n\"ISPEXEC VPUT DATAAREA PROFILE\"\nsecrc = \"The opid would be \"theopid\". it still exists on the file\"\nIF RUNTYPE = \"LIVE\" THEN DO\n  \"EXECIO * DISKW INOPID ( FINIS STEM IN.)\"\n  secrc = \"The opid is \"theopid\". it has been removed from file\"\nEND\n\"FREE DDN(INOPID)\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nSAY SECRC\nEXIT 0\nERRALLOC: NOP\nsecrc = \"Unable to obtain an enqueue on the opid dsn\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nSAY SECRC\nEXIT 2\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GIVEUID": {"ttr": 13575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\n\\x00Q\\x00\\x99\\t\\x1f\\x01\\t\\x04O\\x14\\x17\\x00>\\x00:\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.10", "flags": 0, "createdate": "1999-04-01T00:00:00", "modifydate": "2009-02-13T14:17:51", "lines": 62, "newlines": 58, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : GIVEUID                           **/\n/** LAST MODIFIED    : 18 MAR 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID                                   **/\n/** GROUP   : THE GROUP TO BE GIVEN                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - DEFGROUP                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : HIGHUID              **/\n/**                                 BPXWIRAC             **/\n/**     THE BPXWIRAC EXEC IS INCLUDED IN THE TOP SECRET  **/\n/**     TSSOPMAT DATASET ON YOUR TSS INSTALLATION TAPE,  **/\n/**     IT MUST BE INCLUDED IN YOUR OS/390 TSS           **/\n/**     ENVIRONMENT.                                     **/\n/**********************************************************/\nARG ACID GROUP\nSIGNAL OFF ERROR\nIF GROUP = \"\" THEN DO\n  ADDRESS ISPEXEC \"VGET DEFGROUP profile\"\n  GETCODE = RC\n  IF GETCODE /= 0 THEN DO\n    secrc =  \"TSA508E: fatal error\",\n    \"no group specified and vget for defgroup failed.\"\n    say secrc\n    if getcode = 8 then ADDRESS ISPEXEC \"Vput secrc profile\"\n    EXIT 08\n  END\n  GROUP = DEFGROUP\nEND\nUID =\nSIGNAL OFF ERROR\n/*\nADDRESS TSO \"%HIGHUID\"\nIF RC < 0 THEN DO\n  SAY \"GIVEUID: TERMINAL ERROR.\"\n  SAY \"GIVEUID: HIGHUID ROUTINE FAILED. \"\n  EXIT 8\nEND\nUID = UID + RC\nSAY \"GIVEUID: NEXT UID IS \" UID\n*/\n/* ADDRESS TSO \"%CBHALIAS \"ACID */\nADDRESS TSO \"TSS ADD(\"ACID\") UID(?) RANGE(1000,3000)\"\nADDRESS TSO \"TSS ADD(\"ACID\") GROUP(\"GROUP\")\"\nADDRESS TSO \"TSS ADD(\"ACID\") DFLTGRP(\"GROUP\")\"\nADDRESS TSO \"TSS ADD(\"ACID\") HOME(/)\"\nADDRESS TSO \"TSS MODIFY OMVSTABS\"\nMODCODE = RC\nIF MODCODE /= 0 THEN DO\n  SAY \"GIVEUID: TSS MODIFY OMVSTABS COMMANDS FAILED.\"\n  SAY \"GIVEUID: CONFIRM THAT YOU HAVE APPROPRIATE TSS AUTHORITY.\"\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HIGHUID": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x00\\x002\\x00\\x99\\t\\x1f\\x00\\x99&o\\x11'\\x00\\x16\\x00\\x16\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-04-01T00:00:00", "modifydate": "1999-09-23T11:27:32", "lines": 22, "newlines": 22, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\nSIGNAL OFF ERROR\n/**********************************************************/\n/**     THE BPXWIRAC EXEC IS INCLUDED IN THE TOP SECRET  **/\n/**     TSSOPMAT DATASET ON YOUR TSS INSTALLATION TAPE,  **/\n/**     IT MUST BE INCLUDED IN YOUR OS/390 TSS           **/\n/**     ENVIRONMENT IN THE SYSEXEC OR SYSPROC DDNAME     **/\n/**********************************************************/\nADDRESS TSO \"TSS MODIFY OMVSTABS\"\nIF RC /= 0 THEN DO\n  say \"TSA507E: highuid omvstabs modify failed.. unable to determine \"\n  say \"         next uid. highuid terminating                \"\n  EXITCODE = -4\n  EXIT EXITCODE\nEND\nADDRESS TSO \"%BPXWIRAC HIGHUID\"\nRCODE = RC\nIF RCODE >= 0 THEN\n  SAY \"HIGHUID:CURRENT HIGH UID IS \" RCODE\nIF RCODE < 0 THEN\n  say \"TSA506W: BPXWIRAC returned negative return code of \" rcode\nEXIT RCODE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IDCHECK": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x1d\\x005\\x00\\x99\\x14o\\x01\\x01!?\\x132\\x01\\xbb\\x01\\xbb\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.29", "flags": 0, "createdate": "1999-05-26T00:00:00", "modifydate": "2001-08-01T13:32:35", "lines": 443, "newlines": 443, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** NOW CHECKS TSS TSO AREA FOR COMPLETENESS.            **/\n/**********************************************************/\n/** RUNS A VARIETY OF CHECKS ON A standard acid          **/\n/**********************************************************/\n/** EXEC NAME        : IDCHECK                           **/\n/** LAST MODIFIED    : 26 may 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      :  THE USERID TO CHECK                       **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** A PLAIN TEXT RESULTS STREAM.                         **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : getdata DSGLIST      **/\n/**                                 ACCTCHK              **/\n/**********************************************************/\nARG ID\nSIGNAL OFF ERROR\nLASTON = 0\nTODAY = DATE(J)\nQWA   = MSG(\"OFF\")\nprofile=sysdsn(\"'\"id\".ispf.ispprof'\")\nDEFAULT_ACCT = \"NONTSS\"\nLAST_USED = \"$NOTFOUND\"\nACCT_VALID = \"UNKNOWN\"\nT2 = SUBSTR(TODAY,1,2)\nDTYPE = DATATYPE(T2)\naddress ispexec \"vget dsback profile\"\n/* SAY \"IDCHECK: T2 DATATYPE IS \" DTYPE T2*/\nT2 = T2 * 365\nT4 = SUBSTR(TODAY,3)\nTODAY = T2 + T4\nMMDDYY= DATE(U)\nMONTH = SUBSTR(MMDDYY,1,2)\nDAY = SUBSTR(MMDDYY,4,2)\nYEAR = SUBSTR(MMDDYY,7,2)\nID2 = SUBSTR(ID,1,2)\nEXPIRES = \"INDEFINITE\"\nSS = OUTTRAP(idlist.)\naddress tso \"tss list(\"id\") data(all)\"\nlist_rc = rc\nSS = OUTTRAP(LINE.)\n/**********************************************************/\n/** CHECK UADS                                           **/\n/**********************************************************/\nIF LENGTH(ID) > 7 THEN\n  UADS     = \"ID TOO LONG FOR TSO\"\nELSE\n  UADS = SYSDSN(\"'SYS1.UADS(\"ID\"0)'\")\n/* X = OUTTRAP(\"OFF\") */\ncall  getdata NAME\nTSSNAME = SECRC\ncall  getdata TSO\nTSSTSO = SECRC\nIF TSSTSO = \" \" THEN TSSTSO = \"YES\"\n  /**********************************************************/\n  /** IF THE ID IS TOP SECRET DEFINED THEN WE GET SOME DATA**/\n  /**********************************************************/\nIF (TSSNAME \u00ac= \"$BADTSS\") & (TSSNAME \u00ac= \"$BADAUTH\")  THEN DO\n  call getdata \"ATTRIBUTES\"\n  ATTR = SECRC\n  call getdata \" USED\"\n  LAST_USED = SECRC\n  IF TSSTSO = \"YES\" THEN DO /* TSO AREA EXISTS LETS CHECK IT */\n    call getdata TSOLACCT\n    DEFAULT_ACCT = SECRC\n    ACCTNUM = SECRC\n    call getdata TSOLPROC\n    DEFAULT_PROC = SECRC\n    /*****************************************************/\n    /** NOTE: I CHECK FOR THE MOST SERIOUS STUFF LAST   **/\n    /**       1ST  NO PROCEDURE SPECIFIED               **/\n    /**       2ND  NO ACCOUNT NUMBER                    **/\n    /*****************************************************/\n    IF (DEFAULT_PROC = \"$NOTFOUND\") THEN DO\n      TSO_INCOMP = \"YES\"\n      TSO_REASON = \"       ID HAS NO DEFAULT LOGON PROCEDURE    \"\n      TSO_FIX =    \"       ISSUE THE DEFPROC COMMAND WITH VALID PARMS.\"\n    END\n    IF (DEFAULT_ACCT = \"$NOTFOUND\") THEN DO\n      TSO_INCOMP = \"YES\"\n      TSO_REASON = \"       ID HAS NO DEFAULT TSO ACCOUNT NUMBER \"\n      TSO_FIX =    \"       ISSUE THE DEFTSO COMMAND WITH VALID PARMS.\"\n    END\n    ACCT_VALID = \"YES\"\n  END\n  call  getdata  EXPIRES\n  EXPIRES = SECRC\n  IF EXPIRES \u00ac= \"$NOTFOUND\" THEN DO\n   EMONTH = SUBSTR(EXPIRES        ,1,2)\n   EDAY = SUBSTR(EXPIRES          ,4,2)\n   EYEAR = SUBSTR(EXPIRES         ,7,2)\n   IF EYEAR < YEAR THEN EXPIRED = \"YES\"\n   IF (EYEAR = YEAR) & (EMONTH < MONTH) THEN EXPIRED = \"YES\"\n   IF (EYEAR = YEAR) & (EMONTH = MONTH) & (EDAY <= DAY)   THEN\n     EXPIRED = \"YES\"\n  END\n  IF EXPIRES =  \"$NOTFOUND\" THEN EXPIRES = \"INDEFINITE\"\nEND\nADDRESS TSO \"LISTC ENT('\"ID\"')\"\nALIAS_CHECK = RC\n  /**********************************************************/\n  /** INTERPRET ALL THESE RETURN CODES                     **/\n  /**********************************************************/\nsay \"Idcheck: running diagnostics on ID \" ID\nSAY \"***************************************\"\nSAY \"  \"\nIF (list_rc = 8) THEN DO\n  SAY \"************************************************************\"\n  say \"**This ID is not defined to TOP SECRET. TRY AGAIN\"\n  SAY \"************************************************************\"\nEND\nIF (TSSNAME = \"$BADAUTH\") THEN DO\n  SAY \"************************************************************\"\n  say \"**This ID is not subject to your control under top secret\"\n  say \"**this will prevent all your top secret commands from\"\n  say \"**functioning with regard to this ID. Any changes that this\"\n  say \"**ID requires must be done by a higher level of top secret\"\n  say \"**administrator. Diagnostics will continue however TSS \"\n  say \"**data retrieval from this ID will fail.\"\n  SAY \"************************************************************\"\nEND\nIF LENGTH(ID) \u00ac= 7 THEN DO\n  SAY \"************************************************************ \"\n  say \"*This ID is not the standard length of 7. this may not be an \"\n  say \"*  error, but it is not within standards.                    \"\n  SAY \"************************************************************ \"\n  SAY \"   \"\nEND\nIF BACKUP = \"OK\" THEN DO\n  SAY \"**************************************************************\"\n  say \"* This ID has a restore member under the in house panel system\"\n  say \"* this means that the ID was deleted or backed up using the  \"\n  say \"* in house panel system and could be recreated to some degree.\"\n  say \"* this is not an error condition, but is quite unusual.       \"\n  say \"*                                                             \"\n  say \"* note: This may be the only deletion indicator, other checks  \"\n  say \"*       may return results which indicate that this ID has    \"\n  say \"*       never logged on or been used . this is normal.        \"\n  SAY \"**************************************************************\"\n  SAY \"  \"\nEND\nIF TSSTSO = \"YES\" THEN DO\n  say \" This IDs tss definition is front ending UADS.\"\n  SAY \"  \"\nEND\nIF TSO_INCOMP = \"YES\" THEN DO\n  SAY \"**************************************************************\"\n  say \"* The ID has a partially defined top secret tso area, which   \"\n  say \"* means UADS is not checked for logon data, yet the top secret\"\n  say \"* area is inadequate for the following reasons:\"\n  say \"* \"tso_reason\n  say \"* suggested course of action:\"\n  say \"* \"tso_fix\n  SAY \"**************************************************************\"\n  SAY \"  \"\nEND\n  /**********************************************************/\n  /** NEXT WE LOOK AT THE ALIAS                            **/\n  /**********************************************************/\nIF ALIAS_CHECK \u00ac= 0 THEN DO\n  SAY \"************************************************************ \"\n  say \"*This ID has no master catalog alias! this is a severe \"\n  say \"*  condition which will result in allocation errors,   \"\n  say \"*  and an inability to logon to use ISPF. No normal user \"\n  say \"*  should be setup in this manner.\"\n  ADDRESS TSO \"%DSGLIST \"ID\n  IF RC = 0 THEN DO\n    say \"*  even worse the ID has pre-existing datasets which means \"\n    say \"*  someone created them without an alias being present.\"\n    say \"*  to fix this error:\"\n    say \"* 1. Uncatalog all \"ID\". datasets on the system.\"\n    say \"* 2 Define the alias with the imsalias command   \"\n    say \"*    syntax is 'tso %imsalias  \"ID\"'\"\n    say \"* 3. Recatalog dsns you uncataloged.\"\n  END\nSAY \"********************************************************** \"\nEND\nSAY \"   \"\n  /**********************************************************/\n  /** NEXT WE LOOK AT THE ATTRIBUTES OF THE ID             **/\n  /**********************************************************/\nIF INDEX(ATTR,\"SUSPEND\") \u00ac= 0 THEN DO\n  SAY \"************************************************************ \"\n  say \"* This ID is currently suspended and not available for use \"\n  say \"* the 'unsus' command should fix this problem.\"\n  SAY \"************************************************************ \"\n  SAY \" \"\nEND\nelse say \" No suspend attribute was detected.\"\nSAY \"   \"\n/**********************************************************/\n/** LETS EVALUATE THE UADS DATASET RESULTS               **/\n/**********************************************************/\nSELECT\n  WHEN UADS = \"OK\" THEN DO\n    say \" ISPF UADS results are normal \"\n    SAY \" \"\n  END\n  WHEN UADS = \"UNAVAILABLE DATASET\" THEN DO\n    SAY \"************************************************************\"\n    say \"*       UADS check = \" UADS\n    say \"* The ISPF UADS dataset is either allocated or \"\n    say \"* otherwise unavailable. this is a very strange condition.  \"\n    say \"* contact tech development. \"\n    say \"************************************************************\"\n  END\n  WHEN UADS = \"ID TOO LONG FOR TSO\" THEN DO\n    say \"  UADS dataset check was bypassed due to ID length \"\n    SAY \" \"\n  END\n  WHEN UADS = \"DATASET NOT FOUND\" THEN DO\n    SAY \"************************************************************\"\n    say \"* The UADS dataset is not found this is probably an \"\n    say \"* error with the diagnose software. contact \"\n    say \"* tech development.\"\n    say \"************************************************************ \"\n    SAY \" \"\n  END\n  WHEN (UADS = \"MEMBER NOT FOUND\") & (TSSNAME = \"$BADTSS\") THEN DO\n    SAY \"************************************************************\"\n    say \"* The ID has no UADS entry in sys1.UADS and is not defined  \"\n    say \"* to top secret. This ID cannot possibly use tso.         \"\n    SAY \"************************************************************ \"\n    SAY \" \"\n  END\n  WHEN UADS = \"MEMBER NOT FOUND\" THEN DO\n    SAY \"************************************************************\"\n    say \"* The ID has no UADS entry in sys1.uads. This is OK as long \"\n    say \"* as the TSO SEGMENT is present in the TSS ACID             \"\n    say \"************************************************************\"\n    SAY \" \"\n  END\n  OTHERWISE\n    SAY \"************************************************************\"\n    say \"*      UADS check results were \" UADS\n    say \"* This is an unusual condition, i have no specific fix \"\n    say \"* recommendation. contact tech development.\"\n    say \"************************************************************\"\nEND /* UADS SELECT  */\n/**********************************************************/\n/** LETS EVALUATE THE TSOUSERS DATASET RESULTS           **/\n/**********************************************************/\nIF EXPIRED  = \"YES\" THEN DO\n  say \"* This ID appears to have expired on \" expires\n  say \"* the ID can be fixed using the 'expire' command and \"\n  say \"* providing a new expiration date. then issuing an   \"\n  say \"* 'unsus' command.                                   \"\n  SAY \" \"\nEND\nelse say \" The ID has an expiration time of\" expires\nSAY \" \"\n/****************************************************/\n/** START PROFILE CHECK                            **/\n/****************************************************/\nSELECT\n  WHEN PROFILE = \"OK\" THEN\n    say \" ISPF profile results are normal \"\n  WHEN PROFILE = \"UNAVAILABLE DATASET\" THEN DO\n    SAY \"************************************************************\"\n    say \"* The ISPF profile dataset is either allocated or \"\n    say \"* otherwise unavailable. this could be a result of it being \"\n    say \"* allocated by the ID if it is logged on, or another ID \"\n    say \"* updateing the dataset.\"\n    say \"************************************************************\"\n  END\n  WHEN (PROFILE = \"DATASET NOT FOUND\") & (NEVER_TSO \u00ac= \"YES\") THEN DO\n    SAY \"************************************************************\"\n    say \"* The ISPF profile dataset is not found. \"\n    SAY \"************************************************************\"\n  END\n  WHEN (PROFILE = \"DATASET NOT FOUND\") & (NEVER_TSO = \"YES\") THEN DO\n    say \" The ISPF profile dataset is not found. this is normal    \"\n    say \" since the ID has yet to be used in ISPF. \"\n    IF NONTSS = \"YES\" THEN\n     say \" If this is a dataview ID the 'dvnprof' command should be \"\n    IF NONTSS = \"YES\" THEN\n     say \" issued to create this dsn for the customer.\"\n    SAY \" \"\n  END\n  OTHERWISE\n    SAY \"************************************************************\"\n    say \"*      Profile check results were \" profile\n    say \"* This is an unusual condition, I have no specific fix \"\n    say \"* recommendation. Perhaps a delete and reallocate could work\"\n    SAY \"************************************************************\"\nEND /* PROFILE SELECT  */\nSAY \" \"\nIF LAST_USED \u00ac= \"$NOTFOUND\" THEN DO\n  say \" The last recorded system use of the ID was \" last_used\n  IF NEVER_TSO = \"YES\" THEN DO\n    say \" This ID is probably used for batch work or is remotely  \"\n    say \" submitted into the system since it has never used tso.\"\n    say \" This is probably not an error condition.                   \"\n    say \" This ID may actually function without an alias, though it  \"\n    say \" is hard to tell. Problems with this ID should be reported  \"\n    say \" to technical support.                                      \"\n    say \" \"\n  END\nEND\nSAY \"              \"\nBIGGUY = SYSVAR(SYSUID)\nIF BIGGUY \u00ac= \"COA1DIR\" THEN\nexit 0\nSAY \"INDIVIDUAL RETURN CODES ARE BELOW\"\nSAY \"ACCT_VALID  IS\" ACCT_VALID\nSAY \"ALIAS CHECK IS\" ALIAS_CHECK\nSAY \"ATTRIBUTES  IS\" ATTR\nSAY \"BACKUP      IS\" BACKUP\nSAY \"DEF ACCOUNT IS\" DEFAULT_ACCT\nSAY \"DEPT VALID  IS\" DEPT_VALID\nSAY \"EXPIRES     IS\" EXPIRES\nSAY \"GHOSTADD    IS\" GHOSTADD\nSAY \"LAST USED   IS\" LAST_USED\nSAY \"LASTON      IS\" LASTON\nSAY \"LIST_RC     IS\" List_rc\nSAY \"NEVER_TSO   IS\" NEVER_TSO\nSAY \"NONTSS      IS\" NONTSS\nSAY \"PROFILE     IS\" PROFILE\nSAY \"TSOUSERS    IS\" TSOUSERS\nSAY \"TSSNAME     IS\" TSSNAME\nSAY \"TSSTSO      IS\" TSSTSO\nSAY \"UADS        IS\" UADS\nexit 0\ngetdata: procedure expose secrc idlist.\n/** copied from getdata due to lazyness                  **/\nARG FIELD\n/* SAY \"        \"\nSAY \"getdata:\" ACID FIELD */\nHEX00 = '00'X\n/** IF THE FIELD REQUESTED IS ONE THAT NEEDS MULTIPLE    **/\n/** WORDS PASSED BACK TO THE CALLER THEN SET THE MULT.  **/\n/** VARIABLE TO YES BELOW... DIR JAN 97                 **/\nMULT.USED = \"YES\"\nMULT.NAME = \"YES\"\nMULT.PROFILES = \"YES\"\nMULT.BYPASSING = \"YES\"\nMULT.ATTRIBUTES = \"YES\"\nGOTIT = \"NO\"\nIF DATA = \" \" THEN DATA = \"BASIC\"\nSIGNAL ON ERROR NAME SEEYA\nDO X = 1 TO IDLIST.0\n  X1 = X+1 ; X2 = X+2 ; X3 = X+3 ; X4 = X+4\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  idlist.X=TRANSLATE(idlist.X,\" \",HEX00)\n  PARSE VAR idlist.X W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12\n  WNUM = WORDS(idlist.X)\n  DO T = 1 TO WNUM\n    IF WORD(idlist.X,T) = FIELD THEN DO\n      /*    SAY \"getdata: LINE IS \" idlist.X\n      SAY \"getdata: FIELD IS\" FIELD\n      SAY \"getdata: GOT IT ON LINE \" X \" WORD \" T   */\n      T1 = T + 1\n      T2 = T + 2\n      T3 = T + 3\n      SECRC = W.T2\n      /* SAY \"getdata: SETTING INITIAL SECRC TO \" SECRC */\n      IF FIELD = \"DEPT\" THEN SECRC = W.T3\n      IF (FIELD = \"TYPE\") & (W.T3 = \"C/A\") THEN\n        SECRC = SECRC||\"CA\"\n /*   IF FIELD = \"NAME\" THEN */\n /*     SECRC = SECRC  W.T3  */\n      /**************************************************/\n      /** BELOW IS SUPPORT FOR A FIELD THAT HAS MULTIPLE*/\n      /** PARMS, LIKE PROFILES ...DIR 2 MAY 96          */\n      /**************************************************/\n      IF MULT.FIELD = \"YES\" THEN DO\n        IF FIELD = \"PROFILES\" THEN DO\n          /**************************************/\n          /** IF IT IS A PROFILES REQUEST WE   **/\n          /** SCAN AHEAD AND LOAD THE CURRENT  **/\n          /** LINE WITH ALL THE PROFILES IN THE**/\n          /** NEXT 4 LINES, THUS SUPPORTING 5  **/\n          /** FULL LINES OF PROFILES OR 20 OF  **/\n          /** THOSE BUGGARS.   DIR 2 MAY 96    **/\n          /**************************************/\n          /* SAY \"getdata: PROFILE ROUTINE IN CONTROL\"        */\n          NW1 = WORD(idlist.X1,1)\n          NW2 = WORD(idlist.X2,1)\n          NW3 = WORD(idlist.X3,1)\n          NW4 = WORD(idlist.X4,1)\n          IF NW1 = \"PROFILES\" THEN W.8 = SUBSTR(idlist.X1,14)\n          IF NW2 = \"PROFILES\" THEN W.9 = SUBSTR(idlist.X2,14)\n          IF NW3 = \"PROFILES\" THEN W.10 = SUBSTR(idlist.X3,14)\n          IF NW4 = \"PROFILES\" THEN W.11 = SUBSTR(idlist.X4,14)\n          /**************************************/\n          /** LETS TELL THE NEXT ROUTINE THERE **/\n          /** ARE MORE WORDS THAN THERE USED TO**/\n          /** BE IN THE CURRENT LINE.DR 2 MAY96*/\n          /**************************************/\n          WNUM = 11\n        END\n        /*SAY \"getdata: MULTIPLE WORD FIELD DETECTED.\"    */\n        /*SAY \"getdata: COUNTING FROM \"T2 \" TO \" WNUM     */\n        ALLDATA = \"\"\n        DO W1 = T2 TO WNUM\n          IF W.W1 = \"=\" THEN LEAVE /* WE HAVE HIT THE NEXT VALUE */\n          ALLDATA = ALLDATA  W.W1\n        END\n        SECRC = ALLDATA\n      END\n      GOTIT = \"YES\"\n    END\n    IF GOTIT = \"YES\" THEN LEAVE\n  END\n  IF GOTIT = \"YES\" THEN LEAVE\nEND\nSIGNAL OFF ERROR\n/*****************************************************************/\n/** NOT FINDING AN INTERVAL MAY BE OK PASS BACK A ZERO.         **/\n/*****************************************************************/\nIF (GOTIT = \"NO\") & (FIELD = \"INTERVAL\") & (DATA \u00ac= \"BASIC\") THEN DO\n  GOTIT = \"YES\"\n  SECRC = 0\nEND\nIF GOTIT = \"YES\" THEN DO\n  /* SAY \"getdata: FIELD \"FIELD\" WAS FOUND. VALUE IS \" SECRC   */\n  return\nEND\nSECRC = \"$NOTFOUND\"\n/* SAY \"getdata: FIELD \"FIELD\" WAS NOT FOUND. SECRC IS \" SECRC  */\nreturn\nBADDATA: NOP\nSECRC  = \"$BADTSS\"\nSAY \"getdata: ERROR ROUTINE ENTERED, LIST DATA IS\" DATA\nSAY \"getdata: \"ACID FIELD DATA\nIF WORD(idlist.1,1) = \"TSS0352E\" THEN DO\n  SECRC = \"$BADAUTH\"\n  SAY \"getdata: ID IS NOT OWNED WITHIN SCOPE OF CONTROL\"\nEND\nSAY \"getdata: SECRC IS BEING SET TO \" SECRC\nreturn 08\nSEEYA: NOP\nSAY \"getdata: AN ERROR HAS OCCURED IN LINE \"SIGL\nreturn 16\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISRCON": {"ttr": 8461, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00@\\x13\\x01\\x04\\x06\\x8f\\x01\\x04\\x06\\x8f\\x131\\x01\\x85\\x01\\x85\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 64, "createdate": "2004-03-08T00:00:00", "modifydate": "2004-03-08T13:31:13", "lines": 389, "newlines": 389, "modlines": 0, "user": "COA1DIR"}, "text": "/* ISPF Configuration table definition.  Generated by REXX ISPCMOD    */\n/*   Created 13:31:04 on 8 Mar 2004                                   */\n/*   by user COA1DIR.                                                 */\n/*   All values were included.                                        */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\n/*                             PDF EXITS                              */\n/*--------------------------------------------------------------------*/\nDATA_SET_ALLOCATION_PROGRAM_EXIT            = NONE\nPRINT_UTILITY_PROGRAM_EXIT                  = NONE\nPRINT_UTILITY_COMMAND_EXIT                  = NONE\nCOMPRESS_UTILITY_PROGRAM_EXIT               = NONE\nCOMPRESS_UTILITY_CLIST_EXIT                 = NONE\nDATA_SET_LIST_FILTER_PROGRAM_EXIT           = NONE\nMEMBER_LIST_FILTER_PROGRAM_EXIT             = NONE\nDATA_SET_NAME_CHANGE_PROGRAM_EXIT           = NONE\nDATA_SET_LIST_LINE_COMMAND_PROGRAM_EXIT     = NONE\nACTIVITY_MONITORING_PROGRAM_EXIT            = NONE\nMEMBER_LIST_LINE_COMMAND_PROGRAM_EXIT       = NONE\nMEMBER_LIST_LINE_COMMAND_COMMAND_EXIT       = NONE\n/*--------------------------------------------------------------------*/\n/*                    DATA SET ALLOCATION SETTINGS                    */\n/*--------------------------------------------------------------------*/\nPDF_DEFAULT_UNIT                            = SYSALLDA\nALLOWED_ALLOCATION_UNITS                    = ANY\nALLOCATE_BEFORE_UNCATALOG                   = NO\nVERIFY_EXPIRATION_DATE                      = YES\nVOLUME_OF_MIGRATED_DATA_SETS                = MIGRAT\nCOMMAND_TO_DELETE_MIGRATED_DATA_SETS        = HDELETE\n/*--------------------------------------------------------------------*/\n/*                  OUTLIST DATA SET SPECIFICATIONS                   */\n/*--------------------------------------------------------------------*/\nOUTLIST_RECORD_LENGTH                       = 133\nOUTLIST_BLOCK_SIZE                          = 13566\nOUTLIST_PRIMARY_QUANTITY                    = 200\nOUTLIST_SECONDARY_QUANTITY                  = 100\n/*--------------------------------------------------------------------*/\n/*                   SUPERC DATA SET SPECIFICATIONS                   */\n/*--------------------------------------------------------------------*/\nSUPERC_LIST_DATA_SET_BLOCK_SIZE             = 0\nSUPERC_UPDATE_DATA_SET_BLOCK_SIZE           = 0\nSUPERC_PROFILE_DATA_SET_BLOCK_SIZE          = 0\nSUPERC_STATEMENTS_DATA_SET_BLOCK_SIZE       = 0\nUSE_SUPERC_PROGRAM_INTERFACE                = YES\nSUPERC_LISTING_PRIMARY_QUANITY              = 50\nSUPERC_LISTING_SECONDARY_QUANITY            = 100\nSUPERC_UPDATE_PRIMARY_QUANITY               = 15\nSUPERC_UPDATE_SECONDARY_QUANITY             = 30\n/*--------------------------------------------------------------------*/\n/*                                LMF                                 */\n/*--------------------------------------------------------------------*/\nFAIL_ON_LMF_LOCK                            = YES\n/*--------------------------------------------------------------------*/\n/*               EDIT RECOVERY DATA SET SPECIFICATIONS                */\n/*--------------------------------------------------------------------*/\nEDIT_RECOVERY_BLOCK_SIZE                    = 13680\nEDIT_RECOVERY_PRIMARY_QUANTITY              = 40\nEDIT_RECOVERY_SECONDARY_QUANTITY            = 200\n/*--------------------------------------------------------------------*/\n/*                         MOVE/COPY SETTINGS                         */\n/*--------------------------------------------------------------------*/\nMAXIMUM_GOOD_IEBCOPY_RETURN_CODE            = 0\nUSE_IEBCOPY_COPY_OR_COPYMOD_OPTION          = 2\nWHEN_TO_USE_IEBCOPY                         = 0\nALLOW_DATA_SET_CREATION_FOR_MOVE_COPY       = YES\n/*--------------------------------------------------------------------*/\n/*                       EDIT RELATED SETTINGS                        */\n/*--------------------------------------------------------------------*/\nMAXIMUM_EDIT_PROFILES                       = 25\nSCLM_WARNING_LEVEL                          = WARN\nUNDO_STORAGE_SIZE                           = 0\nALLOW_EDIT_HIGHLIGHTING                     = YES\nDEFAULT_EDIT_DISPLAY                        = 3\nMAXIMUM_STORAGE_ALLOWED_FOR_EDIT            = 0\nENABLE_ASSEMBLER_CONTINUATION_ERRORS        = YES\nWARN_ON_TRUNCATION_OF_TRAILING_BLANKS       = YES\nSITE_WIDE_INITIAL_MACRO                     = NONE\nTEXT_FLOW_TERMINATORS                       = .:&<....\nEDIT_CUT_DEFAULT                            = REPLACE\nEDIT_PASTE_DEFAULT                          = KEEP\nALLOW_DATA_SET_CREATION_FOR_CREATE_REPLACE  = YES\nFORCE_ISRE776_FOR_RCHANGE                   = NO\nFORCE_PRESERVE_VB_RECORD_LENGTH             = NO\nPRESERVE_VB_RECORD_LENGTH                   = NO\nMAXIMUM_NUMBER_OF_EDIT_CLIPBOARDS           = 11\nMAXIMUM_EDIT_CLIPBOARD_SIZE                 = 0\nVSAM_EDIT_ENABLED                           = YES\nVSAM_EDIT_COMMAND                           = DITTO VE /\nVSAM_BROWSE_ENABLED                         = YES\nVSAM_BROWSE_COMMAND                         = DITTO VB /\nVSAM_VIEW_ENABLED                           = YES\nVSAM_VIEW_COMMAND                           = DITTO VB /\n/*--------------------------------------------------------------------*/\n/*               EDIT SITE WIDE PROFILE CUSTOMIZATIONS                */\n/*--------------------------------------------------------------------*/\nSTATS                                       = ON\nFORCE_STATS                                 = NO\nRECOVERY                                    = ON\nFORCE_RECOVERY                              = NO\nRECOVERY_WARNING_MESSAGE                    = WARN\nFORCE_RECOVERY_WARNING_MESSAGE              = NO\nSETUNDO                                     = ON\nFORCE_SETUNDO                               = NO\nPACK                                        = OFF\nFORCE_PACK                                  = NO\nIMACRO                                      = NONE\nFORCE_IMACRO                                = NO\nCAPS                                        = OFF\nNOTE                                        = ON\nHEX                                         = OFF\nNULLS                                       = STD\nDISPLAY_SEQUENCE_NUMBERS                    = OFF\nCOBOL_NUMBERS                               = OFF\nSTANDARD_NUMBERS                            = OFF\nAUTONUM                                     = OFF\nAUTOLIST                                    = OFF\nPROFILE                                     = UNLOCK\nAUTOSAVE                                    = ON\nAUTOSAVE_PROMPT                             = PROMPT\nHILITE                                      = OFF\nHILITE_DOLOGIC                              = OFF\nHILITE_IFLOGIC                              = OFF\nHILITE_PAREN                                = OFF\nHILITE_FIND                                 = OFF\nHILITE_CURSOR                               = ON\nHILITE_LANGUAGE                             = 1\n/*--------------------------------------------------------------------*/\n/*               ISPF SITE WIDE PROFILE CUSTOMIZATIONS                */\n/*--------------------------------------------------------------------*/\nVERSION_LEVEL_OF_SITEWIDE_DEFAULTS          = 43000\nTAB_TO_POINT_AND_SHOOT                      = NO\nRESET_TAB_TO_POINT_AND_SHOOT                = NO\nTAB_TO_ACTION_BARS                          = NO\nRESET_TAB_TO_ACTION_BARS                    = NO\nUSE_SESSION_MANAGER                         = NO\nRESET_USE_SESSION_MANAGER                   = NO\nJUMP_FROM_LEADER_DOTS                       = YES\nRESET_JUMP_FROM_LEADER_DOTS                 = NO\nSHOW_SPLIT_LINE                             = YES\nRESET_SHOW_SPLIT_LINE                       = NO\nLONG_MESSAGES_IN_POPUP                      = YES\nRESET_LONG_MESSAGES_IN_POPUP                = NO\nEDIT_PRINTDS_COMMAND                        = NO\nRESET_EDIT_PRINTDS_COMMAND                  = NO\nRESTORE_TEST_TRACE_OPTIONS                  = YES\nRESET_RESTORE_TEST_TRACE_OPTIONS            = NO\nDISPLAY_PANELS_IN_CUA_MODE                  = YES\nRESET_DISPLAY_PANELS_IN_CUA_MODE            = NO\nLOG_DATA_SET_DISPOSITION                    = NONE\nRESET_LOG_DATA_SET_DISPOSITION              = NO\nLIST_DATA_SET_DISPOSITION                   = NONE\nRESET_LIST_DATA_SET_DISPOSITION             = NO\nCOMMAND_LINE_PLACEMENT                      = BOTTOM\nRESET_COMMAND_LINE_PLACEMENT                = NO\nUSE_KEYLISTS                                = YES\nRESET_USE_KEYLISTS                          = NO\nSHOW_PFKEYS                                 = ON\nRESET_SHOW_PFKEYS                           = NO\nSCROLL_DEFAULT                              = CSR\nSTATUS_AREA_DEFAULT                         = SES\nLIST_DATA_SET_RECORDS_PER_BLOCK             = 26\nLOG_DATA_SET_BLOCK_SIZE                     = 129\nBLOCK_SIZE_FOR_TEMPORARY_CNTL_DATA_SETS     = 23200\nBLOCK_SIZE_FOR_TEMPORARY_LIST_DATA_SETS     = 3146\nBLOCK_SIZE_FOR_TEMPORARY_WORK_DATA_SETS     = 25600\nISPCTL_PRIMARY_QUANTITY                     = 100\nISPCTL_SECONDARY_QUANTITY                   = 100\nISPWRK_PRIMARY_QUANTITY                     = 100\nISPWRK_SECONDARY_QUANTITY                   = 100\nUSE_PDFCUNIT_FOR_TEMP_ISPF_DATA_SETS        = NO\nISPF_TEMPORARY_DATA_SET_QUALIFIER           = NONE\nPRINTDS_DEST_OR_WRITER_OPTION               = DEST\nLOCAL_PRINTDS_OPTIONS                       = NONUM\nUSE_ALTERNATE_DIALOG_TEST_PANEL             = 1\n/*--------------------------------------------------------------------*/\n/*                     DEFAULT CUA COLOR SETTINGS                     */\n/*--------------------------------------------------------------------*/\nACTION_BAR_SELECTED_CHOICE                  = 600 /*Yellow Low  None  */\nRESET_ACTION_BAR_SELECTED_CHOICE            = NO\nACTION_BAR_SEPARATOR_LINE                   = 100 /*Blue   Low  None  */\nRESET_ACTION_BAR_SEPARATOR_LINE             = NO\nACTION_BAR_UNSELECTED_CHOICE                = 720 /*White  High None  */\nRESET_ACTION_BAR_UNSELECTED_CHOICE          = NO\nACTION_MESSAGE_TEXT                         = 220 /*Red    High None  */\nRESET_ACTION_MESSAGE_TEXT                   = NO\nCAUTION_TEXT                                = 620 /*Yellow High None  */\nRESET_CAUTION_TEXT                          = NO\nCHOICE_ENTRY_FIELD                          = 504 /*Turq   Low  Uscore*/\nRESET_CHOICE_ENTRY_FIELD                    = NO\nCOLUMN_HEADING                              = 120 /*Blue   High None  */\nRESET_COLUMN_HEADING                        = NO\nDESCRIPTIVE_TEXT                            = 400 /*Green  Low  None  */\nRESET_DESCRIPTIVE_TEXT                      = NO\nEMPHASIZED_TEXT                             = 520 /*Turq   High None  */\nRESET_EMPHASIZED_TEXT                       = NO\nERROR_EMPHASIS                              = 622 /*Yellow High Rev   */\nRESET_ERROR_EMPHASIS                        = NO\nFIELD_PROMPT                                = 400 /*Green  Low  None  */\nRESET_FIELD_PROMPT                          = NO\nFUNCTION_KEYS                               = 100 /*Blue   Low  None  */\nRESET_FUNCTION_KEYS                         = NO\nINFORMATIONAL_MESSAGE_TEXT                  = 720 /*White  High None  */\nRESET_INFORMATIONAL_MESSAGE_TEXT            = NO\nLIST_ENTRY_FIELD                            = 504 /*Turq   Low  Uscore*/\nRESET_LIST_ENTRY_FIELD                      = NO\nLIST_ITEM_DESCRIPTION                       = 400 /*Green  Low  None  */\nRESET_LIST_ITEM_DESCRIPTION                 = NO\nLIST_ITEM                                   = 700 /*White  Low  None  */\nRESET_LIST_ITEM                             = NO\nNORMAL_ENTRY_FIELD                          = 504 /*Turq   Low  Uscore*/\nRESET_NORMAL_ENTRY_FIELD                    = NO\nNORMAL_TEXT                                 = 400 /*Green  Low  None  */\nRESET_NORMAL_TEXT                           = NO\nPANEL_ID                                    = 100 /*Blue   Low  None  */\nRESET_PANEL_ID                              = NO\nPANEL_INFORMATION                           = 400 /*Green  Low  None  */\nRESET_PANEL_INFORMATION                     = NO\nPANEL_TITLE                                 = 100 /*Blue   Low  None  */\nRESET_PANEL_TITLE                           = NO\nPOINT_AND_SHOOT                             = 520 /*Turq   High None  */\nRESET_POINT_AND_SHOOT                       = NO\nPULLDOWN_AVAILABLE_CHOICE                   = 700 /*White  Low  None  */\nRESET_PULLDOWN_AVAILABLE_CHOICE             = NO\nPULLDOWN_UNAVAILABLE_CHOICE                 = 100 /*Blue   Low  None  */\nRESET_PULLDOWN_UNAVAILABLE_CHOICE           = NO\nREFERENCE_PHRASE                            = 720 /*White  High None  */\nRESET_REFERENCE_PHRASE                      = NO\nSCROLL_INFORMATION                          = 720 /*White  High None  */\nRESET_SCROLL_INFORMATION                    = NO\nSELECTION_AVAILABLE_CHOICE                  = 700 /*White  Low  None  */\nRESET_SELECTION_AVAILABLE_CHOICE            = NO\nSELECTION_UNAVAILABLE_CHOICE                = 100 /*Blue   Low  None  */\nRESET_SELECTION_UNAVAILABLE_CHOICE          = NO\nVARIABLE_OUTPUT_INFORMATION                 = 500 /*Turq   Low  None  */\nRESET_VARIABLE_OUTPUT_INFORMATION           = NO\nWARNING_MESSAGE_TEXT                        = 620 /*Yellow High None  */\nRESET_WARNING_MESSAGE_TEXT                  = NO\nWARNING_MESSAGE                             = 220 /*Red    High None  */\nRESET_WARNING_MESSAGE                       = NO\nWORKAREA_SEPARATOR_LINE                     = 100 /*Blue   Low  None  */\nRESET_WORKAREA_SEPARATOR_LINE               = NO\n/*--------------------------------------------------------------------*/\n/*                       MISCELLANEOUS SETTINGS                       */\n/*--------------------------------------------------------------------*/\nMONITOR_EDIT_MACRO_COMMANDS                 = NO\nALLOW_SUBMIT_FROM_BROWSE                    = YES\nALLOW_SUBMIT_FROM_VIEW                      = YES\nWARN_ON_RENAME_TO_GDG_NAME                  = YES\nDEFAULT_EDIT/BROWSE/VIEW_MEMBER_LIST        = YES\nIS_VIEW_SUPPORTED                           = YES\nUSE_ALTERNATE_PANEL_ISRTSOA                 = NO\nPRINT_USING_ICF                             = NO\nDISALLOW_WILDCARDS_IN_HLQ                   = NO\nMAXIMUM_NUMBER_OF_SPLIT_SCREENS             = 8\nAPPLID_FOR_USER_COMMAND_TABLE               = NONE\nAPPLID_FOR_SITE_COMMAND_TABLE               = NONE\nSITE_COMMAND_TABLE_SEARCH_ORDER             = BEFORE\nYEAR_2000_SLIDING_RULE                      = 65\nSHOW_ENQ_DISPLAYS                           = YES\nDEFAULT_SESSION_LANGUAGE                    = ENGLISH\n/*--------------------------------------------------------------------*/\n/*                    VALUES FORMERLY IN ISPDFLTS                     */\n/*--------------------------------------------------------------------*/\nNUMBER_OF_ROWS_FOR_TBADD                    = 1\nRETRIEVE_COMMAND_STACK_SIZE                 = 512\nENABLE_ISPF_EXITS                           = NO\nSAS/C_TCPIP_DATA_VALUE                      = DEFAULT\nSAS/C_TCPIP_PREFIX_VALUE                    = DEFAULT\nUSE_MVS_OPEN_EDITION_SOCKETS                = NO\n/*--------------------------------------------------------------------*/\n/*                     VSAM DATA SET RESTRICTIONS                     */\n/*--------------------------------------------------------------------*/\nVSAM_RESTRICTED_BROWSE_DATASET              = NONE\nVSAM_RESTRICTED_EDIT_DATASET                = NONE\nVSAM_RESTRICTED_VIEW_DATASET                = NONE\n/*--------------------------------------------------------------------*/\n/*                      ISPSPROF GENERAL VALUES                       */\n/*--------------------------------------------------------------------*/\nLOG/LIST_JOB_CARD1                          = NONE\nLOG/LIST_JOB_CARD2                          = NONE\nLOG/LIST_JOB_CARD3                          = NONE\nLOG/LIST_JOB_CARD4                          = NONE\nLOG_DATA_SET_UNIQUE_CHARACTER               = 1\nLOG_SYSOUT_CLASS                            = NONE\nRESET_LOG_SYSOUT_CLASS                      = NO\nLOCAL_LOG_SYSOUT_CLASS                      = NONE\nRESET_LOCAL_LOG_SYSOUT_CLASS                = NO\nLOG_DISPLAY_REQUIRED                        = NO\nLOG_KEPT                                    = NO\nLOG_LINES_PER_PAGE                          = 60\nLOG_MESSAGE_ID                              = NO\nLOG_LOCAL_PRINTER_ID                        = NONE\nRESET_LOG_LOCAL_PRINTER_ID                  = NO\nLOG_PAGES_PRIMARY_QUANTITY                  = 00\nLOG_PAGES_SECONDARY_QUANTITY                = 10\nLIST_DATA_SET_UNIQUE_CHARACTER              = 1\nLIST_SYSOUT_CLASS                           = NONE\nRESET_LIST_SYSOUT_CLASS                     = NO\nLOCAL_LIST_SYSOUT_CLASS                     = NONE\nRESET_LOCAL_LIST_SYSOUT_CLASS               = NO\nLIST_DISPLAY_REQUIRED                       = NO\nLIST_KEPT                                   = NO\nLIST_LINES_PER_PAGE                         = 60\nLIST_LINE_LENGTH                            = 120\nLIST_LOCAL_PRINTER_ID                       = NONE\nRESET_LIST_LOCAL_PRINTER_ID                 = NO\nLIST_RECORD_FORMAT                          = FBA\nLIST_LOGICAL_RECORD_LENGTH                  = 121\nLIST_PAGES_PRIMARY_QUANTITY                 = 000\nLIST_PAGES_SECONDARY_QUANTITY               = 200\nUNIQUE_JOB_CHARACTER                        = NONE\nSCREEN_FORMAT                               = STD\nTERMINAL_TYPE                               = 3278\nFAMILY_PRINTER                              = 2\nDEVICE_NAME                                 = NONE\nRESET_DEVICE_NAME                           = NO\nASPECT_RATIO                                = 0\nPAD_CHARACTER                               = B\nDELIMITER                                   = ;\nRETRIEVE_MINIMUM_LENGTH                     = 1\nRETRIEVE_CURSOR_POSITION                    = 1\nENABLE_DUMP                                 = OFF\nTERMTRAC_DD_NAME                            = ISPSNAP\nRESET_TERMTRAC_DD_NAME                      = NO\nENVIRON_TERMTRAC_VALUE                      = OFF\nPFKEY_PREFIX                                = YES\nFKA_SETTING                                 = LONG\nNUMBER_OF_PFKEYS                            = 12\nCHARACTER_SET_LOAD_MODULE                   = ISP3278\nRESET_CHARACTER_SET_LOAD_MODULE             = NO\nFRAME_COLOR                                 = 1\nFRAME_INTENSITY                             = 2\nTPUT_BUFFER_BLOCKSIZE                       = 0\nGLOBAL_COLORS                               = 1234567\nGUI_GLOBAL_COLORS                           = 010413\nHOST_COLORS                                 = OFF\nPC_COLORS                                   = OFF\nDEFAULT_MESSAGE_ID                          = OFF\nDEFAULT_PANEL_ID                            = OFF\nDEFAULT_SCREEN_NAME                         = OFF\nDEFAULT_PRIMARY_PANEL                       = ISP@MSTR\nENABLE_EURO_SYMBOL                          = NO\nRESET_ENABLE_EURO_SYMBOL                    = NO\nDATE_FORMAT_ZDATEFD                         = DEFAULT\nDATE_FORMAT_ZDATEF                          = DEFAULT\nDEFAULT_TIME_SEPARATOR                      = D\n/*--------------------------------------------------------------------*/\n/*                   ISPSPROF WORKSTATION DEFAULTS                    */\n/*--------------------------------------------------------------------*/\nGUI_APPC_ADDRESS                            = NONE\nGUI_APPC_ADDRESS2                           = NONE\nGUI_APPC_ADDRESS3                           = NONE\nGUI_APPC_ADDRESS4                           = NONE\nGUI_APPC_ADDRESS5                           = NONE\nGUI_CLOSE_WINDOW                            = 1\nGUI_DISPLAY_ENTER_KEY                       = YES\nGUI_WINDOW_FRAME                            = 1\nGUI_NETWORK                                 = 1\nGUI_SWITCH                                  = 1\nSAVE_GUI_VALUES                             = YES\nGUI_TCP_ADDRESS                             = NONE\nGUI_TCP_ADDRESS2                            = NONE\nGUI_TCP_ADDRESS3                            = NONE\nGUI_TCP_ADDRESS4                            = NONE\nGUI_TCP_ADDRESS5                            = NONE\nGUI_TITLE                                   = NONE\nGUI_ACCELERATOR_SUPPORT                     = YES\nHOST_CODE_PAGE                              = 0000\nRESET_HOST_CODE_PAGE                        = NO\nHOST_CHARACTER_SET                          = 0000\nRESET_HOST_CHARACTER_SET                    = NO\nGUI_DEFAULT_BACKGROUND_COLOR                = 1\nGUI_DOWNLOAD_IMAGES                         = YES\nGUI_MAKEPATH_FOR_IMAGES                     = NO\nCONTINUE_3270_AFTER_LOSS_OF_WS_CONNECTION   = YES\n/*--------------------------------------------------------------------*/\n/*               ISPSPROF WORKSTATION DOWNLOAD DEFAULTS               */\n/*--------------------------------------------------------------------*/\nWSA_DOWNLOAD_OPTION                         = 1\nWSA_DOWN_LEVEL_WARNING                      = YES\nWSA_DOWNLOAD_FTP_ADDRESS                    = NONE\nBROWSE_FTP_ERRORS                           = YES\nCREATE_DIRECTORY_ON_WSA_DOWNLOAD            = NO\nWSA_DOWNLOAD_DIRECTORY                      = NONE\nWSA_DOWNLOAD_METHOD                         = NONE\nWSA_DOWNLOAD_DATA_SET                       = 'ISP.SISPGUI'\nRESET_WSA_DOWNLOAD_DATA_SET                 = NO\nWSA_DOWNLOAD_PLATFORM                       = NONE\nWSA_DOWNLOAD_FTP_USER                       = NONE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LOG": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x009\\x01\\x02\\x14?\\x01\\x02\\x14?\\x08\\x13\\x00`\\x00`\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-23T00:00:00", "modifydate": "2002-05-23T08:13:39", "lines": 96, "newlines": 96, "modlines": 0, "user": "*SPIV8*"}, "text": "/* Rexx */\nLOG:\n/**********************************************************/\n/** This function maintains stem variables automatically.**/\n/** It accepts three parms:                              **/\n/** Dataarea - A string which can contain a number       **/\n/**            for the INIT function, or a message for   **/\n/**            the APPEND function, or a DDNAME for the  **/\n/**            DUMP function.                            **/\n/** Logname -  The name you use to refer to a log, must  **/\n/**            be a valid REXX variable name.            **/\n/** Function - INIT to initialize  a log                 **/\n/**            APPEND to append to a log                 **/\n/**            DUMP to write the log to a DDNAME         **/\n/**            WRITE to write the log to the screen      **/\n/**            DELETE to delete the log                  **/\n/**            PURGE to clear all the data from a log    **/\n/**                                                      **/\n/**********************************************************/\n  dataarea = arg(1)\n  logname  = arg(2)\n  funct    = arg(3)\n  upper funct logname\n  if funct = \"\" then funct = \"APPEND\"  /* the default option */\n  Select\n    when funct = \"INIT\" then do\n      upper dataarea\n      /* log(100,debug,init) */\n      log.logname.0max = dataarea\n      if datatype(dataarea) /= \"NUM\" then return 4\n      return 0\n      /* above inits a new log var */\n    end\n    when funct = \"APPEND\" then do\n      /* log(my log dataarea) */\n      /* log(my log dataarea,debug,append) */\n      if logname = \"\" then logname = \"DEBUG\" /* the default log */\n      if datatype(log.logname.0) /= \"NUM\" then log.logname.0 = 0\n      if datatype(log.logname.0max) /= \"NUM\" then do\n        say \"LOG002E: Uninitialized log variable\"\n        say \"         You must init a log variable before use.\"\n        return 12\n      end\n      hold = log.logname.0 + 1\n      if hold > log.logname.0max then log.logname.0wrap = \"YES\"\n      if hold > log.logname.0max then hold = 1\n      /* if we are at max then start at #1 again */\n      log.logname.hold = dataarea\n      log.logname.0 = hold     /* update the tracker subscript */\n      hold = hold + 1\n      log.logname.hold = \"_____________\"\n      return 0\n    end\n    when funct = \"PURGE\" then do\n      /* log(,debug,purge) */\n      /* keep the stream but delete the contents */\n      savemax = log.logname.0max\n      log.logname. = \"\"\n      log.logname.0max = savemax\n      log.logname.0 = 0         /* reset my array */\n      return 0\n    end\n    when funct = \"DELETE\" then do\n      /* log(,debug,delete) */\n      /* as if it never existed */\n      log.logname. = \"\"\n      return 0\n    end\n    when funct = \"DUMP\" then do\n      /* log(ddname,debug,dump) */\n      ddname = dataarea\n      lines = log.logname.0\n      stem = \"log.\"logname\".\"\n      savemax = log.logname.0max\n      if log.logname.0wrap = \"YES\" then lines = log.logname.0max\n      if datatype(log.logname.0) /= \"NUM\" then log.logname.0 = 0\n      /* above inits a new log var */\n      ADDRESS MVS \"EXECIO \"lines\" DISKW \"ddname\" ( FINIS STEM \"stem\")\"\n      /* log.logname. = \"\"\n      log.logname.0max = savemax\n      log.logname.0 = 0            reset my array */\n      return 0\n    end\n    WHEN FUNCT = \"WRITE\" THEN DO\n      /* log(,debug,WRITE) */\n      if datatype(log.logname.0) /= \"NUM\" then log.logname.0 = 0\n      lines = log.logname.0\n      stem = \"log.\"logname\".\"\n      if log.logname.0wrap = \"YES\" then lines = log.logname.0max\n      do w = 1 to lines\n        say log.logname.w\n      end\n      return 0\n    end\n    otherwise return 4\n   End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGOLD": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x02\\x14?\\x01\\x02\\x14?\\x08\\x13\\x00P\\x00P\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-05-23T00:00:00", "modifydate": "2002-05-23T08:13:57", "lines": 80, "newlines": 80, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nLOG:\n  message = arg(1)\n  parm    = arg(2)\n  funct   = arg(3)\n  upper funct parm\n  if funct = \"\" then funct = \"APPEND\"  /* the default option */\n  Select\n    when funct = \"INIT\" then do\n      upper message\n      /* log(debug,100,init) */\n      log.message.0max = parm\n      if datatype(parm) /= \"NUM\" then return 4\n      return 0\n      /* above inits a new log var */\n    end\n    when funct = \"APPEND\" then do\n      /* log(my log message) */\n      /* log(my log message,debug,append) */\n      if parm = \"\" then parm = \"DEBUG\" /* the default log */\n      if datatype(log.parm.0) /= \"NUM\" then log.parm.0 = 0\n      if datatype(log.parm.0max) /= \"NUM\" then do\n        say \"LOG002E: Uninitialized log variable\"\n        say \"         You must init a log variable before use.\"\n        return 12\n      end\n      hold = log.parm.0 + 1\n      if hold > log.parm.0max then log.parm.0wrap = \"YES\"\n      if hold > log.parm.0max then hold = 1\n      /* if we are at max then start at #1 again */\n      log.parm.hold = message\n      log.parm.0 = hold        /* update the tracker subscript */\n      hold = hold + 1\n      log.parm.hold = \"_____________\"\n      return 0\n    end\n    when funct = \"PURGE\" then do\n      /* log(,debug,purge) */\n      /* keep the stream but delete the contents */\n      savemax = log.parm.0max\n      log.parm. = \"\"\n      log.parm.0max = savemax\n      log.parm.0 = 0            /* reset my array */\n      return 0\n    end\n    when funct = \"DELETE\" then do\n      /* log(,debug,delete) */\n      /* as if it never existed */\n      log.parm. = \"\"\n      return 0\n    end\n    when funct = \"DUMP\" then do\n      /* log(ddname,debug,dump) */\n      ddname = message\n      lines = log.parm.0\n      stem = \"log.\"parm\".\"\n      savemax = log.parm.0max\n      if log.parm.0wrap = \"YES\" then lines = log.parm.0max\n      if datatype(log.parm.0) /= \"NUM\" then log.parm.0 = 0\n      /* above inits a new log var */\n      ADDRESS MVS \"EXECIO \"lines\" DISKW \"ddname\" ( FINIS STEM \"stem\")\"\n      log.parm. = \"\"\n      log.parm.0max = savemax\n      log.parm.0 = 0            /* reset my array */\n      return 0\n    end\n    WHEN FUNCT = \"WRITE\" THEN DO\n      /* log(ddname,debug,dump) */\n      ddname = message\n      if datatype(log.parm.0) /= \"NUM\" then log.parm.0 = 0\n      lines = log.parm.0\n      stem = \"log.\"parm\".\"\n      if log.parm.0wrap = \"YES\" then lines = log.parm.0max\n      do w = 1 to lines\n        say log.parm.w\n      end\n      return 0\n    end\n    otherwise return 4\n   End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "L4": {"ttr": 11013, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x10\\x01\\x06\\x10O\\x01\\x06\\x10O\\tI\\x01=\\x01C\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-04-14T00:00:00", "modifydate": "2006-04-14T09:49:10", "lines": 317, "newlines": 323, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX (Restructured eXtended eXecutor language) */\n/*************************************************************/\n/** this exec was stolen from Blair Meglathery at IMS america*/\n/*************************************************************/\nADDRESS ispexec\nDo Forever\n  \"DISPLAY PANEL (LFMP001)\"\n  If rc > 4 Then  /* END command, exit */\n     Leave\n  ADDRESS tso \"NEWSTACK\"  /* create a new stack */\n  Select\n    When l4fddn = \"LLT\" Then\n      Call WalkLLT   /* get link list dsn's */\n    When l4fddn = \"LPAT\" Then\n       Call WalkLPAT  /* get LPA list dsn's */\n    When LENGTH(l4fddn) = 6 & SUBSTR(l4fddn,1,4) = \"PROC\" &  ,\n      (SUBSTR(l4fddn,5,2) >= \"00\" & SUBSTR(l4fddn,5,2) <= \"99\") Then\n      Call WalkJES2  /* get PROCxx dsn's */\n    When l4fddn = \"STEPLIB\" Then Do\n      Call Find_Steplib   /* Find ddname allocated by STEPLIB */\n      If result /= \"\" Then\n        l4fddn = result\n      Call WalkTIOT  /* get ddname dsn's */\n    End\n    Otherwise\n      Call WalkTIOT  /* get ddname dsn's */\n  End\n   If result <= 0 Then\n      \"SETMSG MSG(LFMM000)\"\n   Else Do\n      Call Search /* search libs for member */\n      If result > 0 Then  /* if member found */\n         Call Display     /* display table */\n      Else\n         \"SETMSG MSG(LFMM002)\"\n   End  /* if */\n      ADDRESS tso \"DELSTACK\"  /* delete stack */\n   End  /* do forever */\n   \"CONTROL ERRORS RETURN\"   /* trap error */\n   \"TBCLOSE L4FTABL\"\nExit 0\n/*---------------------------------------------------*/\n/*  Create a stack for LPAT entries (LPA list)       */\n/*---------------------------------------------------*/\nWalkLPAT:\n   @cvt = STORAGE(10,4)    /* CVT address */\n   @lpa = STORAGE(D2X(C2D(@cvt)+1196),4)    /* storage map extension */\n   @lpa = STORAGE(D2X(C2D(@lpa)+56),4)    /* LPAT address */\n   If STORAGE(D2X(C2D(@lpa)),4)  /= \"LPAT\" Then Do\n      Say \"Can't locate LPAT\"   /* not a valid LPAT */\n      Return -1\n   End\n   nrdsns = C2D(STORAGE(D2X(C2D(@lpa)+4),4))  /*number of lpat entries*/\n   lpadsn = \" \"\n   @lpa = D2C(C2D(@lpa)+8)  /* address of 1st lpa entry */\n   Do i=nrdsns to 1 by -1  /* loop thru lpa */\n      lpadsn =  STORAGE(D2X(C2D(@lpa)+1),44)\n      QUEUE lpadsn   /* add dsn to stack */\n      @lpa = D2C(C2D(@lpa)+45)  /* point to next lpa entry */\n   End\nReturn nrdsns\n/*---------------------------------------------------*/\n/*  Create a stack for LLT entries (link list)       */\n/*---------------------------------------------------*/\nWalkLLT:\n   @cvt = STORAGE(10,4)    /* CVT address */\n   @llt = STORAGE(D2X(C2D(@cvt)+1244),4)    /* LLT address */\n   If STORAGE(D2X(C2D(@llt)),4)  /= \"LLT \" Then Do\n      Say \"Can't locate LLT\"   /* not a valid LLT */\n      Return -1\n   End\n   nrdsns = C2D(STORAGE(D2X(C2D(@llt)+4),4))  /* number of LLT entries*/\n   lltdsn = \" \"\n   @llt = D2C(C2D(@llt)+8)  /* address of 1st LLT entry */\n   Do i=nrdsns to 1 by -1  /* loop thru LLT */\n      lltdsn =  STORAGE(D2X(C2D(@llt)+1),44)  /* dsname */\n      QUEUE lltdsn   /* add dsn to stack */\n      @llt = D2C(C2D(@llt)+45)  /* point to next LLT entry */\n   End\nReturn nrdsns\n/*---------------------------------------------------*/\n/*  Create a stack for PROCxx DD entries             */\n/*---------------------------------------------------*/\nWalkJES2:\n   If jes2proc /= \"R\" Then Do\n      /* Read SYS1.PROCLIB(JES2) into variables */\n      jes2proc = \"R\"\n      line.0 = 0\nADDRESS tso\n      /* allocate file */\n      \"ALLOC F(TEMP) DA('SYS1.PROCLIB(JES2)') SHR REUSE\"\n      \"EXECIO * DISKR TEMP ( FINIS STEM line.\"\n      \"FREE F(TEMP)\"\nADDRESS ispexec\n   End\n   If line.0 <= 0 Then  /* JES2 proc not read */\n      Return 0\n\n   nrdsns = 0\n   /* Search for beginning of requested DDname concatenation */\n   Do i = 1 to line.0 by 1 until SUBSTR(line.i,3,6) = l4fddn\n   End\n   If i > line.0 Then /* PROCxx not found */\n      return 0\n   Call Finddsn   /* extract dsname */\n\n   /* Process the rest of the DD's in the concatenation      */\n   Do i = i + 1 to line.0 by 1 While  SUBSTR(line.i,3,1) = \" \"\n      Call Finddsn /* process next statement in concatenation */\n   End\nReturn nrdsns\n\n/* Finddsn - WalkJES2 sub-routine to        */\n/* extract the DSNAME from the DD statement */\nFinddsn:\n   PARSE VAR line.i \"DSN=\" dsname \",\" trail\n   If dsname > \" \" Then Do\n      If SUBSTR(dsname,1,1) /= \"&\"  Then Do\n         QUEUE dsname   /* add dsn to stack */\n         nrdsns = nrdsns + 1\n      End\n      Else Do\n         /* Go back and do the symbolic substitution */\n         compare = STRIP(dsname,l,\"&\")||\"=\"\n         Do a =  1 to line.0 by 1 While INDEX(line.a,\" EXEC \") = 0\n            PARSE VAR line.a (compare) dsname \",\" trail\n            If dsname > \" \" Then Do\n               If SUBSTR(dsname,1,1) = \"'\" Then\n                  dsname = STRIP(dsname,B,\"'\")\n               QUEUE dsname   /* add dsn to stack */\n               nrdsns = nrdsns + 1\n            End\n         End\n      End\n   End\nReturn 0\n/*---------------------------------------------------*/\n/*  Create a stack for DD entries                    */\n/*---------------------------------------------------*/\nWalkTIOT:\n   nrdsns = 0\n   @tcb = STORAGE(21C,4)        /* get TCB address from psaaold */\n   @tiot = STORAGE(D2X(C2D(@tcb)+12),4)\n                                 /*add 12 to get first TIOT address */\n   @1stdd = D2X(C2D(@tiot)+28) /* point to 1st DD in TIOT */\n   @1stddlen = STORAGE(D2X(C2D(@tiot)+24),1) /* get its length */\n   @tiot = D2X(C2D(@tiot)+24) /* point2 1st TIOT DDNAME         */\n   Do While C2D(@1stddlen) /= 0  /* loop  thru entire TIOT*/\n      tiotddname = STORAGE(@1stdd,8)                    /* pick up ddnam e */\n      If nrdsns = 0  Then Do\n         If tiotddname = l4fddn Then Do\n            nrdsns = nrdsns+1\n            @token = STORAGE(D2X(X2D(@tiot)+12),3)\n                  /* get JFCB 24-bit token from TIOT */\n            @jfcb = @SWAREQ(@token)   /* get JFCB address from SWAREQ1*/\n            QUEUE STORAGE(C2X(@jfcb),44)  /* add dsn to stack */\n         End\n      End\n      Else Do\n         If tiotddname /= \" \" Then\n            Leave\n         Else Do\n            nrdsns = nrdsns+1\n            @token = STORAGE(D2X(X2D(@tiot)+12),3)\n                 /* get JFCB 24- bit token from TIOT */\n            @jfcb = @SWAREQ(@token)\n                /* get JFCB address from SWAREQ1   */\n            QUEUE STORAGE(C2X(@jfcb),44)  /* add dsn to stack */\n         End\n      End\n      @tiot = D2X(X2D(@tiot)+C2D(@1stddlen))\n       /* point to next  TIOT entry        */\n      @1stddlen = STORAGE(@tiot,1)\n      /* get length of  TIOT entry        */\n      @1stdd  = D2X(X2D(@tiot)+4)\n      /* point at DDNAME in TIOT         */\n   End\nReturn nrdsns\n/*---------------------------------------------------*/\n/*  Search libs for the member                       */\n/*---------------------------------------------------*/\nSearch:\n   found = 0\n   l4fsel = \" \"\n   l4fnbr = 0\n   \"TBCREATE L4FTABL NAMES(L4FSEL L4FNBR L4FDSN) NOWRITE REPLACE\"\n   Do While QUEUED() > 0\n      pull l4fdsn\n      l4fdsn = STRIP(l4fdsn,T)\n      l4fnbr = l4fnbr+1\n      \"CONTROL DISPLAY LOCK\"\n      \"DISPLAY PANEL (LFMP001) MSG(LFMM001)\"\n      If INDEX(l4fmem,\"*\") /= 0 | INDEX(l4fmem,\"%\") /= 0 Then Do\n         \"CONTROL DISPLAY SAVE\"\n         \"CONTROL ERRORS RETURN\"  /* trap errors */\n         \"CONTROL NONDISPL END\"   /* don't show member list */\n         \"BROWSE DATASET('\"l4fdsn\"(\"l4fmem\")')\"\n         rc2 = rc    /* save return code */\n         \"CONTROL DISPLAY RESTORE\"\n         \"CONTROL ERRORS CANCEL\"  /* cancel trap */\n         If rc2 = 0 Then Do\n            /*---------------------------------*/\n            /* Member found, add DSN to table  */\n            /*---------------------------------*/\n            \"VPUT (L4FSEL L4FNBR L4FDSN) ASIS\"\n            \"TBADD L4FTABL SAVE(L4FSEL L4FNBR L4FDSN)\"\n            found = found+1\n         End\n      End\n      Else Do\n         If SYSDSN(\"'\"l4fdsn\"(\"l4fmem\")'\") = \"OK\" Then Do\n            /*---------------------------------*/\n            /* Member found, add DSN to table  */\n            /*---------------------------------*/\n            \"VPUT (L4FSEL L4FNBR L4FDSN) ASIS\"\n            \"TBADD L4FTABL SAVE(L4FSEL L4FNBR L4FDSN)\"\n            found = found+1\n         End\n      End\n   End  /* do while */\nReturn found\n/*---------------------------------------------------*/\n/*  Display results of successful search             */\n/*---------------------------------------------------*/\nDisplay:\n   ztdtop = 0\n   l4fcrp = 0\n   Do Forever\n      \"TBTOP L4FTABL\"\n      \"TBSKIP  L4FTABL NUMBER(\"ztdtop\")\"\n      \"TBDISPL L4FTABL PANEL(LFMP002) AUTOSEL(NO),\n         POSITION(L4FCRP) CSRROW(\"l4fcrp\")\"\n      If rc > 4 Then Leave  /* END command, exit */\n      Call Process  /* process line select command */\n      Do while ztdsels > 1\n         \"TBDISPL L4FTABL AUTOSEL(NO),\n            POSITION(L4FCRP) CSRROW(\"l4fcrp\")\"\n         Call Process  /* process line select command */\n      End\n   End\nReturn 0\n/*---------------------------------------------------*/\n/*  Process line select commands                     */\n/*---------------------------------------------------*/\nProcess:\n   If usel > \" \" Then Do\n      \"CONTROL DISPLAY SAVE\"\n      usel   /* do what the line select says to */\n      l4fsel = \" \"\n      \"CONTROL DISPLAY RESTORE\"\n   End\nReturn 0\n/*---------------------------------------------------*/\n/*  Find ddname allocated by STEPLIB TSO command     */\n/*---------------------------------------------------*/\nFind_Steplib:\n   stepddn = \"\"  /* assume ddname not found */\n   tcb = STORAGE(21C,4)\n   tiot = STORAGE(D2X(C2D(tcb)+12),4)\n   tcbjstcb = STORAGE(D2X(C2D(tcb)+124),4)\n   tcbgrs10 = STORAGE(D2X(C2D(tcbjstcb)+88),4)\n   tcbgrs11 = STORAGE(D2X(C2D(tcbjstcb)+92),4)\n   If tcbjstcb = tcbgrs10 Then Do\n  /*  tcbgrs10 = STORAGE(D2X(C2D(tcbjstcb)+92),4) */\n      /* ------------------------------------------------ */\n      /* NOTE: the following displacement into the        */\n      /*       STEPLIB/RITMP working storage for the DCB  */\n      /*       may change if STEPLIB is re-assembled or   */\n      /*       additional items are added to working      */\n      /*       storage.                           07Dec95 */\n      /* ------------------------------------------------ */\n/*    pdsdcb = D2C(C2D(tcbgrs10)+224,4)  */\n      pdsdcb = D2C(C2D(tcbgrs11)+224,4)\n      /* ------------------------------------------------ */\n      dcboflgs = STORAGE(D2X(C2D(pdsdcb)+48),1)\n      dcbtiot = STORAGE(D2X(C2D(pdsdcb)+40),2)\n      If BITAND(dcboflgs,'10'x) = '10'x Then\n         stepddn = STORAGE(D2X(C2D(tiot)+C2D(dcbtiot)+4),8)\n   End\nReturn stepddn\n /**********************************************************************  */\n /* TITLE - Look for member                                               */\n /* STATUS - V1R0M0                                                       */\n /*                                                                       */\n /* FUNCTION - Search DD concatention for existence of specified          */\n /*            member.                                                    */\n /* ENVIRONMENT - MVS/SP4.2.0, TSO/E 2.4, ISPF/PDF 3.5.0                  */\n /* Dependencies - @SWAREQ (a user-written REXX function to issue the     */\n /*                SWAREQ macro to convert a 3-byte token to a 31-bit     */\n /*                address)                                               */\n /* Acknowledgements: My thanks to Dave Russell for suggesting and        */\n /*                   demonstrating the use of some of the REXX           */\n /*                   functions that I needed for this exec and with      */\n /*                   which I had been heretofore unfamilar.              */\n /* AUTHOR - Blair N. Meglathery                                          */\n /*          Technical Development Department                             */\n /*          IMS America Ltd.                                             */\n /*          Plymouth Meeting Executive Campus                            */\n /**********************************************************************  */\n /*          660 W. Germantown Pike                                       */\n /*          P.O. BOX 905                                                 */\n /*          Plymouth Meeting, PA  19462-0905                             */\n /*          U.S.A.                                                       */\n /*          Phone: (215) 834-4734                                        */\n /*                       OR                                              */\n /*                 (215) 834-5000                                        */\n /*          SHARE Installation Code: IAT                                 */\n /* DATE WRITTEN -  August 1995                                           */\n /* CHANGE ACTIVITY :                                                     */\n /*   WHEN       WHO                 WHY                                  */\n /* --------  ----------    --------------------------------------------  */\n /*  04Aug95  Meglathery    Original version                              */\n /*  10Nov95  Meglathery    Marine Corps 220th birthday. Added JES2       */\n /*                         PROCxx processing.                            */\n /*  07Dec95  Meglathery    Added STEPLIB command processing              */\n /*  28Dec95  Meglathery    Added library concatenation number to table   */\n /**********************************************************************  */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMLIST": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x12\\x00\\x95\\x19O\\x01\\x00\\x07_\\x10S\\x00?\\x00?\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-07-13T00:00:00", "modifydate": "2000-03-15T10:53:12", "lines": 63, "newlines": 63, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** DOCUMENTATION OF NEW OPTIONS                         **/\n/**********************************************************/\n/** EXEC NAME        : MEMLIST                           **/\n/** LAST MODIFIED    : 06 FEB 97                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     :  THE DSN THAT YOU WANT MEMBERS OF          **/\n/** OPTION  :  OPTION          OUTPUT PRODUCED           **/\n/**            \"NOQUOTES\" ===> THE.DSN(MEMBER)           **/\n/**             \"QUOTES\"  ===> 'THE.DSN(MEMBER)'         **/\n/**              \"ONLY\"   ===> MEMBER                    **/\n/** MASK    :  ONLY PRINT MEMBERS THAT CONTAIN THE MASK  **/\n/** LOCATION:  SPECIFIES IF THE MASK MUST OCCUR FIRST OR **/\n/**            CAN OCCUR ANYWHERE IN THE MEMBER NAME.    **/\n/**            \"ANY\"   ===> ANY MATCH IS PRINTED         **/\n/**            \"FIRST\" ===> MUST START THE MEMBER NAME   **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** REQUIRES TSO SERVICES                                **/\n/**                                                      **/\n/**********************************************************/\nARG DSN OPTION MASK LOCATION\nIF (LOCATION /= \"ANY\") & (LOCATION /= \"FIRST\") THEN DO\n/*SAY \"MEMLIST:MASK LOCATION OPTION NOT RECOGNIZED, ANY ASSUMED.\"*/\n  LOCATION = \"ANY\"\nEND\nQ = OUTTRAP('MEMBER.')\nCHANGE_NUM = 0\nADDRESS TSO \"LISTDS   '\"DSN\"' MEMBERS\"\nDO X = 1 TO MEMBER.0\n  IF MEMBER.X = \"--MEMBERS--\" THEN GONUM = X + 1\n  IF MEMBER.X = \"--MEMBERS--\" THEN LEAVE\nEND\nMEMNUM = MEMBER.0 - GONUM    /* THIS VAR IS NOT USED CURRENTLY */\nMEMNUM = MEMNUM + 1          /* THIS VAR IS NOT USED CURRENTLY */\nDO T = GONUM TO MEMBER.0\n  OUTLINE.  = \" \"\n  LINE.  = \" \"\n  MEMBER.T = STRIP(MEMBER.T)\n  THE_DSNAME = \"'\"DSN\"(\"MEMBER.T\")'\"\n  IF OPTION = \"NOQUOTES\" THEN THE_DSNAME = DSN\"(\"MEMBER.T\")\"\n  IF OPTION = \"NOQUOTE\"  THEN THE_DSNAME = DSN\"(\"MEMBER.T\")\"\n  IF OPTION = \"ONLY\"  THEN THE_DSNAME = MEMBER.T\n  Q1=INDEX(MEMBER.T,MASK)\n  /* SAY MASK Q1*/\n  IF (LOCATION = \"ANY\"),\n    & (MASK \u00ac= '') & ( Q1 = 0 ) THEN ITERATE T\n  IF (LOCATION = \"FIRST\"),\n    & (MASK \u00ac= '') & ( Q1 /= 1 ) THEN ITERATE T\n  /************************************************/\n  /** ABOVE CHECKS FOR STRING ANYWHERE IN MEMBER **/\n  /************************************************/\n  /** BELOW WILL CHECK FOR MEM BEGINING WITH MASK**/\n  /************************************************/\n  /* IF (MASK \u00ac= '') & ( Q1 /= 1 ) THEN ITERATE T */\n  /************************************************/\n  SAY THE_DSNAME\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MEMLOOK": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x000\\x00\\x99\\x02/\\x00\\x99\\x08\\x8f\\x13U\\x00\\xb0\\x00\\xb0\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-01-22T00:00:00", "modifydate": "1999-03-29T13:55:30", "lines": 176, "newlines": 176, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/***********************************************************/\n/** THIS EXEC SCANS A LIST OF DATASETS TO FIND WHETHER    **/\n/** OR NOT A CERTAIN MEMBER EXISTS IN THAT LIST. IT IS    **/\n/** VERY HANDY FOR LOCATING AN APF AUTH'D MODULE IN THE   **/\n/** APF LIST AS AN EXAMPLE!!...........     24 MAR 98     **/\n/***********************************************************/\nSAY \"__________________________________________________________\"\nSAY \"__   Memlook version 3 invoked, masking is supported    __\"\nSAY \"__________________________________________________________\"\nSAY \"__ TSO %MEMLOOK checklist memmask                       __\"\nSAY \"__ Some supported values for checklist are :            __\"\nSAY \"__ HELP/DD=ddname/APF/LINK/LPA                          __\"\nSAY \"__________________________________________________________\"\nARG THEDSN MEMNAME\nADDRESS ISPEXEC \"VGET ZSYSID\"\nsysid = zsysid\nsuffix = 00\nIF SYSID = \"SYSA\" THEN SUFFIX = \"00\"\nIF SYSID = \"SYSB\" THEN SUFFIX = \"0B\"\nIF SYSID = \"SYSC\" THEN SUFFIX = \"0C\"\nIF THEDSN = \"PROC\" THEN PROC  = \"YES\"\nALIASN.1 = \"CLIST\"    ; ALIASD.1 = \"TECH.SCA.CPROC(CLIST)\"\nALIASN.2 = \"PANELS\"   ; ALIASD.2 = \"TECH.SCA.CPROC(PANELS)\"\nALIASN.3 = \"CLISTMSN\" ; ALIASD.3 = \"TECH.MSN.DATA(CLIST)\"\nALIASN.4 = \"PANELMSN\" ; ALIASD.4 = \"TECH.MSN.DATA(PANELS)\"\nALIASN.5 = \"MSN\"      ; ALIASD.5 = \"TECH.MSN.DATA(MEMLOOK)\"\nALIASN.6 = \"APF\"      ; ALIASD.6 = \"SYS1.PARMLIB(IEAAPF\"SUFFIX\")\"\nALIASN.7 = \"LPA\"      ; ALIASD.7 = \"SYS1.PARMLIB(LPALST\"SUFFIX\")\"\nALIASN.8 = \"LINK\"     ; ALIASD.8 = \"SYS1.PARMLIB(LNKLST\"SUFFIX\")\"\nALIASN.9 = \"PROC\"     ; ALIASD.9 = \"SYS1.PROCLIB(JES2)\"\nALIASN.10 = \"NETEX\"    ; ALIASD.10 = \"TECH.SCA.CPROC(NETEX)\"\nALIASN.11 = \"HCD\"    ; ALIASD.11 = \"TECH.DAVER.CMDPROC(HCD)\"\nALIASN.0 = 11\nIF THEDSN= \"HELP\" THEN DO\n  SAY \"    Just provide a DSName that contains a DSN list in the   \"\n  SAY \"    first parm and the member name or mask in the second.    \"\n  SAY \"                                                             \"\n  SAY \"    You may also specify a DDNAME currently allocated in the \"\n  SAY \"    format: DD=xxxxxxx or DD=ALL (for all DDNames allocated) \"\n  SAY \"                                                             \"\n  SAY \"    You may also specify a JCL stream in the format:         \"\n  SAY \"    JCL=xxxx.xxxx.xxxx ( a dsname with JCL in it)            \"\n  SAY \"                                                             \"\n  SAY \"    Or you can provide a recognized alias they are :         \"\n  DO Q = 1 TO ALIASN.0\n    hold = substr(aliasn.q,1,9)\n    SAY hold \"=\" ALIASD.Q\n  END\n  EXIT 00\nEND\nDO Q = 1 TO ALIASN.0\n  if thedsn = aliasn.q then say \"Alias resolved to\" aliasd.q\n  if thedsn = aliasn.q then thedsn = aliasd.q\nEND\nMEMNAME = STRIP(MEMNAME)\nLEAD_GENERIC = \"NO\"\nIF SUBSTR(MEMNAME,1,1) = \"*\" THEN DO\n  LEAD_GENERIC = \"YES\"\n  MEMNAME = SUBSTR(MEMNAME,2)\nEND\nLENGTH_MEMNAME = LENGTH(MEMNAME)\nIF SUBSTR(MEMNAME,LENGTH_MEMNAME,1) = \"*\" THEN DO\n  GENERIC = \"YES\"\n  MEMNAME = STRIP(TRANSLATE(MEMNAME,\" \",\"*\"))\n  MEMMAX  = MEMNAME||\"99999999\"\n  MEMMAX  = SUBSTR(MEMmax,1,8)\nEND\nIF THEDSN = \" \" THEN DO\n  say \"Memlook parameters not provided, Memlook terminating.\"\n  EXIT 00\nEND\nMEMNAME = STRIP(MEMNAME)\nTHEDSN = TRANSLATE(THEDSN,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSUFFIX = \"00\"\nOPT = THEDSN\nSYSID= ZSYSID\n/* ADDRESS TSO \"CLR3270\"*/\nIF INDEX(THEDSN,\"JCL=\") = 1 THEN DO\n  PROC = \"YES\"\n  THEDSN = SUBSTR(THEDSN,5)\nEND\n/*IF THEDSN = \"JCLCA7\" THEN THEDSN = \"TECH.SCA.CPROC(JCLCA7)\"      */\n/*IF THEDSN = \"CLIST\" THEN THEDSN = \"TECH.SCA.CPROC(CLIST)\"        */\n/*IF THEDSN = \"CLISTMSN\" THEN THEDSN = \"TECH.MSN.DATA(CLIST)\"      */\n/*IF THEDSN = \"PANELS\" THEN THEDSN = \"TECH.SCA.CPROC(PANELS)\"      */\n/*IF THEDSN = \"PANELMSN\" THEN THEDSN = \"TECH.MSN.DATA(PANELS)\"     */\n/*IF THEDSN = \"MSN\" THEN THEDSN = \"TECH.MSN.DATA(MEMLOOK)\"         */\n/*IF THEDSN = \"APF\" THEN  THEDSN = \"SYS1.PARMLIB(IEAAPF\"SUFFIX\")\"  */\n/*IF THEDSN = \"LPA\" THEN  THEDSN = \"SYS1.PARMLIB(LPALST\"SUFFIX\")\"  */\n/*IF THEDSN = \"LINK\" THEN THEDSN = \"SYS1.PARMLIB(LNKLST\"SUFFIX\")\"  */\n/*IF THEDSN = \"PROC\" THEN PROC  = \"YES\"                            */\n/*IF THEDSN = \"PROC\" THEN THEDSN = \"SYS1.PROCLIB(JES2)\"            */\nENDLINE = 0\nRCODE = 0\nCOMMA = \",\"\nCALL ON ERROR NAME OOPS\nIF INDEX(THEDSN,\"DDN=\") = 1 THEN\n  THEDSN = \"DD=\"||SUBSTR(THEDSN,5)\nIF INDEX(THEDSN,\"DD=\") = 1 THEN DO\n  THEDDN = SUBSTR(THEDSN,4)\n  C = OUTTRAP('INLINE.')\n  ADDRESS TSO \"%WHATDDX\" THEDDN\n  C = OUTTRAP(OFF)\n  INLINE.1 = \"ALLOCATED TO YOUR TSO DDNAME OF \" THEDDN\nEND\nELSE DO\n  address tso \"ALLOC DDN(TEMP1) DSN('\"THEDSN\"') SHR REUS\"\n  \"EXECIO * DISKR  TEMP1 (FINIS STEM INLINE.)\"\n  \"FREE DDN(TEMP1)\"\nEND\nGOTDATA: NOP\nSAY \" \"\nsay \"Input has been read in Dataset: \" thedsn\nsay \"Input dsn has specified \"inline.0 \"datasets to be checked\"\nSAY \" \"\nHOLD = INLINE.0\nIF OPT = \"LPA\" THEN DO\n  HOLD = HOLD + 1\n  INLINE.HOLD = \"SYS1.LPALIB\"\n  HOLD = HOLD + 1\n  INLINE.HOLD = \"SYS1.NUCLEUS\"\n  INLINE.0   = INLINE.0 + 1\nEND\nIF OPT = \"LINK\" THEN DO\n  HOLD = HOLD + 1\n  INLINE.HOLD = \"SYS1.LINKLIB\"\n  INLINE.0   = INLINE.0 + 1\nEND\nDO X = 1 TO INLINE.0\n  LINE = SUBSTR(INLINE.X,1,60)\n  LINE = TRANSLATE(LINE,\" \",\",\") /* REPLACE COMMA WITH SPACES */\n  IF PROC = \"YES\" THEN DO\n    IF INDEX(LINE,\"DSN=\") = 0 THEN ITERATE X\n    PARSE VAR LINE WITH GARBAGE \"DSN=\" LINE DROPOFF\n    IF INDEX(LINE,\"&\") <> 0 THEN ITERATE X\n  END\n  say \"Checking Dataset \" line\n  DS.X = WORD(LINE,1)\n  IF DS.X = \"ALLOCATED\" THEN ITERATE X\n  IF DS.X = \"/*\" THEN ITERATE X\n  IF SYSDSN(\"'\"DS.X\"'\") /= \"OK\" THEN\n      SAY \"****  DSNAME \"ds.x\" is not accessable\"\n  IF SYSDSN(\"'\"DS.X\"'\") /= \"OK\" THEN iterate x\n  /* SAY \"LEAD_GENERIC = \" LEAD_GENERIC*/\n  IF GENERIC = \"YES\" THEN DO\n    Q = OUTTRAP(\"MEMBER.\")\n    ADDRESS TSO \"LISTDS   '\"DS.X\"' MEMBERS\"\n    DO XX = 7 TO MEMBER.0\n      IF LEAD_GENERIC = \"YES\" THEN DO\n        /*************************************************/\n        /** Above line checks to see if we are past the **/\n        /** last possible match in a dsn..dir 12 may 97 **/\n        /*************************************************/\n        IF INDEX(STRIP(MEMBER.XX),MEMNAME) > 0 THEN DO\n          SAY \"**** MEMBER \"MEMBER.XX\" WAS FOUND IN DSNAME\" DS.X\n          GOTIT = \"YES\"\n        END\n      END\n      IF LEAD_GENERIC = \"NO\" THEN DO\n        IF INDEX(STRIP(MEMBER.XX),MEMNAME) = 1 THEN DO\n          SAY \"**** MEMBER \"MEMBER.XX\" WAS FOUND IN DSNAME\" DS.X\n          GOTIT = \"YES\"\n        END\n      END\n    END\n  END\n  ELSE DO\n    IF SYSDSN(\"'\"DS.X\"(\"MEMNAME\")'\") = OK THEN DO\n      SAY \"****  MEMBER \"MEMNAME\" WAS FOUND IN DSNAME\" DS.X\n      GOTIT = \"YES\"\n    END\n  END\nEND\nIF GOTIT = \"YES\" THEN EXIT\nsay \"No Datasets were found that contained member\" memname\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGHELP": {"ttr": 14852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00Q\\x00\\x99%o\\x01\\x14\\x17O\\x14 \\x00F\\x00F\\x00\\x00\\xc7\\xd9\\xd7\\xe3\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1999-09-13T00:00:00", "modifydate": "2014-06-23T14:20:51", "lines": 70, "newlines": 70, "modlines": 0, "user": "GRPTDIR"}, "text": "/* rexx*/\narg inmsg outhelp\nif inmsg = \"\" then\n  inmsg = \"grptdir.spi.rexx(msgs)\"\nif outhelp = \"\" then\n  outhelp = \"grptdir.spi.help\"       /* the output dataset */\nlines. = 0\nlog_check = sysdsn(\"'\"outhelp\"'\")\nIF log_check  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN('\"OUTHELP\"') vol(tech03)\",\n  \"UNIT(SYSAllDA) NEW DDN(outhelp) DIR(90)\",\n  \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PO)\"\n  address tso \"free ddn(outhelp)\"\nEND\naddress tso \"alloc ddn(inmsg) dsn('\"inmsg\"') shr\"\n\"EXECIO * DISKR INmsg ( FINIS STEM HOLD.)\"\naddress tso \"free  ddn(inmsg)\"\nmsgid.0 = 0\n/***************************************/\n/**the below loop reads and divides up**/\n/**the input data.. dir 14 sep 99     **/\n/***************************************/\ndo x = 1 to hold.0\n  last_msgid = msgid\n  line = hold.x\n  if word(line,1) = \"*\" then iterate x\n  if (index(line,\"TSA\") > 0) & (index(line,\":\") > 0  ) then do\n    PARSE VAR line 'TSA' MSGID ':' MSGTEXT\n    say lastmsgid msgid\n    if last_msgid /= msgid then do\n      msgid.0 = msgid.0 + 1         /* we have another msg */\n      hold = msgid.0\n      msgid.hold = msgid            /* the array of msgid numbers */\n      lines.msgid = 0\n    end\n  end\n  lines.msgid = lines.msgid + 1 /* the # of data with this msgid */\n  hold = lines.msgid\n  out.msgid.hold = line         /* the actual data */\nend\ndo t =  1 to msgid.0\n  msgid = msgid.t\n  say \"**NEWMSGID **\"  msgid\n  output. = \"\"\n  outnum = lines.msgid\n  do v = 1 to lines.msgid\n    output.v = out.msgid.v\n    say out.msgid.v\n  end\n  output.1 = \")F \"output.1\n  outnum = outnum + 1\n  output.outnum = \")X \"\n  outnum = outnum + 1\n  output.outnum = \")O \"\n  memname = \"TSA\"msgid\n  output = outhelp\"(\"memname\")\"\n  out_check = sysdsn(\"'\"output\"'\")\n  say out_check\n  if out_check = \"MEMBER NOT FOUND\" then do\n    address tso \"alloc dsn('\"output\"') ddn(output) shr reus\"\n    ADDRESS MVS \"EXECIO \"outnum\" DISKW output (FINIS STEM output.)\"\n    address tso \"free ddn(output)\"\n  end\n  if out_check = \"OK\" then do\n    address tso \"alloc dsn('\"output\"') ddn(output) shr reus\"\n    ADDRESS MVS \"EXECIO \"outnum\" DISKW output (FINIS STEM output.)\"\n    address tso \"free ddn(output)\"\n  end\nend\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MSGS": {"ttr": 8961, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x00T\\x00\\x99%\\x7f\\x01\\x04\"_\\x10I\\x03\\x97\\x03\\x97\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1999-09-14T00:00:00", "modifydate": "2004-08-12T10:49:54", "lines": 919, "newlines": 919, "modlines": 0, "user": "COA1DIR"}, "text": "* msg index TSA000 - TSA100 TSSINI TSSUT TBMSCR TBMCMD\n*           TSA100 - TSA200 T5xICOMP\n*           TSA200 - TSA210 T5xADD\n*           TSA211 - TSA215 T5xbkup\n*           TSA216 - TSA220 T5xFLOC\n*           TSA221 - TSA230 T5xGCMD\n*           TSA231 - TSA235 T5xGDAT\n*           TSA236 - TSA240 T5xGDEL\n*           TSA241 - TSA250 T5xGREP\n*           TSA251 - TSA255 T5xINS\n*                           T5xJCARD\n*                           T5xLSTO\n*                           T5xPMENU\n*                           T5xPWHO\n*                           T5xRCON\n*                           T5xREPL\n*                           T5xTSSIM\n*                           T5xUNDEL\n*           tsa501 - tsa505 Authrun\n*           tsa506 - tsa599 various\n*\n*\n\n  TSA001I: SPI sample TSSINI used\n  Issuing routine: TSSINI\n\n  Explanation: The %TSSUT command was invoked with the parameter\n               SAMPLE which causes the T$$SAMP routine to be invoked\n               instead of the default T$$xxxx routine.\n\n  TSA002I: UNABLE TO FIND AUTHORITY DATASET:  dsname\n           SENSE CODE:  xxxxxxxx\n  Issuing routine: TSSINI\n\n  Explanation: The SCALIST dataset which contains the authorized\n               user list was unavailable. TSSINI continues with all\n               IDS having maximum panel system authority.\n\n\n  TSA003E: ERROR CALLING LOCAL T$$xxxx .TSSINI LINE =  ###\n  Issuing routine: TSSINI\n\n  Explanation: After determining the SYSID of the current system,\n              TSSINI attempted to call the REXX exec T$$xxxx\n              ( where xxxx is your SYSID). The call resulted in a\n              non zero return code.\n\n  Action:      Correct your T$$xxxx routine so it always sets a return\n               code of zero, or if you do not wish the T$$xxxx exec\n               invoked change the CUSTOM_CALL variable in TSSINI to\n               \"NO\".\n\n  TSA004E: ERROR IN VARIABLE INIT. CHECK TSSINI LINE =  ###\n  Issuing routine: TSSINI\n\n  Explanation: TSSINI encountered an error in the specified line.\n\n  Action: Review and correct the TSSINI REXX exec\n\n\n  TSA005E: RECOVERY ERROR. TSSINI TERMINATING LINE =   ###\n  Issuing routine: TSSINI\n\n  Explanation: TSSINI encountered a fatal error in the specified line.\n               TSSINI immediately terminated without setting the\n               required variables. This error is probably non\n               recoverable.\n\n  Action: Review and correct the TSSINI REXX exec\n\n  TSA006I: Invalid option, or security failure for option  opt\n  Issuing routine: TSSINI\n\n  Explanation: TSSINI did not recognize the option specified, because\n               it is not a valid option, not an authorized option,\n               or is incorrectly spelled.\n\n  Action: If option seems to be entered correctly check your authority\n          and panel tables for improper data.\n\n  TSA026W: VGET FOR  VARIABLE   vname   FAILED IN TSSUT\n           VARIABLE VARLIST MAY BE IMPROPERLY SET.\n  Issuing routine: TSSINI\n\n  Explanation: TSSINI encountered an error when attempting to VGET\n               the mentioned variable from the profile pool. This\n               VGET is attempted because the mentioned variable is\n               included in the VARLIST variable. Processing continues\n               with the mentioned variable in an uninitialized state.\n\n  Action: Ensure that the variable specified is being VPUT into the\n          profile pool in the T$$xxxx exec, or remove the value from\n          VARLIST variable and reinitialize the system to clear this\n          error.\n\n  TSA027W: Too many authorization codes provided. aborting\n\n  Issuing routine: TSSINI\n\n  Explanation: TSSINI encountered more than 20 authorization codes\n               in the AUTHCODE variable. Only the first 20 codes\n               will be processed.\n\n  Action: Ensure that the authcode variable has a maximum of 20\n          codes.\n\n  TSA028I: Trial code found for processor: #####\n\n  Issuing routine: TSSUT\n\n  Explanation: TSSUT found a trial authorization code and is using\n               that code.\n\n  Action: If you have a permanent code for this processor insure\n          it is prior to any trial codes, since the authority\n          routine stops checking upon finding a valid trial code.\n\n  TSA029I: Authorization valid until #####\n\n  Issuing routine: TSSUT\n\n  Explanation: TSSUT found an authorization code and is using\n               that code.\n\n  Action: None.\n\n  TSA030I: Function completed successfully\n\n  Issuing routine: TSSUT\n\n  Explanation: TSSUT invoked a command that has completed and NOT\n               set a completion message. This occurs when a command\n               is defined with the MSGOPT of 0 in the SRCCMD\n               definition member, or any dynamic command is invoked\n               in batch mode.\n\n  Action: No action is required, if your command is setting a message\n          and it is not displayed at completion, check the MSGOPT of\n          the command definition in the SRCCMD member.\n\n  TSA031I: function completed with a return code of xx\n\n  Issuing routine: TSSUT\n\n  Explanation: TSSUT invoked a command that has completed and NOT\n               set a completion message.  The command set a non\n               zero return code which is displayed in the message.\n               This occurs when a command is defined with the\n               MSGOPT of 0 in the SRCCMD definition member, or\n               any dynamic command is invoked in batch mode.\n\n  Action: No action is required, if your command is setting a message\n          and it is not displayed at completion, check the MSGOPT of\n          the command definition in the SRCCMD member.\n\n  TSA032E: load dataset not usable, load aborted. acid\n\n  Issuing routine: TSSUT\n\n  Explanation: A SCREENLOAD or COMMANDLOAD command was issued\n               however the ACID field did not contain a dataset\n               that was available.\n\n  Action: Confirm that the ACID field contains a valid dataset name,\n          and that you have access to it.\n\n  TSA033E: table format not dynamic, screenload not valid\n\n  Issuing routine: TSSUT\n\n  Explanation: A SCREENLOAD command was issued, however the current\n               configuration does not use the screen table as input.\n\n  Action: Confirm that the panel you are using is named SPIUTIL,\n          any other name will prevent the screen table from being\n          used. Confirm that the PANEL variable in TSSINI is set\n          correctly and not being inadvertently overwritten in\n          the T$$xxxx routine. Confirm that TABLEOPT is set\n          to TEMP.\n\n  TSA034I: All internal output will now be shown.\n\n  Issuing routine: TSSUT\n\n  Explanation: A TRAPOFF command was issued and all generated\n               messages will be show to the user.\n\n  Action: None, a TRAPOFF command will reverse this effect.\n\n  TSA035I: I am now trapping subtask created messages\n\n  Issuing routine: TSSUT\n\n  Explanation: A TRAPON command was issued and all generated\n               messages will be trapped.\n\n  Action: None, a TRAPON command will reverse this effect.\n\n  TSA036I: Failed. requires authority level xx yours is xx\n\n  Issuing routine: TSSUT\n\n  Explanation: A command was called for which the user had inadequate\n               authority.\n\n  Action: Confirm user and command authority are correctly defined\n          in the SRCCMD and SCALIST variables in TSSINI.\n\n  TSA037E: Aborted. Log is unavailable yet function requires log\n\n  Issuing routine: TSSUT\n\n  Explanation: A command was called which required the log to be\n               available, the log is not available so the command\n               is terminated.\n\n  Action: Make log available, change command definition or change\n          the global setting of LOGFAIL in TSSINI.\n\n  TSA038E: a xxxxxx field is required for this function\n\n  Issuing routine: TSSUT\n\n  Explanation: A command was called which has data requirements\n               which were not met as specified in the message text.\n               The command was not executed due to lack of data,\n               or the data was not the type required.\n\n  Action: Provided the data needed or change the command definition\n          to reflect updated data requirements in SRCCMD member.\n\n  TSA039I: Panel system standard initialization complete\n\n  Issuing routine: TSSUT\n\n  Explanation: The panel system has completed its initial setup and\n               is ready to accept commands. A full reinitialization\n               of all variables was NOT done.\n\n  Action: None. If you require all variables to be updated issue the\n          REINIT command.\n\n  TSA040I: Primary initialization successful. Variables set\n\n  Issuing routine: TSSUT\n\n  Explanation: The panel system has completed it initial setup and\n               is ready to accept commands. A full reinitialization\n               was done.\n\n  Action: None.\n\n  TSA041E: mode change failed during jobcard build.\n\n  Issuing routine: TSSUT\n\n  Explanation: While calling the TxxJCARD routine during a mode change\n               that routine returned a code of 16 indicating a failure.\n               The mode was not changed.\n\n  Action: Confirm that the DS6 and MSCA variables are contained\n          in your profile pool. ALso confirm that the dataset name\n          in DS6 is accessable to the jobcard routine.\n\n  TSA042I: mode change complete. jcl will be in xxxxxxx\n\n  Issuing routine: TSSUT\n\n  Explanation: The mode was changed to batch successfully. Any resulting\n               JCL will be contained in the dataset mentioned.\n\n\n  Action: If the dataset is incorrect check your DS5 variable and\n          update as needed.\n\n  TSA043I: mode change complete. JCL not submitted, is in xxxxx\n\n  Issuing routine: TSSUT\n\n  Explanation: The mode was changed to online successfully. Any\n               resulting JCL will be contained in the dataset\n               mentioned. The JCL has NOT been submitted.\n\n  Action: If the dataset is incorrect check your DS5 variable and\n          update as needed.\n\n  TSA044I: mode change complete. Batch stream submitted from xxxxx\n\n  Issuing routine: TSSUT\n\n  Explanation: The mode was changed to online successfully. Any\n               resulting JCL is be contained in the dataset\n               mentioned. The JCL was submitted.\n\n  Action: If the dataset is incorrect check your DS5 variable and\n          update as needed.\n\n  TSA045E: Invoked function returned a code of  xx\n\n  Issuing routine: TSSUT\n\n  Explanation: TSSUT invoked a command that has completed and NOT\n               set a completion message.  The command did however\n               set a nonzero return code which is mentioned in\n               the error message.\n\n  Action: No action is required, if your command is setting a message\n          and it is not displayed at completion, check the MSGOPT of\n          the command definition in the SRCCMD member.\n\n\n  TSA046I: ### lines of debug file info written to xxxx\n\n  Issuing routine: TSSUT\n\n  Explanation: The WRITEDEBUG command has written the debug log to\n               the dataset specified.\n\n  Action: No action is required, the log will remain in the specified\n          dataset until overwritten by another function.\n\n  TSA047E: Line ### returned a return code of ###\n\n  Issuing routine: TSSUT\n\n  Explanation: The standard error routine of TSSUT was unexpectedly\n               invoked. The line causing the error as well as the\n               return code are mentioned in the message.\n\n  Action: This is a very unusual error and usually indicates that\n          improper changes have been made to the TSSUT exec. More\n          information may be found in the debug log.\n\n  TSA048E: Possible environmental error. check tver setting\n\n  Issuing routine: TSSUT\n\n  Explanation: The standard error routine of TSSUT was unexpectedly\n               invoked with a return code of -3.\n\n  Action: This error usually indicates that a routine was called and\n          did not exist. This usually means the command definition\n          is incorrect in the SRCCMD member, the TVER variable is\n          corrupted or the routine does not exist. Check variable\n          status and command existance.\n\n  TSA049E: Warning! TSSINI has failed. variables may be corrupted\n\n  Issuing routine: TSSUT\n\n  Explanation: After returning from the TSSINI exec the variable\n               PANEL was not set. This could indicate a fatal\n               error condition.\n\n  Action: Confirm that TSSINI is functioning correctly and setting\n          the required vcariables prior to exit.\n\n  TSA050I: REXX input interpreted successfully\n\n  Issuing routine: TSSUT\n\n  Explanation: The command REXXCMD was successfully completed.\n\n  Action: NONE.\n\n  TSA051W: REXXCMD invalid, input ignored\n\n  Issuing routine: TSSUT\n\n  Explanation: The command REXXCMD was issued but was ignored\n               due to the contents of a soureline instruction.\n\n  Action: Remove the sourceline statement from the command.\n\n  TSA052I: Mode unchanged, remains online\n\n  Issuing routine: TSSUT\n\n  Explanation: The command ONLINE was issued but the current mode is\n               already online, so this command is ignored.\n\n  Action: None.\n\n  TSA053E: Table/screen mismatch, SPIMAIN displayed\n\n  Issuing routine: TSSUT\n\n  Explanation: The TSSUT routine was unable to display the panel\n               SPIUTIL because the screen table was not loaded. The\n               mode was changed to basic and processing continues.\n\n  Action: This is a mismatch between the scrload variable and the\n          panel variable. Insure the scrload variable is set correctly\n          and that the panel value is not being changed in your\n          T$$ exec.\n\n  TSA054I: Trapnum reset to value specified\n\n  Issuing routine: TSSUT\n\n  Explanation: The TRAPSET command was issued and has completed\n               successfully.\n\n  Action: None.\n\n  TSA101D: routine  xxxxxxxxxxxxx\n\n  Issuing routine: First word in message\n\n  Explanation: This message is a standard debug message for the\n               system. The text is informational and written\n               to the debug log. This message is sometimes useful to\n               troubleshoot a failure in the SPI system.\n\n  Action: None.\n\n  TSA102E: Unique ACID xxx not supported. Function aborted\n\n  Issuing routine: TxxICOMP\n\n  Explanation: The TXxICOMP routine was asked to process an\n               unsupported ACID type.\n\n  Action: Correct ACID.\n\n  TSA103I: xxxxxxxx  xxxxxxxx\n\n  Issuing routine: TxxICOMP\n\n  Explanation: The TXxICOMP routine LISTDUP function report has\n               produced a standard report.\n\n  Action: None.\n\n  TSA104E: makeacid routine aborting due to lack of user type\n             acid =  name\n  Issuing routine: TxxICOMP\n\n  Explanation: The TxxICOMP routine MAKEACID routine has encountered\n               a logic error during ACID type processing.\n\n  Action: Insure ACID is valid if in bypass mode. If you require\n          support have the text input available as well as the debug\n          log produced.\n\n  TSA105E: TSS list command failed for ACID xxxxxxxx\n\n  Issuing routine: TxxICOMP\n\n  Explanation: The TxxICOMP list logic was unable to list one of the\n               ACIDs specified.\n\n  Action: Insure all ACIDs passed are valid and under your TSS\n          authority. Be aware the exec is listing the ACIDs with\n          the ALL,EXPIRE keywords.\n\n  TSA106E: Unable to retrieve data to support bypass mode\n\n  Issuing routine: TxxICOMP\n\n  Explanation: The TxxICOMP was invoked with the parm BYPASS but was\n               unable to open the DSN that should have contained the\n               input data.\n\n  Action: Confirm that the dataset specified in variable DS1 is valid\n          and available. More information may be available in the\n          debug log, which can be viewed with the WRITEDEBUG command.\n\n  TSA107I: Translation complete, no other routine invoked\n\n  Issuing routine: TxxICOMP\n\n  Explanation: The TxxICOMP has completed the translation of the\n               specified IDs. No other task is done because no valid\n               function parm was passed, or the caller requested only\n               that translation be done.\n\n  Action: Check the spelling of the function parameter in the command\n          stream to confirm the routine was invoked properly. If the\n          caller requested only translation then this is not an error.\n\n  TSA108E: TSS command failed, check resource type, name and authority\n\n  Issuing routine: TxxICOMP\n\n  Explanation: TxxICOMP encountered an  error when issuing a TSS\n               WHOHAS command.\n\n  Action: Confirm that the resource type and resource name are correct\n          and that you have all required TSS authority. Check the\n          debug log, which can be viewed with the WRITEDEBUG command.\n\n  TSA109I: Complete. Output stream written to  dsname\n\n  Issuing routine: TxxICOMP\n\n  Explanation: TxxICOMP has finished processing the request and the\n               output was written to the dsname mentioned.\n\n  Action: None.\n\n  TSA200E: function aborted. acid not added.\n\n  Issuing routine: T5xADD\n\n  Explanation: The T5xADD exec was exited prior to completion.\n\n  Action: Check the debug log for more information.\n\n  TSA201E: Errors encountered. check ACID status\n\n  Issuing routine: T5xADD\n\n  Explanation: One or more of the commands issued during ACID creation\n          returned a non zero return code.\n\n  Action: Check the debug log for more information.\n\n  TSA202E: ACID added. no errors encountered.\n\n  Issuing routine: T5xADD\n\n  Explanation: The add routine has completed normally.\n\n  Action: None.\n\n  TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS =  status\n\n  Issuing routine: T5xBKUP\n\n  Explanation: The T5xBKUP exec was unable to open the backup DSN.\n\n  Action: Confirm that the dataset specified in variable DSBACK\n          is valid and available. More information may be available\n          in the debug log, which can be viewed with the WRITEDEBUG\n          command.\n\n  TSA221E: FAILED. STREAM IS INCOMPLETE, FAILURE IN LISTING GROUP\n\n  Issuing routine: T5xGCMD\n\n  Explanation: The T5xGCMD exec was unable to list the ACID specified.\n\n  Action: Confirm that the ACID exists and that you have the\n          required authority.\n\n  TSA222E: I HAVE RECEIVED NO INPUT FROM T5xPWHO\n\n  Issuing routine: T5xGCMD\n\n  Explanation: The T5xGCMD exec was unable to list the ACID specified.\n\n  Action: Confirm that the ACID exists and that you have the\n          required authority.\n\n  TSA223I: GROUP COMMMAND STREAM PLACED IN DSN  xxx\n\n  Issuing routine: T5xGCMD\n\n  Explanation: The T5xGCMD exec has completed successfully and the\n               generated output is in the dataset specified.\n\n  Action: None.\n\n  TSA236E: Failed. global delete cannot be run in online mode\n\n  Issuing routine: T5xGDEL\n\n  Explanation: The T5xGDEL exec has been invoked in ONLINE mode,\n               but that exec must be invoked in BATCH mode.\n               Since it generates a batch job that may need to be\n               run more than once.\n\n  Action: Change the mode and reinvoke the command.\n\n  TSA237I: function completed. output appended to batch file\n\n  Issuing routine: T5xGDEL\n\n  Explanation: The T5xGDEL exec has been invoked and completed,\n               with output appended to you standard batch JCL file.\n\n  Action: None.\n\n  TSA241W: Warning - cannot replace an ACID with itself\n\n  Issuing routine: T5xGREP\n\n  Explanation: An attempt was made to replace a profile with itself.\n               The JCL will still be generated but will be invalid.\n\n  Action: Remove the target profile from the replacing string.\n\n  TSA242W: Warning - profile was unlistable JCL may not be valid\n\n  Issuing routine: T5xGREP\n\n  Explanation: A profile was passed to the replace exec was unlistable.\n               The JCL will still be generated but will be invalid.\n\n  Action: Remove the invalid profile from the replacing string.\n\n  TSA243E: Aborted - profile was unlistable. Check validity\n\n  Issuing routine: T5xGREP\n\n  Explanation: The target profile passed to the replace exec was\n               unlistable.  The function cannot continue.\n\n  Action: Insure you have the required authority, and that the ACID\n          Is valid.\n\n  TSA244I: Replace stream generated output in  xxx\n\n  Issuing routine: T5xGREP\n\n  Explanation: The replace exec was called in ONLINE mode and has\n               completed with output routed to the mentioned DSN.\n\n  Action: None. The replace exec always generates a JCL stream, the\n          mode setting merely changes where the output is stored.\n\n  TSA245I: Replace stream appended to batchfile.\n\n  Issuing routine: T5xGREP\n\n  Explanation: The replace exec was called in BATCH mode and has\n               completed with output routed to the batch JCL file.\n\n  Action: None. The replace exec always generates a JCL stream, the\n          mode setting merely changes where the output is stored.\n\n  TSA246E: Unable to find attached ACIDs for replace stream\n\n  Issuing routine: T5xGREP\n\n  Explanation: The replace found no ACIDs attached to the specified\n               profile. The function cannot continue.\n\n  Action: Insure the ACID specified is a profile and has ACIDs\n          connected to it.\n\n  TSA251E: Failed. Insert function only supports 5 profile at a time\n\n  Issuing routine: T5xINS\n\n  Explanation: The insert function was called with more than 5\n               profiles to be inserted.\n\n  Action: Specify only 5 profile for insertion.\n\n  TSA252E: Function aborted. xxxxx is not an owned profile\n\n  Issuing routine: T5xINS\n\n  Explanation: The insert function was called with an invalid\n               profile to be inserted.\n\n  Action: Confirm that the profile exists and you have authority\n          over it.\n\n  TSA253E: Failed. Delete requested but xxxx not removed from ACID xxxx\n\n  Issuing routine: T5xINS\n\n  Explanation: The insert function was called to remove a profile\n               from the specified ACID, but the remove command\n               failed.\n\n  Action: Confirm that the profile is attached to the ACID, and you\n          have authority to remove it. The debug log should contain\n          a detailed message from the security package to indicate\n          what the error was.\n\n  TSA254I: xxxxx inserted in xxxx  at position xxxx\n\n  Issuing routine: T5xINS\n\n  Explanation: The insert function was called to insert a profile\n               and has completed successfully.\n\n  Action: None.\n\n  TSA501E: DSN xxxx is unavailable, status = xxxxx\n\n  Issuing routine: AUTHRUN\n\n  Explanation: The Authrun routine is unable to execute because the\n               dataset mentioned in the message is unavailable. The\n               specific dataset status is in the message.\n\n  Action: Make sure the dataset passed to authrun in the invocation is\n          valid.\n\n  TSA502I: Authrun xxxxx substitution string found in stream\n\n  Issuing routine: AUTHRUN\n\n  Explanation: The Authrun routine has found a $$ string in the\n               command stream and is replacing it with a new value.\n\n  Action: None.\n\n  TSA503I: Authrun resolved command is xxxxx\n\n  Issuing routine: AUTHRUN\n\n  Explanation: The Authrun routine has finished command resolution\n               and the result is shown.\n\n  Action: None.\n\n  TSA504I: Authrun issuing command\n\n  Issuing routine: AUTHRUN\n\n  Explanation: The Authrun is issuing the resolved command mentioned\n               in the TSA503I message.\n\n  Action: None.\n\n  TSA505I: Sum of all return codes is xx\n\n  Issuing routine: AUTHRUN\n\n  Explanation: The Authrun is has issued all commands in the stream\n               and the combined return code is specified.\n\n  Action: If the code is not zero you should determine which command\n          had the non zero code and research that command.\n\n  TSA506W: BPXWIRAC returned negative return code of\n\n  Issuing routine: various\n\n  Explanation: The BPXWIRAC exec was called and set a negative\n               return code. This exec should return a code which\n               indicates the highest UID currently in use for an\n               ACID defined to the security package.\n\n  Action: Map the code to the action below:\n\n\n         -3  The routine was not found, confirm BPXWIRAC is in\n             your SYSEXEC or SYSPROC concatenation.\n\n  TSA507E: HIGHUID omvstabs modify failed.. unable to determine\n           next uid. HIGHUID terminating\n\n  Issuing routine: HIGHUID\n\n  Explanation: During HIGHUID processing a TSS MODIFY OMVSTABS\n               was issued and returned a non zero return code.\n\n  Action: This is probably due to a lack of TSS authority, if\n          so any preceding TSS messages should be reviewed.\n\n  TSA508E: Fatal error, no group specified and vget for defgroup failed\n\n  Issuing routine: GIVEUID\n\n  Explanation: The GIVEUID exec was unable to determine the default\n               group and terminated processing.\n\n  Action: Invoke the GIVEUID exec with a valid group or set the\n          DEFGROUP variable in your profile pool.\n\n  TSA509E: Command not processed. check commands validity\n\n  Issuing routine: T5xCMDO\n\n  Explanation: The command passed to T5xCMDO finished with a non zero\n               return code.\n\n  Action: Insure the command is valid and reissue T5xCMDO.\n\n  TSA510E: xxxxxxx has ended abnormally\n\n  Issuing routine: various\n\n  Explanation: The invoked command mentioned in the error message ended\n               abnormally.\n\n  Action: Check the debug log for more detailed information. This\n          message usually indicates that the exec encountered an\n          error during initialization.\n\n  TSA511I: Batch file updated with delete stream for acid\n\n  Issuing routine: T5xDEL\n\n  Explanation: The delete command appended the created output stream\n               to the current batch file.\n\n  Action: None.\n\n  TSA512E: Provided dataset invalid xxx\n\n  Issuing routine: GETBACKU\n\n  Explanation: The dataset specified is not accessable\n\n  Action: Confirm DSN availability and your authority\n\n  TSA513I: Backup data restored, resides in\n\n  Issuing routine: GETBACKU\n\n  Explanation: The copy was completed\n\n  Action: None\n\n  TSA514I: Command issued output resides in: xxx\n\n  Issuing routine: T5xCMDO\n\n  Explanation: The command passed to T5xCMDO finished and the output\n               resides in the mentioned dataset\n\n  Action: None\n\n  TSA515W: Unsupported function completed. Output in xxxxx\n\n  Issuing routine: T5xCON\n\n  Explanation: You have invoked the unsupported version of the convert\n               routine and it has completed nornally.\n\n  Action: If you were specifically invoking the old routine this\n          message is normal. If you were trying to invoke the current\n          version you should check the CORECMD member of the delivered\n          parmlib and copy the convert command entry to your SRCCMD\n          member and reinvoke SPI .\n\n  TSA516E: Expert function is unavailable in basic mode.\n\n  Issuing routine: TSSUT\n\n  Explanation: An attempt was made to call an expert level function\n               from a basic mode panel which is invalid.\n\n  Action: Invoke the equivalent basic mode function or change the\n          expert level function so that it does not pass any of the\n          variables ACID DATA or DATA2. Since the basic mode panels\n          have no way to retrieve these variables.\n\n  TSA517I: Popup panel aborted, function stopped.\n\n  Issuing routine: TSSUT\n\n  Explanation: The popup panel set a non zero return code, so the\n               selected function did not continue.\n\n  Action: Input the required data on the popup panel and hit enter,\n          do not hit PF3 or otherwise exit the panel prematurely.\n\n  TSA518I: Mode changed due to user request.\n\n  Issuing routine: TSSUT\n\n  Explanation: The panel display mode was changed to expert or basic\n               because of a specific user command.\n\n  Action: None.\n\n  TSA519W: xxxxxxxx\n\n  Issuing routine: TSSUT\n\n  Explanation: This message occurs when the MSGOPT of a command in\n               the SRCCMD is set to DATA, and the user is in basic\n               presentation mode. The DATA parm is used in expert mode\n               to return data in the ACID panel field, since there is\n               no ACID field in basic mode the additional data will\n               overlay the normal message area. This in effect\n               prevents this routine from setting a message that the\n               user will ever see.\n\n  Action: The debug log will contain the original message the routine\n          set prior to the overlay.\n\n  TSA520D: Overlaying xxxxx SECRC= xxx\n\n  Issuing routine: TSSUT\n\n  Explanation: This message documents the overlay that occurs as a\n               result of msg TSA519W. See that msg for more details.\n\n\n  Action: None.\n\n  TSA521I: Permit function successful for id  acid\n\n  Issuing routine: T5xPER\n\n  Explanation: A permit command was issued from T5xPER and returned a\n               condition code of 0.\n\n  Action: None.\n\n  TSA522I: Permit function returned a non zero return code of xxx\n\n  Issuing routine: T5xper\n\n  Explanation: A permit command was issued from T5xPER and returned a\n               non zero return code as specified in the message text.\n\n  Action: Review the debug log using WRITEDEBUG and see why the command\n          failed.\n\n  TSA523I: Sample authority stream created output is in xxxxx\n\n  Issuing routine: T5xicomp\n\n  Explanation: A makeauth command was issued and the output resides\n               in the mentioned dataset.\n\n  Action: Customize the output and place it in your authority stream\n          dataset.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PARSE": {"ttr": 4098, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x00\\t\\x1f\\x01\\x00\\t\\x1f\\x13\\x06\\x00\\x04\\x00\\x04\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-03-31T00:00:00", "modifydate": "2000-03-31T13:06:45", "lines": 4, "newlines": 4, "modlines": 0, "user": "*SPIV8*"}, "text": "PARSE VAR INLINE  W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12\nPARSE VAR SECDEF.T H1 '(' DROPOFF\nPARSE VAR LINE 'DSN=' DSNAME ',' DROPOFF\nPARSE VAR INPUT V1 '.' V2 '.' V3 '.'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "POPEXP": {"ttr": 2853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x007\\x00\\x99)_\\x00\\x991?\\x10V\\x00\\x13\\x00\\x13\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "1999-11-09T10:56:37", "lines": 19, "newlines": 19, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") \"\ntitle   = \"    Expert data function panel\"\ntitle1  = \"Specify the ACID value\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the DATA value\"\nvname2  = \"DATA\"\ntitle3  = \"Specify the DATA2 value\"\nvname3  = \"DATA2\"\nDATAREQ = \"0 0 0 0 0 0 \"\nputvars = \"title title1 title2 title3\"\nputvars = putvars \"vname1 vname2 vname3 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\naddress  ispexec \"vget (\"putvars\") profile\"\nsay vname1 vname2 vname3 datareq\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POPVER": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00V\\x01\\x00\\x10/\\x01\\x00\\x10/\\x10\\x13\\x00\\x1d\\x00\\x1d\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2000-04-11T00:00:00", "modifydate": "2000-04-11T10:13:56", "lines": 29, "newlines": 29, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nsignal off error\nallvars = allvars \"v1 v2 v3 v4 v5 v6\"\n/* address  ispexec \"vget (\"allvars\") profile\"  */\nallvars = allvars \"ver1 ver2 ver3 ver4 ver5 ver6\"\nv1 = \"hello\"\nver1 = \"type(char)\"\n/* address  ispexec \"vget (\"allvars\") profile\"  */\n/*possible values for ver.                                          */\n/*                                                                  */\n/* ONEOF( valid value list )                                        */\n/* TYPE( char  num )                                                */\n/* length(wordnum,maxlength)                                        */\n/*                                                                  */\n/*                                                                  */\n/*                                                                  */\ndo t = 1 to 6\n  hold = \"v\"t\n  hold1 = \"ver\"t\n  verify_value = value(hold1)\n  screen_value = value(hold)\n  upper screen_value verify_value\n  say   screen_value verify_value\n  do x = 1 to words(verify_value)\n    select when index(verify_value,\"TYPE\") /= 0  then do\n    end\n  end\nend\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP001": {"ttr": 2861, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x008\\x00\\x99)?\\x00\\x991O\\x10P\\x00\\x18\\x00\\x18\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-20T00:00:00", "modifydate": "1999-11-10T10:50:38", "lines": 24, "newlines": 24, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\naddress  ispexec \"vget opt profile\"\nif opt = \"MAKEAUTH\" then do\n  makeauth = \"YES\"\n  address ispexec \"vput makeauth profile\"\nend\ntitle   = \"Convert routine query screen.\"\ntitle1  = \"Specify the target ACID(s) or BYPASS to use work DSN #1\"\nif opt = \"MAKEAUTH\" then do\n  makeauth = \"YES\"\n  address ispexec \"vput makeauth profile\"\n  title   = \"Makeauth screen.\"\n  title1  = \"Specify the target ACID(s) or BYPASS to use work DSN #1\"\nend\nvname1  = \"ACID(s) \"\ndatareq = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"datareq vname1 vname2\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP002": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x03\\x00\\x99)O\\x00\\x990\\x7f\\tR\\x00\\x10\\x00\\x10\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-21T00:00:00", "modifydate": "1999-11-03T09:52:03", "lines": 16, "newlines": 16, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Resource Conversion routine query screen.\"\ntitle1  = \"Specify the resource type (example DSN)\"\nvname1  = \"Type   \"\ntitle2  = \"Specify the resource name (example SYS1.PARMLIB)\"\nvname2  = \"Name   \"\nDATAREQ = \"CHAR CHAR\"\naddress ispexec \"vput datareq profile\"\nputvars = \"title title1 title2 \"\nputvars = putvars \"vname1 vname2 \"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP003": {"ttr": 3330, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x03\\x00\\x99)O\\x01\\x00\\x07_\\x16\\x04\\x00\\x11\\x00\\x11\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-10-21T00:00:00", "modifydate": "2000-03-15T16:04:03", "lines": 17, "newlines": 17, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"ACID List data screen\"\ntitle1  = \"Specify the SINGLE ACID to LIST\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the data (example ALL XAUTH BASIC NAME)\"\nvname2  = \"Data type\"\nv2 = \"ALL\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 v2\"\ndatareq = \"CHAR CHAR\"\naddress ispexec \"vput datareq profile\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP004": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x15\\x00\\x99)O\\x00\\x990\\x7f\\tR\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-21T00:00:00", "modifydate": "1999-11-03T09:52:15", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Authority Stream data menu \"\ntitle1  = \"Specify the SINGLE ACID as a target of the stream\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the member name where the stream resides\"\nvname2  = \"Member\"\ndatareq = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP005": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00 \\x00\\x99)_\\x00\\x990\\x7f\\tR\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "1999-11-03T09:52:20", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Suspension Removal Panel \"\ntitle1  = \"Specify the SINGLE ACID for SUSPEND and ASUSPEND removal\"\nvname1  = \"ACID\"\ndatareq = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP006": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00$\\x00\\x99)_\\x00\\x990\\x7f\\tR\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "1999-11-03T09:52:24", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Expiration Removal Panel \"\ntitle1  = \"Specify the SINGLE ACID for Expiration removal\"\nvname1  = \"ACID\"\ndatareq = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP007": {"ttr": 8199, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x10\\x00\\x99)_\\x01\\x03&\\x0f\\x10&\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "2003-09-17T10:26:10", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Expiration addition panel\"\ntitle1  = \"Specify the SINGLE ACID to add expiration date\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the expiration date (mm/dd/yy)\"\nvname2  = \"Expire\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP008": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x002\\x00\\x99)_\\x00\\x990\\x7f\\tR\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "1999-11-03T09:52:32", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Expiration/suspension password reset panel\"\ntitle1  = \"Specify the SINGLE ACID to be reset\"\nvname1  = \"ACID\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP009": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00S\\x00\\x99)_\\x01\\x03&\\x0f\\x106\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "2003-09-17T10:36:53", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \" Acid PW interval update panel\"\ntitle1  = \"Specify the SINGLE ACID for new password interval\"\nvname1  = \"ACID\"\ntitle2  = \"The # of days passwords are to be valid for this ACID\"\nvname2  = \"#DAYS\"\nDATAREQ = \"CHAR NUM\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP010": {"ttr": 3081, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x16\\x00\\x99)_\\x00\\x994?\\x10\\x01\\x00\\x13\\x00\\x13\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "1999-12-09T10:01:16", "lines": 19, "newlines": 19, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \" Profile Addition screen \"\ntitle1  = \"Specify the SINGLE ACID to receive profile(s)\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the profile(s) to add to ID\"\nvname2  = \"Profiles\"\ntitle3  = \"Specify the numeric location ( a 0 will remove the profile)\"\nvname3  = \"location\"\ntitle4  = \"Duration of profile authority ( default = permanent ) \"\nvname4  = \"Days \"\nDATAREQ = \"CHAR CHAR NUM\"\nputvars = \"title title1 title2 title3 title4\"\nputvars = putvars \"vname1 vname2 vname3 vname4 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP011": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00E\\x00\\x99)_\\x00\\x990\\x7f\\tR\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "1999-11-03T09:52:45", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \" Profile removal screen \"\ntitle1  = \"Specify the SINGLE ACID to remove profile(s)\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the profile(s) to be removed\"\nvname2  = \"Profiles\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP012": {"ttr": 2833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00I\\x00\\x99)_\\x00\\x990\\x7f\\tR\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-22T00:00:00", "modifydate": "1999-11-03T09:52:49", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \" ID backup Screen\"\ntitle1  = \"Specify the SINGLE ACID to be backed up.\"\nvname1  = \"ACID\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP013": {"ttr": 2835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00S\\x00\\x99)o\\x00\\x990\\x7f\\tR\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-23T00:00:00", "modifydate": "1999-11-03T09:52:53", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Asuspend attribute addition panel\"\ntitle1  = \"Specify the SINGLE ACID to add the admin suspend field\"\nvname1  = \"ACID\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1 \"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP014": {"ttr": 3085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00H\\x00\\x990O\\x01\\x00\\x00O\\x11\\x18\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-10-31T00:00:00", "modifydate": "2000-01-04T11:18:48", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Dataset permission panel \"\ntitle1  = \"Specify the SINGLE ACID as command target\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the Dataset name for permission\"\nvname2  = \"Dataset\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP015": {"ttr": 8451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x07\\x00\\x990_\\x01\\x04\\x03O\\x11Y\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-11-01T00:00:00", "modifydate": "2004-02-03T11:59:07", "lines": 13, "newlines": 13, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"ACID deletion panel ( with backup ) \"\ntitle1  = \"Specify the ACID to delete\"\nvname1  = \"ACID\"\nDATAREQ = \"ANY\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP016": {"ttr": 2837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x07\\x00\\x990_\\x00\\x990\\x7f\\tS\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-01T00:00:00", "modifydate": "1999-11-03T09:53:07", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Group JCL stream creation panel\"\ntitle1  = \"Specify the owning ACID (profile dept or division)\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the command, include the string ' $$ '\"\nvname2  = \"Command \"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP017": {"ttr": 3087, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x006\\x00\\x991/\\x01\\x00\\x00O\\x11)\\x00\\x15\\x00\\x15\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-11-08T00:00:00", "modifydate": "2000-01-04T11:29:36", "lines": 21, "newlines": 21, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Volume permission panel \"\ntitle1  = \"Specify the SINGLE ACID to receive permission\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the Volume name or mask using (g) for generics\"\nvname2  = \"Volume\"\nDATAREQ = \"CHAR CHAR\"\naddress  ispexec \"vget opt profile\"\nif opt = \"VOLREVOKE\" then do\n  title   = \"Volume permission revoke panel\"\n  title1  = \"Specify the SINGLE ACID to Lose the permission\"\n  title2  = \"Specify the Volume affected\"\nend\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP018": {"ttr": 2841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00&\\x00\\x991/\\x00\\x991/\\x08W\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-08T00:00:00", "modifydate": "1999-11-08T08:57:26", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"ACID deletion panel ( with NO backup ) \"\ntitle1  = \"Specify the ACID to delete\"\nvname1  = \"ACID\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP019": {"ttr": 8964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00S\\x00\\x991/\\x01\\x044?\\x08D\\x00\\x12\\x00\\x12\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1999-11-08T00:00:00", "modifydate": "2004-12-08T08:44:53", "lines": 18, "newlines": 18, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\naddress ispexec \"vget defgroup profile\"\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"UID addition screen \"\ntitle1  = \"Specify the ACID for UID addition.\"\nvname1  = \"ACID\"\ntitle2  = \"Specify group for the ACID, leave blank for\" defgroup\nif defgroup = \"\" then\ntitle2  = \"Specify group for the ACID, since no default group exists.\"\nvname2  = \"OMVS Group\"\nDATAREQ = \"NUM CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP020": {"ttr": 2845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00D\\x00\\x991/\\x00\\x991/\\x10\\t\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-08T00:00:00", "modifydate": "1999-11-08T10:09:44", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Backup retrieval screen.\"\ntitle1  = \"Specify member name ( ACID ) of backup to retrieve\"\nvname1  = \"Member\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1 \"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP021": {"ttr": 2847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00W\\x00\\x991?\\x00\\x991?\\x08U\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-09T00:00:00", "modifydate": "1999-11-09T08:55:57", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Command output trapping screen\"\ntitle1  = \"Specify the command as you would under ISPF option 6.\"\nvname1  = \"Command text\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1 \"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP022": {"ttr": 11011, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00Q\\x00\\x991?\\x01\\x06\\x07/\\x10\"\\x00\\x11\\x00\\x11\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-11-09T00:00:00", "modifydate": "2006-03-13T10:22:51", "lines": 17, "newlines": 17, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Facility Bypass modification menu\"\ntitle1  = \"Specify the TSS facility to be the target of this command\"\nvname1  = \"Facility name\"\ntitle2  = \"Specify the type of bypass entry to update example - OTRAN \"\nvname2  = \"Resource type\"\ntitle3  = \"Specify the actual resource name to update example - CEMT \"\nvname3  = \"Resource Name\"\nDATAREQ = \"CHAR CHAR CHAR\"\nputvars = \"title title1 title2 title3\"\nputvars = putvars \"vname1 vname2 vname3 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP023": {"ttr": 2851, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00H\\x00\\x991?\\x00\\x991?\\x10Q\\x00\\x10\\x00\\x10\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-09T00:00:00", "modifydate": "1999-11-09T10:51:48", "lines": 16, "newlines": 16, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Facility modification menu\"\ntitle1  = \"Specify the TSS facility to be the target of this command\"\nvname1  = \"Facility name\"\ntitle2  = \"Specify the command portion- TSS MODIFY FAC(facname=COMMAND)\"\nvname2  = \"The command\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nsay \"vput rc is \" rc\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP024": {"ttr": 2849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00!\\x00\\x991?\\x00\\x991?\\x10C\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-09T00:00:00", "modifydate": "1999-11-09T10:43:21", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Facility List menu\"\ntitle1  = \"Specify the TSS facility to be listed\"\nvname1  = \"Facility name\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP025": {"ttr": 2855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00 \\x00\\x991?\\x00\\x991?\\x14\\x00\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-09T00:00:00", "modifydate": "1999-11-09T14:00:20", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"STC ACID addition screen\"\ntitle1  = \"Specify the STC name ( member name ) \"\nvname1  = \"STC name\"\ntitle2  = \"Specify the ACID name to be associated with the STC\"\nvname2  = \"ACID name\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP026": {"ttr": 2857, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x006\\x00\\x991?\\x00\\x991?\\x14\\x04\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-09T00:00:00", "modifydate": "1999-11-09T14:04:36", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"STC ACID removal screen\"\ntitle1  = \"Specify the STC name to be removed from STC record\"\nvname1  = \"STC name\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP027": {"ttr": 2859, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00 \\x00\\x991?\\x00\\x991?\\x14R\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-09T00:00:00", "modifydate": "1999-11-09T14:52:20", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Group deletion screen\"\ntitle1  = \"Specify the department or division for deletion\"\nvname1  = \"Target ACID\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP028": {"ttr": 14854, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x10\\x00\\x991O\\x01\\x14\\x17o\\x13Q\\x00F\\x00F\\x00\\x00\\xc7\\xd9\\xd7\\xe2\\xc5\\xd4\\xc4@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1999-11-10T00:00:00", "modifydate": "2014-06-25T13:51:10", "lines": 70, "newlines": 70, "modlines": 0, "user": "GRPSEMD"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\naddress  ispexec \"vget opt profile\"\ntitle   = \"Logon proc removal panel\"\ntitle1  = \"Specify the ACID to remove authority\"\nvname1  = \"Target ACID\"\ntitle2  = \"Specify the TSOPROC to be removed\"\nvname2  = \"TSO procname\"\nif opt = \"ADDLOGON\" then do\n  title   = \"Logon proc addition panel\"\n  title1  = \"Specify the ACID to receive authority\"\n  title2  = \"Specify the TSOPROC to be added\"\nend\nDATAREQ = \"CHAR CHAR\"\nif opt = \"ADDACCOUNT\" then do\n  title   = \"Account number addition panel\"\n  title1  = \"Specify the ACID to receive authority\"\n  title2  = \"Specify the account number to be authorized\"\n  vname2  = \"Account num\"\n  DATAREQ = \"CHAR 1\"\nend\nif opt = \"REMACCOUNT\" then do\n  title   = \"Account number removal panel\"\n  title1  = \"Specify the ACID to remove authority\"\n  title2  = \"Specify the account number to be remove\"\n  vname2  = \"Account num\"\n  DATAREQ = \"CHAR 1\"\nend\nif opt = \"ADDAUTH\" then do\n  title   = \"TSO authority permission addition panel\"\n  title1  = \"Specify the ACID to receive authority\"\n  title2  = \"Specify the permission ( JCL OPER ACCT MOUNT or RECOVER)\"\n  vname2  = \"Authority\"\n  DATAREQ = \"CHAR CHAR\"\nend\nif opt = \"ADDLSIZE\" then do\n  title   = \"TSO authority default region size panel\"\n  title1  = \"Specify the ACID for region size change\"\n  title2  = \"Specify the new default region size\"\n  vname2  = \"Region size\"\n  DATAREQ = \"CHAR NUM\"\nend\nif opt = \"ADDMSIZE\" then do\n  title   = \"TSO authority maximum region size panel\"\n  title1  = \"Specify the ACID for maximum TSO size change\"\n  title2  = \"Specify the new Maximum region size\"\n  vname2  = \"Region size\"\n  DATAREQ = \"CHAR NUM\"\nend\nif opt = \"ADDUNIT\" then do\n  title   = \"TSO default unit addition \"\n  title1  = \"Specify the ACID for unit change\"\n  title2  = \"Specify the new default unit\"\n  vname2  = \"Unit\"\n  DATAREQ = \"CHAR CHAR\"\nend\nif opt = \"REMAUTH\" then do\n  title   = \"TSO authority permission removal panel\"\n  title1  = \"Specify the ACID to remove authority\"\n  title2  = \"Specify the permission ( JCL OPER ACCT MOUNT or RECOVER)\"\n  vname2  = \"Authority\"\n  DATAREQ = \"CHAR CHAR\"\nend\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP029": {"ttr": 2863, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x006\\x00\\x991o\\x00\\x991o\\x14X\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-12T00:00:00", "modifydate": "1999-11-12T14:58:36", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Default password reset screen\"\ntitle1  = \"Specify the ACID for password reset \"\nvname1  = \"Target ACID\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP030": {"ttr": 2865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x16\\x00\\x992\\x0f\\x00\\x992\\x0f\\t\\x10\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-16T00:00:00", "modifydate": "1999-11-16T09:10:16", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"ACID addition screen\"\ntitle1  = \"Specify the ACID to add to the database\"\nvname1  = \"ACID\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP031": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x06\\x00\\x992\\x1f\\x00\\x992\\x1f\\t\\x18\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-17T00:00:00", "modifydate": "1999-11-17T09:18:06", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Global profile replace stream generation menu\"\ntitle1  = \"Specify the profile to be replaced\"\nvname1  = \"Profile\"\ntitle2  = \"Specify the replacement profiles ( 5 maximum)\"\nvname2  = \"New Profiles\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP032": {"ttr": 3095, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x00\\x06o\\x01\\x00\\x06o\\t\\x11\\x00\\r\\x00\\r\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-03-06T00:00:00", "modifydate": "2000-03-06T09:11:40", "lines": 13, "newlines": 13, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Profile Modification menu\"\ntitle1  = \"Specify the profile to be modified\"\nvname1  = \"Profile\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP033": {"ttr": 3097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x07\\x01\\x00\\x06\\x8f\\x01\\x00\\x06\\x8f\\t\\x06\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-03-08T00:00:00", "modifydate": "2000-03-08T09:06:07", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Home directory specification menu\"\ntitle1  = \"Specify the ACID to overlay home directory entry\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the new home directory\"\nvname2  = \"HFS directory\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP034": {"ttr": 4631, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00A\\x01\\x00\\x16\\x7f\\x01\\x00\\x16\\x7f\\x08X\\x00\\x17\\x00\\x17\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2000-06-15T08:58:41", "lines": 23, "newlines": 23, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\naddress  ispexec \"vget opt profile\"\ntitle   = \"NVAS ID addition panel\"\ntitle1  = \"Specify the ID to add to NVAS\"\nvname1  = \"USERID\"\ntitle2  = \"Specify the IDs default Group\"\nvname2  = \"Group\"\nDATAREQ = \"CHAR CHAR\"\nif opt = \"NVADDG\" then do\n  title   = \"NVAS Group creation panel\"\n  title1  = \"Specify the Group to create \"\n  title2  = \" \"\n  Vname2  = \" \"\n  DATAREQ = \"CHAR\"\nend\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP035": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x01\\x05O\\x01\\x01\\x05O\\t3\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-02-23T00:00:00", "modifydate": "2001-02-23T09:33:31", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"ACID Clone data entry Panel\"\ntitle1  = \"Specify the Currently existing ACID for model.\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the ACID for creation\"\nvname2  = \"NEWACID\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP036": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\x01\\t/\\x01\\x01\\t/\\x136\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-04-02T00:00:00", "modifydate": "2001-04-02T13:36:36", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Makelike data entry Panel\"\ntitle1  = \"Specify the ACID to create.\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the ACID to be used as a model.\"\nvname2  = \"USING\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP037": {"ttr": 7171, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x03\\x02\\x9f\\x01\\x03\\x02\\x9f\\x11\\x17\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-01-29T00:00:00", "modifydate": "2003-01-29T11:17:01", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Add Facility panel \"\ntitle1  = \"Specify the ACID as command target\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the Facility to be added to ACID\"\nvname2  = \"FACILITY\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP038": {"ttr": 8457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x04\\x05O\\x01\\x04\\x05O\\x13\\x06\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-23T00:00:00", "modifydate": "2004-02-23T13:06:03", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Change TSS ACID name panel \"\ntitle1  = \"Specify the ACID for name change\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the NEW name WITHOUT quotes\"\nvname2  = \"NAME\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP039": {"ttr": 8459, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x04\\x05O\\x01\\x04\\x05O\\x13\\x10\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-02-23T00:00:00", "modifydate": "2004-02-23T13:10:21", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Change TSS ACID Employee Number change panel\"\ntitle1  = \"Specify the ACID for Employee Number change\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the NEW employee number\"\nvname2  = \"NAME\"\nDATAREQ = \"CHAR NUM\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP040": {"ttr": 10761, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00V\\x01\\x05\\x08\\x7f\\x01\\x05\\x08\\x7f\\x10\\x17\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-28T00:00:00", "modifydate": "2005-03-28T10:17:56", "lines": 13, "newlines": 13, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Custom NVAS user report panel\"\ntitle1  = \"Specify the Email address for report delivery\"\nvname1  = \"EMAIL\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP041": {"ttr": 10777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00E\\x01\\x05\\x08\\x7f\\x01\\x06\\x02o\\x080\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2005-03-28T00:00:00", "modifydate": "2006-01-26T08:30:45", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Custom department report panel\"\ntitle1  = \"Specify the Email address for report delivery\"\nvname1  = \"EMAIL\"\ntitle2  = \"Specify the TSS ACID (Dept or Profile) to query\"\nvname2  = \"Department\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP042": {"ttr": 10763, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00E\\x01\\x05\\tO\\x01\\x05\\tO\\x122\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-04-04T00:00:00", "modifydate": "2005-04-04T12:32:45", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"TSS in storage REFRESH panel\"\ntitle1  = \"Specify the ACID image to be refreshed\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the ACTIVE JOBNAME( If a TSO then ID)\"\nvname2  = \"JOBNAME\"\nDATAREQ = \"CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP043": {"ttr": 10765, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x05\\x11_\\x01\\x05\\x11_\\x103\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-04-25T00:00:00", "modifydate": "2005-04-25T10:33:43", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"JESSPOOL ID authorization panel\"\ntitle1  = \"Specify the ACID to gain/lose the authority\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the IDs spool datasets to be given/removed\"\nvname2  = \"OWNED ID\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP044": {"ttr": 10767, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x007\\x01\\x05\\x11_\\x01\\x05\\x11_\\x108\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-04-25T00:00:00", "modifydate": "2005-04-25T10:38:37", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"JESSPOOL JOBNAME authorization panel\"\ntitle1  = \"Specify the ACID to gain/lose the authority\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the JOBNAMEs  to be given/removed\"\nvname2  = \"OWNED JOB\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP045": {"ttr": 10773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x000\\x01\\x051/\\x01\\x052\\x7f\\x10\\x05\\x00\\x13\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2005-11-08T00:00:00", "modifydate": "2005-11-23T10:05:30", "lines": 19, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Whohas resource panel\"\ntitle1  = \"Specify the resource type.. ie otran\"\nvname1  = \"type\"\ntitle2  = \"Specify the resource name.. ie CEMT\"\nvname2  = \"rname\"\ntitle3  = \"Specify a work dsn for interim output \"\nvname3  = \"wdsn\"\ntitle4  = \"Specify the full output DSN with no quotes ( wide lrecl)\"\nvname4  = \"Odsn\"\nDATAREQ = \"CHAR CHAR CHAR CHAR\"\nputvars = \"title title1 title2 title3 title4\"\nputvars = putvars \"vname1 vname2 vname3 vname4 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP046": {"ttr": 13063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x07\\x13o\\x01\\x07\\x13o\\x08%\\x00\\x0f\\x00\\x13\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2007-05-16T00:00:00", "modifydate": "2007-05-16T08:25:00", "lines": 15, "newlines": 19, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Change TSS ACID LANID field in INSTDATA\"\ntitle1  = \"Specify the ACID for LANID change\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the NEW LAN ID\"\nvname2  = \"NAME\"\nDATAREQ = \"CHAR CHAR\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP047": {"ttr": 13333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x11\\x01\\x07\"/\\x01\\x071\\x9f\\x08#\\x00\\x11\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2007-08-10T00:00:00", "modifydate": "2007-11-15T08:23:11", "lines": 17, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6 sname\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Add a NVAS ID to TOP SECRET\"\ntitle1  = \"Specify the userid to be added.\"\nvname1  = \"ACID\"\ntitle2  = \"Specify the EMP # or 0 or valid bypass value.\"\nvname2  = \"Employee #\"\ntitle3  = \"Specify the name of the ID\"\nvname3  = \"NAME\"\nDATAREQ = \"CHAR ANY 0\"\nputvars = \"title title1 title2 title3\"\nputvars = putvars \"vname1 vname2 vname3 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP048": {"ttr": 13319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01\\x070?\\x01\\x070?\\x08T\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-10-30T00:00:00", "modifydate": "2007-10-30T08:54:55", "lines": 13, "newlines": 13, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Employee number query\"\ntitle1  = \"Specify the full employee number .\"\nvname1  = \"ENUM\"\nDATAREQ = \"ANY\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "POP049": {"ttr": 13327, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x071\\x0f\\x01\\x071\\x0f\\x12%\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2007-11-06T00:00:00", "modifydate": "2007-11-06T12:25:59", "lines": 15, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* rexx */\nallvars = \"title title1 title2 title3 title4 title5 title6\"\nsignal off error\nallvars = allvars \"vname1 vname2 vname3 vname4 vname5 vname6\"\naddress  ispexec \"verase (\"allvars\") profile\"\ntitle   = \"Email dataset screen\"\ntitle1  = \"Specify the FULL email address to receive report.\"\nvname1  = \"ADDR\"\ntitle2  = \"The FULL DSN to send..ie coa1xyz.c4 (with no quotes)\"\nvname2  = \"DSN\"\nDATAREQ = \"ANY ANY\"\nputvars = \"title title1 title2\"\nputvars = putvars \"vname1 vname2 datareq\"\naddress  ispexec \"vput (\"putvars\") profile\"\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFASTC": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\t\\x01\\x00\\x17?\\x01\\x00\\x17?\\x14\\x03\\x00\\x06\\x00\\x06\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-21T00:00:00", "modifydate": "2000-06-21T14:03:09", "lines": 6, "newlines": 6, "modlines": 0, "user": "*SPIV8*"}, "text": "/*rexx */\narg stcn STCID priv trust trc\naddress tso\n\"RDEFINE STARTED\" stcn\".* STDATA(USER(\"stcid\") GROUP(STCGRP)\",\n\"PRIVILEGED(\"priv\")  TRUSTED(\"trust\") TRACE(\"trc\") )\"\nexit rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REMOPID": {"ttr": 7175, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00@\\x01\\x03\\x05\\x1f\\x01\\x03\\x05\\x1f\\x08G\\x00[\\x00[\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2003-02-20T00:00:00", "modifydate": "2003-02-20T08:47:40", "lines": 91, "newlines": 91, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG tgtopid RUNTYPE\nopid1 = SUBSTR(tgtopid,1,1)\n/* IF RUNTYPE IS SIMULATE THEN DONT REMOVE ANYTHING!! */\n/* IF RUNTYPE IS LIVE THEN PROVIDE OPID AND REMOVE FROM FILE ! */\n/***************************************************************/\n/** THIS EXEC deletes an opid from the file                   **/\n/***************************************************************/\n/** THIS VERSION WILL CHECK 2 MEMBERS FOR AN OPID (THE MORE   **/\n/** MEMBERS CHECKED THE BETTER)    DIR 25 JAN 93              **/\n/***************************************************************/\nSECRC = \"ERROR IN GETOPID\"\nADDRESS ISPEXEC \"VGET OPIDDSN PROFILE\"\nIF SYSDSN(OPIDDSN) /= OK THEN\n  OPIDDSN = \"SYS4.SPI.OPIDS\"\n/*OPIDDSN = \"CHTS.DAVEPDS\" */\nHOLD = \"\"\nTHEOPID = \"#\"\nKILLWORD = 0\nKILLLINE = 0\n/* lets see if the OPID is numeric */\nif datatype(tgtopid) = \"NUM\" then opid1 = \"$NUM\"\nSIGNAL ON ERROR NAME ERRALLOC\n\"ALLOC DDN(INOPID) DSN('\"OPIDDSN\"(\"opid1\")') SHR REUS\"\n\"EXECIO * DISKR INOPID ( FINIS STEM IN.)\"\nLEN = LENGTH(NAME)\nDO Z = 1 TO IN.0\n  IF KILLWORD < > 0 THEN LEAVE\n  PREVLINE = INLINE\n  NNUM = Z + 1\n  NEXT = IN.NNUM\n  INLINE = IN.Z\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\n  W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\n  IF W.1 = \" \" THEN ITERATE Z\n  Q1 = WORD(INLINE,1)\n  Q2 = WORD(NEXT,1)\n/*SAY\n  SAY \"THIS1 IS \" Q1 \".............\"\n  SAY \"NEXT1 IS \" Q2 \".............\" */\n  DO wordnum = 1 TO 25\n      POS3 = SUBSTR(W.wordnum\" \",3,1)\n      IF w.wordnum = tgtopid THEN DO\n        theopid = w.wordnum /* the first 2 characters match !*/\n        killword = wordnum /* close enough for govt work  */\n        killline = z\n        ITERATE Z\n    END\n  END\n  /* if we get here there were no opids that had a 2 chr match */\nEND\nDELOPID: NOP\n/***************************************************************/\n/* NOTE : YOU MUST HAVE THE STEM VARIABLE IN. FILLED WHEN      */\n/* YOU ARRIVE HERE. YOU ALSO MUST HAVE THE DDN INOPID ALLOCATED*/\n/* WITH THE PDS MEMBER THAT WILL RECEIVE THE NEW LOOK OPID     */\n/* MEMBER.                         DIR 20 JAN 93               */\n/***************************************************************/\nLINE = IN.KILLLINE\nPARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12,\nW.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20 W.21 W.22 W.23 W.24 W.25\nDO X = 1 TO 25\n  IF X = KILLWORD THEN ITERATE X\n  HOLD = HOLD W.X\nEND\nIN.KILLLINE = HOLD\n/*SAY \"THE OPID IS \" THEOPID  */\n/*SAY \"KILLLINE IS\" KILLLINE  */\n/*SAY \"KILLWORD IS\" KILLWORD  */\n/*SAY \"NEWLINE IS \"           */\n/*SAY HOLD                    */\nTHEOPID = WORD(THEOPID,1)\nDATAAREA = THEOPID\n\"ISPEXEC VPUT DATAAREA PROFILE\"\nsecrc = \"The opid would be \"theopid\". it still exists on the file\"\nIF RUNTYPE = \"LIVE\" THEN DO\n  secrc = \"The opid is \"theopid\". it has been removed from file\"\n  if theopid = \"#\" then\n    secrc = \"The opid was not found on the file.\"\n  if theopid /= \"#\" then\n    \"EXECIO * DISKW INOPID ( FINIS STEM IN.)\"\nEND\n\"FREE DDN(INOPID)\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nSAY SECRC\nEXIT 0\nERRALLOC: NOP\nsecrc = \"Unable to obtain an enqueue on the opid dsn\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nSAY SECRC\nEXIT 2\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXAPPEND": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00I\\x00\\x99\\x16\\x8f\\x00\\x99#\\x0f\\x10 \\x00*\\x00*\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-06-17T00:00:00", "modifydate": "1999-08-18T10:20:49", "lines": 42, "newlines": 42, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/* COPY A LINE TO DS1 */\nSIGNAL OFF ERROR\nARG DSN1 DATALINE\n/*IF SUBSTR(DSN1,1,1) \u00ac= \"'\" THEN   */\n/*  DSN1 = \"'\"DSN1\"'\"               */\nDISP = \"SHR\"\nCOUNT  = 0\nLINE.0 = 1\nLINE.1 = DATALINE\nADDRESS TSO \"ALLOC DDN(THEDSN) DSN(\"DSN1\") SHR REUS\"\nADDRESS MVS \"EXECIO * DISKR THEDSN (FINIS STEM INDSN.)\"\nQ = INDSN.0 + 1\nIF SUBSTR(DATALINE,1,4) = \"DSN=\" THEN DO\n  INLOGDSN = \"YES\"\n  DATALINE= SUBSTR(DATALINE,5)\n/*IF SUBSTR(DATALINE,1,1) \u00ac= \"'\" THEN */\n/*  DATALINE = \"'\"DATALINE\"'\"          */\n  ADDRESS TSO \"ALLOC DDN(INLOG) DSN(\"DATALINE\") SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR INLOG (FINIS STEM LINE.)\"\n  FINAL = INDSN.0 + LINE.0\n  DO X = Q TO FINAL\n    COUNT = COUNT  + 1\n    INDSN.X = LINE.COUNT\n  END\nEND\nIF SUBSTR(DATALINE,1,4) = \"DDN=\" THEN DO\n  DATALINE= SUBSTR(DATALINE,5)\n  ADDRESS MVS \"EXECIO * DISKR \"DATALINE\" (FINIS STEM LINE.)\"\n  FINAL = INDSN.0 + LINE.0\n  DO X = Q TO FINAL\n    COUNT = COUNT  + 1\n    INDSN.X = LINE.COUNT\n  END\nEND\nELSE INDSN.Q = DATALINE\nADDRESS TSO \"ALLOC DDN(OUTLOG) DSN(\"DSN1\") \"DISP\" REUS\"\nADDRESS MVS \"EXECIO * DISKW OUTLOG (FINIS STEM INDSN.)\"\nADDRESS TSO \" FREE DDN(OUTLOG) \"\nADDRESS TSO \" FREE DDN(THEDSN) \"\nIF INLOGDSN = \"YES\" THEN\nADDRESS TSO \" FREE DDN(INLOG) \"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXBROWSE": {"ttr": 13065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x13\\x00\\x98#\\x1f\\x01\\x07\\x13o\\x08@\\x00 \\x00 \\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1998-08-19T00:00:00", "modifydate": "2007-05-16T08:40:13", "lines": 32, "newlines": 32, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\nARG NAME\nIF LENGTH(TSOCMD) = 0 THEN  DO\n  SAY 'RXBROWSE:   INVALID SYNTAX:'\n  SAY 'RXBROWSE:   SYNTAX IS RXBROWSE <SUFFIX>'\n  EXIT\nEND\nX=MSG('OFF')\nX=OUTTRAP(\"OUTLINE.\")\nUID = USERID()\n/* IF SUBSTR(NAME,1,1) \u00ac= \"'\" THEN NAME = \"'\"||NAME||\"'\"     */\n/* NAME = \"TECH.\"UID\".\"SUFFIX */\nOUTLINE.T = \"                                               \"\n WRKDD = \"WRK\" || RANDOM()               /* GENERATE UNIQUE DDNAME */\n\"ALLOC F(\"WRKDD\") DSN(\"NAME\")  SHR REUS\"\n\"EXECIO 10 DISKR \"WRKDD\" ( FINIS STEM HOLD.)\"\nIF HOLD.0 = 0 THEN DO\n  SECRC = \"DATASET IS EMPTY, BROWSE IS UNSUPPORTED.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  \"FREE F(\"WRKDD\")\"\n  EXIT 04\nEND\n/* --------------------------------------------------------------- */\n/* EXECUTE COMMAND                                                 */\n/* --------------------------------------------------------------- */\nADDRESS ISPEXEC \"LMINIT DATAID(DSN1) DDNAME(\"WRKDD\") ENQ(EXCLU)\"\nADDRESS ISPEXEC \"BROWSE DATAID(&DSN1)\"\nADDRESS ISPEXEC \"LMFREE DATAID(&DSN1)\"\nENDD:\n\"FREE F(\"WRKDD\")\"\nsecrc = \"browse operation completed.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXEDIT": {"ttr": 8966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x00\\x00\\x98#\\x1f\\x01\\x05\\x01\\x1f\\x08I\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1998-08-19T00:00:00", "modifydate": "2005-01-11T08:49:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\nARG NAME\nIF LENGTH(NAME) = 0 THEN  DO\n  SAY 'RXEDIT:   INVALID SYNTAX:'\n  SAY 'RXEDIT:   SYNTAX IS RXEDIT <DSNAME>'\n  EXIT\nEND\nX=MSG('OFF')\nX=OUTTRAP(\"OUTLINE.\")\nUID = USERID()\n/* IF SUBSTR(NAME,1,1) \u00ac= \"'\" THEN NAME = \"'\"||NAME||\"'\"      */\n/* NAME = \"TECH.\"UID\".\"SUFFIX */\nOUTLINE.T = \"                                               \"\nWRKDD = \"RXE\" || RANDOM()\nADDRESS TSO \"ALLOC F(\"WRKDD\") DSN(\"NAME\")  SHR REUS\" ,\n/* --------------------------------------------------------------- */\n/* EXECUTE COMMAND                                                 */\n/* --------------------------------------------------------------- */\nADDRESS ISPEXEC \"LMINIT DATAID(DSN1) DDNAME(\"WRKDD\") ENQ(EXCLU)\"\nADDRESS ISPEXEC 'EDIT DATAID(&DSN1)'\nADDRESS ISPEXEC 'LMFREE DATAID(&DSN1)'\nENDD:\n\"FREE F(\"WRKDD\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXPARSE": {"ttr": 273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x04\\x00\\x98\\x16/\\x00\\x98\\x16/\\x11#\\x00\\x07\\x00\\x07\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-06-11T00:00:00", "modifydate": "1998-06-11T11:23:04", "lines": 7, "newlines": 7, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nTRACE OFF\n ARG D.1 D.2 D.3 D.4 D.5 D.6 D.7 D.8 D.9 D.10 D.11 D.12 D.13 D.14\n DO COUNT = 1 TO 14\n   IF D.COUNT = ' ' THEN LEAVE\n   SAY D.COUNT\n END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXREPRO": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x00\\x00P\\x00\\x98'\\x8f\\x00\\x99'\\x1f\\x110\\x000\\x000\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-05T00:00:00", "modifydate": "1999-09-28T11:30:50", "lines": 48, "newlines": 48, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/* COPY DS1 TO DS2 WITH A REXX EXEC */\nARG DSN1 DSN2 DISP\nIF SUBSTR(DSN1,1,1) \u00ac= \"'\" THEN\n  DSN1 = \"'\"DSN1\"'\"\nIF SUBSTR(DSN2,1,1) \u00ac= \"'\" THEN\n  DSN2 = \"'\"DSN2\"'\"\nDSN1_FIRST = SYSDSN(DSN1)\nDSN2_FIRST = SYSDSN(DSN2)\nIF DSN1_FIRST /= \"OK\" THEN  DSN1 = STRIP(TRANSLATE(DSN1,\"\",\"'\"))\nIF DSN2_FIRST /= \"OK\" THEN  DSN2 = STRIP(TRANSLATE(DSN2,\"\",\"'\"))\nDSN1_SECOND = SYSDSN(DSN1)\nDSN2_SECOND = SYSDSN(DSN2)\nIF (DSN1_FIRST /= \"OK\" ) & (DSN1_SECOND /= \"OK\") THEN DO\n  IF SYSVAR(SYSENV) = \"FORE\" THEN DO\n    SECRC = \"TSA512E: PROVIDED DATASET INVALID\" DSN1\n    ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n    EXIT 8\n  END\nEND\nIF (DSN2_FIRST /= \"OK\" ) & (DSN2_SECOND /= \"OK\") THEN DO\n  IF SYSVAR(SYSENV) = \"FORE\" THEN DO\n    SECRC = \"TSA512E: PROVIDED DATASET INVALID\" DSN2\n    ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n    EXIT 8\n  END\nEND\nIF (DSN2_FIRST /= \"OK\" ) & (DSN2_SECOND /= \"OK\") THEN DO\nEND\nTRACE OFF\nSAY \"RXREPRO: RESOLVED DSNS ARE:\"\nSAY DSN1 DSN2\nIF DISP = \" \" THEN DISP = \"SHR\"\n/******************************************************************/\n/* IF DISP = MOD AND A PDS IS THE OUTPUT DSN USE RXAPPEND NOT THIS*/\n/******************************************************************/\nADDRESS TSO \"ALLOC DDN(INFILE) DSN(\"DSN1\") SHR REUS\"\nADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DSN2\") \"DISP\" REUS\"\nADDRESS MVS \"EXECIO * DISKR INFILE (FINIS STEM LINE.)\"\nOUTNUM = LINE.0\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW OUTFILE (FINIS STEM LINE.)\"\nADDRESS TSO \" FREE DDN(INFILE)  \"\nADDRESS TSO \" FREE DDN(OUTFILE) \"\nIF SYSVAR(SYSENV) = \"FORE\" THEN DO\n  secrc = \"TSA513I: Data copied successfully.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 0\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "R29ASEC": {"ttr": 4623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x00\\x16o\\x01\\x00\\x16o\\x07E\\x00-\\x00-\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-14T00:00:00", "modifydate": "2000-06-14T07:45:06", "lines": 45, "newlines": 45, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\narg id g1 g2 proc acct name\n/*******************************************************************/\n/* the id default_group owning_group acct_number                   */\n/*******************************************************************/\n/*                                                                 */\n/*   ADDUSER        - Defines users to RACF and TSO                */\n/*   The syntax of the TSO operands for the ALTUSER command is:    */\n/*      ADDUSER  userid                 +                          */\n/*         TSO(                                                  + */\n/*             PROC()        -  the default logon procedure      + */\n/*             ACCTNUM()     -  the default account number       + */\n/*             SIZE()        -  the default region size          + */\n/*             MAXSIZE()     -  the maximum allowable region size+ */\n/*             UNIT()        -  the default unit                 + */\n/*             DEST()        -  the default destination          + */\n/*             JOBCLASS()    -  the default jobclass             + */\n/*             MSGCLASS()    -  the default message class        + */\n/*             HOLDCLASS()   -  the default hold class           + */\n/*             SYSOUTCLASS() -  the default sysout class         + */\n/*             USERDATA()    -  userdata                         + */\n/*            )                                                  + */\n/*                                                                 */\n/*******************************************************************/\nsignal off error\ntrace r\naddress tso\n  \"%cbhalias \" id\nADDUSER: NOP\n \"ADDUSER \"id\" PASSWORD(\"id\") NAME('\"name\"')\",\n \"DFLTGRP(\"g1\") OWNER(\"g2\")  TSO( PROC(\"proc\")\",\n \"ACCTNUM(\"acct\") SIZE(4096) MAXSIZE(0) UNIT(VIO) MSGCLASS(X)\",\n \"SYSOUTCLASS(D) USERDATA(0000))\"\n\n \"ADDSD '\"id\".**' WARNING OWNER(\"g1\") UACC(ALTER)\",\n \" AUDIT(SUCCESS(UPDATE)\"\n /* */\nPermit: NOP\n \"PERMIT  OPER CLASS(TSOAUTH)    ID(\"id\")\"\n \"PERMIT  JCL CLASS(TSOAUTH)     ID(\"id\")\"\n \"PERMIT  RECOVER CLASS(TSOAUTH) ID(\"id\")\"\n \"PERMIT  \"proc\" CLASS(TSOPROC)  ID(\"id\")\"\n \"PERMIT  \"acct\" CLASS(ACCTNUM)  ID(\"id\")\"\n \"ALU  \"ID\" special auditor\"\n \"CO \"id\"  GROUP(CATALOGA)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "R29ASYS": {"ttr": 4625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00#\\x01\\x00\\x16o\\x01\\x00\\x16o\\x07E\\x00,\\x00,\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-14T00:00:00", "modifydate": "2000-06-14T07:45:23", "lines": 44, "newlines": 44, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\narg id g1 g2 proc acct name\n/*******************************************************************/\n/* the id default_group owning_group acct_number                   */\n/*******************************************************************/\n/*                                                                 */\n/*   ADDUSER        - Defines users to RACF and TSO                */\n/*   The syntax of the TSO operands for the ALTUSER command is:    */\n/*      ADDUSER  userid                 +                          */\n/*         TSO(                                                  + */\n/*             PROC()        -  the default logon procedure      + */\n/*             ACCTNUM()     -  the default account number       + */\n/*             SIZE()        -  the default region size          + */\n/*             MAXSIZE()     -  the maximum allowable region size+ */\n/*             UNIT()        -  the default unit                 + */\n/*             DEST()        -  the default destination          + */\n/*             JOBCLASS()    -  the default jobclass             + */\n/*             MSGCLASS()    -  the default message class        + */\n/*             HOLDCLASS()   -  the default hold class           + */\n/*             SYSOUTCLASS() -  the default sysout class         + */\n/*             USERDATA()    -  userdata                         + */\n/*            )                                                  + */\n/*                                                                 */\n/*******************************************************************/\nsignal off error\ntrace r\naddress tso\n  \"%cbhalias \" id\nADDUSER: NOP\n \"ADDUSER \"id\" PASSWORD(\"id\") NAME('\"name\"')\",\n \"DFLTGRP(\"g1\") OWNER(\"g2\")  TSO( PROC(\"proc\")\",\n \"ACCTNUM(\"acct\") SIZE(4096) MAXSIZE(0) UNIT(VIO) MSGCLASS(X)\",\n \"SYSOUTCLASS(D) USERDATA(0000))\"\n\n \"ADDSD '\"id\".**' WARNING OWNER(\"g1\") UACC(ALTER)\",\n \" AUDIT(SUCCESS(UPDATE)\"\n /* */\nPermit: NOP\n \"PERMIT  OPER CLASS(TSOAUTH)    ID(\"id\")\"\n \"PERMIT  JCL CLASS(TSOAUTH)     ID(\"id\")\"\n \"PERMIT  RECOVER CLASS(TSOAUTH) ID(\"id\")\"\n \"PERMIT  \"proc\" CLASS(TSOPROC)  ID(\"id\")\"\n \"PERMIT  \"acct\" CLASS(ACCTNUM)  ID(\"id\")\"\n \"CO \"id\"  GROUP(CATALOGA)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "R29IDEL": {"ttr": 4629, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00H\\x01\\x00\\x16o\\x01\\x00\\x16o\\x08 \\x00\\x0b\\x00\\x0b\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2000-06-14T00:00:00", "modifydate": "2000-06-14T08:20:48", "lines": 11, "newlines": 11, "modlines": 0, "user": "*SPIV8*"}, "text": "/* rexx */\narg id\n/*******************************************************************/\n/* delete the userid */\nsignal off error\ntrace r\naddress tso\n \"DELDSD '\"id\".**'\"\nDELUSER: NOP\n \"DELUSER \"id\n /* */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "R29JCARD": {"ttr": 4627, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x00\\x16o\\x01\\x00\\x16o\\x07P\\x00<\\x00<\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-06-14T00:00:00", "modifydate": "2000-06-14T07:50:46", "lines": 60, "newlines": 60, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** INSERTS A JOBNAME AND MAYBE A USER= CARD INTO A      **/\n/** SAMPLE JCL DECK WHICH ALREADY IS SYNTACTICALLY VALID **/\n/**********************************************************/\n/** EXEC NAME        : T50JCARD                          **/\n/** LAST MODIFIED    : 15 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSNAME OF THE OUTPUT JCL STREAM        **/\n/** JPARM   : \"SUPER\" OR BLANKS                          **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS6     : THE DSNAME IF THE SAMPLE JOB               **/\n/** DISP    : THE OUTPUT FILE ALLOCATION DISPOSITION     **/\n/** MSCA    : THE ID TO INCLUDE IN A USER= CARD IF NEEDED**/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE                         **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (NEEDS VGETS)               **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/.A                **/\n/**                                                      **/\n/**********************************************************/\nARG DSN JPARM\nADDRESS ISPEXEC\n\"ISPEXEC VGET DS6 PROFILE\"\n\"ISPEXEC VGET MSCA PROFILE\"\nSAY \"TSA101D: T50JCARD: IS IN CONTROL WITH PARMS : \" DSN JPARM\nADDRESS TSO \"ALLOC DDN(JCFILE) DSN(\"DS6\") SHR REUS\"\nJNAME= JPARM\nIF JPARM = '' THEN JNAME = \"TSSJOB\"\nTIME = TIME(NORMAL)\nT12 = SUBSTR(TIME,1,2)\nT45 = SUBSTR(TIME,4,2)\nIF JPARM = \"RANDOM\" THEN\n  JNAME= \"TSSJ\"T12||T45\nADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DSN\") SHR REUS\"\nADDRESS MVS \"EXECIO * DISKR JCFILE (FINIS STEM LINE.)\"\nJOBCARD_INSERT = 99\nDO Q = 8 TO 1 BY -1 /* LETS FIND WHERE THE JOBCARD ENDS */\n  INLINE = LINE.Q\n  IF SUBSTR(INLINE,1,3) = \"//*\" THEN JOBCARD_INSERT = Q - 1\n  IF SUBSTR(INLINE,1,2) = \"/*\" THEN JOBCARD_INSERT = Q - 1\n  IF INDEX(INLINE,\"EXEC\") > 0  THEN JOBCARD_INSERT = Q - 1\nEND\nSAY \"TSA101D: T50JCARD JOBCARD ENDS PRIOR TO LINE\" JOBCARD_INSERT\nIF JPARM = \"SUPER\" THEN DO\n  JNAME= \"TSSJ\"T12||T45\n  LINE.JOBCARD_INSERT= \"// \"WORD(LINE.JOBCARD_INSERT,2)||\",USER=\"MSCA\n  SAY \"TSA101D: JCARD ADDITION : \" LINE.JOBCARD_INSERT\nEND\nLEN1= LENGTH(LINE.1)\nHOLD = SUBSTR(LINE.1,11)\nLINE.1= \"//\"JNAME HOLD\nADDRESS MVS \"EXECIO * DISKW OUTFILE (FINIS STEM LINE.)\"\nADDRESS TSO \" FREE DDN(JCFILE)  \"\nADDRESS TSO \" FREE DDN(OUTFILE) \"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAY": {"ttr": 7183, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x03\\x16\\x1f\\x01\\x03\\x16\\x1f\\x102\\x00\\x03\\x00\\x03\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-06-10T00:00:00", "modifydate": "2003-06-10T10:32:01", "lines": 3, "newlines": 3, "modlines": 0, "user": "*SPIV8*"}, "text": "/*rexx */\nsay 'hi dave'\nexit 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCREEN2": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00B\\x00\\x99\\x08\\x8f\\x00\\x992\\x0f\\x13P\\x00\\t\\x00\\t\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "1999-11-16T13:50:42", "lines": 9, "newlines": 9, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/* AN EXAMPLE OF AN EXEC THAT CAUSES THE PANEL AND SCREEN TABLES TO */\n/* RELOADED. IN EXPERT MODE ONLY !*/\nSRCCMD = \"'SYS3.TSS.PARMLIB(CMDLIST)'\"\nSRCSCR = \"'SYS3.TSS.PARMLIB(SCREEN)'\"\nREFRESH = \"YES\"\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT REFRESH PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWCPU": {"ttr": 517, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00&\\x00\\x99\\x01/\\x00\\x99\\x01/\\x14I\\x00\\x0e\\x00\\x0e\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-01-12T00:00:00", "modifydate": "1999-01-12T14:49:26", "lines": 14, "newlines": 14, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX ****************************************************/\n/******************************/\npsa = ptr(520)\npsa = c2d(psa)  /* we got back a character value from function */\npsa = psa + 6   /* it just got changed to a decimal value */\npsa = d2x(psa)  /* we change it back to a hex value */\ncpu = storage(psa,6) /* give the storage function the address in hex */\ncpu = substr(cpu,3)\n/******************************/\nsay \"your cpu is \" cpu\nexit 0\nPTR:\n  Arg value\n  Return X2C(C2X(STORAGE(D2X(value),4)))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SIG": {"ttr": 2819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00B\\x00\\x990\\x7f\\x00\\x990\\x7f\\tQ\\x00\\x01\\x00\\x01\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-03T00:00:00", "modifydate": "1999-11-03T09:51:42", "lines": 1, "newlines": 1, "modlines": 0, "user": "*SPIV8*"}, "text": "signal off error\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPIRPT01": {"ttr": 10779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\"\\x01\\x05\\x07_\\x01\\x06\\x02o\\x10X\\x00 \\x00\\x1e\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2005-03-16T00:00:00", "modifydate": "2006-01-26T10:58:22", "lines": 32, "newlines": 30, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX */\nADDRESS ISPEXEC \"VGET Zprefix\"\nID = Zprefix\nARG SDSN PROFILE EMAIL_ADDR\nSDSN = ID\".\"SDSN\nQUEUE \"//TSSJOB  JOB 98000,'TSSJOB',                                \"\nQUEUE \"//         CLASS=A,MSGLEVEL=(0,0),                           \"\nQUEUE \"//         MSGCLASS=Q,REGION=32M                             \"\nQUEUE \"/*JOBPARM S=*                                                \"\nQUEUE \"//TSSTMP       EXEC     TSOBATCH,SYSPROC='SYS4.SPI.SOURCE'   \"\nQUEUE \"//***********************************************************\"\nQUEUE \"//* THIS IMAGE ORIGINATES IN PARMLIB MEMBER JCSOURCE         \"\nQUEUE \"//***********************************************************\"\nQUEUE \"//SYSTSIN  DD DATA,DLM=@@                                    \"\nQUEUE \"  TSSLNAME T53PWHO \"PROFILE SDSN\"                           \"\nQUEUE \"@@                                                           \"\nQUEUE \"//XMITIP  EXEC PGM=IKJEFT1B,DYNAMNBR=50                      \"\nQUEUE \"//SYSEXEC  DD DISP=SHR,DSN=SYS4.EMAIL.EXEC                   \"\nQUEUE \"//SYSPRINT DD  SYSOUT=*                                      \"\nQUEUE \"//SYSTSPRT DD  SYSOUT=*                                      \"\nQUEUE \"//SYSTSIN DD   *                                             \"\nQUEUE \"%xmitip \"EMAIL_ADDR\" +                               \"\nQUEUE \"        MSGDS 'SYS4.SPI.SOURCE(STDMSG)' +                    \"\nQUEUE \"        From drussell@yesbank.com +                          \"\nQUEUE \"        Replyto drussell@yesbank.com +                       \"\nQUEUE \"        SUBJECT 'TSS name list of ACID: \"Profile\"' + \"\nQUEUE \"        File '\"SDSN\"' +                                  \"\nQUEUE \"        filename \"profile\".txt +\"\nQUEUE \"        Format txt                                           \"\nQUEUE \"/*                                                           \"\nQUEUE \"$$                                                        \"\nADDRESS TSO \"SUBMIT * END($$)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STDMSG": {"ttr": 10759, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x05\\x07_\\x01\\x05\\x07_\\x11\\x01\\x00\\x01\\x00\\x01\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-03-16T00:00:00", "modifydate": "2005-03-16T11:01:24", "lines": 1, "newlines": 1, "modlines": 0, "user": "COA1DIR"}, "text": "A Standard SPI report is attached below.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "T$$BACK": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x02\\x00$\\x00\\x99'\\x8f\\x01\\x00\\x07_\\x10S\\x00p\\x00p\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-10-05T00:00:00", "modifydate": "2000-03-15T10:53:24", "lines": 112, "newlines": 112, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** THE CUSTOM INIT MEMBER FOR SYSC                      **/\n/**********************************************************/\n/** EXEC NAME        : T$$TD01                           **/\n/** LAST MODIFIED    : 17 SEP 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      : THE USERID                                 **/\n/** AUTHNUM : 1 - 10                                     **/\n/** TYPE    : \"REINIT\" OR  \"NOREINIT\"                    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00  ONLY                     **/\n/** ISPF VARIABLES        - ANY YOU  WANT                **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES, BUT WHY ??                 **/\n/** ISPF ENVIRONMENT   : MOST DEFINATELY                 **/\n/** EXECS CALLED WITHIN THIS EXEC : ANY YOU WANT         **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\nARG ID AUTHNUM TYPE\n                       /******************************/\n                       /** USE A HARDCODED PREFIX   **/\n                       /******************************/\nDS1      = \"'TECH.\"||ID||\".C1'\"\nDS2      = \"'TECH.\"||ID||\".C2'\"\nDS3      = \"'TECH.\"||ID||\".C3'\"\nDS4      = \"'TECH.\"||ID||\".C4'\"\nDS5      = \"'TECH.\"||ID||\".C5'\"\n                       /******************************/\n                       /** USE THE IDS TSO PREFIX   **/\n                       /******************************/\nDS1      = \"C1\"        /* LRECL 80 INTERIM OUTPUT    */\nDS2      = \"C2\"        /* LRECL CONVERT OUTPUT       */\nDS3      = \"C3\"        /* LRECL 80 JCL/DEBUG OUTPUT  */\nDS4      = \"C4\"        /* LRECL 133 OUTPUT           */\nDS5      = \"C5\"        /* LRECL 80 JCL OUTPUT        */\n                       /******************************/\nDS6      = \"'SYS4.SPI.PARMLIB(JCSOURCE)'\"\nSRCCMD   = \"'SYS4.SPI.PARMLIB(CORECMD)'\"\nSRCSCR   = \"'SYS4.SPI.PARMLIB(CORESCR)'\"\nALUNIT   = \"SYSDA\"\nPANEL    = \"SPIUTIL\"\nJESNODE  = \"IMSJESC\"\nFLATMODL = \"G104228.GDA.DATA\"\nIF SYSDSN(DS1)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS1\") UNIT(\"ALUNIT\") NEW \",\n  \"LIKE('\"FLATMODL\"') SPACE(5) CYLINDERS\"\nEND\nIF SYSDSN(DS2)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS2\") UNIT(\"ALUNIT\") NEW \",\n  \"LIKE('\"FLATMODL\"') SPACE(10) CYLINDERS\"\nEND\nIF SYSDSN(DS3)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS3\") UNIT(\"ALUNIT\") NEW \",\n  \"LIKE('\"FLATMODL\"')\"\nEND\nIF SYSDSN(DS4)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS4\") UNIT(\"ALUNIT\") NEW \",\n  \"LIKE('\"FLATMODL\"') LRECL(133) BLKSIZE(26600) SPACE(2,1) CYLINDERS\"\nEND\nIF SYSDSN(DS5)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS5\") UNIT(\"ALUNIT\") NEW \",\n  \"LIKE('\"FLATMODL\"')\"\nEND\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT DS1 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT DS2 PROFILE\" /* ALWAYS PASS THESE */\nADDRESS ISPEXEC \"VPUT DS3 PROFILE\" /* VALUES ON TO MAIN */\nADDRESS ISPEXEC \"VPUT DS4 PROFILE\" /* ROUTINE..DIR      */\nADDRESS ISPEXEC \"VPUT DS5 PROFILE\" /*                   */\nADDRESS ISPEXEC \"VPUT DS6 PROFILE\" /*********************/\n                                  /**********************************/\nIF TYPE = \"NOREINIT\" THEN EXIT 00 /* NOTHING BELOW NEEDS TO BE DONE */\n                                  /* EVERY TIME HE LOGS ON.         */\n                                  /**********************************/\n\nCONVOPT  = \"DATASET\"             /* OUTPUT OPTION FOR CONVERT       */\nCONVOPT  = \"INTERNAL\"            /* OUTPUT OPTION FOR CONVERT       */\n\n            /* NO QUOTES! */\nDSBACK   = \"TECH.SCA.IDBACKUP\"    /* A PDS WITH NO QUOTES! */\n            /* NO QUOTES! */\n\nDSNMODEL = \"G104228.GDA.DATA\"     /* A PDS MODEL FOR ALLOCATE  */\n\nFLATMODL = \"TECH.G104228.C1\"      /* A PS MODEL FOR ALLOCATE   */\n\nMSCA     = \"JOHNDOE\"              /* THE TOP SECRET MSCA ACID. */\n\nNEWPASS  = \"PASSWORD,60,EXP\"      /*  NEW PASSWORD DEFAULT     */\n\nPROD     = SYSID\n\nRECFILE  = \"'SYS2.TSS.RECFILE'\"    /* TSS RECOVERY FILE */\n\nTSAUD  = \"'SYSV.TSS50.AUDIT'\"\n\nADDRESS ISPEXEC \"VPUT ALUNIT   PROFILE\"\nADDRESS ISPEXEC \"VPUT CONVOPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT DSNMODEL PROFILE\"\nADDRESS ISPEXEC \"VPUT FLATMODL PROFILE\"\nADDRESS ISPEXEC \"VPUT JESNODE  PROFILE\"\nADDRESS ISPEXEC \"VPUT MSCA     PROFILE\"\nADDRESS ISPEXEC \"VPUT NEWPASS  PROFILE\"\nADDRESS ISPEXEC \"VPUT PANEL    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT RECFILE  PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T$$CO$A": {"ttr": 13569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x08\\x14\\x1f\\x01\\x08\\x14\\x1f\\x13Y\\x00\\xbb\\x00\\xbb\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-05-20T00:00:00", "modifydate": "2008-05-20T13:59:53", "lines": 187, "newlines": 187, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T$$co2b                           **/\n/** LAST MODIFIED    :  2 mar 2001                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      : THE USERID                                 **/\n/** AUTHNUM : 1 - 10                                     **/\n/** TYPE    : \"REINIT\" OR  \"NOREINIT\"                    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00  ONLY                     **/\n/** ISPF VARIABLES        - ANY YOU  WANT                **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES, BUT WHY ??                 **/\n/** ISPF ENVIRONMENT   : MOST DEFINATELY                 **/\n/** EXECS CALLED WITHIN THIS EXEC : ANY YOU WANT         **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\nARG ID AUTHNUM TYPE\nAUTHCODE = \"-989991699884\"\n                       /***************************************/\n                       /** SAMPLE OF A HARDCODED DS PREFIX   **/\n                       /***************************************/\nDS1      = \"'TECH.\"||ID||\".C1'\"\nDS2      = \"'TECH.\"||ID||\".C2'\"\nDS3      = \"'TECH.\"||ID||\".C3'\"\nDS4      = \"'TECH.\"||ID||\".C4'\"\nDS5      = \"'TECH.\"||ID||\".C5'\"\n                       /******************************/\n                       /** USE THE IDS TSO PREFIX   **/\n                       /******************************/\nDS1      = \"C1\"        /* LRECL 80 INTERIM OUTPUT    */\nDS2      = \"C2\"        /* LRECL CONVERT OUTPUT       */\nDS3      = \"C3\"        /* LRECL 80 JCL/DEBUG OUTPUT  */\nDS4      = \"C4\"        /* LRECL 133 OUTPUT           */\nDS5      = \"C5\"        /* LRECL 80 JCL OUTPUT        */\n                       /******************************/\nDS6      = \"'sys4.spi.PARMLIB(JCSOURCE)'\"\nJCARD    = \" 98000,'TSS-JOB',CLASS=R,MSGCLASS=Z \"\nSRCCMD   = \"'sys4.spi.PARMLIB(CORECMD)'\"\nUSERCMD  = \"'sys4.spi.PARMLIB(USERCMD)'\" /* YOUR COMMAND OVERRIDES */\nLOGDSN   = \"TSADMIN.LOG\"\nLOGDSN   = \"'sys4.spi.LOG(\"ID\")'\"\nLOGDSN   = \"NONE\"\nLOGFAIL  = \"YES\"     /* FAIL A FUNCTION IF THE LOG ISNT WORKING */\nLOGFAIL  = \"NO\"      /* DONT FAIL A FUNCTION IF THE LOG ISNT WORKING */\nSRCSCR   = \"'sys4.spi.PARMLIB(CORESCR)'\"\nALUNIT   = \"SYSALLDA\"\nSCRLOAD  = \"YES\"\nJESNODE  = \"CO2AJES\"\n/*************************************************************/\n/** THE BELOW list is of customized variables that you want  */\n/** to be available to the main panel routine. They will     */\n/** be refreshed on a REINIT.                                */\n/*************************************************************/\nTSOUNIT  = \"3390\"\nTSOSIZE  = \"6144\"\nVARLIST = \"TSOUNIT TSOSIZE\"\n/*************************************************************/\n/** THE BELOW CHECK IS TO INSURE YOU GET THE CORRECT SYSTEM  */\n/** VARIABLES IN CASE YOU ARE RUNNING MULTIPLE IMAGES        */\n/*************************************************************/\nTHISINI = SYSVAR(SYSICMD)\nADDRESS ISPEXEC \" VGET LASTINI  PROFILE\"\nIF LASTINI \\= THISINI THEN DO\n  LASTINI = THISINI\n  ADDRESS ISPEXEC \"VPUT LASTINI PROFILE\" /* SET THE LASTINI NAME   */\n  TYPE = \"REINIT\"  /* LETS RESET ALL THE VARIABLES */\n  MSG2 = \"$$ A REINIT WAS FORCED DUE TO SYSID MISMATCH FROM LAST INIT\"\n  CLEARMSG = \"NO\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n  ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\nEND\nIF SYSDSN(SRCSCR)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCSCR INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCSCR\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCSCR DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(SRCCMD)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCCMD INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCCMD\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCCMD DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(DS1)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS1\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS2)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS2\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS3)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS3\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(5) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS4)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS4\") UNIT(\"ALUNIT\") NEW \",\n  \"LRECL(133) BLKSIZE(26600) SPACE(2,1) CYLINDERS RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS5)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS5\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nADDRESS ISPEXEC \"VGET TABLEOPT PROFILE\"\nIF TABLEOPT = \"PERM\" THEN DO\n  SRCCMD   = \"****NOT USED****\"\n  SRCSCR   = \"****NOT USED****\"\nEND\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT USERCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT AUTHCODE PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT DS1 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT DS2 PROFILE\" /* ALWAYS PASS THESE */\nADDRESS ISPEXEC \"VPUT DS3 PROFILE\" /* VALUES ON TO MAIN */\nADDRESS ISPEXEC \"VPUT DS4 PROFILE\" /* ROUTINE..DIR      */\nADDRESS ISPEXEC \"VPUT DS5 PROFILE\" /*                   */\nADDRESS ISPEXEC \"VPUT DS6 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT SCRLOAD PROFILE\"\n                                  /**********************************/\nIF TYPE = \"NOREINIT\" THEN EXIT 00 /* NOTHING BELOW NEEDS TO BE DONE */\n                                  /* EVERY TIME HE LOGS ON.         */\n                                  /**********************************/\n\nCONVOPT  = \"DATASET\"             /* OUTPUT OPTION FOR CONVERT       */\nCONVOPT  = \"INTERNAL\"            /* OUTPUT OPTION FOR CONVERT       */\n\nDEFDEPT  = \"CBHUSER\"             /* DEFAULT OMVS GROUP FOR ACIDS */\nDEFGROUP = \"PRODGRP\"             /* DEFAULT OMVS GROUP FOR ACIDS */\n\n            /* NO QUOTES! */\nDSBACK   = \"SYS4.SPI.IDBACKUP\"    /* A PDS WITH NO QUOTES! */\n            /* NO QUOTES! */\n\nMSCA     = \"COA1TSS\"              /* THE TOP SECRET MSCA ACID. */\n\nNEWPASS  = \"PASSWORD,60,EXP\"      /*  NEW PASSWORD DEFAULT     */\n\nPROD     = SYSID\n\nRECFILE  = \"'CO2PLEX.ZOS16.TSS80.RECFILE'\" /* TSS RECOVERY FILE */\nTSAUD    = \"'CO2PLEX.ZOS16.TSS80.AUDIT'\" /* TSS RECOVERY FILE */\nTSAUDID  = \"TSSAUDIT\"                /* TSS RECOVERY FILE */\n\nTESTV1   = \"VARIABLE 1\"\nTESTV2   = \"VARIABLE NUMBER TWO\"\n\nADDRESS ISPEXEC \"VPUT ALUNIT   PROFILE\"\nADDRESS ISPEXEC \"VPUT defgroup PROFILE\"\nADDRESS ISPEXEC \"VPUT CONVOPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DEFDEPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT JESNODE  PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGDSN   PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGFAIL  PROFILE\"\nADDRESS ISPEXEC \"VPUT MSCA     PROFILE\"\nADDRESS ISPEXEC \"VPUT NEWPASS  PROFILE\"\nADDRESS ISPEXEC \"VPUT JCARD    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT RECFILE  PROFILE\"\nADDRESS ISPEXEC \"VPUT TSAUDID  PROFILE\"\nADDRESS ISPEXEC \"VPUT TSAUD    PROFILE\"\nADDRESS ISPEXEC \"VPUT VARLIST  PROFILE\"\nSIGNAL OFF ERROR\nDO CNT = 1 TO WORDS(VARLIST)\n  VNAME = WORD(VARLIST,CNT)\n  ADDRESS ISPEXEC \"VPUT \" VNAME \"PROFILE \"\n  IF RC /= 0 THEN DO\n    MSG2 = \"$$ VPUT FOR  VARIABLE \" VNAME \" FAILED IN T$$ EXEC\"\n    CLEARMSG = \"NO\"\n    ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\n  END\nEND\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T$$CO1A": {"ttr": 13315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x08\\x01\\x01\\x08O\\x01\\x07(\\x9f\\x11Q\\x00\\xbd\\x00\\xbb\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2001-03-25T00:00:00", "modifydate": "2007-10-16T11:51:08", "lines": 189, "newlines": 187, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T$$co1a                           **/\n/** LAST MODIFIED    :  2 mar 2001                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      : THE USERID                                 **/\n/** AUTHNUM : 1 - 10                                     **/\n/** TYPE    : \"REINIT\" OR  \"NOREINIT\"                    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00  ONLY                     **/\n/** ISPF VARIABLES        - ANY YOU  WANT                **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES, BUT WHY ??                 **/\n/** ISPF ENVIRONMENT   : MOST DEFINATELY                 **/\n/** EXECS CALLED WITHIN THIS EXEC : ANY YOU WANT         **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\nARG ID AUTHNUM TYPE\n                       /***************************************/\n                       /** SAMPLE OF A HARDCODED DS PREFIX   **/\n                       /***************************************/\nDS1      = \"'TECH.\"||ID||\".C1'\"\nDS2      = \"'TECH.\"||ID||\".C2'\"\nDS3      = \"'TECH.\"||ID||\".C3'\"\nDS4      = \"'TECH.\"||ID||\".C4'\"\nDS5      = \"'TECH.\"||ID||\".C5'\"\n                       /******************************/\n                       /** USE THE IDS TSO PREFIX   **/\n                       /******************************/\nDS1      = \"C1\"        /* LRECL 80 INTERIM OUTPUT    */\nDS2      = \"C2\"        /* LRECL CONVERT OUTPUT       */\nDS3      = \"C3\"        /* LRECL 80 JCL/DEBUG OUTPUT  */\nDS4      = \"C4\"        /* LRECL 133 OUTPUT           */\nDS5      = \"C5\"        /* LRECL 80 JCL OUTPUT        */\n                       /******************************/\nDS6      = \"'sys4.spi.PARMLIB(JCSOURCE)'\"\nJCARD    = \" 98000,'TSS-JOB',CLASS=R,MSGCLASS=Z \"\nSRCCMD   = \"'sys4.spi.PARMLIB(CORECMD)'\"\nUSERCMD  = \"'sys4.spi.PARMLIB(USERCMD)'\" /* YOUR COMMAND OVERRIDES */\nLOGDSN   = \"TSADMIN.LOG\"\nLOGDSN   = \"'sys4.spi.LOG(\"ID\")'\"\nLOGDSN   = \"NONE\"\nLOGFAIL  = \"YES\"     /* FAIL A FUNCTION IF THE LOG ISNT WORKING */\nLOGFAIL  = \"NO\"      /* DONT FAIL A FUNCTION IF THE LOG ISNT WORKING */\nSRCSCR   = \"'sys4.spi.PARMLIB(SPISCR1A)'\"\nALUNIT   = \"SYSALLDA\"\nSCRLOAD  = \"YES\"\nINSTCON  = \"YES\"\nJESNODE  = \"CO1AJES\"\n/*************************************************************/\n/** THE BELOW list is of customized variables that you want  */\n/** to be available to the main panel routine. They will     */\n/** be refreshed on a REINIT.                                */\n/*************************************************************/\nAUD      = \"'SYS4.CO1PLEX.NAMEFILE'\"\nTSOUNIT  = \"3390\"\nTSOSIZE  = \"6144\"\nMAKECUST = \" %ADDLOCAL $$\"\nVARLIST = \" AUD TSOUNIT TSOSIZE INSTCON MAKECUST\"\n/*************************************************************/\n/** THE BELOW CHECK IS TO INSURE YOU GET THE CORRECT SYSTEM  */\n/** VARIABLES IN CASE YOU ARE RUNNING MULTIPLE IMAGES        */\n/*************************************************************/\nTHISINI = SYSVAR(SYSICMD)\nADDRESS ISPEXEC \" VGET LASTINI  PROFILE\"\nIF LASTINI \\= THISINI THEN DO\n  LASTINI = THISINI\n  ADDRESS ISPEXEC \"VPUT LASTINI PROFILE\" /* SET THE LASTINI NAME   */\n  TYPE = \"REINIT\"  /* LETS RESET ALL THE VARIABLES */\n  MSG2 = \"$$ A REINIT WAS FORCED DUE TO SYSID MISMATCH FROM LAST INIT\"\n  CLEARMSG = \"NO\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n  ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\nEND\nIF SYSDSN(SRCSCR)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCSCR INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCSCR\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCSCR DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(SRCCMD)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCCMD INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCCMD\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCCMD DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(DS1)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS1\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS2)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS2\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS3)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS3\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(5) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS4)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS4\") UNIT(\"ALUNIT\") NEW \",\n  \"LRECL(133) BLKSIZE(26600) SPACE(2,1) CYLINDERS RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS5)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS5\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nADDRESS ISPEXEC \"VGET TABLEOPT PROFILE\"\nIF TABLEOPT = \"PERM\" THEN DO\n  SRCCMD   = \"****NOT USED****\"\n  SRCSCR   = \"****NOT USED****\"\nEND\nADDRESS ISPEXEC \"VPUT AUD PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT USERCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT DS1 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT DS2 PROFILE\" /* ALWAYS PASS THESE */\nADDRESS ISPEXEC \"VPUT DS3 PROFILE\" /* VALUES ON TO MAIN */\nADDRESS ISPEXEC \"VPUT DS4 PROFILE\" /* ROUTINE..DIR      */\nADDRESS ISPEXEC \"VPUT DS5 PROFILE\" /*                   */\nADDRESS ISPEXEC \"VPUT DS6 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT SCRLOAD PROFILE\"\n                                  /**********************************/\nIF TYPE = \"NOREINIT\" THEN EXIT 00 /* NOTHING BELOW NEEDS TO BE DONE */\n                                  /* EVERY TIME HE LOGS ON.         */\n                                  /**********************************/\n\nCONVOPT  = \"DATASET\"             /* OUTPUT OPTION FOR CONVERT       */\nCONVOPT  = \"INTERNAL\"            /* OUTPUT OPTION FOR CONVERT       */\n\nDEFDEPT  = \"CBHUSER\"             /* DEFAULT OMVS GROUP FOR ACIDS */\nDEFGROUP = \"PRODGRP\"             /* DEFAULT OMVS GROUP FOR ACIDS */\n\n            /* NO QUOTES! */\nDSBACK   = \"SYS4.SPI.IDBACKUP\"    /* A PDS WITH NO QUOTES! */\n            /* NO QUOTES! */\n\nMSCA     = \"JOHNDOE\"              /* THE TOP SECRET MSCA ACID. */\n\nNEWPASS  = \"PASSWORD,60,EXP\"      /*  NEW PASSWORD DEFAULT     */\n\nPROD     = SYSID\n\nRECFILE  = \"'CO1PLEX.ZOS18.TSS90.RECFILE'\"   /* TSS RECOVERY FILE */\nTSAUD    = \"'CO1PLEX.ZOS18.TSS90.AUDIT'\"     /* TSS RECOVERY FILE */\nTSAUDID  = \"TSSAUDIT\"                /* TSS RECOVERY FILE */\n\nTESTV1   = \"VARIABLE 1\"\nTESTV2   = \"VARIABLE NUMBER TWO\"\n\nADDRESS ISPEXEC \"VPUT ALUNIT   PROFILE\"\nADDRESS ISPEXEC \"VPUT defgroup PROFILE\"\nADDRESS ISPEXEC \"VPUT CONVOPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DEFDEPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT JESNODE  PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGDSN   PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGFAIL  PROFILE\"\nADDRESS ISPEXEC \"VPUT MSCA     PROFILE\"\nADDRESS ISPEXEC \"VPUT NEWPASS  PROFILE\"\nADDRESS ISPEXEC \"VPUT JCARD    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT RECFILE  PROFILE\"\nADDRESS ISPEXEC \"VPUT TSAUDID  PROFILE\"\nADDRESS ISPEXEC \"VPUT TSAUD    PROFILE\"\nADDRESS ISPEXEC \"VPUT VARLIST  PROFILE\"\nSIGNAL OFF ERROR\nDO CNT = 1 TO WORDS(VARLIST)\n  VNAME = WORD(VARLIST,CNT)\n  ADDRESS ISPEXEC \"VPUT \" VNAME \"PROFILE \"\n  IF RC /= 0 THEN DO\n    MSG2 = \"$$ VPUT FOR  VARIABLE \" VNAME \" FAILED IN T$$ EXEC\"\n    CLEARMSG = \"NO\"\n    ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\n  END\nEND\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T$$CO1B": {"ttr": 6151, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x02\\x18o\\x01\\x02\\x18o\\t6\\x00\\xb9\\x00\\xb9\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-07-05T00:00:00", "modifydate": "2002-07-05T09:36:06", "lines": 185, "newlines": 185, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T$$co1a                           **/\n/** LAST MODIFIED    :  2 mar 2001                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      : THE USERID                                 **/\n/** AUTHNUM : 1 - 10                                     **/\n/** TYPE    : \"REINIT\" OR  \"NOREINIT\"                    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00  ONLY                     **/\n/** ISPF VARIABLES        - ANY YOU  WANT                **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES, BUT WHY ??                 **/\n/** ISPF ENVIRONMENT   : MOST DEFINATELY                 **/\n/** EXECS CALLED WITHIN THIS EXEC : ANY YOU WANT         **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\nARG ID AUTHNUM TYPE\n                       /***************************************/\n                       /** SAMPLE OF A HARDCODED DS PREFIX   **/\n                       /***************************************/\nDS1      = \"'TECH.\"||ID||\".C1'\"\nDS2      = \"'TECH.\"||ID||\".C2'\"\nDS3      = \"'TECH.\"||ID||\".C3'\"\nDS4      = \"'TECH.\"||ID||\".C4'\"\nDS5      = \"'TECH.\"||ID||\".C5'\"\n                       /******************************/\n                       /** USE THE IDS TSO PREFIX   **/\n                       /******************************/\nDS1      = \"C1\"        /* LRECL 80 INTERIM OUTPUT    */\nDS2      = \"C2\"        /* LRECL CONVERT OUTPUT       */\nDS3      = \"C3\"        /* LRECL 80 JCL/DEBUG OUTPUT  */\nDS4      = \"C4\"        /* LRECL 133 OUTPUT           */\nDS5      = \"C5\"        /* LRECL 80 JCL OUTPUT        */\n                       /******************************/\nDS6      = \"'sys4.spi.PARMLIB(JCSOURCE)'\"\nJCARD    = \" 98000,'TSS-JOB',CLASS=R,MSGCLASS=Z \"\nSRCCMD   = \"'sys4.spi.PARMLIB(CORECMD)'\"\nUSERCMD  = \"'sys4.spi.PARMLIB(USERCMD)'\" /* YOUR COMMAND OVERRIDES */\nLOGDSN   = \"TSADMIN.LOG\"\nLOGDSN   = \"'sys4.spi.LOG(\"ID\")'\"\nLOGDSN   = \"NONE\"\nLOGFAIL  = \"YES\"     /* FAIL A FUNCTION IF THE LOG ISNT WORKING */\nLOGFAIL  = \"NO\"      /* DONT FAIL A FUNCTION IF THE LOG ISNT WORKING */\nSRCSCR   = \"'sys4.spi.PARMLIB(CORESCR)'\"\nALUNIT   = \"SYSALLDA\"\nSCRLOAD  = \"YES\"\nJESNODE  = \"CO1AJES\"\n/*************************************************************/\n/** THE BELOW list is of customized variables that you want  */\n/** to be available to the main panel routine. They will     */\n/** be refreshed on a REINIT.                                */\n/*************************************************************/\nTSOUNIT  = \"3390\"\nTSOSIZE  = \"6144\"\nVARLIST = \"TSOUNIT TSOSIZE\"\n/*************************************************************/\n/** THE BELOW CHECK IS TO INSURE YOU GET THE CORRECT SYSTEM  */\n/** VARIABLES IN CASE YOU ARE RUNNING MULTIPLE IMAGES        */\n/*************************************************************/\nTHISINI = SYSVAR(SYSICMD)\nADDRESS ISPEXEC \" VGET LASTINI  PROFILE\"\nIF LASTINI \\= THISINI THEN DO\n  LASTINI = THISINI\n  ADDRESS ISPEXEC \"VPUT LASTINI PROFILE\" /* SET THE LASTINI NAME   */\n  TYPE = \"REINIT\"  /* LETS RESET ALL THE VARIABLES */\n  MSG2 = \"$$ A REINIT WAS FORCED DUE TO SYSID MISMATCH FROM LAST INIT\"\n  CLEARMSG = \"NO\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n  ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\nEND\nIF SYSDSN(SRCSCR)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCSCR INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCSCR\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCSCR DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(SRCCMD)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCCMD INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCCMD\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCCMD DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(DS1)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS1\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS2)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS2\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS3)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS3\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(5) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS4)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS4\") UNIT(\"ALUNIT\") NEW \",\n  \"LRECL(133) BLKSIZE(26600) SPACE(2,1) CYLINDERS RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS5)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS5\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nADDRESS ISPEXEC \"VGET TABLEOPT PROFILE\"\nIF TABLEOPT = \"PERM\" THEN DO\n  SRCCMD   = \"****NOT USED****\"\n  SRCSCR   = \"****NOT USED****\"\nEND\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT USERCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT DS1 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT DS2 PROFILE\" /* ALWAYS PASS THESE */\nADDRESS ISPEXEC \"VPUT DS3 PROFILE\" /* VALUES ON TO MAIN */\nADDRESS ISPEXEC \"VPUT DS4 PROFILE\" /* ROUTINE..DIR      */\nADDRESS ISPEXEC \"VPUT DS5 PROFILE\" /*                   */\nADDRESS ISPEXEC \"VPUT DS6 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT SCRLOAD PROFILE\"\n                                  /**********************************/\nIF TYPE = \"NOREINIT\" THEN EXIT 00 /* NOTHING BELOW NEEDS TO BE DONE */\n                                  /* EVERY TIME HE LOGS ON.         */\n                                  /**********************************/\n\nCONVOPT  = \"DATASET\"             /* OUTPUT OPTION FOR CONVERT       */\nCONVOPT  = \"INTERNAL\"            /* OUTPUT OPTION FOR CONVERT       */\n\nDEFDEPT  = \"CBHUSER\"             /* DEFAULT OMVS GROUP FOR ACIDS */\nDEFGROUP = \"PRODGRP\"             /* DEFAULT OMVS GROUP FOR ACIDS */\n\n            /* NO QUOTES! */\nDSBACK   = \"SYS4.SPI.IDBACKUP\"    /* A PDS WITH NO QUOTES! */\n            /* NO QUOTES! */\n\nMSCA     = \"JOHNDOE\"              /* THE TOP SECRET MSCA ACID. */\n\nNEWPASS  = \"PASSWORD,60,EXP\"      /*  NEW PASSWORD DEFAULT     */\n\nPROD     = SYSID\n\nRECFILE  = \"'SYS2.TSS51.RECFILE'\"    /* TSS RECOVERY FILE */\nTSAUD    = \"'SYS2.TSS51.AUDIT'\"      /* TSS RECOVERY FILE */\nTSAUDID  = \"TSSAUDIT\"                /* TSS RECOVERY FILE */\n\nTESTV1   = \"VARIABLE 1\"\nTESTV2   = \"VARIABLE NUMBER TWO\"\n\nADDRESS ISPEXEC \"VPUT ALUNIT   PROFILE\"\nADDRESS ISPEXEC \"VPUT defgroup PROFILE\"\nADDRESS ISPEXEC \"VPUT CONVOPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DEFDEPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT JESNODE  PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGDSN   PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGFAIL  PROFILE\"\nADDRESS ISPEXEC \"VPUT MSCA     PROFILE\"\nADDRESS ISPEXEC \"VPUT NEWPASS  PROFILE\"\nADDRESS ISPEXEC \"VPUT JCARD    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT RECFILE  PROFILE\"\nADDRESS ISPEXEC \"VPUT TSAUDID  PROFILE\"\nADDRESS ISPEXEC \"VPUT TSAUD    PROFILE\"\nADDRESS ISPEXEC \"VPUT VARLIST  PROFILE\"\nSIGNAL OFF ERROR\nDO CNT = 1 TO WORDS(VARLIST)\n  VNAME = WORD(VARLIST,CNT)\n  ADDRESS ISPEXEC \"VPUT \" VNAME \"PROFILE \"\n  IF RC /= 0 THEN DO\n    MSG2 = \"$$ VPUT FOR  VARIABLE \" VNAME \" FAILED IN T$$ EXEC\"\n    CLEARMSG = \"NO\"\n    ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\n  END\nEND\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T$$CO2B": {"ttr": 13069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x19\\x01\\x005_\\x01\\x07\\x16O\\x13\\x19\\x00\\xbb\\x00\\xbb\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2000-12-20T00:00:00", "modifydate": "2007-06-13T13:19:19", "lines": 187, "newlines": 187, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T$$co2b                           **/\n/** LAST MODIFIED    :  2 mar 2001                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      : THE USERID                                 **/\n/** AUTHNUM : 1 - 10                                     **/\n/** TYPE    : \"REINIT\" OR  \"NOREINIT\"                    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00  ONLY                     **/\n/** ISPF VARIABLES        - ANY YOU  WANT                **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES, BUT WHY ??                 **/\n/** ISPF ENVIRONMENT   : MOST DEFINATELY                 **/\n/** EXECS CALLED WITHIN THIS EXEC : ANY YOU WANT         **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\nARG ID AUTHNUM TYPE\nAUTHCODE = \"-989991699884\"\n                       /***************************************/\n                       /** SAMPLE OF A HARDCODED DS PREFIX   **/\n                       /***************************************/\nDS1      = \"'TECH.\"||ID||\".C1'\"\nDS2      = \"'TECH.\"||ID||\".C2'\"\nDS3      = \"'TECH.\"||ID||\".C3'\"\nDS4      = \"'TECH.\"||ID||\".C4'\"\nDS5      = \"'TECH.\"||ID||\".C5'\"\n                       /******************************/\n                       /** USE THE IDS TSO PREFIX   **/\n                       /******************************/\nDS1      = \"C1\"        /* LRECL 80 INTERIM OUTPUT    */\nDS2      = \"C2\"        /* LRECL CONVERT OUTPUT       */\nDS3      = \"C3\"        /* LRECL 80 JCL/DEBUG OUTPUT  */\nDS4      = \"C4\"        /* LRECL 133 OUTPUT           */\nDS5      = \"C5\"        /* LRECL 80 JCL OUTPUT        */\n                       /******************************/\nDS6      = \"'sys4.spi.PARMLIB(JCSOURCE)'\"\nJCARD    = \" 98000,'TSS-JOB',CLASS=R,MSGCLASS=Z \"\nSRCCMD   = \"'sys4.spi.PARMLIB(CORECMD)'\"\nUSERCMD  = \"'sys4.spi.PARMLIB(USERCMD)'\" /* YOUR COMMAND OVERRIDES */\nLOGDSN   = \"TSADMIN.LOG\"\nLOGDSN   = \"'sys4.spi.LOG(\"ID\")'\"\nLOGDSN   = \"NONE\"\nLOGFAIL  = \"YES\"     /* FAIL A FUNCTION IF THE LOG ISNT WORKING */\nLOGFAIL  = \"NO\"      /* DONT FAIL A FUNCTION IF THE LOG ISNT WORKING */\nSRCSCR   = \"'sys4.spi.PARMLIB(CORESCR)'\"\nALUNIT   = \"SYSALLDA\"\nSCRLOAD  = \"YES\"\nJESNODE  = \"CO2AJES\"\n/*************************************************************/\n/** THE BELOW list is of customized variables that you want  */\n/** to be available to the main panel routine. They will     */\n/** be refreshed on a REINIT.                                */\n/*************************************************************/\nTSOUNIT  = \"3390\"\nTSOSIZE  = \"6144\"\nVARLIST = \"TSOUNIT TSOSIZE\"\n/*************************************************************/\n/** THE BELOW CHECK IS TO INSURE YOU GET THE CORRECT SYSTEM  */\n/** VARIABLES IN CASE YOU ARE RUNNING MULTIPLE IMAGES        */\n/*************************************************************/\nTHISINI = SYSVAR(SYSICMD)\nADDRESS ISPEXEC \" VGET LASTINI  PROFILE\"\nIF LASTINI \\= THISINI THEN DO\n  LASTINI = THISINI\n  ADDRESS ISPEXEC \"VPUT LASTINI PROFILE\" /* SET THE LASTINI NAME   */\n  TYPE = \"REINIT\"  /* LETS RESET ALL THE VARIABLES */\n  MSG2 = \"$$ A REINIT WAS FORCED DUE TO SYSID MISMATCH FROM LAST INIT\"\n  CLEARMSG = \"NO\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n  ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\nEND\nIF SYSDSN(SRCSCR)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCSCR INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCSCR\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCSCR DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(SRCCMD)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCCMD INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCCMD\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCCMD DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(DS1)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS1\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS2)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS2\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS3)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS3\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(5) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS4)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS4\") UNIT(\"ALUNIT\") NEW \",\n  \"LRECL(133) BLKSIZE(26600) SPACE(2,1) CYLINDERS RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS5)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS5\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nADDRESS ISPEXEC \"VGET TABLEOPT PROFILE\"\nIF TABLEOPT = \"PERM\" THEN DO\n  SRCCMD   = \"****NOT USED****\"\n  SRCSCR   = \"****NOT USED****\"\nEND\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT USERCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT AUTHCODE PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT DS1 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT DS2 PROFILE\" /* ALWAYS PASS THESE */\nADDRESS ISPEXEC \"VPUT DS3 PROFILE\" /* VALUES ON TO MAIN */\nADDRESS ISPEXEC \"VPUT DS4 PROFILE\" /* ROUTINE..DIR      */\nADDRESS ISPEXEC \"VPUT DS5 PROFILE\" /*                   */\nADDRESS ISPEXEC \"VPUT DS6 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT SCRLOAD PROFILE\"\n                                  /**********************************/\nIF TYPE = \"NOREINIT\" THEN EXIT 00 /* NOTHING BELOW NEEDS TO BE DONE */\n                                  /* EVERY TIME HE LOGS ON.         */\n                                  /**********************************/\n\nCONVOPT  = \"DATASET\"             /* OUTPUT OPTION FOR CONVERT       */\nCONVOPT  = \"INTERNAL\"            /* OUTPUT OPTION FOR CONVERT       */\n\nDEFDEPT  = \"CBHUSER\"             /* DEFAULT OMVS GROUP FOR ACIDS */\nDEFGROUP = \"PRODGRP\"             /* DEFAULT OMVS GROUP FOR ACIDS */\n\n            /* NO QUOTES! */\nDSBACK   = \"SYS4.SPI.IDBACKUP\"    /* A PDS WITH NO QUOTES! */\n            /* NO QUOTES! */\n\nMSCA     = \"COA1TSS\"              /* THE TOP SECRET MSCA ACID. */\n\nNEWPASS  = \"PASSWORD,60,EXP\"      /*  NEW PASSWORD DEFAULT     */\n\nPROD     = SYSID\n\nRECFILE  = \"'CO2PLEX.ZOS16.TSS80.RECFILE'\" /* TSS RECOVERY FILE */\nTSAUD    = \"'CO2PLEX.ZOS16.TSS80.AUDIT'\" /* TSS RECOVERY FILE */\nTSAUDID  = \"TSSAUDIT\"                /* TSS RECOVERY FILE */\n\nTESTV1   = \"VARIABLE 1\"\nTESTV2   = \"VARIABLE NUMBER TWO\"\n\nADDRESS ISPEXEC \"VPUT ALUNIT   PROFILE\"\nADDRESS ISPEXEC \"VPUT defgroup PROFILE\"\nADDRESS ISPEXEC \"VPUT CONVOPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DEFDEPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT JESNODE  PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGDSN   PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGFAIL  PROFILE\"\nADDRESS ISPEXEC \"VPUT MSCA     PROFILE\"\nADDRESS ISPEXEC \"VPUT NEWPASS  PROFILE\"\nADDRESS ISPEXEC \"VPUT JCARD    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT RECFILE  PROFILE\"\nADDRESS ISPEXEC \"VPUT TSAUDID  PROFILE\"\nADDRESS ISPEXEC \"VPUT TSAUD    PROFILE\"\nADDRESS ISPEXEC \"VPUT VARLIST  PROFILE\"\nSIGNAL OFF ERROR\nDO CNT = 1 TO WORDS(VARLIST)\n  VNAME = WORD(VARLIST,CNT)\n  ADDRESS ISPEXEC \"VPUT \" VNAME \"PROFILE \"\n  IF RC /= 0 THEN DO\n    MSG2 = \"$$ VPUT FOR  VARIABLE \" VNAME \" FAILED IN T$$ EXEC\"\n    CLEARMSG = \"NO\"\n    ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\n  END\nEND\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T$$ISTE": {"ttr": 15623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00@\\x01\\x14!?\\x01\\x14!o\\x13\\x04\\x00\\xb1\\x00\\xb1\\x00\\x00\\xc7\\xd9\\xd7\\xe3\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2014-08-01T00:00:00", "modifydate": "2014-08-04T13:04:40", "lines": 177, "newlines": 177, "modlines": 0, "user": "GRPTDIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** THE CUSTOM INIT SAMPLE MEMBER                        **/\n/** COPY THIS MEMBER TO T$$XXXX WHERE XXXX IS YOUR SYSID **/\n/**********************************************************/\n/** EXEC NAME        : T$$SAMP                           **/\n/** LAST MODIFIED    :  30 jul 2014                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      : THE USERID                                 **/\n/** AUTHNUM : 1 - 10                                     **/\n/** TYPE    : \"REINIT\" OR  \"NOREINIT\"                    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00  ONLY                     **/\n/** ISPF VARIABLES        - ANY YOU  WANT                **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES, BUT WHY ??                 **/\n/** ISPF ENVIRONMENT   : MOST DEFINATELY                 **/\n/** EXECS CALLED WITHIN THIS EXEC : ANY YOU WANT         **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\nARG ID AUTHNUM TYPE\n                       /***************************************/\n                       /** SAMPLE OF A HARDCODED DS PREFIX   **/\n                       /***************************************/\nDS1      = \"'TECH.\"||ID||\".C1'\"\nDS2      = \"'TECH.\"||ID||\".C2'\"\nDS3      = \"'TECH.\"||ID||\".C3'\"\nDS4      = \"'TECH.\"||ID||\".C4'\"\nDS5      = \"'TECH.\"||ID||\".C5'\"\n                       /******************************/\n                       /** USE THE IDS TSO PREFIX   **/\n                       /******************************/\nDS1      = \"C1\"        /* LRECL 80 INTERIM OUTPUT    */\nDS2      = \"C2\"        /* LRECL CONVERT OUTPUT       */\nDS3      = \"C3\"        /* LRECL 80 JCL/DEBUG OUTPUT  */\nDS4      = \"C4\"        /* LRECL 133 OUTPUT           */\nDS5      = \"C5\"        /* LRECL 80 JCL OUTPUT        */\n                       /******************************/\nDS6      = \"'sys3.spi.PARMLIB(JCSOURCE)'\"\nJCARD    = \" 98000,'TSS-JOB',CLASS=A,MSGCLASS=Q \"\nSRCCMD   = \"'sys3.spi.PARMLIB(CORECMD)'\"\nUSERCMD  = \"'sys3.spi.PARMLIB(USERCMD)'\" /* YOUR COMMAND OVERRIDES */\nLOGDSN   = \"TSADMIN.LOG\"\nLOGDSN   = \"'sys3.spi.LOG(\"ID\")'\"\nLOGDSN   = \"NONE\"\nLOGFAIL  = \"YES\"     /* FAIL A FUNCTION IF THE LOG ISNT WORKING */\nLOGFAIL  = \"NO\"      /* DONT FAIL A FUNCTION IF THE LOG ISNT WORKING */\nSRCSCR   = \"'sys3.spi.PARMLIB(CORESCR)'\"\nALUNIT   = \"SYSALLDA\"\nSCRLOAD  = \"YES\"\npanel    = \"SPIMAIN\"\nJESNODE  = \"TECS\"\nTHISINI = SYSVAR(SYSICMD)\n/*************************************************************/\n/** THE BELOW CHECK IS TO INSURE YOU GET THE CORRECT SYSTEM  */\n/** VARIABLES IN CASE YOU ARE RUNNING MULTIPLE IMAGES        */\n/*************************************************************/\nADDRESS ISPEXEC \" VGET LASTINI  PROFILE\"\nIF LASTINI \\= THISINI THEN DO\n  LASTINI = THISINI\n  ADDRESS ISPEXEC \"VPUT LASTINI PROFILE\" /* SET THE LASTINI NAME   */\n  TYPE = \"REINIT\"  /* LETS RESET ALL THE VARIABLES */\n  MSG2 = \"$$ A REINIT WAS FORCED DUE TO SYSID MISMATCH FROM LAST INIT\"\n  CLEARMSG = \"NO\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n  ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\nEND\nIF SYSDSN(SRCSCR)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCSCR INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCSCR\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCSCR DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(SRCCMD)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCCMD INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCCMD\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCCMD DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(DS1)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS1\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS2)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS2\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS3)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS3\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(5) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS4)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS4\") UNIT(\"ALUNIT\") NEW \",\n  \"LRECL(133) BLKSIZE(26600) SPACE(2,1) CYLINDERS RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS5)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS5\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nADDRESS ISPEXEC \"VGET TABLEOPT PROFILE\"\nIF TABLEOPT = \"PERM\" THEN DO\n  SRCCMD   = \"****NOT USED****\"\n  SRCSCR   = \"****NOT USED****\"\nEND\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT PANEL  PROFILE\"\nADDRESS ISPEXEC \"VPUT USERCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT DS1 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT DS2 PROFILE\" /* ALWAYS PASS THESE */\nADDRESS ISPEXEC \"VPUT DS3 PROFILE\" /* VALUES ON TO MAIN */\nADDRESS ISPEXEC \"VPUT DS4 PROFILE\" /* ROUTINE..DIR      */\nADDRESS ISPEXEC \"VPUT DS5 PROFILE\" /*                   */\nADDRESS ISPEXEC \"VPUT DS6 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT SCRLOAD PROFILE\"\n                                  /**********************************/\nIF TYPE = \"NOREINIT\" THEN EXIT 00 /* NOTHING BELOW NEEDS TO BE DONE */\n                                  /* EVERY TIME HE LOGS ON.         */\n                                  /**********************************/\n\nCONVOPT  = \"DATASET\"             /* OUTPUT OPTION FOR CONVERT       */\nCONVOPT  = \"INTERNAL\"            /* OUTPUT OPTION FOR CONVERT       */\n\nDEFGROUP = \"PRODGRP\"             /* DEFAULT OMVS GROUP FOR ACIDS */\n\n            /* NO QUOTES! */\nDSBACK   = \"GRDP.SCA.IDBACKUP\"    /* A PDS WITH NO QUOTES! */\n            /* NO QUOTES! */\n\nMSCA     = \"YOURMSCA\"             /* THE TOP SECRET MSCA ACID. */\n\nNEWPASS  = \"PASSWORD,60,EXP\"      /*  NEW PASSWORD DEFAULT     */\n\nPROD     = SYSID\n\nRECFILE  = \"'SYS2.TSS.RECFILE'\"    /* TSS RECOVERY FILE */\n\nTESTV1   = \"VARIABLE 1\"\nTESTV2   = \"VARIABLE NUMBER TWO\"\nVARLIST = \" TESTV1 TESTV2\"\n\nADDRESS ISPEXEC \"VPUT ALUNIT   PROFILE\"\nADDRESS ISPEXEC \"VPUT DEFGROUP PROFILE\"\nADDRESS ISPEXEC \"VPUT CONVOPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT JESNODE  PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGDSN   PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGFAIL  PROFILE\"\nADDRESS ISPEXEC \"VPUT MSCA     PROFILE\"\nADDRESS ISPEXEC \"VPUT NEWPASS  PROFILE\"\nADDRESS ISPEXEC \"VPUT JCARD    PROFILE\"\nADDRESS ISPEXEC \"VPUT PANEL    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT RECFILE  PROFILE\"\nADDRESS ISPEXEC \"VPUT VARLIST  PROFILE\"\nSIGNAL OFF ERROR\nDO CNT = 1 TO WORDS(VARLIST)\n  VNAME = WORD(VARLIST,CNT)\n  ADDRESS ISPEXEC \"VPUT \" VNAME \"PROFILE \"\n  IF RC /= 0 THEN DO\n    MSG2 = \"$$ VPUT FOR  VARIABLE \" VNAME \" FAILED IN T$$ EXEC\"\n    CLEARMSG = \"NO\"\n    ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\n  END\nEND\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T$$SAMP": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0e\\x00I\\x00\\x99\\x08\\x8f\\x01\\x01\\x19\\x1f\\x08\"\\x00\\xb1\\x00\\xb1\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.14", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "2001-07-10T08:22:49", "lines": 177, "newlines": 177, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** THE CUSTOM INIT SAMPLE MEMBER                        **/\n/** COPY THIS MEMBER TO T$$XXXX WHERE XXXX IS YOUR SYSID **/\n/**********************************************************/\n/** EXEC NAME        : T$$SAMP                           **/\n/** LAST MODIFIED    :  2 JAN 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      : THE USERID                                 **/\n/** AUTHNUM : 1 - 10                                     **/\n/** TYPE    : \"REINIT\" OR  \"NOREINIT\"                    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00  ONLY                     **/\n/** ISPF VARIABLES        - ANY YOU  WANT                **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES, BUT WHY ??                 **/\n/** ISPF ENVIRONMENT   : MOST DEFINATELY                 **/\n/** EXECS CALLED WITHIN THIS EXEC : ANY YOU WANT         **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\nARG ID AUTHNUM TYPE\n                       /***************************************/\n                       /** SAMPLE OF A HARDCODED DS PREFIX   **/\n                       /***************************************/\nDS1      = \"'TECH.\"||ID||\".C1'\"\nDS2      = \"'TECH.\"||ID||\".C2'\"\nDS3      = \"'TECH.\"||ID||\".C3'\"\nDS4      = \"'TECH.\"||ID||\".C4'\"\nDS5      = \"'TECH.\"||ID||\".C5'\"\n                       /******************************/\n                       /** USE THE IDS TSO PREFIX   **/\n                       /******************************/\nDS1      = \"C1\"        /* LRECL 80 INTERIM OUTPUT    */\nDS2      = \"C2\"        /* LRECL CONVERT OUTPUT       */\nDS3      = \"C3\"        /* LRECL 80 JCL/DEBUG OUTPUT  */\nDS4      = \"C4\"        /* LRECL 133 OUTPUT           */\nDS5      = \"C5\"        /* LRECL 80 JCL OUTPUT        */\n                       /******************************/\nDS6      = \"'coa1dir.SPI.PARMLIB(JCSOURCE)'\"\nJCARD    = \" 98000,'TSS-JOB',CLASS=A,MSGCLASS=Q \"\nSRCCMD   = \"'coa1dir.SPI.PARMLIB(CORECMD)'\"\nUSERCMD  = \"'coa1dir.SPI.PARMLIB(USERCMD)'\" /* YOUR COMMAND OVERRIDES */\nLOGDSN   = \"TSADMIN.LOG\"\nLOGDSN   = \"'coa1dir.SPI.LOG(\"ID\")'\"\nLOGDSN   = \"NONE\"\nLOGFAIL  = \"YES\"     /* FAIL A FUNCTION IF THE LOG ISNT WORKING */\nLOGFAIL  = \"NO\"      /* DONT FAIL A FUNCTION IF THE LOG ISNT WORKING */\nSRCSCR   = \"'coa1dir.SPI.PARMLIB(CORESCR)'\"\nALUNIT   = \"SYSALLDA\"\nSCRLOAD  = \"YES\"\npanel    = \"SPIMAIN\"\nJESNODE  = \"IMSJES2\"\nTHISINI = SYSVAR(SYSICMD)\n/*************************************************************/\n/** THE BELOW CHECK IS TO INSURE YOU GET THE CORRECT SYSTEM  */\n/** VARIABLES IN CASE YOU ARE RUNNING MULTIPLE IMAGES        */\n/*************************************************************/\nADDRESS ISPEXEC \" VGET LASTINI  PROFILE\"\nIF LASTINI \\= THISINI THEN DO\n  LASTINI = THISINI\n  ADDRESS ISPEXEC \"VPUT LASTINI PROFILE\" /* SET THE LASTINI NAME   */\n  TYPE = \"REINIT\"  /* LETS RESET ALL THE VARIABLES */\n  MSG2 = \"$$ A REINIT WAS FORCED DUE TO SYSID MISMATCH FROM LAST INIT\"\n  CLEARMSG = \"NO\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n  ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\nEND\nIF SYSDSN(SRCSCR)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCSCR INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCSCR\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCSCR DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(SRCCMD)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCCMD INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCCMD\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCCMD DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(DS1)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS1\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS2)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS2\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS3)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS3\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(5) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS4)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS4\") UNIT(\"ALUNIT\") NEW \",\n  \"LRECL(133) BLKSIZE(26600) SPACE(2,1) CYLINDERS RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS5)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS5\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nADDRESS ISPEXEC \"VGET TABLEOPT PROFILE\"\nIF TABLEOPT = \"PERM\" THEN DO\n  SRCCMD   = \"****NOT USED****\"\n  SRCSCR   = \"****NOT USED****\"\nEND\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT PANEL  PROFILE\"\nADDRESS ISPEXEC \"VPUT USERCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT DS1 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT DS2 PROFILE\" /* ALWAYS PASS THESE */\nADDRESS ISPEXEC \"VPUT DS3 PROFILE\" /* VALUES ON TO MAIN */\nADDRESS ISPEXEC \"VPUT DS4 PROFILE\" /* ROUTINE..DIR      */\nADDRESS ISPEXEC \"VPUT DS5 PROFILE\" /*                   */\nADDRESS ISPEXEC \"VPUT DS6 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT SCRLOAD PROFILE\"\n                                  /**********************************/\nIF TYPE = \"NOREINIT\" THEN EXIT 00 /* NOTHING BELOW NEEDS TO BE DONE */\n                                  /* EVERY TIME HE LOGS ON.         */\n                                  /**********************************/\n\nCONVOPT  = \"DATASET\"             /* OUTPUT OPTION FOR CONVERT       */\nCONVOPT  = \"INTERNAL\"            /* OUTPUT OPTION FOR CONVERT       */\n\nDEFGROUP = \"PRODGRP\"             /* DEFAULT OMVS GROUP FOR ACIDS */\n\n            /* NO QUOTES! */\nDSBACK   = \"TECH.SCA.IDBACKUP\"    /* A PDS WITH NO QUOTES! */\n            /* NO QUOTES! */\n\nMSCA     = \"JOHNDOE\"              /* THE TOP SECRET MSCA ACID. */\n\nNEWPASS  = \"PASSWORD,60,EXP\"      /*  NEW PASSWORD DEFAULT     */\n\nPROD     = SYSID\n\nRECFILE  = \"'SYS2.TSS.RECFILE'\"    /* TSS RECOVERY FILE */\n\nTESTV1   = \"VARIABLE 1\"\nTESTV2   = \"VARIABLE NUMBER TWO\"\nVARLIST = \" TESTV1 TESTV2\"\n\nADDRESS ISPEXEC \"VPUT ALUNIT   PROFILE\"\nADDRESS ISPEXEC \"VPUT DEFGROUP PROFILE\"\nADDRESS ISPEXEC \"VPUT CONVOPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT JESNODE  PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGDSN   PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGFAIL  PROFILE\"\nADDRESS ISPEXEC \"VPUT MSCA     PROFILE\"\nADDRESS ISPEXEC \"VPUT NEWPASS  PROFILE\"\nADDRESS ISPEXEC \"VPUT JCARD    PROFILE\"\nADDRESS ISPEXEC \"VPUT PANEL    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT RECFILE  PROFILE\"\nADDRESS ISPEXEC \"VPUT VARLIST  PROFILE\"\nSIGNAL OFF ERROR\nDO CNT = 1 TO WORDS(VARLIST)\n  VNAME = WORD(VARLIST,CNT)\n  ADDRESS ISPEXEC \"VPUT \" VNAME \"PROFILE \"\n  IF RC /= 0 THEN DO\n    MSG2 = \"$$ VPUT FOR  VARIABLE \" VNAME \" FAILED IN T$$ EXEC\"\n    CLEARMSG = \"NO\"\n    ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\n  END\nEND\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T$$TECS": {"ttr": 14083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Q\\x01\\x14\\x15\\x7f\\x01\\x14\\x15\\x7f\\x14@\\x00\\xb1\\x00\\xb1\\x00\\x00\\xc7\\xd9\\xd7\\xe3\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-06-06T00:00:00", "modifydate": "2014-06-06T14:40:51", "lines": 177, "newlines": 177, "modlines": 0, "user": "GRPTDIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** THE CUSTOM INIT SAMPLE MEMBER                        **/\n/** COPY THIS MEMBER TO T$$XXXX WHERE XXXX IS YOUR SYSID **/\n/**********************************************************/\n/** EXEC NAME        : T$$SAMP                           **/\n/** LAST MODIFIED    :  2 JAN 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ID      : THE USERID                                 **/\n/** AUTHNUM : 1 - 10                                     **/\n/** TYPE    : \"REINIT\" OR  \"NOREINIT\"                    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00  ONLY                     **/\n/** ISPF VARIABLES        - ANY YOU  WANT                **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES, BUT WHY ??                 **/\n/** ISPF ENVIRONMENT   : MOST DEFINATELY                 **/\n/** EXECS CALLED WITHIN THIS EXEC : ANY YOU WANT         **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\nARG ID AUTHNUM TYPE\n                       /***************************************/\n                       /** SAMPLE OF A HARDCODED DS PREFIX   **/\n                       /***************************************/\nDS1      = \"'TECH.\"||ID||\".C1'\"\nDS2      = \"'TECH.\"||ID||\".C2'\"\nDS3      = \"'TECH.\"||ID||\".C3'\"\nDS4      = \"'TECH.\"||ID||\".C4'\"\nDS5      = \"'TECH.\"||ID||\".C5'\"\n                       /******************************/\n                       /** USE THE IDS TSO PREFIX   **/\n                       /******************************/\nDS1      = \"C1\"        /* LRECL 80 INTERIM OUTPUT    */\nDS2      = \"C2\"        /* LRECL CONVERT OUTPUT       */\nDS3      = \"C3\"        /* LRECL 80 JCL/DEBUG OUTPUT  */\nDS4      = \"C4\"        /* LRECL 133 OUTPUT           */\nDS5      = \"C5\"        /* LRECL 80 JCL OUTPUT        */\n                       /******************************/\nDS6      = \"'grptdir.SPI.PARMLIB(JCSOURCE)'\"\nJCARD    = \" 98000,'TSS-JOB',CLASS=A,MSGCLASS=Q \"\nSRCCMD   = \"'grptdir.SPI.PARMLIB(CORECMD)'\"\nUSERCMD  = \"'grptdir.SPI.PARMLIB(USERCMD)'\" /* YOUR COMMAND OVERRIDES */\nLOGDSN   = \"TSADMIN.LOG\"\nLOGDSN   = \"'grptdir.SPI.LOG(\"ID\")'\"\nLOGDSN   = \"NONE\"\nLOGFAIL  = \"YES\"     /* FAIL A FUNCTION IF THE LOG ISNT WORKING */\nLOGFAIL  = \"NO\"      /* DONT FAIL A FUNCTION IF THE LOG ISNT WORKING */\nSRCSCR   = \"'grptdir.SPI.PARMLIB(CORESCR)'\"\nALUNIT   = \"SYSALLDA\"\nSCRLOAD  = \"YES\"\npanel    = \"SPIMAIN\"\nJESNODE  = \"TECS\"\nTHISINI = SYSVAR(SYSICMD)\n/*************************************************************/\n/** THE BELOW CHECK IS TO INSURE YOU GET THE CORRECT SYSTEM  */\n/** VARIABLES IN CASE YOU ARE RUNNING MULTIPLE IMAGES        */\n/*************************************************************/\nADDRESS ISPEXEC \" VGET LASTINI  PROFILE\"\nIF LASTINI \\= THISINI THEN DO\n  LASTINI = THISINI\n  ADDRESS ISPEXEC \"VPUT LASTINI PROFILE\" /* SET THE LASTINI NAME   */\n  TYPE = \"REINIT\"  /* LETS RESET ALL THE VARIABLES */\n  MSG2 = \"$$ A REINIT WAS FORCED DUE TO SYSID MISMATCH FROM LAST INIT\"\n  CLEARMSG = \"NO\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n  ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\nEND\nIF SYSDSN(SRCSCR)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCSCR INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCSCR\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCSCR DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(SRCCMD)  /= \"OK\" THEN DO\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  SAY \"T$$XXXX: SRCCMD INPUT IS NOT ACCESSABLE.\"\n  SAY \"T$$XXXX: DSN = \" SRCCMD\n  SAY \"****************************************\"\n  SAY \"****************************************\"\n  MSG2 = \"$$ CATASTROPHIC ERROR SRCCMD DEFINITION IS UNAVAILABLE.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF SYSDSN(DS1)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS1\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS2)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS2\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS3)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS3\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(5) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS4)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS4\") UNIT(\"ALUNIT\") NEW \",\n  \"LRECL(133) BLKSIZE(26600) SPACE(2,1) CYLINDERS RECFM(F B) DSORG(PS)\"\nEND\nIF SYSDSN(DS5)  = \"DATASET NOT FOUND\" THEN DO\n  ADDRESS TSO \"ALLOC DSN(\"DS5\") UNIT(\"ALUNIT\") NEW \",\n  \"SPACE(10) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\nEND\nADDRESS ISPEXEC \"VGET TABLEOPT PROFILE\"\nIF TABLEOPT = \"PERM\" THEN DO\n  SRCCMD   = \"****NOT USED****\"\n  SRCSCR   = \"****NOT USED****\"\nEND\nADDRESS ISPEXEC \"VPUT SRCCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT PANEL  PROFILE\"\nADDRESS ISPEXEC \"VPUT USERCMD PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR PROFILE\"\nADDRESS ISPEXEC \"VPUT DS1 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT DS2 PROFILE\" /* ALWAYS PASS THESE */\nADDRESS ISPEXEC \"VPUT DS3 PROFILE\" /* VALUES ON TO MAIN */\nADDRESS ISPEXEC \"VPUT DS4 PROFILE\" /* ROUTINE..DIR      */\nADDRESS ISPEXEC \"VPUT DS5 PROFILE\" /*                   */\nADDRESS ISPEXEC \"VPUT DS6 PROFILE\" /*********************/\nADDRESS ISPEXEC \"VPUT SCRLOAD PROFILE\"\n                                  /**********************************/\nIF TYPE = \"NOREINIT\" THEN EXIT 00 /* NOTHING BELOW NEEDS TO BE DONE */\n                                  /* EVERY TIME HE LOGS ON.         */\n                                  /**********************************/\n\nCONVOPT  = \"DATASET\"             /* OUTPUT OPTION FOR CONVERT       */\nCONVOPT  = \"INTERNAL\"            /* OUTPUT OPTION FOR CONVERT       */\n\nDEFGROUP = \"PRODGRP\"             /* DEFAULT OMVS GROUP FOR ACIDS */\n\n            /* NO QUOTES! */\nDSBACK   = \"GRDP.SCA.IDBACKUP\"    /* A PDS WITH NO QUOTES! */\n            /* NO QUOTES! */\n\nMSCA     = \"JOHNDOE\"              /* THE TOP SECRET MSCA ACID. */\n\nNEWPASS  = \"PASSWORD,60,EXP\"      /*  NEW PASSWORD DEFAULT     */\n\nPROD     = SYSID\n\nRECFILE  = \"'SYS2.TSS.RECFILE'\"    /* TSS RECOVERY FILE */\n\nTESTV1   = \"VARIABLE 1\"\nTESTV2   = \"VARIABLE NUMBER TWO\"\nVARLIST = \" TESTV1 TESTV2\"\n\nADDRESS ISPEXEC \"VPUT ALUNIT   PROFILE\"\nADDRESS ISPEXEC \"VPUT DEFGROUP PROFILE\"\nADDRESS ISPEXEC \"VPUT CONVOPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT JESNODE  PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGDSN   PROFILE\"\nADDRESS ISPEXEC \"VPUT LOGFAIL  PROFILE\"\nADDRESS ISPEXEC \"VPUT MSCA     PROFILE\"\nADDRESS ISPEXEC \"VPUT NEWPASS  PROFILE\"\nADDRESS ISPEXEC \"VPUT JCARD    PROFILE\"\nADDRESS ISPEXEC \"VPUT PANEL    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT RECFILE  PROFILE\"\nADDRESS ISPEXEC \"VPUT VARLIST  PROFILE\"\nSIGNAL OFF ERROR\nDO CNT = 1 TO WORDS(VARLIST)\n  VNAME = WORD(VARLIST,CNT)\n  ADDRESS ISPEXEC \"VPUT \" VNAME \"PROFILE \"\n  IF RC /= 0 THEN DO\n    MSG2 = \"$$ VPUT FOR  VARIABLE \" VNAME \" FAILED IN T$$ EXEC\"\n    CLEARMSG = \"NO\"\n    ADDRESS ISPEXEC \" VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \" VPUT CLEARMSG PROFILE\"\n  END\nEND\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBMCMD": {"ttr": 5377, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x10\\x00@\\x00\\x99\\x08\\x8f\\x01\\x01\\x19\\x0f\\x13D\\x00{\\x00{\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.16", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "2001-07-09T13:44:40", "lines": 123, "newlines": 123, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** changed comment code to accept any leading asterisk  **/\n/**********************************************************/\n/** removed easyio processing for performance reasons    **/\n/**********************************************************/\n/** baseline baseline baseline baseline baseline baseline**/\n/**********************************************************/\n/** exec name        : tbmcmd                            **/\n/** last modified    : 07 Jul 2001                       **/\n/**----------------input required -----------------------**/\n/** passed args        valid values                      **/\n/** indsn   :  the flatfile ( or pds mem) that has the   **/\n/**            command list to be processed. you can use **/\n/**            the same command list for all auth levels **/\n/**            by merely changing the authmax arg below. **/\n/** outdsn  :  a dsn that is in the isptlib concatenation**/\n/**            for all users of the panel system.        **/\n/** tbname  :  the name of the output table, this must   **/\n/**            match the name specified in tssini.       **/\n/** authmax :  the maximum auth level of input command to**/\n/**            be included in the output table.          **/\n/** storeopt:  Should I store this table ?               **/\n/**                                                      **/\n/**----------------output produced-----------------------**/\n/** valid condition codes - 00                           **/\n/** ispf variables        - none                         **/\n/**----------------requirements--------------------------**/\n/** can run standalone : yes                             **/\n/** ispf environment   : yes                             **/\n/** my io routines     : N/A                             **/\n/** execs called within this exec : none                 **/\n/**                                                      **/\n/**********************************************************/\n/************************************************************/\nARG INDSN OUTDSN TBNAME AUTHMAX storeopt\n/********************************************/\nTB_PREFIX = \"TS5UCM\"\nIF INDSN   = \"\"  THEN INDSN = \"SYS3.TSS.PARMLIB(CMDLIST)\"\nIF INDSN   = \".\" THEN INDSN = \"SYS3.TSS.PARMLIB(CMDLIST)\"\nIF OUTDSN  = \"\"  THEN OUTDSN = \"SYS3.TSS.TABLE\"\nIF OUTDSN  = \".\"  THEN OUTDSN = \"'SYS3.TSS.TABLE'\"\nIF AUTHMAX = \"\"  THEN AUTHMAX  = \"10\"\nIF AUTHMAX = \".\"  THEN AUTHMAX  = \"10\"\nIF TBNAME  = \"\"  THEN TBNAME = TB_PREFIX||AUTHMAX\nIF TBNAME  = \".\"  THEN TBNAME = TB_PREFIX||AUTHMAX\nSAY \"TSA101D: TBMCMD PROVIDED VALUES RESOLVED TO:\"\nsay \"       indsn   :\" indsn\nsay \"       outdsn  :\" outdsn\nsay \"       tbname  :\" tbname\nsay \"       authmax :\" authmax\nsay \"       storeopt:\" storeopt\n/************************************************************/\n/*%include compispf  */\n/************************************************************/\ni = 0\n\"FREE DDN(INPUT1)\"\n\"FREE DDN(INPUT2)\"\n\"FREE DDN(OUTPUT)\"\nIF SUBSTR(INDSN,1,1) /= \"'\" THEN INDSN = \"'\"||INDSN||\"'\"\nIF SUBSTR(OUTDSN,1,1) /= \"'\" THEN OUTDSN = \"'\"||OUTDSN||\"'\"\nsay \"TSA101D: TBMCMD  indsn resolved to :\" indsn\nsay \"TSA101D: TBMCMD  outdsn resolved to :\" outdsn\naddress ispexec \"vget srccmd profile\"\n\"ALLOC DDN(INPUT1) DSN(\"SRCCMD\") SHR REUS\"\n\"ALLOC DDN(INPUT2) DSN(\"INDSN\") SHR REUS\"\n\"ALLOC DDN(OUTPUT) DSN(\"OUTDSN\") SHR REUS\"\nSIGNAL OFF ERROR\nIF STOREOPT /= \"NO\" THEN\n  ADDRESS ISPEXEC \"TBERASE \"TBNAME \"LIBRARY(OUTPUT)\"\nERASERC = RC\nSAY \"TSA101D: TBMCMD TBERASE RETURN CODE FOR \"TBNAME \"IS \" ERASERC\nIF (ERASERC = 8) & (storeopt = \"YES\")  THEN DO\n  SAY \"**********************************************************\"\n  SAY \"**WARNING: TABLE MAY BE IN USE, WHICH WILL PREVENT UPDATES\"\n  SAY \"**********************************************************\"\nEND\nADDRESS ISPEXEC \"TBCREATE \"TBNAME\" KEYS(CMDNAME) \",\n \"NAMES(PGMNAME MSGOPT DATACK DATA2CK AUTH TRAPOPT BATCHOPT VARS) SHARE\"\nTBMAKERC = RC\nSAY \"TSA101D: TBMCMD TBCREATE RETURN CODE FOR \"TBNAME \"IS \" TBMAKERC\n/* CALL FILEREAD \"INPUT1\"                 READ DDNAME INPUT1 */\nRECNUM = RESULT\n\"EXECIO * DISKR INPUT1 ( FINIS STEM HOLD.)\"\n\"EXECIO * DISKR INPUT2 ( FINIS STEM temp.)\"\nrecnum = hold.0 + temp.0\ndo tz1 = hold.0 to recnum\n  i = i + 1\n  hold.tz1 = temp.i\nend\nSAY \"TSA101D: Srccmd  RECORDS READ IS\" hold.0\nSAY \"TSA101D: Usercmd RECORDS READ IS\" temp.0\nSAY \"TSA101D: Totol RECORDS READ IS\" RECNUM\nDO X = 1 TO RECNUM\n  inline = hold.x\n  comment = substr(strip(inline),1,1)\n  IF COMMENT = \"*\" THEN ITERATE X\n  PARSE VAR INLINE  CMDNAME PGMNAME MSGOPT DATACK DATA2CK,\n  auth trapopt BATCHOPT VARS\n  vars = strip(vars)\n  /* CALL NEXTREC \"INPUT1\"       FILL FIELDS FOR ME */\n  /* say \"x is \" x auth authmax   */\n  IF AUTH > AUTHMAX THEN ITERATE X\n  /* say \"tb modifies\"  CMDNAME PGMNAME AUTH                */\n  IF X = 1 THEN\n    ADDRESS ISPEXEC \" TBADD \"TBNAME \" ORDER MULT(250)\"\n  IF X > 1 THEN\n    ADDRESS ISPEXEC \" TBMOD \"TBNAME \" ORDER \"\nEND\nADDRESS ISPEXEC \" TBQUERY \"TBNAME\" POSITION(ADDED)\"\nsay \"TSA101D: TBMCMD Number of rows in table \"TBNAME \"is \" added\nADDRESS ISPEXEC \" TBSORT \"TBNAME\" FIELDS(CMDNAME,C,A)\"\nsay \"TSA101D: TBMCMD TBSORT  RC iS \"rc\nIF STOREOPT /= \"NO\" THEN do\n  ADDRESS ISPEXEC \" TBCLOSE \"TBNAME\" LIBRARY(OUTPUT)\"\n  SAY \"TSA101D: TBMCMD TBCLOSE RC IS \"RC\nend\n/***********************************************/\n  \"FREE DDN(INPUT1)\"\n  \"FREE DDN(INPUT2)\"\n  \"FREE DDN(OUTPUT)\"\nEXIT 0\n/***********************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBMCMD1": {"ttr": 289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x17\\x00\\x99\\x08\\x8f\\x00\\x99\\x08\\x8f\\x13S\\x00\\n\\x00\\n\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "1999-03-29T13:53:17", "lines": 10, "newlines": 10, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX */\nARG INDSN OUTDSN TBLPREF\nIF INDSN = \"\" THEN INDSN = \"'SYS3.TSS.PARMLIB(CMDLIST)'\"\nIF OUTDSN = \"\" THEN OUTDSN = \"'SYS3.TSS.TABLE'\"\nIF TBLPREF = \"\" THEN TBLPREF = \"TS5UCM\"\nQW = OUTTRAP(\"OW.\",0)\nDO T = 1 TO 10\n  TBLNAME = TBLPREF||T\n  ADDRESS TSO \"%TBMCMD \" INDSN OUTDSN TBLNAME T\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBMSCR": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00B\\x00\\x99\\x08\\x8f\\x01\\x00\\x07_\\x10S\\x00k\\x00k\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "2000-03-15T10:53:42", "lines": 107, "newlines": 107, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** removed easyio routine for performance reasons       **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : TBMSCR                            **/\n/** LAST MODIFIED    : 15 APR 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** INDSN   :  THE FLATFILE ( OR PDS MEM) THAT HAS THE   **/\n/**            SCREEN OPTION LIST TO BE PROCESSED.       **/\n/** OUTDSN  :  A DSN THAT IS IN THE ISPTLIB CONCATENATION**/\n/**            FOR ALL USERS OF THE PANEL SYSTEM.        **/\n/** TBNAME  :  THE NAME OF THE OUTPUT TABLE, THIS MUST   **/\n/**            MATCH THE NAME SPECIFIED IN TSSINI.       **/\n/** AUTHMAX :  THE MAXIMUM AUTH LEVEL OF INPUT COMMAND TO**/\n/**            BE INCLUDED IN THE OUTPUT TABLE.          **/\n/** STOREOPT:  IF NO THEN I DO NOT STORE THE TABLE       **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** MY IO ROUTINES     : N/A                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE                 **/\n/**                                                      **/\n/**********************************************************/\nARG INDSN OUTDSN TBNAME AUTHMAX STOREOPT\n/************************************************************/\nTB_PREFIX = \"TS5USC\"\nIF INDSN   = \"\"   THEN INDSN = \"SYS3.TSS.PARMLIB(SCREEN)\"\nIF INDSN   = \".\"  THEN INDSN = \"SYS3.TSS.PARMLIB(SCREEN)\"\nIF OUTDSN  = \"\"   THEN OUTDSN = \"SYS3.TSS.TABLE\"\nIF OUTDSN  = \".\"  THEN OUTDSN = \"SYS3.TSS.TABLE\"\nIF AUTHMAX = \"\"   THEN AUTHMAX= 10\nIF AUTHMAX = \".\"  THEN AUTHMAX= 10\nIF TBNAME  = \".\"  THEN TBNAME = TB_PREFIX||AUTHMAX\nIF TBNAME  = \"\"   THEN TBNAME = TB_PREFIX||AUTHMAX\nSAY \"TSA101D: TBMSCR  PROVIDED VALUES RESOLVED TO:\"\nSAY \"       INDSN   :\" INDSN\nSAY \"       OUTDSN  :\" OUTDSN\nSAY \"       TBNAME  :\" TBNAME\nSAY \"       AUTHMAX :\" authmax\nSAY \"       STOREOPT:\" storeopt\nIF SUBSTR(INDSN,1,1) /= \"'\" THEN INDSN = \"'\"||INDSN||\"'\"\nIF SUBSTR(OUTDSN,1,1) /= \"'\" THEN OUTDSN = \"'\"||OUTDSN||\"'\"\nsay \"TSA101D: TBMSCR indsn resolved to :\" indsn\nsay \"TSA101D: TBMSCR outdsn resolved to :\" outdsn\n\"ALLOC DDN(INPUT1) DSN(\"INDSN\") SHR REUS\"\nSIGNAL OFF ERROR\nIF STOREOPT /= \"NO\" THEN   do\n  \"ALLOC DDN(OUTPUT) DSN(\"OUTDSN\") SHR REUS\"\n  ADDRESS ISPEXEC \"TBERASE \"TBNAME \"LIBRARY(OUTPUT)\"\n  SAY \"TSA101D: TBMSCR ERASE    RC IS \"RC \"FOR \" TBNAME\nend\nADDRESS ISPEXEC \"TBCREATE \"TBNAME\" KEYS(FNAME) \",\n   \"NAMES(CMDLINE VARS AUTH ) SHARE\"\nSAY \"TSA101D: TBMSCR TBCREATE RC IS \"RC \"FOR \" TBNAME\nADDRESS ISPEXEC \" TBSORT \"TBNAME\" FIELDS(FNAME,C,A)\"\nsay \"TSA101D: TBMSCR TBSORT  RC is \" rc\ntrace off\n/*CALL FILEREAD \"INPUT1\"                 READ DDNAME INPUT1 */\n\"EXECIO * DISKR INPUT1 ( FINIS STEM HOLD.)\"\nrecnum = hold.0\nSAY \"TSA101D: TBMSCR RECORDS READ IS\" RECNUM\nDO X = 1 TO RECNUM\n  inline = hold.x\n  comment = substr(inline,1,1)\n  FNAME   = substr(inline,1,21)\n  CMDLINE = substr(inline,23,15)\n  VARS    = substr(inline,41,31)\n  AUTH    = substr(inline,79,2)\n  /* SAY \"X IS\" X  */\n  /* CALL NEXTREC \"INPUT1\"    */\n  IF COMMENT = \"*\" THEN ITERATE X\n  IF AUTH > AUTHMAX THEN ITERATE X\n  FNAME = STRIP(FNAME,L)\n  IF X = 1 THEN\n    ADDRESS ISPEXEC \" TBADD \"TBNAME \" ORDER MULT(250)\"\n  IF X > 1 THEN\n    ADDRESS ISPEXEC \" TBMOD \"TBNAME \" ORDER \"\n  /* SAY FNAME CMDLINE VARS AUTH */\nEND\nADDRESS ISPEXEC \" TBQUERY \"TBNAME\" POSITION(ADDED)\"\nSAY \"TSA101D: TBMSCR NUMBER OF ROWS IN TABLE \"TBNAME \"IS \" ADDED\nADDRESS ISPEXEC \" TBSORT \"TBNAME\" FIELDS(FNAME,C,A)\"\nsay \"TSA101D: TBMSCR TBSORT  RC is \" rc\nIF STOREOPT = \"NO\" THEN\n  SAY \"TSA101D: TBMSCR TABLE CREATED FOR TEMP USE NO STORE TO BE DONE.\"\nELSE\n  ADDRESS ISPEXEC \" TBCLOSE \"TBNAME\" LIBRARY(OUTPUT)\"\nSAY \"TSA101D: TBMSCR TBCLOSE RC IS \" RC\n/***********************************************/\n\"FREE DDN(INPUT1)\"\n\"FREE DDN(OUTPUT)\"\nEXIT 0\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBMSCRO": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00P\\x00\\x98)_\\x01\\x00\\x07_\\x10S\\x01\\x9f\\x01\\x9f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-10-22T00:00:00", "modifydate": "2000-03-15T10:53:50", "lines": 415, "newlines": 415, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : TBMSCR                            **/\n/** LAST MODIFIED    : 15 APR 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** INDSN   :  THE FLATFILE ( OR PDS MEM) THAT HAS THE   **/\n/**            SCREEN OPTION LIST TO BE PROCESSED.       **/\n/** OUTDSN  :  A DSN THAT IS IN THE ISPTLIB CONCATENATION**/\n/**            FOR ALL USERS OF THE PANEL SYSTEM.        **/\n/** TBNAME  :  THE NAME OF THE OUTPUT TABLE, THIS MUST   **/\n/**            MATCH THE NAME SPECIFIED IN TSSINI.       **/\n/** AUTHMAX :  THE MAXIMUM AUTH LEVEL OF INPUT COMMAND TO**/\n/**            BE INCLUDED IN THE OUTPUT TABLE.          **/\n/** STOREOPT:  IF NO THEN I DO NOT STORE THE TABLE       **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** MY IO ROUTINES     : NEXTREC FILEREAD AND RECDEF     **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE                 **/\n/**                                                      **/\n/**********************************************************/\nDEFINE_RECORD = START\nDDNAME = INPUT1\nFILEREAD.INPUT1.READNUM = 0\nFNAME   = 1 21\nCMDLINE = 23 15\nVARS    = 41 31\nAUTH    = 79 2\nCALL RECDEF\nARG INDSN OUTDSN TBNAME AUTHMAX STOREOPT\n/************************************************************/\nTB_PREFIX = \"TS5USC\"\nIF INDSN   = \"\"   THEN INDSN = \"SYS3.TSS.PARMLIB(SCREEN)\"\nIF INDSN   = \".\"  THEN INDSN = \"SYS3.TSS.PARMLIB(SCREEN)\"\nIF OUTDSN  = \"\"   THEN OUTDSN = \"SYS3.TSS.TABLE\"\nIF OUTDSN  = \".\"  THEN OUTDSN = \"SYS3.TSS.TABLE\"\nIF AUTHMAX = \"\"   THEN AUTHMAX= 10\nIF AUTHMAX = \".\"  THEN AUTHMAX= 10\nIF TBNAME  = \".\"  THEN TBNAME = TB_PREFIX||AUTHMAX\nIF TBNAME  = \"\"   THEN TBNAME = TB_PREFIX||AUTHMAX\nSAY \"TBMSCR : PROVIDED VALUES RESOLVED TO:\"\nSAY \"       INDSN   :\" INDSN\nSAY \"       OUTDSN  :\" OUTDSN\nSAY \"       TBNAME  :\" TBNAME\nSAY \"       AUTHMAX :\" authmax\nSAY \"       STOREOPT:\" storeopt\nIF SUBSTR(INDSN,1,1) /= \"'\" THEN INDSN = \"'\"||INDSN||\"'\"\nIF SUBSTR(OUTDSN,1,1) /= \"'\" THEN OUTDSN = \"'\"||OUTDSN||\"'\"\nsay \"TBMSCR: indsn resolved to :\" indsn\nsay \"TBMSCR: outdsn resolved to :\" outdsn\n\"ALLOC DDN(INPUT1) DSN(\"INDSN\") SHR REUS\"\nSIGNAL OFF ERROR\nIF STOREOPT /= \"NO\" THEN   do\n  \"ALLOC DDN(OUTPUT) DSN(\"OUTDSN\") SHR REUS\"\n  ADDRESS ISPEXEC \"TBERASE \"TBNAME \"LIBRARY(OUTPUT)\"\n  SAY \"ERASE    RC IS \"RC \"FOR \" TBNAME\nend\nADDRESS ISPEXEC \"TBCREATE \"TBNAME\" KEYS(FNAME) \",\n   \"NAMES(CMDLINE VARS AUTH ) SHARE\"\nSAY \"TBCREATE RC IS \"RC \"FOR \" TBNAME\nADDRESS ISPEXEC \" TBSORT \"TBNAME\" FIELDS(FNAME,C,A)\"\nsay \"TBSORT  RC is \" rc\ntrace off\nCALL FILEREAD \"INPUT1\"                /* READ DDNAME INPUT1 */\nRECNUM = RESULT\nSAY \"EOF =\" FILEREAD.INPUT1.EOF       /* THE EOF FLAG       */\nSAY \"RECORDS READ IS\" RECNUM\nDO X = 1 TO RECNUM\n  /* SAY \"X IS\" X  */\n  CALL NEXTREC \"INPUT1\"               /* FILL FIELDS FOR ME */\n  IF COMMENT = \"*\" THEN ITERATE X\n  IF AUTH > AUTHMAX THEN ITERATE X\n  FNAME = STRIP(FNAME,L)\n  IF X = 1 THEN\n    ADDRESS ISPEXEC \" TBADD \"TBNAME \" ORDER MULT(250)\"\n  IF X > 1 THEN\n    ADDRESS ISPEXEC \" TBMOD \"TBNAME \" ORDER \"\n  /* SAY FNAME CMDLINE VARS AUTH */\nEND\nADDRESS ISPEXEC \" TBQUERY \"TBNAME\" POSITION(ADDED)\"\nSAY \"NUMBER OF ROWS IN TABLE \"TBNAME \"IS \" ADDED\nADDRESS ISPEXEC \" TBSORT \"TBNAME\" FIELDS(FNAME,C,A)\"\nsay \"TBSORT  RC is \" rc\nIF STOREOPT = \"NO\" THEN\n  SAY \"TABLE CREATED FOR TEMPORARY USE NO STORE WILL BE DONE.\"\nELSE\n  ADDRESS ISPEXEC \" TBCLOSE \"TBNAME\" LIBRARY(OUTPUT)\"\nSAY \"TBCLOSE RC IS \" RC\n/***********************************************/\n\"FREE DDN(INPUT1)\"\n\"FREE DDN(OUTPUT)\"\nEXIT 0\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/************************************************************/\n/**  Dave Russells easy file i/o routines version 2        **/\n/************************************************************/\n/**  two sample execs are included at the bottom of this   **/\n/**  deck, one that reads an entire file with one pass and **/\n/**  one that reads a file 1000 records at a time.         **/\n/************************************************************/\n/************************************************************/\n/* These routines are meant to be used together for easy    */\n/* input processing they are:                               */\n/************************************************************/\n/* Recdef  : To define the record format                    */\n/*           reserves the following vars:                   */\n/*           all RECDEF.    variables                       */\n/* the single define area must have these attributes:       */\n/*    it must begin with the 'exact' statement              */\n/*     DEFINE_RECORD = START                                */\n/*    it must have one set of these statements for each file*/\n/*    defined:                                              */\n/*      DDNAME = INPUT1         <=== The ddname of the file */\n/*      FILEREAD.INPUT1.READNUM =  ##                       */\n/*       the numbers of records to read per call of         */\n/*       the fileread routine ( 0 = all the records at once)*/\n/************************************************************/\n/************************************************************/\n/* Fileread: to read the file into memory                   */\n/*           reserves the following vars:                   */\n/*           all FILEREAD.  variables                       */\n/*   -Input- FILEREAD.DDNAME.READNUM =   The # of records u */\n/*           want read in ( for large file that cant be done*/\n/*           all at once )                                  */\n/*           FILEREAD.DDNAME.DEBUG   = yes/no show debugs   */\n/*  -Output- RESULT                    The # of records read*/\n/*           FILEREAD.DDNAME.0       = the # of records     */\n/*           FILEREAD.DDNAME.#       = the data             */\n/*           FILEREAD.DDNAME.EOF     = \"YES\" if last batch  */\n/*           -------------------------                      */\n/* will set RCODE of 4 if called and no recs are left       */\n/************************************************************/\n/* NEXTREC ddname : to load fields( in recdef) with next    */\n/*           rec data updates the fields in recdef          */\n/* Format for define area                                   */\n/* line format       --- meaning                            */\n/* ---------------------------------------------            */\n/* varname = 1           It is word 1 in the rec            */\n/* varname = 3 all       Starts at word 3 for all record    */\n/* varname = 7 8         It starts @ col 7 for 8            */\n/* varname = 7 0         It starts @ col 7 for whole record */\n/* ----WARNING: MAX LENGTH OF A REXX VARIABLE IS 250--------*/\n/************************************************************/\n/* ----WARNING: The NEXTREC routine does not use a procedure*/\n/* ----expose to shield the main routine from its processing*/\n/* ----since it must update field name variables.           */\n/************************************************************/\n/***********************************************/\n/** the nextrec  routine                      **/\n/***********************************************/\nNEXTREC: NOP\n/*                                                       */\nARG DDNAME\nRCODE = 0\nHOLDLEN = 0\nNEXTREAD = \"NEXTREAD\"\n/*************************************************/\n/* lets figure out whats the next record to read */\n/*************************************************/\nIF DATATYPE(FILEREAD.DDNAME.NEXTREAD) \\= \"NUM\" THEN\n  FILEREAD.DDNAME.NEXTREAD = 0\nFILEREAD.DDNAME.NEXTREAD = FILEREAD.DDNAME.NEXTREAD + 1\nREAD = FILEREAD.DDNAME.NEXTREAD\n/*******************************************************/\n/* read now has the record number we want to deal with */\n/*******************************************************/\nIF READ = \"FILEREAD.\"DDNAME\".\"NEXTREAD THEN RETURN 4\n/*******************************************************/\n/* above is the check to be sure the record exists     */\n/* if not we leave with a rc of 4 saying we are done   */\n/*******************************************************/\nDO Q = 1 TO RECDEF.DDNAME.0  /* STEP THRU THE FIELDS OF THE RECORD) */\n  FIELD =  RECDEF.DDNAME.Q\n  VALID = SYMBOL(FILEREAD.DDNAME.READ)\n  IF VALID = \"LIT\" THEN do\n    SAY \"NEXTREC: NO SUCH RECORD \"\n    SAY \"read is\" read\n    SAY filename.ddname.read\n  END\n  IF VALID = \"LIT\" THEN EXIT 04\n  HOLD1 = RECDEF.DDNAME.Q.START\n  HOLD2 = RECDEF.DDNAME.Q.END\n  IF ((HOLD2 = \"ALL\") | (HOLD2 = \"\")),\n    & (WORDS(FILEREAD.DDNAME.READ) < HOLD1) THEN DO\n    HOLD = \"\"\n    INTERPRET FIELD '=' '\"'HOLD'\"'\n    ITERATE Q\n  END\n  IF DATATYPE(HOLD2) = \"NUM\" THEN\n    HOLD = SUBSTR(FILEREAD.DDNAME.READ,HOLD1,HOLD2)\n  IF HOLD2 = 0 THEN\n    HOLD = SUBSTR(FILEREAD.DDNAME.READ,HOLD1)\n  IF HOLD2 = \"ALL\" THEN DO\n    TEMP1 = WORD(FILEREAD.DDNAME.READ,HOLD1)\n    COUNT = HOLD1 - 1\n    DO T1 = 1 TO COUNT\n      HOLDLEN = LENGTH(WORD(FILEREAD.DDNAME.READ,T1)) + HOLDLEN\n    END\n    POINT = INDEX(FILEREAD.DDNAME.READ,TEMP1,HOLDLEN)\n    HOLD = SUBSTR(FILEREAD.DDNAME.READ,POINT)\n  END\n  IF HOLD2 = \" \" THEN\n    HOLD = WORD(FILEREAD.DDNAME.READ,HOLD1)\n  /****************************************/\n  /** the data can contain single or     **/\n  /** double quotes not both or we get   **/\n  /** a nasty abend ....                 **/\n  /****************************************/\n  IF (INDEX(HOLD,'\"') > 0) & (INDEX(HOLD,\"'\") > 0) THEN DO\n    SAY \"***********FATAL ERROR*********************\"\n    SAY \"***********FATAL ERROR*********************\"\n    SAY \"*******************************************\"\n    SAY \"DATA CONTAINS BOTH SINGLE AND DOUBLE QUOTES\"\n    SAY \"*******************************************\"\n    SAY \"***********FATAL ERROR*********************\"\n    SAY \"***********FATAL ERROR*********************\"\n    EXIT 16\n  END\n  IF INDEX(HOLD,'\"') = 0 THEN\n    INTERPRET FIELD '=' '\"'HOLD'\"'\n  ELSE\n    INTERPRET FIELD \"=\" \"'\"HOLD\"'\"\nEND\nRETURN 0\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/** the fileread routine                      **/\n/***********************************************/\nFILEREAD: PROCEDURE EXPOSE RECDEF. FILEREAD.\nARG DDNAME\nNUM = FILEREAD.DDNAME.READNUM\nIF FILEREAD.DDNAME.DEBUG = \"YES\" THEN SAY \"READNUM IS \" NUM\n  /***********************************************/\n  /* check for eof already                      **/\n  /***********************************************/\nIF FILEREAD.DDNAME.EOF = \"YES\" THEN\n  SAY \"FILEREAD: NO MORE RECORDS IN FILE \" DDNAME\n  /***********************************************/\n  /* if already eof seeya cant complete read.   **/\n  /***********************************************/\nIF FILEREAD.DDNAME.EOF = \"YES\" THEN EXIT 04\n  /***********************************************/\n  /* default is to read all records             **/\n  /***********************************************/\nIF DATATYPE(NUM) \\= \"NUM\" THEN NUM = \"*\"\n  /***********************************************/\n  /* first read start at record # 1             **/\n  /***********************************************/\nBEGIN = FILEREAD.DDNAME.NEXTREC\nIF DATATYPE(BEGIN) /= \"NUM\" THEN\n  BEGIN = 1\n  /***********************************************/\n  /* otherwise increment by readnum             **/\n  /***********************************************/\nELSE BEGIN = BEGIN + NUM\nIF FILEREAD.DDNAME.DEBUG = \"YES\" THEN  SAY \"BEGIN IS\" BEGIN\nFILEREAD.DDNAME.NEXTREC = BEGIN\nFILEREAD.DDNAME.READ = \"INITIALIZED\"\nIF NUM = 0 THEN NUM = \"*\"\n/******************************************/\n/** a debug is below                     **/\n/******************************************/\nIF FILEREAD.DDNAME.DEBUG = \"YES\" THEN  SAY,\n \"EXECIO \"NUM\" DISKR \"DDNAME BEGIN,\n \"( FINIS STEM FILEREAD.\"DDNAME\".)\"\n/******************************************/\n/** end debug                            **/\n/******************************************/\n \"EXECIO \"NUM\" DISKR \"DDNAME BEGIN,\n \"( FINIS STEM FILEREAD.\"DDNAME\".)\"\nFILEREAD.DDNAME.NEXTREAD = 0 /* TELL NEXTREC  TO START AT 0 AGAIN */\nRCODE = RC\n  /***********************************************/\n  /* THE FIRST EOF IS NOT AN ERROR WE EXIT      **/\n  /* NORMALLY AND SET THE EOF FLAG              **/\n  /***********************************************/\nIF RC = 2 THEN FILEREAD.DDNAME.EOF = \"YES\"\n/******************************************/\n/** make result the number of records    **/\n/** read                                 **/\n/******************************************/\nRETURN FILEREAD.DDNAME.0\n/***********************************************/\n/***********************************************/\n/***********************************************/\n/** THE DEFINE RECORD ROUTINE                 **/\n/***********************************************/\nRECDEF: PROCEDURE EXPOSE DDNAME RECDEF.\nIF RECDEF.FOUND = \"RECDEF.FOUND\" THEN RECDEF.FOUND = 0\nSTOP  = SOURCELINE()\nDO T = 1 TO STOP\n  HOLD = SOURCELINE(T)\n  IF WORD(HOLD,1) = \"/*\" THEN ITERATE  T\n  IF INDEX(HOLD,\"DEFINE_RECORD\") > 0 THEN RECDEF_START = T\n  /* IF INDEX(HOLD,\"DEFINE_RECORD\") > 0 THEN SAY HOLD */\n  IF WORD(HOLD,2) = \"RECDEF\" THEN RECDEF_END  = T\n  IF WORD(HOLD,2) = \"RECDEF\" THEN LEAVE\nEND\n/* SAY RECDEF_START RECDEF_END */\nDO X = RECDEF_START TO RECDEF_END\n  /**********************************************/\n  /* LETS LOOK FOR THE RECDEF AREA OF THIS EXEC */\n  /**********************************************/\n  RECDEF_LINE = SOURCELINE(X)\n  UPPER RECDEF_LINE\n  /**********************************************/\n  /* BELOW IS THE SKIP LIST FOR LINES TO IGNORE */\n  /**********************************************/\n  IF INDEX(RECDEF_LINE,\"FILEREAD.\") > 0 THEN ITERATE X\n  IF INDEX(RECDEF_LINE,\"DEFINE_RECORD\") > 0 THEN ITERATE X\n  IF INDEX(RECDEF_LINE,\"/*\") > 0 THEN ITERATE X\n  IF INDEX(RECDEF_LINE,\"=\") = 0 THEN ITERATE X /* BAD FORMAT */\n  /**********************************************/\n  /* END OF SKIP LIST                           */\n  /**********************************************/\n  PARSE VAR RECDEF_LINE W1 W2 W3 W4\n  IF W1 = \"DDNAME\" THEN FILE = STRIP(W3)\n  IF INDEX(RECDEF_LINE,\"DDNAME\") > 0 THEN ITERATE X\n  /* SAY FILE W1 W2 W3 W4 */\n  /**********************************************/\n  /* REMEMBER THE FIELD ATTR OF EACH FILE       */\n  /**********************************************/\n  IF RECDEF.FILE.0 = \"RECDEF.\"FILE\".0\" THEN RECDEF.FILE.0 = 0\n  RECDEF.FILE.0 = RECDEF.FILE.0 + 1      /* THE NUMBER OF FIELDS */\n  HOLD = RECDEF.FILE.0\n  RECDEF.FILE.HOLD = W1                  /* THE FIELD NAME       */\n  RECDEF.FILE.HOLD.START = W3              /* THE START POS        */\n  RECDEF.FILE.HOLD.END = W4                /* THE END POS          */\n  IF W4 > 250 THEN SAY \"FATAL: VARIABLES CANNOT EXCEED LENGTH OF 250\"\n  IF W4 > 250 THEN EXIT 16\nEND\n/* SAY \"RECORD DEFINITION IS FROM LINE\" X \"TO LINE \"SIGL */\nRETURN\n/*********************************************************************/\n/* Example program below for one pass  read                          */\n/*                                                                   */\n/* DEFINE_RECORD = START                                             */\n/* DDNAME = INPUT1                                                   */\n/* FILEREAD.INPUT1.READNUM = 10                                      */\n/* ACID = 1 16                                                       */\n/* DEPT = 2                                                          */\n/* REST = 4 ALL                                                      */\n/* NAME = 3                                                          */\n/* DDNAME = INPUT2                                                   */\n/* FILEREAD.INPUT2.READNUM = 100                                     */\n/* ACID2= 8 8                                                        */\n/* DEPT2= 2                                                          */\n/* NAME2= 32 22                                                      */\n/* CALL RECDEF                                                       */\n/* \"ALLOC DDN(INPUT1) DSN('TECH.thedata.C1')                         */\n/* \"ALLOC DDN(INPUT2) DSN('TECH.thedata.C2')                         */\n/* CALL FILEREAD \"INPUT1\"                                            */\n/* RECNUM = RESULT                                                   */\n/* SAY \"EOF =\" FILEREAD.INPUT1.EOF                                   */\n/* SAY \"RECORDS READ IS\" RECNUM                                      */\n/* CALL FILEREAD \"INPUT2\"                                            */\n/* RECNUM = RESULT                                                   */\n/* SAY \"EOF =\" FILEREAD.INPUT2.EOF                                   */\n/* SAY \"RECORDS READ IS\" RECNUM                                      */\n/* DO X = 1 TO RECNUM                                                */\n/*   CALL NEXTREC \"INPUT1\"                                           */\n/*   SAY \"ACID=\" ACID \"DEPT=\" DEPT                                   */\n/*   CALL NEXTREC \"INPUT2\"                                           */\n/*   SAY \"ACID2=\" ACID2 \"DEPT2=\" DEPT2                               */\n/* END                                                               */\n/* \"FREE DDN(INPUT1)\"                                                */\n/* \"FREE DDN(INPUT2)\"                                                */\n/* EXIT 00                                                           */\n/*                                                                   */\n/*********************************************************************/\n/* Example program below for multi pass read 1000 rec at a time      */\n/*                                                                   */\n/* DEFINE_RECORD = START                                             */\n/* DDNAME = INPUT1                                                   */\n/* FILEREAD.INPUT1.READNUM = 1000                                    */\n/* FILL1   = 1 4                                                     */\n/* TYPE    = 5 4                                                     */\n/* CONTINUE = 11 1                                                   */\n/* ACID    = 15 8                                                    */\n/* DATA    = 33 40                                                   */\n/* CALL RECDEF                                                       */\n/* indsn = \"tech.sca.tsscfile\"                                       */\n/* \"alloc ddn(input1) dsn('\"indsn\"') shr reus\"                       */\n/*signal off error                                                   */\n/*call off error                                                     */\n/*cont_num = 0                                                       */\n/*fileread.input1.debug = \"NO\"                                       */\n/*do until fileread.input1.eof = \"YES\"                               */\n/*  call fileread \"input1\"                                           */\n/*  recnum = result                                                  */\n/*  do x = 1 to recnum                                               */\n/*    call nextrec \"input1\"                                          */\n/*    if continue = \"C\" then cont_num = cont_num + 1                 */\n/*  end                                                              */\n/*end                                                                */\n/*                                                                   */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBMSCR1": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x15\\x00\\x99\\x08\\x8f\\x01\\x00\\x07_\\x10S\\x00 \\x00 \\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "2000-03-15T10:53:15", "lines": 32, "newlines": 32, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : TBMSCR1                           **/\n/** LAST MODIFIED    : 15 JAN 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** INDSN   : THE SCREEN DEFINITION FILE                 **/\n/** OUTDSN  : THE OUTPUT ISPTLIB FILE                    **/\n/** TBLPREF : MUST MATCH THE SCRPRE VALUE SET IN TSSINI  **/\n/**********************************************************/\n/** DEFAULT VALUES FOR THESE PARMS CAN BE SPECIFIED BELOW**/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/**  GENERATES INVOCATION PARMS FOR THE TBMSCR COMMAND   **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : TBMSCR               **/\n/**                                                      **/\n/**********************************************************/\nARG INDSN OUTDSN TBLPREF\nIF INDSN = \"\" THEN INDSN = \"'SYS3.TSS.PARMLIB(SCREEN)'\"\nIF OUTDSN = \"\" THEN OUTDSN = \"'SYS3.TSS.TABLE'\"\nIF TBLPREF = \"\" THEN TBLPREF = \"TS5USC\"\nDO T = 1 TO 10\n  TBLNAME = TBLPREF||T\n  ADDRESS TSO \"%TBMSCR \" INDSN OUTDSN TBLNAME T\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TBVIEW": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x00\\x00'\\x00\\x99\\x08O\\x00\\x992o\\x13F\\x00\\xbb\\x00\\xbb\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-03-25T00:00:00", "modifydate": "1999-11-22T13:46:27", "lines": 187, "newlines": 187, "modlines": 0, "user": "*SPIV8*"}, "text": "                      /* Generic ISPF table viewer ( REXX ) */\n /* CHANGE for retain */\n arg tblname retain\n if datatype(retain) /= \"NUM\" then retain = 0\n retained_cols_width = 0\n /**********************************************************/\n /** the retain parm specifies how many of the key fields **/\n /** to propagate to each screen starting on the left.    **/\n /**********************************************************/\n /* END CHANGE for retain */\n Address ISPEXEC \"CONTROL ERRORS RETURN\"\n         /* Phase 1 - query the table, capture variable names */\n Address ISPEXEC \"TBQUERY\" tblname \"KEYS(KEYS) NAMES(NAMES)\",\n \"KEYNUM(KEYNUM) NAMENUM(NAMENUM)\"\n if rc > 0 then do\n   say  \"TSA101D: TBQUERY failed, check that table name is valid.\"\n   say  \"TSA101D: If this is a screen table insure you are in expert\"\n   say  \"TSA101D: mode.\"\n   exit 12\n end\n keys  = strip(keys,l,'(')  ; keys  = strip(keys,t,')')\n names = strip(names,l,'(') ; names = strip(names,t,')')\n varnum = keynum + namenum\n allvars = keys names   /* chain keys and names together    */\n do col = 1 to varnum   /* arrays of column headings, widths*/\n   name.col = word(allvars,col)     /* name of the variable */\n   hdw.col  = length(name.col)             /* width of name */\n   dwid.col = 0                  /* max width of data found */\n end\n     /* Phase 2 - Review the table for data displayed widths --\n        currently fixed to max out at zscreenw-1 (usually 79) */\n Address ISPEXEC \"VGET ZSCREENW\"\n maxwid = zscreenw - 1     /* need one for attribute byte */\n Address ISPEXEC \"TBTOP\" tblname\n tbrc = 0\n do while tbrc = 0\n   Address ISPEXEC \"TBSKIP\" tblname\n   tbrc = rc\n   if tbrc = 0 then do col = 1 to varnum\n     if length(value(name.col)) > dwid.col\n     then dwid.col = length(value(name.col))\n   end\n end\n     /* Phase 3 - Set reserved width, headings for each\n                     column, and use to build screen widths. */\n maxscr = 1\n              /* total screens required to display all columns */\n modhdrs = '' ; modvars = '' ; mdzvars = ''\n cols_this_screen = 0          /* what's been used so far */\n /*********************/\n /* CHANGE for retain */\n /*********************/\n do ky = 1 to retain\n   if dwid.ky = 0   then dwid.ky = 1\n   if dwid.ky > maxwid then dwid.ky = maxwid\n   grtrwid  = max(hdw.ky,dwid.ky)\n   /***********************/\n   /* we got the biggest  */\n   /***********************/\n   rsvd.ky = 1 + grtrwid       /* one space between columns */\n   retained_cols_width = retained_cols_width + rsvd.ky\n end\n /*********************/\n /* END CHANGE retain */\n /*********************/\n maxwid = maxwid - retained_cols_width\n do col = 1 to varnum\n   /***********************/\n   /* hwid = header width */\n   /* dwid = Data width   */\n   /***********************/\n   if dwid.col = 0  then dwid.col = 1\n   if dwid.col > maxwid then dwid.col = maxwid\n   grtrwid  = max(hdw.col,dwid.col)\n   /***********************/\n   /* we got the biggest  */\n   /***********************/\n   rsvd.col = 1 + grtrwid      /* one space between columns */\n   hdng.col = ' ' || center(name.col,grtrwid,'-')\n   /**********************************************/\n   /* the literal for the column header is above */\n   /**********************************************/\n   if cols_this_screen + rsvd.col > zscreenw then do\n     /*****************************************/\n     /* starting a new screen for this column */\n     /*****************************************/\n     modhdr.maxscr = modhdrs     /* save prior screen formats */\n     modvar.maxscr = modvars\n     mdzvar.maxscr = mdzvars\n     modhdrs = '' ; modvars = '' ; mdzvars = ''\n     maxscr = maxscr + 1              /* begin a new screen */\n     cols_this_screen = 0\n   end\n   /*********************/\n   /* CHANGE for retain */\n   /*********************/\n   if (cols_this_screen = 0) & (maxscr > 1 ) then do ky = 1 to retain\n     /*********************************/\n     /* we  propogate the primary keys*/\n     /* to every screen  dir 25 mar 99*/\n     /*********************************/\n     modhdrs = modhdrs || hdng.ky\n     /********************************/\n     /* below we mark the key fields */\n     /********************************/\n     if ky <= keynum then marker = left('@z',dwid.ky +1)\n       else marker = left('\\z',dwid.ky +1)\n     modvars = modvars || center(marker, rsvd.ky)\n     mdzvars = mdzvars name.ky\n     cols_this_screen = cols_this_screen + rsvd.ky\n     /*                                        */\n     /*say \"CUSTOM\"                            */\n     /*say \"retcols = \" retained_cols_width    */\n     /*say \"colthis = \" cols_this_screen       */\n     /*say \"modvars = \" modvars                */\n     /*say \"mdzvars = \" mdzvars                */\n     /*say \"modhdrs = \" modhdrs                */\n   end\n /*********************/\n /* END CHANGE retain */\n /*********************/\n   modhdrs = modhdrs || hdng.col\n   /********************************/\n   /* below we mark the key fields */\n   /********************************/\n   if col <= keynum then marker = left('@z',dwid.col+1)\n     else marker = left('\\z',dwid.col+1)\n   modvars = modvars || center(marker, rsvd.col)\n   mdzvars = mdzvars name.col\n   cols_this_screen = cols_this_screen + rsvd.col\n end\n modhdr.maxscr = modhdrs   /* save the last screen format */\n modvar.maxscr = modvars\n mdzvar.maxscr = mdzvars\n      /* Phase 4 - Display the table using prepared screens. Saves and\n           sets 4 pkfeys to allow left and right scrolling effect. */\n Address ISPEXEC \"VGET (ZPF10 ZPF11 ZPF22 ZPF23) PROFILE\"\n spf10 = zpf10 ; spf11 = zpf11 ; spf22 = zpf22 ; spf23 = zpf23\n zpf10 = 'TLEFT' ; zpf11 = 'TRIGHT'\n zpf22 = 'TLEFT' ; zpf23 = 'TRIGHT'\n Address ISPEXEC \"VPUT (ZPF10 ZPF11 ZPF22 ZPF23) PROFILE\"\n curscrn = 1\n crp = 1\n call load_screen_vars\n viewrc = 0\n do while viewrc < 8\n   Address ISPEXEC \"TBTOP\" tblname\n   Address ISPEXEC \"TBSKIP\" tblname \"NUMBER(\"crp\")\"\n   /*                 */\n   /*say \"modhdrs\"    */\n   /*say modhdrs      */\n   /*say \"******\"     */\n   /*say \"modvars\"    */\n   /*say modvars      */\n   /*say \"******\"     */\n   /*say \"mdzvars\"    */\n   /*say mdzvars      */\n   /*say \"******\"     */\n   Address ISPEXEC \"TBDISPL\" tblname \"PANEL(TBVIEW)\"\n   viewrc = rc\n   /*Say \"viewrc is \" viewrc */\n   /*Say \"zcmd is \" zcmd        */\n   if viewrc < 8  then do\n     crp = ztdtop\n     if zcmd = 'TRIGHT' then do\n       curscrn = curscrn + 1\n       if curscrn > maxscr then curscrn = 1\n       call load_screen_vars\n     end\n     If zcmd = 'TLEFT' then do\n       curscrn = curscrn - 1\n       if curscrn = 0  then curscrn = maxscr\n       call load_screen_vars\n     end\n   end\n end\n zpf10 = spf10 ; zpf11 = spf11 ; zpf22 = spf22 ; zpf23 = spf23\n Address ISPEXEC \"VPUT (ZPF10 ZPF11 ZPF22 ZPF23) PROFILE\"\n Ending:\n Return\n load_screen_vars :\n                 /* moves current screen formats to actives */\n /* say \"LOAD:\" curscrn \"is CURSCRN\"  */\n modhdrs = modhdr.curscrn\n modvars = modvar.curscrn\n mdzvars = mdzvar.curscrn\n Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TEMPIC": {"ttr": 4873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x01\\x01\\x8f\\x01\\x01\\x01\\x8f\\x10W\\x07\\x1e\\x07\\x1e\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-18T00:00:00", "modifydate": "2001-01-18T10:57:21", "lines": 1822, "newlines": 1822, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T51ICOMP                          **/\n/** LAST MODIFIED    : 26 December 2000                  **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T51JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were pased to me   **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/** acidrul.name.#.0type    the type                     **/\n/** acidrul.name.#.0segment the segment                  **/\n/** acidrul.name.#.0resname the resource name            **/\n/** acidrul.name.#.0restext the resource text            **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/** acidath.name.type.resource                           **/\n/**                    The actual translated data from   **/\n/**                      the TSS list, with all relevant **/\n/**                      data in this one variable.      **/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.convert  = \"NO\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\ndebug.getdata  = \"NO\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command. DIR                   **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\nsay \"TSA101D: makeauth check was \" make_rc makeauth\nif make_rc = 0 then do\n  convert.0newid = \"YES\"\n  convert.0name = \" $$ \"\n  makeacid.0auth = \"YES\"\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"ANIDTOTRACE\"              /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Dec 06 1999\"\nsay \"TSA101D: T51ICOMP in control with parms \" function acidlist\nsay \"TSA101D: T51ICOMP Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T51ICOMP. NO OTHER INFORMATION AVAILABLE\"\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\nif debug.flow = \"YES\" then\n  say \"TSA101D: Retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    if debug.flow = \"YES\" then\n      say \"TSA101D: calling jobcard function. \"\n    address tso \"%t51jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"TSA101D: Output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 16\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\nBYPASS.HOLD.7 = \"* ACID \"\nBYPASS.HOLD.8 = \"* ACIDS\"\nBYPASS.HOLD.9 = \"BASE DEPTACID\"\nBYPASS.HOLD.10 = \"BASE DIVACID\"\nBYPASS.HOLD.11 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"* TCONS\"\nBYPASS.HOLD.15 = \"* TRBA\"\nBYPASS.HOLD.16 = \"* TUPT\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 10\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"* LASTUSED\"\nBYPASS.HOLD.6  = \"AUTHORITY ACID\"\nBYPASS.HOLD.7  = \"BASE ZONEACID\"\nBYPASS.HOLD.8 = \"* TCONS\"\nBYPASS.HOLD.9 = \"* TRBA\"\nBYPASS.HOLD.10 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\nif debug.flow = \"YES\" then\n  say \"TSA101D: Basic initialization complete, execution begins.\"\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  say \"TSA101D: Resource processing started\"\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"TSA101D: Bypass option specified, allocating input DSN\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      if debug.resource = \"YES\" then\n        say \"Owner = \" acidnum \"name = \" owner\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      parse var line drop 'ACID(' name ')' drop2\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\"\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      if debug.resource = \"YES\" then\n        say \"acidnum = \" acidnum \"name = \" name\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"TSA101D: Total acids referenced in input is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then   signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"TSA101D: Bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"TSA101D: Total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  acids.0 = words\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    say \"TSA101D: Listing ACID \"hold\" with data \"data \".\"\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we creat   the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Evaluation of TSS generated data begins.\"\nevaluate: nop\ndo num = 1 to acidnum\n  /***********************************************/\n  /**This outer lop is once for each acid passed**/\n  /** to me. Dave 18 June 99                    **/\n  /***********************************************/\n  rules = 0\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"TSA101D: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"         Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    acidrul.name.a1.0concat  = \"NO\"\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    end\n    first11 = substr(line,1,11)\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if debug.trans = \"YES\" then\n        say \"TSA101D:  Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      if debug.trans = \"YES\" then\n       say \"TSA101D: lcf detected:\" w.2\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area input line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n      w.1 = w.1\".\"savefac\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area reformated line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) tzq1\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T51ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n      /*say \"       \"acidath.name.type.resource  */\n      acidrul.name.rules.0concat  = \"YES\"\n /*   say \"Setting concat to yes for record \" rules  */\n      hold1 = acidrul.name.rules.0concat\n      hold = restext(rules)\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: Concat rule \",\n        \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.rules = segment type resource duplicat\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource\n    acidrul.name.rules.0segment = segment\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidrul.name.rules.0restext = \" \"\n    do t1 = 3 to words\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) strip(w.t1)\n    end\n    if debug.trans = \"YES\" then do\n      say \" NEW/type/rname/text =\" acidrul.name.rules.0type\"/\",\n      acidrul.name.rules.0resname\"/\",\n      acidrul.name.rules.0restext\n    end\n  end\n  acidrul.name.0 = rules\nend\nif debug.flow = \"YES\" then\n  say \"TSA101D: Translation streams have been built.\",\n  \"Starting function check.\"\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter                                     */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Permit/rebuild/revoke area in control.\"\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do x = 1 to acidnum\n    name = acids.x\n    say \"TSA101D: Starting to process ACID:\" x \">\"name\"<\"\n    say \"          Rules#:\" acidrul.name.0\n    do t = 1 to acidrul.name.0\n      if debug.flow = \"YES\" then\n        say \"TSA101D: Starting to process \"name \" Rule #\" t\n      if debug.name.t = \"TRACE\" then trace r\n      call getdata t\n      hold = next\n      record_number = t\n      call convert function hold\n      trace off\n    end\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = acidrul.name.0\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"TSA101D:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: S found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: D found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n        acidrul.name.y = segment type resource\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: M found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          say \"TSA101D:\"\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs */\n          setf = setflag(y,'*MODIFY')\n          acidrul.name.y.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidrul.name.y.0resname  = rsname\n          acidrul.name.y.0restext  = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: A found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T51ICOMP:addition routine entered outnum=\" outnum\n        say \"T51ICOMP:addition routine entered target=\" target\n        say \"T51ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T51ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: Calling modrule\"\n        end\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setflag(fill,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        acidrul.name.fill.0segment  = segment\n        acidrul.name.fill.0resname  = rsname\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"T50101D: leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nif debug.makeacid = \"YES\" then\n  say \"TSA101D: Making ACID:\" function\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    if debug.makeacid = \"YES\" then\n      say \"TSA101D: Owner resolved to:\" own_str\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  if debug.makeacid = \"YES\" then\n    say \"TSA101D: Makeacid type for \"name\" is :\" acid_type\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif debug.makeacid = \"YES\" then\nsay \"TSA101D: leaving makeacid # output = \"create_num create.1 create.2\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  acidrul. cvtnum concat lcffac debug. convert. record_number\nparse arg function segment inline\noname = name\nconcat = acidrul.name.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nif debug.flow = \"YES\" then\n  say \"TSA101D: output name for convert is \" oname \"concat is\" concat\nif debug.flow = \"YES\" then\n  say \"TSA101D: Converting for \"name\":\"function segment \">\"||inline||\"<\"\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Input dsn line \"inline\n  inline = \"XADSN\"||substr(inline,10)\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatted dsn line \"inline\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" TSS %giveuid \" oname defgroup\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MAS\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif acidrul.name.record_number.0concat = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = acidrul.name.record_number.0concat\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"TSA101D: XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nif debug.convert = \"YES\" then\n  say \"TSA101D: Resource is \"resource \"concat is\" concat\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  if debug.convert = \"YES\" then do\n    rule = bypass.function.rulehold\n    say \"TSA101D: bypass rule tripped, Rule is below:\"\n    say \"     \" Rule\n  end\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then\n  say \"TSA101D:***** CONVERT OUTPUT IS NOW :\" output\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T51ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\nseeya: nop\nif sysenv = \"FORE\" then do\n  secrc = \"error in line \"sigl\n  address ispexec \"vput secrc profile\"\nend\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. acidath. name hex00 aciddup. debug. balance. function balout\nOPT = \" \"\nif debug.fillscr = \"YES\" then\nsay \"FILLSCR: thisrec=\" thisrec\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nif function = \"BALANCE\" then\n  h1 = balance.0 - 14\nelse\n  h1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1 - 14) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nsay \"FILLSCR: thisrec=\" thisrec\nsay \"TSA101D: filling screen:\",\n  \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  respass = acidath.name.type.resource\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose acidath. name acidrul. aciddup. next\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. aciddup. next acidlst.\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug. record_number\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsegment  = strip(acidrul.name.t.0segment)\ntype     = strip(acidrul.name.t.0type)\nresource = strip(acidrul.name.t.0resname)\ntheres   = strip(acidrul.name.t.0restext)\ndupchk   = \"\"\ndupnum   = \"\"\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t.0resname\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetdatao: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsay \"new getdata results:\"\nsay acidrul.name.t.0segment\nsay acidrul.name.t.0type\nsay acidrul.name.t.0resname\nsay acidrul.name.t.0restext\nsay \"*******\"\nsegment  = strip(word(acidrul.name.t,1))\ntype     = strip(word(acidrul.name.t,2))\nresource = strip(word(acidrul.name.t,3))\ndupchk   = strip(word(acidrul.name.t,4))\ndupnum   = strip(word(acidrul.name.t,5))\ntheres = acidath.name.type.resource\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = strip(word(acidrul.name.t,1))\ngetdata.0type     = strip(word(acidrul.name.t,2))\ngetdata.0resource = strip(word(acidrul.name.t,3))\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult  = acidrul.name.tempin.0segment\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult  = acidrul.name.tempin.0type\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult  = acidrul.name.tempin.0resname\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult  = acidrul.name.tempin.0restext\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = acidrul.name.tempin.0flag\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult  = acidrul.name.tempin.0resname\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. acidath. name acidrul. conlist modrule. rstype debug.,\n fill_override balance.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"t50pmenu: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\nif (thisrec > h1 )  then do\n  thisrec = h1\n  msg = \"t50pmenu: bottom of data reached\"\nend\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSASIM": {"ttr": 7181, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x002\\x00\\x99)?\\x01\\x03\\x11/\\x08U\\x00K\\x00K\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-10-20T00:00:00", "modifydate": "2003-04-22T08:55:32", "lines": 75, "newlines": 75, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n ARG DSOUT\n GOOD = SYSDSN(DSOUT)\n IF GOOD /= \"OK\" THEN DO\n   SAY \" A VALID DATASET MUST BE PROVIDED FOR ROUTINE OUTPUT.\"\n   SAY \" FUNCTION ABORTED.\"\n   EXIT 8\n END\n ADDRESS ISPEXEC \"ADDPOP POPLOC(Z) \"\n ADDRESS ISPEXEC \"DISPLAY PANEL(SPISIM)\"\n PANEL_RC = RC\n ADDRESS ISPEXEC \"REMPOP\"\n FACILITY = FACILIT\n IF PANEL_RC > 0 THEN EXIT 4\n ADDRESS TSO \"%T52TSSIM\" ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"ALLOC DDN(INFILE) DSN(\"DSOUT\") SHR REUS\"\n ADDRESS MVS \"EXECIO * DISKR INFILE ( FINIS STEM LINE.)\"\n ADDRESS TSO \" FREE DDN(INFILE)\"\n /*SAY \"T52SIM: PARMS:\" ACID RTYPE RNAME FACILITY ACCESS DSOUT */\n SAY \"T52SIM: CHECKING ACCESS FOR\" ACID \"TO\" RNAME \"THRU\" FACILITY\n SAY \"      \"\n DO T = 1 TO LINE.0\n   LINE.T = SUBSTR(LINE.T,1,79)\n   IF (W.2 = \"VOL\") & (W.3 = \"ORIGIN\")  THEN LEAVE\n   PARSE VAR LINE.T  W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n   IF W.1 = \"TSS8379W\" THEN DO\n     SAY \"************************************************\"\n     SAY \"T52SIM: THE INPUT ID IS NOT UNDER YOUR CONTROL.\"\n     SAY \"T52SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8362E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T52SIM: THE INPUT ID WAS NOT TSS DEFINED.\"\n     SAY \"T52SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8361E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T52SIM: AN INPUT PARAMETER WAS INCORRECT.\"\n     SAY \"T52SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8393I\" THEN DO\n     IF INDEX(LINE.T,\"DSN\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T52SIM: THIS ID BYPASSES NORMAL DATASET CHECKS!!\"\n       SAY \"************************************************\"\n     END\n     IF INDEX(LINE.T,\"VOL\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T52SIM: THIS ID BYPASSES NORMAL VOLUME  CHECKS!!\"\n       SAY \"************************************************\"\n     END\n   END\n   IF W.1 = \"TSS8380I\" THEN\n     SAY \"T52SIM: RESOURCE ACCESS WOULD BE GRANTED.\"\n   IF W.1 = \"TSS8381I\" THEN\n     SAY \"T52SIM: RESOURCE ACCESS WOULD BE DENIED.\"\n   IF (W.2 = \"ALLOWED\") & (W.3 = \"ACCESS\")  THEN\n     SAY \"T52SIM: THE ID HAS \"W.5\" ACCESS TO THIS RESOURCE\"\n   IF ( W.1 = \"TSS8394I\" ) & ( W.2 \u00ac= \"VOL\" ) THEN DO\n     PROF = W.6\n     IF W.6 = \"-\" THEN PROF = W.7\n     IF W.6 = \"*USER*\" THEN\n       PROF = \"THE INDIVIDUAL ID DEFINITION FOR\" ACID\n     IF W.6 = \"*ALL*\"  THEN PROF = \"THE SYSTEM ALL RECORD.\"\n     SAY \"T52SIM: THE APPLICABLE RULE IS IN\" PROF\n   END\n   IF W.1 = \"TSS8397I\" THEN SAY \"      \" W.2 W.3 W.4 W.5\n   /* TSS8380I GRANTED  */\n   /* TSS8381I DENIED   */\n END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSAUDU": {"ttr": 13323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00@\\x01\\x03\\x05\\x1f\\x01\\x070\\x9f\\t2\\x00 \\x00\\x1b\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2003-02-20T00:00:00", "modifydate": "2007-11-05T09:32:40", "lines": 32, "newlines": 27, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX */\n/*********************************************************************/\n/*          1         2         3         4         5         6      */\n/* 12345678901234567890123456789012345678901234567890123456789012345 */\n/* H504710   NEWLY.ADDED ??????   WHITE,MARGARET        05/15/95     */\n/*********************************************************************/\nE = \"H504710   NEWLY.ADDED ??????   WHITE,MARGARET        05/15/95\"\n/*SYSID = SYSXSMF() */\nARG ACID\naud = \"sys4.co1plex.namefile\"\nLINE = SUBSTR(ACID              ,1,10)\nidat = OUTTRAP(\"IDAT.\")\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(INSTDATA)\"\nif word(idat.2,1) = 'INSTDATA' then\n  enum = word(idat.2,3)\nenum = substr(enum                       ,1,10)\nQASW = OUTTRAP(\"NAME.\")\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nDATE = DATE('U')\nNAME = WORD(NAME.1,6)\nNAME = NAME WORD(NAME.1,7)\nNAME = SUBSTR(NAME                        ,1,21)\nLINE = LINE||\"NEWLY.ADDED \"||enum||NAME||DATE\nQASW = OUTTRAP(\"OPID.\")\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(CICS)\"\nopid = WORD(opid.3,3)\nLINE.1 = LINE\"   \"opid\nQASW = OUTTRAP(\"OFF\")\nADDRESS TSO \"ALLOC DDN(OUT01) DSN('\"AUD\"') MOD REUS\"\nADDRESS MVS \"EXECIO 1 DISKW OUT01 ( FINIS STEM LINE.)\"\nADDRESS TSO \"FREE DDN(OUT01)\"\nSAY \"TSSAUDU HAS UPDATED \"AUD\" WITH INFO FROM ID\" ACID\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSCFILE": {"ttr": 515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x04\\x00\\x99\\x08\\x8f\\x01\\x00\\x07_\\x10S\\x00Q\\x00Q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "2000-03-15T10:53:04", "lines": 81, "newlines": 81, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                **/\n/** sample exec to create a tsscfile                    **/\n/*********************************************************/\n/** to add this exec to your system include this line   **/\n/** in your SRCCMD DSN:                                 **/\n/** MAKECFILE %TSSCFILE 1     0     0    5    ON     2  **/\n/**                                                     **/\n/** Then:                                               **/\n/** add the cfileds variable to the T$$.... exec        **/\n/** add a vput statement for the cfileds in T$$....     **/\n/** update your SRCSCR dsn with a TSSCFILE entry        **/\n/** ISSUE a reinit command                              **/\n/*********************************************************/\naddress ispexec\nsignal on error name novar\n/*********************************************************/\n/* the below variables must be set in TSSINI or T$$...   */\n/*********************************************************/\nispexec \"vget ds5 profile      \"\nispexec \"vget mode profile     \"\nispexec \"vget ds3 profile      \"\nispexec \"vget jcard profile    \"\nispexec \"vget cfileds profile  \"\nispexec \"vget srcjcl  profile  \"\n/*********************************************************/\n/* the above variables must be set in TSSINI or T$$...   */\n/*********************************************************/\nsignal on error name seeya\ndisp = \"NEW,CATLG\"\nif sysdsn(cfileds) = \"OK\" then disp = \"SHR\"\noutds = ds5\nif mode = \"BATCH\" then outds = ds3\nid = sysvar(sysuid)\nqx = time()\ntnum = substr(qx,1,2)||substr(qx,4,2)\njobname = \"TCFL\"tnum\nqueue \"//\"jobname \"JOB\" jcard\nqueue \"/*JOBPARM S=*                                           \"\nqueue \"//TSSCFILE     EXEC     PGM=TSSCFILE                    \"\nqueue \"//PRINT   DD       SYSOUT=*                             \"\nqueue \"//OUT     DD       DISP=(\"disp\"),UNIT=SYSALLDA,\"\nqueue \"// SPACE=(CYL,(50,10)),DSN=\"cfileds\nqueue \"//IN      DD       *                                    \"\nqueue \"  TSS LIST(ACIDS) DATA(PASSWORD,ALL) TYPE(USER)         \"\nQUEUE \"  TSS LIST(ACIDS) DATA(PASSWORD,ALL) TYPE(DCA)          \"\nQUEUE \"  TSS LIST(ACIDS) DATA(PASSWORD,ALL) TYPE(SCA)          \"\nQUEUE \"  TSS LIST(ACIDS) DATA(PASSWORD,ALL) TYPE(LSCA)         \"\nQUEUE \"  TSS LIST(ACIDS) DATA(PASSWORD,ALL) TYPE(ZCA)          \"\nqueue \"  TSS LIST(ACIDS) DATA(PASSWORD,ALL) TYPE(PROFILE)      \"\nqueue \"/* \"\nif srcjcl = \"YES\" then do\n  lines = queued()\n  say \"lines is \"lines\n  do x = 1 to lines\n    pull thejcl.x\n  end\n  /***********************************************/\n  /** submit the job                            **/\n  /***********************************************/\n  address tso \"alloc ddn(outjcl) dsn(\"outds\") shr reus\"\n  address mvs \"execio \"lines\" diskw outjcl ( finis stem thejcl.)\"\n  address tso \"free ddn(outjcl)\"\n  address tso \"submit \"outds\n  secrc = jobname \"submitted,jcl saved , output to =>\"cfileds\".\"\n  \"vput secrc profile\"\nend\nelse do\n  queue \"$$                                                        \"\n  address tso \"SUBMIT * END($$)\"\n  secrc = jobname \"submitted dynamically, output to=>\"cfileds\".\"\n  \"vput secrc profile\"\nend\nexit 0\nseeya: nop\nsecrc = \"tsscfile terminated abnormally, exit line was\" sigl\n\"vput secrc profile\"\nexit 4\nnovar: nop\nsecrc = \"tsscfile variable retrieval failed. line was\" sigl\n\"vput secrc profile\"\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSDPANL": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x17\\x00\\x99\\t\\x7f\\x01\\x00\\x07_\\x10S\\x00|\\x00|\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-04-07T00:00:00", "modifydate": "2000-03-15T10:53:17", "lines": 124, "newlines": 124, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : TSSDPANL                          **/\n/** LAST MODIFIED    : 23 OCT 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** VARIABLES THE NAMES OF THE VARIABLES ON THE PANEL    **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 16                        **/\n/** ISPF VARIABLES        - VARIABLE DEPENDING ON INPUT  **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES.(NOTE VGET VARIABLES)       **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE                  */\n/**                                                      **/\n/**********************************************************/\nADDRESS ISPEXEC\nARG THEVARS\nBLANKS = \"      \"\nTHEVARS = TRANSLATE(THEVARS,\" \",\".\")\nVARNUM = WORDS(THEVARS)\nPARSE VAR THEVARS W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11,\n       W.12 W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20\nCNT = VARNUM + 1\nDO T = CNT TO 20\n  W.T = \"BLANKS\"\nEND\nVNAME1  = W.1\nVNAME2  = W.2\nVNAME3  = W.3\nVNAME4  = W.4\nVNAME5  = W.5\nVNAME6  = W.6\nVNAME7  = W.7\nVNAME8  = W.8\nVNAME9  = W.9\nVNAME10 = W.10\nVNAME11 = W.11\nVNAME12 = W.12\nVNAME13 = W.13\nVNAME14 = W.14\nVNAME15 = W.15\nVNAME16 = W.16\nVNAME17 = W.17\nVNAME18 = W.18\nVNAME19 = W.19\nVNAME20 = W.20\nADDRESS ISPEXEC \"VGET\" VNAME1     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME2     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME3     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME4     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME5     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME6     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME7     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME8     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME9     \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME10    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME11    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME12    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME13    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME14    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME15    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME16    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME17    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME18    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME19    \"PROFILE\"\nADDRESS ISPEXEC \"VGET\" VNAME20    \"PROFILE\"\nVVAL1 = VALUE(VNAME1)\nVVAL2 = VALUE(VNAME2)\nVVAL3 = VALUE(VNAME3)\nVVAL4 = VALUE(VNAME4)\nVVAL5 = VALUE(VNAME5)\nVVAL6 = VALUE(VNAME6)\nVVAL7 = VALUE(VNAME7)\nVVAL8 = VALUE(VNAME8)\nVVAL9 = VALUE(VNAME9)\nVVAL10 = VALUE(VNAME10)\nVVAL11 = VALUE(VNAME11)\nVVAL12 = VALUE(VNAME12)\nVVAL13 = VALUE(VNAME13)\nVVAL14 = VALUE(VNAME14)\nVVAL15 = VALUE(VNAME15)\nVVAL16 = VALUE(VNAME16)\nVVAL17 = VALUE(VNAME17)\nVVAL18 = VALUE(VNAME18)\nVVAL19 = VALUE(VNAME19)\nVVAL20 = VALUE(VNAME20)\nSIGNAL OFF ERROR\n\"DISPLAY PANEL(VARPANEL)\"\n/*************************************************************/\n/* THE DOUBLE QUOTES BELOW R  TO PRESERVE THE SINGLE QUOTES  */\n/* THE VARIABLES.                                    DAVE    */\n/*************************************************************/\nINTERPRET VNAME1 '=' '\"'VVAL1'\"'\nINTERPRET VNAME2 '=' '\"'VVAL2'\"'\nINTERPRET VNAME3 '=' '\"'VVAL3'\"'\nINTERPRET VNAME4 '=' '\"'VVAL4'\"'\nINTERPRET VNAME5 '=' '\"'VVAL5'\"'\nINTERPRET VNAME6 '=' '\"'VVAL6'\"'\nINTERPRET VNAME7 '=' '\"'VVAL7'\"'\nINTERPRET VNAME8 '=' '\"'VVAL8'\"'\nINTERPRET VNAME9 '=' '\"'VVAL9'\"'\nINTERPRET VNAME10 '=' '\"'VVAL10'\"'\nINTERPRET VNAME11 '=' '\"'VVAL11'\"'\nINTERPRET VNAME12 '=' '\"'VVAL12'\"'\nINTERPRET VNAME13 '=' '\"'VVAL13'\"'\nINTERPRET VNAME14 '=' '\"'VVAL14'\"'\nINTERPRET VNAME15 '=' '\"'VVAL15'\"'\nINTERPRET VNAME16 '=' '\"'VVAL16'\"'\nINTERPRET VNAME17 '=' '\"'VVAL17'\"'\nINTERPRET VNAME18 '=' '\"'VVAL18'\"'\nINTERPRET VNAME19 '=' '\"'VVAL19'\"'\nINTERPRET VNAME20 '=' '\"'VVAL20'\"'\n\"VGET ZAPPLID\"\nDO P = 1 TO 20\n  ADDRESS ISPEXEC \"VPUT\" W.P \"PROFILE\"\n  X = VALUE(W.P)\n  /* SAY W.P \"IS\" X*/\nEND\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSDSNW": {"ttr": 513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x002\\x00\\x99\\x08\\x8f\\x00\\x99\\x08\\x8f\\x13S\\x00\\x9d\\x00\\x9d\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "1999-03-29T13:53:32", "lines": 157, "newlines": 157, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nT = 0\nCNT =\nARG DSN DSOUT DISP\nIF DISP = \" \" THEN DISP = \"SHR\"\nDSOUT=STRIP(DSOUT)\nENV = SYSVAR(SYSENV)\nSIGNAL ON ERROR NAME SEEYA\nSAY \"---------------------------------------------------------------\"\nSAY \"TSSDSNW: RUNNING. OUTPUT DSN IS \" DSOUT\n/*****************************************************************/\n/*  THIS EXEC FINDS WHOHAS ACCESS TO A CERTAIN DSN               */\n/*  AND SAYS THE IDS TO THE CALLING ROUTINE.                     */\n/*  THE DSN PARM IS THE DSN TO BE CHECKED                        */\n/*  THE DSOUT  PARM IS THE OUTPUT DSN.                           */\n/*****************************************************************/\nSAY \"TSSDSNW: DSN = \"DSN\nHEADER1 = \" $  THE FOLLOWING IDS ARE AUTHORIZED TO\"\nHEADER2 = \" $$ ACCESS  DSNS       \" DSN\nPROFILE MSGID WTPMSG\nQ1 = OUTTRAP(OUT.)\nSIGNAL ON ERROR NAME BADDSN\nADDRESS TSO \"TSS WHOHAS DSN(\"DSN\")\"\nSIGNAL ON ERROR NAME SEEYA\n/* QUEUE HEADER1;QUEUE HEADER2 */\nQ1 = OUTTRAP(OFF)\nSAY \"TSSDSNW: WHOHAS RETURNED \"OUT.0 \"LINES OF OUTPUT\"\nDO X = 1 TO OUT.0\n  T = X + 1\n  W = X + 2\n  NEXTLINE = OUT.T\n  LASTLINE = LINE\n  LINE = OUT.X\n  IF WORD(LINE,1) = \"XAUTH\" THEN THE_DSN = WORD(LINE,3)\n  /*\n  IF THE_DSN = \"**\" THEN ITERATE X\n  IF THE_DSN = \"***\" THEN ITERATE X\n  IF THE_DSN = \"****\" THEN ITERATE X\n  IF THE_DSN = \"*****\" THEN ITERATE X\n  */\n  WORD1 = WORD(LINE,1)\n  WORD3 = WORD(LINE,3)\n  IF WORD(LINE,1) = \"XAUTH\" THEN ACCESS  = WORD(NEXTLINE,3)\n  IF ( WORD1 = \"ACTION\" ) & ( WORD3 \u00ac= \"FAIL\" ) THEN DO\n     ACT     = \"ACTION(\"WORD3\")\"\n     DSN.CNT = DSN.CNT ACT\n  END\n  IF WORD1 = \"FAC\" THEN DO\n    FAC = \"FAC(\"WORD3\")\"\n    DSN.CNT = DSN.CNT FAC\n  END\n  IF WORD1 = \"PRIVPGM\" THEN DO\n    PGM = \"PGM(\"WORD3\")\"\n    DSN.CNT = DSN.CNT PGM\n  END\n  IF WORD(LINE,1) = \"TSS0300I\" THEN LEAVE\n  IF WORD(LINE,1) = \"TSS300I\" THEN LEAVE\n  IF WORD(NEXTLINE,1) = \"TSS300I\" THEN LEAVE\n  IF WORD(NEXTLINE,1) = \"TSS0300I\" THEN LEAVE\n  Q = POS(\"ACID(\",LINE)\n  IF Q = 0 THEN ITERATE X\n  START = Q + 5\n  STOP  = LASTPOS(\")\",LINE)\n  STOP  = STOP - START\n  ACID = SUBSTR(LINE,START,STOP)\n  CNT = CNT + 1\n  ACID.CNT = ACID\n  DSN.CNT = THE_DSN \"  ACCESS(\"ACCESS\")\"\n  FAC = \" \"\n  ACT = \" \"\n  PGM = \" \"\n  ITERATE X\nEND\nQ = OUTTRAP(PROFS.)\n\"TSS LIST(ACIDS) TYPE(PROFILE) DATA(NAME)\"\nDO Y = 1 TO PROFS.0\n  PROFS.Y = WORD(PROFS.Y,3)\nEND\nDO Z = 1 TO CNT\n  DO Z1 = 1 TO PROFS.0\n    IF (ACID.Z = PROFS.Z1) & ((ACID.Z \u00ac= \"TECHDEV\"),\n       & (ACID.Z \u00ac= \"TELECOM\")) THEN DO\n      Q = OUTTRAP(OUT.)\n      GO = \"NO\"\n      \"TSS LIST(\"ACID.Z\") DATA(ACIDS)\"\n      DO Z2 = 1 TO OUT.0\n        PARSE VAR OUT.Z2 W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n        IF W.1 = \"TSS0300I\" THEN LEAVE\n        IF W.1 = \"TSS300I\" THEN LEAVE\n        IF W.1 = \"ACIDS\" THEN GO = \"YES\"\n        IF GO <> \"YES\" THEN ITERATE Z2\n        DO Z3 = 1 TO 8\n          IF W.Z3 = \"TSS0300I\" THEN ITERATE Z\n          IF W.Z3 = \"ACIDS\" THEN ITERATE Z3\n          IF W.Z3 = \"=\" THEN ITERATE Z3\n          IF W.Z3 = \" \" THEN ITERATE Z3\n          IF W.Z3 = \"-ZC\" THEN ITERATE Z3\n          IF W.Z3 = \"-LC\" THEN ITERATE Z3\n          IF W.Z3 = \"-SC\" THEN ITERATE Z3\n          IF W.Z3 = \"-DC\" THEN ITERATE Z3\n          IF W.Z3 = \"-VC\" THEN ITERATE Z3\n          IF W.Z3 = \"(S)\" THEN ITERATE Z3\n          IF W.Z3 = \"(Z)\" THEN ITERATE Z3\n          IF W.Z3 = \"(L)\" THEN ITERATE Z3\n          IF W.Z3 = \"(V)\" THEN ITERATE Z3\n          IF W.Z3 = \"(D)\" THEN ITERATE Z3\n          W.Z3 = SUBSTR(W.Z3        ,1,8)\n          QUEUE \" \"||W.Z3 \"THRU PROFILE \" ACID.Z||\", TO DSN\" DSN.Z\n        END\n      END\n    /* HERE WE MUST PUT EACH ID WITH THAT PROFILE ON THE STACK*/\n    ITERATE Z\n    END\n  END\n  QUEUE \" \"||ACID.Z \"THRU USER AUTHORITY,    TO DSN\" DSN.Z\nEND\nACIDNUM = QUEUED()\nQUEUE \"ZZLAST\"\nQUEUE \"\"\n/*                                                */\n/*DO Z = 1 TO ACIDNUM                             */\n/*  PULL ACID                                     */\n/*  Q = OUTTRAP(OUT.,2)                           */\n/*  \"TSS LIST(\"ACID\") DATA(NAME)\"                 */\n/*  PARSE VAR OUT.1 W.1 W.2 W.3 W.4 W.5 W.6       */\n/*  OUTLINE.Z = ACID \"=\" W.6                      */\n/*  Q = OUTTRAP(OFF)                              */\n/*END                                             */\nSIGNAL OFF ERROR\n\"ALLOC DDN(OUT) DSN(\"DSOUT\") \"DISP\" REUS\"\n\"EXECIO 2 DISKW OUT (STEM HEADER FINIS)\"\n\"EXECIO \"ACIDNUM\" DISKW OUT (FINIS \"\n\"FREE DDN(OUT)\"\nDELSTACK\nSAY \"TSSDSNW: HAS COMPLETED WITH \" ACIDNUM \" LINES OF OUTPUT\"\nSAY \"        IN DATASET \" DSOUT\nSECRC = \"COMPLETED, \"ACIDNUM \"LINES OF OUTPUT IN \"DSOUT\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\n   SAY \"AN ERROR HAS OCCURRED IN LINE = :\" SIGL\n   SAY \"TSSDSNW HAS COMPLETED WITH ERRORS.\"\nSECRC = \"ERROR IN LINE # \"SIGL\" TSSDSNW HAS COMPLETED WITH ERRORS.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 1\nBADDSN: NOP\n   SAY \" \"\n   SAY \"THE DATASET YOU HAVE GIVEN ME IS NOT UNDER TOP SECRET CONTROL\"\n   SAY \"OR IS SYNTACTALLY INCORRECT.\"\n   SAY \"TOP SECRET MESSAGES ARE BELOW:\"\n   SAY \"******************************\"\n   SAY OUT.1\n   SAY OUT.2\n   SAY \"******************************\"\nSECRC = \"ERROR IN TSS DATA RETRIEVAL CHECK DEBUG LOG FOR MSGS.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSEMAIL": {"ttr": 13325, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x15\\x01\\x071\\x0f\\x01\\x071\\x0f\\x12$\\x00\\x18\\x00\\x01\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2007-11-06T00:00:00", "modifydate": "2007-11-06T12:24:15", "lines": 24, "newlines": 1, "modlines": 0, "user": "COA1DIR"}, "text": "/*rexx*/\narg the_email_addr  the_dsn\nqueue \"//TSSEMAIL JOB 98111,CLASS=A,MSGCLASS=Z \"\nqueue \"//XMITIP  EXEC PGM=IKJEFT1B,DYNAMNBR=50                      \"\nqueue \"//SYSEXEC  DD DISP=SHR,DSN=SYS4.EMAIL.EXEC                   \"\nqueue \"//SYSPRINT DD  SYSOUT=*                                      \"\nqueue \"//SYSTSPRT DD  SYSOUT=*                                      \"\nqueue \"//SYSTSIN DD   *                                             \"\nqueue \"%xmitip \"the_email_addr\" +                               \"\nqueue \"        Msgds 'sys4.tss.audit80(report1)' +                  \"\nqueue \"        From mainfram@yesbank.com +                          \"\nqueue \"        Replyto drussell@yesbank.com +                       \"\nqueue \"        Subject 'TSS report' +                               \"\nqueue \"        Murphy +                                             \"\nqueue \"        File ('\"the_dsn\"' ) +                    \"\nqueue \"        Filename (Tssrpt.txt ) +                             \"\nqueue \"        Filedesc (Report ) +                                 \"\nqueue \"        Format (txt)                                         \"\nqueue \"$$                                                        \"\naddress tso \"submit * end($$)\"\nsecrc = \" EMAIL task did not complete normally.\"\nif rc = 0 then\n  secrc = \" EMAIL should arrive within 3 minutes.\"\nADDRESS ISPEXEC \"VPUT secrc PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSINI": {"ttr": 15873, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x052\\x00S\\x00\\x99'\\x9f\\x01\\x14!o\\x13\\x05\\x01\\x82\\x01~\\x00\\x00\\xc7\\xd9\\xd7\\xe3\\xc4\\xc9\\xd9@@@\"", "ispf": {"version": "05.50", "flags": 0, "createdate": "1999-10-06T00:00:00", "modifydate": "2014-08-04T13:05:53", "lines": 386, "newlines": 382, "modlines": 0, "user": "GRPTDIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** If you are customizing this for this first time you  **/\n/** must update these variable values below:             **/\n/**                                                      **/\n/** DSBACK, DEF, PARMLIB                                 **/\n/**********************************************************/\n/** EXEC NAME        : Tssini                            **/\n/** LAST MODIFIED    : 16 jun 2014                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** NONE                                                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**      SYSID         The current mvs sysid             **/\n/**      VERNUM        The VERNUM set by TSSVERS         **/\n/**      ZAPPLID       The ISPF APPLID                   **/\n/**      INI           NO - The ID Needs all vars set    **/\n/**                    YES- The ID Needs only the base   **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - ALL panel system vars        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T$$xxxx              **/\n/**********************************************************/\n/** This EXEC also call a T$$xxxx exec where xxxx is the  */\n/** SYSID of the system it executes on if the variable    */\n/** CUSTOM_CALL is set to \"yes\". This allows you to have  */\n/** one custom member for each LPAR.                      */\n/**********************************************************/\nSIGNAL OFF ERROR\nPARMLIB = \"SYS3.SPI.PARMLIB\"    /* YOUR PARMLIB..NO QUOTES */\nADDRESS ISPEXEC \"VGET ZSYSID\"\nADDRESS ISPEXEC \"VGET prefenv profile\"\nif prefenv = \"\" then do\n  PREFENV = \"EXPERT\"\n  address ispexec \"vput prefenv profile\"\n  panel = \"SPIUTIL\"\n  address ispexec \"vput panel profile\"\nend\nSYSID = ZSYSID\nADDRESS ISPEXEC \"VGET SAMPLE\"\nif sample = \"YES\" then do\n  sysid = SAMP\n  sample = \"\"\n  SAY \" TSA001I: SPI sample TSSINI used.\"\nend\nTHIS_VERSION = 25\nADDRESS ISPEXEC \"VGET VERNUM PROFILE\"\nSIGNAL ON ERROR NAME NOVAL\nARG ID\nX = MSG(\"OFF\")\nADDRESS ISPEXEC \"VGET ZAPPLID\"\nADDRESS ISPEXEC \"VGET INI PROFILE\"\nIF THIS_VERSION \u00ac= VERNUM THEN DO\n  INI = \"NO\"\n  WELCOME = \"This is version \"this_version\" of the panel system.\"\nEND\nVERNUM = THIS_VERSION\nADDRESS ISPEXEC \"VPUT VERNUM PROFILE\"\nBACK: NOP\nSCAL. = \" \"           /* INITIALIZE THE SCAL. VARIABLES    */\nTERM  = \"YES\"         /* IF WE ERROR NOW WE ARE OUTTA HERE */\nCUSTOM_CALL   = \"YES\" /* CALL t$$xxxx WHERE xxxx = SYSID ?*/\n/***************************************************************/\n/***************************************************************/\nACID     =  WELCOME              /* any value is ok here */\nALUNIT   = \"SYSDA\"               /* THE DEFAULT ALLOCATION UNIT  */\nAUTHNUM  = 1                     /* the default authnum          */\nAUTOINIT = \"YES\"                 /* Should I auto reinit on error*/\nCFILEDS  = \"'grpd.SCA.TSSCFILE'\" /* The TSSCFILE ds name         */\n                                 /* One of the sample execs      */\n                                 /* creates this dsn when invoked*/\nCHKDSN   = \"YES\"                 /* Check dsn for validity?      */\nL = TIME('S')\nCMDPRET  = \"C\"L                  /* THE PREFIX FOR COMMAND TABLES*/\nSCRPRET  = \"S\"L                  /* THE PREFIX FOR Screen  TABLES*/\n                                 /* THIS VALUE TO GET THE FULL   */\n                                 /* TABLE NAME EX ..TS5UCM10     */\n        /********************************/\n        /* no quotes below              */\n        /********************************/\nDEF      = \"SYS3.SPI.AUTHRUN\" /* THE  DEFAULTS FILE          */\n        /********************************/\n        /* no quotes above              */\n        /********************************/\n        /********************************/\nDEFDEPT  = \"NONE\"                 /* NO DEFAULT DEPARTMENT       */\nDISP     = \"SHR\"                           /* Default dsn disp   */\n                                  /*******************************/\nDSBACK   = \"'grpd.SCA.IDBACKUP'\"  /* backup file with quotes     */\n                                  /*******************************/\n                                  /* below is the list of file   */\n                                  /* variables.                  */\nidat     = \"'sys3.spi.parmlib(idatparm)'\"\nfilelist = \"cfileds dsback scalist srccmd usercmd srcscr idat\"\nfilelist = filelist \"ds1 ds2 ds3 ds4 ds5 ds6\"\n                                  /*******************************/\nGOODAPPL = \"ANY\"                  /* VALID APPL NAME OR \"ANY\"    */\nLOGDSN   = \"NONE\"                 /* NO LOG DATASET              */\nLOGFAIL  = \"NO\"                   /* DONT FAIL A CMD IF NO LOG   */\nMSG2     = \"  \"                   /* a blank filler              */\nscrload  = \"YES\"\nif prefenv = \"BASIC\" then do\n  panel = \"SPIMAIN\"\n  address ispexec \"vput panel profile\"\n  scrload = \"NO\"\nend\naddress ispexec \"vput scrload profile\"\nif prefenv = \"EXPERT\" then panel = \"SPIUTIL\"\nREFRESH  = \"NO\"                   /* never change this value */\nSCALIST  = \"'\"parmlib\"(IDLIST1A)'\"\n /* SCRPRET = \"TS5#SC\"  */\nSCRPRE  = \"TS5USC\"\n                                 /* the authnum is suffixed to   */\n                                 /* this value to get the full   */\n                                 /* TABLE NAME EX ..TS5USC10     */\nSRCJCL   = \"YES\"\nSRCCMD   = \"'\"parmlib\"(CORECMD)'\"\nUSERCMD  = \"'\"parmlib\"(USERCMD)'\"\nSRCSCR   = \"'\"parmlib\"(CORESCR)'\"\nSYSTEM   =  SYSID           /* THE SYSTEM NAME */\nTABLEDSN = \"SYS3.TSS.TABLE\"     /* THE ISPTLIB DSN FOR THE TABLES */\n                                /* NOT USED IF OPT = TEMP         */\nTABLEOPT = \"TEMP\"               /* A TEMP OR PERM TABLE           */\n         /*********************************************************/\n         /* THE TEMP OPTION CAUSES THE TABLE TO BE REBUILT FOR    */\n         /* EACH USER EVERY TIME THE ID ENTERS THE PANEL SYSTEM.  */\n         /* The benefit is that the source file can be updated    */\n         /* and the changes will be seen by each ID the next time */\n         /* the ID logs in. If a permanent table is used updating */\n         /* it is a little more involved but it runs faster.      */\n         /* Note you may not be able to use the temp option       */\n         /* for users who have the permanent table in their       */\n         /* ISPTLIB stream so the SCRPRET and CMDPRET names are   */\n         /* used for temp table users. NEVER create and store the */\n         /* temporary table names                                 */\n         /*********************************************************/\nTRAPNUM  = 200                    /* # of lines of debug data  */\nUIDOPT = \"INCREMENT\"\nUIDCON = \"NO\"                    /* convert a unique UID  to  */\n                                 /* a %giveuid command        */\n                                 /* NOTE : a UID(0) will      */\n                                 /*  always be converted with */\n                                 /* either setting !!         */\nUIDCON = \"YES\"                   /* convert a unique UID  to  */\n                                 /* a TSS add command         */\nUIDCON = \"NO\"                    /* convert a unique UID  to  */\n/***************************************************************/\n/**  Now we will get a list of all the defined users          **/\n/***************************************************************/\n/***************************************************************/\n/***************************************************************/\nAUTOINIT = \"YES\"                    /* autoinit ???           */\nSECRC  = \"TSA040I: Primary initialization successful. Variables set.\"\n/***************************************************************/\n/***************************************************************/\n/* what follows are the dsn descriptors for my STAT panel.     */\n/***************************************************************/\nDDS1    = \"Listed output     \"   /* description for ds1        */\nDDS2    = \"Processed output  \"   /*                 ds2        */\nDDS3    = \"Processed output  \"                             /*  */\nDDS4    = \"Wide reports DSN  \"                             /*  */\nDDS5    = \"Batch mode output \"                             /*  */\nDDS6    = \"Sample ISPF JCL   \"                             /*  */\nDDEF    = \"Default accesses  \"                             /*  */\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\n/***************************************************************/\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/*   there are no furthur lines that need to be changed        */\n/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n/***************************************************************/\nSCACHECK = SYSDSN(SCALIST)\nIF SCACHECK = \"OK\" THEN DO\n  ADDRESS TSO \"ALLOC DDN(INPUT) DSN(\"SCALIST\") SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR INPUT ( FINIS STEM SCAL.)\"\n  ADDRESS TSO \"FREE DDN(INPUT)\"\nend\nIF SCACHECK /= \"OK\" THEN DO\n  SCAL.0 = 0\n  AUTHNUM = 10\n  SAY \"TSA002I: UNABLE TO FIND AUTHORITY DATASET:\" SCALIST\n  SAY \"TSA002I: SENSE CODE: \"SCACHECK\nend\nIF ( ZAPPLID < > GOODAPPL ) & ( GOODAPPL \u00ac= \"ANY\" ) THEN\n  SIGNAL BADAPPL\nSIGNAL ON ERROR NAME SEEYA\nDO X = 1 TO SCAL.0\n  WORD1  = WORD(SCAL.X,1)\n  IF POS(WORD1,ID) = 1 THEN DO\n    IF DATATYPE(WORD(SCAL.X,2)) = \"NUM\" THEN AUTHNUM = WORD(SCAL.X,2)\n  END\nEND\n/***************************************************/\n/* MORE DEFAULT VALUES ARE SET HERE.. DIR 9 SEP 92 */\n/***************************************************/\nSIGNAL ON ERROR NAME NOALLOC\nPASTALOC: NOP\nSIGNAL ON ERROR NAME SEEYA\nSCRTABLE = SCRPRE||AUTHNUM\nCMDTABLE = CMDPRE||AUTHNUM\nIF TABLEOPT = \"TEMP\" THEN DO\n  /******************************************************/\n  /******************************************************/\n  /* SUFFIX = AUTHNUM                                   */\n  /* IF SUFFIX = 10 THEN SUFFIX = \"A\"                   */\n  /* SCRTABLE = SCRPRET||SUFFIX                         */\n  /* SUFFIX = AUTHNUM + 1                               */\n  /* IF SUFFIX = 10 THEN SUFFIX = \"A\"                   */\n  /* IF SUFFIX = 11 THEN SUFFIX = \"B\"                   */\n  /* CMDTABLE = CMDPRET||SUFFIX                         */\n  /******************************************************/\n  /******************************************************/\n  SCRTABLE = SCRPRET||AUTHNUM\n  CMDTABLE = CMDPRET||AUTHNUM\nEND\nADDRESS ISPEXEC \"VPUT CMDTABLE PROFILE\"\nADDRESS ISPEXEC \"VPUT SCRTABLE PROFILE\"\nIF INI = \"YES\" THEN DO /* NOT THE FIRST TIME FOR THIS USER. */\n  SECRC = \"TSA039I: Panel system standard initialization complete.\"\n  ADDRESS ISPEXEC \"VPUT AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VPUT INI   PROFILE\"\n  ADDRESS ISPEXEC \"VPUT IDAT  PROFILE\"\n  ADDRESS ISPEXEC \"VPUT SYSTEM PROFILE\"\n  ADDRESS ISPEXEC \"VPUT CHKDSN PROFILE\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VPUT SYSTEM PROFILE\"\n  ADDRESS ISPEXEC \"VPUT TABLEOPT PROFILE\"\n  SIGNAL ON ERROR NAME CUSTERR\n  IF CUSTOM_CALL = \"YES\" THEN\n    ADDRESS TSO \"%T$$\"SYSID ID AUTHNUM \"NOREINIT\"\n  SIGNAL ON ERROR NAME SEEYA\n  EXIT 00\nEND\n/***************************************************/\n/* FIRST WE SET INI TO YES SO THAT THIS ROUTINE    */\n/* WONT BE CALLED AGAIN.............. DIR 9 SEP 92 */\n/***************************************************/\nINI      = \"YES\"\n/***************************************************/\nSIGNAL OFF ERROR\nADDRESS ISPEXEC \"VPUT ACID     PROFILE\"\nADDRESS ISPEXEC \"VPUT AUTHNUM  PROFILE\"\nADDRESS ISPEXEC \"VPUT AUTOINIT PROFILE\"\nADDRESS ISPEXEC \"VPUT CFILEDS  PROFILE\"\nADDRESS ISPEXEC \"VPUT CHKDSN   PROFILE\"\nADDRESS ISPEXEC \"VPUT CMDPRE   PROFILE\"\nADDRESS ISPEXEC \"VPUT DEFDEPT  PROFILE\"\nADDRESS ISPEXEC \"VPUT DDEF     PROFILE\"\nADDRESS ISPEXEC \"VPUT DDS1     PROFILE\"\nADDRESS ISPEXEC \"VPUT DDS2     PROFILE\"\nADDRESS ISPEXEC \"VPUT DDS3     PROFILE\"\nADDRESS ISPEXEC \"VPUT DDS4     PROFILE\"\nADDRESS ISPEXEC \"VPUT DDS5     PROFILE\"\nADDRESS ISPEXEC \"VPUT DDS6     PROFILE\"\nADDRESS ISPEXEC \"VPUT DEF      PROFILE\"\nADDRESS ISPEXEC \"VPUT DISP     PROFILE\"\nADDRESS ISPEXEC \"VPUT DSBACK   PROFILE\"\nADDRESS ISPEXEC \"VPUT INI      PROFILE\"\nADDRESS ISPEXEC \"VPUT filelist PROFILE\"\nADDRESS ISPEXEC \"VPUT logdsn   PROFILE\"\nADDRESS ISPEXEC \"VPUT logfail  PROFILE\"\nADDRESS ISPEXEC \"VPUT msg2     PROFILE\"\nADDRESS ISPEXEC \"VPUT PANEL    PROFILE\"\nADDRESS ISPEXEC \"VPUT PROD     PROFILE\"\nADDRESS ISPEXEC \"VPUT REFRESH  PROFILE\"\nADDRESS ISPEXEC \"VPUT SCalist  PROFILE\"\nADDRESS ISPEXEC \"VPUT SCRPRE   PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCJCL   PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCCMD   PROFILE\"\nADDRESS ISPEXEC \"VPUT USERCMD  PROFILE\"\nADDRESS ISPEXEC \"VPUT UIDCON   PROFILE\"\nADDRESS ISPEXEC \"VPUT SRCSCR   PROFILE\"\nADDRESS ISPEXEC \"VPUT SECRC    PROFILE\"\nADDRESS ISPEXEC \"VPUT SYSTEM   PROFILE\"\nADDRESS ISPEXEC \"VPUT TABLEDSN PROFILE\"\nADDRESS ISPEXEC \"VPUT TABLEOPT PROFILE\"\nADDRESS ISPEXEC \"VPUT TRAPNUM  PROFILE\"\nADDRESS ISPEXEC \"VPUT TRAPNUM  PROFILE\"\nADDRESS ISPEXEC \"VPUT UIDOPT   PROFILE\"\nSIGNAL ON ERROR NAME CUSTERR\nIF CUSTOM_CALL = \"YES\" THEN DO\n  ADDRESS TSO \"%T$$\"SYSID ID AUTHNUM \"REINIT\"\nEND\nEXIT 0\nCUSTERR: NOP\nSECRC = \"TSA003E: ERROR CALLING LOCAL T$$\"SYSID \".TSSINI LINE = \" SIGL\nSAY SECRC\nX = SOURCELINE(SIGL)\nSAY X\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSEEYA: NOP\nSECRC = \"TSA004E: ERROR IN VARIABLE INIT. CHECK TSSINI LINE = \" SIGL\nSAY SECRC\nX = SOURCELINE(SIGL)\nSAY X\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nNOALLOC: NOP\nSECRC = \"ERROR IN WORK DATASET CREATION. CHECK TSSINI LINE = \" SIGL\nSAY SECRC\nX = SOURCELINE(SIGL)\nSAY X\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSIGNAL PASTALOC\nBADAPPL: NOP\nSAY \" \"\nSAY \" \"\nSAY \" \"\nSAY \" \"\nSAY \" \"\nSAY \" \"\nSAY \" \"\nSAY \" \"\nSECRC = \"NEWAPPL PARM ERROR. I EXPECTED=\"GOODAPPL\" IT IS NOW=\"ZAPPLID\nSAY SECRC\nSAY \"CONTACT YOUR TECHNICAL SUPPORT REPRESENTATIVE\"\nSAY \"TO CORRECT THIS ERROR:\"\nSAY \"1. CODE THE SELECT STATEMENT AS FOLLOWS:\"\nSAY \"   SELECT(TSSUT) NEWAPPL(\"GOODAPPL\")\"\nSAY \"                   OR \"\nSAY \"2. CHANGE THE GOODAPPL PARM IN TSSINI TO 'ANY'\"\nSAY \"   AND REINVOKE TSSUT\"\nSAY \"                   OR \"\nSAY \"3. CALL THE REXX COMMAND TSSU TO INVOKE THE   \"\nSAY \"   REXX DRIVER UNDER THE APPL TSS\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 2\nNOVAL: NOP\nINI = \"NO\"\nAUTOINIT = \"YES\"\nADDRESS ISPEXEC \"VPUT AUTOINIT PROFILE\"\nIF TERM = \"YES\" THEN DO\n  SAY \"TSA005E: RECOVERY ERROR. TSSINI TERMINATING LINE = \" SIGL\n  X = SOURCELINE(SIGL)\n  SAY X\n  EXIT 16 /* NO ENDLESS LOOP , THANX */\nEND\nsignal back\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSINQ": {"ttr": 13321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x05\\x00%\\x00\\x98\\x08\\x9f\\x01\\x070?\\t9\\x00U\\x00S\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.05", "flags": 0, "createdate": "1998-03-30T00:00:00", "modifydate": "2007-10-30T09:39:25", "lines": 85, "newlines": 83, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\n/**********************************************************/\n/** EXEC NAME        : TSSINQ                            **/\n/** LAST MODIFIED    : 16 May 2007                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/**********************************************************/\n/** THIS IS A FLATFILE SEARCH EXEC IT WILL RETRIEVE      **/\n/** RECORDS BASED ON INPUT PARAMETERS... DAVE 20 APR 95  **/\n/**********************************************************/\n/** PASSED ARGS        VALID VALUES                      **/\n/** NAME DSNAME LOC STARTPOS DATALEN                     **/\n/** NAME    : THE VALUE BEING SEARCHED FOR               **/\n/** LOC     : THE POSITION THE VALUE MUST START IN       **/\n/** STARTPOS: POSITION AT WHICH TO START CHECK           **/\n/** DATALEN : HOW MUCH DATA YOU WANT BACK                **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/**********************************************************/\nARG NAME DSNAME LOC STARTPOS DATALEN\nIF DATALEN = \" \" THEN DO\n  secrc = \"Aborted. please specify search parameters for retreival\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 08\nEND\nIF NAME = \"NEWLY.ADDED\" THEN DO\n  LOC = \"ANY\"\n  DATALEN = 7 /* IDS ARE ONLY 7 CHARS LONG IN THE AUD FILE */\n  STARTPOS = 8\nEND\nSIGNAL ON ERROR NAME SEEYA\nsecrc = \"no match found.\"\nDATAAREA  = \" \"\nVAL = SYSDSN(DSNAME)\nIF VAL \u00ac= \"OK\" THEN DO\n  secrc = \"The dsn requested \"dsname\" was not found\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 08\nEND\nIF LOC \u00ac= \"ANY\" THEN\nLOC1 = LOC + 1\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n\"ALLOC DDN(INQUIRE) DSN(\"DSNAME\") SHR REUS\"\n\"EXECIO * DISKR INQUIRE ( FINIS STEM HOLD.)\"\nLEN = LENGTH(NAME)\nDO Z = 1 TO HOLD.0\n   LINE = SUBSTR(HOLD.Z,1,72)\n   IF (POS(NAME,LINE,STARTPOS) \u00ac= 0) & (DATALEN = \"NEXTLINE\") THEN DO\n     SECRC = \"MATCH(S) FOUND. DATA LINE(S) LISTED.\"\n     Q1 = Z + 1\n     SAY HOLD.Q1\n     LEAVE\n   END\n   IF (POS(NAME,LINE,STARTPOS) \u00ac= 0) & (LOC= \"ANY\") THEN DO\n     secrc = \"match(s) found. data line(s) listed.\"\n     SAY LINE\n     T = SUBSTR(LINE,1,DATALEN)\n     DATAAREA = DATAAREA\" \"STRIP(T)\n     ITERATE Z\n   END\n   IF POS(NAME,LINE,STARTPOS) = LOC THEN DO\n     secrc = \"match(s) found. id(s) listed.\"\n     SAY LINE\n     T = SUBSTR(LINE,1,DATALEN)\n     DATAAREA = DATAAREA\" \"STRIP(T)\n   END\n   /*\n   IF POS(NAME,LINE,STARTPOS) = LOC1 THEN DO\n     secrc = \"match(s) found. id(s) listed.\"\n     SAY LINE\n     T = SUBSTR(LINE,1,DATALEN)\n     DATAAREA = DATAAREA\" \"STRIP(T)\n   END\n   */\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VPUT DATAAREA PROFILE\"\nSEEYA: NOP\n\"FREE DDN(INQUIRE)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSJAUD": {"ttr": 11009, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\t\\x004\\x00\\x99 \\x1f\\x01\\x06\\x03\\x9f\\x137\\x00b\\x00`\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.09", "flags": 0, "createdate": "1999-07-20T00:00:00", "modifydate": "2006-02-08T13:37:34", "lines": 98, "newlines": 96, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\nARG DSN ACID DATA\naddress ispexec\nsignal on error name novar\npref = sysvar(syspref)\nispexec vget ds4 profile\nispexec vget ds5 profile\nispexec vget tsaud profile\nispexec vget mode  profile\nispexec vget jcard profile\nispexec vget tsaudid profile\nispexec vget srcjcl  profile\nsignal on error name seeya\nupper acid\nid = sysvar(sysuid)\nqx = time()\ntnum = substr(qx,1,2)||substr(qx,4,2)\ndscheck= sysdsn(\"'\"ds4\"'\")\nif dscheck /= \"OK\" then ds4 = pref\".\"ds4\ndscheck= sysdsn(\"'\"newdsn\"'\")\naudit_parm = \"  REPORT EVENT(ALL) ACID(\"ACID\") DATE(-\"DATA\")\"\nIF (ACID = \"VIOLS\") | (ACID= \"VIOL\")  THEN\n  audit_parm = \"  REPORT EVENT(VIOL)  DATE(-\"DATA\")\"\nIF (ACID = \"AUDIT\")  THEN\n  audit_parm = \"  REPORT EVENT(AUDIT)  DATE(-\"DATA\")\"\njobname = \"TAUD\"tnum\nds4 = TRANSLATE(ds4,\" \",\"'\") /* REPLACE DOTS WITH SPACES */\nqueue \"//\"jobname \"JOB\" jcard\nqueue \"/*JOBPARM S=*                                           \"\nqueue \"//TSSUTIL      EXEC     PGM=TSSUTIL                       \"\nqueue \"//UTILOUT      DD  DISP=SHR,DSN=\"ds4\nqueue \"//SYSUDUMP     DD  DUMMY                                  \"\nqueue \"//SMFIN        DD  DISP=SHR,                             \"\nqueue \"//  DSN=\"tsaud\nqueue \"//UTILIN       DD DDNAME=TSSIN                            \"\nqueue \"//TSSIN        DD *                                       \"\nQUEUE audit_parm\nqueue \"/*                                                        \"\nqueue \"//SORT  EXEC PGM=IEFBR14,REGION=1024K                     \"\nqueue \"//SORTWK01  DD  UNIT=3390,SPACE=(CYL,(5,2))               \"\nqueue \"//SORTWK02  DD  UNIT=3390,SPACE=(CYL,(5,2))               \"\nqueue \"//SORTWK03  DD  UNIT=3390,SPACE=(CYL,(5,2))               \"\nqueue \"//SORTIN    DD  DISP=SHR,DSN=\"ds4\nqueue \"//SYSOUT    DD  SYSOUT=*                                  \"\nqueue \"//SORTOUT   DD  DISP=SHR,DSN=\"ds4\nqueue \"//SYSIN     DD  *                                         \"\nqueue \"  SORT FIELDS=(19,116,CH,A)                            \"\nqueue \"  SUM FIELDS=NONE                                      \"\nqueue \"//TSOSEND      EXEC     PGM=IKJEFT01,COND=(00,NE,TSSUTIL) \"\nqueue \"//SYSPRINT     DD  DUMMY                                  \"\nqueue \"//SYSTSPRT     DD  SYSOUT=*                               \"\nqueue \"//SYSTSIN      DD  *                                      \"\nqueue \"   SEND 'YOUR AUDIT OF ID=\"acid \" ' U(\"id\") LOGON \"\nqueue \"   SEND 'HAS COMPLETED. THE OUTPUT' U(\"id\") LOGON\"\nqueue \"   SEND 'IS IN DSN=\"ds4\"'  U(\"id\") LOGON\"\nqueue \"//TSOSEND2     EXEC     PGM=IKJEFT01,COND=(00,EQ,TSSUTIL) \"\nqueue \"//SYSPRINT     DD  DUMMY                                  \"\nqueue \"//SYSTSPRT     DD  SYSOUT=*                               \"\nqueue \"//SYSTSIN      DD  *                                      \"\nqueue \"  SEND 'YOUR AUDIT OF ID=\"acid\"' U(\"id\") LOGON        \"\nqueue \"  SEND 'HAS COMPLETED. NO  OUTPUT' U(\"id\") LOGON        \"\nqueue \"  SEND 'WAS GENERATED           '  U(\"id\") LOGON        \"\nqueue \"/*                                                        \"\nqueue \"$$                                                        \"\nif (srcjcl = \"YES\") & (mode = \"ONLINE\") then do\n  lines = queued()\n  say \"lines is \"lines\n  do x = 1 to lines\n    pull thejcl.x\n  end\n  /***********************************************/\n  /** submit the job                            **/\n  /***********************************************/\n  address tso \"alloc ddn(outjcl) dsn(\"ds5\") shr reus\"\n  address mvs \"execio \"lines\" diskw outjcl ( finis stem thejcl.)\"\n  address tso \"free ddn(outjcl)\"\n  address tso \"submit \"ds5\n  secrc = jobname \"submitted,jcl saved , output to =>\"ds4\".\"\n  \"vput secrc profile\"\nend\nelse do\n  address tso \"SUBMIT * END($$)\"\n  secrc = jobname \"submitted dynamically, output to=>\"ds4\".\"\n  if mode = \"BATCH\" then do\n    msg2  = \"WARNING: JCL not written to prevent batch jcl overlay.\"\n    \"vput msg2 profile\"\n  end\n  \"vput secrc profile\"\nend\nexit 0\nseeya: nop\nsecrc = \"tssjaud terminated abnormally, exit line was\" sigl\n\"vput secrc profile\"\nexit 4\nnovar: nop\nsecrc = \"tssjaud variable retrieval failed.  line was\" sigl\n\"vput secrc profile\"\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSLNAME": {"ttr": 13067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x13\\x00@\\x00\\x95\\x19O\\x01\\x07\\x14O\\x14\\x07\\x00\\xbb\\x00\\x90\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.19", "flags": 0, "createdate": "1995-07-13T00:00:00", "modifydate": "2007-05-24T14:07:40", "lines": 187, "newlines": 144, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\n/*****************************************************************/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** CHECK TSSRWHO EXEC !!!!!!!!!!!!!!!!!!!!!!!                  **/\n/** FORMATTED LINES TO MAKE MORE  READABLE.                     **/\n/*****************************************************************/\n/*  THIS EXEC HAS TWO INPUT DATA FORMATS.                        */\n/*  THE FIRST:                                                   */\n/*  CALLS THE COMMAND IN ARG CMD WITH THE PARM IN ARG DSN1, THEN */\n/*  TRAPS THE OUTPUT WHICH IT ASSUMES TO BE A USERID LIST 1 USER */\n/*  PER LINE (WITH THE USERID THE FIRST WORD ON EACH LINE) AND   */\n/*  THEN GIVES YOU A LIST OF THOSE USERS AND THEIR NAMES IN DSN2.*/\n/*  THE SECOND:                                                  */\n/*  IT TAKES INPUT FROM A SOURCE DSN.  ANY OTHER DATA ON         */\n/*  THE LINE IS ALSO SAVED IF POSSIBLE.  IT HAS BEEN TESTED WITH */\n/*  VERSION 4.2 AND 4.3 ONLY....DIR 02 FEB 93                    */\n/*                                                               */\n/*................THIS BABY CAN RUN A LONG TIME!!!...............*/\n/*                                                               */\n/*  FORMAT  : \"TSSLNAME\" //CMD// //ARG//   //DSNAME//            */\n/*                            OR                                 */\n/*           \" TSSLNAME DSNAME \" //DSN1//  //DSN2//              */\n/*                                                               */\n/*  EXAMPLE :\"TSO TSSLNAME TSSTRANW CEMT$ALL SYS3.SCA.C1\"        */\n/*            INVOKES COMMAND \"TSSTRANW\" AND \u00a2PASSES IT TWO      */\n/*            PARMS \"CEMT\" AND \"ALL\"  AND WRITES THE             */\n/*            OUTPUT TO \"SYS3.SCA.C1\" .                          */\n/*                                                               */\n/*  EXAMPLE :\"TSO TSSLNAME TSSWHO TRAN$KYCM$COA1DIR.C4$SHR COA1DIR.C4*/\n/*            INVOKES COMMAND \"TSSTRANW\" AND \u00a2PASSES IT TWO      */\n/*            PARMS \"CEMT\" AND \"ALL\"  AND WRITES THE             */\n/*            OUTPUT TO \"SYS3.SCA.C1\" .                          */\n/*                                                               */\n/*  EXAMPLE :\"TSO TSSLNAME PROFWHO TCHDBPRF SYS3.SCA.C1\"         */\n/*            TAKES THE OUTPUT OF A PROFWHO TCHDBPRF COMMAND     */\n/*            FINDS THE NAMES OF THOSE IDS AND WRITES THE        */\n/*            OUTPUT TO \"SYS3.SCA.C1\"                            */\n/*                                                               */\n/*  EXAMPLE :\"TSO TSSLNAME NEWCMD  PARM1.PARM2.PARM3 SYS3.SCA.C1\"*/\n/*            TAKES THE OUTPUT OF A NEWCMD  PARM1 PARM2 PARM3    */\n/*            COMMAND AND WRITES THE                             */\n/*            OUTPUT TO \"SYS3.SCA.C1\"                            */\n/*                                                               */\n/*  EXAMPLE :\"TSO TSSLNAME DSNAME SYS3.SCA.C1 SYS3.SCA.C2\"       */\n/*            TAKES THE ID LIST IN SYS3.SCA.C1 AND               */\n/*            FINDS THE NAMES OF THOSE IDS AND WRITES THE        */\n/*            OUTPUT TO \"SYS3.SCA.C2\"                            */\n/*                                                               */\n/*  EXAMPLE :\"TSO TSSLNAME DSNAME SYS3.SCA.C1 SAME\"              */\n/*            TAKES THE ID LIST IN SYS3.SCA.C1 AND               */\n/*            FINDS THE NAMES OF THOSE IDS AND WRITES THE        */\n/*            OUTPUT TO \"SYS3.SCA.C1\" ALSO.                      */\n/*****************************************************************/\nARG CMD DSN1 DSN2\nDSN1 = STRIP(TRANSLATE(DSN1,\" \",\"'\")) /* REPLACE DOTS WITH SPACES */\nDSN2 = STRIP(TRANSLATE(DSN2,\" \",\"'\")) /* REPLACE DOTS WITH SPACES */\nPARSE VAR DSN1 P.1   '$' P.2 '$' P.3 '$' P.4\nSIGNAL ON ERROR NAME SEEYA\nSYSENV = SYSVAR(SYSENV)\nID = SYSVAR(SYSUID)\nSECRC = \"TSSLNAME HAS RECEIVED CONTROL AND TERMINATED ABNORMALLY\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nSAY \"TSSLNAME: THE RECEIVED PARMS ARE: \" CMD DSN1 DSN2\nIF DSN2 = \"SAME\" THEN DSN2 = DSN1\nIF SYSDSN(\"'\"ID\".\"DSN2\"'\") = \"OK\" THEN DSN2 = ID\".\"DSN2\nIF SYSDSN(\"'\"DSN2\"'\") \u00ac= \"OK\" THEN DO\n  SAY \"TSSLNAME: THE OUTPUT DSN YOU HAVE GIVEN ME IS UNAVAILABLE\"\n  EXIT 00\nEND\nTRACE OFF\nQ = OUTTRAP(OUTID.)\nIF CMD = \"DSNAME\" THEN DO\n  Q = OUTTRAP(OFF)\n  \"ALLOC DDN(IN1) DSN('\"DSN1\"') REUS SHR\"\n  \"EXECIO  * DISKR IN1 (FINIS STEM OUTID.)\"\nEND\n\"ALLOC DDN(OUT1) DSN('\"DSN2\"') REUS SHR\"\nSAY \"TSSLNAME: I AM CALLING \" CMD\" WITH PARMS:\" P.1 P.2 P.3 P.4\nIF CMD <> \"DSNAME\" THEN\n  \"%\"CMD  P.1 P.2 P.3 P.4\nCODE = RC\nSAY \"TSSLNAME: I AM BACK FROM \" CMD\" WITH RETURN CODE OF \" RC\nIF CODE > 4 THEN DO\n  SAY \"TSSLNAME:                                                 \"\n  SAY \"TSSLNAME: ************************************************\"\n  SAY \"TSSLNAME: *******           WARNING             **********\"\n  SAY \"TSSLNAME: ************************************************\"\n  SAY \"TSSLNAME: I BELIVE THAT \"CMD\" MAY HAVE HAD SERIOUS ERRORS!\"\n  SAY \"TSSLNAME: I WILL ATTEMPT TO CONTINUE PROCESSING           \"\n  SAY \"TSSLNAME: ************************************************\"\n  SAY \"TSSLNAME: *******           WARNING             **********\"\n  SAY \"TSSLNAME: ************************************************\"\nEND\nSAY \"TSSLNAME: THE OUTPUT OF \"CMD\" WAS \"OUTID.0 \"RECORDS.\"\nSAY \"TSSLNAME: I AM ROUTING OUTPUT TO \"DSN2\nIF OUTID.0 = 0 THEN DO\n  QUEUE \"TSSLNAME: I HAVE RECEIVED NO INPUT FROM \"CMD\n  QUEUE \"TSSLNAME: ACID MAY BE INVALID OR AUTHORIZATION MAY HAVE FAILED\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC  \"VGET SECRC PROFILE\"\n  QUEUE SECRC\nEND\nSECRC = \"TSSLNAME HAS INVOKED \"CMD\" THEN TERMINATED ABNORMALLY\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nSIGNAL OFF ERROR\nqueue \" Below list is the result of parms: \"     CMD DSN1 DSN2\nDO X = 1 TO OUTID.0\n  PARSE VAR OUTID.X ACID LINE\n  ACID = WORD(OUTID.X,1)\n  IF ACID = \"TSS0300I\" THEN ITERATE X\n  ID3 = WORD(OUTID.X,3)\n  NAME6 = SUBSTR(OUTID.X               ,36,28)\n  CHECK1 = WORD(OUTID.X,4)\n  IF (ACID = \"ACCESSORID\") & (CHECK1 = \"NAME\") THEN DO\n    ID3 = SUBSTR(ID3           ,1,10)\n    LINE = ID3 \"=\" NAME6\n    QUEUE \" \"LINE\n    ITERATE X\n  END\n  IF (ACID = \"*\") | (ACID = \"*NONE*\") THEN DO\n    QUEUE \" \"LINE\n    ITERATE X\n  END\n  Q = OUTTRAP(\"OUTNAME.\",1)\n   /* SAY \"TSSLNAME: I AM LISTING \" ACID */\n  \"TSS LIST(\"ACID\") DATA(NAME)\"\n  ACID = SUBSTR(ACID            ,1,8)\n  PARSE VAR OUTNAME.1 W.1 W.2 W.3 W.4 W.5 W.6 W.7\n  IF W.6 = \"SCOPE\" THEN W.6 = \"**NAME RETRIEVAL FAILED\"\n  IF W.7 = \"SCOPE\" THEN W.7 = \"**NAME RETRIEVAL FAILED\"\n  W.6 = STRIP(W.6)\n  W.7 = STRIP(W.7)\n  HOLD = ACID \"=\" W.6 W.7 \"                                         \"\n  IF WORDS(LINE) > 1 THEN DO\n    PARSE VAR LINE  W.1 W.2 W.3\n    LINE = STRIP(W.1) STRIP(W.2) STRIP(W.3)\n  END\n  LINE = SUBSTR(HOLD,1,29)||\" \"||LINE\n  IF LINE \u00ac= \"=\" THEN\n    QUEUE \" \"LINE    /* NO BLANK LINES! */\nEND\nQUEUE \" \"\nQUEUE \"\"\nSIGNAL OFF ERROR\n\"EXECIO * DISKW OUT1 (FINIS)\"\n\"FREE DDN(OUT1)\"\n\"FREE DDN(IN1)\"\nSECRC = \"FUNCTION SUCCESSFUL,  OUTPUT IS IN \" DSN2\nSAY \"TSSLNAME: OUTID NUM IS \" OUTID.0\nIF OUTID.0 < 2 THEN\n  SECRC = \"FUNCTION GENERATED NO OUTPUT. CHECK IDS VALIDITY\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSEEYA: NOP\nSAY \"TSSLNAME: AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSPRINT": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x13\\x00\\x99\\x18/\\x01\\x00\\x07_\\x10S\\x00X\\x00X\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-07-01T00:00:00", "modifydate": "2000-03-15T10:53:13", "lines": 88, "newlines": 88, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                **/\n/** sample exec to submit a batch job                   **/\n/*********************************************************/\n/** to add this exec to your system include this line   **/\n/** in your SRCCMD DSN:                                 **/\n/** printint  %tssPRINT 1     0     0    5 ON 2  acid   **/\n/**                                                     **/\n/*********************************************************/\naddress ispexec\narg dsn duplex\ndsn = TRANSLATE(dsn,\"\",\"'\") /* REPLACE tics WITH nulls */\ndsn = strip(dsn)\ndscheck = sysdsn(\"'\"dsn\"'\")\ndsw = \"'\"dsn\"'\"\nif dscheck /= \"OK\" then exit 8\nsignal on error name novar\n/*********************************************************/\n/* the below variables must be set in TSSINI or T$$...   */\n/*********************************************************/\nispexec \"vget ds5 profile      \"\nispexec \"vget mode profile     \"\nispexec \"vget ds3 profile      \"\nispexec \"vget jcard profile    \"\nispexec \"vget srcjcl  profile  \"\n/*********************************************************/\n/* the above variables must be set in TSSINI or T$$...   */\n/*********************************************************/\nfrms = \"STD\"  /* landscape */\nfrms = 1107    /* portrait  */\ndest = \"TDJET\"\nFDEF = \"A10110\"\nsay address tso \"%width\" dsw\naddress tso \"%width\" dsw\nispexec \"vget len profile  \"\nIF LEN > 75 THEN FRMS = \"STD\"  /* TOO WIDE FOR PORTRAIT */\nsignal on error name seeya\ndisp = \"NEW,CATLG\"\noutds = ds5\nif mode = \"BATCH\" then outds = ds3\nid = sysvar(sysuid)\nqx = time()\ntnum = substr(qx,1,2)||substr(qx,4,2)\njobname = \"SPIP\"tnum\nqueue \"//\"jobname \"JOB\" jcard\nqueue \"/*JOBPARM S=*  \"\nqueue \"/*ROUTE PRINT MYDEST1   \"\nqueue \"//DRE OUTPUT FORMS=\"FRMS\",DEST=\"dest\nqueue \"//STP1  EXEC PGM=IEBGENER \"\nqueue \"//***********************************************************\"\nqueue \"//**  THIS JOB IS GOOD FOR FLAT FILES ONLY .                *\"\nqueue \"//**  THIS JOB WAS CREATED FROM THE SPIPRINT command        *\"\nQUEUE \"//***********************************************************\"\nQUEUE \"//SYSPRINT  DD   SYSOUT=*\"\nQUEUE \"//SYSUT1   DD   DSN=\"DSN\",DISP=SHR\"\nQUEUE \"//SYSUT2   DD   SYSOUT=D,DEST=\"DEST\",OUTPUT=*.DRE \"\nqueue \"//SYSIN  DD  DUMMY\"\nqueue \"/*\"\nif srcjcl = \"YES\" then do\n  lines = queued()\n  say \"lines is \"lines\n  do x = 1 to lines\n    pull thejcl.x\n  end\n  /***********************************************/\n  /** submit the job                            **/\n  /***********************************************/\n  address tso \"alloc ddn(outjcl) dsn(\"outds\") shr reus\"\n  address mvs \"execio \"lines\" diskw outjcl ( finis stem thejcl.)\"\n  address tso \"free ddn(outjcl)\"\n  address tso \"submit \"outds\n  secrc = jobname \"submitted,jcl saved , output to =>\"DEST\".\"\n  \"vput secrc profile\"\nend\nelse do\n  queue \"$$                                                        \"\n  address tso \"SUBMIT * END($$)\"\n  secrc = jobname \"submitted dynamically, output to=>\"cfileds\".\"\n  \"vput secrc profile\"\nend\nexit 0\nseeya: nop\nsecrc = \"tssprint terminated abnormally, exit line was\" sigl\n\"vput secrc profile\"\nexit 4\nnovar: nop\nsecrc = \"tssprint variable retrieval failed. line was\" sigl\n\"vput secrc profile\"\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSRWHO": {"ttr": 13571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x11\\x01\\x03&\\x7f\\x01\\x08#\\x1f\\x07\\x02\\x00\\x1c\\x00\\x19\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2003-09-24T00:00:00", "modifydate": "2008-08-18T07:02:11", "lines": 28, "newlines": 25, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : TSSRWHO                           **/\n/** LAST MODIFIED    : OCT 04 2007                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** RTYPE   : RESOURCE TYPE                              **/\n/** RNAME   : RESOURCE NAME                              **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : TSSWHO TSSLNAME      **/\n/**                                                      **/\n/**********************************************************/\nARG RTYPE RNAME DSNAME OUTDSN\nRNAME = STRIP(RNAME)\nDSNAME = STRIP(DSNAME)\nOUTDSN = STRIP(OUTDSN)\nADDRESS TSO \"TSSWHO \"RTYPE RNAME DSNAME\" MOD\"\nADDRESS TSO \"TSSLNAME DSNAME \"DSNAME OUTDSN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSRWHOM": {"ttr": 13573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x003\\x01\\x08#\\x1f\\x01\\x08#\\x1f\\x12Q\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-08-18T00:00:00", "modifydate": "2008-08-18T12:51:33", "lines": 29, "newlines": 29, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/** CREATED TO KEEP THE MOD OPTION                       **/\n/**********************************************************/\n/** EXEC NAME        : TSSRWHO                           **/\n/** LAST MODIFIED    : OCT 04 2007                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** RTYPE   : RESOURCE TYPE                              **/\n/** RNAME   : RESOURCE NAME                              **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : TSSWHO TSSLNAME      **/\n/**                                                      **/\n/**********************************************************/\nARG RTYPE RNAME DSNAME OUTDSN\nRNAME = STRIP(RNAME)\nDSNAME = STRIP(DSNAME)\nOUTDSN = STRIP(OUTDSN)\nADDRESS TSO \"TSSWHO \"RTYPE RNAME DSNAME\" MOD\"\nADDRESS TSO \"TSSLNAME DSNAME \"DSNAME OUTDSN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSSAUD": {"ttr": 13317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x13\\x01\\x02\\x05\\x8f\\x01\\x07)\\x0f\\x13B\\x00`\\x00_\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-02-27T00:00:00", "modifydate": "2007-10-17T13:42:13", "lines": 96, "newlines": 95, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\nARG DSN ACID DATA\naddress ispexec\nsignal on error name novar\npref = sysvar(syspref)\nispexec vget ds4 profile\nispexec vget ds5 profile\nispexec vget tsaud profile\nispexec vget mode  profile\nispexec vget jcard profile\nispexec vget tsaudid profile\nispexec vget recfile profile\nispexec vget srcjcl  profile\nsignal on error name seeya\nupper acid\nid = sysvar(sysuid)\nqx = time()\ntnum = substr(qx,1,2)||substr(qx,4,2)\ndscheck= sysdsn(\"'\"ds4\"'\")\nif dscheck /= \"OK\" then ds4 = pref\".\"ds4\ndscheck= sysdsn(\"'\"newdsn\"'\")\njobname = \"TAUD\"tnum\nds4 = TRANSLATE(ds4,\" \",\"'\") /* REPLACE DOTS WITH SPACES */\nqueue \"//\"jobname \"JOB\" jcard\nqueue \"/*JOBPARM S=*                                           \"\nqueue \"//TSSAUDIT     EXEC     PGM=TSSAUDIT                      \"\nqueue \"//AUDITOUT     DD  DISP=SHR,DSN=\"ds4\nQUEUE \"//RECOVERY     DD  DISP=SHR,DSN=\"recfile\nqueue \"//SYSUDUMP     DD  DUMMY                                  \"\nqueue \"//UTILIN       DD DDNAME=TSSIN                            \"\nQUEUE \"//AUDITIN      DD *                                       \"\nIF (ACID = \"VIOLS\") | (ACID= \"VIOL\")  THEN\n  QUEUE \"  REPORT EVENT(VIOL)  DATE(-\"DATA\")\"\nelse\n  QUEUE \"  CHANGES DATE(-\"DATA\")\"\nqueue \"/*                                                        \"\nqueue \"//SORT  EXEC PGM=IEFBR14,REGION=1024K                     \"\nqueue \"//SORTWK01  DD  UNIT=3390,SPACE=(CYL,(5,2))               \"\nqueue \"//SORTWK02  DD  UNIT=3390,SPACE=(CYL,(5,2))               \"\nqueue \"//SORTWK03  DD  UNIT=3390,SPACE=(CYL,(5,2))               \"\nqueue \"//SORTIN    DD  DISP=SHR,DSN=\"ds4\nqueue \"//SYSOUT    DD  SYSOUT=*                                  \"\nqueue \"//SORTOUT   DD  DISP=SHR,DSN=\"ds4\nqueue \"//SYSIN     DD  *                                         \"\nqueue \"  SORT FIELDS=(19,116,CH,A)                            \"\nqueue \"  SUM FIELDS=NONE                                      \"\nqueue \"//TSOSEND      EXEC     PGM=IKJEFT01,COND=(00,NE,TSSAUDIT) \"\nqueue \"//SYSPRINT     DD  DUMMY                                  \"\nqueue \"//SYSTSPRT     DD  SYSOUT=*                               \"\nqueue \"//SYSTSIN      DD  *                                      \"\nqueue \"   SEND 'Your report ' U(\"id\") LOGON \"\nqueue \"   SEND 'has completed. The output' U(\"id\") LOGON\"\nqueue \"   SEND 'is in DSN=\"ds4\"'  U(\"id\") LOGON\"\nqueue \"//TSOSEND2     EXEC     PGM=IKJEFT01,COND=(00,EQ,TSSAUDIT) \"\nqueue \"//SYSPRINT     DD  DUMMY                                  \"\nqueue \"//SYSTSPRT     DD  SYSOUT=*                               \"\nqueue \"//SYSTSIN      DD  *                                      \"\nqueue \"  SEND 'Your report' U(\"id\") LOGON        \"\nqueue \"  SEND 'has completed. No output' U(\"id\") LOGON        \"\nqueue \"  SEND 'was generated           '  U(\"id\") LOGON        \"\nqueue \"/*                                                        \"\nqueue \"$$                                                        \"\nif (srcjcl = \"YES\") & (mode = \"ONLINE\") then do\n  lines = queued()\n  say \"lines is \"lines\n  do x = 1 to lines\n    pull thejcl.x\n  end\n  /***********************************************/\n  /** submit the job                            **/\n  /***********************************************/\n  address tso \"alloc ddn(outjcl) dsn(\"ds5\") shr reus\"\n  address mvs \"execio \"lines\" diskw outjcl ( finis stem thejcl.)\"\n  address tso \"free ddn(outjcl)\"\n  address tso \"submit \"ds5\n  secrc = jobname \"submitted,jcl saved , output to =>\"ds4\".\"\n  \"vput secrc profile\"\nend\nelse do\n  address tso \"SUBMIT * END($$)\"\n  secrc = jobname \"submitted dynamically, output to=>\"ds4\".\"\n  if mode = \"BATCH\" then do\n    msg2  = \"WARNING: JCL not written to prevent batch jcl overlay.\"\n    \"vput msg2 profile\"\n  end\n  \"vput secrc profile\"\nend\nexit 0\nseeya: nop\nsecrc = \"TSSJAUD terminated abnormally, exit line was\" sigl\n\"vput secrc profile\"\nexit 4\nnovar: nop\nsecrc = \"TSSJAUD variable retrieval failed.  line was\" sigl\n\"vput secrc profile\"\nexit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSU": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x02\\x00'\\x00\\x99'\\x9f\\x01\\x00\\x16_\\x13\\x08\\x00)\\x00)\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-10-06T00:00:00", "modifydate": "2000-06-13T13:08:27", "lines": 41, "newlines": 41, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nADDRESS ISPEXEC\n/****************************************/\n/** THEREXX  LIB IS FILE 1 FROM TAPE   **/\n/****************************************/\n/** THEPANEL LIB IS FILE 3 FROM TAPE   **/\n/****************************************/\nSIGNAL OFF ERROR\nSTACK = \"STACK\"\nADDRESS ISPEXEC \"VGET ZSYSID\"\nADDRESS ISPEXEC \"VGET ZPDFREL\"\nZPDFREL = SUBSTR(ZPDFREL,5)\nIF ZPDFREL < 4.5 THEN STACK = \"\"\n/*********************************************/\n/** AN EXAMPLE OF MULTIPLE REXX LIBS IS BELOW*/\n/*********************************************/\nTHEREXX  =\"'SYS4.SPI.SOURCE' 'MY.LOCAL.SOURCE'\"\n/*********************************************/\n/** AN EXAMPLE OF ONE REXX LIB IS BELOW      */\n/*********************************************/\nTHEREXX  =\"'COA1DIR.SPI.SOURCE'\"   /*< -- YOUR REXX SOURCE LIB*/\nTHEPANEL =\"'COA1DIR.SPI.PANEL'\"    /*< -- YOUR REXX PANEL  LIB*/\nLANG = \"LANG(CREX)\" /* FOR THE COMPILED TSSUT */\nLANG = \" \"          /* FOR THE NON COMPILED TSSUT */\nTSS = \"TSS\"\n\"LIBDEF ISPPLIB DATASET ID(\"THEPANEL\")\" STACK\n ADDRESS TSO\n \"ALTLIB ACTIVATE APPLICATION(CLIST) DATASET(\"THEREXX\")\"\n/********************************************************************/\n/** TO USE THE T$$SAMP EXEC INVOKE THE TSSUT WITH A PARM OF SAMPLE  */\n/** LIKE THIS:                                                      */\n/**    \"SELECT CMD(%TSSUT SAMPLE) NEWAPPL(\"TSS\") \"LANG\" PASSLIB\"    */\n/** OTHERWISE:                                                      */\n/**    \"SELECT CMD(%TSSUT)        NEWAPPL(\"TSS\") \"LANG\" PASSLIB\"    */\n/********************************************************************/\nSAY \"INVOKING TS-ADMIN WITH SAMPLE PARM.. TO CHANGE UPDATE TSSU \"\nADDRESS ISPEXEC,\n\"SELECT CMD(%TSSUT SAMPLE) NEWAPPL(\"TSS\") \"LANG\" PASSLIB\"\n \"ALTLIB DEACTIVATE APPLICATION(CLIST) \"\nADDRESS ISPEXEC\n\"LIBDEF ISPPLIB \"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSUOLD": {"ttr": 285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x02\\x00\\x98(/\\x00\\x98(/\\x14V\\x00\\x07\\x00\\x07\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-09T00:00:00", "modifydate": "1998-10-09T14:56:02", "lines": 7, "newlines": 7, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nADDRESS ISPEXEC \"VGET ZSYSID\"\nADDRESS ISPEXEC\nSYSUID = SYSVAR(SYSUID)\nSYSID = ZSYSID\nTSS = \"TSS\"  /* APPL NAME */\n\"SELECT CMD(%TSSUT) NEWAPPL(\"TSS\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSUT": {"ttr": 13825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x059\\x00\\x00\\x00\\x98(\\x8f\\x01\\t\\x14\\x7f\\x11\\x12\\x05\\xde\\x05\\xd1\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.57", "flags": 0, "createdate": "1998-10-15T00:00:00", "modifydate": "2009-05-27T11:12:00", "lines": 1502, "newlines": 1489, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** Changed command load code to support usercmd table   **/\n/**********************************************************/\n/** Documentation of messages                            **/\n/**********************************************************/\n/** LOG function added                                   **/\n/**********************************************************/\n/** ADDED WRITEDEBUG SUPPORT FOR DYNAM COMMANDS          **/\n/**********************************************************/\n/** ADDED TEMP/PERM PARM TO TABLE DEFINITION ROUTINE     **/\n/**********************************************************/\n/** ADDED POPUP MENU OPTIONS TO THE SYSTEM               **/\n/**********************************************************/\n/** REWRITE TO USE ISPF TABLES FOR SCREEN AND CMDS       **/\n/**********************************************************/\n/** THE MAIN DRIVER ROUTINE OF THE ENTIRE LOCAL PANEL    **/\n/** SYSTEM. IT IS QUITE IN DEPTH SO I AINT GONNA SPLAIN  **/\n/** IT.    DAVE 9 MAY 95                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : TSSUT                             **/\n/** LAST MODIFIED    : 23 Sep  2007                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ANY VARIABLES CREATED IN TSSINI OR ISPF ARE AVAILABLE**/\n/** TO ME HERE. ALTHOUGH THIS EXEC EXPECTS NO ARGS PER SE**/\n/** ISPF VGETS - A TON OF THEM                           **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE.                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : A TON OF THEM        **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\narg sample\nif sample = \"SAMPLE\" then do\n  sample = \"YES\"\n  address ispexec \"VPUT SAMPLE PROFILE\"\nend\naddress ispexec \"VPUT SAMPLE PROFILE\"\nPARSE VERSION V .\nIF LEFT(V,5) = \"REXXC\" THEN COMPILED = \"YES\"\nBEGIN_CPU = SYSVAR(SYSCPU)\nADDRESS ISPEXEC \"VGET ZSYSID\"\nSYSID = ZSYSID\nSPI_VERSION = 23SEP2007\nADDRESS ISPEXEC\nPR = PROMPT(\"OFF\")\nTVERMSG = \"WARNING: YOU HAVE OVERRIDDEN ENVIRONMENTAL PARMS.\"\nSYSUID = SYSVAR(SYSUID)\nMSG2 = \" \"\nDATA = \" \"\nDATA2 = \" \"\nROW =\nINT.0 = 0\nBOOK= \" \"\nCLEARMSG = \"YES\"\nRELOAD = \"BOTH\"\nREINIT: NOP\npanel_depth = 0\nauthcode = 0\ncommand_stack = \"\"\nADDRESS TSO \"%TSSVERS\" /* FIND OUT WHAT TOP SECRET VERSION IS RUNNIN*/\nADDRESS TSO \"%TSSINI\" SYSUID /* SET MY VARIABLES FOR ME */\nIF RC = 24 THEN  EXIT 00     /* TSSINI DIED ! */\nCALL ON ERROR NAME NEWINI\n\" ISPEXEC VGET ACID            PROFILE \"\n\" ISPEXEC VGET AUTHNUM         PROFILE \"\n/********************************************/\n/* \" ISPEXEC VGET AUTHCODE        PROFILE \" */\n/* dont do authcode checking any longer     */\n/********************************************/\n\" ISPEXEC VGET AUTOINIT        PROFILE \"\n\" ISPEXEC VGET CHKDSN          PROFILE \"\n\" ISPEXEC VGET CMDPRE          PROFILE \"\n\" ISPEXEC VGET CMDTABLE        PROFILE \"\n\" ISPEXEC VGET DDS1            PROFILE \"\n\" ISPEXEC VGET DDS2            PROFILE \"\n\" ISPEXEC VGET DDS3            PROFILE \"\n\" ISPEXEC VGET DDS4            PROFILE \"\n\" ISPEXEC VGET DDS5            PROFILE \"\n\" ISPEXEC VGET DDS6            PROFILE \"\n\" ISPEXEC VGET DEF             PROFILE \"\n\" ISPEXEC VGET DSBACK          PROFILE \"\n\" ISPEXEC VGET DS1             PROFILE \"\n\" ISPEXEC VGET DS2             PROFILE \"\n\" ISPEXEC VGET DS3             PROFILE \"\n\" ISPEXEC VGET DS4             PROFILE \"\n\" ISPEXEC VGET DS5             PROFILE \"\n\" ISPEXEC VGET DS6             PROFILE \"\n\" ISPEXEC VGET JESNODE         PROFILE \"\n\" ISPEXEC VGET LOGDSN          PROFILE \"\n\" ISPEXEC VGET LOGFAIL         PROFILE \"\n\" ISPEXEC VGET MSG2            PROFILE \"\n\" ISPEXEC VGET NEWPASS         PROFILE \"\n\" ISPEXEC VGET PANEL           PROFILE \"\n\" ISPEXEC VGET SCRPRE          PROFILE \"\n\" ISPEXEC VGET SCRLOAD         PROFILE \"\n\" ISPEXEC VGET SCRTABLE        PROFILE \"\n\" ISPEXEC VGET SECRC           PROFILE \"\n\" ISPEXEC VGET SRCCMD          PROFILE \"\n\" ISPEXEC VGET USERCMD         PROFILE \"\n\" ISPEXEC VGET SRCSCR          PROFILE \"\n\" ISPEXEC VGET SYSTEM          PROFILE \"\n\" ISPEXEC VGET TABLEDSN        PROFILE \"\n\" ISPEXEC VGET TABLEOPT        PROFILE \"\n\" ISPEXEC VGET TRAPNUM         PROFILE \"\n\" ISPEXEC VGET TSSVERS         PROFILE \"\n\" ISPEXEC VGET TVER            PROFILE \"\n\" ISPEXEC VGET ZAPPLID                 \"\n\" ISPEXEC VGET ZSCREEND                \"\n\" ISPEXEC VPUT SECRC           PROFILE \"\n\" ISPEXEC VPUT CLEARMSG        PROFILE \"\ncall off error\n\" ISPEXEC VGET VARLIST         PROFILE \"\n\" ISPEXEC Verase opt           PROFILE \"\nif scrload = \"NO\" then reload = \"COMMAND\"\nDO CNT = 1 TO WORDS(VARLIST)\n  VNAME = WORD(VARLIST,CNT)\n  ADDRESS ISPEXEC \"Vget \" VNAME \"PROFILE \"\n  IF RC <> 0 THEN DO\n    say \"TSA026W: Vget for  variable \" vname \" failed in tssut\"\n    say \"TSA026W: Variable VARLIST may be improperly set.\"\n  END\nEND\nMSG= \"GENERAL :\"    SECRC\nif substr(strip(secrc),1,3) = \"TSA\" then msg = secrc\nSECRC = \" \"\n    /*******************************************************/\n    /* A $$ INDICATES THE MSG WAS SET BY TSSINI SO KEEP IT */\n    /*******************************************************/\nlog_check =  sysdsn(logdsn)\n/***********************************************************/\n/** AUTHORIZATION CHECKING.... NEVER CHANGE THIS CODE  *****/\n/***********************************************************/\ncodes = words(authcode)\nif codes > 20 then do\n  say \"TSA027W: Too many authorization codes provided. aborting \"\nend\nparse var authcode w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8 w.9 w.10 w.11 w.12,\n          w.13 w.14 w.15 w.16 w.17 w.18 w.19 w.20 end1\ni_digits = digits()\ngooddate = \"invalid\"\n/* MSN UPDATE HERE  signal doneauth  */\nsignal doneauth\nnumeric digits 60\n/******************************/\npsa = ptr(520)\npsa = c2d(psa)  /* we got back a character value from function */\npsa = psa + 6   /* it just got changed to a decimal value */\npsa = d2x(psa)  /* we change it back to a hex value */\ncpu = storage(psa,6) /* give the storage function the address in hex */\ncpu = substr(cpu,3)\nanycpu = 99999\n/******************************/\ngocode: nop\ntoday = date(s)\ndo x = 1 to codes\n  acode = w.x\n  tempdate = ((1000000000000 - acode) + (cpu * cpu)) / cpu\n  datechek = format(tempdate,60,0)\n  t_date = ((1000000000000 - acode) + (anycpu * anycpu)) / anycpu\n  trial_check = format(t_date,60,0)\n  if t_date = trial_check then do\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"TSA028I: Trial code found for processor:\" acode\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"You are authorized to run the product until\" t_date\n    trial = \"yes\"\n    gooddate = t_date\n  end\n  if trial = \"yes\" then leave\n  if tempdate /= datechek then do\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"TSA029I: Skipping code, wrong processor:\" acode\n  end\n  if tempdate /= datechek then iterate x\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"TSA029I: Authorization valid until\" tempdate\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"With authcode :\" acode\n  gooddate = tempdate\nend\nif gooddate = \"invalid\" then do\n  say \"TSA031E: \"\n  say \"***********************************************\"\n  say \"**No valid auth codes found for processor\" cpu\n  say \"***********************************************\"\n  say authcode\n  Say \"Please provide valid AUTHCODE for processor \" cpu\n  Say \"or hit PA1 to exit program \"\n  parse pull acode\n  codes = words(acode)\n  w.1 = acode\n  if w.1 = \"quit\" then exit 0\n  signal gocode\nend\n/* finalcode = 1000000000000 - ((cpu * gooddate) - (cpu * cpu))  */\ntimeleft = gooddate - today\nif timeleft < 200 then do\n  say \"************************\"\n  say \" Your current code is soon to expire.\"\n  MSG2 = \"$$ Authorization is soon to expire, on \"gooddate\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  say \"************************\"\nend\nif today > gooddate then do\n  say \"************************\"\n  say \"expired product         \"\n  say \"************************\"\n  exit 16\nend\nnumeric digits i_digits\n/* */\nIF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\nINT.0 = INT.0 + 1\nHOLDTEMP = INT.0\nIf compiled = \"YES\" then\n  INT.HOLDTEMP = \"Compiled version running, \" spi_version\n/***********************************************************/\n/** AUTHORIZATION CHECKING END NEVER CHANGE THIS CODE  *****/\n/***********************************************************/\ndoneauth: nop\nIF WORD(MSG2,1) \\= \"$$\" THEN DO\n  MSG2 = \" \"\n  \" ISPEXEC VPUT MSG2 PROFILE \"\nEND\nIF NEEDINIT = \"YES\" THEN DO\n  NEEDINIT = \"NO\"\n  IF REINIT1 = \"YES\" THEN DO    /* DEEP TROUBLE ENDLESSLOOP */\n    MSG2 = \"TSSUT/TSSINI SYNC ERROR. FATAL ERROR.\" SIGL\n    CLEARMSG = \"NO\"\n  END\n  ELSE DO\n    REINIT1 = \"YES\" /* INDICATE WE HAVE CALLED TSSINI FROM HERE*/\n    SAY \"SIGNALLING REINIT\"\n    OTT = OUTTRAP(\"OFF\")  /* NOTHING */\n    SIGNAL REINIT\n  END\nEND\nTABLES: NOP\nIF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\nIF TABLEOPT = \"TEMP\" THEN DO\n  /* SAY \"BUILDING TEMPORARY TABLES FOR THIS SESSION \" */\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  int.holdtemp = \"TSA101D: TSSUT table load commencing. parm is \" reload\n  OTT = OUTTRAP(ON.,100)  /* TRAPALL */\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"SCREEN\") THEN\n  ADDRESS TSO \"%TBMSCR\" SRCSCR \".\" SCRTABLE AUTHNUM \"NO\"\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"COMMAND\") THEN\n  ADDRESS TSO \"%TBMCMD\" USERCMD \".\" CMDTABLE AUTHNUM \"NO\"\n  /*****************************************************/\n  /**THE ABOVE ROUTINES BUILD TABLES AND LEAVE THEM   **/\n  /** OPEN FOR USE BY THIS EXEC                       **/\n  /*****************************************************/\n  RELOAD = \"BOTH\"\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  int.holdtemp = \"TSA101D: Table load complete. debug msgs below\"\n  OTT = OUTTRAP(\"OFF\")  /* NOTHING */\nEND\nIF TABLEOPT /= \"TEMP\" THEN DO\n  OTT = OUTTRAP(ON.,100)  /* TRAPALL */\n  /*****************************************************/\n  /**THE ABOVE OPTION INDICATES WE ARE USING PERMANENT**/\n  /** TABLES THAT ARE PREDEFINED SO LETS OPEN THEM    **/\n  /*****************************************************/\n  CALL OFF ERROR\n  SIGNAL OFF ERROR\n  CALL ON ERROR NAME NOTABLE\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"COMMAND\") THEN\n  ADDRESS ISPEXEC \"TBOPEN\" CMDTABLE \"NOWRITE\"\n  /*IF STABLE_RC = 12 THEN */\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"SCREEN\") THEN\n  ADDRESS ISPEXEC \"TBOPEN\" SCRTABLE \"NOWRITE\"\n  TRACE OFF\nEND\nCALL ON ERROR NAME SHUCKS\n/*PANEL  = \"SPIUTIL\"                     */\n/*ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"   */\nIF PANEL /= \"SPIUTIL\" THEN DO\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"**Table display is disabled do to custom panel.\"\n  PANEL_ENV = \"BASIC\"\nEND\nDEFPNL = PANEL\ndp.0 = defpnl\nOLDTVER =  TVER\nSCRNUM = ZSCREEND - 7\nWDS. = \" \"\nUNIT =  TSOUNIT\n/******************************************************************/\n/*  NOW I HAVE RETRIEVED ALL VARIABLES   BY TSSINI    DIR 9 SEP 92*/\n/*  I WILL NOW CHECK FOR DSN VALIDITY....DIR  14 SEP 92           */\n/******************************************************************/\nDDS.1 = DDS1\nDDS.2 = DDS2\nDDS.3 = DDS3\nDDS.4 = DDS4\nDDS.5 = DDS5\nDDS.6 = DDS6\nIF CHKDSN < > \"YES\" THEN SIGNAL DSNDONE\nDO TT = 1 TO 6\n  XX = \"DS\"TT\n  DSNTEMP = VALUE(XX)\n  DSNMSG = SYSDSN(DSNTEMP)\n  /* SAY \"DSNMSG \" DSNMSG \"DSN= \" DSNTEMP */\n  IF DSNMSG = \"OK\" THEN ITERATE TT\n  msg2 = \"Work dsn(s) unavailable. some advanced functions may fail\"\n  /* SAY MSG2  */\n  WDS.TT = \"*\"\n  DDS.TT = DSNMSG\n  IF DSNMSG = \"DATASET NOT FOUND\" THEN DO\n    msg2 = \"Work dsn(s) invalid. some advanced functions may fail\"\n     WDS.TT = \"**\"\n  END\n  IF WORD(MSG2,1) \\= \"$$\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nDDS1 = DDS.1\nDDS2 = DDS.2\nDDS3 = DDS.3\nDDS4 = DDS.4\nDDS5 = DDS.5\nDDS6 = DDS.6\nWDS1 = WDS.1\nWDS2 = WDS.2\nWDS3 = WDS.3\nWDS4 = WDS.4\nWDS5 = WDS.5\nWDS6 = WDS.6\nDSNDONE: NOP\nBOPEN = NO\nCURSOR = \"OPT\"\nSPACES = \"                \"\nCMDNUM = 0\nRCODE = 0\nMENUNUM = 0\nSCRARRAY.0 = 0\nMODE = \"ONLINE\"\nIF  PANEL = \"\" THEN  DO\n  msg2 =  \"TSA049E: Warning! TSSINI has failed. variables may be\"\n  msg2 =    msg2 \"corrupted.\"\n  PANEL = SPIUTIL\n  CLEARMSG = \"NO\"\nEND\nCALL OFF ERROR\nSIGNAL OFF ERROR\nCALL ON ERROR NAME SHUCKS\nANUM = 1\n/* SAY SCRARRAY.0 AUTHNUM */\nDO Q = 1 TO ANUM\n  SCRARRAY.Q = OUTA.Q\nEND\nMSG1. = ; MSG2. = ; MSG3. = ; MSG4. = ; MSG5. = ; MSG6.= ; MSG7. = ;\nTEMPARRAY.0 = 0\nTHISREC = 1\nY = 0\nX = 0\nOTT = OUTTRAP(ON.,TRAPNUM) /* TRAP EVERYTHING */\nSOURCE = PREDEF\nif logdsn / = \"NONE\" then do\n  initlog.0 = 3\n  initlog.1 = \"Log initialized for ID\" sysuid\n  initlog.2 = \"on Date\" today\n  initlog.3 = \"**************************\"\n  if log_check = \"MEMBER NOT FOUND\" then do\n    address tso \"alloc ddn(logdd) dsn(\"logdsn\") shr reus\"\n    ADDRESS MVS \"EXECIO * DISKW LOGDD (FINIS STEM INITLOG.)\"\n    address tso \"free ddn(logdd)\"\n  end\n  IF log_check  = \"DATASET NOT FOUND\" THEN DO\n    ADDRESS TSO \"ALLOC DSN(\"LOGDSN\") UNIT(\"ALUNIT\") NEW DDN(LOGDD)\",\n    \"SPACE(15) CYLINDERS LRECL(80) BLKSIZE(24800) RECFM(F B) DSORG(PS)\"\n    ADDRESS MVS \"EXECIO * DISKW LOGDD (FINIS STEM INITLOG.)\"\n    address tso \"free ddn(logdd)\"\n  END\n  log_check = sysdsn(logdsn)\n  /*if log_check = \"OK\" then do                                  */\n  /*  address tso \"alloc ddn(logdd) dsn(\"logdsn\") mod reus\"      */\n  /*end                                                          */\nend\nif (log_check /= \"OK\") & (logfail = \"YES\") then do\n  msg2 =  \"LOG Dataset is not usable, no logged functions are\"\n  msg2 = msg2 \"available.\"\n  clearmsg = \"NO\"\n  address ispexec \"vput msg2 profile\"\n  address ispexec \"vput clearmsg profile\"\nend\n/******************************************************************/\n/*  THIS IS THE LASTOF THE INIT AREA. WHAT FOLLOWS IS THE LOOP.   */\n/******************************************************************/\nTRAP_FLAG = \"YES\"\nDISPPNL: NOP\n  RCODE = 0 /*  RESET THE LAST ERROR RETURN CODE */\n  IF WORD(HOLDLINE,1) = WORD(ACID,1) THEN ACID = HOLDLINE\n  IF OPT = \"NIL\" THEN OPT = \" \"\n  CPUUSED = SYSVAR(SYSCPU) - BEGIN_CPU\n  ADDRESS ISPEXEC  \"VGET MSG2 PROFILE\"\n  ADDRESS ISPEXEC  \"VGET PANEL PROFILE\"\n  ADDRESS ISPEXEC  \"VGET CLEARMSG PROFILE\"\n  ADDRESS ISPEXEC  \"VPUT CPUUSED  PROFILE\"\n  AUTH = AUTHNUM\n  /* \"TBSARG TS5USC10 NAMECOND(AUTH,LE)\" */\n  IF PANEL = \"SPISTAT\" THEN SCAN = \"YES\"\n  IF (FNAME /= \"FNAME\") & (SCAN = \"NO\") THEN DO\n    OTT = OUTTRAP(ON.,TRAPNUM) /* TRAP EVERYTHING */\n    ADDRESS ISPEXEC \"TBSARG \"SCRTABLE\" ARGLIST(FNAME)\"\n    CALL OFF ERROR\n    \"TBGET\" SCRTABLE\n    ADDRESS ISPEXEC \"TBSKIP \"SCRTABLE\" NUMBER(-\"scrnum\")\"\n    CALL ON ERROR NAME SHUCKS\n    /*********************************************/\n    /** EACH LINE PUT ON THE SCREEN UPDATES THE **/\n    /** VARIABLES SO EACH TIME WE DONT SCAN WE  **/\n    /** SET THE TOP OF SCREEN VALUE TO BOTTOM   **/\n    /** - 14                  DAVE              **/\n    /*********************************************/\n  END\n  SCAN = \"NO\"\n  PNL_DISP = \"YES\"\n  /**************************************************************/\n  /** If the below display fails due to a table not open, one  **/\n  /** of two things has occurred.                              **/\n  /** 1 - The panel ( spiutil ) is not available               **/\n  /** 2 - The temporary table name is not available            **/\n  /**     This would happen if the variable scrload is \"NO\"    **/\n  /**     and the panel was set to spiutil. The spiutil panel  **/\n  /**     requires that the screen table be loaded. An error of**/\n  /**     this type is almost always the result of an error in **/\n  /**     the T$$ exec                                         **/\n  /**                                                          **/\n  /**************************************************************/\n   Select\n     when (PANEL = \"SPIUTIL\") & (scrload = \"YES\") then\n       \"TBDISPL \"SCRTABLE\" PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n     when (PANEL = \"SPIUTIL\") & (scrload = \"NO\") then do\n       msg = \"TSA053E: Table/screen mismatch, SPIMAIN displayed\"\n       panel_depth = 0\n       command_stack = \"\"\n       panel_env = \"BASIC\"\n       prefenv = \"BASIC\"\n       opt = \"\"\n       panel = \"SPIMAIN\"\n       defpnl = \"SPIMAIN\"\n       dp.0   = \"SPIMAIN\"\n       address ispexec \"vput panel profile\"\n       address ispexec \"vput prefenv profile\"\n       signal disppnl\n     end\n     otherwise \"DISPLAY PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n   End\n   upper opt\n   /*  old panel display is below\n  IF (PANEL = \"SPIUTIL\") & (scrload = \"YES\") then\n  \"TBDISPL \"SCRTABLE\" PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n  IF (PANEL /= \"SPIUTIL\") & (scrload = \"YES\") then\n  ELSE \"DISPLAY PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n  */\n  PNL_DISP = \"NO\"\n  if panel = \"SPIPOP\" then do\n  end\n  SOURCE = \"PREDEF\"\n  IF OPT = \"TRACEOFF\" THEN TRACE OFF\n  IF OPT = \"STATUS\" then opt = \"0\"\n  ACID_WORDNUM = WORDS(ACID)\n  DATA_WORDNUM = WORDS(DATA)\n  DATA2_WORDNUM = WORDS(DATA2)\n  HOLDLINE = ACID\n  \"ISPEXEC VPUT ACID PROFILE\"\n  \"ISPEXEC VPUT DATA PROFILE\"\n  \"ISPEXEC VPUT DATA2 PROFILE\"\n  IF CLEARMSG = \"YES\"  THEN DO\n    MSG2 =  \" \"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \"VPUT CLEARMSG PROFILE\"\n  END\n  MSG =   \" \"\n  SECRC=  \" \"\n  UPPER DATA\n  UPPER DATA2\n  UPPER ACID\n  FUNCT= \"GENERAL\"\n  CURSOR= \"OPT\"\n  HOLD = ACID\"     \"\n  FIRST4 = SUBSTR(HOLD,1,4)\n/***********************************************************/\n/* HERE WE START THE SPECIAL ENVIRONMENT AFFECTING         */\n/* OPTIONS....................DIR 19 OCT 92                */\n/***********************************************************/\n  IF OPT = \"SCREENLOAD\" THEN DO\n    IF (SYSDSN(\"'\"ACID\"'\")/= \"OK\") & (SYSDSN(ACID)/= \"OK\") THEN DO\n      secrc = \"TSA032E: Load dataset not usable, load aborted.\" acid\n      SIGNAL GOTMSG\n    END\n    IF TABLEOPT /= \"TEMP\" THEN DO\n      secrc = \"TSA033E: Table format not dynamic, screenload not valid.\"\n      SIGNAL GOTMSG\n    END\n    RELOAD = \"SCREEN\"\n    \"ISPEXEC TBEND \"SCRTABLE\n    SRCSCR = ACID\n    SIGNAL TABLES\n  END\n  IF OPT = \"COMMANDLOAD\" THEN DO\n    if PANEL_ENV = \"BASIC\"  then do\n      address tso \"%popexp\"\n      call disppop\n      acid = v1 ;data = v2; data2 = v3\n    end\n    IF (SYSDSN(\"'\"ACID\"'\")/= \"OK\") THEN DO\n      secrc = \"TSA032E: Load dataset not usable, load aborted.\"\n      SIGNAL GOTMSG\n    END\n    IF TABLEOPT /= \"TEMP\" THEN DO\n     secrc = \"TSA033E: Table format not dynamic, commandload not valid.\"\n      SIGNAL GOTMSG\n    END\n    RELOAD = \"COMMAND\"\n    \"ISPEXEC TBEND \"CMDTABLE\n    USERCMD = ACID\n    \" ISPEXEC VPUT USERCMD         PROFILE \"\n    SIGNAL TABLES\n  END\n  IF OPT = \"FILECHECK\" THEN DO\n    TRAP_FLAG = \"YES\"\n    OPT = \"NIL\"\n    ADDRESS TSO \"%FSDISP %FILECHK\"\n    SIGNAL NOMSG\n  END\n  IF OPT = \"WRITEDEBUG\" THEN DO\n    TRAP_FLAG = \"YES\"\n    OPT = \"NIL\"\n    ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") SHR REUS\"\n    ADDRESS MVS \"EXECIO \"INT.0\" DISKW OUT1 ( FINIS STEM INT.)\"\n    ADDRESS TSO \"FREE DDN(OUT1)\"\n    ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") MOD\"\n    ADDRESS MVS \"EXECIO \"TRAPNUM\" DISKW OUT1 ( FINIS STEM ON.)\"\n    ADDRESS TSO \"FREE DDN(OUT1)\"\n    DO QW1 = 1 TO TRAPNUM; ON.QW1 = \" \"; END\n    secrc = \"TSA046I:\" trapnum \"lines of debug file info written to \"ds3\n    address tso \"%rxbrowse \"ds3\n    SIGNAL GOTMSG\n  END\n  IF OPT = \"WD\" THEN DO\n    TRAP_FLAG = \"YES\"\n    OPT = \"NIL\"\n    ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") SHR REUS\"\n    ADDRESS MVS \"EXECIO \"INT.0\" DISKW OUT1 ( FINIS STEM INT.)\"\n    ADDRESS TSO \"FREE DDN(OUT1)\"\n    ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") MOD\"\n    ADDRESS MVS \"EXECIO \"TRAPNUM\" DISKW OUT1 ( FINIS STEM ON.)\"\n    ADDRESS TSO \"FREE DDN(OUT1)\"\n    DO QW1 = 1 TO TRAPNUM; ON.QW1 = \" \"; END\n    secrc = \"TSA046I:\" trapnum \"lines of debug file info written to \"ds3\n    address tso \"%rxbrowse \"ds3\n    SIGNAL GOTMSG\n  END\n  IF OPT = \"TRAPOFF\" THEN DO\n    OTT = OUTTRAP(\"OFF\")  /* NOTHING */\n    TRAP_FLAG = \"NO\"\n    OPT = \"NIL\"\n    secrc = \"TSA034I: All internal output will now be shown.\"\n    SIGNAL GOTMSG\n  END\n  IF OPT = \"TRAPSET\" THEN DO\n    if datatype(acid) /= \"NUM\" then acid = 1000\n    trapnum = acid\n    secrc = \"TSA054I: Trapnum reset to \"acid\n    SIGNAL GOTMSG\n  END\n  IF OPT = \"TRAPON\" THEN TRAP_FLAG = \"YES\"\n  IF OPT = \"TRAPON\" THEN DO\n    TRAP_FLAG = \"YES\"\n    secrc = \"TSA035I: I am now trapping subtask created messages.\"\n    SIGNAL GOTMSG\n  END\n  IF TRAP_FLAG = \"YES\" THEN DO\n     SS = OUTTRAP(ON.,TRAPNUM)\n  END\n  IF TRAP_FLAG = \"NO\" THEN DO\n     SS = OUTTRAP(OFF)\n  END\n  IF (OPT = \"NIL\") | (OPT = \" \" )  THEN DO\n    OPT = \" \"\n    SIGNAL DISPPNL\n  END\n  IF OPT = \"TRAPON\" THEN TRAP_FLAG = \"YES\"\n  IF OPT = \"TRAPOFF\" THEN TRAP_FLAG = \"NO\"\n  IF OPT = \"TRACE\" THEN TRACE R\n  IF OPT = \"TRACE\" THEN SIGNAL REDO\n  IF OPT = \"TRACEOFF\" THEN SIGNAL REDO\n  IF OPT = \"LEAVE\" THEN CALL SHUCKS\n  IF OPT = \"END\" THEN EXIT\n  IF OPT = \"X\" THEN CALL SHUCKS\n  IF OPT = \"QUIT\" THEN CALL SHUCKS\n  IF  TVER \u00ac= OLDTVER THEN  DO\n    MSG2 = TVERMSG\n    CLEARMSG = \"NO\"\n  END\n  IF OPT = \"BASIC\" THEN DO\n    panel_depth = 0\n    command_stack = \"\"\n    panel_env = \"BASIC\"\n    prefenv = \"BASIC\"\n    opt = \"\"\n    panel = \"SPIMAIN\"\n    defpnl = \"SPIMAIN\"\n    dp.0   = \"SPIMAIN\"\n    msg = \"TSA518I: Mode changed due to user request.\"\n    address ispexec \"vput panel profile\"\n    address ispexec \"vput prefenv profile\"\n    signal disppnl\n  end\n  IF OPT = \"EXPERT\" THEN DO\n    panel_depth = 0\n    command_stack = \"\"\n    opt = \"\"\n    PANEL_ENV = \"EXPERT\"\n    Prefenv = \"EXPERT\"\n    panel = \"SPIUTIL\"\n    defpnl = \"SPIUTIL\"\n    dp.0   = \"SPIUTIL\"\n    msg = \"TSA518I: Mode changed due to user request.\"\n    address ispexec \"vput panel profile\"\n    address ispexec \"vput prefenv profile\"\n    if scrload = \"NO\" then do\n      scrload = \"YES\"\n      reload = \"SCREEN\"\n      signal tables\n    end\n    signal disppnl\n  end\n  IF OPT = \"REXXCMD\" THEN DO\n    if PANEL_ENV = \"BASIC\"  then do\n      address tso \"%popexp\"\n      call disppop\n      acid = v1 ;data = v2; data2 = v3\n    end\n    IF INDEX(ACID,\"SOURCELINE\") = 0 THEN INTERPRET ACID\n    msg = \"TSA050I: REXX input interpreted successfully.\"\n    IF INDEX(ACID,\"SOURCELINE\") /= 0 THEN\n      msg = \"TSA051W: REXXCMD invalid, input ignored.\"\n    OPT = \" \"\n    SIGNAL REDO\n  END\n  /* IF (OPT \u00ac= \"CMDO\") &  (OPT \u00ac= \"CMDS\") THEN ACID = WORD(ACID,1) */\n  IF  PANELRC = 8 THEN  DO\n    PANEL= DEFPNL\n    ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n    PANELRC=0\n    msg= \"Function completed successfully\"\n    FUNCT = \"GENERAL\"\n    OPT=  \" \"\n    SIGNAL REDO\n  END\n  IF  OPT = \"REINIT\" THEN  DO\n    INI = \"NO\"\n    RELOAD = \"BOTH\"\n    \"ISPEXEC TBEND \"CMDTABLE\n    if scrload = \"YES\" then\n      \"ISPEXEC TBEND \"SCRTABLE\n    \"ISPEXEC VPUT INI PROFILE\"\n    SIGNAL REINIT\n  END\n  /************************************************/\n  /**--------DYNAMIC COMMAND AREA----------------**/\n  /**  OW LETS PROCESS THE USERS CMDLIST DSN     **/\n  /**--------DYNAMIC COMMAND AREA----------------**/\n  /************************************************/\n  ADDRESS ISPEXEC \"TBTOP \"CMDTABLE\n  ADDRESS ISPEXEC \"TBVCLEAR \"CMDTABLE\n  CMDNAME = OPT\n  if datatype(opt) = \"NUM\" then do\n    /* we must translate the numeric command to the stacked command */\n    /* format that is used in the input parm file.. 21 Oct 99       */\n    numeric_flag = \"YES\"\n    hold = command_stack||\".\"OPT\n    if panel_depth = 0 then hold = opt\n    cmdname = HOLD\n    /* say \"Reformatted command is now\" cmdname */\n  end\n  cmdlook: nop\n  ADDRESS ISPEXEC \"VPUT CMDNAME\"\n  ADDRESS ISPEXEC \"TBSARG \"CMDTABLE \"ARGLIST(CMDNAME)\"\n  CALL OFF ERROR\n  signal off error\n  OTT = OUTTRAP(ON.,trapnum)  /* TRAPALL */\n  IF TRAP_FLAG = \"NO\" THEN\n    OTT = OUTTRAP(\"OFF\")  /* TRAPNONE */\n  \"TBGET\" CMDTABLE\n  CMD_RC = RC\n  CALL ON ERROR NAME SHUCKS\n  IF CMD_RC = 0 THEN DO\n    if numeric_flag = \"YES\" then do\n      numeric_flag = \"NO\"\n      Panel_depth = Panel_depth + 1\n      command_stack = command_stack||\".\"OPT\n      if panel_depth = 1 then command_stack = opt\n      OPT = \"\"\n    end\n    ck1 = index(vars,\"ACID\")\n    ck2 = index(vars,\"DATA \")\n    ck3 = index(vars,\"DATA2 \")\n    ck4 = ck1 + ck2 + ck3\n    IF SUBSTR(PGMNAME,1,5) = \"TVER.\" THEN\n      PGMNAME= \"%\"||TVER||SUBSTR(PGMNAME,6)  /* VER 51 */\n    if (panel_env = \"BASIC\") & (ck4 /= 0) &,\n      (substr(pgmname,1,1) /= \"/\") then do\n  /*  secrc=\"TSA516E: Expert function is unavailable in basic mode.\"*/\n      pgmname = \"/EXP.\"pgmname\n    /*SIGNAL GOTMSG   */\n    end\n    INT.0 = 0\n    IF TRAP_FLAG = \"NO\" THEN\n      SAY PGMNAME MSGOPT DATACK DATA2CK AUTH TRAPOPT BATCHOPT VARS\n    IF TRAP_FLAG = \"YES\" THEN DO\n      IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n      INT.0 = INT.0 + 1\n      HOLDTEMP = INT.0\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"***DYNAMIC ROUTINE ENTERED MATCH IS BELOW: **\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"PGM     MSG  DATA DATA2 AUTH TRAP BATCH VARS \"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = PGMNAME MSGOPT\"   \" DATACK\"    \" DATA2CK\"    \",\n      AUTH\"  \" TRAPOPT\"   \" BATCHOPT \"    \"VARS\n      INT.0 = HOLDTEMP\n    END\n    If substr(pgmname,1,1) = \"/\" then do\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"/ control indicator found found.\"\n      INT.0 = HOLDTEMP\n      if substr(pgmname,2) = \"SCREEN\" then do\n        panel = strip(msgopt)\n        if panel = \"SPI.SYSID.\" then panel = \"SPIL\"ZSYSID\n        address ispexec \"vput panel profile\"\n        msg = \"\"\n        address ispexec \"vput msg profile\"\n        dp.panel_depth = panel\n        panel_var = \"dpanel.\"cmdname\n        /* say panel_var \"= panel\"  */\n        interpret panel_var \"= panel\"\n        /*  say \"Displaying panel \"panel */\n        signal disppnl\n      end\n      temp_cmd = \"POP\"||substr(pgmname,2,3)\n      INT.0 = INT.0 + 1\n      HOLDTEMP = INT.0\n      int.holdtemp = \"TSA101D: Calling prepatory command\" temp_cmd\n      address ispexec \"vput opt profile\"\n      address tso \"%\"temp_cmd\n      pgmname = substr(pgmname,6)\n      IF SUBSTR(PGMNAME,1,5) = \"TVER.\" THEN\n        PGMNAME= \"%\"||TVER||SUBSTR(PGMNAME,6)  /* VER 51 */\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"PGMNAME is now:\" pgmname\n      call disppop\n      /***********************************/\n      /** if the temp_cmd is popexp then**/\n      /** the user is in basic mode and **/\n      /** issuing expert commands       **/\n      /** not the best but well try     **/\n      /***********************************/\n      if temp_cmd = \"POPEXP\" then do\n        acid = v1 ;data = v2; data2 = v3\n      /*say \"ACID DATA DATA2\"\n        say  ACID DATA DATA2  */\n      end\n      if pop_rc /= 0 then do\n      trace off\n        secrc = \"TSA517I: Popup panel aborted, function stopped.\"\n        signal gotmsg\n      end\n      INT.0 = HOLDTEMP\n    end\n    ADDRESS ISPEXEC \"VPUT MODE  PROFILE\"\n    IF TRAP_FLAG = \"NO\" THEN\n      say \"TSA101D: Dynamic routine finds command match on record \" q\n    FUNCT = OPT\n    SOURCE = \"DYNAM\"\n    IF AUTH > AUTHNUM THEN DO\n      secrc = \"TSA036I: Failed. requires authority level\" auth\".\"\n      secrc = secrc \" your level is\" authnum\n      SIGNAL GOTMSG\n    END\n    IF (trapopt = \"LOG\") & (logfail = \"YES\"),\n    & (log_check /= \"OK\") then do\n      secrc = \"TSA037E: Aborted.\"\n      secrc = secrc \"Log is unavailable yet function requires log.\"\n      SIGNAL GOTMSG\n    END\n    /*********************/\n    /** CHECK DATA TYPE **/\n    /*********************/\n    IF (DATACK = \"NUM\" ) & (DATATYPE(DATA) \u00ac= \"NUM\") THEN DO\n      MSG = \"TSA038E: \"\n      msg = msg \"A numeric data field is required for this function\"\n      SIGNAL REDO\n    END\n/*  IF (ACID = \" \" ) & (panel_env = \"EXPERT\") then do\n      MSG = \"TSA038E: \"\n      msg = msg \"An ACID field is required for this function\"\n      SIGNAL REDO\n    END */\n    IF (DATACK = \"CHAR\" ) & (DATATYPE(DATA) \u00ac= \"CHAR\") THEN DO\n      MSG = \"TSA038E: \"\n      msg= msg \"A character data field is required for this function\"\n      SIGNAL REDO\n    END\n    /***********************************************************/\n    /* MSN 06/01/95 - OPTC MEANS FIELD IS OPTIONAL BUT IF IT   */\n    /*    IS CODED, THEN IT MUST BE CHARACTER FORMAT           */\n    /***********************************************************/\n    IF (DATACK = \"OPTC\" ) & (DATATYPE(DATA) \u00ac= \"CHAR\") THEN DO\n      MSG = \"TSA038E: \"\n      msg = msg \"Aborted, if provided the data field must be character.\"\n      SIGNAL REDO\n    END\n    IF DATACK = \"PAD.\"  THEN DO\n      DATA = TRANSLATE(DATA,\".\",\" \")\n      SAY \"DYNAM: BLANKS TRANSLATED TO DOTS IN DATA.\"\n      SAY \"DYNAM: RESULT OF TRANS:\" DATA\n    END\n    IF (DATACK = \"OPTN\" ),\n    & (DATATYPE(DATA) \u00ac= \"NUM\") THEN DO\n      MSG = \"TSA038E:\"\n      msg = msg \"Aborted, if provided the data field must be numeric.\"\n      SIGNAL REDO\n    END\n    IF ( (DATACK = 1 ) | (DATACK = \"CHAR\" ) ) & (DATA = \" \") THEN DO\n      MSG = \"TSA038E:\"\n      msg = msg \"The data field is required for this function\"\n      SIGNAL REDO\n    END\n    IF (DATA2CK = \"OPTN\" ),\n    & ((DATATYPE(DATA2) \u00ac= \"NUM\") & length(strip(data2)) > 0) THEN DO\n      MSG = \"TSA038E:\"\n      msg = msg \"Aborted, if provided the data2 field must be numeric.\"\n      SIGNAL REDO\n    END\n    IF (DATA2CK = \"NUM\" ) & (DATATYPE(DATA2) \u00ac= \"NUM\") THEN DO\n      MSG = \"TSA038E:\"\n      msg = msg \"A numeric data2 field is required for this function\"\n      SIGNAL REDO\n    END\n    IF (DATA2CK = \"CHAR\" ) & (DATATYPE(DATA2) \u00ac= \"CHAR\") THEN DO\n      MSG = \"TSA038E:\"\n      msg = msg \"A character data2 field is required for this function\"\n      SIGNAL REDO\n    END\n    IF ( (DATA2CK = 1 ) | (DATA2CK = \"CHAR\" ) ) & (DATA2= \" \") THEN DO\n      MSG = \"TSA038E:\"\n      msg = msg \"The data2 field is required for this function\"\n      SIGNAL REDO\n    END\n    /******************************/\n    /** FUTURE CMD STACKING DO   **/\n    /** GOES HERE.               **/\n    /******************************/\n    BATCH_VARS = \" \"\n    PARSE VAR VARS W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11,\n          W.12 W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20\n    STOP =  WORDS(VARS)\n    IF STOP > 20 THEN\n      MSG2 = \"DYNAM ROUTINE OVERFLOW MORE THAN 20 VARIABLES IN ARGS\"\n    /******************************/\n    /** LETS SEPERATE THE VARS   **/\n    /** FROM THE LITERALS IN THE **/\n    /** COMMAND STREAM.          **/\n    /** LITERALS HAVE A _ IN.    **/\n    /******************************/\n    DO T1 = 1 TO STOP\n      STRIP = \"NO\"\n      IF (INDEX(W.T1,\"$\") = 1) & (INDEX(W.T1,\".\") = 3) THEN DO\n        holdit1 = substr(w.t1,4)\n        wnum = substr(w.t1,2,1)\n        holdit2 = word(value(holdit1),wnum)\n        INT.0 = INT.0 + 1\n        HOLDTEMP = INT.0\n        INT.HOLDTEMP = \"TSA101D: Dynam replacing \"w.t1\n        INT.HOLDTEMP = int.holdtemp \"with constant\" holdit2\n        INT.0 = HOLDTEMP\n        w.t1 = \"_\"holdit2\n      END\n      IF (INDEX(W.T1,\"<\") \u00ac= 0) THEN DO\n        W.T1 = TRANSLATE(W.T1,\"\",\"<\") /* REPLACE _ WITH NULL */\n        W.T1 = STRIP(W.T1)\n        STRIP = \"YES\"\n        IF TRAP_FLAG = \"NO\" THEN\n          SAY \"DYNAM: DETECTED A NO SPACE VAR\"\n        IF TRAP_FLAG = \"YES\" THEN DO\n          IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n          INT.0 = INT.0 + 1\n          HOLDTEMP = INT.0\n          int.holdtemp = \"TSA101D: Dynam detected a no space var\"\n          INT.0 = HOLDTEMP\n        END\n      END\n      IF (INDEX(W.T1,\"_\") \u00ac= 0) | (DATATYPE(W.T1) = \"NUM\") THEN\n        VAL = TRANSLATE(W.T1,\" \",\"_\") /* REPLACE _ WITH SPACES */\n      ELSE VAL = VALUE(W.T1)\n      VAL = STRIP(VAL)\n      IF STRIP = \"NO\" THEN\n        BATCH_VARS = BATCH_VARS VAL\n      ELSE\n        BATCH_VARS = BATCH_VARS||VAL\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"VALUE OF VAR \" W.T1 \"IS \" VAL\n      IF TRAP_FLAG = \"YES\" THEN DO\n        IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n        INT.0 = INT.0 + 1\n        HOLDTEMP = INT.0\n        int.holdtemp = \"TSA101D: Value of var \" w.t1 \"is \" val\n        INT.0 = HOLDTEMP\n      END\n    END\n    IF VARS = 0 THEN BATCH_VARS = \" \"\n    /*******************************************************/\n    /* Discovered a problem when a non isp command is > 70 */\n    /* characters. It is reformatted as if it is an ISP    */\n    /* command. Dave 2 Feb 2001                            */\n    /*******************************************************/\n    /*******************************************************/\n    IF  (MODE = \"BATCH\") & (BATCHOPT = 0) THEN DO\n      BJCL.1 = PGMNAME BATCH_VARS\n      IF ((LENGTH(BJCL.1) > 70) & (index(pgmname,\"%\") <> 1)) THEN DO\n        PARSE VAR BATCH_VARS  TZ.1 TZ.2 TZ.3 TZ.4 TZ.5 TZ.6\n        /*******************************************************/\n        /* lets chop up the long command for readability      **/\n        /*******************************************************/\n        BJCL.1 = PGMNAME  TZ.1 TZ.2 \" -\"\n        BATCH_VARS = \"  \" TZ.3 TZ.4 TZ.5 TZ.6\n        BJCL.2 = BATCH_VARS\"   \"\n        ADDRESS MVS \"EXECIO 2 DISKW BJCL (FINIS STEM BJCL.)\"\n        BJCL.1 = \" \" /* clear the var for the fall thru write */\n      END\n      IF INDEX(PGMNAME,\"%\") =  1 THEN do\n        BJCL.1 = \"ISPSTART CMD(\"PGMNAME BATCH_VARS\") NEWAPPL(TSS)\"\n        IF LENGTH(BJCL.1) > 70 THEN DO\n          BJCL.1 = \"ISPSTART -\"\n          BJCL.2 = \" CMD(\"PGMNAME\" -\"\n          BJCL.3 = BATCH_VARS\") -\"\n          ADDRESS MVS \"EXECIO 3 DISKW BJCL (FINIS STEM BJCL.)\"\n          /*******************************************************/\n          /* THE LINE BELOW WILL BE WRITTEN BY THE FALLTHRU AREA */\n          /*******************************************************/\n          BJCL.1 = \" NEWAPPL(TSS)\"\n          BJCL.2 = \"BJCL.2\"\n        END\n      END\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"THE BATCH FILE IS UPDATED, COMMAND IS \" BJCL.1 BJCL.2\n      ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      SIGNAL NOMSG\n    END\n    IF  (MODE = \"BATCH\") & (BATCHOPT = 1) THEN DO\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"DYNAM: THE BATCH FILE IS BEING ALLOCATED DISP = MOD\"\n      ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\" DS5\") MOD REUS\"\n      BOPEN = YES\n    END\n    ADDRESS ISPEXEC \"VPUT (ACID DATA DATA2) PROFILE\"\n    IF (TRAPOPT = \"OFF\") | (TRAPOPT = 0) THEN\n      SS = OUTTRAP(OFF)\n    IF TRAP_FLAG = \"NO\" THEN\n      SAY \"ADDRESS TSO\" PGMNAME BATCH_VARS\n    IF TRAP_FLAG = \"YES\" THEN DO\n      IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n      INT.0 = INT.0 + 1\n      HOLDTEMP = INT.0\n      INT.HOLDTEMP = \"ADDRESS TSO\" PGMNAME BATCH_VARS\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"****CONTROL IS BEING ROUTED TO DYNAMIC COMMAND\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      INT.0 = HOLDTEMP\n    END\n    ADDRESS \"TSO\" PGMNAME BATCH_VARS\n    IF (TRAPOPT = \"LOG\") & (LOG_CHECK = \"OK\")  THEN DO\n      time1 = time()\n      ADDRESS tso  \"%rxappend \"logdsn today time1 pgmname batch_vars\n      LOG. = \"\"\n      LOG.0 = 0\n    end\n    IF (TRAPOPT = \"LOGALL\") & (LOG_CHECK = \"OK\")  THEN DO\n      ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") SHR REUS\"\n      ADDRESS MVS \"EXECIO \"INT.0\" DISKW OUT1 ( FINIS STEM INT.)\"\n      ADDRESS TSO \"FREE DDN(OUT1)\"\n      ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") MOD\"\n      writenum = trapnum\n      do tcnt = 1 to trapnum\n        if on.tcnt = \"ON.\"TCNT then writenum = tcnt\n        if on.tcnt = \"ON.\"TCNT then leave\n      end\n      ADDRESS MVS \"EXECIO \"writenuM\" DISKW OUT1 ( FINIS STEM ON.)\"\n      ADDRESS TSO \"FREE DDN(OUT1)\"\n      ADDRESS tso  \"%rxappend \" logdsn \"DSN=\"DS3\n      LOG. = \"\"\n      LOG.0 = 0\n    end\n    /******************************/\n    /** FUTURE CMD STACKING ENDDO**/\n    /** GOES HERE.               **/\n    /******************************/\n    IF TRAP_FLAG = \"YES\" THEN\n      SS = OUTTRAP(ON.,TRAPNUM)\n    ELSE\n      SS = OUTTRAP(OFF)\n    ZPF07 = \"UP\"\n    ZPF19 = \"UP\"\n    ZPF08 = \"DOWN\"\n    ZPF20 = \"DOWN\"\n    ADDRESS ISPEXEC \"VPUT ZPF07  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF19  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF08  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF20  PROFILE\"\n    IF MSGOPT = 0 THEN SIGNAL NOMSG\n    IF MSGOPT = \"DATA\" THEN DO\n      ADDRESS ISPEXEC \"VGET DATAAREA PROFILE\"\n      ACID = DATAAREA\n      if panel_env = \"BASIC\" then do\n        INT.0 = INT.0 + 1\n        HOLDTEMP = INT.0\n        INT.HOLDTEMP = \"TSA520D: Overlaying \" OPT \"SECRC=\" secrc\n        secrc = \"TSA519W:\" dataarea\n        ADDRESS ISPEXEC \"VPUt SECRC PROFILE\"\n      END\n    END\n    SIGNAL GETMSG\n  END\n  /************************************************/\n  /**--------DYNAMIC COMMAND AREA ENDS ----------**/\n  /**  OW LETS PROCESS THE USERS CMDLIST DSN     **/\n  /**--------DYNAMIC COMMAND AREA ENDS ----------**/\n  /************************************************/\n/***********************************************************/\n/* HERE WE START THE NORMAL OPTIONS AREA....DIR 19 OCT 92  */\n/***********************************************************/\n  IF (OPT = \"STATUS\") | (OPT = \"STAT\") THEN  DO\n    PANEL= \"SPISTAT\"\n    ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n    MSG= \"VARIABLE ENTRIES DISPLAYED\" OPT\n    FUNCT = \"STATUS\"\n    IF  PANEL = \"SPISTAT\" THEN\n      OPT= \"STATUS\" /* HE MAY HAVE CHANGED PANEL */\n    SIGNAL REDO\n  END\n  IF  OPT = \"VARSET\" THEN  DO\n    IF AUTHNUM < 10 THEN DO\n      SECRC =  \"VARSET REQUIRES AUTHNUM OF 10, YOUR AUTHNUM IS\" AUTHNUM\n      SIGNAL GOTMSG\n    END\n    IF LENGTH(ACID) > 8 THEN DO\n      SECRC = \"VARIABLE NAME IS TOO LONG, VARSET ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    INTERPRET ACID \"=\" DATA\n    IF TRAP_FLAG = \"NO\" THEN SAY \"ISSUING THIS COMMAND :\",\n      \"ADDRESS ISPEXEC VPUT \" ACID \"PROFILE\"\n    IF TRAP_FLAG = \"YES\" THEN DO\n      INT.1 =  \"ISSUING:ADDRESS ISPEXEC VPUT \" ACID \"PROFILE\"\n    END\n    ADDRESS ISPEXEC \"VPUT \" ACID \"PROFILE\"\n    SECRC = \"VARIABLE\" ACID\" TEMPORARILY RESET IN CURRENT PROFILE.\"\n    SIGNAL GOTMSG\n  END\n  IF  OPT = \"VARRESET\" THEN  DO\n    IF AUTHNUM < 10 THEN DO\n      SECRC =  \"VARSET REQUIRES AUTHNUM OF 10, YOUR AUTHNUM IS\" AUTHNUM\n      SIGNAL GOTMSG\n    END\n    IF LENGTH(ACID) > 8 THEN DO\n      SECRC = \"VARIABLE NAME IS TOO LONG, VARRESET ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    if PANEL_ENV = \"BASIC\"  then do\n      address tso \"%popexp\"\n      call disppop\n      acid = v1 ;data = v2; data2 = v3\n    end\n    IF ACID = \"\" THEN DO\n      SECRC = \" Variable NOT SPECIFIED. VARRESET ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    IF TRAP_FLAG = \"NO\" THEN SAY \"ISSUING THIS COMMAND :\",\n      \"ADDRESS ISPEXEC Verase \" ACID \"PROFILE\"\n    IF TRAP_FLAG = \"YES\" THEN DO\n      INT.1 =  \"ISSUING:ADDRESS ISPEXEC Verase\" ACID \"PROFILE\"\n    END\n    ADDRESS ISPEXEC \"Verase \" ACID \"PROFILE\"\n    secrc = \"variable\" acid\" erased from current profile.\"\n    SIGNAL GOTMSG\n  END\n  IF  OPT = \"SHOWVAR\" THEN  DO\n    IF LENGTH(ACID) > 8 THEN DO\n      secrc = \"variable name is too long, function aborted.\"\n      SIGNAL GOTMSG\n    END\n    if PANEL_ENV = \"BASIC\"  then do\n      address tso \"%popexp\"\n      call disppop\n      acid = v1 ;data = v2; data2 = v3\n    end\n    hold = acid\n    IF TRAP_FLAG = \"YES\" THEN DO\n      INT.1 =  \"ISSUING:ADDRESS ISPEXEC VGET \" ACID \"PROFILE\"\n    END\n    ADDRESS ISPEXEC \"VGET \" ACID \"PROFILE\"\n    SECRC = \"Variable\" ACID\" =\" value(acid)\n    SIGNAL gotmsg\n  END\n  IF SUBSTR(OPT,1,1) = \".\" THEN  DO\n    INDEX = SUBSTR(OPT,2)\n    ADDRESS ISPEXEC \"TBTOP \"SCRTABLE\n    ADDRESS ISPEXEC \"TBVCLEAR \"SCRTABLE\n    INDEX1 = SUBSTR(INDEX,1,1)\n    INDEX2 = SUBSTR(INDEX,2)\n    UPPER INDEX1\n    FNAME = INDEX1||INDEX2\n    ADDRESS ISPEXEC \"VPUT FNAME\"\n    CALL OFF ERROR\n    ADDRESS ISPEXEC \"TBSCAN \"SCRTABLE\" ARGLIST(FNAME) CONDLIST(GE)\"\n    RCODE1 = RC\n    SCAN = \"YES\"\n    Y = 0\n    OPT     = \" \"\n    IF RCODE1 = 8 THEN DO\n      secrc = \"Entry not found, or blanks exist in screen table\"\n      SAY \"*********************************************************\"\n      SAY \"SCREEN TABLE SCAN FAILED CHECK THAT SCREEN TABLE DOES NOT\"\n      SAY \"HAVE LEADING BLANKS.                                     \"\n      SAY \"*********************************************************\"\n      signal gotmsg\n    END\n    CALL ON ERROR NAME SHUCKS\n    SIGNAL DISPPNL\n  END\n  IF  AUTHNUM < 4 THEN SIGNAL HUH\n /******************************************************************/\n /*  THE FOLLOWING FUNCTIONS ARE NOT GENERALLY NEEDED EXCEPT FOR   */\n /*  THE MOST POWERFUL ADMINISTRATORS. THIS IS WHY I CHECK AUTHNUM */\n /*  THIS ALLOWS THE FOLLOWING FUNCTIONS TO BE  EXECUTED FROM      */\n /*  THE TEST MENU........DAVE 20 MAY 91                           */\n /******************************************************************/\n  IF OPT = \"CLEARMSG\"  THEN  DO\n    CLEARMSG = \"YES\"\n    ADDRESS ISPEXEC \"VPUT CLEARMSG PROFILE\"\n    MSG2 = \" \"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    secrc  = \" Message areas cleared, message options reset \"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"SUB\") &  (MODE = \"BATCH\") THEN  DO\n    BJCL.1 =  \"@@\"\n    ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n    ADDRESS TSO \"FREE DDN(BJCL)\"\n    BOPEN= NO\n    ADDRESS TSO \"SUBMIT \" DS5\n    msg2= \"Note: You are in online mode, cmds are issued real time.\"\n    CLEARMSG= \"YES\"\n    MODE= \"ONLINE\"\n    SECRC= \"TSA044I: Mode change complete.\"\n    secrc= secrc \"batch stream submitted from \"ds5\".\"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"SUB\") & (MODE = \"ONLINE\") THEN  DO\n    SECRC= \"THE SUB OPTION IS VALID ONLY IN BATCH MODE.\"\n    SECRC=  SECRC\" OPTION IGNORED\"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"BATCH\") & (MODE < > \"BATCH\") THEN  DO\n    ADDRESS TSO \"%\"TVER\"JCARD\" DS5 \"RANDOM\"\n    IF  RC = 16 THEN  DO\n      SECRC=\"TSA041E: Mode change failed during jobcard build.\"\n      SIGNAL GOTMSG\n    END\n    ADDRESS TSO \" ALLOC DDN(BJCL) DSN(\" DS5\") MOD REUS\"\n    BOPEN = YES\n    msg2= \"Note: You are in batch mode, most cmds are deferred \"\n    MSG2=   MSG2 \"UNTIL MODE IS CHANGED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    CLEARMSG= \"NO\"\n    ADDRESS ISPEXEC \"VPUT clearmsg PROFILE\"\n    MODE = \"BATCH\"\n    secrc= \"TSA042I: mode change complete. jcl will be in \"ds5\".\"\n    SIGNAL GOTMSG\n  END\n  IF  (OPT = \"ONLINE\") & (MODE < > \"ONLINE\") THEN  DO\n    BJCL.1 = \"@@\"\n    ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n    ADDRESS TSO \" FREE DDN(BJCL)\"\n    BOPEN= NO\n    msg2= \"Note: You are in online mode cmds are issued real time.\"\n    CLEARMSG= \"YES\"\n    MODE= \"ONLINE\"\n    SECRC= \"TSA043I: Mode change complete.\"\n    secrc= secrc \"JCL not submitted, is in \"ds5\".\"\n    SIGNAL GOTMSG\n  END\n  IF  (OPT = \"ONLINE\") & (MODE = \"ONLINE\") THEN  DO\n    MSG2= \"NOTE: MODE IS UNCHANGED.\"\n    CLEARMSG= \"YES\"\n    MODE= \"ONLINE\"\n    secrc= \"TSA052I: Mode unchanged, remains online.\"\n    SIGNAL GOTMSG\n  END\n  IF  OPT = \"CMDO\" THEN  DO\n  /*OTT = OUTTRAP(ZZT,0)     TRAP EVERYTHING */\n    DATAAREA =  ACID\n    ARG =  DATAAREA\n   \" ISPEXEC VPUT ARG PROFILE\"\n   ADDRESS TSO \"%\"TVER\"CMDO\" DS1\n    FUNCT= \"CMDOUT\"\n    SIGNAL GETMSG\n  END\n  /***************************************************************/\n  /** THE FOLLOWING OPTIONS USE THE T..TSO ROUTINE FOR CHANGING **/\n  /** THE TOP SECRET TSO DEFINITIONS.  THE T44TSO ROUTINE       **/\n  /** REQUIRES THE FOLLOWING PARMS :  ACTION ACID LPROC ACCTNUM **/\n  /** UNIT SIZE DESPITE THE FACT ALL THESE MAY NOT BE USED FOR  **/\n  /** EACH FUNCTION I PASS THEM ALL EACH TIME AS THEY ARE       **/\n  /** POSITIONALLY DEPENDANT...DIR 2 JUNE 94                    **/\n  /***************************************************************/\n  /***************************************************************/\n  /** THE END OF THE T44TSO AREA                                **/\n  /***************************************************************/\n  IF  OPT = \"POPTEST\" THEN  DO\n    FUNCT =  \"POPTEST\"\n    TITLE  = \"TEST SCREEN TITLE       \"\n    TITLE1 = \"#BOOK TO BE DELETED       \"\n    VNAME1 = \"THIS IS THE BOOK SPOT     \"\n    CALL DISPPOP\n    SAY V1 V2 V3 V4 V5 V6\n  END\n  HUH: NOP\n  secrc= \"TSA006I: Invalid option, or security failure for option\" opt\n  SIGNAL GOTMSG\n  GETMSG: NOP\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET MSG2 PROFILE\"\n  SIGNAL GOTMSG\n  NOMSG: NOP\n  secrc= \"TSA030I: Function completed successfully.\"\n  IF RCODE >  0 THEN\n    secrc=  \"TSA031I: Function completed with a return code of\" rcode\n  IF RCODE =  8 THEN  DO\n    SECRC=  \"TSA045E: Invoked function returned a code of\" rcode\n  END\n  GOTMSG: IF (OPT < > \"L\") & (OPT < > \"IN\"),\n    & (MODE < > \"BATCH\") THEN OPT =   \" \"\n  MSG = SECRC\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\" /* IN CASE I SET A MSG */\n  SYSOUTTRAP= TRAPNUM\n  /******************************************************************/\n  /* NOMSG IS THE JUMP TO POINT (JTP) FOR FUNCTIONS THAT  DO NOT    */\n  /* RETURN A MESSAGE IN VAR SECRC. GETMSG IS FOR OTHERS THAT DO    */\n  /*   ......DAVE 9 APRIL 91                                        */\n  /* NOTE THAT YOU MUST SAVE THE RC IN VARIABLE RCODE FOR JTP       */\n  /* NOMSG....DAVE 9 APRIL 91                                       */\n  /******************************************************************/\n  REDO: RCODE=0 /*A JTP TO KEEP OPTION */\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\" /* IN CASE I SET A MSG */\n  if substr(strip(msg),1,3) /= \"TSA\" then\n    MSG =    FUNCT \":\" MSG\nSIGNAL DISPPNL\n/*******************************************************************/\n/** END OF SEQUENTIAL INSTRUCTIONS                                **/\n/*******************************************************************/\nDISPPOP: NOP\ncall off error\nADDRESS ISPEXEC \"ADDPOP POPLOC(OPT) \"\ncursor = \"v1\"\nredopop: NOP\nPNL_DISP = \"YES\"\naddress ispexec \"vput opt profile\"\naddress ispexec \"vget (title1 title2 title3 title4 title5 title6)\"\naddress ispexec \"vget (vname1 vname2 vname3 vname4 vname5 vname6)\"\nADDRESS ISPEXEC \"DISPLAY PANEL(SPIPOP) cursor(\"cursor\")\"\npop_rc = rc\ncall off error\nif pop_rc = 0 then do\n  /* say \"calling checkdat\"  */\n  call checkdat v1 v2 v3 v4 v5 v6\n  /* Say \"result is \" result */\n  if result = \"REDO\" then signal redopop\nend\ncall on error name shucks\nPNL_DISP = \"NO\"\nADDRESS ISPEXEC \"REMPOP\"\ncursor = \"OPT\"\nRETURN\nSHUCKS: PROCEDURE EXPOSE RC PNL_DISP PANEL MSG SIGL DEFPNL RCODE,\n  BOPEN OPT ACID DS1 DS2 DS3 DS4 DS5 DEF DS6 SECRC TRAP_FLAG,\n  TVER LEAVE CMDTABLE SCRTABLE LOG_CHECK panel_depth dp.,\n  command_stack panel_env scrload\n  RCODE = RC\n  IF TRAP_FLAG = \"NO\" THEN\n    say \"TSA101D:  error routine has been signaled by line\" sigl\n  IF RCODE = 0 THEN LEAVE = \"YES\"\n  RC = 0\n  \"ISPEXEC VPUT ACID PROFILE\"\n  ERRORL = SIGL\n  PANELRC = 0\n  /* SAY \"LINE # \" ERRORL \"CAUSED AN ERROR\" */\n  IF RCODE = 24 THEN EXIT 24 /* APPL PARM ERROR IN TSSINI */\n  IF RCODE = 8 THEN DO\n    IF PNL_DISP = \"YES\" THEN DO\n      IF PANEL = \"SPIMAIN\" THEN LEAVE = YES\n      IF PANEL = \"SPIUTIL\" THEN LEAVE = YES\n      IF PANEL = \"SPIUSER\" THEN LEAVE = YES\n      IF PANEL = DEFPNL THEN LEAVE = YES\n      if panel_depth > 0 then do\n        panel_depth = panel_depth - 1\n        panel = dp.panel_depth\n        address ispexec \"vput panel profile\"\n        do pcount = 1 to panel_depth\n          drop_loc = lastpos(\".\",command_stack)\n          drop_loc = drop_loc - 1\n          /* say \"drop loc = \" drop_loc */\n          if drop_loc < 0 then drop_loc = 1\n          command_stack = substr(command_stack,1,drop_loc)\n          /* say \"Shucks: command stack\" command_stack  */\n        end\n      end\n    END\n  END\n  /* PANEL = DEFPNL */\n  ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n  OPT = \"NIL\"\n  msg = \"TSA047E: Line \"sigl\" returned a return code of \" rcode\n  IF RCODE = -3 THEN DO\n    hz1 = sourceline(sigl)\n    secrc = \"TSA048E: Possible environmental error. check tver setting\"\n    \"ISPEXEC VPUT SECRC PROFILE\"\n  END\n  IF LEAVE = \"YES\" THEN DO\n    IF BOPEN = \"YES\" THEN DO\n      BJCL.1 =  \"@@\"\n      ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      ADDRESS TSO \"FREE DDN(BJCL)\"\n      BOPEN = \"NO\"\n    END\n    \"ISPEXEC VPUT TVER PROFILE \"\n    \"ISPEXEC VPUT DS1 PROFILE  \"\n    \"ISPEXEC VPUT DS2 PROFILE  \"\n    \"ISPEXEC VPUT DS3 PROFILE  \"\n    \"ISPEXEC VPUT DS4 PROFILE  \"\n    \"ISPEXEC VPUT DS6 PROFILE  \"\n    \"ISPEXEC VPUT DS5 PROFILE  \"\n    \"ISPEXEC VPUT DEF PROFILE  \"\n    SIGNAL OFF ERROR\n    \"ISPEXEC TBEND \"CMDTABLE\n    if scrload = \"YES\" then\n      \"ISPEXEC TBEND \"SCRTABLE\n     EXIT\n  END\n  RETURN\nNOTABLE: PROCEDURE EXPOSE RC SIGL CMDTABLE SCRTABLE TABLEOPT\n  ERRORL = SIGL\n  SAY \"LINE # \" ERRORL \"INVOKED ERROR RECOVERY\"\n  SAY \"*********************************************************\"\n  SAY \"** FATAL ERROR FATAL ERROR FATAL ERROR FATAL ERROR     **\"\n  SAY \"*********************************************************\"\n  SAY \"TSSUT: AN OPEN WAS ISSUED FOR ONE OR MORE TABLES THAT DO \"\n  SAY \"       NOT EXIST. OR ARE ALREADY OPEN !                  \"\n  SAY \"       USE THE TBMCMD OR TBMSCR TO CREATE TABLES:\"\n  SAY \"       \" CMDTABLE SCRTABLE\n  SAY \"*********************************************************\"\n  IF TABLEOPT= \"PERM\" THEN DO\n    TABLEOPT = \"TEMP\"\n    ADDRESS ISPEXEC \"VPUT TABLEOPT PROFILE\"\n    SAY \"*********************************************************\"\n    SAY \" I AM CHANGING TABLE OPTION TO TEMP, PLEASE REINVOKE     \"\n    SAY \" THE PANEL SYSTEM TO READ   TABLES FROM FLATFILE INPUT.  \"\n    SAY \" CONFIRM THAT YOU ARE CORRECTLY SET UP TO USE PERMANENT  \"\n    SAY \" TABLE INPUTS. THE TABLE NAMES ARE BELOW.                \"\n    SAY \"       \" CMDTABLE SCRTABLE\n    SAY \"*********************************************************\"\n  END\n  EXIT\n/*******************************************************************/\n/*******************************************************************/\n/*******************************************************************/\n/*******************************************************************/\ncheckdat: procedure expose msgopt datack data2ck auth trapopt batch,\n  msg cursor\narg the_data\nPARSE VAR the_data W.1 W.2 W.3 W.4 W.5 W.6 W.7\ncrit.1 = \"NUM\" ;result.1 =\"NUM\" ; desc.1 = \"numeric\"\ncrit.2 = \"OPTN\";result.2 =\"NUM\" ; desc.2 = \"numeric\"\ncrit.3 = \"CHAR\";result.3 =\"CHAR\"; desc.3 = \"character\"\ncrit.4 = \"OPTC\";result.4 =\"CHAR\"; desc.4 = \"character\"\necode = \"\"\ncursor = \"v1\"\naddress ispexec \"vget datareq profile\"\n/*  say \"checking data\" the_data */\n/* say \"             \" datareq   */\ndo dchk = 1 to 6\n  check_value  = w.dchk\n  requirement  = word(datareq,dchk)\n  if requirement = 0 then iterate\n  if requirement = \"\" then iterate\n  do cnt2 = 1 to 6\n    if requirement = crit.cnt2 then critnum = cnt2\n  end\n  len = length(check_value)\n  description  = desc.critnum\n  if (requirement = \"CHAR\") & ( len = 0) then requirement = \"failed\"\n  /* say \"checking\" check_value \"versus\" requirement dchk */\n  dacheck = datatype(check_value)\n  /* say \" check is \" dacheck  */\n  if requirement = \"ANY\" then requirement = dacheck\n  if requirement /= dacheck then do\n    MSG = \"TSA038E:\"\n    msg = msg \"A \"description\" value is required for this function\"\n    cursor = \"V\"dchk\n    ecode = \"REDO\"\n    return ecode\n  end\nend\nreturn\nNEWINI: PROCEDURE EXPOSE RC SIGL MSG2 CLEARMSG AUTOINIT NEEDINIT RCODE\n  RCODE = RC\n  RC = 0\n  ERRORL = SIGL\n  PANELRC = 0\n  hz1 = sourceline(sigl)\n  SAY \"LINE # \" ERRORL \"INVOKED ERROR RECOVERY\"\n  SAY HZ1\n  IF RCODE = 8 THEN DO\n    MSG2 = \"$$ WARNING: TSSINI VARIABLES NOT FOUND. LINE \" SIGL\n    MSG2 = MSG2 \"A 'REINIT' SHOULD BE ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    CLEARMSG = \"NO\"\n    IF AUTOINIT \u00ac= \"NO\" THEN DO\n      INI = \"NO\"\n      \"ISPEXEC VPUT INI PROFILE\"\n      NEEDINIT = \"YES\"  /* TELL MAIN ROUTINE TO REINIT */\n      MSG2 = \"$$ NOTE: VARIABLES NOT FOUND. TSSINI WAS REINVOKED\"\n      MSG2 = MSG2 \"TO REBUILD YOUR ENVIRONMENT\"\n      ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    END\n  END\n  OPT = \" \"\n  RETURN\nLOG:\n  ARG message parm funct\n  upper funct parm\n  if funct = \"\" then funct = \"APPEND\"\n  Select\n    when funct = \"INIT\" then do\n      /* log(debug,100,init) */\n      log.message.0max = parm\n      if datatype(parm) /= \"NUM\" then return 4\n    end\n    when funct = \"APPEND\" then do\n      /* log(my log message,debug,append) */\n      if datatype(log.parm.0) /= \"NUM\" then log.parm.0 = 0\n      /* above inits a new log var */\n      hold = log.parm.0 + 1\n      if hold > log.parm.0max then log.parm.0wrap = \"YES\"\n      if hold > log.parm.0max then hold = 1\n      /* if we are at max then start at #1 again */\n      log.parm.hold = parm\n      log.parm.0 = hold        /* update the tracker subscript */\n    end\n    when funct = \"DUMP\" then do\n      /* log(ddname,debug,dump) */\n      ddname = message\n      lines = log.parm.0\n      stem = \"log.\"parm\".\"\n      savemax = log.parm.0max\n      if log.parm.0wrap = \"YES\" then lines = log.parm.0max\n      if datatype(log.parm.0) /= \"NUM\" then log.parm.0 = 0\n      /* above inits a new log var */\n      ADDRESS MVS \"EXECIO \"lines\" DISKW \"ddname\" ( FINIS STEM \"stem\")\"\n      log.parm. = \"\"\n      log.parm.0max = savemax\n      log.parm.0 = 0            /* reset my array */\n    end\n    otherwise \"DISPLAY PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n   End\nPTR:\n  ARG VALUE\n  RETURN X2C(C2X(STORAGE(D2X(VALUE),4)))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSUTO": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00C\\x00\\x99\\x14\\x1f\\x01\\x00\\x07_\\x10S\\x04X\\x04X\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-05-21T00:00:00", "modifydate": "2000-03-15T10:53:43", "lines": 1112, "newlines": 1112, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ADDED WRITEDEBUG SUPPORT FOR DYNAM COMMANDS          **/\n/**********************************************************/\n/** ADDED TEMP/PERM PARM TO TABLE DEFINITION ROUTINE     **/\n/**********************************************************/\n/** ADDED POPUP MENU OPTIONS TO THE SYSTEM               **/\n/**********************************************************/\n/** REWRITE TO USE ISPF TABLES FOR SCREEN AND CMDS       **/\n/**********************************************************/\n/** THE MAIN DRIVER ROUTINE OF THE ENTIRE LOCAL PANEL    **/\n/** SYSTEM. IT IS QUITE IN DEPTH SO I AINT GONNA SPLAIN  **/\n/** IT.    DAVE 9 MAY 95                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : TSSUT                             **/\n/** LAST MODIFIED    : 16 MAR  98                        **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ANY VARIABLES CREATED IN TSSINI OR ISPF ARE AVAILABLE**/\n/** TO ME HERE. ALTHOUGH THIS EXEC EXPECTS NO ARGS PER SE**/\n/** ISPF VGETS - A TON OF THEM                           **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE.                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : A TON OF THEM        **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\narg sample\nif sample = \"SAMPLE\" then do\n  sample = \"YES\"\n  address ispexec \"VPUT SAMPLE PROFILE\"\nend\nPARSE VERSION V .\nIF LEFT(V,5) = \"REXXC\" THEN COMPILED = \"YES\"\nBEGIN_CPU = SYSVAR(SYSCPU)\nADDRESS ISPEXEC \"VGET ZSYSID\"\nSYSID = ZSYSID\nSPI_VERSION = 09APR1999\nADDRESS ISPEXEC\nPR = PROMPT(\"OFF\")\nTVERMSG = \"WARNING: YOU HAVE OVERRIDDEN ENVIRONMENTAL PARMS.\"\nSYSUID = SYSVAR(SYSUID)\nMSG2 = \" \"\nDATA = \" \"\nDATA2 = \" \"\nROW =\nINT.0 = 0\nBOOK= \" \"\nCLEARMSG = \"YES\"\nRELOAD = \"BOTH\"\nREINIT: NOP\nADDRESS TSO \"%TSSVERS\" /* FIND OUT WHAT TOP SECRET VERSION IS RUNNIN*/\nADDRESS TSO \"%TSSINI\" SYSUID /* SET MY VARIABLES FOR ME */\nIF RC = 24 THEN  EXIT 00     /* TSSINI DIED ! */\nCALL ON ERROR NAME NEWINI\n\" ISPEXEC VGET ACID            PROFILE \"\n\" ISPEXEC VGET AUTHNUM         PROFILE \"\n\" ISPEXEC VGET AUTHCODE        PROFILE \"\n\" ISPEXEC VGET AUTOINIT        PROFILE \"\n\" ISPEXEC VGET CHKDSN          PROFILE \"\n\" ISPEXEC VGET CMDPRE          PROFILE \"\n\" ISPEXEC VGET CMDTABLE        PROFILE \"\n\" ISPEXEC VGET DDS1            PROFILE \"\n\" ISPEXEC VGET DDS2            PROFILE \"\n\" ISPEXEC VGET DDS3            PROFILE \"\n\" ISPEXEC VGET DDS4            PROFILE \"\n\" ISPEXEC VGET DDS5            PROFILE \"\n\" ISPEXEC VGET DDS6            PROFILE \"\n\" ISPEXEC VGET DEF             PROFILE \"\n\" ISPEXEC VGET DSBACK          PROFILE \"\n\" ISPEXEC VGET DS1             PROFILE \"\n\" ISPEXEC VGET DS2             PROFILE \"\n\" ISPEXEC VGET DS3             PROFILE \"\n\" ISPEXEC VGET DS4             PROFILE \"\n\" ISPEXEC VGET DS5             PROFILE \"\n\" ISPEXEC VGET DS6             PROFILE \"\n\" ISPEXEC VGET JESNODE         PROFILE \"\n\" ISPEXEC VGET MSG2            PROFILE \"\n\" ISPEXEC VGET NEWPASS         PROFILE \"\n\" ISPEXEC VGET PANEL           PROFILE \"\n\" ISPEXEC VGET SCRPRE          PROFILE \"\n\" ISPEXEC VGET SCRTABLE        PROFILE \"\n\" ISPEXEC VGET SECRC           PROFILE \"\n\" ISPEXEC VGET SRCCMD          PROFILE \"\n\" ISPEXEC VGET SRCSCR          PROFILE \"\n\" ISPEXEC VGET SYSTEM          PROFILE \"\n\" ISPEXEC VGET TABLEDSN        PROFILE \"\n\" ISPEXEC VGET TABLEOPT        PROFILE \"\n\" ISPEXEC VGET TRAPNUM         PROFILE \"\n\" ISPEXEC VGET TSSVERS         PROFILE \"\n\" ISPEXEC VGET TVER            PROFILE \"\n\" ISPEXEC VGET ZAPPLID                 \"\n\" ISPEXEC VGET ZSCREEND                \"\n\" ISPEXEC VPUT SECRC           PROFILE \"\n\" ISPEXEC VPUT CLEARMSG        PROFILE \"\n  MSG= \"GENERAL :\"    SECRC\n    SECRC = \" \"\n    /*******************************************************/\n    /* A $$ INDICATES THE MSG WAS SET BY TSSINI SO KEEP IT */\n    /*******************************************************/\n/***********************************************************/\n/** AUTHORIZATION CHECKING.... NEVER CHANGE THIS CODE  *****/\n/***********************************************************/\ncodes = words(authcode)\nif codes > 20 then do\n  say \"Too many authorization codes provided. aborting \"\nend\nparse var authcode w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8 w.9 w.10 w.11 w.12,\n          w.13 w.14 w.15 w.16 w.17 w.18 w.19 w.20\ni_digits = digits()\ngooddate = \"invalid\"\nnumeric digits 60\n/******************************/\npsa = ptr(520)\npsa = c2d(psa)  /* we got back a character value from function */\npsa = psa + 6   /* it just got changed to a decimal value */\npsa = d2x(psa)  /* we change it back to a hex value */\ncpu = storage(psa,6) /* give the storage function the address in hex */\ncpu = substr(cpu,3)\nanycpu = 99999\n/******************************/\ntoday = date(s)\ndo x = 1 to codes\n  authcode = w.x\n  tempdate = ((1000000000000 - authcode) + (cpu * cpu)) / cpu\n  datechek = format(tempdate,60,0)\n  t_date = ((1000000000000 - authcode) + (anycpu * anycpu)) / anycpu\n  trial_check = format(t_date,60,0)\n  if t_date = trial_check then do\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"Trial code found for processor:\" authcode\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"You are authorized to run the product until\" t_date\n    trial = \"yes\"\n    gooddate = t_date\n  end\n  if trial = \"yes\" then leave\n  if tempdate /= datechek then do\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"skipping code, not for this processor:\" authcode\n  end\n  if tempdate /= datechek then iterate x\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"You are authorized to run the product until\" tempdate\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"With authcode :\" authcode\n  gooddate = tempdate\nend\nif gooddate = \"invalid\" then do\n    say \"***********************************************\"\n    say \"**No valid auth codes found for processor\" cpu\n    say \"***********************************************\"\n    exit 16\nend\n/* finalcode = 1000000000000 - ((cpu * gooddate) - (cpu * cpu))  */\ntimeleft = gooddate - today\nif timeleft < 200 then do\n  say \"************************\"\n  say \" Your current code is soon to expire.\"\n  MSG2 = \"$$ Authorization is soon to expire, on \"gooddate\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  say \"************************\"\nend\nif today > gooddate then do\n  say \"************************\"\n  say \"expired product         \"\n  say \"************************\"\n  exit 16\nend\nnumeric digits i_digits\n/* */\nIF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\nINT.0 = INT.0 + 1\nHOLDTEMP = INT.0\nIf compiled = \"YES\" then\n  INT.HOLDTEMP = \"Compiled version running, \" spi_version\n/***********************************************************/\n/** AUTHORIZATION CHECKING END NEVER CHANGE THIS CODE  *****/\n/***********************************************************/\nIF WORD(MSG2,1) \\= \"$$\" THEN DO\n  MSG2 = \" \"\n  \" ISPEXEC VPUT MSG2 PROFILE \"\nEND\nIF NEEDINIT = \"YES\" THEN DO\n  NEEDINIT = \"NO\"\n  IF REINIT1 = \"YES\" THEN DO    /* DEEP TROUBLE ENDLESSLOOP */\n    MSG2 = \"TSSUT/TSSINI SYNC ERROR. FATAL ERROR.\" SIGL\n    CLEARMSG = \"NO\"\n  END\n  ELSE DO\n    REINIT1 = \"YES\" /* INDICATE WE HAVE CALLED TSSINI FROM HERE*/\n    SAY \"SIGNALLING REINIT\"\n    OTT = OUTTRAP(\"OFF\")  /* NOTHING */\n    SIGNAL REINIT\n  END\nEND\nTABLES: NOP\nIF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\nIF TABLEOPT = \"TEMP\" THEN DO\n  /* SAY \"BUILDING TEMPORARY TABLES FOR THIS SESSION \" */\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"TABLE LOAD COMMENCING. RELOAD PARM IS \" RELOAD\n  OTT = OUTTRAP(ON.,100)  /* TRAPALL */\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"SCREEN\") THEN\n  ADDRESS TSO \"%TBMSCR\" SRCSCR \".\" SCRTABLE AUTHNUM \"NO\"\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"COMMAND\") THEN\n  ADDRESS TSO \"%TBMCMD\" SRCCMD \".\" CMDTABLE AUTHNUM \"NO\"\n  /*****************************************************/\n  /**THE ABOVE ROUTINES BUILD TABLES AND LEAVE THEM   **/\n  /** OPEN FOR USE BY THIS EXEC                       **/\n  /*****************************************************/\n  RELOAD = \"BOTH\"\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"TABLE LOAD COMPLETE.\"\n  OTT = OUTTRAP(\"OFF\")  /* NOTHING */\nEND\nIF TABLEOPT /= \"TEMP\" THEN DO\n  OTT = OUTTRAP(ON.,100)  /* TRAPALL */\n  /*****************************************************/\n  /**THE ABOVE OPTION INDICATES WE ARE USING PERMANENT**/\n  /** TABLES THAT ARE PREDEFINED SO LETS OPEN THEM    **/\n  /*****************************************************/\n  CALL OFF ERROR\n  SIGNAL OFF ERROR\n  CALL ON ERROR NAME NOTABLE\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"COMMAND\") THEN\n  ADDRESS ISPEXEC \"TBOPEN\" CMDTABLE \"NOWRITE\"\n  /*IF STABLE_RC = 12 THEN */\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"SCREEN\") THEN\n  ADDRESS ISPEXEC \"TBOPEN\" SCRTABLE \"NOWRITE\"\n  TRACE OFF\nEND\nCALL ON ERROR NAME SHUCKS\n/*PANEL  = \"SPIUTIL\"                     */\n/*ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"   */\nIF PANEL /= \"SPIUTIL\" THEN DO\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"**Table display is disabled do to custom panel.\"\nEND\nDEFPNL = PANEL\nOLDTVER =  TVER\nSCRNUM = ZSCREEND - 10\nWDS. = \" \"\nUNIT =  TSOUNIT\n/******************************************************************/\n/*  NOW I HAVE RETRIEVED ALL VARIABLES   BY TSSINI    DIR 9 SEP 92*/\n/*  I WILL NOW CHECK FOR DSN VALIDITY....DIR  14 SEP 92           */\n/******************************************************************/\nDDS.1 = DDS1\nDDS.2 = DDS2\nDDS.3 = DDS3\nDDS.4 = DDS4\nDDS.5 = DDS5\nDDS.6 = DDS6\nIF CHKDSN < > \"YES\" THEN SIGNAL DSNDONE\nDO TT = 1 TO 6\n  XX = \"DS\"TT\n  DSNTEMP = VALUE(XX)\n  DSNMSG = SYSDSN(DSNTEMP)\n  /* SAY \"DSNMSG \" DSNMSG \"DSN= \" DSNTEMP */\n  IF DSNMSG = \"OK\" THEN ITERATE TT\n  MSG2 = \"WORK DSN(S) UNAVAILABLE. SOME ADVANCED FUNCTIONS MAY FAIL\"\n  /* SAY MSG2  */\n  WDS.TT = \"*\"\n  DDS.TT = DSNMSG\n  IF DSNMSG = \"DATASET NOT FOUND\" THEN DO\n    MSG2 = \"WORK DNS(S) INVALID. SOME ADVANCED FUNCTIONS MAY FAIL\"\n     WDS.TT = \"**\"\n  END\n  IF WORD(MSG2,1) \\= \"$$\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nDDS1 = DDS.1\nDDS2 = DDS.2\nDDS3 = DDS.3\nDDS4 = DDS.4\nDDS5 = DDS.5\nDDS6 = DDS.6\nWDS1 = WDS.1\nWDS2 = WDS.2\nWDS3 = WDS.3\nWDS4 = WDS.4\nWDS5 = WDS.5\nWDS6 = WDS.6\nDSNDONE: NOP\nBOPEN = NO\nCURSOR = \"OPT\"\nSPACES = \"                \"\nCMDNUM = 0\nRCODE = 0\nMENUNUM = 0\nSCRARRAY.0 = 0\nMODE = \"ONLINE\"\nIF  PANEL = \"  \" THEN  DO\n  MSG2 =  \"WARNING! TSSINI HAS FAILED. VARIABLES MAY BE\"\n  MSG2 =    MSG2 \"CORRUPTED.\"\n  PANEL = SPIUTIL\n  CLEARMSG = NO\nEND\nCALL OFF ERROR\nSIGNAL OFF ERROR\nCALL ON ERROR NAME SHUCKS\nANUM = 1\n/* SAY SCRARRAY.0 AUTHNUM */\nDO Q = 1 TO ANUM\n  SCRARRAY.Q = OUTA.Q\nEND\nMSG1. = ; MSG2. = ; MSG3. = ; MSG4. = ; MSG5. = ; MSG6.= ; MSG7. = ;\nTEMPARRAY.0 = 0\nTHISREC = 1\nY = 0\nX = 0\nOTT = OUTTRAP(ON.,TRAPNUM) /* TRAP EVERYTHING */\nSOURCE = PREDEF\n/******************************************************************/\n/*  THIS IS THE LASTOF THE INIT AREA. WHAT FOLLOWS IS THE LOOP.   */\n/******************************************************************/\nTRAP_FLAG = \"YES\"\nDISPPNL: NOP\n  RCODE = 0 /*  RESET THE LAST ERROR RETURN CODE */\n  IF WORD(HOLDLINE,1) = WORD(ACID,1) THEN ACID = HOLDLINE\n  IF OPT = \"NIL\" THEN OPT = \" \"\n  CPUUSED = SYSVAR(SYSCPU) - BEGIN_CPU\n  ADDRESS ISPEXEC  \"VGET MSG2 PROFILE\"\n  ADDRESS ISPEXEC  \"VGET PANEL PROFILE\"\n  ADDRESS ISPEXEC  \"VGET CLEARMSG PROFILE\"\n  ADDRESS ISPEXEC  \"VPUT CPUUSED  PROFILE\"\n  AUTH = AUTHNUM\n  /* \"TBSARG TS5USC10 NAMECOND(AUTH,LE)\" */\n  IF PANEL = \"SPISTAT\" THEN SCAN = \"YES\"\n  IF (FNAME /= \"FNAME\") & (SCAN = \"NO\") THEN DO\n    OTT = OUTTRAP(ON.,TRAPNUM) /* TRAP EVERYTHING */\n    ADDRESS ISPEXEC \"TBSARG \"SCRTABLE\" ARGLIST(FNAME)\"\n    CALL OFF ERROR\n    \"TBGET\" SCRTABLE\n    ADDRESS ISPEXEC \"TBSKIP \"SCRTABLE\" NUMBER(-\"scrnum\")\"\n    CALL ON ERROR NAME SHUCKS\n    /*********************************************/\n    /** EACH LINE PUT ON THE SCREEN UPDATES THE **/\n    /** VARIABLES SO EACH TIME WE DONT SCAN WE  **/\n    /** SET THE TOP OF SCREEN VALUE TO BOTTOM   **/\n    /** - 14                  DAVE              **/\n    /*********************************************/\n  END\n  SCAN = \"NO\"\n  PNL_DISP = \"YES\"\n  IF PANEL = \"SPIUTIL\" THEN\n  \"TBDISPL \"SCRTABLE\" PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n  ELSE \"DISPLAY PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n  PNL_DISP = \"NO\"\n  SOURCE = \"PREDEF\"\n  IF OPT = \"TRACEOFF\" THEN TRACE OFF\n  ACID_WORDNUM = WORDS(ACID)\n  DATA_WORDNUM = WORDS(DATA)\n  DATA2_WORDNUM = WORDS(DATA2)\n  HOLDLINE = ACID\n  \"ISPEXEC VPUT ACID PROFILE\"\n  \"ISPEXEC VPUT DATA PROFILE\"\n  \"ISPEXEC VPUT DATA2 PROFILE\"\n  IF CLEARMSG = \"YES\"  THEN DO\n    MSG2 =  \" \"\n    CLEARMSG = \"YES\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \"VPUT CLEARMSG PROFILE\"\n  END\n  MSG =   \" \"\n  SECRC=  \" \"\n  UPPER DATA\n  UPPER DATA2\n  UPPER ACID\n  FUNCT= \"GENERAL\"\n  CURSOR= \"OPT\"\n  HOLD = ACID\"     \"\n  FIRST4 = SUBSTR(HOLD,1,4)\n/***********************************************************/\n/* HERE WE START THE SPECIAL ENVIRONMENT AFFECTING         */\n/* OPTIONS....................DIR 19 OCT 92                */\n/***********************************************************/\n  IF OPT = \"SCREENLOAD\" THEN DO\n    IF (SYSDSN(\"'\"ACID\"'\")/= \"OK\") & (SYSDSN(ACID)/= \"OK\") THEN DO\n      SECRC = \"LOAD DATASET NOT USABLE, LOAD ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    IF TABLEOPT /= \"TEMP\" THEN DO\n      SECRC = \"TABLE FORMAT IS NOT DYNAMIC, SCREENLOAD NOT VALID.\"\n      SIGNAL GOTMSG\n    END\n    RELOAD = \"SCREEN\"\n    \"ISPEXEC TBEND \"SCRTABLE\n    SRCSCR = ACID\n    SIGNAL TABLES\n  END\n  IF OPT = \"COMMANDLOAD\" THEN DO\n    IF (SYSDSN(\"'\"ACID\"'\")/= \"OK\") THEN DO\n      SECRC = \"LOAD DATASET NOT USABLE, LOAD ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    IF TABLEOPT /= \"TEMP\" THEN DO\n      SECRC = \"TABLE FORMAT IS NOT DYNAMIC, COMMANDLOAD NOT VALID.\"\n      SIGNAL GOTMSG\n    END\n    RELOAD = \"COMMAND\"\n    \"ISPEXEC TBEND \"CMDTABLE\n    SRCCMD = ACID\n    SIGNAL TABLES\n  END\n  IF OPT = \"WRITEDEBUG\" THEN DO\n    TRAP_FLAG = \"YES\"\n    OPT = \"NIL\"\n    ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") SHR REUS\"\n    ADDRESS MVS \"EXECIO \"INT.0\" DISKW OUT1 ( FINIS STEM INT.)\"\n    ADDRESS TSO \"FREE DDN(OUT1)\"\n    ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") MOD\"\n    ADDRESS MVS \"EXECIO \"TRAPNUM\" DISKW OUT1 ( FINIS STEM ON.)\"\n    ADDRESS TSO \"FREE DDN(OUT1)\"\n    DO QW1 = 1 TO TRAPNUM; ON.QW1 = \" \"; END\n    SECRC = TRAPNUM \"LINES OF DEBUG FILE INFO WRITTEN TO \"DS3\n    address tso \"%rxbrowse \"ds3\n    SIGNAL GOTMSG\n  END\n  IF OPT = \"TRAPOFF\" THEN DO\n    OTT = OUTTRAP(\"OFF\")  /* NOTHING */\n    TRAP_FLAG = \"NO\"\n    OPT = \"NIL\"\n    SECRC = \"ALL INTERNAL OUTPUT WILL NOW BE SHOWN.\"\n    SIGNAL GOTMSG\n  END\n  IF OPT = \"TRAPON\" THEN TRAP_FLAG = \"YES\"\n  IF OPT = \"TRAPON\" THEN DO\n    TRAP_FLAG = \"YES\"\n    SECRC = \"I AM NOW TRAPPING SUBTASK CREATED MESSAGES.\"\n    SIGNAL GOTMSG\n  END\n  IF TRAP_FLAG = \"YES\" THEN DO\n     SS = OUTTRAP(ON.,TRAPNUM)\n  END\n  IF TRAP_FLAG = \"NO\" THEN DO\n     SS = OUTTRAP(OFF)\n  END\n  IF (OPT = \"NIL\") | (OPT = \" \" )  THEN DO\n    OPT = \" \"\n    SIGNAL DISPPNL\n  END\n  IF OPT = \"TRAPON\" THEN TRAP_FLAG = \"YES\"\n  IF OPT = \"TRAPOFF\" THEN TRAP_FLAG = \"NO\"\n  IF OPT = \"TRACE\" THEN TRACE R\n  IF OPT = \"TRACE\" THEN SIGNAL REDO\n  IF OPT = \"TRACEOFF\" THEN SIGNAL REDO\n  IF OPT = \"LEAVE\" THEN CALL SHUCKS\n  IF OPT = \"END\" THEN EXIT\n  IF OPT = \"X\" THEN CALL SHUCKS\n  IF OPT = \"QUIT\" THEN CALL SHUCKS\n  IF  TVER \u00ac= OLDTVER THEN  DO\n    MSG2 = TVERMSG\n    CLEARMSG = \"NO\"\n  END\n  IF OPT = \"REXXCMD\" THEN DO\n   IF INDEX(ACID,\"SOURCELINE\") = 0 THEN INTERPRET ACID\n   MSG = \"REXX INPUT INTERPRETED SUCCESSFULLY.\"\n   IF INDEX(ACID,\"SOURCELINE\") /= 0 THEN\n     MSG = \"INPUT IGNORED.\"\n   OPT = \" \"\n   SIGNAL REDO\n  END\n  IF (OPT \u00ac= \"CMDO\") &  (OPT \u00ac= \"CMDS\") THEN ACID = WORD(ACID,1)\n  IF  (OPT = \"STATUS\") | (PANEL= \"SPISTAT\") THEN  DO\n    IF (TVER =  OLDTVER) &  (MSG2 =  TVERMSG) THEN  DO\n      MSG2 =  \"ENVIRONMENT RESTORED TO TSSINI DEFAULT\"\n      MSG2 = MSG2 \"VALUES.\"\n      CLEARMSG = YES\n    END\n    \"ISPEXEC VPUT TVER PROFILE \"\n    \"ISPEXEC VPUT DS1 PROFILE  \"\n    \"ISPEXEC VPUT DS2 PROFILE  \"\n    \"ISPEXEC VPUT DS3 PROFILE  \"\n    \"ISPEXEC VPUT DS4 PROFILE  \"\n    \"ISPEXEC VPUT DSBACK PROFILE  \"\n    \"ISPEXEC VPUT DS6 PROFILE  \"\n    \"ISPEXEC VPUT DS5 PROFILE  \"\n    \"ISPEXEC VPUT DEF PROFILE  \"\n  END\n  IF  PANELRC = 8 THEN  DO\n    PANEL= DEFPNL\n    ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n    PANELRC=0\n    MSG= \"FUNCTION COMPLETED SUCCESSFULLY\"\n    FUNCT = \"GENERAL\"\n    OPT=  \" \"\n    SIGNAL REDO\n  END\n  IF  OPT = \"REINIT\" THEN  DO\n    INI = \"NO\"\n    RELOAD = \"BOTH\"\n    \"ISPEXEC TBEND \"CMDTABLE\n    \"ISPEXEC TBEND \"SCRTABLE\n    \"ISPEXEC VPUT INI PROFILE\"\n    SIGNAL REINIT\n  END\n  IF (OPT= \"LS\") | (OPT=\"LO\") | (OPT=\"L\") THEN DO\n    IF AUTHNUM < 9 THEN DO\n      IF ( INDEX(DATA,\"PW\") > 0 ) | ( INDEX(DATA,\"PA\") > 0 ) THEN\n        DATA = \"BASIC,XAUTH,TSO\"\n    END\n  END\n  /************************************************/\n  /**--------DYNAMIC COMMAND AREA----------------**/\n  /**  OW LETS PROCESS THE USERS CMDLIST DSN     **/\n  /**--------DYNAMIC COMMAND AREA----------------**/\n  /************************************************/\n  ADDRESS ISPEXEC \"TBTOP \"CMDTABLE\n  ADDRESS ISPEXEC \"TBVCLEAR \"CMDTABLE\n  CMDNAME = OPT\n  ADDRESS ISPEXEC \"VPUT CMDNAME\"\n  ADDRESS ISPEXEC \"TBSARG \"CMDTABLE \"ARGLIST(CMDNAME)\"\n  CALL OFF ERROR\n  signal off error\n  OTT = OUTTRAP(ON.,trapnum)  /* TRAPALL */\n  IF TRAP_FLAG = \"NO\" THEN\n    OTT = OUTTRAP(\"OFF\")  /* TRAPNONE */\n  \"TBGET\" CMDTABLE\n  CMD_RC = RC\n  CALL ON ERROR NAME SHUCKS\n  IF CMD_RC = 0 THEN DO\n    INT.0 = 0\n    IF TRAP_FLAG = \"NO\" THEN\n      SAY PGMNAME MSGOPT DATACK DATA2CK AUTH TRAPOPT BATCHOPT VARS\n    IF TRAP_FLAG = \"YES\" THEN DO\n      IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n      INT.0 = INT.0 + 1\n      HOLDTEMP = INT.0\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"***DYNAMIC ROUTINE ENTERED MATCH IS BELOW: **\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"PGM     MSG  DATA DATA2 AUTH TRAP BATCH VARS \"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = PGMNAME MSGOPT\"   \" DATACK\"    \" DATA2CK\"    \",\n      AUTH\"  \" TRAPOPT\"   \" BATCHOPT \"    \"VARS\n      INT.0 = HOLDTEMP\n    END\n    IF SUBSTR(PGMNAME,1,5) = \"TVER.\" THEN\n      PGMNAME= \"%\"||TVER||SUBSTR(PGMNAME,6)  /* VER 51 */\n    ADDRESS ISPEXEC \"VPUT MODE  PROFILE\"\n    IF TRAP_FLAG = \"NO\" THEN\n      SAY \"DYNAMIC ROUTINE FINDS COMMAND MATCH ON RECORD \" Q\n    FUNCT = OPT\n    SOURCE = \"DYNAM\"\n    IF AUTH > AUTHNUM THEN DO\n      SECRC = \"FAILED. REQUIRES AUTHORITY LEVEL\" AUTH\".\"\n      SECRC = SECRC \" YOUR LEVEL IS\" AUTHNUM\n      SIGNAL GOTMSG\n    END\n    /*********************/\n    /** CHECK DATA TYPE **/\n    /*********************/\n    IF (DATACK = \"NUM\" ) & (DATATYPE(DATA) \u00ac= \"NUM\") THEN DO\n      MSG = \"A NUMERIC DATA FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    IF (DATACK = \"CHAR\" ) & (DATATYPE(DATA) \u00ac= \"CHAR\") THEN DO\n      MSG = \"A CHARACTER DATA FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    /***********************************************************/\n    /* MSN 06/01/95 - OPTC MEANS FIELD IS OPTIONAL BUT IF IT   */\n    /*    IS CODED, THEN IT MUST BE CHARACTER FORMAT           */\n    /***********************************************************/\n    IF (DATACK = \"OPTC\" ) & (DATATYPE(DATA) \u00ac= \"CHAR\") THEN DO\n      MSG = \"ABORTED, IF PROVIDED THE DATA FIELD MUST BE CHARACTER.\"\n      SIGNAL REDO\n    END\n    IF DATACK = \"PAD.\"  THEN DO\n      DATA = TRANSLATE(DATA,\".\",\" \")\n      SAY \"DYNAM: BLANKS TRANSLATED TO DOTS IN DATA.\"\n      SAY \"DYNAM: RESULT OF TRANS:\" DATA\n    END\n    IF (DATACK = \"OPTN\" ) & (DATATYPE(DATA) \u00ac= \"NUM\") THEN DO\n      MSG = \"ABORTED, IF PROVIDED THE DATA FIELD MUST BE NUMERIC.\"\n      SIGNAL REDO\n    END\n    IF ( (DATACK = 1 ) | (DATACK = \"CHAR\" ) ) & (DATA = \" \") THEN DO\n      MSG = \"THE DATA FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    IF (DATA2CK = \"NUM\" ) & (DATATYPE(DATA2) \u00ac= \"NUM\") THEN DO\n      MSG = \"A NUMERIC DATA2 FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    IF (DATA2CK = \"CHAR\" ) & (DATATYPE(DATA2) \u00ac= \"CHAR\") THEN DO\n      MSG = \"A CHARACTER DATA2 FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    IF ( (DATA2CK = 1 ) | (DATA2CK = \"CHAR\" ) ) & (DATA2= \" \") THEN DO\n      MSG = \"THE DATA2 FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    /******************************/\n    /** FUTURE CMD STACKING DO   **/\n    /** GOES HERE.               **/\n    /******************************/\n    BATCH_VARS = \" \"\n    PARSE VAR VARS W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11,\n          W.12 W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20\n    STOP =  WORDS(VARS)\n    IF STOP > 20 THEN\n      MSG2 = \"DYNAM ROUTINE OVERFLOW MORE THAN 20 VARIABLES IN ARGS\"\n    /******************************/\n    /** LETS SEPERATE THE VARS   **/\n    /** FROM THE LITERALS IN THE **/\n    /** COMMAND STREAM.          **/\n    /** LITERALS HAVE A _ IN.    **/\n    /******************************/\n    DO T1 = 1 TO STOP\n      STRIP = \"NO\"\n      IF (INDEX(W.T1,\"<\") \u00ac= 0) THEN DO\n        W.T1 = TRANSLATE(W.T1,\"\",\"<\") /* REPLACE _ WITH NULL */\n        W.T1 = STRIP(W.T1)\n        STRIP = \"YES\"\n        IF TRAP_FLAG = \"NO\" THEN\n          SAY \"DYNAM: DETECTED A NO SPACE VAR\"\n        IF TRAP_FLAG = \"YES\" THEN DO\n          IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n          INT.0 = INT.0 + 1\n          HOLDTEMP = INT.0\n          INT.HOLDTEMP = \"DYNAM: DETECTED A NO SPACE VAR\"\n          INT.0 = HOLDTEMP\n        END\n      END\n      IF (INDEX(W.T1,\"_\") \u00ac= 0) | (DATATYPE(W.T1) = \"NUM\") THEN\n        VAL = TRANSLATE(W.T1,\" \",\"_\") /* REPLACE _ WITH SPACES */\n      ELSE VAL = VALUE(W.T1)\n      VAL = STRIP(VAL)\n      IF STRIP = \"NO\" THEN\n        BATCH_VARS = BATCH_VARS VAL\n      ELSE\n        BATCH_VARS = BATCH_VARS||VAL\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"VALUE OF VAR \" W.T1 \"IS \" VAL\n      IF TRAP_FLAG = \"YES\" THEN DO\n        IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n        INT.0 = INT.0 + 1\n        HOLDTEMP = INT.0\n        INT.HOLDTEMP = \"VALUE OF VAR \" W.T1 \"IS \" VAL\n        INT.0 = HOLDTEMP\n      END\n    END\n    IF VARS = 0 THEN BATCH_VARS = \" \"\n    IF  (MODE = \"BATCH\") & (BATCHOPT = 0) THEN DO\n      BJCL.1 = PGMNAME BATCH_VARS\n      IF INDEX(PGMNAME,\"%\") =  1 THEN\n        BJCL.1 = \"ISPSTART CMD(\"PGMNAME BATCH_VARS\") NEWAPPL(TSS)\"\n      IF LENGTH(BJCL.1) > 70 THEN DO\n        BJCL.1 = \"ISPSTART -\"\n        BJCL.2 = \" CMD(\"PGMNAME BATCH_VARS\") -\"\n        ADDRESS MVS \"EXECIO 2 DISKW BJCL (FINIS STEM BJCL.)\"\n        /*******************************************************/\n        /* THE LINE BELOW WILL BE WRITTEN BY THE FALLTHRU AREA */\n        /*******************************************************/\n        BJCL.1 = \" NEWAPPL(TSS)\"\n        BJCL.2 = \"BJCL.2\"\n      END\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"THE BATCH FILE IS UPDATED, COMMAND IS \" BJCL.1 BJCL.2\n      ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      SIGNAL NOMSG\n    END\n    IF  (MODE = \"BATCH\") & (BATCHOPT = 1) THEN DO\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"DYNAM: THE BATCH FILE IS BEING ALLOCATED DISP = MOD\"\n      ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\" DS5\") MOD REUS\"\n      BOPEN = YES\n    END\n    ADDRESS ISPEXEC \"VPUT (ACID DATA DATA2) PROFILE\"\n    IF (TRAPOPT = \"OFF\") | (TRAPOPT = 0) THEN\n      SS = OUTTRAP(OFF)\n    IF TRAP_FLAG = \"NO\" THEN\n      SAY \"ADDRESS TSO\" PGMNAME BATCH_VARS\n    IF TRAP_FLAG = \"YES\" THEN DO\n      IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n      INT.0 = INT.0 + 1\n      HOLDTEMP = INT.0\n      INT.HOLDTEMP = \"ADDRESS TSO\" PGMNAME BATCH_VARS\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"****CONTROL IS BEING ROUTED TO DYNAMIC COMMAND\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      INT.0 = HOLDTEMP\n    END\n    ADDRESS \"TSO\" PGMNAME BATCH_VARS\n    /******************************/\n    /** FUTURE CMD STACKING ENDDO**/\n    /** GOES HERE.               **/\n    /******************************/\n    IF TRAP_FLAG = \"YES\" THEN\n      SS = OUTTRAP(ON.,TRAPNUM)\n    ELSE\n      SS = OUTTRAP(OFF)\n    ZPF07 = \"UP\"\n    ZPF19 = \"UP\"\n    ZPF08 = \"DOWN\"\n    ZPF20 = \"DOWN\"\n    ADDRESS ISPEXEC \"VPUT ZPF07  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF19  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF08  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF20  PROFILE\"\n    IF MSGOPT = 0 THEN SIGNAL NOMSG\n    IF MSGOPT = \"DATA\" THEN DO\n      ADDRESS ISPEXEC \"VGET DATAAREA PROFILE\"\n      ACID = DATAAREA\n    END\n    SIGNAL GETMSG\n  END\n  /************************************************/\n  /**--------DYNAMIC COMMAND AREA ENDS ----------**/\n  /**  OW LETS PROCESS THE USERS CMDLIST DSN     **/\n  /**--------DYNAMIC COMMAND AREA ENDS ----------**/\n  /************************************************/\n/***********************************************************/\n/* HERE WE START THE NORMAL OPTIONS AREA....DIR 19 OCT 92  */\n/***********************************************************/\n  IF (OPT = \"STATUS\") | (OPT = \"STAT\") THEN  DO\n    PANEL= \"SPISTAT\"\n    ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n    MSG= \"VARIABLE ENTRIES DISPLAYED\" OPT\n    FUNCT = \"STATUS\"\n    IF  PANEL = \"SPISTAT\" THEN\n      OPT= \"STATUS\" /* HE MAY HAVE CHANGED PANEL */\n    SIGNAL REDO\n  END\n  IF  OPT = \"VARSET\" THEN  DO\n    IF AUTHNUM < 10 THEN DO\n      SECRC =  \"VARSET REQUIRES AUTHNUM OF 10, YOUR AUTHNUM IS\" AUTHNUM\n      SIGNAL GOTMSG\n    END\n    IF LENGTH(ACID) > 8 THEN DO\n      SECRC = \"VARIABLE NAME IS TOO LONG, VARSET ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    INTERPRET ACID \"=\" DATA\n    IF TRAP_FLAG = \"NO\" THEN SAY \"ISSUING THIS COMMAND :\",\n      \"ADDRESS ISPEXEC VPUT \" ACID \"PROFILE\"\n    IF TRAP_FLAG = \"YES\" THEN DO\n      INT.1 =  \"ISSUING:ADDRESS ISPEXEC VPUT \" ACID \"PROFILE\"\n    END\n    ADDRESS ISPEXEC \"VPUT \" ACID \"PROFILE\"\n    SECRC = \"VARIABLE\" ACID\" TEMPORARILY RESET IN CURRENT PROFILE.\"\n    SIGNAL GOTMSG\n  END\n  IF SUBSTR(OPT,1,1) = \".\" THEN  DO\n    INDEX = SUBSTR(OPT,2)\n    ADDRESS ISPEXEC \"TBTOP \"SCRTABLE\n    ADDRESS ISPEXEC \"TBVCLEAR \"SCRTABLE\n    INDEX1 = SUBSTR(INDEX,1,1)\n    INDEX2 = SUBSTR(INDEX,2)\n    UPPER INDEX1\n    FNAME = INDEX1||INDEX2\n    ADDRESS ISPEXEC \"VPUT FNAME\"\n    CALL OFF ERROR\n    ADDRESS ISPEXEC \"TBSCAN \"SCRTABLE\" ARGLIST(FNAME) CONDLIST(GE)\"\n    RCODE1 = RC\n    SCAN = \"YES\"\n    Y = 0\n    OPT     = \" \"\n    IF RCODE1 = 8 THEN DO\n      secrc = \"Entry not found, or blanks exist in screen table\"\n      SAY \"*********************************************************\"\n      SAY \"SCREEN TABLE SCAN FAILED CHECK THAT SCREEN TABLE DOES NOT\"\n      SAY \"HAVE LEADING BLANKS.                                     \"\n      SAY \"*********************************************************\"\n      signal gotmsg\n    END\n    CALL ON ERROR NAME SHUCKS\n    SIGNAL DISPPNL\n  END\n  IF  AUTHNUM < 4 THEN SIGNAL HUH\n /******************************************************************/\n /*  THE FOLLOWING FUNCTIONS ARE NOT GENERALLY NEEDED EXCEPT FOR   */\n /*  THE MOST POWERFUL ADMINISTRATORS. THIS IS WHY I CHECK AUTHNUM */\n /*  THIS ALLOWS THE FOLLOWING FUNCTIONS TO BE  EXECUTED FROM      */\n /*  THE TEST MENU........DAVE 20 MAY 91                           */\n /******************************************************************/\n  IF OPT = \"CLEARMSG\"  THEN  DO\n    CLEARMSG = \"YES\"\n    ADDRESS ISPEXEC \"VPUT CLEARMSG PROFILE\"\n    MSG2 = \" \"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    SECRC  = \" MESSAGE AREAS CLEARED, MESSAGE OPTIONS RESET \"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"SUB\") &  (MODE = \"BATCH\") THEN  DO\n    BJCL.1 =  \"@@\"\n    ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n    ADDRESS TSO \"FREE DDN(BJCL)\"\n    BOPEN= NO\n    ADDRESS TSO \"SUBMIT \" DS5\n    MSG2= \"NOTE: YOU ARE IN ONLINE MODE, CMDS ARE ISSUED REAL TIME.\"\n    CLEARMSG=YES\n    MODE= \"ONLINE\"\n    SECRC= \"BATCH STREAM SUBMITTED FROM \"DS5\". MODE CHANGE COMPLETE.\"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"SUB\") & (MODE = \"ONLINE\") THEN  DO\n    SECRC= \"THE SUB OPTION IS VALID ONLY IN BATCH MODE.\"\n    SECRC=  SECRC\" OPTION IGNORED\"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"BATCH\") & (MODE < > \"BATCH\") THEN  DO\n    ADDRESS TSO \"%\"TVER\"JCARD\" DS5 \"RANDOM\"\n    IF  RC = 16 THEN  DO\n      SECRC=\"MODE CHANGE FAILED.\"\n      SIGNAL GOTMSG\n    END\n    ADDRESS TSO \" ALLOC DDN(BJCL) DSN(\" DS5\") MOD REUS\"\n    BOPEN = YES\n    MSG2= \"NOTE: YOU ARE IN BATCH MODE, MOST CMDS ARE DEFERRED \"\n    MSG2=   MSG2 \"UNTIL MODE IS CHANGED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    CLEARMSG=NO\n    MODE = \"BATCH\"\n    SECRC= \"MODE CHANGE COMPLETE. JCL WILL BE IN \"DS5\".\"\n    SIGNAL GOTMSG\n  END\n  IF  (OPT = \"ONLINE\") & (MODE < > \"ONLINE\") THEN  DO\n    BJCL.1 = \"@@\"\n    ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n    ADDRESS TSO \" FREE DDN(BJCL)\"\n    BOPEN= NO\n    MSG2= \"NOTE: YOU ARE IN ONLINE MODE CMDS ARE ISSUED REAL TIME.\"\n    CLEARMSG=YES\n    MODE= \"ONLINE\"\n    SECRC= \"MODE CHANGE COMPLETE. JCL NOT SUBMITTED, IS IN \"DS5\".\"\n    SIGNAL GOTMSG\n  END\n  IF  (OPT = \"ONLINE\") & (MODE = \"ONLINE\") THEN  DO\n    MSG2= \"NOTE: MODE IS UNCHANGED.\"\n    CLEARMSG=YES\n    MODE= \"ONLINE\"\n    SECRC= \"NO CHANGES MADE. MODE WAS AND IS STILL ONLINE.\"\n    SIGNAL GOTMSG\n  END\n  IF  OPT = \"CMDO\" THEN  DO\n  /*OTT = OUTTRAP(ZZT,0)     TRAP EVERYTHING */\n    DATAAREA =  ACID\n    ARG =  DATAAREA\n   \" ISPEXEC VPUT ARG PROFILE\"\n   ADDRESS TSO \"%\"TVER\"CMDO\" DS1\n    FUNCT= \"CMDOUT\"\n    SIGNAL GETMSG\n  END\n  /***************************************************************/\n  /** THE FOLLOWING OPTIONS USE THE T..TSO ROUTINE FOR CHANGING **/\n  /** THE TOP SECRET TSO DEFINITIONS.  THE T44TSO ROUTINE       **/\n  /** REQUIRES THE FOLLOWING PARMS :  ACTION ACID LPROC ACCTNUM **/\n  /** UNIT SIZE DESPITE THE FACT ALL THESE MAY NOT BE USED FOR  **/\n  /** EACH FUNCTION I PASS THEM ALL EACH TIME AS THEY ARE       **/\n  /** POSITIONALLY DEPENDANT...DIR 2 JUNE 94                    **/\n  /***************************************************************/\n  /***************************************************************/\n  /** THE END OF THE T44TSO AREA                                **/\n  /***************************************************************/\n  IF  OPT = \"DELBOOK\"   THEN  DO\n    MAXCC = 0\n    FUNCT = \"DELBOOK# \"\n    BOOKS = WORDS(DATA)\n    IF DATATYPE(DATA) < > \"NUM\" THEN DO\n      MSG = \" ONE NUMERIC BOOK NUMBER MUST BE GIVEN, RESPECIFY\"\n      CURSOR = \"DATA\"\n      SIGNAL REDO\n    END\n    IF  MODE = \"BATCH\" THEN DO\n      DO X5 = 1 TO BOOKS\n        BOOK = WORD(DATA,X5)\n        BJCL.1 = \"%TSSDBOOK \"ACID DATA\n        ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      END\n      TRACE OFF\n      SIGNAL NOMSG\n    END\n    DO X5 = 1 TO BOOKS\n      BOOK = WORD(DATA,X5)\n      ADDRESS TSO \"%TSSDBOOK \" ACID DATA\n    END\n    /*OTT = OUTTRAP(\"OFF\")     TRAP NOTHING.          */\n    SIGNAL NOMSG\n  END\n  IF  OPT = \"BOOK\"   THEN  DO\n    MAXCC = 0\n    FUNCT = \"BOOK#  \"\n    UNIT= \"IMSDA\"\n    PROC = DATA2\n    IF DATA2 = \" \" THEN\n      PROC = \"SPFLOGON\"\n    IF DATATYPE(WORD(DATA,1)) < > \"NUM\" THEN DO\n      MSG = \" ONE NUMERIC BOOK NUMBER MUST BE GIVEN, RESPECIFY\"\n      CURSOR = \"DATA\"\n      SIGNAL REDO\n    END\n    BOOKS = WORDS(DATA)\n    IF  MODE = \"BATCH\" THEN DO\n      DO X5 = 1 TO BOOKS\n        BOOK = WORD(DATA,X5)\n        BJCL.1 = \"%TSSBOOK \"ACID PROC BOOK\n        ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      END\n      TRACE OFF\n      SIGNAL GETMSG\n    END\n    /* OTT = OUTTRAP(ZZT,0)     TRAP EVERYTHING */\n    DO X5 = 1 TO BOOKS\n      BOOK = WORD(DATA,X5)\n      ADDRESS TSO \"%TSSBOOK \" ACID  PROC BOOK\n    END\n    /*OTT = OUTTRAP(\"OFF\")     TRAP NOTHING.          */\n    SIGNAL GETMSG\n  END\n  IF  OPT = \"POPTEST\" THEN  DO\n    FUNCT =  \"POPTEST\"\n    TITLE  = \"TEST SCREEN TITLE       \"\n    TITLE1 = \"#BOOK TO BE DELETED       \"\n    VNAME1 = \"THIS IS THE BOOK SPOT     \"\n    CALL DISPPOP\n    SAY V1 V2 V3 V4 V5 V6\n  END\n  IF  OPT = \"REPPROF\" THEN  DO\n    FUNCT =  \"REPPROF\"\n    HOLD = NO\n    DATAP = TRANSLATE(DATA,\".\",\" \")\n    IF  MODE = \"BATCH\" THEN  DO\n     BJCL.1 = \"ISPSTART CMD(%\"TVER\"GREP\" ACID DATAP HOLD\") NEWAPPL(TSS)\"\n      ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      SIGNAL NOMSG\n    END\n    ADDRESS TSO \"%\"TVER\"GREP\" ACID DATA HOLD\n    SIGNAL GETMSG\n  END\n  IF  WORD(OPT,1) = \"UP\" THEN        DO\n    WORD2 = WORD(OPT,2)\n    IF DATATYPE(WORD2) = \"NUM\" THEN THISREC = THISREC - WORD2\n    ELSE THISREC = THISREC - 11\n    Y = 0\n    IF THISREC > MAXREC THEN THISREC = MAXREC\n    IF THISREC < 1 THEN THISREC = 1\n    TGT = THISREC + 10\n    OPT     = \" \"\n    SIGNAL DISPPNL\n  END\n  IF  WORD(OPT,1) = \"DOWN\" THEN      DO\n    WORD2 = WORD(OPT,2)\n    IF DATATYPE(WORD2) = \"NUM\" THEN THISREC = THISREC - WORD2\n    ELSE THISREC = THISREC + 11\n    Y = 0\n    IF THISREC > MAXREC THEN THISREC = MAXREC\n    IF THISREC < 1 THEN THISREC = 1\n    TGT = THISREC + 10\n    OPT     = \" \"\n    SIGNAL DISPPNL\n  END\n  IF OPT = \"AD\" THEN OPT = \"ADD\"\n  HUH: NOP\n  SECRC= \"I DID NOT RECOGNIZE THE OPTION YOU ENTERED.\"    OPT\n  SIGNAL GOTMSG\n  GETMSG: NOP\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET MSG2 PROFILE\"\n  SIGNAL GOTMSG\n  NOMSG: NOP\n  SECRC= \"FUNCTION COMPLETED SUCCESSFULLY.\"\n  IF RCODE >  0 THEN\n    SECRC=  \"FUNCTION COMPLETED WITH A RETURN CODE OF\"     RCODE\n  IF RCODE =  8 THEN  DO\n    SECRC=  \"THE ACID ( \"ACID\") IS INVALID\"\n    SECRC=   SECRC \"OR AUTHORIZATION FAILED.\"\n  END\n  GOTMSG: IF (OPT < > \"L\") & (OPT < > \"IN\"),\n    & (MODE < > \"BATCH\") THEN OPT =   \" \"\n  MSG = SECRC\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\" /* IN CASE I SET A MSG */\n  SYSOUTTRAP= TRAPNUM\n  /******************************************************************/\n  /* NOMSG IS THE JUMP TO POINT (JTP) FOR FUNCTIONS THAT  DO NOT    */\n  /* RETURN A MESSAGE IN VAR SECRC. GETMSG IS FOR OTHERS THAT DO    */\n  /*   ......DAVE 9 APRIL 91                                        */\n  /* NOTE THAT YOU MUST SAVE THE RC IN VARIABLE RCODE FOR JTP       */\n  /* NOMSG....DAVE 9 APRIL 91                                       */\n  /******************************************************************/\n  REDO: RCODE=0 /*A JTP TO KEEP OPTION */\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\" /* IN CASE I SET A MSG */\n  MSG =    FUNCT \":\" MSG\nSIGNAL DISPPNL\n/*******************************************************************/\n/** END OF SEQUENTIAL INSTRUCTIONS                                **/\n/*******************************************************************/\nDISPPOP: NOP\nADDRESS ISPEXEC \"ADDPOP POPLOC(OPT) \"\nADDRESS ISPEXEC \"DISPLAY PANEL(SECPOP)\"\nADDRESS ISPEXEC \"REMPOP\"\nRETURN\nSHUCKS: PROCEDURE EXPOSE RC PNL_DISP PANEL MSG SIGL DEFPNL RCODE,\n  BOPEN OPT ACID DS1 DS2 DS3 DS4 DS5 DEF DS6 SECRC TRAP_FLAG,\n  TVER LEAVE CMDTABLE SCRTABLE\n  RCODE = RC\n  IF TRAP_FLAG = \"NO\" THEN\n    SAY \" ERROR ROUTINE HAS BEEN SIGNALED BY LINE\" SIGL\n  IF RCODE = 0 THEN LEAVE = \"YES\"\n  RC = 0\n  \"ISPEXEC VPUT ACID PROFILE\"\n  ERRORL = SIGL\n  PANELRC = 0\n  /* SAY \"LINE # \" ERRORL \"CAUSED AN ERROR\" */\n  IF RCODE = 24 THEN EXIT 24 /* APPL PARM ERROR IN TSSINI */\n  IF RCODE = 8 THEN DO\n    IF PNL_DISP = \"YES\" THEN DO\n      IF PANEL = \"SPIUTIL\" THEN LEAVE = YES\n      IF PANEL = \"SPIUSER\" THEN LEAVE = YES\n      IF PANEL = DEFPNL THEN LEAVE = YES\n    END\n  END\n  PANEL = DEFPNL\n  ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n  OPT = \"NIL\"\n  MSG = \"FUNCTION RETURNED A RETURN CODE OF \" RCODE\n  IF RCODE = -3 THEN DO\n    MSG = \"POSSIBLE ENVIRONMENTAL ERROR. CHECK TVER SETTING\"\n    SECRC = \"POSSIBLE ENVIRONMENTAL ERROR. CHECK TVER SETTING\"\n    \"ISPEXEC VPUT SECRC PROFILE\"\n  END\n  IF LEAVE = \"YES\" THEN DO\n    IF BOPEN = \"YES\" THEN DO\n      BJCL.1 =  \"@@\"\n      ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      ADDRESS TSO \"FREE DDN(BJCL)\"\n      BOPEN = \"NO\"\n    END\n    \"ISPEXEC VPUT TVER PROFILE \"\n    \"ISPEXEC VPUT DS1 PROFILE  \"\n    \"ISPEXEC VPUT DS2 PROFILE  \"\n    \"ISPEXEC VPUT DS3 PROFILE  \"\n    \"ISPEXEC VPUT DS4 PROFILE  \"\n    \"ISPEXEC VPUT DS6 PROFILE  \"\n    \"ISPEXEC VPUT DS5 PROFILE  \"\n    \"ISPEXEC VPUT DEF PROFILE  \"\n    SIGNAL OFF ERROR\n    \"ISPEXEC TBEND \"CMDTABLE\n    \"ISPEXEC TBEND \"SCRTABLE\n     EXIT\n  END\n  RETURN\nNOTABLE: PROCEDURE EXPOSE RC SIGL CMDTABLE SCRTABLE TABLEOPT\n  ERRORL = SIGL\n  SAY \"LINE # \" ERRORL \"INVOKED ERROR RECOVERY\"\n  SAY \"*********************************************************\"\n  SAY \"** FATAL ERROR FATAL ERROR FATAL ERROR FATAL ERROR     **\"\n  SAY \"*********************************************************\"\n  SAY \"TSSUT: AN OPEN WAS ISSUED FOR ONE OR MORE TABLES THAT DO \"\n  SAY \"       NOT EXIST. OR ARE ALREADY OPEN !                  \"\n  SAY \"       USE THE TBMCMD OR TBMSCR TO CREATE TABLES:\"\n  SAY \"       \" CMDTABLE SCRTABLE\n  SAY \"*********************************************************\"\n  IF TABLEOPT= \"PERM\" THEN DO\n    TABLEOPT = \"TEMP\"\n    ADDRESS ISPEXEC \"VPUT TABLEOPT PROFILE\"\n    SAY \"*********************************************************\"\n    SAY \" I AM CHANGING TABLE OPTION TO TEMP, PLEASE REINVOKE     \"\n    SAY \" THE PANEL SYSTEM TO READ   TABLES FROM FLATFILE INPUT.  \"\n    SAY \" CONFIRM THAT YOU ARE CORRECTLY SET UP TO USE PERMANENT  \"\n    SAY \" TABLE INPUTS. THE TABLE NAMES ARE BELOW.                \"\n    SAY \"       \" CMDTABLE SCRTABLE\n    SAY \"*********************************************************\"\n  END\n  EXIT\nNEWINI: PROCEDURE EXPOSE RC SIGL MSG2 CLEARMSG AUTOINIT NEEDINIT RCODE\n  RCODE = RC\n  RC = 0\n  ERRORL = SIGL\n  PANELRC = 0\n  SAY \"LINE # \" ERRORL \"INVOKED ERROR RECOVERY\"\n  IF RCODE = 8 THEN DO\n    MSG2 = \"$$ WARNING: TSSINI VARIABLES NOT FOUND. LINE \" SIGL\n    MSG2 = MSG2 \"A 'REINIT' SHOULD BE ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    CLEARMSG = \"NO\"\n    IF AUTOINIT \u00ac= \"NO\" THEN DO\n      INI = \"NO\"\n      \"ISPEXEC VPUT INI PROFILE\"\n      NEEDINIT = \"YES\"  /* TELL MAIN ROUTINE TO REINIT */\n      MSG2 = \"$$ NOTE: VARIABLES NOT FOUND. TSSINI WAS REINVOKED\"\n      MSG2 = MSG2 \"TO REBUILD YOUR ENVIRONMENT\"\n      ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    END\n  END\n  OPT = \" \"\n  RETURN\nPTR:\n  ARG VALUE\n  RETURN X2C(C2X(STORAGE(D2X(VALUE),4)))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSUTZ": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00B\\x00\\x99\\x16\\x7f\\x01\\x00\\x07_\\x10S\\x04^\\x04^\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-06-16T00:00:00", "modifydate": "2000-03-15T10:53:42", "lines": 1118, "newlines": 1118, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ADDED WRITEDEBUG SUPPORT FOR DYNAM COMMANDS          **/\n/**********************************************************/\n/** ADDED TEMP/PERM PARM TO TABLE DEFINITION ROUTINE     **/\n/**********************************************************/\n/** ADDED POPUP MENU OPTIONS TO THE SYSTEM               **/\n/**********************************************************/\n/** REWRITE TO USE ISPF TABLES FOR SCREEN AND CMDS       **/\n/**********************************************************/\n/** THE MAIN DRIVER ROUTINE OF THE ENTIRE LOCAL PANEL    **/\n/** SYSTEM. IT IS QUITE IN DEPTH SO I AINT GONNA SPLAIN  **/\n/** IT.    DAVE 9 MAY 95                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : TSSUT                             **/\n/** LAST MODIFIED    : 16 MAR  98                        **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ANY VARIABLES CREATED IN TSSINI OR ISPF ARE AVAILABLE**/\n/** TO ME HERE. ALTHOUGH THIS EXEC EXPECTS NO ARGS PER SE**/\n/** ISPF VGETS - A TON OF THEM                           **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE.                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : A TON OF THEM        **/\n/**                                                      **/\n/**********************************************************/\nSIGNAL OFF ERROR\narg sample\nif sample = \"SAMPLE\" then do\n  sample = \"YES\"\n  address ispexec \"VPUT SAMPLE PROFILE\"\nend\nPARSE VERSION V .\nIF LEFT(V,5) = \"REXXC\" THEN COMPILED = \"YES\"\nBEGIN_CPU = SYSVAR(SYSCPU)\nADDRESS ISPEXEC \"VGET ZSYSID\"\nSYSID = ZSYSID\nSPI_VERSION = 09APR1999\nADDRESS ISPEXEC\nPR = PROMPT(\"OFF\")\nTVERMSG = \"WARNING: YOU HAVE OVERRIDDEN ENVIRONMENTAL PARMS.\"\nSYSUID = SYSVAR(SYSUID)\nMSG2 = \" \"\nDATA = \" \"\nDATA2 = \" \"\nROW =\nINT.0 = 0\nBOOK= \" \"\nCLEARMSG = \"YES\"\nRELOAD = \"BOTH\"\nREINIT: NOP\nADDRESS TSO \"%TSSVERS\" /* FIND OUT WHAT TOP SECRET VERSION IS RUNNIN*/\nADDRESS TSO \"%TSSINI\" SYSUID /* SET MY VARIABLES FOR ME */\nIF RC = 24 THEN  EXIT 00     /* TSSINI DIED ! */\nCALL ON ERROR NAME NEWINI\n\" ISPEXEC VGET ACID            PROFILE \"\n\" ISPEXEC VGET AUTHNUM         PROFILE \"\n\" ISPEXEC VGET AUTHCODE        PROFILE \"\n\" ISPEXEC VGET AUTOINIT        PROFILE \"\n\" ISPEXEC VGET CHKDSN          PROFILE \"\n\" ISPEXEC VGET CMDPRE          PROFILE \"\n\" ISPEXEC VGET CMDTABLE        PROFILE \"\n\" ISPEXEC VGET DDS1            PROFILE \"\n\" ISPEXEC VGET DDS2            PROFILE \"\n\" ISPEXEC VGET DDS3            PROFILE \"\n\" ISPEXEC VGET DDS4            PROFILE \"\n\" ISPEXEC VGET DDS5            PROFILE \"\n\" ISPEXEC VGET DDS6            PROFILE \"\n\" ISPEXEC VGET DEF             PROFILE \"\n\" ISPEXEC VGET DSBACK          PROFILE \"\n\" ISPEXEC VGET DS1             PROFILE \"\n\" ISPEXEC VGET DS2             PROFILE \"\n\" ISPEXEC VGET DS3             PROFILE \"\n\" ISPEXEC VGET DS4             PROFILE \"\n\" ISPEXEC VGET DS5             PROFILE \"\n\" ISPEXEC VGET DS6             PROFILE \"\n\" ISPEXEC VGET JESNODE         PROFILE \"\n\" ISPEXEC VGET MSG2            PROFILE \"\n\" ISPEXEC VGET NEWPASS         PROFILE \"\n\" ISPEXEC VGET PANEL           PROFILE \"\n\" ISPEXEC VGET SCRPRE          PROFILE \"\n\" ISPEXEC VGET SCRTABLE        PROFILE \"\n\" ISPEXEC VGET SECRC           PROFILE \"\n\" ISPEXEC VGET SRCCMD          PROFILE \"\n\" ISPEXEC VGET SRCSCR          PROFILE \"\n\" ISPEXEC VGET SYSTEM          PROFILE \"\n\" ISPEXEC VGET TABLEDSN        PROFILE \"\n\" ISPEXEC VGET TABLEOPT        PROFILE \"\n\" ISPEXEC VGET TRAPNUM         PROFILE \"\n\" ISPEXEC VGET TSSVERS         PROFILE \"\n\" ISPEXEC VGET TVER            PROFILE \"\n\" ISPEXEC VGET ZAPPLID                 \"\n\" ISPEXEC VGET ZSCREEND                \"\n\" ISPEXEC VPUT SECRC           PROFILE \"\n\" ISPEXEC VPUT CLEARMSG        PROFILE \"\n  MSG= \"GENERAL :\"    SECRC\n    SECRC = \" \"\n    /*******************************************************/\n    /* A $$ INDICATES THE MSG WAS SET BY TSSINI SO KEEP IT */\n    /*******************************************************/\n/***********************************************************/\n/** AUTHORIZATION CHECKING.... NEVER CHANGE THIS CODE  *****/\n/***********************************************************/\ncodes = words(authcode)\nif codes > 20 then do\n  say \"Too many authorization codes provided. aborting \"\nend\nparse var authcode w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8 w.9 w.10 w.11 w.12,\n          w.13 w.14 w.15 w.16 w.17 w.18 w.19 w.20\ni_digits = digits()\ngooddate = \"invalid\"\nnumeric digits 60\n/******************************/\npsa = ptr(520)\npsa = c2d(psa)  /* we got back a character value from function */\npsa = psa + 6   /* it just got changed to a decimal value */\npsa = d2x(psa)  /* we change it back to a hex value */\ncpu = storage(psa,6) /* give the storage function the address in hex */\ncpu = substr(cpu,3)\nanycpu = 99999\n/******************************/\ngocode: nop\ntoday = date(s)\ndo x = 1 to codes\n  authcode = w.x\n  tempdate = ((1000000000000 - authcode) + (cpu * cpu)) / cpu\n  datechek = format(tempdate,60,0)\n  t_date = ((1000000000000 - authcode) + (anycpu * anycpu)) / anycpu\n  trial_check = format(t_date,60,0)\n  if t_date = trial_check then do\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"Trial code found for processor:\" authcode\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"You are authorized to run the product until\" t_date\n    trial = \"yes\"\n    gooddate = t_date\n  end\n  if trial = \"yes\" then leave\n  if tempdate /= datechek then do\n    INT.0 = INT.0 + 1\n    HOLDTEMP = INT.0\n    INT.HOLDTEMP = \"skipping code, not for this processor:\" authcode\n  end\n  if tempdate /= datechek then iterate x\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"You are authorized to run the product until\" tempdate\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"With authcode :\" authcode\n  gooddate = tempdate\nend\nif gooddate = \"invalid\" then do\n    say \"***********************************************\"\n    say \"**No valid auth codes found for processor\" cpu\n    say \"***********************************************\"\n    Say \"Please provide valid AUTHCODE for processor \" cpu\n    Say \"or hit PA1 to exit program \"\n    parse pull authcode\n    codes = words(authcode)\n    w.1 = authcode\n    signal gocode\nend\n/* finalcode = 1000000000000 - ((cpu * gooddate) - (cpu * cpu))  */\ntimeleft = gooddate - today\nif timeleft < 200 then do\n  say \"************************\"\n  say \" Your current code is soon to expire.\"\n  MSG2 = \"$$ Authorization is soon to expire, on \"gooddate\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  say \"************************\"\nend\nif today > gooddate then do\n  say \"************************\"\n  say \"expired product         \"\n  say \"************************\"\n  exit 16\nend\nnumeric digits i_digits\n/* */\nIF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\nINT.0 = INT.0 + 1\nHOLDTEMP = INT.0\nIf compiled = \"YES\" then\n  INT.HOLDTEMP = \"Compiled version running, \" spi_version\n/***********************************************************/\n/** AUTHORIZATION CHECKING END NEVER CHANGE THIS CODE  *****/\n/***********************************************************/\nIF WORD(MSG2,1) \\= \"$$\" THEN DO\n  MSG2 = \" \"\n  \" ISPEXEC VPUT MSG2 PROFILE \"\nEND\nIF NEEDINIT = \"YES\" THEN DO\n  NEEDINIT = \"NO\"\n  IF REINIT1 = \"YES\" THEN DO    /* DEEP TROUBLE ENDLESSLOOP */\n    MSG2 = \"TSSUT/TSSINI SYNC ERROR. FATAL ERROR.\" SIGL\n    CLEARMSG = \"NO\"\n  END\n  ELSE DO\n    REINIT1 = \"YES\" /* INDICATE WE HAVE CALLED TSSINI FROM HERE*/\n    SAY \"SIGNALLING REINIT\"\n    OTT = OUTTRAP(\"OFF\")  /* NOTHING */\n    SIGNAL REINIT\n  END\nEND\nTABLES: NOP\nIF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\nIF TABLEOPT = \"TEMP\" THEN DO\n  /* SAY \"BUILDING TEMPORARY TABLES FOR THIS SESSION \" */\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"TABLE LOAD COMMENCING. RELOAD PARM IS \" RELOAD\n  OTT = OUTTRAP(ON.,100)  /* TRAPALL */\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"SCREEN\") THEN\n  ADDRESS TSO \"%TBMSCR\" SRCSCR \".\" SCRTABLE AUTHNUM \"NO\"\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"COMMAND\") THEN\n  ADDRESS TSO \"%TBMCMD\" SRCCMD \".\" CMDTABLE AUTHNUM \"NO\"\n  /*****************************************************/\n  /**THE ABOVE ROUTINES BUILD TABLES AND LEAVE THEM   **/\n  /** OPEN FOR USE BY THIS EXEC                       **/\n  /*****************************************************/\n  RELOAD = \"BOTH\"\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"TABLE LOAD COMPLETE.\"\n  OTT = OUTTRAP(\"OFF\")  /* NOTHING */\nEND\nIF TABLEOPT /= \"TEMP\" THEN DO\n  OTT = OUTTRAP(ON.,100)  /* TRAPALL */\n  /*****************************************************/\n  /**THE ABOVE OPTION INDICATES WE ARE USING PERMANENT**/\n  /** TABLES THAT ARE PREDEFINED SO LETS OPEN THEM    **/\n  /*****************************************************/\n  CALL OFF ERROR\n  SIGNAL OFF ERROR\n  CALL ON ERROR NAME NOTABLE\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"COMMAND\") THEN\n  ADDRESS ISPEXEC \"TBOPEN\" CMDTABLE \"NOWRITE\"\n  /*IF STABLE_RC = 12 THEN */\n  IF (RELOAD = \"BOTH\") | (RELOAD = \"SCREEN\") THEN\n  ADDRESS ISPEXEC \"TBOPEN\" SCRTABLE \"NOWRITE\"\n  TRACE OFF\nEND\nCALL ON ERROR NAME SHUCKS\n/*PANEL  = \"SPIUTIL\"                     */\n/*ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"   */\nIF PANEL /= \"SPIUTIL\" THEN DO\n  INT.0 = INT.0 + 1\n  HOLDTEMP = INT.0\n  INT.HOLDTEMP = \"**Table display is disabled do to custom panel.\"\nEND\nDEFPNL = PANEL\nOLDTVER =  TVER\nSCRNUM = ZSCREEND - 10\nWDS. = \" \"\nUNIT =  TSOUNIT\n/******************************************************************/\n/*  NOW I HAVE RETRIEVED ALL VARIABLES   BY TSSINI    DIR 9 SEP 92*/\n/*  I WILL NOW CHECK FOR DSN VALIDITY....DIR  14 SEP 92           */\n/******************************************************************/\nDDS.1 = DDS1\nDDS.2 = DDS2\nDDS.3 = DDS3\nDDS.4 = DDS4\nDDS.5 = DDS5\nDDS.6 = DDS6\nIF CHKDSN < > \"YES\" THEN SIGNAL DSNDONE\nDO TT = 1 TO 6\n  XX = \"DS\"TT\n  DSNTEMP = VALUE(XX)\n  DSNMSG = SYSDSN(DSNTEMP)\n  /* SAY \"DSNMSG \" DSNMSG \"DSN= \" DSNTEMP */\n  IF DSNMSG = \"OK\" THEN ITERATE TT\n  MSG2 = \"WORK DSN(S) UNAVAILABLE. SOME ADVANCED FUNCTIONS MAY FAIL\"\n  /* SAY MSG2  */\n  WDS.TT = \"*\"\n  DDS.TT = DSNMSG\n  IF DSNMSG = \"DATASET NOT FOUND\" THEN DO\n    MSG2 = \"WORK DNS(S) INVALID. SOME ADVANCED FUNCTIONS MAY FAIL\"\n     WDS.TT = \"**\"\n  END\n  IF WORD(MSG2,1) \\= \"$$\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nDDS1 = DDS.1\nDDS2 = DDS.2\nDDS3 = DDS.3\nDDS4 = DDS.4\nDDS5 = DDS.5\nDDS6 = DDS.6\nWDS1 = WDS.1\nWDS2 = WDS.2\nWDS3 = WDS.3\nWDS4 = WDS.4\nWDS5 = WDS.5\nWDS6 = WDS.6\nDSNDONE: NOP\nBOPEN = NO\nCURSOR = \"OPT\"\nSPACES = \"                \"\nCMDNUM = 0\nRCODE = 0\nMENUNUM = 0\nSCRARRAY.0 = 0\nMODE = \"ONLINE\"\nIF  PANEL = \"  \" THEN  DO\n  MSG2 =  \"WARNING! TSSINI HAS FAILED. VARIABLES MAY BE\"\n  MSG2 =    MSG2 \"CORRUPTED.\"\n  PANEL = SPIUTIL\n  CLEARMSG = NO\nEND\nCALL OFF ERROR\nSIGNAL OFF ERROR\nCALL ON ERROR NAME SHUCKS\nANUM = 1\n/* SAY SCRARRAY.0 AUTHNUM */\nDO Q = 1 TO ANUM\n  SCRARRAY.Q = OUTA.Q\nEND\nMSG1. = ; MSG2. = ; MSG3. = ; MSG4. = ; MSG5. = ; MSG6.= ; MSG7. = ;\nTEMPARRAY.0 = 0\nTHISREC = 1\nY = 0\nX = 0\nOTT = OUTTRAP(ON.,TRAPNUM) /* TRAP EVERYTHING */\nSOURCE = PREDEF\n/******************************************************************/\n/*  THIS IS THE LASTOF THE INIT AREA. WHAT FOLLOWS IS THE LOOP.   */\n/******************************************************************/\nTRAP_FLAG = \"YES\"\nDISPPNL: NOP\n  RCODE = 0 /*  RESET THE LAST ERROR RETURN CODE */\n  IF WORD(HOLDLINE,1) = WORD(ACID,1) THEN ACID = HOLDLINE\n  IF OPT = \"NIL\" THEN OPT = \" \"\n  CPUUSED = SYSVAR(SYSCPU) - BEGIN_CPU\n  ADDRESS ISPEXEC  \"VGET MSG2 PROFILE\"\n  ADDRESS ISPEXEC  \"VGET PANEL PROFILE\"\n  ADDRESS ISPEXEC  \"VGET CLEARMSG PROFILE\"\n  ADDRESS ISPEXEC  \"VPUT CPUUSED  PROFILE\"\n  AUTH = AUTHNUM\n  /* \"TBSARG TS5USC10 NAMECOND(AUTH,LE)\" */\n  IF PANEL = \"SPISTAT\" THEN SCAN = \"YES\"\n  IF (FNAME /= \"FNAME\") & (SCAN = \"NO\") THEN DO\n    OTT = OUTTRAP(ON.,TRAPNUM) /* TRAP EVERYTHING */\n    ADDRESS ISPEXEC \"TBSARG \"SCRTABLE\" ARGLIST(FNAME)\"\n    CALL OFF ERROR\n    \"TBGET\" SCRTABLE\n    ADDRESS ISPEXEC \"TBSKIP \"SCRTABLE\" NUMBER(-\"scrnum\")\"\n    CALL ON ERROR NAME SHUCKS\n    /*********************************************/\n    /** EACH LINE PUT ON THE SCREEN UPDATES THE **/\n    /** VARIABLES SO EACH TIME WE DONT SCAN WE  **/\n    /** SET THE TOP OF SCREEN VALUE TO BOTTOM   **/\n    /** - 14                  DAVE              **/\n    /*********************************************/\n  END\n  SCAN = \"NO\"\n  PNL_DISP = \"YES\"\n  IF PANEL = \"SPIUTIL\" THEN\n  \"TBDISPL \"SCRTABLE\" PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n  ELSE \"DISPLAY PANEL(\"PANEL\") CURSOR(\"CURSOR\")\"\n  PNL_DISP = \"NO\"\n  SOURCE = \"PREDEF\"\n  IF OPT = \"TRACEOFF\" THEN TRACE OFF\n  ACID_WORDNUM = WORDS(ACID)\n  DATA_WORDNUM = WORDS(DATA)\n  DATA2_WORDNUM = WORDS(DATA2)\n  HOLDLINE = ACID\n  \"ISPEXEC VPUT ACID PROFILE\"\n  \"ISPEXEC VPUT DATA PROFILE\"\n  \"ISPEXEC VPUT DATA2 PROFILE\"\n  IF CLEARMSG = \"YES\"  THEN DO\n    MSG2 =  \" \"\n    CLEARMSG = \"YES\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    ADDRESS ISPEXEC \"VPUT CLEARMSG PROFILE\"\n  END\n  MSG =   \" \"\n  SECRC=  \" \"\n  UPPER DATA\n  UPPER DATA2\n  UPPER ACID\n  FUNCT= \"GENERAL\"\n  CURSOR= \"OPT\"\n  HOLD = ACID\"     \"\n  FIRST4 = SUBSTR(HOLD,1,4)\n/***********************************************************/\n/* HERE WE START THE SPECIAL ENVIRONMENT AFFECTING         */\n/* OPTIONS....................DIR 19 OCT 92                */\n/***********************************************************/\n  IF OPT = \"SCREENLOAD\" THEN DO\n    IF (SYSDSN(\"'\"ACID\"'\")/= \"OK\") & (SYSDSN(ACID)/= \"OK\") THEN DO\n      SECRC = \"LOAD DATASET NOT USABLE, LOAD ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    IF TABLEOPT /= \"TEMP\" THEN DO\n      SECRC = \"TABLE FORMAT IS NOT DYNAMIC, SCREENLOAD NOT VALID.\"\n      SIGNAL GOTMSG\n    END\n    RELOAD = \"SCREEN\"\n    \"ISPEXEC TBEND \"SCRTABLE\n    SRCSCR = ACID\n    SIGNAL TABLES\n  END\n  IF OPT = \"COMMANDLOAD\" THEN DO\n    IF (SYSDSN(\"'\"ACID\"'\")/= \"OK\") THEN DO\n      SECRC = \"LOAD DATASET NOT USABLE, LOAD ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    IF TABLEOPT /= \"TEMP\" THEN DO\n      SECRC = \"TABLE FORMAT IS NOT DYNAMIC, COMMANDLOAD NOT VALID.\"\n      SIGNAL GOTMSG\n    END\n    RELOAD = \"COMMAND\"\n    \"ISPEXEC TBEND \"CMDTABLE\n    SRCCMD = ACID\n    SIGNAL TABLES\n  END\n  IF OPT = \"WRITEDEBUG\" THEN DO\n    TRAP_FLAG = \"YES\"\n    OPT = \"NIL\"\n    ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") SHR REUS\"\n    ADDRESS MVS \"EXECIO \"INT.0\" DISKW OUT1 ( FINIS STEM INT.)\"\n    ADDRESS TSO \"FREE DDN(OUT1)\"\n    ADDRESS TSO \"ALLOC DDN(OUT1) DSN(\"DS3\") MOD\"\n    ADDRESS MVS \"EXECIO \"TRAPNUM\" DISKW OUT1 ( FINIS STEM ON.)\"\n    ADDRESS TSO \"FREE DDN(OUT1)\"\n    DO QW1 = 1 TO TRAPNUM; ON.QW1 = \" \"; END\n    SECRC = TRAPNUM \"LINES OF DEBUG FILE INFO WRITTEN TO \"DS3\n    address tso \"%rxbrowse \"ds3\n    SIGNAL GOTMSG\n  END\n  IF OPT = \"TRAPOFF\" THEN DO\n    OTT = OUTTRAP(\"OFF\")  /* NOTHING */\n    TRAP_FLAG = \"NO\"\n    OPT = \"NIL\"\n    SECRC = \"ALL INTERNAL OUTPUT WILL NOW BE SHOWN.\"\n    SIGNAL GOTMSG\n  END\n  IF OPT = \"TRAPON\" THEN TRAP_FLAG = \"YES\"\n  IF OPT = \"TRAPON\" THEN DO\n    TRAP_FLAG = \"YES\"\n    SECRC = \"I AM NOW TRAPPING SUBTASK CREATED MESSAGES.\"\n    SIGNAL GOTMSG\n  END\n  IF TRAP_FLAG = \"YES\" THEN DO\n     SS = OUTTRAP(ON.,TRAPNUM)\n  END\n  IF TRAP_FLAG = \"NO\" THEN DO\n     SS = OUTTRAP(OFF)\n  END\n  IF (OPT = \"NIL\") | (OPT = \" \" )  THEN DO\n    OPT = \" \"\n    SIGNAL DISPPNL\n  END\n  IF OPT = \"TRAPON\" THEN TRAP_FLAG = \"YES\"\n  IF OPT = \"TRAPOFF\" THEN TRAP_FLAG = \"NO\"\n  IF OPT = \"TRACE\" THEN TRACE R\n  IF OPT = \"TRACE\" THEN SIGNAL REDO\n  IF OPT = \"TRACEOFF\" THEN SIGNAL REDO\n  IF OPT = \"LEAVE\" THEN CALL SHUCKS\n  IF OPT = \"END\" THEN EXIT\n  IF OPT = \"X\" THEN CALL SHUCKS\n  IF OPT = \"QUIT\" THEN CALL SHUCKS\n  IF  TVER \u00ac= OLDTVER THEN  DO\n    MSG2 = TVERMSG\n    CLEARMSG = \"NO\"\n  END\n  IF OPT = \"REXXCMD\" THEN DO\n   IF INDEX(ACID,\"SOURCELINE\") = 0 THEN INTERPRET ACID\n   MSG = \"REXX INPUT INTERPRETED SUCCESSFULLY.\"\n   IF INDEX(ACID,\"SOURCELINE\") /= 0 THEN\n     MSG = \"INPUT IGNORED.\"\n   OPT = \" \"\n   SIGNAL REDO\n  END\n  IF (OPT \u00ac= \"CMDO\") &  (OPT \u00ac= \"CMDS\") THEN ACID = WORD(ACID,1)\n  IF  (OPT = \"STATUS\") | (PANEL= \"SPISTAT\") THEN  DO\n    IF (TVER =  OLDTVER) &  (MSG2 =  TVERMSG) THEN  DO\n      MSG2 =  \"ENVIRONMENT RESTORED TO TSSINI DEFAULT\"\n      MSG2 = MSG2 \"VALUES.\"\n      CLEARMSG = YES\n    END\n    \"ISPEXEC VPUT TVER PROFILE \"\n    \"ISPEXEC VPUT DS1 PROFILE  \"\n    \"ISPEXEC VPUT DS2 PROFILE  \"\n    \"ISPEXEC VPUT DS3 PROFILE  \"\n    \"ISPEXEC VPUT DS4 PROFILE  \"\n    \"ISPEXEC VPUT DSBACK PROFILE  \"\n    \"ISPEXEC VPUT DS6 PROFILE  \"\n    \"ISPEXEC VPUT DS5 PROFILE  \"\n    \"ISPEXEC VPUT DEF PROFILE  \"\n  END\n  IF  PANELRC = 8 THEN  DO\n    PANEL= DEFPNL\n    ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n    PANELRC=0\n    MSG= \"FUNCTION COMPLETED SUCCESSFULLY\"\n    FUNCT = \"GENERAL\"\n    OPT=  \" \"\n    SIGNAL REDO\n  END\n  IF  OPT = \"REINIT\" THEN  DO\n    INI = \"NO\"\n    RELOAD = \"BOTH\"\n    \"ISPEXEC TBEND \"CMDTABLE\n    \"ISPEXEC TBEND \"SCRTABLE\n    \"ISPEXEC VPUT INI PROFILE\"\n    SIGNAL REINIT\n  END\n  IF (OPT= \"LS\") | (OPT=\"LO\") | (OPT=\"L\") THEN DO\n    IF AUTHNUM < 9 THEN DO\n      IF ( INDEX(DATA,\"PW\") > 0 ) | ( INDEX(DATA,\"PA\") > 0 ) THEN\n        DATA = \"BASIC,XAUTH,TSO\"\n    END\n  END\n  /************************************************/\n  /**--------DYNAMIC COMMAND AREA----------------**/\n  /**  OW LETS PROCESS THE USERS CMDLIST DSN     **/\n  /**--------DYNAMIC COMMAND AREA----------------**/\n  /************************************************/\n  ADDRESS ISPEXEC \"TBTOP \"CMDTABLE\n  ADDRESS ISPEXEC \"TBVCLEAR \"CMDTABLE\n  CMDNAME = OPT\n  ADDRESS ISPEXEC \"VPUT CMDNAME\"\n  ADDRESS ISPEXEC \"TBSARG \"CMDTABLE \"ARGLIST(CMDNAME)\"\n  CALL OFF ERROR\n  signal off error\n  OTT = OUTTRAP(ON.,trapnum)  /* TRAPALL */\n  IF TRAP_FLAG = \"NO\" THEN\n    OTT = OUTTRAP(\"OFF\")  /* TRAPNONE */\n  \"TBGET\" CMDTABLE\n  CMD_RC = RC\n  CALL ON ERROR NAME SHUCKS\n  IF CMD_RC = 0 THEN DO\n    INT.0 = 0\n    IF TRAP_FLAG = \"NO\" THEN\n      SAY PGMNAME MSGOPT DATACK DATA2CK AUTH TRAPOPT BATCHOPT VARS\n    IF TRAP_FLAG = \"YES\" THEN DO\n      IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n      INT.0 = INT.0 + 1\n      HOLDTEMP = INT.0\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"***DYNAMIC ROUTINE ENTERED MATCH IS BELOW: **\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"PGM     MSG  DATA DATA2 AUTH TRAP BATCH VARS \"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = PGMNAME MSGOPT\"   \" DATACK\"    \" DATA2CK\"    \",\n      AUTH\"  \" TRAPOPT\"   \" BATCHOPT \"    \"VARS\n      INT.0 = HOLDTEMP\n    END\n    IF SUBSTR(PGMNAME,1,5) = \"TVER.\" THEN\n      PGMNAME= \"%\"||TVER||SUBSTR(PGMNAME,6)  /* VER 51 */\n    ADDRESS ISPEXEC \"VPUT MODE  PROFILE\"\n    IF TRAP_FLAG = \"NO\" THEN\n      SAY \"DYNAMIC ROUTINE FINDS COMMAND MATCH ON RECORD \" Q\n    FUNCT = OPT\n    SOURCE = \"DYNAM\"\n    IF AUTH > AUTHNUM THEN DO\n      SECRC = \"FAILED. REQUIRES AUTHORITY LEVEL\" AUTH\".\"\n      SECRC = SECRC \" YOUR LEVEL IS\" AUTHNUM\n      SIGNAL GOTMSG\n    END\n    /*********************/\n    /** CHECK DATA TYPE **/\n    /*********************/\n    IF (DATACK = \"NUM\" ) & (DATATYPE(DATA) \u00ac= \"NUM\") THEN DO\n      MSG = \"A NUMERIC DATA FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    IF (DATACK = \"CHAR\" ) & (DATATYPE(DATA) \u00ac= \"CHAR\") THEN DO\n      MSG = \"A CHARACTER DATA FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    /***********************************************************/\n    /* MSN 06/01/95 - OPTC MEANS FIELD IS OPTIONAL BUT IF IT   */\n    /*    IS CODED, THEN IT MUST BE CHARACTER FORMAT           */\n    /***********************************************************/\n    IF (DATACK = \"OPTC\" ) & (DATATYPE(DATA) \u00ac= \"CHAR\") THEN DO\n      MSG = \"ABORTED, IF PROVIDED THE DATA FIELD MUST BE CHARACTER.\"\n      SIGNAL REDO\n    END\n    IF DATACK = \"PAD.\"  THEN DO\n      DATA = TRANSLATE(DATA,\".\",\" \")\n      SAY \"DYNAM: BLANKS TRANSLATED TO DOTS IN DATA.\"\n      SAY \"DYNAM: RESULT OF TRANS:\" DATA\n    END\n    IF (DATACK = \"OPTN\" ) & (DATATYPE(DATA) \u00ac= \"NUM\") THEN DO\n      MSG = \"ABORTED, IF PROVIDED THE DATA FIELD MUST BE NUMERIC.\"\n      SIGNAL REDO\n    END\n    IF ( (DATACK = 1 ) | (DATACK = \"CHAR\" ) ) & (DATA = \" \") THEN DO\n      MSG = \"THE DATA FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    IF (DATA2CK = \"NUM\" ) & (DATATYPE(DATA2) \u00ac= \"NUM\") THEN DO\n      MSG = \"A NUMERIC DATA2 FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    IF (DATA2CK = \"CHAR\" ) & (DATATYPE(DATA2) \u00ac= \"CHAR\") THEN DO\n      MSG = \"A CHARACTER DATA2 FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    IF ( (DATA2CK = 1 ) | (DATA2CK = \"CHAR\" ) ) & (DATA2= \" \") THEN DO\n      MSG = \"THE DATA2 FIELD IS REQUIRED FOR THIS FUNCTION\"\n      SIGNAL REDO\n    END\n    /******************************/\n    /** FUTURE CMD STACKING DO   **/\n    /** GOES HERE.               **/\n    /******************************/\n    BATCH_VARS = \" \"\n    PARSE VAR VARS W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11,\n          W.12 W.13 W.14 W.15 W.16 W.17 W.18 W.19 W.20\n    STOP =  WORDS(VARS)\n    IF STOP > 20 THEN\n      MSG2 = \"DYNAM ROUTINE OVERFLOW MORE THAN 20 VARIABLES IN ARGS\"\n    /******************************/\n    /** LETS SEPERATE THE VARS   **/\n    /** FROM THE LITERALS IN THE **/\n    /** COMMAND STREAM.          **/\n    /** LITERALS HAVE A _ IN.    **/\n    /******************************/\n    DO T1 = 1 TO STOP\n      STRIP = \"NO\"\n      IF (INDEX(W.T1,\"<\") \u00ac= 0) THEN DO\n        W.T1 = TRANSLATE(W.T1,\"\",\"<\") /* REPLACE _ WITH NULL */\n        W.T1 = STRIP(W.T1)\n        STRIP = \"YES\"\n        IF TRAP_FLAG = \"NO\" THEN\n          SAY \"DYNAM: DETECTED A NO SPACE VAR\"\n        IF TRAP_FLAG = \"YES\" THEN DO\n          IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n          INT.0 = INT.0 + 1\n          HOLDTEMP = INT.0\n          INT.HOLDTEMP = \"DYNAM: DETECTED A NO SPACE VAR\"\n          INT.0 = HOLDTEMP\n        END\n      END\n      IF (INDEX(W.T1,\"_\") \u00ac= 0) | (DATATYPE(W.T1) = \"NUM\") THEN\n        VAL = TRANSLATE(W.T1,\" \",\"_\") /* REPLACE _ WITH SPACES */\n      ELSE VAL = VALUE(W.T1)\n      VAL = STRIP(VAL)\n      IF STRIP = \"NO\" THEN\n        BATCH_VARS = BATCH_VARS VAL\n      ELSE\n        BATCH_VARS = BATCH_VARS||VAL\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"VALUE OF VAR \" W.T1 \"IS \" VAL\n      IF TRAP_FLAG = \"YES\" THEN DO\n        IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n        INT.0 = INT.0 + 1\n        HOLDTEMP = INT.0\n        INT.HOLDTEMP = \"VALUE OF VAR \" W.T1 \"IS \" VAL\n        INT.0 = HOLDTEMP\n      END\n    END\n    IF VARS = 0 THEN BATCH_VARS = \" \"\n    IF  (MODE = \"BATCH\") & (BATCHOPT = 0) THEN DO\n      BJCL.1 = PGMNAME BATCH_VARS\n      IF INDEX(PGMNAME,\"%\") =  1 THEN\n        BJCL.1 = \"ISPSTART CMD(\"PGMNAME BATCH_VARS\") NEWAPPL(TSS)\"\n      IF LENGTH(BJCL.1) > 70 THEN DO\n        BJCL.1 = \"ISPSTART -\"\n        BJCL.2 = \" CMD(\"PGMNAME BATCH_VARS\") -\"\n        ADDRESS MVS \"EXECIO 2 DISKW BJCL (FINIS STEM BJCL.)\"\n        /*******************************************************/\n        /* THE LINE BELOW WILL BE WRITTEN BY THE FALLTHRU AREA */\n        /*******************************************************/\n        BJCL.1 = \" NEWAPPL(TSS)\"\n        BJCL.2 = \"BJCL.2\"\n      END\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"THE BATCH FILE IS UPDATED, COMMAND IS \" BJCL.1 BJCL.2\n      ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      SIGNAL NOMSG\n    END\n    IF  (MODE = \"BATCH\") & (BATCHOPT = 1) THEN DO\n      IF TRAP_FLAG = \"NO\" THEN\n        SAY \"DYNAM: THE BATCH FILE IS BEING ALLOCATED DISP = MOD\"\n      ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\" DS5\") MOD REUS\"\n      BOPEN = YES\n    END\n    ADDRESS ISPEXEC \"VPUT (ACID DATA DATA2) PROFILE\"\n    IF (TRAPOPT = \"OFF\") | (TRAPOPT = 0) THEN\n      SS = OUTTRAP(OFF)\n    IF TRAP_FLAG = \"NO\" THEN\n      SAY \"ADDRESS TSO\" PGMNAME BATCH_VARS\n    IF TRAP_FLAG = \"YES\" THEN DO\n      IF DATATYPE(INT.0) /= \"NUM\" THEN INT.0 = 0\n      INT.0 = INT.0 + 1\n      HOLDTEMP = INT.0\n      INT.HOLDTEMP = \"ADDRESS TSO\" PGMNAME BATCH_VARS\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"****CONTROL IS BEING ROUTED TO DYNAMIC COMMAND\"\n      HOLDTEMP = HOLDTEMP + 1\n      INT.HOLDTEMP = \"*********************************************\"\n      INT.0 = HOLDTEMP\n    END\n    ADDRESS \"TSO\" PGMNAME BATCH_VARS\n    /******************************/\n    /** FUTURE CMD STACKING ENDDO**/\n    /** GOES HERE.               **/\n    /******************************/\n    IF TRAP_FLAG = \"YES\" THEN\n      SS = OUTTRAP(ON.,TRAPNUM)\n    ELSE\n      SS = OUTTRAP(OFF)\n    ZPF07 = \"UP\"\n    ZPF19 = \"UP\"\n    ZPF08 = \"DOWN\"\n    ZPF20 = \"DOWN\"\n    ADDRESS ISPEXEC \"VPUT ZPF07  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF19  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF08  PROFILE\"\n    ADDRESS ISPEXEC \"VPUT ZPF20  PROFILE\"\n    IF MSGOPT = 0 THEN SIGNAL NOMSG\n    IF MSGOPT = \"DATA\" THEN DO\n      ADDRESS ISPEXEC \"VGET DATAAREA PROFILE\"\n      ACID = DATAAREA\n    END\n    SIGNAL GETMSG\n  END\n  /************************************************/\n  /**--------DYNAMIC COMMAND AREA ENDS ----------**/\n  /**  OW LETS PROCESS THE USERS CMDLIST DSN     **/\n  /**--------DYNAMIC COMMAND AREA ENDS ----------**/\n  /************************************************/\n/***********************************************************/\n/* HERE WE START THE NORMAL OPTIONS AREA....DIR 19 OCT 92  */\n/***********************************************************/\n  IF (OPT = \"STATUS\") | (OPT = \"STAT\") THEN  DO\n    PANEL= \"SPISTAT\"\n    ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n    MSG= \"VARIABLE ENTRIES DISPLAYED\" OPT\n    FUNCT = \"STATUS\"\n    IF  PANEL = \"SPISTAT\" THEN\n      OPT= \"STATUS\" /* HE MAY HAVE CHANGED PANEL */\n    SIGNAL REDO\n  END\n  IF  OPT = \"VARSET\" THEN  DO\n    IF AUTHNUM < 10 THEN DO\n      SECRC =  \"VARSET REQUIRES AUTHNUM OF 10, YOUR AUTHNUM IS\" AUTHNUM\n      SIGNAL GOTMSG\n    END\n    IF LENGTH(ACID) > 8 THEN DO\n      SECRC = \"VARIABLE NAME IS TOO LONG, VARSET ABORTED.\"\n      SIGNAL GOTMSG\n    END\n    INTERPRET ACID \"=\" DATA\n    IF TRAP_FLAG = \"NO\" THEN SAY \"ISSUING THIS COMMAND :\",\n      \"ADDRESS ISPEXEC VPUT \" ACID \"PROFILE\"\n    IF TRAP_FLAG = \"YES\" THEN DO\n      INT.1 =  \"ISSUING:ADDRESS ISPEXEC VPUT \" ACID \"PROFILE\"\n    END\n    ADDRESS ISPEXEC \"VPUT \" ACID \"PROFILE\"\n    SECRC = \"VARIABLE\" ACID\" TEMPORARILY RESET IN CURRENT PROFILE.\"\n    SIGNAL GOTMSG\n  END\n  IF SUBSTR(OPT,1,1) = \".\" THEN  DO\n    INDEX = SUBSTR(OPT,2)\n    ADDRESS ISPEXEC \"TBTOP \"SCRTABLE\n    ADDRESS ISPEXEC \"TBVCLEAR \"SCRTABLE\n    INDEX1 = SUBSTR(INDEX,1,1)\n    INDEX2 = SUBSTR(INDEX,2)\n    UPPER INDEX1\n    FNAME = INDEX1||INDEX2\n    ADDRESS ISPEXEC \"VPUT FNAME\"\n    CALL OFF ERROR\n    ADDRESS ISPEXEC \"TBSCAN \"SCRTABLE\" ARGLIST(FNAME) CONDLIST(GE)\"\n    RCODE1 = RC\n    SCAN = \"YES\"\n    Y = 0\n    OPT     = \" \"\n    IF RCODE1 = 8 THEN DO\n      secrc = \"Entry not found, or blanks exist in screen table\"\n      SAY \"*********************************************************\"\n      SAY \"SCREEN TABLE SCAN FAILED CHECK THAT SCREEN TABLE DOES NOT\"\n      SAY \"HAVE LEADING BLANKS.                                     \"\n      SAY \"*********************************************************\"\n      signal gotmsg\n    END\n    CALL ON ERROR NAME SHUCKS\n    SIGNAL DISPPNL\n  END\n  IF  AUTHNUM < 4 THEN SIGNAL HUH\n /******************************************************************/\n /*  THE FOLLOWING FUNCTIONS ARE NOT GENERALLY NEEDED EXCEPT FOR   */\n /*  THE MOST POWERFUL ADMINISTRATORS. THIS IS WHY I CHECK AUTHNUM */\n /*  THIS ALLOWS THE FOLLOWING FUNCTIONS TO BE  EXECUTED FROM      */\n /*  THE TEST MENU........DAVE 20 MAY 91                           */\n /******************************************************************/\n  IF OPT = \"CLEARMSG\"  THEN  DO\n    CLEARMSG = \"YES\"\n    ADDRESS ISPEXEC \"VPUT CLEARMSG PROFILE\"\n    MSG2 = \" \"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    SECRC  = \" MESSAGE AREAS CLEARED, MESSAGE OPTIONS RESET \"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"SUB\") &  (MODE = \"BATCH\") THEN  DO\n    BJCL.1 =  \"@@\"\n    ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n    ADDRESS TSO \"FREE DDN(BJCL)\"\n    BOPEN= NO\n    ADDRESS TSO \"SUBMIT \" DS5\n    MSG2= \"NOTE: YOU ARE IN ONLINE MODE, CMDS ARE ISSUED REAL TIME.\"\n    CLEARMSG=YES\n    MODE= \"ONLINE\"\n    SECRC= \"BATCH STREAM SUBMITTED FROM \"DS5\". MODE CHANGE COMPLETE.\"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"SUB\") & (MODE = \"ONLINE\") THEN  DO\n    SECRC= \"THE SUB OPTION IS VALID ONLY IN BATCH MODE.\"\n    SECRC=  SECRC\" OPTION IGNORED\"\n    SIGNAL GOTMSG\n  END\n  IF (OPT = \"BATCH\") & (MODE < > \"BATCH\") THEN  DO\n    ADDRESS TSO \"%\"TVER\"JCARD\" DS5 \"RANDOM\"\n    IF  RC = 16 THEN  DO\n      SECRC=\"MODE CHANGE FAILED.\"\n      SIGNAL GOTMSG\n    END\n    ADDRESS TSO \" ALLOC DDN(BJCL) DSN(\" DS5\") MOD REUS\"\n    BOPEN = YES\n    MSG2= \"NOTE: YOU ARE IN BATCH MODE, MOST CMDS ARE DEFERRED \"\n    MSG2=   MSG2 \"UNTIL MODE IS CHANGED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    CLEARMSG=NO\n    MODE = \"BATCH\"\n    SECRC= \"MODE CHANGE COMPLETE. JCL WILL BE IN \"DS5\".\"\n    SIGNAL GOTMSG\n  END\n  IF  (OPT = \"ONLINE\") & (MODE < > \"ONLINE\") THEN  DO\n    BJCL.1 = \"@@\"\n    ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n    ADDRESS TSO \" FREE DDN(BJCL)\"\n    BOPEN= NO\n    MSG2= \"NOTE: YOU ARE IN ONLINE MODE CMDS ARE ISSUED REAL TIME.\"\n    CLEARMSG=YES\n    MODE= \"ONLINE\"\n    SECRC= \"MODE CHANGE COMPLETE. JCL NOT SUBMITTED, IS IN \"DS5\".\"\n    SIGNAL GOTMSG\n  END\n  IF  (OPT = \"ONLINE\") & (MODE = \"ONLINE\") THEN  DO\n    MSG2= \"NOTE: MODE IS UNCHANGED.\"\n    CLEARMSG=YES\n    MODE= \"ONLINE\"\n    SECRC= \"NO CHANGES MADE. MODE WAS AND IS STILL ONLINE.\"\n    SIGNAL GOTMSG\n  END\n  IF  OPT = \"CMDO\" THEN  DO\n  /*OTT = OUTTRAP(ZZT,0)     TRAP EVERYTHING */\n    DATAAREA =  ACID\n    ARG =  DATAAREA\n   \" ISPEXEC VPUT ARG PROFILE\"\n   ADDRESS TSO \"%\"TVER\"CMDO\" DS1\n    FUNCT= \"CMDOUT\"\n    SIGNAL GETMSG\n  END\n  /***************************************************************/\n  /** THE FOLLOWING OPTIONS USE THE T..TSO ROUTINE FOR CHANGING **/\n  /** THE TOP SECRET TSO DEFINITIONS.  THE T44TSO ROUTINE       **/\n  /** REQUIRES THE FOLLOWING PARMS :  ACTION ACID LPROC ACCTNUM **/\n  /** UNIT SIZE DESPITE THE FACT ALL THESE MAY NOT BE USED FOR  **/\n  /** EACH FUNCTION I PASS THEM ALL EACH TIME AS THEY ARE       **/\n  /** POSITIONALLY DEPENDANT...DIR 2 JUNE 94                    **/\n  /***************************************************************/\n  /***************************************************************/\n  /** THE END OF THE T44TSO AREA                                **/\n  /***************************************************************/\n  IF  OPT = \"DELBOOK\"   THEN  DO\n    MAXCC = 0\n    FUNCT = \"DELBOOK# \"\n    BOOKS = WORDS(DATA)\n    IF DATATYPE(DATA) < > \"NUM\" THEN DO\n      MSG = \" ONE NUMERIC BOOK NUMBER MUST BE GIVEN, RESPECIFY\"\n      CURSOR = \"DATA\"\n      SIGNAL REDO\n    END\n    IF  MODE = \"BATCH\" THEN DO\n      DO X5 = 1 TO BOOKS\n        BOOK = WORD(DATA,X5)\n        BJCL.1 = \"%TSSDBOOK \"ACID DATA\n        ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      END\n      TRACE OFF\n      SIGNAL NOMSG\n    END\n    DO X5 = 1 TO BOOKS\n      BOOK = WORD(DATA,X5)\n      ADDRESS TSO \"%TSSDBOOK \" ACID DATA\n    END\n    /*OTT = OUTTRAP(\"OFF\")     TRAP NOTHING.          */\n    SIGNAL NOMSG\n  END\n  IF  OPT = \"BOOK\"   THEN  DO\n    MAXCC = 0\n    FUNCT = \"BOOK#  \"\n    UNIT= \"IMSDA\"\n    PROC = DATA2\n    IF DATA2 = \" \" THEN\n      PROC = \"SPFLOGON\"\n    IF DATATYPE(WORD(DATA,1)) < > \"NUM\" THEN DO\n      MSG = \" ONE NUMERIC BOOK NUMBER MUST BE GIVEN, RESPECIFY\"\n      CURSOR = \"DATA\"\n      SIGNAL REDO\n    END\n    BOOKS = WORDS(DATA)\n    IF  MODE = \"BATCH\" THEN DO\n      DO X5 = 1 TO BOOKS\n        BOOK = WORD(DATA,X5)\n        BJCL.1 = \"%TSSBOOK \"ACID PROC BOOK\n        ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      END\n      TRACE OFF\n      SIGNAL GETMSG\n    END\n    /* OTT = OUTTRAP(ZZT,0)     TRAP EVERYTHING */\n    DO X5 = 1 TO BOOKS\n      BOOK = WORD(DATA,X5)\n      ADDRESS TSO \"%TSSBOOK \" ACID  PROC BOOK\n    END\n    /*OTT = OUTTRAP(\"OFF\")     TRAP NOTHING.          */\n    SIGNAL GETMSG\n  END\n  IF  OPT = \"POPTEST\" THEN  DO\n    FUNCT =  \"POPTEST\"\n    TITLE  = \"TEST SCREEN TITLE       \"\n    TITLE1 = \"#BOOK TO BE DELETED       \"\n    VNAME1 = \"THIS IS THE BOOK SPOT     \"\n    CALL DISPPOP\n    SAY V1 V2 V3 V4 V5 V6\n  END\n  IF  OPT = \"REPPROF\" THEN  DO\n    FUNCT =  \"REPPROF\"\n    HOLD = NO\n    DATAP = TRANSLATE(DATA,\".\",\" \")\n    IF  MODE = \"BATCH\" THEN  DO\n     BJCL.1 = \"ISPSTART CMD(%\"TVER\"GREP\" ACID DATAP HOLD\") NEWAPPL(TSS)\"\n      ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      SIGNAL NOMSG\n    END\n    ADDRESS TSO \"%\"TVER\"GREP\" ACID DATA HOLD\n    SIGNAL GETMSG\n  END\n  IF  WORD(OPT,1) = \"UP\" THEN        DO\n    WORD2 = WORD(OPT,2)\n    IF DATATYPE(WORD2) = \"NUM\" THEN THISREC = THISREC - WORD2\n    ELSE THISREC = THISREC - 11\n    Y = 0\n    IF THISREC > MAXREC THEN THISREC = MAXREC\n    IF THISREC < 1 THEN THISREC = 1\n    TGT = THISREC + 10\n    OPT     = \" \"\n    SIGNAL DISPPNL\n  END\n  IF  WORD(OPT,1) = \"DOWN\" THEN      DO\n    WORD2 = WORD(OPT,2)\n    IF DATATYPE(WORD2) = \"NUM\" THEN THISREC = THISREC - WORD2\n    ELSE THISREC = THISREC + 11\n    Y = 0\n    IF THISREC > MAXREC THEN THISREC = MAXREC\n    IF THISREC < 1 THEN THISREC = 1\n    TGT = THISREC + 10\n    OPT     = \" \"\n    SIGNAL DISPPNL\n  END\n  IF OPT = \"AD\" THEN OPT = \"ADD\"\n  HUH: NOP\n  SECRC= \"I DID NOT RECOGNIZE THE OPTION YOU ENTERED.\"    OPT\n  SIGNAL GOTMSG\n  GETMSG: NOP\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET MSG2 PROFILE\"\n  SIGNAL GOTMSG\n  NOMSG: NOP\n  SECRC= \"FUNCTION COMPLETED SUCCESSFULLY.\"\n  IF RCODE >  0 THEN\n    SECRC=  \"FUNCTION COMPLETED WITH A RETURN CODE OF\"     RCODE\n  IF RCODE =  8 THEN  DO\n    SECRC=  \"THE ACID ( \"ACID\") IS INVALID\"\n    SECRC=   SECRC \"OR AUTHORIZATION FAILED.\"\n  END\n  GOTMSG: IF (OPT < > \"L\") & (OPT < > \"IN\"),\n    & (MODE < > \"BATCH\") THEN OPT =   \" \"\n  MSG = SECRC\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\" /* IN CASE I SET A MSG */\n  SYSOUTTRAP= TRAPNUM\n  /******************************************************************/\n  /* NOMSG IS THE JUMP TO POINT (JTP) FOR FUNCTIONS THAT  DO NOT    */\n  /* RETURN A MESSAGE IN VAR SECRC. GETMSG IS FOR OTHERS THAT DO    */\n  /*   ......DAVE 9 APRIL 91                                        */\n  /* NOTE THAT YOU MUST SAVE THE RC IN VARIABLE RCODE FOR JTP       */\n  /* NOMSG....DAVE 9 APRIL 91                                       */\n  /******************************************************************/\n  REDO: RCODE=0 /*A JTP TO KEEP OPTION */\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\" /* IN CASE I SET A MSG */\n  MSG =    FUNCT \":\" MSG\nSIGNAL DISPPNL\n/*******************************************************************/\n/** END OF SEQUENTIAL INSTRUCTIONS                                **/\n/*******************************************************************/\nDISPPOP: NOP\nADDRESS ISPEXEC \"ADDPOP POPLOC(OPT) \"\nADDRESS ISPEXEC \"DISPLAY PANEL(SECPOP)\"\nADDRESS ISPEXEC \"REMPOP\"\nRETURN\nSHUCKS: PROCEDURE EXPOSE RC PNL_DISP PANEL MSG SIGL DEFPNL RCODE,\n  BOPEN OPT ACID DS1 DS2 DS3 DS4 DS5 DEF DS6 SECRC TRAP_FLAG,\n  TVER LEAVE CMDTABLE SCRTABLE\n  RCODE = RC\n  IF TRAP_FLAG = \"NO\" THEN\n    SAY \" ERROR ROUTINE HAS BEEN SIGNALED BY LINE\" SIGL\n  IF RCODE = 0 THEN LEAVE = \"YES\"\n  RC = 0\n  \"ISPEXEC VPUT ACID PROFILE\"\n  ERRORL = SIGL\n  PANELRC = 0\n  /* SAY \"LINE # \" ERRORL \"CAUSED AN ERROR\" */\n  IF RCODE = 24 THEN EXIT 24 /* APPL PARM ERROR IN TSSINI */\n  IF RCODE = 8 THEN DO\n    IF PNL_DISP = \"YES\" THEN DO\n      IF PANEL = \"SPIUTIL\" THEN LEAVE = YES\n      IF PANEL = \"SPIUSER\" THEN LEAVE = YES\n      IF PANEL = DEFPNL THEN LEAVE = YES\n    END\n  END\n  PANEL = DEFPNL\n  ADDRESS ISPEXEC \"VPUT PANEL PROFILE\"\n  OPT = \"NIL\"\n  MSG = \"FUNCTION RETURNED A RETURN CODE OF \" RCODE\n  IF RCODE = -3 THEN DO\n    MSG = \"POSSIBLE ENVIRONMENTAL ERROR. CHECK TVER SETTING\"\n    SECRC = \"POSSIBLE ENVIRONMENTAL ERROR. CHECK TVER SETTING\"\n    \"ISPEXEC VPUT SECRC PROFILE\"\n  END\n  IF LEAVE = \"YES\" THEN DO\n    IF BOPEN = \"YES\" THEN DO\n      BJCL.1 =  \"@@\"\n      ADDRESS MVS \"EXECIO 1 DISKW BJCL (FINIS STEM BJCL.)\"\n      ADDRESS TSO \"FREE DDN(BJCL)\"\n      BOPEN = \"NO\"\n    END\n    \"ISPEXEC VPUT TVER PROFILE \"\n    \"ISPEXEC VPUT DS1 PROFILE  \"\n    \"ISPEXEC VPUT DS2 PROFILE  \"\n    \"ISPEXEC VPUT DS3 PROFILE  \"\n    \"ISPEXEC VPUT DS4 PROFILE  \"\n    \"ISPEXEC VPUT DS6 PROFILE  \"\n    \"ISPEXEC VPUT DS5 PROFILE  \"\n    \"ISPEXEC VPUT DEF PROFILE  \"\n    SIGNAL OFF ERROR\n    \"ISPEXEC TBEND \"CMDTABLE\n    \"ISPEXEC TBEND \"SCRTABLE\n     EXIT\n  END\n  RETURN\nNOTABLE: PROCEDURE EXPOSE RC SIGL CMDTABLE SCRTABLE TABLEOPT\n  ERRORL = SIGL\n  SAY \"LINE # \" ERRORL \"INVOKED ERROR RECOVERY\"\n  SAY \"*********************************************************\"\n  SAY \"** FATAL ERROR FATAL ERROR FATAL ERROR FATAL ERROR     **\"\n  SAY \"*********************************************************\"\n  SAY \"TSSUT: AN OPEN WAS ISSUED FOR ONE OR MORE TABLES THAT DO \"\n  SAY \"       NOT EXIST. OR ARE ALREADY OPEN !                  \"\n  SAY \"       USE THE TBMCMD OR TBMSCR TO CREATE TABLES:\"\n  SAY \"       \" CMDTABLE SCRTABLE\n  SAY \"*********************************************************\"\n  IF TABLEOPT= \"PERM\" THEN DO\n    TABLEOPT = \"TEMP\"\n    ADDRESS ISPEXEC \"VPUT TABLEOPT PROFILE\"\n    SAY \"*********************************************************\"\n    SAY \" I AM CHANGING TABLE OPTION TO TEMP, PLEASE REINVOKE     \"\n    SAY \" THE PANEL SYSTEM TO READ   TABLES FROM FLATFILE INPUT.  \"\n    SAY \" CONFIRM THAT YOU ARE CORRECTLY SET UP TO USE PERMANENT  \"\n    SAY \" TABLE INPUTS. THE TABLE NAMES ARE BELOW.                \"\n    SAY \"       \" CMDTABLE SCRTABLE\n    SAY \"*********************************************************\"\n  END\n  EXIT\nNEWINI: PROCEDURE EXPOSE RC SIGL MSG2 CLEARMSG AUTOINIT NEEDINIT RCODE\n  RCODE = RC\n  RC = 0\n  ERRORL = SIGL\n  PANELRC = 0\n  SAY \"LINE # \" ERRORL \"INVOKED ERROR RECOVERY\"\n  IF RCODE = 8 THEN DO\n    MSG2 = \"$$ WARNING: TSSINI VARIABLES NOT FOUND. LINE \" SIGL\n    MSG2 = MSG2 \"A 'REINIT' SHOULD BE ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    CLEARMSG = \"NO\"\n    IF AUTOINIT \u00ac= \"NO\" THEN DO\n      INI = \"NO\"\n      \"ISPEXEC VPUT INI PROFILE\"\n      NEEDINIT = \"YES\"  /* TELL MAIN ROUTINE TO REINIT */\n      MSG2 = \"$$ NOTE: VARIABLES NOT FOUND. TSSINI WAS REINVOKED\"\n      MSG2 = MSG2 \"TO REBUILD YOUR ENVIRONMENT\"\n      ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    END\n  END\n  OPT = \" \"\n  RETURN\nPTR:\n  ARG VALUE\n  RETURN X2C(C2X(STORAGE(D2X(VALUE),4)))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSVERS": {"ttr": 13059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0c\\x008\\x00\\x99\\x08\\x8f\\x01\\x07\\x13O\\x127\\x00-\\x00,\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.12", "flags": 0, "createdate": "1999-03-29T00:00:00", "modifydate": "2007-05-14T12:37:38", "lines": 45, "newlines": 44, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\n TVER = \"T80\"\n SIGNAL ON SYNTAX   NAME SYNERROR\n SIGNAL ON ERROR    NAME GOODBYE\n SIGNAL ON FAILURE  NAME GOODBYE1\n TSSVERS = \"UNABLE TO OBTAIN SPECIFIC VERSION\"\n TT = OUTTRAP('OUTLINE.')\n \"TSS MODIFY VERSION\"\n TSSVERS = SUBSTR(OUTLINE.1,9)\n PARSE VAR TSSVERS  W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12\n DO X = 1 TO 12\n   IF W.X =\"VERSION=4.3\" THEN TVER=\"T43\"\n   IF W.X =\"4.3\" THEN TVER=\"T43\"\n   IF W.X =\"4.4\" THEN TVER=\"T44\"\n   IF W.X =\"4.5\" THEN TVER=\"T45\"\n   IF W.X =\"4.6\" THEN TVER=\"T46\"\n   IF W.X =\"4.7\" THEN TVER=\"T47\"\n   IF W.X =\"5.0\" THEN TVER=\"T50\"\n   IF W.X =\"5.1\" THEN TVER=\"T51\"\n   IF W.X =\"5.2\" THEN TVER=\"T52\"\n   IF W.X =\"5.3\" THEN TVER=\"T53\"\n   IF W.X =\"8.0\" THEN TVER=\"T80\"\n   IF W.X =\"9.0\" THEN TVER=\"T80\"\n   IF W.X =\"VERSION=4.2\" THEN TVER=\"T42\"\n END\n/* SAY TVER*/\nADDRESS ISPEXEC \"VPUT TVER PROFILE  \"\nADDRESS ISPEXEC \"VPUT TSSVERS PROFILE  \"\nEXIT 0\nSYNERROR: ADDRESS ISPEXEC \"VPUT TVER PROFILE  \"\nADDRESS ISPEXEC \"VPUT TSSVERS PROFILE  \"\nSAY \"SYNTAX ERROR IN PROC\"\nEXIT 0\nGOODBYE:  ADDRESS ISPEXEC \"VPUT TVER PROFILE  \"\nADDRESS ISPEXEC \"VPUT TSSVERS PROFILE  \"\n/***********************************/\n/* THIS IS WHERE WE COME IF THE    */\n/* ID CANNOT ISSUE A MODIFY. IT IS */\n/* USUALLY NOT AN ERROR....DIR     */\n/***********************************/\nEXIT 0\nGOODBYE1: ADDRESS ISPEXEC \"VPUT TVER PROFILE  \"\nADDRESS ISPEXEC \"VPUT TSSVERS PROFILE  \"\nSAY \"TSSVERS: A SERIOUS FAILURE HAS OCCURED\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSSWHO": {"ttr": 10775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x01\\x01\\x03&\\x7f\\x01\\x06\\x01\\x1f\\x08\\x02\\x00\\xa7\\x00\\x96\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2003-09-24T00:00:00", "modifydate": "2006-01-11T08:02:01", "lines": 167, "newlines": 150, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\n/* CHECK TSSRWHO EXEC */\nT = 0\nCNT =\nARG RTYPE RNAME DS1 DISP\nIF DISP = \" \" THEN DISP = \"SHR\"\nTHEDSN = TRANSLATE(DS1,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nDS1=STRIP(THEDSN)\nENV = SYSVAR(SYSENV)\nSIGNAL ON ERROR NAME SEEYA\nSAY \"---------------------------------------------------------------\"\nSAY \"TSSWHO: RUNNING. OUTPUT DSN IS \" DS1\n/*****************************************************************/\n/*  THIS EXEC FINDS WHOHAS ACCESS TO A CERTAIN RESOURCE          */\n/*  AND SAYS THE IDS TO THE CALLING ROUTINE.                     */\n/*  THE DSN PARM IS THE DSN TO BE CHECKED                        */\n/*  THE DS1    PARM IS THE OUTPUT DSN.                           */\n/*****************************************************************/\nSAY \"TSSWHO: RNAME = \"RNAME\nHEADER1 = \" $  THE FOLLOWING IDS ARE AUTHORIZED TO\"\nHEADER2 = \" $$ ACCESS  \"RTYPE\"   \" RNAME\nPROFILE MSGID WTPMSG\nQ1 = OUTTRAP(OUT.)\nSIGNAL ON ERROR NAME BADRNAME\nSAY TSO \"TSS WHOHAS \"RTYPE\"(\"RNAME\")\"\nADDRESS TSO \"TSS WHOHAS \"RTYPE\"(\"RNAME\")\"\nSIGNAL ON ERROR NAME SEEYA\nQUEUE HEADER1;QUEUE HEADER2\nQ1 = OUTTRAP(OFF)\nDO X = 1 TO OUT.0\n  T = X + 1\n  W = X + 2\n  NEXTLINE = OUT.T\n  LASTLINE = LINE\n  LINE = OUT.X\n  ACCESS= \"NA\"\n  THE_RNAME = RNAME\n  IF WORD(LINE,1) = \"XAUTH\" THEN THE_RNAME = WORD(LINE,3)\n  IF THE_RNAME = \"**\" THEN ITERATE X\n  IF THE_RNAME = \"***\" THEN ITERATE X\n  IF THE_RNAME = \"****\" THEN ITERATE X\n  IF THE_RNAME = \"*****\" THEN ITERATE X\n  WORD1 = WORD(LINE,1)\n  WORD3 = WORD(LINE,3)\n  IF WORD(LINE,1) = \"XAUTH\" THEN ACCESS  = WORD(NEXTLINE,3)\n  IF ( WORD1 = \"ACTION\" ) & ( WORD3 /= \"FAIL\" ) THEN DO\n     ACT     = \"ACTION(\"WORD3\")\"\n     RNAME.CNT = RNAME.CNT ACT\n  END\n  IF WORD1 = \"FAC\" THEN DO\n    FAC = \"FAC(\"WORD3\")\"\n    RNAME.CNT = RNAME.CNT FAC\n  END\n  IF WORD1 = \"PRIVPGM\" THEN DO\n    PGM = \"PGM(\"WORD3\")\"\n    RNAME.CNT = RNAME.CNT PGM\n  END\n  IF WORD(LINE,1) = \"TSS0300I\" THEN LEAVE\n  IF WORD(LINE,1) = \"TSS300I\" THEN LEAVE\n  IF WORD(NEXTLINE,1) = \"TSS300I\" THEN LEAVE\n  IF WORD(NEXTLINE,1) = \"TSS0300I\" THEN LEAVE\n  Q = POS(\"ACID(\",LINE)\n  IF Q = 0 THEN ITERATE X\n  START = Q + 5\n  STOP  = LASTPOS(\")\",LINE)\n  STOP  = STOP - START\n  ACID = SUBSTR(LINE,START,STOP)\n  CNT = CNT + 1\n  ACID.CNT = ACID\n  RNAME.CNT = THE_RNAME\n  IF ACCESS /= \"NA\" THEN\n    RNAME.CNT = THE_RNAME \" ACCESS(\"ACCESS\")\"\n  FAC = \" \"\n  ACT = \" \"\n  PGM = \" \"\n  ITERATE X\nEND\nQ = OUTTRAP(PROFS.)\n\"TSS LIST(ACIDS) TYPE(PROFILE) DATA(NAME)\"\nDO Y = 1 TO PROFS.0\n  PROFS.Y = WORD(PROFS.Y,3)\nEND\nDO Z = 1 TO CNT\n  DO Z1 = 1 TO PROFS.0\n    IF (ACID.Z = PROFS.Z1) & ((ACID.Z /= \"TECHDEV\"),\n       & (ACID.Z /= \"TELECOM\")) THEN DO\n      Q = OUTTRAP(OUT.)\n      GO = \"NO\"\n      \"TSS LIST(\"ACID.Z\") DATA(ACIDS)\"\n      DO Z2 = 1 TO OUT.0\n        PARSE VAR OUT.Z2 W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n        IF W.1 = \"TSS0300I\" THEN LEAVE\n        IF W.1 = \"TSS300I\" THEN LEAVE\n        IF W.1 = \"ACIDS\" THEN GO = \"YES\"\n        IF GO <> \"YES\" THEN ITERATE Z2\n        DO Z3 = 1 TO 8\n          IF W.Z3 = \"TSS0300I\" THEN ITERATE Z\n          IF W.Z3 = \"ACIDS\" THEN ITERATE Z3\n          IF W.Z3 = \"=\" THEN ITERATE Z3\n          IF W.Z3 = \" \" THEN ITERATE Z3\n          IF W.Z3 = \"-ZC\" THEN ITERATE Z3\n          IF W.Z3 = \"-LC\" THEN ITERATE Z3\n          IF W.Z3 = \"-SC\" THEN ITERATE Z3\n          IF W.Z3 = \"-DC\" THEN ITERATE Z3\n          IF W.Z3 = \"-VC\" THEN ITERATE Z3\n          IF W.Z3 = \"(S)\" THEN ITERATE Z3\n          IF W.Z3 = \"(Z)\" THEN ITERATE Z3\n          IF W.Z3 = \"(L)\" THEN ITERATE Z3\n          IF W.Z3 = \"(V)\" THEN ITERATE Z3\n          IF W.Z3 = \"(D)\" THEN ITERATE Z3\n          W.Z3 = SUBSTR(W.Z3        ,1,8)\n          QUEUE \" \"||W.Z3 \"THRU PROFILE \" ACID.Z||\", TO \"RTYPE RNAME.Z\n        END\n      END\n    /* HERE WE MUST PUT EACH ID WITH THAT PROFILE ON THE STACK*/\n    ITERATE Z\n    END\n  END\n  QUEUE \" \"||ACID.Z \"THRU USER AUTHORITY,    TO\" RTYPE  RNAME.Z\nEND\nACIDNUM = QUEUED()\nQUEUE \"ZZLAST\"\nQUEUE \"\"\n/*                                                */\n/*DO Z = 1 TO ACIDNUM                             */\n/*  PULL ACID                                     */\n/*  Q = OUTTRAP(OUT.,2)                           */\n/*  \"TSS LIST(\"ACID\") DATA(NAME)\"                 */\n/*  PARSE VAR OUT.1 W.1 W.2 W.3 W.4 W.5 W.6       */\n/*  OUTLINE.Z = ACID \"=\" W.6                      */\n/*  Q = OUTTRAP(OFF)                              */\n/*END                                             */\nSIGNAL OFF ERROR\n\"ALLOC DDN(OUT) DSN('\"DS1\"') \"DISP\" REUS\"\n/*\"EXECIO 2 DISKW OUT (STEM HEADER FINIS)\" */\n\"EXECIO \"ACIDNUM\" DISKW OUT (FINIS \"\n\"FREE DDN(OUT)\"\nDELSTACK\nSAY \"TSSWHO: HAS COMPLETED WITH \" ACIDNUM \" LINES OF OUTPUT\"\nSAY \"        IN DATASET \" DS1\nEXIT\nSEEYA: NOP\n   SAY \"AN ERROR HAS OCCURRED IN LINE = :\" SIGL\n   SAY \"TSSWHO HAS COMPLETED WITH ERRORS.\"\nEXIT 1\nBADRNAME: NOP\n   SAY \" \"\n   SAY \"THE RESOURCE YOU HAVE GIVEN ME IS NOT UNDER TOP SECRET CONTROL\"\n   SAY \"OR IS SYNTACTALLY INCORRECT.\"\n   SAY \"TOP SECRET MESSAGES ARE BELOW:\"\n   SAY \"******************************\"\n   SAY OUT.1\n   SAY OUT.2\n   SAY \"******************************\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50ADD": {"ttr": 3099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x11\\x00\\x955/\\x01\\x00\\x07_\\x105\\x01Z\\x01Z\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:35:11", "lines": 346, "newlines": 346, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50ADD                            **/\n/** LAST MODIFIED    : 12 AUG 98                         **/\n/**********************************************************/\n/** CHANGED ACID VARIABLE MANIPULATION SO THAT THE ACID  **/\n/** VARIABLE REMAINS A LITTLE MORE STABLE.               **/\n/**                                .....DIR 19 AUGUST 96 **/\n/**********************************************************/\n/**********************************************************/\n/** ADDED LOGIC TO DETERMINE IF ID HAS DSNS CATLGD IN    **/\n/** MASTER CAT YET HAS NO ALIAS        DIR  11 MAY 95    **/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nSAY \"T50ADD: CONTROL RECEIVED PARMS = \" ACID MODE\nADDRESS ISPEXEC\n\"VGET AUD       PROFILE\"\n\"VGET DEF       PROFILE\"\n\"VGET DS1       PROFILE\"\n\"VGET DS2       PROFILE\"\n\"VGET DS3       PROFILE\"\n\"VGET DS4       PROFILE\"\n\"VGET DS5       PROFILE\"\n\"VGET DS6       PROFILE\"\n\"VGET MSG2      PROFILE\"\n\"VGET PROD      PROFILE\"\n\"VGET TSOSIZE   PROFILE\"\n\"VGET TSOUNIT   PROFILE\"\n\"VGET TSOPROC   PROFILE\"\n\"VGET TVER      PROFILE\"\nSIGNAL OFF ERROR\n/**********************************************************/\n/** below i am checking that the id doesnot have dsns    **/\n/** cataloged to the master catalog. if it does the      **/\n/** user wont be able to catalog his own datasets. this  **/\n/** will cause allocate errors that are hard to track.   **/\n/** i may make this a seperate callable exec but for     **/\n/** now it is included here    dave 11 may 95            **/\n/**********************************************************/\nDATEHOLD = DATE('U')\nMONTHNUM = SUBSTR(DATEHOLD,1,2)\nADDRESS TSO \"%T50GDAT \"ACID \"NAME\"\nOLDID = RC\nBOOK = \"NIL\"\nBOOK1 = \"NIL\"\nSAY \"TSA101D: T50ADD  EXISTANCE CHECK RC IS \" OLDID\nIF OLDID = 0 THEN DO\n  MSG2 = \"THIS ID EXISTS CURRENTLY, READDITION WILL FAIL UPON\",\n  \"EXECUTION\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nADDRESS ISPEXEC \"VGET TSOALIAS PROFILE\"\nIF TSOALIAS = \"YES\" THEN DO\n  ADDRESS TSO \"LISTC ENT('\"ACID\"')\"\n  SAY \"TSA101D: T50ADD  ALIAS CHECK IS \" RC\n  ALIAS_CODE = RC\n  ADDRESS TSO \"LISTC LEVEL('\"ACID\"')\"\n  SAY \"TSA101D: T50ADD  LEVEL CHECK IS \" RC\n  LEVEL_CODE = RC\n  IF (ALIAS_CODE \u00ac= 0) & (LEVEL_CODE =0)  THEN DO\n    MSG2 = \"THE ID HAS NO ALIAS, YET HAS DSNS CATALOGED, EXPECT\",\n    \"SEVERE ALLOCATION ERRORS\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSIGNAL ON ERROR NAME ABORT\n/**********************************************************/\n/** END OF DSN ALIAS / LEVEL CHECKING                    **/\n/**********************************************************/\nLINE.  = \" \"\nALEN   = LENGTH(ACID)\nBILLA  = \"N\"\nCODE   = 0\nCURSOR = \"NAME\"\nDEFINE = \"NAME('\"NAME\"') DEPT(D0000000) TYPE(USER)\"\nFIRST2 = SUBSTR(ACID,1,2)\nGOTDEF = \"NO\"\nLOGON  = TSOPROC\nNDEPT  = FIRST2||\"DEPT\"\nPROF   = \" \"\nPWORD  = \"PASSWORD,60,EXP\"\nSECDEF. = \" \"\nSECRC  = \"T50ADD DID NOT COMPLETE NORMALLY. PLEASE CHECK THE ID.\"\nS2     = ALEN - 1\nTYPE   =  \"USER\"\nWARNED = \"NO\"\n\"VPUT SECRC PROFILE\"\nPW = \"PASSWORD\"\nDPNL   = \"SPIADD\"\nBASIC_ACID = \" \"\nAUDU.0 =   1\nAUDU.1 =   \"%ADDLOCAL\" ACID NDEPT\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"FAC(TSO,BATCH)\"\n/****************************************************/\n/** the tso authority stream is below              **/\n/****************************************************/\n/*                                                                  */\n/*batchtso.0 = 3                                                    */\n/*batchtso.1 = \" \"                                                  */\n/*batchtso.2 = \"ISPSTART CMD(%\"TVER\"TSO DEFAULTS +\"                 */\n/*batchtso.3 = \" \"ACID LOGON BOOK1 TSOUNIT TSOSIZE\") NEWAPPL(TSS)\"  */\n/*onlintso.0 = 1                                                    */\n/*onlintso.1 =\"%\"TVER\"TSO DEFAULTS\" ACID LOGON BOOK1 TSOUNIT TSOSIZE*/\n/*                                                                  */\n/****************************************************/\n/** beginning of the panel loop                    **/\n/** beginning of the panel loop                    **/\n/****************************************************/\nAGAIN: NOP\nCALL FILLSCR\n\"DISPLAY PANEL(\"DPNL\")  CURSOR(\"CURSOR\")\"\nRCODE = RC\nNAME = TRANSLATE(NAME,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSAY \"TSA101D: T50ADD  PANEL RCODE IS \"RCODE\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ERRMSG\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\nGETNAME: NOP\nCNT1 = 0\nNORMAL: NOP\nMEMBER = mem\nIF MEM = \"\" THEN MEMBER = NDEPT\nmem = member\nSAY \"TSA101D: CHECKING FOR DEFAULT DEPT AUTHORITIES\" DEF\"(\"MEMBER\")\"\nIF SYSDSN(\"'\"DEF\"(\"MEMBER\")'\") = \"OK\" THEN DO\n  SAY \"TSA101D: T50ADD  DEFAULT AUTHORITY GROUP FOUND FOR IN \" DEF BIN\n  ADDRESS TSO \"ALLOC DDN(SECDEF) DSN('\"DEF\"(\"member\")') SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR SECDEF ( FINIS STEM SECDEF.)\"\n  ADDRESS TSO \"FREE DDN(SECDEF)\"\n  /******************************************************/\n  /***                                                ***/\n  /*** NOTE: THE FIRST LINE OF THE DSN MUST HAVE A    ***/\n  /*** CREATE PARM IN IT! IF THERE IS NO MEMBER I     ***/\n  /*** ASSIGN A VALUE TO SECDEF.1                     ***/\n  /***                                                ***/\n  /******************************************************/\n  SECDEF.1 = \"NAME('\"NAME\"')\" SECDEF.1\n  GOTDEF = \"YES\"\nEND\nELSE SECDEF.1 = DEFINE /* IF NO MEMBER WE JUST CREATE A 1 LINER */\nDO T = 1 TO 15\n  /******************************************************/\n  /***                                                ***/\n  /*** ONCE HERE THERE HAS TO BE A SECDEF.1 VALUE AND ***/\n  /*** IT HAS IS    COMPRISED OF VALID 'CREATE' PARMS ***/\n  /*** FOR TOP SECRET. THE REST OF THE SECDEF. STRING ***/\n  /*** MAY CONTAIN commands to be issued by the       ***/\n  /*** system sight unseen.                           ***/\n  /******************************************************/\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \" t50add: $$ substitution string found in secdef\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n    say \" t50add: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \" T50ADD: $DEPT$ substitution string found in secdef\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n    say \" T50add: resolved secdef is \"secdef.t\n  end\n  LINE.T =  secdef.t\nEND\nSCRDISP: NOP\nCALL FILLSCR\nMSG=\"CHANGE DEFAULT COMMAND STREAM IF NEEDED AND HIT ENTER.\"\nIF GOTDEF = \"NO\" THEN\n  MSG=\"NO DEFAULT AUTHORITY STREAM FOUND. ENTER COMMANDS.\"\nPNLDISP: NOP\n\"ISPEXEC DISPLAY PANEL(\"DPNL\")\"\nRCODE = RC\nSAY \"T50ADD: PANEL RCODE IS \"RCODE\nIF MEM /= MEMBER THEN SECDEF. = \" \"\nIF MEM /= MEMBER THEN SIGNAL NORMAL\nNAME = SUBSTR(NAME                  ,1,20)\nCALL FILLDOT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ABORT\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\n/******************************************************************/\n/******************************************************************/\nCOMMIT: NOP\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"              \"\nLINE.1 = DEFINE\nDO T1 = 1 TO 15\n  IF LINE.T1 = \" \" THEN OUTCT = T1\n  IF LINE.T1 = \" \" THEN LEAVE\nEND\nIF PW \u00ac= \" \" THEN PWORD = PW||\",45\"\nELSE PW = \"PASSWORD\"\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T50ADD: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1= \"TSS CREATE(\"ACID\")  PASSWORD(\"PWORD\")      +\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  ADDRESS MVS \"EXECIO \"OUTCT\" DISKW BJCL ( FINIS STEM LINE.)\"\n  /**********************************************************/\n  /*ADDRESS MVS,                                               */\n  /* \"EXECIO \"batchtso.0\" DISKW BJCL ( FINIS STEM batchtso.)\"  */\n\n  SAY \"T50ADD: WRITING DATA TO BJCL DDNAME\"\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM AUDU.)\"\n  CODE = RC\n  IF CODE = 0 THEN SECRC =\"BATCH FILE UPDATED WITH ADD COMMANDS.\"\n  SIGNAL OFF ERROR\n  IF RC < > 0 THEN DO\n    MSG2 = \"THE BILLING FILE UPDATE DID NOT COMPLETE NORMALLY.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  SIGNAL BYE1\nEND\nTSSCMD = \"YES\"\nADDRESS TSO\nSAY \"T50ADD: ISSUING THE TSS ADD COMMAND FOR THE ID\"\nSAY \"T50ADD: TSS CREATE(\"ACID\") PASSWORD(\"PWORD\") \" LINE.1\n\"TSS CREATE(\"ACID\") PASSWORD(\"PWORD\") \" LINE.1\nCODE = RC\nSAY \"T50ADD: THE TSS ADD COMMAND FINISHED WITH A RCODE OF \" CODE\nDO T = 2 TO OUTCT\n   say \"t50add: issuing command:\" line.t\n   IF LINE.T < > \" \" THEN\n   ADDRESS TSO \" \"LINE.T\nEND\n/* ADDRESS TSO \"%TSSAUDU \" ACID    */\nSPACES= \"                                                          \"\nSYSDATE = DATE(U)\nBYE:  NOP\nSIGNAL OFF ERROR\nIF  MODE= \"SKIPIT\" THEN DO\n  SAY \"T50ADD: VERSION 5.0 TSO DEFAULTS BEING SET\"\n  BOOK1 = WORD(BOOK,1)\n  rcode = 0\n  do cmdnum = 1 to audu.0\n    say \"t50add: issuing cmd : \"onlintso.cmdnum\n    address tso onlintso.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"t50add: rcode from cmd is \" holdrc\n  end\n  do cmdnum = 1 to audu.0\n    say \"t50add: issuing cmd : \"audu.cmdnum\n    address tso audu.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"t50add: rcode from cmd is \" holdrc\n  end\n  ADDRESS ISPEXEC\n  IF RCODE > 0 THEN DO\n    \"VGET SECRC PROFILE\"\n    MSG2 = \"DEFAULTS TSO SETUP HAS FAILED, CHECK BOOK AUTHORITIES\"\n    \"VPUT MSG2 PROFILE\"\n    SIGNAL BYE1\n  END\n  SAY \"T50ADD: VERSION 5.0 TSO DEFAULTS HAVE BEEN SET\"\nEND\nJUSTUADS: NOP\nCODE = RC\nSIGNAL ON ERROR NAME BADALIAS\n\nif code = 0 then secrc =\"TSA202I: ACID added. no errors encountered.\"\nBYE1:  NOP\nSIGNAL OFF ERROR\nADDRESS ISPEXEC\n\"VPUT SECRC PROFILE\"\n DATAAREA = ACID\n\"VPUT DATAAREA PROFILE\"\nEXIT 0\nERRMSG: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA201E: Errors encountered. check acid status \"\n  SIGNAL BYE1\nBADALIAS: NOP\n  IF CODE = 0 THEN\n    SECRC= \"ALIAS ADDITION FAILED CHECK ACID STATUS \"\n  ELSE SECRC = SECRC \"AND ALIAS ADDITION FAILED\"\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  SIGNAL BYE1\nABORT: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA200E: Function aborted. acid not added.\"\n  SIGNAL BYE1\n/****************************************************************/\n/*  ERROR ROUTINE MESSAGE DISPLAYS.........DIR                  */\n/****************************************************************/\nFILLDOT: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE.1 = LINE1\n  LINE.2 = LINE2\n  LINE.3 = LINE3\n  LINE.4 = LINE4\n  LINE.5 = LINE5\n  LINE.6 = LINE6\n  LINE.7 = LINE7\n  LINE.8 = LINE8\n  LINE.9 = LINE9\n  LINE.10= LINE10\n  LINE.11= LINE11\n  LINE.12= LINE12\n  LINE.13= LINE13\n  LINE.14= LINE14\n  LINE.15= LINE15\nRETURN\nFILLSCR: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE1 = LINE.1\n  LINE2 = LINE.2\n  LINE3 = LINE.3\n  LINE4 = LINE.4\n  LINE5 = LINE.5\n  LINE6 = LINE.6\n  LINE7 = LINE.7\n  LINE8 = LINE.8\n  LINE9 = LINE.9\n  LINE10= LINE.10\n  LINE11= LINE.11\n  LINE12= LINE.12\n  LINE13= LINE.13\n  LINE14= LINE.14\n  LINE15= LINE.15\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50BCON": {"ttr": 3101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00 \\x00\\x955/\\x01\\x00\\x07_\\x105\\x00\\x87\\x00\\x87\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:35:20", "lines": 135, "newlines": 135, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50BCON                           **/\n/** LAST MODIFIED    : 24 SEP 96                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/**********************************************************/\n/** BASE SUPPORT FOR ZCA TYPE ADMINS                     **/\n/**********************************************************/\n/** PASSED ARGS        VALID VALUES                      **/\n/** THESE ARGS ARE ONLY PASSSED ON A LSCA CONVERT        **/\n/** NEWACID : THE NAME THAT THE ACID IS TO BE CHANGED TO **/\n/** NEWTYPE : THE TYPE OF ACID THAT IS TO BE CREATED     **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DS1     : THE DATASET WHEWRE THE INPUT DATA MUST BE  **/\n/** DS2     : THE OUTPUT DATASET                         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES.(NOTE VGET VARIABLES)       **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE                  */\n/**                                                      **/\n/**********************************************************/\nARG NEWACID NEWTYPE\nSIGNAL ON ERROR NAME SEEYA\nSIGNAL ON SYNTAX NAME SYNERR\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nSAY \"T50BCON: TOP SECRET REXX BASIC ACID CONVERSION CLIST ENTERED\"\nNEST = SYSVAR(SYSNEST)\nIF NEST = \"NO\" THEN DO\n  \"ALLOC DDN(OUTFILE) DSN(\" DS2\") MOD REUS\"\n  \"ALLOC DDN(INPUT) DSN(\" DS1\") SHR REUS\"\nEND\n\"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\nOUTFILE. = \" \"\nATTR = \"ATTR\"\nOPID = \" \"\nPWD = \"12345\"\nNEXTREC: DO RECNUM = 1 TO INLINE.0\n  PREVLINE=  INLINE\n  INLINE= SUBSTR(INLINE.RECNUM,1,59)\n  IF INLINE = \"      \" THEN ITERATE\n  PARSE VAR INLINE PAR.1 PAR.2 PAR.3 PAR.4 PAR.5 PAR.6 PAR.7 PAR.8\n  IF (PAR.1 = \"ACCESSORID\") & ( RECNUM > 3 ) THEN DO\n    \"EXECIO 5 DISKW OUTFILE( FINIS STEM OUTFILE.)\"\n    OUTFILE.  = \"         \"\n    ATTR = \"ATTR\"\n    TYPE = \"TYPE\"\n    DEPT = \"DEPT\"\n    NAME = \"NAME\"\n    OPID = \" \"\n    INSTDATA = \"INSTDATA\"\n    ACID = \"ACID\"\n  END\n  IF PAR.1 = \"INSTDATA\" THEN DO\n     NEXT = RECNUM + 1\n/*   INSTDATA =\"'\"||SUBSTR(INLINE.NEXT,1,55)||\"'\"    */\n     INSTDATA =\"'\"||SUBSTR(INLINE,14,65)||\"'\"\n     ITERATE\n  END\n  IF PAR.1 = \"OPIDENT\" THEN OPID = \"OPIDENT(\"PAR.3\")\"\n  IF PAR.3 = \"OPPRTY\" THEN OPID = \" \"\n  IF PAR.1 = \"PASSWORD\" THEN PWD = PAR.3\n  IF PWD   = \"*NOPW*\" THEN PWD = \"NOPW\"\n  IF PAR.3 = \"*NONE*\" THEN ITERATE\n  IF PAR.1 = \"ACCESSORID\" THEN ACID = PAR.3\n  IF NEWACID \u00ac= \" \" THEN ACID = NEWACID\n  IF ACID = \"*STC*\" THEN EXIT 00\n  IF ACID = \"*RDT*\" THEN EXIT 00\n  IF ACID = \"*ALL*\" THEN EXIT 00\n  IF PAR.1 = \"DEPT\" THEN DEPT = PAR.4\n  IF PAR.1 = \"DIV\" THEN DIV = PAR.4\n  IF PAR.1 = \"TYPE\" THEN TYPE = PAR.3\n  IF NEWTYPE \u00ac= \" \" THEN TYPE = NEWTYPE\n  IF PAR.4 = \"NAME\" THEN NAME = STRIP(PAR.6  PAR.7  PAR.8 )\n  IF PAR.1 = \"ATTRIBUTES\" THEN ATTR = PAR.3\n  IF (TYPE = \"DEPT\") & (PAR.4 = \"C/A\") THEN TYPE = \"DCA\"\n  IF (PAR.1 = \"ZONE\") & (PAR.2 = \"ACID\") THEN TZONE = PAR.4\n  IF (TYPE = \"ZONE\") & (PAR.4 = \"C/A\") THEN TYPE= \"ZCA\"\n  IF TYPE = \"LIMITED\" THEN TYPE = \"LSCA\"\n  IF TYPE = \"MASTER\" THEN EXIT\n  PRINTIT: IF TYPE = \"CENTRAL\" THEN TYPE = \"SCA\"\n  IF TYPE = \"DIV\" THEN TYPE = \"VCA\"\n  OUTFILE.  = \"            \"\n  OUTFILE.1 = \" TSS CRE(\"ACID\") NAME('\"NAME\"') TYPE(\"TYPE\") +\"\n  OUTFILE.2 =\"  DEPT(\"DEPT\")  +\"\n  IF TYPE = \"ZONE\" THEN OUTFILE.2 = \" \"\n  IF TYPE = \"VCA\" THEN\n    OUTFILE.2 =\"  DIV(\"DIV\") +\"\n  IF TYPE = \"ZCA\" THEN\n    OUTFILE.2 =\"  ZONE(\"TZONE\") +\"\n  IF TYPE = \"DEPT\" THEN\n    OUTFILE.2 =\"  DIV(\"DIV\") +\"\n  IF (TYPE=\"SCA\") | (TYPE= \"LSCA\") THEN DO\n    OUTFILE.2 =\"  PASSWORD(\"PWD\",30,EXP) +\"\n    IF OPID \u00ac= \" \" THEN\n      OUTFILE.2 = \"  PASSWORD(\"PWD\",30,EXP) \"OPID\" +\"\n    OUTFILE.3 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.3 =\"  INSTDATA(\"INSTDATA\") \"\n    OUTFILE.4 =\"                       \"\n  END\n  IF TYPE=\"PROFILE\" THEN DO\n    OUTFILE.3 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.3 = \"  INSTDATA(\"INSTDATA\") \"\n    OUTFILE.4 = \"                       \"\n    OUTFILE.5 = \"                       \"\n  END\n  IF (TYPE=\"USER\") | (TYPE=\"DCA\") | (TYPE=\"VCA\") THEN DO\n    OUTFILE.3 = \" PASSWORD(\"PWD\",30,EXP) \"OPID\" +\"\n    OUTFILE.4 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.4 =\"  INSTDATA(\"INSTDATA\") \"\n  END\n  IF ATTR <> \"ATTR\" THEN\n    OUTFILE.5 = \" TSS ADD(\"ACID\") \"ATTR\" \"\n  OUTFILE.6 = \"         \"\nEND\n\"EXECIO 5 DISKW OUTFILE( FINIS STEM OUTFILE.)\"\nEXIT 0\nSEEYA: NOP\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON. ERROR IN LINE \" SIGL\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSYNERR: NOP\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON. SYNTAX ERROR LINE \" SIGL\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50BKUP": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x02\\x004\\x00\\x98'_\\x01\\x00\\x07_\\x10S\\x00T\\x00T\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-10-02T00:00:00", "modifydate": "2000-03-15T10:53:34", "lines": 84, "newlines": 84, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ADDED STRIP PROCESSING FOR DSBACK DSN NAME           **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50BKUP                           **/\n/** LAST MODIFIED    : 2  OCT 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :     THE ID YOU WANT BACKED UP              **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DSBACK  : THE DSN TO PUT THE BACKUP IN               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T50GDAT              **/\n/**                                                      **/\n/**********************************************************/\nARG ACID DSBACK\nHEX00 = '00'X\nSYSENV = SYSVAR(SYSENV)\nIF DSBACK = \"\" THEN\n  ADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nSIGNAL ON ERROR NAME SEEYA\nDSBACK = TRANSLATE(DSBACK,\"\",\"'\") /* REMOVE TICS WITH SPACES */\nDSBACK = STRIP(DSBACK)\nSTATUS  = SYSDSN(\"'\"DSBACK\"'\")\nDSBACK = \"'\"DSBACK\"(\"ACID\")'\"\nSAY \"TSA101D: T50BKUP DSBACK IS \"DSBACK\nADDRESS TSO \"%T50GDAT \" ACID \"TYPE\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nTYPE = SECRC\nSAY \"TSA101D: T50BKUP TYPE IS \" TYPE\nSS = OUTTRAP('OUTLINE.')\nDATA=\"ALL,PASSWORD,EXPIRE\"\nSTATUSM = SYSDSN(DSBACK)\nIF (STATUS = \"OK\") & (STATUSM = \"MEMBER NOT FOUND\")  THEN DO\n  SAY \"TSA101D: T50BKUP BACKUP MEMBER WILL BE CREATED.  \"\nEND\nIF (STATUS = \"OK\") & (STATUSM = \"OK\")  THEN DO\n  SAY \"TSA101D: T50BKUP BACKUP MEMBER WILL BE OVERLAYED BY THIS BACKUP.\"\nEND\nIF (STATUS /= \"OK\")  THEN DO\n  SAY \"TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS = \" STATUS\n  SECRC = \"TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS = \" STATUS\n  EXIT 04\nEND\nSAY \"TSA101D: T50BKUP ALLOCATING DSN\" DSBACK\n\"ALLOC DDN(OUTFILE) DSN(\"DSBACK\") SHR REUS\"\nSAY \"TSA101D: T50BKUP  CALLING TSS FOR LIST OF ID \" ACID\nSELECT\n  WHEN TYPE = \"USER\"    THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"MASTER\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"DEPTCA\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"ZONECA\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"DIVCA\"   THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"CENTRAL\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"LIMITED\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"PROFILE\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"GROUP\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  OTHERWISE   \"TSS LIST(ACIDS) \"TYPE\"(\"ACID\")  DATA(\"DATA\")\"\nEND\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n SECRC = \"FUNCTION COMPLETED. BACKUP TAKEN TO  \" DSBACK\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50CMDO": {"ttr": 2839, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00&\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00A\\x00A\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:26", "lines": 65, "newlines": 65, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ISSUE A COMMAND TRAP THE OUTPUT AND ROUTE IT SOMEWERE**/\n/** I ALSO CHANGE ALL HEX 00 TO BLANKS BECAUSE TSS       **/\n/** SOMETIMES RETURNS SOME '00'X VALUES IN ITS UADS AREA **/\n/**********************************************************/\n/** EXEC NAME        : T50CMDO                           **/\n/** LAST MODIFIED    : 16 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSN TO GET THE OUTPUT                  **/\n/** ARG     : THE ACTUAL COMMAND TO BE ISSUED            **/\n/** DISP    : THE DISP TO ALLOCATE THE DATASET WITH      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE HOWEVER THIS    **/\n/**      EXEC COULD BE PASSED ANOTHER EXEC NAME AND      **/\n/**      INVOKE THAT.                                    **/\n/**********************************************************/\nARG DSN cmd\nHEX00 = '00'X\nsecrc = \"TSA509E: Command not processed. check commands validity.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nif cmd = \"\" then\n  ADDRESS ISPEXEC \"VGET ARG PROFILE\"\nelse arg = cmd\nADDRESS ISPEXEC \"VGET DISP PROFILE\"\nQ = OUTTRAP(OUT.)\nT = 1\n\" \"ARG\nRCODE = RC\nDO Z = 1 TO OUT.0\n  IF LENGTH(OUT.Z) > 80 THEN DO\n    OUTLINE.T = SUBSTR(OUT.Z,1,80)\n    T = T + 1\n    OUTLINE.T = SUBSTR(OUT.Z,81)\n    T = T + 1\n    ITERATE Z\n  END\n  OUT.Z=TRANSLATE(OUT.Z,\" \",HEX00)\n  OUTLINE.T = OUT.Z\n  T = T + 1\nEND\nIF DSN = \"SCREEN\" THEN DO\n  T = T - 1\n  DO Q = 1 TO T\n     IF LENGTH(OUTLINE.Q) > 78 THEN OUTLINE.Q = SUBSTR(OUTLINE.Q,1,78)\n     IF OUTLINE.Q <> \" \" THEN SAY OUTLINE.Q\n  END\n  SIGNAL LETSGO\nEND\n\"ALLOC DDN(OUTPUT) DSN(\"DSN\") \"DISP\" REUS\"\n\"EXECIO * DISKW OUTPUT (STEM OUTLINE. FINIS)\"\n\"FREE DDN(OUTPUT)\"\nLETSGO: NOP\nIF RCODE = 0 THEN\n  secrc = \"TSA514I: Command issued output resides in:\" dsn\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50CON": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00G\\x00\\x98#o\\x01\\x00\\x07_\\x10S\\x049\\x049\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-08-24T00:00:00", "modifydate": "2000-03-15T10:53:47", "lines": 1081, "newlines": 1081, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added code to use FDT segment names                  **/\n/**********************************************************/\n/** added code to ignore dept/div/profile passwords      **/\n/**********************************************************/\n/** added more parm based processing                     **/\n/**********************************************************/\n/** added  parm based parsing                            **/\n/**********************************************************/\n/** bypassing iterate error.                             **/\n/**********************************************************/\n/** fixed reformatter error...                           **/\n/**********************************************************/\n/** added omvs support                                   **/\n/**********************************************************/\n/** REMOVED DUPLICATE OUTPUT LINES  SO AS TO STREAMLINE  **/\n/** THE OUTPUT ID...                                     **/\n/**********************************************************/\n/** ADDED SUPPORT FOR LSCA AND SCA JOBCARD CHANGE        **/\n/** SPECIFYING USER=MSCA ON THE JOBCARD.                 **/\n/**********************************************************/\n/** FIXED ADMIN ACID( SUPPORT..                          **/\n/**********************************************************/\n/** REDID THE RDT AREA FOR THE NEW ADDITION SYNTAX       **/\n/**********************************************************/\n/** ADDED SUPPORT FOR TSOOPTION PARM                     **/\n/**********************************************************/\n/** ADDED SUPPORT FOR ZCA DCA VCA CONVERSION             **/\n/**********************************************************/\n/** ADDED MSGS FOR MFAC CONVERSION                       **/\n/**********************************************************/\n/** SUPPORTS RDT AND LINEFORMATTING                      **/\n/**********************************************************/\n/** SUPPORTS TIMES/DAYS/LOCKTIMES                        **/\n/**********************************************************/\n/** THE NEWER STREAMLINED CONVERT FUNCTION.              **/\n/** THE LOGIC SHOULD BE ALOT MORE READABLE ...           **/\n/**********************************************************/\n/** EXEC NAME        : T50CON                            **/\n/** LAST MODIFIED    : 10 aug 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** NEWACID :  THE NAME THE ACID IS TO BE RENAMED TO     **/\n/** NEWTYPE :  THE NEW TYPE OF ACID TO BE CREATED        **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** CONVOPT : THE INTERNAL OUT OPTION \"DATASET\u00a6INTERNAL\" **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS1     : THE INTERIM OUTPUT FILE                    **/\n/** DS2     : THE BATCH FILE                             **/\n/** newpass : THE password to plug into IDs when it cant **/\n/**           be determined                              **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD.    = THE VALID COMMANDS 4 THIS ENT    \"ADD REM\" **/\n/** TYPE.   = THE RESOURCE TYPE                \"DATASET\" **/\n/** ACID.   = THE TARGET ACID FOR EACH CMD     \" ??    \" **/\n/** RSNAME. = THE RESOURCE NAME                \"SYS1.  \" **/\n/** DAYS.   = THE VALID DAYS                   \"MON,TUE\" **/\n/** TIME.   = THE VALID TIMES                  \"08,18  \" **/\n/** ACCESS. = THE ACCESS LEVEL                 \"UPDATE \" **/\n/** ACTION. = THE ACTION TO TAKE               \"FAIL   \" **/\n/** UNTIL.  = THE EXPIRE   DATE OF RULE \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/**********************************************************/\n/** Multi word parm stuff:                               **/\n/**                                                      **/\n/** In ALL below examples t1 has been set to the first   **/\n/** word in the line and t2 has been set to the second.  **/\n/** ( note the 0 prefixed values are always literals )   **/\n/**                                                      **/\n/** MULTI.T1.T2.0PRECMD        The # of commands to be   **/\n/**                      issued prior to value checking  **/\n/**                      This must correspond to the     **/\n/**                      below commands.                 **/\n/** MULTI.T1.T2.0PRECMD.1      Command # 1               **/\n/** MULTI.T1.T2.0PRECMD.2      Command # 2               **/\n/** MULTI.T1.T2.0ITERATE       0 = suffix to prev line   **/\n/**                            1 = make a new line       **/\n/**                                                      **/\n/** SNAME                      The segment for this rule **/\n/**                      to be activated (used below)    **/\n/** MULTI.T1.T2.SNAME          The value \"YES\"           **/\n/** MULTI.T1.T2.0TYPE          The type of resource      **/\n/**                      (example - DSN )                **/\n/** MULTI.T1.T2.0CMD           The tss cmd ( ADD or PER) **/\n/** MULTI.T1.T2.0RSNAME        The TSS resource(example -**/\n/**                      the dataset name)               **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                                                      **/\n/** Single word rules stuff:                             **/\n/**                                                      **/\n/**                                                      **/\n/**  THOLD               The first word on the data line **/\n/**                 that will trigger this rule          **/\n/**                                                      **/\n/**  SNAME               The section name that must match**/\n/**                 the current section for this rule    **/\n/**                                                      **/\n/**  ITERATE.thold.sname  Will I add line(s) to output ? **/\n/**                                                      **/\n/**  ITERATE.thold        How many lines...              **/\n/**                                                      **/\n/**  TYPE.thold           The RDT data type or \"$$\" to   **/\n/**                 bypass command build logic, and build**/\n/**                 your own command                     **/\n/**  CMD.thold           The command add or per or rev.. **/\n/**  RSNAME.thold        The resource name to be used in **/\n/**                  the command or if you specified $$  **/\n/**                  in the type field above, the actual **/\n/**                  rexx interpret command to be issued **/\n/**                                                      **/\n/**                                                      **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS2  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NEWTYPE\nmaint = \"june 4 1999\"\nsay \"T50CON: in control with parms \" acid newacid newtype\nsay \"T50CON: Maint = \" maint\nif acid = \"BYPASS\" then do\n  say \"T50CON: bypass detected other parms ignored.\"\n  newacid = \"\"\n  newtype = \"\"\nend\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50CON. NO OTHER INFORMATION AVAILABLE\"\nIF SYSENV = \"FORE\" THEN DO\n  SECRC = \"FAILED WHILE GETTING VARIABLES FROM ISPPROF\"\n  SECRC = SECRC||\" TRY 'REINIT' OPTION\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET NEWPASS PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS2 PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n  ADDRESS ISPEXEC \"VGET CONVOPT PROFILE\"\nEND\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nCREATE.   =  \"\"\nUNTIL.    =  \"\"\nTYPE.     =  \"\"\nCMD.      =  \"\"\nACCESS.   =  \"\"\nRSNAME.   =  \"\"\nLIBRARY.  =  \"\"\nPRECMD.   =  \"\"\nDAYS.     =  \"\"\nTIME.     =  \"\"\nFACILITY. =  \"\"\nPRIVPGM.  =  \"\"\nACTION.   =  \"\"\nDEPT      =  \"\"\nZONE      =  \"\"\nDIV       =  \"\"\nACID.0    =  ACID\nIF NEWACID /= \"\" THEN ACID.1 = NEWACID\n/********************************/\nCOMMAND.  = \"ADD\"\nSEGMENT   =  \"ADMINISTRATIONAUTHORITIES\"\nCOMMAND.SEGMENT  = \"ADMIN\"\n/********************************/\n/********************************/\n/** LOCK TIME segment          **/\n/** an example of using the    **/\n/** postcmd processor for      **/\n/** value resolution.          **/\n/********************************/\nTLINE                    = \"LOCK TIME\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0PRECMD      = 2\nMULTI.T1.T2.0PRECMD.1    = \"FAC =','w.6\"\nMULTI.T1.T2.0PRECMD.2    = \"IF W.6 = 'ALL' THEN FAC = ''\"\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0POSTCMD     = 3\nMULTI.T1.T2.0POSTCMD.1   = \"TYPE.OUTNUM = '$$'\"\nMULTI.T1.T2.0POSTCMD.2   = \"CMD.OUTNUM = 'ADD'\"\nMULTI.T1.T2.0POSTCMD.3   = \"RSNAME.OUTNUM = 'LTI('W.3||FAC')'\"\n/********************************/\n/** LIST DATA segment          **/\n/********************************/\nTLINE                    = \"LIST DATA\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0TYPE        = \"$$\"\nMULTI.T1.T2.0CMD         = \"'ADMIN'\"\nMULTI.T1.T2.0RSNAME      = \"'DATA('W.3' 'W.4')'\"\n/********************************/\n/** XA DATASET segment         **/\n/********************************/\nTLINE                    = \"XA DATASET\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0TYPE        = \"DSN\"\nMULTI.T1.T2.0CMD         = \"PER\"\nMULTI.T1.T2.0RSNAME      = \"W.3\"\nMULTI.T1.T2.0UNTIL       = \"W.4\"\n/********************************/\n/** single word rules are below**/\n/********************************/\nTHOLD                = \"GROUP\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'GROUP('W.2 w.3 w.4 w.5')'\"\n/********************************/\n/********************************/\nTHOLD                = \"XA\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"W.2\"\nCMD.THOLD            = \"PER\"\nRSNAME.THOLD         = \"W.3\"\nUNTIL.THOLD          = \"W.4\"\n/********************************/\nTHOLD                = \"FACILITIES\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"'FACILITY'\"\nCMD.THOLD            = \"ADMIN\"\nRSNAME.THOLD         = \"W.2 W.3\"\n/********************************/\nTHOLD                = \"ACID\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"'ACID'\"\nCMD.THOLD            = \"ADMIN\"\nRSNAME.THOLD         = \"W.2\"\n/********************************/\nTHOLD                = \"ACCESS\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nSNAME                = \"AUTHORITY\"\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 0\nACCESS.THOLD         = \"'ACCESS('W.2')'\"\n/********************************/\nTHOLD                = \"BYPASSING\"\nSNAME                = \"BASE\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\n                     /*******************************/\n                     /* only one precmd             */\n                     /*******************************/\nPRECMD.THOLD         = 1\nPRECMD.THOLD.1       = 'W.2 = TRANSLATE(W.2,\" \",\",\")'\n                     /*******************************/\n                     /* get rid of commas in auths  */\n                     /*******************************/\nRSNAME.THOLD         = \"W.2\"\n/********************************/\nTHOLD                = \"SITRAN\"\nSNAME                = \"SEGMENTCICS\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'SIT('W.2','W.4')'\"\n/********************************/\nTHOLD                = \"PROFILE\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'PROF('W.2')' W.3 W.4\"\n/********************************/\nTHOLD                = \"PROFILES\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'PROF('W.2 W.3 W.4')'\"\n/********************************/\nSEGMENT   =  \"BASE\"\nIF DISP = \"\" THEN DISP = SHR\nDATA=\"ALL,EXPIRE\"\nSIGNAL OFF ERROR\n  /******************************************************************/\nSECRC = \"FAILED, CHECK IDS EXISTANCE AND YOUR AUTHORITY.\"\nIF ACID  = \"BYPASS\" THEN DO\n  SAY \"T50CON: BYPASS SPECIFIED ALLOCATING INPUT DSN\"\n  \"ALLOC DDN(INPUT) DSN(\"DS1\") REUS\"\n  \"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\n  SS= OUTTRAP('off')\n  IDTYPE = \"USER\"\n  END\nELSE DO\n  say \"T50CON: calling tss for list of id \" acid\n  ADDRESS TSO \"%T50GDAT \"ACID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  IDTYPE = SECRC\n  say \"T50CON: type is \" idtype\n  IF IDTYPE = \"$BADTSS\" THEN DO\n    say \"T50CON: FATAL ERROR. T50GDAT failed TYPE retrieval.\"\n    secrc =\"ID is unlistable check ownership and existance of ID.\"\n    address ispexec \"vput secrc profile\"\n    exit 04\n    END\n  IF CONVOPT = \"DATASET\" THEN DO\n    say \"T50CON: dataset output specified allocating output dsn\"\n    \"%T50LSTO \" ACID \" ALL,EXPIRE\" DS1\n    \"ALLOC DDN(INPUT) DSN(\"DS1\")\"\n    \"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\n    SS= OUTTRAP('off')\n    END\n  ELSE DO\n    say \"T50CON: no id list output being generated, data being \"\n    say \"T50CON: manipulated internally  \"\n    SS = OUTTRAP('INLINE.')\n    SAY \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n    ADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n    SS= OUTTRAP('DROPIT.')\n  END\nEND\nSIGNAL ON ERROR NAME SEEYA\nsay \"T50CON: checking/allocating dsn\" ds2\nJPARM = \"RANDOM\"\n/***************************************************/\n/* PUT THE MSCA ID ON THE JOBCARD IF SCA OR LSCA   */\n/***************************************************/\nIF (IDTYPE = \"LIMITED\") | (IDTYPE = \"CENTRAL\") THEN JPARM = \"SUPER\"\nADDRESS TSO \"%T50JCARD\" DS2 JPARM\n\"ALLOC DDN(BJCL) DSN(\"DS2\") MOD REUS\"\n  /******************************************************************/\nEQUALLOC = INDEX(INLINE.1,\"=\")\nIF EQUALLOC = 0 THEN DO\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"T50CON: ERROR I AM UNABLE TO INITIALIZE THE EQUALLOC VARIABLE\"\n  SAY \"T50CON: THE TSS VERSION 5 DEFAULT OF 11 IS BEING USED        \"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  EQUALLOC = 12\nEND\nEQUALLOC = EQUALLOC - 1\nsay \"T50CON: equal location is \" equalloc\nGOTOUTPUT: NOP\nTHISREC    = 3\nOUTNUM     = 0\nREALOUT    = 0\nCREATE_NUM = 0\nCREATE.0 = 0\nSECRC = \"FAILED, DURING CONVERT LOGIC .\"\nsay \"T50CON: has a total record count of \" inline.0\nDO I = 1 TO INLINE.0\n  REFORMAT = \"NO\"        /* THIS LINE HASNT BEEN CHANGED YET */\n  T2 = I/100\n  /* IF T2 = FORMAT(T2,4,0) THEN SAY I */\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\")  /* REPLACE = WITH SPACES */\n  LINE= TRANSLATE(LINE,\" \",HEX00) /* KILL THOSE HEX 00 */\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  IF WORD(LINE,1) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  IF (INDEX(LINE,\"*ALL*\") <> 0) & (INDEX(LINE,\"VOLUMES\") =0 ) THEN DO\n    PARSE VAR LINE HOLD0 '*ALL*' HOLD1\n    LINE = HOLD0||\"ALL\"||HOLD1\n    say \"T50CON: removing *all* from line\"\n  END\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  FIRST13 = SUBSTR(LINE,1,EQUALLOC)\n  /***********************************/\n  /** DETERMINE THE segment IN CASE **/\n  /** WE NEED IT LATER.  DIR 15AUG97**/\n  /***********************************/\n  IF W.1 = \"ACCESSORID\" THEN segment = \"BASE\"\n  IF W.1 = \"CREATED\" THEN segment =  \"AUTHORITY\"\n  IF (W.1 = \"LAST\") & (W.2 = \"USED\") THEN segment =  \"AUTHORITY\"\n  IF (W.1 = \"PASSWORD\") & (W.2 = \"*NONE*\") THEN ITERATE I\n  IF  W.1 = \"-----------\" THEN segment =  W.2||W.3\n  IF  W.1 = \"-----------\" THEN Say \"T50CON: Segment changed to \"segment\n  CMD_DEFAULT = COMMAND.SEGMENT\n  IF  W.1 = \"-----------\" THEN iterate i\n  /***********************************/\n  /** END OF segment LOGIC          **/\n  /***********************************/\n  IF W.1 = \"ACIDS\" THEN FLUSH = \"YES\"\n  IF W.1 = \"ACIDS\" THEN ITERATE I\n  IF W.2 = \"LIST(ACIDS)\" THEN ITERATE I /* AN ECHO OF THE ISSUED CMD */\n  IF (SUBSTR(LINE,1,4) = \"ACID\"),\n    & (segment /= \"ADMINISTRATIONAUTHORITIES\") THEN ITERATE I\n  IF W.1 = \"***\" THEN ITERATE I\n  IF LINE = \"             \" THEN ITERATE I\n  IF W.3 = \"NAME\" THEN NAME = W.4 W.5 W.6 W.7 W.8\n  IF W.1 = \"TYPE\" THEN TYPE = W.2\n  IF TYPE = \"CENTRAL\" THEN TYPE = \"SCA\"\n  /**************************************************/\n  /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n  /**************************************************/\n  IF W.3 = \"C/A\"  THEN TYPE = SUBSTR(TYPE,1,1)||\"CA\"\n  IF W.3 = \"LIMITED\" THEN TYPE = \"LSCA\"\n  IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.3\n  IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.3\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.3\n  IF W.1 = \"CREATED\" THEN CALL MAKEACID\n  IF W.1 = \"CREATED\"  THEN ITERATE I\n  IF W.1 = \"TYPE\"  THEN ITERATE I\n  IF W.1 = \"DEPT\"  THEN ITERATE I\n  IF W.1 = \"ZONE\"  THEN ITERATE I\n  IF W.1 = \"DIV\"   THEN ITERATE I\n  IF W.1 = \"LAST\"  THEN ITERATE I\n  IF W.1 = \"TSS0300I\"  THEN ITERATE I\n  IF FIRST13 = \"LCF FAC      \" THEN LCFFAC = W.3\n  IF FIRST13 = \"LCF FAC      \" THEN ITERATE I\n  IF FIRST13 \\= \"             \" THEN DO\n    /**********************************************************/\n    /** I SAVE THE LAST TIME THAT THE 13 CHARACTERS EXISTED  **/\n    /** BECAUSE IF THE LINE IS REALLY INDENTED THEN THOSE    **/\n    /** CHARACTERS ARE GOING TO OVERLAYED ON THIS LINE IN    **/\n    /** A DESPERATE ATTEMPT TO FIGURE OUT WHAT TYPE OF       **/\n    /** RESOURCE IS BEING DEALT WITH. DIR 2 APR 97           **/\n    /**********************************************************/\n    SAVE13 = FIRST13\n    FLUSH = \"NO\"\n  END\n  /**********************************************************/\n  /** below is the logic for dropping lines with entries   **/\n  /** we dont need. the most common example is a profiles  **/\n  /** acids segment.             dir 10 aug 98             **/\n  /**********************************************************/\n  IF (SUBSTR(LINE,1,13) = \"             \") & (FLUSH = \"YES\"),\n  THEN DO\n    say \" T50CON: 13 leading blanks found flushing line #: \" i\n    SAY LINE\n    ITERATE I\n  END\n  /**********************************************************/\n  /** BELOW IS THE REFORMATTER AREA. SOME TSS RULES ARE SO **/\n  /** WEIRDLY SETUP I JUST CREATE A $$ TYPE LINE FOR THEM  **/\n  /** OR OTHERWISE CHANGE THEM                             **/\n  /**********************************************************/\n  IF FIRST13 = \"             \" THEN DO\n    NEWLINE = SAVE13 W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n    PARSE VAR NEWLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n    W.8 W.9 W.10 W.11 W.12\n    say \"T50CON: I am reformatting line #\" i \" to the following\"\n    REFORMAT = \"YES\"\n    /************************************************************/\n    /** THE ABOVE FLAG IS SET SO THAT THE BELOW ROUTINES CAN   **/\n    /** DETERMINE IF THE LINE WAS ORIGINALLY BLANK FROM 1-13   **/\n    /** THIS IS A GOOD WAY TO FIND OUT IF YOU HAVE A           **/\n    /** CONTINUATION THAT HAS TO BE DEALT WITH...DIR 9 JULY 97 **/\n    /************************************************************/\n    SAY NEWLINE\n    LINE = NEWLINE\n    IF WORDS(NEWLINE) > 12 THEN DO\n      SAY \"******************************************************\"\n      SAY \"******************************************************\"\n      SAY \"T50CON: TRUNCATION HAS OCCURED IN REFORMATTING        \"\n      SAY \"******************************************************\"\n      SAY \"******************************************************\"\n    END\n  END\n  /*************************************************************/\n  WORD1 = W.1\n  WORD2 = W.2\n  IF MULTI.WORD1.WORD2.segment = \"YES\" THEN DO\n    /* say \"entering dynam routine outnum is :\" outnum   */\n    OUTNUM = OUTNUM + MULTI.WORD1.WORD2.0ITERATE\n    /* say \"after resolution  outnum is :\" outnum   */\n    /* say \"T50CON: multi match on line\" i\" words: \"word1 word2  */\n    /*say \"T50CON: input cmd/rsname values are below\"            */\n    /*say multi.word1.word2.0cmd multi.word1.word2.0rsname       */\n    /****************************************/\n    /* check for precmd value and issue   it*/\n    /****************************************/\n    VALID = DATATYPE(MULTI.WORD1.WORD2.0PRECMD)\n    if valid = \"NUM\" then do cnum = 1 to MULTI.WORD1.WORD2.0PRECMD\n      SAY \"T50CON: precmd issueing:\" MULTI.WORD1.WORD2.0PRECMD.cnum\n      INTERPRET MULTI.WORD1.WORD2.0PRECMD.cnum\n    end\n    /****************************************/\n    /* check for RSNAME value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0RSNAME\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0RSNAME\" THEN DO\n      HOLDVAL = \"RSNAME.OUTNUM  = \" MULTI.WORD1.WORD2.0RSNAME\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for TYPE value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0TYPE\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0TYPE\" THEN DO\n      HOLDVAL = \"TYPE.OUTNUM    = \" MULTI.WORD1.WORD2.0TYPE\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for access value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0ACCESS\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0ACCESS\" THEN DO\n      HOLDVAL = \"ACCESS.OUTNUM  = \" MULTI.WORD1.WORD2.0ACCESS\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for CMD value and resolve it */\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0CMD\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0CMD\" THEN DO\n      HOLDVAL = \"CMD.OUTNUM    = \" MULTI.WORD1.WORD2.0CMD\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for UNTIL value and resolve it */\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0UNTIL\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0UNTIL\" THEN DO\n      HOLDVAL = \"UNTIL.OUTNUM  = \" MULTI.WORD1.WORD2.0UNTIL\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for postcmd value and issue  it*/\n    /****************************************/\n    VALID = DATATYPE(MULTI.WORD1.WORD2.0POSTCMD)\n    IF VALID = \"NUM\" THEN DO CNUM = 1 TO MULTI.WORD1.WORD2.0POSTCMD\n      SAY \"T50CON: Postcmd issueing:\" MULTI.WORD1.WORD2.0POSTCMD.CNUM\n      INTERPRET MULTI.WORD1.WORD2.0POSTCMD.CNUM\n    END\n    SAY \"T50CON: Multi match output for line \"i\" is : \",\n    cmd.outnum type.outnum rsname.outnum access.outnum\n    ITERATE I\n  END\n  IF ITERATE.WORD1.segment = \"YES\" THEN DO\n    /*                                               */\n    /*SAY \"SINGLE LINE=\" W.1 W.2 W.3 W.4 W.5 W.6 W.7 */\n    /*say \"T50CON: segment is \" segment              */\n    /*say \"T50CON: found single match on line \"i\" word: \"WORD1  */\n    OUTNUM = OUTNUM + ITERATE.WORD1\n    if datatype(precmd.word1) = \"NUM\"  then\n      do cnum = 1 to precmd.word1\n      say \"T50CON: precommand \"cnum\" of \"precmd.word1 precmd.word1.cnum\n      interpret precmd.word1.cnum\n    end\n    if rsname.word1 /= \"\" then do\n      holdval = \"rsname.outnum  = \" rsname.word1\n      interpret holdval\n    end\n    if access.word1 /= \"\" then do\n      holdval = \"access.outnum  = \" access.word1\n      interpret holdval\n    end\n    if until.word1 /= \"\" then do\n      holdval = \"until.outnum  = \" until.word1\n      interpret holdval\n    end\n    if cmd.word1 /= \"\" then do\n      holdval = \"cmd.outnum  = \" cmd.word1\n      interpret holdval\n    end\n    if type.word1 /= \"\" then do\n      holdval = \"type.outnum  = \" type.word1\n      interpret holdval\n    end\n    if datatype(postcmd.word1) = \"NUM\" then\n      do cnum = 1 to postcmd.word1\n      say \"T50CON: postcmd \"cnum\" of \"postcmd.word1 postcmd.word1.cnum\n      interpret postcmd.word1.cnum\n    end\n    SAY \"T50CON: Lone  match output for line \"i\" is : \",\n      cmd.outnum type.outnum rsname.outnum access.outnum\n    ITERATE I\n  END\n  /*************************************************************/\n  /*************************************************************/\n  /**  end of dynamic area                                   ***/\n  /*************************************************************/\n  /*************************************************************/\n  IF (W.1 = \"MASTER\") & (W.2 = \"FAC\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"MAS(\"W.3\")\"\n    MSG2 = \"WARNING: THE SOURCE ID (\"ACID\") IS THE MASTERID OF A\",\n    \"FACILITY (\"W.3\").\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMP1 = W.3\",\"W.4\",\"W.5\",\"W.6\n    TEMP1 = STRIP(TEMP1,T,\",\")\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMP1\"))\"\n    CMD_DEFAULT = \"PER\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMP1 = W.3\",\"W.4\",\"W.5\",\"W.6\n    TEMP1 = STRIP(TEMP1,T,\",\")\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMP1\"))\"\n    /* CMD_DEFAULT = \"PER\"  */\n    ITERATE I\n  END\n  /**************************************************/\n  /* THIS IS THE START OF THE RDT                   */\n  /* THIS FUNCTION MAY PRODUCE MORE THAN 80 CHAR    */\n  /* OUTPUT                            DIR 4 APR 97 */\n  /**************************************************/\n  IF ACID  = \"RDT\" THEN DO\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    IF ((W.1 = \"RESOURCE\") & (W.2= \"CLASS\")) | (W.1 = \"TSS0300I\" ),\n    THEN DO\n      OUTNUM = OUTNUM + 1\n      RSNAME.OUTNUM = \"RESCLASS(\"RCLASS\")\",\n      \" RESCODE(\"RCODE\")  \"\n      IF ATTR \u00ac= \"\" THEN DO\n        RSNAME.OUTNUM = RSNAME.OUTNUM||\"ATTR(\"ATTR\") \"\n      END\n      IF ACLIST1 \u00ac= \"\" THEN DO\n        RSNAME.OUTNUM = RSNAME.OUTNUM||\"ACLST(\"ACLIST\",\"ACLIST1\")\"\n      END\n      ELSE DO\n        IF ACLIST \u00ac= \"\" THEN\n          RSNAME.OUTNUM = RSNAME.OUTNUM||\"ACLST(\"ACLIST\")\"\n      END\n      IF RCLASS = \"RCLASS\" THEN OUTNUM = OUTNUM - 1 /* KILL LINE 1 */\n      RCLASS = W.3\n      ATTR= \"\"\n      ACLIST1 = \"\"\n      ACLIST = \"\"\n      DEFACC= \"\"\n    END\n    IF (W.1 = \"RESOURCE\") & (W.2= \"CODE\") THEN\n      RCODE = SUBSTR(W.3,3,2)\n    IF (W.1 = \"ATTRIBUTE\") THEN\n      ATTR = W.2\n    IF (W.1 = \"ACCESS\") & (ACLIST \u00ac= \"\" ) THEN DO\n      W.2= TRANSLATE(W.2,\"\",\")\")   /* REPLACE ) WITH NULLS */\n      W.2= TRANSLATE(W.2,\"=\",\"(\")  /* REPLACE ) WITH = */\n      W.2= TRANSLATE(W.2,\" \",\",\")  /* REPLACE , WITH   */\n      PARSE VAR W.2 T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 T.11 T.12\n      SAY W.2\n      WORDNUM = WORDS(W.2)\n      HOLD1 = T.WORDNUM\n      LOOPNUM = WORDNUM - 1\n      DO Q2 = LOOPNUM TO 1 BY -1\n        HOLD1 = HOLD1||\",\"T.Q2\n      END\n      ACLIST1 = HOLD1\n    END\n    IF (W.1 = \"ACCESS\") & (ACLIST = \" \" ) THEN DO\n      W.2= TRANSLATE(W.2,\"\",\")\")   /* REPLACE ) WITH NULLS */\n      W.2= TRANSLATE(W.2,\"=\",\"(\")  /* REPLACE ) WITH = */\n      W.2= TRANSLATE(W.2,\" \",\",\")  /* REPLACE , WITH   */\n      PARSE VAR W.2 T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 T.11 T.12\n      WORDNUM = WORDS(W.2)\n      HOLD1 = T.WORDNUM\n      LOOPNUM = WORDNUM - 1\n      DO Q2 = LOOPNUM TO 1 BY -1\n        HOLD1 = HOLD1||\",\"T.Q2\n      END\n      ACLIST= HOLD1\n    END\n    IF (W.1 = \"DEFACC\") THEN\n      DEFACC= W.2\n    ITERATE I\n  END\n  /* SAMPLE RDT ADD IS BELOW                                      */\n  /*  TSS ADD(RDT) RESCLASS(BUDGET) RESCODE(30)                   */\n  /*  ATTR(LONG,GENERIC,DEFPROT) -                                */\n  /*  ACLST(ALL,ADD=000E,CHANGE=0006,USE=0002,NONE) DEFACC(NONE)  */\n  /**************************************************/\n  /* THIS IS THE END OF THE RDT AREA                */\n  /**************************************************/\n  IF W.1 = \"DAYS\" THEN DO\n    DAYS.OUTNUM = \"DAYS(\"W.2\")\"\n    IF INDEX(W.3,\"TIMES(\") = 1 THEN\n      TIME.OUTNUM = W.3\n    IF W.2 = \"ALL\" THEN DAYS.OUTNUM = ''\n    /**************************************************/\n    /* IF THE W.3 WORD IS TIMES( THEN THE RULE IS     */\n    /* TIMES( ANY ) . IN THIS CASE JUST ERASE IT.     */\n    /**************************************************/\n    IF W.3 = \"TIMES(\" THEN TIME.OUTNUM = ''\n    ITERATE I\n  END\n  IF W.1 = \"SOURCES\" THEN DO\n    W.1 = \"SOURCE\"\n    CMD_DEFAULT  = \"ADD\"\n  END\n  IF W.1 = \"INSTDATA\" THEN DO\n    OUTNUM = OUTNUM + 1\n  /*********************************************************/\n  /** ONE OF MY CLASSIC DEBUGS IS BELOW                   **/\n  /*SAY \"T50CON: AT  INSTDATA I IS \" I \"OUTNUM IS \" OUTNUM */\n  /*********************************************************/\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"INSTDATA\"\n    RSNAME.OUTNUM =\"'\"||STRIP(SUBSTR(LINE,14,59))||\"'\"\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"INSTDATA\"\n    ITERATE I\n  END\n  IF W.1 = \"ACCESSORID\" THEN DO\n    FLUSH = \"YES\"\n    TEMP = OUTNUM + 1\n    CMD_DEFAULT = \"ADD\"\n    IF W.2 = \"*RDT*\" THEN W.2 = \"RDT\"\n    IF W.2 = \"*STC*\" THEN W.2 = \"STC\"\n    IF W.2 = \"*AUDIT*\" THEN W.2 = \"AUDIT\"\n    ACID = W.2\n    ACID.TEMP   = W.2\n    if newacid /= \"\" then acid.temp = newacid\n    /******************************************************/\n    /** WE CHANGE THE ACID TO SUPPORT AN INPUT STREAM    **/\n    /** WITH MORE THAN ONE LISTED ACID THIS WOULD BE     **/\n    /** USED IF WE HAD A BYPASS PARM TO A LIST(ACIDS) DSN**/\n    /******************************************************/\n    IF ACID = \"*ALL*\" THEN ACID = \"ALL\"\n    IF ACID = \"*STC*\" THEN ACID = \"STC\"\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = \"LIB(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    IF REFORMAT = \"YES\" THEN DO   /* WE HAVE MULTI LINES OF PGMS */\n      LENP = LENGTH(PRIVPGM.OUTNUM) - 1\n      H1 = SUBSTR(PRIVPGM.OUTNUM,1,LENP)\n      PRIVPGM.OUTNUM = H1 STRIP(W.2 W.3 W.4 W.5 W.6)||\")\"\n    END\n    ELSE   /* IF IT IS NOT MULTIPLE LINES OF PGMS */\n      PRIVPGM.OUTNUM = \"PRIVPGM(\"STRIP(W.2 W.3 W.4 W.5 W.6)\")\"\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = \"FAC(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.1 = \"PASSWORD\" THEN DO\n    OUTNUM = OUTNUM  + 1\n    RSNAME.OUTNUM = \"PASSWORD(\"W.2\",90)\"\n    IF W.2 = \"*NOPW*\" THEN\n      RSNAME.OUTNUM = \"PASSWORD(NOPW,0)\"\n    CMD.OUTNUM = \"REP\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    OUTNUM = OUTNUM + 1\n    W.2  = TRANSLATE(W.2,\" \",\",\") /* REPLACE COMMAS WITH SPACES */\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    OUTNUM = OUTNUM + 1\n    W.2  = TRANSLATE(W.2,\" \",\",\") /* REPLACE COMMAS WITH SPACES */\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = \"ACTION(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.3 = \"NAME\" THEN DO\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    ITERATE I\n  END\n  IF ACID = \"STC\" THEN DO\n    IF W.2 = \"SIZE\" THEN ITERATE I\n    OUTNUM = OUTNUM + 1\n    IF W.2 = \"*DEF*\" THEN W.2 = \"DEFAULT\"\n    IF W.5 = \"*FAIL*\" THEN W.4 = \"FAIL\"\n    IF W.5 = \"*DORM*\" THEN W.4 = \"DORM\"\n    IF W.5 = \"*BYPASS*\" THEN W.4 = \"BYPASS\"\n    IF W.5 = \"*WARN*\" THEN W.4 = \"WARN\"\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    RSNAME.OUTNUM = \"PROC(\"W.2\")               \"\n    TEMP1 = SUBSTR(RSNAME.OUTNUM,1,17)\n    RSNAME.OUTNUM = TEMP1 \"ACID(\"W.4\")\"\n    ITERATE I\n  END\n  /**************************/\n  /* MY BABY FALL THRU AREA */\n  /**************************/\n  IF W.2 = \" \" THEN ITERATE\n  IF SUBSTR(LINE,1,2) = \"  \" THEN DO\n    SAY \"************************************************\"\n    SAY \"************************************************\"\n    SAY \"T50CON: UNRECOGNIZED INDENTED LINE # \" I\n    SAY   LINE\n    SAY \"************************************************\"\n    SAY \"************************************************\"\n  END\n  say \"T50CON: fallthru line:\"i\" segment:\" segment \"word1:\"w.1\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM = CMD_DEFAULT\n  /**************************************************/\n  DO XX = 3 TO 8\n    /*SAY XX IS PAR.XX */\n    /**************************************************/\n    /* NOTE THAT BLANKS AND HEX 00S FAIL THE BELOW    */\n    /* CHECK SO THAT SOME COLUMNS THAT ARE ALWAYS IN  */\n    /* IDS BUT ARE SOMETIMES BLANKS ARE NOT NORMALLY  */\n    /* PROCESSED.                 DIR                 */\n    /**************************************************/\n    IF WORDS(W.XX) <> 0 THEN DO\n      say \"T50CON: fallthru routine parsing \"w.xx\n      OUTNUM = OUTNUM + 1\n      RSNAME.OUTNUM = W.XX\n      TYPE.OUTNUM = W.1\n      CMD.OUTNUM = CMD_DEFAULT\n    END\n  END\nEND\nSAY \"T50CON : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/**************************************************/\n/**************************************************/\n/* THE ACTUAL OUTPUT IS CREATED BELOW FROM THE    */\n/* INPUT LINES. SOME FORMATTING IS DONE UNLESS THE*/\n/* THE TYPE VARIABLE IS \"$$\" IN WHICH CASE THE    */\n/* RSNAME VARIABLE IS APPENDED TO THE ID AND      */\n/* COMMAND AND ISSUED WITH NO FORMATTING. THIS    */\n/* ALLOWS THE ABOVE ROUTINES TO PREPROCESS SOME   */\n/* ENTRY TYPES THAT ARE COMPLEX. DIR 2 APR 97     */\n/**************************************************/\n/**************************************************/\nDO X = 1 TO OUTNUM\n  Y  = X + 1          /* IN CASE WE LOOK AT THE NEXT LINE */\n  B4 = X - 1          /* IN CASE WE LOOK AT THE PREVIOUS LINE */\n  IF ACID.X = \"ACID.\"||X THEN ACID.X = ACID.B4\n  REALOUT = REALOUT + 1\n  /**************************************************/\n  /* A STANDARD DSN PERMIT IS BELOW DIR 2 APR 97    */\n  /**************************************************/\n  BATFILE.X = \" TSS \"CMD.X\"(\"ACID.X\") \"TYPE.X\"(\"RSNAME.X\") \"ACCESS.X,\n    UNTIL.X LIBRARY.X FACILITY.X PRIVPGM.X DAYS.X TIME.X ACTION.X\n  /**************************************************/\n  /* A PREFORMATTED COMMAND JUST ISSUE IT           */\n  /**************************************************/\n  IF TYPE.X = \"$$\" THEN\n    BATFILE.X = \" TSS \"CMD.X\"(\"ACID.X\") \"RSNAME.X\n  BATFILE.X = STRIP(BATFILE.X,T)\n  /**************************************************/\n  /* INSTDATA IS HANDLED SPECIAL BECAUSE IT CAN BE  */\n  /* SO LONG IT GETS ITS OWN LINE DIR 2 APR 97      */\n  /**************************************************/\n  IF TYPE.X = \"INSTDATA\" THEN DO\n    SAY \"                       ***********                       \"\n    SAY \"T51: BEGINNING OF INSTDATA PARSING ROUTINE. LINE IS BELOW\"\n    SAY BATFILE.X\n    PARSE VAR BATFILE.X W.1 W.2 W.3 W.4 W.5 W.6 W.7\n    OUTPUT.REALOUT = \" \"W.1 W.2 \"+\"\n    SAY OUTPUT.REALOUT\n    REALOUT = REALOUT + 1\n    OUTPUT.REALOUT = \"    \"STRIP(W.3 W.4 W.5 W.6 W.7)\n    SAY OUTPUT.REALOUT\n    ITERATE X\n  END\n  /**************************************************/\n  /* IF IT IS TOO LONG ILL BREAK IT UP              */\n  /**************************************************/\n  IF LENGTH(BATFILE.X)  > 72 THEN DO\n    say \"T50CON: line too long reformatting for output of 72\"\n    PARSE VAR BATFILE.X W.1 W.2 W.3 W.4 W.5 W.6 W.7\n    OUTPUT.REALOUT = \" \"W.1 W.2 W.3 \"+\"\n    REALOUT = REALOUT + 1\n    OUTPUT.REALOUT = \"    \"STRIP(W.4 W.5 W.6 W.7)\n    IF LENGTH(OUTPUT.REALOUT) > 72 THEN DO\n      say \"T50CON: breaking up data lines.\"\n      say \"T50CON: w4 and w5:\" w.4 w.5\n      say \"T50CON: w6 and w7:\" w.6 w.7\n      OUTPUT.REALOUT = \"    \"W.4 W.5\" +\"\n      REALOUT = REALOUT + 1\n      V4 = \"\"\n      OUTPUT.REALOUT = W.6 \", + \"\n      /***********************************************/\n      /** IF W6 IS MULTIPLE WORDS SEPERATED BY      **/\n      /** COMMAS THEN WE WILL SEPERATE THEM. 30JUL97**/\n      /***********************************************/\n      IF WORDS(TRANSLATE(W.6,\" \",\",\")) >  3 THEN DO\n        PARSE VAR W.6 V1 ',' V2 ',' V3 ',' V4\n        OUTPUT.REALOUT = \"    \"V1\",\"V2\",\"V3\", + \"\n      END\n      REALOUT = REALOUT + 1\n      OUTPUT.REALOUT = \"    \"V4  W.7\n      REALOUT = REALOUT + 1\n      OUTPUT.REALOUT = \"    \"\n    END\n  END\n  ELSE DO\n    OUTPUT.REALOUT = BATFILE.X\n  END\nEND\nLASTCMD = \"DUMMY\"\nDO T2 = 2 TO REALOUT\n  B4 = T2 - 1\n  IF OUTPUT.T2 = LASTCMD THEN DO\n    SAY \"DUPLICATE LINE DROPPED #\" T2 OUTPUT.T2\n    OUTPUT.T2 = \" \"\n  END\n  IF OUTPUT.T2 /= \" \" THEN LASTCMD = OUTPUT.T2\n  /* SAY \"LASTCMD IS \"LASTCMD */\nEND\nSECRC = \"FAILED, DURING OUTPUT RESOLUTION CHECK OUTPUT STREAM.\"\n\"EXECIO \"CREATE.0\" DISKW BJCL ( FINIS STEM CREATE.)\"\nsay \"T50CON: output lines is \" realout\nREALOUT = REALOUT + 1\nOUTPUT.REALOUT = \"@@\"\n\"EXECIO \"REALOUT\" DISKW BJCL ( FINIS STEM OUTPUT.)\"\n\"FREE DDN(BJCL)\"\n SECRC = \"TSA515W: Unsupported function completed. Output in \" DS2\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\nSIGNAL OFF ERROR\nSAY \"T50CON: ERRORL IN LINE \" SIGL\nSAY SOURCELINE(SIGL)\n/* SECRC = \"T50CON: ERROR IN LINE\"  SIGL  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/**********************************************/\n/**********************************************/\n/***** SUBROUTINES SUBROUTINES  ***************/\n/**********************************************/\n/**********************************************/\nMAKEACID: PROCEDURE EXPOSE ACID I INLINE. NAME TYPE DIV DEPT,\n  ZONE OUTNUM CREATE. CREATE_NUM NEWACID NEWTYPE NEWPASS\n/**********************************************/\nIF NEWACID \\= ''  THEN ACID = NEWACID\nIF NEWTYPE \\= ''  THEN TYPE = NEWTYPE\nIF NEWTYPE = \"LSCA\" THEN OWNER = \"OWNER\"\nUSER_FLAG = \"YES\"\nIF TYPE = \"TYPE\" THEN USER_FLAG = \"$$\"\nIF TYPE = \"DIVISION\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"GROUP\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"DIV\" THEN TYPE= \"VCA\"\nIF TYPE = \"DEPT\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"PROFILE\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"ZONE\" THEN USER_FLAG = \"NO\"\nIF ZONE \\= \" \" THEN OWNER = \"ZONE\"\nIF ZONE \\= \" \" THEN AREA = ZONE\nIF DIV  \\= \" \" THEN OWNER = \"DIV\"\nIF DIV  \\= \" \" THEN AREA  =  DIV\nIF DEPT \\= \" \" THEN OWNER = \"DEPT\"\nIF DEPT \\= \" \" THEN AREA  =  DEPT\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \" TSS CRE(\"ACID\") NAME('\"NAME\"') +\"\nIF USER_FLAG = \"YES\" THEN\n  T = \"  \"OWNER\"(\"AREA\")   TYPE(\"TYPE\") PASSWORD(\"NEWPASS\")\"\nELSE\n  T = \"  \"OWNER\"(\"AREA\")   TYPE(\"TYPE\")\"\nIF OWNER = \"OWNER\" THEN T = \"   TYPE(\"TYPE\") PASSWORD(\"NEWPASS\")\"\nIF TYPE = \"DIVISION \"THEN T = \"   TYPE(\"TYPE\")\"\nIF USER_FLAG = \"$$\" THEN DO\n  SAY \"*********************************************************\"\n  SAY \"T50CON: MAKEACID ROUTINE ABORTING DUE TO LACK OF USER TYPE\"\n  SAY \"T50CON: ACID = \"ACID\n  SAY \"*********************************************************\"\n  RETURN\nEND\nDIV = \"\"\nDEPT = \"\"\nZONE = \"\"\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \"  \"T\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \"  \"\nCREATE.0 = CREATE_NUM\nsay \"T50CON: leaving makeacid routine # lines out = \" create.0\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50DEL": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x000\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00O\\x00O\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:30", "lines": 79, "newlines": 79, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50DEL                            **/\n/** LAST MODIFIED    : 17 SEP 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID YOU WISH DELETED.                 **/\n/** MODE    : THE CURRENT MODE \"BATCH\" OR \"ONLINE\"       **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** UIDTABLE : THE GROUP OF 2 CHR NON TSS ID PREFIXES    **/\n/** TVER     : THE CURRENT TSS VERSION VARIABLE          **/\n/** DSBACK   : THE DS WHERE TO TAKE A BACKUP COPY        **/\n/** DS5      : THE DS WHERE TO PUT BATCH SYSIN UPDATES   **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES ( NOTE VGETS )              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T4?LSTO TSSAUDR      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nthiscmd = sysvar(sysicmd)\nSIGNAL OFF ERROR\nsecrc = \"TSA510E: \"Thiscmd\" has ended abnormally.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET TVER PROFILE\"\nADDRESS ISPEXEC \"VGET AUD PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET DS5 PROFILE\"\nUIDENTRY = LENGTH(UIDTABLE)/2\nUIDSTART = 1\nACID2 = SUBSTR(ACID,1,2)\nDSLIST = \"'\"DSBACK\"(\"||ACID||\")'\"\nBJCL.0 = 3\nBJCL.1 = \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\nBJCL.2 = \"TSS DEL( \"ACID\")\"\nBJCL.3 = \"%DELLOCAL\" ACID\nIF MODE = \"BATCH\" THEN DO\n  SAY \"TSA101D: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  ADDRESS MVS \"EXECIO \"BJCL.0\" DISKW BJCL (FINIS STEM BJCL.)\"\n  secrc = \"TSA511I: Batch file updated with delete stream for \" acid\nEND\nIF MODE = \"ONLINE\" THEN DO\n  TOTCODE = 0\n  SIGNAL OFF ERROR\n  SAY \"TSA101D: ONLINE MODE DETECTED. EXECUTING DELETE STREAM\"\n  SECRC = \"DELETE COMMAND STREAM FOR \" ACID \"FLUSHED.\"\n  DO CN = 1 TO BJCL.0\n    HOLD = BJCL.CN\n    SAY ADDRESS TSO \" \"   HOLD\n    ADDRESS TSO \" \"   HOLD\n    TOTCODE = RC + TOTCODE\n  END\n  SECRC = \"COMMAND STREAM FOR \" ACID \"COMPLETED NORMALLY.\"\n  IF TOTCODE > 0 THEN\n  SECRC = \"STREAM HAD PARTIAL FAILURE, CHECK IDS STATUS. CODE=\" TOTCODE\n  IF TOTCODE = 16 THEN\n  SECRC = \"ID MAY NOT EXIST OR YOUR AUTHORITY MAY BE INVALID.\"\n  SAY SECRC\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n\nBADTSS: NOP\nSECRC = \"THE TSS ID YOU SPECIFIED WAS NOT LISTABLE, CHECK THE ID\"\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\nBOOKAUTH: NOP\nSECRC = \"YOU DONT HAVE AUTHORITY TO DELETE AN ID WITH BOOK NUMBER\" BOOK\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50DISC": {"ttr": 287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x006\\x00\\x97 /\\x01\\x00\\x07_\\x10S\\x00o\\x00o\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-03-15T10:53:36", "lines": 111, "newlines": 111, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** TO REMOVE PROFILE FROM ALL THAT HAVE IT              **/\n/**********************************************************/\n/** EXEC NAME        : T50DISC                           **/\n/** LAST MODIFIED    : 06 JUL 97                         **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** MODE    : THE MODE OF OPERATION                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nENV = SYSVAR(SYSENV)\n/**********************************************************/\n/* REMOVE THE BELOW DO IF YOU WANT THIS EXEC TO RUN IN   **/\n/* ONLINE MODE....( YECH !!)                             **/\n/**********************************************************/\nIF (MODE \\= \"BATCH\") & (ENV = \"FORE\") THEN DO\n  SECRC =\"FUNCTION FAILED. DISCONNECT CANNOT BE RUN IN ONLINE MODE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE   \"\n  EXIT 04\nEND\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS ISPEXEC\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS A PROFILE, FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO REMOVE THAT  PROFILE FROM   */\n/* ALL THE IDS THAT HAVE IT ATTACHED.                               */\n/********************************************************************/\nSTARTOUT: NOP\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T50DISC: BATCH MODE DETECTED. USING DDN BJCL AS OUTPUT\"\n  /* ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"   */\nEND\nOUTNUM =  1\n/***********/\nSECRC = \"LIST COMMAND FAILURE, CHECK IDS VALIDITY\"\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(ACIDS)\"\nQ = OUTTRAP(\"OFF\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  IF WORD(INLINE,1) = \"TSS0300I\" THEN\n    SIGNAL OUTSTART\n  IF SUBSTR(INLINE,14,1) = \" \" THEN\n    GOFLAG = NO\n  IF SUBSTR(INLINE,1,5) = \"ACIDS\" THEN\n    GOFLAG=YES\n  IF GOFLAG = YES THEN DO\n    ID.1 = SUBSTR(INLINE,14,8)\n    ID.2 = SUBSTR(INLINE,26,8)\n    ID.3 = SUBSTR(INLINE,38,8)\n    ID.4 = SUBSTR(INLINE,50,8)\n    DO IDCNT = 1 TO 4\n      IF ID.IDCNT = \"*NONE*\" THEN ITERATE X\n      IF ID.IDCNT = \" \" THEN ITERATE X\n      SECRC = \" \"\n    /************************************************************/\n    /************************************************************/\n      SAY \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      IF MODE \\= \"BATCH\" THEN\n        ADDRESS TSO \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      ELSE DO\n        BJCL.OUTNUM = \"TSS REM(\"ID.IDCNT\") PROF(\"ACID\")\"\n        OUTNUM = OUTNUM + 1\n      END\n    END\n  END\nEND\nOUTSTART: NOP\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM BJCL.)\"\n  /*ADDRESS TSO \"FREE DDN(BJCL)\"   */\nEND\nSECRC= \"FUNCTION COMPLETED NORMALLY. \"\nIF MODE = \"BATCH\" THEN\n  SECRC= \"FUNCTION COMPLETED NORMALLY. OUTPUT APPENDED TO BATCH FILE.\"\n  IF SYSVAR(SYSENV) = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nCLOSEEM: NOP\nSAY \"LINE IS \"SIGL\nSAY  SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50DSSIM": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x008\\x00\\x98(_\\x00\\x98(_\\t!\\x00?\\x00?\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-12T00:00:00", "modifydate": "1998-10-12T09:21:38", "lines": 63, "newlines": 63, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"%T50TSSIM\" ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"ALLOC DDN(INFILE) DSN(\"DSOUT\") SHR REUS\"\n ADDRESS MVS \"EXECIO * DISKR INFILE ( FINIS STEM LINE.)\"\n ADDRESS TSO \" FREE DDN(INFILE)\"\n /*SAY \"T50SIM: PARMS:\" ACID RTYPE RNAME FACILITY ACCESS DSOUT */\n SAY \"T50SIM: CHECKING ACCESS FOR\" ACID \"TO\" RNAME \"THRU\" FACILITY\n SAY \"      \"\n DO T = 1 TO LINE.0\n   LINE.T = SUBSTR(LINE.T,1,79)\n   IF (W.2 = \"VOL\") & (W.3 = \"ORIGIN\")  THEN LEAVE\n   PARSE VAR LINE.T  W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n   IF W.1 = \"TSS8379W\" THEN DO\n     SAY \"************************************************\"\n     SAY \"T50SIM: THE INPUT ID IS NOT UNDER YOUR CONTROL.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8362E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T50SIM: THE INPUT ID WAS NOT TSS DEFINED.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8361E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T50SIM: AN INPUT PARAMETER WAS INCORRECT.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8393I\" THEN DO\n     IF INDEX(LINE.T,\"DSN\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T50SIM: THIS ID BYPASSES NORMAL DATASET CHECKS!!\"\n       SAY \"************************************************\"\n     END\n     IF INDEX(LINE.T,\"VOL\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T50SIM: THIS ID BYPASSES NORMAL VOLUME  CHECKS!!\"\n       SAY \"************************************************\"\n     END\n   END\n   IF W.1 = \"TSS8380I\" THEN\n     SAY \"T50SIM: RESOURCE ACCESS WOULD BE GRANTED.\"\n   IF W.1 = \"TSS8381I\" THEN\n     SAY \"T50SIM: RESOURCE ACCESS WOULD BE DENIED.\"\n   IF (W.2 = \"ALLOWED\") & (W.3 = \"ACCESS\")  THEN\n     SAY \"T50SIM: THE ID HAS \"W.5\" ACCESS TO THIS RESOURCE\"\n   IF ( W.1 = \"TSS8394I\" ) & ( W.2 \u00ac= \"VOL\" ) THEN DO\n     PROF = W.6\n     IF W.6 = \"-\" THEN PROF = W.7\n     IF W.6 = \"*USER*\" THEN\n       PROF = \"THE INDIVIDUAL ID DEFINITION FOR\" ACID\n     IF W.6 = \"*ALL*\"  THEN PROF = \"THE SYSTEM ALL RECORD.\"\n     SAY \"T50SIM: THE APPLICABLE RULE IS IN\" PROF\n   END\n   IF W.1 = \"TSS8397I\" THEN SAY \"      \" W.2 W.3 W.4 W.5\n   /* TSS8380I GRANTED  */\n   /* TSS8381I DENIED   */\n END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50FDIV": {"ttr": 275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00E\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x007\\x007\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:45", "lines": 55, "newlines": 55, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50FDIV                           **/\n/** LAST MODIFIED    : 21 JUN 94                         **/\n/**     CONVERTED FROM CLIST TO REXX EXEC                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**       SECRC CAN CONTAIN:                             **/\n/**   THE DIVISION OF THE ACID.                           */\n/**   THE STRING \"LIST FUNCTION FAILED.\" IF THE ID IS BAD.*/\n/**   THE STRING \"PROFILE\"     IF THE ID IS A PROFILE.    */\n/**   THE STRING \"LIMITED\"     IF THE ID IS AN LSCA.      */\n/**   THE STRING \"CENTRAL\"     IF THE ID IS AN SCA.       */\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  NONE                **/\n/**********************************************************/\nARG ACID\nSAY \"T50FDIV: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nSECRC = \"LIST FUNCTION FAILED.\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T50FDIV: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"\nSAY \"T50FDIV: BACK FROM TSS WITH \"INLINE.0 \"LINES OF DATA\"\nDO X = 1 TO INLINE.0\n  INLINE = INLINE.X\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n  TOTWORDS = WORDS(INLINE)\n  IF W.1 = \"TYPE\" THEN  DO\n    SAY \"T50FDIV: TYPE INITIALLY SET TO \"W.3\n    SECRC = W.3\n  END\n  IF SECRC = \"PROFILE\" THEN LEAVE /* THIS IS WHAT HE WANTS TO KNOW  */\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\") THEN  DO\n    SAY \"T50FDIV : DIVISION FOUND, IS \"W.4\n    SECRC = W.4\n  END\nEND\nSAY \"T50FDIV: NORMAL END. FINAL DIVISION IS\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nW.1 = WORD(INLINE.1,1)\nIF W.1 = \"TSS0352E\" THEN SECRC = \"AUTHORIZATION FAILED.\"\nSAY \"T50FDIV : \"INLINE.1\nSAY \"T50FDIV : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T50FDIV : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50FLOC": {"ttr": 277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x06\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x001\\x001\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:06", "lines": 49, "newlines": 49, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** RETURNS THE LOCATION OF A PROFILE IN A USERS PROFILE **/\n/** LIST ... DIR                                         **/\n/**********************************************************/\n/** EXEC NAME        : T50FLOC                           **/\n/** LAST MODIFIED    : 06 MAY 96                         **/\n/**  USES THE NEW T50FLOC  FUNTIONALITY                  **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  ANY TSS ACID                              **/\n/** PROFILE :  ANY TSS ACID THAT IS A PROFILE            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**   NONE                                               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  T50GDAT             **/\n/**                                                      **/\n/**********************************************************/\nARG ACID PROFILE\nSAY \"T50FLOC: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nGOTPRF = \"NO\"\nSECRC = \"ERROR\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T50FLOC: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"%T50GDAT \"ACID\" PROFILES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nPARSE VAR SECRC P.1 P.2 P.3 P.4 P.5 P.6 P.7 P.8 P.9 P.10 P.11 P.12\nNUM = WORDS(SECRC)\nSECRC = 0\nDO W = 1 TO NUM\n  IF PROFILE = P.W THEN SECRC = W\nEND\nSAY \"T50FLOC: POSITION OF \"PROFILE \" IN \" ACID \"IS \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"T50FLOC : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T50FLOC : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50GCMD": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x00\\x01\\x00\\x955/\\x00\\x994O\\x10)\\x00`\\x00`\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1999-12-10T10:29:01", "lines": 96, "newlines": 96, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/*****************************************************************/\n/* added a null line to the output to fix prompt of user         */\n/*****************************************************************/\n/* THIS EXEC WILL CREATE A COMMAND STREAM THAT WILL AFFECT       */\n/* ALL THE ACIDS IN A DEPARTMENT DIVISION OR CONNECTED TO A      */\n/* PROFILE.                                                      */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nARG GROUP DSN1 CMD\nADDRESS ISPEXEC\n\"VGET (ACID DS3 DATA MODE) PROFILE\"\nIF GROUP = \" \" THEN GROUP = ACID\nIF DSN1 = \" \" THEN DSN1  = DS3\nIF CMD = \" \" THEN CMD  = DATA\nSAY \"T50GCMD: CALLING T50JCARD FOR JCL STREAM INITIALIZATION.\"\nADDRESS TSO \"T50JCARD\" DS3\nREPNUM = 0\nLCMD = LENGTH(CMD) - 2\nIF POS(\" $$\",CMD) = LCMD THEN SIGNAL OKTOGO\nIF POS(\" $$ \",CMD) = 0 THEN DO\n  SECRC = \"ERROR: THE STRING ' $$ ' MUST EXIST IN THE COMMAND STRING.\"\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nOKTOGO: NOP\nPARSE VAR CMD W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\nSIGNAL ON ERROR NAME SEEYA\nIF SYSDSN(DSN1) \u00ac= \"OK\" THEN DO\n  SAY \"TSSGCMD: THE OUTPUT DSN YOU HAVE GIVEN ME IS UNAVAILABLE\"\n  EXIT 00\nEND\nDO Z = 1 TO 9\n  IF W.Z = \" $$ \" THEN REPNUM = Z\nEND\nCOUNT_LIM = REPNUM - 1\nDO Z = 1 TO COUNT_LIM\n  IF W.Z = \" $$ \" THEN REPNUM1 = Z\nEND\nQ = OUTTRAP(OUTID.)\nADDRESS TSO\nIF MODE = \"ONLINE\" THEN\n  \"ALLOC DDN(OUT1) DSN(\"DSN1\") REUS MOD\"\nSAY \"T50GCMD: I AM CALLING T50PWHO WITH PARMS:\" GROUP\nSIGNAL OFF ERROR\n\"%T50PWHO\" GROUP\nLIST_CODE = RC\nSIGNAL ON ERROR NAME SEEYA\nsay \"TSA101D: T50GCMD I am back from T50PWHO with return code of \" rc\nsay \"TSA101D: T50GCMD the output of T50PWHO was \"outid.0 \"records.\"\nsay \"TSA101D: T50GCMD I am routing output to \"dsn1\nIF ( OUTID.0 = 0 ) | ( LIST_CODE \\= 0 )  THEN DO\n  msg2 = \"TSA221E: \"\n  msg2 = msg2 \"Failed. stream is incomplete, failure in listing \" group\n  ADDRESS ISPEXEC  \"VPUT MSG2 PROFILE\"\n  queue \"T50222E: I have received no input from T50PWHO\"\n  queue \"         acid may be invalid or authorization may have failed\"\n  ADDRESS ISPEXEC  \"VGET SECRC PROFILE\"\n  QUEUE SECRC\nEND\nDO X = 1 TO OUTID.0\n  PARSE VAR OUTID.X ACID LINE\n  ACID = WORD(OUTID.X,1)\n  if acid = \"TSS0300I\" then iterate x\n  IF ACID = \"ACCESSORID\" THEN ACID= WORD(OUTID.X,3)\n  W.REPNUM = ACID\n  W.REPNUM1 = ACID\n  IF (ACID = \"*\") | (ACID = \"*NONE*\") THEN DO\n    QUEUE LINE\n    ITERATE X\n  END\n  LINE = W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\n  IF LINE \u00ac= \"=\" THEN\n    QUEUE LINE    /* NO BLANK LINES! */\nEND\nQUEUE \" \"\nQUEUE \"@@\"\nqueue\nSIGNAL OFF ERROR\nsecrc = \"TSA223I: group commmand stream placed in dsn \" dsn1\nIF MODE = \"ONLINE\" THEN  DO\n  \"EXECIO * DISKW OUT1 (FINIS)\"\n  \"FREE DDN(OUT1)\"\nEND\nIF MODE = \"BATCH\" THEN DO\n  \"EXECIO * DISKW BJCL (FINIS)\"\n   SECRC = \"COMPLETED. COMMAND STREAM APPENDED TO BATCH FILE \"\nEND\n\"FREE DDN(IN1)\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50GDAT": {"ttr": 279, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x07\\x00\\x97 /\\x01\\x00\\x07_\\x10S\\x00\\x90\\x00\\x90\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-03-15T10:53:07", "lines": 144, "newlines": 144, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T50GDAT                           **/\n/** LAST MODIFIED    : 02 MAY 96                         **/\n/**********************************************************/\n/** ADDED SUPPORT FOR MULTIPLE WORD FIELDS AND THE       **/\n/** SPECIAL REQUIREMENTS OF THE PROFILE FIELD..DR        **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : ANY TSS ACID                               **/\n/** FIELD   : THE TSS FIELD THE CALLER WANTS TO RECEIVE  **/\n/**           BACK                                       **/\n/** DATA    : THE TYPE OF LIST I MUST DO. (NOT REQ)      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** NONE                                                 **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 04 08 16                  **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES (VPUT OF SECRC)             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG ACID FIELD DATA\n/* SAY ACID FIELD DATA */\nHEX00 = '00'X\n/** IF THE FIELD REQUESTED IS ONE THAT NEEDS MULTIPLE    **/\n/** WORDS PASSED BACK TO THE CALLER THEN SET THE MULT.  **/\n/** VARIABLE TO YES BELOW... DIR JAN 97                 **/\nMULT.USED = \"YES\"\nMULT.NAME = \"YES\"\nMULT.PROFILES = \"YES\"\nMULT.BYPASSING = \"YES\"\nMULT.ATTRIBUTES = \"YES\"\n/* SAY \"T50GDAT: HAS CONTROL PARMS \" ACID FIELD DATA */\nGOTIT = \"NO\"\nIF DATA = \" \" THEN DATA = \"BASIC\"\nSIGNAL ON ERROR NAME BADDATA\nQ = OUTTRAP(OUTID.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nSIGNAL ON ERROR NAME SEEYA\nDO X = 1 TO OUTID.0\n  X1 = X+1 ; X2 = X+2 ; X3 = X+3 ; X4 = X+4\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTID.X=TRANSLATE(OUTID.X,\" \",HEX00)\n  PARSE VAR OUTID.X W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12\n  WNUM = WORDS(OUTID.X)\n  DO T = 1 TO WNUM\n    IF WORD(OUTID.X,T) = FIELD THEN DO\n      /* SAY \"T50GDAT: LINE IS \" OUTID.X                 */\n      /*SAY \"T50GDAT: FIELD IS\" FIELD                    */\n      /*SAY \"T50GDAT: GOT IT ON LINE \" X \" WORD \" T      */\n      T1 = T + 1\n      T2 = T + 2\n      T3 = T + 3\n      SECRC = W.T2\n      /* SAY \"T50GDAT: SETTING INITIAL SECRC TO \" SECRC    */\n      IF FIELD = \"DEPT\" THEN SECRC = W.T3\n      IF (FIELD = \"TYPE\") & (W.T3 = \"C/A\") THEN\n        SECRC = SECRC||\"CA\"\n /*   IF FIELD = \"NAME\" THEN */\n /*     SECRC = SECRC  W.T3  */\n      /**************************************************/\n      /** BELOW IS SUPPORT FOR A FIELD THAT HAS MULTIPLE*/\n      /** PARMS, LIKE PROFILES ...DIR 2 MAY 96          */\n      /**************************************************/\n      IF MULT.FIELD = \"YES\" THEN DO\n        IF FIELD = \"PROFILES\" THEN DO\n          /**************************************/\n          /** IF IT IS A PROFILES REQUEST WE   **/\n          /** SCAN AHEAD AND LOAD THE CURRENT  **/\n          /** LINE WITH ALL THE PROFILES IN THE**/\n          /** NEXT 4 LINES, THUS SUPPORTING 5  **/\n          /** FULL LINES OF PROFILES OR 20 OF  **/\n          /** THOSE BUGGARS.   DIR 2 MAY 96    **/\n          /**************************************/\n          /* SAY \"T50GDAT: PROFILE ROUTINE IN CONTROL\"        */\n          NW1 = WORD(OUTID.X1,1)\n          NW2 = WORD(OUTID.X2,1)\n          NW3 = WORD(OUTID.X3,1)\n          NW4 = WORD(OUTID.X4,1)\n          IF NW1 = \"PROFILES\" THEN W.8 = SUBSTR(OUTID.X1,14)\n          IF NW2 = \"PROFILES\" THEN W.9 = SUBSTR(OUTID.X2,14)\n          IF NW3 = \"PROFILES\" THEN W.10 = SUBSTR(OUTID.X3,14)\n          IF NW4 = \"PROFILES\" THEN W.11 = SUBSTR(OUTID.X4,14)\n          /**************************************/\n          /** LETS TELL THE NEXT ROUTINE THERE **/\n          /** ARE MORE WORDS THAN THERE USED TO**/\n          /** BE IN THE CURRENT LINE.DR 2 MAY96*/\n          /**************************************/\n          WNUM = 11\n        END\n        /*SAY \"T50GDAT: MULTIPLE WORD FIELD DETECTED.\"    */\n        /*SAY \"T50GDAT: COUNTING FROM \"T2 \" TO \" WNUM     */\n        ALLDATA = \"\"\n        DO W1 = T2 TO WNUM\n          IF W.W1 = \"=\" THEN LEAVE /* WE HAVE HIT THE NEXT VALUE */\n          ALLDATA = ALLDATA  W.W1\n        END\n        SECRC = ALLDATA\n      END\n      GOTIT = \"YES\"\n    END\n    IF GOTIT = \"YES\" THEN LEAVE\n  END\n  IF GOTIT = \"YES\" THEN LEAVE\nEND\nSIGNAL OFF ERROR\n/*****************************************************************/\n/** NOT FINDING AN INTERVAL MAY BE OK PASS BACK A ZERO.         **/\n/*****************************************************************/\nIF (GOTIT = \"NO\") & (FIELD = \"INTERVAL\") & (DATA \u00ac= \"BASIC\") THEN DO\n  GOTIT = \"YES\"\n  SECRC = 0\nEND\nIF GOTIT = \"YES\" THEN DO\n  /* SAY \"T50GDAT: FIELD \"FIELD\" WAS FOUND. VALUE IS \" SECRC   */\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSECRC = \"$NOTFOUND\"\n/* SAY \"T50GDAT: FIELD \"FIELD\" WAS NOT FOUND. SECRC IS \" SECRC  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nBADDATA: NOP\nSECRC  = \"$BADTSS\"\nSAY \"T50GDAT: ERROR ROUTINE ENTERED, LIST DATA IS\" DATA\nSAY \"T50GDAT: \"ACID FIELD DATA\nIF WORD(OUTID.1,1) = \"TSS0352E\" THEN DO\n  SECRC = \"$BADAUTH\"\n  SAY \"T50GDAT: ID IS NOT OWNED WITHIN SCOPE OF CONTROL\"\nEND\nSAY \"T50GDAT: SECRC IS BEING SET TO \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSEEYA: NOP\nSAY \"T50GDAT: AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50GDEL": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00A\\x00\\x97 /\\x01\\x00\\x07_\\x10S\\x00n\\x00n\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-03-15T10:53:41", "lines": 110, "newlines": 110, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** Creates a batch job that will delete multiple ids    **/\n/** under a department or division, depending on how many**/\n/** times the job is submitted                           **/\n/** submit it once:  Deletes all users and profiles      **/\n/**                  but leaves the departments that     **/\n/**                  had IDs in them.                    **/\n/** submit it twice: Deletes all the newly emptied depts **/\n/** submit it thrice Deletes the dept or division.       **/\n/**********************************************************/\n/** exec name        : T50GDEL                           **/\n/** last modified    : 06 jul 97                         **/\n/**********************************************************/\n/**----------------input required -----------------------**/\n/** passed args        valid values                      **/\n/** acid    : the one to be replaced                     **/\n/** mode    : the mode of operation                      **/\n/** ispf vgets         valid values                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T50GDAT T50pwho      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS ISPEXEC\nIF MODE = \"BATCH\" THEN DO\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nenv = sysvar(sysenv)\nIF MODE \\= \"BATCH\" THEN DO\n  secrc =\"TSA236E: failed. global delete cannot be run in online mode.\"\n  \" VPUT SECRC PROFILE   \"\n  say \"TSA101D: T50GDEL global delete cannot be run in online mode\"\n  EXIT 04\nEND\nSay \"TSA101D: T50GDEL Batch mode detected. using ddname BJCL as output.\"\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS AN ID    , FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO DELETE THOSE IDS            */\n/********************************************************************/\nSTARTOUT: NOP\n/*                                                              */\n/*IF MODE = \"BATCH\" THEN DO                                     */\n/*     ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"        */\n/*END                                                           */\nOUTNUM =  1\n/***********/\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T50PWHO \"ACID \"YES\"\nSAY \"TSA101D: # of lines of output return from TxxPWHO is\" OUT.0\nQ = OUTTRAP(\"XX.\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  SAY strip(INLINE)\n  ID=WORD(INLINE,1)\n  IF WORD(INLINE,1) = \"ACCESSORID\" THEN ID = WORD(INLINE,3)\n  IF ID = TSS0300I THEN LEAVE\n  /************************************************************/\n  /*                                                          */\n  /************************************************************/\n  say \"TSA101D: T50GDEL issuing \" ADDRESS TSO \"%T50GDAT \"ID \" TYPE \"\n  ADDRESS TSO \"%T50GDAT \"ID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  say \"TSA101D: T50GDEL deleting logic for id:\" id \"type:\" type\n  IF MODE = \"ONLINE\" THEN\n    say \"TSA101D: T50GDEL online mode ignored.\"\n    /* ADDRESS TSO \" TSS REMOVE(\"ID\")\" */\n  IF MODE = \"BATCH\" THEN DO\n    IF TYPE = \"PROFILE\" THEN\n      BJCL.OUTNUM = \"ISPSTART CMD(%T50DISC \"ID\")\"\n    IF TYPE = \"PROFILE\" THEN OUTNUM = OUTNUM + 1\n    BJCL.OUTNUM = \"TSS DEL(\"ID\")\"\n    OUTNUM = OUTNUM + 1\n  END\nEND\nOUTSTART: NOP\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nsecrc= \"TSA237I: function completed. output appended to batch file.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nEXIT\n/*************************************/\nCLOSEEM: NOP\nSIGNAL OFF ERROR\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nSAY \"****************************************************\"\nSAY \"LINE IS \"SIGL\nX = SOURCELINE(SIGL)\nSAY X\nSAY  SECRC id type\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50GREP": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x17\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00y\\x00y\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:17", "lines": 121, "newlines": 121, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED ALL LOCATION PROCESSING WITH USE OF AFTER    **/\n/** KEYWORD DIR 2 OCT 97                                 **/\n/**********************************************************/\n/** TO GLOBALLY REPLACE A PROFILE WITH ANOTHER           **/\n/**********************************************************/\n/** EXEC NAME        : T50GREP                           **/\n/** LAST MODIFIED    : 02 OCT 97                         **/\n/**********************************************************/\n/** TOTALLY REWRITTEN TO IMPROVE SPEED BY 1000%          **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** NEWACID : THE ONE TO REPLACE IT WITH                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NOTUSED\nADDRESS ISPEXEC\n\"      VGET DISP PROFILE     \"\n\"      VGET MODE PROFILE     \"\n\"      VGET DS1 PROFILE     \"\n\"      VGET DS2 PROFILE     \"\n\"      VGET DS3 PROFILE     \"\n\"      VGET DS4 PROFILE     \"\n\"      VGET DS5 PROFILE     \"\n\"      VGET DS6 PROFILE     \"\nMYCODE = 0\nTOTAL_RC = 0\nACID = TRANSLATE(ACID,\" \",\".\")\nNEWACIDS = TRANSLATE(NEWACID,\" \",\".\")\nIF INDEX(\" \"NEWACID\" \",\" \"ACID\" \") \\= 0 THEN DO\n  msg2  = \"TSA241W: Warning - cannot replace an ACID with itself.\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE   \"\nEND\nSECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n\"      VPUT SECRC PROFILE   \"\nSIGNAL ON ERROR NAME CLOSEEM\nOUTFILE.0 = 0\nSTARTOUT: NOP\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS3\") \"DISP\" REUS\"\n  ADDRESS TSO \"ALLOC DDN(JCLFILE) DSN(\"DS6\") SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR JCLFILE ( FINIS STEM OUTFILE.)\"\nEND\nOUTNUM = OUTFILE.0 + 1\n/***********/\nQ = OUTTRAP(DROPOUT.)\nSIGNAL OFF ERROR\nDO T1 = 1 TO WORDS(NEWACIDS)\n  LISTACID = WORD(NEWACIDS,T1)\n  ADDRESS TSO \"TSS LIST(\"LISTACID\") DATA(BASIC)\"\n  TOTAL_RC = TOTAL_RC + RC\n  IF TOTAL_RC > 0 THEN BADID = LISTACID\nEND\nIF TOTAL_RC \\=0 THEN DO\n  MSG2 = \"TSA242W: Warning\"\n  msg2 = msg2 badid \" profile was unlistable jcl may not be valid.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T50PWHO \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF SECRC = \"$BADTSS\" THEN DO\n  secrc = \"TSA243E: Aborted.\"\n  secrc = secrc acid\" profile was unlistable. Check validity.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nEND\nSIGNAL ON ERROR NAME CLOSEEM\nQ = OUTTRAP(\"OFF\")\nsay \"TSA101D: Pwho generated \"out.0 \"lines of output .\"\nif out.0 = 0 then do\n  secrc = \"TSA246E: Unable to find attached ACIDs for replace stream\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nend\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  ID = WORD(OUT.X,1)\n  IF ID = \"ACCESSORID\" THEN ID = WORD(OUT.X,3)\n  OUTFILE.OUTNUM =\"TSS ADD(\"ID\") PROFILE(\"NEWACIDS\") AFTER(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\n  OUTFILE.OUTNUM =\"TSS REM(\"ID\") PROFILE(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\nEND\nOUTSTART: NOP\nOUTFILE.OUTNUM = \" \"\nOUTDD = \"OUTFILE\"\nIF MODE = \"BATCH\" THEN OUTDD = \"BJCL\"\nADDRESS MVS \"EXECIO * DISKW \"OUTDD\" ( FINIS STEM OUTFILE.)\"\nSECRC= \"TSA244I: Replace stream generated output in \" DS3\nIF MODE = \"BATCH\" THEN\nsecrc= \"TSA245I: Replace stream appended to batchfile.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\nCLOSEEM: NOP\nSAY \"TSA101D: T50grep error line is \"SIGL\nSAY \"TSA101D: secrc is \"  SECRC\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50ICOMP": {"ttr": 14085, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x1e\\x006\\x00\\x99\\x17/\\x01\\x14\\x17O\\x12S\\x07~\\x07~\\x00\\x00\\xc7\\xd9\\xd7\\xe3\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.30", "flags": 0, "createdate": "1999-06-21T00:00:00", "modifydate": "2014-06-23T12:53:36", "lines": 1918, "newlines": 1918, "modlines": 0, "user": "GRPTDIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** Clone function added        ***************************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T50ICOMP                          **/\n/** LAST MODIFIED    :  6 December  1999                 **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Compare:                                           **/\n/**     This function compare the permission of each ID  **/\n/**     in the acidlist to the first ID specified in the **/\n/**     list.                                            **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Listdup:                                           **/\n/**     List the duplicate permissions in the acids      **/\n/**     specified.                                       **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/** ACIDLIST:  The list of acids to compare              **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T50JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were pased to me   **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/** aciddup.name.0     How many lines of output for below**/\n/** aciddup.name.#     One line for each duplicate       **/\n/**                      keyset that the ID has          **/\n/**                      The type and resource name      **/\n/**                                                      **/\n/** aciddup.name.type.resource.0 = how many dups there   **/\n/**                   for this key set ( there may be    **/\n/**                   seven SYS1. DATASET rules)         **/\n/**                                                      **/\n/** aciddup.name.type.resource.# = The duplicates        **/\n/**                                                      **/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/**                      the acid in name has.           **/\n/**                      segment                         **/\n/**                      restype                         **/\n/**                      resource                        **/\n/**     optional ===>    DUPLICATE                       **/\n/**     optional ===>    subscript                       **/\n/**                                                      **/\n/**     if the literal DUPLICATE appears the data for this*/\n/**      line musts be retrieved from the variable:      **/\n/**        aciddup.name.type.resource.subscript          **/\n/**                                                      **/\n/**     otherwise the data can be retireved from the     **/\n/**      below variable                                  **/\n/**                                                      **/\n/** acidath.name.type.resource                           **/\n/**                    The actual translated data from   **/\n/**                      the TSS list, with all relevant **/\n/**                      data in this one variable.      **/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multi    = \"NO\"\ndebug.convert  = \"YES\"\ndebug.makeacid = \"YES\"\ndebug.balance  = \"NO\"\ndebug.modify   = \"NO\"\ndebug.getdata  = \"NO\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget idebug profile\"\naddress ispexec \"vget MODE profile\"\nif rc = 0 then do\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command. DIR                   **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\nsay \"TSA101D: makeauth check was \" make_rc makeauth\nif make_rc = 0 then do\n  convert.0newid = \"YES\"\n  convert.0name = \" $$ \"\n  makeacid.0auth = \"YES\"\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = \"    %imsalias $$\"\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"ANIDTOTRACE\"              /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Dec 06 1999\"\nsay \"TSA101D: T50ICOMP in control with parms \" function acidlist\nsay \"TSA101D: T50ICOMP Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50ICOMP. NO OTHER INFORMATION AVAILABLE\"\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\nif debug.flow = \"YES\" then\n  say \"TSA101D: Retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    if debug.flow = \"YES\" then\n      say \"TSA101D: calling jobcard function. \"\n    address tso \"%t50jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"TSA101D: Output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nacidath.   =  hex00\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\nHOLD = \"MODIFY\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nBYPASS.0SUPRESS.HOLD.0 = 9\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nHOLD = \"BALANCE\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nBYPASS.0SUPRESS.HOLD.0 = 9\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 2\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 2\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 12\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\nBYPASS.HOLD.7 = \"* ACIDS \"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9 = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.11 = \"* PASSWORD\"\nBYPASS.HOLD.12 = \"AUTHORITY ACID\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 7\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"* LASTUSED\"\nBYPASS.HOLD.6  = \"AUTHORITY ACID\"\nBYPASS.HOLD.7  = \"BASE ZONEACID\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\nif debug.flow = \"YES\" then\n  say \"TSA101D: Basic initialization complete, execution begins.\"\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  say \"TSA101D: Resource processing started\"\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"TSA101D: Bypass option specified, allocating input DSN\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      if debug.resource = \"YES\" then\n        say \"Owner = \" acidnum \"name = \" owner\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      parse var line drop 'ACID(' name ')' drop2\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\"\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      if debug.resource = \"YES\" then\n        say \"acidnum = \" acidnum \"name = \" name\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"TSA101D: Total acids referenced in input is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then   signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"TSA101D: Bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"TSA101D: Total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  acids.0 = words\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we creat   the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Evaluation of TSS generated data begins.\"\nevaluate: nop\ndo num = 1 to acidnum\n  /***********************************************/\n  /**This outer lop is once for each acid passed**/\n  /** to me. Dave 18 June 99                    **/\n  /***********************************************/\n  rules = 0\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"TSA101D: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"         Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    end\n    first11 = substr(line,1,11)\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if debug.trans = \"YES\" then\n        say \"TSA101D:  Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      if debug.trans = \"YES\" then\n       say \"TSA101D: lcf detected:\" w.2\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area input line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n      w.1 = w.1\".\"savefac\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area reformated line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if repeat = \"YES\" then do\n      /***************************************/\n      /** Note the duplicates for each ID   **/\n      /***************************************/\n      hold = acidath.name.prev_type.prev_resource\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: In duplicate loop\",\n          concat prev_type prev_resource hold\n        if debug.trans = \"YES\" then\n          say \"TSA101D: Mult key \"name \"==>\",\n            prev_type prev_resource hold\n      end\n      hold1 = aciddup.name.0\n      hold2 = hold1 + 1\n      aciddup.name.0 = hold2\n      aciddup.name.hold2 = prev_type prev_resource\n      if aciddup.name.hold1 = aciddup.name.hold2 then\n        aciddup.name.0 = hold1\n      zz1 = aciddup.name.0\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: New total for dup array:\" name  aciddup.name.0\n        say \"         array key is:\" aciddup.name.zz1\n      end\n      tz0  = aciddup.name.prev_type.prev_resource.0\n      tz1  = tz0 + 1\n      aciddup.name.prev_type.prev_resource.0  = tz1\n      aciddup.name.prev_type.prev_resource.tz1 = hold\n      duplicat = \"DUPLICATE \"tz1\n      if debug.trans = \"YES\" then  do\n        say \"TSA101D: Mult keys\" prev_type prev_resource \" is now \" tz1\n        say \"         \" name prev_type prev_resource hold duplicat\n      end\n/*                                                                   */\n/*    if aciddup.name.prev_type.prev_resource.tz0 = hold then do     */\n/*      say \"Full duplicate rule found dropping data:\"               */\n/*      say \"  \" prev_type prev_resource hold                        */\n/*      aciddup.name.prev_type.prev_resource.0  = tz0                */\n/*      duplicat = \" \"                                               */\n/*      rules = rules -1                                             */\n/*    end                                                            */\n      acidath.name.type.resource = \"\"\n      /* kill the previous one and prepare to load this one */\n    end\n    if concat = \"YES\" then do\n      hold = acidath.name.type.resource\n      acidath.name.type.resource = strip(hold) strip(line)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T50ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n      /*say \"       \"acidath.name.type.resource  */\n      acidath.name.type.resource.0concat  = \"YES\"\n      hold1 = acidath.name.type.resource.0concat\n      hold = acidath.name.type.resource\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: Concat rule \",\n        \"n=\"name \"t=\"type \"r=\"resource hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.rules = segment type resource duplicat\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidath.name.type.resource = \" \"\n    do t1 = 3 to words\n      hold = acidath.name.type.resource\n      acidath.name.type.resource = strip(hold) strip(w.t1)\n    end\n    if debug.trans = \"YES\" then\n      say \"  Type/res=\" type resource acidath.name.type.resource\n  end\n  acidrul.name.0 = rules\nend\nif debug.flow = \"YES\" then\n  say \"TSA101D: Translation streams have been built.\",\n  \"Starting function check.\"\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter                                     */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif function = \"LISTDUP\" then  do\n  dupnum = 0\n  do x = 1 to acidnum\n    name = acids.x\n    /* say acidnum name  */\n    say \"TSA103I: \"name \"duplicate keysets\" aciddup.name.0\n    do t = 1 to aciddup.name.0\n      type     = strip(word(aciddup.name.t,1))\n      resource = strip(word(aciddup.name.t,2))\n      tz2 = aciddup.name.type.resource.0\n      prime = acidath.name.type.resource\n      say \" \"\n      say \"TSA103I:\"\n      say \" LISTDUP:\"name \"keyset=\" type resource\n      say \" LISTDUP: primary:\" prime\n      dupnum = dupnum + 1\n      listdup.dupnum = \" \"\n      dupnum = dupnum + 1\n      listdup.dupnum = \" LISTDUP:\"name \"keyset=\" type resource\n      dupnum = dupnum + 1\n      listdup.dupnum = \"          primary:\" prime\n      if prime = \" \" then listdup.dupnum = \" \"\n      do cnt = 1 to tz2\n        hold = aciddup.name.type.resource.cnt\n        dupnum = dupnum + 1\n        listdup.dupnum = \"    ACID=\" name type resource hold\n        say listdup.dupnum\n        secrc = \"List duplicates complete.\"\n      end\n      if screen /= \"YES\" then do\n        address tso \"alloc ddn(outds2) dsn(\"ds2\") shr reus\"\n        \"EXECIO \"dupnum\" DISKW outds2 (FINIS STEM listdup.)\"\n        address tso \"free ddn(outds2)\"\n        secrc = \"TSA109I: Complete. Output stream written to \" ds2\n      end\n    end\n    /* call snapshot */\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Permit/rebuild/revoke area in control.\"\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do x = 1 to acidnum\n    name = acids.x\n    say \"TSA101D: Starting to process ACID:\" x \">\"name\"<\"\n    say \"          Rules#:\" acidrul.name.0\n    do t = 1 to acidrul.name.0\n      if debug.flow = \"YES\" then\n        say \"TSA101D: Starting to process \"name \" Rule #\" t\n      if debug.name.t = \"TRACE\" then trace r\n      call getdata t\n      hold = next\n      call convert function hold\n      trace off\n    end\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = acidrul.name.0\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"TSA101D:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: S found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: D found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = strip(word(acidrul.name.y,1))\n        type     = strip(word(acidrul.name.y,2))\n        resource = strip(word(acidrul.name.y,3))\n        acidath.name.type.resource.0flag = \"*DELETE\"\n        acidrul.name.y = segment type resource\n        hold = segment type resource acidath.name.type.resource\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: M found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        if seccode = \"OK\" then do\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          hold = segment type resource acidath.name.type.resource\n          say \"TSA101D:\"\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          /* say  \"back from modify  rsname is \"rsname */\n          acidath.name.type.rsname.0flag  = \"*MODIFY\"\n          acidath.name.type.rsname.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidath.name.type.rsname = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: A found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n     /*                                                          */\n     /* say \"t50icomp:addition routine entered outnum=\" outnum   */\n     /* say \"t50icomp:addition routine entered target=\" target   */\n     /* say \"t50icomp:addition routine entered thisrec=\" thisrec */\n     /* say \"t50icomp:addition routine entered fill=\" fill       */\n        do q = outnum to target by -1\n          q1 = q - 1\n          acidrul.name.q = acidrul.name.q1\n        end\n        modrule.0panel = \"SECUPDT\"\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: Calling modrule\"\n        end\n        call modrule\n        acidath.name.type.rsname.0concat = \"YES\"\n        acidath.name.type.rsname.0flag = \"*NEWRULE\"\n        acidrul.name.fill = segment type rsname\n        acidath.name.type.rsname = modrule.newrs\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"T50101D: leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\nif function = \"BALANCE\" then do\n  call off error\n  name1 = acids.1\n  name2 = acids.2\n  /*********************************/\n  /** below we create a backward  **/\n  /** pointer to the full record  **/\n  /** based  on restype/name      **/\n  /*********************************/\n  do u = 1 to 2\n    daname = acids.u\n    do v = 1 to acidrul.daname.0\n      name = daname\n      call getdata v\n      gtype = getdata.0type\n      gseg  = getdata.0segment\n      gres  = getdata.0resource\n      acidath.daname.gtype.gres.0recnum = v\n    end\n  end\n  balout = 0\n  do b1 = 1 to acidrul.name1.0\n    name = name1\n    bname = name1\n    call getdata b1\n    balout = balout + 1\n    balance.balout = bname b1\n    call getdata b1\n    getdata.debug = \"YES\"\n    gtype = getdata.0type\n    gseg  = getdata.0segment\n    gres  = getdata.0resource\n /* if debug.balance = \"YES\" then\n      say \"TSA101D: comparing \" gtype gres,\n      acidath.name1.gtype.gres  acidath.name2.gtype.gres  */\n    if acidath.name1.gtype.gres = acidath.name2.gtype.gres then do\n  /* say \"SAME\" acidath.name1.gtype.gres   acidath.name2.gtype.gres*/\n      res_value = acidath.name2.gtype.gres\n      balance.name2.gtype.gres.res_value = \"$GOTIT\"\n      bname = \"$BOTH$\"\n      balance.balout = bname b1\n      /* say acidath.name2.gtype.gres.0recnum */\n      balance.balout = balance.balout acidath.name2.gtype.gres.0recnum\n      /* lets not display this one again */\n      if debug.balance = \"YES\" then\n        say \"TSA101D: Values are equal\" balance.balout\n    end\n    if symbol(acidath.name2.gtype.gres) = \"VAR\" then do\n      if debug.balance = \"YES\" then\n        say \"TSA101D: Same rule diff access level found.\" balance.balout\n      balout = balout + 1\n      balance.name2.gtype.gres.res_value = \"$GOTIT\"\n      balance.balout = name2 acidath.name2.gtype.gres.0recnum\n    end\n  end\n  do b2 = 1 to acidrul.name2.0\n    name = name2\n    call getdata b2\n    gtype = getdata.0type\n    gseg  = getdata.0segment\n    gres  = getdata.0resource\n    res_value = acidath.name2.gtype.gres\n    if balance.name2.gtype.gres.res_value = \"$GOTIT\" then iterate b2\n    balout = balout + 1\n    balance.balout = name2 b2\n    /* say \"setting balance to \" balance.balout */\n  end\n  balance.0 = balout\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = balance.0\n  top = 1\n  bot = 2\n  do until bot =  outnum\n    sort.top = word(balance.top,2)\n    sort.bot = word(balance.bot,2)\n    if sort.top > sort.bot then do\n      hold = balance.top\n      balance.top = balance.bot\n      balance.bot = hold\n      top = 0\n      bot = 1\n    end\n    top = top + 1\n    bot = bot + 1\n  end\n  if debug.balance = \"YES\" then do x2 = 1 to balout\n    say \"TSA101D: balance.\"x2 balance.x2\n  end\n  panel_code = 0\n  say \"TSA101D:  balance starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIBLNC)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      balnum = t + thisrec - 1\n      fill_override = word(balance.balnum,2) /* the new fill routine */\n      name = a.t                           /* The acid involved */\n      if f.t  = 'S' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        if name = \"$BOTH$\" then name = acids.1\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = fill_override\n        if name = \"$BOTH$\" then do\n          say \"TSA101D: In duplicate name processing.\"\n          name = acids.1\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          acidath.name.type.resource.0flag = \"*DELETE\"\n          acidrul.name.y = segment type resource\n          hold = segment type resource acidath.name.type.resource\n          call convert \"REVOKE\" hold\n          name = acids.2\n          y = word(balance.balnum,3)\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          acidath.name.type.resource.0flag = \"*DELETE\"\n          acidrul.name.y = segment type resource\n          hold = segment type resource acidath.name.type.resource\n          call convert \"REVOKE\" hold\n        end\n      end\n      if f.t  = 'C' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = fill_override\n        if name = \"$BOTH$\" then do\n          say \"TSA101D: In duplicate name processing.\"\n          name = acids.1\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          acidath.name.type.resource.0flag = \"*DELETE\"\n          acidrul.name.y = segment type resource\n          hold = segment type resource acidath.name.type.resource\n          call convert \"PERMIT\" hold\n          y = word(balance.balnum,3)\n        end\n        segment  = strip(word(acidrul.name.y,1))\n        type     = strip(word(acidrul.name.y,2))\n        resource = strip(word(acidrul.name.y,3))\n        acidath.name.type.resource.0flag = \"*COPIED\"\n        acidrul.name.y = segment type resource\n        hold = segment type resource acidath.name.type.resource\n        Select\n          when name = acids.1 then  name= acids.2\n          when name = acids.2 then  name= acids.1\n          otherwise nop\n        End\n        call convert \"PERMIT\" hold\n      end\n      if f.t  = 'M' then do\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y = fill_override\n        if seccode = \"OK\" then do\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          hold = segment type resource acidath.name.type.resource\n          say \"TSA101D:\"\n          say \"TSA101D:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from balance we use new RSNAME  now */\n          /* say  \"back from balance rsname is \"rsname */\n          acidath.name.type.rsname.0flag  = \"*balance\"\n          acidath.name.type.rsname.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidath.name.type.rsname = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n    end\n  end\n  say \"T50101D: leaving balance\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    call getdata t\n    say next\n  end\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"COMPARE\" then do\n  name = acids.1    /* compare all Ids to the first one */\n  cmpnum = cmpnum + 1\n  compare.cmpnum = \" Comparison of ACIDs \" acidlist\n  cmpnum = cmpnum + 1\n  compare.cmpnum = \"               \"\n  call snapshot\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    resource = word(acidrul.name.t,3)\n    hold = acidath.name.type.resource\n    do cnt = 2 to acidnum\n      otherid = acids.cnt\n      /******************/\n      /*take a snap     */\n      snaphold = name\n      name = otherid\n      call snapshot\n      name = snaphold\n      /******************/\n      hold1 = acidath.otherid.type.resource\n      if hold = hold1 then iterate cnt\n      say \"hold =\" name type resource\n      say \"      \" hold\n      if hold1 = hex00 then hold1 = \"**No rule **\"\n      say \"hold1=\" otherid type resource\n      say \"      \" hold1\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"***********************\"\n      compare.cmpnum = \"** Differences found **\" type resource\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \" \"name  \" ACID data ====>\" hold\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \" \"otherid \" ACID data ====>\" hold1\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"***********************\"\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"  \"\n    end\n  end\n  if screen /= \"YES\" then do\n    \"EXECIO \"cmpnum\" DISKW outds2 (FINIS STEM compare.)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n  end\n  if screen = \"YES\" then do h1 = 1 to cmpnum\n    say compare.cmpnum\n  end\n  address ispexec \"vput secrc profile\"\n  exit 0\nend\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nif debug.makeacid = \"YES\" then\n  say \"TSA101D: Making ACID:\" function\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    if debug.makeacid = \"YES\" then\n      say \"TSA101D: Owner resolved to:\" own_str\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  if debug.makeacid = \"YES\" then\n    say \"TSA101D: Makeacid type for \"name\" is :\" acid_type\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif debug.makeacid = \"YES\" then\nsay \"TSA101D: leaving makeacid # output = \"create_num create.1 create.2\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00,\n  acidath. cvtnum concat lcffac debug. convert.\nparse arg function segment inline\noname = name\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nif debug.flow = \"YES\" then\n  say \"TSA101D: output name for convert is \" oname\nif debug.flow = \"YES\" then\n  say \"TSA101D: Converting for \"name\":\"function segment \">\"||inline||\"<\"\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"XADATASET\") then do\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Input dsn line \"inline\n  inline = \"XADSN\"||substr(inline,10)\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatted dsn line \"inline\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"UID\") then do\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MAS\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"name\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,30)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\nif acidath.name.tchk.resource.0concat = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = acidath.name.type.resource.0concat\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"TSA101D: XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nif debug.convert = \"YES\" then\n  say \"TSA101D: Resource is \"resource \"concat is\" concat\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  if debug.convert = \"YES\" then do\n    rule = bypass.function.rulehold\n    say \"TSA101D: bypass rule tripped, Rule is below:\"\n    say \"     \" Rule\n  end\n  return\nend\noutput = \" TSS \"cmd\"(\"oname\")\"\nif function = \"REVOKE\" then do\n  output = output w.1\"(\"w.2\")\"\nend\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multi = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then\n  say \"TSA101D: convert output is now :\" output\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T50ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\nseeya: nop\nif sysenv = \"FORE\" then do\n  secrc = \"error in line \"sigl\n  address ispexec \"vput secrc profile\"\nend\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. acidath. name hex00 aciddup. debug. balance. function balout\nOPT = \" \"\nif debug.fillscr = \"YES\" then\nsay \"FILLSCR: thisrec=\" thisrec\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nif function = \"BALANCE\" then\n  h1 = balance.0 - 14\nelse\n  h1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\nIF (THISREC > h1 - 14) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nsay \"FILLSCR: thisrec=\" thisrec\nsay \"TSA101D: filling screen:\",\n  \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  if function = \"BALANCE\" then do\n    script = word(balance.fill,2)\n    ID   = word(balance.fill,1)\n    name = ID\n    if ID = \"$BOTH$\" then name = acids.1\n    a.cnt = id\n    interpret \"a\"||cnt \" =\" a.cnt\n    SAY \"fillscr: BALANCE line \"cnt \" acid=\" name \"data# = \"script\n    SAY \"fillscr: a.\"cnt \"=\" a.cnt \"thisrec=\" thisrec \"fill=\" fill\n  end\n  /* dont need segment here for doc                   */\n  segment       = strip(word(acidrul.name.script,1))\n  type.fill     = strip(word(acidrul.name.script,2))\n  type     = type.fill\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = strip(word(acidrul.name.script,3))\n  dup_check     = strip(word(acidrul.name.script,4))\n  dup_num       = strip(word(acidrul.name.script,5))\n  resource = resource.fill\n  if acidath.name.type.resource.0flag /= hex00 then do\n    type.fill = acidath.name.type.resource.0flag\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  respass = acidath.name.type.resource\n  if dup_check = \"DUPLICATE\" then\n    respass = aciddup.name.type.resource.dup_num\n  hold = segment type resource respass\n  parse var hold h1 'ACCESS ' access dropoff\n  access.fill = access\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose acidath. name acidrul. aciddup. next\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. aciddup. next acidlst.\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsegment  = strip(word(acidrul.name.t,1))\ntype     = strip(word(acidrul.name.t,2))\nresource = strip(word(acidrul.name.t,3))\ndupchk   = strip(word(acidrul.name.t,4))\ndupnum   = strip(word(acidrul.name.t,5))\ntheres = acidath.name.type.resource\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = strip(word(acidrul.name.t,1))\ngetdata.0type     = strip(word(acidrul.name.t,2))\ngetdata.0resource = strip(word(acidrul.name.t,3))\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. acidath. name acidrul. conlist modrule. rstype debug.,\n fill_override balance.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"t50pmenu: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\nif (thisrec > h1 )  then do\n  thisrec = h1\n  msg = \"t50pmenu: bottom of data reached\"\nend\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment       = strip(word(acidrul.name.fill,1))\ntype          = strip(word(acidrul.name.fill,2))\nresource      = strip(word(acidrul.name.fill,3))\nrsname        = strip(word(acidrul.name.fill,3))\nmodrule.newrs = \"\"\nhold = acidath.name.type.resource\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50ICOMY": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x007\\x00\\x99\\x18\\x8f\\x01\\x00\\x07_\\x10S\\x06\\x1c\\x06\\x1c\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-07-07T00:00:00", "modifydate": "2000-03-15T10:53:37", "lines": 1564, "newlines": 1564, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T50ICOMP                          **/\n/** LAST MODIFIED    : 12 October   1999                 **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Compare:                                           **/\n/**     This function compare the permission of each ID  **/\n/**     in the acidlist to the first ID specified in the **/\n/**     list.                                            **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Listdup:                                           **/\n/**     List the duplicate permissions in the acids      **/\n/**     specified.                                       **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/** ACIDLIST:  The list of acids to compare              **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T50JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/**                                                      **/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were pased to me   **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/** aciddup.name.0     How many lines of output for below**/\n/** aciddup.name.#     One line for each duplicate       **/\n/**                      keyset that the ID has          **/\n/**                      The type and resource name      **/\n/**                                                      **/\n/** aciddup.name.type.resource.0 = how many dups there   **/\n/**                   for this key set ( there may be    **/\n/**                   seven SYS1. DATASET rules)         **/\n/**                                                      **/\n/** aciddup.name.type.resource.# = The duplicates        **/\n/**                                                      **/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/**                      the acid in name has.           **/\n/**                      segment                         **/\n/**                      restype                         **/\n/**                      resource                        **/\n/**     optional ===>    DUPLICATE                       **/\n/**     optional ===>    subscript                       **/\n/**                                                      **/\n/**     if the literal DUPLICATE appears the data for this*/\n/**      line musts be retrieved from the variable:      **/\n/**        aciddup.name.type.resource.subscript          **/\n/**                                                      **/\n/**     otherwise the data can be retireved from the     **/\n/**      below variable                                  **/\n/**                                                      **/\n/** acidath.name.type.resource                           **/\n/**                    The actual translated data from   **/\n/**                      the TSS list, with all relevant **/\n/**                      data in this one variable.      **/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multi    = \"NO\"\ndebug.convert  = \"NO\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\ndebug.getdata  = \"NO\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nsignal off error\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command. DIR                   **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\ntrace_acid = \"ANIDTOTRACE\"              /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Oct 12 1999\"\nsay \"TSA101D: T50ICOMP in control with parms \" function acidlist\nsay \"TSA101D: T50ICOMP Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50ICOMP. NO OTHER INFORMATION AVAILABLE\"\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\nif debug.flow = \"YES\" then\n  say \"TSA101D: Retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    if debug.flow = \"YES\" then\n      say \"TSA101D: calling jobcard function. \"\n    address tso \"%t50jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"TSA101D: Output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nacidath.   =  hex00\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\nHOLD = \"MODIFY\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nBYPASS.0SUPRESS.HOLD.0 = 9\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 2\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 2\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"* CREATED\"\nBYPASS.HOLD.5 = \"BASE LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\nBYPASS.HOLD.7 = \"* ACIDS \"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9 = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.11 = \"* PASSWORD\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 8\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"BASE CREATED\"\nBYPASS.HOLD.5 = \"* LASTUSED\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\nif debug.flow = \"YES\" then\n  say \"TSA101D: Basic initialization complete, execution begins.\"\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  say \"TSA101D: Resource processing started\"\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"TSA101D: Bypass option specified, allocating input DSN\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      if debug.resource = \"YES\" then\n        say \"Owner = \" acidnum \"name = \" owner\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      parse var line drop 'ACID(' name ')' drop2\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\"\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      if debug.resource = \"YES\" then\n        say \"acidnum = \" acidnum \"name = \" name\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"TSA101D: Total acids referenced in input is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then   signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"TSA101D: Bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"TSA101D: Total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  acids.0 = words\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we creat   the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Evaluation of TSS generated data begins.\"\nevaluate: nop\ndo num = 1 to acidnum\n  /***********************************************/\n  /**This outer lop is once for each acid passed**/\n  /** to me. Dave 18 June 99                    **/\n  /***********************************************/\n  rules = 0\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"TSA101D: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"         Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    line = substr(acidlst.name.a1,1,59)\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    end\n    first11 = substr(line,1,11)\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if debug.trans = \"YES\" then\n        say \"TSA101D:  Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      if debug.trans = \"YES\" then\n       say \"TSA101D: lcf detected:\" w.2\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area input line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n      w.1 = w.1\".\"savefac\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area reformated line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if repeat = \"YES\" then do\n      /***************************************/\n      /** Note the duplicates for each ID   **/\n      /***************************************/\n      hold = acidath.name.prev_type.prev_resource\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: In duplicate loop\",\n          concat prev_type prev_resource hold\n        if debug.trans = \"YES\" then\n          say \"TSA101D: Mult key \"name \"==>\",\n            prev_type prev_resource hold\n      end\n      hold1 = aciddup.name.0\n      hold2 = hold1 + 1\n      aciddup.name.0 = hold2\n      aciddup.name.hold2 = prev_type prev_resource\n      if aciddup.name.hold1 = aciddup.name.hold2 then\n        aciddup.name.0 = hold1\n      zz1 = aciddup.name.0\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: New total for dup array:\" name  aciddup.name.0\n        say \"         array key is:\" aciddup.name.zz1\n      end\n      tz0  = aciddup.name.prev_type.prev_resource.0\n      tz1  = tz0 + 1\n      aciddup.name.prev_type.prev_resource.0  = tz1\n      aciddup.name.prev_type.prev_resource.tz1 = hold\n      duplicat = \"DUPLICATE \"tz1\n      if debug.trans = \"YES\" then  do\n        say \"TSA101D: Mult keys\" prev_type prev_resource \" is now \" tz1\n        say \"         \" name prev_type prev_resource hold duplicat\n      end\n/*                                                                   */\n/*    if aciddup.name.prev_type.prev_resource.tz0 = hold then do     */\n/*      say \"Full duplicate rule found dropping data:\"               */\n/*      say \"  \" prev_type prev_resource hold                        */\n/*      aciddup.name.prev_type.prev_resource.0  = tz0                */\n/*      duplicat = \" \"                                               */\n/*      rules = rules -1                                             */\n/*    end                                                            */\n      acidath.name.type.resource = \"\"\n      /* kill the previous one and prepare to load this one */\n    end\n    if concat = \"YES\" then do\n      hold = acidath.name.type.resource\n      acidath.name.type.resource = strip(hold) strip(line)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T50ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n      /*say \"       \"acidath.name.type.resource  */\n      acidath.name.type.resource.0concat  = \"YES\"\n      hold1 = acidath.name.type.resource.0concat\n      hold = acidath.name.type.resource\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: Concat rule \",\n        \"n=\"name \"t=\"type \"r=\"resource hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.rules = segment type resource duplicat\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidath.name.type.resource = \" \"\n    do t1 = 3 to words\n      hold = acidath.name.type.resource\n      acidath.name.type.resource = strip(hold) strip(w.t1)\n    end\n    if debug.trans = \"YES\" then\n      say \"  Type/res=\" type resource acidath.name.type.resource\n  end\n  acidrul.name.0 = rules\nend\nif debug.flow = \"YES\" then\n  say \"TSA101D: Translation streams have been built.\",\n  \"Starting function check.\"\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter                                     */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif function = \"LISTDUP\" then  do\n  dupnum = 0\n  do x = 1 to acidnum\n    name = acids.x\n    /* say acidnum name  */\n    say \"TSA103I: \"name \"duplicate keysets\" aciddup.name.0\n    do t = 1 to aciddup.name.0\n      type     = strip(word(aciddup.name.t,1))\n      resource = strip(word(aciddup.name.t,2))\n      tz2 = aciddup.name.type.resource.0\n      prime = acidath.name.type.resource\n      say \" \"\n      say \"TSA103I:\"\n      say \" LISTDUP:\"name \"keyset=\" type resource\n      say \" LISTDUP: primary:\" prime\n      dupnum = dupnum + 1\n      listdup.dupnum = \" \"\n      dupnum = dupnum + 1\n      listdup.dupnum = \" LISTDUP:\"name \"keyset=\" type resource\n      dupnum = dupnum + 1\n      listdup.dupnum = \"          primary:\" prime\n      if prime = \" \" then listdup.dupnum = \" \"\n      do cnt = 1 to tz2\n        hold = aciddup.name.type.resource.cnt\n        dupnum = dupnum + 1\n        listdup.dupnum = \"    ACID=\" name type resource hold\n        say listdup.dupnum\n        secrc = \"List duplicates complete.\"\n      end\n      if screen /= \"YES\" then do\n        address tso \"alloc ddn(outds2) dsn(\"ds2\") shr reus\"\n        \"EXECIO \"dupnum\" DISKW outds2 (FINIS STEM listdup.)\"\n        address tso \"free ddn(outds2)\"\n        secrc = \"TSA109I: Complete. Output stream written to \" ds2\n      end\n    end\n    /* call snapshot */\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Permit/rebuild/revoke area in control.\"\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do x = 1 to acidnum\n    name = acids.x\n    say \"TSA101D: Starting to process ACID:\" x \">\"name\"<\"\n    say \"          Rules#:\" acidrul.name.0\n    do t = 1 to acidrul.name.0\n      if debug.flow = \"YES\" then\n        say \"TSA101D: Starting to process \"name \" Rule #\" t\n      if debug.name.t = \"TRACE\" then trace r\n      call getdata t\n      hold = next\n      call convert function hold\n      trace off\n    end\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = acidrul.name.0\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"TSA101D:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = strip(word(acidrul.name.y,1))\n        type     = strip(word(acidrul.name.y,2))\n        resource = strip(word(acidrul.name.y,3))\n        acidath.name.type.resource.0flag = \"*DELETE\"\n        acidrul.name.y = segment type resource\n        hold = segment type resource acidath.name.type.resource\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        if seccode = \"OK\" then do\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          hold = segment type resource acidath.name.type.resource\n          say \"TSA101D:\"\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          /* say  \"back from modify  rsname is \"rsname */\n          acidath.name.type.rsname.0flag  = \"*MODIFY\"\n          acidath.name.type.rsname.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidath.name.type.rsname = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n     /*                                                          */\n     /* say \"t50icomp:addition routine entered outnum=\" outnum   */\n     /* say \"t50icomp:addition routine entered target=\" target   */\n     /* say \"t50icomp:addition routine entered thisrec=\" thisrec */\n     /* say \"t50icomp:addition routine entered fill=\" fill       */\n        do q = outnum to target by -1\n          q1 = q - 1\n          acidrul.name.q = acidrul.name.q1\n        end\n        modrule.0panel = \"SECUPDT\"\n        call modrule\n        acidath.name.type.rsname.0concat = \"YES\"\n        acidath.name.type.rsname.0flag = \"*NEWRULE\"\n        acidrul.name.fill = segment type rsname\n        acidath.name.type.rsname = modrule.newrs\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"T50101D: leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    call getdata t\n    say next\n  end\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"COMPARE\" then do\n  name = acids.1    /* compare all Ids to the first one */\n  cmpnum = cmpnum + 1\n  compare.cmpnum = \" Comparison of ACIDs \" acidlist\n  cmpnum = cmpnum + 1\n  compare.cmpnum = \"               \"\n  call snapshot\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    resource = word(acidrul.name.t,3)\n    hold = acidath.name.type.resource\n    do cnt = 2 to acidnum\n      otherid = acids.cnt\n      /******************/\n      /*take a snap     */\n      snaphold = name\n      name = otherid\n      call snapshot\n      name = snaphold\n      /******************/\n      hold1 = acidath.otherid.type.resource\n      if hold = hold1 then iterate cnt\n      say \"hold =\" name type resource\n      say \"      \" hold\n      if hold1 = hex00 then hold1 = \"**No rule **\"\n      say \"hold1=\" otherid type resource\n      say \"      \" hold1\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"***********************\"\n      compare.cmpnum = \"** Differences found **\" type resource\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \" \"name  \" ACID data ====>\" hold\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \" \"otherid \" ACID data ====>\" hold1\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"***********************\"\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"  \"\n    end\n  end\n  if screen /= \"YES\" then do\n    \"EXECIO \"cmpnum\" DISKW outds2 (FINIS STEM compare.)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n  end\n  if screen = \"YES\" then do h1 = 1 to cmpnum\n    say compare.cmpnum\n  end\n  address ispexec \"vput secrc profile\"\n  exit 0\nend\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid.\nparse arg function\nif function /= \"REBUILD\" then return\nif debug.makeacid = \"YES\" then\n  say \"TSA101D: Making ACID:\" function\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    if debug.makeacid = \"YES\" then\n      say \"TSA101D: Owner resolved to:\" own_str\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  CREATE.CREATE_NUM = \" TSS CRE(\"NAME\") NAME('\"ACID_NAME\"') +\"\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  if debug.makeacid = \"YES\" then\n    say \"TSA101D: Makeacid type for \"name\" is :\" acid_type\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    create.create_num = q1||name||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00,\n  acidath. cvtnum concat lcffac debug. convert.\nparse arg function segment inline\noname = name\nif oname = \"*ALL*\" then oname = \"ALL\"\nif debug.flow = \"YES\" then\n  say \"TSA101D: Converting: \"function segment \">\"||inline||\"<\"\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"XADATASET\") then do\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Input dsn line \"inline\n  inline = \"XADSN\"||substr(inline,10)\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatted dsn line \"inline\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") INSTDATA('\"hold\"')\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"UID\") then do\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MAS\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"name\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROC(\"W.2\")                           \"\n  hold = substr(hold,1,30)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\nif acidath.name.tchk.resource.0concat = \"YES\" then concat = \"YES\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = acidath.name.type.resource.0concat\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"TSA101D: XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nif debug.convert = \"YES\" then\n  say \"TSA101D: Resource is \"resource \"concat is\" concat\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  if debug.convert = \"YES\" then do\n    rule = bypass.function.rulehold\n    say \"TSA101D: bypass rule tripped, Rule is below:\"\n    say \"     \" Rule\n  end\n  return\nend\noutput = \" TSS \"cmd\"(\"oname\")\"\nif function = \"REVOKE\" then do\n  output = output w.1\"(\"w.2\")\"\nend\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multi = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then\n  say \"TSA101D: convert output is now :\" output\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T50ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\nseeya: nop\nif sysenv = \"FORE\" then do\n  secrc = \"error in line \"sigl\n  address ispexec \"vput secrc profile\"\nend\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. acidath. name hex00 aciddup. debug.\nOPT = \" \"\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nh1 = acidrul.name.0 - 14\nIF (THISREC > h1 - 14) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nsay \"TSA101D: filling screen:\",\n  \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  segment       = strip(word(acidrul.name.fill,1))\n  type.fill     = strip(word(acidrul.name.fill,2))\n  type     = type.fill\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = strip(word(acidrul.name.fill,3))\n  dup_check     = strip(word(acidrul.name.fill,4))\n  dup_num       = strip(word(acidrul.name.fill,5))\n  resource = resource.fill\n  if acidath.name.type.resource.0flag /= hex00 then do\n    type.fill = acidath.name.type.resource.0flag\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  respass = acidath.name.type.resource\n  if dup_check = \"DUPLICATE\" then\n    respass = aciddup.name.type.resource.dup_num\n  hold = segment type resource respass\n  parse var hold h1 'ACCESS ' access dropoff\n  access.fill = access\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose acidath. name acidrul. aciddup. next\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. aciddup. next acidlst.\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next acidath. name debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsegment  = strip(word(acidrul.name.t,1))\ntype     = strip(word(acidrul.name.t,2))\nresource = strip(word(acidrul.name.t,3))\ndupchk   = strip(word(acidrul.name.t,4))\ndupnum   = strip(word(acidrul.name.t,5))\ntheres = acidath.name.type.resource\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.segment  = strip(word(acidrul.name.t,1))\ngetdata.type     = strip(word(acidrul.name.t,2))\ngetdata.resource = strip(word(acidrul.name.t,3))\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. acidath. name acidrul. conlist modrule. rstype debug.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"t50pmenu: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif (thisrec > h1 - 14)  then do\n  thisrec = outnum - 14\n  msg = \"t50pmenu: bottom of data reached\"\nend\nfill = thisrec + t - 1\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment       = strip(word(acidrul.name.fill,1))\ntype          = strip(word(acidrul.name.fill,2))\nresource      = strip(word(acidrul.name.fill,3))\nrsname        = strip(word(acidrul.name.fill,3))\nmodrule.newrs = \"\"\nhold = acidath.name.type.resource\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50ICOMZ": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00H\\x00\\x99\\x16\\x9f\\x01\\x00\\x07_\\x10S\\x04\\xc2\\x04\\xc2\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1999-06-18T00:00:00", "modifydate": "2000-03-15T10:53:48", "lines": 1218, "newlines": 1218, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50ICOMP                          **/\n/** LAST MODIFIED    :  8 July 99                        **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Compare:                                           **/\n/**     This function compare the permission of each ID  **/\n/**     in the acidlist to the first ID specified in the **/\n/**     list.                                            **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Listdup:                                           **/\n/**     List the duplicate permissions in the acids      **/\n/**     specified.                                       **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/** ACIDLIST:  The list of acids to compare              **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T50JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/**                                                      **/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were pased to me   **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/** aciddup.name.0     How many lines of output for below**/\n/** aciddup.name.#     One line for each duplicate       **/\n/**                      keyset that the ID has          **/\n/**                      The type and resource name      **/\n/**                                                      **/\n/** aciddup.name.type.resource.0 = how many dups there   **/\n/**                   for this key set ( there may be    **/\n/**                   seven SYS1. DATASET rules)         **/\n/**                                                      **/\n/** aciddup.name.type.resource.# = The duplicates        **/\n/**                                                      **/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/**                      the acid in name has.           **/\n/**                      segment                         **/\n/**                      restype                         **/\n/**                      resource                        **/\n/**     optional ===>    DUPLICATE                       **/\n/**     optional ===>    subscript                       **/\n/**                                                      **/\n/**     if the literal DUPLICATE appears the data for this*/\n/**      line musts be retrieved from the variable:      **/\n/**        aciddup.name.type.resource.subscript          **/\n/**                                                      **/\n/**     otherwise the data can be retireved from the     **/\n/**      below variable                                  **/\n/**                                                      **/\n/** acidath.name.type.resource                           **/\n/**                    The actual translated data from   **/\n/**                      the TSS list, with all relevant **/\n/**                      data in this one variable.      **/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\nmaint = \"July 07 1999\"\nsay \"T50ICOMP: in control with parms \" function acidlist\nsay \"T50ICOMP: Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50ICOMP. NO OTHER INFORMATION AVAILABLE\"\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\nsay \"T50ICOMP: retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    say \"T50ICOMP: calling jobcard function. \"\n    address tso \"%t50jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nacidath.   =  hex00\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\ncreate.0 = 0\nBYPASS. = 0\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\nHOLD = \"MODIFY\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nBYPASS.0SUPRESS.HOLD.0 = 8\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.HOLD.0 = 2\nBYPASS.HOLD.1 = \"LASTUSED\"\nBYPASS.HOLD.2 = \"CREATED\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 6\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"* SEGMENT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"BASE CREATED\"\nBYPASS.HOLD.5 = \"BASE LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\nBYPASS.HOLD.7 = \"* ACIDS \"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9 = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.11 = \"* PASSWORD\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 8\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"BASE CREATED\"\nBYPASS.HOLD.5 = \"* LASTUSED\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\nsignal on error name baddsn\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  acidnum = 0\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  if acidlist = \"BYPASS\" then do\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"T50ICOMP: bypass option specified, allocating input dsn\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    line = hold.l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      /* say \"Owner = \" acidnum \"name = \" owner */\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line drop 'ACID(' name ')' drop2\n      accessor.acidnum = l\n      acids.acidnum = name\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    say \"ACIDLST.\"name\".\"temp\" \" line\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"T50ICOMP: total acids contained in input DSN is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then   signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"T50ICOMP: bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"T50ICOMP: total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  acids.0 = words\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,1000)\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we creat   the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nevaluate: nop\ndo num = 1 to acidnum\n  /***********************************************/\n  /**This outer lop is once for each acid passed**/\n  /** to me. Dave 18 June 99                    **/\n  /***********************************************/\n  rules = 0\n  segment = \"BASE\"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if name = \"RDT\" then do\n    SAY  \"Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    line = substr(acidlst.name.a1,1,59)\n    first11 = substr(line,1,11)\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then concat = \"YES\"\n    first11 = substr(line,1,11)\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace dots with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4  */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if function = \"TRANSLATE\" then\n        say \"T50ICOMP: Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then\n      do supnum = 1 to bypass.0supress.function.0\n      if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n    end\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) &  (prev_resource = resource) then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if repeat = \"YES\" then do\n      /***************************************/\n      /** Note the duplicates for each ID   **/\n      /***************************************/\n      hold = acidath.name.prev_type.prev_resource\n      /* say \"In duplicate loop\" concat prev_type prev_resource hold*/\n      if function = \"TRANSLATE\" then\n        say \"T50ICOMP: Mult key \"name \"==>\" prev_type prev_resource hold\n      hold1 = aciddup.name.0\n      hold2 = hold1 + 1\n      aciddup.name.0 = hold2\n      aciddup.name.hold2 = prev_type prev_resource\n      if aciddup.name.hold1 = aciddup.name.hold2 then\n        aciddup.name.0 = hold1\n      /* say \"set dup array:\" name  aciddup.name.0 */\n      zz1 = aciddup.name.0\n      /* say \"aciddup is\" aciddup.name.zz1 */\n      tz0  = aciddup.name.prev_type.prev_resource.0\n      tz1  = tz0 + 1\n      aciddup.name.prev_type.prev_resource.0  = tz1\n      aciddup.name.prev_type.prev_resource.tz1 = hold\n      duplicat = \"DUPLICATE \"tz1\n      say \"T50ICOMP: Mult keys\" prev_type prev_resource \" is now \" tz1\n      say \"         \" prev_type prev_resource hold duplicat\n/*                                                                   */\n/*    if aciddup.name.prev_type.prev_resource.tz0 = hold then do     */\n/*      say \"Full duplicate rule found dropping data:\"               */\n/*      say \"  \" prev_type prev_resource hold                        */\n/*      aciddup.name.prev_type.prev_resource.0  = tz0                */\n/*      duplicat = \" \"                                               */\n/*      rules = rules -1                                             */\n/*    end                                                            */\n      acidath.name.type.resource = \"\"\n      /* kill the previous one and prepare to load this one */\n    end\n    if concat = \"YES\" then do\n      hold = acidath.name.type.resource\n      acidath.name.type.resource = strip(hold) strip(line)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      acidath.name.type.resource.0concat  = \"YES\"\n      hold1 = acidath.name.type.resource.0concat\n      hold = acidath.name.type.resource\n      if function = \"TRANSLATE\" then do\n        say \"T50ICOMP: Concatenated rule built\"\n        say \"T50ICOMP: \"  \"name=\"name \"type =\"type \"res=\"resource hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.rules = segment type resource duplicat\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidath.name.type.resource = \" \"\n    do t1 = 3 to words\n      hold = acidath.name.type.resource\n      acidath.name.type.resource = strip(hold) strip(w.t1)\n    end\n    /* say \"type + res is\" type resource acidath.name.type.resource */\n  end\n  acidrul.name.0 = rules  - 1\nend\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif function = \"LISTDUP\" then  do\n  dupnum = 0\n  do x = 1 to acidnum\n    name = acids.x\n    /* say acidnum name  */\n    say \"LISTDUP:\"name \"duplicate keysets\" aciddup.name.0\n    do t = 1 to aciddup.name.0\n      type     = strip(word(aciddup.name.t,1))\n      resource = strip(word(aciddup.name.t,2))\n      tz2 = aciddup.name.type.resource.0\n      prime = acidath.name.type.resource\n      say \" \"\n      say \"LISTDUP:\"name \"keyset=\" type resource\n      say \"LISTDUP: primary:\" prime\n      do cnt = 1 to tz2\n        hold = aciddup.name.type.resource.cnt\n        dupnum = dupnum + 1\n        listdup.dupnum = \"ACID=\" name type resource hold\n        say listdup.dupnum\n      end\n    end\n    call snapshot\n    secrc = \"List duplicates complete.\"\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do x = 1 to acidnum\n    name = acids.x\n    say \"T50ICOMP: starting to process ACID:\" x name\n    do t = 1 to acidrul.name.0\n      call getdata name t\n      hold = next\n      call convert function hold\n    end\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = acidrul.name.0\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"T50ICOMP:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(secprof)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = strip(word(acidrul.name.y,1))\n        type     = strip(word(acidrul.name.y,2))\n        resource = strip(word(acidrul.name.y,3))\n        acidath.name.type.resource.0flag = \"*DELETE\"\n        acidrul.name.y = segment type resource\n        hold = segment type resource acidath.name.type.resource\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        if seccode = \"OK\" then do\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          hold = segment type resource acidath.name.type.resource\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          say  \"back from modify  rsname is \"rsname\n          acidath.name.type.rsname.0flag  = \"*MODIFY\"\n          acidath.name.type.rsname.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidath.name.type.rsname = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"t50pmenu: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n     /*                                                          */\n     /* say \"t50icomp:addition routine entered outnum=\" outnum   */\n     /* say \"t50icomp:addition routine entered target=\" target   */\n     /* say \"t50icomp:addition routine entered thisrec=\" thisrec */\n     /* say \"t50icomp:addition routine entered fill=\" fill       */\n        do q = outnum to target by -1\n          q1 = q - 1\n          acidrul.name.q = acidrul.name.q1\n        end\n        modrule.0panel = \"SECUPDT\"\n        call modrule\n        acidath.name.type.rsname.0concat = \"YES\"\n        acidath.name.type.rsname.0flag = \"*NEWRULE\"\n        acidrul.name.fill = segment type rsname\n        acidath.name.type.rsname = modrule.newrs\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    call getdata name t\n    say next\n  end\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"COMPARE\" then do\n  name = acids.1    /* compare all Ids to the first one */\n  cmpnum = cmpnum + 1\n  compare.cmpnum = \"Comparison of ACIDs \" acidlist\n  cmpnum = cmpnum + 1\n  compare.cmpnum = \"               \"\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    resource = word(acidrul.name.t,3)\n    hold = acidath.name.type.resource\n    do cnt = 2 to acidnum\n      otherid = acids.cnt\n      hold1 = acidath.otherid.type.resource\n      if hold = hold1 then iterate cnt\n      if hold1 = hex00 then hold1 = \"**No rule **\"\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"***********************\"\n      compare.cmpnum = \"** Differences found **\" type resource\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  name  \"ACID data ====>\" hold\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  otherid \"ACID data ====>\" hold1\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"***********************\"\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"  \"\n    end\n  end\n  if screen /= \"YES\" then do\n    \"EXECIO \"cmpnum\" DISKW outds2 (FINIS STEM compare.)\"\n    secrc = \"Compare complete. Report in \" ds2\n  end\n  if screen = \"YES\" then do h1 = 1 to cmpnum\n    say compare.cmpnum\n  end\n  address ispexec \"vput secrc profile\"\n  exit 0\nend\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass\nparse arg function\nif function /= \"REBUILD\" then return\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.4 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  CREATE.CREATE_NUM = \" TSS CRE(\"NAME\") NAME('\"ACID_NAME\"') +\"\n  IF USER_FLAG = \"YES\" THEN\n    T2 = \"  \"OWNER\"(\"AREA\")   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2= \"  \"OWNER\"(\"AREA\")   TYPE(\"acid_TYPE\")\"\n  IF OWNER = \"OWNER\" THEN\n    T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  IF TYPE = \"DIVISION \"THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"T50ICOMP makeacid routine aborting due to lack of user type\"\n    SAY \"T50ICOMP : acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00,\n  acidath. cvtnum concat\nparse arg function segment inline\n/* say \"CONIN \"function segment \">\"||inline||\"<\"  */\ncmd_set = \"ADD REM\"\nif words(inline) = 1 then return\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/*************************************************/\nif (word(inline,1) = \"BYPASSING\") | (word(inline,1) = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"name\")\" hold\n  return\nend\nif (word(inline,1) = \"INSTDATA\") then do\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"name\") INSTDATA(\"hold\")\"\n  return\nend\n/*************************************************/\n/** the reformatter area                        **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\nend\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = LTI\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROC(\"W.2\")                           \"\n  hold = substr(hold,1,30)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\nif acidath.name.type.resource.0concat = \"YES\" then concat = \"YES\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = acidath.name.type.resource.0concat\n  say \"convert: type =\"type \"res=\"resource \"name=\"name\n  say \"convert: concat = \" hold\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\n/* say \"resource is \"resource \"concat is\" concat */\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\nend\n/*                                                */\n/*say \"hold1 hold type_match seg_match bypass\"    */\n/*say hold1 hold type_match seg_match bypass      */\nif bypass = \"YES\" then return\noutput = \" TSS \"cmd\"(\"name\")\"\nif function = \"REVOKE\" then do\n  output = output w.1\"(\"w.2\")\"\nend\nhold = \"\"\nmulti = output\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\nif (function = \"PERMIT\")  then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T50ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\nseeya: nop\nif sysenv = \"FORE\" then do\n  secrc = \"error in line \"sigl\n  address ispexec \"vput secrc profile\"\nend\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. acidath. name hex00 aciddup.\nOPT = \" \"\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nh1 = acidrul.name.0 - 14\nIF (THISREC > h1 - 14)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  segment       = strip(word(acidrul.name.fill,1))\n  type.fill     = strip(word(acidrul.name.fill,2))\n  type     = type.fill\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = strip(word(acidrul.name.fill,3))\n  dup_check     = strip(word(acidrul.name.fill,4))\n  dup_num       = strip(word(acidrul.name.fill,5))\n  resource = resource.fill\n  if acidath.name.type.resource.0flag /= hex00 then do\n    type.fill = acidath.name.type.resource.0flag\n    /* say \"fillscr: type overlayed type, resource =\" type resource*/\n    /* say \"fillscr: NEWTYPE  =\" type.fill                          */\n  end\n  respass = acidath.name.type.resource\n  if dup_check = \"DUPLICATE\" then\n    respass = aciddup.name.type.resource.dup_num\n  hold = segment type resource respass\n  parse var hold h1 'ACCESS ' access dropoff\n  access.fill = access\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  /* say \"FILLSCR\" l */\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose acidath. name acidrul. aciddup. next\nsay \"Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata name out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next acidath.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg name record_number\nt = record_number\nsegment  = strip(word(acidrul.name.t,1))\ntype     = strip(word(acidrul.name.t,2))\nresource = strip(word(acidrul.name.t,3))\ndupchk   = strip(word(acidrul.name.t,4))\ndupnum   = strip(word(acidrul.name.t,5))\ntheres = acidath.name.type.resource\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  /* say \"getdata:Record # \" t \"Duplicate processing:\" dupnum theres*/\nend\nnext = segment type resource theres\ngetdata.segment  = strip(word(acidrul.name.t,1))\ngetdata.type     = strip(word(acidrul.name.t,2))\ngetdata.resource = strip(word(acidrul.name.t,3))\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. acidath. name acidrul. conlist modrule. rstype\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"t50pmenu: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif (thisrec > h1 - 14)  then do\n  thisrec = outnum - 14\n  msg = \"t50pmenu: bottom of data reached\"\nend\nfill = thisrec + t - 1\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment       = strip(word(acidrul.name.fill,1))\ntype          = strip(word(acidrul.name.fill,2))\nresource      = strip(word(acidrul.name.fill,3))\nrsname        = strip(word(acidrul.name.fill,3))\nmodrule.newrs = \"\"\nhold = acidath.name.type.resource\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nl = rsname library type access facility action until privpgm other\n/* say \"MODRULE:prepanel\" l */\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\n/* say \"MODRULE:postpanel\" conlist */\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nsay \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50INS": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x05\\x00\\x955/\\x01\\x00\\x11\\x8f\\x14W\\x00\\xd0\\x00\\xd0\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-04-27T14:57:05", "lines": 208, "newlines": 208, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T50INS                            **/\n/** LAST MODIFIED    :  9 dec 99                         **/\n/**********************************************************/\n/** NOW ACCEPTS MULTIPLE PROFS IN STD INVOCATION         **/\n/**********************************************************/\n/** CHANGED CODE TO FIX ERROR FOR INSERTS AT POSITION    **/\n/** GREATER THAN 1 WHEN ID HAS NO PROFILES    ....DR     **/\n/**********************************************************/\n/** REVAMPED TO USE THE AFTER KEYWORD OF INSERT COMMAND  **/\n/** SHOULD BE LOTS FASTER AND EASIER TO MANAGE....DR     **/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         EXITPRM                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T50FDIV %T50GDAT    **/\n/**********************************************************/\nARG ACID PROFILE TARGET DAYS\n/************************************************************/\n/** PATCH BELOW FOR NORMAL INVOCATION FOR MULTIPLE PROFILES */\n/************************************************************/\nif target = \" \" then target = 1\nTEMP = PROFILE TARGET DAYS\nPROFS = 0\nPARSE VAR TEMP TW.1 TW.2 TW.3 TW.4 TW.5 TW.6 TW.7 TW.8 TW.9 TW.10\nALLWORDS = WORDS(TEMP)\nIF (ALLWORDS = 3) & ( DATATYPE(TW.2) = \"CHAR\" ) THEN do\n  PROFILE = TW.1||\".\"||TW.2\n  TARGET = DAYS\n  DAYS = \"\"\n  say \"TSA101D: T50INS reformatted input is :\" acid profile target days\nEND\nIF ALLWORDS > 3 THEN DO\n  DO COUNT = 1 TO ALLWORDS\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN PROFS = COUNT - 1\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN LEAVE\n  END\n  PROFILE = \"\"\n  DO CNT2 = 1 TO PROFS\n    PROFILE = PROFILE||\".\"||TW.CNT2\n  END\n  TARGET_WORD = PROFS + 1\n  DAYS_WORD = PROFS + 2\n  TARGET = WORD(TEMP,TARGET_WORD)\n  DAYS   = WORD(TEMP,DAYS_WORD)\n  say \"TSA101D: T50INS reformatted input is :\" acid profile target days\nEND\n/*****/\nACT = \"AFTER\"\nADDRESS ISPEXEC\nPROFILE = TRANSLATE(PROFILE,\" \",\".\") /*CHANGE DOTS TO BLANKS */\nPROFILE = TRANSLATE(PROFILE,\" \",\"_\") /*CHANGE _    TO BLANKS */\nSYSENV = SYSVAR(SYSENV)\nPROF. = \" \"\nPROFHLD = \" \"\nQ = OUTTRAP(\"OFF\")\nSAY \" \"\nsay \"TSA101D: T50INS control received.\"\nsay \"TSA101D: T50INS profile is\" profile\nsay \"TSA101D: T50INS target  is\" target\nsay \"TSA101D: T50INS days    is\" days\nPARSE VAR PROFILE PROF.1 PROF.2 PROF.3 PROF.4 PROF.5\nPROFNUM = WORDS(PROFILE)\nIF PROFNUM > 5 THEN DO\n  secrc = \"TSA251E: Failed. Insert function only supports \"\n  secrc = secrc||\"5 profiles at a time\"\n  say \"TSA101D: T50INS:\" secrc\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DATATYPE(TARGET) \u00ac= \"NUM\" THEN DO\n   SECRC=\"FUNCTION ABORTED. LOCATION SPECIFIED IS NOT NUMERIC.\"\n   SECRC= SECRC TARGET\n   IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n   EXIT 16\nEND\n/*********************************************************************/\n/* NOW I MAKE SURE EACH PROF HE PASSED ME IS ACTUALLY A PROFILE. DIR */\n/* NOTE THAT THIS CHECKING IS SKIPPED FOR A BATCH USER.          DIR */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  SECRC = \"PROFILE\" /*SET TO PROFILE FOR BATCH DEFAULTS */\n  IF SYSENV = \"FORE\" THEN DO\n    say \"TSA101D: T50INS environment is foreground\"\n    say \"TSA101D: T50INS I am calling Txxfdiv for data on \"prof.cnt\n    ADDRESS TSO \"%T50FDIV \"PROF.CNT\n    ADDRESS ISPEXEC \" VGET SECRC PROFILE\"\n  END\n  IF SECRC \u00ac= \"PROFILE\" THEN DO\n    say \"TSA101D: T50INS rcode indicates \" prof.cnt \"is not a profile\"\n    say \"TSA101D: T50INS return code is ===>\" secrc\n    secrc= \"TSA252E: \"\n    secrc= secrc\"Function aborted. \"prof.cnt \"is not an owned profile.\"\n    IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n    EXIT 08\n  END\nEND\nSIGNAL ON ERROR NAME ERRID\nsay \"TSA101D: T50INS testing primary id for existance\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nsay \"TSA101D: T50INS rcode from test is \" rc\nSIGNAL OFF ERROR\n/*********************************************************************/\n/* NOW I REMOVE THE PROFS BEFORE INSERTING THEM JUST IN CASE THIS IS */\n/* THE EQUIVALENT OF A MOVE OPERATION...........DIR 19 JUN 91        */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  say \"TSA101D: T50INS removing the stated profiles first !\" prof.cnt\n  ADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROF.CNT\")\"\n  IF RC > 0 THEN NOTTHERE = \"YES\"\nEND\n/*********************************************************************/\n/* IF THIS IS THE EQUIVALENT OF A DELETE WE ARE DONE....DIR 19 JUN 91*/\n/*********************************************************************/\nIF TARGET = 0 THEN DO\n  SECRC = PROFILE \" REMOVED FROM \"ACID\", AND NOT REINSERTED.\"\n  IF NOTTHERE = \"YES\" THEN DO\n    say \"TSA101D: T50INS non 0 rc received from tss remove command\"\n    secrc = \"TSA253E: Failed. Delete requested but \"profile \"not\"\n    secrc =  secrc\" removed from ACID\" acid\".\"\n  END\n  SAY \"T50INS:\" SECRC\n  IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n  EXIT\nEND\n/*                                              */\n/*Q = OUTTRAP(\"OUT.\")                           */\n/*ADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"    */\nQ = OUTTRAP(\"OFF\")\n/*********************************************************************/\n/* NOW I GET THE PROFILES CURRENTLY ATTACHED TO THE ACID DR 2 MAY96  */\n/*********************************************************************/\nADDRESS TSO \" %T50GDAT \"ACID \" PROFILES\"\nADDRESS ISPEXEC \" VGET SECRC PROFILE\"\nPROFHLD = SECRC\nSAY \"T50INS: CURRENT PROFILES ARE : \" PROFHLD\nTOTWORDS = WORDS(PROFHLD)\nIF PROFHLD = \"$NOTFOUND\" THEN TOTWORDS = 0\nIF TARGET > TOTWORDS THEN DO\n  TARGET = TOTWORDS + 1\n  SAY \"T50INS: POSITION PARM OVERRIDDEN. CHANGED TO \"TARGET\nEND\n/******************************************************************/\n/* WE ISSUE THE COMMAND WITH AN AFTER PARM UNLESS THE FUNCTION IS */\n/* TO ADD THE PROFILE AS THE FIRST IN HIS LIST, THEN WE MUST      */\n/* USE THE BEFORE PARM. THIS NEXT CODE IS HERE IN CASE TARGET IS  */\n/* EQUAL TO POSITION 1. DIR 2 MAY 96                              */\n/******************************************************************/\nIF TOTWORDS = 0 THEN DO\n  IF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"\n  IF DAYS \u00ac= \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\")\"\n  SIGNAL SEEYA\nEND\nQ1 = TARGET\nIF TARGET = 1 THEN ACT = \"BEFORE\"\nELSE Q1 = TARGET - 1\nIF Q1 = 0 THEN ACT = \"BEFORE\"\nTPROF = WORD(PROFHLD,Q1)\nIF LEFT(TPROF,1) = \"*\" THEN TPROF = SUBSTR(TPROF,2)\nSAY \"T50INS: INSERT TGT IS PROFILE \" TPROF\nSIGNAL ON ERROR NAME ERRXIT\nSAY \"T50INS: ADDING FOLLOWING PROFILES TO ACID\"\nSAY \"T50INS: PROFILES ===> \"PROFILE\nSAY \"T50INS: CHECKING FOR TEMPORARY TIMESPAN\"\nIF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"ACT\"(\"TPROF\")\"\nELSE ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\") \",\n      ACT\"(\"TPROF\")\"\nSEEYA: NOP\nsecrc =  \"TSA254I:\" profile \"inserted in \"acid\" at position\" target\".\"\nSAY \"T50INS: \"SECRC\nSAY \"  \"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nEXIT 0\n\nERRXIT: NOP\nSAY \"T50INS: ERROR IN LINE:\" SIGL\nSECRC =  \"CATASTROPHIC FAILURE ! PROFILES BELOW NOT ADDED !\"\nSAY \"T50INS: \"SECRC\nSAY \"  \"\nEXITRC16 = ACID \"LOST:\" PROFHLD\nSAY \"T50INS: \"EXITRC16\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC16 PROFILE\"\nEXIT 1\nERRID: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . MAY NOT EXIST\"\nSAY \"T50INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"MAY NOT EXIST\"\nSAY \"T50INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\nERRPRF: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . SOME PROFILES MAY NOT BE OWNED!\"\nSAY \"T50INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"PROFS IN QUESTION:\" Y\nSAY \"T50INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50JCARD": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x11\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00<\\x00<\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:11", "lines": 60, "newlines": 60, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** INSERTS A JOBNAME AND MAYBE A USER= CARD INTO A      **/\n/** SAMPLE JCL DECK WHICH ALREADY IS SYNTACTICALLY VALID **/\n/**********************************************************/\n/** EXEC NAME        : T50JCARD                          **/\n/** LAST MODIFIED    : 15 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSNAME OF THE OUTPUT JCL STREAM        **/\n/** JPARM   : \"SUPER\" OR BLANKS                          **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS6     : THE DSNAME IF THE SAMPLE JOB               **/\n/** DISP    : THE OUTPUT FILE ALLOCATION DISPOSITION     **/\n/** MSCA    : THE ID TO INCLUDE IN A USER= CARD IF NEEDED**/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE                         **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (NEEDS VGETS)               **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/.A                **/\n/**                                                      **/\n/**********************************************************/\nARG DSN JPARM\nADDRESS ISPEXEC\n\"ISPEXEC VGET DS6 PROFILE\"\n\"ISPEXEC VGET MSCA PROFILE\"\nSAY \"TSA101D: T50JCARD: IS IN CONTROL WITH PARMS : \" DSN JPARM\nADDRESS TSO \"ALLOC DDN(JCFILE) DSN(\"DS6\") SHR REUS\"\nJNAME= JPARM\nIF JPARM = '' THEN JNAME = \"TSSJOB\"\nTIME = TIME(NORMAL)\nT12 = SUBSTR(TIME,1,2)\nT45 = SUBSTR(TIME,4,2)\nIF JPARM = \"RANDOM\" THEN\n  JNAME= \"TSSJ\"T12||T45\nADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DSN\") SHR REUS\"\nADDRESS MVS \"EXECIO * DISKR JCFILE (FINIS STEM LINE.)\"\nJOBCARD_INSERT = 99\nDO Q = 8 TO 1 BY -1 /* LETS FIND WHERE THE JOBCARD ENDS */\n  INLINE = LINE.Q\n  IF SUBSTR(INLINE,1,3) = \"//*\" THEN JOBCARD_INSERT = Q - 1\n  IF SUBSTR(INLINE,1,2) = \"/*\" THEN JOBCARD_INSERT = Q - 1\n  IF INDEX(INLINE,\"EXEC\") > 0  THEN JOBCARD_INSERT = Q - 1\nEND\nSAY \"TSA101D: T50JCARD JOBCARD ENDS PRIOR TO LINE\" JOBCARD_INSERT\nIF JPARM = \"SUPER\" THEN DO\n  JNAME= \"TSSJ\"T12||T45\n  LINE.JOBCARD_INSERT= \"// \"WORD(LINE.JOBCARD_INSERT,2)||\",USER=\"MSCA\n  SAY \"TSA101D: JCARD ADDITION : \" LINE.JOBCARD_INSERT\nEND\nLEN1= LENGTH(LINE.1)\nHOLD = SUBSTR(LINE.1,11)\nLINE.1= \"//\"JNAME HOLD\nADDRESS MVS \"EXECIO * DISKW OUTFILE (FINIS STEM LINE.)\"\nADDRESS TSO \" FREE DDN(JCFILE)  \"\nADDRESS TSO \" FREE DDN(OUTFILE) \"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50LSTO": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\"\\x00\\x98(/\\x00\\x99\\'?\\x15V\\x00.\\x00.\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-09T00:00:00", "modifydate": "1999-09-30T15:56:22", "lines": 46, "newlines": 46, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID DATA DS1\n HEX00 = '00'X\n DISP = \"SHR\"\n SYSENV = SYSVAR(SYSENV)\n SAY HEX00\n SECRC = \"FAILED IN T50LSTO. CHECK ACIDS VALIDITY\"\n SECRC = SECRC||\" AND YOUR CURRENT AUTHORITY\"\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n   ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n END\n IF DISP = \"\" THEN DISP = SHR\n SIGNAL ON ERROR NAME SEEYA\n SS = OUTTRAP('OUTLINE.')\n  /******************************************************************/\n  /* THIS EXEC PRINTS OUTPUT TO A DSN.                              */\n  /* IT IS VERY SIMPLE......DAVE 20 MAY 91                          */\n  /******************************************************************/\nIF DATA  = \"  \" THEN  DATA=\"ALL\"\nIF DATA  = \"ALLPW\" THEN  DATA=\"ALL,PASSWORD\"\nIF DATA  = \"DATAAREA\" THEN DO\n  ADDRESS ISPEXEC \"VGET DATAAREA PROFILE\"\n  DATA = DATAAREA\nEND\nSAY \"T50LSTO: ALLOCATING DSN\" DS1\n\"ALLOC DDN(OUTFILE) DSN(\"DS1\") \"DISP\" REUS\"\nSAY \"T50LSTO: CALLING TSS FOR LIST OF ID \" ACID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n SECRC = \"FUNCTION COMPLETED. OUTPUT IN \" DS1\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50PER": {"ttr": 2843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00F\\x00\\x990O\\x00\\x991/\\t\\x14\\x00g\\x00g\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-31T00:00:00", "modifydate": "1999-11-08T09:14:46", "lines": 103, "newlines": 103, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG ACID RESTYPE RESNAME ACCESS DAYS\nSIGNAL OFF ERROR\nSECRC = \"T50PER FAILED WITH ERRORS\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nRES.0 = 3\nRES.1 = \"DATASET\"\nRES.2 = \"JESSPOOL\"\nRES.2 = \"VOL\"\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE ASTERISK WITH Z */\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = RESTYPE THEN VALID = \"YES\"\nEND\nIF VALID /= \"YES\" THEN DO\n  SAY \"T50PER: RESTYPE NOT SUPPORTED. RESTYPE = \" RESTYPE\n  MSG2 = \"THE FOLLOWING RESTYPE WAS NOT RECOGNIZED\" RESTYPE\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  EXIT 08\nEND\nACTION = \"ACTION(FAIL)\"\nIF DAYS /= \" \" THEN DAYCMD = \"FOR(\"DAYS\")\"\nSLASH = INDEX(\"/\",DAYS)\nIF SLASH > 0 THEN DAYCMD = \"UNTIL(\"DAYS\")\"\nDAY1 = WORD(DAYS,1)\nSIGNAL NOCHECK\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE DOTS WITH SPACES */\nACCCHK = ACCESS\nQ = OUTTRAP(HOLD.,5)\nIF ACCESS = \"ALL\" THEN ACCCHK = \"ALTER\"\nIF ACCESS = \"REMOVE\" THEN ACCCHK = \"ALTER\"\nSAY \"T50PER: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nSAY \"T50PER: RES IS \" RESNAME\nSAY \"********CHECK IS BELOW **************\"\nSAY \" TSSCHECK(\"RESTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\nX5 = TSSCHECK(RESTYPE,RESCHK,ACCCHK,\"NOMSG\")\nSAY \"********CHECK IS BELOW **************\"\nSAY \"T50PER: TSSCHECK RETURN CODE IS \" X5\nIF X5 \u00ac= \"OK\"  THEN DO\n  SECRC = \"YOU CANNOT GRANT THAT LEVEL OF ACCESS TO THAT RESOURCE.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nNOCHECK: NOP\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T50PER: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\n/********************************/\n/* LETS ACTUALLY DO THE WORK... */\n/********************************/\nQ = OUTTRAP(OUT.,5)\nIF RESTYPE = \"DATASET\" THEN RESTYPE = \"DSN\"\nIF ACCESS = \"REMOVE\" THEN DO\n  \"TSS REV(\"ACID\") \"RESTYPE\"(\"RESNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"AUTHORITY REMOVED FOR ID \"ACID\".\"\n  ELSE DO\n    SECRC = \"REMOVE RETURNED NON ZERO RCODE OF \"RCODE\n    MSG2 = OUT.1\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") \"RESTYPE\"(\"RESNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"RESNAME\")\",\n  \"ACCESS(\"ACCESS\")\" DAYCMD ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  secrc = \"TSA521I: permit function successful for id\" acid\nELSE DO\n  secrc = \"TSA522I: permit returned non zero rcode of \"rcode\n  MSG2 = OUT.1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50PMENU": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00H\\x00\\x98#/\\x01\\x00\\x07_\\x10S\\x02\\x96\\x02\\x96\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-08-20T00:00:00", "modifydate": "2000-03-15T10:53:48", "lines": 662, "newlines": 662, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added  security checking for datsets                 **/\n/**********************************************************/\n/** added  privpgm support 11 nov 97                     **/\n/**********************************************************/\n/** added  support for the STC record by creating        **/\n/** the DELTRUNC. variable to be referenced in deletes   **/\n/**********************************************************/\n/** added  support for the user TSO area. dir 1 oct 97   **/\n/**********************************************************/\n/** Fixed truncation of last data line and added sitran  **/\n/** support.     dave 29 aug 97                          **/\n/**********************************************************/\n/** NOW SUPPORTS LCF CMDS     DIR 28 AUG 97              **/\n/**********************************************************/\n/** MODIFY PROFILES IN A PANEL BASED ENVIRONMENT         **/\n/** LOTS  OF SAYS   TO FACILITATE DEBUGGING...           **/\n/**********************************************************/\n/** EXEC NAME        : T50PMENU                          **/\n/** LAST MODIFIED    : 25 MAR 97                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS3     : THE BATCH FILE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD  = THE VALID COMMANDS FOR THIS ENTRY   \"ADD REM\" **/\n/** TYPE = THE RESOURCE TYPE                   \"DATASET\" **/\n/** RSNAME= THE RESOURCE NAME                  \"SYS1.  \" **/\n/** ACCESS=THE ACCESS LEVEL                    \"UPDATE \" **/\n/** ACTION=THE ACTION TO TAKE                  \"FAIL   \" **/\n/** UNTIL= THE EXPIRATION DATE OF RULE  \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/** OTHER   = ANYTHING ELSE             \"DAYS(MON.TUE)  \"**/\n/** DELTRUNC= Number of words to retain of the resource \"**/\n/**           name when doing a delete function.         **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** OUT_COUNT = THE # OF OUTPUT CHANGES                  **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS3  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nCALL OFF ERROR\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50PMENU. CHECK ACIDS VALIDITY\"\nSECRC = SECRC||\" AND YOUR CURRENT AUTHORITY\"\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS3 PROFILE\"\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\nEND\nDELTRUNC. =  0\nF0        =  \" \"\nUNTIL.    =  \" \"\nACCESS.   =  \" \"\nRSNAME.   =  \" \"\nOTHER.    =  \" \"\nLIBRARY.  =  \" \"\nFACILITY. =  \" \"\nPGM.      =  \" \"\nCOMMAND_FALLTHRU = \"ADD REM\"\nCMD.      =  \"PER REV\"\nACTION.   =  \" \"\nIF DISP = \"\" THEN DISP = SHR\nSIGNAL ON ERROR NAME BYEBYE\nDATA=\"ALL,EXPIRE\"\nIF MODE = \"ONLINE\" THEN DO\n  SAY \"T50PMENU: ALLOCATING DSN\" DS3\n  ADDRESS TSO \"%T50JCARD\" DS3\n  \"ALLOC DDN(BJCL) DSN(\"DS3\") MOD REUS\"\nEND\nSAY \"T50PMENU: CALLING TSS FOR LIST OF ID \" ACID\nSS = OUTTRAP('INLINE.')\nSIGNAL ON ERROR NAME BADID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nRCODE = RC\nSIGNAL ON ERROR NAME BYEBYE\nTHISREC = 3\nOUT_COUNT = 0\nOUTNUM = 0\nSAY \"T50PMENU: HAS A TOTAL RECORD COUNT OF \" inline.0\nDO I = 1 TO INLINE.0\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\") /* REPLACE = WITH SPACES */\n  /***********************************************************/\n  /** Kill those = signs.. very important to know for the   **/\n  /** lower loop...    Dave 29 Aug 97                       **/\n  /***********************************************************/\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  /****************************/\n  /* SAVE THE LAST LINE HEADER*/\n  /****************************/\n  FIRST13 = SUBSTR(LINE,1,13)\n  IF FIRST13 \\= \"             \" THEN SAVE13 = FIRST13\n  IF SUBSTR(LINE,1,2) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  /***********************************************************/\n  /** Reformatter area                                      **/\n  /** The lower loop operates on the principal that each    **/\n  /** line contains enough data to recreate any command     **/\n  /** pertaining to the resources mentioned there.          **/\n  /** I created this area for LCF commands, where lines do  **/\n  /** not mention the facilites that they are affecting     **/\n  /** nor do they mention the type of resource they are     **/\n  /** securing. So I 'proprogate' the first 13 chars of     **/\n  /** the line that does have this data to the lower        **/\n  /** lines.      DAVE 29 AUG 97                            **/\n  /***********************************************************/\n  IF (SAVE13 = \" AUTH CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"AUTH CMDS  \"||LINE\n  IF (SAVE13 = \" EXMP CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"EXMP CMDS  \"||LINE\n  IF SAVE13 = \" AUTH CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  IF SAVE13 = \" EXMP CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  /****************************/\n  /** END OF REFORMATTER AREA**/\n  /****************************/\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  IF FIRST13 = \"LCF FAC     \" THEN LCFFAC = W.3\n  IF W.1 = \"XA\" THEN DO\n    OUTNUM = OUTNUM + 1\n    CMD.OUTNUM = \"PER REV\"\n    IF W.2 = \"DATASET\" THEN W.2 = \"DSN\" /* FIX FOR ADD/PER WITH DSNS*/\n    TYPE.OUTNUM = W.2\n    RSNAME.OUTNUM = W.3\n    UNTIL.OUTNUM = W.4\n    ITERATE I\n  END\n  IF W.1 = \"ACCESS\" THEN DO\n    ACCESS.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"DAYS\" THEN DO\n    OTHER.OUTNUM = \"DAYS(\"W.2\")\"  W.3 W.4 W.5 W.6 W.7 W.8 W.9\n    OTHER.OUTNUM = STRIP(OTHER.OUTNUM)\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n  IF W.1 = \"STC\" THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"PROCNAME(\"W.2\") acid(\"w.4\")\"\n    DELTRUNC.OUTNUM = 1 /* TO DEL THIS RULE ONLY USE WORD # 1 */\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n/*************************************************/\n/* SITRAN     = M3CL      FACILITY   = FINTST1   */\n/* TSS ADD(CONSPROF) SIT(M3CL,FINTST1)           */\n/*************************************************/\n  IF W.1 = \"SITRAN\"   THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"SIT(\"W.2\",\"W.4\")\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$SITRAN\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$ATTRIB\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    PGM.OUTNUM = W.2 W.3 W.4 W.5 W.6\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  END\n  /*************************************************/\n  /* below is the processing for the tso area      */\n  /* note that it checks handles all tso prefixed  */\n  /* words............  dir 1 oct 97               */\n  /*************************************************/\n  IF SUBSTR(W.1,1,3) = \"TSO\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  /*************************************************/\n  /* Below is the area for words to ignore         */\n  /*************************************************/\n  END\n  IF W.3 = \"NAME\" THEN iterate i\n  IF W.1 = \"DEPT\" THEN ITERATE I\n  IF W.1 = \"ZONE\" THEN ITERATE I\n  IF W.1 = \"DIV\" THEN ITERATE I\n  IF W.1 = \"TYPE\" THEN ITERATE I\n  IF W.1 = \"CREATED\" THEN ITERATE I\n  IF W.1 = \"TSS0300I\" THEN ITERATE I\n  IF W.1 = \"LAST\" THEN ITERATE I\n  IF W.1 = \"ACID\" THEN ITERATE I\n  /*************************************************/\n  /* Below is the area to change fallthru defaults */\n  /*************************************************/\n  IF W.1 = \"LIST\" & W.2 = \"DATA\"  THEN do\n    w.1 = \"DATA\";w.2 = w.3;w.3 = \" \"\n  end\n  IF INDEX(W.2,\"*ALL*\") THEN DO\n    PARSE VAR W.2  TZ1 '*ALL*' TZ2\n    W.2 = TZ1||\"ALL\"TZ2\n  END\n  IF W.2 = \"ADMINISTRATION\" & W.3 = \"AUTHORITIES\"  THEN\n    COMMAND_FALLTHRU = \"ADMIN DEADMIN\"\n  /*************************************************/\n  /* below is the fall thru area                   */\n  /* I take my best guess at the command           */\n  /*      ............  dir 29 jan 99              */\n  /*************************************************/\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM =  command_fallthru\n  ITERATE I\nEND\n/*******************************************************/\n/*******************************************************/\n/** End of loop now we create the output lines DIR    **/\n/*******************************************************/\n/*******************************************************/\nOUTNUM = OUTNUM + 1\nIF OUTNUM < 15 THEN DO A = OUTNUM TO 15\n  CMD.A      = \"PER REV\"\n  TYPE.A        = \" \"\n  RSNAME.A      = \" \"\n  ACCESS.A      = \" \"\n  OUTNUM = 15\nEND\nCALL FILLSCR\nSCANSCR: NOP\nDO T = 1 TO 14\n  IF F.T  = 'S' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    CALL SHOWRULE\n  END\n  IF F.T  = 'D' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN  CALL DELRULE\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T50PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'M' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN DO\n      CALL DELRULE\n      SAY \"T50PMENU: TYPE AFTER RULE PROCESSING IS \" TYPE.T\n      FLAG = \"*MODIFY\"\n      CALL MODRULE\n    END\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T50PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'A' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    F.T = \" \"\n    F0 = \"\"\n    DO TEMP3 = OUTNUM TO T BY - 1\n      BEFORE = TEMP3 - 1\n      F.TEMP3 = F.BEFORE\n      INTERPRET \"F\"||TEMP3 \"= F\"||BEFORE\n    END\n    OUTNUM = OUTNUM + 1\n    FILL = THISREC + T - 1\n    TARGET = FILL + 1\n    SAY \"T50PMENU: RECNUM IS  \" FILL\n    SAY \"T50PMENU: ACCESS IS  \"ACCESS.FILL\n    SAY \"T50PMENU: TYPE IS    \"TYPE.FILL\n    SAY \"T50PMENU: RSNAME IS  \"RSNAME.FILL\n    DO Q = OUTNUM TO TARGET BY -1\n      Q1 = Q - 1\n      FACILITY.Q = FACILITY.Q1\n      ACTION.Q   = ACTION.Q1\n      PGM.Q      = PGM.Q1\n      LIBRARY.Q  = LIBRARY.Q1\n      ACCESS.Q   = ACCESS.Q1\n      TYPE.Q     = TYPE.Q1\n      UNTIL.Q    = UNTIL.Q1\n      RSNAME.Q   = RSNAME.Q1\n    END\n    FLAG = \"*NEWRULE\"\n    CALL MODRULE\n    F.T = \" \"\n  END\nEND\nCALL FILLSCR\nADDRESS ISPEXEC \"DISPLAY PANEL(\"SECPROF\")\"\nCALL FILLSCR\nIF RC > 0 THEN SIGNAL BYEBYE\n/* IF OPT = \"NEXTM\" THEN THISREC = THISREC + 14         */\n/*IF OPT = \"PREVM\" THEN THISREC = THISREC - 14           */\nsay \"option is \"opt\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"F\") THEN OPT = \" \"\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"FIND\") THEN OPT = \" \"\nIF WORDS(OPT) = 1 THEN SIGNAL NOLOOP\nIF (WORD(OPT,1) = \"FIND\") | (WORD(OPT,1) = \"F\") then do\n  HOLD2 = WORD(OPT,2)\n  TGTNUM = OUTNUM - 14\n  HIT = \"NO\"\n  DO TF1 = THISREC TO OUTNUM\n    IF INDEX(TYPE.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(RSNAME.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(ACCESS.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF HIT = \"YES\" THEN THISREC = TF1\n    IF HIT = \"YES\" THEN LEAVE\n  END\n  IF THISREC > TGTNUM THEN THISREC = TGTNUM\nEND\nnoloop: nop\nIF WORD(OPT,1) = \"PREVM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC - 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = THISREC - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = 1\nend\nIF WORD(OPT,1) = \"NEXTM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC + 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = OUTNUM - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = OUTNUM - 14\nEND\nIF OPT = \"QUIT\" THEN SIGNAL BYEBYE\nOPT = \" \"\nSIGNAL SCANSCR\nSAY \"T50PMENU : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/*DO X = 1 TO OUTNUM                                                */\n/*  BATFILE.X =  X CMD.X TYPE.X RSNAME.X UNTIL.X ACCESS.X LIBRARY.X,*/\n/*  ACTION.X                                                        */\n/*END                                                               */\n\"EXECIO \"OUT_COUNT\" DISKW BJCL ( FINIS STEM BATFILE.)\"\n SECRC = \"FUNCTION COMPLETED. OUTPUT IN \" DS3\n IF MODE = \"BATCH\" THEN\n   SECRC = \"FUNCTION COMPLETED. OUTPUT APPENDED TO BATCH FILE.\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nBADID: NOP\n SECRC = \"ID LIST FAILED, CHECK YOUR AUTHORITIES AND IDS EXISTANCE\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nSEEYA: NOP\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/******************************************************************/\n/**  THE SHOWRULE SECTION                                        **/\n/******************************************************************/\nSHOWRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. OTHER.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nSAY \"T50PMENU: TEMP IS \" TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nRSNAME   = RSNAME.TEMP\nSAY \"T50PMENU: INSIDE SHOWRULE ROUTINE\"\nSAY \"T50PMENU: ACTION IS   \"  ACTION\nSAY \"T50PMENU: FACILITY IS \"  FACILITY\nSAY \"T50PMENU: PGM IS      \"  PGM\nSAY \"T50PMENU: ACCESS IS   \"  ACCESS\nSAY \"T50PMENU: LIBRARY IS  \"  LIBRARY\nSAY \"T50PMENU: UNTIL IS    \"  UNTIL\nSAY \"T50PMENU: TYPE IS     \"  TYPE\nSAY \"T50PMENU: RSNAME IS   \"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECSHOW)\"\nADDRESS ISPEXEC \"REMPOP\"\nRETURN\n/*******************************************************/\n/**              THE SECURITY CHECK                   **/\n/*******************************************************/\nSECURE: PROCEDURE EXPOSE TYPE. RSNAME. ACCESS. T,\n       ACTION. THISREC CMD. FLAG,\n       ACID OTHER. SECCODE\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nCALL OFF ERROR\nVALID = \"NO\"\nTEMP   = T + THISREC - 1\nOUT_RNAME = RSNAME.TEMP\nACCESS   = ACCESS.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T50PMENU(SECURE): MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nRES.0 = 2\nRES.1 = \"DSN\"\nRES.2 = \"JESSPOOL\"\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = TYPE THEN VALID = \"***DISABLED***\"\nEND\nIF TYPE = \"*SECURE\" THEN SECCODE = 16\nSAY \"MODRULE VALID IS\" VALID\nIF VALID = \"YES\" THEN DO\n  RESCHK = TRANSLATE(RSNAME,\"Z\",\"*\") /* REPLACE * WITH zzzzzz */\n  ACCCHK = \"ALTER\"\n  IF TYPE = \"DSN\" THEN TYPE = \"DATASET\"\n  RSTYPE = STRIP(TYPE)\n  /* Q = OUTTRAP(HOLD.,5)  */\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \" TSSCHECK(\"RSTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\n  SECCODE = TSSCHECK(RSTYPE,RESCHK,ACCCHK,\"NOMSG\")\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \"T50PMENU(MODRULE): TSSCHECK RETURN CODE IS \" SECCODE\nEND\nRETURN\n/*******************************************************/\n/******************************************************************/\n/**  THE MODRULE SECTION                                         **/\n/******************************************************************/\n/*******************************************************/\nMODRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. CMD. BATFILE. OUT_COUNT FLAG,\n       ACID OTHER. SECCODE\nCALL OFF ERROR\nOUT_COUNT = OUT_COUNT + 1\nSAY \"T50PMENU: RECNUM IS \" FILL\nTEMP   = T + THISREC - 1\nSAY \"T50PMENU: RECNUM IS \" TEMP\nOUT_CMD = WORD(CMD.TEMP,1)\nOUT_RNAME = RSNAME.TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T50PMENU: MODRULE TYPE WAS :\" TYPE\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = FLAG TYPE\nSAY \"T50PMENU: MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nSAY \"T50PMENU: INSIDE MODRULE  ROUTINE\"\nSAY \"T50PMENU: ACTION IS\"  ACTION\nSAY \"T50PMENU: FACILITY IS \"  FACILITY\nSAY \"T50PMENU: PGM IS\"  PGM\nSAY \"T50PMENU: ACCESS IS\"  ACCESS\nSAY \"T50PMENU: LIBRARY IS\"  LIBRARY\nSAY \"T50PMENU: UNTIL IS\"  UNTIL\nSAY \"T50PMENU: TYPE IS\"  TYPE\nSAY \"T50PMENU: RSNAME IS\"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECUPDT)\"\nRCODE = RC\nADDRESS ISPEXEC \"REMPOP\"\nIF RCODE > 0 THEN DO\n  OUT_COUNT = OUT_COUNT - 1  /* KILL THE DELETE ENTRY */\n  TYPE.TEMP = TYPE           /* RESET THE TYPE FIELD */\n  MSG = \" MODIFY ABORTED DUE TO PANEL RETURN CODE.\"\n  RETURN\nEND\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"RSNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  H = H||TYPE||\"(\"RSNAME\") + \"\nEND\nBATFILE.OUT_COUNT = H\nH =  ''\nOUT_COUNT = OUT_COUNT + 1\nIF LENGTH(UNTIL) = 8 THEN UNTIL = \"UNTIL(\"UNTIL\")\"\nIF ACCESS <> '' THEN H = H||\"ACCESS(\"ACCESS\") \"\nIF LIBRARY <> '' THEN DO\n  H = H||\"LIBRARY(\"LIBRARY\") + \"\n  BATFILE.OUT_COUNT = \"  \"||H\n  H =  ''\n  OUT_COUNT = OUT_COUNT + 1\nEND\nIF PGM <> '' THEN H = H||\"PRIVPGM(\"PGM\") \"\nIF UNTIL  <> '' THEN H = H||\" \"UNTIL\nIF ACTION <> '' THEN H = H||\" ACTION(\"ACTION\") \"\nIF FACILITY <> '' THEN H = H||\" FAC(\"FACILITY\") \"\nIF OTHER <> '' THEN H = H OTHER\nBATFILE.OUT_COUNT = \"  \"||H\nPGM.TEMP      = PGM\nACCESS.TEMP   = ACCESS\nLIBRARY.TEMP  = LIBRARY\nACTION.TEMP   = ACTION\nFACILITY.TEMP = FACILITY\nUNTIL.TEMP    = UNTIL\nRSNAME.TEMP    = RSNAME\nRETURN\n/******************************************************************/\n/** THE DELETE RULE SECTION                                      **/\n/******************************************************************/\nDELRULE: PROCEDURE EXPOSE TYPE. RSNAME. T ACID,\n        THISREC UPDATE. CMD. BATFILE. OUT_COUNT DELTRUNC.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nOUT_COUNT = OUT_COUNT + 1\nTYPE= TYPE.TEMP\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = \"*DELETE\" TYPE.TEMP\nOUT_ACID = ACID\nOUT_CMD = WORD(CMD.TEMP,2)\nOUT_RNAME = RSNAME.TEMP\nOUT_TRUNC = DELTRUNC.TEMP\n/******************************/\n/** truncate the rsname maybe**/\n/******************************/\nIF OUT_TRUNC = 1 THEN OUT_RNAME = WORD(OUT_RNAME,1)\nIF OUT_TRUNC = 2 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2)\nIF OUT_TRUNC = 3 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2) WORD(OUT_RNAME,3)\nIF SUBSTR(TYPE,1,1) = \"*\" THEN TYPE = WORD(TYPE,2) WORD(TYPE,3)\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"OUT_RNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  /*                         */\n  H = H||TYPE||\"(\"OUT_RNAME\")\"\nEND\nBATFILE.OUT_COUNT = H\n/* SAY OUT_COUNT */\n/* SAY H*/\nRETURN\nFILLSCR: PROCEDURE EXPOSE THISREC OUTNUM TYPE. RSNAME. ACCESS. T,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 TYPE1 TYPE2 TYPE3,\n TYPE4 TYPE5 TYPE6 TYPE7 TYPE8 TYPE9 TYPE10 TYPE11 TYPE12 TYPE13,\n ACCESS1 ACCESS2 ACCESS3 ACCESS4 ACCESS5 ACCESS6 ACCESS7 ACCESS8,\n ACCESS9 ACCESS10 ACCESS11 ACCESS12 ACCESS13 ACCESS14 TYPE14,\n RSNAME1 RSNAME2 RSNAME3 RSNAME4 RSNAME5 RSNAME6 RSNAME7 RSNAME8,\n RSNAME9 RSNAME10 RSNAME11 RSNAME12 RSNAME13 RSNAME14,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F.\nOPT = \" \"\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nIF (THISREC > OUTNUM - 14)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\nDO T = 1 TO 14\n  FILL = THISREC + T - 1\n  INTERPRET \"F.\"T \"=  F\"||T\n  IF WORDS(TYPE.FILL) > 2 THEN DO\n    SAY \"T50PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n    TYPE.FILL = WORD(TYPE.FILL,1) WORD(TYPE.FILL,3)\n    SAY \"T50PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n  END\n  INTERPRET \"TYPE\"||T \" =  TYPE.FILL\"\n  INTERPRET \"RSNAME\"||T \"= RSNAME.FILL\"\n  INTERPRET \"ACCESS\"||T  \"=  ACCESS.FILL\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50PWHO": {"ttr": 281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00G\\x00\\x97 /\\x01\\x00\\x07_\\x10S\\x00\\x8d\\x00\\x8d\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-03-15T10:53:47", "lines": 141, "newlines": 141, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added an exit with rc=8 for a bad tss id.             */\n/**********************************************************/\n/** Changed to use t50gdat for type processing            */\n/** should be faster for departments and divisions than   */\n/** the older routine.  Dave                              */\n/**********************************************************/\n/** Changed to support all listopt parm which allows      */\n/** all IDs to be listed including departments profiles   */\n/** and security administrators.           Dave           */\n/**********************************************************/\n/**********************************************************/\n/** NO SAYS CAUSE  THIS PGM IS EXPECTED TO WRITE OUTPUT  **/\n/** DATA DIRECTLY TO THE SCREEN.   DAVE                  **/\n/**********************************************************/\n/** EXEC NAME        : T50PWHO                           **/\n/** LAST MODIFIED    : 15 July 97                        **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** PROF    : THE TARGET ID OF THE LIST.                 **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG PROF LISTALL\nENV = SYSVAR(SYSENV)\nsecrc = \"List function failed. ACID may be invalid.\"\nIF ENV = \"FORE\" THEN DO\n  ADDRESS TSO \"%T50GDAT \"PROF\" TYPE\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  IF TYPE = \"$BADTSS\" THEN EXIT 08\n  secrc = \"List function failed. ACID may be invalid.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  IF TYPE = \"MASTER\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"PROFILE\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"DIVISION\" THEN DIVFLAG = \"YES\"\n  IF TYPE = \"DEPT\" THEN DEPTfLAG = \"YES\"\n  IF TYPE = \"ZONE\" THEN ZONEFLAG = \"YES\"\nEND\nIF ENV /= \"FORE\" THEN DO\n  SPACES = \"                                \"\n  Q = OUTTRAP(\"TYPE.\")\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(BASIC)\"\n  DO T = 1 TO TYPE.0\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DIVISION\") THEN\n      DIVFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DEPT\") THEN\n      DEPTFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"MASTER\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"PROFILE\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"ZONE\") THEN\n      ZONEFLAG = \"YES\"  /* FOR LATER ENHANCEMENTS */\n  END\nEND\nIF NORMFLAG = \"YES\" THEN DO\n   ACID.1   = PROF\n   CALL PRINTDPT /* A DEPT OR PROFILE WAS GIVEN. NO PROBLEM. */\n   EXIT 00\nEND\nIF ZONEFLAG = \"YES\" THEN DO     /* ZONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") TYPE(USER)\"\nEND\nIF DEPTFLAG = \"YES\" THEN DO     /* DEPT PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") TYPE(USER)\"\nEND\nIF DIVFLAG = \"YES\" THEN DO     /* DIVISIONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") TYPE(USER)\"\nEND\n/*                       */\nSECRC = \"FUNCTION COMPLETED NORMALLY.\"\nIF ENV = \"FORE\" THEN\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nPRINTDPT: PROCEDURE EXPOSE ACID. LISTALL\nDO IDNUM = 1 TO 4\n  Q = OUTTRAP(\"TYPE.\")\n  IF ACID.IDNUM = \"  \" THEN RETURN\n  IF ACID.IDNUM = \"ACID.\"IDNUM THEN RETURN\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(BASIC)\"\n  IF LISTALL = \"YES\" THEN SAY ACID.IDNUM\n  Q = OUTTRAP(\"OFF.\",0)\n  NORMAL = \"NO\"\n  DO T = 1 TO TYPE.0\n    W1 = WORD(TYPE.T,1)\n    W3 = WORD(TYPE.T,3)\n    IF W1 = \"TYPE\" THEN DO\n      IF W3 = \"DEPT\" THEN NORMAL = \"YES\"\n      IF W3 = \"MASTER\" THEN NORMAL = \"YES\"\n      IF W3 = \"PROFILE\" THEN NORMAL = \"YES\"\n      IF NORMAL = \"NO\" THEN DO\n        SAY ACID.IDNUM /* AN UNUSUAL USER */\n        ITERATE IDNUM\n      END\n    END\n  END\n  /********************************************************/\n  /* SINCE WE ARE HERE THIS ACID MUST BE A DEPARTMENT!    */\n  /********************************************************/\n  Q = OUTTRAP(\"OUT.\")\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(ACIDS)\"\n  Q = OUTTRAP(\"OFF.\",0)\n  GOFLAG = \"NO\"\n  DO T = 1 TO OUT.0\n    IF WORD(OUT.T,1) = \"ACIDS\" THEN GOFLAG = \"YES\"\n    IF WORD(OUT.T,1) = \"TSS0300I\" THEN LEAVE\n    IF WORD(OUT.T,1) = \"TSS300I\" THEN LEAVE\n    IF GOFLAG = \"YES\" THEN DO\n      /*SAY \"OUT.T IS  \"OUT.T */\n      PRT.1 = SUBSTR(OUT.T,14,8)\n      PRT.2 = SUBSTR(OUT.T,26,8)\n      PRT.3 = SUBSTR(OUT.T,38,8)\n      PRT.4 = SUBSTR(OUT.T,50,8)\n      DO X = 1 TO 4\n        IF PRT.X = \"*NONE*\" THEN PRT.X = \"  \"\n        IF PRT.X \u00ac= \"  \" THEN SAY PRT.X\n        PRT.X = \"  \"\n      END\n    END\n  END\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(ACIDS)\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50RCON": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x00\\x00\\x12\\x00\\x98'_\\x00\\x99\\x13\\x1f\\x13Y\\x00\\x9b\\x00\\x9b\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-02T00:00:00", "modifydate": "1999-05-11T13:59:12", "lines": 155, "newlines": 155, "modlines": 0, "user": "*SPIV8*"}, "text": "/**REXX THE WONDER DOGG                                  **/\n/**********************************************************/\n/** V10R1M3 ADDED GENERIC VOLUME PARENTHETICAL SUPPORT   **/\n/**********************************************************/\n/** ADDED SUPPROT FOR THE LIBRARY PARM ON PERMITS        **/\n/**********************************************************/\n/** EXEC NAME        : T50RCON                           **/\n/**********************************************************/\n/** CONVERTS ALL RESOURCE    RULES FOR A SPECIFIC RESOURCE*/\n/** DATABASE WIDE. SAME PREMISE AS AN ID CONVERT, BUT THE**/\n/** RESOURCE MUST BE SUBJECT TO THE TSS WHOHAS COMMAND   **/\n/**********************************************************/\n/** LAST MODIFIED    :  5 OCT 98                         **/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** INPUT PARMS      VALUE                               **/\n/** RTYPE            THE TYPE OF THE RESOURCE            **/\n/** RNAME            THE NAME OF THE RESOURCE            **/\n/** ALTOPT           \"    \" OR \"REMOVE\" OR \"AUDIT\"       **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (NEEDS VGET VARS THOUGH)    **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T50JCARD             **/\n/**                                                      **/\n/**********************************************************/\nARG RTYPE RNAME ALTOPT\nMAINT = \"V10R1M3\"\nADDRESS ISPEXEC\n\"VGET DS1 PROFILE  \"\n\"VGET DS2 PROFILE  \"\n\"VGET DS3 PROFILE  \"\n\"VGET DS4 PROFILE  \"\n\"VGET DS5 PROFILE  \"\n\"VGET DS6 PROFILE  \"\nSECRC = \"T50RCON RECEIVED CONTROL BUT HAD ERRORS\"\n\"VPUT SECRC PROFILE\"\nIF RTYPE = \"BYPASS\" & ALTOPT = \"\" THEN ALTOPT = RNAME\nSAY \"T50RCON: RECEIVING CONTROL\" MAINT RTYPE RNAME ALTOPT\nADDRESS TSO\nOUTNUM = -1\nIF ALTOPT = \"REMOVE\" THEN OUTNUM = 0\nUNTIL = \"\"\nSAY \"T50RCON: CALLING T50JCARD TO \" DS2\nADDRESS TSO \"%T50JCARD\" DS2 \"RANDOM\"\nSAY \"T50RCON: BACK FROM T50JCARD\"\nSAY \"T50RCON: I WILL TRY TO ALLOCATE \" DS2\n\"ALLOC DDN(OUTFILE) DSN(\" DS2\") MOD REUS\"\nSAY \"T50RCON: I HAVE ALLOCATED \" DS2\nIF ALTOPT = \"REMOVE\" THEN\n  SAY \"T50RCON: REMOVE OPTION HAS BEEN CONFIRMED. \"\nIF RTYPE = \"BYPASS\" THEN DO\n  SAY \"T50RCON: BYPASS PARM DETECTED. ALLOCATING \" DS1 \"FOR INPUT\"\n  \"ALLOC DDN(INFILE) DSN(\"DS1\") SHR REUS\"\n  SAY \"T50RCON: I HAVE ALLOCATED \" DS1 \"SUCCESSFULLY\"\n  \"EXECIO * DISKR INFILE (FINIS STEM LINE.)\"\n  \"FREE DDN(INFILE)\"\n  RTYPE = WORD(LINE.1,1)\n  END\nELSE DO\n  SAY \"T50RCON: ISSUEING THE COMMAND TSS WHOHAS\" RTYPE\"(\"RNAME\")\"\n  Q = OUTTRAP(\"LINE.\")\n  \"TSS WHOHAS \"RTYPE\"(\"RNAME\")\"\nEND /* ENDIF  */\nSAY \"T50RCON: I HAVE \" LINE.0 \"LINES OF DATA TO BE PROCESSED\"\nDO X = 2 TO LINE.0\n  INLINE = LINE.X\n  X1 = X + 1\n  NEXTLINE = LINE.X1\n  /* V1R1M3 */\n  /** ONLY CHANGE PARENS WHEN THEY OCCUR AT THE END OF THE RECORD */\n  ENDLINE = SUBSTR(INLINE,40)\n  BEGLINE = SUBSTR(INLINE,1,39)\n  ENDLINE = TRANSLATE(ENDLINE,\" \",\")\")\n  ENDLINE = TRANSLATE(ENDLINE,\" \",\"(\")\n  INLINE = BEGLINE||ENDLINE\n  /* V1R1M3 */\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n  IF ACID = \"*ALL*\" THEN ACID = \"ALL\"\n  IF W.1 = \"PRIVPGM\" THEN PGM = \"PRIVPGM(\"W.3\")\"\n  IF W.1 = \"LIBRARY\" THEN LIBRARY = \"LIBRARY(\"W.3\")\"\n  IF (W.1 = \"ACTION\") & (W.3 = \"FAIL,PASSWORD\") THEN ITERATE X\n  IF W.1 = \"RESOURCE\" THEN DO\n    OUTNUM = OUTNUM + 1 /* A NEW RNAME IS BORN */\n    OUTLINE.OUTNUM = \" TSS ADD(\"ACID\") \"RTYPE\"(\"RNAME\")\"\n    IF ALTOPT = \"REMOVE\" THEN\n      OUTLINE.OUTNUM = \" TSS REM(\"ACID\") \"RTYPE\"(\"RNAME\")\"\n    ITERATE X\n  END\n  IF (W.1 = \"XAUTH\") | (W.1 = \"TSS0300I\") THEN DO\n    SAY RNAME ACID ACCESS UNTIL ACTION FAC PGM LIBRARY\n    OUTLINE.OUTNUM = \" TSS REV(\"ACID\") \"RTYPE\"(\"RNAME\")\"\n    IF ( ALTOPT = \"REMOVE\" ) | ( ALTOPT = \"AUDIT\" ) THEN DO\n      SAY \"T50RCON: SPECIAL PROCESSING REQUESTED, ALTOPT = \" ALTOPT\n      SAY \"T50RCON: OUTLINE IS \" OUTLINE.OUTNUM\n      OUTNUM = OUTNUM + 1 /* KEEP THE REVOKE   */\n    END\n    /***************************************************/\n    /** KEEP THE ACTION OR OVERLAY IT IF AUDITING     **/\n    /***************************************************/\n    /***************************************************/\n    /** CREATE THE  PERMIT LINE AND THE ACCESS LINE.  **/\n    /***************************************************/\n    OUTLINE.OUTNUM = \" TSS PER(\"ACID\") \"RTYPE\"(\"RNAME\") +\"\n    OUTNUM = OUTNUM + 1 /* ACCESS COMING UP  */\n    OUTLINE.OUTNUM = \"     \" ACCESS PGM UNTIL ACTION FAC LIBRARY\n    OUTNUM = OUTNUM + 1 /* KEEP WHAT WE HAVE */\n    IF (ACCESS = \"ACCESS\") & (ALTOPT = \"AUDIT\") THEN\n       OUTNUM = OUTNUM - 1 /* FIRST RECORD */\n    IF ALTOPT = \"REMOVE\" THEN DO\n      SAY \"T50RCON: DISCARDING PERMITS DUE TO ALOTPT SETTING.\"\n      OUTNUM = OUTNUM - 2 /* KILL PERMIT*/\n    END\n    DISPLAY = OUTNUM - 2\n    DISPLAY1 = OUTNUM - 1\n    SAY \"T50RCON: CREATED OUTLINES ARE\" OUTLINE.DISPLAY\n    SAY \"                            \" OUTLINE.DISPLAY1\n                 /***************************************************/\n    ACCESS = \"\"  /***************************************************/\n    UNTIL  = \"\"  /* BLANK THESE PUPPIES OUT EACH TIME WE WRITE THEM */\n    ACTION = \"\"  /***************************************************/\n    PGM    = \"\"  /***************************************************/\n    LIBRARY = \"\" /***************************************************/\n    FAC    = \"\"  /***************************************************/\n  END\n  DO ANUM = 1 TO 7\n    NEXTA = ANUM + 1\n    NEXTB = ANUM + 2\n    IF W.1    = \"XAUTH\"  THEN RNAME  = W.3\n    IF W.1    = \"PGM\"    THEN PGM    = \"PGM(\"W.3\")\"\n    IF W.1    = \"FAC\"    THEN FAC    = \"FAC(\"W.3\")\"\n    IF W.ANUM = \"UNTIL\"  THEN UNTIL  = \"UNTIL(\"W.NEXTA\")\"\n    IF W.ANUM = \"ACCESS\" THEN ACCESS = \"ACCESS(\"W.NEXTB\")\"\n    IF ALTOPT = \"AUDIT\"  THEN ACTION = \"ACTION(AUDIT)\"\n    IF W.ANUM = \"ACTION\" THEN DO\n      IF (INDEX(W.NEXTB,\"AUDIT\") = 0) & (ALTOPT = \"AUDIT\") THEN,\n        W.NEXTB = W.NEXTB||\",AUDIT\"\n      ACTION = \"ACTION(\"W.NEXTB\")\"\n    END\n    IF W.ANUM = \"ACID\"   THEN ACID   =  W.NEXTA\n  END\nEND\nOUTLINE.OUTNUM = \"@@\"   /* JCL DD DLM MARKER     */\nSAY \"T50RCON: I AM WRITING \"OUTNUM \" LINES OF OUTPUT\"\nIF OUTNUM > 1 THEN\n  \"EXECIO \"OUTNUM\" DISKW OUTFILE( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\nSECRC = \"CONVERSION STREAM CREATED IN DATASET\" DS2\nIF OUTNUM < 1 THEN SECRC = \"NO OUTPUT GENERATED. CHECK RNAME VALIDITY\"\nSAY \"T50RCON: SECRC IS \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T50RCON: LEAVING T50RCON\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50REPL": {"ttr": 283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00Q\\x00\\x955/\\x00\\x98&O\\x14X\\x00)\\x00)\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1998-09-21T14:58:51", "lines": 41, "newlines": 41, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\nARG ACID PROFOLD PROFNEW\nSAY ACID PROFOLD PROFNEW\nPROFHOLD = PROFNEW /* SAVE ORIGINAL PARM FOR T50INS */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\".\") /* REPLACE DOTS WITH SPACES */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\"_\") /* REPLACE BARS WITH SPACES */\nSAY \"T50REPL: \" ACID PROFOLD PROFNEW\nADDRESS ISPEXEC\n/********************************************************************/\n/***  THIS EXEC REPLACES ONE PROFILE IN A TOP SECRET ACID WITH    ***/\n/***  ONE OR MORE OTHER PROFILES. IT REQUIRES THAT T50INS         ***/\n/***  BE AVAILABLE TO DO INSERTIONS.....DIR 26 APRIL 93           ***/\n/********************************************************************/\nWORDNUM = WORDS(PROFOLD)\nIF WORDNUM > 1 THEN DO\n  SECRC = \"YOU MUST SPECIFY ONLY 1 PROFILE FOR REPLACEMENT\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSAY \"T50REPL: CALLING T50FLOC\"\nADDRESS TSO \"%T50FLOC\" ACID PROFOLD\nSAY \"T50REPL: BACK FROM T50FLOC\"\n\" VGET SECRC PROFILE\"\nPLACE = SECRC\nSAY \" PLACE IS \" PLACE\nIF (PLACE = \"ERROR\") | ( PLACE= 0 ) THEN DO\n  SECRC = \"ERROR LOCATING \"PROFOLD \"IN ACID.. REPLACE ABORTED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROFOLD\")\"\nSIGNAL ON ERROR NAME BADPROF\nSAY \"T50REPL: CALLING T50INS\"\nADDRESS TSO \"%T50INS\" ACID PROFHOLD PLACE\nSECRC = \"PROFILE REPLACE COMPLETED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT 00\nBADPROF: NOP\nSECRC = PROFOLD \"WAS IN PLACE \"PLACE\", HOWEVER INSERTION OF \",\n  PROFNEW \"FAILED!\"\n  \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50RESET": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00S\\x00\\x993?\\x00\\x993?\\x102\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-29T00:00:00", "modifydate": "1999-11-29T10:32:53", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\nsignal off error\narg acid newpass\nrcode = 0\naddress tso\nsay \"tss rem(\"acid\") asuspend \"\n\"tss rem(\"acid\") asuspend \"\nrcode = rcode + rc\nsay \"tss rem(\"acid\") suspend \"\n\"tss rem(\"acid\") suspend \"\nrcode = rcode + rc\nsay \"tss rep(\"acid\") password(\"newpass\")\"\n\"tss rep(\"acid\") password(\"newpass\")\"\nrcode = rcode + rc\nexit rcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50TSSIM": {"ttr": 3093, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x009\\x00\\x955/\\x01\\x00\\x05O\\x115\\x00*\\x00*\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-02-23T11:35:39", "lines": 42, "newlines": 42, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* ROUTES THE OUTPUT OF A TSSSIM COMMAND TO A DATASET OF YOUR CHOICE */\n/*********************************************************************/\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n SAY \"ACID RTYPE RNAME FACILITY ACCESS DSOUT\"\n SAY ACID RTYPE RNAME FACILITY ACCESS DSOUT\n IF RTYPE = \"VOLUME\" THEN RTYPE = \"DASDVOL\"\n IF RTYPE = \"VOL\" THEN RTYPE = \"DASDVOL\"\n ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"ALLOC DDN(SIM$$OUT) DSN(\"DSOUT\") SHR REUS\"\n OUT.1 = \"  LOGON ACID(\"ACID\") FAC(\"FACILITY\") TRACE \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") MOD REUS\"\n OUT.1 = \"  $\"RTYPE\"(\"RNAME\") ACCESS(\"ACCESS\")  \"\n IF ACCESS = \".NA.\" THEN\n   OUT.1 = \"  $\"RTYPE\"(\"RNAME\")\"\n IF RTYPE = \"DSN\" THEN\n   OUT.1 = \"  $\"RTYPE\"('\"RNAME\"') ACCESS(\"ACCESS\")  \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \" FREE DDN(OUTFILE)\"\n ADDRESS TSO \"ALLOC DDN(SIM$$IN) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"TSSSIM\"\n ADDRESS TSO \" FREE DDN(SIM$$IN)\"\n ADDRESS TSO \" FREE DDN(SIM$$OUT)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T50UNDEL": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00W\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00:\\x00:\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:57", "lines": 58, "newlines": 58, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED UADS STEP .....................              **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50UNDEL                          **/\n/** LAST MODIFIED    : 31 MAR 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID TO BE RECREATED                   **/\n/** MODE    : THE MODE \"ONLINE\" OR \"BATCH\"               **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS1     : A FLAT FILE LRECL 80                       **/\n/** DS2     : A FLAT FILE LRECL 80                       **/\n/** DSBACK  : A PDS CONATAINING MEMBER (ACID)            **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (BUT IT NEEDS VGETS !)      **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : RXREPRO T44CON       **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS TSO\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nACID_COPY = \"'\"DSBACK\"(\"ACID\")'\"\nUADS_COPY = \"'\"UADSBACK\"(\"ACID\"0)'\"\nIF SYSDSN(ACID_COPY) \u00ac= \"OK\" THEN DO\n  say \"enqueue failed on\" acid_copy\n  secrc = \"Acid not resurrectable, no backup available. sorry\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 00\nEND\nIF MODE = \"ONLINE\" THEN DO\n  /* \"SMCOPY FDS(\"ACID_COPY\") TDS(\"DS1\") NOTRANS\"*/\n  ADDRESS TSO \"%RXREPRO \" ACID_COPY DS1\n  ADDRESS TSO \"%T50ICOMP  REBUILD BYPASS\"\n  ADDRESS TSO \"SUBMIT\" DS2\n  secrc = \"Job submitted to resurrect id \" acid\". check uads entries\"\n  END\nELSE DO\n  BJCL.1 = \"  %RXREPRO \"ACID_COPY DS1\n  BJCL.2 = \"  ISPSTART CMD(%T50ICOMP REBUILD ACID  ) NEWAPPL(TSS)\"\n  BJCL.3 = \"  SUBMIT\" DS2\n  BJCL.4 = \"  \"\n  ADDRESS MVS \"EXECIO 4 DISKW BJCL ( FINIS STEM BJCL.)\"\n  secrc = \"Batch file has been updated with resurrection stream.\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51ADD": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0c\\x00\\x13\\x00\\x955/\\x01\\x02\\x07O\\x11G\\x01g\\x01g\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.12", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2002-03-15T11:47:13", "lines": 359, "newlines": 359, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T51ADD                            **/\n/** LAST MODIFIED    :  2 feb 2000                       **/\n/**********************************************************/\n/** added variable for default department vget           **/\n/**********************************************************/\n/** CHANGED ACID VARIABLE MANIPULATION SO THAT THE ACID  **/\n/** VARIABLE REMAINS A LITTLE MORE STABLE.               **/\n/**                                .....DIR 19 AUGUST 96 **/\n/**********************************************************/\n/**********************************************************/\n/** ADDED LOGIC TO DETERMINE IF ID HAS DSNS CATLGD IN    **/\n/** MASTER CAT YET HAS NO ALIAS        DIR  11 MAY 95    **/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nSAY \"T51ADD: CONTROL RECEIVED PARMS = \" ACID MODE\nADDRESS ISPEXEC\n\"VGET AUD       PROFILE\"\n\"VGET DEF       PROFILE\"\n\"VGET DS1       PROFILE\"\n\"VGET DS2       PROFILE\"\n\"VGET DS3       PROFILE\"\n\"VGET DS4       PROFILE\"\n\"VGET DS5       PROFILE\"\n\"VGET DS6       PROFILE\"\n\"VGET MSG2      PROFILE\"\n\"VGET PROD      PROFILE\"\n\"VGET TSOSIZE   PROFILE\"\n\"VGET TSOUNIT   PROFILE\"\n\"VGET TSOPROC   PROFILE\"\n\"VGET TVER      PROFILE\"\nSIGNAL OFF ERROR\n/**********************************************************/\n/** below I am checking that the id doesnot have dsns    **/\n/** cataloged to the master catalog. if it does the      **/\n/** user wont be able to catalog his own datasets. this  **/\n/** will cause allocate errors that are hard to track.   **/\n/** i may make this a seperate callable exec but for     **/\n/** now it is included here    dave 11 may 95            **/\n/**********************************************************/\nDATEHOLD = DATE('U')\nMONTHNUM = SUBSTR(DATEHOLD,1,2)\nADDRESS TSO \"%T51GDAT \"ACID \"NAME\"\nOLDID = RC\noutct = 40\nBOOK = \"NIL\"\nBOOK1 = \"NIL\"\nSAY \"TSA101D: T51ADD  EXISTANCE CHECK RC IS \" OLDID\nIF OLDID = 0 THEN DO\n  MSG2 = \"THIS ID EXISTS CURRENTLY, READDITION WILL FAIL UPON\",\n  \"EXECUTION\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\n/**************************************/\n/* get the default department         */\n/**************************************/\nADDRESS ISPEXEC \"VGET DEFDEPT PROFILE\"\nADDRESS ISPEXEC \"VGET TSOALIAS PROFILE\"\nIF TSOALIAS = \"YES\" THEN DO\n  ADDRESS TSO \"LISTC ENT('\"ACID\"')\"\n  SAY \"TSA101D: T51ADD  ALIAS CHECK IS \" RC\n  ALIAS_CODE = RC\n  ADDRESS TSO \"LISTC LEVEL('\"ACID\"')\"\n  SAY \"TSA101D: T51ADD  LEVEL CHECK IS \" RC\n  LEVEL_CODE = RC\n  IF (ALIAS_CODE \u00ac= 0) & (LEVEL_CODE =0)  THEN DO\n    MSG2 = \"THE ID HAS NO ALIAS, YET HAS DSNS CATALOGED, EXPECT\",\n    \"SEVERE ALLOCATION ERRORS\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSIGNAL ON ERROR NAME ABORT\n/**********************************************************/\n/** END OF DSN ALIAS / LEVEL CHECKING                    **/\n/**********************************************************/\nLINE.  = \" \"\nALEN   = LENGTH(ACID)\nBILLA  = \"N\"\nCODE   = 0\nCURSOR = \"NAME\"\nDEFINE = \"NAME('\"NAME\"') DEPT(D0000000) TYPE(USER)\"\nFIRST2 = SUBSTR(ACID,1,2)\nGOTDEF = \"NO\"\nLOGON  = TSOPROC\nNDEPT  = FIRST2||\"DEPT\"\nif defdept /= \"NONE\" then ndept = defdept\nPROF   = \" \"\nPWORD  = \"PASSWORD,60,EXP\"\nSECDEF. = \" \"\nSECRC  = \"T51ADD DID NOT COMPLETE NORMALLY. PLEASE CHECK THE ID.\"\nS2     = ALEN - 1\nTYPE   =  \"USER\"\nWARNED = \"NO\"\n\"VPUT SECRC PROFILE\"\nPW = \"PASSWORD\"\nDPNL   = \"SPIADD\"\nBASIC_ACID = \" \"\nAUDU.0 =   1\nAUDU.1 =   \"%ADDLOCAL\" ACID NDEPT\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"FAC(TSO,BATCH)\"\n/****************************************************/\n/** the tso authority stream is below              **/\n/****************************************************/\n/*                                                                  */\n/*batchtso.0 = 3                                                    */\n/*batchtso.1 = \" \"                                                  */\n/*batchtso.2 = \"ISPSTART CMD(%\"TVER\"TSO DEFAULTS +\"                 */\n/*batchtso.3 = \" \"ACID LOGON BOOK1 TSOUNIT TSOSIZE\") NEWAPPL(TSS)\"  */\n/*onlintso.0 = 1                                                    */\n/*onlintso.1 =\"%\"TVER\"TSO DEFAULTS\" ACID LOGON BOOK1 TSOUNIT TSOSIZE*/\n/*                                                                  */\n/****************************************************/\n/** beginning of the panel loop                    **/\n/** beginning of the panel loop                    **/\n/****************************************************/\nAGAIN: NOP\nCALL FILLSCR\n\"DISPLAY PANEL(\"DPNL\")  CURSOR(\"CURSOR\")\"\nRCODE = RC\nNAME = TRANSLATE(NAME,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSAY \"TSA101D: T51ADD  PANEL RCODE IS \"RCODE\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ERRMSG\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\nGETNAME: NOP\nCNT1 = 0\nNORMAL: NOP\nMEMBER = mem\nIF MEM = \"\" THEN MEMBER = NDEPT\nmem = member\nSAY \"TSA101D: CHECKING FOR DEFAULT DEPT AUTHORITIES\" DEF\"(\"MEMBER\")\"\nIF SYSDSN(\"'\"DEF\"(\"MEMBER\")'\") = \"OK\" THEN DO\n  SAY \"TSA101D: T51ADD  DEFAULT AUTHORITY GROUP FOUND FOR IN \" DEF BIN\n  ADDRESS TSO \"ALLOC DDN(SECDEF) DSN('\"DEF\"(\"member\")') SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR SECDEF ( FINIS STEM SECDEF.)\"\n  ADDRESS TSO \"FREE DDN(SECDEF)\"\n  /******************************************************/\n  /***                                                ***/\n  /*** NOTE: THE FIRST LINE OF THE DSN MUST HAVE A    ***/\n  /*** CREATE PARM IN IT! IF THERE IS NO MEMBER I     ***/\n  /*** ASSIGN A VALUE TO SECDEF.1                     ***/\n  /***                                                ***/\n  /******************************************************/\n  SECDEF.1 = \"NAME('\"NAME\"')\" SECDEF.1\n  GOTDEF = \"YES\"\nEND\nELSE SECDEF.1 = DEFINE /* IF NO MEMBER WE JUST CREATE A 1 LINER */\nDO T = 1 TO 40\n  /******************************************************/\n  /***                                                ***/\n  /*** ONCE HERE THERE HAS TO BE A SECDEF.1 VALUE AND ***/\n  /*** IT HAS IS    COMPRISED OF VALID 'CREATE' PARMS ***/\n  /*** FOR TOP SECRET. THE REST OF THE SECDEF. STRING ***/\n  /*** MAY CONTAIN commands to be issued by the       ***/\n  /*** system sight unseen.                           ***/\n  /******************************************************/\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \" T51add: $$ substitution string found in secdef\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n    say \" T51add: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \" T51ADD: $DEPT$ substitution string found in secdef\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n    say \" T51add: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$MEM$\") /= 0 then do\n    say \" T51ADD: $MEM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$MEM$' q2\n    secdef.t = q1||member||q2\n    say \" T51add: resolved secdef is \"secdef.t\n  end\n  LINE.T =  secdef.t\n  say t line.t\nEND\nSCRDISP: NOP\nCALL FILLSCR\nMSG=\"CHANGE DEFAULT COMMAND STREAM IF NEEDED AND HIT ENTER.\"\nIF GOTDEF = \"NO\" THEN\n  MSG=\"NO DEFAULT AUTHORITY STREAM FOUND. ENTER COMMANDS.\"\nPNLDISP: NOP\n\"ISPEXEC DISPLAY PANEL(\"DPNL\")\"\nRCODE = RC\nSAY \"T51ADD: PANEL RCODE IS \"RCODE\nIF MEM /= MEMBER THEN SECDEF. = \" \"\nIF MEM /= MEMBER THEN SIGNAL NORMAL\nNAME = SUBSTR(NAME                  ,1,20)\nCALL FILLDOT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ABORT\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\n/******************************************************************/\n/******************************************************************/\nCOMMIT: NOP\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"              \"\nLINE.1 = DEFINE\nIF PW \u00ac= \" \" THEN PWORD = PW||\",45\"\nELSE PW = \"PASSWORD\"\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T51ADD: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1= \"TSS CREATE(\"ACID\")  PASSWORD(\"PWORD\")      +\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  ADDRESS MVS \"EXECIO \"OUTCT\" DISKW BJCL ( FINIS STEM LINE.)\"\n  /**********************************************************/\n  /*ADDRESS MVS,                                               */\n  /* \"EXECIO \"batchtso.0\" DISKW BJCL ( FINIS STEM batchtso.)\"  */\n\n  SAY \"T51ADD: WRITING DATA TO BJCL DDNAME\"\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM AUDU.)\"\n  CODE = RC\n  IF CODE = 0 THEN SECRC =\"BATCH FILE UPDATED WITH ADD COMMANDS.\"\n  SIGNAL OFF ERROR\n  IF RC < > 0 THEN DO\n    MSG2 = \"THE BILLING FILE UPDATE DID NOT COMPLETE NORMALLY.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  SIGNAL BYE1\nEND\nTSSCMD = \"YES\"\nADDRESS TSO\nSAY \"T51ADD: ISSUING THE TSS ADD COMMAND FOR THE ID\"\nSAY \"T51ADD: TSS CREATE(\"ACID\") PASSWORD(\"PWORD\") \" LINE.1\nSAY \"T51ADD: \" line.1\n\"TSS CREATE(\"ACID\") PASSWORD(\"PWORD\") \" LINE.1\nCODE = RC\nSAY \"T51ADD: THE TSS ADD COMMAND FINISHED WITH A RCODE OF \" CODE\nSIGNAL OFF ERROR\nDO T = 2 TO OUTCT\n   say \"T51add: issuing command:\" line.t\n   IF LINE.T < > \" \" THEN\n   ADDRESS TSO \" \"LINE.T\nEND\n/* ADDRESS TSO \"%TSSAUDU \" ACID    */\nSPACES= \"                                                          \"\nSYSDATE = DATE(U)\nBYE:  NOP\nSIGNAL OFF ERROR\nIF  MODE= \"SKIPIT\" THEN DO\n  SAY \"T51ADD: VERSION 5.0 TSO DEFAULTS BEING SET\"\n  BOOK1 = WORD(BOOK,1)\n  rcode = 0\n  do cmdnum = 1 to audu.0\n    say \"T51add: issuing cmd : \"onlintso.cmdnum\n    address tso onlintso.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T51add: rcode from cmd is \" holdrc\n  end\n  do cmdnum = 1 to audu.0\n    say \"T51add: issuing cmd : \"audu.cmdnum\n    address tso audu.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T51add: rcode from cmd is \" holdrc\n  end\n  ADDRESS ISPEXEC\n  IF RCODE > 0 THEN DO\n    \"VGET SECRC PROFILE\"\n    MSG2 = \"DEFAULTS TSO SETUP HAS FAILED, CHECK BOOK AUTHORITIES\"\n    \"VPUT MSG2 PROFILE\"\n    SIGNAL BYE1\n  END\n  SAY \"T51ADD: VERSION 5.0 TSO DEFAULTS HAVE BEEN SET\"\nEND\nJUSTUADS: NOP\nCODE = RC\nSIGNAL ON ERROR NAME BADALIAS\n\nif code = 0 then secrc =\"TSA202I: ACID added. no errors encountered.\"\nBYE1:  NOP\nSIGNAL OFF ERROR\nADDRESS ISPEXEC\n\"VPUT SECRC PROFILE\"\n DATAAREA = ACID\n\"VPUT DATAAREA PROFILE\"\nEXIT 0\nERRMSG: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA201E: Errors encountered. check acid status \"\n  SIGNAL BYE1\nBADALIAS: NOP\n  IF CODE = 0 THEN\n    SECRC= \"ALIAS ADDITION FAILED CHECK ACID STATUS \"\n  ELSE SECRC = SECRC \"AND ALIAS ADDITION FAILED\"\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  SIGNAL BYE1\nABORT: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA200E: Function aborted. acid not added.\"\n  SIGNAL BYE1\n/****************************************************************/\n/*  ERROR ROUTINE MESSAGE DISPLAYS.........DIR                  */\n/****************************************************************/\nFILLDOT: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE.1 = LINE1\n  LINE.2 = LINE2\n  LINE.3 = LINE3\n  LINE.4 = LINE4\n  LINE.5 = LINE5\n  LINE.6 = LINE6\n  LINE.7 = LINE7\n  LINE.8 = LINE8\n  LINE.9 = LINE9\n  LINE.10= LINE10\n  LINE.11= LINE11\n  LINE.12= LINE12\n  LINE.13= LINE13\n  LINE.14= LINE14\n  LINE.15= LINE15\nRETURN\nFILLSCR: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE1 = LINE.1\n  LINE2 = LINE.2\n  LINE3 = LINE.3\n  LINE4 = LINE.4\n  LINE5 = LINE.5\n  LINE6 = LINE.6\n  LINE7 = LINE.7\n  LINE8 = LINE.8\n  LINE9 = LINE.9\n  LINE10= LINE.10\n  LINE11= LINE.11\n  LINE12= LINE.12\n  LINE13= LINE.13\n  LINE14= LINE.14\n  LINE15= LINE.15\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51BCON": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00 \\x00\\x955/\\x01\\x00\\x07_\\x105\\x00\\x87\\x00\\x87\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:35:20", "lines": 135, "newlines": 135, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50BCON                           **/\n/** LAST MODIFIED    : 24 SEP 96                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/**********************************************************/\n/** BASE SUPPORT FOR ZCA TYPE ADMINS                     **/\n/**********************************************************/\n/** PASSED ARGS        VALID VALUES                      **/\n/** THESE ARGS ARE ONLY PASSSED ON A LSCA CONVERT        **/\n/** NEWACID : THE NAME THAT THE ACID IS TO BE CHANGED TO **/\n/** NEWTYPE : THE TYPE OF ACID THAT IS TO BE CREATED     **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DS1     : THE DATASET WHEWRE THE INPUT DATA MUST BE  **/\n/** DS2     : THE OUTPUT DATASET                         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES.(NOTE VGET VARIABLES)       **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE                  */\n/**                                                      **/\n/**********************************************************/\nARG NEWACID NEWTYPE\nSIGNAL ON ERROR NAME SEEYA\nSIGNAL ON SYNTAX NAME SYNERR\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nSAY \"T50BCON: TOP SECRET REXX BASIC ACID CONVERSION CLIST ENTERED\"\nNEST = SYSVAR(SYSNEST)\nIF NEST = \"NO\" THEN DO\n  \"ALLOC DDN(OUTFILE) DSN(\" DS2\") MOD REUS\"\n  \"ALLOC DDN(INPUT) DSN(\" DS1\") SHR REUS\"\nEND\n\"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\nOUTFILE. = \" \"\nATTR = \"ATTR\"\nOPID = \" \"\nPWD = \"12345\"\nNEXTREC: DO RECNUM = 1 TO INLINE.0\n  PREVLINE=  INLINE\n  INLINE= SUBSTR(INLINE.RECNUM,1,59)\n  IF INLINE = \"      \" THEN ITERATE\n  PARSE VAR INLINE PAR.1 PAR.2 PAR.3 PAR.4 PAR.5 PAR.6 PAR.7 PAR.8\n  IF (PAR.1 = \"ACCESSORID\") & ( RECNUM > 3 ) THEN DO\n    \"EXECIO 5 DISKW OUTFILE( FINIS STEM OUTFILE.)\"\n    OUTFILE.  = \"         \"\n    ATTR = \"ATTR\"\n    TYPE = \"TYPE\"\n    DEPT = \"DEPT\"\n    NAME = \"NAME\"\n    OPID = \" \"\n    INSTDATA = \"INSTDATA\"\n    ACID = \"ACID\"\n  END\n  IF PAR.1 = \"INSTDATA\" THEN DO\n     NEXT = RECNUM + 1\n/*   INSTDATA =\"'\"||SUBSTR(INLINE.NEXT,1,55)||\"'\"    */\n     INSTDATA =\"'\"||SUBSTR(INLINE,14,65)||\"'\"\n     ITERATE\n  END\n  IF PAR.1 = \"OPIDENT\" THEN OPID = \"OPIDENT(\"PAR.3\")\"\n  IF PAR.3 = \"OPPRTY\" THEN OPID = \" \"\n  IF PAR.1 = \"PASSWORD\" THEN PWD = PAR.3\n  IF PWD   = \"*NOPW*\" THEN PWD = \"NOPW\"\n  IF PAR.3 = \"*NONE*\" THEN ITERATE\n  IF PAR.1 = \"ACCESSORID\" THEN ACID = PAR.3\n  IF NEWACID \u00ac= \" \" THEN ACID = NEWACID\n  IF ACID = \"*STC*\" THEN EXIT 00\n  IF ACID = \"*RDT*\" THEN EXIT 00\n  IF ACID = \"*ALL*\" THEN EXIT 00\n  IF PAR.1 = \"DEPT\" THEN DEPT = PAR.4\n  IF PAR.1 = \"DIV\" THEN DIV = PAR.4\n  IF PAR.1 = \"TYPE\" THEN TYPE = PAR.3\n  IF NEWTYPE \u00ac= \" \" THEN TYPE = NEWTYPE\n  IF PAR.4 = \"NAME\" THEN NAME = STRIP(PAR.6  PAR.7  PAR.8 )\n  IF PAR.1 = \"ATTRIBUTES\" THEN ATTR = PAR.3\n  IF (TYPE = \"DEPT\") & (PAR.4 = \"C/A\") THEN TYPE = \"DCA\"\n  IF (PAR.1 = \"ZONE\") & (PAR.2 = \"ACID\") THEN TZONE = PAR.4\n  IF (TYPE = \"ZONE\") & (PAR.4 = \"C/A\") THEN TYPE= \"ZCA\"\n  IF TYPE = \"LIMITED\" THEN TYPE = \"LSCA\"\n  IF TYPE = \"MASTER\" THEN EXIT\n  PRINTIT: IF TYPE = \"CENTRAL\" THEN TYPE = \"SCA\"\n  IF TYPE = \"DIV\" THEN TYPE = \"VCA\"\n  OUTFILE.  = \"            \"\n  OUTFILE.1 = \" TSS CRE(\"ACID\") NAME('\"NAME\"') TYPE(\"TYPE\") +\"\n  OUTFILE.2 =\"  DEPT(\"DEPT\")  +\"\n  IF TYPE = \"ZONE\" THEN OUTFILE.2 = \" \"\n  IF TYPE = \"VCA\" THEN\n    OUTFILE.2 =\"  DIV(\"DIV\") +\"\n  IF TYPE = \"ZCA\" THEN\n    OUTFILE.2 =\"  ZONE(\"TZONE\") +\"\n  IF TYPE = \"DEPT\" THEN\n    OUTFILE.2 =\"  DIV(\"DIV\") +\"\n  IF (TYPE=\"SCA\") | (TYPE= \"LSCA\") THEN DO\n    OUTFILE.2 =\"  PASSWORD(\"PWD\",30,EXP) +\"\n    IF OPID \u00ac= \" \" THEN\n      OUTFILE.2 = \"  PASSWORD(\"PWD\",30,EXP) \"OPID\" +\"\n    OUTFILE.3 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.3 =\"  INSTDATA(\"INSTDATA\") \"\n    OUTFILE.4 =\"                       \"\n  END\n  IF TYPE=\"PROFILE\" THEN DO\n    OUTFILE.3 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.3 = \"  INSTDATA(\"INSTDATA\") \"\n    OUTFILE.4 = \"                       \"\n    OUTFILE.5 = \"                       \"\n  END\n  IF (TYPE=\"USER\") | (TYPE=\"DCA\") | (TYPE=\"VCA\") THEN DO\n    OUTFILE.3 = \" PASSWORD(\"PWD\",30,EXP) \"OPID\" +\"\n    OUTFILE.4 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.4 =\"  INSTDATA(\"INSTDATA\") \"\n  END\n  IF ATTR <> \"ATTR\" THEN\n    OUTFILE.5 = \" TSS ADD(\"ACID\") \"ATTR\" \"\n  OUTFILE.6 = \"         \"\nEND\n\"EXECIO 5 DISKW OUTFILE( FINIS STEM OUTFILE.)\"\nEXIT 0\nSEEYA: NOP\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON. ERROR IN LINE \" SIGL\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSYNERR: NOP\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON. SYNTAX ERROR LINE \" SIGL\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51BKUP": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x02\\x004\\x00\\x98'_\\x01\\x00\\x07_\\x10S\\x00T\\x00T\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@\"", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-10-02T00:00:00", "modifydate": "2000-03-15T10:53:34", "lines": 84, "newlines": 84, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ADDED STRIP PROCESSING FOR DSBACK DSN NAME           **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50BKUP                           **/\n/** LAST MODIFIED    : 2  OCT 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :     THE ID YOU WANT BACKED UP              **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DSBACK  : THE DSN TO PUT THE BACKUP IN               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T50GDAT              **/\n/**                                                      **/\n/**********************************************************/\nARG ACID DSBACK\nHEX00 = '00'X\nSYSENV = SYSVAR(SYSENV)\nIF DSBACK = \"\" THEN\n  ADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nSIGNAL ON ERROR NAME SEEYA\nDSBACK = TRANSLATE(DSBACK,\"\",\"'\") /* REMOVE TICS WITH SPACES */\nDSBACK = STRIP(DSBACK)\nSTATUS  = SYSDSN(\"'\"DSBACK\"'\")\nDSBACK = \"'\"DSBACK\"(\"ACID\")'\"\nSAY \"TSA101D: T50BKUP DSBACK IS \"DSBACK\nADDRESS TSO \"%T50GDAT \" ACID \"TYPE\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nTYPE = SECRC\nSAY \"TSA101D: T50BKUP TYPE IS \" TYPE\nSS = OUTTRAP('OUTLINE.')\nDATA=\"ALL,PASSWORD,EXPIRE\"\nSTATUSM = SYSDSN(DSBACK)\nIF (STATUS = \"OK\") & (STATUSM = \"MEMBER NOT FOUND\")  THEN DO\n  SAY \"TSA101D: T50BKUP BACKUP MEMBER WILL BE CREATED.  \"\nEND\nIF (STATUS = \"OK\") & (STATUSM = \"OK\")  THEN DO\n  SAY \"TSA101D: T50BKUP BACKUP MEMBER WILL BE OVERLAYED BY THIS BACKUP.\"\nEND\nIF (STATUS /= \"OK\")  THEN DO\n  SAY \"TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS = \" STATUS\n  SECRC = \"TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS = \" STATUS\n  EXIT 04\nEND\nSAY \"TSA101D: T50BKUP ALLOCATING DSN\" DSBACK\n\"ALLOC DDN(OUTFILE) DSN(\"DSBACK\") SHR REUS\"\nSAY \"TSA101D: T50BKUP  CALLING TSS FOR LIST OF ID \" ACID\nSELECT\n  WHEN TYPE = \"USER\"    THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"MASTER\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"DEPTCA\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"ZONECA\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"DIVCA\"   THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"CENTRAL\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"LIMITED\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"PROFILE\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"GROUP\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  OTHERWISE   \"TSS LIST(ACIDS) \"TYPE\"(\"ACID\")  DATA(\"DATA\")\"\nEND\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n SECRC = \"FUNCTION COMPLETED. BACKUP TAKEN TO  \" DSBACK\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51CMDO": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00&\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00A\\x00A\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:26", "lines": 65, "newlines": 65, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ISSUE A COMMAND TRAP THE OUTPUT AND ROUTE IT SOMEWERE**/\n/** I ALSO CHANGE ALL HEX 00 TO BLANKS BECAUSE TSS       **/\n/** SOMETIMES RETURNS SOME '00'X VALUES IN ITS UADS AREA **/\n/**********************************************************/\n/** EXEC NAME        : T50CMDO                           **/\n/** LAST MODIFIED    : 16 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSN TO GET THE OUTPUT                  **/\n/** ARG     : THE ACTUAL COMMAND TO BE ISSUED            **/\n/** DISP    : THE DISP TO ALLOCATE THE DATASET WITH      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE HOWEVER THIS    **/\n/**      EXEC COULD BE PASSED ANOTHER EXEC NAME AND      **/\n/**      INVOKE THAT.                                    **/\n/**********************************************************/\nARG DSN cmd\nHEX00 = '00'X\nsecrc = \"TSA509E: Command not processed. check commands validity.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nif cmd = \"\" then\n  ADDRESS ISPEXEC \"VGET ARG PROFILE\"\nelse arg = cmd\nADDRESS ISPEXEC \"VGET DISP PROFILE\"\nQ = OUTTRAP(OUT.)\nT = 1\n\" \"ARG\nRCODE = RC\nDO Z = 1 TO OUT.0\n  IF LENGTH(OUT.Z) > 80 THEN DO\n    OUTLINE.T = SUBSTR(OUT.Z,1,80)\n    T = T + 1\n    OUTLINE.T = SUBSTR(OUT.Z,81)\n    T = T + 1\n    ITERATE Z\n  END\n  OUT.Z=TRANSLATE(OUT.Z,\" \",HEX00)\n  OUTLINE.T = OUT.Z\n  T = T + 1\nEND\nIF DSN = \"SCREEN\" THEN DO\n  T = T - 1\n  DO Q = 1 TO T\n     IF LENGTH(OUTLINE.Q) > 78 THEN OUTLINE.Q = SUBSTR(OUTLINE.Q,1,78)\n     IF OUTLINE.Q <> \" \" THEN SAY OUTLINE.Q\n  END\n  SIGNAL LETSGO\nEND\n\"ALLOC DDN(OUTPUT) DSN(\"DSN\") \"DISP\" REUS\"\n\"EXECIO * DISKW OUTPUT (STEM OUTLINE. FINIS)\"\n\"FREE DDN(OUTPUT)\"\nLETSGO: NOP\nIF RCODE = 0 THEN\n  secrc = \"TSA514I: Command issued output resides in:\" dsn\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51CON": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00G\\x00\\x98#o\\x01\\x00\\x07_\\x10S\\x049\\x049\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-08-24T00:00:00", "modifydate": "2000-03-15T10:53:47", "lines": 1081, "newlines": 1081, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added code to use FDT segment names                  **/\n/**********************************************************/\n/** added code to ignore dept/div/profile passwords      **/\n/**********************************************************/\n/** added more parm based processing                     **/\n/**********************************************************/\n/** added  parm based parsing                            **/\n/**********************************************************/\n/** bypassing iterate error.                             **/\n/**********************************************************/\n/** fixed reformatter error...                           **/\n/**********************************************************/\n/** added omvs support                                   **/\n/**********************************************************/\n/** REMOVED DUPLICATE OUTPUT LINES  SO AS TO STREAMLINE  **/\n/** THE OUTPUT ID...                                     **/\n/**********************************************************/\n/** ADDED SUPPORT FOR LSCA AND SCA JOBCARD CHANGE        **/\n/** SPECIFYING USER=MSCA ON THE JOBCARD.                 **/\n/**********************************************************/\n/** FIXED ADMIN ACID( SUPPORT..                          **/\n/**********************************************************/\n/** REDID THE RDT AREA FOR THE NEW ADDITION SYNTAX       **/\n/**********************************************************/\n/** ADDED SUPPORT FOR TSOOPTION PARM                     **/\n/**********************************************************/\n/** ADDED SUPPORT FOR ZCA DCA VCA CONVERSION             **/\n/**********************************************************/\n/** ADDED MSGS FOR MFAC CONVERSION                       **/\n/**********************************************************/\n/** SUPPORTS RDT AND LINEFORMATTING                      **/\n/**********************************************************/\n/** SUPPORTS TIMES/DAYS/LOCKTIMES                        **/\n/**********************************************************/\n/** THE NEWER STREAMLINED CONVERT FUNCTION.              **/\n/** THE LOGIC SHOULD BE ALOT MORE READABLE ...           **/\n/**********************************************************/\n/** EXEC NAME        : T50CON                            **/\n/** LAST MODIFIED    : 10 aug 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** NEWACID :  THE NAME THE ACID IS TO BE RENAMED TO     **/\n/** NEWTYPE :  THE NEW TYPE OF ACID TO BE CREATED        **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** CONVOPT : THE INTERNAL OUT OPTION \"DATASET\u00a6INTERNAL\" **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS1     : THE INTERIM OUTPUT FILE                    **/\n/** DS2     : THE BATCH FILE                             **/\n/** newpass : THE password to plug into IDs when it cant **/\n/**           be determined                              **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD.    = THE VALID COMMANDS 4 THIS ENT    \"ADD REM\" **/\n/** TYPE.   = THE RESOURCE TYPE                \"DATASET\" **/\n/** ACID.   = THE TARGET ACID FOR EACH CMD     \" ??    \" **/\n/** RSNAME. = THE RESOURCE NAME                \"SYS1.  \" **/\n/** DAYS.   = THE VALID DAYS                   \"MON,TUE\" **/\n/** TIME.   = THE VALID TIMES                  \"08,18  \" **/\n/** ACCESS. = THE ACCESS LEVEL                 \"UPDATE \" **/\n/** ACTION. = THE ACTION TO TAKE               \"FAIL   \" **/\n/** UNTIL.  = THE EXPIRE   DATE OF RULE \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/**********************************************************/\n/** Multi word parm stuff:                               **/\n/**                                                      **/\n/** In ALL below examples t1 has been set to the first   **/\n/** word in the line and t2 has been set to the second.  **/\n/** ( note the 0 prefixed values are always literals )   **/\n/**                                                      **/\n/** MULTI.T1.T2.0PRECMD        The # of commands to be   **/\n/**                      issued prior to value checking  **/\n/**                      This must correspond to the     **/\n/**                      below commands.                 **/\n/** MULTI.T1.T2.0PRECMD.1      Command # 1               **/\n/** MULTI.T1.T2.0PRECMD.2      Command # 2               **/\n/** MULTI.T1.T2.0ITERATE       0 = suffix to prev line   **/\n/**                            1 = make a new line       **/\n/**                                                      **/\n/** SNAME                      The segment for this rule **/\n/**                      to be activated (used below)    **/\n/** MULTI.T1.T2.SNAME          The value \"YES\"           **/\n/** MULTI.T1.T2.0TYPE          The type of resource      **/\n/**                      (example - DSN )                **/\n/** MULTI.T1.T2.0CMD           The tss cmd ( ADD or PER) **/\n/** MULTI.T1.T2.0RSNAME        The TSS resource(example -**/\n/**                      the dataset name)               **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                                                      **/\n/** Single word rules stuff:                             **/\n/**                                                      **/\n/**                                                      **/\n/**  THOLD               The first word on the data line **/\n/**                 that will trigger this rule          **/\n/**                                                      **/\n/**  SNAME               The section name that must match**/\n/**                 the current section for this rule    **/\n/**                                                      **/\n/**  ITERATE.thold.sname  Will I add line(s) to output ? **/\n/**                                                      **/\n/**  ITERATE.thold        How many lines...              **/\n/**                                                      **/\n/**  TYPE.thold           The RDT data type or \"$$\" to   **/\n/**                 bypass command build logic, and build**/\n/**                 your own command                     **/\n/**  CMD.thold           The command add or per or rev.. **/\n/**  RSNAME.thold        The resource name to be used in **/\n/**                  the command or if you specified $$  **/\n/**                  in the type field above, the actual **/\n/**                  rexx interpret command to be issued **/\n/**                                                      **/\n/**                                                      **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS2  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NEWTYPE\nmaint = \"june 4 1999\"\nsay \"T50CON: in control with parms \" acid newacid newtype\nsay \"T50CON: Maint = \" maint\nif acid = \"BYPASS\" then do\n  say \"T50CON: bypass detected other parms ignored.\"\n  newacid = \"\"\n  newtype = \"\"\nend\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50CON. NO OTHER INFORMATION AVAILABLE\"\nIF SYSENV = \"FORE\" THEN DO\n  SECRC = \"FAILED WHILE GETTING VARIABLES FROM ISPPROF\"\n  SECRC = SECRC||\" TRY 'REINIT' OPTION\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET NEWPASS PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS2 PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n  ADDRESS ISPEXEC \"VGET CONVOPT PROFILE\"\nEND\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nCREATE.   =  \"\"\nUNTIL.    =  \"\"\nTYPE.     =  \"\"\nCMD.      =  \"\"\nACCESS.   =  \"\"\nRSNAME.   =  \"\"\nLIBRARY.  =  \"\"\nPRECMD.   =  \"\"\nDAYS.     =  \"\"\nTIME.     =  \"\"\nFACILITY. =  \"\"\nPRIVPGM.  =  \"\"\nACTION.   =  \"\"\nDEPT      =  \"\"\nZONE      =  \"\"\nDIV       =  \"\"\nACID.0    =  ACID\nIF NEWACID /= \"\" THEN ACID.1 = NEWACID\n/********************************/\nCOMMAND.  = \"ADD\"\nSEGMENT   =  \"ADMINISTRATIONAUTHORITIES\"\nCOMMAND.SEGMENT  = \"ADMIN\"\n/********************************/\n/********************************/\n/** LOCK TIME segment          **/\n/** an example of using the    **/\n/** postcmd processor for      **/\n/** value resolution.          **/\n/********************************/\nTLINE                    = \"LOCK TIME\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0PRECMD      = 2\nMULTI.T1.T2.0PRECMD.1    = \"FAC =','w.6\"\nMULTI.T1.T2.0PRECMD.2    = \"IF W.6 = 'ALL' THEN FAC = ''\"\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0POSTCMD     = 3\nMULTI.T1.T2.0POSTCMD.1   = \"TYPE.OUTNUM = '$$'\"\nMULTI.T1.T2.0POSTCMD.2   = \"CMD.OUTNUM = 'ADD'\"\nMULTI.T1.T2.0POSTCMD.3   = \"RSNAME.OUTNUM = 'LTI('W.3||FAC')'\"\n/********************************/\n/** LIST DATA segment          **/\n/********************************/\nTLINE                    = \"LIST DATA\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0TYPE        = \"$$\"\nMULTI.T1.T2.0CMD         = \"'ADMIN'\"\nMULTI.T1.T2.0RSNAME      = \"'DATA('W.3' 'W.4')'\"\n/********************************/\n/** XA DATASET segment         **/\n/********************************/\nTLINE                    = \"XA DATASET\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0TYPE        = \"DSN\"\nMULTI.T1.T2.0CMD         = \"PER\"\nMULTI.T1.T2.0RSNAME      = \"W.3\"\nMULTI.T1.T2.0UNTIL       = \"W.4\"\n/********************************/\n/** single word rules are below**/\n/********************************/\nTHOLD                = \"GROUP\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'GROUP('W.2 w.3 w.4 w.5')'\"\n/********************************/\n/********************************/\nTHOLD                = \"XA\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"W.2\"\nCMD.THOLD            = \"PER\"\nRSNAME.THOLD         = \"W.3\"\nUNTIL.THOLD          = \"W.4\"\n/********************************/\nTHOLD                = \"FACILITIES\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"'FACILITY'\"\nCMD.THOLD            = \"ADMIN\"\nRSNAME.THOLD         = \"W.2 W.3\"\n/********************************/\nTHOLD                = \"ACID\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"'ACID'\"\nCMD.THOLD            = \"ADMIN\"\nRSNAME.THOLD         = \"W.2\"\n/********************************/\nTHOLD                = \"ACCESS\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nSNAME                = \"AUTHORITY\"\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 0\nACCESS.THOLD         = \"'ACCESS('W.2')'\"\n/********************************/\nTHOLD                = \"BYPASSING\"\nSNAME                = \"BASE\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\n                     /*******************************/\n                     /* only one precmd             */\n                     /*******************************/\nPRECMD.THOLD         = 1\nPRECMD.THOLD.1       = 'W.2 = TRANSLATE(W.2,\" \",\",\")'\n                     /*******************************/\n                     /* get rid of commas in auths  */\n                     /*******************************/\nRSNAME.THOLD         = \"W.2\"\n/********************************/\nTHOLD                = \"SITRAN\"\nSNAME                = \"SEGMENTCICS\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'SIT('W.2','W.4')'\"\n/********************************/\nTHOLD                = \"PROFILE\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'PROF('W.2')' W.3 W.4\"\n/********************************/\nTHOLD                = \"PROFILES\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'PROF('W.2 W.3 W.4')'\"\n/********************************/\nSEGMENT   =  \"BASE\"\nIF DISP = \"\" THEN DISP = SHR\nDATA=\"ALL,EXPIRE\"\nSIGNAL OFF ERROR\n  /******************************************************************/\nSECRC = \"FAILED, CHECK IDS EXISTANCE AND YOUR AUTHORITY.\"\nIF ACID  = \"BYPASS\" THEN DO\n  SAY \"T50CON: BYPASS SPECIFIED ALLOCATING INPUT DSN\"\n  \"ALLOC DDN(INPUT) DSN(\"DS1\") REUS\"\n  \"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\n  SS= OUTTRAP('off')\n  IDTYPE = \"USER\"\n  END\nELSE DO\n  say \"T50CON: calling tss for list of id \" acid\n  ADDRESS TSO \"%T50GDAT \"ACID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  IDTYPE = SECRC\n  say \"T50CON: type is \" idtype\n  IF IDTYPE = \"$BADTSS\" THEN DO\n    say \"T50CON: FATAL ERROR. T50GDAT failed TYPE retrieval.\"\n    secrc =\"ID is unlistable check ownership and existance of ID.\"\n    address ispexec \"vput secrc profile\"\n    exit 04\n    END\n  IF CONVOPT = \"DATASET\" THEN DO\n    say \"T50CON: dataset output specified allocating output dsn\"\n    \"%T50LSTO \" ACID \" ALL,EXPIRE\" DS1\n    \"ALLOC DDN(INPUT) DSN(\"DS1\")\"\n    \"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\n    SS= OUTTRAP('off')\n    END\n  ELSE DO\n    say \"T50CON: no id list output being generated, data being \"\n    say \"T50CON: manipulated internally  \"\n    SS = OUTTRAP('INLINE.')\n    SAY \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n    ADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n    SS= OUTTRAP('DROPIT.')\n  END\nEND\nSIGNAL ON ERROR NAME SEEYA\nsay \"T50CON: checking/allocating dsn\" ds2\nJPARM = \"RANDOM\"\n/***************************************************/\n/* PUT THE MSCA ID ON THE JOBCARD IF SCA OR LSCA   */\n/***************************************************/\nIF (IDTYPE = \"LIMITED\") | (IDTYPE = \"CENTRAL\") THEN JPARM = \"SUPER\"\nADDRESS TSO \"%T50JCARD\" DS2 JPARM\n\"ALLOC DDN(BJCL) DSN(\"DS2\") MOD REUS\"\n  /******************************************************************/\nEQUALLOC = INDEX(INLINE.1,\"=\")\nIF EQUALLOC = 0 THEN DO\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"T50CON: ERROR I AM UNABLE TO INITIALIZE THE EQUALLOC VARIABLE\"\n  SAY \"T50CON: THE TSS VERSION 5 DEFAULT OF 11 IS BEING USED        \"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  EQUALLOC = 12\nEND\nEQUALLOC = EQUALLOC - 1\nsay \"T50CON: equal location is \" equalloc\nGOTOUTPUT: NOP\nTHISREC    = 3\nOUTNUM     = 0\nREALOUT    = 0\nCREATE_NUM = 0\nCREATE.0 = 0\nSECRC = \"FAILED, DURING CONVERT LOGIC .\"\nsay \"T50CON: has a total record count of \" inline.0\nDO I = 1 TO INLINE.0\n  REFORMAT = \"NO\"        /* THIS LINE HASNT BEEN CHANGED YET */\n  T2 = I/100\n  /* IF T2 = FORMAT(T2,4,0) THEN SAY I */\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\")  /* REPLACE = WITH SPACES */\n  LINE= TRANSLATE(LINE,\" \",HEX00) /* KILL THOSE HEX 00 */\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  IF WORD(LINE,1) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  IF (INDEX(LINE,\"*ALL*\") <> 0) & (INDEX(LINE,\"VOLUMES\") =0 ) THEN DO\n    PARSE VAR LINE HOLD0 '*ALL*' HOLD1\n    LINE = HOLD0||\"ALL\"||HOLD1\n    say \"T50CON: removing *all* from line\"\n  END\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  FIRST13 = SUBSTR(LINE,1,EQUALLOC)\n  /***********************************/\n  /** DETERMINE THE segment IN CASE **/\n  /** WE NEED IT LATER.  DIR 15AUG97**/\n  /***********************************/\n  IF W.1 = \"ACCESSORID\" THEN segment = \"BASE\"\n  IF W.1 = \"CREATED\" THEN segment =  \"AUTHORITY\"\n  IF (W.1 = \"LAST\") & (W.2 = \"USED\") THEN segment =  \"AUTHORITY\"\n  IF (W.1 = \"PASSWORD\") & (W.2 = \"*NONE*\") THEN ITERATE I\n  IF  W.1 = \"-----------\" THEN segment =  W.2||W.3\n  IF  W.1 = \"-----------\" THEN Say \"T50CON: Segment changed to \"segment\n  CMD_DEFAULT = COMMAND.SEGMENT\n  IF  W.1 = \"-----------\" THEN iterate i\n  /***********************************/\n  /** END OF segment LOGIC          **/\n  /***********************************/\n  IF W.1 = \"ACIDS\" THEN FLUSH = \"YES\"\n  IF W.1 = \"ACIDS\" THEN ITERATE I\n  IF W.2 = \"LIST(ACIDS)\" THEN ITERATE I /* AN ECHO OF THE ISSUED CMD */\n  IF (SUBSTR(LINE,1,4) = \"ACID\"),\n    & (segment /= \"ADMINISTRATIONAUTHORITIES\") THEN ITERATE I\n  IF W.1 = \"***\" THEN ITERATE I\n  IF LINE = \"             \" THEN ITERATE I\n  IF W.3 = \"NAME\" THEN NAME = W.4 W.5 W.6 W.7 W.8\n  IF W.1 = \"TYPE\" THEN TYPE = W.2\n  IF TYPE = \"CENTRAL\" THEN TYPE = \"SCA\"\n  /**************************************************/\n  /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n  /**************************************************/\n  IF W.3 = \"C/A\"  THEN TYPE = SUBSTR(TYPE,1,1)||\"CA\"\n  IF W.3 = \"LIMITED\" THEN TYPE = \"LSCA\"\n  IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.3\n  IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.3\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.3\n  IF W.1 = \"CREATED\" THEN CALL MAKEACID\n  IF W.1 = \"CREATED\"  THEN ITERATE I\n  IF W.1 = \"TYPE\"  THEN ITERATE I\n  IF W.1 = \"DEPT\"  THEN ITERATE I\n  IF W.1 = \"ZONE\"  THEN ITERATE I\n  IF W.1 = \"DIV\"   THEN ITERATE I\n  IF W.1 = \"LAST\"  THEN ITERATE I\n  IF W.1 = \"TSS0300I\"  THEN ITERATE I\n  IF FIRST13 = \"LCF FAC      \" THEN LCFFAC = W.3\n  IF FIRST13 = \"LCF FAC      \" THEN ITERATE I\n  IF FIRST13 \\= \"             \" THEN DO\n    /**********************************************************/\n    /** I SAVE THE LAST TIME THAT THE 13 CHARACTERS EXISTED  **/\n    /** BECAUSE IF THE LINE IS REALLY INDENTED THEN THOSE    **/\n    /** CHARACTERS ARE GOING TO OVERLAYED ON THIS LINE IN    **/\n    /** A DESPERATE ATTEMPT TO FIGURE OUT WHAT TYPE OF       **/\n    /** RESOURCE IS BEING DEALT WITH. DIR 2 APR 97           **/\n    /**********************************************************/\n    SAVE13 = FIRST13\n    FLUSH = \"NO\"\n  END\n  /**********************************************************/\n  /** below is the logic for dropping lines with entries   **/\n  /** we dont need. the most common example is a profiles  **/\n  /** acids segment.             dir 10 aug 98             **/\n  /**********************************************************/\n  IF (SUBSTR(LINE,1,13) = \"             \") & (FLUSH = \"YES\"),\n  THEN DO\n    say \" T50CON: 13 leading blanks found flushing line #: \" i\n    SAY LINE\n    ITERATE I\n  END\n  /**********************************************************/\n  /** BELOW IS THE REFORMATTER AREA. SOME TSS RULES ARE SO **/\n  /** WEIRDLY SETUP I JUST CREATE A $$ TYPE LINE FOR THEM  **/\n  /** OR OTHERWISE CHANGE THEM                             **/\n  /**********************************************************/\n  IF FIRST13 = \"             \" THEN DO\n    NEWLINE = SAVE13 W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n    PARSE VAR NEWLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n    W.8 W.9 W.10 W.11 W.12\n    say \"T50CON: I am reformatting line #\" i \" to the following\"\n    REFORMAT = \"YES\"\n    /************************************************************/\n    /** THE ABOVE FLAG IS SET SO THAT THE BELOW ROUTINES CAN   **/\n    /** DETERMINE IF THE LINE WAS ORIGINALLY BLANK FROM 1-13   **/\n    /** THIS IS A GOOD WAY TO FIND OUT IF YOU HAVE A           **/\n    /** CONTINUATION THAT HAS TO BE DEALT WITH...DIR 9 JULY 97 **/\n    /************************************************************/\n    SAY NEWLINE\n    LINE = NEWLINE\n    IF WORDS(NEWLINE) > 12 THEN DO\n      SAY \"******************************************************\"\n      SAY \"******************************************************\"\n      SAY \"T50CON: TRUNCATION HAS OCCURED IN REFORMATTING        \"\n      SAY \"******************************************************\"\n      SAY \"******************************************************\"\n    END\n  END\n  /*************************************************************/\n  WORD1 = W.1\n  WORD2 = W.2\n  IF MULTI.WORD1.WORD2.segment = \"YES\" THEN DO\n    /* say \"entering dynam routine outnum is :\" outnum   */\n    OUTNUM = OUTNUM + MULTI.WORD1.WORD2.0ITERATE\n    /* say \"after resolution  outnum is :\" outnum   */\n    /* say \"T50CON: multi match on line\" i\" words: \"word1 word2  */\n    /*say \"T50CON: input cmd/rsname values are below\"            */\n    /*say multi.word1.word2.0cmd multi.word1.word2.0rsname       */\n    /****************************************/\n    /* check for precmd value and issue   it*/\n    /****************************************/\n    VALID = DATATYPE(MULTI.WORD1.WORD2.0PRECMD)\n    if valid = \"NUM\" then do cnum = 1 to MULTI.WORD1.WORD2.0PRECMD\n      SAY \"T50CON: precmd issueing:\" MULTI.WORD1.WORD2.0PRECMD.cnum\n      INTERPRET MULTI.WORD1.WORD2.0PRECMD.cnum\n    end\n    /****************************************/\n    /* check for RSNAME value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0RSNAME\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0RSNAME\" THEN DO\n      HOLDVAL = \"RSNAME.OUTNUM  = \" MULTI.WORD1.WORD2.0RSNAME\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for TYPE value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0TYPE\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0TYPE\" THEN DO\n      HOLDVAL = \"TYPE.OUTNUM    = \" MULTI.WORD1.WORD2.0TYPE\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for access value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0ACCESS\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0ACCESS\" THEN DO\n      HOLDVAL = \"ACCESS.OUTNUM  = \" MULTI.WORD1.WORD2.0ACCESS\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for CMD value and resolve it */\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0CMD\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0CMD\" THEN DO\n      HOLDVAL = \"CMD.OUTNUM    = \" MULTI.WORD1.WORD2.0CMD\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for UNTIL value and resolve it */\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0UNTIL\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0UNTIL\" THEN DO\n      HOLDVAL = \"UNTIL.OUTNUM  = \" MULTI.WORD1.WORD2.0UNTIL\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for postcmd value and issue  it*/\n    /****************************************/\n    VALID = DATATYPE(MULTI.WORD1.WORD2.0POSTCMD)\n    IF VALID = \"NUM\" THEN DO CNUM = 1 TO MULTI.WORD1.WORD2.0POSTCMD\n      SAY \"T50CON: Postcmd issueing:\" MULTI.WORD1.WORD2.0POSTCMD.CNUM\n      INTERPRET MULTI.WORD1.WORD2.0POSTCMD.CNUM\n    END\n    SAY \"T50CON: Multi match output for line \"i\" is : \",\n    cmd.outnum type.outnum rsname.outnum access.outnum\n    ITERATE I\n  END\n  IF ITERATE.WORD1.segment = \"YES\" THEN DO\n    /*                                               */\n    /*SAY \"SINGLE LINE=\" W.1 W.2 W.3 W.4 W.5 W.6 W.7 */\n    /*say \"T50CON: segment is \" segment              */\n    /*say \"T50CON: found single match on line \"i\" word: \"WORD1  */\n    OUTNUM = OUTNUM + ITERATE.WORD1\n    if datatype(precmd.word1) = \"NUM\"  then\n      do cnum = 1 to precmd.word1\n      say \"T50CON: precommand \"cnum\" of \"precmd.word1 precmd.word1.cnum\n      interpret precmd.word1.cnum\n    end\n    if rsname.word1 /= \"\" then do\n      holdval = \"rsname.outnum  = \" rsname.word1\n      interpret holdval\n    end\n    if access.word1 /= \"\" then do\n      holdval = \"access.outnum  = \" access.word1\n      interpret holdval\n    end\n    if until.word1 /= \"\" then do\n      holdval = \"until.outnum  = \" until.word1\n      interpret holdval\n    end\n    if cmd.word1 /= \"\" then do\n      holdval = \"cmd.outnum  = \" cmd.word1\n      interpret holdval\n    end\n    if type.word1 /= \"\" then do\n      holdval = \"type.outnum  = \" type.word1\n      interpret holdval\n    end\n    if datatype(postcmd.word1) = \"NUM\" then\n      do cnum = 1 to postcmd.word1\n      say \"T50CON: postcmd \"cnum\" of \"postcmd.word1 postcmd.word1.cnum\n      interpret postcmd.word1.cnum\n    end\n    SAY \"T50CON: Lone  match output for line \"i\" is : \",\n      cmd.outnum type.outnum rsname.outnum access.outnum\n    ITERATE I\n  END\n  /*************************************************************/\n  /*************************************************************/\n  /**  end of dynamic area                                   ***/\n  /*************************************************************/\n  /*************************************************************/\n  IF (W.1 = \"MASTER\") & (W.2 = \"FAC\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"MAS(\"W.3\")\"\n    MSG2 = \"WARNING: THE SOURCE ID (\"ACID\") IS THE MASTERID OF A\",\n    \"FACILITY (\"W.3\").\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMP1 = W.3\",\"W.4\",\"W.5\",\"W.6\n    TEMP1 = STRIP(TEMP1,T,\",\")\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMP1\"))\"\n    CMD_DEFAULT = \"PER\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMP1 = W.3\",\"W.4\",\"W.5\",\"W.6\n    TEMP1 = STRIP(TEMP1,T,\",\")\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMP1\"))\"\n    /* CMD_DEFAULT = \"PER\"  */\n    ITERATE I\n  END\n  /**************************************************/\n  /* THIS IS THE START OF THE RDT                   */\n  /* THIS FUNCTION MAY PRODUCE MORE THAN 80 CHAR    */\n  /* OUTPUT                            DIR 4 APR 97 */\n  /**************************************************/\n  IF ACID  = \"RDT\" THEN DO\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    IF ((W.1 = \"RESOURCE\") & (W.2= \"CLASS\")) | (W.1 = \"TSS0300I\" ),\n    THEN DO\n      OUTNUM = OUTNUM + 1\n      RSNAME.OUTNUM = \"RESCLASS(\"RCLASS\")\",\n      \" RESCODE(\"RCODE\")  \"\n      IF ATTR \u00ac= \"\" THEN DO\n        RSNAME.OUTNUM = RSNAME.OUTNUM||\"ATTR(\"ATTR\") \"\n      END\n      IF ACLIST1 \u00ac= \"\" THEN DO\n        RSNAME.OUTNUM = RSNAME.OUTNUM||\"ACLST(\"ACLIST\",\"ACLIST1\")\"\n      END\n      ELSE DO\n        IF ACLIST \u00ac= \"\" THEN\n          RSNAME.OUTNUM = RSNAME.OUTNUM||\"ACLST(\"ACLIST\")\"\n      END\n      IF RCLASS = \"RCLASS\" THEN OUTNUM = OUTNUM - 1 /* KILL LINE 1 */\n      RCLASS = W.3\n      ATTR= \"\"\n      ACLIST1 = \"\"\n      ACLIST = \"\"\n      DEFACC= \"\"\n    END\n    IF (W.1 = \"RESOURCE\") & (W.2= \"CODE\") THEN\n      RCODE = SUBSTR(W.3,3,2)\n    IF (W.1 = \"ATTRIBUTE\") THEN\n      ATTR = W.2\n    IF (W.1 = \"ACCESS\") & (ACLIST \u00ac= \"\" ) THEN DO\n      W.2= TRANSLATE(W.2,\"\",\")\")   /* REPLACE ) WITH NULLS */\n      W.2= TRANSLATE(W.2,\"=\",\"(\")  /* REPLACE ) WITH = */\n      W.2= TRANSLATE(W.2,\" \",\",\")  /* REPLACE , WITH   */\n      PARSE VAR W.2 T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 T.11 T.12\n      SAY W.2\n      WORDNUM = WORDS(W.2)\n      HOLD1 = T.WORDNUM\n      LOOPNUM = WORDNUM - 1\n      DO Q2 = LOOPNUM TO 1 BY -1\n        HOLD1 = HOLD1||\",\"T.Q2\n      END\n      ACLIST1 = HOLD1\n    END\n    IF (W.1 = \"ACCESS\") & (ACLIST = \" \" ) THEN DO\n      W.2= TRANSLATE(W.2,\"\",\")\")   /* REPLACE ) WITH NULLS */\n      W.2= TRANSLATE(W.2,\"=\",\"(\")  /* REPLACE ) WITH = */\n      W.2= TRANSLATE(W.2,\" \",\",\")  /* REPLACE , WITH   */\n      PARSE VAR W.2 T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 T.11 T.12\n      WORDNUM = WORDS(W.2)\n      HOLD1 = T.WORDNUM\n      LOOPNUM = WORDNUM - 1\n      DO Q2 = LOOPNUM TO 1 BY -1\n        HOLD1 = HOLD1||\",\"T.Q2\n      END\n      ACLIST= HOLD1\n    END\n    IF (W.1 = \"DEFACC\") THEN\n      DEFACC= W.2\n    ITERATE I\n  END\n  /* SAMPLE RDT ADD IS BELOW                                      */\n  /*  TSS ADD(RDT) RESCLASS(BUDGET) RESCODE(30)                   */\n  /*  ATTR(LONG,GENERIC,DEFPROT) -                                */\n  /*  ACLST(ALL,ADD=000E,CHANGE=0006,USE=0002,NONE) DEFACC(NONE)  */\n  /**************************************************/\n  /* THIS IS THE END OF THE RDT AREA                */\n  /**************************************************/\n  IF W.1 = \"DAYS\" THEN DO\n    DAYS.OUTNUM = \"DAYS(\"W.2\")\"\n    IF INDEX(W.3,\"TIMES(\") = 1 THEN\n      TIME.OUTNUM = W.3\n    IF W.2 = \"ALL\" THEN DAYS.OUTNUM = ''\n    /**************************************************/\n    /* IF THE W.3 WORD IS TIMES( THEN THE RULE IS     */\n    /* TIMES( ANY ) . IN THIS CASE JUST ERASE IT.     */\n    /**************************************************/\n    IF W.3 = \"TIMES(\" THEN TIME.OUTNUM = ''\n    ITERATE I\n  END\n  IF W.1 = \"SOURCES\" THEN DO\n    W.1 = \"SOURCE\"\n    CMD_DEFAULT  = \"ADD\"\n  END\n  IF W.1 = \"INSTDATA\" THEN DO\n    OUTNUM = OUTNUM + 1\n  /*********************************************************/\n  /** ONE OF MY CLASSIC DEBUGS IS BELOW                   **/\n  /*SAY \"T50CON: AT  INSTDATA I IS \" I \"OUTNUM IS \" OUTNUM */\n  /*********************************************************/\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"INSTDATA\"\n    RSNAME.OUTNUM =\"'\"||STRIP(SUBSTR(LINE,14,59))||\"'\"\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"INSTDATA\"\n    ITERATE I\n  END\n  IF W.1 = \"ACCESSORID\" THEN DO\n    FLUSH = \"YES\"\n    TEMP = OUTNUM + 1\n    CMD_DEFAULT = \"ADD\"\n    IF W.2 = \"*RDT*\" THEN W.2 = \"RDT\"\n    IF W.2 = \"*STC*\" THEN W.2 = \"STC\"\n    IF W.2 = \"*AUDIT*\" THEN W.2 = \"AUDIT\"\n    ACID = W.2\n    ACID.TEMP   = W.2\n    if newacid /= \"\" then acid.temp = newacid\n    /******************************************************/\n    /** WE CHANGE THE ACID TO SUPPORT AN INPUT STREAM    **/\n    /** WITH MORE THAN ONE LISTED ACID THIS WOULD BE     **/\n    /** USED IF WE HAD A BYPASS PARM TO A LIST(ACIDS) DSN**/\n    /******************************************************/\n    IF ACID = \"*ALL*\" THEN ACID = \"ALL\"\n    IF ACID = \"*STC*\" THEN ACID = \"STC\"\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = \"LIB(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    IF REFORMAT = \"YES\" THEN DO   /* WE HAVE MULTI LINES OF PGMS */\n      LENP = LENGTH(PRIVPGM.OUTNUM) - 1\n      H1 = SUBSTR(PRIVPGM.OUTNUM,1,LENP)\n      PRIVPGM.OUTNUM = H1 STRIP(W.2 W.3 W.4 W.5 W.6)||\")\"\n    END\n    ELSE   /* IF IT IS NOT MULTIPLE LINES OF PGMS */\n      PRIVPGM.OUTNUM = \"PRIVPGM(\"STRIP(W.2 W.3 W.4 W.5 W.6)\")\"\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = \"FAC(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.1 = \"PASSWORD\" THEN DO\n    OUTNUM = OUTNUM  + 1\n    RSNAME.OUTNUM = \"PASSWORD(\"W.2\",90)\"\n    IF W.2 = \"*NOPW*\" THEN\n      RSNAME.OUTNUM = \"PASSWORD(NOPW,0)\"\n    CMD.OUTNUM = \"REP\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    OUTNUM = OUTNUM + 1\n    W.2  = TRANSLATE(W.2,\" \",\",\") /* REPLACE COMMAS WITH SPACES */\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    OUTNUM = OUTNUM + 1\n    W.2  = TRANSLATE(W.2,\" \",\",\") /* REPLACE COMMAS WITH SPACES */\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = \"ACTION(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.3 = \"NAME\" THEN DO\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    ITERATE I\n  END\n  IF ACID = \"STC\" THEN DO\n    IF W.2 = \"SIZE\" THEN ITERATE I\n    OUTNUM = OUTNUM + 1\n    IF W.2 = \"*DEF*\" THEN W.2 = \"DEFAULT\"\n    IF W.5 = \"*FAIL*\" THEN W.4 = \"FAIL\"\n    IF W.5 = \"*DORM*\" THEN W.4 = \"DORM\"\n    IF W.5 = \"*BYPASS*\" THEN W.4 = \"BYPASS\"\n    IF W.5 = \"*WARN*\" THEN W.4 = \"WARN\"\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    RSNAME.OUTNUM = \"PROC(\"W.2\")               \"\n    TEMP1 = SUBSTR(RSNAME.OUTNUM,1,17)\n    RSNAME.OUTNUM = TEMP1 \"ACID(\"W.4\")\"\n    ITERATE I\n  END\n  /**************************/\n  /* MY BABY FALL THRU AREA */\n  /**************************/\n  IF W.2 = \" \" THEN ITERATE\n  IF SUBSTR(LINE,1,2) = \"  \" THEN DO\n    SAY \"************************************************\"\n    SAY \"************************************************\"\n    SAY \"T50CON: UNRECOGNIZED INDENTED LINE # \" I\n    SAY   LINE\n    SAY \"************************************************\"\n    SAY \"************************************************\"\n  END\n  say \"T50CON: fallthru line:\"i\" segment:\" segment \"word1:\"w.1\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM = CMD_DEFAULT\n  /**************************************************/\n  DO XX = 3 TO 8\n    /*SAY XX IS PAR.XX */\n    /**************************************************/\n    /* NOTE THAT BLANKS AND HEX 00S FAIL THE BELOW    */\n    /* CHECK SO THAT SOME COLUMNS THAT ARE ALWAYS IN  */\n    /* IDS BUT ARE SOMETIMES BLANKS ARE NOT NORMALLY  */\n    /* PROCESSED.                 DIR                 */\n    /**************************************************/\n    IF WORDS(W.XX) <> 0 THEN DO\n      say \"T50CON: fallthru routine parsing \"w.xx\n      OUTNUM = OUTNUM + 1\n      RSNAME.OUTNUM = W.XX\n      TYPE.OUTNUM = W.1\n      CMD.OUTNUM = CMD_DEFAULT\n    END\n  END\nEND\nSAY \"T50CON : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/**************************************************/\n/**************************************************/\n/* THE ACTUAL OUTPUT IS CREATED BELOW FROM THE    */\n/* INPUT LINES. SOME FORMATTING IS DONE UNLESS THE*/\n/* THE TYPE VARIABLE IS \"$$\" IN WHICH CASE THE    */\n/* RSNAME VARIABLE IS APPENDED TO THE ID AND      */\n/* COMMAND AND ISSUED WITH NO FORMATTING. THIS    */\n/* ALLOWS THE ABOVE ROUTINES TO PREPROCESS SOME   */\n/* ENTRY TYPES THAT ARE COMPLEX. DIR 2 APR 97     */\n/**************************************************/\n/**************************************************/\nDO X = 1 TO OUTNUM\n  Y  = X + 1          /* IN CASE WE LOOK AT THE NEXT LINE */\n  B4 = X - 1          /* IN CASE WE LOOK AT THE PREVIOUS LINE */\n  IF ACID.X = \"ACID.\"||X THEN ACID.X = ACID.B4\n  REALOUT = REALOUT + 1\n  /**************************************************/\n  /* A STANDARD DSN PERMIT IS BELOW DIR 2 APR 97    */\n  /**************************************************/\n  BATFILE.X = \" TSS \"CMD.X\"(\"ACID.X\") \"TYPE.X\"(\"RSNAME.X\") \"ACCESS.X,\n    UNTIL.X LIBRARY.X FACILITY.X PRIVPGM.X DAYS.X TIME.X ACTION.X\n  /**************************************************/\n  /* A PREFORMATTED COMMAND JUST ISSUE IT           */\n  /**************************************************/\n  IF TYPE.X = \"$$\" THEN\n    BATFILE.X = \" TSS \"CMD.X\"(\"ACID.X\") \"RSNAME.X\n  BATFILE.X = STRIP(BATFILE.X,T)\n  /**************************************************/\n  /* INSTDATA IS HANDLED SPECIAL BECAUSE IT CAN BE  */\n  /* SO LONG IT GETS ITS OWN LINE DIR 2 APR 97      */\n  /**************************************************/\n  IF TYPE.X = \"INSTDATA\" THEN DO\n    SAY \"                       ***********                       \"\n    SAY \"T51: BEGINNING OF INSTDATA PARSING ROUTINE. LINE IS BELOW\"\n    SAY BATFILE.X\n    PARSE VAR BATFILE.X W.1 W.2 W.3 W.4 W.5 W.6 W.7\n    OUTPUT.REALOUT = \" \"W.1 W.2 \"+\"\n    SAY OUTPUT.REALOUT\n    REALOUT = REALOUT + 1\n    OUTPUT.REALOUT = \"    \"STRIP(W.3 W.4 W.5 W.6 W.7)\n    SAY OUTPUT.REALOUT\n    ITERATE X\n  END\n  /**************************************************/\n  /* IF IT IS TOO LONG ILL BREAK IT UP              */\n  /**************************************************/\n  IF LENGTH(BATFILE.X)  > 72 THEN DO\n    say \"T50CON: line too long reformatting for output of 72\"\n    PARSE VAR BATFILE.X W.1 W.2 W.3 W.4 W.5 W.6 W.7\n    OUTPUT.REALOUT = \" \"W.1 W.2 W.3 \"+\"\n    REALOUT = REALOUT + 1\n    OUTPUT.REALOUT = \"    \"STRIP(W.4 W.5 W.6 W.7)\n    IF LENGTH(OUTPUT.REALOUT) > 72 THEN DO\n      say \"T50CON: breaking up data lines.\"\n      say \"T50CON: w4 and w5:\" w.4 w.5\n      say \"T50CON: w6 and w7:\" w.6 w.7\n      OUTPUT.REALOUT = \"    \"W.4 W.5\" +\"\n      REALOUT = REALOUT + 1\n      V4 = \"\"\n      OUTPUT.REALOUT = W.6 \", + \"\n      /***********************************************/\n      /** IF W6 IS MULTIPLE WORDS SEPERATED BY      **/\n      /** COMMAS THEN WE WILL SEPERATE THEM. 30JUL97**/\n      /***********************************************/\n      IF WORDS(TRANSLATE(W.6,\" \",\",\")) >  3 THEN DO\n        PARSE VAR W.6 V1 ',' V2 ',' V3 ',' V4\n        OUTPUT.REALOUT = \"    \"V1\",\"V2\",\"V3\", + \"\n      END\n      REALOUT = REALOUT + 1\n      OUTPUT.REALOUT = \"    \"V4  W.7\n      REALOUT = REALOUT + 1\n      OUTPUT.REALOUT = \"    \"\n    END\n  END\n  ELSE DO\n    OUTPUT.REALOUT = BATFILE.X\n  END\nEND\nLASTCMD = \"DUMMY\"\nDO T2 = 2 TO REALOUT\n  B4 = T2 - 1\n  IF OUTPUT.T2 = LASTCMD THEN DO\n    SAY \"DUPLICATE LINE DROPPED #\" T2 OUTPUT.T2\n    OUTPUT.T2 = \" \"\n  END\n  IF OUTPUT.T2 /= \" \" THEN LASTCMD = OUTPUT.T2\n  /* SAY \"LASTCMD IS \"LASTCMD */\nEND\nSECRC = \"FAILED, DURING OUTPUT RESOLUTION CHECK OUTPUT STREAM.\"\n\"EXECIO \"CREATE.0\" DISKW BJCL ( FINIS STEM CREATE.)\"\nsay \"T50CON: output lines is \" realout\nREALOUT = REALOUT + 1\nOUTPUT.REALOUT = \"@@\"\n\"EXECIO \"REALOUT\" DISKW BJCL ( FINIS STEM OUTPUT.)\"\n\"FREE DDN(BJCL)\"\n SECRC = \"TSA515W: Unsupported function completed. Output in \" DS2\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\nSIGNAL OFF ERROR\nSAY \"T50CON: ERRORL IN LINE \" SIGL\nSAY SOURCELINE(SIGL)\n/* SECRC = \"T50CON: ERROR IN LINE\"  SIGL  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/**********************************************/\n/**********************************************/\n/***** SUBROUTINES SUBROUTINES  ***************/\n/**********************************************/\n/**********************************************/\nMAKEACID: PROCEDURE EXPOSE ACID I INLINE. NAME TYPE DIV DEPT,\n  ZONE OUTNUM CREATE. CREATE_NUM NEWACID NEWTYPE NEWPASS\n/**********************************************/\nIF NEWACID \\= ''  THEN ACID = NEWACID\nIF NEWTYPE \\= ''  THEN TYPE = NEWTYPE\nIF NEWTYPE = \"LSCA\" THEN OWNER = \"OWNER\"\nUSER_FLAG = \"YES\"\nIF TYPE = \"TYPE\" THEN USER_FLAG = \"$$\"\nIF TYPE = \"DIVISION\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"GROUP\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"DIV\" THEN TYPE= \"VCA\"\nIF TYPE = \"DEPT\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"PROFILE\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"ZONE\" THEN USER_FLAG = \"NO\"\nIF ZONE \\= \" \" THEN OWNER = \"ZONE\"\nIF ZONE \\= \" \" THEN AREA = ZONE\nIF DIV  \\= \" \" THEN OWNER = \"DIV\"\nIF DIV  \\= \" \" THEN AREA  =  DIV\nIF DEPT \\= \" \" THEN OWNER = \"DEPT\"\nIF DEPT \\= \" \" THEN AREA  =  DEPT\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \" TSS CRE(\"ACID\") NAME('\"NAME\"') +\"\nIF USER_FLAG = \"YES\" THEN\n  T = \"  \"OWNER\"(\"AREA\")   TYPE(\"TYPE\") PASSWORD(\"NEWPASS\")\"\nELSE\n  T = \"  \"OWNER\"(\"AREA\")   TYPE(\"TYPE\")\"\nIF OWNER = \"OWNER\" THEN T = \"   TYPE(\"TYPE\") PASSWORD(\"NEWPASS\")\"\nIF TYPE = \"DIVISION \"THEN T = \"   TYPE(\"TYPE\")\"\nIF USER_FLAG = \"$$\" THEN DO\n  SAY \"*********************************************************\"\n  SAY \"T50CON: MAKEACID ROUTINE ABORTING DUE TO LACK OF USER TYPE\"\n  SAY \"T50CON: ACID = \"ACID\n  SAY \"*********************************************************\"\n  RETURN\nEND\nDIV = \"\"\nDEPT = \"\"\nZONE = \"\"\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \"  \"T\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \"  \"\nCREATE.0 = CREATE_NUM\nsay \"T50CON: leaving makeacid routine # lines out = \" create.0\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51DEL": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x04\\x00&\\x00\\x955/\\x01\\x005\\x7f\\tG\\x00O\\x00O\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.04", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-12-22T09:47:26", "lines": 79, "newlines": 79, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50DEL                            **/\n/** LAST MODIFIED    : 17 SEP 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID YOU WISH DELETED.                 **/\n/** MODE    : THE CURRENT MODE \"BATCH\" OR \"ONLINE\"       **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** UIDTABLE : THE GROUP OF 2 CHR NON TSS ID PREFIXES    **/\n/** TVER     : THE CURRENT TSS VERSION VARIABLE          **/\n/** DSBACK   : THE DS WHERE TO TAKE A BACKUP COPY        **/\n/** DS5      : THE DS WHERE TO PUT BATCH SYSIN UPDATES   **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES ( NOTE VGETS )              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T4?LSTO TSSAUDR      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nthiscmd = sysvar(sysicmd)\nSIGNAL OFF ERROR\nsecrc = \"TSA510E: \"Thiscmd\" has ended abnormally.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET TVER PROFILE\"\nADDRESS ISPEXEC \"VGET AUD PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET DS5 PROFILE\"\nUIDENTRY = LENGTH(UIDTABLE)/2\nUIDSTART = 1\nACID2 = SUBSTR(ACID,1,2)\nDSLIST = \"'\"DSBACK\"(\"||ACID||\")'\"\nBJCL.0 = 3\nBJCL.1 = \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\nBJCL.2 = \"TSS DEL( \"ACID\")\"\nBJCL.3 = \"%DELLOCAL\" ACID\nIF MODE = \"BATCH\" THEN DO\n  SAY \"TSA101D: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  ADDRESS MVS \"EXECIO \"BJCL.0\" DISKW BJCL (FINIS STEM BJCL.)\"\n  secrc = \"TSA511I: Batch file updated with delete stream for \" acid\nEND\nIF MODE = \"ONLINE\" THEN DO\n  TOTCODE = 0\n  SIGNAL OFF ERROR\n  SAY \"TSA101D: ONLINE MODE DETECTED. EXECUTING DELETE STREAM\"\n  SECRC = \"DELETE COMMAND STREAM FOR \" ACID \"FLUSHED.\"\n  DO CN = 1 TO BJCL.0\n    HOLD = BJCL.CN\n    SAY ADDRESS TSO \" \"   HOLD\n    ADDRESS TSO \" \"   HOLD\n    TOTCODE = RC + TOTCODE\n  END\n  SECRC = \"COMMAND STREAM FOR \" ACID \"COMPLETED NORMALLY.\"\n  IF TOTCODE > 0 THEN\n  SECRC = \"STREAM HAD PARTIAL FAILURE, CHECK IDS STATUS. CODE=\" TOTCODE\n  IF TOTCODE = 16 THEN\n  SECRC = \"ID MAY NOT EXIST OR YOUR AUTHORITY MAY BE INVALID.\"\n  SAY SECRC\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n\nBADTSS: NOP\nSECRC = \"THE TSS ID YOU SPECIFIED WAS NOT LISTABLE, CHECK THE ID\"\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\nBOOKAUTH: NOP\nSECRC = \"YOU DONT HAVE AUTHORITY TO DELETE AN ID WITH BOOK NUMBER\" BOOK\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51DELO": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x005\\x7f\\x01\\x005\\x7f\\tH\\x00}\\x00}\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-22T00:00:00", "modifydate": "2000-12-22T09:48:04", "lines": 125, "newlines": 125, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** REMOVED THE CODE TO DELETE ALIAS FROM IMS            **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50DEL                            **/\n/** LAST MODIFIED    : 07 DEC 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID YOU WISH DELETED.                 **/\n/** MODE    : THE CURRENT MODE \"BATCH\" OR \"ONLINE\"       **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** UIDTABLE : THE GROUP OF 2 CHR NON TSS ID PREFIXES    **/\n/** TVER     : THE CURRENT TSS VERSION VARIABLE          **/\n/** DSBACK   : THE DS WHERE TO TAKE A BACKUP COPY        **/\n/** DS5      : THE DS WHERE TO PUT BATCH SYSIN UPDATES   **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES ( NOTE VGETS )              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T4?LSTO TSSAUDR      **/\n/**                                 TSSACNT              **/\n/**********************************************************/\nARG ACID MODE\nSIGNAL OFF ERROR\nSECRC = \"T50DEL HAS ENDED ABNORMALLY.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET UADSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET UIDTABLE PROFILE\"\nADDRESS ISPEXEC \"VGET TVER PROFILE\"\nADDRESS ISPEXEC \"VGET AUD PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET DS5 PROFILE\"\nUIDENTRY = LENGTH(UIDTABLE)/2\nUIDSTART = 1\nACID2 = SUBSTR(ACID,1,2)\nDSLIST = \"'\"DSBACK\"(\"||ACID||\")'\"\nSAY \"T50DEL: BUILDING UID BYPASS TABLE ARRAY OF \" UIDENTRY \"ENTRIES\"\nDO X = 1 TO UIDENTRY\n  UID.X = SUBSTR(UIDTABLE,UIDSTART,2)\n  UIDSTART = UIDSTART + 2\nEND\nNONTSS = \"NO\"\nDO T = 1 TO UIDENTRY\n  IF (ACID2 = UID.T) THEN NONTSS = \"YES\"\nEND\nIF NONTSS =  \"NO\" THEN DO\n  ADDRESS TSO \"%T50GDAT \" ACID \"TSOLACCT  TSO\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  IF SECRC = \"$BADTSS\" THEN SIGNAL BADTSS\n  IF SECRC /= \"$NOTFOUND\" THEN DO\n    BOOK = SECRC\n    X5 = TSSCHECK(\"BOOKNUM\",BOOK,\"UPDATE\")  /* CAN THEY DO THIS */\n    SAY \"T50DEL: TSSCHECK RETURN CODE IS \" X5\n    IF X5 /= \"OK\"  THEN SIGNAL BOOKAUTH\n  END\nEND\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T50DEL: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1 = \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\n  BJCL.2 = \"%RXREPRO SYS1.UADS(\"ACID\"0) \"UADSBACK\"(\"ACID\"0)\"\n  BJCL.2 = \" \"\n  BJCL.3 = \"TSS DEL( \"ACID\")\"\n  BJCL.4 = \"ACCOUNT\"\n  BJCL.5 = \"DEL (\"ACID \")\"\n  BJCL.6 = \"E\"\n  BJCL.7 = \"%TSSAUDR \" ACID AUD\n  BJCL.8 = \"%IMSDALIA\" ACID\n  BJCL.8 = \"  \"\n  IF NONTSS = \"YES\"  THEN DO\n    BJCL.1 = \"%\"TVER\"LSTO\" ACID||\"@  ALLPW\"  DSLIST\n    BJCL.2 = \"TSS DEL( \"ACID\"@)\"\n  END\n  ADDRESS MVS \"EXECIO 8 DISKW BJCL (FINIS STEM BJCL.)\"\n  SECRC = \"BATCH FILE UPDATED WITH DELETE COMMAND STREAM FOR \" ACID\nEND\nELSE DO\n  TOTCODE = 0\n  SIGNAL OFF ERROR\n  SAY \"T50DEL: ONLINE MODE DETECTED. EXECUTING DELETE STREAM\"\n  SECRC = \"DELETE COMMAND STREAM FOR \" ACID \"FLUSHED.\"\n  /***************************************************/\n  /** IF NONTSS = YES THEN I DO NOT CARE IF THE TSS **/\n  /** PORTION OF THE DELETE STREAM FUNCTIONS        **/\n  /** CORRECTLY..      HENCE ALL THE IFS BELOW      **/\n  /***************************************************/\n  ADDRESS TSO  \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\n  IF NONTSS = \"YES\" THEN  /* TRY TO DELETE THE @ GHOST ENTRY */\n    ADDRESS TSO  \"%\"TVER\"LSTO\" ACID\"@ ALLPW\"  DSLIST\n  IF NONTSS = \"NO\" THEN TOTCODE = RC + TOTCODE\n  /* \"%RXREPRO SYS1.UADS(\"ACID\"0) \"UADSBACK\"(\"ACID\"0)\"*/\n  ADDRESS TSO  \"%TSSAUDR \" ACID\n  TOTCODE = RC + TOTCODE\n  /* ADDRESS TSO  \"%IMSDALIA\" ACID */\n  /* TOTCODE = RC + TOTCODE */\n  ADDRESS TSO  \"TSS DEL(\" ACID \")\"\n  IF NONTSS = \"YES\" THEN ADDRESS TSO  \"TSS DEL(\" ACID\"@)\"\n  IF NONTSS = \"NO\" THEN TOTCODE = RC + TOTCODE\n  ADDRESS TSO  \"%TSSACNT \" ACID \"DELETE\"\n  TOTCODE = RC + TOTCODE\n  SECRC = \"COMMAND STREAM FOR \" ACID \"COMPLETED NORMALLY.\"\n  IF TOTCODE > 0 THEN\n  SECRC = \"STREAM HAD PARTIAL FAILURE, CHECK IDS STATUS. CODE=\" TOTCODE\n  IF TOTCODE = 16 THEN\n  SECRC = \"ID MAY NOT EXIST OR YOUR AUTHORITY MAY BE INVALID.\"\n  SAY SECRC\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n\nBADTSS: NOP\nSECRC = \"THE TSS ID YOU SPECIFIED WAS NOT LISTABLE, CHECK THE ID\"\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\nBOOKAUTH: NOP\nSECRC = \"YOU DONT HAVE AUTHORITY TO DELETE AN ID WITH BOOK NUMBER\" BOOK\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51DISC": {"ttr": 5128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x007\\x00\\x97 /\\x01\\x01\\x19\\x0f\\x081\\x00o\\x00o\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2001-07-09T08:31:37", "lines": 111, "newlines": 111, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** TO REMOVE PROFILE FROM ALL THAT HAVE IT              **/\n/**********************************************************/\n/** EXEC NAME        : T51DISC                           **/\n/** LAST MODIFIED    : 06 JUL 97                         **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** MODE    : THE MODE OF OPERATION                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nENV = SYSVAR(SYSENV)\n/**********************************************************/\n/* REMOVE THE BELOW DO IF YOU WANT THIS EXEC TO RUN IN   **/\n/* ONLINE MODE....( YECH !!)                             **/\n/**********************************************************/\nIF (MODE \\= \"BATCH\") & (ENV = \"FORE\") THEN DO\n  SECRC =\"FUNCTION FAILED. DISCONNECT CANNOT BE RUN IN ONLINE MODE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE   \"\n  EXIT 04\nEND\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS ISPEXEC\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS A PROFILE, FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO REMOVE THAT  PROFILE FROM   */\n/* ALL THE IDS THAT HAVE IT ATTACHED.                               */\n/********************************************************************/\nSTARTOUT: NOP\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T51DISC: BATCH MODE DETECTED. USING DDN BJCL AS OUTPUT\"\n  /* ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"   */\nEND\nOUTNUM =  1\n/***********/\nSECRC = \"LIST COMMAND FAILURE, CHECK IDS VALIDITY\"\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(ACIDS)\"\nQ = OUTTRAP(\"OFF\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  IF WORD(INLINE,1) = \"TSS0300I\" THEN\n    SIGNAL OUTSTART\n  IF SUBSTR(INLINE,14,1) = \" \" THEN\n    GOFLAG = NO\n  IF SUBSTR(INLINE,1,5) = \"ACIDS\" THEN\n    GOFLAG=YES\n  IF GOFLAG = YES THEN DO\n    ID.1 = SUBSTR(INLINE,14,8)\n    ID.2 = SUBSTR(INLINE,26,8)\n    ID.3 = SUBSTR(INLINE,38,8)\n    ID.4 = SUBSTR(INLINE,50,8)\n    DO IDCNT = 1 TO 4\n      IF ID.IDCNT = \"*NONE*\" THEN ITERATE X\n      IF ID.IDCNT = \" \" THEN ITERATE X\n      SECRC = \" \"\n    /************************************************************/\n    /************************************************************/\n      SAY \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      IF MODE \\= \"BATCH\" THEN\n        ADDRESS TSO \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      ELSE DO\n        BJCL.OUTNUM = \"TSS REM(\"ID.IDCNT\") PROF(\"ACID\")\"\n        OUTNUM = OUTNUM + 1\n      END\n    END\n  END\nEND\nOUTSTART: NOP\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM BJCL.)\"\n  /*ADDRESS TSO \"FREE DDN(BJCL)\"   */\nEND\nSECRC= \"FUNCTION COMPLETED NORMALLY. \"\nIF MODE = \"BATCH\" THEN\n  SECRC= \"FUNCTION COMPLETED NORMALLY. OUTPUT APPENDED TO BATCH FILE.\"\n  IF SYSVAR(SYSENV) = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nCLOSEEM: NOP\nSAY \"LINE IS \"SIGL\nSAY  SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51DSNP": {"ttr": 4356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x00\\x10\\x1f\\x01\\x00\\x10\\x1f\\x15G\\x00p\\x00p\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-04-10T00:00:00", "modifydate": "2000-04-10T15:47:58", "lines": 112, "newlines": 112, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG ACID DSNAME ACCESS DAYS\nSIGNAL OFF ERROR\nSECRC = \"T50DSNP FAILED WITH ERRORS\"\nD.0 =\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET DSNAUDL  PROFILE\"\nIF DSNAUDL = \" \" THEN DSNAUDL = \"'IMS.PROD.PARMLIB(AUDIT)'\"\nIF SYSDSN(DSNAUDL) = \"OK\" THEN DO\n  SAY \"T50DSNP: DSNAUDL IS\" DSNAUDL\n  \"ALLOC DDN(INPUT) DSN(\"DSNAUDL\") SHR REUS\"\n  \"EXECIO * DISKR INPUT ( FINIS STEM D.)\"\n  \"FREE DDN(INPUT)\"\n  SAY \"T50DSNP: I HAVE \"D.0\" QUALIFIERS TO AUDIT\"\n  DO T = 1 TO D.0\n    D.T = WORD(D.T,1)\n  END\nEND\nQ = OUTTRAP(OUT.)\nACTION = \"ACTION(FAIL)\"\nDAY1 = WORD(DAYS,1)\nDAY2 = WORD(DAYS,2)\nIF DAYS = \"AUDIT\" THEN DO\n  SAY \"T50DSNP: AUDIT VALUE DETECTED WITH NO DAYS LIMITATION.\"\n  DAYS = \"0\"\n  DAY1 = \"0\"\n  ACTION= \"ACTION(AUDIT)\"\nEND\nIF (DATATYPE(DAY1) \u00ac= \"NUM\") & (DAY1 \u00ac= \" \" ) THEN DO\n  SAY \"T50DSNP: DAYS VALUE NOT NUMERIC. EXEC ENDING.\"\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(AUDIT)\"\n  MSG2 = \"THE FOLLOWING PARAMETER WAS NOT NUMERIC\" DAY1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF DAY2 = \"AUDIT\" THEN DO\n  SAY \"T50DSNP: AUDIT VALUE DETECTED.\"\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(AUDIT)\"\nEND\nIF (DAY2 \u00ac= \"AUDIT\") & (DAY2 \u00ac= \" \") THEN DO\n  SAY \"T50DSNP: DAY2 VALUE NOT UNDERSTOOD = \" DAY2\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(FAIL)\"\n  MSG2 = \"THE FOLLOWING PARAMETER WAS NOT UNDERSTOOD\" DAY2\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF ACCESS \u00ac= \"READ\" THEN DO COUNT = 1 TO D.0\n  SAY \"T50DSNP: COMPARING \"DSNAME \"TO \" D.COUNT\n  IF INDEX(DSNAME,D.COUNT) = 1 THEN DO\n    SAY \"T50DSNP: DSNAUDIT ENTRY MATCH ENTRY\" COUNT DSNAME D.COUNT\n    ACTION = \"ACTION(AUDIT)\"\n    MSG2 = \"THAT DATASET IS AUDITED DAILY, AUDIT RULE INCLUDED\"\n    IF ACID = \"UCC7BAT\" THEN DO\n      MSG2 = \"NO AUDIT RULE ADDED. ID IS THE PRODUCTION JCL ID.\"\n      ACTION = \"ACTION(FAIL)\"\n    END\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSAY \"T50DSNP: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nRCODE = 0\nADDRESS TSO \"TSS WHOOWNS DSN(\"DSNAME\")\"\nRCODE = RC\nSAY \"T50DSNP: WHOOWNS RC IS \" RCODE\nIF RCODE \u00ac= 0 THEN DO\n  SECRC = \"THAT DATASET IS NOT UNDER YOUR OWNERSHIP. FUNCTION FAILED.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY OUT.1 OUT.2\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nRCODE = RC\nSAY \"T50DSNP: TSS LIST RC IS \" RCODE\nIF RCODE \u00ac= 0 THEN DO\n  SECRC = \"THAT ID IS NOT OWNED BY YOU OR IS INVALID.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY OUT.1 OUT.2\n  EXIT 04\nEND\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T50DSNP: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") DSN(\"DSNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"DSNAME\") ACCESS(\"ACCESS\") FOR(\"DAYS\")\" ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  SECRC = \"PERMIT FUNCTION SUCCESSFULL FOR ID \"ACID\" FOR \"DAYS\" DAYS.\"\nELSE\n  SECRC = \"PERMIT RETURNED NON ZERO RCODE OF \"RCODE\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51DSSIM": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x008\\x00\\x98(_\\x00\\x98(_\\t!\\x00?\\x00?\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-12T00:00:00", "modifydate": "1998-10-12T09:21:38", "lines": 63, "newlines": 63, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"%T50TSSIM\" ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"ALLOC DDN(INFILE) DSN(\"DSOUT\") SHR REUS\"\n ADDRESS MVS \"EXECIO * DISKR INFILE ( FINIS STEM LINE.)\"\n ADDRESS TSO \" FREE DDN(INFILE)\"\n /*SAY \"T50SIM: PARMS:\" ACID RTYPE RNAME FACILITY ACCESS DSOUT */\n SAY \"T50SIM: CHECKING ACCESS FOR\" ACID \"TO\" RNAME \"THRU\" FACILITY\n SAY \"      \"\n DO T = 1 TO LINE.0\n   LINE.T = SUBSTR(LINE.T,1,79)\n   IF (W.2 = \"VOL\") & (W.3 = \"ORIGIN\")  THEN LEAVE\n   PARSE VAR LINE.T  W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n   IF W.1 = \"TSS8379W\" THEN DO\n     SAY \"************************************************\"\n     SAY \"T50SIM: THE INPUT ID IS NOT UNDER YOUR CONTROL.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8362E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T50SIM: THE INPUT ID WAS NOT TSS DEFINED.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8361E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T50SIM: AN INPUT PARAMETER WAS INCORRECT.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8393I\" THEN DO\n     IF INDEX(LINE.T,\"DSN\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T50SIM: THIS ID BYPASSES NORMAL DATASET CHECKS!!\"\n       SAY \"************************************************\"\n     END\n     IF INDEX(LINE.T,\"VOL\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T50SIM: THIS ID BYPASSES NORMAL VOLUME  CHECKS!!\"\n       SAY \"************************************************\"\n     END\n   END\n   IF W.1 = \"TSS8380I\" THEN\n     SAY \"T50SIM: RESOURCE ACCESS WOULD BE GRANTED.\"\n   IF W.1 = \"TSS8381I\" THEN\n     SAY \"T50SIM: RESOURCE ACCESS WOULD BE DENIED.\"\n   IF (W.2 = \"ALLOWED\") & (W.3 = \"ACCESS\")  THEN\n     SAY \"T50SIM: THE ID HAS \"W.5\" ACCESS TO THIS RESOURCE\"\n   IF ( W.1 = \"TSS8394I\" ) & ( W.2 \u00ac= \"VOL\" ) THEN DO\n     PROF = W.6\n     IF W.6 = \"-\" THEN PROF = W.7\n     IF W.6 = \"*USER*\" THEN\n       PROF = \"THE INDIVIDUAL ID DEFINITION FOR\" ACID\n     IF W.6 = \"*ALL*\"  THEN PROF = \"THE SYSTEM ALL RECORD.\"\n     SAY \"T50SIM: THE APPLICABLE RULE IS IN\" PROF\n   END\n   IF W.1 = \"TSS8397I\" THEN SAY \"      \" W.2 W.3 W.4 W.5\n   /* TSS8380I GRANTED  */\n   /* TSS8381I DENIED   */\n END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51FDIV": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00E\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x007\\x007\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:45", "lines": 55, "newlines": 55, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50FDIV                           **/\n/** LAST MODIFIED    : 21 JUN 94                         **/\n/**     CONVERTED FROM CLIST TO REXX EXEC                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**       SECRC CAN CONTAIN:                             **/\n/**   THE DIVISION OF THE ACID.                           */\n/**   THE STRING \"LIST FUNCTION FAILED.\" IF THE ID IS BAD.*/\n/**   THE STRING \"PROFILE\"     IF THE ID IS A PROFILE.    */\n/**   THE STRING \"LIMITED\"     IF THE ID IS AN LSCA.      */\n/**   THE STRING \"CENTRAL\"     IF THE ID IS AN SCA.       */\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  NONE                **/\n/**********************************************************/\nARG ACID\nSAY \"T50FDIV: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nSECRC = \"LIST FUNCTION FAILED.\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T50FDIV: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"\nSAY \"T50FDIV: BACK FROM TSS WITH \"INLINE.0 \"LINES OF DATA\"\nDO X = 1 TO INLINE.0\n  INLINE = INLINE.X\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n  TOTWORDS = WORDS(INLINE)\n  IF W.1 = \"TYPE\" THEN  DO\n    SAY \"T50FDIV: TYPE INITIALLY SET TO \"W.3\n    SECRC = W.3\n  END\n  IF SECRC = \"PROFILE\" THEN LEAVE /* THIS IS WHAT HE WANTS TO KNOW  */\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\") THEN  DO\n    SAY \"T50FDIV : DIVISION FOUND, IS \"W.4\n    SECRC = W.4\n  END\nEND\nSAY \"T50FDIV: NORMAL END. FINAL DIVISION IS\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nW.1 = WORD(INLINE.1,1)\nIF W.1 = \"TSS0352E\" THEN SECRC = \"AUTHORIZATION FAILED.\"\nSAY \"T50FDIV : \"INLINE.1\nSAY \"T50FDIV : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T50FDIV : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51FLOC": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x06\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x001\\x001\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:06", "lines": 49, "newlines": 49, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** RETURNS THE LOCATION OF A PROFILE IN A USERS PROFILE **/\n/** LIST ... DIR                                         **/\n/**********************************************************/\n/** EXEC NAME        : T50FLOC                           **/\n/** LAST MODIFIED    : 06 MAY 96                         **/\n/**  USES THE NEW T50FLOC  FUNTIONALITY                  **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  ANY TSS ACID                              **/\n/** PROFILE :  ANY TSS ACID THAT IS A PROFILE            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**   NONE                                               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  T50GDAT             **/\n/**                                                      **/\n/**********************************************************/\nARG ACID PROFILE\nSAY \"T50FLOC: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nGOTPRF = \"NO\"\nSECRC = \"ERROR\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T50FLOC: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"%T50GDAT \"ACID\" PROFILES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nPARSE VAR SECRC P.1 P.2 P.3 P.4 P.5 P.6 P.7 P.8 P.9 P.10 P.11 P.12\nNUM = WORDS(SECRC)\nSECRC = 0\nDO W = 1 TO NUM\n  IF PROFILE = P.W THEN SECRC = W\nEND\nSAY \"T50FLOC: POSITION OF \"PROFILE \" IN \" ACID \"IS \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"T50FLOC : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T50FLOC : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51GCMD": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x00\\x01\\x00\\x955/\\x00\\x994O\\x10)\\x00`\\x00`\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1999-12-10T10:29:01", "lines": 96, "newlines": 96, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/*****************************************************************/\n/* added a null line to the output to fix prompt of user         */\n/*****************************************************************/\n/* THIS EXEC WILL CREATE A COMMAND STREAM THAT WILL AFFECT       */\n/* ALL THE ACIDS IN A DEPARTMENT DIVISION OR CONNECTED TO A      */\n/* PROFILE.                                                      */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nARG GROUP DSN1 CMD\nADDRESS ISPEXEC\n\"VGET (ACID DS3 DATA MODE) PROFILE\"\nIF GROUP = \" \" THEN GROUP = ACID\nIF DSN1 = \" \" THEN DSN1  = DS3\nIF CMD = \" \" THEN CMD  = DATA\nSAY \"T50GCMD: CALLING T50JCARD FOR JCL STREAM INITIALIZATION.\"\nADDRESS TSO \"T50JCARD\" DS3\nREPNUM = 0\nLCMD = LENGTH(CMD) - 2\nIF POS(\" $$\",CMD) = LCMD THEN SIGNAL OKTOGO\nIF POS(\" $$ \",CMD) = 0 THEN DO\n  SECRC = \"ERROR: THE STRING ' $$ ' MUST EXIST IN THE COMMAND STRING.\"\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nOKTOGO: NOP\nPARSE VAR CMD W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\nSIGNAL ON ERROR NAME SEEYA\nIF SYSDSN(DSN1) \u00ac= \"OK\" THEN DO\n  SAY \"TSSGCMD: THE OUTPUT DSN YOU HAVE GIVEN ME IS UNAVAILABLE\"\n  EXIT 00\nEND\nDO Z = 1 TO 9\n  IF W.Z = \" $$ \" THEN REPNUM = Z\nEND\nCOUNT_LIM = REPNUM - 1\nDO Z = 1 TO COUNT_LIM\n  IF W.Z = \" $$ \" THEN REPNUM1 = Z\nEND\nQ = OUTTRAP(OUTID.)\nADDRESS TSO\nIF MODE = \"ONLINE\" THEN\n  \"ALLOC DDN(OUT1) DSN(\"DSN1\") REUS MOD\"\nSAY \"T50GCMD: I AM CALLING T50PWHO WITH PARMS:\" GROUP\nSIGNAL OFF ERROR\n\"%T50PWHO\" GROUP\nLIST_CODE = RC\nSIGNAL ON ERROR NAME SEEYA\nsay \"TSA101D: T50GCMD I am back from T50PWHO with return code of \" rc\nsay \"TSA101D: T50GCMD the output of T50PWHO was \"outid.0 \"records.\"\nsay \"TSA101D: T50GCMD I am routing output to \"dsn1\nIF ( OUTID.0 = 0 ) | ( LIST_CODE \\= 0 )  THEN DO\n  msg2 = \"TSA221E: \"\n  msg2 = msg2 \"Failed. stream is incomplete, failure in listing \" group\n  ADDRESS ISPEXEC  \"VPUT MSG2 PROFILE\"\n  queue \"T50222E: I have received no input from T50PWHO\"\n  queue \"         acid may be invalid or authorization may have failed\"\n  ADDRESS ISPEXEC  \"VGET SECRC PROFILE\"\n  QUEUE SECRC\nEND\nDO X = 1 TO OUTID.0\n  PARSE VAR OUTID.X ACID LINE\n  ACID = WORD(OUTID.X,1)\n  if acid = \"TSS0300I\" then iterate x\n  IF ACID = \"ACCESSORID\" THEN ACID= WORD(OUTID.X,3)\n  W.REPNUM = ACID\n  W.REPNUM1 = ACID\n  IF (ACID = \"*\") | (ACID = \"*NONE*\") THEN DO\n    QUEUE LINE\n    ITERATE X\n  END\n  LINE = W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\n  IF LINE \u00ac= \"=\" THEN\n    QUEUE LINE    /* NO BLANK LINES! */\nEND\nQUEUE \" \"\nQUEUE \"@@\"\nqueue\nSIGNAL OFF ERROR\nsecrc = \"TSA223I: group commmand stream placed in dsn \" dsn1\nIF MODE = \"ONLINE\" THEN  DO\n  \"EXECIO * DISKW OUT1 (FINIS)\"\n  \"FREE DDN(OUT1)\"\nEND\nIF MODE = \"BATCH\" THEN DO\n  \"EXECIO * DISKW BJCL (FINIS)\"\n   SECRC = \"COMPLETED. COMMAND STREAM APPENDED TO BATCH FILE \"\nEND\n\"FREE DDN(IN1)\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51GDAT": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x07\\x00\\x97 /\\x01\\x00\\x07_\\x10S\\x00\\x90\\x00\\x90\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-03-15T10:53:07", "lines": 144, "newlines": 144, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T50GDAT                           **/\n/** LAST MODIFIED    : 02 MAY 96                         **/\n/**********************************************************/\n/** ADDED SUPPORT FOR MULTIPLE WORD FIELDS AND THE       **/\n/** SPECIAL REQUIREMENTS OF THE PROFILE FIELD..DR        **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : ANY TSS ACID                               **/\n/** FIELD   : THE TSS FIELD THE CALLER WANTS TO RECEIVE  **/\n/**           BACK                                       **/\n/** DATA    : THE TYPE OF LIST I MUST DO. (NOT REQ)      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** NONE                                                 **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 04 08 16                  **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES (VPUT OF SECRC)             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG ACID FIELD DATA\n/* SAY ACID FIELD DATA */\nHEX00 = '00'X\n/** IF THE FIELD REQUESTED IS ONE THAT NEEDS MULTIPLE    **/\n/** WORDS PASSED BACK TO THE CALLER THEN SET THE MULT.  **/\n/** VARIABLE TO YES BELOW... DIR JAN 97                 **/\nMULT.USED = \"YES\"\nMULT.NAME = \"YES\"\nMULT.PROFILES = \"YES\"\nMULT.BYPASSING = \"YES\"\nMULT.ATTRIBUTES = \"YES\"\n/* SAY \"T50GDAT: HAS CONTROL PARMS \" ACID FIELD DATA */\nGOTIT = \"NO\"\nIF DATA = \" \" THEN DATA = \"BASIC\"\nSIGNAL ON ERROR NAME BADDATA\nQ = OUTTRAP(OUTID.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nSIGNAL ON ERROR NAME SEEYA\nDO X = 1 TO OUTID.0\n  X1 = X+1 ; X2 = X+2 ; X3 = X+3 ; X4 = X+4\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTID.X=TRANSLATE(OUTID.X,\" \",HEX00)\n  PARSE VAR OUTID.X W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12\n  WNUM = WORDS(OUTID.X)\n  DO T = 1 TO WNUM\n    IF WORD(OUTID.X,T) = FIELD THEN DO\n      /* SAY \"T50GDAT: LINE IS \" OUTID.X                 */\n      /*SAY \"T50GDAT: FIELD IS\" FIELD                    */\n      /*SAY \"T50GDAT: GOT IT ON LINE \" X \" WORD \" T      */\n      T1 = T + 1\n      T2 = T + 2\n      T3 = T + 3\n      SECRC = W.T2\n      /* SAY \"T50GDAT: SETTING INITIAL SECRC TO \" SECRC    */\n      IF FIELD = \"DEPT\" THEN SECRC = W.T3\n      IF (FIELD = \"TYPE\") & (W.T3 = \"C/A\") THEN\n        SECRC = SECRC||\"CA\"\n /*   IF FIELD = \"NAME\" THEN */\n /*     SECRC = SECRC  W.T3  */\n      /**************************************************/\n      /** BELOW IS SUPPORT FOR A FIELD THAT HAS MULTIPLE*/\n      /** PARMS, LIKE PROFILES ...DIR 2 MAY 96          */\n      /**************************************************/\n      IF MULT.FIELD = \"YES\" THEN DO\n        IF FIELD = \"PROFILES\" THEN DO\n          /**************************************/\n          /** IF IT IS A PROFILES REQUEST WE   **/\n          /** SCAN AHEAD AND LOAD THE CURRENT  **/\n          /** LINE WITH ALL THE PROFILES IN THE**/\n          /** NEXT 4 LINES, THUS SUPPORTING 5  **/\n          /** FULL LINES OF PROFILES OR 20 OF  **/\n          /** THOSE BUGGARS.   DIR 2 MAY 96    **/\n          /**************************************/\n          /* SAY \"T50GDAT: PROFILE ROUTINE IN CONTROL\"        */\n          NW1 = WORD(OUTID.X1,1)\n          NW2 = WORD(OUTID.X2,1)\n          NW3 = WORD(OUTID.X3,1)\n          NW4 = WORD(OUTID.X4,1)\n          IF NW1 = \"PROFILES\" THEN W.8 = SUBSTR(OUTID.X1,14)\n          IF NW2 = \"PROFILES\" THEN W.9 = SUBSTR(OUTID.X2,14)\n          IF NW3 = \"PROFILES\" THEN W.10 = SUBSTR(OUTID.X3,14)\n          IF NW4 = \"PROFILES\" THEN W.11 = SUBSTR(OUTID.X4,14)\n          /**************************************/\n          /** LETS TELL THE NEXT ROUTINE THERE **/\n          /** ARE MORE WORDS THAN THERE USED TO**/\n          /** BE IN THE CURRENT LINE.DR 2 MAY96*/\n          /**************************************/\n          WNUM = 11\n        END\n        /*SAY \"T50GDAT: MULTIPLE WORD FIELD DETECTED.\"    */\n        /*SAY \"T50GDAT: COUNTING FROM \"T2 \" TO \" WNUM     */\n        ALLDATA = \"\"\n        DO W1 = T2 TO WNUM\n          IF W.W1 = \"=\" THEN LEAVE /* WE HAVE HIT THE NEXT VALUE */\n          ALLDATA = ALLDATA  W.W1\n        END\n        SECRC = ALLDATA\n      END\n      GOTIT = \"YES\"\n    END\n    IF GOTIT = \"YES\" THEN LEAVE\n  END\n  IF GOTIT = \"YES\" THEN LEAVE\nEND\nSIGNAL OFF ERROR\n/*****************************************************************/\n/** NOT FINDING AN INTERVAL MAY BE OK PASS BACK A ZERO.         **/\n/*****************************************************************/\nIF (GOTIT = \"NO\") & (FIELD = \"INTERVAL\") & (DATA \u00ac= \"BASIC\") THEN DO\n  GOTIT = \"YES\"\n  SECRC = 0\nEND\nIF GOTIT = \"YES\" THEN DO\n  /* SAY \"T50GDAT: FIELD \"FIELD\" WAS FOUND. VALUE IS \" SECRC   */\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSECRC = \"$NOTFOUND\"\n/* SAY \"T50GDAT: FIELD \"FIELD\" WAS NOT FOUND. SECRC IS \" SECRC  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nBADDATA: NOP\nSECRC  = \"$BADTSS\"\nSAY \"T50GDAT: ERROR ROUTINE ENTERED, LIST DATA IS\" DATA\nSAY \"T50GDAT: \"ACID FIELD DATA\nIF WORD(OUTID.1,1) = \"TSS0352E\" THEN DO\n  SECRC = \"$BADAUTH\"\n  SAY \"T50GDAT: ID IS NOT OWNED WITHIN SCOPE OF CONTROL\"\nEND\nSAY \"T50GDAT: SECRC IS BEING SET TO \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSEEYA: NOP\nSAY \"T50GDAT: AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51GDEL": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00A\\x00\\x97 /\\x01\\x00\\x07_\\x10S\\x00n\\x00n\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-03-15T10:53:41", "lines": 110, "newlines": 110, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** Creates a batch job that will delete multiple ids    **/\n/** under a department or division, depending on how many**/\n/** times the job is submitted                           **/\n/** submit it once:  Deletes all users and profiles      **/\n/**                  but leaves the departments that     **/\n/**                  had IDs in them.                    **/\n/** submit it twice: Deletes all the newly emptied depts **/\n/** submit it thrice Deletes the dept or division.       **/\n/**********************************************************/\n/** exec name        : T50GDEL                           **/\n/** last modified    : 06 jul 97                         **/\n/**********************************************************/\n/**----------------input required -----------------------**/\n/** passed args        valid values                      **/\n/** acid    : the one to be replaced                     **/\n/** mode    : the mode of operation                      **/\n/** ispf vgets         valid values                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T50GDAT T50pwho      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS ISPEXEC\nIF MODE = \"BATCH\" THEN DO\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nenv = sysvar(sysenv)\nIF MODE \\= \"BATCH\" THEN DO\n  secrc =\"TSA236E: failed. global delete cannot be run in online mode.\"\n  \" VPUT SECRC PROFILE   \"\n  say \"TSA101D: T50GDEL global delete cannot be run in online mode\"\n  EXIT 04\nEND\nSay \"TSA101D: T50GDEL Batch mode detected. using ddname BJCL as output.\"\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS AN ID    , FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO DELETE THOSE IDS            */\n/********************************************************************/\nSTARTOUT: NOP\n/*                                                              */\n/*IF MODE = \"BATCH\" THEN DO                                     */\n/*     ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"        */\n/*END                                                           */\nOUTNUM =  1\n/***********/\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T50PWHO \"ACID \"YES\"\nSAY \"TSA101D: # of lines of output return from TxxPWHO is\" OUT.0\nQ = OUTTRAP(\"XX.\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  SAY strip(INLINE)\n  ID=WORD(INLINE,1)\n  IF WORD(INLINE,1) = \"ACCESSORID\" THEN ID = WORD(INLINE,3)\n  IF ID = TSS0300I THEN LEAVE\n  /************************************************************/\n  /*                                                          */\n  /************************************************************/\n  say \"TSA101D: T50GDEL issuing \" ADDRESS TSO \"%T50GDAT \"ID \" TYPE \"\n  ADDRESS TSO \"%T50GDAT \"ID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  say \"TSA101D: T50GDEL deleting logic for id:\" id \"type:\" type\n  IF MODE = \"ONLINE\" THEN\n    say \"TSA101D: T50GDEL online mode ignored.\"\n    /* ADDRESS TSO \" TSS REMOVE(\"ID\")\" */\n  IF MODE = \"BATCH\" THEN DO\n    IF TYPE = \"PROFILE\" THEN\n      BJCL.OUTNUM = \"ISPSTART CMD(%T50DISC \"ID\")\"\n    IF TYPE = \"PROFILE\" THEN OUTNUM = OUTNUM + 1\n    BJCL.OUTNUM = \"TSS DEL(\"ID\")\"\n    OUTNUM = OUTNUM + 1\n  END\nEND\nOUTSTART: NOP\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nsecrc= \"TSA237I: function completed. output appended to batch file.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nEXIT\n/*************************************/\nCLOSEEM: NOP\nSIGNAL OFF ERROR\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nSAY \"****************************************************\"\nSAY \"LINE IS \"SIGL\nX = SOURCELINE(SIGL)\nSAY X\nSAY  SECRC id type\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51GREP": {"ttr": 3599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x17\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00y\\x00y\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:17", "lines": 121, "newlines": 121, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED ALL LOCATION PROCESSING WITH USE OF AFTER    **/\n/** KEYWORD DIR 2 OCT 97                                 **/\n/**********************************************************/\n/** TO GLOBALLY REPLACE A PROFILE WITH ANOTHER           **/\n/**********************************************************/\n/** EXEC NAME        : T50GREP                           **/\n/** LAST MODIFIED    : 02 OCT 97                         **/\n/**********************************************************/\n/** TOTALLY REWRITTEN TO IMPROVE SPEED BY 1000%          **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** NEWACID : THE ONE TO REPLACE IT WITH                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NOTUSED\nADDRESS ISPEXEC\n\"      VGET DISP PROFILE     \"\n\"      VGET MODE PROFILE     \"\n\"      VGET DS1 PROFILE     \"\n\"      VGET DS2 PROFILE     \"\n\"      VGET DS3 PROFILE     \"\n\"      VGET DS4 PROFILE     \"\n\"      VGET DS5 PROFILE     \"\n\"      VGET DS6 PROFILE     \"\nMYCODE = 0\nTOTAL_RC = 0\nACID = TRANSLATE(ACID,\" \",\".\")\nNEWACIDS = TRANSLATE(NEWACID,\" \",\".\")\nIF INDEX(\" \"NEWACID\" \",\" \"ACID\" \") \\= 0 THEN DO\n  msg2  = \"TSA241W: Warning - cannot replace an ACID with itself.\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE   \"\nEND\nSECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n\"      VPUT SECRC PROFILE   \"\nSIGNAL ON ERROR NAME CLOSEEM\nOUTFILE.0 = 0\nSTARTOUT: NOP\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS3\") \"DISP\" REUS\"\n  ADDRESS TSO \"ALLOC DDN(JCLFILE) DSN(\"DS6\") SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR JCLFILE ( FINIS STEM OUTFILE.)\"\nEND\nOUTNUM = OUTFILE.0 + 1\n/***********/\nQ = OUTTRAP(DROPOUT.)\nSIGNAL OFF ERROR\nDO T1 = 1 TO WORDS(NEWACIDS)\n  LISTACID = WORD(NEWACIDS,T1)\n  ADDRESS TSO \"TSS LIST(\"LISTACID\") DATA(BASIC)\"\n  TOTAL_RC = TOTAL_RC + RC\n  IF TOTAL_RC > 0 THEN BADID = LISTACID\nEND\nIF TOTAL_RC \\=0 THEN DO\n  MSG2 = \"TSA242W: Warning\"\n  msg2 = msg2 badid \" profile was unlistable jcl may not be valid.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T50PWHO \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF SECRC = \"$BADTSS\" THEN DO\n  secrc = \"TSA243E: Aborted.\"\n  secrc = secrc acid\" profile was unlistable. Check validity.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nEND\nSIGNAL ON ERROR NAME CLOSEEM\nQ = OUTTRAP(\"OFF\")\nsay \"TSA101D: Pwho generated \"out.0 \"lines of output .\"\nif out.0 = 0 then do\n  secrc = \"TSA246E: Unable to find attached ACIDs for replace stream\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nend\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  ID = WORD(OUT.X,1)\n  IF ID = \"ACCESSORID\" THEN ID = WORD(OUT.X,3)\n  OUTFILE.OUTNUM =\"TSS ADD(\"ID\") PROFILE(\"NEWACIDS\") AFTER(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\n  OUTFILE.OUTNUM =\"TSS REM(\"ID\") PROFILE(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\nEND\nOUTSTART: NOP\nOUTFILE.OUTNUM = \" \"\nOUTDD = \"OUTFILE\"\nIF MODE = \"BATCH\" THEN OUTDD = \"BJCL\"\nADDRESS MVS \"EXECIO * DISKW \"OUTDD\" ( FINIS STEM OUTFILE.)\"\nSECRC= \"TSA244I: Replace stream generated output in \" DS3\nIF MODE = \"BATCH\" THEN\nsecrc= \"TSA245I: Replace stream appended to batchfile.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\nCLOSEEM: NOP\nSAY \"TSA101D: T50grep error line is \"SIGL\nSAY \"TSA101D: secrc is \"  SECRC\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51ICOMP": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05c\\x00\"\\x00\\x99\\x17/\\x01\\x02\\x12o\\x08T\\x07\\xbf\\x07\\xbf\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.99", "flags": 0, "createdate": "1999-06-21T00:00:00", "modifydate": "2002-05-06T08:54:22", "lines": 1983, "newlines": 1983, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** added convert support for d,g and t,g in volume      **/\n/** rules  dir may 5 2002                                **/\n/**********************************************************/\n/**********************************************************/\n/** changed some doc spelling DIR FEB 22 2002            **/\n/**********************************************************/\n/** Change to modrule routine to totally remove the      **/\n/** scrolling area of that routine... I don't even know  **/\n/** why that section of the routine was there....        **/\n/**                  DIR Novem 05 2001                   **/\n/**********************************************************/\n/**********************************************************/\n/** July 25 2001 - documentation updates                 **/\n/**********************************************************/\n/** Change to debug modify processing to fix errant ptr  **/\n/** Which caused some scrolling to miss records and      **/\n/** caused records selected during modify to be wrongly  **/\n/** grabbed.         DIR april 12 2001                   **/\n/**********************************************************/\n/** Discovered that modify will not support stacked/     **/\n/** owned resources, and that it would be a bear to      **/\n/** fix so I am leaving it alone.                        **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T51ICOMP                          **/\n/** LAST MODIFIED    : 5 Novem     2001                  **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T51JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/**                                                      **/\n/** defgroup = the defgroup OMVS group for invoking the  **/\n/**            %GIVEUID exec.                            **/\n/**                                                      **/\n/** DS1      = work dsn #1 in the SPI system             **/\n/**                                                      **/\n/** DS2      = work dsn #2 in the SPI system             **/\n/**                                                      **/\n/** idebug   = a debug value that can be set to override **/\n/**            debug values in this exec                 **/\n/**                                                      **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/** newpass  = The password value to be used in converts **/\n/**                                                      **/\n/** uidcon   = a value to specify if UIDs are converted  **/\n/**            'as is' or if the %giveuid exec is to be  **/\n/**             used instead.                            **/\n/**            NO =  The GIVEUID exec is issued for a new**/\n/**              UID, unless UID is zero.                **/\n/**            YES = The exact UID will be replicated    **/\n/**              A UID of zero is always be replicated   **/\n/**                                                      **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were passed to me  **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/**********************************************************/\n/** IN the below variables the 'name' area is a variable **/\n/**  which is an actual ACID                             **/\n/**********************************************************/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/** acidrul.name.#.0type    the type                     **/\n/** acidrul.name.#.0segment the segment                  **/\n/** acidrul.name.#.0resname the resource name            **/\n/** acidrul.name.#.0restext the resource text            **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** In the below variable name and type and resource     **/\n/**   are all variables !!                               **/\n/**********************************************************/\n/** acidath.name.type.resource                           **/\n/**                    The actual translated data from   **/\n/**                      the TSS list, with all relevant **/\n/**                      data in this one variable.      **/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** convert.0newid    \"YES\" or \"NO\" depending on if the  **/\n/**                      ACID is changing in the convert **/\n/** convert.0name     The new ACID to replace real one   **/\n/**                      in the ouput stream             **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.convert  = \"YES\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"YES\"\nDEBUG.GETDATA  = \"NO\"\ndebug.fillscr  = \"YES\"\ndebug.modrule  = \"YES\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  /*****************************************************************/\n  /* idebug is a value that can be set in the T$$ execs to turn on */\n  /* a specific debug. U&sually for testing something.             */\n  /*****************************************************************/\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /**         The MAKECUST variable               **/\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command.                       **/\n  /** This would be used if you were moving IDs to**/\n  /** another environment and wanted a certain    **/\n  /** command included in the convert to          **/\n  /** support that environment.                   **/\n  /**                           DIR 25 july 2001  **/\n  /**                                             **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\n  /*************************************************/\n  /** A makeauth command is basically a convert   **/\n  /** with two changes:                           **/\n  /** 1 - The new ID is $$                        **/\n  /** 2 - The tss create command is not done      **/\n  /**                                             **/\n  /*************************************************/\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\nsay \"TSA101D: makeauth check was \" make_rc makeauth\nif make_rc = 0 then do\n  /*************************************************/\n  /** Makeacid is just a type of CLONE really     **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n     /* tells the convert routine to change all outbound ACID */\n  convert.0name = \" $$ \"  /* this is the new ACID name */\n  makeacid.0auth = \"YES\"  /* tell the makeacid routine */\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  /*************************************************/\n  /** a clone is a convert with a new ID plugged  **/\n  /** into the output, so we set some flags and   **/\n  /** then change function to REBUILD.            **/\n  /**                                             **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  /*************************************************/\n  /** We use the makeauth feature to plug in the  **/\n  /** %addlocal command into the output           **/\n  /**                                             **/\n  /*************************************************/\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"ANIDTOTRACE\"              /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Dec 06 2001\"\nsay \"TSA101D: T51ICOMP in control with parms \" function acidlist\nsay \"TSA101D: T51ICOMP Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nsecrc = \"failed in T51ICOMP. no other information available\"\nsecrc = \"failed during jobcard function\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\n  /*****************************************************************/\n  /** A resource function uses an entirely different variable     **/\n  /** loader routine since the input is in a radically different  **/\n  /** format.                                                     **/\n  /**                                                             **/\n  /**                                                             **/\n  /*****************************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    if debug.flow = \"YES\" then\n      say \"TSA101D: calling jobcard function. \"\n    address tso \"%t51jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"TSA101D: Output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 15\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\n/* BYPASS.HOLD.7 = \"* ACID \"  */\n/* commented above due to the need for admin auth to function */\nBYPASS.HOLD.7 = \"* ACIDS\"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9  = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"* TCONS\"\nBYPASS.HOLD.15 = \"* TRBA\"\nBYPASS.HOLD.15 = \"* TUPT\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 10\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"* LASTUSED\"\nBYPASS.HOLD.6  = \"AUTHORITY ACID\"\nBYPASS.HOLD.7  = \"BASE ZONEACID\"\nBYPASS.HOLD.8 = \"* TCONS\"\nBYPASS.HOLD.9 = \"* TRBA\"\nBYPASS.HOLD.10 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\n/*****************************************************************/\n/*****************************************************************/\n/* all variables are initialized.....the main section(s) follow  */\n/*****************************************************************/\n/*****************************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Basic initialization complete, execution begins.\"\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  say \"TSA101D: Resource processing started\"\n  /*****************************************************************/\n  /* Lets either issue the tss list or read in the data from file  */\n  /*****************************************************************/\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  /*****************************************************************/\n  /* I code the two ifs this way because an else when in multiple  */\n  /* loops is confusing...dir ay because an else when this far     */\n  /*****************************************************************/\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"TSA101D: Bypass option specified, allocating input DSN\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      if debug.resource = \"YES\" then\n        say \"Owner = \" acidnum \"name = \" owner\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      /* lets grab the acid */\n      parse var line drop 'ACID(' name ')' drop2\n    /*****************************************************************/\n    /* In resources the ACID with the auth is way to the right on    */\n    /*  the report so we note each of them for future reference      */\n    /*  Note the .name portion of the below variable insures that    */\n    /*  even if one ACID has authorites in multiple areas of the     */\n    /*  output, it is counted only once. The classic variable named  */\n    /*  variable....                                                 */\n    /*****************************************************************/\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\"\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      if debug.resource = \"YES\" then\n        say \"acidnum = \" acidnum \"name = \" name\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"TSA101D: Total acids referenced in input is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"TSA101D: Bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"TSA101D: Total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  acids.0 = words\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    say \"TSA101D: Listing ACID \"hold\" with data \"data \".\"\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we create  the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Evaluation of TSS generated data begins.\"\nevaluate: nop  /* a branch to point for a resource convert */\n/*************************************************/\n/*************************************************/\n/** The below routine does the exact same thing **/\n/** for both resource and standard output, since**/\n/** the variable structure created above is the **/\n/** same for either.                            **/\n/*************************************************/\n/*************************************************/\ndo num = 1 to acidnum\n  /***********************************************/\n  /**This outer lop is once for each acid passed**/\n  /** to me. Dave 18 June 99                    **/\n  /***********************************************/\n  rules = 0\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"TSA101D: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"         Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    acidrul.name.a1.0concat  = \"NO\"\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if debug.trans = \"YES\" then say line\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    end\n    first11 = substr(line,1,11)\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if debug.trans = \"YES\" then\n        say \"TSA101D:  Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      if debug.trans = \"YES\" then\n       say \"TSA101D: lcf detected:\" w.2\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area input line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n      w.1 = w.1\".\"savefac\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area reformated line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) tzq1\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T51ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n      /*say \"       \"acidath.name.type.resource  */\n      acidrul.name.rules.0concat  = \"YES\"\n /*   say \"Setting concat to yes for record \" rules  */\n      hold1 = acidrul.name.rules.0concat\n      hold = restext(rules)\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: Concat rule \",\n        \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.rules = segment type resource duplicat\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource\n    acidrul.name.rules.0segment = segment\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidrul.name.rules.0restext = \" \"\n    do t1 = 3 to words\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) strip(w.t1)\n    end\n    if debug.trans = \"YES\" then do\n      say \" TSA101D: Type/Rname/Text =\" acidrul.name.rules.0type\"/\",\n      acidrul.name.rules.0resname\"/\",\n      acidrul.name.rules.0restext\n    end\n  end\n  acidrul.name.0 = rules\nend\nif debug.flow = \"YES\" then\n  say \"TSA101D: Translation streams have been built.\",\n  \"Starting function check.\"\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter                                     */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Permit/rebuild/revoke area in control.\"\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do x = 1 to acidnum\n    name = acids.x\n    say \"TSA101D: Starting to process ACID:\" x \">\"name\"<\"\n    say \"          Rules#:\" acidrul.name.0\n    do t = 1 to acidrul.name.0\n      if debug.flow = \"YES\" then\n        say \"TSA101D: Starting to process \"name \" Rule #\" t\n      if debug.name.t = \"TRACE\" then trace r\n      call getdata t\n      hold = next\n      record_number = t\n      call convert function hold\n      trace off\n    end\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = acidrul.name.0\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"TSA101D:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: S found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: D found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n        acidrul.name.y = segment type resource\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: M found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        say \"TSA101D: t=\" t \"thisrec=\" thisrec\n        say \"TSA101D: Subscript is now:\" y\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          say \"TSA101D:\"\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs\n          setf = setflag(y,'*MODIFY')\n          acidrul.name.y.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidrul.name.y.0resname  = rsname\n          acidrul.name.y.0restext  = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: A found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T51ICOMP:addition routine entered outnum=\" outnum\n        say \"T51ICOMP:addition routine entered target=\" target\n        say \"T51ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T51ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: Calling modrule\"\n        end\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setflag(fill,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        acidrul.name.fill.0segment  = segment\n        acidrul.name.fill.0resname  = rsname\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"TSA101D: leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then\n  say \"acidrul.name array || multiline ? || segment || data \"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nif debug.makeacid = \"YES\" then\n  say \"TSA101D: Making ACID:\" function\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    if debug.makeacid = \"YES\" then\n      say \"TSA101D: Owner resolved to:\" own_str\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  if debug.makeacid = \"YES\" then\n    say \"TSA101D: Makeacid type for \"name\" is :\" acid_type\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif debug.makeacid = \"YES\" then\nsay \"TSA101D: leaving makeacid # output = \"create_num create.1 create.2\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  acidrul. cvtnum concat lcffac debug. convert. record_number\nparse arg function segment inline\nsay \"TSA101D: convert called with \" function segment inline\noname = name\nconcat = acidrul.name.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nif debug.flow = \"YES\" then\n  say \"TSA101D: output name for convert is \" oname \"concat is\" concat\nif debug.flow = \"YES\" then\n  say \"TSA101D: Converting for \"name\":\"function segment \">\"||inline||\"<\"\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XAVOLUME\") then do\n  /*********************************************************/\n  /* a volume generic of (d,g) or (t,g) is invalid so we   */\n  /* handle it here.                                       */\n  /*********************************************************/\n  where_gen = index(inline,\",G)\")\n  if where_gen /= 0 then do\n    if debug.convert = \"YES\" then\n      say \"TSA101D: Vol generic, Input dsn line \"inline\n     parse var inline hz1  ',' hz2\n    inline = hz1||hz2\n    if debug.convert = \"YES\" then\n      say \"TSA101D: Reformatted vol generic line \"inline\n  end\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Input dsn line \"inline\n  inline = \"XADSN\"||substr(inline,10)\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatted dsn line \"inline\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" %giveuid \" oname defgroup\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\n  IF W.1 = \"SCOPEACID\" THEN W.1 = \"SCOPE\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MAS\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif acidrul.name.record_number.0concat = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = acidrul.name.record_number.0concat\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"TSA101D: XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nif debug.convert = \"YES\" then\n  say \"TSA101D: Resource is \"resource \"concat is\" concat\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  if debug.convert = \"YES\" then do\n    rule = bypass.function.rulehold\n    say \"TSA101D: bypass rule tripped, Rule is below:\"\n    say \"     \" Rule\n  end\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then\n  say \"TSA101D:***** CONVERT OUTPUT IS NOW :\" output\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T51ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. acidath. name hex00 aciddup. debug. balance. function balout\nOPT = \" \"\nif debug.fillscr = \"YES\" then\n  say \"TSA101D: Fillscr invoked. Thisrec=\" thisrec\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T51ICOMP: TOP OF DATA REACHED\"\nEND\nh1 = acidrul.name.0 - 13\ntempz1 = acidrul.name.0\n/* save this value for the display below*/\nif debug.fillscr = \"YES\" then\n    say \"TSA101D: h1=\" h1 \"acidrul.\"name\".0=\"  tempz1\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 13\n  MSG = \"T51ICOMP: BOTTOM OF DATA REACHED\"\n  if debug.fillscr = \"YES\" then\n    say \"TSA101D: Bottom of data thisrec set to :\"thisrec\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T51ICOMP: TOP OF DATA REACHED\"\nEND\nif debug.fillscr = \"YES\" then do\n  say \"FILLSCR: thisrec=\" thisrec\n  say \"TSA101D: filling screen:\",\n    \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\nend\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  maxdata = acidrul.name.0\n  if debug.fillscr = \"YES\" then do\n    say \"TSA101D: fillscr calling subfunctions with subscript:\" script\n    say \"         maxdata is:\" maxdata\n  end\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if debug.fillscr = \"YES\" then do\n    say \"TSA101D: fillscr segment=\"segment\n    say \"   type=\"type \"resource=\"resource \"fchk=\"fchk\n  end\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  respass = acidath.name.type.resource\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose acidath. name acidrul. aciddup. next\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. aciddup. next acidlst.\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug. record_number\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsegment  = strip(acidrul.name.t.0segment)\ntype     = strip(acidrul.name.t.0type)\nresource = strip(acidrul.name.t.0resname)\ntheres   = strip(acidrul.name.t.0restext)\ndupchk   = \"\"\ndupnum   = \"\"\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t.0resname\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetdatao: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsay \"new getdata results:\"\nsay acidrul.name.t.0segment\nsay acidrul.name.t.0type\nsay acidrul.name.t.0resname\nsay acidrul.name.t.0restext\nsay \"*******\"\nsegment  = strip(word(acidrul.name.t,1))\ntype     = strip(word(acidrul.name.t,2))\nresource = strip(word(acidrul.name.t,3))\ndupchk   = strip(word(acidrul.name.t,4))\ndupnum   = strip(word(acidrul.name.t,5))\ntheres = acidath.name.type.resource\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = strip(word(acidrul.name.t,1))\ngetdata.0type     = strip(word(acidrul.name.t,2))\ngetdata.0resource = strip(word(acidrul.name.t,3))\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult  = acidrul.name.tempin.0segment\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult  = acidrul.name.tempin.0type\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult  = acidrul.name.tempin.0resname\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult  = acidrul.name.tempin.0restext\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = acidrul.name.tempin.0flag\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult  = acidrul.name.tempin.0resname\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. acidath. name acidrul. conlist modrule. rstype debug.,\n fill_override balance.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\n/*\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"T51ICOMP: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\nif (thisrec > h1 )  then do\n  thisrec = h1\n  msg = \"T51ICOMP: bottom of data reached\"\nend\n*/\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51ICSAV": {"ttr": 4100, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00%\\x01\\x00\\tO\\x01\\x00\\tO\\x13\\x05\\x07\\xa8\\x07\\xa8\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-04-03T00:00:00", "modifydate": "2000-04-03T13:05:25", "lines": 1960, "newlines": 1960, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T50ICOMP                          **/\n/** LAST MODIFIED    :  6 December  1999                 **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Compare:                                           **/\n/**     This function compare the permission of each ID  **/\n/**     in the acidlist to the first ID specified in the **/\n/**     list.                                            **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Listdup:                                           **/\n/**     List the duplicate permissions in the acids      **/\n/**     specified.                                       **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/** ACIDLIST:  The list of acids to compare              **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T50JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were pased to me   **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/** aciddup.name.0     How many lines of output for below**/\n/** aciddup.name.#     One line for each duplicate       **/\n/**                      keyset that the ID has          **/\n/**                      The type and resource name      **/\n/**                                                      **/\n/** aciddup.name.type.resource.0 = how many dups there   **/\n/**                   for this key set ( there may be    **/\n/**                   seven SYS1. DATASET rules)         **/\n/**                                                      **/\n/** aciddup.name.type.resource.# = The duplicates        **/\n/**                                                      **/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/**                      the acid in name has.           **/\n/**                      segment                         **/\n/**                      restype                         **/\n/**                      resource                        **/\n/**     optional ===>    DUPLICATE                       **/\n/**     optional ===>    subscript                       **/\n/**                                                      **/\n/**     if the literal DUPLICATE appears the data for this*/\n/**      line musts be retrieved from the variable:      **/\n/**        aciddup.name.type.resource.subscript          **/\n/**                                                      **/\n/**     otherwise the data can be retireved from the     **/\n/**      below variable                                  **/\n/**                                                      **/\n/** acidath.name.type.resource                           **/\n/**                    The actual translated data from   **/\n/**                      the TSS list, with all relevant **/\n/**                      data in this one variable.      **/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.convert  = \"NO\"\ndebug.makeacid = \"NO\"\ndebug.balance  = \"NO\"\ndebug.modify   = \"NO\"\ndebug.getdata  = \"NO\"\ndebug.fillscr  = \"YES\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command. DIR                   **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\nsay \"TSA101D: makeauth check was \" make_rc makeauth\nif make_rc = 0 then do\n  convert.0newid = \"YES\"\n  convert.0name = \" $$ \"\n  makeacid.0auth = \"YES\"\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"ANIDTOTRACE\"              /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Dec 06 1999\"\nsay \"TSA101D: T50ICOMP in control with parms \" function acidlist\nsay \"TSA101D: T50ICOMP Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50ICOMP. NO OTHER INFORMATION AVAILABLE\"\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\nif debug.flow = \"YES\" then\n  say \"TSA101D: Retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    if debug.flow = \"YES\" then\n      say \"TSA101D: calling jobcard function. \"\n    address tso \"%t50jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"TSA101D: Output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nacidath.   =  hex00\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 15\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\nBYPASS.HOLD.7 = \"* ACIDS \"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9 = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.11 = \"* PASSWORD\"\nBYPASS.HOLD.12 = \"AUTHORITY ACID\"\nBYPASS.HOLD.13 = \"* TCONS\"\nBYPASS.HOLD.14 = \"* TRBA\"\nBYPASS.HOLD.15 = \"* TUPT\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 10\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"* LASTUSED\"\nBYPASS.HOLD.6  = \"AUTHORITY ACID\"\nBYPASS.HOLD.7  = \"BASE ZONEACID\"\nBYPASS.HOLD.8 = \"* TCONS\"\nBYPASS.HOLD.9 = \"* TRBA\"\nBYPASS.HOLD.10 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\nif debug.flow = \"YES\" then\n  say \"TSA101D: Basic initialization complete, execution begins.\"\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  say \"TSA101D: Resource processing started\"\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"TSA101D: Bypass option specified, allocating input DSN\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      if debug.resource = \"YES\" then\n        say \"Owner = \" acidnum \"name = \" owner\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      parse var line drop 'ACID(' name ')' drop2\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\"\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      if debug.resource = \"YES\" then\n        say \"acidnum = \" acidnum \"name = \" name\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"TSA101D: Total acids referenced in input is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then   signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"TSA101D: Bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"TSA101D: Total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  acids.0 = words\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we creat   the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Evaluation of TSS generated data begins.\"\nevaluate: nop\ndo num = 1 to acidnum\n  /***********************************************/\n  /**This outer lop is once for each acid passed**/\n  /** to me. Dave 18 June 99                    **/\n  /***********************************************/\n  rules = 0\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"TSA101D: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"         Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    end\n    first11 = substr(line,1,11)\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if debug.trans = \"YES\" then\n        say \"TSA101D:  Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      if debug.trans = \"YES\" then\n       say \"TSA101D: lcf detected:\" w.2\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area input line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n      w.1 = w.1\".\"savefac\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area reformated line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if repeat = \"YES\" then do\n      /***************************************/\n      /** Note the duplicates for each ID   **/\n      /***************************************/\n      hold = acidath.name.prev_type.prev_resource\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: In duplicate loop\",\n          concat prev_type prev_resource hold\n        if debug.trans = \"YES\" then\n          say \"TSA101D: Mult key \"name \"==>\",\n            prev_type prev_resource hold\n      end\n      hold1 = aciddup.name.0\n      hold2 = hold1 + 1\n      aciddup.name.0 = hold2\n      aciddup.name.hold2 = prev_type prev_resource\n      if aciddup.name.hold1 = aciddup.name.hold2 then\n        aciddup.name.0 = hold1\n      zz1 = aciddup.name.0\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: New total for dup array:\" name  aciddup.name.0\n        say \"         array key is:\" aciddup.name.zz1\n      end\n      tz0  = aciddup.name.prev_type.prev_resource.0\n      tz1  = tz0 + 1\n      aciddup.name.prev_type.prev_resource.0  = tz1\n      aciddup.name.prev_type.prev_resource.tz1 = hold\n      duplicat = \"DUPLICATE \"tz1\n      if debug.trans = \"YES\" then  do\n        say \"TSA101D: Mult keys\" prev_type prev_resource \" is now \" tz1\n        say \"         \" name prev_type prev_resource hold duplicat\n      end\n/*                                                                   */\n/*    if aciddup.name.prev_type.prev_resource.tz0 = hold then do     */\n/*      say \"Full duplicate rule found dropping data:\"               */\n/*      say \"  \" prev_type prev_resource hold                        */\n/*      aciddup.name.prev_type.prev_resource.0  = tz0                */\n/*      duplicat = \" \"                                               */\n/*      rules = rules -1                                             */\n/*    end                                                            */\n      acidath.name.type.resource = \"\"\n      /* kill the previous one and prepare to load this one */\n    end\n    if concat = \"YES\" then do\n      hold = acidath.name.type.resource\n      acidath.name.type.resource = strip(hold) strip(line)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T50ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n      /*say \"       \"acidath.name.type.resource  */\n      acidath.name.type.resource.0concat  = \"YES\"\n      hold1 = acidath.name.type.resource.0concat\n      hold = acidath.name.type.resource\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: Concat rule \",\n        \"n=\"name \"t=\"type \"r=\"resource hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.rules = segment type resource duplicat\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidath.name.type.resource = \" \"\n    do t1 = 3 to words\n      hold = acidath.name.type.resource\n      acidath.name.type.resource = strip(hold) strip(w.t1)\n    end\n    if debug.trans = \"YES\" then\n      say \"  Type/res=\" type resource acidath.name.type.resource\n  end\n  acidrul.name.0 = rules\nend\nif debug.flow = \"YES\" then\n  say \"TSA101D: Translation streams have been built.\",\n  \"Starting function check.\"\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter                                     */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif function = \"LISTDUP\" then  do\n  dupnum = 0\n  do x = 1 to acidnum\n    name = acids.x\n    /* say acidnum name  */\n    say \"TSA103I: \"name \"duplicate keysets\" aciddup.name.0\n    do t = 1 to aciddup.name.0\n      type     = strip(word(aciddup.name.t,1))\n      resource = strip(word(aciddup.name.t,2))\n      tz2 = aciddup.name.type.resource.0\n      prime = acidath.name.type.resource\n      prime = deblank(prime)\n      say \" \"\n      say \"TSA103I:\"\n      say \" LISTDUP:\"name \"keyset=\" type resource\n      say \" LISTDUP: primary:\" prime\n      dupnum = dupnum + 1\n      listdup.dupnum = \" \"\n      dupnum = dupnum + 1\n      listdup.dupnum = \" LISTDUP:\"name \"keyset=\" type resource\n      dupnum = dupnum + 1\n      listdup.dupnum = \"          primary:\" prime\n      if prime = \" \" then listdup.dupnum = \" \"\n      do cnt = 1 to tz2\n        hold = strip(aciddup.name.type.resource.cnt)\n        hold = deblank(hold)\n        dupnum = dupnum + 1\n        listdup.dupnum = \"    ACID=\" name type resource hold\n        say listdup.dupnum\n        secrc = \"List duplicates complete.\"\n      end\n      if screen /= \"YES\" then do\n        address tso \"alloc ddn(outds2) dsn(\"ds2\") shr reus\"\n        \"EXECIO \"dupnum\" DISKW outds2 (FINIS STEM listdup.)\"\n        address tso \"free ddn(outds2)\"\n        secrc = \"TSA109I: Complete. Output stream written to \" ds2\n      end\n    end\n    /* call snapshot */\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Permit/rebuild/revoke area in control.\"\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do x = 1 to acidnum\n    name = acids.x\n    say \"TSA101D: Starting to process ACID:\" x \">\"name\"<\"\n    say \"          Rules#:\" acidrul.name.0\n    do t = 1 to acidrul.name.0\n      if debug.flow = \"YES\" then\n        say \"TSA101D: Starting to process \"name \" Rule #\" t\n      if debug.name.t = \"TRACE\" then trace r\n      call getdata t\n      hold = next\n      call convert function hold\n      trace off\n    end\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = acidrul.name.0\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"TSA101D:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: S found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: D found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = strip(word(acidrul.name.y,1))\n        type     = strip(word(acidrul.name.y,2))\n        resource = strip(word(acidrul.name.y,3))\n        acidath.name.type.resource.0flag = \"*DELETE\"\n        acidrul.name.y = segment type resource\n        hold = segment type resource acidath.name.type.resource\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: M found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        if seccode = \"OK\" then do\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          hold = segment type resource acidath.name.type.resource\n          say \"TSA101D:\"\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          /* say  \"back from modify  rsname is \"rsname */\n          acidath.name.type.rsname.0flag  = \"*MODIFY\"\n          acidath.name.type.rsname.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidath.name.type.rsname = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: A found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n     /*                                                          */\n     /* say \"t50icomp:addition routine entered outnum=\" outnum   */\n     /* say \"t50icomp:addition routine entered target=\" target   */\n     /* say \"t50icomp:addition routine entered thisrec=\" thisrec */\n     /* say \"t50icomp:addition routine entered fill=\" fill       */\n        do q = outnum to target by -1\n          q1 = q - 1\n          acidrul.name.q = acidrul.name.q1\n        end\n        modrule.0panel = \"SECUPDT\"\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: Calling modrule\"\n        end\n        call modrule\n        acidath.name.type.rsname.0concat = \"YES\"\n        acidath.name.type.rsname.0flag = \"*NEWRULE\"\n        acidrul.name.fill = segment type rsname\n        acidath.name.type.rsname = modrule.newrs\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"T50101D: leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\nif function = \"BALANCE\" then do\n  call off error\n  name1 = acids.1\n  name2 = acids.2\n  /*********************************/\n  /** below we create a backward  **/\n  /** pointer to the full record  **/\n  /** based  on restype/name      **/\n  /*********************************/\n  do u = 1 to 2\n    daname = acids.u\n    do v = 1 to acidrul.daname.0\n      name = daname\n      call getdata v\n      gtype = getdata.0type\n      gseg  = getdata.0segment\n      gres  = getdata.0resource\n      acidath.daname.gtype.gres.0recnum = v\n    end\n  end\n  balout = 0\n  do b1 = 1 to acidrul.name1.0\n    name = name1\n    bname = name1\n    call getdata b1\n    balout = balout + 1\n    balance.balout = bname b1\n    call getdata b1\n    getdata.debug = \"YES\"\n    gtype = getdata.0type\n    gseg  = getdata.0segment\n    gres  = getdata.0resource\n /* if debug.balance = \"YES\" then\n      say \"TSA101D: comparing \" gtype gres,\n      acidath.name1.gtype.gres  acidath.name2.gtype.gres  */\n    if acidath.name1.gtype.gres = acidath.name2.gtype.gres then do\n  /* say \"SAME\" acidath.name1.gtype.gres   acidath.name2.gtype.gres*/\n      res_value = acidath.name2.gtype.gres\n      balance.name2.gtype.gres.res_value = \"$GOTIT\"\n      bname = \"$BOTH$\"\n      balance.balout = bname b1\n      /* say acidath.name2.gtype.gres.0recnum */\n      balance.balout = balance.balout acidath.name2.gtype.gres.0recnum\n      /* lets not display this one again */\n      if debug.balance = \"YES\" then\n        say \"TSA101D: Values are equal\" balance.balout\n    end\n    if symbol(acidath.name2.gtype.gres) = \"VAR\" then do\n      if debug.balance = \"YES\" then\n        say \"TSA101D: Same rule diff access level found.\" balance.balout\n      balout = balout + 1\n      balance.name2.gtype.gres.res_value = \"$GOTIT\"\n      balance.balout = name2 acidath.name2.gtype.gres.0recnum\n    end\n  end\n  do b2 = 1 to acidrul.name2.0\n    name = name2\n    call getdata b2\n    gtype = getdata.0type\n    gseg  = getdata.0segment\n    gres  = getdata.0resource\n    res_value = acidath.name2.gtype.gres\n    if balance.name2.gtype.gres.res_value = \"$GOTIT\" then iterate b2\n    balout = balout + 1\n    balance.balout = name2 b2\n    /* say \"setting balance to \" balance.balout */\n  end\n  balance.0 = balout\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = balance.0\n  top = 1\n  bot = 2\n  do until bot =  outnum\n    sort.top = word(balance.top,2)\n    sort.bot = word(balance.bot,2)\n    if sort.top > sort.bot then do\n      hold = balance.top\n      balance.top = balance.bot\n      balance.bot = hold\n      top = 0\n      bot = 1\n    end\n    top = top + 1\n    bot = bot + 1\n  end\n  if debug.balance = \"YES\" then do x2 = 1 to balout\n    say \"TSA101D: balance.\"x2 balance.x2\n  end\n  panel_code = 0\n  say \"TSA101D:  balance starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIBLNC)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      balnum = t + thisrec - 1\n      fill_override = word(balance.balnum,2) /* the new fill routine */\n      name = a.t                           /* The acid involved */\n      if f.t  = 'S' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        if name = \"$BOTH$\" then name = acids.1\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = fill_override\n        if name = \"$BOTH$\" then do\n          say \"TSA101D: In duplicate name processing.\"\n          name = acids.1\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          acidath.name.type.resource.0flag = \"*DELETE\"\n          acidrul.name.y = segment type resource\n          hold = segment type resource acidath.name.type.resource\n          call convert \"REVOKE\" hold\n          name = acids.2\n          y = word(balance.balnum,3)\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          acidath.name.type.resource.0flag = \"*DELETE\"\n          acidrul.name.y = segment type resource\n          hold = segment type resource acidath.name.type.resource\n          call convert \"REVOKE\" hold\n        end\n      end\n      if f.t  = 'C' then do\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = fill_override\n        if name = \"$BOTH$\" then do\n          say \"TSA101D: In duplicate name processing.\"\n          name = acids.1\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          acidath.name.type.resource.0flag = \"*DELETE\"\n          acidrul.name.y = segment type resource\n          hold = segment type resource acidath.name.type.resource\n          call convert \"PERMIT\" hold\n          y = word(balance.balnum,3)\n        end\n        segment  = strip(word(acidrul.name.y,1))\n        type     = strip(word(acidrul.name.y,2))\n        resource = strip(word(acidrul.name.y,3))\n        acidath.name.type.resource.0flag = \"*COPIED\"\n        acidrul.name.y = segment type resource\n        hold = segment type resource acidath.name.type.resource\n        Select\n          when name = acids.1 then  name= acids.2\n          when name = acids.2 then  name= acids.1\n          otherwise nop\n        End\n        call convert \"PERMIT\" hold\n      end\n      if f.t  = 'M' then do\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y = fill_override\n        if seccode = \"OK\" then do\n          segment  = strip(word(acidrul.name.y,1))\n          type     = strip(word(acidrul.name.y,2))\n          resource = strip(word(acidrul.name.y,3))\n          hold = segment type resource acidath.name.type.resource\n          say \"TSA101D:\"\n          say \"TSA101D:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from balance we use new RSNAME  now */\n          /* say  \"back from balance rsname is \"rsname */\n          acidath.name.type.rsname.0flag  = \"*balance\"\n          acidath.name.type.rsname.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidath.name.type.rsname = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n    end\n  end\n  say \"T50101D: leaving balance\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    call getdata t\n    say next\n  end\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"COMPARE\" then do\n  name = acids.1    /* compare all Ids to the first one */\n  cmpnum = cmpnum + 1\n  compare.cmpnum = \" Comparison of ACIDs \" acidlist\n  cmpnum = cmpnum + 1\n  compare.cmpnum = \"               \"\n  call snapshot\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    resource = word(acidrul.name.t,3)\n    hold = acidath.name.type.resource\n    do cnt = 2 to acidnum\n      otherid = acids.cnt\n      /******************/\n      /*take a snap     */\n      snaphold = name\n      name = otherid\n      call snapshot\n      name = snaphold\n      /******************/\n      hold1 = acidath.otherid.type.resource\n      if hold = hold1 then iterate cnt\n      say \"hold =\" name type resource\n      say \"      \" hold\n      if hold1 = hex00 then hold1 = \"**No rule **\"\n      say \"hold1=\" otherid type resource\n      say \"      \" hold1\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"***********************\"\n      compare.cmpnum = \"** Differences found **\" type resource\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \" \"name  \" ACID data ====>\" hold\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \" \"otherid \" ACID data ====>\" hold1\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"***********************\"\n      cmpnum = cmpnum + 1\n      compare.cmpnum =  \"  \"\n    end\n  end\n  if screen /= \"YES\" then do\n    \"EXECIO \"cmpnum\" DISKW outds2 (FINIS STEM compare.)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n  end\n  if screen = \"YES\" then do h1 = 1 to cmpnum\n    say compare.cmpnum\n  end\n  address ispexec \"vput secrc profile\"\n  exit 0\nend\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid.\nparse arg function\nif function /= \"REBUILD\" then return\nif debug.makeacid = \"YES\" then\n  say \"TSA101D: Making ACID:\" function\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    if debug.makeacid = \"YES\" then\n      say \"TSA101D: Owner resolved to:\" own_str\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  CREATE.CREATE_NUM = \" TSS CRE(\"NAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  if debug.makeacid = \"YES\" then\n    say \"TSA101D: Makeacid type for \"name\" is :\" acid_type\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    create.create_num = q1||name||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif debug.makeacid = \"YES\" then\nsay \"TSA101D: leaving makeacid # output = \"create_num create.1 create.2\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00,\n  acidath. cvtnum concat lcffac debug. convert.\nparse arg function segment inline\noname = name\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nif debug.flow = \"YES\" then\n  say \"TSA101D: output name for convert is \" oname\nif debug.flow = \"YES\" then\n  say \"TSA101D: Converting for \"name\":\"function segment \">\"||inline||\"<\"\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"XADATASET\") then do\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Input dsn line \"inline\n  inline = \"XADSN\"||substr(inline,10)\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatted dsn line \"inline\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"UID\") then do\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MAS\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"name\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,30)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\nif acidath.name.tchk.resource.0concat = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = acidath.name.type.resource.0concat\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"TSA101D: XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nif debug.convert = \"YES\" then\n  say \"TSA101D: Resource is \"resource \"concat is\" concat\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  if debug.convert = \"YES\" then do\n    rule = bypass.function.rulehold\n    say \"TSA101D: bypass rule tripped, Rule is below:\"\n    say \"     \" Rule\n  end\n  return\nend\noutput = \" TSS \"cmd\"(\"oname\")\"\nif (function = \"REVOKE\") & (cmd = \"REM\") then do\n  output = output w.1\"(\"w.2\")\"\nend\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nif (type = \"FACILITY\") then do\n  output = multi\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then\n  say \"TSA101D:***** CONVERT OUTPUT IS NOW :\" output\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T50ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\nseeya: nop\nif sysenv = \"FORE\" then do\n  secrc = \"error in line \"sigl\n  address ispexec \"vput secrc profile\"\nend\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. acidath. name hex00 aciddup. debug. balance. function balout\nOPT = \" \"\nif debug.fillscr = \"YES\" then\nsay \"FILLSCR: thisrec=\" thisrec\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nif function = \"BALANCE\" then\n  h1 = balance.0 - 14\nelse\n  h1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1 - 14) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nsay \"FILLSCR: thisrec=\" thisrec\nsay \"TSA101D: filling screen:\",\n  \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  if function = \"BALANCE\" then do\n    script = word(balance.fill,2)\n    ID   = word(balance.fill,1)\n    name = ID\n    if ID = \"$BOTH$\" then name = acids.1\n    a.cnt = id\n    interpret \"a\"||cnt \" =\" a.cnt\n    SAY \"fillscr: BALANCE line \"cnt \" acid=\" name \"data# = \"script\n    SAY \"fillscr: a.\"cnt \"=\" a.cnt \"thisrec=\" thisrec \"fill=\" fill\n  end\n  /* dont need segment here for doc                   */\n  segment       = strip(word(acidrul.name.script,1))\n  type.fill     = strip(word(acidrul.name.script,2))\n  type     = type.fill\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = strip(word(acidrul.name.script,3))\n  dup_check     = strip(word(acidrul.name.script,4))\n  dup_num       = strip(word(acidrul.name.script,5))\n  resource = resource.fill\n  if acidath.name.type.resource.0flag /= hex00 then do\n    type.fill = acidath.name.type.resource.0flag\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  respass = acidath.name.type.resource\n  if dup_check = \"DUPLICATE\" then\n    respass = aciddup.name.type.resource.dup_num\n  hold = segment type resource respass\n  parse var hold h1 'ACCESS ' access dropoff\n  access.fill = access\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose acidath. name acidrul. aciddup. next\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. aciddup. next acidlst.\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsegment  = strip(word(acidrul.name.t,1))\ntype     = strip(word(acidrul.name.t,2))\nresource = strip(word(acidrul.name.t,3))\ndupchk   = strip(word(acidrul.name.t,4))\ndupnum   = strip(word(acidrul.name.t,5))\ntheres = acidath.name.type.resource\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = strip(word(acidrul.name.t,1))\ngetdata.0type     = strip(word(acidrul.name.t,2))\ngetdata.0resource = strip(word(acidrul.name.t,3))\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. acidath. name acidrul. conlist modrule. rstype debug.,\n fill_override balance.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"t50pmenu: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\nif (thisrec > h1 )  then do\n  thisrec = h1\n  msg = \"t50pmenu: bottom of data reached\"\nend\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment       = strip(word(acidrul.name.fill,1))\ntype          = strip(word(acidrul.name.fill,2))\nresource      = strip(word(acidrul.name.fill,3))\nrsname        = strip(word(acidrul.name.fill,3))\nmodrule.newrs = \"\"\nhold = acidath.name.type.resource\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51INS": {"ttr": 3842, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00B\\x00\\x955/\\x00\\x994?\\x14\\x17\\x00\\xcf\\x00\\xcf\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1999-12-09T14:17:42", "lines": 207, "newlines": 207, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T50INS                            **/\n/** LAST MODIFIED    :  9 dec 99                         **/\n/**********************************************************/\n/** NOW ACCEPTS MULTIPLE PROFS IN STD INVOCATION         **/\n/**********************************************************/\n/** CHANGED CODE TO FIX ERROR FOR INSERTS AT POSITION    **/\n/** GREATER THAN 1 WHEN ID HAS NO PROFILES    ....DR     **/\n/**********************************************************/\n/** REVAMPED TO USE THE AFTER KEYWORD OF INSERT COMMAND  **/\n/** SHOULD BE LOTS FASTER AND EASIER TO MANAGE....DR     **/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         EXITPRM                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T50FDIV %T50GDAT    **/\n/**********************************************************/\nARG ACID PROFILE TARGET DAYS\n/************************************************************/\n/** PATCH BELOW FOR NORMAL INVOCATION FOR MULTIPLE PROFILES */\n/************************************************************/\nif target = \" \" then target = 1\nTEMP = PROFILE TARGET DAYS\nPROFS = 0\nPARSE VAR TEMP TW.1 TW.2 TW.3 TW.4 TW.5 TW.6 TW.7 TW.8 TW.9 TW.10\nALLWORDS = WORDS(TEMP)\nIF (ALLWORDS = 3) & ( DATATYPE(TW.2) = \"CHAR\" ) THEN do\n  PROFILE = TW.1||\".\"||TW.2\n  TARGET = DAYS\n  DAYS = \"\"\n  say \"TSA101D: T50INS reformatted input is :\" acid profile target days\nEND\nIF ALLWORDS > 3 THEN DO\n  DO COUNT = 1 TO ALLWORDS\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN PROFS = COUNT - 1\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN LEAVE\n  END\n  PROFILE = \"\"\n  DO CNT2 = 1 TO PROFS\n    PROFILE = PROFILE||\".\"||TW.CNT2\n  END\n  TARGET_WORD = PROFS + 1\n  DAYS_WORD = PROFS + 2\n  TARGET = WORD(TEMP,TARGET_WORD)\n  DAYS   = WORD(TEMP,DAYS_WORD)\n  say \"TSA101D: T50INS reformatted input is :\" acid profile target days\nEND\n/*****/\nACT = \"AFTER\"\nADDRESS ISPEXEC\nPROFILE = TRANSLATE(PROFILE,\" \",\".\") /*CHANGE DOTS TO BLANKS */\nPROFILE = TRANSLATE(PROFILE,\" \",\"_\") /*CHANGE _    TO BLANKS */\nSYSENV = SYSVAR(SYSENV)\nPROF. = \" \"\nPROFHLD = \" \"\nQ = OUTTRAP(\"OFF\")\nSAY \" \"\nsay \"TSA101D: T50INS control received.\"\nsay \"TSA101D: T50INS profile is\" profile\nsay \"TSA101D: T50INS target  is\" target\nsay \"TSA101D: T50INS days    is\" days\nPARSE VAR PROFILE PROF.1 PROF.2 PROF.3 PROF.4 PROF.5\nPROFNUM = WORDS(PROFILE)\nIF PROFNUM > 5 THEN DO\n  secrc = \"TSA251E: Failed. Insert function only supports \"\n  secrc = secrc||\"5 profiles at a time\"\n  say \"TSA101D: T50INS:\" secrc\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DATATYPE(TARGET) \u00ac= \"NUM\" THEN DO\n   SECRC=\"FUNCTION ABORTED. LOCATION SPECIFIED IS NOT NUMERIC.\"\n   SECRC= SECRC TARGET\n   IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n   EXIT 16\nEND\n/*********************************************************************/\n/* NOW I MAKE SURE EACH PROF HE PASSED ME IS ACTUALLY A PROFILE. DIR */\n/* NOTE THAT THIS CHECKING IS SKIPPED FOR A BATCH USER.          DIR */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  SECRC = \"PROFILE\" /*SET TO PROFILE FOR BATCH DEFAULTS */\n  IF SYSENV = \"FORE\" THEN DO\n    say \"TSA101D: T50INS environment is foreground\"\n    say \"TSA101D: T50INS I am calling Txxfdiv for data on \"prof.cnt\n    ADDRESS TSO \"%T50FDIV \"PROF.CNT\n    ADDRESS ISPEXEC \" VGET SECRC PROFILE\"\n  END\n  IF SECRC \u00ac= \"PROFILE\" THEN DO\n    say \"TSA101D: T50INS rcode indicates \" prof.cnt \"is not a profile\"\n    say \"TSA101D: T50INS return code is ===>\" secrc\n    secrc= \"TSA252E: \"\n    secrc= secrc\"Function aborted. \"prof.cnt \"is not an owned profile.\"\n    IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n    EXIT 08\n  END\nEND\nSIGNAL ON ERROR NAME ERRID\nsay \"TSA101D: T50INS testing primary id for existance\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nsay \"TSA101D: T50INS rcode from test is \" rc\nSIGNAL OFF ERROR\n/*********************************************************************/\n/* NOW I REMOVE THE PROFS BEFORE INSERTING THEM JUST IN CASE THIS IS */\n/* THE EQUIVALENT OF A MOVE OPERATION...........DIR 19 JUN 91        */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  say \"TSA101D: T50INS removing the stated profiles first !\" prof.cnt\n  ADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROF.CNT\")\"\n  IF RC > 0 THEN NOTTHERE = \"YES\"\nEND\n/*********************************************************************/\n/* IF THIS IS THE EQUIVALENT OF A DELETE WE ARE DONE....DIR 19 JUN 91*/\n/*********************************************************************/\nIF TARGET = 0 THEN DO\n  SECRC = PROFILE \" REMOVED FROM \"ACID\", AND NOT REINSERTED.\"\n  IF NOTTHERE = \"YES\" THEN DO\n    say \"TSA101D: T50INS non 0 rc received from tss remove command\"\n    secrc = \"TSA253E: Failed. Delete requested but \"profile \"not\"\n    secrc =  secrc\" removed from ACID\" acid\".\"\n  END\n  SAY \"T50INS:\" SECRC\n  IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n  EXIT\nEND\n/*                                              */\n/*Q = OUTTRAP(\"OUT.\")                           */\n/*ADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"    */\nQ = OUTTRAP(\"OFF\")\n/*********************************************************************/\n/* NOW I GET THE PROFILES CURRENTLY ATTACHED TO THE ACID DR 2 MAY96  */\n/*********************************************************************/\nADDRESS TSO \" %T50GDAT \"ACID \" PROFILES\"\nADDRESS ISPEXEC \" VGET SECRC PROFILE\"\nPROFHLD = SECRC\nSAY \"T50INS: CURRENT PROFILES ARE : \" PROFHLD\nTOTWORDS = WORDS(PROFHLD)\nIF PROFHLD = \"$NOTFOUND\" THEN TOTWORDS = 0\nIF TARGET > TOTWORDS THEN DO\n  TARGET = TOTWORDS + 1\n  SAY \"T50INS: POSITION PARM OVERRIDDEN. CHANGED TO \"TARGET\nEND\n/******************************************************************/\n/* WE ISSUE THE COMMAND WITH AN AFTER PARM UNLESS THE FUNCTION IS */\n/* TO ADD THE PROFILE AS THE FIRST IN HIS LIST, THEN WE MUST      */\n/* USE THE BEFORE PARM. THIS NEXT CODE IS HERE IN CASE TARGET IS  */\n/* EQUAL TO POSITION 1. DIR 2 MAY 96                              */\n/******************************************************************/\nIF TOTWORDS = 0 THEN DO\n  IF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"\n  IF DAYS \u00ac= \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\")\"\n  SIGNAL SEEYA\nEND\nQ1 = TARGET\nIF TARGET = 1 THEN ACT = \"BEFORE\"\nELSE Q1 = TARGET - 1\nIF Q1 = 0 THEN ACT = \"BEFORE\"\nTPROF = WORD(PROFHLD,Q1)\nSAY \"T50INS: INSERT TGT IS PROFILE \" TPROF\nSIGNAL ON ERROR NAME ERRXIT\nSAY \"T50INS: ADDING FOLLOWING PROFILES TO ACID\"\nSAY \"T50INS: PROFILES ===> \"PROFILE\nSAY \"T50INS: CHECKING FOR TEMPORARY TIMESPAN\"\nIF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"ACT\"(\"TPROF\")\"\nELSE ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\") \",\n      ACT\"(\"TPROF\")\"\nSEEYA: NOP\nsecrc =  \"TSA254I:\" profile \"inserted in \"acid\" at position\" target\".\"\nSAY \"T50INS: \"SECRC\nSAY \"  \"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nEXIT 0\n\nERRXIT: NOP\nSAY \"T50INS: ERROR IN LINE:\" SIGL\nSECRC =  \"CATASTROPHIC FAILURE ! PROFILES BELOW NOT ADDED !\"\nSAY \"T50INS: \"SECRC\nSAY \"  \"\nEXITRC16 = ACID \"LOST:\" PROFHLD\nSAY \"T50INS: \"EXITRC16\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC16 PROFILE\"\nEXIT 1\nERRID: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . MAY NOT EXIST\"\nSAY \"T50INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"MAY NOT EXIST\"\nSAY \"T50INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\nERRPRF: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . SOME PROFILES MAY NOT BE OWNED!\"\nSAY \"T50INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"PROFS IN QUESTION:\" Y\nSAY \"T50INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51JCARD": {"ttr": 5381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x08\\x00\\x955/\\x01\\x01\\x19?\\x07T\\x00<\\x00<\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2001-07-12T07:54:08", "lines": 60, "newlines": 60, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** INSERTS A JOBNAME AND MAYBE A USER= CARD INTO A      **/\n/** SAMPLE JCL DECK WHICH ALREADY IS SYNTACTICALLY VALID **/\n/**********************************************************/\n/** EXEC NAME        : T51JCARD                          **/\n/** LAST MODIFIED    : 15 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSNAME OF THE OUTPUT JCL STREAM        **/\n/** JPARM   : \"SUPER\" OR BLANKS                          **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS6     : THE DSNAME IF THE SAMPLE JOB               **/\n/** DISP    : THE OUTPUT FILE ALLOCATION DISPOSITION     **/\n/** MSCA    : THE ID TO INCLUDE IN A USER= CARD IF NEEDED**/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE                         **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (NEEDS VGETS)               **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/.A                **/\n/**                                                      **/\n/**********************************************************/\nARG DSN JPARM\nADDRESS ISPEXEC\n\"ISPEXEC VGET DS6 PROFILE\"\n\"ISPEXEC VGET MSCA PROFILE\"\nSAY \"TSA101D: T51JCARD: IS IN CONTROL WITH PARMS : \" DSN JPARM\nADDRESS TSO \"ALLOC DDN(JCFILE) DSN(\"DS6\") SHR REUS\"\nJNAME= JPARM\nIF JPARM = '' THEN JNAME = \"TSSJOB\"\nTIME = TIME(NORMAL)\nT12 = SUBSTR(TIME,1,2)\nT45 = SUBSTR(TIME,4,2)\nIF JPARM = \"RANDOM\" THEN\n  JNAME= \"TSSJ\"T12||T45\nADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DSN\") SHR REUS\"\nADDRESS MVS \"EXECIO * DISKR JCFILE (FINIS STEM LINE.)\"\nJOBCARD_INSERT = 99\nDO Q = 8 TO 1 BY -1 /* LETS FIND WHERE THE JOBCARD ENDS */\n  INLINE = LINE.Q\n  IF SUBSTR(INLINE,1,3) = \"//*\" THEN JOBCARD_INSERT = Q - 1\n  IF SUBSTR(INLINE,1,2) = \"/*\" THEN JOBCARD_INSERT = Q - 1\n  IF INDEX(INLINE,\"EXEC\") > 0  THEN JOBCARD_INSERT = Q - 1\nEND\nSAY \"TSA101D: T51JCARD JOBCARD ENDS PRIOR TO LINE\" JOBCARD_INSERT\nIF JPARM = \"SUPER\" THEN DO\n  JNAME= \"TSSJ\"T12||T45\n  LINE.JOBCARD_INSERT= \"// \"WORD(LINE.JOBCARD_INSERT,2)||\",USER=\"MSCA\n  SAY \"TSA101D: JCARD ADDITION : \" LINE.JOBCARD_INSERT\nEND\nLEN1= LENGTH(LINE.1)\nHOLD = SUBSTR(LINE.1,11)\nLINE.1= \"//\"JNAME HOLD\nADDRESS MVS \"EXECIO * DISKW OUTFILE (FINIS STEM LINE.)\"\nADDRESS TSO \" FREE DDN(JCFILE)  \"\nADDRESS TSO \" FREE DDN(OUTFILE) \"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51LISTP": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x01\\x19?\\x01\\x01\\x19?\\t\\x15\\x00Q\\x00Q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-07-12T00:00:00", "modifydate": "2001-07-12T09:15:20", "lines": 81, "newlines": 81, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51LISTP                          **/\n/** LAST MODIFIED    : 11 JUL 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE VALID TSS DEFINED ID                   **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  ACID IF NOT PASSED AS AN ARG.                       **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         MSG2                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T51FDIV T51GETPW     **/\n/**                                                      **/\n/**********************************************************/\nARG ACID\nIF ACID = \" \" THEN ADDRESS ISPEXEC \"VGET ACID  PROFILE\"\nSAY \"T51LISTP: HAS CONTROL\"\nSAY \"T51LISTP: CALLING T51FDIV\"\nSYSSCMD = SYSVAR(SYSSCMD)\nSYSPCMD = SYSVAR(SYSPCMD)\nSYSICMD = SYSVAR(SYSICMD)\nSYSNEST = SYSVAR(SYSNEST)\nSYSRACF = SYSVAR(SYSRACF)\nSAY \"I=\"SYSICMD \"P=\" SYSPCMD \"S=\" SYSSCMD \"RACF= \" SYSRACF\nADDRESS TSO \"%T51FDIV \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\nSAY \"T51LISTP: BACK FROM  T51FDIV WITH SECRC OF\" SECRC\nIF SECRC = \"LIST FUNCTION FAILED.\" THEN DO\n  ADDRESS TSO \"%T51GETPW \" ACID\n  ADDRESS ISPEXEC \" VGET SECRC PROFILE \"\n  IF SECRC \u00ac= \"$ERROR\" THEN\n    SECRC = \"THAT IDS PASSWORD = \" SECRC\n  ELSE\n    SECRC = \"FAILED. THAT ID DOES NOT EXIST IN UADS OR TOP SECRET\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC = \"AUTHORIZATION FAILED.\" THEN DO\n  SECRC = \"FAILED. YOUR TOP SECRET AUTHORIZATION IS INADEQUATE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC \u00ac= \"CUSTDIV\" THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"THAT ID IS NOT DEFINED AS AN EXTERNAL CUSTOMER. \"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    IF SUBSTR(ACID            ,8,1) = \"@\" THEN DO\n      MSG2 = \"THAT IS A GHOST ENTRY, TRY LISTING THE ID WITHOUT THE @\"\n      ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\n    END\n    EXIT 00\n    END\n  ELSE DO\n    MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY LISTABLE\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nADDRESS TSO \"%T51GDAT \"ACID\" ATTRIBUTES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF INDEX(SECRC,\"SUSPEND\") \u00ac=  0 THEN DO\n  MSG2 =  \"THIS ID IS SUSPENDED, YOU MUST UNSUSPEND TO USE\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nADDRESS TSO \"T51GDAT \"ACID\" PASSWORD PW\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF ( SECRC = \"$NOTFOUND\" ) | ( SECRC = \"$BADTSS\" )  THEN DO\n  MSG2 = \"THE IDS PASSWORD IS NOT RETRIEVABLE. CONTACT TECH SUPPORT\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nELSE\n  SECRC = \"THE IDS PASSWORD  = \"SECRC\nTHEEND: NOP\nADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51LSTO": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\"\\x00\\x98(/\\x00\\x99\\'?\\x15V\\x00.\\x00.\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-09T00:00:00", "modifydate": "1999-09-30T15:56:22", "lines": 46, "newlines": 46, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID DATA DS1\n HEX00 = '00'X\n DISP = \"SHR\"\n SYSENV = SYSVAR(SYSENV)\n SAY HEX00\n SECRC = \"FAILED IN T50LSTO. CHECK ACIDS VALIDITY\"\n SECRC = SECRC||\" AND YOUR CURRENT AUTHORITY\"\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n   ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n END\n IF DISP = \"\" THEN DISP = SHR\n SIGNAL ON ERROR NAME SEEYA\n SS = OUTTRAP('OUTLINE.')\n  /******************************************************************/\n  /* THIS EXEC PRINTS OUTPUT TO A DSN.                              */\n  /* IT IS VERY SIMPLE......DAVE 20 MAY 91                          */\n  /******************************************************************/\nIF DATA  = \"  \" THEN  DATA=\"ALL\"\nIF DATA  = \"ALLPW\" THEN  DATA=\"ALL,PASSWORD\"\nIF DATA  = \"DATAAREA\" THEN DO\n  ADDRESS ISPEXEC \"VGET DATAAREA PROFILE\"\n  DATA = DATAAREA\nEND\nSAY \"T50LSTO: ALLOCATING DSN\" DS1\n\"ALLOC DDN(OUTFILE) DSN(\"DS1\") \"DISP\" REUS\"\nSAY \"T50LSTO: CALLING TSS FOR LIST OF ID \" ACID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n SECRC = \"FUNCTION COMPLETED. OUTPUT IN \" DS1\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51PER": {"ttr": 3846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00F\\x00\\x990O\\x00\\x991/\\t\\x14\\x00g\\x00g\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-31T00:00:00", "modifydate": "1999-11-08T09:14:46", "lines": 103, "newlines": 103, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG ACID RESTYPE RESNAME ACCESS DAYS\nSIGNAL OFF ERROR\nSECRC = \"T50PER FAILED WITH ERRORS\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nRES.0 = 3\nRES.1 = \"DATASET\"\nRES.2 = \"JESSPOOL\"\nRES.2 = \"VOL\"\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE ASTERISK WITH Z */\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = RESTYPE THEN VALID = \"YES\"\nEND\nIF VALID /= \"YES\" THEN DO\n  SAY \"T50PER: RESTYPE NOT SUPPORTED. RESTYPE = \" RESTYPE\n  MSG2 = \"THE FOLLOWING RESTYPE WAS NOT RECOGNIZED\" RESTYPE\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  EXIT 08\nEND\nACTION = \"ACTION(FAIL)\"\nIF DAYS /= \" \" THEN DAYCMD = \"FOR(\"DAYS\")\"\nSLASH = INDEX(\"/\",DAYS)\nIF SLASH > 0 THEN DAYCMD = \"UNTIL(\"DAYS\")\"\nDAY1 = WORD(DAYS,1)\nSIGNAL NOCHECK\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE DOTS WITH SPACES */\nACCCHK = ACCESS\nQ = OUTTRAP(HOLD.,5)\nIF ACCESS = \"ALL\" THEN ACCCHK = \"ALTER\"\nIF ACCESS = \"REMOVE\" THEN ACCCHK = \"ALTER\"\nSAY \"T50PER: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nSAY \"T50PER: RES IS \" RESNAME\nSAY \"********CHECK IS BELOW **************\"\nSAY \" TSSCHECK(\"RESTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\nX5 = TSSCHECK(RESTYPE,RESCHK,ACCCHK,\"NOMSG\")\nSAY \"********CHECK IS BELOW **************\"\nSAY \"T50PER: TSSCHECK RETURN CODE IS \" X5\nIF X5 \u00ac= \"OK\"  THEN DO\n  SECRC = \"YOU CANNOT GRANT THAT LEVEL OF ACCESS TO THAT RESOURCE.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nNOCHECK: NOP\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T50PER: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\n/********************************/\n/* LETS ACTUALLY DO THE WORK... */\n/********************************/\nQ = OUTTRAP(OUT.,5)\nIF RESTYPE = \"DATASET\" THEN RESTYPE = \"DSN\"\nIF ACCESS = \"REMOVE\" THEN DO\n  \"TSS REV(\"ACID\") \"RESTYPE\"(\"RESNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"AUTHORITY REMOVED FOR ID \"ACID\".\"\n  ELSE DO\n    SECRC = \"REMOVE RETURNED NON ZERO RCODE OF \"RCODE\n    MSG2 = OUT.1\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") \"RESTYPE\"(\"RESNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"RESNAME\")\",\n  \"ACCESS(\"ACCESS\")\" DAYCMD ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  secrc = \"TSA521I: permit function successful for id\" acid\nELSE DO\n  secrc = \"TSA522I: permit returned non zero rcode of \"rcode\n  MSG2 = OUT.1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51PMENU": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00H\\x00\\x98#/\\x01\\x00\\x07_\\x10S\\x02\\x96\\x02\\x96\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-08-20T00:00:00", "modifydate": "2000-03-15T10:53:48", "lines": 662, "newlines": 662, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added  security checking for datsets                 **/\n/**********************************************************/\n/** added  privpgm support 11 nov 97                     **/\n/**********************************************************/\n/** added  support for the STC record by creating        **/\n/** the DELTRUNC. variable to be referenced in deletes   **/\n/**********************************************************/\n/** added  support for the user TSO area. dir 1 oct 97   **/\n/**********************************************************/\n/** Fixed truncation of last data line and added sitran  **/\n/** support.     dave 29 aug 97                          **/\n/**********************************************************/\n/** NOW SUPPORTS LCF CMDS     DIR 28 AUG 97              **/\n/**********************************************************/\n/** MODIFY PROFILES IN A PANEL BASED ENVIRONMENT         **/\n/** LOTS  OF SAYS   TO FACILITATE DEBUGGING...           **/\n/**********************************************************/\n/** EXEC NAME        : T50PMENU                          **/\n/** LAST MODIFIED    : 25 MAR 97                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS3     : THE BATCH FILE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD  = THE VALID COMMANDS FOR THIS ENTRY   \"ADD REM\" **/\n/** TYPE = THE RESOURCE TYPE                   \"DATASET\" **/\n/** RSNAME= THE RESOURCE NAME                  \"SYS1.  \" **/\n/** ACCESS=THE ACCESS LEVEL                    \"UPDATE \" **/\n/** ACTION=THE ACTION TO TAKE                  \"FAIL   \" **/\n/** UNTIL= THE EXPIRATION DATE OF RULE  \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/** OTHER   = ANYTHING ELSE             \"DAYS(MON.TUE)  \"**/\n/** DELTRUNC= Number of words to retain of the resource \"**/\n/**           name when doing a delete function.         **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** OUT_COUNT = THE # OF OUTPUT CHANGES                  **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS3  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nCALL OFF ERROR\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50PMENU. CHECK ACIDS VALIDITY\"\nSECRC = SECRC||\" AND YOUR CURRENT AUTHORITY\"\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS3 PROFILE\"\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\nEND\nDELTRUNC. =  0\nF0        =  \" \"\nUNTIL.    =  \" \"\nACCESS.   =  \" \"\nRSNAME.   =  \" \"\nOTHER.    =  \" \"\nLIBRARY.  =  \" \"\nFACILITY. =  \" \"\nPGM.      =  \" \"\nCOMMAND_FALLTHRU = \"ADD REM\"\nCMD.      =  \"PER REV\"\nACTION.   =  \" \"\nIF DISP = \"\" THEN DISP = SHR\nSIGNAL ON ERROR NAME BYEBYE\nDATA=\"ALL,EXPIRE\"\nIF MODE = \"ONLINE\" THEN DO\n  SAY \"T50PMENU: ALLOCATING DSN\" DS3\n  ADDRESS TSO \"%T50JCARD\" DS3\n  \"ALLOC DDN(BJCL) DSN(\"DS3\") MOD REUS\"\nEND\nSAY \"T50PMENU: CALLING TSS FOR LIST OF ID \" ACID\nSS = OUTTRAP('INLINE.')\nSIGNAL ON ERROR NAME BADID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nRCODE = RC\nSIGNAL ON ERROR NAME BYEBYE\nTHISREC = 3\nOUT_COUNT = 0\nOUTNUM = 0\nSAY \"T50PMENU: HAS A TOTAL RECORD COUNT OF \" inline.0\nDO I = 1 TO INLINE.0\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\") /* REPLACE = WITH SPACES */\n  /***********************************************************/\n  /** Kill those = signs.. very important to know for the   **/\n  /** lower loop...    Dave 29 Aug 97                       **/\n  /***********************************************************/\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  /****************************/\n  /* SAVE THE LAST LINE HEADER*/\n  /****************************/\n  FIRST13 = SUBSTR(LINE,1,13)\n  IF FIRST13 \\= \"             \" THEN SAVE13 = FIRST13\n  IF SUBSTR(LINE,1,2) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  /***********************************************************/\n  /** Reformatter area                                      **/\n  /** The lower loop operates on the principal that each    **/\n  /** line contains enough data to recreate any command     **/\n  /** pertaining to the resources mentioned there.          **/\n  /** I created this area for LCF commands, where lines do  **/\n  /** not mention the facilites that they are affecting     **/\n  /** nor do they mention the type of resource they are     **/\n  /** securing. So I 'proprogate' the first 13 chars of     **/\n  /** the line that does have this data to the lower        **/\n  /** lines.      DAVE 29 AUG 97                            **/\n  /***********************************************************/\n  IF (SAVE13 = \" AUTH CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"AUTH CMDS  \"||LINE\n  IF (SAVE13 = \" EXMP CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"EXMP CMDS  \"||LINE\n  IF SAVE13 = \" AUTH CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  IF SAVE13 = \" EXMP CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  /****************************/\n  /** END OF REFORMATTER AREA**/\n  /****************************/\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  IF FIRST13 = \"LCF FAC     \" THEN LCFFAC = W.3\n  IF W.1 = \"XA\" THEN DO\n    OUTNUM = OUTNUM + 1\n    CMD.OUTNUM = \"PER REV\"\n    IF W.2 = \"DATASET\" THEN W.2 = \"DSN\" /* FIX FOR ADD/PER WITH DSNS*/\n    TYPE.OUTNUM = W.2\n    RSNAME.OUTNUM = W.3\n    UNTIL.OUTNUM = W.4\n    ITERATE I\n  END\n  IF W.1 = \"ACCESS\" THEN DO\n    ACCESS.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"DAYS\" THEN DO\n    OTHER.OUTNUM = \"DAYS(\"W.2\")\"  W.3 W.4 W.5 W.6 W.7 W.8 W.9\n    OTHER.OUTNUM = STRIP(OTHER.OUTNUM)\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n  IF W.1 = \"STC\" THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"PROCNAME(\"W.2\") acid(\"w.4\")\"\n    DELTRUNC.OUTNUM = 1 /* TO DEL THIS RULE ONLY USE WORD # 1 */\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n/*************************************************/\n/* SITRAN     = M3CL      FACILITY   = FINTST1   */\n/* TSS ADD(CONSPROF) SIT(M3CL,FINTST1)           */\n/*************************************************/\n  IF W.1 = \"SITRAN\"   THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"SIT(\"W.2\",\"W.4\")\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$SITRAN\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$ATTRIB\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    PGM.OUTNUM = W.2 W.3 W.4 W.5 W.6\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  END\n  /*************************************************/\n  /* below is the processing for the tso area      */\n  /* note that it checks handles all tso prefixed  */\n  /* words............  dir 1 oct 97               */\n  /*************************************************/\n  IF SUBSTR(W.1,1,3) = \"TSO\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  /*************************************************/\n  /* Below is the area for words to ignore         */\n  /*************************************************/\n  END\n  IF W.3 = \"NAME\" THEN iterate i\n  IF W.1 = \"DEPT\" THEN ITERATE I\n  IF W.1 = \"ZONE\" THEN ITERATE I\n  IF W.1 = \"DIV\" THEN ITERATE I\n  IF W.1 = \"TYPE\" THEN ITERATE I\n  IF W.1 = \"CREATED\" THEN ITERATE I\n  IF W.1 = \"TSS0300I\" THEN ITERATE I\n  IF W.1 = \"LAST\" THEN ITERATE I\n  IF W.1 = \"ACID\" THEN ITERATE I\n  /*************************************************/\n  /* Below is the area to change fallthru defaults */\n  /*************************************************/\n  IF W.1 = \"LIST\" & W.2 = \"DATA\"  THEN do\n    w.1 = \"DATA\";w.2 = w.3;w.3 = \" \"\n  end\n  IF INDEX(W.2,\"*ALL*\") THEN DO\n    PARSE VAR W.2  TZ1 '*ALL*' TZ2\n    W.2 = TZ1||\"ALL\"TZ2\n  END\n  IF W.2 = \"ADMINISTRATION\" & W.3 = \"AUTHORITIES\"  THEN\n    COMMAND_FALLTHRU = \"ADMIN DEADMIN\"\n  /*************************************************/\n  /* below is the fall thru area                   */\n  /* I take my best guess at the command           */\n  /*      ............  dir 29 jan 99              */\n  /*************************************************/\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM =  command_fallthru\n  ITERATE I\nEND\n/*******************************************************/\n/*******************************************************/\n/** End of loop now we create the output lines DIR    **/\n/*******************************************************/\n/*******************************************************/\nOUTNUM = OUTNUM + 1\nIF OUTNUM < 15 THEN DO A = OUTNUM TO 15\n  CMD.A      = \"PER REV\"\n  TYPE.A        = \" \"\n  RSNAME.A      = \" \"\n  ACCESS.A      = \" \"\n  OUTNUM = 15\nEND\nCALL FILLSCR\nSCANSCR: NOP\nDO T = 1 TO 14\n  IF F.T  = 'S' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    CALL SHOWRULE\n  END\n  IF F.T  = 'D' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN  CALL DELRULE\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T50PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'M' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN DO\n      CALL DELRULE\n      SAY \"T50PMENU: TYPE AFTER RULE PROCESSING IS \" TYPE.T\n      FLAG = \"*MODIFY\"\n      CALL MODRULE\n    END\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T50PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'A' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    F.T = \" \"\n    F0 = \"\"\n    DO TEMP3 = OUTNUM TO T BY - 1\n      BEFORE = TEMP3 - 1\n      F.TEMP3 = F.BEFORE\n      INTERPRET \"F\"||TEMP3 \"= F\"||BEFORE\n    END\n    OUTNUM = OUTNUM + 1\n    FILL = THISREC + T - 1\n    TARGET = FILL + 1\n    SAY \"T50PMENU: RECNUM IS  \" FILL\n    SAY \"T50PMENU: ACCESS IS  \"ACCESS.FILL\n    SAY \"T50PMENU: TYPE IS    \"TYPE.FILL\n    SAY \"T50PMENU: RSNAME IS  \"RSNAME.FILL\n    DO Q = OUTNUM TO TARGET BY -1\n      Q1 = Q - 1\n      FACILITY.Q = FACILITY.Q1\n      ACTION.Q   = ACTION.Q1\n      PGM.Q      = PGM.Q1\n      LIBRARY.Q  = LIBRARY.Q1\n      ACCESS.Q   = ACCESS.Q1\n      TYPE.Q     = TYPE.Q1\n      UNTIL.Q    = UNTIL.Q1\n      RSNAME.Q   = RSNAME.Q1\n    END\n    FLAG = \"*NEWRULE\"\n    CALL MODRULE\n    F.T = \" \"\n  END\nEND\nCALL FILLSCR\nADDRESS ISPEXEC \"DISPLAY PANEL(\"SECPROF\")\"\nCALL FILLSCR\nIF RC > 0 THEN SIGNAL BYEBYE\n/* IF OPT = \"NEXTM\" THEN THISREC = THISREC + 14         */\n/*IF OPT = \"PREVM\" THEN THISREC = THISREC - 14           */\nsay \"option is \"opt\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"F\") THEN OPT = \" \"\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"FIND\") THEN OPT = \" \"\nIF WORDS(OPT) = 1 THEN SIGNAL NOLOOP\nIF (WORD(OPT,1) = \"FIND\") | (WORD(OPT,1) = \"F\") then do\n  HOLD2 = WORD(OPT,2)\n  TGTNUM = OUTNUM - 14\n  HIT = \"NO\"\n  DO TF1 = THISREC TO OUTNUM\n    IF INDEX(TYPE.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(RSNAME.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(ACCESS.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF HIT = \"YES\" THEN THISREC = TF1\n    IF HIT = \"YES\" THEN LEAVE\n  END\n  IF THISREC > TGTNUM THEN THISREC = TGTNUM\nEND\nnoloop: nop\nIF WORD(OPT,1) = \"PREVM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC - 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = THISREC - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = 1\nend\nIF WORD(OPT,1) = \"NEXTM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC + 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = OUTNUM - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = OUTNUM - 14\nEND\nIF OPT = \"QUIT\" THEN SIGNAL BYEBYE\nOPT = \" \"\nSIGNAL SCANSCR\nSAY \"T50PMENU : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/*DO X = 1 TO OUTNUM                                                */\n/*  BATFILE.X =  X CMD.X TYPE.X RSNAME.X UNTIL.X ACCESS.X LIBRARY.X,*/\n/*  ACTION.X                                                        */\n/*END                                                               */\n\"EXECIO \"OUT_COUNT\" DISKW BJCL ( FINIS STEM BATFILE.)\"\n SECRC = \"FUNCTION COMPLETED. OUTPUT IN \" DS3\n IF MODE = \"BATCH\" THEN\n   SECRC = \"FUNCTION COMPLETED. OUTPUT APPENDED TO BATCH FILE.\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nBADID: NOP\n SECRC = \"ID LIST FAILED, CHECK YOUR AUTHORITIES AND IDS EXISTANCE\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nSEEYA: NOP\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/******************************************************************/\n/**  THE SHOWRULE SECTION                                        **/\n/******************************************************************/\nSHOWRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. OTHER.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nSAY \"T50PMENU: TEMP IS \" TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nRSNAME   = RSNAME.TEMP\nSAY \"T50PMENU: INSIDE SHOWRULE ROUTINE\"\nSAY \"T50PMENU: ACTION IS   \"  ACTION\nSAY \"T50PMENU: FACILITY IS \"  FACILITY\nSAY \"T50PMENU: PGM IS      \"  PGM\nSAY \"T50PMENU: ACCESS IS   \"  ACCESS\nSAY \"T50PMENU: LIBRARY IS  \"  LIBRARY\nSAY \"T50PMENU: UNTIL IS    \"  UNTIL\nSAY \"T50PMENU: TYPE IS     \"  TYPE\nSAY \"T50PMENU: RSNAME IS   \"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECSHOW)\"\nADDRESS ISPEXEC \"REMPOP\"\nRETURN\n/*******************************************************/\n/**              THE SECURITY CHECK                   **/\n/*******************************************************/\nSECURE: PROCEDURE EXPOSE TYPE. RSNAME. ACCESS. T,\n       ACTION. THISREC CMD. FLAG,\n       ACID OTHER. SECCODE\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nCALL OFF ERROR\nVALID = \"NO\"\nTEMP   = T + THISREC - 1\nOUT_RNAME = RSNAME.TEMP\nACCESS   = ACCESS.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T50PMENU(SECURE): MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nRES.0 = 2\nRES.1 = \"DSN\"\nRES.2 = \"JESSPOOL\"\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = TYPE THEN VALID = \"***DISABLED***\"\nEND\nIF TYPE = \"*SECURE\" THEN SECCODE = 16\nSAY \"MODRULE VALID IS\" VALID\nIF VALID = \"YES\" THEN DO\n  RESCHK = TRANSLATE(RSNAME,\"Z\",\"*\") /* REPLACE * WITH zzzzzz */\n  ACCCHK = \"ALTER\"\n  IF TYPE = \"DSN\" THEN TYPE = \"DATASET\"\n  RSTYPE = STRIP(TYPE)\n  /* Q = OUTTRAP(HOLD.,5)  */\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \" TSSCHECK(\"RSTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\n  SECCODE = TSSCHECK(RSTYPE,RESCHK,ACCCHK,\"NOMSG\")\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \"T50PMENU(MODRULE): TSSCHECK RETURN CODE IS \" SECCODE\nEND\nRETURN\n/*******************************************************/\n/******************************************************************/\n/**  THE MODRULE SECTION                                         **/\n/******************************************************************/\n/*******************************************************/\nMODRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. CMD. BATFILE. OUT_COUNT FLAG,\n       ACID OTHER. SECCODE\nCALL OFF ERROR\nOUT_COUNT = OUT_COUNT + 1\nSAY \"T50PMENU: RECNUM IS \" FILL\nTEMP   = T + THISREC - 1\nSAY \"T50PMENU: RECNUM IS \" TEMP\nOUT_CMD = WORD(CMD.TEMP,1)\nOUT_RNAME = RSNAME.TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T50PMENU: MODRULE TYPE WAS :\" TYPE\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = FLAG TYPE\nSAY \"T50PMENU: MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nSAY \"T50PMENU: INSIDE MODRULE  ROUTINE\"\nSAY \"T50PMENU: ACTION IS\"  ACTION\nSAY \"T50PMENU: FACILITY IS \"  FACILITY\nSAY \"T50PMENU: PGM IS\"  PGM\nSAY \"T50PMENU: ACCESS IS\"  ACCESS\nSAY \"T50PMENU: LIBRARY IS\"  LIBRARY\nSAY \"T50PMENU: UNTIL IS\"  UNTIL\nSAY \"T50PMENU: TYPE IS\"  TYPE\nSAY \"T50PMENU: RSNAME IS\"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECUPDT)\"\nRCODE = RC\nADDRESS ISPEXEC \"REMPOP\"\nIF RCODE > 0 THEN DO\n  OUT_COUNT = OUT_COUNT - 1  /* KILL THE DELETE ENTRY */\n  TYPE.TEMP = TYPE           /* RESET THE TYPE FIELD */\n  MSG = \" MODIFY ABORTED DUE TO PANEL RETURN CODE.\"\n  RETURN\nEND\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"RSNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  H = H||TYPE||\"(\"RSNAME\") + \"\nEND\nBATFILE.OUT_COUNT = H\nH =  ''\nOUT_COUNT = OUT_COUNT + 1\nIF LENGTH(UNTIL) = 8 THEN UNTIL = \"UNTIL(\"UNTIL\")\"\nIF ACCESS <> '' THEN H = H||\"ACCESS(\"ACCESS\") \"\nIF LIBRARY <> '' THEN DO\n  H = H||\"LIBRARY(\"LIBRARY\") + \"\n  BATFILE.OUT_COUNT = \"  \"||H\n  H =  ''\n  OUT_COUNT = OUT_COUNT + 1\nEND\nIF PGM <> '' THEN H = H||\"PRIVPGM(\"PGM\") \"\nIF UNTIL  <> '' THEN H = H||\" \"UNTIL\nIF ACTION <> '' THEN H = H||\" ACTION(\"ACTION\") \"\nIF FACILITY <> '' THEN H = H||\" FAC(\"FACILITY\") \"\nIF OTHER <> '' THEN H = H OTHER\nBATFILE.OUT_COUNT = \"  \"||H\nPGM.TEMP      = PGM\nACCESS.TEMP   = ACCESS\nLIBRARY.TEMP  = LIBRARY\nACTION.TEMP   = ACTION\nFACILITY.TEMP = FACILITY\nUNTIL.TEMP    = UNTIL\nRSNAME.TEMP    = RSNAME\nRETURN\n/******************************************************************/\n/** THE DELETE RULE SECTION                                      **/\n/******************************************************************/\nDELRULE: PROCEDURE EXPOSE TYPE. RSNAME. T ACID,\n        THISREC UPDATE. CMD. BATFILE. OUT_COUNT DELTRUNC.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nOUT_COUNT = OUT_COUNT + 1\nTYPE= TYPE.TEMP\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = \"*DELETE\" TYPE.TEMP\nOUT_ACID = ACID\nOUT_CMD = WORD(CMD.TEMP,2)\nOUT_RNAME = RSNAME.TEMP\nOUT_TRUNC = DELTRUNC.TEMP\n/******************************/\n/** truncate the rsname maybe**/\n/******************************/\nIF OUT_TRUNC = 1 THEN OUT_RNAME = WORD(OUT_RNAME,1)\nIF OUT_TRUNC = 2 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2)\nIF OUT_TRUNC = 3 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2) WORD(OUT_RNAME,3)\nIF SUBSTR(TYPE,1,1) = \"*\" THEN TYPE = WORD(TYPE,2) WORD(TYPE,3)\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"OUT_RNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  /*                         */\n  H = H||TYPE||\"(\"OUT_RNAME\")\"\nEND\nBATFILE.OUT_COUNT = H\n/* SAY OUT_COUNT */\n/* SAY H*/\nRETURN\nFILLSCR: PROCEDURE EXPOSE THISREC OUTNUM TYPE. RSNAME. ACCESS. T,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 TYPE1 TYPE2 TYPE3,\n TYPE4 TYPE5 TYPE6 TYPE7 TYPE8 TYPE9 TYPE10 TYPE11 TYPE12 TYPE13,\n ACCESS1 ACCESS2 ACCESS3 ACCESS4 ACCESS5 ACCESS6 ACCESS7 ACCESS8,\n ACCESS9 ACCESS10 ACCESS11 ACCESS12 ACCESS13 ACCESS14 TYPE14,\n RSNAME1 RSNAME2 RSNAME3 RSNAME4 RSNAME5 RSNAME6 RSNAME7 RSNAME8,\n RSNAME9 RSNAME10 RSNAME11 RSNAME12 RSNAME13 RSNAME14,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F.\nOPT = \" \"\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nIF (THISREC > OUTNUM - 14)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\nDO T = 1 TO 14\n  FILL = THISREC + T - 1\n  INTERPRET \"F.\"T \"=  F\"||T\n  IF WORDS(TYPE.FILL) > 2 THEN DO\n    SAY \"T50PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n    TYPE.FILL = WORD(TYPE.FILL,1) WORD(TYPE.FILL,3)\n    SAY \"T50PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n  END\n  INTERPRET \"TYPE\"||T \" =  TYPE.FILL\"\n  INTERPRET \"RSNAME\"||T \"= RSNAME.FILL\"\n  INTERPRET \"ACCESS\"||T  \"=  ACCESS.FILL\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51PWHO": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x16\\x00\\x97 /\\x01\\x005o\\x14A\\x00\\x8d\\x00\\x8d\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-12-21T14:41:16", "lines": 141, "newlines": 141, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added an exit with rc=8 for a bad tss id.             */\n/**********************************************************/\n/** Changed to use T51gdat for type processing            */\n/** should be faster for departments and divisions than   */\n/** the older routine.  Dave                              */\n/**********************************************************/\n/** Changed to support all listopt parm which allows      */\n/** all IDs to be listed including departments profiles   */\n/** and security administrators.           Dave           */\n/**********************************************************/\n/**********************************************************/\n/** NO SAYS CAUSE  THIS PGM IS EXPECTED TO WRITE OUTPUT  **/\n/** DATA DIRECTLY TO THE SCREEN.   DAVE                  **/\n/**********************************************************/\n/** EXEC NAME        : T51PWHO                           **/\n/** LAST MODIFIED    : 15 July 97                        **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** PROF    : THE TARGET ID OF THE LIST.                 **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG PROF LISTALL\nENV = SYSVAR(SYSENV)\nsecrc = \"List function failed. ACID may be invalid.\"\nIF ENV = \"FORE\" THEN DO\n  ADDRESS TSO \"%T51GDAT \"PROF\" TYPE\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  IF TYPE = \"$BADTSS\" THEN EXIT 08\n  secrc = \"List function failed. ACID may be invalid.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  IF TYPE = \"MASTER\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"PROFILE\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"DIVISION\" THEN DIVFLAG = \"YES\"\n  IF TYPE = \"DEPT\" THEN DEPTfLAG = \"YES\"\n  IF TYPE = \"ZONE\" THEN ZONEFLAG = \"YES\"\nEND\nIF ENV /= \"FORE\" THEN DO\n  SPACES = \"                                \"\n  Q = OUTTRAP(\"TYPE.\")\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(BASIC)\"\n  DO T = 1 TO TYPE.0\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DIVISION\") THEN\n      DIVFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DEPT\") THEN\n      DEPTFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"MASTER\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"PROFILE\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"ZONE\") THEN\n      ZONEFLAG = \"YES\"  /* FOR LATER ENHANCEMENTS */\n  END\nEND\nIF NORMFLAG = \"YES\" THEN DO\n   ACID.1   = PROF\n   CALL PRINTDPT /* A DEPT OR PROFILE WAS GIVEN. NO PROBLEM. */\n   EXIT 00\nEND\nIF ZONEFLAG = \"YES\" THEN DO     /* ZONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") TYPE(USER)\"\nEND\nIF DEPTFLAG = \"YES\" THEN DO     /* DEPT PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") TYPE(USER)\"\nEND\nIF DIVFLAG = \"YES\" THEN DO     /* DIVISIONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") TYPE(USER)\"\nEND\n/*                       */\nSECRC = \"FUNCTION COMPLETED NORMALLY.\"\nIF ENV = \"FORE\" THEN\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nPRINTDPT: PROCEDURE EXPOSE ACID. LISTALL\nDO IDNUM = 1 TO 4\n  Q = OUTTRAP(\"TYPE.\")\n  IF ACID.IDNUM = \"  \" THEN RETURN\n  IF ACID.IDNUM = \"ACID.\"IDNUM THEN RETURN\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(BASIC)\"\n  IF LISTALL = \"YES\" THEN SAY ACID.IDNUM\n  Q = OUTTRAP(\"OFF.\",0)\n  NORMAL = \"NO\"\n  DO T = 1 TO TYPE.0\n    W1 = WORD(TYPE.T,1)\n    W3 = WORD(TYPE.T,3)\n    IF W1 = \"TYPE\" THEN DO\n      IF W3 = \"DEPT\" THEN NORMAL = \"YES\"\n      IF W3 = \"MASTER\" THEN NORMAL = \"YES\"\n      IF W3 = \"PROFILE\" THEN NORMAL = \"YES\"\n      IF NORMAL = \"NO\" THEN DO\n        SAY ACID.IDNUM /* AN UNUSUAL USER */\n        ITERATE IDNUM\n      END\n    END\n  END\n  /********************************************************/\n  /* SINCE WE ARE HERE THIS ACID MUST BE A DEPARTMENT!    */\n  /********************************************************/\n  Q = OUTTRAP(\"OUT.\")\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(ACIDS)\"\n  Q = OUTTRAP(\"OFF.\",0)\n  GOFLAG = \"NO\"\n  DO T = 1 TO OUT.0\n    IF WORD(OUT.T,1) = \"ACIDS\" THEN GOFLAG = \"YES\"\n    IF WORD(OUT.T,1) = \"TSS0300I\" THEN LEAVE\n    IF WORD(OUT.T,1) = \"TSS300I\" THEN LEAVE\n    IF GOFLAG = \"YES\" THEN DO\n      /*SAY \"OUT.T IS  \"OUT.T */\n      PRT.1 = SUBSTR(OUT.T,14,8)\n      PRT.2 = SUBSTR(OUT.T,26,8)\n      PRT.3 = SUBSTR(OUT.T,38,8)\n      PRT.4 = SUBSTR(OUT.T,50,8)\n      DO X = 1 TO 4\n        IF PRT.X = \"*NONE*\" THEN PRT.X = \"  \"\n        IF PRT.X \u00ac= \"  \" THEN SAY PRT.X\n        PRT.X = \"  \"\n      END\n    END\n  END\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(ACIDS)\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51RENA": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x00\\x16\\x7f\\x01\\x005_\\t6\\x00Q\\x00Q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2000-12-20T09:36:07", "lines": 81, "newlines": 81, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** THIS IS AN IMS ONLY EXEC DON NOT USE ON CSS LPAR     **/\n/**********************************************************/\n/** EXEC NAME        : T51RENA                           **/\n/** LAST MODIFIED    : 15 DEC 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID                                   **/\n/** NEW_ACID: WHAT YOU WANT IT RENAMED TO                **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  NONE                                                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEW_ACID\nSAY \"T51RENA: IN CONTROL WITH PARMS :\" ACID NEW_ACID\nADDRESS TSO\nNEW_LENGTH = LENGTH(NEW_ACID)\nIF NEW_LENGTH = 2 THEN DO\n  SAY \"T51RENA: TARGET ACID IS BEING RESOLVED DUE TO LENGTH\"\n  NEW_ACID = NEW_ACID||SUBSTR(ACID,3)\n  SAY \"T51RENA: TARGET ACID IS RESOLVED TO : \" NEW_ACID\nEND\nCALL OFF ERROR\nADDRESS ISPEXEC \"VGET ZSYSID \"; SYSID = ZSYSID\nSAY \"T51RENA: SYSID IS :\" SYSID\nif sysid = \"CSS1\" then secrc = \"rename function is invalid on CSS LPAR.\"\nif sysid = \"CSS1\" then signal seeya\nSECRC = \"THE RENAME FUNCTION HAS COMPLETED.\"\nRCODE = 0\nNEWD1  =  SUBSTR(DATA,1,2)\nNEWDPT =    NEWD1\"DEPT\"\n/*******************************************************/\n/** HERE IS THE IMS CHANGE SECTION.                   **/\n/** SYSA SYSB AND SYSC                                **/\n/*******************************************************/\n  SAY \"T51RENA: WE ARE ENTERING IMS RENAME LOGIC \"\n  \"%IMSALIAS\"  NEW_ACID\n  IF RC = 4 THEN SECRC = \"FUNCTION COMPLETE. TSO AUTHS MAY NEED TO BE\",\n   \"CHECKED.\"\n  RCODE = 0\n  \"TSS RENAME( \"ACID\") ACID(\"NEW_ACID\")\"\n  \"%TSSAUDU \" NEW_ACID\n  \"%TSSAUDR \" ACID\n  IF SYSDSN(\"'SYS1.TSOUSERS(\"NEW_ACID\")'\") /= \"OK\" THEN\n    \"%RXREPRO SYS1.TSOUSERS(\"ACID\") SYS1.TSOUSERS(\"NEW_ACID\")\"\n  \"%UADRENA \"ACID  NEW_ACID\n  /* \"%REPLACE SYS1.TSOUSERS(\"NEW_ACID\")\" ACID NEW_ACID*/\n  \"TSS REP(\"NEW_ACID\") TSOCOMMAND('PROFILE PREFIX(\"NEW_ACID\")')\"\n  \"TSS LIST( \"NEWDPT\") DATA(NAME)\"\n  IF RC = 0 THEN ADDRESS TSO \"TSS MOVE(\"NEW_ACID\") DEPT(\"NEWDPT\")\"\n  Q = OUTTRAP('LINE.')\n  \"LISTC LEVEL(\"ACID\")\"\n  Q = OUTTRAP('NULL.') /* LETS NOT SCREW UP OUR DATA NOW !  */\n  SAY \"I AM RENAMING \"LINE.0 \"DATASETS.\"\n  DO X = 1 TO LINE.0\n    PARSE VAR LINE.X W.1 W.2 W.3 W.4\n    IF W.1 = \"NONVSAM\" THEN DO\n      PARSE VAR W.3 HLQ \".\" LOWLQ\n       SAY \"RENAME '\"W.3\"' '\"NEW_ACID\".\"LOWLQ\"'\"\n      \"RENAME '\"W.3\"' '\"NEW_ACID\".\"LOWLQ\"'\"\n       IF RC /= 0 THEN SAY \"RENAME FOR \"W.3 \"FAILED!\"\n    END\n  END\n  \"%IMSDALIA\" ACID\nIF RCODE /= 0 THEN SECRC = \"ERRORS ENCOUNTERED. CHECK ID STATUS\"\n\"%UADRENAM\" ACID  NEW_ACID\nseeya: nop\nSAY \"T51RENA:\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51REPL": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00Q\\x00\\x955/\\x00\\x98&O\\x14X\\x00)\\x00)\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1998-09-21T14:58:51", "lines": 41, "newlines": 41, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\nARG ACID PROFOLD PROFNEW\nSAY ACID PROFOLD PROFNEW\nPROFHOLD = PROFNEW /* SAVE ORIGINAL PARM FOR T50INS */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\".\") /* REPLACE DOTS WITH SPACES */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\"_\") /* REPLACE BARS WITH SPACES */\nSAY \"T50REPL: \" ACID PROFOLD PROFNEW\nADDRESS ISPEXEC\n/********************************************************************/\n/***  THIS EXEC REPLACES ONE PROFILE IN A TOP SECRET ACID WITH    ***/\n/***  ONE OR MORE OTHER PROFILES. IT REQUIRES THAT T50INS         ***/\n/***  BE AVAILABLE TO DO INSERTIONS.....DIR 26 APRIL 93           ***/\n/********************************************************************/\nWORDNUM = WORDS(PROFOLD)\nIF WORDNUM > 1 THEN DO\n  SECRC = \"YOU MUST SPECIFY ONLY 1 PROFILE FOR REPLACEMENT\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSAY \"T50REPL: CALLING T50FLOC\"\nADDRESS TSO \"%T50FLOC\" ACID PROFOLD\nSAY \"T50REPL: BACK FROM T50FLOC\"\n\" VGET SECRC PROFILE\"\nPLACE = SECRC\nSAY \" PLACE IS \" PLACE\nIF (PLACE = \"ERROR\") | ( PLACE= 0 ) THEN DO\n  SECRC = \"ERROR LOCATING \"PROFOLD \"IN ACID.. REPLACE ABORTED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROFOLD\")\"\nSIGNAL ON ERROR NAME BADPROF\nSAY \"T50REPL: CALLING T50INS\"\nADDRESS TSO \"%T50INS\" ACID PROFHOLD PLACE\nSECRC = \"PROFILE REPLACE COMPLETED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT 00\nBADPROF: NOP\nSECRC = PROFOLD \"WAS IN PLACE \"PLACE\", HOWEVER INSERTION OF \",\n  PROFNEW \"FAILED!\"\n  \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51REPPW": {"ttr": 5387, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x00\\x16\\x7f\\x01\\x005_\\t5\\x00S\\x00S\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2000-12-20T09:35:57", "lines": 83, "newlines": 83, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51REPPW                          **/\n/** LAST MODIFIED    : 11 JUL 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE VALID TSS DEFINED ID                   **/\n/** NEWPW   : A VALID 1 - 8 CHR NEW PASSWORD             **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  ACID IF NOT PASSED AS AN ARG.                       **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         MSG2                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T51FDIV TSSPWDR      **/\n/**                                 T51GDAT              **/\n/**********************************************************/\nARG ACID NEWPW\nIF ACID = \" \" THEN ADDRESS ISPEXEC \"VGET ACID  PROFILE\"\nSAY \"T51REPPW: HAS CONTROL\"\nSAY \"T51REPPW: CALLING T51FDIV\"\nADDRESS TSO \"%T51FDIV \"ACID\nADDRESS ISPEXEC \"VGET MODE PROFILE\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET UIDTABLE PROFILE\"\nADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\nSAY \"T51REPPW: BACK FROM  T51FDIV WITH SECRC OF\" SECRC\nIF SECRC = \"AUTHORIZATION FAILED.\" THEN DO\n  SECRC = \"FAILED. YOUR TOP SECRET AUTHORIZATION IS INADEQUATE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC = \"CUSTDIV\" THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"THAT IS DEFINED AS AN EXTERNAL CUSTOMER. TRY LISTPW\"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    EXIT 00\n    END\n  ELSE DO\n   MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY CHANGEABLE.\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nIF (SECRC = \"CENTRAL\") | (SECRC = \"MASTER\") THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"YOU ARE NOT AUTHORIZED TO CHANGE THAT ID.\"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    EXIT 00\n    END\n  ELSE DO\n   MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY CHANGEABLE.\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nADDRESS TSO \"%T51GDAT \"ACID\" ATTRIBUTES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF INDEX(SECRC,\"SUSPEND\") /=  0 THEN DO\n  MSG2 =  \"THIS ID IS SUSPENDED, YOU MUST UNSUSPEND TO USE\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(\"NEWPW\")\"\nIF MODE = \"BATCH\" THEN DO\n  BJCL.1 = \" TSS REP(\"ACID\") PASSWORD(\"NEWPW\")\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  SECRC = \"THE BATCH FILE WAS UPDATED WITH COMMAND TO REPLACE PWORD\"\n  SIGNAL THEEND\nEND\nADDRESS TSO \"T51GDAT \"ACID\" PASSWORD PW\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF ( SECRC = \"$NOTFOUND\" ) | ( SECRC = \"$BADTSS\" )  THEN DO\n  MSG2 = \"THE IDS PASSWORD IS NOT RETRIEVABLE. CONTACT TECH SUPPORT\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nELSE\n  SECRC = \"THE IDS PASSWORD IS NOW  = \"SECRC\nTHEEND: NOP\nADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51RESET": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00S\\x00\\x993?\\x00\\x993?\\x102\\x00\\x0f\\x00\\x0f\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-11-29T00:00:00", "modifydate": "1999-11-29T10:32:53", "lines": 15, "newlines": 15, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\nsignal off error\narg acid newpass\nrcode = 0\naddress tso\nsay \"tss rem(\"acid\") asuspend \"\n\"tss rem(\"acid\") asuspend \"\nrcode = rcode + rc\nsay \"tss rem(\"acid\") suspend \"\n\"tss rem(\"acid\") suspend \"\nrcode = rcode + rc\nsay \"tss rep(\"acid\") password(\"newpass\")\"\n\"tss rep(\"acid\") password(\"newpass\")\"\nrcode = rcode + rc\nexit rcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51TSO": {"ttr": 5389, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x005o\\x01\\x01\\t_\\x155\\x01[\\x01[\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-12-21T00:00:00", "modifydate": "2001-04-05T15:35:08", "lines": 347, "newlines": 347, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51TSO                            **/\n/** LAST MODIFIED    : 21 SEP 98                         **/\n/**********************************************************/\n/**********************************************************/\n/** CHANGED TO MAKE MORE GENERIC                         **/\n/**********************************************************/\n/** CHANGED TO ALLOW DEFINITION OF UNOWNED RESOURCES     **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** VAR                VALID VALUES                      **/\n/** ACTION  : DEFAULTS ADDPROC ADDACCT DEFACCT DEFPROC   **/\n/**           DEFSIZE  DEFUNIT MAXSIZE REMACCT TSOAUTH   **/\n/** ACID    : ANY VALID TSS ACID                         **/\n/** LPROC   : ANY VALID PREDEFINED (TO TSS) PROC         **/\n/** ACCTNUM : ANY VALID PREDEFINED (TO TSS) ACCOUNT      **/\n/** UNIT    : ANY VALID UNIT                             **/\n/** SIZE    : ANY VALID SIZE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 16                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : NOT NEEDED, BUT WILL USE        **/\n/** EXECS CALLED WITHIN THIS EXEC : T51INS               **/\n/**                                                      **/\n/**********************************************************/\nSYSENV = SYSVAR(SYSENV)\nMSG2 = \"NO UNUSUAL CONDITIONS WERE FOUND.\"\nARG ACTION ACID LPROC ACCTNUM UNIT SIZE\n/*                                             */\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET BOOKSEC PROFILE\"\nEND\nELSE DO\n  AUTHNUM = 10\n  BOOKSEC = \"NO\"\nEND\n/*IF SUBSTR(ACID         ,8,1) = \"@\" THEN DO                      */\n/*  MSG2 = \"WARNING: THE ID YOU HAVE GIVEN ME IS A GHOST ID.\"     */\n/*  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"   */\n/*  ELSE SAY SECRC                                                */\n/*END                                                             */\nIF (LENGTH(ACID) > 8) & ( SUBSTR(ACID        ,8,1) \u00ac= \"@\" ) THEN DO\n  SECRC = \"THE ID YOU HAVE GIVEN ME IS TOO LONG MAX IS 7 CHRS\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ELSE SAY SECRC\n  EXIT 00\nEND\nSIGNAL ON ERROR NAME NOTSSID\nQ = OUTTRAP(DROPIT.,5)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nSIGNAL OFF ERROR\nX5 = \"OK\"\nSAY \"T51TSO: RECEIVED  CONTROL ACTION=\" ACTION \"ACID=\"ACID\nSAY \"T51TSO: PROC=\"LPROC\" ACCT=\"ACCTNUM\" UNIT=\"UNIT \"SIZE=\"SIZE\n/**************************************************/\n/* IF THE RESOURCE IS NOT OWNED ADD IT TO TSODEPT */\n/**************************************************/\nIF (AUTHNUM > 8) & (ACTION \u00ac= \"TSOAUTH\")  THEN DO\n  Q = OUTTRAP(DROPOUT.,5)\n  /* SAY \"T51TSO: CHECKING THAT ALL RESOURCES ARE OWNED \" */\n  TSS_RESOURCE = LPROC\n  ADDRESS TSO \" TSS WHOOWNS TSOPROC(\"LPROC\")\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE LPROC TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOPROC(\"LPROC\")\"\n  END\n  TSS_RESOURCE = ACCTNUM\n  ADDRESS TSO \" TSS WHOOWNS TSOACCT(\"ACCTNUM\")\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE ACCTNUM TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOACCT(\"ACCTNUM\")\"\n  END\n  TSS_RESOURCE = \"JCL\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(JCL)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE JCL AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(JCL)\"\n  END\n  TSS_RESOURCE = \"OPER\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(OPER)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE OPER AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(OPER)\"\n  END\n  TSS_RESOURCE = \"ACCT\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(ACCT)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE ACCT AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(ACCT)\"\n  END\n  SAY \"T51TSO: RESOURCE OWNER CHECKING COMPLETED.\"\nEND\n/**************************************************/\n/* END OF OWNERSHIP RESOLUTION.                   */\n/**************************************************/\nQ = OUTTRAP(OUT.,5)\nSIGNAL ON ERROR NAME SEEYA\n/* ACTION =DEFAULTS */\nIF (ACTION = \"DEFAULTS\") | (ACTION = \"DEFTSO\") THEN DO\n  SAY \"T51TSO: ATTEMPTING TO DEFINE ALL TSO AUTHS\"\n  SAY \"T51TSO: REMOVING ANY OLD PERMISSIONS FOR\" LPROC ACCTNUM\n  IF ACCTNUM \u00ac= \"NIL\" THEN DO\n    IF BOOKSEC = \"YES\" THEN\n      X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS*/\n    ELSE X5 = \"OK\"\n  END\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOAUTH(JCL)\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLPROC(\"LPROC\")\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLSIZE(\"SIZE\")\"\n  SAY \"T51TSO: DEFINING NEW TSO DEFAULTS.\"\n  SIGNAL ON ERROR NAME NOTSSDEF\n  Q = OUTTRAP(OUT.,5)\n  TSS_RESOURCE = \"LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\n  TSS_RESOURCE = \"ACCT NUM\" ACCTNUM\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  TSS_RESOURCE = \"JCL\"\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOAUTH(JCL)\"\n  SIGNAL ON ERROR NAME SEEYA\n  Q = OUTTRAP(OUT.,5)\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOUNIT(\"UNIT\")\"\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLPROC(\"LPROC\")\"\n  IF ACCTNUM \u00ac= \"NIL\" THEN\n    ADDRESS TSO \" TSS ADD(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLSIZE(\"SIZE\")\"\n  SAY \"T51TSO: CALLING T51INS FOR PROFILE INSERTION\"\n  ADDRESS TSO \"%T51INS\" ACID \"TSOPROF 9\"\n  SAY  \"T51TSO: BACK FROM T51INS WITH RC OF\" RC\nEND\nIF ACTION = \"ADDPROC\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM PROC\" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \"TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING ID TO PROC\" LPROC\n  ADDRESS TSO \"TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\nEND\nIF ACTION = \"ADDACCT\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM ACCT\" ACCTNUM\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME NOBOOK\n  SAY \"T51TSO: PERMITTING ID TO ACCT\" ACCTNUM\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"DEFACCT\" THEN DO\n  SIGNAL OFF ERROR\n  ADDRESS TSO \"%T51GDAT \" ACID \"TSOLACCT  TSO\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  BOOK = SECRC\n  IF BOOK = \"\" THEN SAY \"T51TSO: NO DEFAULT BOOK NUMBER DEFINED \"\n  IF BOOK = \"\" THEN BOOK  = \"$NOTFOUND\"\n  /********************************************************/\n  /* DOES HE HAVE A CURRENT DEFAULT TSS BOOK NUMBER ??    */\n  /********************************************************/\n  IF (BOOK = \"$BADTSS\") |  (BOOK = \"$NOTFOUND\") THEN NOP\n  ELSE DO\n    /********************************************************/\n    /* CAN HE OVERLAY THE CURRENT DEFAULT BOOK NUMBER ??    */\n    /********************************************************/\n    BOOK = SECRC\n    IF BOOKSEC = \"YES\" THEN\n      X5 = TSSCHECK(\"BOOKNUM\",BOOK,\"UPDATE\")  /* CAN THEY DO THIS */\n    ELSE X5 = \"OK\"\n    SAY \"T51DEL: TSSCHECK RETURN CODE IS \" X5\n    IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKREMA\n  END\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SAY \"T51TSO: REVOKING ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME NOBOOK\n  SAY \"T51TSO: PERMITTING ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SAY \"T51TSO: MAKING IDS DEFAULT ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"DEFPROC\" THEN DO\n  SIGNAL OFF ERROR\n  SAY \"T51TSO: REVOKING LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLPROC(\"LPROC\")\"\n  PDSN = \"'MVS.TSO.PROCLIB(\"LPROC\")'\"\n  /* SAY SYSDSN(PDSN) */\n  IF SYSDSN(PDSN)  = \"MEMBER NOT FOUND\" THEN DO\n    MSG2 = \"LOGON PROC CHANGED, BUT \"PDSN\" WAS NOT FOUND\"\n    IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    SAY \"T51TSO:\" MSG2\n  END\nEND\nIF ACTION = \"DEFSIZE\" THEN DO\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON SIZE\" SIZE\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLSIZE(\"SIZE\")\"\nEND\nIF ACTION = \"DEFUNIT\" THEN DO\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON UNIT\" UNIT\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOUNIT(\"UNIT\")\"\nEND\nIF ACTION = \"MAXSIZE\" THEN DO\n  SAY \"T51TSO: MAKING IDS MAXIMUM REGION SIZE\" SIZE\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOMSIZE(\"SIZE\")\"\nEND\nIF ACTION = \"REMACCT\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM ACCOUNT \" ACCTNUM\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"REMPROC\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM LOGON PROC \" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"TSOAUTH\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM AUTHS \" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOAUTH(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING ID TO \" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOAUTH(\"LPROC\")\"\nEND\nSAY \"T51TSO: CHECKING FOR TSO AREA COMPLETENESS.\"\nSAY \" \"\nSIGNAL OFF ERROR\nIF (ACTION \u00ac= \"DEFAULTS\") & (ACTION \u00ac= \"DEFTSO\") THEN DO\n  ADDRESS TSO \"%T51GDAT \"ACID\" TSOLACCT TSO\"\n  IF SYSENV = \"FORE\" THEN\n    ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  DEFAULT_ACCT = SECRC\n  SAY \"T51TSO: IDS DEFAULT ACCOUNT IS \" DEFAULT_ACCT\n  ADDRESS TSO \"%T51GDAT \"ACID\" TSOLPROC TSO\"\n  IF SYSENV = \"FORE\" THEN\n    ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  DEFAULT_PROC = SECRC\n  SAY \"T51TSO: IDS DEFAULT LPROC IS \" DEFAULT_PROC\n  IF (DEFAULT_PROC = \"$NOTFOUND\") THEN DO\n    MSG2 = \"ID HAS NO DEFAULT PROC IN TSS,\"\n    MSG2 = MSG2 \"MAY NEED THE DEFTSO CMD ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  IF (DEFAULT_ACCT = \"$NOTFOUND\") THEN DO\n    MSG2 = \"ID HAS NO DEFAULT ACCOUNT IN TSS,\"\n    MSG2 = MSG2 \"MAY NEED THE DEFTSO CMD ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSAY \"T51TSO: FALL THRU AREA REACHED. SETTING MSG AND EXITING\"\nSAY \" \"\nSECRC = ACTION \"FUNCTION COMPLETED\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nELSE SAY SECRC MSG2\nEXIT 0\nSEEYA: NOP\nSAY \"T51TSO: **FATAL** ERROR OCCURRED IN LINE :\" SIGL\nTEMP = SOURCELINE(SIGL)\nSAY \"T51TSO: LINE\" SIGL \"=\" TEMP\nIF RC = 8 THEN DO\n  SECRC = \"FUNCTION FAILED. CONFIRM VALIDITY (OWNERSHIP) OF DATA\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY \"T51TSO: *************************************************\"\n  SAY \"T51TSO: EXITING WITH RC = 08 PROBABLE TSS COMMAND FAILURE\"\n  SAY \"T51TSO: *************************************************\"\n  EXIT 8\nEND\nNOBOOK: NOP\nSAY \"T51TSO: ERROR OCCURRED IN LINE :\" SIGL\nTEMP = SOURCELINE(SIGL)\nSAY \"T51TSO: LINE\" SIGL \"=\" TEMP\nIF RC = 8 THEN DO\n  SECRC = \"FUNCTION FAILED. BOOK NUMBER MAY NOT EXIST \"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY \"T51TSO: EXITING WITH RC = 08 PROBABLE TSS OWNERSHIP ERROR.\"\n  EXIT 8\nEND\nSAY \"T51TSO: *************************************************\"\nSAY \"T51TSO: EXITING WITH RC = 16 !  FATAL ERROR.\"\nSAY \"T51TSO: *************************************************\"\nEXIT 1\nNOTSSDEF: NOP\nSAY \"T51TSO: A PERMIT ERROR OCCURRED IN LINE:\" SIGL\nSECRC = \"ABORTED.\" TSS_RESOURCE\" IS UNOWNED IN TSS.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY OUT.1\nSAY OUT.2\nSAY OUT.3\nSAY \"T51TSO: \"SECRC\nEXIT 8\nNOTSSID: NOP\nSAY \"T51TSO: THE ID YOU HAVE GIVEN DOES NOT EXIST\"\nSECRC = \"ABORTED. NO SUCH TOP SECRET ID, UNDER YOUR OWNERSHIP.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nBOOKAUTH: NOP\nSAY TSSCHECK RCODE WAS X5\nSECRC = \"YOU ARE NOT AUTHORIZED FOR THIS BOOK FUNCTION. BOOK= \" ACCTNUM\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nBOOKREMA: NOP\nSAY TSSCHECK RCODE WAS X5\nSECRC = \"YOU CANT OVERLAY BOOK VALUE = \"BOOK\". TRY ADDACCT INSTEAD.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nTSSNOADD: NOP\nSAY \"T51TSO: AN OWNERSHIP ERROR OCCURRED IN LINE:\" SIGL\nSECRC = \"ABORTED.\" TSS_RESOURCE\" OWNERSHIP RESOLUTION FAILED IN TSS.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51TSSIM": {"ttr": 3854, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x009\\x00\\x955/\\x01\\x00\\x05O\\x115\\x00*\\x00*\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-02-23T11:35:39", "lines": 42, "newlines": 42, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* ROUTES THE OUTPUT OF A TSSSIM COMMAND TO A DATASET OF YOUR CHOICE */\n/*********************************************************************/\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n SAY \"ACID RTYPE RNAME FACILITY ACCESS DSOUT\"\n SAY ACID RTYPE RNAME FACILITY ACCESS DSOUT\n IF RTYPE = \"VOLUME\" THEN RTYPE = \"DASDVOL\"\n IF RTYPE = \"VOL\" THEN RTYPE = \"DASDVOL\"\n ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"ALLOC DDN(SIM$$OUT) DSN(\"DSOUT\") SHR REUS\"\n OUT.1 = \"  LOGON ACID(\"ACID\") FAC(\"FACILITY\") TRACE \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") MOD REUS\"\n OUT.1 = \"  $\"RTYPE\"(\"RNAME\") ACCESS(\"ACCESS\")  \"\n IF ACCESS = \".NA.\" THEN\n   OUT.1 = \"  $\"RTYPE\"(\"RNAME\")\"\n IF RTYPE = \"DSN\" THEN\n   OUT.1 = \"  $\"RTYPE\"('\"RNAME\"') ACCESS(\"ACCESS\")  \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \" FREE DDN(OUTFILE)\"\n ADDRESS TSO \"ALLOC DDN(SIM$$IN) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"TSSSIM\"\n ADDRESS TSO \" FREE DDN(SIM$$IN)\"\n ADDRESS TSO \" FREE DDN(SIM$$OUT)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51UNDEL": {"ttr": 3856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00W\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00:\\x00:\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:57", "lines": 58, "newlines": 58, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED UADS STEP .....................              **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50UNDEL                          **/\n/** LAST MODIFIED    : 31 MAR 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID TO BE RECREATED                   **/\n/** MODE    : THE MODE \"ONLINE\" OR \"BATCH\"               **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS1     : A FLAT FILE LRECL 80                       **/\n/** DS2     : A FLAT FILE LRECL 80                       **/\n/** DSBACK  : A PDS CONATAINING MEMBER (ACID)            **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (BUT IT NEEDS VGETS !)      **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : RXREPRO T44CON       **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS TSO\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nACID_COPY = \"'\"DSBACK\"(\"ACID\")'\"\nUADS_COPY = \"'\"UADSBACK\"(\"ACID\"0)'\"\nIF SYSDSN(ACID_COPY) \u00ac= \"OK\" THEN DO\n  say \"enqueue failed on\" acid_copy\n  secrc = \"Acid not resurrectable, no backup available. sorry\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 00\nEND\nIF MODE = \"ONLINE\" THEN DO\n  /* \"SMCOPY FDS(\"ACID_COPY\") TDS(\"DS1\") NOTRANS\"*/\n  ADDRESS TSO \"%RXREPRO \" ACID_COPY DS1\n  ADDRESS TSO \"%T50ICOMP  REBUILD BYPASS\"\n  ADDRESS TSO \"SUBMIT\" DS2\n  secrc = \"Job submitted to resurrect id \" acid\". check uads entries\"\n  END\nELSE DO\n  BJCL.1 = \"  %RXREPRO \"ACID_COPY DS1\n  BJCL.2 = \"  ISPSTART CMD(%T50ICOMP REBUILD ACID  ) NEWAPPL(TSS)\"\n  BJCL.3 = \"  SUBMIT\" DS2\n  BJCL.4 = \"  \"\n  ADDRESS MVS \"EXECIO 4 DISKW BJCL ( FINIS STEM BJCL.)\"\n  secrc = \"Batch file has been updated with resurrection stream.\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T51USUS": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x01\\x00\\x16\\x7f\\x01\\x01\\t_\\t@\\x00F\\x00F\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2001-04-05T09:40:12", "lines": 70, "newlines": 70, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** CHANGED THE TSOUSERS LOOKUP                          **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51USUS                           **/\n/** LAST MODIFIED    : 04 apr 2001                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ID TO UNSUSPEND                        **/\n/** ARG2    :                                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : CALLS PGM=IMSU200    **/\n/**                                                      **/\n/**********************************************************/\n ARG ACID MODE PWVAL\n /*******************************************************/\n /* dont use mode currently but it is here if I need it */\n /*******************************************************/\n say \"T51USUS: in control with parms \" acid mode pwval\n SYSENV = SYSVAR(SYSENV)\n OTT = OUTTRAP(OUT,0)  /* TRAP EVERYTHING */\n SIGNAL OFF ERROR\n ADDRESS TSO \"%T51GDAT \"ACID\" ATTRIBUTES\"\n ADDRESS ISPEXEC \"VGET SECRC \"\n ADDRESS TSO \"TSS REMOVE(\"ACID\") SUSPEND\"\n IF PWVAL = \"SAME\" THEN  DO\n   say \"T51USUS: issuing  address tso tss rep(\"acid\") password(*,60)\"\n   ADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(*,60)\"\n END\n ELSE DO\n   say \"T51USUS: issuing address tso tss rep(\"acid\") password(\"pwval\")\"\n   ADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(\"PWVAL\")\"\n END\n say \"T51USUS: attributes are \" secrc\n IF POS(\"ASUSPEND\",SECRC) \\= 0 THEN ADMIN_SUSPEND = \"YES\"\n IF POS(\"ADMIN SUSPEND\",SECRC) \\= 0 THEN ADMIN_SUSPEND = \"YES\"\n SIGNAL ON ERROR NAME BADID\n say \"T51USUS: received control env is \"sysenv\n CHKACID = ACID\n IF LENGTH(ACID) = 8 THEN CHKACID = SUBSTR(ACID,1,7)\n IF ( SYSENV = \"FORE\" ) & ( ACID= \" \" ) THEN\n   ADDRESS ISPEXEC \"VGET ACID PROFILE\"\n SECRC = \"NO UADS OR TOP SECRET ENTRY WAS FOUND FOR\" ACID\n say \"T51USUS: calling TSS for ACID\" acid\n IF ADMIN_SUSPEND = \"YES\" THEN DO\n   say \"T51USUS: ACID is admin suspended removing asuspend\"\n   ADDRESS TSO \" TSS REM(\"ACID\") ASUSPEND\"\n   say \"T51USUS: ACID was Admin suspended setting message\"\n   MSG2 = \"WARNING: ID WAS MANUALLY SUSPENDED BY AN ADMINISTRATOR!\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n END\n SECRC = \"ID UNSUSPEND SUCCESSFUL FOR \"ACID\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n else say \"T51USUS:\" secrc\n EXIT 00\n BADID: RCODE = RC\n say \"T51USUS: entering error recovery from line \" sigl \"code = \" rcode\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n EXIT 08\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52ADD": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x051\\x00\\x05\\x00\\x955/\\x01\\x04\\t/\\x08\\x04\\x01\\x7f\\x01s\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.49", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2004-04-01T08:04:05", "lines": 383, "newlines": 371, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T52ADD                            **/\n/** LAST MODIFIED    :  2 Jul 2003                       **/\n/**********************************************************/\n/** Added smarts to routine to insert the password parm  **/\n/** on the create if it doesn't exist and honor it if it **/\n/** does dir july 2 2003                                 **/\n/**********************************************************/\n/** added variable for default department vget           **/\n/**********************************************************/\n/** changed acid variable manipulation so that the acid  **/\n/** variable remains a little more stable.               **/\n/**                                .....DIR 19 AUGUST 96 **/\n/**********************************************************/\n/**********************************************************/\n/** ADDED LOGIC TO DETERMINE IF ID HAS DSNS CATLGD IN    **/\n/** MASTER CAT YET HAS NO ALIAS        DIR  11 MAY 95    **/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nSAY \"T52ADD: CONTROL RECEIVED PARMS = \" ACID MODE\nADDRESS ISPEXEC\n\"VGET AUD       PROFILE\"\n\"VGET DEF       PROFILE\"\n\"VGET DS1       PROFILE\"\n\"VGET DS2       PROFILE\"\n\"VGET DS3       PROFILE\"\n\"VGET DS4       PROFILE\"\n\"VGET DS5       PROFILE\"\n\"VGET DS6       PROFILE\"\n\"VGET MSG2      PROFILE\"\n\"VGET PROD      PROFILE\"\n\"VGET TSOSIZE   PROFILE\"\n\"VGET TSOUNIT   PROFILE\"\n\"VGET TSOPROC   PROFILE\"\n\"VGET TVER      PROFILE\"\nSIGNAL OFF ERROR\n/**********************************************************/\n/** below I am checking that the id doesnot have dsns    **/\n/** cataloged to the master catalog. if it does the      **/\n/** user wont be able to catalog his own datasets. this  **/\n/** will cause allocate errors that are hard to track.   **/\n/** i may make this a seperate callable exec but for     **/\n/** now it is included here    dave 11 may 95            **/\n/**********************************************************/\nDATEHOLD = DATE('U')\nMONTHNUM = SUBSTR(DATEHOLD,1,2)\nADDRESS TSO \"%T52GDAT \"ACID \"NAME\"\nOLDID = RC\noutct = 40\nBOOK = \"NIL\"\nBOOK1 = \"NIL\"\nSAY \"TSA101D: T52ADD  EXISTANCE CHECK RC IS \" OLDID\nIF OLDID = 0 THEN DO\n  msg2 = \"This id exists currently, readdition will fail upon\",\n  \"execution\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\n/**************************************/\n/* get the default department         */\n/**************************************/\nADDRESS ISPEXEC \"VGET DEFDEPT PROFILE\"\nADDRESS ISPEXEC \"VGET TSOALIAS PROFILE\"\nIF TSOALIAS = \"YES\" THEN DO\n  ADDRESS TSO \"LISTC ENT('\"ACID\"')\"\n  SAY \"TSA101D: T52ADD  ALIAS CHECK IS \" RC\n  ALIAS_CODE = RC\n  ADDRESS TSO \"LISTC LEVEL('\"ACID\"')\"\n  SAY \"TSA101D: T52ADD  LEVEL CHECK IS \" RC\n  LEVEL_CODE = RC\n  IF (ALIAS_CODE \u00ac= 0) & (LEVEL_CODE =0)  THEN DO\n    msg2 = \"The id has no alias, yet has dsns cataloged, expect\",\n    \"severe allocation errors\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSIGNAL ON ERROR NAME ABORT\n/**********************************************************/\n/** END OF DSN ALIAS / LEVEL CHECKING                    **/\n/**********************************************************/\nLINE.  = \" \"\nALEN   = LENGTH(ACID)\nBILLA  = \"N\"\nCODE   = 0\nCURSOR = \"NAME\"\nDEFINE = \"NAME('\"NAME\"') DEPT(D0) TYPE(USER)\"\nFIRST2 = SUBSTR(ACID,1,2)\nGOTDEF = \"NO\"\nLOGON  = TSOPROC\nNDEPT  = FIRST2||\"DEPT\"\nif defdept /= \"NONE\" then ndept = defdept\nPROF   = \" \"\nPWORD  = \"PASSWORD,60,EXP\"\nSECDEF. = \" \"\nsecrc  = \"T52ADD did not complete normally. please check the id.\"\nS2     = ALEN - 1\nTYPE   =  \"USER\"\nWARNED = \"NO\"\n\"VPUT SECRC PROFILE\"\nPW = \"PASSWORD\"\nDPNL   = \"SPIADD\"\nBASIC_ACID = \" \"\nAUDU.0 =   1\nAUDU.1 =   \"%ADDLOCAL\" ACID NDEPT\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER) PASSWORD(\"PW\",60,EXP)\"\n/****************************************************/\n/** the tso authority stream is below              **/\n/****************************************************/\n/*                                                                  */\n/*batchtso.0 = 3                                                    */\n/*batchtso.1 = \" \"                                                  */\n/*batchtso.2 = \"ISPSTART CMD(%\"TVER\"TSO DEFAULTS +\"                 */\n/*batchtso.3 = \" \"ACID LOGON BOOK1 TSOUNIT TSOSIZE\") NEWAPPL(TSS)\"  */\n/*onlintso.0 = 1                                                    */\n/*onlintso.1 =\"%\"TVER\"TSO DEFAULTS\" ACID LOGON BOOK1 TSOUNIT TSOSIZE*/\n/*                                                                  */\n/****************************************************/\n/** beginning of the panel loop                    **/\n/** beginning of the panel loop                    **/\n/****************************************************/\nAGAIN: NOP\nCALL FILLSCR\n\"DISPLAY PANEL(\"DPNL\")  CURSOR(\"CURSOR\")\"\nRCODE = RC\nif enum = \" \" then enum = \"000000    initial\"\nNAME = TRANSLATE(NAME,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSAY \"TSA101D: T52ADD  PANEL RCODE IS \"RCODE\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ERRMSG\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\nGETNAME: NOP\nCNT1 = 0\nNORMAL: NOP\nMEMBER = mem\nIF MEM = \"\" THEN MEMBER = NDEPT\nmem = member\nSAY \"TSA101D: CHECKING FOR DEFAULT DEPT AUTHORITIES\" DEF\"(\"MEMBER\")\"\nIF SYSDSN(\"'\"DEF\"(\"MEMBER\")'\") = \"OK\" THEN DO\n  say \"tsa101d: T52ADD  default authority group found for in \" def bin\n  address tso \"alloc ddn(secdef) dsn('\"def\"(\"member\")') shr reus\"\n  address mvs \"execio * diskr secdef ( finis stem secdef.)\"\n  address tso \"free ddn(secdef)\"\n  /******************************************************/\n  /***                                                ***/\n  /*** NOTE: THE FIRST LINE OF THE DSN MUST HAVE A    ***/\n  /*** CREATE PARM IN IT! IF THERE IS NO MEMBER I     ***/\n  /*** ASSIGN A VALUE TO SECDEF.1                     ***/\n  /***                                                ***/\n  /******************************************************/\n  SECDEF.1 = \"NAME('\"NAME\"')\" SECDEF.1\n  GOTDEF = \"YES\"\nEND\nELSE Do\n  secdef.1 = define /* if no member we just create a 1 liner */\n  if enum /= \" \" then\n    secdef.2 = \"TSS add(\"acid\") instdata('\"enum\"')\"\nEND\nsay \"T52ADD: secdef.1 is\" secdef.1\nsay \"T52ADD: secdef.2 is\" secdef.2\nDO T = 1 TO 40\n  /******************************************************/\n  /***                                                ***/\n  /*** ONCE HERE THERE HAS TO BE A SECDEF.1 VALUE AND ***/\n  /*** IT HAS IS    COMPRISED OF VALID 'CREATE' PARMS ***/\n  /*** FOR TOP SECRET. THE REST OF THE SECDEF. STRING ***/\n  /*** MAY CONTAIN commands to be issued by the       ***/\n  /*** system sight unseen.                           ***/\n  /******************************************************/\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \" T52ADD: $$ substitution string found in secdef\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \" T52ADD: $DEPT$ substitution string found in secdef\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$ENUM$\") /= 0 then do\n    say \" T52ADD: $ENUM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$ENUM$' q2\n    secdef.t = q1||Enum||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$MEM$\") /= 0 then do\n    say \" T52ADD: $MEM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$MEM$' q2\n    secdef.t = q1||member||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$OPID$\") /= 0 then do\n    say \" T52ADD: $OPID$ substitution string found in secdef\"\n    parse var secdef.t q1 '$OPID$' q2\n    opid = substr(acid,5,3)\n    secdef.t = q1||opid||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  LINE.T =  strip(secdef.t)\n  say t line.t\nEND\nSCRDISP: NOP\nCALL FILLSCR\nMSG=\"CHANGE DEFAULT COMMAND STREAM IF NEEDED AND HIT ENTER.\"\nIF GOTDEF = \"NO\" THEN\n  MSG=\"NO DEFAULT AUTHORITY STREAM FOUND. ENTER COMMANDS.\"\nPNLDISP: NOP\n\"ISPEXEC DISPLAY PANEL(\"DPNL\")\"\nRCODE = RC\nSAY \"T52ADD: PANEL RCODE IS \"RCODE\nIF MEM /= MEMBER THEN SECDEF. = \" \"\nIF MEM /= MEMBER THEN SIGNAL NORMAL\nNAME = SUBSTR(NAME                  ,1,20)\nCALL FILLDOT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ABORT\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\n/******************************************************************/\n/******************************************************************/\nCOMMIT: NOP\n/*\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"              \"\nLINE.1 = DEFINE\n*/\nIF PW \u00ac= \" \" THEN PWORD = PW||\",60,EXP\"\nELSE PW = \"PASSWORD\"\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T52ADD: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1= \"TSS CREATE(\"ACID\") password(\"pword\")  +\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  ADDRESS MVS \"EXECIO \"OUTCT\" DISKW BJCL ( FINIS STEM LINE.)\"\n  /**********************************************************/\n  /*ADDRESS MVS,                                               */\n  /* \"EXECIO \"batchtso.0\" DISKW BJCL ( FINIS STEM batchtso.)\"  */\n\n  SAY \"T52ADD: WRITING DATA TO BJCL DDNAME\"\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM AUDU.)\"\n  CODE = RC\n  IF CODE = 0 THEN SECRC =\"BATCH FILE UPDATED WITH ADD COMMANDS.\"\n  SIGNAL OFF ERROR\n  SIGNAL BYE1\nEND\nTSSCMD = \"YES\"\nADDRESS TSO\nSAY \"T52ADD: ISSUING THE TSS ADD COMMAND FOR THE ID\"\nif index(line.1,\"PASSWORD\") = 0 then do\n  line.1 = line.1 \"PASSWORD(\"PW\",60,EXP)\"\n  SAY \"T52ADD: Inserting default password into create stream\"\nend\nSAY \"T52ADD: TSS CRE(\"ACID\")\" LINE.1\n\"TSS CREATE(\"ACID\")\"  LINE.1\nCODE = RC\nSAY \"T52ADD: THE TSS ADD COMMAND FINISHED WITH A RCODE OF \" CODE\nSIGNAL OFF ERROR\nDO T = 2 TO OUTCT\n   say \"T52ADD: issuing command:\" line.t\n   IF LINE.T < > \" \" THEN\n   ADDRESS TSO \" \"LINE.T\nEND\n/* ADDRESS TSO \"%TSSAUDU \" ACID    */\nSPACES= \"                                                          \"\nSYSDATE = DATE(U)\nBYE:  NOP\nSIGNAL OFF ERROR\nIF  MODE= \"SKIPIT\" THEN DO\n  SAY \"T52ADD: VERSION 5.2 TSO DEFAULTS BEING SET\"\n  BOOK1 = WORD(BOOK,1)\n  rcode = 0\n  do cmdnum = 1 to audu.0\n    say \"T52ADD: issuing cmd : \"onlintso.cmdnum\n    address tso onlintso.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T52ADD: rcode from cmd is \" holdrc\n  end\n  do cmdnum = 1 to audu.0\n    say \"T52ADD: issuing cmd : \"audu.cmdnum\n    address tso audu.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T52ADD: rcode from cmd is \" holdrc\n  end\n  ADDRESS ISPEXEC\n  IF RCODE > 0 THEN DO\n    \"VGET SECRC PROFILE\"\n    msg2 = \"defaults tso setup has failed, check book authorities\"\n    \"VPUT MSG2 PROFILE\"\n    SIGNAL BYE1\n  END\n  SAY \"T52ADD: VERSION 5.0 TSO DEFAULTS HAVE BEEN SET\"\nEND\nJUSTUADS: NOP\nCODE = RC\nSIGNAL ON ERROR NAME BADALIAS\n\nif code = 0 then secrc =\"TSA202I: ACID added. no errors encountered.\"\nBYE1:  NOP\nSIGNAL OFF ERROR\nADDRESS ISPEXEC\n\"VPUT SECRC PROFILE\"\n DATAAREA = ACID\n\"VPUT DATAAREA PROFILE\"\nEXIT 0\nERRMSG: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA201E: Errors encountered. check acid status \"\n  SIGNAL BYE1\nBADALIAS: NOP\n  IF CODE = 0 THEN\n    secrc= \"alias addition failed check acid status \"\n  else secrc = secrc \"and alias addition failed\"\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  SIGNAL BYE1\nABORT: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA200E: Function aborted. acid not added. SIGL:\" sigl\n  SIGNAL BYE1\n/****************************************************************/\n/*  ERROR ROUTINE MESSAGE DISPLAYS.........DIR                  */\n/****************************************************************/\nFILLDOT: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE.1 = LINE1\n  LINE.2 = LINE2\n  LINE.3 = LINE3\n  LINE.4 = LINE4\n  LINE.5 = LINE5\n  LINE.6 = LINE6\n  LINE.7 = LINE7\n  LINE.8 = LINE8\n  LINE.9 = LINE9\n  LINE.10= LINE10\n  LINE.11= LINE11\n  LINE.12= LINE12\n  LINE.13= LINE13\n  LINE.14= LINE14\n  LINE.15= LINE15\nRETURN\nFILLSCR: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE1 = LINE.1\n  LINE2 = LINE.2\n  LINE3 = LINE.3\n  LINE4 = LINE.4\n  LINE5 = LINE.5\n  LINE6 = LINE.6\n  LINE7 = LINE.7\n  LINE8 = LINE.8\n  LINE9 = LINE.9\n  LINE10= LINE.10\n  LINE11= LINE.11\n  LINE12= LINE.12\n  LINE13= LINE.13\n  LINE14= LINE.14\n  LINE15= LINE.15\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52ADDO": {"ttr": 7173, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x03\\x05\\x0f\\x01\\x03\\x05\\x0f\\x14B\\x01j\\x01j\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-02-19T00:00:00", "modifydate": "2003-02-19T14:42:59", "lines": 362, "newlines": 362, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T52ADD                            **/\n/** LAST MODIFIED    :  2 feb 2000                       **/\n/**********************************************************/\n/** added variable for default department vget           **/\n/**********************************************************/\n/** CHANGED ACID VARIABLE MANIPULATION SO THAT THE ACID  **/\n/** VARIABLE REMAINS A LITTLE MORE STABLE.               **/\n/**                                .....DIR 19 AUGUST 96 **/\n/**********************************************************/\n/**********************************************************/\n/** ADDED LOGIC TO DETERMINE IF ID HAS DSNS CATLGD IN    **/\n/** MASTER CAT YET HAS NO ALIAS        DIR  11 MAY 95    **/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nSAY \"T52ADD: CONTROL RECEIVED PARMS = \" ACID MODE\nADDRESS ISPEXEC\n\"VGET AUD       PROFILE\"\n\"VGET DEF       PROFILE\"\n\"VGET DS1       PROFILE\"\n\"VGET DS2       PROFILE\"\n\"VGET DS3       PROFILE\"\n\"VGET DS4       PROFILE\"\n\"VGET DS5       PROFILE\"\n\"VGET DS6       PROFILE\"\n\"VGET MSG2      PROFILE\"\n\"VGET PROD      PROFILE\"\n\"VGET TSOSIZE   PROFILE\"\n\"VGET TSOUNIT   PROFILE\"\n\"VGET TSOPROC   PROFILE\"\n\"VGET TVER      PROFILE\"\nSIGNAL OFF ERROR\n/**********************************************************/\n/** below I am checking that the id doesnot have dsns    **/\n/** cataloged to the master catalog. if it does the      **/\n/** user wont be able to catalog his own datasets. this  **/\n/** will cause allocate errors that are hard to track.   **/\n/** i may make this a seperate callable exec but for     **/\n/** now it is included here    dave 11 may 95            **/\n/**********************************************************/\nDATEHOLD = DATE('U')\nMONTHNUM = SUBSTR(DATEHOLD,1,2)\nADDRESS TSO \"%t52GDAT \"ACID \"NAME\"\nOLDID = RC\noutct = 40\nBOOK = \"NIL\"\nBOOK1 = \"NIL\"\nSAY \"TSA101D: T52ADD  EXISTANCE CHECK RC IS \" OLDID\nIF OLDID = 0 THEN DO\n  msg2 = \"This id exists currently, readdition will fail upon\",\n  \"execution\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\n/**************************************/\n/* get the default department         */\n/**************************************/\nADDRESS ISPEXEC \"VGET DEFDEPT PROFILE\"\nADDRESS ISPEXEC \"VGET TSOALIAS PROFILE\"\nIF TSOALIAS = \"YES\" THEN DO\n  ADDRESS TSO \"LISTC ENT('\"ACID\"')\"\n  SAY \"TSA101D: T52ADD  ALIAS CHECK IS \" RC\n  ALIAS_CODE = RC\n  ADDRESS TSO \"LISTC LEVEL('\"ACID\"')\"\n  SAY \"TSA101D: T52ADD  LEVEL CHECK IS \" RC\n  LEVEL_CODE = RC\n  IF (ALIAS_CODE \u00ac= 0) & (LEVEL_CODE =0)  THEN DO\n    msg2 = \"The id has no alias, yet has dsns cataloged, expect\",\n    \"severe allocation errors\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSIGNAL ON ERROR NAME ABORT\n/**********************************************************/\n/** END OF DSN ALIAS / LEVEL CHECKING                    **/\n/**********************************************************/\nLINE.  = \" \"\nALEN   = LENGTH(ACID)\nBILLA  = \"N\"\nCODE   = 0\nCURSOR = \"NAME\"\nDEFINE = \"NAME('\"NAME\"') DEPT(D0000000) TYPE(USER)\"\nFIRST2 = SUBSTR(ACID,1,2)\nGOTDEF = \"NO\"\nLOGON  = TSOPROC\nNDEPT  = FIRST2||\"DEPT\"\nif defdept /= \"NONE\" then ndept = defdept\nPROF   = \" \"\nPWORD  = \"PASSWORD,60,EXP\"\nSECDEF. = \" \"\nsecrc  = \"T52ADD did not complete normally. please check the id.\"\nS2     = ALEN - 1\nTYPE   =  \"USER\"\nWARNED = \"NO\"\n\"VPUT SECRC PROFILE\"\nPW = \"PASSWORD\"\nDPNL   = \"SPIADD\"\nBASIC_ACID = \" \"\nAUDU.0 =   1\nAUDU.1 =   \"%ADDLOCAL\" ACID NDEPT\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"FAC(TSO,BATCH)\"\n/****************************************************/\n/** the tso authority stream is below              **/\n/****************************************************/\n/*                                                                  */\n/*batchtso.0 = 3                                                    */\n/*batchtso.1 = \" \"                                                  */\n/*batchtso.2 = \"ISPSTART CMD(%\"TVER\"TSO DEFAULTS +\"                 */\n/*batchtso.3 = \" \"ACID LOGON BOOK1 TSOUNIT TSOSIZE\") NEWAPPL(TSS)\"  */\n/*onlintso.0 = 1                                                    */\n/*onlintso.1 =\"%\"TVER\"TSO DEFAULTS\" ACID LOGON BOOK1 TSOUNIT TSOSIZE*/\n/*                                                                  */\n/****************************************************/\n/** beginning of the panel loop                    **/\n/** beginning of the panel loop                    **/\n/****************************************************/\nAGAIN: NOP\nCALL FILLSCR\n\"DISPLAY PANEL(\"DPNL\")  CURSOR(\"CURSOR\")\"\nRCODE = RC\nNAME = TRANSLATE(NAME,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSAY \"TSA101D: T52ADD  PANEL RCODE IS \"RCODE\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ERRMSG\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\nGETNAME: NOP\nCNT1 = 0\nNORMAL: NOP\nMEMBER = mem\nIF MEM = \"\" THEN MEMBER = NDEPT\nmem = member\nSAY \"TSA101D: CHECKING FOR DEFAULT DEPT AUTHORITIES\" DEF\"(\"MEMBER\")\"\nIF SYSDSN(\"'\"DEF\"(\"MEMBER\")'\") = \"OK\" THEN DO\n  SAY \"TSA101D: T52ADD  DEFAULT AUTHORITY GROUP FOUND FOR IN \" DEF BIN\n  ADDRESS TSO \"ALLOC DDN(SECDEF) DSN('\"DEF\"(\"member\")') SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR SECDEF ( FINIS STEM SECDEF.)\"\n  ADDRESS TSO \"FREE DDN(SECDEF)\"\n  /******************************************************/\n  /***                                                ***/\n  /*** NOTE: THE FIRST LINE OF THE DSN MUST HAVE A    ***/\n  /*** CREATE PARM IN IT! IF THERE IS NO MEMBER I     ***/\n  /*** ASSIGN A VALUE TO SECDEF.1                     ***/\n  /***                                                ***/\n  /******************************************************/\n  SECDEF.1 = \"NAME('\"NAME\"')\" SECDEF.1\n  GOTDEF = \"YES\"\nEND\nELSE SECDEF.1 = DEFINE /* IF NO MEMBER WE JUST CREATE A 1 LINER */\nsay \"t52add: secdef.1 is\" secdef.1\nDO T = 1 TO 40\n  /******************************************************/\n  /***                                                ***/\n  /*** ONCE HERE THERE HAS TO BE A SECDEF.1 VALUE AND ***/\n  /*** IT HAS IS    COMPRISED OF VALID 'CREATE' PARMS ***/\n  /*** FOR TOP SECRET. THE REST OF THE SECDEF. STRING ***/\n  /*** MAY CONTAIN commands to be issued by the       ***/\n  /*** system sight unseen.                           ***/\n  /******************************************************/\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \" T52ADD: $$ substitution string found in secdef\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \" T52ADD: $DEPT$ substitution string found in secdef\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$MEM$\") /= 0 then do\n    say \" T52ADD: $MEM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$MEM$' q2\n    secdef.t = q1||member||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  LINE.T =  secdef.t\n  say t line.t\nEND\nSCRDISP: NOP\nCALL FILLSCR\nMSG=\"CHANGE DEFAULT COMMAND STREAM IF NEEDED AND HIT ENTER.\"\nIF GOTDEF = \"NO\" THEN\n  MSG=\"NO DEFAULT AUTHORITY STREAM FOUND. ENTER COMMANDS.\"\nPNLDISP: NOP\n\"ISPEXEC DISPLAY PANEL(\"DPNL\")\"\nRCODE = RC\nSAY \"T52ADD: PANEL RCODE IS \"RCODE\nIF MEM /= MEMBER THEN SECDEF. = \" \"\nIF MEM /= MEMBER THEN SIGNAL NORMAL\nNAME = SUBSTR(NAME                  ,1,20)\nCALL FILLDOT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ABORT\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\n/******************************************************************/\n/******************************************************************/\nCOMMIT: NOP\n/*\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"              \"\nLINE.1 = DEFINE\n*/\nIF PW \u00ac= \" \" THEN PWORD = PW||\",60\"\nELSE PW = \"PASSWORD\"\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T52ADD: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1= \"TSS CREATE(\"ACID\")   +\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  ADDRESS MVS \"EXECIO \"OUTCT\" DISKW BJCL ( FINIS STEM LINE.)\"\n  /**********************************************************/\n  /*ADDRESS MVS,                                               */\n  /* \"EXECIO \"batchtso.0\" DISKW BJCL ( FINIS STEM batchtso.)\"  */\n\n  SAY \"T52ADD: WRITING DATA TO BJCL DDNAME\"\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM AUDU.)\"\n  CODE = RC\n  IF CODE = 0 THEN SECRC =\"BATCH FILE UPDATED WITH ADD COMMANDS.\"\n  SIGNAL OFF ERROR\n  IF RC < > 0 THEN DO\n    MSG2 = \"THE BILLING FILE UPDATE DID NOT COMPLETE NORMALLY.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  SIGNAL BYE1\nEND\nTSSCMD = \"YES\"\nADDRESS TSO\nSAY \"T52ADD: ISSUING THE TSS ADD COMMAND FOR THE ID\"\nSAY \"T52ADD: TSS CREATE(\"ACID\") PASSWORD(\"PWORD\") \" LINE.1\nSAY \"T52ADD: \" line.1\n\"TSS CREATE(\"ACID\") PASSWORD(\"PWORD\") \" LINE.1\nCODE = RC\nSAY \"T52ADD: THE TSS ADD COMMAND FINISHED WITH A RCODE OF \" CODE\nSIGNAL OFF ERROR\nDO T = 2 TO OUTCT\n   say \"T52ADD: issuing command:\" line.t\n   IF LINE.T < > \" \" THEN\n   ADDRESS TSO \" \"LINE.T\nEND\n/* ADDRESS TSO \"%TSSAUDU \" ACID    */\nSPACES= \"                                                          \"\nSYSDATE = DATE(U)\nBYE:  NOP\nSIGNAL OFF ERROR\nIF  MODE= \"SKIPIT\" THEN DO\n  SAY \"T52ADD: VERSION 5.0 TSO DEFAULTS BEING SET\"\n  BOOK1 = WORD(BOOK,1)\n  rcode = 0\n  do cmdnum = 1 to audu.0\n    say \"T52ADD: issuing cmd : \"onlintso.cmdnum\n    address tso onlintso.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T52ADD: rcode from cmd is \" holdrc\n  end\n  do cmdnum = 1 to audu.0\n    say \"T52ADD: issuing cmd : \"audu.cmdnum\n    address tso audu.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T52ADD: rcode from cmd is \" holdrc\n  end\n  ADDRESS ISPEXEC\n  IF RCODE > 0 THEN DO\n    \"VGET SECRC PROFILE\"\n    MSG2 = \"DEFAULTS TSO SETUP HAS FAILED, CHECK BOOK AUTHORITIES\"\n    \"VPUT MSG2 PROFILE\"\n    SIGNAL BYE1\n  END\n  SAY \"T52ADD: VERSION 5.0 TSO DEFAULTS HAVE BEEN SET\"\nEND\nJUSTUADS: NOP\nCODE = RC\nSIGNAL ON ERROR NAME BADALIAS\n\nif code = 0 then secrc =\"TSA202I: ACID added. no errors encountered.\"\nBYE1:  NOP\nSIGNAL OFF ERROR\nADDRESS ISPEXEC\n\"VPUT SECRC PROFILE\"\n DATAAREA = ACID\n\"VPUT DATAAREA PROFILE\"\nEXIT 0\nERRMSG: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA201E: Errors encountered. check acid status \"\n  SIGNAL BYE1\nBADALIAS: NOP\n  IF CODE = 0 THEN\n    SECRC= \"ALIAS ADDITION FAILED CHECK ACID STATUS \"\n  ELSE SECRC = SECRC \"AND ALIAS ADDITION FAILED\"\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  SIGNAL BYE1\nABORT: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA200E: Function aborted. acid not added.\"\n  SIGNAL BYE1\n/****************************************************************/\n/*  ERROR ROUTINE MESSAGE DISPLAYS.........DIR                  */\n/****************************************************************/\nFILLDOT: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE.1 = LINE1\n  LINE.2 = LINE2\n  LINE.3 = LINE3\n  LINE.4 = LINE4\n  LINE.5 = LINE5\n  LINE.6 = LINE6\n  LINE.7 = LINE7\n  LINE.8 = LINE8\n  LINE.9 = LINE9\n  LINE.10= LINE10\n  LINE.11= LINE11\n  LINE.12= LINE12\n  LINE.13= LINE13\n  LINE.14= LINE14\n  LINE.15= LINE15\nRETURN\nFILLSCR: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE1 = LINE.1\n  LINE2 = LINE.2\n  LINE3 = LINE.3\n  LINE4 = LINE.4\n  LINE5 = LINE.5\n  LINE6 = LINE.6\n  LINE7 = LINE.7\n  LINE8 = LINE.8\n  LINE9 = LINE.9\n  LINE10= LINE.10\n  LINE11= LINE.11\n  LINE12= LINE.12\n  LINE13= LINE.13\n  LINE14= LINE.14\n  LINE15= LINE.15\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52BCON": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00 \\x00\\x955/\\x01\\x00\\x07_\\x105\\x00\\x87\\x00\\x87\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:35:20", "lines": 135, "newlines": 135, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50BCON                           **/\n/** LAST MODIFIED    : 24 SEP 96                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/**********************************************************/\n/** BASE SUPPORT FOR ZCA TYPE ADMINS                     **/\n/**********************************************************/\n/** PASSED ARGS        VALID VALUES                      **/\n/** THESE ARGS ARE ONLY PASSSED ON A LSCA CONVERT        **/\n/** NEWACID : THE NAME THAT THE ACID IS TO BE CHANGED TO **/\n/** NEWTYPE : THE TYPE OF ACID THAT IS TO BE CREATED     **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DS1     : THE DATASET WHEWRE THE INPUT DATA MUST BE  **/\n/** DS2     : THE OUTPUT DATASET                         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES.(NOTE VGET VARIABLES)       **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE                  */\n/**                                                      **/\n/**********************************************************/\nARG NEWACID NEWTYPE\nSIGNAL ON ERROR NAME SEEYA\nSIGNAL ON SYNTAX NAME SYNERR\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nSAY \"T50BCON: TOP SECRET REXX BASIC ACID CONVERSION CLIST ENTERED\"\nNEST = SYSVAR(SYSNEST)\nIF NEST = \"NO\" THEN DO\n  \"ALLOC DDN(OUTFILE) DSN(\" DS2\") MOD REUS\"\n  \"ALLOC DDN(INPUT) DSN(\" DS1\") SHR REUS\"\nEND\n\"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\nOUTFILE. = \" \"\nATTR = \"ATTR\"\nOPID = \" \"\nPWD = \"12345\"\nNEXTREC: DO RECNUM = 1 TO INLINE.0\n  PREVLINE=  INLINE\n  INLINE= SUBSTR(INLINE.RECNUM,1,59)\n  IF INLINE = \"      \" THEN ITERATE\n  PARSE VAR INLINE PAR.1 PAR.2 PAR.3 PAR.4 PAR.5 PAR.6 PAR.7 PAR.8\n  IF (PAR.1 = \"ACCESSORID\") & ( RECNUM > 3 ) THEN DO\n    \"EXECIO 5 DISKW OUTFILE( FINIS STEM OUTFILE.)\"\n    OUTFILE.  = \"         \"\n    ATTR = \"ATTR\"\n    TYPE = \"TYPE\"\n    DEPT = \"DEPT\"\n    NAME = \"NAME\"\n    OPID = \" \"\n    INSTDATA = \"INSTDATA\"\n    ACID = \"ACID\"\n  END\n  IF PAR.1 = \"INSTDATA\" THEN DO\n     NEXT = RECNUM + 1\n/*   INSTDATA =\"'\"||SUBSTR(INLINE.NEXT,1,55)||\"'\"    */\n     INSTDATA =\"'\"||SUBSTR(INLINE,14,65)||\"'\"\n     ITERATE\n  END\n  IF PAR.1 = \"OPIDENT\" THEN OPID = \"OPIDENT(\"PAR.3\")\"\n  IF PAR.3 = \"OPPRTY\" THEN OPID = \" \"\n  IF PAR.1 = \"PASSWORD\" THEN PWD = PAR.3\n  IF PWD   = \"*NOPW*\" THEN PWD = \"NOPW\"\n  IF PAR.3 = \"*NONE*\" THEN ITERATE\n  IF PAR.1 = \"ACCESSORID\" THEN ACID = PAR.3\n  IF NEWACID \u00ac= \" \" THEN ACID = NEWACID\n  IF ACID = \"*STC*\" THEN EXIT 00\n  IF ACID = \"*RDT*\" THEN EXIT 00\n  IF ACID = \"*ALL*\" THEN EXIT 00\n  IF PAR.1 = \"DEPT\" THEN DEPT = PAR.4\n  IF PAR.1 = \"DIV\" THEN DIV = PAR.4\n  IF PAR.1 = \"TYPE\" THEN TYPE = PAR.3\n  IF NEWTYPE \u00ac= \" \" THEN TYPE = NEWTYPE\n  IF PAR.4 = \"NAME\" THEN NAME = STRIP(PAR.6  PAR.7  PAR.8 )\n  IF PAR.1 = \"ATTRIBUTES\" THEN ATTR = PAR.3\n  IF (TYPE = \"DEPT\") & (PAR.4 = \"C/A\") THEN TYPE = \"DCA\"\n  IF (PAR.1 = \"ZONE\") & (PAR.2 = \"ACID\") THEN TZONE = PAR.4\n  IF (TYPE = \"ZONE\") & (PAR.4 = \"C/A\") THEN TYPE= \"ZCA\"\n  IF TYPE = \"LIMITED\" THEN TYPE = \"LSCA\"\n  IF TYPE = \"MASTER\" THEN EXIT\n  PRINTIT: IF TYPE = \"CENTRAL\" THEN TYPE = \"SCA\"\n  IF TYPE = \"DIV\" THEN TYPE = \"VCA\"\n  OUTFILE.  = \"            \"\n  OUTFILE.1 = \" TSS CRE(\"ACID\") NAME('\"NAME\"') TYPE(\"TYPE\") +\"\n  OUTFILE.2 =\"  DEPT(\"DEPT\")  +\"\n  IF TYPE = \"ZONE\" THEN OUTFILE.2 = \" \"\n  IF TYPE = \"VCA\" THEN\n    OUTFILE.2 =\"  DIV(\"DIV\") +\"\n  IF TYPE = \"ZCA\" THEN\n    OUTFILE.2 =\"  ZONE(\"TZONE\") +\"\n  IF TYPE = \"DEPT\" THEN\n    OUTFILE.2 =\"  DIV(\"DIV\") +\"\n  IF (TYPE=\"SCA\") | (TYPE= \"LSCA\") THEN DO\n    OUTFILE.2 =\"  PASSWORD(\"PWD\",30,EXP) +\"\n    IF OPID \u00ac= \" \" THEN\n      OUTFILE.2 = \"  PASSWORD(\"PWD\",30,EXP) \"OPID\" +\"\n    OUTFILE.3 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.3 =\"  INSTDATA(\"INSTDATA\") \"\n    OUTFILE.4 =\"                       \"\n  END\n  IF TYPE=\"PROFILE\" THEN DO\n    OUTFILE.3 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.3 = \"  INSTDATA(\"INSTDATA\") \"\n    OUTFILE.4 = \"                       \"\n    OUTFILE.5 = \"                       \"\n  END\n  IF (TYPE=\"USER\") | (TYPE=\"DCA\") | (TYPE=\"VCA\") THEN DO\n    OUTFILE.3 = \" PASSWORD(\"PWD\",30,EXP) \"OPID\" +\"\n    OUTFILE.4 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.4 =\"  INSTDATA(\"INSTDATA\") \"\n  END\n  IF ATTR <> \"ATTR\" THEN\n    OUTFILE.5 = \" TSS ADD(\"ACID\") \"ATTR\" \"\n  OUTFILE.6 = \"         \"\nEND\n\"EXECIO 5 DISKW OUTFILE( FINIS STEM OUTFILE.)\"\nEXIT 0\nSEEYA: NOP\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON. ERROR IN LINE \" SIGL\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSYNERR: NOP\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON. SYNTAX ERROR LINE \" SIGL\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52BKUP": {"ttr": 8205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x03\\x006\\x00\\x98'_\\x01\\x03&\\x1f\\x08V\\x00T\\x00T\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@\"", "ispf": {"version": "05.03", "flags": 0, "createdate": "1998-10-02T00:00:00", "modifydate": "2003-09-18T08:56:36", "lines": 84, "newlines": 84, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ADDED STRIP PROCESSING FOR DSBACK DSN NAME           **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50BKUP                           **/\n/** LAST MODIFIED    : 2  OCT 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :     THE ID YOU WANT BACKED UP              **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DSBACK  : THE DSN TO PUT THE BACKUP IN               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T52GDAT              **/\n/**                                                      **/\n/**********************************************************/\nARG ACID DSBACK\nHEX00 = '00'X\nSYSENV = SYSVAR(SYSENV)\nIF DSBACK = \"\" THEN\n  ADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nSIGNAL ON ERROR NAME SEEYA\nDSBACK = TRANSLATE(DSBACK,\"\",\"'\") /* REMOVE TICS WITH SPACES */\nDSBACK = STRIP(DSBACK)\nSTATUS  = SYSDSN(\"'\"DSBACK\"'\")\nDSBACK = \"'\"DSBACK\"(\"ACID\")'\"\nSAY \"TSA101D: T52BKUP DSBACK IS \"DSBACK\nADDRESS TSO \"%T52GDAT \" ACID \"TYPE\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nTYPE = SECRC\nSAY \"TSA101D: T52BKUP TYPE IS \" TYPE\nSS = OUTTRAP('OUTLINE.')\nDATA=\"ALL,PASSWORD,EXPIRE\"\nSTATUSM = SYSDSN(DSBACK)\nIF (STATUS = \"OK\") & (STATUSM = \"MEMBER NOT FOUND\")  THEN DO\n  SAY \"TSA101D: T52BKUP BACKUP MEMBER WILL BE CREATED.  \"\nEND\nIF (STATUS = \"OK\") & (STATUSM = \"OK\")  THEN DO\n  SAY \"TSA101D: T52BKUP BACKUP MEMBER WILL BE OVERLAYED BY THIS BACKUP.\"\nEND\nIF (STATUS /= \"OK\")  THEN DO\n  SAY \"TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS = \" STATUS\n  SECRC = \"TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS = \" STATUS\n  EXIT 04\nEND\nSAY \"TSA101D: T52BKUP ALLOCATING DSN\" DSBACK\n\"ALLOC DDN(OUTFILE) DSN(\"DSBACK\") SHR REUS\"\nSAY \"TSA101D: T52BKUP  CALLING TSS FOR LIST OF ID \" ACID\nSELECT\n  WHEN TYPE = \"USER\"    THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"MASTER\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"DEPTCA\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"ZONECA\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"DIVCA\"   THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"CENTRAL\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"LIMITED\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"PROFILE\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"GROUP\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  OTHERWISE   \"TSS LIST(ACIDS) \"TYPE\"(\"ACID\")  DATA(\"DATA\")\"\nEND\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n secrc = \"function completed. backup taken to  \" dsback\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52CADD": {"ttr": 7177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x03\\x01\\x03\\x05\\x0f\\x01\\x03\\x05\\x1f\\tT\\x000\\x000\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2003-02-19T00:00:00", "modifydate": "2003-02-20T09:54:03", "lines": 48, "newlines": 48, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T52CADD                           **/\n/** LAST MODIFIED    :  2 feb 2000                       **/\n/**********************************************************/\n/** This exec take a name and ID stem and gets an OPID   **/\n/** and determines the full ID.                          **/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Stem    : The acid stem , usually 4 characters       **/\n/** MODE    : BATCH or ONLINE passed to t52add           **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG stem fname Lname mode\nSAY \"T52CADD: Control received = \" stem fname lname mode\nfirst = substr(fname,1,1)\nsecond = substr(lname,1,1)\nif length(stem) > 4 then do\n  secrc  =  \"Stem of ACID cannot exceed 4 characters\"\n  ADDRESS ISPEXEC\n  \"VPUT secrc  PROFILE\"\n  exit 4\nend\nsay first second\naddress tso \"%getopid\" first second \"LIVE\"\nname = fname lname\nADDRESS ISPEXEC\n\"VGET dataarea  PROFILE\"\nopid = dataarea\n\"Vput name  PROFILE\"\naddress tso \"%t52add\" stem||opid  mode\naddress tso \"%tssaudu\" stem||opid\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52CMDO": {"ttr": 6155, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00&\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00A\\x00A\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:26", "lines": 65, "newlines": 65, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ISSUE A COMMAND TRAP THE OUTPUT AND ROUTE IT SOMEWERE**/\n/** I ALSO CHANGE ALL HEX 00 TO BLANKS BECAUSE TSS       **/\n/** SOMETIMES RETURNS SOME '00'X VALUES IN ITS UADS AREA **/\n/**********************************************************/\n/** EXEC NAME        : T50CMDO                           **/\n/** LAST MODIFIED    : 16 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSN TO GET THE OUTPUT                  **/\n/** ARG     : THE ACTUAL COMMAND TO BE ISSUED            **/\n/** DISP    : THE DISP TO ALLOCATE THE DATASET WITH      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE HOWEVER THIS    **/\n/**      EXEC COULD BE PASSED ANOTHER EXEC NAME AND      **/\n/**      INVOKE THAT.                                    **/\n/**********************************************************/\nARG DSN cmd\nHEX00 = '00'X\nsecrc = \"TSA509E: Command not processed. check commands validity.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nif cmd = \"\" then\n  ADDRESS ISPEXEC \"VGET ARG PROFILE\"\nelse arg = cmd\nADDRESS ISPEXEC \"VGET DISP PROFILE\"\nQ = OUTTRAP(OUT.)\nT = 1\n\" \"ARG\nRCODE = RC\nDO Z = 1 TO OUT.0\n  IF LENGTH(OUT.Z) > 80 THEN DO\n    OUTLINE.T = SUBSTR(OUT.Z,1,80)\n    T = T + 1\n    OUTLINE.T = SUBSTR(OUT.Z,81)\n    T = T + 1\n    ITERATE Z\n  END\n  OUT.Z=TRANSLATE(OUT.Z,\" \",HEX00)\n  OUTLINE.T = OUT.Z\n  T = T + 1\nEND\nIF DSN = \"SCREEN\" THEN DO\n  T = T - 1\n  DO Q = 1 TO T\n     IF LENGTH(OUTLINE.Q) > 78 THEN OUTLINE.Q = SUBSTR(OUTLINE.Q,1,78)\n     IF OUTLINE.Q <> \" \" THEN SAY OUTLINE.Q\n  END\n  SIGNAL LETSGO\nEND\n\"ALLOC DDN(OUTPUT) DSN(\"DSN\") \"DISP\" REUS\"\n\"EXECIO * DISKW OUTPUT (STEM OUTLINE. FINIS)\"\n\"FREE DDN(OUTPUT)\"\nLETSGO: NOP\nIF RCODE = 0 THEN\n  secrc = \"TSA514I: Command issued output resides in:\" dsn\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52CON": {"ttr": 6402, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00G\\x00\\x98#o\\x01\\x00\\x07_\\x10S\\x049\\x049\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-08-24T00:00:00", "modifydate": "2000-03-15T10:53:47", "lines": 1081, "newlines": 1081, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added code to use FDT segment names                  **/\n/**********************************************************/\n/** added code to ignore dept/div/profile passwords      **/\n/**********************************************************/\n/** added more parm based processing                     **/\n/**********************************************************/\n/** added  parm based parsing                            **/\n/**********************************************************/\n/** bypassing iterate error.                             **/\n/**********************************************************/\n/** fixed reformatter error...                           **/\n/**********************************************************/\n/** added omvs support                                   **/\n/**********************************************************/\n/** REMOVED DUPLICATE OUTPUT LINES  SO AS TO STREAMLINE  **/\n/** THE OUTPUT ID...                                     **/\n/**********************************************************/\n/** ADDED SUPPORT FOR LSCA AND SCA JOBCARD CHANGE        **/\n/** SPECIFYING USER=MSCA ON THE JOBCARD.                 **/\n/**********************************************************/\n/** FIXED ADMIN ACID( SUPPORT..                          **/\n/**********************************************************/\n/** REDID THE RDT AREA FOR THE NEW ADDITION SYNTAX       **/\n/**********************************************************/\n/** ADDED SUPPORT FOR TSOOPTION PARM                     **/\n/**********************************************************/\n/** ADDED SUPPORT FOR ZCA DCA VCA CONVERSION             **/\n/**********************************************************/\n/** ADDED MSGS FOR MFAC CONVERSION                       **/\n/**********************************************************/\n/** SUPPORTS RDT AND LINEFORMATTING                      **/\n/**********************************************************/\n/** SUPPORTS TIMES/DAYS/LOCKTIMES                        **/\n/**********************************************************/\n/** THE NEWER STREAMLINED CONVERT FUNCTION.              **/\n/** THE LOGIC SHOULD BE ALOT MORE READABLE ...           **/\n/**********************************************************/\n/** EXEC NAME        : T50CON                            **/\n/** LAST MODIFIED    : 10 aug 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** NEWACID :  THE NAME THE ACID IS TO BE RENAMED TO     **/\n/** NEWTYPE :  THE NEW TYPE OF ACID TO BE CREATED        **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** CONVOPT : THE INTERNAL OUT OPTION \"DATASET\u00a6INTERNAL\" **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS1     : THE INTERIM OUTPUT FILE                    **/\n/** DS2     : THE BATCH FILE                             **/\n/** newpass : THE password to plug into IDs when it cant **/\n/**           be determined                              **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD.    = THE VALID COMMANDS 4 THIS ENT    \"ADD REM\" **/\n/** TYPE.   = THE RESOURCE TYPE                \"DATASET\" **/\n/** ACID.   = THE TARGET ACID FOR EACH CMD     \" ??    \" **/\n/** RSNAME. = THE RESOURCE NAME                \"SYS1.  \" **/\n/** DAYS.   = THE VALID DAYS                   \"MON,TUE\" **/\n/** TIME.   = THE VALID TIMES                  \"08,18  \" **/\n/** ACCESS. = THE ACCESS LEVEL                 \"UPDATE \" **/\n/** ACTION. = THE ACTION TO TAKE               \"FAIL   \" **/\n/** UNTIL.  = THE EXPIRE   DATE OF RULE \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/**********************************************************/\n/** Multi word parm stuff:                               **/\n/**                                                      **/\n/** In ALL below examples t1 has been set to the first   **/\n/** word in the line and t2 has been set to the second.  **/\n/** ( note the 0 prefixed values are always literals )   **/\n/**                                                      **/\n/** MULTI.T1.T2.0PRECMD        The # of commands to be   **/\n/**                      issued prior to value checking  **/\n/**                      This must correspond to the     **/\n/**                      below commands.                 **/\n/** MULTI.T1.T2.0PRECMD.1      Command # 1               **/\n/** MULTI.T1.T2.0PRECMD.2      Command # 2               **/\n/** MULTI.T1.T2.0ITERATE       0 = suffix to prev line   **/\n/**                            1 = make a new line       **/\n/**                                                      **/\n/** SNAME                      The segment for this rule **/\n/**                      to be activated (used below)    **/\n/** MULTI.T1.T2.SNAME          The value \"YES\"           **/\n/** MULTI.T1.T2.0TYPE          The type of resource      **/\n/**                      (example - DSN )                **/\n/** MULTI.T1.T2.0CMD           The tss cmd ( ADD or PER) **/\n/** MULTI.T1.T2.0RSNAME        The TSS resource(example -**/\n/**                      the dataset name)               **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                                                      **/\n/** Single word rules stuff:                             **/\n/**                                                      **/\n/**                                                      **/\n/**  THOLD               The first word on the data line **/\n/**                 that will trigger this rule          **/\n/**                                                      **/\n/**  SNAME               The section name that must match**/\n/**                 the current section for this rule    **/\n/**                                                      **/\n/**  ITERATE.thold.sname  Will I add line(s) to output ? **/\n/**                                                      **/\n/**  ITERATE.thold        How many lines...              **/\n/**                                                      **/\n/**  TYPE.thold           The RDT data type or \"$$\" to   **/\n/**                 bypass command build logic, and build**/\n/**                 your own command                     **/\n/**  CMD.thold           The command add or per or rev.. **/\n/**  RSNAME.thold        The resource name to be used in **/\n/**                  the command or if you specified $$  **/\n/**                  in the type field above, the actual **/\n/**                  rexx interpret command to be issued **/\n/**                                                      **/\n/**                                                      **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS2  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NEWTYPE\nmaint = \"june 4 1999\"\nsay \"T50CON: in control with parms \" acid newacid newtype\nsay \"T50CON: Maint = \" maint\nif acid = \"BYPASS\" then do\n  say \"T50CON: bypass detected other parms ignored.\"\n  newacid = \"\"\n  newtype = \"\"\nend\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50CON. NO OTHER INFORMATION AVAILABLE\"\nIF SYSENV = \"FORE\" THEN DO\n  SECRC = \"FAILED WHILE GETTING VARIABLES FROM ISPPROF\"\n  SECRC = SECRC||\" TRY 'REINIT' OPTION\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET NEWPASS PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS2 PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n  ADDRESS ISPEXEC \"VGET CONVOPT PROFILE\"\nEND\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nCREATE.   =  \"\"\nUNTIL.    =  \"\"\nTYPE.     =  \"\"\nCMD.      =  \"\"\nACCESS.   =  \"\"\nRSNAME.   =  \"\"\nLIBRARY.  =  \"\"\nPRECMD.   =  \"\"\nDAYS.     =  \"\"\nTIME.     =  \"\"\nFACILITY. =  \"\"\nPRIVPGM.  =  \"\"\nACTION.   =  \"\"\nDEPT      =  \"\"\nZONE      =  \"\"\nDIV       =  \"\"\nACID.0    =  ACID\nIF NEWACID /= \"\" THEN ACID.1 = NEWACID\n/********************************/\nCOMMAND.  = \"ADD\"\nSEGMENT   =  \"ADMINISTRATIONAUTHORITIES\"\nCOMMAND.SEGMENT  = \"ADMIN\"\n/********************************/\n/********************************/\n/** LOCK TIME segment          **/\n/** an example of using the    **/\n/** postcmd processor for      **/\n/** value resolution.          **/\n/********************************/\nTLINE                    = \"LOCK TIME\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0PRECMD      = 2\nMULTI.T1.T2.0PRECMD.1    = \"FAC =','w.6\"\nMULTI.T1.T2.0PRECMD.2    = \"IF W.6 = 'ALL' THEN FAC = ''\"\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0POSTCMD     = 3\nMULTI.T1.T2.0POSTCMD.1   = \"TYPE.OUTNUM = '$$'\"\nMULTI.T1.T2.0POSTCMD.2   = \"CMD.OUTNUM = 'ADD'\"\nMULTI.T1.T2.0POSTCMD.3   = \"RSNAME.OUTNUM = 'LTI('W.3||FAC')'\"\n/********************************/\n/** LIST DATA segment          **/\n/********************************/\nTLINE                    = \"LIST DATA\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0TYPE        = \"$$\"\nMULTI.T1.T2.0CMD         = \"'ADMIN'\"\nMULTI.T1.T2.0RSNAME      = \"'DATA('W.3' 'W.4')'\"\n/********************************/\n/** XA DATASET segment         **/\n/********************************/\nTLINE                    = \"XA DATASET\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0TYPE        = \"DSN\"\nMULTI.T1.T2.0CMD         = \"PER\"\nMULTI.T1.T2.0RSNAME      = \"W.3\"\nMULTI.T1.T2.0UNTIL       = \"W.4\"\n/********************************/\n/** single word rules are below**/\n/********************************/\nTHOLD                = \"GROUP\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'GROUP('W.2 w.3 w.4 w.5')'\"\n/********************************/\n/********************************/\nTHOLD                = \"XA\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"W.2\"\nCMD.THOLD            = \"PER\"\nRSNAME.THOLD         = \"W.3\"\nUNTIL.THOLD          = \"W.4\"\n/********************************/\nTHOLD                = \"FACILITIES\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"'FACILITY'\"\nCMD.THOLD            = \"ADMIN\"\nRSNAME.THOLD         = \"W.2 W.3\"\n/********************************/\nTHOLD                = \"ACID\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"'ACID'\"\nCMD.THOLD            = \"ADMIN\"\nRSNAME.THOLD         = \"W.2\"\n/********************************/\nTHOLD                = \"ACCESS\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nSNAME                = \"AUTHORITY\"\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 0\nACCESS.THOLD         = \"'ACCESS('W.2')'\"\n/********************************/\nTHOLD                = \"BYPASSING\"\nSNAME                = \"BASE\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\n                     /*******************************/\n                     /* only one precmd             */\n                     /*******************************/\nPRECMD.THOLD         = 1\nPRECMD.THOLD.1       = 'W.2 = TRANSLATE(W.2,\" \",\",\")'\n                     /*******************************/\n                     /* get rid of commas in auths  */\n                     /*******************************/\nRSNAME.THOLD         = \"W.2\"\n/********************************/\nTHOLD                = \"SITRAN\"\nSNAME                = \"SEGMENTCICS\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'SIT('W.2','W.4')'\"\n/********************************/\nTHOLD                = \"PROFILE\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'PROF('W.2')' W.3 W.4\"\n/********************************/\nTHOLD                = \"PROFILES\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'PROF('W.2 W.3 W.4')'\"\n/********************************/\nSEGMENT   =  \"BASE\"\nIF DISP = \"\" THEN DISP = SHR\nDATA=\"ALL,EXPIRE\"\nSIGNAL OFF ERROR\n  /******************************************************************/\nSECRC = \"FAILED, CHECK IDS EXISTANCE AND YOUR AUTHORITY.\"\nIF ACID  = \"BYPASS\" THEN DO\n  SAY \"T50CON: BYPASS SPECIFIED ALLOCATING INPUT DSN\"\n  \"ALLOC DDN(INPUT) DSN(\"DS1\") REUS\"\n  \"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\n  SS= OUTTRAP('off')\n  IDTYPE = \"USER\"\n  END\nELSE DO\n  say \"T50CON: calling tss for list of id \" acid\n  ADDRESS TSO \"%T50GDAT \"ACID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  IDTYPE = SECRC\n  say \"T50CON: type is \" idtype\n  IF IDTYPE = \"$BADTSS\" THEN DO\n    say \"T50CON: FATAL ERROR. T50GDAT failed TYPE retrieval.\"\n    secrc =\"ID is unlistable check ownership and existance of ID.\"\n    address ispexec \"vput secrc profile\"\n    exit 04\n    END\n  IF CONVOPT = \"DATASET\" THEN DO\n    say \"T50CON: dataset output specified allocating output dsn\"\n    \"%T50LSTO \" ACID \" ALL,EXPIRE\" DS1\n    \"ALLOC DDN(INPUT) DSN(\"DS1\")\"\n    \"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\n    SS= OUTTRAP('off')\n    END\n  ELSE DO\n    say \"T50CON: no id list output being generated, data being \"\n    say \"T50CON: manipulated internally  \"\n    SS = OUTTRAP('INLINE.')\n    SAY \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n    ADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n    SS= OUTTRAP('DROPIT.')\n  END\nEND\nSIGNAL ON ERROR NAME SEEYA\nsay \"T50CON: checking/allocating dsn\" ds2\nJPARM = \"RANDOM\"\n/***************************************************/\n/* PUT THE MSCA ID ON THE JOBCARD IF SCA OR LSCA   */\n/***************************************************/\nIF (IDTYPE = \"LIMITED\") | (IDTYPE = \"CENTRAL\") THEN JPARM = \"SUPER\"\nADDRESS TSO \"%T50JCARD\" DS2 JPARM\n\"ALLOC DDN(BJCL) DSN(\"DS2\") MOD REUS\"\n  /******************************************************************/\nEQUALLOC = INDEX(INLINE.1,\"=\")\nIF EQUALLOC = 0 THEN DO\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"T50CON: ERROR I AM UNABLE TO INITIALIZE THE EQUALLOC VARIABLE\"\n  SAY \"T50CON: THE TSS VERSION 5 DEFAULT OF 11 IS BEING USED        \"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  EQUALLOC = 12\nEND\nEQUALLOC = EQUALLOC - 1\nsay \"T50CON: equal location is \" equalloc\nGOTOUTPUT: NOP\nTHISREC    = 3\nOUTNUM     = 0\nREALOUT    = 0\nCREATE_NUM = 0\nCREATE.0 = 0\nSECRC = \"FAILED, DURING CONVERT LOGIC .\"\nsay \"T50CON: has a total record count of \" inline.0\nDO I = 1 TO INLINE.0\n  REFORMAT = \"NO\"        /* THIS LINE HASNT BEEN CHANGED YET */\n  T2 = I/100\n  /* IF T2 = FORMAT(T2,4,0) THEN SAY I */\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\")  /* REPLACE = WITH SPACES */\n  LINE= TRANSLATE(LINE,\" \",HEX00) /* KILL THOSE HEX 00 */\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  IF WORD(LINE,1) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  IF (INDEX(LINE,\"*ALL*\") <> 0) & (INDEX(LINE,\"VOLUMES\") =0 ) THEN DO\n    PARSE VAR LINE HOLD0 '*ALL*' HOLD1\n    LINE = HOLD0||\"ALL\"||HOLD1\n    say \"T50CON: removing *all* from line\"\n  END\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  FIRST13 = SUBSTR(LINE,1,EQUALLOC)\n  /***********************************/\n  /** DETERMINE THE segment IN CASE **/\n  /** WE NEED IT LATER.  DIR 15AUG97**/\n  /***********************************/\n  IF W.1 = \"ACCESSORID\" THEN segment = \"BASE\"\n  IF W.1 = \"CREATED\" THEN segment =  \"AUTHORITY\"\n  IF (W.1 = \"LAST\") & (W.2 = \"USED\") THEN segment =  \"AUTHORITY\"\n  IF (W.1 = \"PASSWORD\") & (W.2 = \"*NONE*\") THEN ITERATE I\n  IF  W.1 = \"-----------\" THEN segment =  W.2||W.3\n  IF  W.1 = \"-----------\" THEN Say \"T50CON: Segment changed to \"segment\n  CMD_DEFAULT = COMMAND.SEGMENT\n  IF  W.1 = \"-----------\" THEN iterate i\n  /***********************************/\n  /** END OF segment LOGIC          **/\n  /***********************************/\n  IF W.1 = \"ACIDS\" THEN FLUSH = \"YES\"\n  IF W.1 = \"ACIDS\" THEN ITERATE I\n  IF W.2 = \"LIST(ACIDS)\" THEN ITERATE I /* AN ECHO OF THE ISSUED CMD */\n  IF (SUBSTR(LINE,1,4) = \"ACID\"),\n    & (segment /= \"ADMINISTRATIONAUTHORITIES\") THEN ITERATE I\n  IF W.1 = \"***\" THEN ITERATE I\n  IF LINE = \"             \" THEN ITERATE I\n  IF W.3 = \"NAME\" THEN NAME = W.4 W.5 W.6 W.7 W.8\n  IF W.1 = \"TYPE\" THEN TYPE = W.2\n  IF TYPE = \"CENTRAL\" THEN TYPE = \"SCA\"\n  /**************************************************/\n  /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n  /**************************************************/\n  IF W.3 = \"C/A\"  THEN TYPE = SUBSTR(TYPE,1,1)||\"CA\"\n  IF W.3 = \"LIMITED\" THEN TYPE = \"LSCA\"\n  IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.3\n  IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.3\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.3\n  IF W.1 = \"CREATED\" THEN CALL MAKEACID\n  IF W.1 = \"CREATED\"  THEN ITERATE I\n  IF W.1 = \"TYPE\"  THEN ITERATE I\n  IF W.1 = \"DEPT\"  THEN ITERATE I\n  IF W.1 = \"ZONE\"  THEN ITERATE I\n  IF W.1 = \"DIV\"   THEN ITERATE I\n  IF W.1 = \"LAST\"  THEN ITERATE I\n  IF W.1 = \"TSS0300I\"  THEN ITERATE I\n  IF FIRST13 = \"LCF FAC      \" THEN LCFFAC = W.3\n  IF FIRST13 = \"LCF FAC      \" THEN ITERATE I\n  IF FIRST13 \\= \"             \" THEN DO\n    /**********************************************************/\n    /** I SAVE THE LAST TIME THAT THE 13 CHARACTERS EXISTED  **/\n    /** BECAUSE IF THE LINE IS REALLY INDENTED THEN THOSE    **/\n    /** CHARACTERS ARE GOING TO OVERLAYED ON THIS LINE IN    **/\n    /** A DESPERATE ATTEMPT TO FIGURE OUT WHAT TYPE OF       **/\n    /** RESOURCE IS BEING DEALT WITH. DIR 2 APR 97           **/\n    /**********************************************************/\n    SAVE13 = FIRST13\n    FLUSH = \"NO\"\n  END\n  /**********************************************************/\n  /** below is the logic for dropping lines with entries   **/\n  /** we dont need. the most common example is a profiles  **/\n  /** acids segment.             dir 10 aug 98             **/\n  /**********************************************************/\n  IF (SUBSTR(LINE,1,13) = \"             \") & (FLUSH = \"YES\"),\n  THEN DO\n    say \" T50CON: 13 leading blanks found flushing line #: \" i\n    SAY LINE\n    ITERATE I\n  END\n  /**********************************************************/\n  /** BELOW IS THE REFORMATTER AREA. SOME TSS RULES ARE SO **/\n  /** WEIRDLY SETUP I JUST CREATE A $$ TYPE LINE FOR THEM  **/\n  /** OR OTHERWISE CHANGE THEM                             **/\n  /**********************************************************/\n  IF FIRST13 = \"             \" THEN DO\n    NEWLINE = SAVE13 W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n    PARSE VAR NEWLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n    W.8 W.9 W.10 W.11 W.12\n    say \"T50CON: I am reformatting line #\" i \" to the following\"\n    REFORMAT = \"YES\"\n    /************************************************************/\n    /** THE ABOVE FLAG IS SET SO THAT THE BELOW ROUTINES CAN   **/\n    /** DETERMINE IF THE LINE WAS ORIGINALLY BLANK FROM 1-13   **/\n    /** THIS IS A GOOD WAY TO FIND OUT IF YOU HAVE A           **/\n    /** CONTINUATION THAT HAS TO BE DEALT WITH...DIR 9 JULY 97 **/\n    /************************************************************/\n    SAY NEWLINE\n    LINE = NEWLINE\n    IF WORDS(NEWLINE) > 12 THEN DO\n      SAY \"******************************************************\"\n      SAY \"******************************************************\"\n      SAY \"T50CON: TRUNCATION HAS OCCURED IN REFORMATTING        \"\n      SAY \"******************************************************\"\n      SAY \"******************************************************\"\n    END\n  END\n  /*************************************************************/\n  WORD1 = W.1\n  WORD2 = W.2\n  IF MULTI.WORD1.WORD2.segment = \"YES\" THEN DO\n    /* say \"entering dynam routine outnum is :\" outnum   */\n    OUTNUM = OUTNUM + MULTI.WORD1.WORD2.0ITERATE\n    /* say \"after resolution  outnum is :\" outnum   */\n    /* say \"T50CON: multi match on line\" i\" words: \"word1 word2  */\n    /*say \"T50CON: input cmd/rsname values are below\"            */\n    /*say multi.word1.word2.0cmd multi.word1.word2.0rsname       */\n    /****************************************/\n    /* check for precmd value and issue   it*/\n    /****************************************/\n    VALID = DATATYPE(MULTI.WORD1.WORD2.0PRECMD)\n    if valid = \"NUM\" then do cnum = 1 to MULTI.WORD1.WORD2.0PRECMD\n      SAY \"T50CON: precmd issueing:\" MULTI.WORD1.WORD2.0PRECMD.cnum\n      INTERPRET MULTI.WORD1.WORD2.0PRECMD.cnum\n    end\n    /****************************************/\n    /* check for RSNAME value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0RSNAME\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0RSNAME\" THEN DO\n      HOLDVAL = \"RSNAME.OUTNUM  = \" MULTI.WORD1.WORD2.0RSNAME\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for TYPE value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0TYPE\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0TYPE\" THEN DO\n      HOLDVAL = \"TYPE.OUTNUM    = \" MULTI.WORD1.WORD2.0TYPE\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for access value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0ACCESS\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0ACCESS\" THEN DO\n      HOLDVAL = \"ACCESS.OUTNUM  = \" MULTI.WORD1.WORD2.0ACCESS\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for CMD value and resolve it */\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0CMD\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0CMD\" THEN DO\n      HOLDVAL = \"CMD.OUTNUM    = \" MULTI.WORD1.WORD2.0CMD\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for UNTIL value and resolve it */\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0UNTIL\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0UNTIL\" THEN DO\n      HOLDVAL = \"UNTIL.OUTNUM  = \" MULTI.WORD1.WORD2.0UNTIL\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for postcmd value and issue  it*/\n    /****************************************/\n    VALID = DATATYPE(MULTI.WORD1.WORD2.0POSTCMD)\n    IF VALID = \"NUM\" THEN DO CNUM = 1 TO MULTI.WORD1.WORD2.0POSTCMD\n      SAY \"T50CON: Postcmd issueing:\" MULTI.WORD1.WORD2.0POSTCMD.CNUM\n      INTERPRET MULTI.WORD1.WORD2.0POSTCMD.CNUM\n    END\n    SAY \"T50CON: Multi match output for line \"i\" is : \",\n    cmd.outnum type.outnum rsname.outnum access.outnum\n    ITERATE I\n  END\n  IF ITERATE.WORD1.segment = \"YES\" THEN DO\n    /*                                               */\n    /*SAY \"SINGLE LINE=\" W.1 W.2 W.3 W.4 W.5 W.6 W.7 */\n    /*say \"T50CON: segment is \" segment              */\n    /*say \"T50CON: found single match on line \"i\" word: \"WORD1  */\n    OUTNUM = OUTNUM + ITERATE.WORD1\n    if datatype(precmd.word1) = \"NUM\"  then\n      do cnum = 1 to precmd.word1\n      say \"T50CON: precommand \"cnum\" of \"precmd.word1 precmd.word1.cnum\n      interpret precmd.word1.cnum\n    end\n    if rsname.word1 /= \"\" then do\n      holdval = \"rsname.outnum  = \" rsname.word1\n      interpret holdval\n    end\n    if access.word1 /= \"\" then do\n      holdval = \"access.outnum  = \" access.word1\n      interpret holdval\n    end\n    if until.word1 /= \"\" then do\n      holdval = \"until.outnum  = \" until.word1\n      interpret holdval\n    end\n    if cmd.word1 /= \"\" then do\n      holdval = \"cmd.outnum  = \" cmd.word1\n      interpret holdval\n    end\n    if type.word1 /= \"\" then do\n      holdval = \"type.outnum  = \" type.word1\n      interpret holdval\n    end\n    if datatype(postcmd.word1) = \"NUM\" then\n      do cnum = 1 to postcmd.word1\n      say \"T50CON: postcmd \"cnum\" of \"postcmd.word1 postcmd.word1.cnum\n      interpret postcmd.word1.cnum\n    end\n    SAY \"T50CON: Lone  match output for line \"i\" is : \",\n      cmd.outnum type.outnum rsname.outnum access.outnum\n    ITERATE I\n  END\n  /*************************************************************/\n  /*************************************************************/\n  /**  end of dynamic area                                   ***/\n  /*************************************************************/\n  /*************************************************************/\n  IF (W.1 = \"MASTER\") & (W.2 = \"FAC\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"MAS(\"W.3\")\"\n    MSG2 = \"WARNING: THE SOURCE ID (\"ACID\") IS THE MASTERID OF A\",\n    \"FACILITY (\"W.3\").\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMP1 = W.3\",\"W.4\",\"W.5\",\"W.6\n    TEMP1 = STRIP(TEMP1,T,\",\")\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMP1\"))\"\n    CMD_DEFAULT = \"PER\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMP1 = W.3\",\"W.4\",\"W.5\",\"W.6\n    TEMP1 = STRIP(TEMP1,T,\",\")\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMP1\"))\"\n    /* CMD_DEFAULT = \"PER\"  */\n    ITERATE I\n  END\n  /**************************************************/\n  /* THIS IS THE START OF THE RDT                   */\n  /* THIS FUNCTION MAY PRODUCE MORE THAN 80 CHAR    */\n  /* OUTPUT                            DIR 4 APR 97 */\n  /**************************************************/\n  IF ACID  = \"RDT\" THEN DO\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    IF ((W.1 = \"RESOURCE\") & (W.2= \"CLASS\")) | (W.1 = \"TSS0300I\" ),\n    THEN DO\n      OUTNUM = OUTNUM + 1\n      RSNAME.OUTNUM = \"RESCLASS(\"RCLASS\")\",\n      \" RESCODE(\"RCODE\")  \"\n      IF ATTR \u00ac= \"\" THEN DO\n        RSNAME.OUTNUM = RSNAME.OUTNUM||\"ATTR(\"ATTR\") \"\n      END\n      IF ACLIST1 \u00ac= \"\" THEN DO\n        RSNAME.OUTNUM = RSNAME.OUTNUM||\"ACLST(\"ACLIST\",\"ACLIST1\")\"\n      END\n      ELSE DO\n        IF ACLIST \u00ac= \"\" THEN\n          RSNAME.OUTNUM = RSNAME.OUTNUM||\"ACLST(\"ACLIST\")\"\n      END\n      IF RCLASS = \"RCLASS\" THEN OUTNUM = OUTNUM - 1 /* KILL LINE 1 */\n      RCLASS = W.3\n      ATTR= \"\"\n      ACLIST1 = \"\"\n      ACLIST = \"\"\n      DEFACC= \"\"\n    END\n    IF (W.1 = \"RESOURCE\") & (W.2= \"CODE\") THEN\n      RCODE = SUBSTR(W.3,3,2)\n    IF (W.1 = \"ATTRIBUTE\") THEN\n      ATTR = W.2\n    IF (W.1 = \"ACCESS\") & (ACLIST \u00ac= \"\" ) THEN DO\n      W.2= TRANSLATE(W.2,\"\",\")\")   /* REPLACE ) WITH NULLS */\n      W.2= TRANSLATE(W.2,\"=\",\"(\")  /* REPLACE ) WITH = */\n      W.2= TRANSLATE(W.2,\" \",\",\")  /* REPLACE , WITH   */\n      PARSE VAR W.2 T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 T.11 T.12\n      SAY W.2\n      WORDNUM = WORDS(W.2)\n      HOLD1 = T.WORDNUM\n      LOOPNUM = WORDNUM - 1\n      DO Q2 = LOOPNUM TO 1 BY -1\n        HOLD1 = HOLD1||\",\"T.Q2\n      END\n      ACLIST1 = HOLD1\n    END\n    IF (W.1 = \"ACCESS\") & (ACLIST = \" \" ) THEN DO\n      W.2= TRANSLATE(W.2,\"\",\")\")   /* REPLACE ) WITH NULLS */\n      W.2= TRANSLATE(W.2,\"=\",\"(\")  /* REPLACE ) WITH = */\n      W.2= TRANSLATE(W.2,\" \",\",\")  /* REPLACE , WITH   */\n      PARSE VAR W.2 T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 T.11 T.12\n      WORDNUM = WORDS(W.2)\n      HOLD1 = T.WORDNUM\n      LOOPNUM = WORDNUM - 1\n      DO Q2 = LOOPNUM TO 1 BY -1\n        HOLD1 = HOLD1||\",\"T.Q2\n      END\n      ACLIST= HOLD1\n    END\n    IF (W.1 = \"DEFACC\") THEN\n      DEFACC= W.2\n    ITERATE I\n  END\n  /* SAMPLE RDT ADD IS BELOW                                      */\n  /*  TSS ADD(RDT) RESCLASS(BUDGET) RESCODE(30)                   */\n  /*  ATTR(LONG,GENERIC,DEFPROT) -                                */\n  /*  ACLST(ALL,ADD=000E,CHANGE=0006,USE=0002,NONE) DEFACC(NONE)  */\n  /**************************************************/\n  /* THIS IS THE END OF THE RDT AREA                */\n  /**************************************************/\n  IF W.1 = \"DAYS\" THEN DO\n    DAYS.OUTNUM = \"DAYS(\"W.2\")\"\n    IF INDEX(W.3,\"TIMES(\") = 1 THEN\n      TIME.OUTNUM = W.3\n    IF W.2 = \"ALL\" THEN DAYS.OUTNUM = ''\n    /**************************************************/\n    /* IF THE W.3 WORD IS TIMES( THEN THE RULE IS     */\n    /* TIMES( ANY ) . IN THIS CASE JUST ERASE IT.     */\n    /**************************************************/\n    IF W.3 = \"TIMES(\" THEN TIME.OUTNUM = ''\n    ITERATE I\n  END\n  IF W.1 = \"SOURCES\" THEN DO\n    W.1 = \"SOURCE\"\n    CMD_DEFAULT  = \"ADD\"\n  END\n  IF W.1 = \"INSTDATA\" THEN DO\n    OUTNUM = OUTNUM + 1\n  /*********************************************************/\n  /** ONE OF MY CLASSIC DEBUGS IS BELOW                   **/\n  /*SAY \"T50CON: AT  INSTDATA I IS \" I \"OUTNUM IS \" OUTNUM */\n  /*********************************************************/\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"INSTDATA\"\n    RSNAME.OUTNUM =\"'\"||STRIP(SUBSTR(LINE,14,59))||\"'\"\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"INSTDATA\"\n    ITERATE I\n  END\n  IF W.1 = \"ACCESSORID\" THEN DO\n    FLUSH = \"YES\"\n    TEMP = OUTNUM + 1\n    CMD_DEFAULT = \"ADD\"\n    IF W.2 = \"*RDT*\" THEN W.2 = \"RDT\"\n    IF W.2 = \"*STC*\" THEN W.2 = \"STC\"\n    IF W.2 = \"*AUDIT*\" THEN W.2 = \"AUDIT\"\n    ACID = W.2\n    ACID.TEMP   = W.2\n    if newacid /= \"\" then acid.temp = newacid\n    /******************************************************/\n    /** WE CHANGE THE ACID TO SUPPORT AN INPUT STREAM    **/\n    /** WITH MORE THAN ONE LISTED ACID THIS WOULD BE     **/\n    /** USED IF WE HAD A BYPASS PARM TO A LIST(ACIDS) DSN**/\n    /******************************************************/\n    IF ACID = \"*ALL*\" THEN ACID = \"ALL\"\n    IF ACID = \"*STC*\" THEN ACID = \"STC\"\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = \"LIB(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    IF REFORMAT = \"YES\" THEN DO   /* WE HAVE MULTI LINES OF PGMS */\n      LENP = LENGTH(PRIVPGM.OUTNUM) - 1\n      H1 = SUBSTR(PRIVPGM.OUTNUM,1,LENP)\n      PRIVPGM.OUTNUM = H1 STRIP(W.2 W.3 W.4 W.5 W.6)||\")\"\n    END\n    ELSE   /* IF IT IS NOT MULTIPLE LINES OF PGMS */\n      PRIVPGM.OUTNUM = \"PRIVPGM(\"STRIP(W.2 W.3 W.4 W.5 W.6)\")\"\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = \"FAC(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.1 = \"PASSWORD\" THEN DO\n    OUTNUM = OUTNUM  + 1\n    RSNAME.OUTNUM = \"PASSWORD(\"W.2\",90)\"\n    IF W.2 = \"*NOPW*\" THEN\n      RSNAME.OUTNUM = \"PASSWORD(NOPW,0)\"\n    CMD.OUTNUM = \"REP\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    OUTNUM = OUTNUM + 1\n    W.2  = TRANSLATE(W.2,\" \",\",\") /* REPLACE COMMAS WITH SPACES */\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    OUTNUM = OUTNUM + 1\n    W.2  = TRANSLATE(W.2,\" \",\",\") /* REPLACE COMMAS WITH SPACES */\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = \"ACTION(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.3 = \"NAME\" THEN DO\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    ITERATE I\n  END\n  IF ACID = \"STC\" THEN DO\n    IF W.2 = \"SIZE\" THEN ITERATE I\n    OUTNUM = OUTNUM + 1\n    IF W.2 = \"*DEF*\" THEN W.2 = \"DEFAULT\"\n    IF W.5 = \"*FAIL*\" THEN W.4 = \"FAIL\"\n    IF W.5 = \"*DORM*\" THEN W.4 = \"DORM\"\n    IF W.5 = \"*BYPASS*\" THEN W.4 = \"BYPASS\"\n    IF W.5 = \"*WARN*\" THEN W.4 = \"WARN\"\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    RSNAME.OUTNUM = \"PROC(\"W.2\")               \"\n    TEMP1 = SUBSTR(RSNAME.OUTNUM,1,17)\n    RSNAME.OUTNUM = TEMP1 \"ACID(\"W.4\")\"\n    ITERATE I\n  END\n  /**************************/\n  /* MY BABY FALL THRU AREA */\n  /**************************/\n  IF W.2 = \" \" THEN ITERATE\n  IF SUBSTR(LINE,1,2) = \"  \" THEN DO\n    SAY \"************************************************\"\n    SAY \"************************************************\"\n    SAY \"T50CON: UNRECOGNIZED INDENTED LINE # \" I\n    SAY   LINE\n    SAY \"************************************************\"\n    SAY \"************************************************\"\n  END\n  say \"T50CON: fallthru line:\"i\" segment:\" segment \"word1:\"w.1\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM = CMD_DEFAULT\n  /**************************************************/\n  DO XX = 3 TO 8\n    /*SAY XX IS PAR.XX */\n    /**************************************************/\n    /* NOTE THAT BLANKS AND HEX 00S FAIL THE BELOW    */\n    /* CHECK SO THAT SOME COLUMNS THAT ARE ALWAYS IN  */\n    /* IDS BUT ARE SOMETIMES BLANKS ARE NOT NORMALLY  */\n    /* PROCESSED.                 DIR                 */\n    /**************************************************/\n    IF WORDS(W.XX) <> 0 THEN DO\n      say \"T50CON: fallthru routine parsing \"w.xx\n      OUTNUM = OUTNUM + 1\n      RSNAME.OUTNUM = W.XX\n      TYPE.OUTNUM = W.1\n      CMD.OUTNUM = CMD_DEFAULT\n    END\n  END\nEND\nSAY \"T50CON : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/**************************************************/\n/**************************************************/\n/* THE ACTUAL OUTPUT IS CREATED BELOW FROM THE    */\n/* INPUT LINES. SOME FORMATTING IS DONE UNLESS THE*/\n/* THE TYPE VARIABLE IS \"$$\" IN WHICH CASE THE    */\n/* RSNAME VARIABLE IS APPENDED TO THE ID AND      */\n/* COMMAND AND ISSUED WITH NO FORMATTING. THIS    */\n/* ALLOWS THE ABOVE ROUTINES TO PREPROCESS SOME   */\n/* ENTRY TYPES THAT ARE COMPLEX. DIR 2 APR 97     */\n/**************************************************/\n/**************************************************/\nDO X = 1 TO OUTNUM\n  Y  = X + 1          /* IN CASE WE LOOK AT THE NEXT LINE */\n  B4 = X - 1          /* IN CASE WE LOOK AT THE PREVIOUS LINE */\n  IF ACID.X = \"ACID.\"||X THEN ACID.X = ACID.B4\n  REALOUT = REALOUT + 1\n  /**************************************************/\n  /* A STANDARD DSN PERMIT IS BELOW DIR 2 APR 97    */\n  /**************************************************/\n  BATFILE.X = \" TSS \"CMD.X\"(\"ACID.X\") \"TYPE.X\"(\"RSNAME.X\") \"ACCESS.X,\n    UNTIL.X LIBRARY.X FACILITY.X PRIVPGM.X DAYS.X TIME.X ACTION.X\n  /**************************************************/\n  /* A PREFORMATTED COMMAND JUST ISSUE IT           */\n  /**************************************************/\n  IF TYPE.X = \"$$\" THEN\n    BATFILE.X = \" TSS \"CMD.X\"(\"ACID.X\") \"RSNAME.X\n  BATFILE.X = STRIP(BATFILE.X,T)\n  /**************************************************/\n  /* INSTDATA IS HANDLED SPECIAL BECAUSE IT CAN BE  */\n  /* SO LONG IT GETS ITS OWN LINE DIR 2 APR 97      */\n  /**************************************************/\n  IF TYPE.X = \"INSTDATA\" THEN DO\n    SAY \"                       ***********                       \"\n    SAY \"T51: BEGINNING OF INSTDATA PARSING ROUTINE. LINE IS BELOW\"\n    SAY BATFILE.X\n    PARSE VAR BATFILE.X W.1 W.2 W.3 W.4 W.5 W.6 W.7\n    OUTPUT.REALOUT = \" \"W.1 W.2 \"+\"\n    SAY OUTPUT.REALOUT\n    REALOUT = REALOUT + 1\n    OUTPUT.REALOUT = \"    \"STRIP(W.3 W.4 W.5 W.6 W.7)\n    SAY OUTPUT.REALOUT\n    ITERATE X\n  END\n  /**************************************************/\n  /* IF IT IS TOO LONG ILL BREAK IT UP              */\n  /**************************************************/\n  IF LENGTH(BATFILE.X)  > 72 THEN DO\n    say \"T50CON: line too long reformatting for output of 72\"\n    PARSE VAR BATFILE.X W.1 W.2 W.3 W.4 W.5 W.6 W.7\n    OUTPUT.REALOUT = \" \"W.1 W.2 W.3 \"+\"\n    REALOUT = REALOUT + 1\n    OUTPUT.REALOUT = \"    \"STRIP(W.4 W.5 W.6 W.7)\n    IF LENGTH(OUTPUT.REALOUT) > 72 THEN DO\n      say \"T50CON: breaking up data lines.\"\n      say \"T50CON: w4 and w5:\" w.4 w.5\n      say \"T50CON: w6 and w7:\" w.6 w.7\n      OUTPUT.REALOUT = \"    \"W.4 W.5\" +\"\n      REALOUT = REALOUT + 1\n      V4 = \"\"\n      OUTPUT.REALOUT = W.6 \", + \"\n      /***********************************************/\n      /** IF W6 IS MULTIPLE WORDS SEPERATED BY      **/\n      /** COMMAS THEN WE WILL SEPERATE THEM. 30JUL97**/\n      /***********************************************/\n      IF WORDS(TRANSLATE(W.6,\" \",\",\")) >  3 THEN DO\n        PARSE VAR W.6 V1 ',' V2 ',' V3 ',' V4\n        OUTPUT.REALOUT = \"    \"V1\",\"V2\",\"V3\", + \"\n      END\n      REALOUT = REALOUT + 1\n      OUTPUT.REALOUT = \"    \"V4  W.7\n      REALOUT = REALOUT + 1\n      OUTPUT.REALOUT = \"    \"\n    END\n  END\n  ELSE DO\n    OUTPUT.REALOUT = BATFILE.X\n  END\nEND\nLASTCMD = \"DUMMY\"\nDO T2 = 2 TO REALOUT\n  B4 = T2 - 1\n  IF OUTPUT.T2 = LASTCMD THEN DO\n    SAY \"DUPLICATE LINE DROPPED #\" T2 OUTPUT.T2\n    OUTPUT.T2 = \" \"\n  END\n  IF OUTPUT.T2 /= \" \" THEN LASTCMD = OUTPUT.T2\n  /* SAY \"LASTCMD IS \"LASTCMD */\nEND\nSECRC = \"FAILED, DURING OUTPUT RESOLUTION CHECK OUTPUT STREAM.\"\n\"EXECIO \"CREATE.0\" DISKW BJCL ( FINIS STEM CREATE.)\"\nsay \"T50CON: output lines is \" realout\nREALOUT = REALOUT + 1\nOUTPUT.REALOUT = \"@@\"\n\"EXECIO \"REALOUT\" DISKW BJCL ( FINIS STEM OUTPUT.)\"\n\"FREE DDN(BJCL)\"\n SECRC = \"TSA515W: Unsupported function completed. Output in \" DS2\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\nSIGNAL OFF ERROR\nSAY \"T50CON: ERRORL IN LINE \" SIGL\nSAY SOURCELINE(SIGL)\n/* SECRC = \"T50CON: ERROR IN LINE\"  SIGL  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/**********************************************/\n/**********************************************/\n/***** SUBROUTINES SUBROUTINES  ***************/\n/**********************************************/\n/**********************************************/\nMAKEACID: PROCEDURE EXPOSE ACID I INLINE. NAME TYPE DIV DEPT,\n  ZONE OUTNUM CREATE. CREATE_NUM NEWACID NEWTYPE NEWPASS\n/**********************************************/\nIF NEWACID \\= ''  THEN ACID = NEWACID\nIF NEWTYPE \\= ''  THEN TYPE = NEWTYPE\nIF NEWTYPE = \"LSCA\" THEN OWNER = \"OWNER\"\nUSER_FLAG = \"YES\"\nIF TYPE = \"TYPE\" THEN USER_FLAG = \"$$\"\nIF TYPE = \"DIVISION\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"GROUP\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"DIV\" THEN TYPE= \"VCA\"\nIF TYPE = \"DEPT\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"PROFILE\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"ZONE\" THEN USER_FLAG = \"NO\"\nIF ZONE \\= \" \" THEN OWNER = \"ZONE\"\nIF ZONE \\= \" \" THEN AREA = ZONE\nIF DIV  \\= \" \" THEN OWNER = \"DIV\"\nIF DIV  \\= \" \" THEN AREA  =  DIV\nIF DEPT \\= \" \" THEN OWNER = \"DEPT\"\nIF DEPT \\= \" \" THEN AREA  =  DEPT\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \" TSS CRE(\"ACID\") NAME('\"NAME\"') +\"\nIF USER_FLAG = \"YES\" THEN\n  T = \"  \"OWNER\"(\"AREA\")   TYPE(\"TYPE\") PASSWORD(\"NEWPASS\")\"\nELSE\n  T = \"  \"OWNER\"(\"AREA\")   TYPE(\"TYPE\")\"\nIF OWNER = \"OWNER\" THEN T = \"   TYPE(\"TYPE\") PASSWORD(\"NEWPASS\")\"\nIF TYPE = \"DIVISION \"THEN T = \"   TYPE(\"TYPE\")\"\nIF USER_FLAG = \"$$\" THEN DO\n  SAY \"*********************************************************\"\n  SAY \"T50CON: MAKEACID ROUTINE ABORTING DUE TO LACK OF USER TYPE\"\n  SAY \"T50CON: ACID = \"ACID\n  SAY \"*********************************************************\"\n  RETURN\nEND\nDIV = \"\"\nDEPT = \"\"\nZONE = \"\"\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \"  \"T\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \"  \"\nCREATE.0 = CREATE_NUM\nsay \"T50CON: leaving makeacid routine # lines out = \" create.0\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52DEL": {"ttr": 8453, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x05\\x00W\\x00\\x955/\\x01\\x04\\x03O\\x12T\\x00O\\x00O\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.05", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2004-02-03T12:54:57", "lines": 79, "newlines": 79, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50DEL                            **/\n/** LAST MODIFIED    : 17 SEP 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID YOU WISH DELETED.                 **/\n/** MODE    : THE CURRENT MODE \"BATCH\" OR \"ONLINE\"       **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** UIDTABLE : THE GROUP OF 2 CHR NON TSS ID PREFIXES    **/\n/** TVER     : THE CURRENT TSS VERSION VARIABLE          **/\n/** DSBACK   : THE DS WHERE TO TAKE A BACKUP COPY        **/\n/** DS5      : THE DS WHERE TO PUT BATCH SYSIN UPDATES   **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES ( NOTE VGETS )              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T4?LSTO TSSAUDR      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nthiscmd = sysvar(sysicmd)\nSIGNAL OFF ERROR\nsecrc = \"TSA510E: \"Thiscmd\" has ended abnormally.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET TVER PROFILE\"\nADDRESS ISPEXEC \"VGET AUD PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET DS5 PROFILE\"\nUIDENTRY = LENGTH(UIDTABLE)/2\nUIDSTART = 1\nACID2 = SUBSTR(ACID,1,2)\nDSLIST = \"'\"DSBACK\"(\"||ACID||\")'\"\nBJCL.0 = 3\nBJCL.1 = \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\nBJCL.2 = \"TSS DEL( \"ACID\")\"\nBJCL.3 = \"%DELLOCAL\" ACID\nIF MODE = \"BATCH\" THEN DO\n  say \"tsa101d: batch mode detected. allocating \" ds5 \"to bjcl ddn\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  ADDRESS MVS \"EXECIO \"BJCL.0\" DISKW BJCL (FINIS STEM BJCL.)\"\n  secrc = \"TSA511I: Batch file updated with delete stream for \" acid\nEND\nIF MODE = \"ONLINE\" THEN DO\n  TOTCODE = 0\n  SIGNAL OFF ERROR\n  say \"tsa101d: online mode detected. executing delete stream\"\n  SECRC = \"DELETE COMMAND STREAM FOR \" ACID \"FLUSHED.\"\n  DO CN = 1 TO BJCL.0\n    HOLD = BJCL.CN\n    SAY ADDRESS TSO \" \"   HOLD\n    ADDRESS TSO \" \"   HOLD\n    TOTCODE = RC + TOTCODE\n  END\n  secrc = \"command stream for \" acid \"completed normally.\"\n  IF TOTCODE > 0 THEN\n  secrc = \"stream had partial failure, check ids status. code=\" totcode\n  IF TOTCODE = 16 THEN\n  secrc = \"id may not exist or your authority may be invalid.\"\n  SAY SECRC\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n\nBADTSS: NOP\nsecrc = \"the tss id you specified was not listable, check the id\"\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\nBOOKAUTH: NOP\nSECRC = \"YOU DONT HAVE AUTHORITY TO DELETE AN ID WITH BOOK NUMBER\" BOOK\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52DELB": {"ttr": 8713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x04\\x19\\x7f\\x01\\x04\\x19\\x7f\\x10Y\\x00\\x06\\x00\\x06\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-07-15T00:00:00", "modifydate": "2004-07-15T10:59:01", "lines": 6, "newlines": 6, "modlines": 0, "user": "COA1DIR"}, "text": "/*rexx */\narg id\naddress tso \"%T52LSTO \"id\" ALLPW 'SYS4.SPI.IDBACKUP(\"id\")'\"\naddress tso \"TSS DEL( \"id\")\"\naddress tso \"%DELLOCAL\" id\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52DELO": {"ttr": 6923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x005\\x7f\\x01\\x005\\x7f\\tH\\x00}\\x00}\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-22T00:00:00", "modifydate": "2000-12-22T09:48:04", "lines": 125, "newlines": 125, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** REMOVED THE CODE TO DELETE ALIAS FROM IMS            **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50DEL                            **/\n/** LAST MODIFIED    : 07 DEC 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID YOU WISH DELETED.                 **/\n/** MODE    : THE CURRENT MODE \"BATCH\" OR \"ONLINE\"       **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** UIDTABLE : THE GROUP OF 2 CHR NON TSS ID PREFIXES    **/\n/** TVER     : THE CURRENT TSS VERSION VARIABLE          **/\n/** DSBACK   : THE DS WHERE TO TAKE A BACKUP COPY        **/\n/** DS5      : THE DS WHERE TO PUT BATCH SYSIN UPDATES   **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES ( NOTE VGETS )              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T4?LSTO TSSAUDR      **/\n/**                                 TSSACNT              **/\n/**********************************************************/\nARG ACID MODE\nSIGNAL OFF ERROR\nSECRC = \"T50DEL HAS ENDED ABNORMALLY.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET UADSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET UIDTABLE PROFILE\"\nADDRESS ISPEXEC \"VGET TVER PROFILE\"\nADDRESS ISPEXEC \"VGET AUD PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET DS5 PROFILE\"\nUIDENTRY = LENGTH(UIDTABLE)/2\nUIDSTART = 1\nACID2 = SUBSTR(ACID,1,2)\nDSLIST = \"'\"DSBACK\"(\"||ACID||\")'\"\nSAY \"T50DEL: BUILDING UID BYPASS TABLE ARRAY OF \" UIDENTRY \"ENTRIES\"\nDO X = 1 TO UIDENTRY\n  UID.X = SUBSTR(UIDTABLE,UIDSTART,2)\n  UIDSTART = UIDSTART + 2\nEND\nNONTSS = \"NO\"\nDO T = 1 TO UIDENTRY\n  IF (ACID2 = UID.T) THEN NONTSS = \"YES\"\nEND\nIF NONTSS =  \"NO\" THEN DO\n  ADDRESS TSO \"%T50GDAT \" ACID \"TSOLACCT  TSO\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  IF SECRC = \"$BADTSS\" THEN SIGNAL BADTSS\n  IF SECRC /= \"$NOTFOUND\" THEN DO\n    BOOK = SECRC\n    X5 = TSSCHECK(\"BOOKNUM\",BOOK,\"UPDATE\")  /* CAN THEY DO THIS */\n    SAY \"T50DEL: TSSCHECK RETURN CODE IS \" X5\n    IF X5 /= \"OK\"  THEN SIGNAL BOOKAUTH\n  END\nEND\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T50DEL: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1 = \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\n  BJCL.2 = \"%RXREPRO SYS1.UADS(\"ACID\"0) \"UADSBACK\"(\"ACID\"0)\"\n  BJCL.2 = \" \"\n  BJCL.3 = \"TSS DEL( \"ACID\")\"\n  BJCL.4 = \"ACCOUNT\"\n  BJCL.5 = \"DEL (\"ACID \")\"\n  BJCL.6 = \"E\"\n  BJCL.7 = \"%TSSAUDR \" ACID AUD\n  BJCL.8 = \"%IMSDALIA\" ACID\n  BJCL.8 = \"  \"\n  IF NONTSS = \"YES\"  THEN DO\n    BJCL.1 = \"%\"TVER\"LSTO\" ACID||\"@  ALLPW\"  DSLIST\n    BJCL.2 = \"TSS DEL( \"ACID\"@)\"\n  END\n  ADDRESS MVS \"EXECIO 8 DISKW BJCL (FINIS STEM BJCL.)\"\n  SECRC = \"BATCH FILE UPDATED WITH DELETE COMMAND STREAM FOR \" ACID\nEND\nELSE DO\n  TOTCODE = 0\n  SIGNAL OFF ERROR\n  SAY \"T50DEL: ONLINE MODE DETECTED. EXECUTING DELETE STREAM\"\n  SECRC = \"DELETE COMMAND STREAM FOR \" ACID \"FLUSHED.\"\n  /***************************************************/\n  /** IF NONTSS = YES THEN I DO NOT CARE IF THE TSS **/\n  /** PORTION OF THE DELETE STREAM FUNCTIONS        **/\n  /** CORRECTLY..      HENCE ALL THE IFS BELOW      **/\n  /***************************************************/\n  ADDRESS TSO  \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\n  IF NONTSS = \"YES\" THEN  /* TRY TO DELETE THE @ GHOST ENTRY */\n    ADDRESS TSO  \"%\"TVER\"LSTO\" ACID\"@ ALLPW\"  DSLIST\n  IF NONTSS = \"NO\" THEN TOTCODE = RC + TOTCODE\n  /* \"%RXREPRO SYS1.UADS(\"ACID\"0) \"UADSBACK\"(\"ACID\"0)\"*/\n  ADDRESS TSO  \"%TSSAUDR \" ACID\n  TOTCODE = RC + TOTCODE\n  /* ADDRESS TSO  \"%IMSDALIA\" ACID */\n  /* TOTCODE = RC + TOTCODE */\n  ADDRESS TSO  \"TSS DEL(\" ACID \")\"\n  IF NONTSS = \"YES\" THEN ADDRESS TSO  \"TSS DEL(\" ACID\"@)\"\n  IF NONTSS = \"NO\" THEN TOTCODE = RC + TOTCODE\n  ADDRESS TSO  \"%TSSACNT \" ACID \"DELETE\"\n  TOTCODE = RC + TOTCODE\n  SECRC = \"COMMAND STREAM FOR \" ACID \"COMPLETED NORMALLY.\"\n  IF TOTCODE > 0 THEN\n  SECRC = \"STREAM HAD PARTIAL FAILURE, CHECK IDS STATUS. CODE=\" TOTCODE\n  IF TOTCODE = 16 THEN\n  SECRC = \"ID MAY NOT EXIST OR YOUR AUTHORITY MAY BE INVALID.\"\n  SAY SECRC\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n\nBADTSS: NOP\nSECRC = \"THE TSS ID YOU SPECIFIED WAS NOT LISTABLE, CHECK THE ID\"\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\nBOOKAUTH: NOP\nSECRC = \"YOU DONT HAVE AUTHORITY TO DELETE AN ID WITH BOOK NUMBER\" BOOK\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52DISC": {"ttr": 6919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x007\\x00\\x97 /\\x01\\x01\\x19\\x0f\\x081\\x00o\\x00o\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2001-07-09T08:31:37", "lines": 111, "newlines": 111, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** TO REMOVE PROFILE FROM ALL THAT HAVE IT              **/\n/**********************************************************/\n/** EXEC NAME        : T51DISC                           **/\n/** LAST MODIFIED    : 06 JUL 97                         **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** MODE    : THE MODE OF OPERATION                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nENV = SYSVAR(SYSENV)\n/**********************************************************/\n/* REMOVE THE BELOW DO IF YOU WANT THIS EXEC TO RUN IN   **/\n/* ONLINE MODE....( YECH !!)                             **/\n/**********************************************************/\nIF (MODE \\= \"BATCH\") & (ENV = \"FORE\") THEN DO\n  SECRC =\"FUNCTION FAILED. DISCONNECT CANNOT BE RUN IN ONLINE MODE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE   \"\n  EXIT 04\nEND\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS ISPEXEC\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS A PROFILE, FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO REMOVE THAT  PROFILE FROM   */\n/* ALL THE IDS THAT HAVE IT ATTACHED.                               */\n/********************************************************************/\nSTARTOUT: NOP\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T51DISC: BATCH MODE DETECTED. USING DDN BJCL AS OUTPUT\"\n  /* ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"   */\nEND\nOUTNUM =  1\n/***********/\nSECRC = \"LIST COMMAND FAILURE, CHECK IDS VALIDITY\"\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(ACIDS)\"\nQ = OUTTRAP(\"OFF\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  IF WORD(INLINE,1) = \"TSS0300I\" THEN\n    SIGNAL OUTSTART\n  IF SUBSTR(INLINE,14,1) = \" \" THEN\n    GOFLAG = NO\n  IF SUBSTR(INLINE,1,5) = \"ACIDS\" THEN\n    GOFLAG=YES\n  IF GOFLAG = YES THEN DO\n    ID.1 = SUBSTR(INLINE,14,8)\n    ID.2 = SUBSTR(INLINE,26,8)\n    ID.3 = SUBSTR(INLINE,38,8)\n    ID.4 = SUBSTR(INLINE,50,8)\n    DO IDCNT = 1 TO 4\n      IF ID.IDCNT = \"*NONE*\" THEN ITERATE X\n      IF ID.IDCNT = \" \" THEN ITERATE X\n      SECRC = \" \"\n    /************************************************************/\n    /************************************************************/\n      SAY \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      IF MODE \\= \"BATCH\" THEN\n        ADDRESS TSO \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      ELSE DO\n        BJCL.OUTNUM = \"TSS REM(\"ID.IDCNT\") PROF(\"ACID\")\"\n        OUTNUM = OUTNUM + 1\n      END\n    END\n  END\nEND\nOUTSTART: NOP\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM BJCL.)\"\n  /*ADDRESS TSO \"FREE DDN(BJCL)\"   */\nEND\nSECRC= \"FUNCTION COMPLETED NORMALLY. \"\nIF MODE = \"BATCH\" THEN\n  SECRC= \"FUNCTION COMPLETED NORMALLY. OUTPUT APPENDED TO BATCH FILE.\"\n  IF SYSVAR(SYSENV) = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nCLOSEEM: NOP\nSAY \"LINE IS \"SIGL\nSAY  SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52DSNP": {"ttr": 8195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x00\\x10\\x1f\\x01\\x03\\x19_\\x07B\\x00q\\x00q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-04-10T00:00:00", "modifydate": "2003-07-14T07:42:43", "lines": 113, "newlines": 113, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG ACID DSNAME ACCESS DAYS\nSIGNAL OFF ERROR\n/* PERMITS AN ID TO A DSN */\nSECRC = \"T50DSNP FAILED WITH ERRORS\"\nD.0 =\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET DSNAUDL  PROFILE\"\nIF DSNAUDL = \" \" THEN DSNAUDL = \"'IMS.PROD.PARMLIB(AUDIT)'\"\nIF SYSDSN(DSNAUDL) = \"OK\" THEN DO\n  SAY \"T50DSNP: DSNAUDL IS\" DSNAUDL\n  \"ALLOC DDN(INPUT) DSN(\"DSNAUDL\") SHR REUS\"\n  \"EXECIO * DISKR INPUT ( FINIS STEM D.)\"\n  \"FREE DDN(INPUT)\"\n  SAY \"T50DSNP: I HAVE \"D.0\" QUALIFIERS TO AUDIT\"\n  DO T = 1 TO D.0\n    D.T = WORD(D.T,1)\n  END\nEND\nQ = OUTTRAP(OUT.)\nACTION = \"ACTION(FAIL)\"\nDAY1 = WORD(DAYS,1)\nDAY2 = WORD(DAYS,2)\nIF DAYS = \"AUDIT\" THEN DO\n  SAY \"T50DSNP: AUDIT VALUE DETECTED WITH NO DAYS LIMITATION.\"\n  DAYS = \"0\"\n  DAY1 = \"0\"\n  ACTION= \"ACTION(AUDIT)\"\nEND\nIF (DATATYPE(DAY1) \u00ac= \"NUM\") & (DAY1 \u00ac= \" \" ) THEN DO\n  SAY \"T50DSNP: DAYS VALUE NOT NUMERIC. EXEC ENDING.\"\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(AUDIT)\"\n  MSG2 = \"THE FOLLOWING PARAMETER WAS NOT NUMERIC\" DAY1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF DAY2 = \"AUDIT\" THEN DO\n  SAY \"T50DSNP: AUDIT VALUE DETECTED.\"\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(AUDIT)\"\nEND\nIF (DAY2 \u00ac= \"AUDIT\") & (DAY2 \u00ac= \" \") THEN DO\n  SAY \"T50DSNP: DAY2 VALUE NOT UNDERSTOOD = \" DAY2\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(FAIL)\"\n  MSG2 = \"THE FOLLOWING PARAMETER WAS NOT UNDERSTOOD\" DAY2\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF ACCESS \u00ac= \"READ\" THEN DO COUNT = 1 TO D.0\n  SAY \"T50DSNP: COMPARING \"DSNAME \"TO \" D.COUNT\n  IF INDEX(DSNAME,D.COUNT) = 1 THEN DO\n    SAY \"T50DSNP: DSNAUDIT ENTRY MATCH ENTRY\" COUNT DSNAME D.COUNT\n    ACTION = \"ACTION(AUDIT)\"\n    MSG2 = \"THAT DATASET IS AUDITED DAILY, AUDIT RULE INCLUDED\"\n    IF ACID = \"UCC7BAT\" THEN DO\n      MSG2 = \"NO AUDIT RULE ADDED. ID IS THE PRODUCTION JCL ID.\"\n      ACTION = \"ACTION(FAIL)\"\n    END\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSAY \"T50DSNP: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nRCODE = 0\nADDRESS TSO \"TSS WHOOWNS DSN(\"DSNAME\")\"\nRCODE = RC\nSAY \"T50DSNP: WHOOWNS RC IS \" RCODE\nIF RCODE \u00ac= 0 THEN DO\n  SECRC = \"THAT DATASET IS NOT UNDER YOUR OWNERSHIP. FUNCTION FAILED.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY OUT.1 OUT.2\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nRCODE = RC\nSAY \"T50DSNP: TSS LIST RC IS \" RCODE\nIF RCODE \u00ac= 0 THEN DO\n  SECRC = \"THAT ID IS NOT OWNED BY YOU OR IS INVALID.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY OUT.1 OUT.2\n  EXIT 04\nEND\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T50DSNP: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") DSN(\"DSNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"DSNAME\") ACCESS(\"ACCESS\") FOR(\"DAYS\")\" ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  SECRC = \"PERMIT FUNCTION SUCCESSFULL FOR ID \"ACID\" FOR \"DAYS\" DAYS.\"\nELSE\n  SECRC = \"PERMIT RETURNED NON ZERO RCODE OF \"RCODE\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52DSSIM": {"ttr": 6405, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x008\\x00\\x98(_\\x00\\x98(_\\t!\\x00?\\x00?\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-12T00:00:00", "modifydate": "1998-10-12T09:21:38", "lines": 63, "newlines": 63, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"%T50TSSIM\" ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"ALLOC DDN(INFILE) DSN(\"DSOUT\") SHR REUS\"\n ADDRESS MVS \"EXECIO * DISKR INFILE ( FINIS STEM LINE.)\"\n ADDRESS TSO \" FREE DDN(INFILE)\"\n /*SAY \"T50SIM: PARMS:\" ACID RTYPE RNAME FACILITY ACCESS DSOUT */\n SAY \"T50SIM: CHECKING ACCESS FOR\" ACID \"TO\" RNAME \"THRU\" FACILITY\n SAY \"      \"\n DO T = 1 TO LINE.0\n   LINE.T = SUBSTR(LINE.T,1,79)\n   IF (W.2 = \"VOL\") & (W.3 = \"ORIGIN\")  THEN LEAVE\n   PARSE VAR LINE.T  W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n   IF W.1 = \"TSS8379W\" THEN DO\n     SAY \"************************************************\"\n     SAY \"T50SIM: THE INPUT ID IS NOT UNDER YOUR CONTROL.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8362E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T50SIM: THE INPUT ID WAS NOT TSS DEFINED.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8361E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T50SIM: AN INPUT PARAMETER WAS INCORRECT.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8393I\" THEN DO\n     IF INDEX(LINE.T,\"DSN\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T50SIM: THIS ID BYPASSES NORMAL DATASET CHECKS!!\"\n       SAY \"************************************************\"\n     END\n     IF INDEX(LINE.T,\"VOL\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T50SIM: THIS ID BYPASSES NORMAL VOLUME  CHECKS!!\"\n       SAY \"************************************************\"\n     END\n   END\n   IF W.1 = \"TSS8380I\" THEN\n     SAY \"T50SIM: RESOURCE ACCESS WOULD BE GRANTED.\"\n   IF W.1 = \"TSS8381I\" THEN\n     SAY \"T50SIM: RESOURCE ACCESS WOULD BE DENIED.\"\n   IF (W.2 = \"ALLOWED\") & (W.3 = \"ACCESS\")  THEN\n     SAY \"T50SIM: THE ID HAS \"W.5\" ACCESS TO THIS RESOURCE\"\n   IF ( W.1 = \"TSS8394I\" ) & ( W.2 \u00ac= \"VOL\" ) THEN DO\n     PROF = W.6\n     IF W.6 = \"-\" THEN PROF = W.7\n     IF W.6 = \"*USER*\" THEN\n       PROF = \"THE INDIVIDUAL ID DEFINITION FOR\" ACID\n     IF W.6 = \"*ALL*\"  THEN PROF = \"THE SYSTEM ALL RECORD.\"\n     SAY \"T50SIM: THE APPLICABLE RULE IS IN\" PROF\n   END\n   IF W.1 = \"TSS8397I\" THEN SAY \"      \" W.2 W.3 W.4 W.5\n   /* TSS8380I GRANTED  */\n   /* TSS8381I DENIED   */\n END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52FDIV": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00E\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x007\\x007\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:45", "lines": 55, "newlines": 55, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50FDIV                           **/\n/** LAST MODIFIED    : 21 JUN 94                         **/\n/**     CONVERTED FROM CLIST TO REXX EXEC                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**       SECRC CAN CONTAIN:                             **/\n/**   THE DIVISION OF THE ACID.                           */\n/**   THE STRING \"LIST FUNCTION FAILED.\" IF THE ID IS BAD.*/\n/**   THE STRING \"PROFILE\"     IF THE ID IS A PROFILE.    */\n/**   THE STRING \"LIMITED\"     IF THE ID IS AN LSCA.      */\n/**   THE STRING \"CENTRAL\"     IF THE ID IS AN SCA.       */\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  NONE                **/\n/**********************************************************/\nARG ACID\nSAY \"T50FDIV: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nSECRC = \"LIST FUNCTION FAILED.\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T50FDIV: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"\nSAY \"T50FDIV: BACK FROM TSS WITH \"INLINE.0 \"LINES OF DATA\"\nDO X = 1 TO INLINE.0\n  INLINE = INLINE.X\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n  TOTWORDS = WORDS(INLINE)\n  IF W.1 = \"TYPE\" THEN  DO\n    SAY \"T50FDIV: TYPE INITIALLY SET TO \"W.3\n    SECRC = W.3\n  END\n  IF SECRC = \"PROFILE\" THEN LEAVE /* THIS IS WHAT HE WANTS TO KNOW  */\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\") THEN  DO\n    SAY \"T50FDIV : DIVISION FOUND, IS \"W.4\n    SECRC = W.4\n  END\nEND\nSAY \"T50FDIV: NORMAL END. FINAL DIVISION IS\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nW.1 = WORD(INLINE.1,1)\nIF W.1 = \"TSS0352E\" THEN SECRC = \"AUTHORIZATION FAILED.\"\nSAY \"T50FDIV : \"INLINE.1\nSAY \"T50FDIV : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T50FDIV : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52FLOC": {"ttr": 6659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x06\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x001\\x001\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:06", "lines": 49, "newlines": 49, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** RETURNS THE LOCATION OF A PROFILE IN A USERS PROFILE **/\n/** LIST ... DIR                                         **/\n/**********************************************************/\n/** EXEC NAME        : T50FLOC                           **/\n/** LAST MODIFIED    : 06 MAY 96                         **/\n/**  USES THE NEW T50FLOC  FUNTIONALITY                  **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  ANY TSS ACID                              **/\n/** PROFILE :  ANY TSS ACID THAT IS A PROFILE            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**   NONE                                               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  T50GDAT             **/\n/**                                                      **/\n/**********************************************************/\nARG ACID PROFILE\nSAY \"T50FLOC: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nGOTPRF = \"NO\"\nSECRC = \"ERROR\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T50FLOC: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"%T50GDAT \"ACID\" PROFILES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nPARSE VAR SECRC P.1 P.2 P.3 P.4 P.5 P.6 P.7 P.8 P.9 P.10 P.11 P.12\nNUM = WORDS(SECRC)\nSECRC = 0\nDO W = 1 TO NUM\n  IF PROFILE = P.W THEN SECRC = W\nEND\nSAY \"T50FLOC: POSITION OF \"PROFILE \" IN \" ACID \"IS \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"T50FLOC : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T50FLOC : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52GCMD": {"ttr": 6661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x00\\x01\\x00\\x955/\\x00\\x994O\\x10)\\x00`\\x00`\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1999-12-10T10:29:01", "lines": 96, "newlines": 96, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/*****************************************************************/\n/* added a null line to the output to fix prompt of user         */\n/*****************************************************************/\n/* THIS EXEC WILL CREATE A COMMAND STREAM THAT WILL AFFECT       */\n/* ALL THE ACIDS IN A DEPARTMENT DIVISION OR CONNECTED TO A      */\n/* PROFILE.                                                      */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nARG GROUP DSN1 CMD\nADDRESS ISPEXEC\n\"VGET (ACID DS3 DATA MODE) PROFILE\"\nIF GROUP = \" \" THEN GROUP = ACID\nIF DSN1 = \" \" THEN DSN1  = DS3\nIF CMD = \" \" THEN CMD  = DATA\nSAY \"T50GCMD: CALLING T50JCARD FOR JCL STREAM INITIALIZATION.\"\nADDRESS TSO \"T50JCARD\" DS3\nREPNUM = 0\nLCMD = LENGTH(CMD) - 2\nIF POS(\" $$\",CMD) = LCMD THEN SIGNAL OKTOGO\nIF POS(\" $$ \",CMD) = 0 THEN DO\n  SECRC = \"ERROR: THE STRING ' $$ ' MUST EXIST IN THE COMMAND STRING.\"\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nOKTOGO: NOP\nPARSE VAR CMD W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\nSIGNAL ON ERROR NAME SEEYA\nIF SYSDSN(DSN1) \u00ac= \"OK\" THEN DO\n  SAY \"TSSGCMD: THE OUTPUT DSN YOU HAVE GIVEN ME IS UNAVAILABLE\"\n  EXIT 00\nEND\nDO Z = 1 TO 9\n  IF W.Z = \" $$ \" THEN REPNUM = Z\nEND\nCOUNT_LIM = REPNUM - 1\nDO Z = 1 TO COUNT_LIM\n  IF W.Z = \" $$ \" THEN REPNUM1 = Z\nEND\nQ = OUTTRAP(OUTID.)\nADDRESS TSO\nIF MODE = \"ONLINE\" THEN\n  \"ALLOC DDN(OUT1) DSN(\"DSN1\") REUS MOD\"\nSAY \"T50GCMD: I AM CALLING T50PWHO WITH PARMS:\" GROUP\nSIGNAL OFF ERROR\n\"%T50PWHO\" GROUP\nLIST_CODE = RC\nSIGNAL ON ERROR NAME SEEYA\nsay \"TSA101D: T50GCMD I am back from T50PWHO with return code of \" rc\nsay \"TSA101D: T50GCMD the output of T50PWHO was \"outid.0 \"records.\"\nsay \"TSA101D: T50GCMD I am routing output to \"dsn1\nIF ( OUTID.0 = 0 ) | ( LIST_CODE \\= 0 )  THEN DO\n  msg2 = \"TSA221E: \"\n  msg2 = msg2 \"Failed. stream is incomplete, failure in listing \" group\n  ADDRESS ISPEXEC  \"VPUT MSG2 PROFILE\"\n  queue \"T50222E: I have received no input from T50PWHO\"\n  queue \"         acid may be invalid or authorization may have failed\"\n  ADDRESS ISPEXEC  \"VGET SECRC PROFILE\"\n  QUEUE SECRC\nEND\nDO X = 1 TO OUTID.0\n  PARSE VAR OUTID.X ACID LINE\n  ACID = WORD(OUTID.X,1)\n  if acid = \"TSS0300I\" then iterate x\n  IF ACID = \"ACCESSORID\" THEN ACID= WORD(OUTID.X,3)\n  W.REPNUM = ACID\n  W.REPNUM1 = ACID\n  IF (ACID = \"*\") | (ACID = \"*NONE*\") THEN DO\n    QUEUE LINE\n    ITERATE X\n  END\n  LINE = W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\n  IF LINE \u00ac= \"=\" THEN\n    QUEUE LINE    /* NO BLANK LINES! */\nEND\nQUEUE \" \"\nQUEUE \"@@\"\nqueue\nSIGNAL OFF ERROR\nsecrc = \"TSA223I: group commmand stream placed in dsn \" dsn1\nIF MODE = \"ONLINE\" THEN  DO\n  \"EXECIO * DISKW OUT1 (FINIS)\"\n  \"FREE DDN(OUT1)\"\nEND\nIF MODE = \"BATCH\" THEN DO\n  \"EXECIO * DISKW BJCL (FINIS)\"\n   SECRC = \"COMPLETED. COMMAND STREAM APPENDED TO BATCH FILE \"\nEND\n\"FREE DDN(IN1)\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52GDAT": {"ttr": 8465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x07\\x00P\\x00\\x97 /\\x01\\x04\\x08/\\x11\\x15\\x00\\x95\\x00\\x90\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.07", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2004-03-22T11:15:50", "lines": 149, "newlines": 144, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T52GDAT                           **/\n/** LAST MODIFIED    : 02 MAY 96                         **/\n/**********************************************************/\n/** ADDED SUPPORT FOR MULTIPLE WORD FIELDS AND THE       **/\n/** SPECIAL REQUIREMENTS OF THE PROFILE FIELD..DR        **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : ANY TSS ACID                               **/\n/** FIELD   : THE TSS FIELD THE CALLER WANTS TO RECEIVE  **/\n/**           BACK                                       **/\n/** DATA    : THE TYPE OF LIST I MUST DO. (NOT REQ)      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** NONE                                                 **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 04 08 16                  **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES (VPUT OF SECRC)             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG ACID FIELD DATA\n/* SAY ACID FIELD DATA */\nHEX00 = '00'X\n/** IF THE FIELD REQUESTED IS ONE THAT NEEDS MULTIPLE    **/\n/** WORDS PASSED BACK TO THE CALLER THEN SET THE MULT.  **/\n/** VARIABLE TO YES BELOW... DIR JAN 97                 **/\nMULT.USED = \"YES\"\nMULT.NAME = \"YES\"\nMULT.PROFILES = \"YES\"\nMULT.INSTDATA = \"YES\"\nMULT.BYPASSING = \"YES\"\nMULT.ATTRIBUTES = \"YES\"\n/* SAY \"T52GDAT: HAS CONTROL PARMS \" ACID FIELD DATA */\nGOTIT = \"NO\"\nIF DATA = \" \" THEN DATA = \"BASIC\"\nSIGNAL ON ERROR NAME BADDATA\nQ = OUTTRAP(OUTID.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nSIGNAL ON ERROR NAME SEEYA\nDO X = 1 TO OUTID.0\n  X1 = X+1 ; X2 = X+2 ; X3 = X+3 ; X4 = X+4\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTID.X=TRANSLATE(OUTID.X,\" \",HEX00)\n  PARSE VAR OUTID.X W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12\n  WNUM = WORDS(OUTID.X)\n  DO T = 1 TO WNUM\n    IF WORD(OUTID.X,T) = FIELD THEN DO\n      /* SAY \"T52GDAT: LINE IS \" OUTID.X                 */\n      /*SAY \"T52GDAT: FIELD IS\" FIELD                    */\n      /*SAY \"T52GDAT: GOT IT ON LINE \" X \" WORD \" T      */\n      T1 = T + 1\n      T2 = T + 2\n      T3 = T + 3\n      SECRC = W.T2\n      /* SAY \"T52GDAT: SETTING INITIAL SECRC TO \" SECRC    */\n      IF FIELD = \"DEPT\" THEN SECRC = W.T3\n      IF (FIELD = \"TYPE\") & (W.T3 = \"C/A\") THEN\n        SECRC = SECRC||\"CA\"\n /*   IF FIELD = \"NAME\" THEN */\n /*     SECRC = SECRC  W.T3  */\n      /**************************************************/\n      /** BELOW IS SUPPORT FOR A FIELD THAT HAS MULTIPLE*/\n      /** PARMS, LIKE PROFILES ...DIR 2 MAY 96          */\n      /**************************************************/\n      IF MULT.FIELD = \"YES\" THEN DO\n        IF FIELD = \"PROFILES\" THEN DO\n          /**************************************/\n          /** IF IT IS A PROFILES REQUEST WE   **/\n          /** SCAN AHEAD AND LOAD THE CURRENT  **/\n          /** LINE WITH ALL THE PROFILES IN THE**/\n          /** NEXT 4 LINES, THUS SUPPORTING 5  **/\n          /** FULL LINES OF PROFILES OR 20 OF  **/\n          /** THOSE BUGGARS.   DIR 2 MAY 96    **/\n          /**************************************/\n          /* SAY \"T52GDAT: PROFILE ROUTINE IN CONTROL\"        */\n          NW1 = WORD(OUTID.X1,1)\n          NW2 = WORD(OUTID.X2,1)\n          NW3 = WORD(OUTID.X3,1)\n          NW4 = WORD(OUTID.X4,1)\n          IF NW1 = \"PROFILES\" THEN W.8 = SUBSTR(OUTID.X1,14)\n          IF NW2 = \"PROFILES\" THEN W.9 = SUBSTR(OUTID.X2,14)\n          IF NW3 = \"PROFILES\" THEN W.10 = SUBSTR(OUTID.X3,14)\n          IF NW4 = \"PROFILES\" THEN W.11 = SUBSTR(OUTID.X4,14)\n          /**************************************/\n          /** LETS TELL THE NEXT ROUTINE THERE **/\n          /** ARE MORE WORDS THAN THERE USED TO**/\n          /** BE IN THE CURRENT LINE.DR 2 MAY96*/\n          /**************************************/\n          WNUM = 11\n        END\n        /*SAY \"T52GDAT: MULTIPLE WORD FIELD DETECTED.\"    */\n        /*SAY \"T52GDAT: COUNTING FROM \"T2 \" TO \" WNUM     */\n        ALLDATA = \"\"\n        DO W1 = T2 TO WNUM\n          IF W.W1 = \"=\" THEN LEAVE /* WE HAVE HIT THE NEXT VALUE */\n          ALLDATA = ALLDATA  W.W1\n        END\n        SECRC = ALLDATA\n      END\n      GOTIT = \"YES\"\n    END\n    IF GOTIT = \"YES\" THEN LEAVE\n  END\n  IF GOTIT = \"YES\" THEN LEAVE\nEND\nSIGNAL OFF ERROR\n/*****************************************************************/\n/** NOT FINDING AN INTERVAL MAY BE OK PASS BACK A ZERO.         **/\n/*****************************************************************/\nIF (GOTIT = \"NO\") & (FIELD = \"INTERVAL\") & (DATA \u00ac= \"BASIC\") THEN DO\n  GOTIT = \"YES\"\n  SECRC = 0\nEND\nIF GOTIT = \"YES\" THEN DO\n  /* SAY \"T52GDAT: FIELD \"FIELD\" WAS FOUND. VALUE IS \" SECRC   */\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSECRC = \"$NOTFOUND\"\n/* SAY \"T52GDAT: FIELD \"FIELD\" WAS NOT FOUND. SECRC IS \" SECRC  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nBADDATA: NOP\nSECRC  = \"$BADTSS\"\nSAY \"T52GDAT: ERROR ROUTINE ENTERED, LIST DATA IS\" DATA\nSAY \"T52GDAT: \"ACID FIELD DATA\nIF WORD(OUTID.1,1) = \"TSS0352E\" THEN DO\n  SECRC = \"$BADAUTH\"\n  SAY \"T52GDAT: ID IS NOT OWNED WITHIN SCOPE OF CONTROL\"\nEND\nIF WORD(OUTID.1,1) = \"TSS0314E\" THEN DO\n  SECRC = \"$BADACID\"\n  SAY \"T52GDAT: No such TSS ACID.\"\nEND\nSAY \"T52GDAT: SECRC IS BEING SET TO \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSEEYA: NOP\nSAY \"T52GDAT: AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52GDEL": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00A\\x00\\x97 /\\x01\\x00\\x07_\\x10S\\x00n\\x00n\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-03-15T10:53:41", "lines": 110, "newlines": 110, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** Creates a batch job that will delete multiple ids    **/\n/** under a department or division, depending on how many**/\n/** times the job is submitted                           **/\n/** submit it once:  Deletes all users and profiles      **/\n/**                  but leaves the departments that     **/\n/**                  had IDs in them.                    **/\n/** submit it twice: Deletes all the newly emptied depts **/\n/** submit it thrice Deletes the dept or division.       **/\n/**********************************************************/\n/** exec name        : T50GDEL                           **/\n/** last modified    : 06 jul 97                         **/\n/**********************************************************/\n/**----------------input required -----------------------**/\n/** passed args        valid values                      **/\n/** acid    : the one to be replaced                     **/\n/** mode    : the mode of operation                      **/\n/** ispf vgets         valid values                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T50GDAT T50pwho      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS ISPEXEC\nIF MODE = \"BATCH\" THEN DO\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nenv = sysvar(sysenv)\nIF MODE \\= \"BATCH\" THEN DO\n  secrc =\"TSA236E: failed. global delete cannot be run in online mode.\"\n  \" VPUT SECRC PROFILE   \"\n  say \"TSA101D: T50GDEL global delete cannot be run in online mode\"\n  EXIT 04\nEND\nSay \"TSA101D: T50GDEL Batch mode detected. using ddname BJCL as output.\"\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS AN ID    , FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO DELETE THOSE IDS            */\n/********************************************************************/\nSTARTOUT: NOP\n/*                                                              */\n/*IF MODE = \"BATCH\" THEN DO                                     */\n/*     ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"        */\n/*END                                                           */\nOUTNUM =  1\n/***********/\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T50PWHO \"ACID \"YES\"\nSAY \"TSA101D: # of lines of output return from TxxPWHO is\" OUT.0\nQ = OUTTRAP(\"XX.\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  SAY strip(INLINE)\n  ID=WORD(INLINE,1)\n  IF WORD(INLINE,1) = \"ACCESSORID\" THEN ID = WORD(INLINE,3)\n  IF ID = TSS0300I THEN LEAVE\n  /************************************************************/\n  /*                                                          */\n  /************************************************************/\n  say \"TSA101D: T50GDEL issuing \" ADDRESS TSO \"%T50GDAT \"ID \" TYPE \"\n  ADDRESS TSO \"%T50GDAT \"ID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  say \"TSA101D: T50GDEL deleting logic for id:\" id \"type:\" type\n  IF MODE = \"ONLINE\" THEN\n    say \"TSA101D: T50GDEL online mode ignored.\"\n    /* ADDRESS TSO \" TSS REMOVE(\"ID\")\" */\n  IF MODE = \"BATCH\" THEN DO\n    IF TYPE = \"PROFILE\" THEN\n      BJCL.OUTNUM = \"ISPSTART CMD(%T50DISC \"ID\")\"\n    IF TYPE = \"PROFILE\" THEN OUTNUM = OUTNUM + 1\n    BJCL.OUTNUM = \"TSS DEL(\"ID\")\"\n    OUTNUM = OUTNUM + 1\n  END\nEND\nOUTSTART: NOP\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nsecrc= \"TSA237I: function completed. output appended to batch file.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nEXIT\n/*************************************/\nCLOSEEM: NOP\nSIGNAL OFF ERROR\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nSAY \"****************************************************\"\nSAY \"LINE IS \"SIGL\nX = SOURCELINE(SIGL)\nSAY X\nSAY  SECRC id type\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52GREP": {"ttr": 6665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x17\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00y\\x00y\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:17", "lines": 121, "newlines": 121, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED ALL LOCATION PROCESSING WITH USE OF AFTER    **/\n/** KEYWORD DIR 2 OCT 97                                 **/\n/**********************************************************/\n/** TO GLOBALLY REPLACE A PROFILE WITH ANOTHER           **/\n/**********************************************************/\n/** EXEC NAME        : T50GREP                           **/\n/** LAST MODIFIED    : 02 OCT 97                         **/\n/**********************************************************/\n/** TOTALLY REWRITTEN TO IMPROVE SPEED BY 1000%          **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** NEWACID : THE ONE TO REPLACE IT WITH                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NOTUSED\nADDRESS ISPEXEC\n\"      VGET DISP PROFILE     \"\n\"      VGET MODE PROFILE     \"\n\"      VGET DS1 PROFILE     \"\n\"      VGET DS2 PROFILE     \"\n\"      VGET DS3 PROFILE     \"\n\"      VGET DS4 PROFILE     \"\n\"      VGET DS5 PROFILE     \"\n\"      VGET DS6 PROFILE     \"\nMYCODE = 0\nTOTAL_RC = 0\nACID = TRANSLATE(ACID,\" \",\".\")\nNEWACIDS = TRANSLATE(NEWACID,\" \",\".\")\nIF INDEX(\" \"NEWACID\" \",\" \"ACID\" \") \\= 0 THEN DO\n  msg2  = \"TSA241W: Warning - cannot replace an ACID with itself.\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE   \"\nEND\nSECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n\"      VPUT SECRC PROFILE   \"\nSIGNAL ON ERROR NAME CLOSEEM\nOUTFILE.0 = 0\nSTARTOUT: NOP\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS3\") \"DISP\" REUS\"\n  ADDRESS TSO \"ALLOC DDN(JCLFILE) DSN(\"DS6\") SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR JCLFILE ( FINIS STEM OUTFILE.)\"\nEND\nOUTNUM = OUTFILE.0 + 1\n/***********/\nQ = OUTTRAP(DROPOUT.)\nSIGNAL OFF ERROR\nDO T1 = 1 TO WORDS(NEWACIDS)\n  LISTACID = WORD(NEWACIDS,T1)\n  ADDRESS TSO \"TSS LIST(\"LISTACID\") DATA(BASIC)\"\n  TOTAL_RC = TOTAL_RC + RC\n  IF TOTAL_RC > 0 THEN BADID = LISTACID\nEND\nIF TOTAL_RC \\=0 THEN DO\n  MSG2 = \"TSA242W: Warning\"\n  msg2 = msg2 badid \" profile was unlistable jcl may not be valid.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T50PWHO \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF SECRC = \"$BADTSS\" THEN DO\n  secrc = \"TSA243E: Aborted.\"\n  secrc = secrc acid\" profile was unlistable. Check validity.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nEND\nSIGNAL ON ERROR NAME CLOSEEM\nQ = OUTTRAP(\"OFF\")\nsay \"TSA101D: Pwho generated \"out.0 \"lines of output .\"\nif out.0 = 0 then do\n  secrc = \"TSA246E: Unable to find attached ACIDs for replace stream\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nend\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  ID = WORD(OUT.X,1)\n  IF ID = \"ACCESSORID\" THEN ID = WORD(OUT.X,3)\n  OUTFILE.OUTNUM =\"TSS ADD(\"ID\") PROFILE(\"NEWACIDS\") AFTER(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\n  OUTFILE.OUTNUM =\"TSS REM(\"ID\") PROFILE(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\nEND\nOUTSTART: NOP\nOUTFILE.OUTNUM = \" \"\nOUTDD = \"OUTFILE\"\nIF MODE = \"BATCH\" THEN OUTDD = \"BJCL\"\nADDRESS MVS \"EXECIO * DISKW \"OUTDD\" ( FINIS STEM OUTFILE.)\"\nSECRC= \"TSA244I: Replace stream generated output in \" DS3\nIF MODE = \"BATCH\" THEN\nsecrc= \"TSA245I: Replace stream appended to batchfile.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\nCLOSEEM: NOP\nSAY \"TSA101D: T50grep error line is \"SIGL\nSAY \"TSA101D: secrc is \"  SECRC\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52ICOMO": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x03\\x16O\\x01\\x03\\x16O\\x08$\\x07\\xbf\\x07\\xbf\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-06-13T00:00:00", "modifydate": "2003-06-13T08:24:26", "lines": 1983, "newlines": 1983, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** added convert support for d,g and t,g in volume      **/\n/** rules  dir may 5 2002                                **/\n/**********************************************************/\n/**********************************************************/\n/** changed some doc spelling DIR FEB 22 2002            **/\n/**********************************************************/\n/** Change to modrule routine to totally remove the      **/\n/** scrolling area of that routine... I don't even know  **/\n/** why that section of the routine was there....        **/\n/**                  DIR Novem 05 2001                   **/\n/**********************************************************/\n/**********************************************************/\n/** July 25 2001 - documentation updates                 **/\n/**********************************************************/\n/** Change to debug modify processing to fix errant ptr  **/\n/** Which caused some scrolling to miss records and      **/\n/** caused records selected during modify to be wrongly  **/\n/** grabbed.         DIR april 12 2001                   **/\n/**********************************************************/\n/** Discovered that modify will not support stacked/     **/\n/** owned resources, and that it would be a bear to      **/\n/** fix so I am leaving it alone.                        **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T52ICOMP                          **/\n/** LAST MODIFIED    : 5 Novem     2001                  **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T52JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/**                                                      **/\n/** defgroup = the defgroup OMVS group for invoking the  **/\n/**            %GIVEUID exec.                            **/\n/**                                                      **/\n/** DS1      = work dsn #1 in the SPI system             **/\n/**                                                      **/\n/** DS2      = work dsn #2 in the SPI system             **/\n/**                                                      **/\n/** idebug   = a debug value that can be set to override **/\n/**            debug values in this exec                 **/\n/**                                                      **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/** newpass  = The password value to be used in converts **/\n/**                                                      **/\n/** uidcon   = a value to specify if UIDs are converted  **/\n/**            'as is' or if the %giveuid exec is to be  **/\n/**             used instead.                            **/\n/**            NO =  The GIVEUID exec is issued for a new**/\n/**              UID, unless UID is zero.                **/\n/**            YES = The exact UID will be replicated    **/\n/**              A UID of zero is always be replicated   **/\n/**                                                      **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were passed to me  **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/**********************************************************/\n/** IN the below variables the 'name' area is a variable **/\n/**  which is an actual ACID                             **/\n/**********************************************************/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/** acidrul.name.#.0type    the type                     **/\n/** acidrul.name.#.0segment the segment                  **/\n/** acidrul.name.#.0resname the resource name            **/\n/** acidrul.name.#.0restext the resource text            **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** In the below variable name and type and resource     **/\n/**   are all variables !!                               **/\n/**********************************************************/\n/** acidath.name.type.resource                           **/\n/**                    The actual translated data from   **/\n/**                      the TSS list, with all relevant **/\n/**                      data in this one variable.      **/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** convert.0newid    \"YES\" or \"NO\" depending on if the  **/\n/**                      ACID is changing in the convert **/\n/** convert.0name     The new ACID to replace real one   **/\n/**                      in the ouput stream             **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.convert  = \"YES\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\nDEBUG.GETDATA  = \"YES\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  /*****************************************************************/\n  /* idebug is a value that can be set in the T$$ execs to turn on */\n  /* a specific debug. U&sually for testing something.             */\n  /*****************************************************************/\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /**         The MAKECUST variable               **/\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command.                       **/\n  /** This would be used if you were moving IDs to**/\n  /** another environment and wanted a certain    **/\n  /** command included in the convert to          **/\n  /** support that environment.                   **/\n  /**                           DIR 25 july 2001  **/\n  /**                                             **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\n  /*************************************************/\n  /** A makeauth command is basically a convert   **/\n  /** with two changes:                           **/\n  /** 1 - The new ID is $$                        **/\n  /** 2 - The tss create command is not done      **/\n  /**                                             **/\n  /*************************************************/\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\nsay \"TSA101D: makeauth check was \" make_rc makeauth\nif make_rc = 0 then do\n  /*************************************************/\n  /** Makeacid is just a type of CLONE really     **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n     /* tells the convert routine to change all outbound ACID */\n  convert.0name = \" $$ \"  /* this is the new ACID name */\n  makeacid.0auth = \"YES\"  /* tell the makeacid routine */\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  /*************************************************/\n  /** a clone is a convert with a new ID plugged  **/\n  /** into the output, so we set some flags and   **/\n  /** then change function to REBUILD.            **/\n  /**                                             **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  /*************************************************/\n  /** We use the makeauth feature to plug in the  **/\n  /** %addlocal command into the output           **/\n  /**                                             **/\n  /*************************************************/\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"ANIDTOTRACE\"              /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Nov 21 2002\"\nsay \"TSA101D: T52ICOMP in control with parms \" function acidlist\nsay \"TSA101D: T52ICOMP Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nsecrc = \"failed in T52ICOMP. no other information available\"\nsecrc = \"failed during jobcard function\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\n  /*****************************************************************/\n  /** A resource function uses an entirely different variable     **/\n  /** loader routine since the input is in a radically different  **/\n  /** format.                                                     **/\n  /**                                                             **/\n  /**                                                             **/\n  /*****************************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    if debug.flow = \"YES\" then\n      say \"TSA101D: calling jobcard function. \"\n    address tso \"%T52jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"TSA101D: Output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 15\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\n/* BYPASS.HOLD.7 = \"* ACID \"  */\n/* commented above due to the need for admin auth to function */\nBYPASS.HOLD.7 = \"* ACIDS\"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9  = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"* TCONS\"\nBYPASS.HOLD.15 = \"* TRBA\"\nBYPASS.HOLD.15 = \"* TUPT\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 10\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"* LASTUSED\"\nBYPASS.HOLD.6  = \"AUTHORITY ACID\"\nBYPASS.HOLD.7  = \"BASE ZONEACID\"\nBYPASS.HOLD.8 = \"* TCONS\"\nBYPASS.HOLD.9 = \"* TRBA\"\nBYPASS.HOLD.10 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\n/*****************************************************************/\n/*****************************************************************/\n/* all variables are initialized.....the main section(s) follow  */\n/*****************************************************************/\n/*****************************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Basic initialization complete, execution begins.\"\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  say \"TSA101D: Resource processing started\"\n  /*****************************************************************/\n  /* Lets either issue the tss list or read in the data from file  */\n  /*****************************************************************/\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  /*****************************************************************/\n  /* I code the two ifs this way because an else when in multiple  */\n  /* loops is confusing...dir                                      */\n  /*****************************************************************/\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"TSA101D: Bypass option specified, allocating input DSN\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      if debug.resource = \"YES\" then\n        say \"Owner = \" acidnum \"name = \" owner\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      /* lets grab the acid */\n      parse var line drop 'ACID(' name ')' drop2\n    /*****************************************************************/\n    /* In resources the ACID with the auth is way to the right on    */\n    /*  the report so we note each of them for future reference      */\n    /*  Note the .name portion of the below variable insures that    */\n    /*  even if one ACID has authorites in multiple areas of the     */\n    /*  output, it is counted only once. The classic variable named  */\n    /*  variable....                                                 */\n    /*****************************************************************/\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\"\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      if debug.resource = \"YES\" then\n        say \"acidnum = \" acidnum \"name = \" name\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"TSA101D: Total acids referenced in input is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"TSA101D: Bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"TSA101D: Total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  acids.0 = words\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    say \"TSA101D: Listing ACID \"hold\" with data \"data \".\"\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we create  the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Evaluation of TSS generated data begins.\"\nevaluate: nop  /* a branch to point for a resource convert */\n/*************************************************/\n/*************************************************/\n/** The below routine does the exact same thing **/\n/** for both resource and standard output, since**/\n/** the variable structure created above is the **/\n/** same for either.                            **/\n/*************************************************/\n/*************************************************/\ndo num = 1 to acidnum\n  /************************************************/\n  /**This outer loop is once for each acid passed**/\n  /** to me. Dave 18 June 99                     **/\n  /************************************************/\n  rules = 0\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"TSA101D: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"         Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    acidrul.name.a1.0concat  = \"NO\"\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if debug.trans = \"YES\" then say line\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    end\n    first11 = substr(line,1,11)\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if debug.trans = \"YES\" then\n        say \"TSA101D:  Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      if debug.trans = \"YES\" then\n       say \"TSA101D: lcf detected:\" w.2\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area input line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n      w.1 = w.1\".\"savefac\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area reformated line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) tzq1\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T52ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n      /*say \"       \"acidath.name.type.resource  */\n      acidrul.name.rules.0concat  = \"YES\"\n /*   say \"Setting concat to yes for record \" rules  */\n      hold1 = acidrul.name.rules.0concat\n      hold = restext(rules)\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: Concat rule \",\n        \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.rules = segment type resource duplicat\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource\n    acidrul.name.rules.0segment = segment\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidrul.name.rules.0restext = \" \"\n    do t1 = 3 to words\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) strip(w.t1)\n    end\n    if debug.trans = \"YES\" then do\n      say \" TSA101D: Type/Rname/Text =\" acidrul.name.rules.0type\"/\",\n      acidrul.name.rules.0resname\"/\",\n      acidrul.name.rules.0restext\n    end\n  end\n  acidrul.name.0 = rules\nend\nif debug.flow = \"YES\" then\n  say \"TSA101D: Translation streams have been built.\",\n  \"Starting function check.\"\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter                                     */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Permit/rebuild/revoke area in control.\"\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do x = 1 to acidnum\n    name = acids.x\n    say \"TSA101D: Starting to process ACID:\" x \">\"name\"<\"\n    say \"          Rules#:\" acidrul.name.0\n    do t = 1 to acidrul.name.0\n      if debug.flow = \"YES\" then\n        say \"TSA101D: Starting to process \"name \" Rule #\" t\n      if debug.name.t = \"TRACE\" then trace r\n      call getdata t\n      hold = next\n      record_number = t\n      call convert function hold\n      trace off\n    end\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = acidrul.name.0\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"TSA101D:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: S found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: D found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n        acidrul.name.y = segment type resource\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: M found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        say \"TSA101D: t=\" t \"thisrec=\" thisrec\n        say \"TSA101D: Subscript is now:\" y\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          say \"TSA101D:\"\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs\n          setf = setflag(y,'*MODIFY')\n          acidrul.name.y.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidrul.name.y.0resname  = rsname\n          acidrul.name.y.0restext  = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: A found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T52ICOMP:addition routine entered outnum=\" outnum\n        say \"T52ICOMP:addition routine entered target=\" target\n        say \"T52ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T52ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: Calling modrule\"\n        end\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setflag(fill,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        acidrul.name.fill.0segment  = segment\n        acidrul.name.fill.0resname  = rsname\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"TSA101D: leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then\n  say \"acidrul.name array || multiline ? || segment || data \"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nif debug.makeacid = \"YES\" then\n  say \"TSA101D: Making ACID:\" function\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    if debug.makeacid = \"YES\" then\n      say \"TSA101D: Owner resolved to:\" own_str\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  if debug.makeacid = \"YES\" then\n    say \"TSA101D: Makeacid type for \"name\" is :\" acid_type\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif debug.makeacid = \"YES\" then\nsay \"TSA101D: leaving makeacid # output = \"create_num create.1 create.2\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  acidrul. cvtnum concat lcffac debug. convert. record_number\nparse arg function segment inline\nsay \"TSA101D: convert called with \" function segment inline\noname = name\nconcat = acidrul.name.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nif debug.flow = \"YES\" then\n  say \"TSA101D: output name for convert is \" oname \"concat is\" concat\nif debug.flow = \"YES\" then\n  say \"TSA101D: Converting for \"name\":\"function segment \">\"||inline||\"<\"\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XAVOLUME\") then do\n  /*********************************************************/\n  /* a volume generic of (d,g) or (t,g) is invalid so we   */\n  /* handle it here.                                       */\n  /*********************************************************/\n  where_gen = index(inline,\",G)\")\n  if where_gen /= 0 then do\n    if debug.convert = \"YES\" then\n      say \"TSA101D: Vol generic, Input dsn line \"inline\n     parse var inline hz1  ',' hz2\n    inline = hz1||hz2\n    if debug.convert = \"YES\" then\n      say \"TSA101D: Reformatted vol generic line \"inline\n  end\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Input dsn line \"inline\n  inline = \"XADSN\"||substr(inline,10)\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatted dsn line \"inline\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" %giveuid \" oname defgroup\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\n  IF W.1 = \"SCOPEACID\" THEN W.1 = \"SCOPE\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MASTFAC\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif acidrul.name.record_number.0concat = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = acidrul.name.record_number.0concat\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"TSA101D: XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nif debug.convert = \"YES\" then\n  say \"TSA101D: Resource is \"resource \"concat is\" concat\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  if debug.convert = \"YES\" then do\n    rule = bypass.function.rulehold\n    say \"TSA101D: bypass rule tripped, Rule is below:\"\n    say \"     \" Rule\n  end\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then\n  say \"TSA101D:***** CONVERT OUTPUT IS NOW :\" output\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T52ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. acidath. name hex00 aciddup. debug. balance. function balout\nOPT = \" \"\nif debug.fillscr = \"YES\" then\n  say \"TSA101D: Fillscr invoked. Thisrec=\" thisrec\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T52ICOMP: TOP OF DATA REACHED\"\nEND\nh1 = acidrul.name.0 - 13\ntempz1 = acidrul.name.0\n/* save this value for the display below*/\nif debug.fillscr = \"YES\" then\n    say \"TSA101D: h1=\" h1 \"acidrul.\"name\".0=\"  tempz1\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 13\n  MSG = \"T52ICOMP: BOTTOM OF DATA REACHED\"\n  if debug.fillscr = \"YES\" then\n    say \"TSA101D: Bottom of data thisrec set to :\"thisrec\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T52ICOMP: TOP OF DATA REACHED\"\nEND\nif debug.fillscr = \"YES\" then do\n  say \"FILLSCR: thisrec=\" thisrec\n  say \"TSA101D: filling screen:\",\n    \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\nend\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  maxdata = acidrul.name.0\n  if debug.fillscr = \"YES\" then do\n    say \"TSA101D: fillscr calling subfunctions with subscript:\" script\n    say \"         maxdata is:\" maxdata\n  end\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if debug.fillscr = \"YES\" then do\n    say \"TSA101D: fillscr segment=\"segment\n    say \"   type=\"type \"resource=\"resource \"fchk=\"fchk\n  end\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  respass = acidath.name.type.resource\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose acidath. name acidrul. aciddup. next\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. aciddup. next acidlst.\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug. record_number\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsegment  = strip(acidrul.name.t.0segment)\ntype     = strip(acidrul.name.t.0type)\nresource = strip(acidrul.name.t.0resname)\ntheres   = strip(acidrul.name.t.0restext)\ndupchk   = \"\"\ndupnum   = \"\"\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t.0resname\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetdatao: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsay \"new getdata results:\"\nsay acidrul.name.t.0segment\nsay acidrul.name.t.0type\nsay acidrul.name.t.0resname\nsay acidrul.name.t.0restext\nsay \"*******\"\nsegment  = strip(word(acidrul.name.t,1))\ntype     = strip(word(acidrul.name.t,2))\nresource = strip(word(acidrul.name.t,3))\ndupchk   = strip(word(acidrul.name.t,4))\ndupnum   = strip(word(acidrul.name.t,5))\ntheres = acidath.name.type.resource\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = strip(word(acidrul.name.t,1))\ngetdata.0type     = strip(word(acidrul.name.t,2))\ngetdata.0resource = strip(word(acidrul.name.t,3))\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult  = acidrul.name.tempin.0segment\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult  = acidrul.name.tempin.0type\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult  = acidrul.name.tempin.0resname\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult  = acidrul.name.tempin.0restext\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = acidrul.name.tempin.0flag\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult  = acidrul.name.tempin.0resname\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. acidath. name acidrul. conlist modrule. rstype debug.,\n fill_override balance.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\n/*\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"T52ICOMP: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\nif (thisrec > h1 )  then do\n  thisrec = h1\n  msg = \"T52ICOMP: bottom of data reached\"\nend\n*/\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52ICOMP": {"ttr": 11265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01;\\x00@\\x01\\x02 o\\x01\\x07\\x04O\\t9\\x08\\\\\\x08=\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.59", "flags": 0, "createdate": "2002-07-25T00:00:00", "modifydate": "2007-02-13T09:39:40", "lines": 2140, "newlines": 2109, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** Updated comments                        7/27/04      **/\n/**********************************************************/\n/** Fixed array load error which would invalidate        **/\n/** converts..                              12/1/03      **/\n/** Very important fix....                               **/\n/**********************************************************/\n/** Fixed MASTFAC syntax on converts         9/17/03     **/\n/**********************************************************/\n/** Fixed volume rules for (D) specification 9/15/03     **/\n/**********************************************************/\n/** updated modrule varname error   Aug 21 2003  DIR     **/\n/**********************************************************/\n/** updated getval routine to return blanks when a var   **/\n/** has not been assigned a value     Aug 5 2003  dir    **/\n/**********************************************************/\n/** created DL subroutine to write log data to           **/\n/** writedebug log  July 2003                            **/\n/**********************************************************/\n/**********************************************************/\n/** Updated allacid. array processing and adding comments**/\n/** Removed the acidrul array                            **/\n/**********************************************************/\n/**********************************************************/\n/** Started conversion to one array instead of one array **/\n/** for each acid instream. nov 22 2002                  **/\n/**********************************************************/\n/**********************************************************/\n/** added convert support for d,g and t,g in volume      **/\n/** rules  dir may 5 2002                                **/\n/**********************************************************/\n/**********************************************************/\n/** changed some doc spelling DIR FEB 22 2002            **/\n/**********************************************************/\n/** Change to modrule routine to totally remove the      **/\n/** scrolling area of that routine... I don't even know  **/\n/** why that section of the routine was there....        **/\n/**                  DIR Novem 05 2001                   **/\n/**********************************************************/\n/**********************************************************/\n/** July 25 2001 - documentation updates                 **/\n/**********************************************************/\n/** Change to debug modify processing to fix errant ptr  **/\n/** Which caused some scrolling to miss records and      **/\n/** caused records selected during modify to be wrongly  **/\n/** selected         DIR april 12 2001                   **/\n/**********************************************************/\n/** Discovered that modify will not support stacked/     **/\n/** owned resources, and that it would be a bear to      **/\n/** fix so I am leaving it alone.                        **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T52ICOMP                          **/\n/** LAST MODIFIED    : 11June  2003                      **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T52JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/**                                                      **/\n/** defgroup = the defgroup OMVS group for invoking the  **/\n/**            %GIVEUID exec.                            **/\n/**                                                      **/\n/** DS1      = work dsn #1 in the SPI system             **/\n/**                                                      **/\n/** DS2      = work dsn #2 in the SPI system             **/\n/**                                                      **/\n/** idebug   = a debug value that can be set to override **/\n/**            debug values in this exec                 **/\n/**                                                      **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/** newpass  = The password value to be used in converts **/\n/**                                                      **/\n/** uidcon   = a value to specify if UIDs are converted  **/\n/**            'as is' or if the %giveuid exec is to be  **/\n/**             used instead.                            **/\n/**            NO =  The GIVEUID exec is issued for a new**/\n/**              UID, unless UID is zero.                **/\n/**            YES = The exact UID will be replicated    **/\n/**              A UID of zero is always be replicated   **/\n/**                                                      **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were passed to me  **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/**********************************************************/\n/** IN the below variables the 'name' area is a variable **/\n/**  which is an actual ACID                             **/\n/**********************************************************/\n/** The acidlst. arrays are the actual output from the   **/\n/**  TSS list command.                                   **/\n/**                                                      **/\n/**  NOTE: The ACIDS. array has one entry for each listed**/\n/**        ACID, it is the source for the name below...  **/\n/**                                                      **/\n/**                                                      **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** The ALLACID array is a sequential array that has one **/\n/** translated rule for each listed ACID                 **/\n/**                                                      **/\n/** Note: This array should be accessed by the SETVAL and**/\n/**       GETVAL functions, not accessed natively in the **/\n/**       main routine.                                  **/\n/**                                                      **/\n/** allacid.0          How many total lines of data      **/\n/** allacid.#.0acid    the acid this line relates to     **/\n/** allacid.#.0type    the type                          **/\n/** allacid.#.0segment the segment                       **/\n/** allacid.#.0resname the resource name                 **/\n/** allacid.#.0restext the resource text                 **/\n/** allacid.#.0concat  is this line to be concatenated   **/\n/**                    to the previous one ? ie part of  **/\n/**                    a multi line permission...        **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                  ARRAY FLOW                          **/\n/**   _______     _______      _______                   **/\n/**  |       |   |       |    |       |                  **/\n/**  | lst1  |   | lst2  |    | lst3  |  acidlst. arrays **/\n/**  |       |   |       |    |       |                  **/\n/**  |_______|   |_______|    |_______|                  **/\n/**      |           |            |                      **/\n/**      |           |            |                      **/\n/**      |___________|____________|                      **/\n/**                  |                                   **/\n/**               _______                                **/\n/**              |       |                               **/\n/**              |       |                               **/\n/**              |  all  |               allacid. array  **/\n/**              |       |                               **/\n/**              |_______|                               **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** In the below variable name and type and resource     **/\n/**   are all variables !!                               **/\n/**********************************************************/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** convert.0newid    \"YES\" or \"NO\" depending on if the  **/\n/**                      ACID is changing in the convert **/\n/** convert.0name     The new ACID to replace real one   **/\n/**                      in the ouput stream             **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.convert  = \"NO\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\nDEBUG.GETDATA  = \"YES\"\nDEBUG.setval   = \"NO\"\nDEBUG.getval   = \"NO\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"YES\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget instcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  /*****************************************************************/\n  /* idebug is a value that can be set in the T$$ execs to turn on */\n  /* a specific debug. Usually for testing something.              */\n  /*****************************************************************/\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /**         The MAKECUST variable               **/\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command.                       **/\n  /** This would be used if you were moving IDs to**/\n  /** another environment and wanted a certain    **/\n  /** command included in the convert to          **/\n  /** support that environment.                   **/\n  /**                           DIR 25 july 2001  **/\n  /**                                             **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\n  /*************************************************/\n  /** A makeauth command is basically a convert   **/\n  /** with two changes:                           **/\n  /** 1 - The new ID is $$                        **/\n  /** 2 - The tss create command is not done      **/\n  /**                                             **/\n  /*************************************************/\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\n/*\nsay \"TSA101D: makeauth check was \" make_rc makeauth\n*/\nq=dl(,,\"makeauth check was \" make_rc makeauth)\nif make_rc = 0 then do\n  /*************************************************/\n  /** Makeacid is just a type of CLONE really     **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n     /* tells the convert routine to change all outbound ACID */\n  convert.0name = \" $$ \"  /* this is the new ACID name */\n  makeacid.0auth = \"YES\"  /* tell the makeacid routine */\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  /*************************************************/\n  /** a clone is a convert with a new ID plugged  **/\n  /** into the output, so we set some flags and   **/\n  /** then change function to REBUILD.            **/\n  /**                                             **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  /*************************************************/\n  /** We use the makeauth feature to plug in the  **/\n  /** %addlocal command into the output           **/\n  /**                                             **/\n  /*************************************************/\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"AN_ID_TO_TRACE\"            /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Dec 30 2003\"\nq=dl(,,\"T52ICOMP in control with parms \" function acidlist)\nq=dl(,,\" T52ICOMP Maint = \" maint)\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nsecrc = \"failed in T52ICOMP. no other information available\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\n  /*****************************************************************/\n  /** A resource function uses an entirely different variable     **/\n  /** loader routine since the input is in a radically different  **/\n  /** format.                                                     **/\n  /**                                                             **/\n  /**                                                             **/\n  /*****************************************************************/\nq=dl(,,\" Retrieving profile variables \")\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nsecrc = \"failed during jobcard function\"\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    q=dl(,,\" calling jobcard function. \" )\n    address tso \"%T52jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  q=dl(,,\" Output DSN unusable, data written to screen \")\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\nsecrc = \"failed in T52ICOMP. no other information available\"\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 13\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\nBYPASS.0SUPRESS.HOLD.13 = \"ACIDS\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 16\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\n/* BYPASS.HOLD.7 = \"* ACID \"  */\n/* commented above due to the need for admin auth to function */\nBYPASS.HOLD.7 = \"* ACIDS\"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9  = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"* TCONS\"\nBYPASS.HOLD.15 = \"* TRBA\"\nBYPASS.HOLD.16 = \"* TUPT\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 12\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"BASE DIVACID\"\nBYPASS.HOLD.5 = \"BASE ZONEACID\"\nBYPASS.HOLD.6 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.7 = \"* LASTUSED\"\nBYPASS.HOLD.8  = \"AUTHORITY ACID\"\nBYPASS.HOLD.9  = \"BASE ZONEACID\"\nBYPASS.HOLD.10= \"* TCONS\"\nBYPASS.HOLD.11= \"* TRBA\"\nBYPASS.HOLD.12 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\n/*****************************************************************/\n/*****************************************************************/\n/* all variables are initialized.....the main section(s) follow  */\n/*****************************************************************/\n/*****************************************************************/\nq=dl(,,\" Basic initialization complete, execution begins.\")\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  q=dl(,,\" Resource processing started\")\n  /*****************************************************************/\n  /* Lets either issue the tss list or read in the data from file  */\n  /*****************************************************************/\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  /*****************************************************************/\n  /* I code the two ifs this way because an else when in multiple  */\n  /* loops is confusing...dir                                      */\n  /*****************************************************************/\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    q=dl(,,\" Bypass option specified, allocating input DSN\")\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n                           /* below we save the starting line #  */\n                           /* of each acid.. not sure why        */\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      q=dl(,\"RESOURCE\",\"owner = \" acidnum \"name = \" owner )\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      /* lets grab the acid */\n      parse var line drop 'ACID(' name ')' drop2\n    /*****************************************************************/\n    /* In resources the ACID with the auth is way to the right on    */\n    /*  the report so we note each of them for future reference      */\n    /*  Note the .name portion of the below variable insures that    */\n    /*  even if one ACID has authorites in multiple areas of the     */\n    /*  output, it is counted only once. The classic variable named  */\n    /*  variable....                                                 */\n    /*****************************************************************/\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\" /* actually any non  NO value works */\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      q=dl(,resource,\"acidnum = \" acidnum \"name = \" name )\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    q=dl(,,\" Total acids referenced in input is \" acidnum )\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  q=dl(\"tsa101d\",,\" Bypass option specified, allocating input dsn\")\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  q=dl(\"tsa101d\",,\" Total acids contained in input DSN is \" acidnum)\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n    /* each acid receives its own list area.. should be one */\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    q=dl(\"tsa101d\",,\" Listing ACID \"hold\" with data \"data \".\" )\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we create  the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nq=dl(\"tsa101d\",,\" Evaluation of TSS generated data begins.\" )\nevaluate: nop  /* a branch to point for a resource convert */\n/*************************************************/\n/*************************************************/\n/** The below routine does the exact same thing **/\n/** for both resource and standard output, since**/\n/** the variable structure created above is the **/\n/** same for either.                            **/\n/*************************************************/\n/*************************************************/\nlinenum = 0\nlinehold= 0\nif debug.flow = \"YES\" then do\n  say \"TSA101D Evaluate routine in control values as follows:\"\n  say \"acidnum:  \" acidnum\n  say \"accessor.0\" accessor.0\n  say \"accessor.1\" accessor.1\nend\nrules = 0\ndo num = 1 to acidnum\n  /************************************************/\n  /**This outer loop is once for each acid passed**/\n  /** to me. Dave 18 June 99                     **/\n  /************************************************/\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"tsa101d: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"        Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  q=dl(\"tsa101d\",,\" Acidlst.\"name\".0 is\" acidlst.name.0)\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    /* */\n    /* the below statements just clear the variables... */\n    setf = setval(rules,0flag,hex00)\n/*  acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0concat  = \"NO\"\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    setf = setval(rules,0restext,\" \")\n    setf = setval(rules,0type,\" \")\n    setf = setval(rules,0segment,\" \")\n    setf = setval(rules,0concat,\"NO\")\n    setf = setval(rules,0resname,\" \") */\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if debug.trans = \"YES\" then do\n      say \"TSA101D: Translation starting for below data:\"\n      say \"         \"line\n    end\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    /*acidrul.name.a1.0concat  = \"YES\" */\n      setf = setval(rules,0concat,\"YES\")\n    end\n    first11 = substr(line,1,11)\n    /* below we take 2 words and make one for first 11 */\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      q=dl(\"tsa101d\",TRANS,\" Segment changed to \"segment \"for \" name)\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      q=dl(\"tsa101d\",trans,\" lcf detected:\" w.2)\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      q=dl(\"tsa101d\",trans,\" lcf area input line:\",\n      w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8)\n      w.1 = w.1\".\"savefac\n      q=dl(\"tsa101d\",trans,\" lcf area reformated line:\",\n      w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8)\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then linehold = linehold - 1\n    if linehold < 0 then linehold = 0\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = getval(rules,0restext)\n/*    acidrul.name.rules.0restext = strip(hold) tzq1 */\n      setv = setval(rules,0restext,strip(hold) tzq1)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T52ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n /*   acidrul.name.rules.0concat  = \"YES\" */\n      setf = setval(rules,0concat,\"YES\")\n /*   say \"Setting concat to yes for record \" rules  */\n /*   hold1 = acidrul.name.rules.0concat */\n      hold = restext(rules)\n      q=dl(\"tsa101d\",trans,\" Concat rule \",\n      \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold)\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n/*  acidrul.name.a1.0concat  = \"NO\"  */\n    setf = setval(rules,0ACID,name)\n    setf = setval(rules,0concat,\"NO\")\n/*  acidrul.name.rules = segment type resource\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource */\n    setf = setval(rules,\"RESET\",segment type resource)\n    setf = setval(rules,0segment,segment)\n    setf = setval(rules,0type,type)\n    setf = setval(rules,0resname,resource)\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n/*  acidrul.name.rules.0restext = \" \"  */\n    Setf = setval(rules,0restext,\" \")\n    do t1 = 3 to words\n      hold = getval(rules,0restext)\n/*    acidrul.name.rules.0restext = strip(hold) strip(w.t1)  */\n      setf = setval(rules,0restext,strip(hold) strip(w.t1))\n    end\n      q=dl(\"tsa101d\",trans,\" Type/Rname/Text =\" getval(rules,0type) \"/\",\n      getval(rules,0resname)\"/\",\n      getval(rules,0restext) )\n  end\n  /* acidrul.name.0 = rules */\n  linenum = linenum + rules\nend\nq=dl(\"Total lines of translated data is:\" linenum )\nallacid.0 = rules\nq=dl(\"tsa101d\",,\" Translation streams have been built.\",\n  \"Starting function check.\")\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter, or we did a translate function.    */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  q=dl(\"tsa101d\",,\" Permit/rebuild/revoke area in control.\")\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do t = 1 to allacid.0\n    q=dl(\"tsa101d\",,\" Starting to process LINE #\" t )\n    call getadata t\n    hold = next\n    record_number = t\n    name = allacid.t.0acid\n    q=dl(\"tsa101d\",,\" acid recnum next\" name record_number hold)\n    call convert function hold\n    trace off\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = linenum\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  q=dl(\"tsa101d\",,\" MODIFY starting to process ACID:\" name )\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    /* thisrec is the rec at the top of the screen */\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt /* scan the screen for an option */\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" S found on line\" t )\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        q=dl(\"tsa101d\",modify,\" D found on line\" t)\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n     /* acidrul.name.y = segment type resource */\n        setf = setval(y,\"RESET\",segment type resource,)\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" M found on line\" t )\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        q=dl(\"tsa101d\",\"MODIFY\",\" t=\" t \"thisrec=\" thisrec )\n        q=dl(\"tsa101d\",\"MODIFY\",\" Subscript is now:\" y )\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          SAY  \"TSA101D:\"\n          say \"MODIFY:segment type resource \"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          /* modrule creates the variable conlist     */\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs\n          setf = setflag(y,'*MODIFY')\n          /* */\n          setf = setval(y,0concat,\"YES\")\n        /*acidrul.name.y.0concat = \"YES\"\n          acidrul.name.y = segment type rsname  */\n          setf = setval(y,\"RESET\",segment type rsname,)\n          /*\n          acidrul.name.y.0resname  = rsname\n          */\n          setf = setval(y,0resname,rsname)\n          /*\n          acidrul.name.y.0restext  = modrule.newrs\n          */\n          setf = setval(y,0restext,modrule.newrs)\n          /* */\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          q=dl(\"tsa101d\",,\" secure routine failed access \")\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" A found on line\" t)\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T52ICOMP:addition routine entered outnum=\" outnum\n        say \"T52ICOMP:addition routine entered target=\" target\n        say \"T52ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T52ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          /*** zzzzebra **/\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          f = setval(q,0segment,getval(q1,0segment))\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          f = setval(q,0flag,getval(q1,0flag))\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          f = setval(q,0type,getval(q1,0type))\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          f = setval(q,0restext,getval(q1,0restext))\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n          f = setval(q,0resname,getval(q1,0resname))\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        q=dl(\"tsa101d\",\"MODIFY\",\" Calling modrule\")\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setval(fill,0concat,\"YES\")\n        setit = setflag(fill,\"*NEWRULE\")\n        setit = setval(fill,0flag,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        setit = setval(fill,0type,type)\n        acidrul.name.fill.0segment  = segment\n        setit = setval(fill,0segment,segment)\n        acidrul.name.fill.0resname  = rsname\n        setit = setval(fill,0resname,rsname)\n        acidrul.name.fill.0restext  = modrule.newrs\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  q=dl(\"tsa101d\",,\" leaving modify\")\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\n/*\nif function = \"TRANSLATE\" then\n  say \"acidrul.name array || multiline ? || segment || data \"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\n*/\nif function = \"TRANSLATE\" then do qt = 1 to allacid.0\n    say qt allacid.qt.0ACID,\n         allacid.qt allacid.qt.0restext\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nq=dl(\"tsa101d\",\"MAKEACID\",\" Making ACID:\" function )\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    q=dl(\"tsa101d\",\"MAKEACID\", \"makacid resolved to:\" own_str )\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  q=dl(\"tsa101d\",\"MAKEACID\",\" Makeacid type for \"name\" is :\" acid_type)\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nq=dl(\"tsa101d\",,\n\"makeacid\",\"leaving ma # out = \"create_num create.1 create.2)\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  instcon,\n  acidrul. cvtnum concat lcffac debug. convert. record_number allacid.\nparse arg function segment inline\nq=dl(\"tsa101d\",,\" convert called with \" function segment inline)\nname = getval(record_number,0acid)\noname = name\nq=dl(\"tsa101d\",,\" Output ACID name: \" oname)\nconcat = getval(record_number,0concat)\nif debug.newgdata = \"YES\" then concat = allacid.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nq=dl(\"tsa101d\",,\" Outname for con is \" oname \"concat is\" concat  )\nq=dl(\"tsa101d\",,\" Confor \"name\":\"function segment \">\"||inline||\"<\" )\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XAVOLUME\") then do\n  /*********************************************************/\n  /* a volume generic of (d,g) or (t,g) is invalid so we   */\n  /* handle it here.                                       */\n  /*********************************************************/\n  where_gen = index(inline,\",G)\")\n  if where_gen /= 0 then do\n    q=dl(\"tsa101d\",convert,\" Vol generic, Input dsn line \"inline )\n     parse var inline hz1  ',' hz2\n    inline = hz1||hz2\n    q=dl(\"tsa101d\",convert,\" Reformatted vol generic line \"inline)\n  end\n  where_gen = index(inline,\"(D)\")\n  if where_gen /= 0 then do\n    q=dl(\"tsa101d\",convert,\" Disk ref, Input dsn line \"inline )\n     parse var inline hz1  '(D)' hz2\n    inline = strip(hz1,t)||'(D)' hz2\n    q=dl(\"tsa101d\",convert,\" Reformatted Disk line \"inline)\n  end\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  q=dl(\"tsa101d\",convert,\" Input dsn line \"inline )\n  inline = \"XADSN\"||substr(inline,10)\n  q=dl(\"tsa101d\",convert,\" Reformatted dsn line \"inline)\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  q=dl(\"tsa101d\",convert,\" Reformat area completed convert. returning.\")\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  if instcon = \"NO\" then hold = \"000000\"\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  q=dl(\"tsa101d\",convert,\" Reformat area done convert. returning.\")\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" %giveuid \" oname defgroup\n  q=dl(\"tsa101d\",convert,\" Reformat area done convert. returning.\")\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\n  IF W.1 = \"SCOPEACID\" THEN W.1 = \"SCOPE\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MASTFAC\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif getval(record_number,0concat) = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = getval(record_number,0concat)\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"tsa101d XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nq=dl(\"tsa101d\",convert,\" Resource is \"resource \"concat is\" concat )\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n    q=dl(\"tsa101d\",\"CONVERT\",\" bypass rule tripped, Rule is below:\")\n    q=dl(\"tsa101d\",\"CONVERT\",bypass.function.rulehold)\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REM\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then do\n  say \"tsa101d: ***** CONVERT OUTPUT IS NOW :\"\n  say \"  \" output\nend\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T52ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. allacid. name hex00 debug. linenum function balout\nOPT = \" \"\nq=dl(\"tsa101d\",fillscr,\" Fillscr invoked. Thisrec=\" thisrec )\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T52ICOMP: TOP OF DATA REACHED\"\nEND\nh1 = linenum - 13\ntempz1 = linenum\n/* save this value for the display below*/\nq=dl(\"tsa101d\",\"FILLSCR\",\" h1=\" h1 \"acidrul.\"name\".0=\" tempz1 )\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 13\n  MSG = \"T52ICOMP: BOTTOM OF DATA REACHED\"\n  q=dl(\"tsa101d\",FILLSCR,\" Bottom of data thisrec set to :\"thisrec)\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T52ICOMP: TOP OF DATA REACHED\"\nEND\nif debug.fillscr = \"YES\" then do\n  say \"FILLSCR: thisrec=\" thisrec\n  say \"tsa101d     filling screen:\",\n    \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\nend\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  maxdata = acidrul.name.0\n  q=dl(\"tsa101d\",fillscr,\"fillscr calling with subscript:\" script)\n  q=dl(\"tsa101d\",fillscr,\"maxdata is:\"imaxdata )\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if debug.fillscr = \"YES\" then do\n    say \"tsa101d fillscr segment=\"segment\n    say \"   type=\"type \"resource=\"resource \"fchk=\"fchk\n  end\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose name acidrul. next allacid.\nq=dl(\"tsa101d\",,\" Dumping allacid array\")\ndo qt = 1 to allacid.0\n    say qt allacid.qt.0ACID,\n         allacid.qt allacid.qt.0restext\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. next acidlst.\nq=dl(\"tsa101d\",,\" Dumping acidlst array for \" name )\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetadata: procedure expose allacid. name next,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nt = record_number\nif debug.getdata = \"YES\" then do\n  say \"tsa101d Getadata invoked with:\" record_number\n  say \"New Getadata results:\"\n  say \"t=\"allacid.t\n  say \"acid=\"allacid.t.0acid\n  say \"segment=\"allacid.t.0segment\n  say \"type=\"allacid.t.0type\n  say \"resname=\"allacid.t.0resname\n  say \"restext=\"allacid.t.0restext\n  say \"*******\"\nend\ndebug.newgdata = \"YES\"\nsegment  = strip(allacid.t.0segment)\ntype     = strip(allacid.t.0type)\nresource = strip(allacid.t.0resname)\ntheres   = strip(allacid.t.0restext)\nif debug.Getdata = \"YES\" then do\n  say \"TSA101D: Getadata base resource:\" allacid.t\n  say \"TSA101D: Getadata resource data:\" theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult = getval(tempin,0segment)\n/* say \"Segment returning\" result */\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\n/*******************************************************/\n/*******************************************************/\n/**Gets the access from a string parens must be gone  **/\n/**prior to invocation.                               **/\n/*******************************************************/\n/*******************************************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult = getval(tempin,0type)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult = getval(tempin,0restext)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nsetv = setval(tempin,0flag,theflag)\nreturn 0\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\ngetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**Gets the allacid array variable specified.         **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nresult = allacid.record.varname\nif substr(result,1,8) = \"ALLACID.\" then result = \"\"\nif debug.getval = \"YES\" then\n  say \"GETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"is\" result\nreturn result\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\nsetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**sets the allacid array variable to specified value **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nnewvalue= arg(3)\nif debug.setval = \"YES\" then\n  say \"SETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"to\" newvalue\nallacid.record.varname = newvalue\nif varname = \"RESET\" then\nallacid.record  = newvalue\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ndl: NOP\n/**********************************************************/\n/** This routine checks to see if the debug flag is set  **/\n/** for a certain routine, and if it is issues the given **/\n/** msg to the log. It enables me to not have an if every**/\n/** time I want to write a msg          July 2003        **/\n/**********************************************************/\nmsgid  = arg(1)\nfield  = arg(2)\nthemsg = arg(3)\nupper msgid field\nD.1 = \"FLOW\"\nD.2 = \"MULTCON\"\nD.3 = \"CONVERT\"\nD.4 = \"MAKEACID\"\nD.5 = \"MODIFY\"\nD.6 = \"GETDATA\"\nD.7 = \"FILLSCR\"\nD.8 = \"MODRULE\"\nD.9 = \"RESOURCE\"\nD.10= \"TRANS\"\nd.0 = 10\nif msgid = \"\" then msgid = \"TSA101D\"\nif field = \"\" then field = \"FLOW\"\nfchk = \"BAD\"\ndo ck = 1 to d.0\n  if field = d.ck then fchk = \"OK\"\nend\nif fchk = \"BAD\" then do\n  say \"********************\"\n  say \"********************\"\n  say \"********************\"\n  say \"**debuglog routine invoked with :\" field\n  say \"********************\"\n  say \"********************\"\n  say \"********************\"\nend\nif debug.field = \"YES\" then do\n  outmsg = msgid\"*\"themsg\n  if length(outmsg) > 80 then do\n    outmsg2 = substr(outmsg,81)\n    outmsg = substr(outmsg,1,80)\n    say outmsg\n    say \"       * \"outmsg2\n  end\n  else say outmsg\nend\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = getval(tempin,0flag)\n/* say \"getflag: \" res */\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. name acidrul. conlist modrule. rstype debug.,\n fill_override allacid.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52IDAT": {"ttr": 8711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x03\\x01\\x04\\t?\\x01\\x04\\x12O\\x10\\x12\\x01.\\x01\\x19\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-05-03T10:12:03", "lines": 302, "newlines": 281, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T52Idat                           **/\n/** LAST MODIFIED    :  3 4 2004                         **/\n/**********************************************************/\n/** Update the INSTDATA of an individual ACID            **/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/**                                                      **/\n/**                                                      **/\n/**  Detailed return code:                               **/\n/**                                                      **/\n/**  _____Data Retrieval Status                          **/\n/** |                                                    **/\n/** |_____ID Status                                      **/\n/** ||                                                   **/\n/** ||____Previous INSTDATA state                        **/\n/** |||                                                  **/\n/** |||___Action Taken                                   **/\n/** ||||                                                 **/\n/** 0...- Data retrieval worked                          **/\n/** 1...- No such ID                                     **/\n/** 2...- Not authorized for this ID                     **/\n/** 4...- TSS retrieval error                            **/\n/** 8...- Unknown invocation code                        **/\n/**                                                      **/\n/** .0..- ID has no unusual attributes                   **/\n/** .1..- ID is currently Suspended                      **/\n/** .2..- ID is currently Asuspended                     **/\n/** .4..- ID is currently Expired **future enhancement** **/\n/** .8..- ID has special attributes                      **/\n/**                                                      **/\n/** ..0.- Instdata had valid data                        **/\n/** ..1.- Instdata had no previous instdata              **/\n/** ..2.- Instdata had special code                      **/\n/** ..4.- Instdata had invalid data                      **/\n/** ..8.- Instdata had pending suspend                   **/\n/**                                                      **/\n/** ...0- Instdata updated                               **/\n/** ...1- Instdata provided enum invalid                 **/\n/** ...2- Not used                                       **/\n/** ...4- Instdata not updated due to data retreival     **/\n/**       Failure                                        **/\n/** ...8- Instdata not updated due to failed TSS command **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** Current fields for instdata code                     **/\n/**                                                      **/\n/** Initial    - Value created by the TxxIDAT routine at **/\n/**              addition time                           **/\n/**                                                      **/\n/** Replace    - Value updated by the TxxIDAT routine at **/\n/**              request of administrator                **/\n/**                                                      **/\n/** Tosuspend  - Value set by automatic process,         **/\n/**              indicates the ID is to be suspended     **/\n/**              the next time the auto process is run.  **/\n/**                                                      **/\n/** Suspend    - Value set by automatic process,         **/\n/**              indicates the ID was      suspended     **/\n/**              by the automatic process.               **/\n/**                                                      **/\n/** Asuspend   - Value set by txxIDAT as a result of     **/\n/**              an administrator request.               **/\n/**                                                      **/\n/** Reset      - Value was reset as result of an         **/\n/**              administrator request.                  **/\n/**                                                      **/\n/** SYSTEMS    - A SPECIAL BYPASS VALUE NOT TO BE UPDATED**/\n/**                                                      **/\n/** CONSULT    - A SPECIAL BYPASS VALUE NOT TO BE UPDATED**/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T52GDAT             **/\n/**********************************************************/\ngood_msg = \"Completed successfully. DRC is:\"\nwarn_msg = \"Completed with warning. DRC is:\"\nfail_msg = \"Update Failed. DRC is:\"\nnew_trail = \"\"\nSPECIAL.SYSTEMS = \"YES\"\nSPECIAL.CONSULT = \"YES\"\nSPECIAL.BYPASS  = \"YES\"\nIDAT = \"'SYS4.SPI.IDATPARM(GOODIDAT)'\"\n\"ALLOC DDN(IDATparm) DSN(\"idat\") SHR REUS\"\n\"EXECIO * DISKR IDATPARM ( FINIS STEM HOLD.)\"\n\"FREE DDN(IDATPARM)\"\nCODE. = \"$$BADCODE$\"\n/*\nQ = TCODE(\"SUSPEND\",\"ASUSPEND\")\nQ = TCODE(\"INSTDATA\",\"REPLACE\")\nQ = TCODE(\"UNSUSPEND\",\"RESET\")\nQ = TCODE(\"ADD\",\"INITIAL\") */\n/* the gcode routine defines a code as valid */\n/* the tcode routine defines a translate code */\n/*************************************************************/\n/* Below we map an invocation value to an output value to be */\n/* placed into INSTDATA.                                     */\n/* All output codes below should be defined as valid codes   */\n/* with the gcode routine earlier.                           */\n/*************************************************************/\ndo w = 1 to hold.0\n  line = hold.w\n  w1 = strip(word(line,1))\n  w2 = strip(word(line,2))\n  Q = GCODE(w2) /*define word2 as a valid non numerical value */\n  if w1 /= \".\" then\n    Q = TCODE(w1,w2) /* define invocation/resultant values */\nend\n/*\nQ = GCODE(\"CONSULT\")\nQ = GCODE(\"SYSTEMS\")\nQ = GCODE(\"INITIAL\")\nQ = GCODE(\"REPLACE\")\nQ = GCODE(\"TOSUSPEND\")\nQ = GCODE(\"SUSPEND\")\nQ = GCODE(\"ASUSPEND\")\nQ = GCODE(\"RESET\")\n*/\noutcode = 0\nARG ACID function newidata\nfunction = strip(function)\nsay \"T52IDAT invoked with :\" function newidata\n/************************************************************/\n/** Lets get all the ACID data we will need                **/\n/************************************************************/\nADDRESS tso \"%T52GDAT \" ACID \" INSTDATA INSTDATA\"\nADDRESS ISPEXEC \"vget secrc profile\"\nsay \"gdat idata is :\" secrc\ncurrent_idata = secrc\nADDRESS tso \"%T52GDAT \" ACID \" ATTRIBUTES BASIC\"\nADDRESS ISPEXEC \"vget secrc profile\"\nsay \"gdat attr is :\" secrc\nIF SECRC = \"$NOTFOUND\" THEN SECRC = \" \"\ncurrent_attr = secrc\n/************************************************************/\n/**                                                        **/\n/************************************************************/\n/************************************************************/\n/** lets get 1st byte of Detailed Return Code  DRC         **/\n/************************************************************/\noutcode = outcode + acode(current_attr)\nnew_code = code.function\n/************************************************************/\n/** lets get 2nd byte of DRC                               **/\n/************************************************************/\nsay \"T52IDAT: current Idata:\" current_idata\nif current_idata = \"$BADTSS\" then outcode = outcode + 4000\nif current_idata = \"$BADAUTH\" then outcode = outcode + 2000\nif current_idata = \"$BADACID\" then outcode = outcode + 1000\nif current_idata = \"$BADACID\" then current_idata = \" \"\nif New_code = \"$$BADCODE$\" then outcode = outcode + 8000\n/************************************************************/\n/** lets get 3rd byte of DRC                               **/\n/************************************************************/\noutcode = outcode + icode(current_idata)\ncurrent_enum = word(current_idata,1)\nnew_enum = current_enum\ncurrent_code = word(current_idata,2)\nnew_code = current_code\ncurrent_trail = substr(current_idata                                ,21)\nnew_trail = current_trail\nSelect\n  when function= \"UNSUSPEND\" then do\n    new_enum  = current_enum\n    new_trail = current_trail\n    new_code  = code.function\n  end\n  when function= \"ADD\" then do\n    new_enum  = substr(newidata,1,10)\n    new_code  = code.function\n  end\n  when function= \"SUSPEND\" then do\n    new_enum  = current_enum\n    new_code  = code.function\n  end\n  when function= \"INSTDATA\" then do\n    new_enum  = substr(newidata                 ,1,10)\n    new_code  = code.function\n  end\n  otherwise secrc = \"Failed. Unmapped invocation code\" function\n            address ispexec \"vput secrc profile\"\n            say secrc\nEnd\nif special.current_code = \"YES\" then new_code = current_code\nif special.current_code = \"YES\" then new_code = current_code\nsay \"T52IDAT: back from GDAT with:\" secrc\nsay \"  Current enum :\" current_enum\nsay \"  Current code :\" current_code\nsay \"  Current trail:\" current_trail\nsay \"****************\"\nsay \"  New enum :\" new_enum\nsay \"  New code :\" new_code\nsay \"  New trail:\" new_trail\n/************************************************************/\n/** lets get 4th byte of DRC                               **/\n/************************************************************/\nnew_enum = substr(new_enum                 ,1,10)\nnew_code = substr(new_code                 ,1,10)\nnew_idata = new_enum||new_code||new_trail\nif new_enum > 99999 then outcode = outcode + 1\nif new_enum < 1 then outcode = outcode + 1\n/************************************************************/\n/** A code > 1000 indicates a data get error from GDAT     **/\n/************************************************************/\nsecrc = good_msg outcode\nif outcode < 1000 then do\n  say \"TSS REP(\"acid\") instdata('\"new_idata\"')\"\n  tss_rcode = rc\n  address tso\n  \"TSS REP(\"acid\") instdata('\"new_idata\"')\"\nend\nelse do\n  outcode = outcode + 4\n  secrc = fail_msg outcode\nend\nif tss_rcode > 0 then do\n  outcode = outcode + 8\n  secrc = fail_msg outcode\nend\nsay \"T52IDAT invoked:\" newidata function\nsay \"  DRC is \" outcode\nif outcode /10 <> outcode%10 then do\n  remain = outcode//10\n  if remain < 6 then secrc = warn_msg outcode\nend\nsay \"/**  Detailed return code:                               **/\"\nsay \"/**                                                      **/\"\nsay \"/**  _____Data Retrieval Status                          **/\"\nsay \"/** |                                                    **/\"\nsay \"/** |_____ID Status                                      **/\"\nsay \"/** ||                                                   **/\"\nsay \"/** ||____Previous INSTDATA state                        **/\"\nsay \"/** |||                                                  **/\"\nsay \"/** |||___Action Taken                                   **/\"\nsay \"/** ||||                                                 **/\"\nsay \"/** 0...- Data retrieval worked                          **/\"\nsay \"/** 1...- No such ID                                     **/\"\nsay \"/** 2...- Not authorized for this ID                     **/\"\nsay \"/** 6...- TSS retrieval error                            **/\"\nsay \"/** 8...- Unknown invocation code                        **/\"\nsay \"/**                                                      **/\"\nsay \"/** .0..- ID has no unusual attributes                   **/\"\nsay \"/** .1..- ID is currently Suspended                      **/\"\nsay \"/** .2..- ID is currently Asuspended                     **/\"\nsay \"/** .4..- ID is currently Expired                        **/\"\nsay \"/** .8..- ID has special attributes                      **/\"\nsay \"/**                                                      **/\"\nsay \"/** ..0.- Instdata had valid data                        **/\"\nsay \"/** ..1.- Instdata had no previous instdata              **/\"\nsay \"/** ..2.- Instdata had special code                      **/\"\nsay \"/** ..4.- Instdata had invalid data                      **/\"\nsay \"/** ..8.- Instdata had pending suspend                   **/\"\nsay \"/**                                                      **/\"\nsay \"/** ...0- Instdata updated                               **/\"\nsay \"/** ...1- Instdata provided enum invalid                 **/\"\nsay \"/** ...2- Not used                                       **/\"\nsay \"/** ...4- Not used                                       **/\"\nsay \"/** ...6- Instdata not updated due to data retreival     **/\"\nsay \"/**       Failure                                        **/\"\nsay \"/** ...8- Instdata not updated due to failed TSS command **/\"\nADDRESS ISPEXEC \"vput secrc profile\"\nexit outcode\n/***************************/\ngcode: nop\narg indat\ngoodcode.indat = \"YES\"\nreturn 0\n/***************************/\ntcode: nop\nindat = arg(1)\nindat2 = arg(2)\ncode.indat = indat2\nreturn 0\n/***************************/\nacode: nop\narg indat\nif index(indat,\"SUSPEND\") > 0 then outcode = outcode + 100\nif index(indat,\"ASUSPEND\") >0  then outcode = 200\nif index(indat,\"CONSOLE\") > 0 then outcode = outcode + 800\nif index(indat,\"NO\") > 0 then outcode = outcode + 800\nreturn outcode\n/***************************/\nicode: nop\narg idat\nsay \"icode invoked with:\" idat\noutcode = 0\nc_enum = word(idat,1)\nc_code = word(idat,2)\nc_trail = substr(idat                                ,21)\nif (datatype(strip(c_enum)) /= \"NUM\") & (idat /= \" \" ) then\n  outcode = outcode + 40\nif idat = \" \" then outcode = outcode + 10\nif idat = \"TOSUSPEND\" then outcode = outcode + 80\nif special.c_code = \"YES\" then outcode = outcode + 20\nreturn outcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52INS": {"ttr": 8197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00)\\x00\\x955/\\x01\\x03%\\x9f\\t9\\x00\\xcf\\x00\\xcf\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2003-09-16T09:39:29", "lines": 207, "newlines": 207, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T52INS                            **/\n/** LAST MODIFIED    :  9 dec 99                         **/\n/**********************************************************/\n/** NOW ACCEPTS MULTIPLE PROFS IN STD INVOCATION         **/\n/**********************************************************/\n/** CHANGED CODE TO FIX ERROR FOR INSERTS AT POSITION    **/\n/** GREATER THAN 1 WHEN ID HAS NO PROFILES    ....DR     **/\n/**********************************************************/\n/** REVAMPED TO USE THE AFTER KEYWORD OF INSERT COMMAND  **/\n/** SHOULD BE LOTS FASTER AND EASIER TO MANAGE....DR     **/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         EXITPRM                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T52FDIV %T52GDAT    **/\n/**********************************************************/\nARG ACID PROFILE TARGET DAYS\n/************************************************************/\n/** PATCH BELOW FOR NORMAL INVOCATION FOR MULTIPLE PROFILES */\n/************************************************************/\nif target = \" \" then target = 1\nTEMP = PROFILE TARGET DAYS\nPROFS = 0\nPARSE VAR TEMP TW.1 TW.2 TW.3 TW.4 TW.5 TW.6 TW.7 TW.8 TW.9 TW.10\nALLWORDS = WORDS(TEMP)\nIF (ALLWORDS = 3) & ( DATATYPE(TW.2) = \"CHAR\" ) THEN do\n  PROFILE = TW.1||\".\"||TW.2\n  TARGET = DAYS\n  DAYS = \"\"\n  say \"TSA101D: T52INS reformatted input is :\" acid profile target days\nEND\nIF ALLWORDS > 3 THEN DO\n  DO COUNT = 1 TO ALLWORDS\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN PROFS = COUNT - 1\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN LEAVE\n  END\n  PROFILE = \"\"\n  DO CNT2 = 1 TO PROFS\n    PROFILE = PROFILE||\".\"||TW.CNT2\n  END\n  TARGET_WORD = PROFS + 1\n  DAYS_WORD = PROFS + 2\n  TARGET = WORD(TEMP,TARGET_WORD)\n  DAYS   = WORD(TEMP,DAYS_WORD)\n  say \"TSA101D: T52INS reformatted input is :\" acid profile target days\nEND\n/*****/\nACT = \"AFTER\"\nADDRESS ISPEXEC\nPROFILE = TRANSLATE(PROFILE,\" \",\".\") /*CHANGE DOTS TO BLANKS */\nPROFILE = TRANSLATE(PROFILE,\" \",\"_\") /*CHANGE _    TO BLANKS */\nSYSENV = SYSVAR(SYSENV)\nPROF. = \" \"\nPROFHLD = \" \"\nQ = OUTTRAP(\"OFF\")\nSAY \" \"\nsay \"TSA101D: T52INS control received.\"\nsay \"TSA101D: T52INS profile is\" profile\nsay \"TSA101D: T52INS target  is\" target\nsay \"TSA101D: T52INS days    is\" days\nPARSE VAR PROFILE PROF.1 PROF.2 PROF.3 PROF.4 PROF.5\nPROFNUM = WORDS(PROFILE)\nIF PROFNUM > 5 THEN DO\n  secrc = \"TSA251E: Failed. Insert function only supports \"\n  secrc = secrc||\"5 profiles at a time\"\n  say \"TSA101D: T52INS:\" secrc\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DATATYPE(TARGET) \u00ac= \"NUM\" THEN DO\n   SECRC=\"FUNCTION ABORTED. LOCATION SPECIFIED IS NOT NUMERIC.\"\n   SECRC= SECRC TARGET\n   IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n   EXIT 16\nEND\n/*********************************************************************/\n/* NOW I MAKE SURE EACH PROF HE PASSED ME IS ACTUALLY A PROFILE. DIR */\n/* NOTE THAT THIS CHECKING IS SKIPPED FOR A BATCH USER.          DIR */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  SECRC = \"PROFILE\" /*SET TO PROFILE FOR BATCH DEFAULTS */\n  IF SYSENV = \"FORE\" THEN DO\n    say \"TSA101D: T52INS environment is foreground\"\n    say \"TSA101D: T52INS I am calling Txxfdiv for data on \"prof.cnt\n    ADDRESS TSO \"%T52FDIV \"PROF.CNT\n    ADDRESS ISPEXEC \" VGET SECRC PROFILE\"\n  END\n  IF SECRC \u00ac= \"PROFILE\" THEN DO\n    say \"TSA101D: T52INS rcode indicates \" prof.cnt \"is not a profile\"\n    say \"TSA101D: T52INS return code is ===>\" secrc\n    secrc= \"TSA252E: \"\n    secrc= secrc\"Function aborted. \"prof.cnt \"is not an owned profile.\"\n    IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n    EXIT 08\n  END\nEND\nSIGNAL ON ERROR NAME ERRID\nsay \"TSA101D: T52INS testing primary id for existance\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nsay \"TSA101D: T52INS rcode from test is \" rc\nSIGNAL OFF ERROR\n/*********************************************************************/\n/* NOW I REMOVE THE PROFS BEFORE INSERTING THEM JUST IN CASE THIS IS */\n/* THE EQUIVALENT OF A MOVE OPERATION...........DIR 19 JUN 91        */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  say \"TSA101D: T52INS removing the stated profiles first !\" prof.cnt\n  ADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROF.CNT\")\"\n  IF RC > 0 THEN NOTTHERE = \"YES\"\nEND\n/*********************************************************************/\n/* IF THIS IS THE EQUIVALENT OF A DELETE WE ARE DONE....DIR 19 JUN 91*/\n/*********************************************************************/\nIF TARGET = 0 THEN DO\n  SECRC = PROFILE \" REMOVED FROM \"ACID\", AND NOT REINSERTED.\"\n  IF NOTTHERE = \"YES\" THEN DO\n    say \"TSA101D: T52INS non 0 rc received from tss remove command\"\n    secrc = \"TSA253E: Failed. Delete requested but \"profile \"not\"\n    secrc =  secrc\" removed from ACID\" acid\".\"\n  END\n  SAY \"T52INS:\" SECRC\n  IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n  EXIT\nEND\n/*                                              */\n/*Q = OUTTRAP(\"OUT.\")                           */\n/*ADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"    */\nQ = OUTTRAP(\"OFF\")\n/*********************************************************************/\n/* NOW I GET THE PROFILES CURRENTLY ATTACHED TO THE ACID DR 2 MAY96  */\n/*********************************************************************/\nADDRESS TSO \" %T52GDAT \"ACID \" PROFILES\"\nADDRESS ISPEXEC \" VGET SECRC PROFILE\"\nPROFHLD = SECRC\nSAY \"T52INS: CURRENT PROFILES ARE : \" PROFHLD\nTOTWORDS = WORDS(PROFHLD)\nIF PROFHLD = \"$NOTFOUND\" THEN TOTWORDS = 0\nIF TARGET > TOTWORDS THEN DO\n  TARGET = TOTWORDS + 1\n  SAY \"T52INS: POSITION PARM OVERRIDDEN. CHANGED TO \"TARGET\nEND\n/******************************************************************/\n/* WE ISSUE THE COMMAND WITH AN AFTER PARM UNLESS THE FUNCTION IS */\n/* TO ADD THE PROFILE AS THE FIRST IN HIS LIST, THEN WE MUST      */\n/* USE THE BEFORE PARM. THIS NEXT CODE IS HERE IN CASE TARGET IS  */\n/* EQUAL TO POSITION 1. DIR 2 MAY 96                              */\n/******************************************************************/\nIF TOTWORDS = 0 THEN DO\n  IF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"\n  IF DAYS \u00ac= \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\")\"\n  SIGNAL SEEYA\nEND\nQ1 = TARGET\nIF TARGET = 1 THEN ACT = \"BEFORE\"\nELSE Q1 = TARGET - 1\nIF Q1 = 0 THEN ACT = \"BEFORE\"\nTPROF = WORD(PROFHLD,Q1)\nSAY \"T52INS: INSERT TGT IS PROFILE \" TPROF\nSIGNAL ON ERROR NAME ERRXIT\nSAY \"T52INS: ADDING FOLLOWING PROFILES TO ACID\"\nSAY \"T52INS: PROFILES ===> \"PROFILE\nSAY \"T52INS: CHECKING FOR TEMPORARY TIMESPAN\"\nIF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"ACT\"(\"TPROF\")\"\nELSE ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\") \",\n      ACT\"(\"TPROF\")\"\nSEEYA: NOP\nsecrc =  \"TSA254I:\" profile \"inserted in \"acid\" at position\" target\".\"\nSAY \"T52INS: \"SECRC\nSAY \"  \"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nEXIT 0\n\nERRXIT: NOP\nSAY \"T52INS: ERROR IN LINE:\" SIGL\nSECRC =  \"CATASTROPHIC FAILURE ! PROFILES BELOW NOT ADDED !\"\nSAY \"T52INS: \"SECRC\nSAY \"  \"\nEXITRC16 = ACID \"LOST:\" PROFHLD\nSAY \"T52INS: \"EXITRC16\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC16 PROFILE\"\nEXIT 1\nERRID: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . MAY NOT EXIST\"\nSAY \"T52INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"MAY NOT EXIST\"\nSAY \"T52INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\nERRPRF: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . SOME PROFILES MAY NOT BE OWNED!\"\nSAY \"T52INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"PROFS IN QUESTION:\" Y\nSAY \"T52INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52JCARD": {"ttr": 6921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x08\\x00\\x955/\\x01\\x01\\x19?\\x07T\\x00<\\x00<\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2001-07-12T07:54:08", "lines": 60, "newlines": 60, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** INSERTS A JOBNAME AND MAYBE A USER= CARD INTO A      **/\n/** SAMPLE JCL DECK WHICH ALREADY IS SYNTACTICALLY VALID **/\n/**********************************************************/\n/** EXEC NAME        : T51JCARD                          **/\n/** LAST MODIFIED    : 15 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSNAME OF THE OUTPUT JCL STREAM        **/\n/** JPARM   : \"SUPER\" OR BLANKS                          **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS6     : THE DSNAME IF THE SAMPLE JOB               **/\n/** DISP    : THE OUTPUT FILE ALLOCATION DISPOSITION     **/\n/** MSCA    : THE ID TO INCLUDE IN A USER= CARD IF NEEDED**/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE                         **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (NEEDS VGETS)               **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/.A                **/\n/**                                                      **/\n/**********************************************************/\nARG DSN JPARM\nADDRESS ISPEXEC\n\"ISPEXEC VGET DS6 PROFILE\"\n\"ISPEXEC VGET MSCA PROFILE\"\nSAY \"TSA101D: T51JCARD: IS IN CONTROL WITH PARMS : \" DSN JPARM\nADDRESS TSO \"ALLOC DDN(JCFILE) DSN(\"DS6\") SHR REUS\"\nJNAME= JPARM\nIF JPARM = '' THEN JNAME = \"TSSJOB\"\nTIME = TIME(NORMAL)\nT12 = SUBSTR(TIME,1,2)\nT45 = SUBSTR(TIME,4,2)\nIF JPARM = \"RANDOM\" THEN\n  JNAME= \"TSSJ\"T12||T45\nADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DSN\") SHR REUS\"\nADDRESS MVS \"EXECIO * DISKR JCFILE (FINIS STEM LINE.)\"\nJOBCARD_INSERT = 99\nDO Q = 8 TO 1 BY -1 /* LETS FIND WHERE THE JOBCARD ENDS */\n  INLINE = LINE.Q\n  IF SUBSTR(INLINE,1,3) = \"//*\" THEN JOBCARD_INSERT = Q - 1\n  IF SUBSTR(INLINE,1,2) = \"/*\" THEN JOBCARD_INSERT = Q - 1\n  IF INDEX(INLINE,\"EXEC\") > 0  THEN JOBCARD_INSERT = Q - 1\nEND\nSAY \"TSA101D: T51JCARD JOBCARD ENDS PRIOR TO LINE\" JOBCARD_INSERT\nIF JPARM = \"SUPER\" THEN DO\n  JNAME= \"TSSJ\"T12||T45\n  LINE.JOBCARD_INSERT= \"// \"WORD(LINE.JOBCARD_INSERT,2)||\",USER=\"MSCA\n  SAY \"TSA101D: JCARD ADDITION : \" LINE.JOBCARD_INSERT\nEND\nLEN1= LENGTH(LINE.1)\nHOLD = SUBSTR(LINE.1,11)\nLINE.1= \"//\"JNAME HOLD\nADDRESS MVS \"EXECIO * DISKW OUTFILE (FINIS STEM LINE.)\"\nADDRESS TSO \" FREE DDN(JCFILE)  \"\nADDRESS TSO \" FREE DDN(OUTFILE) \"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52LISTP": {"ttr": 7169, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x01\\x19?\\x01\\x01\\x19?\\t\\x15\\x00Q\\x00Q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-07-12T00:00:00", "modifydate": "2001-07-12T09:15:20", "lines": 81, "newlines": 81, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51LISTP                          **/\n/** LAST MODIFIED    : 11 JUL 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE VALID TSS DEFINED ID                   **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  ACID IF NOT PASSED AS AN ARG.                       **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         MSG2                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T51FDIV T51GETPW     **/\n/**                                                      **/\n/**********************************************************/\nARG ACID\nIF ACID = \" \" THEN ADDRESS ISPEXEC \"VGET ACID  PROFILE\"\nSAY \"T51LISTP: HAS CONTROL\"\nSAY \"T51LISTP: CALLING T51FDIV\"\nSYSSCMD = SYSVAR(SYSSCMD)\nSYSPCMD = SYSVAR(SYSPCMD)\nSYSICMD = SYSVAR(SYSICMD)\nSYSNEST = SYSVAR(SYSNEST)\nSYSRACF = SYSVAR(SYSRACF)\nSAY \"I=\"SYSICMD \"P=\" SYSPCMD \"S=\" SYSSCMD \"RACF= \" SYSRACF\nADDRESS TSO \"%T51FDIV \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\nSAY \"T51LISTP: BACK FROM  T51FDIV WITH SECRC OF\" SECRC\nIF SECRC = \"LIST FUNCTION FAILED.\" THEN DO\n  ADDRESS TSO \"%T51GETPW \" ACID\n  ADDRESS ISPEXEC \" VGET SECRC PROFILE \"\n  IF SECRC \u00ac= \"$ERROR\" THEN\n    SECRC = \"THAT IDS PASSWORD = \" SECRC\n  ELSE\n    SECRC = \"FAILED. THAT ID DOES NOT EXIST IN UADS OR TOP SECRET\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC = \"AUTHORIZATION FAILED.\" THEN DO\n  SECRC = \"FAILED. YOUR TOP SECRET AUTHORIZATION IS INADEQUATE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC \u00ac= \"CUSTDIV\" THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"THAT ID IS NOT DEFINED AS AN EXTERNAL CUSTOMER. \"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    IF SUBSTR(ACID            ,8,1) = \"@\" THEN DO\n      MSG2 = \"THAT IS A GHOST ENTRY, TRY LISTING THE ID WITHOUT THE @\"\n      ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\n    END\n    EXIT 00\n    END\n  ELSE DO\n    MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY LISTABLE\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nADDRESS TSO \"%T51GDAT \"ACID\" ATTRIBUTES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF INDEX(SECRC,\"SUSPEND\") \u00ac=  0 THEN DO\n  MSG2 =  \"THIS ID IS SUSPENDED, YOU MUST UNSUSPEND TO USE\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nADDRESS TSO \"T51GDAT \"ACID\" PASSWORD PW\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF ( SECRC = \"$NOTFOUND\" ) | ( SECRC = \"$BADTSS\" )  THEN DO\n  MSG2 = \"THE IDS PASSWORD IS NOT RETRIEVABLE. CONTACT TECH SUPPORT\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nELSE\n  SECRC = \"THE IDS PASSWORD  = \"SECRC\nTHEEND: NOP\nADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52LSTO": {"ttr": 8203, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x14\\x00\\x98(/\\x01\\x03&\\x0f\\x15\\x06\\x00.\\x00.\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1998-10-09T00:00:00", "modifydate": "2003-09-17T15:06:14", "lines": 46, "newlines": 46, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID DATA DS1\n HEX00 = '00'X\n DISP = \"SHR\"\n SYSENV = SYSVAR(SYSENV)\n SAY HEX00\n SECRC = \"FAILED IN T52LSTO. CHECK ACIDS VALIDITY\"\n secrc = secrc||\" and your current authority\"\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n   ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n END\n IF DISP = \"\" THEN DISP = SHR\n SIGNAL ON ERROR NAME SEEYA\n SS = OUTTRAP('OUTLINE.')\n  /******************************************************************/\n  /* THIS EXEC PRINTS OUTPUT TO A DSN.                              */\n  /* IT IS VERY SIMPLE......DAVE 20 MAY 91                          */\n  /******************************************************************/\nIF DATA  = \"  \" THEN  DATA=\"ALL\"\nIF DATA  = \"ALLPW\" THEN  DATA=\"ALL,PASSWORD\"\nIF DATA  = \"DATAAREA\" THEN DO\n  ADDRESS ISPEXEC \"VGET DATAAREA PROFILE\"\n  DATA = DATAAREA\nEND\nSAY \"T52LSTO: ALLOCATING DSN\" DS1\n\"ALLOC DDN(OUTFILE) DSN(\"DS1\") \"DISP\" REUS\"\nSAY \"T52LSTO: CALLING TSS FOR LIST OF ID \" ACID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n secrc = \"function completed. output in \" ds1\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52MAINT": {"ttr": 8707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x11\\x01\\x04\\t?\\x01\\x04\\t?\\x08'\\x009\\x00:\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2004-04-02T08:27:11", "lines": 57, "newlines": 58, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T52maint                          **/\n/** LAST MODIFIED    :  3 31 2004                        **/\n/**********************************************************/\n/** a front end exec for the idat exec that will suspend **/\n/** or unsuspend or whatever and then call the instdata  **/\n/** routine to maintain instdata                         **/\n/**                                                      **/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**  COA1DIR UNSUSPEND */\n/**                                                      **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T52IDAT             **/\n/**********************************************************/\nARG ACID Function data\nfunction = strip(function)\nsignal off error\naddress tso\nSelect\n  when function= \"UNSUSPEND\" then do\n    thecmd = \"%t52idat\" acid function\n    \" \"thecmd\n    drc = rc\n    thecmd = \"tss rem(\"acid\") SUSPEND\"\n    \" \"thecmd\n    address ispexec \"vget secrc profile\"\n  end\n  when function= \"SUSPEND\" then do\n    thecmd = \"%t52idat\" acid function\n    \" \"thecmd\n    drc = rc\n    thecmd = \"tss add(\"acid\") SUSPEND\"\n    \" \"thecmd\n    address ispexec \"vget secrc profile\"\n  end\n  when function= \"INSTDATA\" then do\n    new_enum  = substr(newidata                 ,1,10)\n    new_code  = code.function\n  end\n  otherwise secrc = \"Failed. Unknown function\" function\n            address ispexec \"vput secrc profile\"\n            say secrc\nEnd\nsay secrc drc\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52PER": {"ttr": 6667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00F\\x00\\x990O\\x00\\x991/\\t\\x14\\x00g\\x00g\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-31T00:00:00", "modifydate": "1999-11-08T09:14:46", "lines": 103, "newlines": 103, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG ACID RESTYPE RESNAME ACCESS DAYS\nSIGNAL OFF ERROR\nSECRC = \"T50PER FAILED WITH ERRORS\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nRES.0 = 3\nRES.1 = \"DATASET\"\nRES.2 = \"JESSPOOL\"\nRES.2 = \"VOL\"\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE ASTERISK WITH Z */\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = RESTYPE THEN VALID = \"YES\"\nEND\nIF VALID /= \"YES\" THEN DO\n  SAY \"T50PER: RESTYPE NOT SUPPORTED. RESTYPE = \" RESTYPE\n  MSG2 = \"THE FOLLOWING RESTYPE WAS NOT RECOGNIZED\" RESTYPE\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  EXIT 08\nEND\nACTION = \"ACTION(FAIL)\"\nIF DAYS /= \" \" THEN DAYCMD = \"FOR(\"DAYS\")\"\nSLASH = INDEX(\"/\",DAYS)\nIF SLASH > 0 THEN DAYCMD = \"UNTIL(\"DAYS\")\"\nDAY1 = WORD(DAYS,1)\nSIGNAL NOCHECK\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE DOTS WITH SPACES */\nACCCHK = ACCESS\nQ = OUTTRAP(HOLD.,5)\nIF ACCESS = \"ALL\" THEN ACCCHK = \"ALTER\"\nIF ACCESS = \"REMOVE\" THEN ACCCHK = \"ALTER\"\nSAY \"T50PER: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nSAY \"T50PER: RES IS \" RESNAME\nSAY \"********CHECK IS BELOW **************\"\nSAY \" TSSCHECK(\"RESTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\nX5 = TSSCHECK(RESTYPE,RESCHK,ACCCHK,\"NOMSG\")\nSAY \"********CHECK IS BELOW **************\"\nSAY \"T50PER: TSSCHECK RETURN CODE IS \" X5\nIF X5 \u00ac= \"OK\"  THEN DO\n  SECRC = \"YOU CANNOT GRANT THAT LEVEL OF ACCESS TO THAT RESOURCE.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nNOCHECK: NOP\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T50PER: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\n/********************************/\n/* LETS ACTUALLY DO THE WORK... */\n/********************************/\nQ = OUTTRAP(OUT.,5)\nIF RESTYPE = \"DATASET\" THEN RESTYPE = \"DSN\"\nIF ACCESS = \"REMOVE\" THEN DO\n  \"TSS REV(\"ACID\") \"RESTYPE\"(\"RESNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"AUTHORITY REMOVED FOR ID \"ACID\".\"\n  ELSE DO\n    SECRC = \"REMOVE RETURNED NON ZERO RCODE OF \"RCODE\n    MSG2 = OUT.1\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") \"RESTYPE\"(\"RESNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"RESNAME\")\",\n  \"ACCESS(\"ACCESS\")\" DAYCMD ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  secrc = \"TSA521I: permit function successful for id\" acid\nELSE DO\n  secrc = \"TSA522I: permit returned non zero rcode of \"rcode\n  MSG2 = OUT.1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52PMENU": {"ttr": 6669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00H\\x00\\x98#/\\x01\\x00\\x07_\\x10S\\x02\\x96\\x02\\x96\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-08-20T00:00:00", "modifydate": "2000-03-15T10:53:48", "lines": 662, "newlines": 662, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added  security checking for datsets                 **/\n/**********************************************************/\n/** added  privpgm support 11 nov 97                     **/\n/**********************************************************/\n/** added  support for the STC record by creating        **/\n/** the DELTRUNC. variable to be referenced in deletes   **/\n/**********************************************************/\n/** added  support for the user TSO area. dir 1 oct 97   **/\n/**********************************************************/\n/** Fixed truncation of last data line and added sitran  **/\n/** support.     dave 29 aug 97                          **/\n/**********************************************************/\n/** NOW SUPPORTS LCF CMDS     DIR 28 AUG 97              **/\n/**********************************************************/\n/** MODIFY PROFILES IN A PANEL BASED ENVIRONMENT         **/\n/** LOTS  OF SAYS   TO FACILITATE DEBUGGING...           **/\n/**********************************************************/\n/** EXEC NAME        : T50PMENU                          **/\n/** LAST MODIFIED    : 25 MAR 97                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS3     : THE BATCH FILE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD  = THE VALID COMMANDS FOR THIS ENTRY   \"ADD REM\" **/\n/** TYPE = THE RESOURCE TYPE                   \"DATASET\" **/\n/** RSNAME= THE RESOURCE NAME                  \"SYS1.  \" **/\n/** ACCESS=THE ACCESS LEVEL                    \"UPDATE \" **/\n/** ACTION=THE ACTION TO TAKE                  \"FAIL   \" **/\n/** UNTIL= THE EXPIRATION DATE OF RULE  \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/** OTHER   = ANYTHING ELSE             \"DAYS(MON.TUE)  \"**/\n/** DELTRUNC= Number of words to retain of the resource \"**/\n/**           name when doing a delete function.         **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** OUT_COUNT = THE # OF OUTPUT CHANGES                  **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS3  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nCALL OFF ERROR\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50PMENU. CHECK ACIDS VALIDITY\"\nSECRC = SECRC||\" AND YOUR CURRENT AUTHORITY\"\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS3 PROFILE\"\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\nEND\nDELTRUNC. =  0\nF0        =  \" \"\nUNTIL.    =  \" \"\nACCESS.   =  \" \"\nRSNAME.   =  \" \"\nOTHER.    =  \" \"\nLIBRARY.  =  \" \"\nFACILITY. =  \" \"\nPGM.      =  \" \"\nCOMMAND_FALLTHRU = \"ADD REM\"\nCMD.      =  \"PER REV\"\nACTION.   =  \" \"\nIF DISP = \"\" THEN DISP = SHR\nSIGNAL ON ERROR NAME BYEBYE\nDATA=\"ALL,EXPIRE\"\nIF MODE = \"ONLINE\" THEN DO\n  SAY \"T50PMENU: ALLOCATING DSN\" DS3\n  ADDRESS TSO \"%T50JCARD\" DS3\n  \"ALLOC DDN(BJCL) DSN(\"DS3\") MOD REUS\"\nEND\nSAY \"T50PMENU: CALLING TSS FOR LIST OF ID \" ACID\nSS = OUTTRAP('INLINE.')\nSIGNAL ON ERROR NAME BADID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nRCODE = RC\nSIGNAL ON ERROR NAME BYEBYE\nTHISREC = 3\nOUT_COUNT = 0\nOUTNUM = 0\nSAY \"T50PMENU: HAS A TOTAL RECORD COUNT OF \" inline.0\nDO I = 1 TO INLINE.0\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\") /* REPLACE = WITH SPACES */\n  /***********************************************************/\n  /** Kill those = signs.. very important to know for the   **/\n  /** lower loop...    Dave 29 Aug 97                       **/\n  /***********************************************************/\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  /****************************/\n  /* SAVE THE LAST LINE HEADER*/\n  /****************************/\n  FIRST13 = SUBSTR(LINE,1,13)\n  IF FIRST13 \\= \"             \" THEN SAVE13 = FIRST13\n  IF SUBSTR(LINE,1,2) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  /***********************************************************/\n  /** Reformatter area                                      **/\n  /** The lower loop operates on the principal that each    **/\n  /** line contains enough data to recreate any command     **/\n  /** pertaining to the resources mentioned there.          **/\n  /** I created this area for LCF commands, where lines do  **/\n  /** not mention the facilites that they are affecting     **/\n  /** nor do they mention the type of resource they are     **/\n  /** securing. So I 'proprogate' the first 13 chars of     **/\n  /** the line that does have this data to the lower        **/\n  /** lines.      DAVE 29 AUG 97                            **/\n  /***********************************************************/\n  IF (SAVE13 = \" AUTH CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"AUTH CMDS  \"||LINE\n  IF (SAVE13 = \" EXMP CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"EXMP CMDS  \"||LINE\n  IF SAVE13 = \" AUTH CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  IF SAVE13 = \" EXMP CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  /****************************/\n  /** END OF REFORMATTER AREA**/\n  /****************************/\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  IF FIRST13 = \"LCF FAC     \" THEN LCFFAC = W.3\n  IF W.1 = \"XA\" THEN DO\n    OUTNUM = OUTNUM + 1\n    CMD.OUTNUM = \"PER REV\"\n    IF W.2 = \"DATASET\" THEN W.2 = \"DSN\" /* FIX FOR ADD/PER WITH DSNS*/\n    TYPE.OUTNUM = W.2\n    RSNAME.OUTNUM = W.3\n    UNTIL.OUTNUM = W.4\n    ITERATE I\n  END\n  IF W.1 = \"ACCESS\" THEN DO\n    ACCESS.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"DAYS\" THEN DO\n    OTHER.OUTNUM = \"DAYS(\"W.2\")\"  W.3 W.4 W.5 W.6 W.7 W.8 W.9\n    OTHER.OUTNUM = STRIP(OTHER.OUTNUM)\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n  IF W.1 = \"STC\" THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"PROCNAME(\"W.2\") acid(\"w.4\")\"\n    DELTRUNC.OUTNUM = 1 /* TO DEL THIS RULE ONLY USE WORD # 1 */\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n/*************************************************/\n/* SITRAN     = M3CL      FACILITY   = FINTST1   */\n/* TSS ADD(CONSPROF) SIT(M3CL,FINTST1)           */\n/*************************************************/\n  IF W.1 = \"SITRAN\"   THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"SIT(\"W.2\",\"W.4\")\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$SITRAN\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$ATTRIB\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    PGM.OUTNUM = W.2 W.3 W.4 W.5 W.6\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  END\n  /*************************************************/\n  /* below is the processing for the tso area      */\n  /* note that it checks handles all tso prefixed  */\n  /* words............  dir 1 oct 97               */\n  /*************************************************/\n  IF SUBSTR(W.1,1,3) = \"TSO\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  /*************************************************/\n  /* Below is the area for words to ignore         */\n  /*************************************************/\n  END\n  IF W.3 = \"NAME\" THEN iterate i\n  IF W.1 = \"DEPT\" THEN ITERATE I\n  IF W.1 = \"ZONE\" THEN ITERATE I\n  IF W.1 = \"DIV\" THEN ITERATE I\n  IF W.1 = \"TYPE\" THEN ITERATE I\n  IF W.1 = \"CREATED\" THEN ITERATE I\n  IF W.1 = \"TSS0300I\" THEN ITERATE I\n  IF W.1 = \"LAST\" THEN ITERATE I\n  IF W.1 = \"ACID\" THEN ITERATE I\n  /*************************************************/\n  /* Below is the area to change fallthru defaults */\n  /*************************************************/\n  IF W.1 = \"LIST\" & W.2 = \"DATA\"  THEN do\n    w.1 = \"DATA\";w.2 = w.3;w.3 = \" \"\n  end\n  IF INDEX(W.2,\"*ALL*\") THEN DO\n    PARSE VAR W.2  TZ1 '*ALL*' TZ2\n    W.2 = TZ1||\"ALL\"TZ2\n  END\n  IF W.2 = \"ADMINISTRATION\" & W.3 = \"AUTHORITIES\"  THEN\n    COMMAND_FALLTHRU = \"ADMIN DEADMIN\"\n  /*************************************************/\n  /* below is the fall thru area                   */\n  /* I take my best guess at the command           */\n  /*      ............  dir 29 jan 99              */\n  /*************************************************/\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM =  command_fallthru\n  ITERATE I\nEND\n/*******************************************************/\n/*******************************************************/\n/** End of loop now we create the output lines DIR    **/\n/*******************************************************/\n/*******************************************************/\nOUTNUM = OUTNUM + 1\nIF OUTNUM < 15 THEN DO A = OUTNUM TO 15\n  CMD.A      = \"PER REV\"\n  TYPE.A        = \" \"\n  RSNAME.A      = \" \"\n  ACCESS.A      = \" \"\n  OUTNUM = 15\nEND\nCALL FILLSCR\nSCANSCR: NOP\nDO T = 1 TO 14\n  IF F.T  = 'S' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    CALL SHOWRULE\n  END\n  IF F.T  = 'D' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN  CALL DELRULE\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T50PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'M' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN DO\n      CALL DELRULE\n      SAY \"T50PMENU: TYPE AFTER RULE PROCESSING IS \" TYPE.T\n      FLAG = \"*MODIFY\"\n      CALL MODRULE\n    END\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T50PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'A' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    F.T = \" \"\n    F0 = \"\"\n    DO TEMP3 = OUTNUM TO T BY - 1\n      BEFORE = TEMP3 - 1\n      F.TEMP3 = F.BEFORE\n      INTERPRET \"F\"||TEMP3 \"= F\"||BEFORE\n    END\n    OUTNUM = OUTNUM + 1\n    FILL = THISREC + T - 1\n    TARGET = FILL + 1\n    SAY \"T50PMENU: RECNUM IS  \" FILL\n    SAY \"T50PMENU: ACCESS IS  \"ACCESS.FILL\n    SAY \"T50PMENU: TYPE IS    \"TYPE.FILL\n    SAY \"T50PMENU: RSNAME IS  \"RSNAME.FILL\n    DO Q = OUTNUM TO TARGET BY -1\n      Q1 = Q - 1\n      FACILITY.Q = FACILITY.Q1\n      ACTION.Q   = ACTION.Q1\n      PGM.Q      = PGM.Q1\n      LIBRARY.Q  = LIBRARY.Q1\n      ACCESS.Q   = ACCESS.Q1\n      TYPE.Q     = TYPE.Q1\n      UNTIL.Q    = UNTIL.Q1\n      RSNAME.Q   = RSNAME.Q1\n    END\n    FLAG = \"*NEWRULE\"\n    CALL MODRULE\n    F.T = \" \"\n  END\nEND\nCALL FILLSCR\nADDRESS ISPEXEC \"DISPLAY PANEL(\"SECPROF\")\"\nCALL FILLSCR\nIF RC > 0 THEN SIGNAL BYEBYE\n/* IF OPT = \"NEXTM\" THEN THISREC = THISREC + 14         */\n/*IF OPT = \"PREVM\" THEN THISREC = THISREC - 14           */\nsay \"option is \"opt\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"F\") THEN OPT = \" \"\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"FIND\") THEN OPT = \" \"\nIF WORDS(OPT) = 1 THEN SIGNAL NOLOOP\nIF (WORD(OPT,1) = \"FIND\") | (WORD(OPT,1) = \"F\") then do\n  HOLD2 = WORD(OPT,2)\n  TGTNUM = OUTNUM - 14\n  HIT = \"NO\"\n  DO TF1 = THISREC TO OUTNUM\n    IF INDEX(TYPE.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(RSNAME.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(ACCESS.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF HIT = \"YES\" THEN THISREC = TF1\n    IF HIT = \"YES\" THEN LEAVE\n  END\n  IF THISREC > TGTNUM THEN THISREC = TGTNUM\nEND\nnoloop: nop\nIF WORD(OPT,1) = \"PREVM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC - 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = THISREC - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = 1\nend\nIF WORD(OPT,1) = \"NEXTM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC + 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = OUTNUM - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = OUTNUM - 14\nEND\nIF OPT = \"QUIT\" THEN SIGNAL BYEBYE\nOPT = \" \"\nSIGNAL SCANSCR\nSAY \"T50PMENU : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/*DO X = 1 TO OUTNUM                                                */\n/*  BATFILE.X =  X CMD.X TYPE.X RSNAME.X UNTIL.X ACCESS.X LIBRARY.X,*/\n/*  ACTION.X                                                        */\n/*END                                                               */\n\"EXECIO \"OUT_COUNT\" DISKW BJCL ( FINIS STEM BATFILE.)\"\n SECRC = \"FUNCTION COMPLETED. OUTPUT IN \" DS3\n IF MODE = \"BATCH\" THEN\n   SECRC = \"FUNCTION COMPLETED. OUTPUT APPENDED TO BATCH FILE.\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nBADID: NOP\n SECRC = \"ID LIST FAILED, CHECK YOUR AUTHORITIES AND IDS EXISTANCE\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nSEEYA: NOP\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/******************************************************************/\n/**  THE SHOWRULE SECTION                                        **/\n/******************************************************************/\nSHOWRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. OTHER.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nSAY \"T50PMENU: TEMP IS \" TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nRSNAME   = RSNAME.TEMP\nSAY \"T50PMENU: INSIDE SHOWRULE ROUTINE\"\nSAY \"T50PMENU: ACTION IS   \"  ACTION\nSAY \"T50PMENU: FACILITY IS \"  FACILITY\nSAY \"T50PMENU: PGM IS      \"  PGM\nSAY \"T50PMENU: ACCESS IS   \"  ACCESS\nSAY \"T50PMENU: LIBRARY IS  \"  LIBRARY\nSAY \"T50PMENU: UNTIL IS    \"  UNTIL\nSAY \"T50PMENU: TYPE IS     \"  TYPE\nSAY \"T50PMENU: RSNAME IS   \"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECSHOW)\"\nADDRESS ISPEXEC \"REMPOP\"\nRETURN\n/*******************************************************/\n/**              THE SECURITY CHECK                   **/\n/*******************************************************/\nSECURE: PROCEDURE EXPOSE TYPE. RSNAME. ACCESS. T,\n       ACTION. THISREC CMD. FLAG,\n       ACID OTHER. SECCODE\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nCALL OFF ERROR\nVALID = \"NO\"\nTEMP   = T + THISREC - 1\nOUT_RNAME = RSNAME.TEMP\nACCESS   = ACCESS.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T50PMENU(SECURE): MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nRES.0 = 2\nRES.1 = \"DSN\"\nRES.2 = \"JESSPOOL\"\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = TYPE THEN VALID = \"***DISABLED***\"\nEND\nIF TYPE = \"*SECURE\" THEN SECCODE = 16\nSAY \"MODRULE VALID IS\" VALID\nIF VALID = \"YES\" THEN DO\n  RESCHK = TRANSLATE(RSNAME,\"Z\",\"*\") /* REPLACE * WITH zzzzzz */\n  ACCCHK = \"ALTER\"\n  IF TYPE = \"DSN\" THEN TYPE = \"DATASET\"\n  RSTYPE = STRIP(TYPE)\n  /* Q = OUTTRAP(HOLD.,5)  */\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \" TSSCHECK(\"RSTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\n  SECCODE = TSSCHECK(RSTYPE,RESCHK,ACCCHK,\"NOMSG\")\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \"T50PMENU(MODRULE): TSSCHECK RETURN CODE IS \" SECCODE\nEND\nRETURN\n/*******************************************************/\n/******************************************************************/\n/**  THE MODRULE SECTION                                         **/\n/******************************************************************/\n/*******************************************************/\nMODRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. CMD. BATFILE. OUT_COUNT FLAG,\n       ACID OTHER. SECCODE\nCALL OFF ERROR\nOUT_COUNT = OUT_COUNT + 1\nSAY \"T50PMENU: RECNUM IS \" FILL\nTEMP   = T + THISREC - 1\nSAY \"T50PMENU: RECNUM IS \" TEMP\nOUT_CMD = WORD(CMD.TEMP,1)\nOUT_RNAME = RSNAME.TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T50PMENU: MODRULE TYPE WAS :\" TYPE\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = FLAG TYPE\nSAY \"T50PMENU: MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nSAY \"T50PMENU: INSIDE MODRULE  ROUTINE\"\nSAY \"T50PMENU: ACTION IS\"  ACTION\nSAY \"T50PMENU: FACILITY IS \"  FACILITY\nSAY \"T50PMENU: PGM IS\"  PGM\nSAY \"T50PMENU: ACCESS IS\"  ACCESS\nSAY \"T50PMENU: LIBRARY IS\"  LIBRARY\nSAY \"T50PMENU: UNTIL IS\"  UNTIL\nSAY \"T50PMENU: TYPE IS\"  TYPE\nSAY \"T50PMENU: RSNAME IS\"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECUPDT)\"\nRCODE = RC\nADDRESS ISPEXEC \"REMPOP\"\nIF RCODE > 0 THEN DO\n  OUT_COUNT = OUT_COUNT - 1  /* KILL THE DELETE ENTRY */\n  TYPE.TEMP = TYPE           /* RESET THE TYPE FIELD */\n  MSG = \" MODIFY ABORTED DUE TO PANEL RETURN CODE.\"\n  RETURN\nEND\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"RSNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  H = H||TYPE||\"(\"RSNAME\") + \"\nEND\nBATFILE.OUT_COUNT = H\nH =  ''\nOUT_COUNT = OUT_COUNT + 1\nIF LENGTH(UNTIL) = 8 THEN UNTIL = \"UNTIL(\"UNTIL\")\"\nIF ACCESS <> '' THEN H = H||\"ACCESS(\"ACCESS\") \"\nIF LIBRARY <> '' THEN DO\n  H = H||\"LIBRARY(\"LIBRARY\") + \"\n  BATFILE.OUT_COUNT = \"  \"||H\n  H =  ''\n  OUT_COUNT = OUT_COUNT + 1\nEND\nIF PGM <> '' THEN H = H||\"PRIVPGM(\"PGM\") \"\nIF UNTIL  <> '' THEN H = H||\" \"UNTIL\nIF ACTION <> '' THEN H = H||\" ACTION(\"ACTION\") \"\nIF FACILITY <> '' THEN H = H||\" FAC(\"FACILITY\") \"\nIF OTHER <> '' THEN H = H OTHER\nBATFILE.OUT_COUNT = \"  \"||H\nPGM.TEMP      = PGM\nACCESS.TEMP   = ACCESS\nLIBRARY.TEMP  = LIBRARY\nACTION.TEMP   = ACTION\nFACILITY.TEMP = FACILITY\nUNTIL.TEMP    = UNTIL\nRSNAME.TEMP    = RSNAME\nRETURN\n/******************************************************************/\n/** THE DELETE RULE SECTION                                      **/\n/******************************************************************/\nDELRULE: PROCEDURE EXPOSE TYPE. RSNAME. T ACID,\n        THISREC UPDATE. CMD. BATFILE. OUT_COUNT DELTRUNC.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nOUT_COUNT = OUT_COUNT + 1\nTYPE= TYPE.TEMP\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = \"*DELETE\" TYPE.TEMP\nOUT_ACID = ACID\nOUT_CMD = WORD(CMD.TEMP,2)\nOUT_RNAME = RSNAME.TEMP\nOUT_TRUNC = DELTRUNC.TEMP\n/******************************/\n/** truncate the rsname maybe**/\n/******************************/\nIF OUT_TRUNC = 1 THEN OUT_RNAME = WORD(OUT_RNAME,1)\nIF OUT_TRUNC = 2 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2)\nIF OUT_TRUNC = 3 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2) WORD(OUT_RNAME,3)\nIF SUBSTR(TYPE,1,1) = \"*\" THEN TYPE = WORD(TYPE,2) WORD(TYPE,3)\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"OUT_RNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  /*                         */\n  H = H||TYPE||\"(\"OUT_RNAME\")\"\nEND\nBATFILE.OUT_COUNT = H\n/* SAY OUT_COUNT */\n/* SAY H*/\nRETURN\nFILLSCR: PROCEDURE EXPOSE THISREC OUTNUM TYPE. RSNAME. ACCESS. T,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 TYPE1 TYPE2 TYPE3,\n TYPE4 TYPE5 TYPE6 TYPE7 TYPE8 TYPE9 TYPE10 TYPE11 TYPE12 TYPE13,\n ACCESS1 ACCESS2 ACCESS3 ACCESS4 ACCESS5 ACCESS6 ACCESS7 ACCESS8,\n ACCESS9 ACCESS10 ACCESS11 ACCESS12 ACCESS13 ACCESS14 TYPE14,\n RSNAME1 RSNAME2 RSNAME3 RSNAME4 RSNAME5 RSNAME6 RSNAME7 RSNAME8,\n RSNAME9 RSNAME10 RSNAME11 RSNAME12 RSNAME13 RSNAME14,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F.\nOPT = \" \"\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nIF (THISREC > OUTNUM - 14)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\nDO T = 1 TO 14\n  FILL = THISREC + T - 1\n  INTERPRET \"F.\"T \"=  F\"||T\n  IF WORDS(TYPE.FILL) > 2 THEN DO\n    SAY \"T50PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n    TYPE.FILL = WORD(TYPE.FILL,1) WORD(TYPE.FILL,3)\n    SAY \"T50PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n  END\n  INTERPRET \"TYPE\"||T \" =  TYPE.FILL\"\n  INTERPRET \"RSNAME\"||T \"= RSNAME.FILL\"\n  INTERPRET \"ACCESS\"||T  \"=  ACCESS.FILL\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52PWHO": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x04\\x00\\x03\\x00\\x97 /\\x01\\x04\\x00\\x7f\\x15&\\x00\\x8d\\x00\\x8d\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.04", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2004-01-07T15:26:03", "lines": 141, "newlines": 141, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added an exit with rc=8 for a bad tss id.             */\n/**********************************************************/\n/** Changed to use T51gdat for type processing            */\n/** should be faster for departments and divisions than   */\n/** the older routine.  Dave                              */\n/**********************************************************/\n/** Changed to support all listopt parm which allows      */\n/** all IDs to be listed including departments profiles   */\n/** and security administrators.           Dave           */\n/**********************************************************/\n/**********************************************************/\n/** NO SAYS CAUSE  THIS PGM IS EXPECTED TO WRITE OUTPUT  **/\n/** DATA DIRECTLY TO THE SCREEN.   DAVE                  **/\n/**********************************************************/\n/** EXEC NAME        : T51PWHO                           **/\n/** LAST MODIFIED    : 15 July 97                        **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** PROF    : THE TARGET ID OF THE LIST.                 **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG PROF LISTALL\nENV = SYSVAR(SYSENV)\nsecrc = \"List function failed. ACID may be invalid.\"\nIF ENV = \"FORE\" THEN DO\n  ADDRESS TSO \"%T52GDAT \"PROF\" TYPE\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  IF TYPE = \"$BADTSS\" THEN EXIT 08\n  secrc = \"List function failed. ACID may be invalid.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  IF TYPE = \"MASTER\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"PROFILE\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"DIVISION\" THEN DIVFLAG = \"YES\"\n  IF TYPE = \"DEPT\" THEN DEPTfLAG = \"YES\"\n  IF TYPE = \"ZONE\" THEN ZONEFLAG = \"YES\"\nEND\nIF ENV /= \"FORE\" THEN DO\n  SPACES = \"                                \"\n  Q = OUTTRAP(\"TYPE.\")\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(BASIC)\"\n  DO T = 1 TO TYPE.0\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DIVISION\") THEN\n      DIVFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DEPT\") THEN\n      DEPTFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"MASTER\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"PROFILE\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"ZONE\") THEN\n      ZONEFLAG = \"YES\"  /* FOR LATER ENHANCEMENTS */\n  END\nEND\nIF NORMFLAG = \"YES\" THEN DO\n   ACID.1   = PROF\n   CALL PRINTDPT /* A DEPT OR PROFILE WAS GIVEN. NO PROBLEM. */\n   EXIT 00\nEND\nIF ZONEFLAG = \"YES\" THEN DO     /* ZONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") TYPE(USER)\"\nEND\nIF DEPTFLAG = \"YES\" THEN DO     /* DEPT PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") TYPE(USER)\"\nEND\nIF DIVFLAG = \"YES\" THEN DO     /* DIVISIONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") TYPE(USER)\"\nEND\n/*                       */\nSECRC = \"FUNCTION COMPLETED NORMALLY.\"\nIF ENV = \"FORE\" THEN\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nPRINTDPT: PROCEDURE EXPOSE ACID. LISTALL\nDO IDNUM = 1 TO 4\n  Q = OUTTRAP(\"TYPE.\")\n  IF ACID.IDNUM = \"  \" THEN RETURN\n  IF ACID.IDNUM = \"ACID.\"IDNUM THEN RETURN\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(BASIC)\"\n  IF LISTALL = \"YES\" THEN SAY ACID.IDNUM\n  Q = OUTTRAP(\"OFF.\",0)\n  NORMAL = \"NO\"\n  DO T = 1 TO TYPE.0\n    W1 = WORD(TYPE.T,1)\n    W3 = WORD(TYPE.T,3)\n    IF W1 = \"TYPE\" THEN DO\n      IF W3 = \"DEPT\" THEN NORMAL = \"YES\"\n      IF W3 = \"MASTER\" THEN NORMAL = \"YES\"\n      IF W3 = \"PROFILE\" THEN NORMAL = \"YES\"\n      IF NORMAL = \"NO\" THEN DO\n        SAY ACID.IDNUM /* AN UNUSUAL USER */\n        ITERATE IDNUM\n      END\n    END\n  END\n  /********************************************************/\n  /* SINCE WE ARE HERE THIS ACID MUST BE A DEPARTMENT!    */\n  /********************************************************/\n  Q = OUTTRAP(\"OUT.\")\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(ACIDS)\"\n  Q = OUTTRAP(\"OFF.\",0)\n  GOFLAG = \"NO\"\n  DO T = 1 TO OUT.0\n    IF WORD(OUT.T,1) = \"ACIDS\" THEN GOFLAG = \"YES\"\n    IF WORD(OUT.T,1) = \"TSS0300I\" THEN LEAVE\n    IF WORD(OUT.T,1) = \"TSS300I\" THEN LEAVE\n    IF GOFLAG = \"YES\" THEN DO\n      /*SAY \"OUT.T IS  \"OUT.T */\n      PRT.1 = SUBSTR(OUT.T,14,8)\n      PRT.2 = SUBSTR(OUT.T,26,8)\n      PRT.3 = SUBSTR(OUT.T,38,8)\n      PRT.4 = SUBSTR(OUT.T,50,8)\n      DO X = 1 TO 4\n        IF PRT.X = \"*NONE*\" THEN PRT.X = \"  \"\n        IF PRT.X \u00ac= \"  \" THEN SAY PRT.X\n        PRT.X = \"  \"\n      END\n    END\n  END\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(ACIDS)\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52RENA": {"ttr": 6925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x00\\x16\\x7f\\x01\\x005_\\t6\\x00Q\\x00Q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2000-12-20T09:36:07", "lines": 81, "newlines": 81, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** THIS IS AN IMS ONLY EXEC DON NOT USE ON CSS LPAR     **/\n/**********************************************************/\n/** EXEC NAME        : T51RENA                           **/\n/** LAST MODIFIED    : 15 DEC 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID                                   **/\n/** NEW_ACID: WHAT YOU WANT IT RENAMED TO                **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  NONE                                                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEW_ACID\nSAY \"T51RENA: IN CONTROL WITH PARMS :\" ACID NEW_ACID\nADDRESS TSO\nNEW_LENGTH = LENGTH(NEW_ACID)\nIF NEW_LENGTH = 2 THEN DO\n  SAY \"T51RENA: TARGET ACID IS BEING RESOLVED DUE TO LENGTH\"\n  NEW_ACID = NEW_ACID||SUBSTR(ACID,3)\n  SAY \"T51RENA: TARGET ACID IS RESOLVED TO : \" NEW_ACID\nEND\nCALL OFF ERROR\nADDRESS ISPEXEC \"VGET ZSYSID \"; SYSID = ZSYSID\nSAY \"T51RENA: SYSID IS :\" SYSID\nif sysid = \"CSS1\" then secrc = \"rename function is invalid on CSS LPAR.\"\nif sysid = \"CSS1\" then signal seeya\nSECRC = \"THE RENAME FUNCTION HAS COMPLETED.\"\nRCODE = 0\nNEWD1  =  SUBSTR(DATA,1,2)\nNEWDPT =    NEWD1\"DEPT\"\n/*******************************************************/\n/** HERE IS THE IMS CHANGE SECTION.                   **/\n/** SYSA SYSB AND SYSC                                **/\n/*******************************************************/\n  SAY \"T51RENA: WE ARE ENTERING IMS RENAME LOGIC \"\n  \"%IMSALIAS\"  NEW_ACID\n  IF RC = 4 THEN SECRC = \"FUNCTION COMPLETE. TSO AUTHS MAY NEED TO BE\",\n   \"CHECKED.\"\n  RCODE = 0\n  \"TSS RENAME( \"ACID\") ACID(\"NEW_ACID\")\"\n  \"%TSSAUDU \" NEW_ACID\n  \"%TSSAUDR \" ACID\n  IF SYSDSN(\"'SYS1.TSOUSERS(\"NEW_ACID\")'\") /= \"OK\" THEN\n    \"%RXREPRO SYS1.TSOUSERS(\"ACID\") SYS1.TSOUSERS(\"NEW_ACID\")\"\n  \"%UADRENA \"ACID  NEW_ACID\n  /* \"%REPLACE SYS1.TSOUSERS(\"NEW_ACID\")\" ACID NEW_ACID*/\n  \"TSS REP(\"NEW_ACID\") TSOCOMMAND('PROFILE PREFIX(\"NEW_ACID\")')\"\n  \"TSS LIST( \"NEWDPT\") DATA(NAME)\"\n  IF RC = 0 THEN ADDRESS TSO \"TSS MOVE(\"NEW_ACID\") DEPT(\"NEWDPT\")\"\n  Q = OUTTRAP('LINE.')\n  \"LISTC LEVEL(\"ACID\")\"\n  Q = OUTTRAP('NULL.') /* LETS NOT SCREW UP OUR DATA NOW !  */\n  SAY \"I AM RENAMING \"LINE.0 \"DATASETS.\"\n  DO X = 1 TO LINE.0\n    PARSE VAR LINE.X W.1 W.2 W.3 W.4\n    IF W.1 = \"NONVSAM\" THEN DO\n      PARSE VAR W.3 HLQ \".\" LOWLQ\n       SAY \"RENAME '\"W.3\"' '\"NEW_ACID\".\"LOWLQ\"'\"\n      \"RENAME '\"W.3\"' '\"NEW_ACID\".\"LOWLQ\"'\"\n       IF RC /= 0 THEN SAY \"RENAME FOR \"W.3 \"FAILED!\"\n    END\n  END\n  \"%IMSDALIA\" ACID\nIF RCODE /= 0 THEN SECRC = \"ERRORS ENCOUNTERED. CHECK ID STATUS\"\n\"%UADRENAM\" ACID  NEW_ACID\nseeya: nop\nSAY \"T51RENA:\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52REPL": {"ttr": 6913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00Q\\x00\\x955/\\x00\\x98&O\\x14X\\x00)\\x00)\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1998-09-21T14:58:51", "lines": 41, "newlines": 41, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\nARG ACID PROFOLD PROFNEW\nSAY ACID PROFOLD PROFNEW\nPROFHOLD = PROFNEW /* SAVE ORIGINAL PARM FOR T50INS */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\".\") /* REPLACE DOTS WITH SPACES */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\"_\") /* REPLACE BARS WITH SPACES */\nSAY \"T50REPL: \" ACID PROFOLD PROFNEW\nADDRESS ISPEXEC\n/********************************************************************/\n/***  THIS EXEC REPLACES ONE PROFILE IN A TOP SECRET ACID WITH    ***/\n/***  ONE OR MORE OTHER PROFILES. IT REQUIRES THAT T50INS         ***/\n/***  BE AVAILABLE TO DO INSERTIONS.....DIR 26 APRIL 93           ***/\n/********************************************************************/\nWORDNUM = WORDS(PROFOLD)\nIF WORDNUM > 1 THEN DO\n  SECRC = \"YOU MUST SPECIFY ONLY 1 PROFILE FOR REPLACEMENT\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSAY \"T50REPL: CALLING T50FLOC\"\nADDRESS TSO \"%T50FLOC\" ACID PROFOLD\nSAY \"T50REPL: BACK FROM T50FLOC\"\n\" VGET SECRC PROFILE\"\nPLACE = SECRC\nSAY \" PLACE IS \" PLACE\nIF (PLACE = \"ERROR\") | ( PLACE= 0 ) THEN DO\n  SECRC = \"ERROR LOCATING \"PROFOLD \"IN ACID.. REPLACE ABORTED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROFOLD\")\"\nSIGNAL ON ERROR NAME BADPROF\nSAY \"T50REPL: CALLING T50INS\"\nADDRESS TSO \"%T50INS\" ACID PROFHOLD PLACE\nSECRC = \"PROFILE REPLACE COMPLETED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT 00\nBADPROF: NOP\nSECRC = PROFOLD \"WAS IN PLACE \"PLACE\", HOWEVER INSERTION OF \",\n  PROFNEW \"FAILED!\"\n  \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52REPPW": {"ttr": 6927, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00W\\x01\\x00\\x16\\x7f\\x01\\x005_\\t5\\x00S\\x00S\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2000-12-20T09:35:57", "lines": 83, "newlines": 83, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51REPPW                          **/\n/** LAST MODIFIED    : 11 JUL 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE VALID TSS DEFINED ID                   **/\n/** NEWPW   : A VALID 1 - 8 CHR NEW PASSWORD             **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  ACID IF NOT PASSED AS AN ARG.                       **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         MSG2                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T51FDIV TSSPWDR      **/\n/**                                 T51GDAT              **/\n/**********************************************************/\nARG ACID NEWPW\nIF ACID = \" \" THEN ADDRESS ISPEXEC \"VGET ACID  PROFILE\"\nSAY \"T51REPPW: HAS CONTROL\"\nSAY \"T51REPPW: CALLING T51FDIV\"\nADDRESS TSO \"%T51FDIV \"ACID\nADDRESS ISPEXEC \"VGET MODE PROFILE\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET UIDTABLE PROFILE\"\nADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\nSAY \"T51REPPW: BACK FROM  T51FDIV WITH SECRC OF\" SECRC\nIF SECRC = \"AUTHORIZATION FAILED.\" THEN DO\n  SECRC = \"FAILED. YOUR TOP SECRET AUTHORIZATION IS INADEQUATE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC = \"CUSTDIV\" THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"THAT IS DEFINED AS AN EXTERNAL CUSTOMER. TRY LISTPW\"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    EXIT 00\n    END\n  ELSE DO\n   MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY CHANGEABLE.\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nIF (SECRC = \"CENTRAL\") | (SECRC = \"MASTER\") THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"YOU ARE NOT AUTHORIZED TO CHANGE THAT ID.\"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    EXIT 00\n    END\n  ELSE DO\n   MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY CHANGEABLE.\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nADDRESS TSO \"%T51GDAT \"ACID\" ATTRIBUTES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF INDEX(SECRC,\"SUSPEND\") /=  0 THEN DO\n  MSG2 =  \"THIS ID IS SUSPENDED, YOU MUST UNSUSPEND TO USE\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(\"NEWPW\")\"\nIF MODE = \"BATCH\" THEN DO\n  BJCL.1 = \" TSS REP(\"ACID\") PASSWORD(\"NEWPW\")\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  SECRC = \"THE BATCH FILE WAS UPDATED WITH COMMAND TO REPLACE PWORD\"\n  SIGNAL THEEND\nEND\nADDRESS TSO \"T51GDAT \"ACID\" PASSWORD PW\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF ( SECRC = \"$NOTFOUND\" ) | ( SECRC = \"$BADTSS\" )  THEN DO\n  MSG2 = \"THE IDS PASSWORD IS NOT RETRIEVABLE. CONTACT TECH SUPPORT\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nELSE\n  SECRC = \"THE IDS PASSWORD IS NOW  = \"SECRC\nTHEEND: NOP\nADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52RESET": {"ttr": 8463, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x11\\x00\\x993?\\x01\\x04\\x07\\x1f\\x07)\\x00\\x10\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-11-29T00:00:00", "modifydate": "2004-03-11T07:29:11", "lines": 16, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX THE WONDER DOG */\nsignal off error\narg acid newpass\nrcode = 0\naddress tso\nsay \"tss rem(\"acid\") asuspend \"\n\"tss rem(\"acid\") asuspend \"\nrcode = rcode + rc\nsay \"tss rem(\"acid\") suspend \"\n\"tss rem(\"acid\") suspend \"\nrcode = rcode + rc\nsay \"tss rep(\"acid\") password(\"newpass\")\"\n\"tss rep(\"acid\") password(\"newpass\")\"\nrcode = rcode + rc\nexit 0\nexit rcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52TSO": {"ttr": 6929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x005o\\x01\\x01\\t_\\x155\\x01[\\x01[\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-12-21T00:00:00", "modifydate": "2001-04-05T15:35:08", "lines": 347, "newlines": 347, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51TSO                            **/\n/** LAST MODIFIED    : 21 SEP 98                         **/\n/**********************************************************/\n/**********************************************************/\n/** CHANGED TO MAKE MORE GENERIC                         **/\n/**********************************************************/\n/** CHANGED TO ALLOW DEFINITION OF UNOWNED RESOURCES     **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** VAR                VALID VALUES                      **/\n/** ACTION  : DEFAULTS ADDPROC ADDACCT DEFACCT DEFPROC   **/\n/**           DEFSIZE  DEFUNIT MAXSIZE REMACCT TSOAUTH   **/\n/** ACID    : ANY VALID TSS ACID                         **/\n/** LPROC   : ANY VALID PREDEFINED (TO TSS) PROC         **/\n/** ACCTNUM : ANY VALID PREDEFINED (TO TSS) ACCOUNT      **/\n/** UNIT    : ANY VALID UNIT                             **/\n/** SIZE    : ANY VALID SIZE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 16                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : NOT NEEDED, BUT WILL USE        **/\n/** EXECS CALLED WITHIN THIS EXEC : T51INS               **/\n/**                                                      **/\n/**********************************************************/\nSYSENV = SYSVAR(SYSENV)\nMSG2 = \"NO UNUSUAL CONDITIONS WERE FOUND.\"\nARG ACTION ACID LPROC ACCTNUM UNIT SIZE\n/*                                             */\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET BOOKSEC PROFILE\"\nEND\nELSE DO\n  AUTHNUM = 10\n  BOOKSEC = \"NO\"\nEND\n/*IF SUBSTR(ACID         ,8,1) = \"@\" THEN DO                      */\n/*  MSG2 = \"WARNING: THE ID YOU HAVE GIVEN ME IS A GHOST ID.\"     */\n/*  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"   */\n/*  ELSE SAY SECRC                                                */\n/*END                                                             */\nIF (LENGTH(ACID) > 8) & ( SUBSTR(ACID        ,8,1) \u00ac= \"@\" ) THEN DO\n  SECRC = \"THE ID YOU HAVE GIVEN ME IS TOO LONG MAX IS 7 CHRS\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ELSE SAY SECRC\n  EXIT 00\nEND\nSIGNAL ON ERROR NAME NOTSSID\nQ = OUTTRAP(DROPIT.,5)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nSIGNAL OFF ERROR\nX5 = \"OK\"\nSAY \"T51TSO: RECEIVED  CONTROL ACTION=\" ACTION \"ACID=\"ACID\nSAY \"T51TSO: PROC=\"LPROC\" ACCT=\"ACCTNUM\" UNIT=\"UNIT \"SIZE=\"SIZE\n/**************************************************/\n/* IF THE RESOURCE IS NOT OWNED ADD IT TO TSODEPT */\n/**************************************************/\nIF (AUTHNUM > 8) & (ACTION \u00ac= \"TSOAUTH\")  THEN DO\n  Q = OUTTRAP(DROPOUT.,5)\n  /* SAY \"T51TSO: CHECKING THAT ALL RESOURCES ARE OWNED \" */\n  TSS_RESOURCE = LPROC\n  ADDRESS TSO \" TSS WHOOWNS TSOPROC(\"LPROC\")\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE LPROC TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOPROC(\"LPROC\")\"\n  END\n  TSS_RESOURCE = ACCTNUM\n  ADDRESS TSO \" TSS WHOOWNS TSOACCT(\"ACCTNUM\")\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE ACCTNUM TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOACCT(\"ACCTNUM\")\"\n  END\n  TSS_RESOURCE = \"JCL\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(JCL)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE JCL AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(JCL)\"\n  END\n  TSS_RESOURCE = \"OPER\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(OPER)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE OPER AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(OPER)\"\n  END\n  TSS_RESOURCE = \"ACCT\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(ACCT)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE ACCT AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(ACCT)\"\n  END\n  SAY \"T51TSO: RESOURCE OWNER CHECKING COMPLETED.\"\nEND\n/**************************************************/\n/* END OF OWNERSHIP RESOLUTION.                   */\n/**************************************************/\nQ = OUTTRAP(OUT.,5)\nSIGNAL ON ERROR NAME SEEYA\n/* ACTION =DEFAULTS */\nIF (ACTION = \"DEFAULTS\") | (ACTION = \"DEFTSO\") THEN DO\n  SAY \"T51TSO: ATTEMPTING TO DEFINE ALL TSO AUTHS\"\n  SAY \"T51TSO: REMOVING ANY OLD PERMISSIONS FOR\" LPROC ACCTNUM\n  IF ACCTNUM \u00ac= \"NIL\" THEN DO\n    IF BOOKSEC = \"YES\" THEN\n      X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS*/\n    ELSE X5 = \"OK\"\n  END\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOAUTH(JCL)\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLPROC(\"LPROC\")\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLSIZE(\"SIZE\")\"\n  SAY \"T51TSO: DEFINING NEW TSO DEFAULTS.\"\n  SIGNAL ON ERROR NAME NOTSSDEF\n  Q = OUTTRAP(OUT.,5)\n  TSS_RESOURCE = \"LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\n  TSS_RESOURCE = \"ACCT NUM\" ACCTNUM\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  TSS_RESOURCE = \"JCL\"\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOAUTH(JCL)\"\n  SIGNAL ON ERROR NAME SEEYA\n  Q = OUTTRAP(OUT.,5)\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOUNIT(\"UNIT\")\"\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLPROC(\"LPROC\")\"\n  IF ACCTNUM \u00ac= \"NIL\" THEN\n    ADDRESS TSO \" TSS ADD(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLSIZE(\"SIZE\")\"\n  SAY \"T51TSO: CALLING T51INS FOR PROFILE INSERTION\"\n  ADDRESS TSO \"%T51INS\" ACID \"TSOPROF 9\"\n  SAY  \"T51TSO: BACK FROM T51INS WITH RC OF\" RC\nEND\nIF ACTION = \"ADDPROC\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM PROC\" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \"TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING ID TO PROC\" LPROC\n  ADDRESS TSO \"TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\nEND\nIF ACTION = \"ADDACCT\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM ACCT\" ACCTNUM\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME NOBOOK\n  SAY \"T51TSO: PERMITTING ID TO ACCT\" ACCTNUM\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"DEFACCT\" THEN DO\n  SIGNAL OFF ERROR\n  ADDRESS TSO \"%T51GDAT \" ACID \"TSOLACCT  TSO\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  BOOK = SECRC\n  IF BOOK = \"\" THEN SAY \"T51TSO: NO DEFAULT BOOK NUMBER DEFINED \"\n  IF BOOK = \"\" THEN BOOK  = \"$NOTFOUND\"\n  /********************************************************/\n  /* DOES HE HAVE A CURRENT DEFAULT TSS BOOK NUMBER ??    */\n  /********************************************************/\n  IF (BOOK = \"$BADTSS\") |  (BOOK = \"$NOTFOUND\") THEN NOP\n  ELSE DO\n    /********************************************************/\n    /* CAN HE OVERLAY THE CURRENT DEFAULT BOOK NUMBER ??    */\n    /********************************************************/\n    BOOK = SECRC\n    IF BOOKSEC = \"YES\" THEN\n      X5 = TSSCHECK(\"BOOKNUM\",BOOK,\"UPDATE\")  /* CAN THEY DO THIS */\n    ELSE X5 = \"OK\"\n    SAY \"T51DEL: TSSCHECK RETURN CODE IS \" X5\n    IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKREMA\n  END\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SAY \"T51TSO: REVOKING ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME NOBOOK\n  SAY \"T51TSO: PERMITTING ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SAY \"T51TSO: MAKING IDS DEFAULT ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"DEFPROC\" THEN DO\n  SIGNAL OFF ERROR\n  SAY \"T51TSO: REVOKING LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLPROC(\"LPROC\")\"\n  PDSN = \"'MVS.TSO.PROCLIB(\"LPROC\")'\"\n  /* SAY SYSDSN(PDSN) */\n  IF SYSDSN(PDSN)  = \"MEMBER NOT FOUND\" THEN DO\n    MSG2 = \"LOGON PROC CHANGED, BUT \"PDSN\" WAS NOT FOUND\"\n    IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    SAY \"T51TSO:\" MSG2\n  END\nEND\nIF ACTION = \"DEFSIZE\" THEN DO\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON SIZE\" SIZE\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLSIZE(\"SIZE\")\"\nEND\nIF ACTION = \"DEFUNIT\" THEN DO\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON UNIT\" UNIT\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOUNIT(\"UNIT\")\"\nEND\nIF ACTION = \"MAXSIZE\" THEN DO\n  SAY \"T51TSO: MAKING IDS MAXIMUM REGION SIZE\" SIZE\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOMSIZE(\"SIZE\")\"\nEND\nIF ACTION = \"REMACCT\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM ACCOUNT \" ACCTNUM\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"REMPROC\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM LOGON PROC \" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"TSOAUTH\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM AUTHS \" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOAUTH(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING ID TO \" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOAUTH(\"LPROC\")\"\nEND\nSAY \"T51TSO: CHECKING FOR TSO AREA COMPLETENESS.\"\nSAY \" \"\nSIGNAL OFF ERROR\nIF (ACTION \u00ac= \"DEFAULTS\") & (ACTION \u00ac= \"DEFTSO\") THEN DO\n  ADDRESS TSO \"%T51GDAT \"ACID\" TSOLACCT TSO\"\n  IF SYSENV = \"FORE\" THEN\n    ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  DEFAULT_ACCT = SECRC\n  SAY \"T51TSO: IDS DEFAULT ACCOUNT IS \" DEFAULT_ACCT\n  ADDRESS TSO \"%T51GDAT \"ACID\" TSOLPROC TSO\"\n  IF SYSENV = \"FORE\" THEN\n    ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  DEFAULT_PROC = SECRC\n  SAY \"T51TSO: IDS DEFAULT LPROC IS \" DEFAULT_PROC\n  IF (DEFAULT_PROC = \"$NOTFOUND\") THEN DO\n    MSG2 = \"ID HAS NO DEFAULT PROC IN TSS,\"\n    MSG2 = MSG2 \"MAY NEED THE DEFTSO CMD ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  IF (DEFAULT_ACCT = \"$NOTFOUND\") THEN DO\n    MSG2 = \"ID HAS NO DEFAULT ACCOUNT IN TSS,\"\n    MSG2 = MSG2 \"MAY NEED THE DEFTSO CMD ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSAY \"T51TSO: FALL THRU AREA REACHED. SETTING MSG AND EXITING\"\nSAY \" \"\nSECRC = ACTION \"FUNCTION COMPLETED\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nELSE SAY SECRC MSG2\nEXIT 0\nSEEYA: NOP\nSAY \"T51TSO: **FATAL** ERROR OCCURRED IN LINE :\" SIGL\nTEMP = SOURCELINE(SIGL)\nSAY \"T51TSO: LINE\" SIGL \"=\" TEMP\nIF RC = 8 THEN DO\n  SECRC = \"FUNCTION FAILED. CONFIRM VALIDITY (OWNERSHIP) OF DATA\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY \"T51TSO: *************************************************\"\n  SAY \"T51TSO: EXITING WITH RC = 08 PROBABLE TSS COMMAND FAILURE\"\n  SAY \"T51TSO: *************************************************\"\n  EXIT 8\nEND\nNOBOOK: NOP\nSAY \"T51TSO: ERROR OCCURRED IN LINE :\" SIGL\nTEMP = SOURCELINE(SIGL)\nSAY \"T51TSO: LINE\" SIGL \"=\" TEMP\nIF RC = 8 THEN DO\n  SECRC = \"FUNCTION FAILED. BOOK NUMBER MAY NOT EXIST \"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY \"T51TSO: EXITING WITH RC = 08 PROBABLE TSS OWNERSHIP ERROR.\"\n  EXIT 8\nEND\nSAY \"T51TSO: *************************************************\"\nSAY \"T51TSO: EXITING WITH RC = 16 !  FATAL ERROR.\"\nSAY \"T51TSO: *************************************************\"\nEXIT 1\nNOTSSDEF: NOP\nSAY \"T51TSO: A PERMIT ERROR OCCURRED IN LINE:\" SIGL\nSECRC = \"ABORTED.\" TSS_RESOURCE\" IS UNOWNED IN TSS.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY OUT.1\nSAY OUT.2\nSAY OUT.3\nSAY \"T51TSO: \"SECRC\nEXIT 8\nNOTSSID: NOP\nSAY \"T51TSO: THE ID YOU HAVE GIVEN DOES NOT EXIST\"\nSECRC = \"ABORTED. NO SUCH TOP SECRET ID, UNDER YOUR OWNERSHIP.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nBOOKAUTH: NOP\nSAY TSSCHECK RCODE WAS X5\nSECRC = \"YOU ARE NOT AUTHORIZED FOR THIS BOOK FUNCTION. BOOK= \" ACCTNUM\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nBOOKREMA: NOP\nSAY TSSCHECK RCODE WAS X5\nSECRC = \"YOU CANT OVERLAY BOOK VALUE = \"BOOK\". TRY ADDACCT INSTEAD.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nTSSNOADD: NOP\nSAY \"T51TSO: AN OWNERSHIP ERROR OCCURRED IN LINE:\" SIGL\nSECRC = \"ABORTED.\" TSS_RESOURCE\" OWNERSHIP RESOLUTION FAILED IN TSS.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52TSSIM": {"ttr": 6915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x009\\x00\\x955/\\x01\\x00\\x05O\\x115\\x00*\\x00*\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-02-23T11:35:39", "lines": 42, "newlines": 42, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* ROUTES THE OUTPUT OF A TSSSIM COMMAND TO A DATASET OF YOUR CHOICE */\n/*********************************************************************/\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n SAY \"ACID RTYPE RNAME FACILITY ACCESS DSOUT\"\n SAY ACID RTYPE RNAME FACILITY ACCESS DSOUT\n IF RTYPE = \"VOLUME\" THEN RTYPE = \"DASDVOL\"\n IF RTYPE = \"VOL\" THEN RTYPE = \"DASDVOL\"\n ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"ALLOC DDN(SIM$$OUT) DSN(\"DSOUT\") SHR REUS\"\n OUT.1 = \"  LOGON ACID(\"ACID\") FAC(\"FACILITY\") TRACE \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") MOD REUS\"\n OUT.1 = \"  $\"RTYPE\"(\"RNAME\") ACCESS(\"ACCESS\")  \"\n IF ACCESS = \".NA.\" THEN\n   OUT.1 = \"  $\"RTYPE\"(\"RNAME\")\"\n IF RTYPE = \"DSN\" THEN\n   OUT.1 = \"  $\"RTYPE\"('\"RNAME\"') ACCESS(\"ACCESS\")  \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \" FREE DDN(OUTFILE)\"\n ADDRESS TSO \"ALLOC DDN(SIM$$IN) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"TSSSIM\"\n ADDRESS TSO \" FREE DDN(SIM$$IN)\"\n ADDRESS TSO \" FREE DDN(SIM$$OUT)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52UNDEL": {"ttr": 6917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00W\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00:\\x00:\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:57", "lines": 58, "newlines": 58, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED UADS STEP .....................              **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50UNDEL                          **/\n/** LAST MODIFIED    : 31 MAR 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID TO BE RECREATED                   **/\n/** MODE    : THE MODE \"ONLINE\" OR \"BATCH\"               **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS1     : A FLAT FILE LRECL 80                       **/\n/** DS2     : A FLAT FILE LRECL 80                       **/\n/** DSBACK  : A PDS CONATAINING MEMBER (ACID)            **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (BUT IT NEEDS VGETS !)      **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : RXREPRO T44CON       **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS TSO\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nACID_COPY = \"'\"DSBACK\"(\"ACID\")'\"\nUADS_COPY = \"'\"UADSBACK\"(\"ACID\"0)'\"\nIF SYSDSN(ACID_COPY) \u00ac= \"OK\" THEN DO\n  say \"enqueue failed on\" acid_copy\n  secrc = \"Acid not resurrectable, no backup available. sorry\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 00\nEND\nIF MODE = \"ONLINE\" THEN DO\n  /* \"SMCOPY FDS(\"ACID_COPY\") TDS(\"DS1\") NOTRANS\"*/\n  ADDRESS TSO \"%RXREPRO \" ACID_COPY DS1\n  ADDRESS TSO \"%T50ICOMP  REBUILD BYPASS\"\n  ADDRESS TSO \"SUBMIT\" DS2\n  secrc = \"Job submitted to resurrect id \" acid\". check uads entries\"\n  END\nELSE DO\n  BJCL.1 = \"  %RXREPRO \"ACID_COPY DS1\n  BJCL.2 = \"  ISPSTART CMD(%T50ICOMP REBUILD ACID  ) NEWAPPL(TSS)\"\n  BJCL.3 = \"  SUBMIT\" DS2\n  BJCL.4 = \"  \"\n  ADDRESS MVS \"EXECIO 4 DISKW BJCL ( FINIS STEM BJCL.)\"\n  secrc = \"Batch file has been updated with resurrection stream.\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T52USUS": {"ttr": 8709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x04\\x01\\x00\\x16\\x7f\\x01\\x04\\t?\\x086\\x00I\\x00F\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2004-04-02T08:36:04", "lines": 73, "newlines": 70, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** CHANGED THE TSOUSERS LOOKUP                          **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T52USUS                           **/\n/** LAST MODIFIED    : 04 apr 2001                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ID TO UNSUSPEND                        **/\n/** ARG2    :                                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : CALLS PGM=IMSU200    **/\n/**                                                      **/\n/**********************************************************/\n ARG ACID MODE PWVAL\n /*******************************************************/\n /* dont use mode currently but it is here if I need it */\n /*******************************************************/\n say \"T52USUS: in control with parms \" acid mode pwval\n SYSENV = SYSVAR(SYSENV)\n SIGNAL OFF ERROR\n ADDRESS TSO \"%T52IDAT \"ACID\" UNSUSPEND\"\n idat_drc= rc\n OTT = OUTTRAP(OUT,0)  /* TRAP EVERYTHING */\n say \"T52USUS: IDATA drc:\" idat_drc\n ADDRESS TSO \"%T52GDAT \"ACID\" ATTRIBUTES\"\n ADDRESS ISPEXEC \"VGET SECRC \"\n ADDRESS TSO \"TSS REMOVE(\"ACID\") SUSPEND\"\n IF PWVAL = \"SAME\" THEN  DO\n   say \"T52USUS: issuing  address tso tss rep(\"acid\") password(*,60)\"\n   ADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(*,60)\"\n END\n ELSE DO\n   say \"T52USUS: issuing address tso tss rep(\"acid\") password(\"pwval\")\"\n   ADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(\"PWVAL\")\"\n END\n say \"T52USUS: attributes are \" secrc\n IF POS(\"ASUSPEND\",SECRC) \\= 0 THEN ADMIN_SUSPEND = \"YES\"\n IF POS(\"ADMIN SUSPEND\",SECRC) \\= 0 THEN ADMIN_SUSPEND = \"YES\"\n SIGNAL ON ERROR NAME BADID\n say \"T52USUS: received control env is \"sysenv\n CHKACID = ACID\n IF LENGTH(ACID) = 8 THEN CHKACID = SUBSTR(ACID,1,7)\n IF ( SYSENV = \"FORE\" ) & ( ACID= \" \" ) THEN\n   ADDRESS ISPEXEC \"VGET ACID PROFILE\"\n SECRC = \"NO UADS OR TOP SECRET ENTRY WAS FOUND FOR\" ACID\n say \"T52USUS: calling TSS for ACID\" acid\n IF ADMIN_SUSPEND = \"YES\" THEN DO\n   say \"T52USUS: ACID is admin suspended removing asuspend\"\n   ADDRESS TSO \" TSS REM(\"ACID\") ASUSPEND\"\n   say \"T52USUS: ACID was Admin suspended setting message\"\n   MSG2 = \"Warning: ID was manually suspended by an administrator!\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n END\n SECRC = \"ID unsuspend sucessful for \"ACID\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n else say \"T52USUS:\" secrc\n EXIT 00\n BADID: RCODE = RC\n say \"T52USUS: entering error recovery from line \" sigl \"code = \" rcode\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n EXIT 08\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53ADD": {"ttr": 8968, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x051\\x00\\x05\\x00\\x955/\\x01\\x04\\t/\\x08\\x04\\x01\\x7f\\x01s\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.49", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2004-04-01T08:04:05", "lines": 383, "newlines": 371, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T52ADD                            **/\n/** LAST MODIFIED    :  2 Jul 2003                       **/\n/**********************************************************/\n/** Added smarts to routine to insert the password parm  **/\n/** on the create if it doesn't exist and honor it if it **/\n/** does dir july 2 2003                                 **/\n/**********************************************************/\n/** added variable for default department vget           **/\n/**********************************************************/\n/** changed acid variable manipulation so that the acid  **/\n/** variable remains a little more stable.               **/\n/**                                .....DIR 19 AUGUST 96 **/\n/**********************************************************/\n/**********************************************************/\n/** ADDED LOGIC TO DETERMINE IF ID HAS DSNS CATLGD IN    **/\n/** MASTER CAT YET HAS NO ALIAS        DIR  11 MAY 95    **/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nSAY \"T52ADD: CONTROL RECEIVED PARMS = \" ACID MODE\nADDRESS ISPEXEC\n\"VGET AUD       PROFILE\"\n\"VGET DEF       PROFILE\"\n\"VGET DS1       PROFILE\"\n\"VGET DS2       PROFILE\"\n\"VGET DS3       PROFILE\"\n\"VGET DS4       PROFILE\"\n\"VGET DS5       PROFILE\"\n\"VGET DS6       PROFILE\"\n\"VGET MSG2      PROFILE\"\n\"VGET PROD      PROFILE\"\n\"VGET TSOSIZE   PROFILE\"\n\"VGET TSOUNIT   PROFILE\"\n\"VGET TSOPROC   PROFILE\"\n\"VGET TVER      PROFILE\"\nSIGNAL OFF ERROR\n/**********************************************************/\n/** below I am checking that the id doesnot have dsns    **/\n/** cataloged to the master catalog. if it does the      **/\n/** user wont be able to catalog his own datasets. this  **/\n/** will cause allocate errors that are hard to track.   **/\n/** i may make this a seperate callable exec but for     **/\n/** now it is included here    dave 11 may 95            **/\n/**********************************************************/\nDATEHOLD = DATE('U')\nMONTHNUM = SUBSTR(DATEHOLD,1,2)\nADDRESS TSO \"%T52GDAT \"ACID \"NAME\"\nOLDID = RC\noutct = 40\nBOOK = \"NIL\"\nBOOK1 = \"NIL\"\nSAY \"TSA101D: T52ADD  EXISTANCE CHECK RC IS \" OLDID\nIF OLDID = 0 THEN DO\n  msg2 = \"This id exists currently, readdition will fail upon\",\n  \"execution\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\n/**************************************/\n/* get the default department         */\n/**************************************/\nADDRESS ISPEXEC \"VGET DEFDEPT PROFILE\"\nADDRESS ISPEXEC \"VGET TSOALIAS PROFILE\"\nIF TSOALIAS = \"YES\" THEN DO\n  ADDRESS TSO \"LISTC ENT('\"ACID\"')\"\n  SAY \"TSA101D: T52ADD  ALIAS CHECK IS \" RC\n  ALIAS_CODE = RC\n  ADDRESS TSO \"LISTC LEVEL('\"ACID\"')\"\n  SAY \"TSA101D: T52ADD  LEVEL CHECK IS \" RC\n  LEVEL_CODE = RC\n  IF (ALIAS_CODE \u00ac= 0) & (LEVEL_CODE =0)  THEN DO\n    msg2 = \"The id has no alias, yet has dsns cataloged, expect\",\n    \"severe allocation errors\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSIGNAL ON ERROR NAME ABORT\n/**********************************************************/\n/** END OF DSN ALIAS / LEVEL CHECKING                    **/\n/**********************************************************/\nLINE.  = \" \"\nALEN   = LENGTH(ACID)\nBILLA  = \"N\"\nCODE   = 0\nCURSOR = \"NAME\"\nDEFINE = \"NAME('\"NAME\"') DEPT(D0) TYPE(USER)\"\nFIRST2 = SUBSTR(ACID,1,2)\nGOTDEF = \"NO\"\nLOGON  = TSOPROC\nNDEPT  = FIRST2||\"DEPT\"\nif defdept /= \"NONE\" then ndept = defdept\nPROF   = \" \"\nPWORD  = \"PASSWORD,60,EXP\"\nSECDEF. = \" \"\nsecrc  = \"T52ADD did not complete normally. please check the id.\"\nS2     = ALEN - 1\nTYPE   =  \"USER\"\nWARNED = \"NO\"\n\"VPUT SECRC PROFILE\"\nPW = \"PASSWORD\"\nDPNL   = \"SPIADD\"\nBASIC_ACID = \" \"\nAUDU.0 =   1\nAUDU.1 =   \"%ADDLOCAL\" ACID NDEPT\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER) PASSWORD(\"PW\",60,EXP)\"\n/****************************************************/\n/** the tso authority stream is below              **/\n/****************************************************/\n/*                                                                  */\n/*batchtso.0 = 3                                                    */\n/*batchtso.1 = \" \"                                                  */\n/*batchtso.2 = \"ISPSTART CMD(%\"TVER\"TSO DEFAULTS +\"                 */\n/*batchtso.3 = \" \"ACID LOGON BOOK1 TSOUNIT TSOSIZE\") NEWAPPL(TSS)\"  */\n/*onlintso.0 = 1                                                    */\n/*onlintso.1 =\"%\"TVER\"TSO DEFAULTS\" ACID LOGON BOOK1 TSOUNIT TSOSIZE*/\n/*                                                                  */\n/****************************************************/\n/** beginning of the panel loop                    **/\n/** beginning of the panel loop                    **/\n/****************************************************/\nAGAIN: NOP\nCALL FILLSCR\n\"DISPLAY PANEL(\"DPNL\")  CURSOR(\"CURSOR\")\"\nRCODE = RC\nif enum = \" \" then enum = \"000000    initial\"\nNAME = TRANSLATE(NAME,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSAY \"TSA101D: T52ADD  PANEL RCODE IS \"RCODE\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ERRMSG\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\nGETNAME: NOP\nCNT1 = 0\nNORMAL: NOP\nMEMBER = mem\nIF MEM = \"\" THEN MEMBER = NDEPT\nmem = member\nSAY \"TSA101D: CHECKING FOR DEFAULT DEPT AUTHORITIES\" DEF\"(\"MEMBER\")\"\nIF SYSDSN(\"'\"DEF\"(\"MEMBER\")'\") = \"OK\" THEN DO\n  say \"tsa101d: T52ADD  default authority group found for in \" def bin\n  address tso \"alloc ddn(secdef) dsn('\"def\"(\"member\")') shr reus\"\n  address mvs \"execio * diskr secdef ( finis stem secdef.)\"\n  address tso \"free ddn(secdef)\"\n  /******************************************************/\n  /***                                                ***/\n  /*** NOTE: THE FIRST LINE OF THE DSN MUST HAVE A    ***/\n  /*** CREATE PARM IN IT! IF THERE IS NO MEMBER I     ***/\n  /*** ASSIGN A VALUE TO SECDEF.1                     ***/\n  /***                                                ***/\n  /******************************************************/\n  SECDEF.1 = \"NAME('\"NAME\"')\" SECDEF.1\n  GOTDEF = \"YES\"\nEND\nELSE Do\n  secdef.1 = define /* if no member we just create a 1 liner */\n  if enum /= \" \" then\n    secdef.2 = \"TSS add(\"acid\") instdata('\"enum\"')\"\nEND\nsay \"T52ADD: secdef.1 is\" secdef.1\nsay \"T52ADD: secdef.2 is\" secdef.2\nDO T = 1 TO 40\n  /******************************************************/\n  /***                                                ***/\n  /*** ONCE HERE THERE HAS TO BE A SECDEF.1 VALUE AND ***/\n  /*** IT HAS IS    COMPRISED OF VALID 'CREATE' PARMS ***/\n  /*** FOR TOP SECRET. THE REST OF THE SECDEF. STRING ***/\n  /*** MAY CONTAIN commands to be issued by the       ***/\n  /*** system sight unseen.                           ***/\n  /******************************************************/\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \" T52ADD: $$ substitution string found in secdef\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \" T52ADD: $DEPT$ substitution string found in secdef\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$ENUM$\") /= 0 then do\n    say \" T52ADD: $ENUM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$ENUM$' q2\n    secdef.t = q1||Enum||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$MEM$\") /= 0 then do\n    say \" T52ADD: $MEM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$MEM$' q2\n    secdef.t = q1||member||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$OPID$\") /= 0 then do\n    say \" T52ADD: $OPID$ substitution string found in secdef\"\n    parse var secdef.t q1 '$OPID$' q2\n    opid = substr(acid,5,3)\n    secdef.t = q1||opid||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  LINE.T =  strip(secdef.t)\n  say t line.t\nEND\nSCRDISP: NOP\nCALL FILLSCR\nMSG=\"CHANGE DEFAULT COMMAND STREAM IF NEEDED AND HIT ENTER.\"\nIF GOTDEF = \"NO\" THEN\n  MSG=\"NO DEFAULT AUTHORITY STREAM FOUND. ENTER COMMANDS.\"\nPNLDISP: NOP\n\"ISPEXEC DISPLAY PANEL(\"DPNL\")\"\nRCODE = RC\nSAY \"T52ADD: PANEL RCODE IS \"RCODE\nIF MEM /= MEMBER THEN SECDEF. = \" \"\nIF MEM /= MEMBER THEN SIGNAL NORMAL\nNAME = SUBSTR(NAME                  ,1,20)\nCALL FILLDOT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ABORT\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\n/******************************************************************/\n/******************************************************************/\nCOMMIT: NOP\n/*\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"              \"\nLINE.1 = DEFINE\n*/\nIF PW \u00ac= \" \" THEN PWORD = PW||\",60,EXP\"\nELSE PW = \"PASSWORD\"\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T52ADD: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1= \"TSS CREATE(\"ACID\") password(\"pword\")  +\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  ADDRESS MVS \"EXECIO \"OUTCT\" DISKW BJCL ( FINIS STEM LINE.)\"\n  /**********************************************************/\n  /*ADDRESS MVS,                                               */\n  /* \"EXECIO \"batchtso.0\" DISKW BJCL ( FINIS STEM batchtso.)\"  */\n\n  SAY \"T52ADD: WRITING DATA TO BJCL DDNAME\"\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM AUDU.)\"\n  CODE = RC\n  IF CODE = 0 THEN SECRC =\"BATCH FILE UPDATED WITH ADD COMMANDS.\"\n  SIGNAL OFF ERROR\n  SIGNAL BYE1\nEND\nTSSCMD = \"YES\"\nADDRESS TSO\nSAY \"T52ADD: ISSUING THE TSS ADD COMMAND FOR THE ID\"\nif index(line.1,\"PASSWORD\") = 0 then do\n  line.1 = line.1 \"PASSWORD(\"PW\",60,EXP)\"\n  SAY \"T52ADD: Inserting default password into create stream\"\nend\nSAY \"T52ADD: TSS CRE(\"ACID\")\" LINE.1\n\"TSS CREATE(\"ACID\")\"  LINE.1\nCODE = RC\nSAY \"T52ADD: THE TSS ADD COMMAND FINISHED WITH A RCODE OF \" CODE\nSIGNAL OFF ERROR\nDO T = 2 TO OUTCT\n   say \"T52ADD: issuing command:\" line.t\n   IF LINE.T < > \" \" THEN\n   ADDRESS TSO \" \"LINE.T\nEND\n/* ADDRESS TSO \"%TSSAUDU \" ACID    */\nSPACES= \"                                                          \"\nSYSDATE = DATE(U)\nBYE:  NOP\nSIGNAL OFF ERROR\nIF  MODE= \"SKIPIT\" THEN DO\n  SAY \"T52ADD: VERSION 5.2 TSO DEFAULTS BEING SET\"\n  BOOK1 = WORD(BOOK,1)\n  rcode = 0\n  do cmdnum = 1 to audu.0\n    say \"T52ADD: issuing cmd : \"onlintso.cmdnum\n    address tso onlintso.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T52ADD: rcode from cmd is \" holdrc\n  end\n  do cmdnum = 1 to audu.0\n    say \"T52ADD: issuing cmd : \"audu.cmdnum\n    address tso audu.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T52ADD: rcode from cmd is \" holdrc\n  end\n  ADDRESS ISPEXEC\n  IF RCODE > 0 THEN DO\n    \"VGET SECRC PROFILE\"\n    msg2 = \"defaults tso setup has failed, check book authorities\"\n    \"VPUT MSG2 PROFILE\"\n    SIGNAL BYE1\n  END\n  SAY \"T52ADD: VERSION 5.0 TSO DEFAULTS HAVE BEEN SET\"\nEND\nJUSTUADS: NOP\nCODE = RC\nSIGNAL ON ERROR NAME BADALIAS\n\nif code = 0 then secrc =\"TSA202I: ACID added. no errors encountered.\"\nBYE1:  NOP\nSIGNAL OFF ERROR\nADDRESS ISPEXEC\n\"VPUT SECRC PROFILE\"\n DATAAREA = ACID\n\"VPUT DATAAREA PROFILE\"\nEXIT 0\nERRMSG: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA201E: Errors encountered. check acid status \"\n  SIGNAL BYE1\nBADALIAS: NOP\n  IF CODE = 0 THEN\n    secrc= \"alias addition failed check acid status \"\n  else secrc = secrc \"and alias addition failed\"\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  SIGNAL BYE1\nABORT: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA200E: Function aborted. acid not added. SIGL:\" sigl\n  SIGNAL BYE1\n/****************************************************************/\n/*  ERROR ROUTINE MESSAGE DISPLAYS.........DIR                  */\n/****************************************************************/\nFILLDOT: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE.1 = LINE1\n  LINE.2 = LINE2\n  LINE.3 = LINE3\n  LINE.4 = LINE4\n  LINE.5 = LINE5\n  LINE.6 = LINE6\n  LINE.7 = LINE7\n  LINE.8 = LINE8\n  LINE.9 = LINE9\n  LINE.10= LINE10\n  LINE.11= LINE11\n  LINE.12= LINE12\n  LINE.13= LINE13\n  LINE.14= LINE14\n  LINE.15= LINE15\nRETURN\nFILLSCR: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE1 = LINE.1\n  LINE2 = LINE.2\n  LINE3 = LINE.3\n  LINE4 = LINE.4\n  LINE5 = LINE.5\n  LINE6 = LINE.6\n  LINE7 = LINE.7\n  LINE8 = LINE.8\n  LINE9 = LINE.9\n  LINE10= LINE.10\n  LINE11= LINE.11\n  LINE12= LINE.12\n  LINE13= LINE.13\n  LINE14= LINE.14\n  LINE15= LINE.15\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53ADDO": {"ttr": 9217, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x03\\x05\\x0f\\x01\\x03\\x05\\x0f\\x14B\\x01j\\x01j\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-02-19T00:00:00", "modifydate": "2003-02-19T14:42:59", "lines": 362, "newlines": 362, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T52ADD                            **/\n/** LAST MODIFIED    :  2 feb 2000                       **/\n/**********************************************************/\n/** added variable for default department vget           **/\n/**********************************************************/\n/** CHANGED ACID VARIABLE MANIPULATION SO THAT THE ACID  **/\n/** VARIABLE REMAINS A LITTLE MORE STABLE.               **/\n/**                                .....DIR 19 AUGUST 96 **/\n/**********************************************************/\n/**********************************************************/\n/** ADDED LOGIC TO DETERMINE IF ID HAS DSNS CATLGD IN    **/\n/** MASTER CAT YET HAS NO ALIAS        DIR  11 MAY 95    **/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nSAY \"T52ADD: CONTROL RECEIVED PARMS = \" ACID MODE\nADDRESS ISPEXEC\n\"VGET AUD       PROFILE\"\n\"VGET DEF       PROFILE\"\n\"VGET DS1       PROFILE\"\n\"VGET DS2       PROFILE\"\n\"VGET DS3       PROFILE\"\n\"VGET DS4       PROFILE\"\n\"VGET DS5       PROFILE\"\n\"VGET DS6       PROFILE\"\n\"VGET MSG2      PROFILE\"\n\"VGET PROD      PROFILE\"\n\"VGET TSOSIZE   PROFILE\"\n\"VGET TSOUNIT   PROFILE\"\n\"VGET TSOPROC   PROFILE\"\n\"VGET TVER      PROFILE\"\nSIGNAL OFF ERROR\n/**********************************************************/\n/** below I am checking that the id doesnot have dsns    **/\n/** cataloged to the master catalog. if it does the      **/\n/** user wont be able to catalog his own datasets. this  **/\n/** will cause allocate errors that are hard to track.   **/\n/** i may make this a seperate callable exec but for     **/\n/** now it is included here    dave 11 may 95            **/\n/**********************************************************/\nDATEHOLD = DATE('U')\nMONTHNUM = SUBSTR(DATEHOLD,1,2)\nADDRESS TSO \"%t52GDAT \"ACID \"NAME\"\nOLDID = RC\noutct = 40\nBOOK = \"NIL\"\nBOOK1 = \"NIL\"\nSAY \"TSA101D: T52ADD  EXISTANCE CHECK RC IS \" OLDID\nIF OLDID = 0 THEN DO\n  msg2 = \"This id exists currently, readdition will fail upon\",\n  \"execution\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\n/**************************************/\n/* get the default department         */\n/**************************************/\nADDRESS ISPEXEC \"VGET DEFDEPT PROFILE\"\nADDRESS ISPEXEC \"VGET TSOALIAS PROFILE\"\nIF TSOALIAS = \"YES\" THEN DO\n  ADDRESS TSO \"LISTC ENT('\"ACID\"')\"\n  SAY \"TSA101D: T52ADD  ALIAS CHECK IS \" RC\n  ALIAS_CODE = RC\n  ADDRESS TSO \"LISTC LEVEL('\"ACID\"')\"\n  SAY \"TSA101D: T52ADD  LEVEL CHECK IS \" RC\n  LEVEL_CODE = RC\n  IF (ALIAS_CODE \u00ac= 0) & (LEVEL_CODE =0)  THEN DO\n    msg2 = \"The id has no alias, yet has dsns cataloged, expect\",\n    \"severe allocation errors\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSIGNAL ON ERROR NAME ABORT\n/**********************************************************/\n/** END OF DSN ALIAS / LEVEL CHECKING                    **/\n/**********************************************************/\nLINE.  = \" \"\nALEN   = LENGTH(ACID)\nBILLA  = \"N\"\nCODE   = 0\nCURSOR = \"NAME\"\nDEFINE = \"NAME('\"NAME\"') DEPT(D0000000) TYPE(USER)\"\nFIRST2 = SUBSTR(ACID,1,2)\nGOTDEF = \"NO\"\nLOGON  = TSOPROC\nNDEPT  = FIRST2||\"DEPT\"\nif defdept /= \"NONE\" then ndept = defdept\nPROF   = \" \"\nPWORD  = \"PASSWORD,60,EXP\"\nSECDEF. = \" \"\nsecrc  = \"T52ADD did not complete normally. please check the id.\"\nS2     = ALEN - 1\nTYPE   =  \"USER\"\nWARNED = \"NO\"\n\"VPUT SECRC PROFILE\"\nPW = \"PASSWORD\"\nDPNL   = \"SPIADD\"\nBASIC_ACID = \" \"\nAUDU.0 =   1\nAUDU.1 =   \"%ADDLOCAL\" ACID NDEPT\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"FAC(TSO,BATCH)\"\n/****************************************************/\n/** the tso authority stream is below              **/\n/****************************************************/\n/*                                                                  */\n/*batchtso.0 = 3                                                    */\n/*batchtso.1 = \" \"                                                  */\n/*batchtso.2 = \"ISPSTART CMD(%\"TVER\"TSO DEFAULTS +\"                 */\n/*batchtso.3 = \" \"ACID LOGON BOOK1 TSOUNIT TSOSIZE\") NEWAPPL(TSS)\"  */\n/*onlintso.0 = 1                                                    */\n/*onlintso.1 =\"%\"TVER\"TSO DEFAULTS\" ACID LOGON BOOK1 TSOUNIT TSOSIZE*/\n/*                                                                  */\n/****************************************************/\n/** beginning of the panel loop                    **/\n/** beginning of the panel loop                    **/\n/****************************************************/\nAGAIN: NOP\nCALL FILLSCR\n\"DISPLAY PANEL(\"DPNL\")  CURSOR(\"CURSOR\")\"\nRCODE = RC\nNAME = TRANSLATE(NAME,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSAY \"TSA101D: T52ADD  PANEL RCODE IS \"RCODE\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ERRMSG\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\nGETNAME: NOP\nCNT1 = 0\nNORMAL: NOP\nMEMBER = mem\nIF MEM = \"\" THEN MEMBER = NDEPT\nmem = member\nSAY \"TSA101D: CHECKING FOR DEFAULT DEPT AUTHORITIES\" DEF\"(\"MEMBER\")\"\nIF SYSDSN(\"'\"DEF\"(\"MEMBER\")'\") = \"OK\" THEN DO\n  SAY \"TSA101D: T52ADD  DEFAULT AUTHORITY GROUP FOUND FOR IN \" DEF BIN\n  ADDRESS TSO \"ALLOC DDN(SECDEF) DSN('\"DEF\"(\"member\")') SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR SECDEF ( FINIS STEM SECDEF.)\"\n  ADDRESS TSO \"FREE DDN(SECDEF)\"\n  /******************************************************/\n  /***                                                ***/\n  /*** NOTE: THE FIRST LINE OF THE DSN MUST HAVE A    ***/\n  /*** CREATE PARM IN IT! IF THERE IS NO MEMBER I     ***/\n  /*** ASSIGN A VALUE TO SECDEF.1                     ***/\n  /***                                                ***/\n  /******************************************************/\n  SECDEF.1 = \"NAME('\"NAME\"')\" SECDEF.1\n  GOTDEF = \"YES\"\nEND\nELSE SECDEF.1 = DEFINE /* IF NO MEMBER WE JUST CREATE A 1 LINER */\nsay \"t52add: secdef.1 is\" secdef.1\nDO T = 1 TO 40\n  /******************************************************/\n  /***                                                ***/\n  /*** ONCE HERE THERE HAS TO BE A SECDEF.1 VALUE AND ***/\n  /*** IT HAS IS    COMPRISED OF VALID 'CREATE' PARMS ***/\n  /*** FOR TOP SECRET. THE REST OF THE SECDEF. STRING ***/\n  /*** MAY CONTAIN commands to be issued by the       ***/\n  /*** system sight unseen.                           ***/\n  /******************************************************/\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \" T52ADD: $$ substitution string found in secdef\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \" T52ADD: $DEPT$ substitution string found in secdef\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$MEM$\") /= 0 then do\n    say \" T52ADD: $MEM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$MEM$' q2\n    secdef.t = q1||member||q2\n    say \" T52ADD: resolved secdef is \"secdef.t\n  end\n  LINE.T =  secdef.t\n  say t line.t\nEND\nSCRDISP: NOP\nCALL FILLSCR\nMSG=\"CHANGE DEFAULT COMMAND STREAM IF NEEDED AND HIT ENTER.\"\nIF GOTDEF = \"NO\" THEN\n  MSG=\"NO DEFAULT AUTHORITY STREAM FOUND. ENTER COMMANDS.\"\nPNLDISP: NOP\n\"ISPEXEC DISPLAY PANEL(\"DPNL\")\"\nRCODE = RC\nSAY \"T52ADD: PANEL RCODE IS \"RCODE\nIF MEM /= MEMBER THEN SECDEF. = \" \"\nIF MEM /= MEMBER THEN SIGNAL NORMAL\nNAME = SUBSTR(NAME                  ,1,20)\nCALL FILLDOT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ABORT\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\n/******************************************************************/\n/******************************************************************/\nCOMMIT: NOP\n/*\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"              \"\nLINE.1 = DEFINE\n*/\nIF PW \u00ac= \" \" THEN PWORD = PW||\",60\"\nELSE PW = \"PASSWORD\"\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T52ADD: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1= \"TSS CREATE(\"ACID\")   +\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  ADDRESS MVS \"EXECIO \"OUTCT\" DISKW BJCL ( FINIS STEM LINE.)\"\n  /**********************************************************/\n  /*ADDRESS MVS,                                               */\n  /* \"EXECIO \"batchtso.0\" DISKW BJCL ( FINIS STEM batchtso.)\"  */\n\n  SAY \"T52ADD: WRITING DATA TO BJCL DDNAME\"\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM AUDU.)\"\n  CODE = RC\n  IF CODE = 0 THEN SECRC =\"BATCH FILE UPDATED WITH ADD COMMANDS.\"\n  SIGNAL OFF ERROR\n  IF RC < > 0 THEN DO\n    MSG2 = \"THE BILLING FILE UPDATE DID NOT COMPLETE NORMALLY.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  SIGNAL BYE1\nEND\nTSSCMD = \"YES\"\nADDRESS TSO\nSAY \"T52ADD: ISSUING THE TSS ADD COMMAND FOR THE ID\"\nSAY \"T52ADD: TSS CREATE(\"ACID\") PASSWORD(\"PWORD\") \" LINE.1\nSAY \"T52ADD: \" line.1\n\"TSS CREATE(\"ACID\") PASSWORD(\"PWORD\") \" LINE.1\nCODE = RC\nSAY \"T52ADD: THE TSS ADD COMMAND FINISHED WITH A RCODE OF \" CODE\nSIGNAL OFF ERROR\nDO T = 2 TO OUTCT\n   say \"T52ADD: issuing command:\" line.t\n   IF LINE.T < > \" \" THEN\n   ADDRESS TSO \" \"LINE.T\nEND\n/* ADDRESS TSO \"%TSSAUDU \" ACID    */\nSPACES= \"                                                          \"\nSYSDATE = DATE(U)\nBYE:  NOP\nSIGNAL OFF ERROR\nIF  MODE= \"SKIPIT\" THEN DO\n  SAY \"T52ADD: VERSION 5.0 TSO DEFAULTS BEING SET\"\n  BOOK1 = WORD(BOOK,1)\n  rcode = 0\n  do cmdnum = 1 to audu.0\n    say \"T52ADD: issuing cmd : \"onlintso.cmdnum\n    address tso onlintso.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T52ADD: rcode from cmd is \" holdrc\n  end\n  do cmdnum = 1 to audu.0\n    say \"T52ADD: issuing cmd : \"audu.cmdnum\n    address tso audu.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T52ADD: rcode from cmd is \" holdrc\n  end\n  ADDRESS ISPEXEC\n  IF RCODE > 0 THEN DO\n    \"VGET SECRC PROFILE\"\n    MSG2 = \"DEFAULTS TSO SETUP HAS FAILED, CHECK BOOK AUTHORITIES\"\n    \"VPUT MSG2 PROFILE\"\n    SIGNAL BYE1\n  END\n  SAY \"T52ADD: VERSION 5.0 TSO DEFAULTS HAVE BEEN SET\"\nEND\nJUSTUADS: NOP\nCODE = RC\nSIGNAL ON ERROR NAME BADALIAS\n\nif code = 0 then secrc =\"TSA202I: ACID added. no errors encountered.\"\nBYE1:  NOP\nSIGNAL OFF ERROR\nADDRESS ISPEXEC\n\"VPUT SECRC PROFILE\"\n DATAAREA = ACID\n\"VPUT DATAAREA PROFILE\"\nEXIT 0\nERRMSG: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA201E: Errors encountered. check acid status \"\n  SIGNAL BYE1\nBADALIAS: NOP\n  IF CODE = 0 THEN\n    SECRC= \"ALIAS ADDITION FAILED CHECK ACID STATUS \"\n  ELSE SECRC = SECRC \"AND ALIAS ADDITION FAILED\"\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  SIGNAL BYE1\nABORT: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA200E: Function aborted. acid not added.\"\n  SIGNAL BYE1\n/****************************************************************/\n/*  ERROR ROUTINE MESSAGE DISPLAYS.........DIR                  */\n/****************************************************************/\nFILLDOT: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE.1 = LINE1\n  LINE.2 = LINE2\n  LINE.3 = LINE3\n  LINE.4 = LINE4\n  LINE.5 = LINE5\n  LINE.6 = LINE6\n  LINE.7 = LINE7\n  LINE.8 = LINE8\n  LINE.9 = LINE9\n  LINE.10= LINE10\n  LINE.11= LINE11\n  LINE.12= LINE12\n  LINE.13= LINE13\n  LINE.14= LINE14\n  LINE.15= LINE15\nRETURN\nFILLSCR: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE1 = LINE.1\n  LINE2 = LINE.2\n  LINE3 = LINE.3\n  LINE4 = LINE.4\n  LINE5 = LINE.5\n  LINE6 = LINE.6\n  LINE7 = LINE.7\n  LINE8 = LINE.8\n  LINE9 = LINE.9\n  LINE10= LINE.10\n  LINE11= LINE.11\n  LINE12= LINE.12\n  LINE13= LINE.13\n  LINE14= LINE.14\n  LINE15= LINE.15\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53BCON": {"ttr": 9219, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00 \\x00\\x955/\\x01\\x00\\x07_\\x105\\x00\\x87\\x00\\x87\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:35:20", "lines": 135, "newlines": 135, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50BCON                           **/\n/** LAST MODIFIED    : 24 SEP 96                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/**********************************************************/\n/** BASE SUPPORT FOR ZCA TYPE ADMINS                     **/\n/**********************************************************/\n/** PASSED ARGS        VALID VALUES                      **/\n/** THESE ARGS ARE ONLY PASSSED ON A LSCA CONVERT        **/\n/** NEWACID : THE NAME THAT THE ACID IS TO BE CHANGED TO **/\n/** NEWTYPE : THE TYPE OF ACID THAT IS TO BE CREATED     **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DS1     : THE DATASET WHEWRE THE INPUT DATA MUST BE  **/\n/** DS2     : THE OUTPUT DATASET                         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES.(NOTE VGET VARIABLES)       **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE                  */\n/**                                                      **/\n/**********************************************************/\nARG NEWACID NEWTYPE\nSIGNAL ON ERROR NAME SEEYA\nSIGNAL ON SYNTAX NAME SYNERR\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nSAY \"T50BCON: TOP SECRET REXX BASIC ACID CONVERSION CLIST ENTERED\"\nNEST = SYSVAR(SYSNEST)\nIF NEST = \"NO\" THEN DO\n  \"ALLOC DDN(OUTFILE) DSN(\" DS2\") MOD REUS\"\n  \"ALLOC DDN(INPUT) DSN(\" DS1\") SHR REUS\"\nEND\n\"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\nOUTFILE. = \" \"\nATTR = \"ATTR\"\nOPID = \" \"\nPWD = \"12345\"\nNEXTREC: DO RECNUM = 1 TO INLINE.0\n  PREVLINE=  INLINE\n  INLINE= SUBSTR(INLINE.RECNUM,1,59)\n  IF INLINE = \"      \" THEN ITERATE\n  PARSE VAR INLINE PAR.1 PAR.2 PAR.3 PAR.4 PAR.5 PAR.6 PAR.7 PAR.8\n  IF (PAR.1 = \"ACCESSORID\") & ( RECNUM > 3 ) THEN DO\n    \"EXECIO 5 DISKW OUTFILE( FINIS STEM OUTFILE.)\"\n    OUTFILE.  = \"         \"\n    ATTR = \"ATTR\"\n    TYPE = \"TYPE\"\n    DEPT = \"DEPT\"\n    NAME = \"NAME\"\n    OPID = \" \"\n    INSTDATA = \"INSTDATA\"\n    ACID = \"ACID\"\n  END\n  IF PAR.1 = \"INSTDATA\" THEN DO\n     NEXT = RECNUM + 1\n/*   INSTDATA =\"'\"||SUBSTR(INLINE.NEXT,1,55)||\"'\"    */\n     INSTDATA =\"'\"||SUBSTR(INLINE,14,65)||\"'\"\n     ITERATE\n  END\n  IF PAR.1 = \"OPIDENT\" THEN OPID = \"OPIDENT(\"PAR.3\")\"\n  IF PAR.3 = \"OPPRTY\" THEN OPID = \" \"\n  IF PAR.1 = \"PASSWORD\" THEN PWD = PAR.3\n  IF PWD   = \"*NOPW*\" THEN PWD = \"NOPW\"\n  IF PAR.3 = \"*NONE*\" THEN ITERATE\n  IF PAR.1 = \"ACCESSORID\" THEN ACID = PAR.3\n  IF NEWACID \u00ac= \" \" THEN ACID = NEWACID\n  IF ACID = \"*STC*\" THEN EXIT 00\n  IF ACID = \"*RDT*\" THEN EXIT 00\n  IF ACID = \"*ALL*\" THEN EXIT 00\n  IF PAR.1 = \"DEPT\" THEN DEPT = PAR.4\n  IF PAR.1 = \"DIV\" THEN DIV = PAR.4\n  IF PAR.1 = \"TYPE\" THEN TYPE = PAR.3\n  IF NEWTYPE \u00ac= \" \" THEN TYPE = NEWTYPE\n  IF PAR.4 = \"NAME\" THEN NAME = STRIP(PAR.6  PAR.7  PAR.8 )\n  IF PAR.1 = \"ATTRIBUTES\" THEN ATTR = PAR.3\n  IF (TYPE = \"DEPT\") & (PAR.4 = \"C/A\") THEN TYPE = \"DCA\"\n  IF (PAR.1 = \"ZONE\") & (PAR.2 = \"ACID\") THEN TZONE = PAR.4\n  IF (TYPE = \"ZONE\") & (PAR.4 = \"C/A\") THEN TYPE= \"ZCA\"\n  IF TYPE = \"LIMITED\" THEN TYPE = \"LSCA\"\n  IF TYPE = \"MASTER\" THEN EXIT\n  PRINTIT: IF TYPE = \"CENTRAL\" THEN TYPE = \"SCA\"\n  IF TYPE = \"DIV\" THEN TYPE = \"VCA\"\n  OUTFILE.  = \"            \"\n  OUTFILE.1 = \" TSS CRE(\"ACID\") NAME('\"NAME\"') TYPE(\"TYPE\") +\"\n  OUTFILE.2 =\"  DEPT(\"DEPT\")  +\"\n  IF TYPE = \"ZONE\" THEN OUTFILE.2 = \" \"\n  IF TYPE = \"VCA\" THEN\n    OUTFILE.2 =\"  DIV(\"DIV\") +\"\n  IF TYPE = \"ZCA\" THEN\n    OUTFILE.2 =\"  ZONE(\"TZONE\") +\"\n  IF TYPE = \"DEPT\" THEN\n    OUTFILE.2 =\"  DIV(\"DIV\") +\"\n  IF (TYPE=\"SCA\") | (TYPE= \"LSCA\") THEN DO\n    OUTFILE.2 =\"  PASSWORD(\"PWD\",30,EXP) +\"\n    IF OPID \u00ac= \" \" THEN\n      OUTFILE.2 = \"  PASSWORD(\"PWD\",30,EXP) \"OPID\" +\"\n    OUTFILE.3 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.3 =\"  INSTDATA(\"INSTDATA\") \"\n    OUTFILE.4 =\"                       \"\n  END\n  IF TYPE=\"PROFILE\" THEN DO\n    OUTFILE.3 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.3 = \"  INSTDATA(\"INSTDATA\") \"\n    OUTFILE.4 = \"                       \"\n    OUTFILE.5 = \"                       \"\n  END\n  IF (TYPE=\"USER\") | (TYPE=\"DCA\") | (TYPE=\"VCA\") THEN DO\n    OUTFILE.3 = \" PASSWORD(\"PWD\",30,EXP) \"OPID\" +\"\n    OUTFILE.4 = \"                       \"\n    IF INSTDATA \u00ac= \"INSTDATA\" THEN\n    OUTFILE.4 =\"  INSTDATA(\"INSTDATA\") \"\n  END\n  IF ATTR <> \"ATTR\" THEN\n    OUTFILE.5 = \" TSS ADD(\"ACID\") \"ATTR\" \"\n  OUTFILE.6 = \"         \"\nEND\n\"EXECIO 5 DISKW OUTFILE( FINIS STEM OUTFILE.)\"\nEXIT 0\nSEEYA: NOP\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON. ERROR IN LINE \" SIGL\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSYNERR: NOP\nSECRC = \"FUNCTION FAILED IN EXEC T50BCON. SYNTAX ERROR LINE \" SIGL\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53BKUP": {"ttr": 9221, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x03\\x006\\x00\\x98'_\\x01\\x03&\\x1f\\x08V\\x00T\\x00T\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@\"", "ispf": {"version": "05.03", "flags": 0, "createdate": "1998-10-02T00:00:00", "modifydate": "2003-09-18T08:56:36", "lines": 84, "newlines": 84, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ADDED STRIP PROCESSING FOR DSBACK DSN NAME           **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50BKUP                           **/\n/** LAST MODIFIED    : 2  OCT 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :     THE ID YOU WANT BACKED UP              **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DSBACK  : THE DSN TO PUT THE BACKUP IN               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T52GDAT              **/\n/**                                                      **/\n/**********************************************************/\nARG ACID DSBACK\nHEX00 = '00'X\nSYSENV = SYSVAR(SYSENV)\nIF DSBACK = \"\" THEN\n  ADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nSIGNAL ON ERROR NAME SEEYA\nDSBACK = TRANSLATE(DSBACK,\"\",\"'\") /* REMOVE TICS WITH SPACES */\nDSBACK = STRIP(DSBACK)\nSTATUS  = SYSDSN(\"'\"DSBACK\"'\")\nDSBACK = \"'\"DSBACK\"(\"ACID\")'\"\nSAY \"TSA101D: T52BKUP DSBACK IS \"DSBACK\nADDRESS TSO \"%T52GDAT \" ACID \"TYPE\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nTYPE = SECRC\nSAY \"TSA101D: T52BKUP TYPE IS \" TYPE\nSS = OUTTRAP('OUTLINE.')\nDATA=\"ALL,PASSWORD,EXPIRE\"\nSTATUSM = SYSDSN(DSBACK)\nIF (STATUS = \"OK\") & (STATUSM = \"MEMBER NOT FOUND\")  THEN DO\n  SAY \"TSA101D: T52BKUP BACKUP MEMBER WILL BE CREATED.  \"\nEND\nIF (STATUS = \"OK\") & (STATUSM = \"OK\")  THEN DO\n  SAY \"TSA101D: T52BKUP BACKUP MEMBER WILL BE OVERLAYED BY THIS BACKUP.\"\nEND\nIF (STATUS /= \"OK\")  THEN DO\n  SAY \"TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS = \" STATUS\n  SECRC = \"TSA211E: BACKUP DATASET IS UNAVAILABLE STATUS = \" STATUS\n  EXIT 04\nEND\nSAY \"TSA101D: T52BKUP ALLOCATING DSN\" DSBACK\n\"ALLOC DDN(OUTFILE) DSN(\"DSBACK\") SHR REUS\"\nSAY \"TSA101D: T52BKUP  CALLING TSS FOR LIST OF ID \" ACID\nSELECT\n  WHEN TYPE = \"USER\"    THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"MASTER\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"DEPTCA\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"ZONECA\"  THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"DIVCA\"   THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"CENTRAL\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"LIMITED\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"PROFILE\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  WHEN TYPE = \"GROUP\" THEN \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n  OTHERWISE   \"TSS LIST(ACIDS) \"TYPE\"(\"ACID\")  DATA(\"DATA\")\"\nEND\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n secrc = \"function completed. backup taken to  \" dsback\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53CADD": {"ttr": 9223, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x03\\x01\\x03\\x05\\x0f\\x01\\x03\\x05\\x1f\\tT\\x000\\x000\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2003-02-19T00:00:00", "modifydate": "2003-02-20T09:54:03", "lines": 48, "newlines": 48, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T52CADD                           **/\n/** LAST MODIFIED    :  2 feb 2000                       **/\n/**********************************************************/\n/** This exec take a name and ID stem and gets an OPID   **/\n/** and determines the full ID.                          **/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Stem    : The acid stem , usually 4 characters       **/\n/** MODE    : BATCH or ONLINE passed to t52add           **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG stem fname Lname mode\nSAY \"T52CADD: Control received = \" stem fname lname mode\nfirst = substr(fname,1,1)\nsecond = substr(lname,1,1)\nif length(stem) > 4 then do\n  secrc  =  \"Stem of ACID cannot exceed 4 characters\"\n  ADDRESS ISPEXEC\n  \"VPUT secrc  PROFILE\"\n  exit 4\nend\nsay first second\naddress tso \"%getopid\" first second \"LIVE\"\nname = fname lname\nADDRESS ISPEXEC\n\"VGET dataarea  PROFILE\"\nopid = dataarea\n\"Vput name  PROFILE\"\naddress tso \"%t52add\" stem||opid  mode\naddress tso \"%tssaudu\" stem||opid\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53CMDO": {"ttr": 9225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00&\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00A\\x00A\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:26", "lines": 65, "newlines": 65, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ISSUE A COMMAND TRAP THE OUTPUT AND ROUTE IT SOMEWERE**/\n/** I ALSO CHANGE ALL HEX 00 TO BLANKS BECAUSE TSS       **/\n/** SOMETIMES RETURNS SOME '00'X VALUES IN ITS UADS AREA **/\n/**********************************************************/\n/** EXEC NAME        : T50CMDO                           **/\n/** LAST MODIFIED    : 16 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSN TO GET THE OUTPUT                  **/\n/** ARG     : THE ACTUAL COMMAND TO BE ISSUED            **/\n/** DISP    : THE DISP TO ALLOCATE THE DATASET WITH      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE HOWEVER THIS    **/\n/**      EXEC COULD BE PASSED ANOTHER EXEC NAME AND      **/\n/**      INVOKE THAT.                                    **/\n/**********************************************************/\nARG DSN cmd\nHEX00 = '00'X\nsecrc = \"TSA509E: Command not processed. check commands validity.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nif cmd = \"\" then\n  ADDRESS ISPEXEC \"VGET ARG PROFILE\"\nelse arg = cmd\nADDRESS ISPEXEC \"VGET DISP PROFILE\"\nQ = OUTTRAP(OUT.)\nT = 1\n\" \"ARG\nRCODE = RC\nDO Z = 1 TO OUT.0\n  IF LENGTH(OUT.Z) > 80 THEN DO\n    OUTLINE.T = SUBSTR(OUT.Z,1,80)\n    T = T + 1\n    OUTLINE.T = SUBSTR(OUT.Z,81)\n    T = T + 1\n    ITERATE Z\n  END\n  OUT.Z=TRANSLATE(OUT.Z,\" \",HEX00)\n  OUTLINE.T = OUT.Z\n  T = T + 1\nEND\nIF DSN = \"SCREEN\" THEN DO\n  T = T - 1\n  DO Q = 1 TO T\n     IF LENGTH(OUTLINE.Q) > 78 THEN OUTLINE.Q = SUBSTR(OUTLINE.Q,1,78)\n     IF OUTLINE.Q <> \" \" THEN SAY OUTLINE.Q\n  END\n  SIGNAL LETSGO\nEND\n\"ALLOC DDN(OUTPUT) DSN(\"DSN\") \"DISP\" REUS\"\n\"EXECIO * DISKW OUTPUT (STEM OUTLINE. FINIS)\"\n\"FREE DDN(OUTPUT)\"\nLETSGO: NOP\nIF RCODE = 0 THEN\n  secrc = \"TSA514I: Command issued output resides in:\" dsn\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53CON": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00G\\x00\\x98#o\\x01\\x00\\x07_\\x10S\\x049\\x049\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-08-24T00:00:00", "modifydate": "2000-03-15T10:53:47", "lines": 1081, "newlines": 1081, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added code to use FDT segment names                  **/\n/**********************************************************/\n/** added code to ignore dept/div/profile passwords      **/\n/**********************************************************/\n/** added more parm based processing                     **/\n/**********************************************************/\n/** added  parm based parsing                            **/\n/**********************************************************/\n/** bypassing iterate error.                             **/\n/**********************************************************/\n/** fixed reformatter error...                           **/\n/**********************************************************/\n/** added omvs support                                   **/\n/**********************************************************/\n/** REMOVED DUPLICATE OUTPUT LINES  SO AS TO STREAMLINE  **/\n/** THE OUTPUT ID...                                     **/\n/**********************************************************/\n/** ADDED SUPPORT FOR LSCA AND SCA JOBCARD CHANGE        **/\n/** SPECIFYING USER=MSCA ON THE JOBCARD.                 **/\n/**********************************************************/\n/** FIXED ADMIN ACID( SUPPORT..                          **/\n/**********************************************************/\n/** REDID THE RDT AREA FOR THE NEW ADDITION SYNTAX       **/\n/**********************************************************/\n/** ADDED SUPPORT FOR TSOOPTION PARM                     **/\n/**********************************************************/\n/** ADDED SUPPORT FOR ZCA DCA VCA CONVERSION             **/\n/**********************************************************/\n/** ADDED MSGS FOR MFAC CONVERSION                       **/\n/**********************************************************/\n/** SUPPORTS RDT AND LINEFORMATTING                      **/\n/**********************************************************/\n/** SUPPORTS TIMES/DAYS/LOCKTIMES                        **/\n/**********************************************************/\n/** THE NEWER STREAMLINED CONVERT FUNCTION.              **/\n/** THE LOGIC SHOULD BE ALOT MORE READABLE ...           **/\n/**********************************************************/\n/** EXEC NAME        : T50CON                            **/\n/** LAST MODIFIED    : 10 aug 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** NEWACID :  THE NAME THE ACID IS TO BE RENAMED TO     **/\n/** NEWTYPE :  THE NEW TYPE OF ACID TO BE CREATED        **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** CONVOPT : THE INTERNAL OUT OPTION \"DATASET\u00a6INTERNAL\" **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS1     : THE INTERIM OUTPUT FILE                    **/\n/** DS2     : THE BATCH FILE                             **/\n/** newpass : THE password to plug into IDs when it cant **/\n/**           be determined                              **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD.    = THE VALID COMMANDS 4 THIS ENT    \"ADD REM\" **/\n/** TYPE.   = THE RESOURCE TYPE                \"DATASET\" **/\n/** ACID.   = THE TARGET ACID FOR EACH CMD     \" ??    \" **/\n/** RSNAME. = THE RESOURCE NAME                \"SYS1.  \" **/\n/** DAYS.   = THE VALID DAYS                   \"MON,TUE\" **/\n/** TIME.   = THE VALID TIMES                  \"08,18  \" **/\n/** ACCESS. = THE ACCESS LEVEL                 \"UPDATE \" **/\n/** ACTION. = THE ACTION TO TAKE               \"FAIL   \" **/\n/** UNTIL.  = THE EXPIRE   DATE OF RULE \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/**********************************************************/\n/** Multi word parm stuff:                               **/\n/**                                                      **/\n/** In ALL below examples t1 has been set to the first   **/\n/** word in the line and t2 has been set to the second.  **/\n/** ( note the 0 prefixed values are always literals )   **/\n/**                                                      **/\n/** MULTI.T1.T2.0PRECMD        The # of commands to be   **/\n/**                      issued prior to value checking  **/\n/**                      This must correspond to the     **/\n/**                      below commands.                 **/\n/** MULTI.T1.T2.0PRECMD.1      Command # 1               **/\n/** MULTI.T1.T2.0PRECMD.2      Command # 2               **/\n/** MULTI.T1.T2.0ITERATE       0 = suffix to prev line   **/\n/**                            1 = make a new line       **/\n/**                                                      **/\n/** SNAME                      The segment for this rule **/\n/**                      to be activated (used below)    **/\n/** MULTI.T1.T2.SNAME          The value \"YES\"           **/\n/** MULTI.T1.T2.0TYPE          The type of resource      **/\n/**                      (example - DSN )                **/\n/** MULTI.T1.T2.0CMD           The tss cmd ( ADD or PER) **/\n/** MULTI.T1.T2.0RSNAME        The TSS resource(example -**/\n/**                      the dataset name)               **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                                                      **/\n/** Single word rules stuff:                             **/\n/**                                                      **/\n/**                                                      **/\n/**  THOLD               The first word on the data line **/\n/**                 that will trigger this rule          **/\n/**                                                      **/\n/**  SNAME               The section name that must match**/\n/**                 the current section for this rule    **/\n/**                                                      **/\n/**  ITERATE.thold.sname  Will I add line(s) to output ? **/\n/**                                                      **/\n/**  ITERATE.thold        How many lines...              **/\n/**                                                      **/\n/**  TYPE.thold           The RDT data type or \"$$\" to   **/\n/**                 bypass command build logic, and build**/\n/**                 your own command                     **/\n/**  CMD.thold           The command add or per or rev.. **/\n/**  RSNAME.thold        The resource name to be used in **/\n/**                  the command or if you specified $$  **/\n/**                  in the type field above, the actual **/\n/**                  rexx interpret command to be issued **/\n/**                                                      **/\n/**                                                      **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS2  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NEWTYPE\nmaint = \"june 4 1999\"\nsay \"T50CON: in control with parms \" acid newacid newtype\nsay \"T50CON: Maint = \" maint\nif acid = \"BYPASS\" then do\n  say \"T50CON: bypass detected other parms ignored.\"\n  newacid = \"\"\n  newtype = \"\"\nend\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50CON. NO OTHER INFORMATION AVAILABLE\"\nIF SYSENV = \"FORE\" THEN DO\n  SECRC = \"FAILED WHILE GETTING VARIABLES FROM ISPPROF\"\n  SECRC = SECRC||\" TRY 'REINIT' OPTION\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET NEWPASS PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS2 PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n  ADDRESS ISPEXEC \"VGET CONVOPT PROFILE\"\nEND\nSECRC = \"FAILED DURING JOBCARD FUNCTION\"\n/*                          */\nCREATE.   =  \"\"\nUNTIL.    =  \"\"\nTYPE.     =  \"\"\nCMD.      =  \"\"\nACCESS.   =  \"\"\nRSNAME.   =  \"\"\nLIBRARY.  =  \"\"\nPRECMD.   =  \"\"\nDAYS.     =  \"\"\nTIME.     =  \"\"\nFACILITY. =  \"\"\nPRIVPGM.  =  \"\"\nACTION.   =  \"\"\nDEPT      =  \"\"\nZONE      =  \"\"\nDIV       =  \"\"\nACID.0    =  ACID\nIF NEWACID /= \"\" THEN ACID.1 = NEWACID\n/********************************/\nCOMMAND.  = \"ADD\"\nSEGMENT   =  \"ADMINISTRATIONAUTHORITIES\"\nCOMMAND.SEGMENT  = \"ADMIN\"\n/********************************/\n/********************************/\n/** LOCK TIME segment          **/\n/** an example of using the    **/\n/** postcmd processor for      **/\n/** value resolution.          **/\n/********************************/\nTLINE                    = \"LOCK TIME\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0PRECMD      = 2\nMULTI.T1.T2.0PRECMD.1    = \"FAC =','w.6\"\nMULTI.T1.T2.0PRECMD.2    = \"IF W.6 = 'ALL' THEN FAC = ''\"\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0POSTCMD     = 3\nMULTI.T1.T2.0POSTCMD.1   = \"TYPE.OUTNUM = '$$'\"\nMULTI.T1.T2.0POSTCMD.2   = \"CMD.OUTNUM = 'ADD'\"\nMULTI.T1.T2.0POSTCMD.3   = \"RSNAME.OUTNUM = 'LTI('W.3||FAC')'\"\n/********************************/\n/** LIST DATA segment          **/\n/********************************/\nTLINE                    = \"LIST DATA\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0TYPE        = \"$$\"\nMULTI.T1.T2.0CMD         = \"'ADMIN'\"\nMULTI.T1.T2.0RSNAME      = \"'DATA('W.3' 'W.4')'\"\n/********************************/\n/** XA DATASET segment         **/\n/********************************/\nTLINE                    = \"XA DATASET\"\nT1                       = WORD(TLINE,1)\nT2                       = WORD(TLINE,2)\nMULTI.T1.T2.0ITERATE     = 1\nSNAME                    = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nMULTI.T1.T2.SNAME        = \"YES\"\nMULTI.T1.T2.0TYPE        = \"DSN\"\nMULTI.T1.T2.0CMD         = \"PER\"\nMULTI.T1.T2.0RSNAME      = \"W.3\"\nMULTI.T1.T2.0UNTIL       = \"W.4\"\n/********************************/\n/** single word rules are below**/\n/********************************/\nTHOLD                = \"GROUP\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'GROUP('W.2 w.3 w.4 w.5')'\"\n/********************************/\n/********************************/\nTHOLD                = \"XA\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"W.2\"\nCMD.THOLD            = \"PER\"\nRSNAME.THOLD         = \"W.3\"\nUNTIL.THOLD          = \"W.4\"\n/********************************/\nTHOLD                = \"FACILITIES\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"'FACILITY'\"\nCMD.THOLD            = \"ADMIN\"\nRSNAME.THOLD         = \"W.2 W.3\"\n/********************************/\nTHOLD                = \"ACID\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"'ACID'\"\nCMD.THOLD            = \"ADMIN\"\nRSNAME.THOLD         = \"W.2\"\n/********************************/\nTHOLD                = \"ACCESS\"\nSNAME                = \"ADMINISTRATIONAUTHORITIES\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nSNAME                = \"AUTHORITY\"\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 0\nACCESS.THOLD         = \"'ACCESS('W.2')'\"\n/********************************/\nTHOLD                = \"BYPASSING\"\nSNAME                = \"BASE\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\n                     /*******************************/\n                     /* only one precmd             */\n                     /*******************************/\nPRECMD.THOLD         = 1\nPRECMD.THOLD.1       = 'W.2 = TRANSLATE(W.2,\" \",\",\")'\n                     /*******************************/\n                     /* get rid of commas in auths  */\n                     /*******************************/\nRSNAME.THOLD         = \"W.2\"\n/********************************/\nTHOLD                = \"SITRAN\"\nSNAME                = \"SEGMENTCICS\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'SIT('W.2','W.4')'\"\n/********************************/\nTHOLD                = \"PROFILE\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'PROF('W.2')' W.3 W.4\"\n/********************************/\nTHOLD                = \"PROFILES\"\nSNAME                = \"AUTHORITY\"\n                         /*****************************************/\n                         /* The YES below activates this rule set */\n                         /* for the above segment name            */\n                         /*****************************************/\nITERATE.THOLD.SNAME  = \"YES\"\nITERATE.THOLD        = 1\nTYPE.THOLD           = \"$$\"\nCMD.THOLD            = \"ADD\"\nRSNAME.THOLD         = \"'PROF('W.2 W.3 W.4')'\"\n/********************************/\nSEGMENT   =  \"BASE\"\nIF DISP = \"\" THEN DISP = SHR\nDATA=\"ALL,EXPIRE\"\nSIGNAL OFF ERROR\n  /******************************************************************/\nSECRC = \"FAILED, CHECK IDS EXISTANCE AND YOUR AUTHORITY.\"\nIF ACID  = \"BYPASS\" THEN DO\n  SAY \"T50CON: BYPASS SPECIFIED ALLOCATING INPUT DSN\"\n  \"ALLOC DDN(INPUT) DSN(\"DS1\") REUS\"\n  \"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\n  SS= OUTTRAP('off')\n  IDTYPE = \"USER\"\n  END\nELSE DO\n  say \"T50CON: calling tss for list of id \" acid\n  ADDRESS TSO \"%T50GDAT \"ACID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  IDTYPE = SECRC\n  say \"T50CON: type is \" idtype\n  IF IDTYPE = \"$BADTSS\" THEN DO\n    say \"T50CON: FATAL ERROR. T50GDAT failed TYPE retrieval.\"\n    secrc =\"ID is unlistable check ownership and existance of ID.\"\n    address ispexec \"vput secrc profile\"\n    exit 04\n    END\n  IF CONVOPT = \"DATASET\" THEN DO\n    say \"T50CON: dataset output specified allocating output dsn\"\n    \"%T50LSTO \" ACID \" ALL,EXPIRE\" DS1\n    \"ALLOC DDN(INPUT) DSN(\"DS1\")\"\n    \"EXECIO * DISKR INPUT (FINIS STEM INLINE.)\"\n    SS= OUTTRAP('off')\n    END\n  ELSE DO\n    say \"T50CON: no id list output being generated, data being \"\n    say \"T50CON: manipulated internally  \"\n    SS = OUTTRAP('INLINE.')\n    SAY \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n    ADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\n    SS= OUTTRAP('DROPIT.')\n  END\nEND\nSIGNAL ON ERROR NAME SEEYA\nsay \"T50CON: checking/allocating dsn\" ds2\nJPARM = \"RANDOM\"\n/***************************************************/\n/* PUT THE MSCA ID ON THE JOBCARD IF SCA OR LSCA   */\n/***************************************************/\nIF (IDTYPE = \"LIMITED\") | (IDTYPE = \"CENTRAL\") THEN JPARM = \"SUPER\"\nADDRESS TSO \"%T50JCARD\" DS2 JPARM\n\"ALLOC DDN(BJCL) DSN(\"DS2\") MOD REUS\"\n  /******************************************************************/\nEQUALLOC = INDEX(INLINE.1,\"=\")\nIF EQUALLOC = 0 THEN DO\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"T50CON: ERROR I AM UNABLE TO INITIALIZE THE EQUALLOC VARIABLE\"\n  SAY \"T50CON: THE TSS VERSION 5 DEFAULT OF 11 IS BEING USED        \"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  SAY \"*************************************************************\"\n  EQUALLOC = 12\nEND\nEQUALLOC = EQUALLOC - 1\nsay \"T50CON: equal location is \" equalloc\nGOTOUTPUT: NOP\nTHISREC    = 3\nOUTNUM     = 0\nREALOUT    = 0\nCREATE_NUM = 0\nCREATE.0 = 0\nSECRC = \"FAILED, DURING CONVERT LOGIC .\"\nsay \"T50CON: has a total record count of \" inline.0\nDO I = 1 TO INLINE.0\n  REFORMAT = \"NO\"        /* THIS LINE HASNT BEEN CHANGED YET */\n  T2 = I/100\n  /* IF T2 = FORMAT(T2,4,0) THEN SAY I */\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\")  /* REPLACE = WITH SPACES */\n  LINE= TRANSLATE(LINE,\" \",HEX00) /* KILL THOSE HEX 00 */\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  IF WORD(LINE,1) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  IF (INDEX(LINE,\"*ALL*\") <> 0) & (INDEX(LINE,\"VOLUMES\") =0 ) THEN DO\n    PARSE VAR LINE HOLD0 '*ALL*' HOLD1\n    LINE = HOLD0||\"ALL\"||HOLD1\n    say \"T50CON: removing *all* from line\"\n  END\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  FIRST13 = SUBSTR(LINE,1,EQUALLOC)\n  /***********************************/\n  /** DETERMINE THE segment IN CASE **/\n  /** WE NEED IT LATER.  DIR 15AUG97**/\n  /***********************************/\n  IF W.1 = \"ACCESSORID\" THEN segment = \"BASE\"\n  IF W.1 = \"CREATED\" THEN segment =  \"AUTHORITY\"\n  IF (W.1 = \"LAST\") & (W.2 = \"USED\") THEN segment =  \"AUTHORITY\"\n  IF (W.1 = \"PASSWORD\") & (W.2 = \"*NONE*\") THEN ITERATE I\n  IF  W.1 = \"-----------\" THEN segment =  W.2||W.3\n  IF  W.1 = \"-----------\" THEN Say \"T50CON: Segment changed to \"segment\n  CMD_DEFAULT = COMMAND.SEGMENT\n  IF  W.1 = \"-----------\" THEN iterate i\n  /***********************************/\n  /** END OF segment LOGIC          **/\n  /***********************************/\n  IF W.1 = \"ACIDS\" THEN FLUSH = \"YES\"\n  IF W.1 = \"ACIDS\" THEN ITERATE I\n  IF W.2 = \"LIST(ACIDS)\" THEN ITERATE I /* AN ECHO OF THE ISSUED CMD */\n  IF (SUBSTR(LINE,1,4) = \"ACID\"),\n    & (segment /= \"ADMINISTRATIONAUTHORITIES\") THEN ITERATE I\n  IF W.1 = \"***\" THEN ITERATE I\n  IF LINE = \"             \" THEN ITERATE I\n  IF W.3 = \"NAME\" THEN NAME = W.4 W.5 W.6 W.7 W.8\n  IF W.1 = \"TYPE\" THEN TYPE = W.2\n  IF TYPE = \"CENTRAL\" THEN TYPE = \"SCA\"\n  /**************************************************/\n  /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n  /**************************************************/\n  IF W.3 = \"C/A\"  THEN TYPE = SUBSTR(TYPE,1,1)||\"CA\"\n  IF W.3 = \"LIMITED\" THEN TYPE = \"LSCA\"\n  IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.3\n  IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.3\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.3\n  IF W.1 = \"CREATED\" THEN CALL MAKEACID\n  IF W.1 = \"CREATED\"  THEN ITERATE I\n  IF W.1 = \"TYPE\"  THEN ITERATE I\n  IF W.1 = \"DEPT\"  THEN ITERATE I\n  IF W.1 = \"ZONE\"  THEN ITERATE I\n  IF W.1 = \"DIV\"   THEN ITERATE I\n  IF W.1 = \"LAST\"  THEN ITERATE I\n  IF W.1 = \"TSS0300I\"  THEN ITERATE I\n  IF FIRST13 = \"LCF FAC      \" THEN LCFFAC = W.3\n  IF FIRST13 = \"LCF FAC      \" THEN ITERATE I\n  IF FIRST13 \\= \"             \" THEN DO\n    /**********************************************************/\n    /** I SAVE THE LAST TIME THAT THE 13 CHARACTERS EXISTED  **/\n    /** BECAUSE IF THE LINE IS REALLY INDENTED THEN THOSE    **/\n    /** CHARACTERS ARE GOING TO OVERLAYED ON THIS LINE IN    **/\n    /** A DESPERATE ATTEMPT TO FIGURE OUT WHAT TYPE OF       **/\n    /** RESOURCE IS BEING DEALT WITH. DIR 2 APR 97           **/\n    /**********************************************************/\n    SAVE13 = FIRST13\n    FLUSH = \"NO\"\n  END\n  /**********************************************************/\n  /** below is the logic for dropping lines with entries   **/\n  /** we dont need. the most common example is a profiles  **/\n  /** acids segment.             dir 10 aug 98             **/\n  /**********************************************************/\n  IF (SUBSTR(LINE,1,13) = \"             \") & (FLUSH = \"YES\"),\n  THEN DO\n    say \" T50CON: 13 leading blanks found flushing line #: \" i\n    SAY LINE\n    ITERATE I\n  END\n  /**********************************************************/\n  /** BELOW IS THE REFORMATTER AREA. SOME TSS RULES ARE SO **/\n  /** WEIRDLY SETUP I JUST CREATE A $$ TYPE LINE FOR THEM  **/\n  /** OR OTHERWISE CHANGE THEM                             **/\n  /**********************************************************/\n  IF FIRST13 = \"             \" THEN DO\n    NEWLINE = SAVE13 W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n    PARSE VAR NEWLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n    W.8 W.9 W.10 W.11 W.12\n    say \"T50CON: I am reformatting line #\" i \" to the following\"\n    REFORMAT = \"YES\"\n    /************************************************************/\n    /** THE ABOVE FLAG IS SET SO THAT THE BELOW ROUTINES CAN   **/\n    /** DETERMINE IF THE LINE WAS ORIGINALLY BLANK FROM 1-13   **/\n    /** THIS IS A GOOD WAY TO FIND OUT IF YOU HAVE A           **/\n    /** CONTINUATION THAT HAS TO BE DEALT WITH...DIR 9 JULY 97 **/\n    /************************************************************/\n    SAY NEWLINE\n    LINE = NEWLINE\n    IF WORDS(NEWLINE) > 12 THEN DO\n      SAY \"******************************************************\"\n      SAY \"******************************************************\"\n      SAY \"T50CON: TRUNCATION HAS OCCURED IN REFORMATTING        \"\n      SAY \"******************************************************\"\n      SAY \"******************************************************\"\n    END\n  END\n  /*************************************************************/\n  WORD1 = W.1\n  WORD2 = W.2\n  IF MULTI.WORD1.WORD2.segment = \"YES\" THEN DO\n    /* say \"entering dynam routine outnum is :\" outnum   */\n    OUTNUM = OUTNUM + MULTI.WORD1.WORD2.0ITERATE\n    /* say \"after resolution  outnum is :\" outnum   */\n    /* say \"T50CON: multi match on line\" i\" words: \"word1 word2  */\n    /*say \"T50CON: input cmd/rsname values are below\"            */\n    /*say multi.word1.word2.0cmd multi.word1.word2.0rsname       */\n    /****************************************/\n    /* check for precmd value and issue   it*/\n    /****************************************/\n    VALID = DATATYPE(MULTI.WORD1.WORD2.0PRECMD)\n    if valid = \"NUM\" then do cnum = 1 to MULTI.WORD1.WORD2.0PRECMD\n      SAY \"T50CON: precmd issueing:\" MULTI.WORD1.WORD2.0PRECMD.cnum\n      INTERPRET MULTI.WORD1.WORD2.0PRECMD.cnum\n    end\n    /****************************************/\n    /* check for RSNAME value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0RSNAME\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0RSNAME\" THEN DO\n      HOLDVAL = \"RSNAME.OUTNUM  = \" MULTI.WORD1.WORD2.0RSNAME\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for TYPE value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0TYPE\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0TYPE\" THEN DO\n      HOLDVAL = \"TYPE.OUTNUM    = \" MULTI.WORD1.WORD2.0TYPE\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for access value and resolve it*/\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0ACCESS\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0ACCESS\" THEN DO\n      HOLDVAL = \"ACCESS.OUTNUM  = \" MULTI.WORD1.WORD2.0ACCESS\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for CMD value and resolve it */\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0CMD\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0CMD\" THEN DO\n      HOLDVAL = \"CMD.OUTNUM    = \" MULTI.WORD1.WORD2.0CMD\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for UNTIL value and resolve it */\n    /****************************************/\n    VALID = MULTI.WORD1.WORD2.0UNTIL\n    IF VALID /= \"MULTI.\"WORD1\".\"WORD2\".0UNTIL\" THEN DO\n      HOLDVAL = \"UNTIL.OUTNUM  = \" MULTI.WORD1.WORD2.0UNTIL\n      INTERPRET HOLDVAL\n    end\n    /****************************************/\n    /* check for postcmd value and issue  it*/\n    /****************************************/\n    VALID = DATATYPE(MULTI.WORD1.WORD2.0POSTCMD)\n    IF VALID = \"NUM\" THEN DO CNUM = 1 TO MULTI.WORD1.WORD2.0POSTCMD\n      SAY \"T50CON: Postcmd issueing:\" MULTI.WORD1.WORD2.0POSTCMD.CNUM\n      INTERPRET MULTI.WORD1.WORD2.0POSTCMD.CNUM\n    END\n    SAY \"T50CON: Multi match output for line \"i\" is : \",\n    cmd.outnum type.outnum rsname.outnum access.outnum\n    ITERATE I\n  END\n  IF ITERATE.WORD1.segment = \"YES\" THEN DO\n    /*                                               */\n    /*SAY \"SINGLE LINE=\" W.1 W.2 W.3 W.4 W.5 W.6 W.7 */\n    /*say \"T50CON: segment is \" segment              */\n    /*say \"T50CON: found single match on line \"i\" word: \"WORD1  */\n    OUTNUM = OUTNUM + ITERATE.WORD1\n    if datatype(precmd.word1) = \"NUM\"  then\n      do cnum = 1 to precmd.word1\n      say \"T50CON: precommand \"cnum\" of \"precmd.word1 precmd.word1.cnum\n      interpret precmd.word1.cnum\n    end\n    if rsname.word1 /= \"\" then do\n      holdval = \"rsname.outnum  = \" rsname.word1\n      interpret holdval\n    end\n    if access.word1 /= \"\" then do\n      holdval = \"access.outnum  = \" access.word1\n      interpret holdval\n    end\n    if until.word1 /= \"\" then do\n      holdval = \"until.outnum  = \" until.word1\n      interpret holdval\n    end\n    if cmd.word1 /= \"\" then do\n      holdval = \"cmd.outnum  = \" cmd.word1\n      interpret holdval\n    end\n    if type.word1 /= \"\" then do\n      holdval = \"type.outnum  = \" type.word1\n      interpret holdval\n    end\n    if datatype(postcmd.word1) = \"NUM\" then\n      do cnum = 1 to postcmd.word1\n      say \"T50CON: postcmd \"cnum\" of \"postcmd.word1 postcmd.word1.cnum\n      interpret postcmd.word1.cnum\n    end\n    SAY \"T50CON: Lone  match output for line \"i\" is : \",\n      cmd.outnum type.outnum rsname.outnum access.outnum\n    ITERATE I\n  END\n  /*************************************************************/\n  /*************************************************************/\n  /**  end of dynamic area                                   ***/\n  /*************************************************************/\n  /*************************************************************/\n  IF (W.1 = \"MASTER\") & (W.2 = \"FAC\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"MAS(\"W.3\")\"\n    MSG2 = \"WARNING: THE SOURCE ID (\"ACID\") IS THE MASTERID OF A\",\n    \"FACILITY (\"W.3\").\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMP1 = W.3\",\"W.4\",\"W.5\",\"W.6\n    TEMP1 = STRIP(TEMP1,T,\",\")\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMP1\"))\"\n    CMD_DEFAULT = \"PER\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\") THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMP1 = W.3\",\"W.4\",\"W.5\",\"W.6\n    TEMP1 = STRIP(TEMP1,T,\",\")\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMP1\"))\"\n    /* CMD_DEFAULT = \"PER\"  */\n    ITERATE I\n  END\n  /**************************************************/\n  /* THIS IS THE START OF THE RDT                   */\n  /* THIS FUNCTION MAY PRODUCE MORE THAN 80 CHAR    */\n  /* OUTPUT                            DIR 4 APR 97 */\n  /**************************************************/\n  IF ACID  = \"RDT\" THEN DO\n    TYPE.OUTNUM = \"$$\"\n    CMD.OUTNUM = \"ADD\"\n    IF ((W.1 = \"RESOURCE\") & (W.2= \"CLASS\")) | (W.1 = \"TSS0300I\" ),\n    THEN DO\n      OUTNUM = OUTNUM + 1\n      RSNAME.OUTNUM = \"RESCLASS(\"RCLASS\")\",\n      \" RESCODE(\"RCODE\")  \"\n      IF ATTR \u00ac= \"\" THEN DO\n        RSNAME.OUTNUM = RSNAME.OUTNUM||\"ATTR(\"ATTR\") \"\n      END\n      IF ACLIST1 \u00ac= \"\" THEN DO\n        RSNAME.OUTNUM = RSNAME.OUTNUM||\"ACLST(\"ACLIST\",\"ACLIST1\")\"\n      END\n      ELSE DO\n        IF ACLIST \u00ac= \"\" THEN\n          RSNAME.OUTNUM = RSNAME.OUTNUM||\"ACLST(\"ACLIST\")\"\n      END\n      IF RCLASS = \"RCLASS\" THEN OUTNUM = OUTNUM - 1 /* KILL LINE 1 */\n      RCLASS = W.3\n      ATTR= \"\"\n      ACLIST1 = \"\"\n      ACLIST = \"\"\n      DEFACC= \"\"\n    END\n    IF (W.1 = \"RESOURCE\") & (W.2= \"CODE\") THEN\n      RCODE = SUBSTR(W.3,3,2)\n    IF (W.1 = \"ATTRIBUTE\") THEN\n      ATTR = W.2\n    IF (W.1 = \"ACCESS\") & (ACLIST \u00ac= \"\" ) THEN DO\n      W.2= TRANSLATE(W.2,\"\",\")\")   /* REPLACE ) WITH NULLS */\n      W.2= TRANSLATE(W.2,\"=\",\"(\")  /* REPLACE ) WITH = */\n      W.2= TRANSLATE(W.2,\" \",\",\")  /* REPLACE , WITH   */\n      PARSE VAR W.2 T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 T.11 T.12\n      SAY W.2\n      WORDNUM = WORDS(W.2)\n      HOLD1 = T.WORDNUM\n      LOOPNUM = WORDNUM - 1\n      DO Q2 = LOOPNUM TO 1 BY -1\n        HOLD1 = HOLD1||\",\"T.Q2\n      END\n      ACLIST1 = HOLD1\n    END\n    IF (W.1 = \"ACCESS\") & (ACLIST = \" \" ) THEN DO\n      W.2= TRANSLATE(W.2,\"\",\")\")   /* REPLACE ) WITH NULLS */\n      W.2= TRANSLATE(W.2,\"=\",\"(\")  /* REPLACE ) WITH = */\n      W.2= TRANSLATE(W.2,\" \",\",\")  /* REPLACE , WITH   */\n      PARSE VAR W.2 T.1 T.2 T.3 T.4 T.5 T.6 T.7 T.8 T.9 T.10 T.11 T.12\n      WORDNUM = WORDS(W.2)\n      HOLD1 = T.WORDNUM\n      LOOPNUM = WORDNUM - 1\n      DO Q2 = LOOPNUM TO 1 BY -1\n        HOLD1 = HOLD1||\",\"T.Q2\n      END\n      ACLIST= HOLD1\n    END\n    IF (W.1 = \"DEFACC\") THEN\n      DEFACC= W.2\n    ITERATE I\n  END\n  /* SAMPLE RDT ADD IS BELOW                                      */\n  /*  TSS ADD(RDT) RESCLASS(BUDGET) RESCODE(30)                   */\n  /*  ATTR(LONG,GENERIC,DEFPROT) -                                */\n  /*  ACLST(ALL,ADD=000E,CHANGE=0006,USE=0002,NONE) DEFACC(NONE)  */\n  /**************************************************/\n  /* THIS IS THE END OF THE RDT AREA                */\n  /**************************************************/\n  IF W.1 = \"DAYS\" THEN DO\n    DAYS.OUTNUM = \"DAYS(\"W.2\")\"\n    IF INDEX(W.3,\"TIMES(\") = 1 THEN\n      TIME.OUTNUM = W.3\n    IF W.2 = \"ALL\" THEN DAYS.OUTNUM = ''\n    /**************************************************/\n    /* IF THE W.3 WORD IS TIMES( THEN THE RULE IS     */\n    /* TIMES( ANY ) . IN THIS CASE JUST ERASE IT.     */\n    /**************************************************/\n    IF W.3 = \"TIMES(\" THEN TIME.OUTNUM = ''\n    ITERATE I\n  END\n  IF W.1 = \"SOURCES\" THEN DO\n    W.1 = \"SOURCE\"\n    CMD_DEFAULT  = \"ADD\"\n  END\n  IF W.1 = \"INSTDATA\" THEN DO\n    OUTNUM = OUTNUM + 1\n  /*********************************************************/\n  /** ONE OF MY CLASSIC DEBUGS IS BELOW                   **/\n  /*SAY \"T50CON: AT  INSTDATA I IS \" I \"OUTNUM IS \" OUTNUM */\n  /*********************************************************/\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"INSTDATA\"\n    RSNAME.OUTNUM =\"'\"||STRIP(SUBSTR(LINE,14,59))||\"'\"\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"INSTDATA\"\n    ITERATE I\n  END\n  IF W.1 = \"ACCESSORID\" THEN DO\n    FLUSH = \"YES\"\n    TEMP = OUTNUM + 1\n    CMD_DEFAULT = \"ADD\"\n    IF W.2 = \"*RDT*\" THEN W.2 = \"RDT\"\n    IF W.2 = \"*STC*\" THEN W.2 = \"STC\"\n    IF W.2 = \"*AUDIT*\" THEN W.2 = \"AUDIT\"\n    ACID = W.2\n    ACID.TEMP   = W.2\n    if newacid /= \"\" then acid.temp = newacid\n    /******************************************************/\n    /** WE CHANGE THE ACID TO SUPPORT AN INPUT STREAM    **/\n    /** WITH MORE THAN ONE LISTED ACID THIS WOULD BE     **/\n    /** USED IF WE HAD A BYPASS PARM TO A LIST(ACIDS) DSN**/\n    /******************************************************/\n    IF ACID = \"*ALL*\" THEN ACID = \"ALL\"\n    IF ACID = \"*STC*\" THEN ACID = \"STC\"\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = \"LIB(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    IF REFORMAT = \"YES\" THEN DO   /* WE HAVE MULTI LINES OF PGMS */\n      LENP = LENGTH(PRIVPGM.OUTNUM) - 1\n      H1 = SUBSTR(PRIVPGM.OUTNUM,1,LENP)\n      PRIVPGM.OUTNUM = H1 STRIP(W.2 W.3 W.4 W.5 W.6)||\")\"\n    END\n    ELSE   /* IF IT IS NOT MULTIPLE LINES OF PGMS */\n      PRIVPGM.OUTNUM = \"PRIVPGM(\"STRIP(W.2 W.3 W.4 W.5 W.6)\")\"\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = \"FAC(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.1 = \"PASSWORD\" THEN DO\n    OUTNUM = OUTNUM  + 1\n    RSNAME.OUTNUM = \"PASSWORD(\"W.2\",90)\"\n    IF W.2 = \"*NOPW*\" THEN\n      RSNAME.OUTNUM = \"PASSWORD(NOPW,0)\"\n    CMD.OUTNUM = \"REP\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    OUTNUM = OUTNUM + 1\n    W.2  = TRANSLATE(W.2,\" \",\",\") /* REPLACE COMMAS WITH SPACES */\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    OUTNUM = OUTNUM + 1\n    W.2  = TRANSLATE(W.2,\" \",\",\") /* REPLACE COMMAS WITH SPACES */\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = \"ACTION(\"W.2\")\"\n    ITERATE I\n  END\n  IF W.3 = \"NAME\" THEN DO\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD\"\n    ITERATE I\n  END\n  IF ACID = \"STC\" THEN DO\n    IF W.2 = \"SIZE\" THEN ITERATE I\n    OUTNUM = OUTNUM + 1\n    IF W.2 = \"*DEF*\" THEN W.2 = \"DEFAULT\"\n    IF W.5 = \"*FAIL*\" THEN W.4 = \"FAIL\"\n    IF W.5 = \"*DORM*\" THEN W.4 = \"DORM\"\n    IF W.5 = \"*BYPASS*\" THEN W.4 = \"BYPASS\"\n    IF W.5 = \"*WARN*\" THEN W.4 = \"WARN\"\n    CMD.OUTNUM = \"ADD\"\n    TYPE.OUTNUM = \"$$\"\n    RSNAME.OUTNUM = \"PROC(\"W.2\")               \"\n    TEMP1 = SUBSTR(RSNAME.OUTNUM,1,17)\n    RSNAME.OUTNUM = TEMP1 \"ACID(\"W.4\")\"\n    ITERATE I\n  END\n  /**************************/\n  /* MY BABY FALL THRU AREA */\n  /**************************/\n  IF W.2 = \" \" THEN ITERATE\n  IF SUBSTR(LINE,1,2) = \"  \" THEN DO\n    SAY \"************************************************\"\n    SAY \"************************************************\"\n    SAY \"T50CON: UNRECOGNIZED INDENTED LINE # \" I\n    SAY   LINE\n    SAY \"************************************************\"\n    SAY \"************************************************\"\n  END\n  say \"T50CON: fallthru line:\"i\" segment:\" segment \"word1:\"w.1\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM = CMD_DEFAULT\n  /**************************************************/\n  DO XX = 3 TO 8\n    /*SAY XX IS PAR.XX */\n    /**************************************************/\n    /* NOTE THAT BLANKS AND HEX 00S FAIL THE BELOW    */\n    /* CHECK SO THAT SOME COLUMNS THAT ARE ALWAYS IN  */\n    /* IDS BUT ARE SOMETIMES BLANKS ARE NOT NORMALLY  */\n    /* PROCESSED.                 DIR                 */\n    /**************************************************/\n    IF WORDS(W.XX) <> 0 THEN DO\n      say \"T50CON: fallthru routine parsing \"w.xx\n      OUTNUM = OUTNUM + 1\n      RSNAME.OUTNUM = W.XX\n      TYPE.OUTNUM = W.1\n      CMD.OUTNUM = CMD_DEFAULT\n    END\n  END\nEND\nSAY \"T50CON : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/**************************************************/\n/**************************************************/\n/* THE ACTUAL OUTPUT IS CREATED BELOW FROM THE    */\n/* INPUT LINES. SOME FORMATTING IS DONE UNLESS THE*/\n/* THE TYPE VARIABLE IS \"$$\" IN WHICH CASE THE    */\n/* RSNAME VARIABLE IS APPENDED TO THE ID AND      */\n/* COMMAND AND ISSUED WITH NO FORMATTING. THIS    */\n/* ALLOWS THE ABOVE ROUTINES TO PREPROCESS SOME   */\n/* ENTRY TYPES THAT ARE COMPLEX. DIR 2 APR 97     */\n/**************************************************/\n/**************************************************/\nDO X = 1 TO OUTNUM\n  Y  = X + 1          /* IN CASE WE LOOK AT THE NEXT LINE */\n  B4 = X - 1          /* IN CASE WE LOOK AT THE PREVIOUS LINE */\n  IF ACID.X = \"ACID.\"||X THEN ACID.X = ACID.B4\n  REALOUT = REALOUT + 1\n  /**************************************************/\n  /* A STANDARD DSN PERMIT IS BELOW DIR 2 APR 97    */\n  /**************************************************/\n  BATFILE.X = \" TSS \"CMD.X\"(\"ACID.X\") \"TYPE.X\"(\"RSNAME.X\") \"ACCESS.X,\n    UNTIL.X LIBRARY.X FACILITY.X PRIVPGM.X DAYS.X TIME.X ACTION.X\n  /**************************************************/\n  /* A PREFORMATTED COMMAND JUST ISSUE IT           */\n  /**************************************************/\n  IF TYPE.X = \"$$\" THEN\n    BATFILE.X = \" TSS \"CMD.X\"(\"ACID.X\") \"RSNAME.X\n  BATFILE.X = STRIP(BATFILE.X,T)\n  /**************************************************/\n  /* INSTDATA IS HANDLED SPECIAL BECAUSE IT CAN BE  */\n  /* SO LONG IT GETS ITS OWN LINE DIR 2 APR 97      */\n  /**************************************************/\n  IF TYPE.X = \"INSTDATA\" THEN DO\n    SAY \"                       ***********                       \"\n    SAY \"T51: BEGINNING OF INSTDATA PARSING ROUTINE. LINE IS BELOW\"\n    SAY BATFILE.X\n    PARSE VAR BATFILE.X W.1 W.2 W.3 W.4 W.5 W.6 W.7\n    OUTPUT.REALOUT = \" \"W.1 W.2 \"+\"\n    SAY OUTPUT.REALOUT\n    REALOUT = REALOUT + 1\n    OUTPUT.REALOUT = \"    \"STRIP(W.3 W.4 W.5 W.6 W.7)\n    SAY OUTPUT.REALOUT\n    ITERATE X\n  END\n  /**************************************************/\n  /* IF IT IS TOO LONG ILL BREAK IT UP              */\n  /**************************************************/\n  IF LENGTH(BATFILE.X)  > 72 THEN DO\n    say \"T50CON: line too long reformatting for output of 72\"\n    PARSE VAR BATFILE.X W.1 W.2 W.3 W.4 W.5 W.6 W.7\n    OUTPUT.REALOUT = \" \"W.1 W.2 W.3 \"+\"\n    REALOUT = REALOUT + 1\n    OUTPUT.REALOUT = \"    \"STRIP(W.4 W.5 W.6 W.7)\n    IF LENGTH(OUTPUT.REALOUT) > 72 THEN DO\n      say \"T50CON: breaking up data lines.\"\n      say \"T50CON: w4 and w5:\" w.4 w.5\n      say \"T50CON: w6 and w7:\" w.6 w.7\n      OUTPUT.REALOUT = \"    \"W.4 W.5\" +\"\n      REALOUT = REALOUT + 1\n      V4 = \"\"\n      OUTPUT.REALOUT = W.6 \", + \"\n      /***********************************************/\n      /** IF W6 IS MULTIPLE WORDS SEPERATED BY      **/\n      /** COMMAS THEN WE WILL SEPERATE THEM. 30JUL97**/\n      /***********************************************/\n      IF WORDS(TRANSLATE(W.6,\" \",\",\")) >  3 THEN DO\n        PARSE VAR W.6 V1 ',' V2 ',' V3 ',' V4\n        OUTPUT.REALOUT = \"    \"V1\",\"V2\",\"V3\", + \"\n      END\n      REALOUT = REALOUT + 1\n      OUTPUT.REALOUT = \"    \"V4  W.7\n      REALOUT = REALOUT + 1\n      OUTPUT.REALOUT = \"    \"\n    END\n  END\n  ELSE DO\n    OUTPUT.REALOUT = BATFILE.X\n  END\nEND\nLASTCMD = \"DUMMY\"\nDO T2 = 2 TO REALOUT\n  B4 = T2 - 1\n  IF OUTPUT.T2 = LASTCMD THEN DO\n    SAY \"DUPLICATE LINE DROPPED #\" T2 OUTPUT.T2\n    OUTPUT.T2 = \" \"\n  END\n  IF OUTPUT.T2 /= \" \" THEN LASTCMD = OUTPUT.T2\n  /* SAY \"LASTCMD IS \"LASTCMD */\nEND\nSECRC = \"FAILED, DURING OUTPUT RESOLUTION CHECK OUTPUT STREAM.\"\n\"EXECIO \"CREATE.0\" DISKW BJCL ( FINIS STEM CREATE.)\"\nsay \"T50CON: output lines is \" realout\nREALOUT = REALOUT + 1\nOUTPUT.REALOUT = \"@@\"\n\"EXECIO \"REALOUT\" DISKW BJCL ( FINIS STEM OUTPUT.)\"\n\"FREE DDN(BJCL)\"\n SECRC = \"TSA515W: Unsupported function completed. Output in \" DS2\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\nSIGNAL OFF ERROR\nSAY \"T50CON: ERRORL IN LINE \" SIGL\nSAY SOURCELINE(SIGL)\n/* SECRC = \"T50CON: ERROR IN LINE\"  SIGL  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/**********************************************/\n/**********************************************/\n/***** SUBROUTINES SUBROUTINES  ***************/\n/**********************************************/\n/**********************************************/\nMAKEACID: PROCEDURE EXPOSE ACID I INLINE. NAME TYPE DIV DEPT,\n  ZONE OUTNUM CREATE. CREATE_NUM NEWACID NEWTYPE NEWPASS\n/**********************************************/\nIF NEWACID \\= ''  THEN ACID = NEWACID\nIF NEWTYPE \\= ''  THEN TYPE = NEWTYPE\nIF NEWTYPE = \"LSCA\" THEN OWNER = \"OWNER\"\nUSER_FLAG = \"YES\"\nIF TYPE = \"TYPE\" THEN USER_FLAG = \"$$\"\nIF TYPE = \"DIVISION\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"GROUP\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"DIV\" THEN TYPE= \"VCA\"\nIF TYPE = \"DEPT\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"PROFILE\" THEN USER_FLAG = \"NO\"\nIF TYPE = \"ZONE\" THEN USER_FLAG = \"NO\"\nIF ZONE \\= \" \" THEN OWNER = \"ZONE\"\nIF ZONE \\= \" \" THEN AREA = ZONE\nIF DIV  \\= \" \" THEN OWNER = \"DIV\"\nIF DIV  \\= \" \" THEN AREA  =  DIV\nIF DEPT \\= \" \" THEN OWNER = \"DEPT\"\nIF DEPT \\= \" \" THEN AREA  =  DEPT\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \" TSS CRE(\"ACID\") NAME('\"NAME\"') +\"\nIF USER_FLAG = \"YES\" THEN\n  T = \"  \"OWNER\"(\"AREA\")   TYPE(\"TYPE\") PASSWORD(\"NEWPASS\")\"\nELSE\n  T = \"  \"OWNER\"(\"AREA\")   TYPE(\"TYPE\")\"\nIF OWNER = \"OWNER\" THEN T = \"   TYPE(\"TYPE\") PASSWORD(\"NEWPASS\")\"\nIF TYPE = \"DIVISION \"THEN T = \"   TYPE(\"TYPE\")\"\nIF USER_FLAG = \"$$\" THEN DO\n  SAY \"*********************************************************\"\n  SAY \"T50CON: MAKEACID ROUTINE ABORTING DUE TO LACK OF USER TYPE\"\n  SAY \"T50CON: ACID = \"ACID\n  SAY \"*********************************************************\"\n  RETURN\nEND\nDIV = \"\"\nDEPT = \"\"\nZONE = \"\"\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \"  \"T\nCREATE_NUM = CREATE_NUM + 1\nCREATE.CREATE_NUM = \"  \"\nCREATE.0 = CREATE_NUM\nsay \"T50CON: leaving makeacid routine # lines out = \" create.0\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53DEL": {"ttr": 9476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x05\\x00W\\x00\\x955/\\x01\\x04\\x03O\\x12T\\x00O\\x00O\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.05", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2004-02-03T12:54:57", "lines": 79, "newlines": 79, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50DEL                            **/\n/** LAST MODIFIED    : 17 SEP 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID YOU WISH DELETED.                 **/\n/** MODE    : THE CURRENT MODE \"BATCH\" OR \"ONLINE\"       **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** UIDTABLE : THE GROUP OF 2 CHR NON TSS ID PREFIXES    **/\n/** TVER     : THE CURRENT TSS VERSION VARIABLE          **/\n/** DSBACK   : THE DS WHERE TO TAKE A BACKUP COPY        **/\n/** DS5      : THE DS WHERE TO PUT BATCH SYSIN UPDATES   **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES ( NOTE VGETS )              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T4?LSTO TSSAUDR      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nthiscmd = sysvar(sysicmd)\nSIGNAL OFF ERROR\nsecrc = \"TSA510E: \"Thiscmd\" has ended abnormally.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET TVER PROFILE\"\nADDRESS ISPEXEC \"VGET AUD PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET DS5 PROFILE\"\nUIDENTRY = LENGTH(UIDTABLE)/2\nUIDSTART = 1\nACID2 = SUBSTR(ACID,1,2)\nDSLIST = \"'\"DSBACK\"(\"||ACID||\")'\"\nBJCL.0 = 3\nBJCL.1 = \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\nBJCL.2 = \"TSS DEL( \"ACID\")\"\nBJCL.3 = \"%DELLOCAL\" ACID\nIF MODE = \"BATCH\" THEN DO\n  say \"tsa101d: batch mode detected. allocating \" ds5 \"to bjcl ddn\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  ADDRESS MVS \"EXECIO \"BJCL.0\" DISKW BJCL (FINIS STEM BJCL.)\"\n  secrc = \"TSA511I: Batch file updated with delete stream for \" acid\nEND\nIF MODE = \"ONLINE\" THEN DO\n  TOTCODE = 0\n  SIGNAL OFF ERROR\n  say \"tsa101d: online mode detected. executing delete stream\"\n  SECRC = \"DELETE COMMAND STREAM FOR \" ACID \"FLUSHED.\"\n  DO CN = 1 TO BJCL.0\n    HOLD = BJCL.CN\n    SAY ADDRESS TSO \" \"   HOLD\n    ADDRESS TSO \" \"   HOLD\n    TOTCODE = RC + TOTCODE\n  END\n  secrc = \"command stream for \" acid \"completed normally.\"\n  IF TOTCODE > 0 THEN\n  secrc = \"stream had partial failure, check ids status. code=\" totcode\n  IF TOTCODE = 16 THEN\n  secrc = \"id may not exist or your authority may be invalid.\"\n  SAY SECRC\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n\nBADTSS: NOP\nsecrc = \"the tss id you specified was not listable, check the id\"\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\nBOOKAUTH: NOP\nSECRC = \"YOU DONT HAVE AUTHORITY TO DELETE AN ID WITH BOOK NUMBER\" BOOK\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53DELB": {"ttr": 9478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x01\\x01\\x04\\x19\\x7f\\x01\\x04\\x19\\x7f\\x10Y\\x00\\x06\\x00\\x06\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-07-15T00:00:00", "modifydate": "2004-07-15T10:59:01", "lines": 6, "newlines": 6, "modlines": 0, "user": "COA1DIR"}, "text": "/*rexx */\narg id\naddress tso \"%T52LSTO \"id\" ALLPW 'SYS4.SPI.IDBACKUP(\"id\")'\"\naddress tso \"TSS DEL( \"id\")\"\naddress tso \"%DELLOCAL\" id\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53DELO": {"ttr": 9729, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x005\\x7f\\x01\\x005\\x7f\\tH\\x00}\\x00}\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-12-22T00:00:00", "modifydate": "2000-12-22T09:48:04", "lines": 125, "newlines": 125, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** REMOVED THE CODE TO DELETE ALIAS FROM IMS            **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50DEL                            **/\n/** LAST MODIFIED    : 07 DEC 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID YOU WISH DELETED.                 **/\n/** MODE    : THE CURRENT MODE \"BATCH\" OR \"ONLINE\"       **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** UIDTABLE : THE GROUP OF 2 CHR NON TSS ID PREFIXES    **/\n/** TVER     : THE CURRENT TSS VERSION VARIABLE          **/\n/** DSBACK   : THE DS WHERE TO TAKE A BACKUP COPY        **/\n/** DS5      : THE DS WHERE TO PUT BATCH SYSIN UPDATES   **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES ( NOTE VGETS )              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T4?LSTO TSSAUDR      **/\n/**                                 TSSACNT              **/\n/**********************************************************/\nARG ACID MODE\nSIGNAL OFF ERROR\nSECRC = \"T50DEL HAS ENDED ABNORMALLY.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET UADSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET UIDTABLE PROFILE\"\nADDRESS ISPEXEC \"VGET TVER PROFILE\"\nADDRESS ISPEXEC \"VGET AUD PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET DS5 PROFILE\"\nUIDENTRY = LENGTH(UIDTABLE)/2\nUIDSTART = 1\nACID2 = SUBSTR(ACID,1,2)\nDSLIST = \"'\"DSBACK\"(\"||ACID||\")'\"\nSAY \"T50DEL: BUILDING UID BYPASS TABLE ARRAY OF \" UIDENTRY \"ENTRIES\"\nDO X = 1 TO UIDENTRY\n  UID.X = SUBSTR(UIDTABLE,UIDSTART,2)\n  UIDSTART = UIDSTART + 2\nEND\nNONTSS = \"NO\"\nDO T = 1 TO UIDENTRY\n  IF (ACID2 = UID.T) THEN NONTSS = \"YES\"\nEND\nIF NONTSS =  \"NO\" THEN DO\n  ADDRESS TSO \"%T50GDAT \" ACID \"TSOLACCT  TSO\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  IF SECRC = \"$BADTSS\" THEN SIGNAL BADTSS\n  IF SECRC /= \"$NOTFOUND\" THEN DO\n    BOOK = SECRC\n    X5 = TSSCHECK(\"BOOKNUM\",BOOK,\"UPDATE\")  /* CAN THEY DO THIS */\n    SAY \"T50DEL: TSSCHECK RETURN CODE IS \" X5\n    IF X5 /= \"OK\"  THEN SIGNAL BOOKAUTH\n  END\nEND\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T50DEL: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1 = \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\n  BJCL.2 = \"%RXREPRO SYS1.UADS(\"ACID\"0) \"UADSBACK\"(\"ACID\"0)\"\n  BJCL.2 = \" \"\n  BJCL.3 = \"TSS DEL( \"ACID\")\"\n  BJCL.4 = \"ACCOUNT\"\n  BJCL.5 = \"DEL (\"ACID \")\"\n  BJCL.6 = \"E\"\n  BJCL.7 = \"%TSSAUDR \" ACID AUD\n  BJCL.8 = \"%IMSDALIA\" ACID\n  BJCL.8 = \"  \"\n  IF NONTSS = \"YES\"  THEN DO\n    BJCL.1 = \"%\"TVER\"LSTO\" ACID||\"@  ALLPW\"  DSLIST\n    BJCL.2 = \"TSS DEL( \"ACID\"@)\"\n  END\n  ADDRESS MVS \"EXECIO 8 DISKW BJCL (FINIS STEM BJCL.)\"\n  SECRC = \"BATCH FILE UPDATED WITH DELETE COMMAND STREAM FOR \" ACID\nEND\nELSE DO\n  TOTCODE = 0\n  SIGNAL OFF ERROR\n  SAY \"T50DEL: ONLINE MODE DETECTED. EXECUTING DELETE STREAM\"\n  SECRC = \"DELETE COMMAND STREAM FOR \" ACID \"FLUSHED.\"\n  /***************************************************/\n  /** IF NONTSS = YES THEN I DO NOT CARE IF THE TSS **/\n  /** PORTION OF THE DELETE STREAM FUNCTIONS        **/\n  /** CORRECTLY..      HENCE ALL THE IFS BELOW      **/\n  /***************************************************/\n  ADDRESS TSO  \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\n  IF NONTSS = \"YES\" THEN  /* TRY TO DELETE THE @ GHOST ENTRY */\n    ADDRESS TSO  \"%\"TVER\"LSTO\" ACID\"@ ALLPW\"  DSLIST\n  IF NONTSS = \"NO\" THEN TOTCODE = RC + TOTCODE\n  /* \"%RXREPRO SYS1.UADS(\"ACID\"0) \"UADSBACK\"(\"ACID\"0)\"*/\n  ADDRESS TSO  \"%TSSAUDR \" ACID\n  TOTCODE = RC + TOTCODE\n  /* ADDRESS TSO  \"%IMSDALIA\" ACID */\n  /* TOTCODE = RC + TOTCODE */\n  ADDRESS TSO  \"TSS DEL(\" ACID \")\"\n  IF NONTSS = \"YES\" THEN ADDRESS TSO  \"TSS DEL(\" ACID\"@)\"\n  IF NONTSS = \"NO\" THEN TOTCODE = RC + TOTCODE\n  ADDRESS TSO  \"%TSSACNT \" ACID \"DELETE\"\n  TOTCODE = RC + TOTCODE\n  SECRC = \"COMMAND STREAM FOR \" ACID \"COMPLETED NORMALLY.\"\n  IF TOTCODE > 0 THEN\n  SECRC = \"STREAM HAD PARTIAL FAILURE, CHECK IDS STATUS. CODE=\" TOTCODE\n  IF TOTCODE = 16 THEN\n  SECRC = \"ID MAY NOT EXIST OR YOUR AUTHORITY MAY BE INVALID.\"\n  SAY SECRC\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n\nBADTSS: NOP\nSECRC = \"THE TSS ID YOU SPECIFIED WAS NOT LISTABLE, CHECK THE ID\"\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\nBOOKAUTH: NOP\nSECRC = \"YOU DONT HAVE AUTHORITY TO DELETE AN ID WITH BOOK NUMBER\" BOOK\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53DISC": {"ttr": 9731, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x007\\x00\\x97 /\\x01\\x01\\x19\\x0f\\x081\\x00o\\x00o\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2001-07-09T08:31:37", "lines": 111, "newlines": 111, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** TO REMOVE PROFILE FROM ALL THAT HAVE IT              **/\n/**********************************************************/\n/** EXEC NAME        : T51DISC                           **/\n/** LAST MODIFIED    : 06 JUL 97                         **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** MODE    : THE MODE OF OPERATION                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nENV = SYSVAR(SYSENV)\n/**********************************************************/\n/* REMOVE THE BELOW DO IF YOU WANT THIS EXEC TO RUN IN   **/\n/* ONLINE MODE....( YECH !!)                             **/\n/**********************************************************/\nIF (MODE \\= \"BATCH\") & (ENV = \"FORE\") THEN DO\n  SECRC =\"FUNCTION FAILED. DISCONNECT CANNOT BE RUN IN ONLINE MODE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE   \"\n  EXIT 04\nEND\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS ISPEXEC\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS A PROFILE, FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO REMOVE THAT  PROFILE FROM   */\n/* ALL THE IDS THAT HAVE IT ATTACHED.                               */\n/********************************************************************/\nSTARTOUT: NOP\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T51DISC: BATCH MODE DETECTED. USING DDN BJCL AS OUTPUT\"\n  /* ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"   */\nEND\nOUTNUM =  1\n/***********/\nSECRC = \"LIST COMMAND FAILURE, CHECK IDS VALIDITY\"\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(ACIDS)\"\nQ = OUTTRAP(\"OFF\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  IF WORD(INLINE,1) = \"TSS0300I\" THEN\n    SIGNAL OUTSTART\n  IF SUBSTR(INLINE,14,1) = \" \" THEN\n    GOFLAG = NO\n  IF SUBSTR(INLINE,1,5) = \"ACIDS\" THEN\n    GOFLAG=YES\n  IF GOFLAG = YES THEN DO\n    ID.1 = SUBSTR(INLINE,14,8)\n    ID.2 = SUBSTR(INLINE,26,8)\n    ID.3 = SUBSTR(INLINE,38,8)\n    ID.4 = SUBSTR(INLINE,50,8)\n    DO IDCNT = 1 TO 4\n      IF ID.IDCNT = \"*NONE*\" THEN ITERATE X\n      IF ID.IDCNT = \" \" THEN ITERATE X\n      SECRC = \" \"\n    /************************************************************/\n    /************************************************************/\n      SAY \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      IF MODE \\= \"BATCH\" THEN\n        ADDRESS TSO \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      ELSE DO\n        BJCL.OUTNUM = \"TSS REM(\"ID.IDCNT\") PROF(\"ACID\")\"\n        OUTNUM = OUTNUM + 1\n      END\n    END\n  END\nEND\nOUTSTART: NOP\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM BJCL.)\"\n  /*ADDRESS TSO \"FREE DDN(BJCL)\"   */\nEND\nSECRC= \"FUNCTION COMPLETED NORMALLY. \"\nIF MODE = \"BATCH\" THEN\n  SECRC= \"FUNCTION COMPLETED NORMALLY. OUTPUT APPENDED TO BATCH FILE.\"\n  IF SYSVAR(SYSENV) = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nCLOSEEM: NOP\nSAY \"LINE IS \"SIGL\nSAY  SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53DSNP": {"ttr": 9733, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x00\\x10\\x1f\\x01\\x03\\x19_\\x07B\\x00q\\x00q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-04-10T00:00:00", "modifydate": "2003-07-14T07:42:43", "lines": 113, "newlines": 113, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG ACID DSNAME ACCESS DAYS\nSIGNAL OFF ERROR\n/* PERMITS AN ID TO A DSN */\nSECRC = \"T50DSNP FAILED WITH ERRORS\"\nD.0 =\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET DSNAUDL  PROFILE\"\nIF DSNAUDL = \" \" THEN DSNAUDL = \"'IMS.PROD.PARMLIB(AUDIT)'\"\nIF SYSDSN(DSNAUDL) = \"OK\" THEN DO\n  SAY \"T50DSNP: DSNAUDL IS\" DSNAUDL\n  \"ALLOC DDN(INPUT) DSN(\"DSNAUDL\") SHR REUS\"\n  \"EXECIO * DISKR INPUT ( FINIS STEM D.)\"\n  \"FREE DDN(INPUT)\"\n  SAY \"T50DSNP: I HAVE \"D.0\" QUALIFIERS TO AUDIT\"\n  DO T = 1 TO D.0\n    D.T = WORD(D.T,1)\n  END\nEND\nQ = OUTTRAP(OUT.)\nACTION = \"ACTION(FAIL)\"\nDAY1 = WORD(DAYS,1)\nDAY2 = WORD(DAYS,2)\nIF DAYS = \"AUDIT\" THEN DO\n  SAY \"T50DSNP: AUDIT VALUE DETECTED WITH NO DAYS LIMITATION.\"\n  DAYS = \"0\"\n  DAY1 = \"0\"\n  ACTION= \"ACTION(AUDIT)\"\nEND\nIF (DATATYPE(DAY1) \u00ac= \"NUM\") & (DAY1 \u00ac= \" \" ) THEN DO\n  SAY \"T50DSNP: DAYS VALUE NOT NUMERIC. EXEC ENDING.\"\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(AUDIT)\"\n  MSG2 = \"THE FOLLOWING PARAMETER WAS NOT NUMERIC\" DAY1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF DAY2 = \"AUDIT\" THEN DO\n  SAY \"T50DSNP: AUDIT VALUE DETECTED.\"\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(AUDIT)\"\nEND\nIF (DAY2 \u00ac= \"AUDIT\") & (DAY2 \u00ac= \" \") THEN DO\n  SAY \"T50DSNP: DAY2 VALUE NOT UNDERSTOOD = \" DAY2\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(FAIL)\"\n  MSG2 = \"THE FOLLOWING PARAMETER WAS NOT UNDERSTOOD\" DAY2\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF ACCESS \u00ac= \"READ\" THEN DO COUNT = 1 TO D.0\n  SAY \"T50DSNP: COMPARING \"DSNAME \"TO \" D.COUNT\n  IF INDEX(DSNAME,D.COUNT) = 1 THEN DO\n    SAY \"T50DSNP: DSNAUDIT ENTRY MATCH ENTRY\" COUNT DSNAME D.COUNT\n    ACTION = \"ACTION(AUDIT)\"\n    MSG2 = \"THAT DATASET IS AUDITED DAILY, AUDIT RULE INCLUDED\"\n    IF ACID = \"UCC7BAT\" THEN DO\n      MSG2 = \"NO AUDIT RULE ADDED. ID IS THE PRODUCTION JCL ID.\"\n      ACTION = \"ACTION(FAIL)\"\n    END\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSAY \"T50DSNP: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nRCODE = 0\nADDRESS TSO \"TSS WHOOWNS DSN(\"DSNAME\")\"\nRCODE = RC\nSAY \"T50DSNP: WHOOWNS RC IS \" RCODE\nIF RCODE \u00ac= 0 THEN DO\n  SECRC = \"THAT DATASET IS NOT UNDER YOUR OWNERSHIP. FUNCTION FAILED.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY OUT.1 OUT.2\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nRCODE = RC\nSAY \"T50DSNP: TSS LIST RC IS \" RCODE\nIF RCODE \u00ac= 0 THEN DO\n  SECRC = \"THAT ID IS NOT OWNED BY YOU OR IS INVALID.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY OUT.1 OUT.2\n  EXIT 04\nEND\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T50DSNP: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") DSN(\"DSNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"DSNAME\") ACCESS(\"ACCESS\") FOR(\"DAYS\")\" ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  SECRC = \"PERMIT FUNCTION SUCCESSFULL FOR ID \"ACID\" FOR \"DAYS\" DAYS.\"\nELSE\n  SECRC = \"PERMIT RETURNED NON ZERO RCODE OF \"RCODE\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53DSSIM": {"ttr": 9735, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x008\\x00\\x98(_\\x00\\x98(_\\t!\\x00?\\x00?\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1998-10-12T00:00:00", "modifydate": "1998-10-12T09:21:38", "lines": 63, "newlines": 63, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"%T50TSSIM\" ACID RTYPE RNAME FACILITY ACCESS DSOUT\n ADDRESS TSO \"ALLOC DDN(INFILE) DSN(\"DSOUT\") SHR REUS\"\n ADDRESS MVS \"EXECIO * DISKR INFILE ( FINIS STEM LINE.)\"\n ADDRESS TSO \" FREE DDN(INFILE)\"\n /*SAY \"T50SIM: PARMS:\" ACID RTYPE RNAME FACILITY ACCESS DSOUT */\n SAY \"T50SIM: CHECKING ACCESS FOR\" ACID \"TO\" RNAME \"THRU\" FACILITY\n SAY \"      \"\n DO T = 1 TO LINE.0\n   LINE.T = SUBSTR(LINE.T,1,79)\n   IF (W.2 = \"VOL\") & (W.3 = \"ORIGIN\")  THEN LEAVE\n   PARSE VAR LINE.T  W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n   IF W.1 = \"TSS8379W\" THEN DO\n     SAY \"************************************************\"\n     SAY \"T50SIM: THE INPUT ID IS NOT UNDER YOUR CONTROL.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8362E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T50SIM: THE INPUT ID WAS NOT TSS DEFINED.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8361E\" THEN DO\n     SAY \"************************************************\"\n     SAY \" \"W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10\n     SAY \"T50SIM: AN INPUT PARAMETER WAS INCORRECT.\"\n     SAY \"T50SIM: FUNCTION MAY NOT DELIVER OUTPUT .\"\n     SAY \"************************************************\"\n   END\n   IF W.1 = \"TSS8393I\" THEN DO\n     IF INDEX(LINE.T,\"DSN\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T50SIM: THIS ID BYPASSES NORMAL DATASET CHECKS!!\"\n       SAY \"************************************************\"\n     END\n     IF INDEX(LINE.T,\"VOL\") \u00ac=  0 THEN DO\n       SAY \"************************************************\"\n       SAY \"T50SIM: THIS ID BYPASSES NORMAL VOLUME  CHECKS!!\"\n       SAY \"************************************************\"\n     END\n   END\n   IF W.1 = \"TSS8380I\" THEN\n     SAY \"T50SIM: RESOURCE ACCESS WOULD BE GRANTED.\"\n   IF W.1 = \"TSS8381I\" THEN\n     SAY \"T50SIM: RESOURCE ACCESS WOULD BE DENIED.\"\n   IF (W.2 = \"ALLOWED\") & (W.3 = \"ACCESS\")  THEN\n     SAY \"T50SIM: THE ID HAS \"W.5\" ACCESS TO THIS RESOURCE\"\n   IF ( W.1 = \"TSS8394I\" ) & ( W.2 \u00ac= \"VOL\" ) THEN DO\n     PROF = W.6\n     IF W.6 = \"-\" THEN PROF = W.7\n     IF W.6 = \"*USER*\" THEN\n       PROF = \"THE INDIVIDUAL ID DEFINITION FOR\" ACID\n     IF W.6 = \"*ALL*\"  THEN PROF = \"THE SYSTEM ALL RECORD.\"\n     SAY \"T50SIM: THE APPLICABLE RULE IS IN\" PROF\n   END\n   IF W.1 = \"TSS8397I\" THEN SAY \"      \" W.2 W.3 W.4 W.5\n   /* TSS8380I GRANTED  */\n   /* TSS8381I DENIED   */\n END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53FDIV": {"ttr": 9737, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00E\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x007\\x007\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:45", "lines": 55, "newlines": 55, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T50FDIV                           **/\n/** LAST MODIFIED    : 21 JUN 94                         **/\n/**     CONVERTED FROM CLIST TO REXX EXEC                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**       SECRC CAN CONTAIN:                             **/\n/**   THE DIVISION OF THE ACID.                           */\n/**   THE STRING \"LIST FUNCTION FAILED.\" IF THE ID IS BAD.*/\n/**   THE STRING \"PROFILE\"     IF THE ID IS A PROFILE.    */\n/**   THE STRING \"LIMITED\"     IF THE ID IS AN LSCA.      */\n/**   THE STRING \"CENTRAL\"     IF THE ID IS AN SCA.       */\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  NONE                **/\n/**********************************************************/\nARG ACID\nSAY \"T50FDIV: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nSECRC = \"LIST FUNCTION FAILED.\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T50FDIV: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"\nSAY \"T50FDIV: BACK FROM TSS WITH \"INLINE.0 \"LINES OF DATA\"\nDO X = 1 TO INLINE.0\n  INLINE = INLINE.X\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n  TOTWORDS = WORDS(INLINE)\n  IF W.1 = \"TYPE\" THEN  DO\n    SAY \"T50FDIV: TYPE INITIALLY SET TO \"W.3\n    SECRC = W.3\n  END\n  IF SECRC = \"PROFILE\" THEN LEAVE /* THIS IS WHAT HE WANTS TO KNOW  */\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\") THEN  DO\n    SAY \"T50FDIV : DIVISION FOUND, IS \"W.4\n    SECRC = W.4\n  END\nEND\nSAY \"T50FDIV: NORMAL END. FINAL DIVISION IS\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nW.1 = WORD(INLINE.1,1)\nIF W.1 = \"TSS0352E\" THEN SECRC = \"AUTHORIZATION FAILED.\"\nSAY \"T50FDIV : \"INLINE.1\nSAY \"T50FDIV : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T50FDIV : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53FLOC": {"ttr": 9739, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x06\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x001\\x001\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:06", "lines": 49, "newlines": 49, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** RETURNS THE LOCATION OF A PROFILE IN A USERS PROFILE **/\n/** LIST ... DIR                                         **/\n/**********************************************************/\n/** EXEC NAME        : T50FLOC                           **/\n/** LAST MODIFIED    : 06 MAY 96                         **/\n/**  USES THE NEW T50FLOC  FUNTIONALITY                  **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  ANY TSS ACID                              **/\n/** PROFILE :  ANY TSS ACID THAT IS A PROFILE            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**   NONE                                               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  T50GDAT             **/\n/**                                                      **/\n/**********************************************************/\nARG ACID PROFILE\nSAY \"T50FLOC: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nGOTPRF = \"NO\"\nSECRC = \"ERROR\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T50FLOC: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"%T50GDAT \"ACID\" PROFILES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nPARSE VAR SECRC P.1 P.2 P.3 P.4 P.5 P.6 P.7 P.8 P.9 P.10 P.11 P.12\nNUM = WORDS(SECRC)\nSECRC = 0\nDO W = 1 TO NUM\n  IF PROFILE = P.W THEN SECRC = W\nEND\nSAY \"T50FLOC: POSITION OF \"PROFILE \" IN \" ACID \"IS \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"T50FLOC : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T50FLOC : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53GCMD": {"ttr": 9741, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x00\\x01\\x00\\x955/\\x00\\x994O\\x10)\\x00`\\x00`\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1999-12-10T10:29:01", "lines": 96, "newlines": 96, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\n/*****************************************************************/\n/* added a null line to the output to fix prompt of user         */\n/*****************************************************************/\n/* THIS EXEC WILL CREATE A COMMAND STREAM THAT WILL AFFECT       */\n/* ALL THE ACIDS IN A DEPARTMENT DIVISION OR CONNECTED TO A      */\n/* PROFILE.                                                      */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nARG GROUP DSN1 CMD\nADDRESS ISPEXEC\n\"VGET (ACID DS3 DATA MODE) PROFILE\"\nIF GROUP = \" \" THEN GROUP = ACID\nIF DSN1 = \" \" THEN DSN1  = DS3\nIF CMD = \" \" THEN CMD  = DATA\nSAY \"T50GCMD: CALLING T50JCARD FOR JCL STREAM INITIALIZATION.\"\nADDRESS TSO \"T50JCARD\" DS3\nREPNUM = 0\nLCMD = LENGTH(CMD) - 2\nIF POS(\" $$\",CMD) = LCMD THEN SIGNAL OKTOGO\nIF POS(\" $$ \",CMD) = 0 THEN DO\n  SECRC = \"ERROR: THE STRING ' $$ ' MUST EXIST IN THE COMMAND STRING.\"\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nOKTOGO: NOP\nPARSE VAR CMD W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\nSIGNAL ON ERROR NAME SEEYA\nIF SYSDSN(DSN1) \u00ac= \"OK\" THEN DO\n  SAY \"TSSGCMD: THE OUTPUT DSN YOU HAVE GIVEN ME IS UNAVAILABLE\"\n  EXIT 00\nEND\nDO Z = 1 TO 9\n  IF W.Z = \" $$ \" THEN REPNUM = Z\nEND\nCOUNT_LIM = REPNUM - 1\nDO Z = 1 TO COUNT_LIM\n  IF W.Z = \" $$ \" THEN REPNUM1 = Z\nEND\nQ = OUTTRAP(OUTID.)\nADDRESS TSO\nIF MODE = \"ONLINE\" THEN\n  \"ALLOC DDN(OUT1) DSN(\"DSN1\") REUS MOD\"\nSAY \"T50GCMD: I AM CALLING T50PWHO WITH PARMS:\" GROUP\nSIGNAL OFF ERROR\n\"%T50PWHO\" GROUP\nLIST_CODE = RC\nSIGNAL ON ERROR NAME SEEYA\nsay \"TSA101D: T50GCMD I am back from T50PWHO with return code of \" rc\nsay \"TSA101D: T50GCMD the output of T50PWHO was \"outid.0 \"records.\"\nsay \"TSA101D: T50GCMD I am routing output to \"dsn1\nIF ( OUTID.0 = 0 ) | ( LIST_CODE \\= 0 )  THEN DO\n  msg2 = \"TSA221E: \"\n  msg2 = msg2 \"Failed. stream is incomplete, failure in listing \" group\n  ADDRESS ISPEXEC  \"VPUT MSG2 PROFILE\"\n  queue \"T50222E: I have received no input from T50PWHO\"\n  queue \"         acid may be invalid or authorization may have failed\"\n  ADDRESS ISPEXEC  \"VGET SECRC PROFILE\"\n  QUEUE SECRC\nEND\nDO X = 1 TO OUTID.0\n  PARSE VAR OUTID.X ACID LINE\n  ACID = WORD(OUTID.X,1)\n  if acid = \"TSS0300I\" then iterate x\n  IF ACID = \"ACCESSORID\" THEN ACID= WORD(OUTID.X,3)\n  W.REPNUM = ACID\n  W.REPNUM1 = ACID\n  IF (ACID = \"*\") | (ACID = \"*NONE*\") THEN DO\n    QUEUE LINE\n    ITERATE X\n  END\n  LINE = W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\n  IF LINE \u00ac= \"=\" THEN\n    QUEUE LINE    /* NO BLANK LINES! */\nEND\nQUEUE \" \"\nQUEUE \"@@\"\nqueue\nSIGNAL OFF ERROR\nsecrc = \"TSA223I: group commmand stream placed in dsn \" dsn1\nIF MODE = \"ONLINE\" THEN  DO\n  \"EXECIO * DISKW OUT1 (FINIS)\"\n  \"FREE DDN(OUT1)\"\nEND\nIF MODE = \"BATCH\" THEN DO\n  \"EXECIO * DISKW BJCL (FINIS)\"\n   SECRC = \"COMPLETED. COMMAND STREAM APPENDED TO BATCH FILE \"\nEND\n\"FREE DDN(IN1)\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53GDAT": {"ttr": 9743, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x07\\x00P\\x00\\x97 /\\x01\\x04\\x08/\\x11\\x15\\x00\\x95\\x00\\x90\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.07", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2004-03-22T11:15:50", "lines": 149, "newlines": 144, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T52GDAT                           **/\n/** LAST MODIFIED    : 02 MAY 96                         **/\n/**********************************************************/\n/** ADDED SUPPORT FOR MULTIPLE WORD FIELDS AND THE       **/\n/** SPECIAL REQUIREMENTS OF THE PROFILE FIELD..DR        **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : ANY TSS ACID                               **/\n/** FIELD   : THE TSS FIELD THE CALLER WANTS TO RECEIVE  **/\n/**           BACK                                       **/\n/** DATA    : THE TYPE OF LIST I MUST DO. (NOT REQ)      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** NONE                                                 **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 04 08 16                  **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES (VPUT OF SECRC)             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG ACID FIELD DATA\n/* SAY ACID FIELD DATA */\nHEX00 = '00'X\n/** IF THE FIELD REQUESTED IS ONE THAT NEEDS MULTIPLE    **/\n/** WORDS PASSED BACK TO THE CALLER THEN SET THE MULT.  **/\n/** VARIABLE TO YES BELOW... DIR JAN 97                 **/\nMULT.USED = \"YES\"\nMULT.NAME = \"YES\"\nMULT.PROFILES = \"YES\"\nMULT.INSTDATA = \"YES\"\nMULT.BYPASSING = \"YES\"\nMULT.ATTRIBUTES = \"YES\"\n/* SAY \"T52GDAT: HAS CONTROL PARMS \" ACID FIELD DATA */\nGOTIT = \"NO\"\nIF DATA = \" \" THEN DATA = \"BASIC\"\nSIGNAL ON ERROR NAME BADDATA\nQ = OUTTRAP(OUTID.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nSIGNAL ON ERROR NAME SEEYA\nDO X = 1 TO OUTID.0\n  X1 = X+1 ; X2 = X+2 ; X3 = X+3 ; X4 = X+4\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTID.X=TRANSLATE(OUTID.X,\" \",HEX00)\n  PARSE VAR OUTID.X W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12\n  WNUM = WORDS(OUTID.X)\n  DO T = 1 TO WNUM\n    IF WORD(OUTID.X,T) = FIELD THEN DO\n      /* SAY \"T52GDAT: LINE IS \" OUTID.X                 */\n      /*SAY \"T52GDAT: FIELD IS\" FIELD                    */\n      /*SAY \"T52GDAT: GOT IT ON LINE \" X \" WORD \" T      */\n      T1 = T + 1\n      T2 = T + 2\n      T3 = T + 3\n      SECRC = W.T2\n      /* SAY \"T52GDAT: SETTING INITIAL SECRC TO \" SECRC    */\n      IF FIELD = \"DEPT\" THEN SECRC = W.T3\n      IF (FIELD = \"TYPE\") & (W.T3 = \"C/A\") THEN\n        SECRC = SECRC||\"CA\"\n /*   IF FIELD = \"NAME\" THEN */\n /*     SECRC = SECRC  W.T3  */\n      /**************************************************/\n      /** BELOW IS SUPPORT FOR A FIELD THAT HAS MULTIPLE*/\n      /** PARMS, LIKE PROFILES ...DIR 2 MAY 96          */\n      /**************************************************/\n      IF MULT.FIELD = \"YES\" THEN DO\n        IF FIELD = \"PROFILES\" THEN DO\n          /**************************************/\n          /** IF IT IS A PROFILES REQUEST WE   **/\n          /** SCAN AHEAD AND LOAD THE CURRENT  **/\n          /** LINE WITH ALL THE PROFILES IN THE**/\n          /** NEXT 4 LINES, THUS SUPPORTING 5  **/\n          /** FULL LINES OF PROFILES OR 20 OF  **/\n          /** THOSE BUGGARS.   DIR 2 MAY 96    **/\n          /**************************************/\n          /* SAY \"T52GDAT: PROFILE ROUTINE IN CONTROL\"        */\n          NW1 = WORD(OUTID.X1,1)\n          NW2 = WORD(OUTID.X2,1)\n          NW3 = WORD(OUTID.X3,1)\n          NW4 = WORD(OUTID.X4,1)\n          IF NW1 = \"PROFILES\" THEN W.8 = SUBSTR(OUTID.X1,14)\n          IF NW2 = \"PROFILES\" THEN W.9 = SUBSTR(OUTID.X2,14)\n          IF NW3 = \"PROFILES\" THEN W.10 = SUBSTR(OUTID.X3,14)\n          IF NW4 = \"PROFILES\" THEN W.11 = SUBSTR(OUTID.X4,14)\n          /**************************************/\n          /** LETS TELL THE NEXT ROUTINE THERE **/\n          /** ARE MORE WORDS THAN THERE USED TO**/\n          /** BE IN THE CURRENT LINE.DR 2 MAY96*/\n          /**************************************/\n          WNUM = 11\n        END\n        /*SAY \"T52GDAT: MULTIPLE WORD FIELD DETECTED.\"    */\n        /*SAY \"T52GDAT: COUNTING FROM \"T2 \" TO \" WNUM     */\n        ALLDATA = \"\"\n        DO W1 = T2 TO WNUM\n          IF W.W1 = \"=\" THEN LEAVE /* WE HAVE HIT THE NEXT VALUE */\n          ALLDATA = ALLDATA  W.W1\n        END\n        SECRC = ALLDATA\n      END\n      GOTIT = \"YES\"\n    END\n    IF GOTIT = \"YES\" THEN LEAVE\n  END\n  IF GOTIT = \"YES\" THEN LEAVE\nEND\nSIGNAL OFF ERROR\n/*****************************************************************/\n/** NOT FINDING AN INTERVAL MAY BE OK PASS BACK A ZERO.         **/\n/*****************************************************************/\nIF (GOTIT = \"NO\") & (FIELD = \"INTERVAL\") & (DATA \u00ac= \"BASIC\") THEN DO\n  GOTIT = \"YES\"\n  SECRC = 0\nEND\nIF GOTIT = \"YES\" THEN DO\n  /* SAY \"T52GDAT: FIELD \"FIELD\" WAS FOUND. VALUE IS \" SECRC   */\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSECRC = \"$NOTFOUND\"\n/* SAY \"T52GDAT: FIELD \"FIELD\" WAS NOT FOUND. SECRC IS \" SECRC  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nBADDATA: NOP\nSECRC  = \"$BADTSS\"\nSAY \"T52GDAT: ERROR ROUTINE ENTERED, LIST DATA IS\" DATA\nSAY \"T52GDAT: \"ACID FIELD DATA\nIF WORD(OUTID.1,1) = \"TSS0352E\" THEN DO\n  SECRC = \"$BADAUTH\"\n  SAY \"T52GDAT: ID IS NOT OWNED WITHIN SCOPE OF CONTROL\"\nEND\nIF WORD(OUTID.1,1) = \"TSS0314E\" THEN DO\n  SECRC = \"$BADACID\"\n  SAY \"T52GDAT: No such TSS ACID.\"\nEND\nSAY \"T52GDAT: SECRC IS BEING SET TO \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSEEYA: NOP\nSAY \"T52GDAT: AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53GDEL": {"ttr": 9745, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00A\\x00\\x97 /\\x01\\x00\\x07_\\x10S\\x00n\\x00n\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2000-03-15T10:53:41", "lines": 110, "newlines": 110, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** Creates a batch job that will delete multiple ids    **/\n/** under a department or division, depending on how many**/\n/** times the job is submitted                           **/\n/** submit it once:  Deletes all users and profiles      **/\n/**                  but leaves the departments that     **/\n/**                  had IDs in them.                    **/\n/** submit it twice: Deletes all the newly emptied depts **/\n/** submit it thrice Deletes the dept or division.       **/\n/**********************************************************/\n/** exec name        : T50GDEL                           **/\n/** last modified    : 06 jul 97                         **/\n/**********************************************************/\n/**----------------input required -----------------------**/\n/** passed args        valid values                      **/\n/** acid    : the one to be replaced                     **/\n/** mode    : the mode of operation                      **/\n/** ispf vgets         valid values                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T50GDAT T50pwho      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS ISPEXEC\nIF MODE = \"BATCH\" THEN DO\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nenv = sysvar(sysenv)\nIF MODE \\= \"BATCH\" THEN DO\n  secrc =\"TSA236E: failed. global delete cannot be run in online mode.\"\n  \" VPUT SECRC PROFILE   \"\n  say \"TSA101D: T50GDEL global delete cannot be run in online mode\"\n  EXIT 04\nEND\nSay \"TSA101D: T50GDEL Batch mode detected. using ddname BJCL as output.\"\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS AN ID    , FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO DELETE THOSE IDS            */\n/********************************************************************/\nSTARTOUT: NOP\n/*                                                              */\n/*IF MODE = \"BATCH\" THEN DO                                     */\n/*     ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"        */\n/*END                                                           */\nOUTNUM =  1\n/***********/\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T50PWHO \"ACID \"YES\"\nSAY \"TSA101D: # of lines of output return from TxxPWHO is\" OUT.0\nQ = OUTTRAP(\"XX.\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  SAY strip(INLINE)\n  ID=WORD(INLINE,1)\n  IF WORD(INLINE,1) = \"ACCESSORID\" THEN ID = WORD(INLINE,3)\n  IF ID = TSS0300I THEN LEAVE\n  /************************************************************/\n  /*                                                          */\n  /************************************************************/\n  say \"TSA101D: T50GDEL issuing \" ADDRESS TSO \"%T50GDAT \"ID \" TYPE \"\n  ADDRESS TSO \"%T50GDAT \"ID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  say \"TSA101D: T50GDEL deleting logic for id:\" id \"type:\" type\n  IF MODE = \"ONLINE\" THEN\n    say \"TSA101D: T50GDEL online mode ignored.\"\n    /* ADDRESS TSO \" TSS REMOVE(\"ID\")\" */\n  IF MODE = \"BATCH\" THEN DO\n    IF TYPE = \"PROFILE\" THEN\n      BJCL.OUTNUM = \"ISPSTART CMD(%T50DISC \"ID\")\"\n    IF TYPE = \"PROFILE\" THEN OUTNUM = OUTNUM + 1\n    BJCL.OUTNUM = \"TSS DEL(\"ID\")\"\n    OUTNUM = OUTNUM + 1\n  END\nEND\nOUTSTART: NOP\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nsecrc= \"TSA237I: function completed. output appended to batch file.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nEXIT\n/*************************************/\nCLOSEEM: NOP\nSIGNAL OFF ERROR\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nSAY \"****************************************************\"\nSAY \"LINE IS \"SIGL\nX = SOURCELINE(SIGL)\nSAY X\nSAY  SECRC id type\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53GREP": {"ttr": 9747, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x17\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00y\\x00y\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:17", "lines": 121, "newlines": 121, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED ALL LOCATION PROCESSING WITH USE OF AFTER    **/\n/** KEYWORD DIR 2 OCT 97                                 **/\n/**********************************************************/\n/** TO GLOBALLY REPLACE A PROFILE WITH ANOTHER           **/\n/**********************************************************/\n/** EXEC NAME        : T50GREP                           **/\n/** LAST MODIFIED    : 02 OCT 97                         **/\n/**********************************************************/\n/** TOTALLY REWRITTEN TO IMPROVE SPEED BY 1000%          **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** NEWACID : THE ONE TO REPLACE IT WITH                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NOTUSED\nADDRESS ISPEXEC\n\"      VGET DISP PROFILE     \"\n\"      VGET MODE PROFILE     \"\n\"      VGET DS1 PROFILE     \"\n\"      VGET DS2 PROFILE     \"\n\"      VGET DS3 PROFILE     \"\n\"      VGET DS4 PROFILE     \"\n\"      VGET DS5 PROFILE     \"\n\"      VGET DS6 PROFILE     \"\nMYCODE = 0\nTOTAL_RC = 0\nACID = TRANSLATE(ACID,\" \",\".\")\nNEWACIDS = TRANSLATE(NEWACID,\" \",\".\")\nIF INDEX(\" \"NEWACID\" \",\" \"ACID\" \") \\= 0 THEN DO\n  msg2  = \"TSA241W: Warning - cannot replace an ACID with itself.\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE   \"\nEND\nSECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n\"      VPUT SECRC PROFILE   \"\nSIGNAL ON ERROR NAME CLOSEEM\nOUTFILE.0 = 0\nSTARTOUT: NOP\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS3\") \"DISP\" REUS\"\n  ADDRESS TSO \"ALLOC DDN(JCLFILE) DSN(\"DS6\") SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR JCLFILE ( FINIS STEM OUTFILE.)\"\nEND\nOUTNUM = OUTFILE.0 + 1\n/***********/\nQ = OUTTRAP(DROPOUT.)\nSIGNAL OFF ERROR\nDO T1 = 1 TO WORDS(NEWACIDS)\n  LISTACID = WORD(NEWACIDS,T1)\n  ADDRESS TSO \"TSS LIST(\"LISTACID\") DATA(BASIC)\"\n  TOTAL_RC = TOTAL_RC + RC\n  IF TOTAL_RC > 0 THEN BADID = LISTACID\nEND\nIF TOTAL_RC \\=0 THEN DO\n  MSG2 = \"TSA242W: Warning\"\n  msg2 = msg2 badid \" profile was unlistable jcl may not be valid.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T50PWHO \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF SECRC = \"$BADTSS\" THEN DO\n  secrc = \"TSA243E: Aborted.\"\n  secrc = secrc acid\" profile was unlistable. Check validity.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nEND\nSIGNAL ON ERROR NAME CLOSEEM\nQ = OUTTRAP(\"OFF\")\nsay \"TSA101D: Pwho generated \"out.0 \"lines of output .\"\nif out.0 = 0 then do\n  secrc = \"TSA246E: Unable to find attached ACIDs for replace stream\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nend\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  ID = WORD(OUT.X,1)\n  IF ID = \"ACCESSORID\" THEN ID = WORD(OUT.X,3)\n  OUTFILE.OUTNUM =\"TSS ADD(\"ID\") PROFILE(\"NEWACIDS\") AFTER(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\n  OUTFILE.OUTNUM =\"TSS REM(\"ID\") PROFILE(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\nEND\nOUTSTART: NOP\nOUTFILE.OUTNUM = \" \"\nOUTDD = \"OUTFILE\"\nIF MODE = \"BATCH\" THEN OUTDD = \"BJCL\"\nADDRESS MVS \"EXECIO * DISKW \"OUTDD\" ( FINIS STEM OUTFILE.)\"\nSECRC= \"TSA244I: Replace stream generated output in \" DS3\nIF MODE = \"BATCH\" THEN\nsecrc= \"TSA245I: Replace stream appended to batchfile.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\nCLOSEEM: NOP\nSAY \"TSA101D: T50grep error line is \"SIGL\nSAY \"TSA101D: secrc is \"  SECRC\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53ICOMO": {"ttr": 9985, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00&\\x01\\x03\\x16O\\x01\\x03\\x16O\\x08$\\x07\\xbf\\x07\\xbf\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-06-13T00:00:00", "modifydate": "2003-06-13T08:24:26", "lines": 1983, "newlines": 1983, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** added convert support for d,g and t,g in volume      **/\n/** rules  dir may 5 2002                                **/\n/**********************************************************/\n/**********************************************************/\n/** changed some doc spelling DIR FEB 22 2002            **/\n/**********************************************************/\n/** Change to modrule routine to totally remove the      **/\n/** scrolling area of that routine... I don't even know  **/\n/** why that section of the routine was there....        **/\n/**                  DIR Novem 05 2001                   **/\n/**********************************************************/\n/**********************************************************/\n/** July 25 2001 - documentation updates                 **/\n/**********************************************************/\n/** Change to debug modify processing to fix errant ptr  **/\n/** Which caused some scrolling to miss records and      **/\n/** caused records selected during modify to be wrongly  **/\n/** grabbed.         DIR april 12 2001                   **/\n/**********************************************************/\n/** Discovered that modify will not support stacked/     **/\n/** owned resources, and that it would be a bear to      **/\n/** fix so I am leaving it alone.                        **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T52ICOMP                          **/\n/** LAST MODIFIED    : 5 Novem     2001                  **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T52JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/**                                                      **/\n/** defgroup = the defgroup OMVS group for invoking the  **/\n/**            %GIVEUID exec.                            **/\n/**                                                      **/\n/** DS1      = work dsn #1 in the SPI system             **/\n/**                                                      **/\n/** DS2      = work dsn #2 in the SPI system             **/\n/**                                                      **/\n/** idebug   = a debug value that can be set to override **/\n/**            debug values in this exec                 **/\n/**                                                      **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/** newpass  = The password value to be used in converts **/\n/**                                                      **/\n/** uidcon   = a value to specify if UIDs are converted  **/\n/**            'as is' or if the %giveuid exec is to be  **/\n/**             used instead.                            **/\n/**            NO =  The GIVEUID exec is issued for a new**/\n/**              UID, unless UID is zero.                **/\n/**            YES = The exact UID will be replicated    **/\n/**              A UID of zero is always be replicated   **/\n/**                                                      **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were passed to me  **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/**********************************************************/\n/** IN the below variables the 'name' area is a variable **/\n/**  which is an actual ACID                             **/\n/**********************************************************/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/** acidrul.name.#.0type    the type                     **/\n/** acidrul.name.#.0segment the segment                  **/\n/** acidrul.name.#.0resname the resource name            **/\n/** acidrul.name.#.0restext the resource text            **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** In the below variable name and type and resource     **/\n/**   are all variables !!                               **/\n/**********************************************************/\n/** acidath.name.type.resource                           **/\n/**                    The actual translated data from   **/\n/**                      the TSS list, with all relevant **/\n/**                      data in this one variable.      **/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** convert.0newid    \"YES\" or \"NO\" depending on if the  **/\n/**                      ACID is changing in the convert **/\n/** convert.0name     The new ACID to replace real one   **/\n/**                      in the ouput stream             **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.convert  = \"YES\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\nDEBUG.GETDATA  = \"YES\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  /*****************************************************************/\n  /* idebug is a value that can be set in the T$$ execs to turn on */\n  /* a specific debug. U&sually for testing something.             */\n  /*****************************************************************/\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /**         The MAKECUST variable               **/\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command.                       **/\n  /** This would be used if you were moving IDs to**/\n  /** another environment and wanted a certain    **/\n  /** command included in the convert to          **/\n  /** support that environment.                   **/\n  /**                           DIR 25 july 2001  **/\n  /**                                             **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\n  /*************************************************/\n  /** A makeauth command is basically a convert   **/\n  /** with two changes:                           **/\n  /** 1 - The new ID is $$                        **/\n  /** 2 - The tss create command is not done      **/\n  /**                                             **/\n  /*************************************************/\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\nsay \"TSA101D: makeauth check was \" make_rc makeauth\nif make_rc = 0 then do\n  /*************************************************/\n  /** Makeacid is just a type of CLONE really     **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n     /* tells the convert routine to change all outbound ACID */\n  convert.0name = \" $$ \"  /* this is the new ACID name */\n  makeacid.0auth = \"YES\"  /* tell the makeacid routine */\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  /*************************************************/\n  /** a clone is a convert with a new ID plugged  **/\n  /** into the output, so we set some flags and   **/\n  /** then change function to REBUILD.            **/\n  /**                                             **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  /*************************************************/\n  /** We use the makeauth feature to plug in the  **/\n  /** %addlocal command into the output           **/\n  /**                                             **/\n  /*************************************************/\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"ANIDTOTRACE\"              /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Nov 21 2002\"\nsay \"TSA101D: T52ICOMP in control with parms \" function acidlist\nsay \"TSA101D: T52ICOMP Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nsecrc = \"failed in T52ICOMP. no other information available\"\nsecrc = \"failed during jobcard function\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\n  /*****************************************************************/\n  /** A resource function uses an entirely different variable     **/\n  /** loader routine since the input is in a radically different  **/\n  /** format.                                                     **/\n  /**                                                             **/\n  /**                                                             **/\n  /*****************************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    if debug.flow = \"YES\" then\n      say \"TSA101D: calling jobcard function. \"\n    address tso \"%T52jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"TSA101D: Output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 15\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\n/* BYPASS.HOLD.7 = \"* ACID \"  */\n/* commented above due to the need for admin auth to function */\nBYPASS.HOLD.7 = \"* ACIDS\"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9  = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"* TCONS\"\nBYPASS.HOLD.15 = \"* TRBA\"\nBYPASS.HOLD.15 = \"* TUPT\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 10\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"* LASTUSED\"\nBYPASS.HOLD.6  = \"AUTHORITY ACID\"\nBYPASS.HOLD.7  = \"BASE ZONEACID\"\nBYPASS.HOLD.8 = \"* TCONS\"\nBYPASS.HOLD.9 = \"* TRBA\"\nBYPASS.HOLD.10 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\n/*****************************************************************/\n/*****************************************************************/\n/* all variables are initialized.....the main section(s) follow  */\n/*****************************************************************/\n/*****************************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Basic initialization complete, execution begins.\"\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  say \"TSA101D: Resource processing started\"\n  /*****************************************************************/\n  /* Lets either issue the tss list or read in the data from file  */\n  /*****************************************************************/\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  /*****************************************************************/\n  /* I code the two ifs this way because an else when in multiple  */\n  /* loops is confusing...dir                                      */\n  /*****************************************************************/\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"TSA101D: Bypass option specified, allocating input DSN\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      if debug.resource = \"YES\" then\n        say \"Owner = \" acidnum \"name = \" owner\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      /* lets grab the acid */\n      parse var line drop 'ACID(' name ')' drop2\n    /*****************************************************************/\n    /* In resources the ACID with the auth is way to the right on    */\n    /*  the report so we note each of them for future reference      */\n    /*  Note the .name portion of the below variable insures that    */\n    /*  even if one ACID has authorites in multiple areas of the     */\n    /*  output, it is counted only once. The classic variable named  */\n    /*  variable....                                                 */\n    /*****************************************************************/\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\"\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      if debug.resource = \"YES\" then\n        say \"acidnum = \" acidnum \"name = \" name\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"TSA101D: Total acids referenced in input is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"TSA101D: Bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"TSA101D: Total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  acids.0 = words\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    say \"TSA101D: Listing ACID \"hold\" with data \"data \".\"\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we create  the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Evaluation of TSS generated data begins.\"\nevaluate: nop  /* a branch to point for a resource convert */\n/*************************************************/\n/*************************************************/\n/** The below routine does the exact same thing **/\n/** for both resource and standard output, since**/\n/** the variable structure created above is the **/\n/** same for either.                            **/\n/*************************************************/\n/*************************************************/\ndo num = 1 to acidnum\n  /************************************************/\n  /**This outer loop is once for each acid passed**/\n  /** to me. Dave 18 June 99                     **/\n  /************************************************/\n  rules = 0\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"TSA101D: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"         Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    acidrul.name.a1.0concat  = \"NO\"\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if debug.trans = \"YES\" then say line\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    end\n    first11 = substr(line,1,11)\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if debug.trans = \"YES\" then\n        say \"TSA101D:  Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      if debug.trans = \"YES\" then\n       say \"TSA101D: lcf detected:\" w.2\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area input line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n      w.1 = w.1\".\"savefac\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area reformated line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) tzq1\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T52ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n      /*say \"       \"acidath.name.type.resource  */\n      acidrul.name.rules.0concat  = \"YES\"\n /*   say \"Setting concat to yes for record \" rules  */\n      hold1 = acidrul.name.rules.0concat\n      hold = restext(rules)\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: Concat rule \",\n        \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.rules = segment type resource duplicat\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource\n    acidrul.name.rules.0segment = segment\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidrul.name.rules.0restext = \" \"\n    do t1 = 3 to words\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) strip(w.t1)\n    end\n    if debug.trans = \"YES\" then do\n      say \" TSA101D: Type/Rname/Text =\" acidrul.name.rules.0type\"/\",\n      acidrul.name.rules.0resname\"/\",\n      acidrul.name.rules.0restext\n    end\n  end\n  acidrul.name.0 = rules\nend\nif debug.flow = \"YES\" then\n  say \"TSA101D: Translation streams have been built.\",\n  \"Starting function check.\"\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter                                     */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Permit/rebuild/revoke area in control.\"\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do x = 1 to acidnum\n    name = acids.x\n    say \"TSA101D: Starting to process ACID:\" x \">\"name\"<\"\n    say \"          Rules#:\" acidrul.name.0\n    do t = 1 to acidrul.name.0\n      if debug.flow = \"YES\" then\n        say \"TSA101D: Starting to process \"name \" Rule #\" t\n      if debug.name.t = \"TRACE\" then trace r\n      call getdata t\n      hold = next\n      record_number = t\n      call convert function hold\n      trace off\n    end\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = acidrul.name.0\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"TSA101D:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: S found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: D found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n        acidrul.name.y = segment type resource\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: M found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        say \"TSA101D: t=\" t \"thisrec=\" thisrec\n        say \"TSA101D: Subscript is now:\" y\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          say \"TSA101D:\"\n          say \"MODIFY:segment type resource acidath.name.type.resource\"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs\n          setf = setflag(y,'*MODIFY')\n          acidrul.name.y.0concat = \"YES\"\n          acidrul.name.y = segment type rsname\n          acidrul.name.y.0resname  = rsname\n          acidrul.name.y.0restext  = modrule.newrs\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: A found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T52ICOMP:addition routine entered outnum=\" outnum\n        say \"T52ICOMP:addition routine entered target=\" target\n        say \"T52ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T52ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: Calling modrule\"\n        end\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setflag(fill,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        acidrul.name.fill.0segment  = segment\n        acidrul.name.fill.0resname  = rsname\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"TSA101D: leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then\n  say \"acidrul.name array || multiline ? || segment || data \"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nif debug.makeacid = \"YES\" then\n  say \"TSA101D: Making ACID:\" function\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    if debug.makeacid = \"YES\" then\n      say \"TSA101D: Owner resolved to:\" own_str\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  if debug.makeacid = \"YES\" then\n    say \"TSA101D: Makeacid type for \"name\" is :\" acid_type\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif debug.makeacid = \"YES\" then\nsay \"TSA101D: leaving makeacid # output = \"create_num create.1 create.2\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  acidrul. cvtnum concat lcffac debug. convert. record_number\nparse arg function segment inline\nsay \"TSA101D: convert called with \" function segment inline\noname = name\nconcat = acidrul.name.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nif debug.flow = \"YES\" then\n  say \"TSA101D: output name for convert is \" oname \"concat is\" concat\nif debug.flow = \"YES\" then\n  say \"TSA101D: Converting for \"name\":\"function segment \">\"||inline||\"<\"\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XAVOLUME\") then do\n  /*********************************************************/\n  /* a volume generic of (d,g) or (t,g) is invalid so we   */\n  /* handle it here.                                       */\n  /*********************************************************/\n  where_gen = index(inline,\",G)\")\n  if where_gen /= 0 then do\n    if debug.convert = \"YES\" then\n      say \"TSA101D: Vol generic, Input dsn line \"inline\n     parse var inline hz1  ',' hz2\n    inline = hz1||hz2\n    if debug.convert = \"YES\" then\n      say \"TSA101D: Reformatted vol generic line \"inline\n  end\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Input dsn line \"inline\n  inline = \"XADSN\"||substr(inline,10)\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatted dsn line \"inline\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" %giveuid \" oname defgroup\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\n  IF W.1 = \"SCOPEACID\" THEN W.1 = \"SCOPE\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MASTFAC\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif acidrul.name.record_number.0concat = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = acidrul.name.record_number.0concat\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"TSA101D: XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nif debug.convert = \"YES\" then\n  say \"TSA101D: Resource is \"resource \"concat is\" concat\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  if debug.convert = \"YES\" then do\n    rule = bypass.function.rulehold\n    say \"TSA101D: bypass rule tripped, Rule is below:\"\n    say \"     \" Rule\n  end\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then\n  say \"TSA101D:***** CONVERT OUTPUT IS NOW :\" output\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T52ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. acidath. name hex00 aciddup. debug. balance. function balout\nOPT = \" \"\nif debug.fillscr = \"YES\" then\n  say \"TSA101D: Fillscr invoked. Thisrec=\" thisrec\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T52ICOMP: TOP OF DATA REACHED\"\nEND\nh1 = acidrul.name.0 - 13\ntempz1 = acidrul.name.0\n/* save this value for the display below*/\nif debug.fillscr = \"YES\" then\n    say \"TSA101D: h1=\" h1 \"acidrul.\"name\".0=\"  tempz1\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 13\n  MSG = \"T52ICOMP: BOTTOM OF DATA REACHED\"\n  if debug.fillscr = \"YES\" then\n    say \"TSA101D: Bottom of data thisrec set to :\"thisrec\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T52ICOMP: TOP OF DATA REACHED\"\nEND\nif debug.fillscr = \"YES\" then do\n  say \"FILLSCR: thisrec=\" thisrec\n  say \"TSA101D: filling screen:\",\n    \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\nend\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  maxdata = acidrul.name.0\n  if debug.fillscr = \"YES\" then do\n    say \"TSA101D: fillscr calling subfunctions with subscript:\" script\n    say \"         maxdata is:\" maxdata\n  end\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if debug.fillscr = \"YES\" then do\n    say \"TSA101D: fillscr segment=\"segment\n    say \"   type=\"type \"resource=\"resource \"fchk=\"fchk\n  end\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  respass = acidath.name.type.resource\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose acidath. name acidrul. aciddup. next\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. aciddup. next acidlst.\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug. record_number\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsegment  = strip(acidrul.name.t.0segment)\ntype     = strip(acidrul.name.t.0type)\nresource = strip(acidrul.name.t.0resname)\ntheres   = strip(acidrul.name.t.0restext)\ndupchk   = \"\"\ndupnum   = \"\"\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t.0resname\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetdatao: procedure expose acidrul. aciddup. next acidath. name,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsay \"new getdata results:\"\nsay acidrul.name.t.0segment\nsay acidrul.name.t.0type\nsay acidrul.name.t.0resname\nsay acidrul.name.t.0restext\nsay \"*******\"\nsegment  = strip(word(acidrul.name.t,1))\ntype     = strip(word(acidrul.name.t,2))\nresource = strip(word(acidrul.name.t,3))\ndupchk   = strip(word(acidrul.name.t,4))\ndupnum   = strip(word(acidrul.name.t,5))\ntheres = acidath.name.type.resource\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = strip(word(acidrul.name.t,1))\ngetdata.0type     = strip(word(acidrul.name.t,2))\ngetdata.0resource = strip(word(acidrul.name.t,3))\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult  = acidrul.name.tempin.0segment\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult  = acidrul.name.tempin.0type\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult  = acidrul.name.tempin.0resname\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult  = acidrul.name.tempin.0restext\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = acidrul.name.tempin.0flag\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult  = acidrul.name.tempin.0resname\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. acidath. name acidrul. conlist modrule. rstype debug.,\n fill_override balance.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\n/*\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"T52ICOMP: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\nif (thisrec > h1 )  then do\n  thisrec = h1\n  msg = \"T52ICOMP: bottom of data reached\"\nend\n*/\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53ICOMP": {"ttr": 11777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01F\\x00%\\x01\\x02 o\\x01\\x07\\x12\\x8f\\x10\\x12\\x08t\\x08=\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.70", "flags": 0, "createdate": "2002-07-25T00:00:00", "modifydate": "2007-05-08T10:12:25", "lines": 2164, "newlines": 2109, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** Added a lineskip section for lines that can be       **/\n/** totally ignored for conversion and other functions   **/\n/** for the adminby data                   02/13/2007    **/\n/**********************************************************/\n/** changed for 5.3 profile acid conversion              **/\n/** acids are listed differently so the bypass list      **/\n/** parms had to be updated                03/31/2005    **/\n/**********************************************************/\n/**********************************************************/\n/** Updated comments                        7/27/04      **/\n/**********************************************************/\n/** Fixed array load error which would invalidate        **/\n/** converts..                              12/1/03      **/\n/** Very important fix....                               **/\n/**********************************************************/\n/** Fixed MASTFAC syntax on converts         9/17/03     **/\n/**********************************************************/\n/** Fixed volume rules for (D) specification 9/15/03     **/\n/**********************************************************/\n/** updated modrule varname error   Aug 21 2003  DIR     **/\n/**********************************************************/\n/** updated getval routine to return blanks when a var   **/\n/** has not been assigned a value     Aug 5 2003  dir    **/\n/**********************************************************/\n/** created DL subroutine to write log data to           **/\n/** writedebug log  July 2003                            **/\n/**********************************************************/\n/**********************************************************/\n/** Updated allacid. array processing and adding comments**/\n/** Removed the acidrul array                            **/\n/**********************************************************/\n/**********************************************************/\n/** Started conversion to one array instead of one array **/\n/** for each acid instream. nov 22 2002                  **/\n/**********************************************************/\n/**********************************************************/\n/** added convert support for d,g and t,g in volume      **/\n/** rules  dir may 5 2002                                **/\n/**********************************************************/\n/**********************************************************/\n/** changed some doc spelling DIR FEB 22 2002            **/\n/**********************************************************/\n/** Change to modrule routine to totally remove the      **/\n/** scrolling area of that routine... I don't even know  **/\n/** why that section of the routine was there....        **/\n/**                  DIR Novem 05 2001                   **/\n/**********************************************************/\n/**********************************************************/\n/** July 25 2001 - documentation updates                 **/\n/**********************************************************/\n/** Change to debug modify processing to fix errant ptr  **/\n/** Which caused some scrolling to miss records and      **/\n/** caused records selected during modify to be wrongly  **/\n/** selected         DIR april 12 2001                   **/\n/**********************************************************/\n/** Discovered that modify will not support stacked/     **/\n/** owned resources, and that it would be a bear to      **/\n/** fix so I am leaving it alone.                        **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T53ICOMP                          **/\n/** LAST MODIFIED    : 11June  2003                      **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T52JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/**                                                      **/\n/** defgroup = the defgroup OMVS group for invoking the  **/\n/**            %GIVEUID exec.                            **/\n/**                                                      **/\n/** DS1      = work dsn #1 in the SPI system             **/\n/**                                                      **/\n/** DS2      = work dsn #2 in the SPI system             **/\n/**                                                      **/\n/** idebug   = a debug value that can be set to override **/\n/**            debug values in this exec                 **/\n/**                                                      **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/** newpass  = The password value to be used in converts **/\n/**                                                      **/\n/** uidcon   = a value to specify if UIDs are converted  **/\n/**            'as is' or if the %giveuid exec is to be  **/\n/**             used instead.                            **/\n/**            NO =  The GIVEUID exec is issued for a new**/\n/**              UID, unless UID is zero.                **/\n/**            YES = The exact UID will be replicated    **/\n/**              A UID of zero is always be replicated   **/\n/**                                                      **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were passed to me  **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/**********************************************************/\n/** IN the below variables the 'name' area is a variable **/\n/**  which is an actual ACID                             **/\n/**********************************************************/\n/** The acidlst. arrays are the actual output from the   **/\n/**  TSS list command.                                   **/\n/**                                                      **/\n/**  NOTE: The ACIDS. array has one entry for each listed**/\n/**        ACID, it is the source for the name below...  **/\n/**                                                      **/\n/**                                                      **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** The ALLACID array is a sequential array that has one **/\n/** translated rule for each listed ACID                 **/\n/**                                                      **/\n/** Note: This array should be accessed by the SETVAL and**/\n/**       GETVAL functions, not accessed natively in the **/\n/**       main routine.                                  **/\n/**                                                      **/\n/** allacid.0          How many total lines of data      **/\n/** allacid.#.0acid    the acid this line relates to     **/\n/** allacid.#.0type    the type                          **/\n/** allacid.#.0segment the segment                       **/\n/** allacid.#.0resname the resource name                 **/\n/** allacid.#.0restext the resource text                 **/\n/** allacid.#.0concat  is this line to be concatenated   **/\n/**                    to the previous one ? ie part of  **/\n/**                    a multi line permission...        **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                  ARRAY FLOW                          **/\n/**   _______     _______      _______                   **/\n/**  |       |   |       |    |       |                  **/\n/**  | lst1  |   | lst2  |    | lst3  |  acidlst. arrays **/\n/**  |       |   |       |    |       |                  **/\n/**  |_______|   |_______|    |_______|                  **/\n/**      |           |            |                      **/\n/**      |           |            |                      **/\n/**      |___________|____________|                      **/\n/**                  |                                   **/\n/**               _______                                **/\n/**              |       |                               **/\n/**              |       |                               **/\n/**              |  all  |               allacid. array  **/\n/**              |       |                               **/\n/**              |_______|                               **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** In the below variable name and type and resource     **/\n/**   are all variables !!                               **/\n/**********************************************************/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** convert.0newid    \"YES\" or \"NO\" depending on if the  **/\n/**                      ACID is changing in the convert **/\n/** convert.0name     The new ACID to replace real one   **/\n/**                      in the ouput stream             **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.convert  = \"NO\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\nDEBUG.GETDATA  = \"NO\"\nDEBUG.setval   = \"NO\"\nDEBUG.getval   = \"NO\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget instcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  /*****************************************************************/\n  /* idebug is a value that can be set in the T$$ execs to turn on */\n  /* a specific debug. Usually for testing something.              */\n  /*****************************************************************/\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /**         The MAKECUST variable               **/\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command.                       **/\n  /** This would be used if you were moving IDs to**/\n  /** another environment and wanted a certain    **/\n  /** command included in the convert to          **/\n  /** support that environment.                   **/\n  /**                           DIR 25 july 2001  **/\n  /**                                             **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\n  /*************************************************/\n  /** A makeauth command is basically a convert   **/\n  /** with two changes:                           **/\n  /** 1 - The new ID is $$                        **/\n  /** 2 - The tss create command is not done      **/\n  /**                                             **/\n  /*************************************************/\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\n/*\nsay \"TSA101D: makeauth check was \" make_rc makeauth\n*/\nq=dl(,,\"makeauth check was \" make_rc makeauth)\nif make_rc = 0 then do\n  /*************************************************/\n  /** Makeacid is just a type of CLONE really     **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n     /* tells the convert routine to change all outbound ACID */\n  convert.0name = \" $$ \"  /* this is the new ACID name */\n  makeacid.0auth = \"YES\"  /* tell the makeacid routine */\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  /*************************************************/\n  /** a clone is a convert with a new ID plugged  **/\n  /** into the output, so we set some flags and   **/\n  /** then change function to REBUILD.            **/\n  /**                                             **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  /*************************************************/\n  /** We use the makeauth feature to plug in the  **/\n  /** %addlocal command into the output           **/\n  /**                                             **/\n  /*************************************************/\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"AN_ID_TO_TRACE\"            /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Dec 30 2003\"\nq=dl(,,\"T53ICOMP in control with parms \" function acidlist)\nq=dl(,,\" T53ICOMP Maint = \" maint)\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nsecrc = \"failed in T53ICOMP. no other information available\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\n  /*****************************************************************/\n  /** A resource function uses an entirely different variable     **/\n  /** loader routine since the input is in a radically different  **/\n  /** format.                                                     **/\n  /**                                                             **/\n  /**                                                             **/\n  /*****************************************************************/\nq=dl(,,\" Retrieving profile variables \")\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nsecrc = \"failed during jobcard function\"\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    q=dl(,,\" calling jobcard function. \" )\n    address tso \"%T52jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  q=dl(,,\" Output DSN unusable, data written to screen \")\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\nsecrc = \"failed in T53ICOMP. no other information available\"\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* The following words in position 1 cause the entire   */\n/* line to be skipped                                   */\n/********************************************************/\nlineskip.0 = 2\nlineskip.1 = \"TSS0300I\"\nlineskip.2 = \"ADMIN\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 13\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\nBYPASS.0SUPRESS.HOLD.13 = \"ACID\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 6\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nBYPASS.0SUPRESS.HOLD.6 = \"ADMINBY\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 17\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\n/* BYPASS.HOLD.7 = \"* ACID \"  */\n/* commented above due to the need for admin auth to function */\nBYPASS.HOLD.7 = \"xxxx ACID \"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9  = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"* TCONS\"\nBYPASS.HOLD.15 = \"* TRBA\"\nBYPASS.HOLD.16 = \"* TUPT\"\nBYPASS.HOLD.17 = \"* ADMIN\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 12\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"BASE DIVACID\"\nBYPASS.HOLD.5 = \"BASE ZONEACID\"\nBYPASS.HOLD.6 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.7 = \"* LASTUSED\"\nBYPASS.HOLD.8  = \"AUTHORITY ACID\"\nBYPASS.HOLD.9  = \"BASE ZONEACID\"\nBYPASS.HOLD.10= \"* TCONS\"\nBYPASS.HOLD.11= \"* TRBA\"\nBYPASS.HOLD.12 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\n/*****************************************************************/\n/*****************************************************************/\n/* all variables are initialized.....the main section(s) follow  */\n/*****************************************************************/\n/*****************************************************************/\nq=dl(,,\" Basic initialization complete, execution begins.\")\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  q=dl(,,\" Resource processing started\")\n  /*****************************************************************/\n  /* Lets either issue the tss list or read in the data from file  */\n  /*****************************************************************/\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  /*****************************************************************/\n  /* I code the two ifs this way because an else when in multiple  */\n  /* loops is confusing...dir                                      */\n  /*****************************************************************/\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    q=dl(,,\" Bypass option specified, allocating input DSN\")\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n                           /* below we save the starting line #  */\n                           /* of each acid.. not sure why        */\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      q=dl(,\"RESOURCE\",\"owner = \" acidnum \"name = \" owner )\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      /* lets grab the acid */\n      parse var line drop 'ACID(' name ')' drop2\n    /*****************************************************************/\n    /* In resources the ACID with the auth is way to the right on    */\n    /*  the report so we note each of them for future reference      */\n    /*  Note the .name portion of the below variable insures that    */\n    /*  even if one ACID has authorites in multiple areas of the     */\n    /*  output, it is counted only once. The classic variable named  */\n    /*  variable....                                                 */\n    /*****************************************************************/\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\" /* actually any non  NO value works */\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      q=dl(,resource,\"acidnum = \" acidnum \"name = \" name )\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    q=dl(,,\" Total acids referenced in input is \" acidnum )\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  q=dl(\"tsa101d\",,\" Bypass option specified, allocating input dsn\")\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  q=dl(\"tsa101d\",,\" Total acids contained in input DSN is \" acidnum)\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n    /* each acid receives its own list area.. should be one */\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    q=dl(\"tsa101d\",,\" Listing ACID \"hold\" with data \"data \".\" )\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we create  the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nq=dl(\"tsa101d\",,\" Evaluation of TSS generated data begins.\" )\nevaluate: nop  /* a branch to point for a resource convert */\n/*************************************************/\n/*************************************************/\n/** The below routine does the exact same thing **/\n/** for both resource and standard output, since**/\n/** the variable structure created above is the **/\n/** same for either.                            **/\n/*************************************************/\n/*************************************************/\nlinenum = 0\nlinehold= 0\nif debug.flow = \"YES\" then do\n  say \"TSA101D Evaluate routine in control values as follows:\"\n  say \"acidnum:  \" acidnum\n  say \"accessor.0\" accessor.0\n  say \"accessor.1\" accessor.1\nend\nrules = 0\ndo num = 1 to acidnum\n  /************************************************/\n  /**This outer loop is once for each acid passed**/\n  /** to me. Dave 18 June 99                     **/\n  /************************************************/\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"tsa101d: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"        Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  q=dl(\"tsa101d\",,\" Acidlst.\"name\".0 is\" acidlst.name.0)\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    /* */\n    /* the below statements just clear the variables... */\n    setf = setval(rules,0flag,hex00)\n/*  acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0concat  = \"NO\"\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    setf = setval(rules,0restext,\" \")\n    setf = setval(rules,0type,\" \")\n    setf = setval(rules,0segment,\" \")\n    setf = setval(rules,0concat,\"NO\")\n    setf = setval(rules,0resname,\" \") */\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if debug.trans = \"YES\" then do\n      say \"TSA101D: Translation starting for below data:\"\n      say \"         \"line\n    end\n    do skipit = 1 to lineskip.0\n      if word(line,1) = lineskip.skipit then iterate a1\n    end\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    /*acidrul.name.a1.0concat  = \"YES\" */\n      setf = setval(rules,0concat,\"YES\")\n    end\n    first11 = substr(line,1,11)\n    /* below we take 2 words and make one for first 11 */\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"INSTDATA\" then do\n      segment = \"INSTDATA\"\n      q=dl(\"tsa101d\",TRANS,\" Segment changed to \"segment \"for \" name)\n    end\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      q=dl(\"tsa101d\",TRANS,\" Segment changed to \"segment \"for \" name)\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      q=dl(\"tsa101d\",trans,\" lcf detected:\" w.2)\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      q=dl(\"tsa101d\",trans,\" lcf area input line:\",\n      w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8)\n      w.1 = w.1\".\"savefac\n      q=dl(\"tsa101d\",trans,\" lcf area reformated line:\",\n      w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8)\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then linehold = linehold - 1\n    if linehold < 0 then linehold = 0\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = getval(rules,0restext)\n/*    acidrul.name.rules.0restext = strip(hold) tzq1 */\n      setv = setval(rules,0restext,strip(hold) tzq1)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T53ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n /*   acidrul.name.rules.0concat  = \"YES\" */\n      setf = setval(rules,0concat,\"YES\")\n /*   say \"Setting concat to yes for record \" rules  */\n /*   hold1 = acidrul.name.rules.0concat */\n      hold = restext(rules)\n      q=dl(\"tsa101d\",trans,\" Concat rule \",\n      \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold)\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n/*  acidrul.name.a1.0concat  = \"NO\"  */\n    setf = setval(rules,0ACID,name)\n    setf = setval(rules,0concat,\"NO\")\n/*  acidrul.name.rules = segment type resource\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource */\n    setf = setval(rules,\"RESET\",segment type resource)\n    setf = setval(rules,0segment,segment)\n    setf = setval(rules,0type,type)\n    setf = setval(rules,0resname,resource)\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n/*  acidrul.name.rules.0restext = \" \"  */\n    Setf = setval(rules,0restext,\" \")\n    do t1 = 3 to words\n      hold = getval(rules,0restext)\n/*    acidrul.name.rules.0restext = strip(hold) strip(w.t1)  */\n      setf = setval(rules,0restext,strip(hold) strip(w.t1))\n    end\n      q=dl(\"tsa101d\",trans,\" Type/Rname/Text =\" getval(rules,0type) \"/\",\n      getval(rules,0resname)\"/\",\n      getval(rules,0restext) )\n  end\n  /* acidrul.name.0 = rules */\n  linenum = linenum + rules\nend\nq=dl(\"Total lines of translated data is:\" linenum )\nallacid.0 = rules\nq=dl(\"tsa101d\",,\" Translation streams have been built.\",\n  \"Starting function check.\")\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter, or we did a translate function.    */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  q=dl(\"tsa101d\",,\" Permit/rebuild/revoke area in control.\")\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do t = 1 to allacid.0\n    q=dl(\"tsa101d\",,\" Starting to process LINE #\" t )\n    call getadata t\n    hold = next\n    record_number = t\n    name = allacid.t.0acid\n    q=dl(\"tsa101d\",,\" acid recnum next\" name record_number hold)\n    call convert function hold\n    trace off\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = linenum\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  q=dl(\"tsa101d\",,\" MODIFY starting to process ACID:\" name )\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    /* thisrec is the rec at the top of the screen */\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt /* scan the screen for an option */\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" S found on line\" t )\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        q=dl(\"tsa101d\",modify,\" D found on line\" t)\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n     /* acidrul.name.y = segment type resource */\n        setf = setval(y,\"RESET\",segment type resource,)\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" M found on line\" t )\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        q=dl(\"tsa101d\",\"MODIFY\",\" t=\" t \"thisrec=\" thisrec )\n        q=dl(\"tsa101d\",\"MODIFY\",\" Subscript is now:\" y )\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          SAY  \"TSA101D:\"\n          say \"MODIFY:segment type resource \"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          /* modrule creates the variable conlist     */\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs\n          setf = setflag(y,'*MODIFY')\n          /* */\n          setf = setval(y,0concat,\"YES\")\n        /*acidrul.name.y.0concat = \"YES\"\n          acidrul.name.y = segment type rsname  */\n          setf = setval(y,\"RESET\",segment type rsname,)\n          /*\n          acidrul.name.y.0resname  = rsname\n          */\n          setf = setval(y,0resname,rsname)\n          /*\n          acidrul.name.y.0restext  = modrule.newrs\n          */\n          setf = setval(y,0restext,modrule.newrs)\n          /* */\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          q=dl(\"tsa101d\",,\" secure routine failed access \")\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" A found on line\" t)\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T53ICOMP:addition routine entered outnum=\" outnum\n        say \"T53ICOMP:addition routine entered target=\" target\n        say \"T53ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T53ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          /*** zzzzebra **/\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          f = setval(q,0segment,getval(q1,0segment))\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          f = setval(q,0flag,getval(q1,0flag))\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          f = setval(q,0type,getval(q1,0type))\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          f = setval(q,0restext,getval(q1,0restext))\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n          f = setval(q,0resname,getval(q1,0resname))\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        q=dl(\"tsa101d\",\"MODIFY\",\" Calling modrule\")\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setval(fill,0concat,\"YES\")\n        setit = setflag(fill,\"*NEWRULE\")\n        setit = setval(fill,0flag,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        setit = setval(fill,0type,type)\n        acidrul.name.fill.0segment  = segment\n        setit = setval(fill,0segment,segment)\n        acidrul.name.fill.0resname  = rsname\n        setit = setval(fill,0resname,rsname)\n        acidrul.name.fill.0restext  = modrule.newrs\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  q=dl(\"tsa101d\",,\" leaving modify\")\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\n/*\nif function = \"TRANSLATE\" then\n  say \"acidrul.name array || multiline ? || segment || data \"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\n*/\nif function = \"TRANSLATE\" then do qt = 1 to allacid.0\n    say qt allacid.qt.0ACID,\n         allacid.qt allacid.qt.0restext\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nq=dl(\"tsa101d\",\"MAKEACID\",\" Making ACID:\" function )\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    q=dl(\"tsa101d\",\"MAKEACID\", \"makacid resolved to:\" own_str )\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  q=dl(\"tsa101d\",\"MAKEACID\",\" Makeacid type for \"name\" is :\" acid_type)\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nq=dl(\"tsa101d\",,\n\"makeacid\",\"leaving ma # out = \"create_num create.1 create.2)\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  instcon,\n  acidrul. cvtnum concat lcffac debug. convert. record_number allacid.\nparse arg function segment inline\nq=dl(\"tsa101d\",,\" convert called with \" function segment inline)\nname = getval(record_number,0acid)\noname = name\nq=dl(\"tsa101d\",,\" Output ACID name: \" oname)\nconcat = getval(record_number,0concat)\nif debug.newgdata = \"YES\" then concat = allacid.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nq=dl(\"tsa101d\",,\" Outname for con is \" oname \"concat is\" concat  )\nq=dl(\"tsa101d\",,\" Confor \"name\":\"function segment \">\"||inline||\"<\" )\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XAVOLUME\") then do\n  /*********************************************************/\n  /* a volume generic of (d,g) or (t,g) is invalid so we   */\n  /* handle it here.                                       */\n  /*********************************************************/\n  where_gen = index(inline,\",G)\")\n  if where_gen /= 0 then do\n    q=dl(\"tsa101d\",convert,\" Vol generic, Input dsn line \"inline )\n     parse var inline hz1  ',' hz2\n    inline = hz1||hz2\n    q=dl(\"tsa101d\",convert,\" Reformatted vol generic line \"inline)\n  end\n  where_gen = index(inline,\"(D)\")\n  if where_gen /= 0 then do\n    q=dl(\"tsa101d\",convert,\" Disk ref, Input dsn line \"inline )\n     parse var inline hz1  '(D)' hz2\n    inline = strip(hz1,t)||'(D)' hz2\n    q=dl(\"tsa101d\",convert,\" Reformatted Disk line \"inline)\n  end\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  q=dl(\"tsa101d\",convert,\" Input dsn line \"inline )\n  inline = \"XADSN\"||substr(inline,10)\n  q=dl(\"tsa101d\",convert,\" Reformatted dsn line \"inline)\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  q=dl(\"tsa101d\",convert,\" Reformat area completed convert. returning.\")\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  if instcon = \"NO\" then hold = \"000000\"\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  q=dl(\"tsa101d\",convert,\" Reformat area done convert. returning.\")\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" %giveuid \" oname defgroup\n  q=dl(\"tsa101d\",convert,\" Reformat area done convert. returning.\")\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\n  IF W.1 = \"SCOPEACID\" THEN W.1 = \"SCOPE\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MASTFAC\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif getval(record_number,0concat) = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = getval(record_number,0concat)\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"tsa101d XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nq=dl(\"tsa101d\",convert,\" Resource is \"resource \"concat is\" concat )\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n    q=dl(\"tsa101d\",\"CONVERT\",\" bypass rule tripped, Rule is below:\")\n    q=dl(\"tsa101d\",\"CONVERT\",bypass.function.rulehold)\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REM\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then do\n  say \"tsa101d: ***** CONVERT OUTPUT IS NOW :\"\n  say \"  \" output\nend\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T53ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. allacid. name hex00 debug. linenum function balout\nOPT = \" \"\nq=dl(\"tsa101d\",fillscr,\" Fillscr invoked. Thisrec=\" thisrec )\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T53ICOMP: TOP OF DATA REACHED\"\nEND\nh1 = linenum - 13\ntempz1 = linenum\n/* save this value for the display below*/\nq=dl(\"tsa101d\",\"FILLSCR\",\" h1=\" h1 \"acidrul.\"name\".0=\" tempz1 )\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 13\n  MSG = \"T53ICOMP: BOTTOM OF DATA REACHED\"\n  q=dl(\"tsa101d\",FILLSCR,\" Bottom of data thisrec set to :\"thisrec)\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T53ICOMP: TOP OF DATA REACHED\"\nEND\nif debug.fillscr = \"YES\" then do\n  say \"FILLSCR: thisrec=\" thisrec\n  say \"tsa101d     filling screen:\",\n    \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\nend\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  maxdata = acidrul.name.0\n  q=dl(\"tsa101d\",fillscr,\"fillscr calling with subscript:\" script)\n  q=dl(\"tsa101d\",fillscr,\"maxdata is:\"imaxdata )\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if debug.fillscr = \"YES\" then do\n    say \"tsa101d fillscr segment=\"segment\n    say \"   type=\"type \"resource=\"resource \"fchk=\"fchk\n  end\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose name acidrul. next allacid.\nq=dl(\"tsa101d\",,\" Dumping allacid array\")\ndo qt = 1 to allacid.0\n    say qt allacid.qt.0ACID,\n         allacid.qt allacid.qt.0restext\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. next acidlst.\nq=dl(\"tsa101d\",,\" Dumping acidlst array for \" name )\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetadata: procedure expose allacid. name next,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nt = record_number\nif debug.getdata = \"YES\" then do\n  say \"tsa101d Getadata invoked with:\" record_number\n  say \"New Getadata results:\"\n  say \"t=\"allacid.t\n  say \"acid=\"allacid.t.0acid\n  say \"segment=\"allacid.t.0segment\n  say \"type=\"allacid.t.0type\n  say \"resname=\"allacid.t.0resname\n  say \"restext=\"allacid.t.0restext\n  say \"*******\"\nend\ndebug.newgdata = \"YES\"\nsegment  = strip(allacid.t.0segment)\ntype     = strip(allacid.t.0type)\nresource = strip(allacid.t.0resname)\ntheres   = strip(allacid.t.0restext)\nif debug.Getdata = \"YES\" then do\n  say \"TSA101D: Getadata base resource:\" allacid.t\n  say \"TSA101D: Getadata resource data:\" theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult = getval(tempin,0segment)\n/* say \"Segment returning\" result */\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\n/*******************************************************/\n/*******************************************************/\n/**Gets the access from a string parens must be gone  **/\n/**prior to invocation.                               **/\n/*******************************************************/\n/*******************************************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult = getval(tempin,0type)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult = getval(tempin,0restext)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nsetv = setval(tempin,0flag,theflag)\nreturn 0\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\ngetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**Gets the allacid array variable specified.         **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nresult = allacid.record.varname\nif substr(result,1,8) = \"ALLACID.\" then result = \"\"\nif debug.getval = \"YES\" then\n  say \"GETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"is\" result\nreturn result\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\nsetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**sets the allacid array variable to specified value **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nnewvalue= arg(3)\nif debug.setval = \"YES\" then\n  say \"SETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"to\" newvalue\nallacid.record.varname = newvalue\nif varname = \"RESET\" then\nallacid.record  = newvalue\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ndl: NOP\n/**********************************************************/\n/** This routine checks to see if the debug flag is set  **/\n/** for a certain routine, and if it is issues the given **/\n/** msg to the log. It enables me to not have an if every**/\n/** time I want to write a msg          July 2003        **/\n/**********************************************************/\nmsgid  = arg(1)\nfield  = arg(2)\nthemsg = arg(3)\nupper msgid field\nD.1 = \"FLOW\"\nD.2 = \"MULTCON\"\nD.3 = \"CONVERT\"\nD.4 = \"MAKEACID\"\nD.5 = \"MODIFY\"\nD.6 = \"GETDATA\"\nD.7 = \"FILLSCR\"\nD.8 = \"MODRULE\"\nD.9 = \"RESOURCE\"\nD.10= \"TRANS\"\nd.0 = 10\nif msgid = \"\" then msgid = \"TSA101D\"\nif field = \"\" then field = \"FLOW\"\nfchk = \"BAD\"\ndo ck = 1 to d.0\n  if field = d.ck then fchk = \"OK\"\nend\nif fchk = \"BAD\" then do\n  say \"********************\"\n  say \"********************\"\n  say \"********************\"\n  say \"**debuglog routine invoked with :\" field\n  say \"********************\"\n  say \"********************\"\n  say \"********************\"\nend\nif debug.field = \"YES\" then do\n  outmsg = msgid\"*\"themsg\n  if length(outmsg) > 80 then do\n    outmsg2 = substr(outmsg,81)\n    outmsg = substr(outmsg,1,80)\n    say outmsg\n    say \"       * \"outmsg2\n  end\n  else say outmsg\nend\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = getval(tempin,0flag)\n/* say \"getflag: \" res */\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. name acidrul. conlist modrule. rstype debug.,\n fill_override allacid.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53IDAT": {"ttr": 12036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x009\\x01\\x04\\t?\\x01\\x07\\x12\\x8f\\x10Y\\x01/\\x01\\x19\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2007-05-08T10:59:39", "lines": 303, "newlines": 281, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T53IDAT                           **/\n/** LAST MODIFIED    :  3 4 2004                         **/\n/**********************************************************/\n/** Update the INSTDATA of an individual ACID            **/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/**                                                      **/\n/**                                                      **/\n/**  Detailed return code:                               **/\n/**                                                      **/\n/**  _____Data Retrieval Status                          **/\n/** |                                                    **/\n/** |_____ID Status                                      **/\n/** ||                                                   **/\n/** ||____Previous INSTDATA state                        **/\n/** |||                                                  **/\n/** |||___Action Taken                                   **/\n/** ||||                                                 **/\n/** 0...- Data retrieval worked                          **/\n/** 1...- No such ID                                     **/\n/** 2...- Not authorized for this ID                     **/\n/** 4...- TSS retrieval error                            **/\n/** 8...- Unknown invocation code                        **/\n/**                                                      **/\n/** .0..- ID has no unusual attributes                   **/\n/** .1..- ID is currently Suspended                      **/\n/** .2..- ID is currently Asuspended                     **/\n/** .4..- ID is currently Expired **future enhancement** **/\n/** .8..- ID has special attributes                      **/\n/**                                                      **/\n/** ..0.- Instdata had valid data                        **/\n/** ..1.- Instdata had no previous instdata              **/\n/** ..2.- Instdata had special code                      **/\n/** ..4.- Instdata had invalid data                      **/\n/** ..8.- Instdata had pending suspend                   **/\n/**                                                      **/\n/** ...0- Instdata updated                               **/\n/** ...1- Instdata provided enum invalid                 **/\n/** ...2- Not used                                       **/\n/** ...4- Instdata not updated due to data retreival     **/\n/**       Failure                                        **/\n/** ...8- Instdata not updated due to failed TSS command **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** Current fields for instdata code                     **/\n/**                                                      **/\n/** Initial    - Value created by the TxxIDAT routine at **/\n/**              addition time                           **/\n/**                                                      **/\n/** Replace    - Value updated by the TxxIDAT routine at **/\n/**              request of administrator                **/\n/**                                                      **/\n/** Tosuspend  - Value set by automatic process,         **/\n/**              indicates the ID is to be suspended     **/\n/**              the next time the auto process is run.  **/\n/**                                                      **/\n/** Suspend    - Value set by automatic process,         **/\n/**              indicates the ID was      suspended     **/\n/**              by the automatic process.               **/\n/**                                                      **/\n/** Asuspend   - Value set by txxIDAT as a result of     **/\n/**              an administrator request.               **/\n/**                                                      **/\n/** Reset      - Value was reset as result of an         **/\n/**              administrator request.                  **/\n/**                                                      **/\n/** SYSTEMS    - A SPECIAL BYPASS VALUE NOT TO BE UPDATED**/\n/**                                                      **/\n/** CONSULT    - A SPECIAL BYPASS VALUE NOT TO BE UPDATED**/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T53GDAT             **/\n/**********************************************************/\ngood_msg = \"Completed successfully. DRC is:\"\nwarn_msg = \"Completed with warning. DRC is:\"\nfail_msg = \"Update Failed. DRC is:\"\nnew_trail = \"\"\nSPECIAL.SYSTEMS = \"YES\"\nSPECIAL.CONSULT = \"YES\"\nSPECIAL.BYPASS  = \"YES\"\naddress ispexec vget idat\n/* IDAT = \"'SYS4.SPI.IDATPARM(GOODIDAT)'\"  */\n\"ALLOC DDN(IDATparm) DSN(\"idat\") SHR REUS\"\n\"EXECIO * DISKR IDATPARM ( FINIS STEM HOLD.)\"\n\"FREE DDN(IDATPARM)\"\nCODE. = \"$$BADCODE$\"\n/*\nQ = TCODE(\"SUSPEND\",\"ASUSPEND\")\nQ = TCODE(\"INSTDATA\",\"REPLACE\")\nQ = TCODE(\"UNSUSPEND\",\"RESET\")\nQ = TCODE(\"ADD\",\"INITIAL\") */\n/* the gcode routine defines a code as valid */\n/* the tcode routine defines a translate code */\n/*************************************************************/\n/* Below we map an invocation value to an output value to be */\n/* placed into INSTDATA.                                     */\n/* All output codes below should be defined as valid codes   */\n/* with the gcode routine earlier.                           */\n/*************************************************************/\ndo w = 1 to hold.0\n  line = substr(hold.w,1,80)\n  w1 = strip(word(line,1))\n  w2 = strip(word(line,2))\n  Q = GCODE(w2) /*define word2 as a valid non numerical value */\n  if w1 /= \".\" then\n    Q = TCODE(w1,w2) /* define invocation/resultant values */\nend\n/*\nQ = GCODE(\"CONSULT\")\nQ = GCODE(\"SYSTEMS\")\nQ = GCODE(\"INITIAL\")\nQ = GCODE(\"REPLACE\")\nQ = GCODE(\"TOSUSPEND\")\nQ = GCODE(\"SUSPEND\")\nQ = GCODE(\"ASUSPEND\")\nQ = GCODE(\"RESET\")\n*/\noutcode = 0\nARG ACID function newidata\nfunction = strip(function)\nsay \"T53IDAT invoked with :\" function newidata\n/************************************************************/\n/** Lets get all the ACID data we will need                **/\n/************************************************************/\nADDRESS tso \"%T53GDAT \" ACID \" INSTDATA INSTDATA\"\nADDRESS ISPEXEC \"vget secrc profile\"\nsay \"gdat idata is :\" secrc\ncurrent_idata = secrc\nADDRESS tso \"%T53GDAT \" ACID \" ATTRIBUTES BASIC\"\nADDRESS ISPEXEC \"vget secrc profile\"\nsay \"gdat attr is :\" secrc\nIF SECRC = \"$NOTFOUND\" THEN SECRC = \" \"\ncurrent_attr = secrc\n/************************************************************/\n/**                                                        **/\n/************************************************************/\n/************************************************************/\n/** lets get 1st byte of Detailed Return Code  DRC         **/\n/************************************************************/\noutcode = outcode + acode(current_attr)\nnew_code = code.function\n/************************************************************/\n/** lets get 2nd byte of DRC                               **/\n/************************************************************/\nsay \"T53IDAT: current Idata:\" current_idata\nif current_idata = \"$BADTSS\" then outcode = outcode + 4000\nif current_idata = \"$BADAUTH\" then outcode = outcode + 2000\nif current_idata = \"$BADACID\" then outcode = outcode + 1000\nif current_idata = \"$BADACID\" then current_idata = \" \"\nif New_code = \"$$BADCODE$\" then outcode = outcode + 8000\n/************************************************************/\n/** lets get 3rd byte of DRC                               **/\n/************************************************************/\noutcode = outcode + icode(current_idata)\ncurrent_enum = word(current_idata,1)\nnew_enum = current_enum\ncurrent_code = word(current_idata,2)\nnew_code = current_code\ncurrent_trail = substr(current_idata                                ,21)\nnew_trail = current_trail\nSelect\n  when function= \"UNSUSPEND\" then do\n    new_enum  = current_enum\n    new_trail = current_trail\n    new_code  = code.function\n  end\n  when function= \"ADD\" then do\n    new_enum  = substr(newidata,1,10)\n    new_code  = code.function\n  end\n  when function= \"SUSPEND\" then do\n    new_enum  = current_enum\n    new_code  = code.function\n  end\n  when function= \"INSTDATA\" then do\n    new_enum  = substr(newidata                 ,1,10)\n    new_code  = code.function\n  end\n  otherwise secrc = \"Failed. Unmapped invocation code\" function\n            address ispexec \"vput secrc profile\"\n            say secrc\nEnd\nif special.current_code = \"YES\" then new_code = current_code\nif special.current_code = \"YES\" then new_code = current_code\nsay \"T53IDAT: back from GDAT with:\" secrc\nsay \"  Current enum :\" current_enum\nsay \"  Current code :\" current_code\nsay \"  Current trail:\" current_trail\nsay \"****************\"\nsay \"  New enum :\" new_enum\nsay \"  New code :\" new_code\nsay \"  New trail:\" new_trail\n/************************************************************/\n/** lets get 4th byte of DRC                               **/\n/************************************************************/\nnew_enum = substr(new_enum                 ,1,10)\nnew_code = substr(new_code                 ,1,10)\nnew_idata = new_enum||new_code||new_trail\nif new_enum > 99999 then outcode = outcode + 1\nif new_enum < 1 then outcode = outcode + 1\n/************************************************************/\n/** A code > 1000 indicates a data get error from GDAT     **/\n/************************************************************/\nsecrc = good_msg outcode\nif outcode < 1000 then do\n  say \"TSS REP(\"acid\") instdata('\"new_idata\"')\"\n  tss_rcode = rc\n  address tso\n  \"TSS REP(\"acid\") instdata('\"new_idata\"')\"\nend\nelse do\n  outcode = outcode + 4\n  secrc = fail_msg outcode\nend\nif tss_rcode > 0 then do\n  outcode = outcode + 8\n  secrc = fail_msg outcode\nend\nsay \"T53IDAT invoked:\" newidata function\nsay \"  DRC is \" outcode\nif outcode /10 <> outcode%10 then do\n  remain = outcode//10\n  if remain < 6 then secrc = warn_msg outcode\nend\nsay \"/**  Detailed return code:                               **/\"\nsay \"/**                                                      **/\"\nsay \"/**  _____Data Retrieval Status                          **/\"\nsay \"/** |                                                    **/\"\nsay \"/** |_____ID Status                                      **/\"\nsay \"/** ||                                                   **/\"\nsay \"/** ||____Previous INSTDATA state                        **/\"\nsay \"/** |||                                                  **/\"\nsay \"/** |||___Action Taken                                   **/\"\nsay \"/** ||||                                                 **/\"\nsay \"/** 0...- Data retrieval worked                          **/\"\nsay \"/** 1...- No such ID                                     **/\"\nsay \"/** 2...- Not authorized for this ID                     **/\"\nsay \"/** 4...- TSS retrieval error                            **/\"\nsay \"/** 8...- Unknown invocation code                        **/\"\nsay \"/**                                                      **/\"\nsay \"/** .0..- ID has no unusual attributes                   **/\"\nsay \"/** .1..- ID is currently Suspended                      **/\"\nsay \"/** .2..- ID is currently Asuspended                     **/\"\nsay \"/** .4..- ID is currently Expired                        **/\"\nsay \"/** .8..- ID has special attributes                      **/\"\nsay \"/**                                                      **/\"\nsay \"/** ..0.- Instdata had valid data                        **/\"\nsay \"/** ..1.- Instdata had no previous instdata              **/\"\nsay \"/** ..2.- Instdata had special code                      **/\"\nsay \"/** ..4.- Instdata had invalid data                      **/\"\nsay \"/** ..8.- Instdata had pending suspend                   **/\"\nsay \"/**                                                      **/\"\nsay \"/** ...0- Instdata updated                               **/\"\nsay \"/** ...1- Instdata provided enum invalid                 **/\"\nsay \"/** ...2- Not used                                       **/\"\nsay \"/** ...4- Not used                                       **/\"\nsay \"/** ...6- Instdata not updated due to data retreival     **/\"\nsay \"/**       Failure                                        **/\"\nsay \"/** ...8- Instdata not updated due to failed TSS command **/\"\nADDRESS ISPEXEC \"vput secrc profile\"\nexit outcode\n/***************************/\ngcode: nop\narg indat\ngoodcode.indat = \"YES\"\nreturn 0\n/***************************/\ntcode: nop\nindat = arg(1)\nindat2 = arg(2)\ncode.indat = indat2\nreturn 0\n/***************************/\nacode: nop\narg indat\nif index(indat,\"SUSPEND\") > 0 then outcode = outcode + 100\nif index(indat,\"ASUSPEND\") >0  then outcode = 200\nif index(indat,\"CONSOLE\") > 0 then outcode = outcode + 800\nif index(indat,\"NO\") > 0 then outcode = outcode + 800\nreturn outcode\n/***************************/\nicode: nop\narg idat\nsay \"icode invoked with:\" idat\noutcode = 0\nc_enum = word(idat,1)\nc_code = word(idat,2)\nc_trail = substr(idat                                ,21)\nif (datatype(strip(c_enum)) /= \"NUM\") & (idat /= \" \" ) then\n  outcode = outcode + 40\nif idat = \" \" then outcode = outcode + 10\nif idat = \"TOSUSPEND\" then outcode = outcode + 80\nif special.c_code = \"YES\" then outcode = outcode + 20\nreturn outcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53INS": {"ttr": 10243, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00)\\x00\\x955/\\x01\\x03%\\x9f\\t9\\x00\\xcf\\x00\\xcf\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2003-09-16T09:39:29", "lines": 207, "newlines": 207, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T52INS                            **/\n/** LAST MODIFIED    :  9 dec 99                         **/\n/**********************************************************/\n/** NOW ACCEPTS MULTIPLE PROFS IN STD INVOCATION         **/\n/**********************************************************/\n/** CHANGED CODE TO FIX ERROR FOR INSERTS AT POSITION    **/\n/** GREATER THAN 1 WHEN ID HAS NO PROFILES    ....DR     **/\n/**********************************************************/\n/** REVAMPED TO USE THE AFTER KEYWORD OF INSERT COMMAND  **/\n/** SHOULD BE LOTS FASTER AND EASIER TO MANAGE....DR     **/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         EXITPRM                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T52FDIV %T52GDAT    **/\n/**********************************************************/\nARG ACID PROFILE TARGET DAYS\n/************************************************************/\n/** PATCH BELOW FOR NORMAL INVOCATION FOR MULTIPLE PROFILES */\n/************************************************************/\nif target = \" \" then target = 1\nTEMP = PROFILE TARGET DAYS\nPROFS = 0\nPARSE VAR TEMP TW.1 TW.2 TW.3 TW.4 TW.5 TW.6 TW.7 TW.8 TW.9 TW.10\nALLWORDS = WORDS(TEMP)\nIF (ALLWORDS = 3) & ( DATATYPE(TW.2) = \"CHAR\" ) THEN do\n  PROFILE = TW.1||\".\"||TW.2\n  TARGET = DAYS\n  DAYS = \"\"\n  say \"TSA101D: T52INS reformatted input is :\" acid profile target days\nEND\nIF ALLWORDS > 3 THEN DO\n  DO COUNT = 1 TO ALLWORDS\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN PROFS = COUNT - 1\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN LEAVE\n  END\n  PROFILE = \"\"\n  DO CNT2 = 1 TO PROFS\n    PROFILE = PROFILE||\".\"||TW.CNT2\n  END\n  TARGET_WORD = PROFS + 1\n  DAYS_WORD = PROFS + 2\n  TARGET = WORD(TEMP,TARGET_WORD)\n  DAYS   = WORD(TEMP,DAYS_WORD)\n  say \"TSA101D: T52INS reformatted input is :\" acid profile target days\nEND\n/*****/\nACT = \"AFTER\"\nADDRESS ISPEXEC\nPROFILE = TRANSLATE(PROFILE,\" \",\".\") /*CHANGE DOTS TO BLANKS */\nPROFILE = TRANSLATE(PROFILE,\" \",\"_\") /*CHANGE _    TO BLANKS */\nSYSENV = SYSVAR(SYSENV)\nPROF. = \" \"\nPROFHLD = \" \"\nQ = OUTTRAP(\"OFF\")\nSAY \" \"\nsay \"TSA101D: T52INS control received.\"\nsay \"TSA101D: T52INS profile is\" profile\nsay \"TSA101D: T52INS target  is\" target\nsay \"TSA101D: T52INS days    is\" days\nPARSE VAR PROFILE PROF.1 PROF.2 PROF.3 PROF.4 PROF.5\nPROFNUM = WORDS(PROFILE)\nIF PROFNUM > 5 THEN DO\n  secrc = \"TSA251E: Failed. Insert function only supports \"\n  secrc = secrc||\"5 profiles at a time\"\n  say \"TSA101D: T52INS:\" secrc\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DATATYPE(TARGET) \u00ac= \"NUM\" THEN DO\n   SECRC=\"FUNCTION ABORTED. LOCATION SPECIFIED IS NOT NUMERIC.\"\n   SECRC= SECRC TARGET\n   IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n   EXIT 16\nEND\n/*********************************************************************/\n/* NOW I MAKE SURE EACH PROF HE PASSED ME IS ACTUALLY A PROFILE. DIR */\n/* NOTE THAT THIS CHECKING IS SKIPPED FOR A BATCH USER.          DIR */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  SECRC = \"PROFILE\" /*SET TO PROFILE FOR BATCH DEFAULTS */\n  IF SYSENV = \"FORE\" THEN DO\n    say \"TSA101D: T52INS environment is foreground\"\n    say \"TSA101D: T52INS I am calling Txxfdiv for data on \"prof.cnt\n    ADDRESS TSO \"%T52FDIV \"PROF.CNT\n    ADDRESS ISPEXEC \" VGET SECRC PROFILE\"\n  END\n  IF SECRC \u00ac= \"PROFILE\" THEN DO\n    say \"TSA101D: T52INS rcode indicates \" prof.cnt \"is not a profile\"\n    say \"TSA101D: T52INS return code is ===>\" secrc\n    secrc= \"TSA252E: \"\n    secrc= secrc\"Function aborted. \"prof.cnt \"is not an owned profile.\"\n    IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n    EXIT 08\n  END\nEND\nSIGNAL ON ERROR NAME ERRID\nsay \"TSA101D: T52INS testing primary id for existance\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nsay \"TSA101D: T52INS rcode from test is \" rc\nSIGNAL OFF ERROR\n/*********************************************************************/\n/* NOW I REMOVE THE PROFS BEFORE INSERTING THEM JUST IN CASE THIS IS */\n/* THE EQUIVALENT OF A MOVE OPERATION...........DIR 19 JUN 91        */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  say \"TSA101D: T52INS removing the stated profiles first !\" prof.cnt\n  ADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROF.CNT\")\"\n  IF RC > 0 THEN NOTTHERE = \"YES\"\nEND\n/*********************************************************************/\n/* IF THIS IS THE EQUIVALENT OF A DELETE WE ARE DONE....DIR 19 JUN 91*/\n/*********************************************************************/\nIF TARGET = 0 THEN DO\n  SECRC = PROFILE \" REMOVED FROM \"ACID\", AND NOT REINSERTED.\"\n  IF NOTTHERE = \"YES\" THEN DO\n    say \"TSA101D: T52INS non 0 rc received from tss remove command\"\n    secrc = \"TSA253E: Failed. Delete requested but \"profile \"not\"\n    secrc =  secrc\" removed from ACID\" acid\".\"\n  END\n  SAY \"T52INS:\" SECRC\n  IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n  EXIT\nEND\n/*                                              */\n/*Q = OUTTRAP(\"OUT.\")                           */\n/*ADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"    */\nQ = OUTTRAP(\"OFF\")\n/*********************************************************************/\n/* NOW I GET THE PROFILES CURRENTLY ATTACHED TO THE ACID DR 2 MAY96  */\n/*********************************************************************/\nADDRESS TSO \" %T52GDAT \"ACID \" PROFILES\"\nADDRESS ISPEXEC \" VGET SECRC PROFILE\"\nPROFHLD = SECRC\nSAY \"T52INS: CURRENT PROFILES ARE : \" PROFHLD\nTOTWORDS = WORDS(PROFHLD)\nIF PROFHLD = \"$NOTFOUND\" THEN TOTWORDS = 0\nIF TARGET > TOTWORDS THEN DO\n  TARGET = TOTWORDS + 1\n  SAY \"T52INS: POSITION PARM OVERRIDDEN. CHANGED TO \"TARGET\nEND\n/******************************************************************/\n/* WE ISSUE THE COMMAND WITH AN AFTER PARM UNLESS THE FUNCTION IS */\n/* TO ADD THE PROFILE AS THE FIRST IN HIS LIST, THEN WE MUST      */\n/* USE THE BEFORE PARM. THIS NEXT CODE IS HERE IN CASE TARGET IS  */\n/* EQUAL TO POSITION 1. DIR 2 MAY 96                              */\n/******************************************************************/\nIF TOTWORDS = 0 THEN DO\n  IF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"\n  IF DAYS \u00ac= \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\")\"\n  SIGNAL SEEYA\nEND\nQ1 = TARGET\nIF TARGET = 1 THEN ACT = \"BEFORE\"\nELSE Q1 = TARGET - 1\nIF Q1 = 0 THEN ACT = \"BEFORE\"\nTPROF = WORD(PROFHLD,Q1)\nSAY \"T52INS: INSERT TGT IS PROFILE \" TPROF\nSIGNAL ON ERROR NAME ERRXIT\nSAY \"T52INS: ADDING FOLLOWING PROFILES TO ACID\"\nSAY \"T52INS: PROFILES ===> \"PROFILE\nSAY \"T52INS: CHECKING FOR TEMPORARY TIMESPAN\"\nIF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"ACT\"(\"TPROF\")\"\nELSE ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\") \",\n      ACT\"(\"TPROF\")\"\nSEEYA: NOP\nsecrc =  \"TSA254I:\" profile \"inserted in \"acid\" at position\" target\".\"\nSAY \"T52INS: \"SECRC\nSAY \"  \"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nEXIT 0\n\nERRXIT: NOP\nSAY \"T52INS: ERROR IN LINE:\" SIGL\nSECRC =  \"CATASTROPHIC FAILURE ! PROFILES BELOW NOT ADDED !\"\nSAY \"T52INS: \"SECRC\nSAY \"  \"\nEXITRC16 = ACID \"LOST:\" PROFHLD\nSAY \"T52INS: \"EXITRC16\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC16 PROFILE\"\nEXIT 1\nERRID: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . MAY NOT EXIST\"\nSAY \"T52INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"MAY NOT EXIST\"\nSAY \"T52INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\nERRPRF: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . SOME PROFILES MAY NOT BE OWNED!\"\nSAY \"T52INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"PROFS IN QUESTION:\" Y\nSAY \"T52INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53JCARD": {"ttr": 10245, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x08\\x00\\x955/\\x01\\x01\\x19?\\x07T\\x00<\\x00<\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2001-07-12T07:54:08", "lines": 60, "newlines": 60, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** INSERTS A JOBNAME AND MAYBE A USER= CARD INTO A      **/\n/** SAMPLE JCL DECK WHICH ALREADY IS SYNTACTICALLY VALID **/\n/**********************************************************/\n/** EXEC NAME        : T51JCARD                          **/\n/** LAST MODIFIED    : 15 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSNAME OF THE OUTPUT JCL STREAM        **/\n/** JPARM   : \"SUPER\" OR BLANKS                          **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS6     : THE DSNAME IF THE SAMPLE JOB               **/\n/** DISP    : THE OUTPUT FILE ALLOCATION DISPOSITION     **/\n/** MSCA    : THE ID TO INCLUDE IN A USER= CARD IF NEEDED**/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE                         **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (NEEDS VGETS)               **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/.A                **/\n/**                                                      **/\n/**********************************************************/\nARG DSN JPARM\nADDRESS ISPEXEC\n\"ISPEXEC VGET DS6 PROFILE\"\n\"ISPEXEC VGET MSCA PROFILE\"\nSAY \"TSA101D: T51JCARD: IS IN CONTROL WITH PARMS : \" DSN JPARM\nADDRESS TSO \"ALLOC DDN(JCFILE) DSN(\"DS6\") SHR REUS\"\nJNAME= JPARM\nIF JPARM = '' THEN JNAME = \"TSSJOB\"\nTIME = TIME(NORMAL)\nT12 = SUBSTR(TIME,1,2)\nT45 = SUBSTR(TIME,4,2)\nIF JPARM = \"RANDOM\" THEN\n  JNAME= \"TSSJ\"T12||T45\nADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DSN\") SHR REUS\"\nADDRESS MVS \"EXECIO * DISKR JCFILE (FINIS STEM LINE.)\"\nJOBCARD_INSERT = 99\nDO Q = 8 TO 1 BY -1 /* LETS FIND WHERE THE JOBCARD ENDS */\n  INLINE = LINE.Q\n  IF SUBSTR(INLINE,1,3) = \"//*\" THEN JOBCARD_INSERT = Q - 1\n  IF SUBSTR(INLINE,1,2) = \"/*\" THEN JOBCARD_INSERT = Q - 1\n  IF INDEX(INLINE,\"EXEC\") > 0  THEN JOBCARD_INSERT = Q - 1\nEND\nSAY \"TSA101D: T51JCARD JOBCARD ENDS PRIOR TO LINE\" JOBCARD_INSERT\nIF JPARM = \"SUPER\" THEN DO\n  JNAME= \"TSSJ\"T12||T45\n  LINE.JOBCARD_INSERT= \"// \"WORD(LINE.JOBCARD_INSERT,2)||\",USER=\"MSCA\n  SAY \"TSA101D: JCARD ADDITION : \" LINE.JOBCARD_INSERT\nEND\nLEN1= LENGTH(LINE.1)\nHOLD = SUBSTR(LINE.1,11)\nLINE.1= \"//\"JNAME HOLD\nADDRESS MVS \"EXECIO * DISKW OUTFILE (FINIS STEM LINE.)\"\nADDRESS TSO \" FREE DDN(JCFILE)  \"\nADDRESS TSO \" FREE DDN(OUTFILE) \"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53LISTP": {"ttr": 10247, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00 \\x01\\x01\\x19?\\x01\\x01\\x19?\\t\\x15\\x00Q\\x00Q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-07-12T00:00:00", "modifydate": "2001-07-12T09:15:20", "lines": 81, "newlines": 81, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51LISTP                          **/\n/** LAST MODIFIED    : 11 JUL 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE VALID TSS DEFINED ID                   **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  ACID IF NOT PASSED AS AN ARG.                       **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         MSG2                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T51FDIV T51GETPW     **/\n/**                                                      **/\n/**********************************************************/\nARG ACID\nIF ACID = \" \" THEN ADDRESS ISPEXEC \"VGET ACID  PROFILE\"\nSAY \"T51LISTP: HAS CONTROL\"\nSAY \"T51LISTP: CALLING T51FDIV\"\nSYSSCMD = SYSVAR(SYSSCMD)\nSYSPCMD = SYSVAR(SYSPCMD)\nSYSICMD = SYSVAR(SYSICMD)\nSYSNEST = SYSVAR(SYSNEST)\nSYSRACF = SYSVAR(SYSRACF)\nSAY \"I=\"SYSICMD \"P=\" SYSPCMD \"S=\" SYSSCMD \"RACF= \" SYSRACF\nADDRESS TSO \"%T51FDIV \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\nSAY \"T51LISTP: BACK FROM  T51FDIV WITH SECRC OF\" SECRC\nIF SECRC = \"LIST FUNCTION FAILED.\" THEN DO\n  ADDRESS TSO \"%T51GETPW \" ACID\n  ADDRESS ISPEXEC \" VGET SECRC PROFILE \"\n  IF SECRC \u00ac= \"$ERROR\" THEN\n    SECRC = \"THAT IDS PASSWORD = \" SECRC\n  ELSE\n    SECRC = \"FAILED. THAT ID DOES NOT EXIST IN UADS OR TOP SECRET\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC = \"AUTHORIZATION FAILED.\" THEN DO\n  SECRC = \"FAILED. YOUR TOP SECRET AUTHORIZATION IS INADEQUATE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC \u00ac= \"CUSTDIV\" THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"THAT ID IS NOT DEFINED AS AN EXTERNAL CUSTOMER. \"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    IF SUBSTR(ACID            ,8,1) = \"@\" THEN DO\n      MSG2 = \"THAT IS A GHOST ENTRY, TRY LISTING THE ID WITHOUT THE @\"\n      ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\n    END\n    EXIT 00\n    END\n  ELSE DO\n    MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY LISTABLE\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nADDRESS TSO \"%T51GDAT \"ACID\" ATTRIBUTES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF INDEX(SECRC,\"SUSPEND\") \u00ac=  0 THEN DO\n  MSG2 =  \"THIS ID IS SUSPENDED, YOU MUST UNSUSPEND TO USE\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nADDRESS TSO \"T51GDAT \"ACID\" PASSWORD PW\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF ( SECRC = \"$NOTFOUND\" ) | ( SECRC = \"$BADTSS\" )  THEN DO\n  MSG2 = \"THE IDS PASSWORD IS NOT RETRIEVABLE. CONTACT TECH SUPPORT\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nELSE\n  SECRC = \"THE IDS PASSWORD  = \"SECRC\nTHEEND: NOP\nADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53LSTO": {"ttr": 11015, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x00\\x11\\x00\\x98(/\\x01\\x06\\x11o\\t%\\x000\\x00.\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1998-10-09T00:00:00", "modifydate": "2006-04-26T09:25:11", "lines": 48, "newlines": 46, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID DATA DS1 DISP\n HEX00 = '00'X\n /* DISP = \"SHR\" */\n SYSENV = SYSVAR(SYSENV)\n SAY HEX00\n SECRC = \"FAILED IN T53LSTO. CHECK ACIDS VALIDITY\"\n secrc = secrc||\" and your current authority\"\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n   ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n END\n IF DISP = \"\" THEN DISP = SHR\n SIGNAL ON ERROR NAME SEEYA\n SS = OUTTRAP('OUTLINE.')\n  /******************************************************************/\n  /* THIS EXEC PRINTS OUTPUT TO A DSN.                              */\n  /* IT IS VERY SIMPLE......DAVE 20 MAY 91                          */\n  /******************************************************************/\nIF DATA  = \"  \" THEN  DATA=\"ALL\"\nIF DATA  = \"ALLPW\" THEN  DATA=\"ALL,PASSWORD\"\nIF DATA  = \"DATAAREA\" THEN DO\n  ADDRESS ISPEXEC \"VGET DATAAREA PROFILE\"\n  DATA = DATAAREA\nEND\n\nSAY \"t53LSTO: ALLOCATING DSN\" DS1\n\"ALLOC DDN(OUTFILE) DSN(\"DS1\") \"DISP\" REUS\"\ntrace off\nSAY \"T53LSTO: CALLING TSS FOR LIST OF ID \" ACID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n secrc = \"function completed. output in \" ds1\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53MAINT": {"ttr": 10769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00U\\x01\\x04\\t?\\x01\\x05\\x11o\\x08\\x04\\x009\\x00:\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2005-04-26T08:04:55", "lines": 57, "newlines": 58, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T53maint                          **/\n/** LAST MODIFIED    :  3 31 2004                        **/\n/**********************************************************/\n/** a front end exec for the idat exec that will suspend **/\n/** or unsuspend or whatever and then call the instdata  **/\n/** routine to maintain instdata                         **/\n/**                                                      **/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**  COA1DIR UNSUSPEND */\n/**                                                      **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %t53idat             **/\n/**********************************************************/\nARG ACID Function data\nfunction = strip(function)\nsignal off error\naddress tso\nSelect\n  when function= \"UNSUSPEND\" then do\n    thecmd = \"%t53idat\" acid function\n    \" \"thecmd\n    drc = rc\n    thecmd = \"tss rem(\"acid\") SUSPEND\"\n    \" \"thecmd\n    address ispexec \"vget secrc profile\"\n  end\n  when function= \"SUSPEND\" then do\n    thecmd = \"%t53idat\" acid function\n    \" \"thecmd\n    drc = rc\n    thecmd = \"tss add(\"acid\") SUSPEND\"\n    \" \"thecmd\n    address ispexec \"vget secrc profile\"\n  end\n  when function= \"INSTDATA\" then do\n    new_enum  = substr(newidata                 ,1,10)\n    new_code  = code.function\n  end\n  otherwise secrc = \"Failed. Unknown function\" function\n            address ispexec \"vput secrc profile\"\n            say secrc\nEnd\nsay secrc drc\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53PER": {"ttr": 10249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00F\\x00\\x990O\\x00\\x991/\\t\\x14\\x00g\\x00g\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1999-10-31T00:00:00", "modifydate": "1999-11-08T09:14:46", "lines": 103, "newlines": 103, "modlines": 0, "user": "*SPIV8*"}, "text": "/*REXX*/\nARG ACID RESTYPE RESNAME ACCESS DAYS\nSIGNAL OFF ERROR\nSECRC = \"T50PER FAILED WITH ERRORS\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nRES.0 = 3\nRES.1 = \"DATASET\"\nRES.2 = \"JESSPOOL\"\nRES.2 = \"VOL\"\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE ASTERISK WITH Z */\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = RESTYPE THEN VALID = \"YES\"\nEND\nIF VALID /= \"YES\" THEN DO\n  SAY \"T50PER: RESTYPE NOT SUPPORTED. RESTYPE = \" RESTYPE\n  MSG2 = \"THE FOLLOWING RESTYPE WAS NOT RECOGNIZED\" RESTYPE\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  EXIT 08\nEND\nACTION = \"ACTION(FAIL)\"\nIF DAYS /= \" \" THEN DAYCMD = \"FOR(\"DAYS\")\"\nSLASH = INDEX(\"/\",DAYS)\nIF SLASH > 0 THEN DAYCMD = \"UNTIL(\"DAYS\")\"\nDAY1 = WORD(DAYS,1)\nSIGNAL NOCHECK\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE DOTS WITH SPACES */\nACCCHK = ACCESS\nQ = OUTTRAP(HOLD.,5)\nIF ACCESS = \"ALL\" THEN ACCCHK = \"ALTER\"\nIF ACCESS = \"REMOVE\" THEN ACCCHK = \"ALTER\"\nSAY \"T50PER: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nSAY \"T50PER: RES IS \" RESNAME\nSAY \"********CHECK IS BELOW **************\"\nSAY \" TSSCHECK(\"RESTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\nX5 = TSSCHECK(RESTYPE,RESCHK,ACCCHK,\"NOMSG\")\nSAY \"********CHECK IS BELOW **************\"\nSAY \"T50PER: TSSCHECK RETURN CODE IS \" X5\nIF X5 \u00ac= \"OK\"  THEN DO\n  SECRC = \"YOU CANNOT GRANT THAT LEVEL OF ACCESS TO THAT RESOURCE.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nNOCHECK: NOP\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T50PER: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\n/********************************/\n/* LETS ACTUALLY DO THE WORK... */\n/********************************/\nQ = OUTTRAP(OUT.,5)\nIF RESTYPE = \"DATASET\" THEN RESTYPE = \"DSN\"\nIF ACCESS = \"REMOVE\" THEN DO\n  \"TSS REV(\"ACID\") \"RESTYPE\"(\"RESNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"AUTHORITY REMOVED FOR ID \"ACID\".\"\n  ELSE DO\n    SECRC = \"REMOVE RETURNED NON ZERO RCODE OF \"RCODE\n    MSG2 = OUT.1\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") \"RESTYPE\"(\"RESNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"RESNAME\")\",\n  \"ACCESS(\"ACCESS\")\" DAYCMD ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  secrc = \"TSA521I: permit function successful for id\" acid\nELSE DO\n  secrc = \"TSA522I: permit returned non zero rcode of \"rcode\n  MSG2 = OUT.1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53PMENU": {"ttr": 10497, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00H\\x00\\x98#/\\x01\\x00\\x07_\\x10S\\x02\\x96\\x02\\x96\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1998-08-20T00:00:00", "modifydate": "2000-03-15T10:53:48", "lines": 662, "newlines": 662, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added  security checking for datsets                 **/\n/**********************************************************/\n/** added  privpgm support 11 nov 97                     **/\n/**********************************************************/\n/** added  support for the STC record by creating        **/\n/** the DELTRUNC. variable to be referenced in deletes   **/\n/**********************************************************/\n/** added  support for the user TSO area. dir 1 oct 97   **/\n/**********************************************************/\n/** Fixed truncation of last data line and added sitran  **/\n/** support.     dave 29 aug 97                          **/\n/**********************************************************/\n/** NOW SUPPORTS LCF CMDS     DIR 28 AUG 97              **/\n/**********************************************************/\n/** MODIFY PROFILES IN A PANEL BASED ENVIRONMENT         **/\n/** LOTS  OF SAYS   TO FACILITATE DEBUGGING...           **/\n/**********************************************************/\n/** EXEC NAME        : T50PMENU                          **/\n/** LAST MODIFIED    : 25 MAR 97                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS3     : THE BATCH FILE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD  = THE VALID COMMANDS FOR THIS ENTRY   \"ADD REM\" **/\n/** TYPE = THE RESOURCE TYPE                   \"DATASET\" **/\n/** RSNAME= THE RESOURCE NAME                  \"SYS1.  \" **/\n/** ACCESS=THE ACCESS LEVEL                    \"UPDATE \" **/\n/** ACTION=THE ACTION TO TAKE                  \"FAIL   \" **/\n/** UNTIL= THE EXPIRATION DATE OF RULE  \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/** OTHER   = ANYTHING ELSE             \"DAYS(MON.TUE)  \"**/\n/** DELTRUNC= Number of words to retain of the resource \"**/\n/**           name when doing a delete function.         **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** OUT_COUNT = THE # OF OUTPUT CHANGES                  **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS3  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nCALL OFF ERROR\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T50PMENU. CHECK ACIDS VALIDITY\"\nSECRC = SECRC||\" AND YOUR CURRENT AUTHORITY\"\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS3 PROFILE\"\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\nEND\nDELTRUNC. =  0\nF0        =  \" \"\nUNTIL.    =  \" \"\nACCESS.   =  \" \"\nRSNAME.   =  \" \"\nOTHER.    =  \" \"\nLIBRARY.  =  \" \"\nFACILITY. =  \" \"\nPGM.      =  \" \"\nCOMMAND_FALLTHRU = \"ADD REM\"\nCMD.      =  \"PER REV\"\nACTION.   =  \" \"\nIF DISP = \"\" THEN DISP = SHR\nSIGNAL ON ERROR NAME BYEBYE\nDATA=\"ALL,EXPIRE\"\nIF MODE = \"ONLINE\" THEN DO\n  SAY \"T50PMENU: ALLOCATING DSN\" DS3\n  ADDRESS TSO \"%T50JCARD\" DS3\n  \"ALLOC DDN(BJCL) DSN(\"DS3\") MOD REUS\"\nEND\nSAY \"T50PMENU: CALLING TSS FOR LIST OF ID \" ACID\nSS = OUTTRAP('INLINE.')\nSIGNAL ON ERROR NAME BADID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nRCODE = RC\nSIGNAL ON ERROR NAME BYEBYE\nTHISREC = 3\nOUT_COUNT = 0\nOUTNUM = 0\nSAY \"T50PMENU: HAS A TOTAL RECORD COUNT OF \" inline.0\nDO I = 1 TO INLINE.0\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\") /* REPLACE = WITH SPACES */\n  /***********************************************************/\n  /** Kill those = signs.. very important to know for the   **/\n  /** lower loop...    Dave 29 Aug 97                       **/\n  /***********************************************************/\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  /****************************/\n  /* SAVE THE LAST LINE HEADER*/\n  /****************************/\n  FIRST13 = SUBSTR(LINE,1,13)\n  IF FIRST13 \\= \"             \" THEN SAVE13 = FIRST13\n  IF SUBSTR(LINE,1,2) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  /***********************************************************/\n  /** Reformatter area                                      **/\n  /** The lower loop operates on the principal that each    **/\n  /** line contains enough data to recreate any command     **/\n  /** pertaining to the resources mentioned there.          **/\n  /** I created this area for LCF commands, where lines do  **/\n  /** not mention the facilites that they are affecting     **/\n  /** nor do they mention the type of resource they are     **/\n  /** securing. So I 'proprogate' the first 13 chars of     **/\n  /** the line that does have this data to the lower        **/\n  /** lines.      DAVE 29 AUG 97                            **/\n  /***********************************************************/\n  IF (SAVE13 = \" AUTH CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"AUTH CMDS  \"||LINE\n  IF (SAVE13 = \" EXMP CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"EXMP CMDS  \"||LINE\n  IF SAVE13 = \" AUTH CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  IF SAVE13 = \" EXMP CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  /****************************/\n  /** END OF REFORMATTER AREA**/\n  /****************************/\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  IF FIRST13 = \"LCF FAC     \" THEN LCFFAC = W.3\n  IF W.1 = \"XA\" THEN DO\n    OUTNUM = OUTNUM + 1\n    CMD.OUTNUM = \"PER REV\"\n    IF W.2 = \"DATASET\" THEN W.2 = \"DSN\" /* FIX FOR ADD/PER WITH DSNS*/\n    TYPE.OUTNUM = W.2\n    RSNAME.OUTNUM = W.3\n    UNTIL.OUTNUM = W.4\n    ITERATE I\n  END\n  IF W.1 = \"ACCESS\" THEN DO\n    ACCESS.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"DAYS\" THEN DO\n    OTHER.OUTNUM = \"DAYS(\"W.2\")\"  W.3 W.4 W.5 W.6 W.7 W.8 W.9\n    OTHER.OUTNUM = STRIP(OTHER.OUTNUM)\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n  IF W.1 = \"STC\" THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"PROCNAME(\"W.2\") acid(\"w.4\")\"\n    DELTRUNC.OUTNUM = 1 /* TO DEL THIS RULE ONLY USE WORD # 1 */\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n/*************************************************/\n/* SITRAN     = M3CL      FACILITY   = FINTST1   */\n/* TSS ADD(CONSPROF) SIT(M3CL,FINTST1)           */\n/*************************************************/\n  IF W.1 = \"SITRAN\"   THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"SIT(\"W.2\",\"W.4\")\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$SITRAN\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$ATTRIB\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    PGM.OUTNUM = W.2 W.3 W.4 W.5 W.6\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  END\n  /*************************************************/\n  /* below is the processing for the tso area      */\n  /* note that it checks handles all tso prefixed  */\n  /* words............  dir 1 oct 97               */\n  /*************************************************/\n  IF SUBSTR(W.1,1,3) = \"TSO\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  /*************************************************/\n  /* Below is the area for words to ignore         */\n  /*************************************************/\n  END\n  IF W.3 = \"NAME\" THEN iterate i\n  IF W.1 = \"DEPT\" THEN ITERATE I\n  IF W.1 = \"ZONE\" THEN ITERATE I\n  IF W.1 = \"DIV\" THEN ITERATE I\n  IF W.1 = \"TYPE\" THEN ITERATE I\n  IF W.1 = \"CREATED\" THEN ITERATE I\n  IF W.1 = \"TSS0300I\" THEN ITERATE I\n  IF W.1 = \"LAST\" THEN ITERATE I\n  IF W.1 = \"ACID\" THEN ITERATE I\n  /*************************************************/\n  /* Below is the area to change fallthru defaults */\n  /*************************************************/\n  IF W.1 = \"LIST\" & W.2 = \"DATA\"  THEN do\n    w.1 = \"DATA\";w.2 = w.3;w.3 = \" \"\n  end\n  IF INDEX(W.2,\"*ALL*\") THEN DO\n    PARSE VAR W.2  TZ1 '*ALL*' TZ2\n    W.2 = TZ1||\"ALL\"TZ2\n  END\n  IF W.2 = \"ADMINISTRATION\" & W.3 = \"AUTHORITIES\"  THEN\n    COMMAND_FALLTHRU = \"ADMIN DEADMIN\"\n  /*************************************************/\n  /* below is the fall thru area                   */\n  /* I take my best guess at the command           */\n  /*      ............  dir 29 jan 99              */\n  /*************************************************/\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM =  command_fallthru\n  ITERATE I\nEND\n/*******************************************************/\n/*******************************************************/\n/** End of loop now we create the output lines DIR    **/\n/*******************************************************/\n/*******************************************************/\nOUTNUM = OUTNUM + 1\nIF OUTNUM < 15 THEN DO A = OUTNUM TO 15\n  CMD.A      = \"PER REV\"\n  TYPE.A        = \" \"\n  RSNAME.A      = \" \"\n  ACCESS.A      = \" \"\n  OUTNUM = 15\nEND\nCALL FILLSCR\nSCANSCR: NOP\nDO T = 1 TO 14\n  IF F.T  = 'S' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    CALL SHOWRULE\n  END\n  IF F.T  = 'D' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN  CALL DELRULE\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T50PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'M' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN DO\n      CALL DELRULE\n      SAY \"T50PMENU: TYPE AFTER RULE PROCESSING IS \" TYPE.T\n      FLAG = \"*MODIFY\"\n      CALL MODRULE\n    END\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T50PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'A' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    F.T = \" \"\n    F0 = \"\"\n    DO TEMP3 = OUTNUM TO T BY - 1\n      BEFORE = TEMP3 - 1\n      F.TEMP3 = F.BEFORE\n      INTERPRET \"F\"||TEMP3 \"= F\"||BEFORE\n    END\n    OUTNUM = OUTNUM + 1\n    FILL = THISREC + T - 1\n    TARGET = FILL + 1\n    SAY \"T50PMENU: RECNUM IS  \" FILL\n    SAY \"T50PMENU: ACCESS IS  \"ACCESS.FILL\n    SAY \"T50PMENU: TYPE IS    \"TYPE.FILL\n    SAY \"T50PMENU: RSNAME IS  \"RSNAME.FILL\n    DO Q = OUTNUM TO TARGET BY -1\n      Q1 = Q - 1\n      FACILITY.Q = FACILITY.Q1\n      ACTION.Q   = ACTION.Q1\n      PGM.Q      = PGM.Q1\n      LIBRARY.Q  = LIBRARY.Q1\n      ACCESS.Q   = ACCESS.Q1\n      TYPE.Q     = TYPE.Q1\n      UNTIL.Q    = UNTIL.Q1\n      RSNAME.Q   = RSNAME.Q1\n    END\n    FLAG = \"*NEWRULE\"\n    CALL MODRULE\n    F.T = \" \"\n  END\nEND\nCALL FILLSCR\nADDRESS ISPEXEC \"DISPLAY PANEL(\"SECPROF\")\"\nCALL FILLSCR\nIF RC > 0 THEN SIGNAL BYEBYE\n/* IF OPT = \"NEXTM\" THEN THISREC = THISREC + 14         */\n/*IF OPT = \"PREVM\" THEN THISREC = THISREC - 14           */\nsay \"option is \"opt\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"F\") THEN OPT = \" \"\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"FIND\") THEN OPT = \" \"\nIF WORDS(OPT) = 1 THEN SIGNAL NOLOOP\nIF (WORD(OPT,1) = \"FIND\") | (WORD(OPT,1) = \"F\") then do\n  HOLD2 = WORD(OPT,2)\n  TGTNUM = OUTNUM - 14\n  HIT = \"NO\"\n  DO TF1 = THISREC TO OUTNUM\n    IF INDEX(TYPE.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(RSNAME.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(ACCESS.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF HIT = \"YES\" THEN THISREC = TF1\n    IF HIT = \"YES\" THEN LEAVE\n  END\n  IF THISREC > TGTNUM THEN THISREC = TGTNUM\nEND\nnoloop: nop\nIF WORD(OPT,1) = \"PREVM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC - 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = THISREC - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = 1\nend\nIF WORD(OPT,1) = \"NEXTM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC + 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = OUTNUM - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = OUTNUM - 14\nEND\nIF OPT = \"QUIT\" THEN SIGNAL BYEBYE\nOPT = \" \"\nSIGNAL SCANSCR\nSAY \"T50PMENU : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/*DO X = 1 TO OUTNUM                                                */\n/*  BATFILE.X =  X CMD.X TYPE.X RSNAME.X UNTIL.X ACCESS.X LIBRARY.X,*/\n/*  ACTION.X                                                        */\n/*END                                                               */\n\"EXECIO \"OUT_COUNT\" DISKW BJCL ( FINIS STEM BATFILE.)\"\n SECRC = \"FUNCTION COMPLETED. OUTPUT IN \" DS3\n IF MODE = \"BATCH\" THEN\n   SECRC = \"FUNCTION COMPLETED. OUTPUT APPENDED TO BATCH FILE.\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nBADID: NOP\n SECRC = \"ID LIST FAILED, CHECK YOUR AUTHORITIES AND IDS EXISTANCE\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nSEEYA: NOP\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/******************************************************************/\n/**  THE SHOWRULE SECTION                                        **/\n/******************************************************************/\nSHOWRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. OTHER.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nSAY \"T50PMENU: TEMP IS \" TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nRSNAME   = RSNAME.TEMP\nSAY \"T50PMENU: INSIDE SHOWRULE ROUTINE\"\nSAY \"T50PMENU: ACTION IS   \"  ACTION\nSAY \"T50PMENU: FACILITY IS \"  FACILITY\nSAY \"T50PMENU: PGM IS      \"  PGM\nSAY \"T50PMENU: ACCESS IS   \"  ACCESS\nSAY \"T50PMENU: LIBRARY IS  \"  LIBRARY\nSAY \"T50PMENU: UNTIL IS    \"  UNTIL\nSAY \"T50PMENU: TYPE IS     \"  TYPE\nSAY \"T50PMENU: RSNAME IS   \"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECSHOW)\"\nADDRESS ISPEXEC \"REMPOP\"\nRETURN\n/*******************************************************/\n/**              THE SECURITY CHECK                   **/\n/*******************************************************/\nSECURE: PROCEDURE EXPOSE TYPE. RSNAME. ACCESS. T,\n       ACTION. THISREC CMD. FLAG,\n       ACID OTHER. SECCODE\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nCALL OFF ERROR\nVALID = \"NO\"\nTEMP   = T + THISREC - 1\nOUT_RNAME = RSNAME.TEMP\nACCESS   = ACCESS.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T50PMENU(SECURE): MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nRES.0 = 2\nRES.1 = \"DSN\"\nRES.2 = \"JESSPOOL\"\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = TYPE THEN VALID = \"***DISABLED***\"\nEND\nIF TYPE = \"*SECURE\" THEN SECCODE = 16\nSAY \"MODRULE VALID IS\" VALID\nIF VALID = \"YES\" THEN DO\n  RESCHK = TRANSLATE(RSNAME,\"Z\",\"*\") /* REPLACE * WITH zzzzzz */\n  ACCCHK = \"ALTER\"\n  IF TYPE = \"DSN\" THEN TYPE = \"DATASET\"\n  RSTYPE = STRIP(TYPE)\n  /* Q = OUTTRAP(HOLD.,5)  */\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \" TSSCHECK(\"RSTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\n  SECCODE = TSSCHECK(RSTYPE,RESCHK,ACCCHK,\"NOMSG\")\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \"T50PMENU(MODRULE): TSSCHECK RETURN CODE IS \" SECCODE\nEND\nRETURN\n/*******************************************************/\n/******************************************************************/\n/**  THE MODRULE SECTION                                         **/\n/******************************************************************/\n/*******************************************************/\nMODRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. CMD. BATFILE. OUT_COUNT FLAG,\n       ACID OTHER. SECCODE\nCALL OFF ERROR\nOUT_COUNT = OUT_COUNT + 1\nSAY \"T50PMENU: RECNUM IS \" FILL\nTEMP   = T + THISREC - 1\nSAY \"T50PMENU: RECNUM IS \" TEMP\nOUT_CMD = WORD(CMD.TEMP,1)\nOUT_RNAME = RSNAME.TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T50PMENU: MODRULE TYPE WAS :\" TYPE\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = FLAG TYPE\nSAY \"T50PMENU: MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nSAY \"T50PMENU: INSIDE MODRULE  ROUTINE\"\nSAY \"T50PMENU: ACTION IS\"  ACTION\nSAY \"T50PMENU: FACILITY IS \"  FACILITY\nSAY \"T50PMENU: PGM IS\"  PGM\nSAY \"T50PMENU: ACCESS IS\"  ACCESS\nSAY \"T50PMENU: LIBRARY IS\"  LIBRARY\nSAY \"T50PMENU: UNTIL IS\"  UNTIL\nSAY \"T50PMENU: TYPE IS\"  TYPE\nSAY \"T50PMENU: RSNAME IS\"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECUPDT)\"\nRCODE = RC\nADDRESS ISPEXEC \"REMPOP\"\nIF RCODE > 0 THEN DO\n  OUT_COUNT = OUT_COUNT - 1  /* KILL THE DELETE ENTRY */\n  TYPE.TEMP = TYPE           /* RESET THE TYPE FIELD */\n  MSG = \" MODIFY ABORTED DUE TO PANEL RETURN CODE.\"\n  RETURN\nEND\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"RSNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  H = H||TYPE||\"(\"RSNAME\") + \"\nEND\nBATFILE.OUT_COUNT = H\nH =  ''\nOUT_COUNT = OUT_COUNT + 1\nIF LENGTH(UNTIL) = 8 THEN UNTIL = \"UNTIL(\"UNTIL\")\"\nIF ACCESS <> '' THEN H = H||\"ACCESS(\"ACCESS\") \"\nIF LIBRARY <> '' THEN DO\n  H = H||\"LIBRARY(\"LIBRARY\") + \"\n  BATFILE.OUT_COUNT = \"  \"||H\n  H =  ''\n  OUT_COUNT = OUT_COUNT + 1\nEND\nIF PGM <> '' THEN H = H||\"PRIVPGM(\"PGM\") \"\nIF UNTIL  <> '' THEN H = H||\" \"UNTIL\nIF ACTION <> '' THEN H = H||\" ACTION(\"ACTION\") \"\nIF FACILITY <> '' THEN H = H||\" FAC(\"FACILITY\") \"\nIF OTHER <> '' THEN H = H OTHER\nBATFILE.OUT_COUNT = \"  \"||H\nPGM.TEMP      = PGM\nACCESS.TEMP   = ACCESS\nLIBRARY.TEMP  = LIBRARY\nACTION.TEMP   = ACTION\nFACILITY.TEMP = FACILITY\nUNTIL.TEMP    = UNTIL\nRSNAME.TEMP    = RSNAME\nRETURN\n/******************************************************************/\n/** THE DELETE RULE SECTION                                      **/\n/******************************************************************/\nDELRULE: PROCEDURE EXPOSE TYPE. RSNAME. T ACID,\n        THISREC UPDATE. CMD. BATFILE. OUT_COUNT DELTRUNC.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nOUT_COUNT = OUT_COUNT + 1\nTYPE= TYPE.TEMP\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = \"*DELETE\" TYPE.TEMP\nOUT_ACID = ACID\nOUT_CMD = WORD(CMD.TEMP,2)\nOUT_RNAME = RSNAME.TEMP\nOUT_TRUNC = DELTRUNC.TEMP\n/******************************/\n/** truncate the rsname maybe**/\n/******************************/\nIF OUT_TRUNC = 1 THEN OUT_RNAME = WORD(OUT_RNAME,1)\nIF OUT_TRUNC = 2 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2)\nIF OUT_TRUNC = 3 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2) WORD(OUT_RNAME,3)\nIF SUBSTR(TYPE,1,1) = \"*\" THEN TYPE = WORD(TYPE,2) WORD(TYPE,3)\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"OUT_RNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  /*                         */\n  H = H||TYPE||\"(\"OUT_RNAME\")\"\nEND\nBATFILE.OUT_COUNT = H\n/* SAY OUT_COUNT */\n/* SAY H*/\nRETURN\nFILLSCR: PROCEDURE EXPOSE THISREC OUTNUM TYPE. RSNAME. ACCESS. T,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 TYPE1 TYPE2 TYPE3,\n TYPE4 TYPE5 TYPE6 TYPE7 TYPE8 TYPE9 TYPE10 TYPE11 TYPE12 TYPE13,\n ACCESS1 ACCESS2 ACCESS3 ACCESS4 ACCESS5 ACCESS6 ACCESS7 ACCESS8,\n ACCESS9 ACCESS10 ACCESS11 ACCESS12 ACCESS13 ACCESS14 TYPE14,\n RSNAME1 RSNAME2 RSNAME3 RSNAME4 RSNAME5 RSNAME6 RSNAME7 RSNAME8,\n RSNAME9 RSNAME10 RSNAME11 RSNAME12 RSNAME13 RSNAME14,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F.\nOPT = \" \"\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T50PMENU: TOP OF DATA REACHED\"\nEND\nIF (THISREC > OUTNUM - 14)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T50PMENU: BOTTOM OF DATA REACHED\"\nEND\nDO T = 1 TO 14\n  FILL = THISREC + T - 1\n  INTERPRET \"F.\"T \"=  F\"||T\n  IF WORDS(TYPE.FILL) > 2 THEN DO\n    SAY \"T50PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n    TYPE.FILL = WORD(TYPE.FILL,1) WORD(TYPE.FILL,3)\n    SAY \"T50PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n  END\n  INTERPRET \"TYPE\"||T \" =  TYPE.FILL\"\n  INTERPRET \"RSNAME\"||T \"= RSNAME.FILL\"\n  INTERPRET \"ACCESS\"||T  \"=  ACCESS.FILL\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53PWHO": {"ttr": 10499, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x04\\x00\\x03\\x00\\x97 /\\x01\\x04\\x00\\x7f\\x15&\\x00\\x8d\\x00\\x8d\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.04", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2004-01-07T15:26:03", "lines": 141, "newlines": 141, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added an exit with rc=8 for a bad tss id.             */\n/**********************************************************/\n/** Changed to use T51gdat for type processing            */\n/** should be faster for departments and divisions than   */\n/** the older routine.  Dave                              */\n/**********************************************************/\n/** Changed to support all listopt parm which allows      */\n/** all IDs to be listed including departments profiles   */\n/** and security administrators.           Dave           */\n/**********************************************************/\n/**********************************************************/\n/** NO SAYS CAUSE  THIS PGM IS EXPECTED TO WRITE OUTPUT  **/\n/** DATA DIRECTLY TO THE SCREEN.   DAVE                  **/\n/**********************************************************/\n/** EXEC NAME        : T51PWHO                           **/\n/** LAST MODIFIED    : 15 July 97                        **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** PROF    : THE TARGET ID OF THE LIST.                 **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG PROF LISTALL\nENV = SYSVAR(SYSENV)\nsecrc = \"List function failed. ACID may be invalid.\"\nIF ENV = \"FORE\" THEN DO\n  ADDRESS TSO \"%T52GDAT \"PROF\" TYPE\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  IF TYPE = \"$BADTSS\" THEN EXIT 08\n  secrc = \"List function failed. ACID may be invalid.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  IF TYPE = \"MASTER\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"PROFILE\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"DIVISION\" THEN DIVFLAG = \"YES\"\n  IF TYPE = \"DEPT\" THEN DEPTfLAG = \"YES\"\n  IF TYPE = \"ZONE\" THEN ZONEFLAG = \"YES\"\nEND\nIF ENV /= \"FORE\" THEN DO\n  SPACES = \"                                \"\n  Q = OUTTRAP(\"TYPE.\")\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(BASIC)\"\n  DO T = 1 TO TYPE.0\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DIVISION\") THEN\n      DIVFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DEPT\") THEN\n      DEPTFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"MASTER\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"PROFILE\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"ZONE\") THEN\n      ZONEFLAG = \"YES\"  /* FOR LATER ENHANCEMENTS */\n  END\nEND\nIF NORMFLAG = \"YES\" THEN DO\n   ACID.1   = PROF\n   CALL PRINTDPT /* A DEPT OR PROFILE WAS GIVEN. NO PROBLEM. */\n   EXIT 00\nEND\nIF ZONEFLAG = \"YES\" THEN DO     /* ZONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") TYPE(USER)\"\nEND\nIF DEPTFLAG = \"YES\" THEN DO     /* DEPT PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") TYPE(USER)\"\nEND\nIF DIVFLAG = \"YES\" THEN DO     /* DIVISIONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") TYPE(USER)\"\nEND\n/*                       */\nSECRC = \"FUNCTION COMPLETED NORMALLY.\"\nIF ENV = \"FORE\" THEN\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nPRINTDPT: PROCEDURE EXPOSE ACID. LISTALL\nDO IDNUM = 1 TO 4\n  Q = OUTTRAP(\"TYPE.\")\n  IF ACID.IDNUM = \"  \" THEN RETURN\n  IF ACID.IDNUM = \"ACID.\"IDNUM THEN RETURN\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(BASIC)\"\n  IF LISTALL = \"YES\" THEN SAY ACID.IDNUM\n  Q = OUTTRAP(\"OFF.\",0)\n  NORMAL = \"NO\"\n  DO T = 1 TO TYPE.0\n    W1 = WORD(TYPE.T,1)\n    W3 = WORD(TYPE.T,3)\n    IF W1 = \"TYPE\" THEN DO\n      IF W3 = \"DEPT\" THEN NORMAL = \"YES\"\n      IF W3 = \"MASTER\" THEN NORMAL = \"YES\"\n      IF W3 = \"PROFILE\" THEN NORMAL = \"YES\"\n      IF NORMAL = \"NO\" THEN DO\n        SAY ACID.IDNUM /* AN UNUSUAL USER */\n        ITERATE IDNUM\n      END\n    END\n  END\n  /********************************************************/\n  /* SINCE WE ARE HERE THIS ACID MUST BE A DEPARTMENT!    */\n  /********************************************************/\n  Q = OUTTRAP(\"OUT.\")\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(ACIDS)\"\n  Q = OUTTRAP(\"OFF.\",0)\n  GOFLAG = \"NO\"\n  DO T = 1 TO OUT.0\n    IF WORD(OUT.T,1) = \"ACIDS\" THEN GOFLAG = \"YES\"\n    IF WORD(OUT.T,1) = \"TSS0300I\" THEN LEAVE\n    IF WORD(OUT.T,1) = \"TSS300I\" THEN LEAVE\n    IF GOFLAG = \"YES\" THEN DO\n      /*SAY \"OUT.T IS  \"OUT.T */\n      PRT.1 = SUBSTR(OUT.T,14,8)\n      PRT.2 = SUBSTR(OUT.T,26,8)\n      PRT.3 = SUBSTR(OUT.T,38,8)\n      PRT.4 = SUBSTR(OUT.T,50,8)\n      DO X = 1 TO 4\n        IF PRT.X = \"*NONE*\" THEN PRT.X = \"  \"\n        IF PRT.X \u00ac= \"  \" THEN SAY PRT.X\n        PRT.X = \"  \"\n      END\n    END\n  END\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(ACIDS)\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53RENA": {"ttr": 10501, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x07\\x01\\x00\\x16\\x7f\\x01\\x005_\\t6\\x00Q\\x00Q\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2000-12-20T09:36:07", "lines": 81, "newlines": 81, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX */\n/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** THIS IS AN IMS ONLY EXEC DON NOT USE ON CSS LPAR     **/\n/**********************************************************/\n/** EXEC NAME        : T51RENA                           **/\n/** LAST MODIFIED    : 15 DEC 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID                                   **/\n/** NEW_ACID: WHAT YOU WANT IT RENAMED TO                **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  NONE                                                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEW_ACID\nSAY \"T51RENA: IN CONTROL WITH PARMS :\" ACID NEW_ACID\nADDRESS TSO\nNEW_LENGTH = LENGTH(NEW_ACID)\nIF NEW_LENGTH = 2 THEN DO\n  SAY \"T51RENA: TARGET ACID IS BEING RESOLVED DUE TO LENGTH\"\n  NEW_ACID = NEW_ACID||SUBSTR(ACID,3)\n  SAY \"T51RENA: TARGET ACID IS RESOLVED TO : \" NEW_ACID\nEND\nCALL OFF ERROR\nADDRESS ISPEXEC \"VGET ZSYSID \"; SYSID = ZSYSID\nSAY \"T51RENA: SYSID IS :\" SYSID\nif sysid = \"CSS1\" then secrc = \"rename function is invalid on CSS LPAR.\"\nif sysid = \"CSS1\" then signal seeya\nSECRC = \"THE RENAME FUNCTION HAS COMPLETED.\"\nRCODE = 0\nNEWD1  =  SUBSTR(DATA,1,2)\nNEWDPT =    NEWD1\"DEPT\"\n/*******************************************************/\n/** HERE IS THE IMS CHANGE SECTION.                   **/\n/** SYSA SYSB AND SYSC                                **/\n/*******************************************************/\n  SAY \"T51RENA: WE ARE ENTERING IMS RENAME LOGIC \"\n  \"%IMSALIAS\"  NEW_ACID\n  IF RC = 4 THEN SECRC = \"FUNCTION COMPLETE. TSO AUTHS MAY NEED TO BE\",\n   \"CHECKED.\"\n  RCODE = 0\n  \"TSS RENAME( \"ACID\") ACID(\"NEW_ACID\")\"\n  \"%TSSAUDU \" NEW_ACID\n  \"%TSSAUDR \" ACID\n  IF SYSDSN(\"'SYS1.TSOUSERS(\"NEW_ACID\")'\") /= \"OK\" THEN\n    \"%RXREPRO SYS1.TSOUSERS(\"ACID\") SYS1.TSOUSERS(\"NEW_ACID\")\"\n  \"%UADRENA \"ACID  NEW_ACID\n  /* \"%REPLACE SYS1.TSOUSERS(\"NEW_ACID\")\" ACID NEW_ACID*/\n  \"TSS REP(\"NEW_ACID\") TSOCOMMAND('PROFILE PREFIX(\"NEW_ACID\")')\"\n  \"TSS LIST( \"NEWDPT\") DATA(NAME)\"\n  IF RC = 0 THEN ADDRESS TSO \"TSS MOVE(\"NEW_ACID\") DEPT(\"NEWDPT\")\"\n  Q = OUTTRAP('LINE.')\n  \"LISTC LEVEL(\"ACID\")\"\n  Q = OUTTRAP('NULL.') /* LETS NOT SCREW UP OUR DATA NOW !  */\n  SAY \"I AM RENAMING \"LINE.0 \"DATASETS.\"\n  DO X = 1 TO LINE.0\n    PARSE VAR LINE.X W.1 W.2 W.3 W.4\n    IF W.1 = \"NONVSAM\" THEN DO\n      PARSE VAR W.3 HLQ \".\" LOWLQ\n       SAY \"RENAME '\"W.3\"' '\"NEW_ACID\".\"LOWLQ\"'\"\n      \"RENAME '\"W.3\"' '\"NEW_ACID\".\"LOWLQ\"'\"\n       IF RC /= 0 THEN SAY \"RENAME FOR \"W.3 \"FAILED!\"\n    END\n  END\n  \"%IMSDALIA\" ACID\nIF RCODE /= 0 THEN SECRC = \"ERRORS ENCOUNTERED. CHECK ID STATUS\"\n\"%UADRENAM\" ACID  NEW_ACID\nseeya: nop\nSAY \"T51RENA:\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53REPL": {"ttr": 10503, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00Q\\x00\\x955/\\x00\\x98&O\\x14X\\x00)\\x00)\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "1998-09-21T14:58:51", "lines": 41, "newlines": 41, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\nARG ACID PROFOLD PROFNEW\nSAY ACID PROFOLD PROFNEW\nPROFHOLD = PROFNEW /* SAVE ORIGINAL PARM FOR T50INS */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\".\") /* REPLACE DOTS WITH SPACES */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\"_\") /* REPLACE BARS WITH SPACES */\nSAY \"T50REPL: \" ACID PROFOLD PROFNEW\nADDRESS ISPEXEC\n/********************************************************************/\n/***  THIS EXEC REPLACES ONE PROFILE IN A TOP SECRET ACID WITH    ***/\n/***  ONE OR MORE OTHER PROFILES. IT REQUIRES THAT T50INS         ***/\n/***  BE AVAILABLE TO DO INSERTIONS.....DIR 26 APRIL 93           ***/\n/********************************************************************/\nWORDNUM = WORDS(PROFOLD)\nIF WORDNUM > 1 THEN DO\n  SECRC = \"YOU MUST SPECIFY ONLY 1 PROFILE FOR REPLACEMENT\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSAY \"T50REPL: CALLING T50FLOC\"\nADDRESS TSO \"%T50FLOC\" ACID PROFOLD\nSAY \"T50REPL: BACK FROM T50FLOC\"\n\" VGET SECRC PROFILE\"\nPLACE = SECRC\nSAY \" PLACE IS \" PLACE\nIF (PLACE = \"ERROR\") | ( PLACE= 0 ) THEN DO\n  SECRC = \"ERROR LOCATING \"PROFOLD \"IN ACID.. REPLACE ABORTED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROFOLD\")\"\nSIGNAL ON ERROR NAME BADPROF\nSAY \"T50REPL: CALLING T50INS\"\nADDRESS TSO \"%T50INS\" ACID PROFHOLD PLACE\nSECRC = \"PROFILE REPLACE COMPLETED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT 00\nBADPROF: NOP\nSECRC = PROFOLD \"WAS IN PLACE \"PLACE\", HOWEVER INSERTION OF \",\n  PROFNEW \"FAILED!\"\n  \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53REPPW": {"ttr": 10771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x04\\x01\\x00\\x16\\x7f\\x01\\x05\"\\x9f\\t\\x00\\x00V\\x00S\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2005-08-17T09:00:04", "lines": 86, "newlines": 83, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51REPPW                          **/\n/** LAST MODIFIED    : 11 JUL 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE VALID TSS DEFINED ID                   **/\n/** NEWPW   : A VALID 1 - 8 CHR NEW PASSWORD             **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  ACID IF NOT PASSED AS AN ARG.                       **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         MSG2                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T51FDIV TSSPWDR      **/\n/**                                 T51GDAT              **/\n/**********************************************************/\nARG ACID NEWPW\nIF ACID = \" \" THEN ADDRESS ISPEXEC \"VGET ACID  PROFILE\"\nSAY \"T51REPPW: HAS CONTROL\"\nSAY \"T51REPPW: CALLING T51FDIV\"\nADDRESS TSO \"%T51FDIV \"ACID\nADDRESS ISPEXEC \"VGET MODE PROFILE\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET UIDTABLE PROFILE\"\nADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\nSAY \"T51REPPW: BACK FROM  T51FDIV WITH SECRC OF\" SECRC\nIF SECRC = \"AUTHORIZATION FAILED.\" THEN DO\n  SECRC = \"FAILED. YOUR TOP SECRET AUTHORIZATION IS INADEQUATE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC = \"CUSTDIV\" THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"THAT IS DEFINED AS AN EXTERNAL CUSTOMER. TRY LISTPW\"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    EXIT 00\n    END\n  ELSE DO\n   MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY CHANGEABLE.\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nIF (SECRC = \"CENTRAL\") | (SECRC = \"MASTER\") THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"YOU ARE NOT AUTHORIZED TO CHANGE THAT ID.\"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    EXIT 00\n    END\n  ELSE DO\n   MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY CHANGEABLE.\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nADDRESS TSO \"%T51GDAT \"ACID\" ATTRIBUTES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF INDEX(SECRC,\"SUSPEND\") /=  0 THEN DO\n  MSG2 =  \"THIS ID IS SUSPENDED, YOU MUST UNSUSPEND TO USE\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(\"NEWPW\",60,EXP)\"\nIF MODE = \"BATCH\" THEN DO\n  BJCL.1 = \" TSS REP(\"ACID\") PASSWORD(\"NEWPW\",60,EXP)\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  SECRC = \"THE BATCH FILE WAS UPDATED WITH COMMAND TO REPLACE PWORD\"\n  SIGNAL THEEND\nEND\nADDRESS TSO \"T51GDAT \"ACID\" PASSWORD PW\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF ( SECRC = \"$NOTFOUND\" ) | ( SECRC = \"$BADTSS\" )  THEN DO\n/*\n  MSG2 = \"THE IDS PASSWORD IS NOT RETRIEVABLE. CONTACT TECH SUPPORT\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\n  */\n  secrc = \"Reset command issued.\"\nEND\nELSE\n  secrc = \"The ids password is now  = \"secrc\nTHEEND: NOP\nADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53RESET": {"ttr": 10505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x11\\x00\\x993?\\x01\\x04\\x07\\x1f\\x07)\\x00\\x10\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-11-29T00:00:00", "modifydate": "2004-03-11T07:29:11", "lines": 16, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX THE WONDER DOG */\nsignal off error\narg acid newpass\nrcode = 0\naddress tso\nsay \"tss rem(\"acid\") asuspend \"\n\"tss rem(\"acid\") asuspend \"\nrcode = rcode + rc\nsay \"tss rem(\"acid\") suspend \"\n\"tss rem(\"acid\") suspend \"\nrcode = rcode + rc\nsay \"tss rep(\"acid\") password(\"newpass\")\"\n\"tss rep(\"acid\") password(\"newpass\")\"\nrcode = rcode + rc\nexit 0\nexit rcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53TSO": {"ttr": 10753, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x005o\\x01\\x01\\t_\\x155\\x01[\\x01[\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2000-12-21T00:00:00", "modifydate": "2001-04-05T15:35:08", "lines": 347, "newlines": 347, "modlines": 0, "user": "*SPIV8*"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T51TSO                            **/\n/** LAST MODIFIED    : 21 SEP 98                         **/\n/**********************************************************/\n/**********************************************************/\n/** CHANGED TO MAKE MORE GENERIC                         **/\n/**********************************************************/\n/** CHANGED TO ALLOW DEFINITION OF UNOWNED RESOURCES     **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** VAR                VALID VALUES                      **/\n/** ACTION  : DEFAULTS ADDPROC ADDACCT DEFACCT DEFPROC   **/\n/**           DEFSIZE  DEFUNIT MAXSIZE REMACCT TSOAUTH   **/\n/** ACID    : ANY VALID TSS ACID                         **/\n/** LPROC   : ANY VALID PREDEFINED (TO TSS) PROC         **/\n/** ACCTNUM : ANY VALID PREDEFINED (TO TSS) ACCOUNT      **/\n/** UNIT    : ANY VALID UNIT                             **/\n/** SIZE    : ANY VALID SIZE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 16                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : NOT NEEDED, BUT WILL USE        **/\n/** EXECS CALLED WITHIN THIS EXEC : T51INS               **/\n/**                                                      **/\n/**********************************************************/\nSYSENV = SYSVAR(SYSENV)\nMSG2 = \"NO UNUSUAL CONDITIONS WERE FOUND.\"\nARG ACTION ACID LPROC ACCTNUM UNIT SIZE\n/*                                             */\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET BOOKSEC PROFILE\"\nEND\nELSE DO\n  AUTHNUM = 10\n  BOOKSEC = \"NO\"\nEND\n/*IF SUBSTR(ACID         ,8,1) = \"@\" THEN DO                      */\n/*  MSG2 = \"WARNING: THE ID YOU HAVE GIVEN ME IS A GHOST ID.\"     */\n/*  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"   */\n/*  ELSE SAY SECRC                                                */\n/*END                                                             */\nIF (LENGTH(ACID) > 8) & ( SUBSTR(ACID        ,8,1) \u00ac= \"@\" ) THEN DO\n  SECRC = \"THE ID YOU HAVE GIVEN ME IS TOO LONG MAX IS 7 CHRS\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ELSE SAY SECRC\n  EXIT 00\nEND\nSIGNAL ON ERROR NAME NOTSSID\nQ = OUTTRAP(DROPIT.,5)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nSIGNAL OFF ERROR\nX5 = \"OK\"\nSAY \"T51TSO: RECEIVED  CONTROL ACTION=\" ACTION \"ACID=\"ACID\nSAY \"T51TSO: PROC=\"LPROC\" ACCT=\"ACCTNUM\" UNIT=\"UNIT \"SIZE=\"SIZE\n/**************************************************/\n/* IF THE RESOURCE IS NOT OWNED ADD IT TO TSODEPT */\n/**************************************************/\nIF (AUTHNUM > 8) & (ACTION \u00ac= \"TSOAUTH\")  THEN DO\n  Q = OUTTRAP(DROPOUT.,5)\n  /* SAY \"T51TSO: CHECKING THAT ALL RESOURCES ARE OWNED \" */\n  TSS_RESOURCE = LPROC\n  ADDRESS TSO \" TSS WHOOWNS TSOPROC(\"LPROC\")\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE LPROC TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOPROC(\"LPROC\")\"\n  END\n  TSS_RESOURCE = ACCTNUM\n  ADDRESS TSO \" TSS WHOOWNS TSOACCT(\"ACCTNUM\")\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE ACCTNUM TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOACCT(\"ACCTNUM\")\"\n  END\n  TSS_RESOURCE = \"JCL\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(JCL)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE JCL AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(JCL)\"\n  END\n  TSS_RESOURCE = \"OPER\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(OPER)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE OPER AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(OPER)\"\n  END\n  TSS_RESOURCE = \"ACCT\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(ACCT)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T51TSO: I AM ADDING THE ACCT AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(ACCT)\"\n  END\n  SAY \"T51TSO: RESOURCE OWNER CHECKING COMPLETED.\"\nEND\n/**************************************************/\n/* END OF OWNERSHIP RESOLUTION.                   */\n/**************************************************/\nQ = OUTTRAP(OUT.,5)\nSIGNAL ON ERROR NAME SEEYA\n/* ACTION =DEFAULTS */\nIF (ACTION = \"DEFAULTS\") | (ACTION = \"DEFTSO\") THEN DO\n  SAY \"T51TSO: ATTEMPTING TO DEFINE ALL TSO AUTHS\"\n  SAY \"T51TSO: REMOVING ANY OLD PERMISSIONS FOR\" LPROC ACCTNUM\n  IF ACCTNUM \u00ac= \"NIL\" THEN DO\n    IF BOOKSEC = \"YES\" THEN\n      X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS*/\n    ELSE X5 = \"OK\"\n  END\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOAUTH(JCL)\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLPROC(\"LPROC\")\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLSIZE(\"SIZE\")\"\n  SAY \"T51TSO: DEFINING NEW TSO DEFAULTS.\"\n  SIGNAL ON ERROR NAME NOTSSDEF\n  Q = OUTTRAP(OUT.,5)\n  TSS_RESOURCE = \"LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\n  TSS_RESOURCE = \"ACCT NUM\" ACCTNUM\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  TSS_RESOURCE = \"JCL\"\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOAUTH(JCL)\"\n  SIGNAL ON ERROR NAME SEEYA\n  Q = OUTTRAP(OUT.,5)\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOUNIT(\"UNIT\")\"\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLPROC(\"LPROC\")\"\n  IF ACCTNUM \u00ac= \"NIL\" THEN\n    ADDRESS TSO \" TSS ADD(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLSIZE(\"SIZE\")\"\n  SAY \"T51TSO: CALLING T51INS FOR PROFILE INSERTION\"\n  ADDRESS TSO \"%T51INS\" ACID \"TSOPROF 9\"\n  SAY  \"T51TSO: BACK FROM T51INS WITH RC OF\" RC\nEND\nIF ACTION = \"ADDPROC\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM PROC\" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \"TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING ID TO PROC\" LPROC\n  ADDRESS TSO \"TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\nEND\nIF ACTION = \"ADDACCT\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM ACCT\" ACCTNUM\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME NOBOOK\n  SAY \"T51TSO: PERMITTING ID TO ACCT\" ACCTNUM\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"DEFACCT\" THEN DO\n  SIGNAL OFF ERROR\n  ADDRESS TSO \"%T51GDAT \" ACID \"TSOLACCT  TSO\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  BOOK = SECRC\n  IF BOOK = \"\" THEN SAY \"T51TSO: NO DEFAULT BOOK NUMBER DEFINED \"\n  IF BOOK = \"\" THEN BOOK  = \"$NOTFOUND\"\n  /********************************************************/\n  /* DOES HE HAVE A CURRENT DEFAULT TSS BOOK NUMBER ??    */\n  /********************************************************/\n  IF (BOOK = \"$BADTSS\") |  (BOOK = \"$NOTFOUND\") THEN NOP\n  ELSE DO\n    /********************************************************/\n    /* CAN HE OVERLAY THE CURRENT DEFAULT BOOK NUMBER ??    */\n    /********************************************************/\n    BOOK = SECRC\n    IF BOOKSEC = \"YES\" THEN\n      X5 = TSSCHECK(\"BOOKNUM\",BOOK,\"UPDATE\")  /* CAN THEY DO THIS */\n    ELSE X5 = \"OK\"\n    SAY \"T51DEL: TSSCHECK RETURN CODE IS \" X5\n    IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKREMA\n  END\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SAY \"T51TSO: REVOKING ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME NOBOOK\n  SAY \"T51TSO: PERMITTING ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SAY \"T51TSO: MAKING IDS DEFAULT ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"DEFPROC\" THEN DO\n  SIGNAL OFF ERROR\n  SAY \"T51TSO: REVOKING LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLPROC(\"LPROC\")\"\n  PDSN = \"'MVS.TSO.PROCLIB(\"LPROC\")'\"\n  /* SAY SYSDSN(PDSN) */\n  IF SYSDSN(PDSN)  = \"MEMBER NOT FOUND\" THEN DO\n    MSG2 = \"LOGON PROC CHANGED, BUT \"PDSN\" WAS NOT FOUND\"\n    IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    SAY \"T51TSO:\" MSG2\n  END\nEND\nIF ACTION = \"DEFSIZE\" THEN DO\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON SIZE\" SIZE\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLSIZE(\"SIZE\")\"\nEND\nIF ACTION = \"DEFUNIT\" THEN DO\n  SAY \"T51TSO: MAKING IDS DEFAULT LOGON UNIT\" UNIT\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOUNIT(\"UNIT\")\"\nEND\nIF ACTION = \"MAXSIZE\" THEN DO\n  SAY \"T51TSO: MAKING IDS MAXIMUM REGION SIZE\" SIZE\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOMSIZE(\"SIZE\")\"\nEND\nIF ACTION = \"REMACCT\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM ACCOUNT \" ACCTNUM\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T51TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"REMPROC\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM LOGON PROC \" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"TSOAUTH\" THEN DO\n  SAY \"T51TSO: REVOKING ID FROM AUTHS \" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOAUTH(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T51TSO: PERMITTING ID TO \" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOAUTH(\"LPROC\")\"\nEND\nSAY \"T51TSO: CHECKING FOR TSO AREA COMPLETENESS.\"\nSAY \" \"\nSIGNAL OFF ERROR\nIF (ACTION \u00ac= \"DEFAULTS\") & (ACTION \u00ac= \"DEFTSO\") THEN DO\n  ADDRESS TSO \"%T51GDAT \"ACID\" TSOLACCT TSO\"\n  IF SYSENV = \"FORE\" THEN\n    ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  DEFAULT_ACCT = SECRC\n  SAY \"T51TSO: IDS DEFAULT ACCOUNT IS \" DEFAULT_ACCT\n  ADDRESS TSO \"%T51GDAT \"ACID\" TSOLPROC TSO\"\n  IF SYSENV = \"FORE\" THEN\n    ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  DEFAULT_PROC = SECRC\n  SAY \"T51TSO: IDS DEFAULT LPROC IS \" DEFAULT_PROC\n  IF (DEFAULT_PROC = \"$NOTFOUND\") THEN DO\n    MSG2 = \"ID HAS NO DEFAULT PROC IN TSS,\"\n    MSG2 = MSG2 \"MAY NEED THE DEFTSO CMD ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  IF (DEFAULT_ACCT = \"$NOTFOUND\") THEN DO\n    MSG2 = \"ID HAS NO DEFAULT ACCOUNT IN TSS,\"\n    MSG2 = MSG2 \"MAY NEED THE DEFTSO CMD ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSAY \"T51TSO: FALL THRU AREA REACHED. SETTING MSG AND EXITING\"\nSAY \" \"\nSECRC = ACTION \"FUNCTION COMPLETED\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nELSE SAY SECRC MSG2\nEXIT 0\nSEEYA: NOP\nSAY \"T51TSO: **FATAL** ERROR OCCURRED IN LINE :\" SIGL\nTEMP = SOURCELINE(SIGL)\nSAY \"T51TSO: LINE\" SIGL \"=\" TEMP\nIF RC = 8 THEN DO\n  SECRC = \"FUNCTION FAILED. CONFIRM VALIDITY (OWNERSHIP) OF DATA\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY \"T51TSO: *************************************************\"\n  SAY \"T51TSO: EXITING WITH RC = 08 PROBABLE TSS COMMAND FAILURE\"\n  SAY \"T51TSO: *************************************************\"\n  EXIT 8\nEND\nNOBOOK: NOP\nSAY \"T51TSO: ERROR OCCURRED IN LINE :\" SIGL\nTEMP = SOURCELINE(SIGL)\nSAY \"T51TSO: LINE\" SIGL \"=\" TEMP\nIF RC = 8 THEN DO\n  SECRC = \"FUNCTION FAILED. BOOK NUMBER MAY NOT EXIST \"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY \"T51TSO: EXITING WITH RC = 08 PROBABLE TSS OWNERSHIP ERROR.\"\n  EXIT 8\nEND\nSAY \"T51TSO: *************************************************\"\nSAY \"T51TSO: EXITING WITH RC = 16 !  FATAL ERROR.\"\nSAY \"T51TSO: *************************************************\"\nEXIT 1\nNOTSSDEF: NOP\nSAY \"T51TSO: A PERMIT ERROR OCCURRED IN LINE:\" SIGL\nSECRC = \"ABORTED.\" TSS_RESOURCE\" IS UNOWNED IN TSS.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY OUT.1\nSAY OUT.2\nSAY OUT.3\nSAY \"T51TSO: \"SECRC\nEXIT 8\nNOTSSID: NOP\nSAY \"T51TSO: THE ID YOU HAVE GIVEN DOES NOT EXIST\"\nSECRC = \"ABORTED. NO SUCH TOP SECRET ID, UNDER YOUR OWNERSHIP.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nBOOKAUTH: NOP\nSAY TSSCHECK RCODE WAS X5\nSECRC = \"YOU ARE NOT AUTHORIZED FOR THIS BOOK FUNCTION. BOOK= \" ACCTNUM\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nBOOKREMA: NOP\nSAY TSSCHECK RCODE WAS X5\nSECRC = \"YOU CANT OVERLAY BOOK VALUE = \"BOOK\". TRY ADDACCT INSTEAD.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n\nTSSNOADD: NOP\nSAY \"T51TSO: AN OWNERSHIP ERROR OCCURRED IN LINE:\" SIGL\nSECRC = \"ABORTED.\" TSS_RESOURCE\" OWNERSHIP RESOLUTION FAILED IN TSS.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T51TSO: \"SECRC\nEXIT 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53TSSIM": {"ttr": 10755, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x009\\x00\\x955/\\x01\\x00\\x05O\\x115\\x00*\\x00*\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-02-23T11:35:39", "lines": 42, "newlines": 42, "modlines": 0, "user": "*SPIV8*"}, "text": "/* REXX THE WONDER DOG */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* ROUTES THE OUTPUT OF A TSSSIM COMMAND TO A DATASET OF YOUR CHOICE */\n/*********************************************************************/\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n SAY \"ACID RTYPE RNAME FACILITY ACCESS DSOUT\"\n SAY ACID RTYPE RNAME FACILITY ACCESS DSOUT\n IF RTYPE = \"VOLUME\" THEN RTYPE = \"DASDVOL\"\n IF RTYPE = \"VOL\" THEN RTYPE = \"DASDVOL\"\n ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"ALLOC DDN(SIM$$OUT) DSN(\"DSOUT\") SHR REUS\"\n OUT.1 = \"  LOGON ACID(\"ACID\") FAC(\"FACILITY\") TRACE \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") MOD REUS\"\n OUT.1 = \"  $\"RTYPE\"(\"RNAME\") ACCESS(\"ACCESS\")  \"\n IF ACCESS = \".NA.\" THEN\n   OUT.1 = \"  $\"RTYPE\"(\"RNAME\")\"\n IF RTYPE = \"DSN\" THEN\n   OUT.1 = \"  $\"RTYPE\"('\"RNAME\"') ACCESS(\"ACCESS\")  \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \" FREE DDN(OUTFILE)\"\n ADDRESS TSO \"ALLOC DDN(SIM$$IN) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"TSSSIM\"\n ADDRESS TSO \" FREE DDN(SIM$$IN)\"\n ADDRESS TSO \" FREE DDN(SIM$$OUT)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53UNDEL": {"ttr": 10757, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00W\\x00\\x955/\\x01\\x00\\x07_\\x10S\\x00:\\x00:\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2000-03-15T10:53:57", "lines": 58, "newlines": 58, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED UADS STEP .....................              **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T50UNDEL                          **/\n/** LAST MODIFIED    : 31 MAR 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID TO BE RECREATED                   **/\n/** MODE    : THE MODE \"ONLINE\" OR \"BATCH\"               **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS1     : A FLAT FILE LRECL 80                       **/\n/** DS2     : A FLAT FILE LRECL 80                       **/\n/** DSBACK  : A PDS CONATAINING MEMBER (ACID)            **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (BUT IT NEEDS VGETS !)      **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : RXREPRO T44CON       **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS TSO\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nACID_COPY = \"'\"DSBACK\"(\"ACID\")'\"\nUADS_COPY = \"'\"UADSBACK\"(\"ACID\"0)'\"\nIF SYSDSN(ACID_COPY) \u00ac= \"OK\" THEN DO\n  say \"enqueue failed on\" acid_copy\n  secrc = \"Acid not resurrectable, no backup available. sorry\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 00\nEND\nIF MODE = \"ONLINE\" THEN DO\n  /* \"SMCOPY FDS(\"ACID_COPY\") TDS(\"DS1\") NOTRANS\"*/\n  ADDRESS TSO \"%RXREPRO \" ACID_COPY DS1\n  ADDRESS TSO \"%T50ICOMP  REBUILD BYPASS\"\n  ADDRESS TSO \"SUBMIT\" DS2\n  secrc = \"Job submitted to resurrect id \" acid\". check uads entries\"\n  END\nELSE DO\n  BJCL.1 = \"  %RXREPRO \"ACID_COPY DS1\n  BJCL.2 = \"  ISPSTART CMD(%T50ICOMP REBUILD ACID  ) NEWAPPL(TSS)\"\n  BJCL.3 = \"  SUBMIT\" DS2\n  BJCL.4 = \"  \"\n  ADDRESS MVS \"EXECIO 4 DISKW BJCL ( FINIS STEM BJCL.)\"\n  secrc = \"Batch file has been updated with resurrection stream.\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T53USUS": {"ttr": 12289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x14\\x01\\x00\\x16\\x7f\\x01\\x07\\x12\\x8f\\x11\\x07\\x00N\\x00F\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2007-05-08T11:07:14", "lines": 78, "newlines": 70, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** CHANGED THE TSOUSERS LOOKUP                          **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T53USUS                           **/\n/** LAST MODIFIED    : 04 apr 2001                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ID TO UNSUSPEND                        **/\n/** ARG2    :                                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**                                                      **/\n/**********************************************************/\n ARG ACID MODE PWVAL\n /*******************************************************/\n /* dont use mode currently but it is here if I need it */\n /*******************************************************/\n say \"T53USUS: in control with parms \" acid mode pwval\n SYSENV = SYSVAR(SYSENV)\n SIGNAL OFF ERROR\n ADDRESS TSO \"%T53IDAT \"ACID\" UNSUSPEND\"\n idat_drc= rc\n OTT = OUTTRAP(OUT,0)  /* TRAP EVERYTHING */\n say \"T53USUS: IDATA drc:\" idat_drc\n ADDRESS TSO \"%T52GDAT \"ACID\" ATTRIBUTES\"\n ADDRESS ISPEXEC \"VGET SECRC \"\n ADDRESS TSO \"TSS REMOVE(\"ACID\") SUSPEND\"\n IF PWVAL = \"SAME\" THEN  DO\n   say \"T53USUS: issuing  address tso tss rep(\"acid\") password(*,60)\"\n   ADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(*,60)\"\n END\n ELSE DO\n   say \"T53USUS: issuing address tso tss rep(\"acid\") password(\"pwval\")\"\n   ADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(\"PWVAL\")\"\n END\n say \"T53USUS: attributes are \" secrc\n if secrc = \"$BADACID\" then do\n   secrc = \"That ID doesn't exist or you cannot administer it\"\n   signal badid\n end\n IF POS(\"ASUSPEND\",SECRC) \\= 0 THEN ADMIN_SUSPEND = \"YES\"\n IF POS(\"ADMIN SUSPEND\",SECRC) \\= 0 THEN ADMIN_SUSPEND = \"YES\"\n SIGNAL ON ERROR NAME BADID\n say \"T53USUS: received control env is \"sysenv\n CHKACID = ACID\n IF LENGTH(ACID) = 8 THEN CHKACID = SUBSTR(ACID,1,7)\n IF ( SYSENV = \"FORE\" ) & ( ACID= \" \" ) THEN\n   ADDRESS ISPEXEC \"VGET ACID PROFILE\"\n SECRC = \"Retrieval failed for ID:\" ACID\n say \"T53USUS: calling TSS for ACID\" acid\n IF ADMIN_SUSPEND = \"YES\" THEN DO\n   SECRC = \"ID is ASUSPENDED, you are not authorized to remove\"\n   say \"T53USUS: ACID is admin suspended removing asuspend\"\n   ADDRESS TSO \" TSS REM(\"ACID\") ASUSPEND\"\n   say \"T53USUS: ACID was Admin suspended setting message\"\n   MSG2 = \"Warning: ID was manually suspended by an administrator!\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n END\n SECRC = \"ID unsuspend sucessful for \"ACID\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n else say \"T53USUS:\" secrc\n EXIT 00\n BADID: RCODE = RC\n say \"T53USUS: entering error recovery from line \" sigl \"code = \" rcode\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n EXIT 08\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T54ICOMP": {"ttr": 7425, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x007\\x01\\x022o\\x01\\x03\\x16/\\t1\\x08P\\x08P\\x00\\x00\\\\\\xe2\\xd7\\xc9\\xe5\\xf8\\\\@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-11-22T00:00:00", "modifydate": "2003-06-11T09:31:37", "lines": 2128, "newlines": 2128, "modlines": 0, "user": "*SPIV8*"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** save prior to deleting acidrul. array                **/\n/**********************************************************/\n/**********************************************************/\n/** Updated allacid. array processing and adding comments**/\n/**********************************************************/\n/**********************************************************/\n/** Started conversion to one array instead of one array **/\n/** for each acid instream. nov 22 2002                  **/\n/**********************************************************/\n/**********************************************************/\n/** added convert support for d,g and t,g in volume      **/\n/** rules  dir may 5 2002                                **/\n/**********************************************************/\n/**********************************************************/\n/** changed some doc spelling DIR FEB 22 2002            **/\n/**********************************************************/\n/** Change to modrule routine to totally remove the      **/\n/** scrolling area of that routine... I don't even know  **/\n/** why that section of the routine was there....        **/\n/**                  DIR Novem 05 2001                   **/\n/**********************************************************/\n/**********************************************************/\n/** July 25 2001 - documentation updates                 **/\n/**********************************************************/\n/** Change to debug modify processing to fix errant ptr  **/\n/** Which caused some scrolling to miss records and      **/\n/** caused records selected during modify to be wrongly  **/\n/** grabbed.         DIR april 12 2001                   **/\n/**********************************************************/\n/** Discovered that modify will not support stacked/     **/\n/** owned resources, and that it would be a bear to      **/\n/** fix so I am leaving it alone.                        **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T53ICOMP                          **/\n/** LAST MODIFIED    : 21Novem     2002                  **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T53JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/**                                                      **/\n/** defgroup = the defgroup OMVS group for invoking the  **/\n/**            %GIVEUID exec.                            **/\n/**                                                      **/\n/** DS1      = work dsn #1 in the SPI system             **/\n/**                                                      **/\n/** DS2      = work dsn #2 in the SPI system             **/\n/**                                                      **/\n/** idebug   = a debug value that can be set to override **/\n/**            debug values in this exec                 **/\n/**                                                      **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/** newpass  = The password value to be used in converts **/\n/**                                                      **/\n/** uidcon   = a value to specify if UIDs are converted  **/\n/**            'as is' or if the %giveuid exec is to be  **/\n/**             used instead.                            **/\n/**            NO =  The GIVEUID exec is issued for a new**/\n/**              UID, unless UID is zero.                **/\n/**            YES = The exact UID will be replicated    **/\n/**              A UID of zero is always be replicated   **/\n/**                                                      **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were passed to me  **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/**********************************************************/\n/** IN the below variables the 'name' area is a variable **/\n/**  which is an actual ACID                             **/\n/**********************************************************/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** acidrul.name.0     How many lines of output for below**/\n/** acidrul.name.#     One line for each permission that **/\n/** acidrul.name.#.0type    the type                     **/\n/** acidrul.name.#.0segment the segment                  **/\n/** acidrul.name.#.0resname the resource name            **/\n/** acidrul.name.#.0restext the resource text            **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                  ARRAY FLOW                          **/\n/**   _______     _______      _______                   **/\n/**  |       |   |       |    |       |                  **/\n/**  | lst1  |   | lst2  |    | lst3  |  acidlst. arrays **/\n/**  |       |   |       |    |       |                  **/\n/**  |_______|   |_______|    |_______|                  **/\n/**      |           |            |                      **/\n/**      |           |            |                      **/\n/**      |           |            |                      **/\n/**   _______     _______      _______                   **/\n/**  |       |   |       |    |       |                  **/\n/**  | rul1  |   | rul2  |    | rul3  |  acidrul. arrays **/\n/**  |       |   |       |    |       |                  **/\n/**  |_______|   |_______|    |_______|                  **/\n/**      |           |            |                      **/\n/**      |           |            |                      **/\n/**      |___________|____________|                      **/\n/**                  |                                   **/\n/**               _______                                **/\n/**              |       |                               **/\n/**              |       |                               **/\n/**              |  all  |               allacid. array  **/\n/**              |       |                               **/\n/**              |_______|                               **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** In the below variable name and type and resource     **/\n/**   are all variables !!                               **/\n/**********************************************************/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** convert.0newid    \"YES\" or \"NO\" depending on if the  **/\n/**                      ACID is changing in the convert **/\n/** convert.0name     The new ACID to replace real one   **/\n/**                      in the ouput stream             **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.convert  = \"NO\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\nDEBUG.GETDATA  = \"NO\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  /*****************************************************************/\n  /* idebug is a value that can be set in the T$$ execs to turn on */\n  /* a specific debug. U&sually for testing something.             */\n  /*****************************************************************/\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /**         The MAKECUST variable               **/\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command.                       **/\n  /** This would be used if you were moving IDs to**/\n  /** another environment and wanted a certain    **/\n  /** command included in the convert to          **/\n  /** support that environment.                   **/\n  /**                           DIR 25 july 2001  **/\n  /**                                             **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\n  /*************************************************/\n  /** A makeauth command is basically a convert   **/\n  /** with two changes:                           **/\n  /** 1 - The new ID is $$                        **/\n  /** 2 - The tss create command is not done      **/\n  /**                                             **/\n  /*************************************************/\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\nsay \"TSA101D: makeauth check was \" make_rc makeauth\nif make_rc = 0 then do\n  /*************************************************/\n  /** Makeacid is just a type of CLONE really     **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n     /* tells the convert routine to change all outbound ACID */\n  convert.0name = \" $$ \"  /* this is the new ACID name */\n  makeacid.0auth = \"YES\"  /* tell the makeacid routine */\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  /*************************************************/\n  /** a clone is a convert with a new ID plugged  **/\n  /** into the output, so we set some flags and   **/\n  /** then change function to REBUILD.            **/\n  /**                                             **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  /*************************************************/\n  /** We use the makeauth feature to plug in the  **/\n  /** %addlocal command into the output           **/\n  /**                                             **/\n  /*************************************************/\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"ANIDTOTRACE\"              /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Nov 22 2002\"\nsay \"TSA101D: T53ICOMP in control with parms \" function acidlist\nsay \"TSA101D: T53ICOMP Maint = \" maint\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nsecrc = \"failed in T53ICOMP. no other information available\"\nsecrc = \"failed during jobcard function\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\n  /*****************************************************************/\n  /** A resource function uses an entirely different variable     **/\n  /** loader routine since the input is in a radically different  **/\n  /** format.                                                     **/\n  /**                                                             **/\n  /**                                                             **/\n  /*****************************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Retrieving profile variables \"\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    if debug.flow = \"YES\" then\n      say \"TSA101D: calling jobcard function. \"\n    address tso \"%T52jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  say \"TSA101D: Output DSN unusable, data written to screen \"\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\naciddup.   =  0\nacidres.   =  \"\"\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 13\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\nBYPASS.0SUPRESS.HOLD.13 = \"ACIDS\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 16\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\n/* BYPASS.HOLD.7 = \"* ACID \"  */\n/* commented above due to the need for admin auth to function */\nBYPASS.HOLD.7 = \"* ACIDS\"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9  = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"* TCONS\"\nBYPASS.HOLD.15 = \"* TRBA\"\nBYPASS.HOLD.16 = \"* TUPT\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 12\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"BASE DIVACID\"\nBYPASS.HOLD.5 = \"BASE ZONEACID\"\nBYPASS.HOLD.6 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.7 = \"* LASTUSED\"\nBYPASS.HOLD.8  = \"AUTHORITY ACID\"\nBYPASS.HOLD.9  = \"BASE ZONEACID\"\nBYPASS.HOLD.10= \"* TCONS\"\nBYPASS.HOLD.11= \"* TRBA\"\nBYPASS.HOLD.12 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\n/*****************************************************************/\n/*****************************************************************/\n/* all variables are initialized.....the main section(s) follow  */\n/*****************************************************************/\n/*****************************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Basic initialization complete, execution begins.\"\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  say \"TSA101D: Resource processing started\"\n  /*****************************************************************/\n  /* Lets either issue the tss list or read in the data from file  */\n  /*****************************************************************/\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  /*****************************************************************/\n  /* I code the two ifs this way because an else when in multiple  */\n  /* loops is confusing...dir                                      */\n  /*****************************************************************/\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    say \"TSA101D: Bypass option specified, allocating input DSN\"\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n                           /* below we save the starting line #  */\n                           /* of each acid.. not sure why        */\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      if debug.resource = \"YES\" then\n        say \"Owner = \" acidnum \"name = \" owner\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      /* lets grab the acid */\n      parse var line drop 'ACID(' name ')' drop2\n    /*****************************************************************/\n    /* In resources the ACID with the auth is way to the right on    */\n    /*  the report so we note each of them for future reference      */\n    /*  Note the .name portion of the below variable insures that    */\n    /*  even if one ACID has authorites in multiple areas of the     */\n    /*  output, it is counted only once. The classic variable named  */\n    /*  variable....                                                 */\n    /*****************************************************************/\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\"\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      if debug.resource = \"YES\" then\n        say \"acidnum = \" acidnum \"name = \" name\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    say \"TSA101D: Total acids referenced in input is \" acidnum\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  say \"TSA101D: Bypass option specified, allocating input dsn\"\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    /* say \"LINE =\" w.1 w.2 w.3 w.4  */\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  say \"TSA101D: Total acids contained in input DSN is \" acidnum\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n    /* each acid receives its own list area.. should be one */\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    say \"TSA101D: Listing ACID \"hold\" with data \"data \".\"\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we create  the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nif debug.flow = \"YES\" then\n  say \"TSA101D: Evaluation of TSS generated data begins.\"\nevaluate: nop  /* a branch to point for a resource convert */\n/*************************************************/\n/*************************************************/\n/** The below routine does the exact same thing **/\n/** for both resource and standard output, since**/\n/** the variable structure created above is the **/\n/** same for either.                            **/\n/*************************************************/\n/*************************************************/\nlinenum = 0\nlinehold= 0\nif debug.flow = \"YES\" then do\n  say \"TSA101D: Evaluate routine in control values as follows:\"\n  say \"acidnum:  \" acidnum\n  say \"accessor.0\" accessor.0\n  say \"accessor.1\" accessor.1\nend\nrules = 0\ndo num = 1 to acidnum\n  /************************************************/\n  /**This outer loop is once for each acid passed**/\n  /** to me. Dave 18 June 99                     **/\n  /************************************************/\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"TSA101D: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"         Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Acidlst.\"name\".0 is\" acidlst.name.0\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    /* */\n    /* the below statements just clear the variables... */\n    acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0concat  = \"NO\"\n    setf = setval(rules,0flag,hex00)\n    setf = setval(rules,0ACID,name)\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    /*\n    setf = setval(rules,0restext,\" \")\n    setf = setval(rules,0type,\" \")\n    setf = setval(rules,0segment,\" \")\n    setf = setval(rules,0concat,\"NO\")\n    setf = setval(rules,0resname,\" \") */\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if debug.trans = \"YES\" then do\n      say \"  \"\n      say \"TSA101D: Translation starting for below data:\"\n      say \"         \"line\n    end\n    if word(line,1) = \"TSS0300I\" then iterate a1\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n      acidrul.name.a1.0concat  = \"YES\"\n      setf = setval(rules,0concat,\"YES\")\n    end\n    first11 = substr(line,1,11)\n    /* below we take 2 words and make one for first 11 */\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    /* say w.1 w.2 w.3 w.4 */\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      if debug.trans = \"YES\" then\n        say \"TSA101D:  Segment changed to \"segment \"for \" name\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      if debug.trans = \"YES\" then\n       say \"TSA101D: lcf detected:\" w.2\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area input line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n      w.1 = w.1\".\"savefac\n      if debug.trans = \"YES\" then\n        say \"TSA101D: lcf area reformated line:\",\n        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then linehold = linehold - 1\n    if linehold < 0 then linehold = 0\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = acidrul.name.rules.0restext\n      acidrul.name.rules.0restext = strip(hold) tzq1\n      setv = setval(rules,0restext,strip(hold) tzq1)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T53ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n      acidrul.name.rules.0concat  = \"YES\"\n      setf = setval(rules,0concat,\"YES\")\n /*   say \"Setting concat to yes for record \" rules  */\n      hold1 = acidrul.name.rules.0concat\n      hold = restext(rules)\n      if debug.trans = \"YES\" then do\n        say \"TSA101D: Concat rule \",\n        \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold\n      end\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n    acidrul.name.a1.0concat  = \"NO\"\n    setf = setval(rules,0concat,\"NO\")\n    acidrul.name.rules = segment type resource\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource\n    setf = setval(rules,\"RESET\",segment type resource)\n    setf = setval(rules,0segment,segment)\n    setf = setval(rules,0type,type)\n    setf = setval(rules,0resname,resource)\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n    acidrul.name.rules.0restext = \" \"\n    setf = setval(rules,0restext,\" \")\n    do t1 = 3 to words\n      hold = getval(rules,0restext)\n      acidrul.name.rules.0restext = strip(hold) strip(w.t1)\n      setf = setval(rules,0restext,strip(hold) strip(w.t1))\n    end\n    if debug.trans = \"YES\" then do\n      say \"TSA101D: Type/Rname/Text =\" getval(rules,0type) \"/\",\n      getval(rules,0resname)\"/\",\n      getval(rules,0restext)\n    end\n  end\n  acidrul.name.0 = rules\n  linenum = linenum + rules\nend\nsay \"Total lines of translated data is:\" linenum\nallacid.0 = rules\nif debug.flow = \"YES\" then\n  say \"TSA101D: Translation streams have been built.\",\n  \"Starting function check.\"\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter, or we did a translate function.    */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  if debug.flow = \"YES\" then\n    say \"TSA101D: Permit/rebuild/revoke area in control.\"\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do t = 1 to allacid.0\n    if debug.flow = \"YES\" then\n      say \"TSA101D: Starting to process LINE #\" t\n    if debug.name.t = \"TRACE\" then trace r\n    call getadata t\n    hold = next\n    record_number = t\n    name = allacid.t.0acid\n    call convert function hold\n    trace off\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = linenum\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  say \"TSA101D:  MODIFY starting to process ACID:\" name\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    /* thisrec is the rec at the top of the screen */\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt /* scan the screen for an option */\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: S found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: D found on line\" t\n        end\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n        acidrul.name.y = segment type resource\n        setf = setval(y,\"RESET\",segment type resource,)\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: M found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        say \"TSA101D: t=\" t \"thisrec=\" thisrec\n        say \"TSA101D: Subscript is now:\" y\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          say \"TSA101D:\"\n          say \"MODIFY:segment type resource \"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          /* modrule creates the variable conlist     */\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs\n          setf = setflag(y,'*MODIFY')\n          /* */\n          setf = setval(y,0concat,\"YES\")\n          acidrul.name.y.0concat = \"YES\"\n          /* */\n          acidrul.name.y = segment type rsname\n          setf = setval(y,\"RESET\",segment type rsname,)\n          /* */\n          acidrul.name.y.0resname  = rsname\n          setf = setval(y,0resname,rsname)\n          /* */\n          acidrul.name.y.0restext  = modrule.newrs\n          setf = setval(y,0restext,modrule.newrs)\n          /* */\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          say \"TSA101D: secure routine failed access \"\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: A found on line\" t\n        end\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T53ICOMP:addition routine entered outnum=\" outnum\n        say \"T53ICOMP:addition routine entered target=\" target\n        say \"T53ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T53ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          /*** zzzzebra **/\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          f = setval(q,0segment,getval(q1,0segment))\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          f = setval(q,0flag,getval(q1,0flag))\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          f = setval(q,0type,getval(q1,0type))\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          f = setval(q,0restext,getval(q1,0restext))\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n          f = setval(q,0resname,getval(q1,0resname))\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        if debug.modify = \"YES\" then do\n          say \"TSA101D: Calling modrule\"\n        end\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setval(fill,0concat,\"YES\")\n        setit = setflag(fill,\"*NEWRULE\")\n        setit = setval(fill,0flag,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        setit = setval(fill,0type,type)\n        acidrul.name.fill.0segment  = segment\n        setit = setval(fill,0segment,segment)\n        acidrul.name.fill.0resname  = rsname\n        setit = setval(fill,0rsname,rsname)\n        acidrul.name.fill.0restext  = modrule.newrs\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  say \"TSA101D: leaving modify\"\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\nif function = \"TRANSLATE\" then\n  say \"acidrul.name array || multiline ? || segment || data \"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\nif function = \"TRANSLATE\" then do qt = 1 to allacid.0\n    say qt allacid.qt.0concat allacid.qt allacid.qt.0restext\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nif debug.makeacid = \"YES\" then\n  say \"TSA101D: Making ACID:\" function\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    if debug.makeacid = \"YES\" then\n      say \"TSA101D: Owner resolved to:\" own_str\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  if debug.makeacid = \"YES\" then\n    say \"TSA101D: Makeacid type for \"name\" is :\" acid_type\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nif debug.makeacid = \"YES\" then\nsay \"TSA101D: leaving makeacid # output = \"create_num create.1 create.2\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  acidrul. cvtnum concat lcffac debug. convert. record_number allacid.\nparse arg function segment inline\nsay \"TSA101D: convert called with \" function segment inline\nname = getval(record_number,0acid)\noname = name\nconcat = getval(record_number,0concat)\nif debug.newgdata = \"YES\" then concat = allacid.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nif debug.flow = \"YES\" then\n  say \"TSA101D: output name for convert is \" oname \"concat is\" concat\nif debug.flow = \"YES\" then\n  say \"TSA101D: Converting for \"name\":\"function segment \">\"||inline||\"<\"\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XAVOLUME\") then do\n  /*********************************************************/\n  /* a volume generic of (d,g) or (t,g) is invalid so we   */\n  /* handle it here.                                       */\n  /*********************************************************/\n  where_gen = index(inline,\",G)\")\n  if where_gen /= 0 then do\n    if debug.convert = \"YES\" then\n      say \"TSA101D: Vol generic, Input dsn line \"inline\n     parse var inline hz1  ',' hz2\n    inline = hz1||hz2\n    if debug.convert = \"YES\" then\n      say \"TSA101D: Reformatted vol generic line \"inline\n  end\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Input dsn line \"inline\n  inline = \"XADSN\"||substr(inline,10)\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatted dsn line \"inline\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  hold = translate(substr(inline,10),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" %giveuid \" oname defgroup\n  if debug.convert = \"YES\" then\n    say \"TSA101D: Reformatter area completed convert. returning.\"\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\n  IF W.1 = \"SCOPEACID\" THEN W.1 = \"SCOPE\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MAS\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif getval(record_number,0concat) = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = getval(record_number,0concat)\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"TSA101D: XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nif debug.convert = \"YES\" then\n  say \"TSA101D: Resource is \"resource \"concat is\" concat\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  if debug.convert = \"YES\" then do\n    rule = bypass.function.rulehold\n    say \"TSA101D: bypass rule tripped, Rule is below:\"\n    say \"     \" Rule\n  end\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REM\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then\n  say \"TSA101D:***** CONVERT OUTPUT IS NOW :\" output\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T53ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. allacid. name hex00 aciddup. debug. linenum function balout\nOPT = \" \"\nif debug.fillscr = \"YES\" then\n  say \"TSA101D: Fillscr invoked. Thisrec=\" thisrec\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T53ICOMP: TOP OF DATA REACHED\"\nEND\nh1 = linenum - 13\ntempz1 = linenum\n/* save this value for the display below*/\nif debug.fillscr = \"YES\" then\n    say \"TSA101D: h1=\" h1 \"acidrul.\"name\".0=\"  tempz1\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 13\n  MSG = \"T53ICOMP: BOTTOM OF DATA REACHED\"\n  if debug.fillscr = \"YES\" then\n    say \"TSA101D: Bottom of data thisrec set to :\"thisrec\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T53ICOMP: TOP OF DATA REACHED\"\nEND\nif debug.fillscr = \"YES\" then do\n  say \"FILLSCR: thisrec=\" thisrec\n  say \"TSA101D: filling screen:\",\n    \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\nend\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  maxdata = acidrul.name.0\n  if debug.fillscr = \"YES\" then do\n    say \"TSA101D: fillscr calling subfunctions with subscript:\" script\n    say \"         maxdata is:\" maxdata\n  end\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if debug.fillscr = \"YES\" then do\n    say \"TSA101D: fillscr segment=\"segment\n    say \"   type=\"type \"resource=\"resource \"fchk=\"fchk\n  end\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose name acidrul. aciddup. next\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidrul.name.0\n  call getdata out\n  say out \"=\" next\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. aciddup. next acidlst.\nsay \"TSA101D: Dumping acidrul array for \" name\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ngetdata: procedure expose acidrul. aciddup. next name,\n  getdata. debug. record_number\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata invoked with:\" name record_number\nt = record_number\nsegment  = strip(acidrul.name.t.0segment)\ntype     = strip(acidrul.name.t.0type)\nresource = strip(acidrul.name.t.0resname)\ntheres   = strip(acidrul.name.t.0restext)\ndupchk   = \"\"\ndupnum   = \"\"\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getdata base resource:\" acidrul.name.t.0resname\n  say \"TSA101D: Getdata resource data:\" theres\nend\nif dupchk = \"DUPLICATE\" then do\n  theres = aciddup.name.type.resource.dupnum\n  if debug.getdata = \"YES\" then\n    say \"Getdata:Record # \" t \"Duplicate processing:\" dupnum theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetadata: procedure expose allacid. name next,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nif debug.getdata = \"YES\" then do\n  say \"TSA101D: Getadata invoked with:\" record_number\n  say \"New Getadata results:\"\n  say allacid.t\n  say allacid.t.0segment\n  say allacid.t.0type\n  say allacid.t.0resname\n  say allacid.t.0restext\n  say \"*******\"\nend\nt = record_number\ndebug.newgdata = \"YES\"\nsegment  = strip(allacid.t.0segment)\ntype     = strip(allacid.t.0type)\nresource = strip(allacid.t.0resname)\ntheres   = strip(allacid.t.0restext)\nif debug.Getdata = \"YES\" then do\n  say \"TSA101D: Getadata base resource:\" allacid.t\n  say \"TSA101D: Getadata resource data:\" theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult = getval(tempin,0segment)\nsay \"Segment returning\" result\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\n/*******************************************************/\n/*******************************************************/\n/**Gets the access from a string parens must be gone  **/\n/**prior to invocation.                               **/\n/*******************************************************/\n/*******************************************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult = getval(tempin,0type)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult = getval(tempin,0restext)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nsetv = setval(tempin,0flag,theflag)\nreturn 0\n/************************/\n/************************/\ngetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**Gets the allacid array variable specified.         **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nresult = allacid.record.varname\nreturn result\n/************************/\n/************************/\nsetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**sets the allacid array variable to specified value **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nnewvalue= arg(3)\n/*\nsay \"SETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"to\" newvalue\n  */\nallacid.record.varname = newvalue\nif varname = \"RESET\" then\nallacid.record  = newvalue\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = getval(tempin,0flag)\n/* say \"getflag: \" res */\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. name acidrul. conlist modrule. rstype debug.,\n fill_override allacid.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\n/*\nif thisrec < 1 then do\n   thisrec = 1\n   msg = \"T53ICOMP: top of data reached\"\nend\nh1 = acidrul.name.0 - 14\nif h1 < 1 then h1 = 1\nif (thisrec > h1 )  then do\n  thisrec = h1\n  msg = \"T53ICOMP: bottom of data reached\"\nend\n*/\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80ADD": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x058\\x00\\x17\\x00\\x955/\\x01\\x07\\x13_\\t0\\x01\\x7f\\x01s\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.56", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-15T09:30:17", "lines": 383, "newlines": 371, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T80ADD                            **/\n/** LAST MODIFIED    :  2 Jul 2003                       **/\n/**********************************************************/\n/** Added smarts to routine to insert the password parm  **/\n/** on the create if it doesn't exist and honor it if it **/\n/** does dir july 2 2003                                 **/\n/**********************************************************/\n/** added variable for default department vget           **/\n/**********************************************************/\n/** changed acid variable manipulation so that the acid  **/\n/** variable remains a little more stable.               **/\n/**                                .....DIR 19 AUGUST 96 **/\n/**********************************************************/\n/**********************************************************/\n/** ADDED LOGIC TO DETERMINE IF ID HAS DSNS CATLGD IN    **/\n/** MASTER CAT YET HAS NO ALIAS        DIR  11 MAY 95    **/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nSAY \"T80ADD: CONTROL RECEIVED PARMS = \" ACID MODE\nADDRESS ISPEXEC\n\"VGET AUD       PROFILE\"\n\"VGET DEF       PROFILE\"\n\"VGET DS1       PROFILE\"\n\"VGET DS2       PROFILE\"\n\"VGET DS3       PROFILE\"\n\"VGET DS4       PROFILE\"\n\"VGET DS5       PROFILE\"\n\"VGET DS6       PROFILE\"\n\"VGET MSG2      PROFILE\"\n\"VGET PROD      PROFILE\"\n\"VGET TSOSIZE   PROFILE\"\n\"VGET TSOUNIT   PROFILE\"\n\"VGET TSOPROC   PROFILE\"\n\"VGET TVER      PROFILE\"\nSIGNAL OFF ERROR\n/**********************************************************/\n/** below I am checking that the id doesnot have dsns    **/\n/** cataloged to the master catalog. if it does the      **/\n/** user wont be able to catalog his own datasets. this  **/\n/** will cause allocate errors that are hard to track.   **/\n/** i may make this a seperate callable exec but for     **/\n/** now it is included here    dave 11 may 95            **/\n/**********************************************************/\nDATEHOLD = DATE('U')\nMONTHNUM = SUBSTR(DATEHOLD,1,2)\nADDRESS TSO \"%T80GDAT \"ACID \"NAME\"\nOLDID = RC\noutct = 40\nBOOK = \"NIL\"\nBOOK1 = \"NIL\"\nSAY \"TSA101D: T80ADD  EXISTANCE CHECK RC IS \" OLDID\nIF OLDID = 0 THEN DO\n  msg2 = \"This id exists currently, readdition will fail upon\",\n  \"execution\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\n/**************************************/\n/* get the default department         */\n/**************************************/\nADDRESS ISPEXEC \"VGET DEFDEPT PROFILE\"\nADDRESS ISPEXEC \"VGET TSOALIAS PROFILE\"\nIF TSOALIAS = \"YES\" THEN DO\n  ADDRESS TSO \"LISTC ENT('\"ACID\"')\"\n  SAY \"TSA101D: T80ADD  ALIAS CHECK IS \" RC\n  ALIAS_CODE = RC\n  ADDRESS TSO \"LISTC LEVEL('\"ACID\"')\"\n  SAY \"TSA101D: T80ADD  LEVEL CHECK IS \" RC\n  LEVEL_CODE = RC\n  IF (ALIAS_CODE \u00ac= 0) & (LEVEL_CODE =0)  THEN DO\n    msg2 = \"The id has no alias, yet has dsns cataloged, expect\",\n    \"severe allocation errors\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSIGNAL ON ERROR NAME ABORT\n/**********************************************************/\n/** END OF DSN ALIAS / LEVEL CHECKING                    **/\n/**********************************************************/\nLINE.  = \" \"\nALEN   = LENGTH(ACID)\nBILLA  = \"N\"\nCODE   = 0\nCURSOR = \"NAME\"\nDEFINE = \"NAME('\"NAME\"') DEPT(D0) TYPE(USER)\"\nFIRST2 = SUBSTR(ACID,1,2)\nGOTDEF = \"NO\"\nLOGON  = TSOPROC\nNDEPT  = FIRST2||\"DEPT\"\nif defdept /= \"NONE\" then ndept = defdept\nPROF   = \" \"\nPWORD  = \"PASSWORD,60,EXP\"\nSECDEF. = \" \"\nsecrc  = \"T80ADD did not complete normally. please check the id.\"\nS2     = ALEN - 1\nTYPE   =  \"USER\"\nWARNED = \"NO\"\n\"VPUT SECRC PROFILE\"\nPW = \"PASSWORD\"\nDPNL   = \"SPIADD\"\nBASIC_ACID = \" \"\nAUDU.0 =   1\nAUDU.1 =   \"%ADDLOCAL\" ACID NDEPT\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER) PASSWORD(\"PW\",60,EXP)\"\n/****************************************************/\n/** the tso authority stream is below              **/\n/****************************************************/\n/*                                                                  */\n/*batchtso.0 = 3                                                    */\n/*batchtso.1 = \" \"                                                  */\n/*batchtso.2 = \"ISPSTART CMD(%\"TVER\"TSO DEFAULTS +\"                 */\n/*batchtso.3 = \" \"ACID LOGON BOOK1 TSOUNIT TSOSIZE\") NEWAPPL(TSS)\"  */\n/*onlintso.0 = 1                                                    */\n/*onlintso.1 =\"%\"TVER\"TSO DEFAULTS\" ACID LOGON BOOK1 TSOUNIT TSOSIZE*/\n/*                                                                  */\n/****************************************************/\n/** beginning of the panel loop                    **/\n/** beginning of the panel loop                    **/\n/****************************************************/\nAGAIN: NOP\nCALL FILLSCR\n\"DISPLAY PANEL(\"DPNL\")  CURSOR(\"CURSOR\")\"\nRCODE = RC\nif enum = \" \" then enum = \"000000    initial \"\nNAME = TRANSLATE(NAME,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSAY \"TSA101D: T80ADD  PANEL RCODE IS \"RCODE\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ERRMSG\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\nGETNAME: NOP\nCNT1 = 0\nNORMAL: NOP\nMEMBER = mem\nIF MEM = \"\" THEN MEMBER = NDEPT\nmem = member\nSAY \"TSA101D: CHECKING FOR DEFAULT DEPT AUTHORITIES\" DEF\"(\"MEMBER\")\"\nIF SYSDSN(\"'\"DEF\"(\"MEMBER\")'\") = \"OK\" THEN DO\n  say \"tsa101d: T80ADD  default authority group found for in \" def bin\n  address tso \"alloc ddn(secdef) dsn('\"def\"(\"member\")') shr reus\"\n  address mvs \"execio * diskr secdef ( finis stem secdef.)\"\n  address tso \"free ddn(secdef)\"\n  /******************************************************/\n  /***                                                ***/\n  /*** NOTE: THE FIRST LINE OF THE DSN MUST HAVE A    ***/\n  /*** CREATE PARM IN IT! IF THERE IS NO MEMBER I     ***/\n  /*** ASSIGN A VALUE TO SECDEF.1                     ***/\n  /***                                                ***/\n  /******************************************************/\n  SECDEF.1 = \"NAME('\"NAME\"')\" SECDEF.1\n  GOTDEF = \"YES\"\nEND\nELSE Do\n  secdef.1 = define /* if no member we just create a 1 liner */\n  if enum /= \" \" then\n    secdef.2 = \"TSS add(\"acid\") instdata('\"enum netid\"')\"\nEND\nsay \"T80ADD: secdef.1 is\" secdef.1\nsay \"T80ADD: secdef.2 is\" secdef.2\nDO T = 1 TO 40\n  /******************************************************/\n  /***                                                ***/\n  /*** ONCE HERE THERE HAS TO BE A SECDEF.1 VALUE AND ***/\n  /*** IT HAS IS    COMPRISED OF VALID 'CREATE' PARMS ***/\n  /*** FOR TOP SECRET. THE REST OF THE SECDEF. STRING ***/\n  /*** MAY CONTAIN commands to be issued by the       ***/\n  /*** system sight unseen.                           ***/\n  /******************************************************/\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \" T80ADD: $$ substitution string found in secdef\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n    say \" T80ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \" T80ADD: $DEPT$ substitution string found in secdef\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n    say \" T80ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$ENUM$\") /= 0 then do\n    say \" T80ADD: $ENUM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$ENUM$' q2\n    secdef.t = q1||Enum||q2\n    say \" T80ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$MEM$\") /= 0 then do\n    say \" T80ADD: $MEM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$MEM$' q2\n    secdef.t = q1||member||q2\n    say \" T80ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$OPID$\") /= 0 then do\n    say \" T80ADD: $OPID$ substitution string found in secdef\"\n    parse var secdef.t q1 '$OPID$' q2\n    opid = substr(acid,5,3)\n    secdef.t = q1||opid||q2\n    say \" T80ADD: resolved secdef is \"secdef.t\n  end\n  LINE.T =  strip(secdef.t)\n  say t line.t\nEND\nSCRDISP: NOP\nCALL FILLSCR\nMSG=\"CHANGE DEFAULT COMMAND STREAM IF NEEDED AND HIT ENTER.\"\nIF GOTDEF = \"NO\" THEN\n  MSG=\"NO DEFAULT AUTHORITY STREAM FOUND. ENTER COMMANDS.\"\nPNLDISP: NOP\n\"ISPEXEC DISPLAY PANEL(\"DPNL\")\"\nRCODE = RC\nSAY \"T80ADD: PANEL RCODE IS \"RCODE\nIF MEM /= MEMBER THEN SECDEF. = \" \"\nIF MEM /= MEMBER THEN SIGNAL NORMAL\nNAME = SUBSTR(NAME                  ,1,20)\nCALL FILLDOT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ABORT\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\n/******************************************************************/\n/******************************************************************/\nCOMMIT: NOP\n/*\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"              \"\nLINE.1 = DEFINE\n*/\nIF PW \u00ac= \" \" THEN PWORD = PW||\",60,EXP\"\nELSE PW = \"PASSWORD\"\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T80ADD: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1= \"TSS CREATE(\"ACID\") password(\"pword\")  +\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  ADDRESS MVS \"EXECIO \"OUTCT\" DISKW BJCL ( FINIS STEM LINE.)\"\n  /**********************************************************/\n  /*ADDRESS MVS,                                               */\n  /* \"EXECIO \"batchtso.0\" DISKW BJCL ( FINIS STEM batchtso.)\"  */\n\n  SAY \"T80ADD: WRITING DATA TO BJCL DDNAME\"\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM AUDU.)\"\n  CODE = RC\n  IF CODE = 0 THEN SECRC =\"BATCH FILE UPDATED WITH ADD COMMANDS.\"\n  SIGNAL OFF ERROR\n  SIGNAL BYE1\nEND\nTSSCMD = \"YES\"\nADDRESS TSO\nSAY \"T80ADD: ISSUING THE TSS ADD COMMAND FOR THE ID\"\nif index(line.1,\"PASSWORD\") = 0 then do\n  line.1 = line.1 \"PASSWORD(\"PW\",60,EXP)\"\n  SAY \"T80ADD: Inserting default password into create stream\"\nend\nSAY \"T80ADD: TSS CRE(\"ACID\")\" LINE.1\n\"TSS CREATE(\"ACID\")\"  LINE.1\nCODE = RC\nSAY \"T80ADD: THE TSS ADD COMMAND FINISHED WITH A RCODE OF \" CODE\nSIGNAL OFF ERROR\nDO T = 2 TO OUTCT\n   say \"T80ADD: issuing command:\" line.t\n   IF LINE.T < > \" \" THEN\n   ADDRESS TSO \" \"LINE.T\nEND\n/* ADDRESS TSO \"%TSSAUDU \" ACID    */\nSPACES= \"                                                          \"\nSYSDATE = DATE(U)\nBYE:  NOP\nSIGNAL OFF ERROR\nIF  MODE= \"SKIPIT\" THEN DO\n  SAY \"T80ADD: VERSION 5.2 TSO DEFAULTS BEING SET\"\n  BOOK1 = WORD(BOOK,1)\n  rcode = 0\n  do cmdnum = 1 to audu.0\n    say \"T80ADD: issuing cmd : \"onlintso.cmdnum\n    address tso onlintso.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T80ADD: rcode from cmd is \" holdrc\n  end\n  do cmdnum = 1 to audu.0\n    say \"T80ADD: issuing cmd : \"audu.cmdnum\n    address tso audu.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T80ADD: rcode from cmd is \" holdrc\n  end\n  ADDRESS ISPEXEC\n  IF RCODE > 0 THEN DO\n    \"VGET SECRC PROFILE\"\n    msg2 = \"defaults tso setup has failed, check book authorities\"\n    \"VPUT MSG2 PROFILE\"\n    SIGNAL BYE1\n  END\n  SAY \"T80ADD: VERSION 5.0 TSO DEFAULTS HAVE BEEN SET\"\nEND\nJUSTUADS: NOP\nCODE = RC\nSIGNAL ON ERROR NAME BADALIAS\n\nif code = 0 then secrc =\"TSA202I: ACID added. no errors encountered.\"\nBYE1:  NOP\nSIGNAL OFF ERROR\nADDRESS ISPEXEC\n\"VPUT SECRC PROFILE\"\n DATAAREA = ACID\n\"VPUT DATAAREA PROFILE\"\nEXIT 0\nERRMSG: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA201E: Errors encountered. check acid status \"\n  SIGNAL BYE1\nBADALIAS: NOP\n  IF CODE = 0 THEN\n    secrc= \"alias addition failed check acid status \"\n  else secrc = secrc \"and alias addition failed\"\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  SIGNAL BYE1\nABORT: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA200E: Function aborted. acid not added. SIGL:\" sigl\n  SIGNAL BYE1\n/****************************************************************/\n/*  ERROR ROUTINE MESSAGE DISPLAYS.........DIR                  */\n/****************************************************************/\nFILLDOT: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE.1 = LINE1\n  LINE.2 = LINE2\n  LINE.3 = LINE3\n  LINE.4 = LINE4\n  LINE.5 = LINE5\n  LINE.6 = LINE6\n  LINE.7 = LINE7\n  LINE.8 = LINE8\n  LINE.9 = LINE9\n  LINE.10= LINE10\n  LINE.11= LINE11\n  LINE.12= LINE12\n  LINE.13= LINE13\n  LINE.14= LINE14\n  LINE.15= LINE15\nRETURN\nFILLSCR: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE1 = LINE.1\n  LINE2 = LINE.2\n  LINE3 = LINE.3\n  LINE4 = LINE.4\n  LINE5 = LINE.5\n  LINE6 = LINE.6\n  LINE7 = LINE.7\n  LINE8 = LINE.8\n  LINE9 = LINE.9\n  LINE10= LINE.10\n  LINE11= LINE.11\n  LINE12= LINE.12\n  LINE13= LINE.13\n  LINE14= LINE.14\n  LINE15= LINE.15\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80AEMS": {"ttr": 13331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x006\\x01\\x07\"/\\x01\\x071\\x8f\\x137\\x00,\\x00\\x17\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2007-08-10T00:00:00", "modifydate": "2007-11-14T13:37:36", "lines": 44, "newlines": 23, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T80AEMS                           **/\n/** LAST MODIFIED    : 10 July 2007                      **/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : t80idat TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID ENUM NAME\nname = strip(substr(name                                   ,1,21))\nSay \"TSA101D: T80AEMS invoked:\" acid enum name\nif enum = \"$\" then do\n  h1 = \"FAILED :No employee number provided.\"\n  say \"TSA101d:\" h1\n  secrc = h1\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  exit 4\nend\nle = length(enum) -1\nenum = substr(enum,1,le)\ncmd= \"tss create(\"acid\") USING(EMSID) PASSWORD(PASSWORD,90,exp)\"\ncmd= cmd \"name('\"name\"')\"\nSay \"TSA101D: Issuing:\" cmd\nADDRESS  TSO\" \" cmd\nrcode = rc\nSay \"TSA101D: Command rcode :\" rcode\nif rcode = 0 then\n  address tso \"t80idat \"acid\" add \"enum\nSecrc = \"Successful. ID added.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80CADD": {"ttr": 13329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00C\\x01\\x03\\x05\\x0f\\x01\\x071\\x8f\\x13$\\x000\\x000\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2003-02-19T00:00:00", "modifydate": "2007-11-14T13:24:43", "lines": 48, "newlines": 48, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T80CADD                           **/\n/** LAST MODIFIED    :  2 feb 2000                       **/\n/**********************************************************/\n/** This exec take a name and ID stem and gets an OPID   **/\n/** and determines the full ID.                          **/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Stem    : The acid stem , usually 4 characters       **/\n/** MODE    : BATCH or ONLINE passed to T80add           **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG stem fname Lname mode\nSAY \"T80CADD: Control received = \" stem fname lname mode\nfirst = substr(fname,1,1)\nsecond = substr(lname,1,1)\nif length(stem) > 4 then do\n  secrc  =  \"Stem of ACID cannot exceed 4 characters\"\n  ADDRESS ISPEXEC\n  \"VPUT secrc  PROFILE\"\n  exit 4\nend\nsay first second\naddress tso \"%getopid\" first second \"LIVE\"\nname = fname lname\nADDRESS ISPEXEC\n\"VGET dataarea  PROFILE\"\nopid = dataarea\n\"Vput name  PROFILE\"\naddress tso \"%T90add\" stem||opid  mode\naddress tso \"%tssaudu\" stem||opid\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80CMDO": {"ttr": 12293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x12\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x16\\x00A\\x00A\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:16:12", "lines": 65, "newlines": 65, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** ISSUE A COMMAND TRAP THE OUTPUT AND ROUTE IT SOMEWERE**/\n/** I ALSO CHANGE ALL HEX 00 TO BLANKS BECAUSE TSS       **/\n/** SOMETIMES RETURNS SOME '00'X VALUES IN ITS UADS AREA **/\n/**********************************************************/\n/** EXEC NAME        : T50CMDO                           **/\n/** LAST MODIFIED    : 16 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSN TO GET THE OUTPUT                  **/\n/** ARG     : THE ACTUAL COMMAND TO BE ISSUED            **/\n/** DISP    : THE DISP TO ALLOCATE THE DATASET WITH      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : NONE HOWEVER THIS    **/\n/**      EXEC COULD BE PASSED ANOTHER EXEC NAME AND      **/\n/**      INVOKE THAT.                                    **/\n/**********************************************************/\nARG DSN cmd\nHEX00 = '00'X\nsecrc = \"TSA509E: Command not processed. check commands validity.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nif cmd = \"\" then\n  ADDRESS ISPEXEC \"VGET ARG PROFILE\"\nelse arg = cmd\nADDRESS ISPEXEC \"VGET DISP PROFILE\"\nQ = OUTTRAP(OUT.)\nT = 1\n\" \"ARG\nRCODE = RC\nDO Z = 1 TO OUT.0\n  IF LENGTH(OUT.Z) > 80 THEN DO\n    OUTLINE.T = SUBSTR(OUT.Z,1,80)\n    T = T + 1\n    OUTLINE.T = SUBSTR(OUT.Z,81)\n    T = T + 1\n    ITERATE Z\n  END\n  OUT.Z=TRANSLATE(OUT.Z,\" \",HEX00)\n  OUTLINE.T = OUT.Z\n  T = T + 1\nEND\nIF DSN = \"SCREEN\" THEN DO\n  T = T - 1\n  DO Q = 1 TO T\n     IF LENGTH(OUTLINE.Q) > 78 THEN OUTLINE.Q = SUBSTR(OUTLINE.Q,1,78)\n     IF OUTLINE.Q <> \" \" THEN SAY OUTLINE.Q\n  END\n  SIGNAL LETSGO\nEND\n\"ALLOC DDN(OUTPUT) DSN(\"DSN\") \"DISP\" REUS\"\n\"EXECIO * DISKW OUTPUT (STEM OUTLINE. FINIS)\"\n\"FREE DDN(OUTPUT)\"\nLETSGO: NOP\nIF RCODE = 0 THEN\n  secrc = \"TSA514I: Command issued output resides in:\" dsn\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80DEL": {"ttr": 12295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x00T\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x16\\x00O\\x00O\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:16:54", "lines": 79, "newlines": 79, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T80DEL                            **/\n/** LAST MODIFIED    : 17 SEP 98                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID YOU WISH DELETED.                 **/\n/** MODE    : THE CURRENT MODE \"BATCH\" OR \"ONLINE\"       **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** UIDTABLE : THE GROUP OF 2 CHR NON TSS ID PREFIXES    **/\n/** TVER     : THE CURRENT TSS VERSION VARIABLE          **/\n/** DSBACK   : THE DS WHERE TO TAKE A BACKUP COPY        **/\n/** DS5      : THE DS WHERE TO PUT BATCH SYSIN UPDATES   **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES ( NOTE VGETS )              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T4?LSTO TSSAUDR      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nthiscmd = sysvar(sysicmd)\nSIGNAL OFF ERROR\nsecrc = \"TSA510E: \"Thiscmd\" has ended abnormally.\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET TVER PROFILE\"\nADDRESS ISPEXEC \"VGET AUD PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nADDRESS ISPEXEC \"VGET DS5 PROFILE\"\nUIDENTRY = LENGTH(UIDTABLE)/2\nUIDSTART = 1\nACID2 = SUBSTR(ACID,1,2)\nDSLIST = \"'\"DSBACK\"(\"||ACID||\")'\"\nBJCL.0 = 3\nBJCL.1 = \"%\"TVER\"LSTO\" ACID \"ALLPW\"  DSLIST\nBJCL.2 = \"TSS DEL( \"ACID\")\"\nBJCL.3 = \"%DELLOCAL\" ACID\nIF MODE = \"BATCH\" THEN DO\n  say \"tsa101d: batch mode detected. allocating \" ds5 \"to bjcl ddn\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  ADDRESS MVS \"EXECIO \"BJCL.0\" DISKW BJCL (FINIS STEM BJCL.)\"\n  secrc = \"TSA511I: Batch file updated with delete stream for \" acid\nEND\nIF MODE = \"ONLINE\" THEN DO\n  TOTCODE = 0\n  SIGNAL OFF ERROR\n  say \"tsa101d: online mode detected. executing delete stream\"\n  SECRC = \"DELETE COMMAND STREAM FOR \" ACID \"FLUSHED.\"\n  DO CN = 1 TO BJCL.0\n    HOLD = BJCL.CN\n    SAY ADDRESS TSO \" \"   HOLD\n    ADDRESS TSO \" \"   HOLD\n    TOTCODE = RC + TOTCODE\n  END\n  secrc = \"command stream for \" acid \"completed normally.\"\n  IF TOTCODE > 0 THEN\n  secrc = \"stream had partial failure, check ids status. code=\" totcode\n  IF TOTCODE = 16 THEN\n  secrc = \"id may not exist or your authority may be invalid.\"\n  SAY SECRC\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n\nBADTSS: NOP\nsecrc = \"the tss id you specified was not listable, check the id\"\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\nBOOKAUTH: NOP\nSECRC = \"YOU DONT HAVE AUTHORITY TO DELETE AN ID WITH BOOK NUMBER\" BOOK\nADDRESS ISPEXEC \" VPUT SECRC PROFILE\"\nEXIT 0\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80DELB": {"ttr": 12297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x04\\x19\\x7f\\x01\\x07\\x13\\x0f\\x10\\x17\\x00\\x06\\x00\\x06\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-07-15T00:00:00", "modifydate": "2007-05-10T10:17:31", "lines": 6, "newlines": 6, "modlines": 0, "user": "COA1DIR"}, "text": "/*rexx */\narg id\naddress tso \"%T80LSTO \"id\" ALLPW 'SYS4.SPI.IDBACKUP(\"id\")'\"\naddress tso \"TSS DEL( \"id\")\"\naddress tso \"%DELLOCAL\" id\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80DISC": {"ttr": 12299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x04\\x00D\\x00\\x97 /\\x01\\x07\\x13\\x0f\\x10\\x17\\x00o\\x00o\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.04", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2007-05-10T10:17:44", "lines": 111, "newlines": 111, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** TO REMOVE PROFILE FROM ALL THAT HAVE IT              **/\n/**********************************************************/\n/** EXEC NAME        : T80DISC                           **/\n/** LAST MODIFIED    : 06 JUL 97                         **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** MODE    : THE MODE OF OPERATION                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nENV = SYSVAR(SYSENV)\n/**********************************************************/\n/* REMOVE THE BELOW DO IF YOU WANT THIS EXEC TO RUN IN   **/\n/* ONLINE MODE....( YECH !!)                             **/\n/**********************************************************/\nIF (MODE \\= \"BATCH\") & (ENV = \"FORE\") THEN DO\n  SECRC =\"FUNCTION FAILED. DISCONNECT CANNOT BE RUN IN ONLINE MODE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE   \"\n  EXIT 04\nEND\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS ISPEXEC\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS A PROFILE, FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO REMOVE THAT  PROFILE FROM   */\n/* ALL THE IDS THAT HAVE IT ATTACHED.                               */\n/********************************************************************/\nSTARTOUT: NOP\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T80DISC: BATCH MODE DETECTED. USING DDN BJCL AS OUTPUT\"\n  /* ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"   */\nEND\nOUTNUM =  1\n/***********/\nSECRC = \"LIST COMMAND FAILURE, CHECK IDS VALIDITY\"\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(ACIDS)\"\nQ = OUTTRAP(\"OFF\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  IF WORD(INLINE,1) = \"TSS0300I\" THEN\n    SIGNAL OUTSTART\n  IF SUBSTR(INLINE,14,1) = \" \" THEN\n    GOFLAG = NO\n  IF SUBSTR(INLINE,1,5) = \"ACIDS\" THEN\n    GOFLAG=YES\n  IF GOFLAG = YES THEN DO\n    ID.1 = SUBSTR(INLINE,14,8)\n    ID.2 = SUBSTR(INLINE,26,8)\n    ID.3 = SUBSTR(INLINE,38,8)\n    ID.4 = SUBSTR(INLINE,50,8)\n    DO IDCNT = 1 TO 4\n      IF ID.IDCNT = \"*NONE*\" THEN ITERATE X\n      IF ID.IDCNT = \" \" THEN ITERATE X\n      SECRC = \" \"\n    /************************************************************/\n    /************************************************************/\n      SAY \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      IF MODE \\= \"BATCH\" THEN\n        ADDRESS TSO \" TSS REMOVE(\"ID.IDCNT\") PROFILE(\"ACID\")\"\n      ELSE DO\n        BJCL.OUTNUM = \"TSS REM(\"ID.IDCNT\") PROF(\"ACID\")\"\n        OUTNUM = OUTNUM + 1\n      END\n    END\n  END\nEND\nOUTSTART: NOP\nIF MODE = \"BATCH\" THEN DO\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM BJCL.)\"\n  /*ADDRESS TSO \"FREE DDN(BJCL)\"   */\nEND\nSECRC= \"FUNCTION COMPLETED NORMALLY. \"\nIF MODE = \"BATCH\" THEN\n  SECRC= \"FUNCTION COMPLETED NORMALLY. OUTPUT APPENDED TO BATCH FILE.\"\n  IF SYSVAR(SYSENV) = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nCLOSEEM: NOP\nSAY \"LINE IS \"SIGL\nSAY  SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80DSNP": {"ttr": 12301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x00\\x10\\x1f\\x01\\x07\\x13\\x0f\\x10\\x17\\x00q\\x00q\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-04-10T00:00:00", "modifydate": "2007-05-10T10:17:46", "lines": 113, "newlines": 113, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\nARG ACID DSNAME ACCESS DAYS\nSIGNAL OFF ERROR\n/* PERMITS AN ID TO A DSN */\nSECRC = \"T80DSNP FAILED WITH ERRORS\"\nD.0 =\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET DSNAUDL  PROFILE\"\nIF DSNAUDL = \" \" THEN DSNAUDL = \"'IMS.PROD.PARMLIB(AUDIT)'\"\nIF SYSDSN(DSNAUDL) = \"OK\" THEN DO\n  SAY \"T80DSNP: DSNAUDL IS\" DSNAUDL\n  \"ALLOC DDN(INPUT) DSN(\"DSNAUDL\") SHR REUS\"\n  \"EXECIO * DISKR INPUT ( FINIS STEM D.)\"\n  \"FREE DDN(INPUT)\"\n  SAY \"T80DSNP: I HAVE \"D.0\" QUALIFIERS TO AUDIT\"\n  DO T = 1 TO D.0\n    D.T = WORD(D.T,1)\n  END\nEND\nQ = OUTTRAP(OUT.)\nACTION = \"ACTION(FAIL)\"\nDAY1 = WORD(DAYS,1)\nDAY2 = WORD(DAYS,2)\nIF DAYS = \"AUDIT\" THEN DO\n  SAY \"T80DSNP: AUDIT VALUE DETECTED WITH NO DAYS LIMITATION.\"\n  DAYS = \"0\"\n  DAY1 = \"0\"\n  ACTION= \"ACTION(AUDIT)\"\nEND\nIF (DATATYPE(DAY1) \u00ac= \"NUM\") & (DAY1 \u00ac= \" \" ) THEN DO\n  SAY \"T80DSNP: DAYS VALUE NOT NUMERIC. EXEC ENDING.\"\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(AUDIT)\"\n  MSG2 = \"THE FOLLOWING PARAMETER WAS NOT NUMERIC\" DAY1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF DAY2 = \"AUDIT\" THEN DO\n  SAY \"T80DSNP: AUDIT VALUE DETECTED.\"\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(AUDIT)\"\nEND\nIF (DAY2 \u00ac= \"AUDIT\") & (DAY2 \u00ac= \" \") THEN DO\n  SAY \"T80DSNP: DAY2 VALUE NOT UNDERSTOOD = \" DAY2\n  DAYS = WORD(DAYS,1)\n  ACTION= \"ACTION(FAIL)\"\n  MSG2 = \"THE FOLLOWING PARAMETER WAS NOT UNDERSTOOD\" DAY2\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nIF ACCESS \u00ac= \"READ\" THEN DO COUNT = 1 TO D.0\n  SAY \"T80DSNP: COMPARING \"DSNAME \"TO \" D.COUNT\n  IF INDEX(DSNAME,D.COUNT) = 1 THEN DO\n    SAY \"T80DSNP: DSNAUDIT ENTRY MATCH ENTRY\" COUNT DSNAME D.COUNT\n    ACTION = \"ACTION(AUDIT)\"\n    MSG2 = \"THAT DATASET IS AUDITED DAILY, AUDIT RULE INCLUDED\"\n    IF ACID = \"UCC7BAT\" THEN DO\n      MSG2 = \"NO AUDIT RULE ADDED. ID IS THE PRODUCTION JCL ID.\"\n      ACTION = \"ACTION(FAIL)\"\n    END\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSAY \"T80DSNP: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nRCODE = 0\nADDRESS TSO \"TSS WHOOWNS DSN(\"DSNAME\")\"\nRCODE = RC\nSAY \"T80DSNP: WHOOWNS RC IS \" RCODE\nIF RCODE \u00ac= 0 THEN DO\n  SECRC = \"THAT DATASET IS NOT UNDER YOUR OWNERSHIP. FUNCTION FAILED.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY OUT.1 OUT.2\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nRCODE = RC\nSAY \"T80DSNP: TSS LIST RC IS \" RCODE\nIF RCODE \u00ac= 0 THEN DO\n  SECRC = \"THAT ID IS NOT OWNED BY YOU OR IS INVALID.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY OUT.1 OUT.2\n  EXIT 04\nEND\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T80DSNP: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") DSN(\"DSNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"DSNAME\") ACCESS(\"ACCESS\") FOR(\"DAYS\")\" ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  SECRC = \"PERMIT FUNCTION SUCCESSFULL FOR ID \"ACID\" FOR \"DAYS\" DAYS.\"\nELSE\n  SECRC = \"PERMIT RETURNED NON ZERO RCODE OF \"RCODE\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80FDIV": {"ttr": 12303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00H\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x17\\x007\\x007\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:17:48", "lines": 55, "newlines": 55, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T80FDIV                           **/\n/** LAST MODIFIED    : 21 JUN 94                         **/\n/**     CONVERTED FROM CLIST TO REXX EXEC                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**       SECRC CAN CONTAIN:                             **/\n/**   THE DIVISION OF THE ACID.                           */\n/**   THE STRING \"LIST FUNCTION FAILED.\" IF THE ID IS BAD.*/\n/**   THE STRING \"PROFILE\"     IF THE ID IS A PROFILE.    */\n/**   THE STRING \"LIMITED\"     IF THE ID IS AN LSCA.      */\n/**   THE STRING \"CENTRAL\"     IF THE ID IS AN SCA.       */\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  NONE                **/\n/**********************************************************/\nARG ACID\nSAY \"T80FDIV: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nSECRC = \"LIST FUNCTION FAILED.\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T80FDIV: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"\nSAY \"T80FDIV: BACK FROM TSS WITH \"INLINE.0 \"LINES OF DATA\"\nDO X = 1 TO INLINE.0\n  INLINE = INLINE.X\n  PARSE VAR INLINE W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8\n  TOTWORDS = WORDS(INLINE)\n  IF W.1 = \"TYPE\" THEN  DO\n    SAY \"T80FDIV: TYPE INITIALLY SET TO \"W.3\n    SECRC = W.3\n  END\n  IF SECRC = \"PROFILE\" THEN LEAVE /* THIS IS WHAT HE WANTS TO KNOW  */\n  IF (W.1 = \"DIV\") & (W.2 = \"ACID\") THEN  DO\n    SAY \"T80FDIV : DIVISION FOUND, IS \"W.4\n    SECRC = W.4\n  END\nEND\nSAY \"T80FDIV: NORMAL END. FINAL DIVISION IS\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nW.1 = WORD(INLINE.1,1)\nIF W.1 = \"TSS0352E\" THEN SECRC = \"AUTHORIZATION FAILED.\"\nSAY \"T80FDIV : \"INLINE.1\nSAY \"T80FDIV : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T80FDIV : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80FLOC": {"ttr": 12305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00Q\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x17\\x001\\x001\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:17:51", "lines": 49, "newlines": 49, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** RETURNS THE LOCATION OF A PROFILE IN A USERS PROFILE **/\n/** LIST ... DIR                                         **/\n/**********************************************************/\n/** EXEC NAME        : T80FLOC                           **/\n/** LAST MODIFIED    : 06 MAY 96                         **/\n/**  USES THE NEW T80FLOC  FUNTIONALITY                  **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  ANY TSS ACID                              **/\n/** PROFILE :  ANY TSS ACID THAT IS A PROFILE            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**   NONE                                               **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08                        **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  T80GDAT             **/\n/**                                                      **/\n/**********************************************************/\nARG ACID PROFILE\nSAY \"T80FLOC: HAS CONTROL.\"\nQ = OUTTRAP(\"INLINE.\")\nNUM =\nGOTPRF = \"NO\"\nSECRC = \"ERROR\"\nSIGNAL ON ERROR NAME SEEYA\nSAY \"T80FLOC: CALLING TSS FOR LIST OF ID\" ACID\nADDRESS TSO \"%T80GDAT \"ACID\" PROFILES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nPARSE VAR SECRC P.1 P.2 P.3 P.4 P.5 P.6 P.7 P.8 P.9 P.10 P.11 P.12\nNUM = WORDS(SECRC)\nSECRC = 0\nDO W = 1 TO NUM\n  IF PROFILE = P.W THEN SECRC = W\nEND\nSAY \"T80FLOC: POSITION OF \"PROFILE \" IN \" ACID \"IS \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"T80FLOC : ERROR ENCOUNTERED IN LINE \" SIGL\nSAY \"T80FLOC : SECRC IS \"SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80GCMD": {"ttr": 12307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x07\\x00R\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x17\\x00`\\x00`\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.07", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:17:52", "lines": 96, "newlines": 96, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\n/*****************************************************************/\n/* added a null line to the output to fix prompt of user         */\n/*****************************************************************/\n/* THIS EXEC WILL CREATE A COMMAND STREAM THAT WILL AFFECT       */\n/* ALL THE ACIDS IN A DEPARTMENT DIVISION OR CONNECTED TO A      */\n/* PROFILE.                                                      */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nARG GROUP DSN1 CMD\nADDRESS ISPEXEC\n\"VGET (ACID DS3 DATA MODE) PROFILE\"\nIF GROUP = \" \" THEN GROUP = ACID\nIF DSN1 = \" \" THEN DSN1  = DS3\nIF CMD = \" \" THEN CMD  = DATA\nSAY \"T80GCMD: CALLING T80JCARD FOR JCL STREAM INITIALIZATION.\"\nADDRESS TSO \"T80JCARD\" DS3\nREPNUM = 0\nLCMD = LENGTH(CMD) - 2\nIF POS(\" $$\",CMD) = LCMD THEN SIGNAL OKTOGO\nIF POS(\" $$ \",CMD) = 0 THEN DO\n  SECRC = \"ERROR: THE STRING ' $$ ' MUST EXIST IN THE COMMAND STRING.\"\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nOKTOGO: NOP\nPARSE VAR CMD W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\nSIGNAL ON ERROR NAME SEEYA\nIF SYSDSN(DSN1) \u00ac= \"OK\" THEN DO\n  SAY \"TSSGCMD: THE OUTPUT DSN YOU HAVE GIVEN ME IS UNAVAILABLE\"\n  EXIT 00\nEND\nDO Z = 1 TO 9\n  IF W.Z = \" $$ \" THEN REPNUM = Z\nEND\nCOUNT_LIM = REPNUM - 1\nDO Z = 1 TO COUNT_LIM\n  IF W.Z = \" $$ \" THEN REPNUM1 = Z\nEND\nQ = OUTTRAP(OUTID.)\nADDRESS TSO\nIF MODE = \"ONLINE\" THEN\n  \"ALLOC DDN(OUT1) DSN(\"DSN1\") REUS MOD\"\nSAY \"T80GCMD: I AM CALLING T80PWHO WITH PARMS:\" GROUP\nSIGNAL OFF ERROR\n\"%T80PWHO\" GROUP\nLIST_CODE = RC\nSIGNAL ON ERROR NAME SEEYA\nsay \"TSA101D: T80GCMD I am back from T80PWHO with return code of \" rc\nsay \"TSA101D: T80GCMD the output of T80PWHO was \"outid.0 \"records.\"\nsay \"TSA101D: T80GCMD I am routing output to \"dsn1\nIF ( OUTID.0 = 0 ) | ( LIST_CODE \\= 0 )  THEN DO\n  msg2 = \"TSA221E: \"\n  msg2 = msg2 \"Failed. stream is incomplete, failure in listing \" group\n  ADDRESS ISPEXEC  \"VPUT MSG2 PROFILE\"\n  queue \"T80222E: I have received no input from T80PWHO\"\n  queue \"         acid may be invalid or authorization may have failed\"\n  ADDRESS ISPEXEC  \"VGET SECRC PROFILE\"\n  QUEUE SECRC\nEND\nDO X = 1 TO OUTID.0\n  PARSE VAR OUTID.X ACID LINE\n  ACID = WORD(OUTID.X,1)\n  if acid = \"TSS0300I\" then iterate x\n  IF ACID = \"ACCESSORID\" THEN ACID= WORD(OUTID.X,3)\n  W.REPNUM = ACID\n  W.REPNUM1 = ACID\n  IF (ACID = \"*\") | (ACID = \"*NONE*\") THEN DO\n    QUEUE LINE\n    ITERATE X\n  END\n  LINE = W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9\n  IF LINE \u00ac= \"=\" THEN\n    QUEUE LINE    /* NO BLANK LINES! */\nEND\nQUEUE \" \"\nQUEUE \"@@\"\nqueue\nSIGNAL OFF ERROR\nsecrc = \"TSA223I: group commmand stream placed in dsn \" dsn1\nIF MODE = \"ONLINE\" THEN  DO\n  \"EXECIO * DISKW OUT1 (FINIS)\"\n  \"FREE DDN(OUT1)\"\nEND\nIF MODE = \"BATCH\" THEN DO\n  \"EXECIO * DISKW BJCL (FINIS)\"\n   SECRC = \"COMPLETED. COMMAND STREAM APPENDED TO BATCH FILE \"\nEND\n\"FREE DDN(IN1)\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\nSEEYA: NOP\nSAY \"AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80GDAT": {"ttr": 13057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x13\\x00C\\x00\\x97 /\\x01\\x07\\x13\\x0f\\x14\\x02\\x00\\x9a\\x00\\x90\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.19", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2007-05-10T14:02:43", "lines": 154, "newlines": 144, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T80GDAT                           **/\n/** LAST MODIFIED    : 10 MAY 2007                       **/\n/**********************************************************/\n/** ADDED SUPPORT FOR MULTIPLE WORD FIELDS AND THE       **/\n/** SPECIAL REQUIREMENTS OF THE PROFILE FIELD..DR        **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : ANY TSS ACID                               **/\n/** FIELD   : THE TSS FIELD THE CALLER WANTS TO RECEIVE  **/\n/**           BACK                                       **/\n/** DATA    : THE TYPE OF LIST I MUST DO. (NOT REQ)      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** NONE                                                 **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 04 08 16                  **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES (VPUT OF SECRC)             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG ACID FIELD DATA\n/* SAY ACID FIELD DATA */\nHEX00 = '00'X\n/** IF THE FIELD REQUESTED IS ONE THAT NEEDS MULTIPLE    **/\n/** WORDS PASSED BACK TO THE CALLER THEN SET THE MULT.  **/\n/** VARIABLE TO YES BELOW... DIR JAN 97                 **/\nMULT.USED = \"YES\"\nMULT.NAME = \"YES\"\nMULT.PROFILES = \"YES\"\nMULT.INSTDATA = \"YES\"\nMULT.BYPASSING = \"YES\"\nMULT.ATTRIBUTES = \"YES\"\n/* SAY \"T80GDAT: HAS CONTROL PARMS \" ACID FIELD DATA */\nGOTIT = \"NO\"\nIF DATA = \" \" THEN DATA = \"BASIC\"\nSIGNAL ON ERROR NAME BADDATA\nQ = OUTTRAP(OUTID.)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nSIGNAL ON ERROR NAME SEEYA\nDO X = 1 TO OUTID.0\n  X1 = X+1 ; X2 = X+2 ; X3 = X+3 ; X4 = X+4\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTID.X=TRANSLATE(OUTID.X,\" \",HEX00)\n  PARSE VAR OUTID.X W.1 W.2 W.3 W.4 W.5 W.6 W.7 W.8 W.9 W.10 W.11 W.12\n  WNUM = WORDS(OUTID.X)\n  DO T = 1 TO WNUM\n    IF WORD(OUTID.X,T) = FIELD THEN DO\n      /* SAY \"T80GDAT: LINE IS \" OUTID.X                 */\n      /*SAY \"T80GDAT: FIELD IS\" FIELD                    */\n      /*SAY \"T80GDAT: GOT IT ON LINE \" X \" WORD \" T      */\n      T1 = T + 1\n      T2 = T + 2\n      T3 = T + 3\n      SECRC = W.T2\n      /* SAY \"T80GDAT: SETTING INITIAL SECRC TO \" SECRC    */\n      IF FIELD = \"DEPT\" THEN SECRC = W.T3\n      IF (FIELD = \"TYPE\") & (W.T3 = \"C/A\") THEN\n        SECRC = SECRC||\"CA\"\n /*   IF FIELD = \"NAME\" THEN */\n /*     SECRC = SECRC  W.T3  */\n      /**************************************************/\n      /** BELOW IS SUPPORT FOR A FIELD THAT HAS MULTIPLE*/\n      /** PARMS, LIKE PROFILES ...DIR 2 MAY 96          */\n      /**************************************************/\n      IF MULT.FIELD = \"YES\" THEN DO\n        IF FIELD = \"INSTDATA\" THEN DO\n          secrc = substr(outid.x,13)\n          gotit = \"YES\"\n          Leave\n        end\n        IF FIELD = \"PROFILES\" THEN DO\n          /**************************************/\n          /** IF IT IS A PROFILES REQUEST WE   **/\n          /** SCAN AHEAD AND LOAD THE CURRENT  **/\n          /** LINE WITH ALL THE PROFILES IN THE**/\n          /** NEXT 4 LINES, THUS SUPPORTING 5  **/\n          /** FULL LINES OF PROFILES OR 20 OF  **/\n          /** THOSE BUGGARS.   DIR 2 MAY 96    **/\n          /**************************************/\n          /* SAY \"T80GDAT: PROFILE ROUTINE IN CONTROL\"        */\n          NW1 = WORD(OUTID.X1,1)\n          NW2 = WORD(OUTID.X2,1)\n          NW3 = WORD(OUTID.X3,1)\n          NW4 = WORD(OUTID.X4,1)\n          IF NW1 = \"PROFILES\" THEN W.8 = SUBSTR(OUTID.X1,14)\n          IF NW2 = \"PROFILES\" THEN W.9 = SUBSTR(OUTID.X2,14)\n          IF NW3 = \"PROFILES\" THEN W.10 = SUBSTR(OUTID.X3,14)\n          IF NW4 = \"PROFILES\" THEN W.11 = SUBSTR(OUTID.X4,14)\n          /**************************************/\n          /** LETS TELL THE NEXT ROUTINE THERE **/\n          /** ARE MORE WORDS THAN THERE USED TO**/\n          /** BE IN THE CURRENT LINE.DR 2 MAY96*/\n          /**************************************/\n          WNUM = 11\n        END\n        /*SAY \"T80GDAT: MULTIPLE WORD FIELD DETECTED.\"    */\n        /*SAY \"T80GDAT: COUNTING FROM \"T2 \" TO \" WNUM     */\n        ALLDATA = \"\"\n        DO W1 = T2 TO WNUM\n          IF W.W1 = \"=\" THEN LEAVE /* WE HAVE HIT THE NEXT VALUE */\n          ALLDATA = ALLDATA  W.W1\n        END\n        SECRC = ALLDATA\n      END\n      GOTIT = \"YES\"\n    END\n    IF GOTIT = \"YES\" THEN LEAVE\n  END\n  IF GOTIT = \"YES\" THEN LEAVE\nEND\nSIGNAL OFF ERROR\n/*****************************************************************/\n/** NOT FINDING AN INTERVAL MAY BE OK PASS BACK A ZERO.         **/\n/*****************************************************************/\nIF (GOTIT = \"NO\") & (FIELD = \"INTERVAL\") & (DATA \u00ac= \"BASIC\") THEN DO\n  GOTIT = \"YES\"\n  SECRC = 0\nEND\nIF GOTIT = \"YES\" THEN DO\n  /* SAY \"T80GDAT: FIELD \"FIELD\" WAS FOUND. VALUE IS \" SECRC   */\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSECRC = \"$NOTFOUND\"\n/* SAY \"T80GDAT: FIELD \"FIELD\" WAS NOT FOUND. SECRC IS \" SECRC  */\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nBADDATA: NOP\nSECRC  = \"$BADTSS\"\nSAY \"T80GDAT: ERROR ROUTINE ENTERED, LIST DATA IS\" DATA\nSAY \"T80GDAT: \"ACID FIELD DATA\nIF WORD(OUTID.1,1) = \"TSS0352E\" THEN DO\n  SECRC = \"$BADAUTH\"\n  SAY \"T80GDAT: ID IS NOT OWNED WITHIN SCOPE OF CONTROL\"\nEND\nIF WORD(OUTID.1,1) = \"TSS0314E\" THEN DO\n  SECRC = \"$BADACID\"\n  SAY \"T80GDAT: No such TSS ACID.\"\nEND\nSAY \"T80GDAT: SECRC IS BEING SET TO \" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nSEEYA: NOP\nSAY \"T80GDAT: AN ERROR HAS OCCURED IN LINE \"SIGL\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80GDEL": {"ttr": 12309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00V\\x00\\x97 /\\x01\\x07\\x13\\x0f\\x10\\x17\\x00n\\x00n\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2007-05-10T10:17:56", "lines": 110, "newlines": 110, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** Creates a batch job that will delete multiple ids    **/\n/** under a department or division, depending on how many**/\n/** times the job is submitted                           **/\n/** submit it once:  Deletes all users and profiles      **/\n/**                  but leaves the departments that     **/\n/**                  had IDs in them.                    **/\n/** submit it twice: Deletes all the newly emptied depts **/\n/** submit it thrice Deletes the dept or division.       **/\n/**********************************************************/\n/** exec name        : T80GDEL                           **/\n/** last modified    : 06 jul 97                         **/\n/**********************************************************/\n/**----------------input required -----------------------**/\n/** passed args        valid values                      **/\n/** acid    : the one to be replaced                     **/\n/** mode    : the mode of operation                      **/\n/** ispf vgets         valid values                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T80GDAT T80pwho      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS ISPEXEC\nIF MODE = \"BATCH\" THEN DO\n  \"      VGET DISP PROFILE     \"\n  \"      VGET DS1 PROFILE     \"\n  \"      VGET DS2 PROFILE     \"\n  \"      VGET DS3 PROFILE     \"\n  \"      VGET DS4 PROFILE     \"\n  \"      VGET DS5 PROFILE     \"\n  \"      VGET DS6 PROFILE     \"\n  SECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n  \"      VPUT SECRC PROFILE   \"\nEND\nenv = sysvar(sysenv)\nIF MODE \\= \"BATCH\" THEN DO\n  secrc =\"TSA236E: failed. global delete cannot be run in online mode.\"\n  \" VPUT SECRC PROFILE   \"\n  say \"TSA101D: T80GDEL global delete cannot be run in online mode\"\n  EXIT 04\nEND\nSay \"TSA101D: T80GDEL Batch mode detected. using ddname BJCL as output.\"\nACID = TRANSLATE(ACID,\" \",\".\")\nSIGNAL ON ERROR NAME CLOSEEM\n/********************************************************************/\n/* THIS EXEC LISTS AN ID    , FINDS WHICH ACIDS ARE CONNECTED TO IT*/\n/* AND THEN CREATES A COMMAND STREAM TO DELETE THOSE IDS            */\n/********************************************************************/\nSTARTOUT: NOP\n/*                                                              */\n/*IF MODE = \"BATCH\" THEN DO                                     */\n/*     ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"        */\n/*END                                                           */\nOUTNUM =  1\n/***********/\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T80PWHO \"ACID \"YES\"\nSAY \"TSA101D: # of lines of output return from TxxPWHO is\" OUT.0\nQ = OUTTRAP(\"XX.\")\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  INLINE = OUT.X||\"                                      \"\n  SAY strip(INLINE)\n  ID=WORD(INLINE,1)\n  IF WORD(INLINE,1) = \"ACCESSORID\" THEN ID = WORD(INLINE,3)\n  IF ID = TSS0300I THEN LEAVE\n  /************************************************************/\n  /*                                                          */\n  /************************************************************/\n  say \"TSA101D: T80GDEL issuing \" ADDRESS TSO \"%T80GDAT \"ID \" TYPE \"\n  ADDRESS TSO \"%T80GDAT \"ID \" TYPE \"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  say \"TSA101D: T80GDEL deleting logic for id:\" id \"type:\" type\n  IF MODE = \"ONLINE\" THEN\n    say \"TSA101D: T80GDEL online mode ignored.\"\n    /* ADDRESS TSO \" TSS REMOVE(\"ID\")\" */\n  IF MODE = \"BATCH\" THEN DO\n    IF TYPE = \"PROFILE\" THEN\n      BJCL.OUTNUM = \"ISPSTART CMD(%T80DISC \"ID\")\"\n    IF TYPE = \"PROFILE\" THEN OUTNUM = OUTNUM + 1\n    BJCL.OUTNUM = \"TSS DEL(\"ID\")\"\n    OUTNUM = OUTNUM + 1\n  END\nEND\nOUTSTART: NOP\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nsecrc= \"TSA237I: function completed. output appended to batch file.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nEXIT\n/*************************************/\nCLOSEEM: NOP\nSIGNAL OFF ERROR\nOUTNUM = OUTNUM - 1\nADDRESS MVS \"EXECIO \"OUTNUM\" DISKW BJCL ( FINIS STEM BJCL.)\"\nSAY \"****************************************************\"\nSAY \"LINE IS \"SIGL\nX = SOURCELINE(SIGL)\nSAY X\nSAY  SECRC id type\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80GREP": {"ttr": 12311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00X\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x17\\x00y\\x00y\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:17:58", "lines": 121, "newlines": 121, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED ALL LOCATION PROCESSING WITH USE OF AFTER    **/\n/** KEYWORD DIR 2 OCT 97                                 **/\n/**********************************************************/\n/** TO GLOBALLY REPLACE A PROFILE WITH ANOTHER           **/\n/**********************************************************/\n/** EXEC NAME        : T80GREP                           **/\n/** LAST MODIFIED    : 02 OCT 97                         **/\n/**********************************************************/\n/** TOTALLY REWRITTEN TO IMPROVE SPEED BY 1000%          **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ONE TO BE REPLACED                     **/\n/** NEWACID : THE ONE TO REPLACE IT WITH                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEWACID NOTUSED\nADDRESS ISPEXEC\n\"      VGET DISP PROFILE     \"\n\"      VGET MODE PROFILE     \"\n\"      VGET DS1 PROFILE     \"\n\"      VGET DS2 PROFILE     \"\n\"      VGET DS3 PROFILE     \"\n\"      VGET DS4 PROFILE     \"\n\"      VGET DS5 PROFILE     \"\n\"      VGET DS6 PROFILE     \"\nMYCODE = 0\nTOTAL_RC = 0\nACID = TRANSLATE(ACID,\" \",\".\")\nNEWACIDS = TRANSLATE(NEWACID,\" \",\".\")\nIF INDEX(\" \"NEWACID\" \",\" \"ACID\" \") \\= 0 THEN DO\n  msg2  = \"TSA241W: Warning - cannot replace an ACID with itself.\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE   \"\nEND\nSECRC = \"FUNCTION FAILED.\" ACID \"MAY BE INVALID.\"\n\"      VPUT SECRC PROFILE   \"\nSIGNAL ON ERROR NAME CLOSEEM\nOUTFILE.0 = 0\nSTARTOUT: NOP\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS3\") \"DISP\" REUS\"\n  ADDRESS TSO \"ALLOC DDN(JCLFILE) DSN(\"DS6\") SHR REUS\"\n  ADDRESS MVS \"EXECIO * DISKR JCLFILE ( FINIS STEM OUTFILE.)\"\nEND\nOUTNUM = OUTFILE.0 + 1\n/***********/\nQ = OUTTRAP(DROPOUT.)\nSIGNAL OFF ERROR\nDO T1 = 1 TO WORDS(NEWACIDS)\n  LISTACID = WORD(NEWACIDS,T1)\n  ADDRESS TSO \"TSS LIST(\"LISTACID\") DATA(BASIC)\"\n  TOTAL_RC = TOTAL_RC + RC\n  IF TOTAL_RC > 0 THEN BADID = LISTACID\nEND\nIF TOTAL_RC \\=0 THEN DO\n  MSG2 = \"TSA242W: Warning\"\n  msg2 = msg2 badid \" profile was unlistable jcl may not be valid.\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nQ = OUTTRAP(OUT.)\nADDRESS TSO \"%T80PWHO \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF SECRC = \"$BADTSS\" THEN DO\n  secrc = \"TSA243E: Aborted.\"\n  secrc = secrc acid\" profile was unlistable. Check validity.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nEND\nSIGNAL ON ERROR NAME CLOSEEM\nQ = OUTTRAP(\"OFF\")\nsay \"TSA101D: Pwho generated \"out.0 \"lines of output .\"\nif out.0 = 0 then do\n  secrc = \"TSA246E: Unable to find attached ACIDs for replace stream\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  MYCODE = 4\n  SIGNAL CLOSEEM\nend\nAGAIN: NOP\nDO X = 1 TO OUT.0\n  ID = WORD(OUT.X,1)\n  IF ID = \"ACCESSORID\" THEN ID = WORD(OUT.X,3)\n  OUTFILE.OUTNUM =\"TSS ADD(\"ID\") PROFILE(\"NEWACIDS\") AFTER(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\n  OUTFILE.OUTNUM =\"TSS REM(\"ID\") PROFILE(\"ACID\")\"\n  OUTNUM = OUTNUM + 1\nEND\nOUTSTART: NOP\nOUTFILE.OUTNUM = \" \"\nOUTDD = \"OUTFILE\"\nIF MODE = \"BATCH\" THEN OUTDD = \"BJCL\"\nADDRESS MVS \"EXECIO * DISKW \"OUTDD\" ( FINIS STEM OUTFILE.)\"\nSECRC= \"TSA244I: Replace stream generated output in \" DS3\nIF MODE = \"BATCH\" THEN\nsecrc= \"TSA245I: Replace stream appended to batchfile.\"\n\"ISPEXEC VPUT SECRC PROFILE\"\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\nCLOSEEM: NOP\nSAY \"TSA101D: T80grep error line is \"SIGL\nSAY \"TSA101D: secrc is \"  SECRC\nIF MODE = \"ONLINE\" THEN DO\n  ADDRESS TSO \"FREE DDN(OUTFILE)\"\n  ADDRESS TSO \"FREE DDN(JCLFILE)\"\nEND\nEXIT MYCODE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80ICOMP": {"ttr": 15105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x08\\x01\\x02 o\\x01\\x14\\x19\\x8f\\x08V\\x08\\x8a\\x08=\\x00\\x00\\xc7\\xd9\\xd7\\xe3\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2002-07-25T00:00:00", "modifydate": "2014-07-17T08:56:08", "lines": 2186, "newlines": 2109, "modlines": 0, "user": "GRPTDIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** fixed a nasty problem for OMVS ACIDS... by the  time **/\n/** I added all my debugs I had resolved it...           **/\n/**                                        07/14/2014    **/\n/**********************************************************/\n/** Fixed problem where a profile with INSTDATA does     **/\n/** not skip ACIDS                         05/14/2007    **/\n/**********************************************************/\n/** Added support for a better instdata conversion       **/\n/**                                        05/11/2007    **/\n/**********************************************************/\n/** Added a lineskip section for lines that can be       **/\n/** totally ignored for conversion and other functions   **/\n/** for the adminby data                   02/13/2007    **/\n/**********************************************************/\n/** changed for 5.3 profile acid conversion              **/\n/** acids are listed differently so the bypass list      **/\n/** parms had to be updated                03/31/2005    **/\n/**********************************************************/\n/**********************************************************/\n/** Updated comments                        7/27/04      **/\n/**********************************************************/\n/** Fixed array load error which would invalidate        **/\n/** converts..                              12/1/03      **/\n/** Very important fix....                               **/\n/**********************************************************/\n/** Fixed MASTFAC syntax on converts         9/17/03     **/\n/**********************************************************/\n/** Fixed volume rules for (D) specification 9/15/03     **/\n/**********************************************************/\n/** updated modrule varname error   Aug 21 2003  DIR     **/\n/**********************************************************/\n/** updated getval routine to return blanks when a var   **/\n/** has not been assigned a value     Aug 5 2003  dir    **/\n/**********************************************************/\n/** created DL subroutine to write log data to           **/\n/** writedebug log  July 2003                            **/\n/**********************************************************/\n/**********************************************************/\n/** Updated allacid. array processing and adding comments**/\n/** Removed the acidrul array                            **/\n/**********************************************************/\n/**********************************************************/\n/** Started conversion to one array instead of one array **/\n/** for each acid instream. nov 22 2002                  **/\n/**********************************************************/\n/**********************************************************/\n/** added convert support for d,g and t,g in volume      **/\n/** rules  dir may 5 2002                                **/\n/**********************************************************/\n/**********************************************************/\n/** changed some doc spelling DIR FEB 22 2002            **/\n/**********************************************************/\n/** Change to modrule routine to totally remove the      **/\n/** scrolling area of that routine... I don't even know  **/\n/** why that section of the routine was there....        **/\n/**                  DIR Novem 05 2001                   **/\n/**********************************************************/\n/**********************************************************/\n/** July 25 2001 - documentation updates                 **/\n/**********************************************************/\n/** Change to debug modify processing to fix errant ptr  **/\n/** Which caused some scrolling to miss records and      **/\n/** caused records selected during modify to be wrongly  **/\n/** selected         DIR april 12 2001                   **/\n/**********************************************************/\n/** Discovered that modify will not support stacked/     **/\n/** owned resources, and that it would be a bear to      **/\n/** fix so I am leaving it alone.                        **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T80ICOMP                          **/\n/** LAST MODIFIED    : 23 Jun  2014                      **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T80JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/**                                                      **/\n/** defgroup = the defgroup OMVS group for invoking the  **/\n/**            %GIVEUID exec.                            **/\n/**                                                      **/\n/** DS1      = work dsn #1 in the SPI system             **/\n/**                                                      **/\n/** DS2      = work dsn #2 in the SPI system             **/\n/**                                                      **/\n/** idebug   = a debug value that can be set to override **/\n/**            debug values in this exec                 **/\n/**                                                      **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/** newpass  = The password value to be used in converts **/\n/**                                                      **/\n/** uidcon   = a value to specify if UIDs are converted  **/\n/**            'as is' or if the %giveuid exec is to be  **/\n/**             used instead.                            **/\n/**            NO =  The GIVEUID exec is issued for a new**/\n/**              UID, unless UID is zero.                **/\n/**            YES = The exact UID will be replicated    **/\n/**              A UID of zero is always be replicated   **/\n/**                                                      **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were passed to me  **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/**********************************************************/\n/** IN the below variables the 'name' area is a variable **/\n/**  which is an actual ACID                             **/\n/**********************************************************/\n/** The acidlst. arrays are the actual output from the   **/\n/**  TSS list command.                                   **/\n/**                                                      **/\n/**  NOTE: The ACIDS. array has one entry for each listed**/\n/**        ACID, it is the source for the name below...  **/\n/**                                                      **/\n/**                                                      **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** The ALLACID array is a sequential array that has one **/\n/** translated rule for each listed ACID                 **/\n/**                                                      **/\n/** Note: This array should be accessed by the SETVAL and**/\n/**       GETVAL functions, not accessed natively in the **/\n/**       main routine.                                  **/\n/**                                                      **/\n/** allacid.0          How many total lines of data      **/\n/** allacid.#.0acid    the acid this line relates to     **/\n/** allacid.#.0type    the type                          **/\n/** allacid.#.0segment the segment                       **/\n/** allacid.#.0resname the resource name                 **/\n/** allacid.#.0restext the resource text                 **/\n/** allacid.#.0concat  is this line to be concatenated   **/\n/**                    to the previous one ? ie part of  **/\n/**                    a multi line permission...        **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                  ARRAY FLOW                          **/\n/**   _______     _______      _______                   **/\n/**  |       |   |       |    |       |                  **/\n/**  | lst1  |   | lst2  |    | lst3  |  acidlst. arrays **/\n/**  |       |   |       |    |       |                  **/\n/**  |_______|   |_______|    |_______|                  **/\n/**      |           |            |                      **/\n/**      |           |            |                      **/\n/**      |___________|____________|                      **/\n/**                  |                                   **/\n/**               _______                                **/\n/**              |       |                               **/\n/**              |       |                               **/\n/**              |  all  |               allacid. array  **/\n/**              |       |                               **/\n/**              |_______|                               **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** In the below variable name and type and resource     **/\n/**   are all variables !!                               **/\n/**********************************************************/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** convert.0newid    \"YES\" or \"NO\" depending on if the  **/\n/**                      ACID is changing in the convert **/\n/** convert.0name     The new ACID to replace real one   **/\n/**                      in the ouput stream             **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.bypass   = \"NO\"\ndebug.convert  = \"NO\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\nDEBUG.GETDATA  = \"NO\"\nDEBUG.setval   = \"NO\"\nDEBUG.getval   = \"NO\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget instcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  /*****************************************************************/\n  /* idebug is a value that can be set in the T$$ execs to turn on */\n  /* a specific debug. Usually for testing something.              */\n  /*****************************************************************/\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /**         The MAKECUST variable               **/\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command.                       **/\n  /** This would be used if you were moving IDs to**/\n  /** another environment and wanted a certain    **/\n  /** command included in the convert to          **/\n  /** support that environment.                   **/\n  /**                           DIR 25 july 2001  **/\n  /**                                             **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\n  /*************************************************/\n  /** A makeauth command is basically a convert   **/\n  /** with two changes:                           **/\n  /** 1 - The new ID is $$                        **/\n  /** 2 - The tss create command is not done      **/\n  /**                                             **/\n  /*************************************************/\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\n/*\nsay \"TSA101D: makeauth check was \" make_rc makeauth\n*/\nq=dl(,,\"makeauth check was \" make_rc makeauth)\nif make_rc = 0 then do\n  /*************************************************/\n  /** Makeacid is just a type of CLONE really     **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n     /* tells the convert routine to change all outbound ACID */\n  convert.0name = \" $$ \"  /* this is the new ACID name */\n  makeacid.0auth = \"YES\"  /* tell the makeacid routine */\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  /*************************************************/\n  /** a clone is a convert with a new ID plugged  **/\n  /** into the output, so we set some flags and   **/\n  /** then change function to REBUILD.            **/\n  /**                                             **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  /*************************************************/\n  /** We use the makeauth feature to plug in the  **/\n  /** %addlocal command into the output           **/\n  /**                                             **/\n  /*************************************************/\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"AN_ID_TO_TRACE\"            /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Feb 13 2007\"\nq=dl(,,\"T80ICOMP in control with parms \" function acidlist)\nq=dl(,,\" T80ICOMP Maint = \" maint)\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nsecrc = \"failed in T80ICOMP. no other information available\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\n  /*****************************************************************/\n  /** A resource function uses an entirely different variable     **/\n  /** loader routine since the input is in a radically different  **/\n  /** format.                                                     **/\n  /**                                                             **/\n  /**                                                             **/\n  /*****************************************************************/\nq=dl(,,\" Retrieving profile variables \")\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nsecrc = \"failed during jobcard function\"\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    q=dl(,,\" calling jobcard function. \" )\n    address tso \"%T80jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  q=dl(,,\" Output DSN unusable, data written to screen \")\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\nsecrc = \"failed in T80ICOMP. no other information available\"\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* The following words in position 1 cause the entire   */\n/* line to be skipped                                   */\n/********************************************************/\nlineskip.0 = 2\nlineskip.1 = \"TSS0300I\"\nlineskip.2 = \"ADMIN\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 13\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\nBYPASS.0SUPRESS.HOLD.13 = \"ACID\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 6\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nBYPASS.0SUPRESS.HOLD.6 = \"ADMINBY\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 19\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\n/* BYPASS.HOLD.7 = \"* ACID \"  */\n/* commented above due to the need for admin auth to function */\nBYPASS.HOLD.7 = \"INSTDATA ACID \"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9  = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"AUTHORITY ACIDS\"\nBYPASS.HOLD.15 = \"* TCONS\"\nBYPASS.HOLD.16 = \"* TRBA\"\nBYPASS.HOLD.17 = \"* TUPT\"\nBYPASS.HOLD.18 = \"* ADMIN\"\nBYPASS.HOLD.19 = \"* ACIDS\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 12\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"BASE DIVACID\"\nBYPASS.HOLD.5 = \"BASE ZONEACID\"\nBYPASS.HOLD.6 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.7 = \"* LASTUSED\"\nBYPASS.HOLD.8  = \"AUTHORITY ACID\"\nBYPASS.HOLD.9  = \"BASE ZONEACID\"\nBYPASS.HOLD.10= \"* TCONS\"\nBYPASS.HOLD.11= \"* TRBA\"\nBYPASS.HOLD.12 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\n/*****************************************************************/\n/*****************************************************************/\n/* all variables are initialized.....the main section(s) follow  */\n/*****************************************************************/\n/*****************************************************************/\nq=dl(,,\" Basic initialization complete, execution begins.\")\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  q=dl(,,\" Resource processing started\")\n  /*****************************************************************/\n  /* Lets either issue the tss list or read in the data from file  */\n  /*****************************************************************/\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  /*****************************************************************/\n  /* I code the two ifs this way because an else when in multiple  */\n  /* loops is confusing...dir                                      */\n  /*****************************************************************/\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    q=dl(,,\" Bypass option specified, allocating input DSN\")\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n                           /* below we save the starting line #  */\n                           /* of each acid.. not sure why        */\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      q=dl(,\"RESOURCE\",\"owner = \" acidnum \"name = \" owner )\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      /* lets grab the acid */\n      parse var line drop 'ACID(' name ')' drop2\n    /*****************************************************************/\n    /* In resources the ACID with the auth is way to the right on    */\n    /*  the report so we note each of them for future reference      */\n    /*  Note the .name portion of the below variable insures that    */\n    /*  even if one ACID has authorites in multiple areas of the     */\n    /*  output, it is counted only once. The classic variable named  */\n    /*  variable....                                                 */\n    /*****************************************************************/\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\" /* actually any non  NO value works */\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      q=dl(,resource,\"acidnum = \" acidnum \"name = \" name )\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    q=dl(,,\" Total acids referenced in input is \" acidnum )\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  q=dl(\"tsa101d\",,\" Bypass option specified, allocating input dsn\")\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  q=dl(\"tsa101d\",,\" Total acids contained in input DSN is \" acidnum)\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n    /* each acid receives its own list area.. should be one */\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    q=dl(\"tsa101d\",,\" Listing ACID \"hold\" with data \"data \".\" )\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we create  the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nq=dl(\"tsa101d\",,\" Evaluation of TSS generated data begins.\" )\nevaluate: nop  /* a branch to point for a resource convert */\n/*************************************************/\n/*************************************************/\n/** The below routine does the exact same thing **/\n/** for both resource and standard output, since**/\n/** the variable structure created above is the **/\n/** same for either.                            **/\n/*************************************************/\n/*************************************************/\nlinenum = 0\nlinehold= 0\nif debug.flow = \"YES\" then do\n  say \"TSA101D Evaluate routine in control values as follows:\"\n  say \"acidnum:  \" acidnum\n  say \"accessor.0\" accessor.0\n  say \"accessor.1\" accessor.1\nend\nrules = 0\ndo num = 1 to acidnum\n  /************************************************/\n  /**This outer loop is once for each acid passed**/\n  /** to me. Dave 18 June 99                     **/\n  /************************************************/\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"tsa101d: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"        Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  q=dl(\"tsa101d\",,\" Acidlst.\"name\".0 is\" acidlst.name.0)\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    /* */\n    /* the below statements just clear the variables... */\n    setf = setval(rules,0flag,hex00)\n/*  acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0concat  = \"NO\"\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    setf = setval(rules,0restext,\" \")\n    setf = setval(rules,0type,\" \")\n    setf = setval(rules,0segment,\" \")\n    setf = setval(rules,0concat,\"NO\")\n    setf = setval(rules,0resname,\" \") */\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    if word(acidlst.name.a1,1) = \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,72)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if debug.trans = \"YES\" then do\n      say \"TSA101D: Translation starting for below data:\"\n      say \"         \"line\n    end\n    do skipit = 1 to lineskip.0\n      if word(line,1) = lineskip.skipit then iterate a1\n    end\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    /*acidrul.name.a1.0concat  = \"YES\" */\n      setf = setval(rules,0concat,\"YES\")\n    end\n    first11 = substr(line,1,11)\n    /* below we take 2 words and make one for first 11 */\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    if w.1 = \"INSTDATA\" then do\n      segment = \"INSTDATA\"\n      q=dl(\"tsa101d\",TRANS,\" Segment changed to \"segment \"for \" name)\n      save_idata = substr(line,14)\n    end\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      q=dl(\"tsa101d\",TRANS,\" Segment changed to \"segment \"for \" name)\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      q=dl(\"tsa101d\",trans,\" lcf detected:\" w.2)\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      q=dl(\"tsa101d\",trans,\" lcf area input line:\",\n      w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8)\n      w.1 = w.1\".\"savefac\n      q=dl(\"tsa101d\",trans,\" lcf area reformated line:\",\n      w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8)\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if debug.bypass = \"YES\" then\n          say bypass.0supress.function.supnum \"data:\" w.1\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then linehold = linehold - 1\n    if linehold < 0 then linehold = 0\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = getval(rules,0restext)\n/*    acidrul.name.rules.0restext = strip(hold) tzq1 */\n      setv = setval(rules,0restext,strip(hold) tzq1)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T80ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n /*   acidrul.name.rules.0concat  = \"YES\" */\n      setf = setval(rules,0concat,\"YES\")\n /*   say \"Setting concat to yes for record \" rules  */\n /*   hold1 = acidrul.name.rules.0concat */\n      hold = restext(rules)\n      q=dl(\"tsa101d\",trans,\" Concat rule \",\n      \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold)\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n/*  acidrul.name.a1.0concat  = \"NO\"  */\n    setf = setval(rules,0ACID,name)\n    setf = setval(rules,0concat,\"NO\")\n/*  acidrul.name.rules = segment type resource\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource */\n    setf = setval(rules,\"RESET\",segment type resource)\n    setf = setval(rules,0segment,segment)\n    setf = setval(rules,0type,type)\n    setf = setval(rules,0resname,resource)\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n/*  acidrul.name.rules.0restext = \" \"  */\n    Setf = setval(rules,0restext,\" \")\n    do t1 = 3 to words\n      hold = getval(rules,0restext)\n/*    acidrul.name.rules.0restext = strip(hold) strip(w.t1)  */\n      setf = setval(rules,0restext,strip(hold) strip(w.t1))\n      if getval(rules,0type) = \"INSTDATA\" then do\n      setf = setval(rules,0restext,save_idata)\n      setf = setval(rules,0resname,\"INSTDATA\")\n      end\n    end\n    q=dl(\"tsa101d\",trans,\" Type/Rname/Text =\" getval(rules,0type) \"/\",\n    getval(rules,0resname)\"/\",\n    getval(rules,0restext) )\n  end\n  /* acidrul.name.0 = rules */\n  linenum = linenum + rules\nend\nq=dl(\"Total lines of translated data is:\" linenum )\nallacid.0 = rules\nq=dl(\"tsa101d\",,\" Translation streams have been built.\",\n  \"Starting function check.\")\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter, or we did a translate function.    */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  q=dl(\"tsa101d\",,\" Permit/rebuild/revoke area in control.\")\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do t = 1 to allacid.0\n    q=dl(\"tsa101d\",,\" Starting to process LINE #\" t )\n    call getadata t\n    hold = next\n    record_number = t\n    name = allacid.t.0acid\n    q=dl(\"tsa101d\",,\" acid recnum next\" name record_number hold)\n    call convert function hold\n    trace off\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = linenum\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  q=dl(\"tsa101d\",,\" MODIFY starting to process ACID:\" name )\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    /* thisrec is the rec at the top of the screen */\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt /* scan the screen for an option */\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" S found on line\" t )\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        q=dl(\"tsa101d\",modify,\" D found on line\" t)\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n     /* acidrul.name.y = segment type resource */\n        setf = setval(y,\"RESET\",segment type resource,)\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" M found on line\" t )\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        q=dl(\"tsa101d\",\"MODIFY\",\" t=\" t \"thisrec=\" thisrec )\n        q=dl(\"tsa101d\",\"MODIFY\",\" Subscript is now:\" y )\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          SAY  \"TSA101D:\"\n          say \"MODIFY:segment type resource \"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          /* modrule creates the variable conlist     */\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs\n          setf = setflag(y,'*MODIFY')\n          /* */\n          setf = setval(y,0concat,\"YES\")\n        /*acidrul.name.y.0concat = \"YES\"\n          acidrul.name.y = segment type rsname  */\n          setf = setval(y,\"RESET\",segment type rsname,)\n          /*\n          acidrul.name.y.0resname  = rsname\n          */\n          setf = setval(y,0resname,rsname)\n          /*\n          acidrul.name.y.0restext  = modrule.newrs\n          */\n          setf = setval(y,0restext,modrule.newrs)\n          /* */\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          q=dl(\"tsa101d\",,\" secure routine failed access \")\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" A found on line\" t)\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T80ICOMP:addition routine entered outnum=\" outnum\n        say \"T80ICOMP:addition routine entered target=\" target\n        say \"T80ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T80ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          /*** zzzzebra **/\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          f = setval(q,0segment,getval(q1,0segment))\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          f = setval(q,0flag,getval(q1,0flag))\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          f = setval(q,0type,getval(q1,0type))\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          f = setval(q,0restext,getval(q1,0restext))\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n          f = setval(q,0resname,getval(q1,0resname))\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        q=dl(\"tsa101d\",\"MODIFY\",\" Calling modrule\")\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setval(fill,0concat,\"YES\")\n        setit = setflag(fill,\"*NEWRULE\")\n        setit = setval(fill,0flag,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        setit = setval(fill,0type,type)\n        acidrul.name.fill.0segment  = segment\n        setit = setval(fill,0segment,segment)\n        acidrul.name.fill.0resname  = rsname\n        setit = setval(fill,0resname,rsname)\n        acidrul.name.fill.0restext  = modrule.newrs\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  q=dl(\"tsa101d\",,\" leaving modify\")\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\n/*\nif function = \"TRANSLATE\" then\n  say \"acidrul.name array || multiline ? || segment || data \"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\n*/\nif function = \"TRANSLATE\" then do qt = 1 to allacid.0\n    say qt allacid.qt.0ACID,\n         allacid.qt allacid.qt.0restext\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nq=dl(\"tsa101d\",\"MAKEACID\",\" Making ACID:\" function )\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    q=dl(\"tsa101d\",\"MAKEACID\", \"makacid resolved to:\" own_str )\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  q=dl(\"tsa101d\",\"MAKEACID\",\" Makeacid type for \"name\" is :\" acid_type)\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nq=dl(\"tsa101d\",,\n\"makeacid\",\"leaving ma # out = \"create_num create.1 create.2)\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  instcon,\n  acidrul. cvtnum concat lcffac debug. convert. record_number allacid.\nparse arg function segment inline\nq=dl(\"tsa101d\",,\" convert called with \" function segment inline)\nname = getval(record_number,0acid)\noname = name\nq=dl(\"tsa101d\",,\" Output ACID name: \" oname)\nconcat = getval(record_number,0concat)\nif debug.newgdata = \"YES\" then concat = allacid.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nq=dl(\"tsa101d\",,\" Outname for con is \" oname \"concat is\" concat  )\nq=dl(\"tsa101d\",,\" Confor \"name\":\"function segment \">\"||inline||\"<\" )\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XAVOLUME\") then do\n  /*********************************************************/\n  /* a volume generic of (d,g) or (t,g) is invalid so we   */\n  /* handle it here.                                       */\n  /*********************************************************/\n  where_gen = index(inline,\",G)\")\n  if where_gen /= 0 then do\n    q=dl(\"tsa101d\",convert,\" Vol generic, Input dsn line \"inline )\n     parse var inline hz1  ',' hz2\n    inline = hz1||hz2\n    q=dl(\"tsa101d\",convert,\" Reformatted vol generic line \"inline)\n  end\n  where_gen = index(inline,\"(D)\")\n  if where_gen /= 0 then do\n    q=dl(\"tsa101d\",convert,\" Disk ref, Input dsn line \"inline )\n     parse var inline hz1  '(D)' hz2\n    inline = strip(hz1,t)||'(D)' hz2\n    q=dl(\"tsa101d\",convert,\" Reformatted Disk line \"inline)\n  end\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  q=dl(\"tsa101d\",convert,\" Input dsn line \"inline )\n  inline = \"XADSN\"||substr(inline,10)\n  q=dl(\"tsa101d\",convert,\" Reformatted dsn line \"inline)\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  q=dl(\"tsa101d\",convert,\" Reformat area completed convert. returning.\")\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 11 may 2007   */\n  /*********************************************************/\n  hold = translate(substr(inline,19),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  if instcon = \"NO\" then hold = \"000000\"\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  q=dl(\"tsa101d\",convert,\" Reformat area done convert. returning.\")\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" %giveuid \" oname defgroup\n  q=dl(\"tsa101d\",convert,\" Reformat area done convert. returning.\")\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\n  IF W.1 = \"SCOPEACID\" THEN W.1 = \"SCOPE\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MASTFAC\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif getval(record_number,0concat) = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = getval(record_number,0concat)\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"tsa101d XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nq=dl(\"tsa101d\",convert,\" Resource is \"resource \"concat is\" concat )\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  q=dl(\"tsa101d\",\"CONVERT\",\"Checking bypass rule for:\")\n  q=dl(\"tsa101d\",\"CONVERT\",bypass.function.q1)\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nif bypass = \"YES\" then do\n  q=dl(\"tsa101d\",\"CONVERT\",\" bypass rule tripped, Rule is below:\")\n  q=dl(\"tsa101d\",\"CONVERT\",bypass.function.rulehold)\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REM\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then do\n  say \"tsa101d: ***** CONVERT OUTPUT IS NOW :\"\n  say \"  \" output\nend\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T80ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. allacid. name hex00 debug. linenum function balout\nOPT = \" \"\nq=dl(\"tsa101d\",fillscr,\" Fillscr invoked. Thisrec=\" thisrec )\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T80ICOMP: TOP OF DATA REACHED\"\nEND\nh1 = linenum - 13\ntempz1 = linenum\n/* save this value for the display below*/\nq=dl(\"tsa101d\",\"FILLSCR\",\" h1=\" h1 \"acidrul.\"name\".0=\" tempz1 )\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 13\n  MSG = \"T80ICOMP: BOTTOM OF DATA REACHED\"\n  q=dl(\"tsa101d\",FILLSCR,\" Bottom of data thisrec set to :\"thisrec)\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T80ICOMP: TOP OF DATA REACHED\"\nEND\nif debug.fillscr = \"YES\" then do\n  say \"FILLSCR: thisrec=\" thisrec\n  say \"tsa101d     filling screen:\",\n    \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\nend\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  maxdata = acidrul.name.0\n  q=dl(\"tsa101d\",fillscr,\"fillscr calling with subscript:\" script)\n  q=dl(\"tsa101d\",fillscr,\"maxdata is:\"imaxdata )\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if debug.fillscr = \"YES\" then do\n    say \"tsa101d fillscr segment=\"segment\n    say \"   type=\"type \"resource=\"resource \"fchk=\"fchk\n  end\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose name acidrul. next allacid.\nq=dl(\"tsa101d\",,\" Dumping allacid array\")\ndo qt = 1 to allacid.0\n    say qt allacid.qt.0ACID,\n         allacid.qt allacid.qt.0restext\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. next acidlst.\nq=dl(\"tsa101d\",,\" Dumping acidlst array for \" name )\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetadata: procedure expose allacid. name next,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nt = record_number\nif debug.getdata = \"YES\" then do\n  say \"tsa101d Getadata invoked with:\" record_number\n  say \"New Getadata results:\"\n  say \"t=\"allacid.t\n  say \"acid=\"allacid.t.0acid\n  say \"segment=\"allacid.t.0segment\n  say \"type=\"allacid.t.0type\n  say \"resname=\"allacid.t.0resname\n  say \"restext=\"allacid.t.0restext\n  say \"*******\"\nend\ndebug.newgdata = \"YES\"\nsegment  = strip(allacid.t.0segment)\ntype     = strip(allacid.t.0type)\nresource = strip(allacid.t.0resname)\ntheres   = strip(allacid.t.0restext)\nif debug.Getdata = \"YES\" then do\n  say \"TSA101D: Getadata base resource:\" allacid.t\n  say \"TSA101D: Getadata resource data:\" theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult = getval(tempin,0segment)\n/* say \"Segment returning\" result */\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\n/*******************************************************/\n/*******************************************************/\n/**Gets the access from a string parens must be gone  **/\n/**prior to invocation.                               **/\n/*******************************************************/\n/*******************************************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult = getval(tempin,0type)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult = getval(tempin,0restext)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nsetv = setval(tempin,0flag,theflag)\nreturn 0\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\ngetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**Gets the allacid array variable specified.         **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nresult = allacid.record.varname\nif substr(result,1,8) = \"ALLACID.\" then result = \"\"\nif debug.getval = \"YES\" then\n  say \"GETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"is\" result\nreturn result\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\nsetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**sets the allacid array variable to specified value **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nnewvalue= arg(3)\nif debug.setval = \"YES\" then\n  say \"SETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"to\" newvalue\nallacid.record.varname = newvalue\nif varname = \"RESET\" then\nallacid.record  = newvalue\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ndl: NOP\n/**********************************************************/\n/** This routine checks to see if the debug flag is set  **/\n/** for a certain routine, and if it is issues the given **/\n/** msg to the log. It enables me to not have an if every**/\n/** time I want to write a msg          July 2003        **/\n/**********************************************************/\nmsgid  = arg(1)\nfield  = arg(2)\nthemsg = arg(3)\nupper msgid field\nD.1 = \"FLOW\"\nD.2 = \"MULTCON\"\nD.3 = \"CONVERT\"\nD.4 = \"MAKEACID\"\nD.5 = \"MODIFY\"\nD.6 = \"GETDATA\"\nD.7 = \"FILLSCR\"\nD.8 = \"MODRULE\"\nD.9 = \"RESOURCE\"\nD.10= \"TRANS\"\nd.0 = 10\nif msgid = \"\" then msgid = \"TSA101D\"\nif field = \"\" then field = \"FLOW\"\nfchk = \"BAD\"\ndo ck = 1 to d.0\n  if field = d.ck then fchk = \"OK\"\nend\nif fchk = \"BAD\" then do\n  say \"********************\"\n  say \"********************\"\n  say \"********************\"\n  say \"**debuglog routine invoked with :\" field\n  say \"********************\"\n  say \"********************\"\n  say \"********************\"\nend\nif debug.field = \"YES\" then do\n  outmsg = msgid\"*\"themsg\n  if length(outmsg) > 80 then do\n    outmsg2 = substr(outmsg,81)\n    outmsg = substr(outmsg,1,80)\n    say outmsg\n    say \"       * \"outmsg2\n  end\n  else say outmsg\nend\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = getval(tempin,0flag)\n/* say \"getflag: \" res */\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. name acidrul. conlist modrule. rstype debug.,\n fill_override allacid.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80IDAT": {"ttr": 13313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\"\\x01\\x04\\t?\\x01\\x07#\\x9f\\x140\\x017\\x01\\x19\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2007-08-27T14:30:22", "lines": 311, "newlines": 281, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T80IDAT                           **/\n/** LAST MODIFIED    :  may 10 2007                      **/\n/**********************************************************/\n/** Update the INSTDATA of an individual ACID            **/\n/**********************************************************/\n/**********************************************************/\n/** Idata format                                         **/\n/** first 20 characters are the enum and function flag   **/\n/** from 21 on it is the lanid or whatever you want....  **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/**                                                      **/\n/**                                                      **/\n/**  Detailed return code:                               **/\n/**                                                      **/\n/**  _____Data Retrieval Status                          **/\n/** |                                                    **/\n/** |_____ID Status                                      **/\n/** ||                                                   **/\n/** ||____Previous INSTDATA state                        **/\n/** |||                                                  **/\n/** |||___Action Taken                                   **/\n/** ||||                                                 **/\n/** 0...- Data retrieval worked                          **/\n/** 1...- No such ID                                     **/\n/** 2...- Not authorized for this ID                     **/\n/** 4...- TSS retrieval error                            **/\n/** 8...- Unknown invocation code                        **/\n/**                                                      **/\n/** .0..- ID has no unusual attributes                   **/\n/** .1..- ID is currently Suspended                      **/\n/** .2..- ID is currently Asuspended                     **/\n/** .4..- ID is currently Expired **future enhancement** **/\n/** .8..- ID has special attributes                      **/\n/**                                                      **/\n/** ..0.- Instdata had valid data                        **/\n/** ..1.- Instdata had no previous instdata              **/\n/** ..2.- Instdata had special code                      **/\n/** ..4.- Instdata had invalid data                      **/\n/** ..8.- Instdata had pending suspend                   **/\n/**                                                      **/\n/** ...0- Instdata updated                               **/\n/** ...1- Instdata provided enum invalid                 **/\n/** ...2- Not used                                       **/\n/** ...4- Instdata not updated due to data retreival     **/\n/**       Failure                                        **/\n/** ...8- Instdata not updated due to failed TSS command **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** Current fields for instdata code                     **/\n/**                                                      **/\n/** Initial    - Value created by the TxxIDAT routine at **/\n/**              addition time                           **/\n/**                                                      **/\n/** Replace    - Value updated by the TxxIDAT routine at **/\n/**              request of administrator                **/\n/**                                                      **/\n/** Tosuspend  - Value set by automatic process,         **/\n/**              indicates the ID is to be suspended     **/\n/**              the next time the auto process is run.  **/\n/**                                                      **/\n/** Suspend    - Value set by automatic process,         **/\n/**              indicates the ID was      suspended     **/\n/**              by the automatic process.               **/\n/**                                                      **/\n/** Asuspend   - Value set by txxIDAT as a result of     **/\n/**              an administrator request.               **/\n/**                                                      **/\n/** Reset      - Value was reset as result of an         **/\n/**              administrator request.                  **/\n/**                                                      **/\n/** SYSTEMS    - A SPECIAL BYPASS VALUE NOT TO BE UPDATED**/\n/**                                                      **/\n/** CONSULT    - A SPECIAL BYPASS VALUE NOT TO BE UPDATED**/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T80GDAT             **/\n/**********************************************************/\ngood_msg = \"Completed successfully. DRC is:\"\nwarn_msg = \"Completed with warning. DRC is:\"\nfail_msg = \"Update Failed. DRC is:\"\nnew_trail = \"\"\nSPECIAL.SYSTEMS = \"YES\"\nSPECIAL.CONSULT = \"YES\"\nSPECIAL.BYPASS  = \"YES\"\naddress ispexec vget idat\n/* IDAT = \"'SYS4.SPI.IDATPARM(GOODIDAT)'\"  */\n\"ALLOC DDN(IDATparm) DSN(\"idat\") SHR REUS\"\n\"EXECIO * DISKR IDATPARM ( FINIS STEM HOLD.)\"\n\"FREE DDN(IDATPARM)\"\nCODE. = \"$$BADCODE$\"\nQ = TCODE(\"SUSPEND\",\"ASUSPEND\")\nQ = TCODE(\"INSTDATA\",\"REPLACE\")\nQ = TCODE(\"LANID\",\"REPLAN\")\nQ = TCODE(\"UNSUSPEND\",\"RESET\")\nQ = TCODE(\"ADD\",\"INITIAL\")\n/* the gcode routine defines a code as valid */\n/* the tcode routine defines a translate code */\n/*************************************************************/\n/* Below we map an invocation value to an output value to be */\n/* placed into INSTDATA.                                     */\n/* All output codes below should be defined as valid codes   */\n/* with the gcode routine earlier.                           */\n/*************************************************************/\ndo w = 1 to hold.0\n  line = substr(hold.w,1,80)\n  w1 = strip(word(line,1))\n  w2 = strip(word(line,2))\n  Q = GCODE(w2) /*define word2 as a valid non numerical value */\n  if w1 /= \".\" then\n    Q = TCODE(w1,w2) /* define invocation/resultant values */\nend\nQ = GCODE(\"INITIAL\")\nQ = GCODE(\"CONSULT\")\nQ = GCODE(\"SYSTEMS\")\nQ = GCODE(\"REPLACE\")\nQ = GCODE(\"TOSUSPEND\")\nQ = GCODE(\"SUSPEND\")\nQ = GCODE(\"ASUSPEND\")\nQ = GCODE(\"RESET\")\noutcode = 0\nARG ACID function newidata\nfunction = strip(function)\nsay \"T80IDAT invoked with :\" function newidata\n/************************************************************/\n/** Lets get all the ACID data we will need                **/\n/************************************************************/\nADDRESS tso \"%T80GDAT \" ACID \" INSTDATA INSTDATA\"\nADDRESS ISPEXEC \"vget secrc profile\"\nsay \"gdat idata is :\" secrc\ncurrent_idata = secrc\nADDRESS tso \"%T80GDAT \" ACID \" ATTRIBUTES BASIC\"\nADDRESS ISPEXEC \"vget secrc profile\"\nsay \"gdat attr is :\" secrc\nIF SECRC = \"$NOTFOUND\" THEN SECRC = \" \"\ncurrent_attr = secrc\n/************************************************************/\n/**                                                        **/\n/************************************************************/\n/************************************************************/\n/** lets get 1st byte of Detailed Return Code  DRC         **/\n/************************************************************/\noutcode = outcode + acode(current_attr)\nnew_code = code.function\n/************************************************************/\n/** lets get 2nd byte of DRC                               **/\n/************************************************************/\nsay \"T80IDAT: current Idata:\" current_idata\nif current_idata = \"$BADTSS\" then outcode = outcode + 4000\nif current_idata = \"$BADAUTH\" then outcode = outcode + 2000\nif current_idata = \"$BADACID\" then outcode = outcode + 1000\nif current_idata = \"$BADACID\" then current_idata = \" \"\nif New_code = \"$$BADCODE$\" then outcode = outcode + 8000\n/************************************************************/\n/** lets get 3rd byte of DRC                               **/\n/************************************************************/\noutcode = outcode + icode(current_idata)\ncurrent_enum = word(current_idata,1)\nnew_enum = current_enum\ncurrent_code = word(current_idata,2)\nnew_code = current_code\ncurrent_trail = substr(current_idata                                ,21)\nnew_trail = current_trail\nSelect\n  when function= \"LANID\" then do\n    new_enum  = current_enum\n    new_trail = newidata\n    new_code  = code.function\n  end\n  when function= \"UNSUSPEND\" then do\n    new_enum  = current_enum\n    new_trail = current_trail\n    new_code  = code.function\n  end\n  when function= \"ADD\" then do\n    new_enum  = substr(newidata,1,10)\n    new_code  = code.function\n  end\n  when function= \"SUSPEND\" then do\n    new_enum  = current_enum\n    new_code  = code.function\n  end\n  when function= \"INSTDATA\" then do\n    new_enum  = substr(newidata                 ,1,10)\n    new_code  = code.function\n  end\n  otherwise secrc = \"Failed. Unmapped invocation code\" function\n            address ispexec \"vput secrc profile\"\n            say secrc\nEnd\nif special.current_code = \"YES\" then new_code = current_code\nif special.current_code = \"YES\" then new_code = current_code\nsay \"T80IDAT: back from GDAT with:\" secrc\nsay \"  Current enum :\" current_enum\nsay \"  Current code :\" current_code\nsay \"  Current trail:\" current_trail\nsay \"****************\"\nsay \"  New enum :\" new_enum\nsay \"  New code :\" new_code\nsay \"  New trail:\" new_trail\n/************************************************************/\n/** lets get 4th byte of DRC                               **/\n/************************************************************/\nnew_enum = substr(new_enum                 ,1,10)\nnew_code = substr(new_code                 ,1,10)\nnew_idata = new_enum||new_code||new_trail\nif new_enum > 99999 then outcode = outcode + 1\nif new_enum < 0 then outcode = outcode + 1\n/************************************************************/\n/** A code > 1000 indicates a data get error from GDAT     **/\n/************************************************************/\nsecrc = good_msg outcode\nif outcode < 1000 then do\n  say \"TSS REP(\"acid\") instdata('\"new_idata\"')\"\n  tss_rcode = rc\n  address tso\n  \"TSS REP(\"acid\") instdata('\"new_idata\"')\"\nend\nelse do\n  outcode = outcode + 4\n  secrc = fail_msg outcode\nend\nif tss_rcode > 0 then do\n  outcode = outcode + 8\n  secrc = fail_msg outcode\nend\nsay \"T80IDAT invoked:\" newidata function\nsay \"  DRC is \" outcode\nif outcode /10 <> outcode%10 then do\n  remain = outcode//10\n  if remain < 6 then secrc = warn_msg outcode\nend\nsay \"/**  Detailed return code:                               **/\"\nsay \"/**                                                      **/\"\nsay \"/**  _____Data Retrieval Status                          **/\"\nsay \"/** |                                                    **/\"\nsay \"/** |_____ID Status                                      **/\"\nsay \"/** ||                                                   **/\"\nsay \"/** ||____Previous INSTDATA state                        **/\"\nsay \"/** |||                                                  **/\"\nsay \"/** |||___Action Taken                                   **/\"\nsay \"/** ||||                                                 **/\"\nsay \"/** 0...- Data retrieval worked                          **/\"\nsay \"/** 1...- No such ID                                     **/\"\nsay \"/** 2...- Not authorized for this ID                     **/\"\nsay \"/** 4...- TSS retrieval error                            **/\"\nsay \"/** 8...- Unknown invocation code                        **/\"\nsay \"/**                                                      **/\"\nsay \"/** .0..- ID has no unusual attributes                   **/\"\nsay \"/** .1..- ID is currently Suspended                      **/\"\nsay \"/** .2..- ID is currently Asuspended                     **/\"\nsay \"/** .4..- ID is currently Expired                        **/\"\nsay \"/** .8..- ID has special attributes                      **/\"\nsay \"/**                                                      **/\"\nsay \"/** ..0.- Instdata had valid data                        **/\"\nsay \"/** ..1.- Instdata had no previous instdata              **/\"\nsay \"/** ..2.- Instdata had special code                      **/\"\nsay \"/** ..4.- Instdata had invalid data                      **/\"\nsay \"/** ..8.- Instdata had pending suspend                   **/\"\nsay \"/**                                                      **/\"\nsay \"/** ...0- Instdata updated                               **/\"\nsay \"/** ...1- Instdata provided enum invalid                 **/\"\nsay \"/** ...2- Not used                                       **/\"\nsay \"/** ...4- Not used                                       **/\"\nsay \"/** ...6- Instdata not updated due to data retreival     **/\"\nsay \"/**       Failure                                        **/\"\nsay \"/** ...8- Instdata not updated due to failed TSS command **/\"\nADDRESS ISPEXEC \"vput secrc profile\"\nexit outcode\n/***************************/\ngcode: nop\narg indat\ngoodcode.indat = \"YES\"\nreturn 0\n/***************************/\ntcode: nop\nindat = arg(1)\nindat2 = arg(2)\ncode.indat = indat2\nreturn 0\n/***************************/\nacode: nop\narg indat\nif index(indat,\"SUSPEND\") > 0 then outcode = outcode + 100\nif index(indat,\"ASUSPEND\") >0  then outcode = 200\nif index(indat,\"CONSOLE\") > 0 then outcode = outcode + 800\nif index(indat,\"NO\") > 0 then outcode = outcode + 800\nreturn outcode\n/***************************/\nicode: nop\narg idat\nsay \"icode invoked with:\" idat\noutcode = 0\nc_enum = word(idat,1)\nc_code = word(idat,2)\nc_trail = substr(idat                                ,21)\nif (datatype(strip(c_enum)) /= \"NUM\") & (idat /= \" \" ) then\n  outcode = outcode + 40\nif idat = \" \" then outcode = outcode + 10\nif idat = \"TOSUSPEND\" then outcode = outcode + 80\nif special.c_code = \"YES\" then outcode = outcode + 20\nreturn outcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80INS": {"ttr": 12545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x04\\x00\\x03\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x18\\x00\\xcf\\x00\\xcf\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.04", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:18:03", "lines": 207, "newlines": 207, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T80INS                            **/\n/** LAST MODIFIED    :  9 dec 99                         **/\n/**********************************************************/\n/** NOW ACCEPTS MULTIPLE PROFS IN STD INVOCATION         **/\n/**********************************************************/\n/** CHANGED CODE TO FIX ERROR FOR INSERTS AT POSITION    **/\n/** GREATER THAN 1 WHEN ID HAS NO PROFILES    ....DR     **/\n/**********************************************************/\n/** REVAMPED TO USE THE AFTER KEYWORD OF INSERT COMMAND  **/\n/** SHOULD BE LOTS FASTER AND EASIER TO MANAGE....DR     **/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 12                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         EXITPRM                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T80FDIV %T80GDAT    **/\n/**********************************************************/\nARG ACID PROFILE TARGET DAYS\n/************************************************************/\n/** PATCH BELOW FOR NORMAL INVOCATION FOR MULTIPLE PROFILES */\n/************************************************************/\nif target = \" \" then target = 1\nTEMP = PROFILE TARGET DAYS\nPROFS = 0\nPARSE VAR TEMP TW.1 TW.2 TW.3 TW.4 TW.5 TW.6 TW.7 TW.8 TW.9 TW.10\nALLWORDS = WORDS(TEMP)\nIF (ALLWORDS = 3) & ( DATATYPE(TW.2) = \"CHAR\" ) THEN do\n  PROFILE = TW.1||\".\"||TW.2\n  TARGET = DAYS\n  DAYS = \"\"\n  say \"TSA101D: T80INS reformatted input is :\" acid profile target days\nEND\nIF ALLWORDS > 3 THEN DO\n  DO COUNT = 1 TO ALLWORDS\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN PROFS = COUNT - 1\n    IF DATATYPE(TW.COUNT) = \"NUM\" THEN LEAVE\n  END\n  PROFILE = \"\"\n  DO CNT2 = 1 TO PROFS\n    PROFILE = PROFILE||\".\"||TW.CNT2\n  END\n  TARGET_WORD = PROFS + 1\n  DAYS_WORD = PROFS + 2\n  TARGET = WORD(TEMP,TARGET_WORD)\n  DAYS   = WORD(TEMP,DAYS_WORD)\n  say \"TSA101D: T80INS reformatted input is :\" acid profile target days\nEND\n/*****/\nACT = \"AFTER\"\nADDRESS ISPEXEC\nPROFILE = TRANSLATE(PROFILE,\" \",\".\") /*CHANGE DOTS TO BLANKS */\nPROFILE = TRANSLATE(PROFILE,\" \",\"_\") /*CHANGE _    TO BLANKS */\nSYSENV = SYSVAR(SYSENV)\nPROF. = \" \"\nPROFHLD = \" \"\nQ = OUTTRAP(\"OFF\")\nSAY \" \"\nsay \"TSA101D: T80INS control received.\"\nsay \"TSA101D: T80INS profile is\" profile\nsay \"TSA101D: T80INS target  is\" target\nsay \"TSA101D: T80INS days    is\" days\nPARSE VAR PROFILE PROF.1 PROF.2 PROF.3 PROF.4 PROF.5\nPROFNUM = WORDS(PROFILE)\nIF PROFNUM > 5 THEN DO\n  secrc = \"TSA251E: Failed. Insert function only supports \"\n  secrc = secrc||\"5 profiles at a time\"\n  say \"TSA101D: T80INS:\" secrc\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DATATYPE(TARGET) \u00ac= \"NUM\" THEN DO\n   SECRC=\"FUNCTION ABORTED. LOCATION SPECIFIED IS NOT NUMERIC.\"\n   SECRC= SECRC TARGET\n   IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n   EXIT 16\nEND\n/*********************************************************************/\n/* NOW I MAKE SURE EACH PROF HE PASSED ME IS ACTUALLY A PROFILE. DIR */\n/* NOTE THAT THIS CHECKING IS SKIPPED FOR A BATCH USER.          DIR */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  SECRC = \"PROFILE\" /*SET TO PROFILE FOR BATCH DEFAULTS */\n  IF SYSENV = \"FORE\" THEN DO\n    say \"TSA101D: T80INS environment is foreground\"\n    say \"TSA101D: T80INS I am calling Txxfdiv for data on \"prof.cnt\n    ADDRESS TSO \"%T80FDIV \"PROF.CNT\n    ADDRESS ISPEXEC \" VGET SECRC PROFILE\"\n  END\n  IF SECRC \u00ac= \"PROFILE\" THEN DO\n    say \"TSA101D: T80INS rcode indicates \" prof.cnt \"is not a profile\"\n    say \"TSA101D: T80INS return code is ===>\" secrc\n    secrc= \"TSA252E: \"\n    secrc= secrc\"Function aborted. \"prof.cnt \"is not an owned profile.\"\n    IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n    EXIT 08\n  END\nEND\nSIGNAL ON ERROR NAME ERRID\nsay \"TSA101D: T80INS testing primary id for existance\"\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nsay \"TSA101D: T80INS rcode from test is \" rc\nSIGNAL OFF ERROR\n/*********************************************************************/\n/* NOW I REMOVE THE PROFS BEFORE INSERTING THEM JUST IN CASE THIS IS */\n/* THE EQUIVALENT OF A MOVE OPERATION...........DIR 19 JUN 91        */\n/*********************************************************************/\nDO CNT = 1 TO PROFNUM\n  say \"TSA101D: T80INS removing the stated profiles first !\" prof.cnt\n  ADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROF.CNT\")\"\n  IF RC > 0 THEN NOTTHERE = \"YES\"\nEND\n/*********************************************************************/\n/* IF THIS IS THE EQUIVALENT OF A DELETE WE ARE DONE....DIR 19 JUN 91*/\n/*********************************************************************/\nIF TARGET = 0 THEN DO\n  SECRC = PROFILE \" REMOVED FROM \"ACID\", AND NOT REINSERTED.\"\n  IF NOTTHERE = \"YES\" THEN DO\n    say \"TSA101D: T80INS non 0 rc received from tss remove command\"\n    secrc = \"TSA253E: Failed. Delete requested but \"profile \"not\"\n    secrc =  secrc\" removed from ACID\" acid\".\"\n  END\n  SAY \"T80INS:\" SECRC\n  IF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\n  EXIT\nEND\n/*                                              */\n/*Q = OUTTRAP(\"OUT.\")                           */\n/*ADDRESS TSO \"TSS LIST(\"ACID\") DATA(BASIC)\"    */\nQ = OUTTRAP(\"OFF\")\n/*********************************************************************/\n/* NOW I GET THE PROFILES CURRENTLY ATTACHED TO THE ACID DR 2 MAY96  */\n/*********************************************************************/\nADDRESS TSO \" %T80GDAT \"ACID \" PROFILES\"\nADDRESS ISPEXEC \" VGET SECRC PROFILE\"\nPROFHLD = SECRC\nSAY \"T80INS: CURRENT PROFILES ARE : \" PROFHLD\nTOTWORDS = WORDS(PROFHLD)\nIF PROFHLD = \"$NOTFOUND\" THEN TOTWORDS = 0\nIF TARGET > TOTWORDS THEN DO\n  TARGET = TOTWORDS + 1\n  SAY \"T80INS: POSITION PARM OVERRIDDEN. CHANGED TO \"TARGET\nEND\n/******************************************************************/\n/* WE ISSUE THE COMMAND WITH AN AFTER PARM UNLESS THE FUNCTION IS */\n/* TO ADD THE PROFILE AS THE FIRST IN HIS LIST, THEN WE MUST      */\n/* USE THE BEFORE PARM. THIS NEXT CODE IS HERE IN CASE TARGET IS  */\n/* EQUAL TO POSITION 1. DIR 2 MAY 96                              */\n/******************************************************************/\nIF TOTWORDS = 0 THEN DO\n  IF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"\n  IF DAYS \u00ac= \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\")\"\n  SIGNAL SEEYA\nEND\nQ1 = TARGET\nIF TARGET = 1 THEN ACT = \"BEFORE\"\nELSE Q1 = TARGET - 1\nIF Q1 = 0 THEN ACT = \"BEFORE\"\nTPROF = WORD(PROFHLD,Q1)\nSAY \"T80INS: INSERT TGT IS PROFILE \" TPROF\nSIGNAL ON ERROR NAME ERRXIT\nSAY \"T80INS: ADDING FOLLOWING PROFILES TO ACID\"\nSAY \"T80INS: PROFILES ===> \"PROFILE\nSAY \"T80INS: CHECKING FOR TEMPORARY TIMESPAN\"\nIF DAYS =  \" \" THEN ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") \"ACT\"(\"TPROF\")\"\nELSE ADDRESS TSO \"TSS ADD(\"ACID\") PROF(\"PROFILE\") FOR(\"DAYS\") \",\n      ACT\"(\"TPROF\")\"\nSEEYA: NOP\nsecrc =  \"TSA254I:\" profile \"inserted in \"acid\" at position\" target\".\"\nSAY \"T80INS: \"SECRC\nSAY \"  \"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nEXIT 0\n\nERRXIT: NOP\nSAY \"T80INS: ERROR IN LINE:\" SIGL\nSECRC =  \"CATASTROPHIC FAILURE ! PROFILES BELOW NOT ADDED !\"\nSAY \"T80INS: \"SECRC\nSAY \"  \"\nEXITRC16 = ACID \"LOST:\" PROFHLD\nSAY \"T80INS: \"EXITRC16\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC16 PROFILE\"\nEXIT 1\nERRID: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . MAY NOT EXIST\"\nSAY \"T80INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"MAY NOT EXIST\"\nSAY \"T80INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\nERRPRF: NOP\nSECRC =  \"INSERT FAILED. CHECK ID!! . SOME PROFILES MAY NOT BE OWNED!\"\nSAY \"T80INS: \"SECRC\nSAY \"  \"\nEXITRC12 = ACID \"PROFS IN QUESTION:\" Y\nSAY \"T80INS: \"EXITRC12\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT SECRC PROFILE\"\nIF SYSENV = \"FORE\" THEN \"ISPEXEC VPUT EXITRC12 PROFILE\"\nEXIT 1\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80ISAVE": {"ttr": 14593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x14\\x17O\\x01\\x14\\x17O\\x13E\\x08\\x88\\x08\\x88\\x00\\x00\\xc7\\xd9\\xd7\\xe3\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-06-23T00:00:00", "modifydate": "2014-06-23T13:45:03", "lines": 2184, "newlines": 2184, "modlines": 0, "user": "GRPTDIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** fixed some doc                         02/16/2009    **/\n/**********************************************************/\n/** Fixed problem where a profile with INSTDATA does     **/\n/** not skip ACIDS                         05/14/2007    **/\n/**********************************************************/\n/** Added support for a better instdata conversion       **/\n/**                                        05/11/2007    **/\n/**********************************************************/\n/** Added a lineskip section for lines that can be       **/\n/** totally ignored for conversion and other functions   **/\n/** for the adminby data                   02/13/2007    **/\n/**********************************************************/\n/** changed for 5.3 profile acid conversion              **/\n/** acids are listed differently so the bypass list      **/\n/** parms had to be updated                03/31/2005    **/\n/**********************************************************/\n/**********************************************************/\n/** Updated comments                        7/27/04      **/\n/**********************************************************/\n/** Fixed array load error which would invalidate        **/\n/** converts..                              12/1/03      **/\n/** Very important fix....                               **/\n/**********************************************************/\n/** Fixed MASTFAC syntax on converts         9/17/03     **/\n/**********************************************************/\n/** Fixed volume rules for (D) specification 9/15/03     **/\n/**********************************************************/\n/** updated modrule varname error   Aug 21 2003  DIR     **/\n/**********************************************************/\n/** updated getval routine to return blanks when a var   **/\n/** has not been assigned a value     Aug 5 2003  dir    **/\n/**********************************************************/\n/** created DL subroutine to write log data to           **/\n/** writedebug log  July 2003                            **/\n/**********************************************************/\n/**********************************************************/\n/** Updated allacid. array processing and adding comments**/\n/** Removed the acidrul array                            **/\n/**********************************************************/\n/**********************************************************/\n/** Started conversion to one array instead of one array **/\n/** for each acid instream. nov 22 2002                  **/\n/**********************************************************/\n/**********************************************************/\n/** added convert support for d,g and t,g in volume      **/\n/** rules  dir may 5 2002                                **/\n/**********************************************************/\n/**********************************************************/\n/** changed some doc spelling DIR FEB 22 2002            **/\n/**********************************************************/\n/** Change to modrule routine to totally remove the      **/\n/** scrolling area of that routine... I don't even know  **/\n/** why that section of the routine was there....        **/\n/**                  DIR Novem 05 2001                   **/\n/**********************************************************/\n/**********************************************************/\n/** July 25 2001 - documentation updates                 **/\n/**********************************************************/\n/** Change to debug modify processing to fix errant ptr  **/\n/** Which caused some scrolling to miss records and      **/\n/** caused records selected during modify to be wrongly  **/\n/** selected         DIR april 12 2001                   **/\n/**********************************************************/\n/** Discovered that modify will not support stacked/     **/\n/** owned resources, and that it would be a bear to      **/\n/** fix so I am leaving it alone.                        **/\n/**********************************************************/\n/** Fixed modify function to properly display access for **/\n/** datasets.                                            **/\n/**********************************************************/\n/** Added the clone function to support requirements     **/\n/**********************************************************/\n/** Added some comments for the poor guy who will        **/\n/** maintain this after I am long gone.                  **/\n/**********************************************************/\n/** removed balance and listdup functions due to lack    **/\n/** of interest and extended support issues              **/\n/**********************************************************/\n/** getdata routine and translate routine changed to     **/\n/** used straight subscript reference for duplicates     **/\n/** so we no longer need the aciddup. stem.              **/\n/**********************************************************/\n/** Multi parm revoke logic added for v51 *****************/\n/**********************************************************/\n/** Multi line instdata fixed   ***************************/\n/**********************************************************/\n/** profile expiration fixed    ***************************/\n/**********************************************************/\n/** EXEC NAME        : T80ICOMP                          **/\n/** LAST MODIFIED    : 16 Feb  2009                      **/\n/** a multiple function routine which initially breaks   **/\n/** down an ID of group of IDs into 'translated data'.   **/\n/** This tranlated data is a list of the ID with one line**/\n/** per permission rule.                                 **/\n/** This list   is then evaluated to produce the desired **/\n/** output depending on the function specified.          **/\n/**                                                      **/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** Function:  one of the following options:             **/\n/**                                                      **/\n/**   Translate:                                         **/\n/**     This function is used for debugging, when        **/\n/**     specified the exec writes out the translated     **/\n/**     interim data for each ID specified in the        **/\n/**     acidlist. This is excellent for seeing how an ID **/\n/**     is being manipulated internally. Be aware this   **/\n/**     function writes output directly to the screen so **/\n/**     you may wish to front end this option            **/\n/**     with some of of output trapping. Like the FSDISP **/\n/**     exec for example.                                **/\n/**                                                      **/\n/**   Modify:                                            **/\n/**     This function is a full screen modify facility   **/\n/**     for a TSS ACID.                                  **/\n/**                                                      **/\n/**   Rebuild:                                           **/\n/**     This function creates a stream to recreate an ID **/\n/**     The stream contains the TSS create command in    **/\n/**     addition to the add and permit commands that are **/\n/**     generated by the permit function below.          **/\n/**                                                      **/\n/**   Clone:                                             **/\n/**     This function creates a stream to create an ID   **/\n/**     based on the authorities of another specified    **/\n/**     ID.                                              **/\n/**                                                      **/\n/**   Permit:                                            **/\n/**     Exactly the same output as above but with no TSS **/\n/**     create command for each ID.                      **/\n/**                                                      **/\n/**   Rpermit                                            **/\n/**     This creates a stream that would recreate all    **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**   Revoke:                                            **/\n/**     This creates a stream that would remove all      **/\n/**     permissions from the ID.                         **/\n/**                                                      **/\n/**   Rrevoke:                                           **/\n/**     This creates a stream that would remove all      **/\n/**     permissions to a resource system wide            **/\n/**                                                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  %T80JCARD           **/\n/**********************************************************/\n/** Variable definitions                                 **/\n/**********************************************************/\n/** Input variable for vgets:                            **/\n/**                                                      **/\n/** defgroup = the defgroup OMVS group for invoking the  **/\n/**            %GIVEUID exec.                            **/\n/**                                                      **/\n/** DS1      = work dsn #1 in the SPI system             **/\n/**                                                      **/\n/** DS2      = work dsn #2 in the SPI system             **/\n/**                                                      **/\n/** idebug   = a debug value that can be set to override **/\n/**            debug values in this exec                 **/\n/**                                                      **/\n/** Makeauth = \"YES\" - indicates we are making an        **/\n/**             authority stream                         **/\n/** Makecust = If set is a custom command for this user  **/\n/**            that we will include after every ACID     **/\n/**            creation stream.                          **/\n/** newpass  = The password value to be used in converts **/\n/**                                                      **/\n/** uidcon   = a value to specify if UIDs are converted  **/\n/**            'as is' or if the %giveuid exec is to be  **/\n/**             used instead.                            **/\n/**            NO =  The GIVEUID exec is issued for a new**/\n/**              UID, unless UID is zero.                **/\n/**            YES = The exact UID will be replicated    **/\n/**              A UID of zero is always be replicated   **/\n/**                                                      **/\n/**********************************************************/\n/** Note : I use the '#' below to indicate a numeric     **/\n/**          subscript                                   **/\n/**                                                      **/\n/** acidnum            How many acids were passed to me  **/\n/** acids.#            The actual acids                  **/\n/** accessor.#         The subscripts of the ACCESSORID= **/\n/**                      lines in the list               **/\n/**********************************************************/\n/** IN the below variables the 'name' area is a variable **/\n/**  which is an actual ACID                             **/\n/**********************************************************/\n/** The acidlst. arrays are the actual output from the   **/\n/**  TSS list command.                                   **/\n/**                                                      **/\n/**  NOTE: The ACIDS. array has one entry for each listed**/\n/**        ACID, it is the source for the name below...  **/\n/**                                                      **/\n/**                                                      **/\n/** acidlst.name.0     How many lines of output for below**/\n/** acidlst.name.#     the TSS list output for the acid  **/\n/**                      in variable name                **/\n/**********************************************************/\n/** The ALLACID array is a sequential array that has one **/\n/** translated rule for each listed ACID                 **/\n/**                                                      **/\n/** Note: This array should be accessed by the SETVAL and**/\n/**       GETVAL functions, not accessed natively in the **/\n/**       main routine.                                  **/\n/**                                                      **/\n/** allacid.0          How many total lines of data      **/\n/** allacid.#.0acid    the acid this line relates to     **/\n/** allacid.#.0type    the type                          **/\n/** allacid.#.0segment the segment                       **/\n/** allacid.#.0resname the resource name                 **/\n/** allacid.#.0restext the resource text                 **/\n/** allacid.#.0concat  is this line to be concatenated   **/\n/**                    to the previous one ? ie part of  **/\n/**                    a multi line permission...        **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**                  ARRAY FLOW                          **/\n/**   _______     _______      _______                   **/\n/**  |       |   |       |    |       |                  **/\n/**  | lst1  |   | lst2  |    | lst3  |  acidlst. arrays **/\n/**  |       |   |       |    |       |                  **/\n/**  |_______|   |_______|    |_______|                  **/\n/**      |           |            |                      **/\n/**      |           |            |                      **/\n/**      |___________|____________|                      **/\n/**                  |                                   **/\n/**               _______                                **/\n/**              |       |                               **/\n/**              |       |                               **/\n/**              |  all  |               allacid. array  **/\n/**              |       |                               **/\n/**              |_______|                               **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/** In the below variable name and type and resource     **/\n/**   are all variables !!                               **/\n/**********************************************************/\n/**                                                      **/\n/** modrule.0parse.0   The number of keywords to search  **/\n/**                for in a rule permission.             **/\n/**                                                      **/\n/** modrule.0parse.#   The keywords                      **/\n/**                                                      **/\n/** convert.0newid    \"YES\" or \"NO\" depending on if the  **/\n/**                      ACID is changing in the convert **/\n/** convert.0name     The new ACID to replace real one   **/\n/**                      in the ouput stream             **/\n/**                                                      **/\n/** debug.xxxxxx       Turns on debug displays in various**/\n/**                    routines for serious problems.    **/\n/**                                                      **/\n/**********************************************************/\nARG function ACIDLIST\ndebug.flow     = \"YES\"  /* keep this YES for basic messages. */\ndebug.multcon  = \"NO\"\ndebug.bypass   = \"YES\"\ndebug.convert  = \"YES\"\ndebug.makeacid = \"NO\"\ndebug.modify   = \"NO\"\nDEBUG.GETDATA  = \"NO\"\nDEBUG.setval   = \"NO\"\nDEBUG.getval   = \"NO\"\ndebug.fillscr  = \"NO\"\ndebug.modrule  = \"NO\"\ndebug.resource = \"NO\"\ndebug.trans    = \"NO\"\nfill_override = 0\nsignal off error\naddress ispexec \"vget uidcon profile\"\naddress ispexec \"vget instcon profile\"\naddress ispexec \"vget defgroup profile\"\naddress ispexec \"vget idebug profile\"\nif rc = 0 then do\n  /*****************************************************************/\n  /* idebug is a value that can be set in the T$$ execs to turn on */\n  /* a specific debug. Usually for testing something.              */\n  /*****************************************************************/\n  dflag = idebug\n  address ispexec \"verase idebug profile\"\n  debug.dflag = \"YES\"\n  if dflag = \"ALL\" then debug. = \"YES\"\n  if dflag = \"NONE\" then debug. = \"NO\"\nend\naddress ispexec \"vget makecust profile\"\nif rc = 0 then do\n  /*************************************************/\n  /**         The MAKECUST variable               **/\n  /*************************************************/\n  /** This variable should hold a custom command  **/\n  /** to be included in the stream directly       **/\n  /** after the create statement. The command     **/\n  /** should have a $$ in it to hold the ACID     **/\n  /** place in the command.                       **/\n  /** This would be used if you were moving IDs to**/\n  /** another environment and wanted a certain    **/\n  /** command included in the convert to          **/\n  /** support that environment.                   **/\n  /**                           DIR 25 july 2001  **/\n  /**                                             **/\n  /*************************************************/\n  makeacid.0custom = \"YES\"\n  makeacid.0custom.command = makecust\n  /* address ispexec \"verase makecust profile\" */\nend\n  /*************************************************/\n  /** A makeauth command is basically a convert   **/\n  /** with two changes:                           **/\n  /** 1 - The new ID is $$                        **/\n  /** 2 - The tss create command is not done      **/\n  /**                                             **/\n  /*************************************************/\naddress ispexec \"vget makeauth profile\" /* R we making an auth stream */\nmake_rc = rc\n/*\nsay \"TSA101D: makeauth check was \" make_rc makeauth\n*/\nq=dl(,,\"makeauth check was \" make_rc makeauth)\nif make_rc = 0 then do\n  /*************************************************/\n  /** Makeacid is just a type of CLONE really     **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n     /* tells the convert routine to change all outbound ACID */\n  convert.0name = \" $$ \"  /* this is the new ACID name */\n  makeacid.0auth = \"YES\"  /* tell the makeacid routine */\n  address ispexec \"verase makeauth profile\"\nend\nif function = \"CLONE\" then do\n  /*************************************************/\n  /** a clone is a convert with a new ID plugged  **/\n  /** into the output, so we set some flags and   **/\n  /** then change function to REBUILD.            **/\n  /**                                             **/\n  /*************************************************/\n  convert.0newid = \"YES\"\n  convert.0name = word(acidlist,2)\n  Acidlist = word(acidlist,1)\n  function = \"REBUILD\"\n  makeacid.0custom = \"YES\"\n  uidcon = \"NO\"\n  makeacid.0custom.command = \"    %ADDLOCAL $$\"\n  /*************************************************/\n  /** We use the makeauth feature to plug in the  **/\n  /** %addlocal command into the output           **/\n  /**                                             **/\n  /*************************************************/\n  address ispexec \"verase makeauth profile\"\nend\ntrace_acid = \"AN_ID_TO_TRACE\"            /* a way to trace one line */\ntrace_record = 21                       /* of one id.. lots of output*/\ndebug.trace_acid.trace_record = \"TRACE\"\n/********************************************************/\n/* Specify that these resources use the entire line     */\n/********************************************************/\nrname = \"TSOCOMMAND\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"TSOC\"\nrname = \"IMSMSC\"\nconvert.0fulline.rname = \"YES\"\nconvert.0resource.rname = \"IMSMSC\"\n/*******/\n/* uncomment the below line for all debugs */\n/* debug. = \"YES\"  */\nmaint = \"Feb 13 2007\"\nq=dl(,,\"T80ICOMP in control with parms \" function acidlist)\nq=dl(,,\" T80ICOMP Maint = \" maint)\nSIGNAL ON ERROR NAME SEEYA\nHEX00 = '00'X\nDISP = \"SHR\"\nblank59= \"                                                           \"\nSYSENV = SYSVAR(SYSENV)\nsecrc = \"failed in T80ICOMP. no other information available\"\n/*                          */\nif substr(function,1,1) = \"*\" then functype = \"RESOURCE\"\nif substr(function,1,1) = \"*\" then function = substr(function,2)\n  /*****************************************************************/\n  /** A resource function uses an entirely different variable     **/\n  /** loader routine since the input is in a radically different  **/\n  /** format.                                                     **/\n  /**                                                             **/\n  /**                                                             **/\n  /*****************************************************************/\nq=dl(,,\" Retrieving profile variables \")\naddress ispexec \"vget ds2 profile\"\naddress ispexec \"vget newpass profile\"\n/**************************************************/\n/* below we define which functions need a jobcard */\n/**************************************************/\nsecrc = \"failed during jobcard function\"\nJOBCARD.MODIFY = \"YES\"\nJOBCARD.PERMIT  = \"YES\"\nJOBCARD.RPERMIT = \"YES\"\nJOBCARD.BALANCE = \"YES\"\nJOBCARD.RREVOKE = \"YES\"\nJOBCARD.REVOKE  = \"YES\"\nJOBCARD.REBUILD = \"YES\"\nif makeauth = \"YES\" then jobcard.rebuild = \"NO\"\nif sysdsn(ds2) = \"OK\" then do\n  if jobcard.function = \"YES\" then do\n    q=dl(,,\" calling jobcard function. \" )\n    address tso \"%T80jcard \"ds2\n    disp = \"MOD\"\n  end\n  address tso \"alloc ddn(outds2) dsn(\"ds2\") \"disp\" reus\"\nend\nif sysdsn(ds2) /= \"OK\" then do\n  q=dl(,,\" Output DSN unusable, data written to screen \")\n  screen = \"YES\"\nend\nacidlst.NAME.0 = 0\nPASSWORD.  =  \"NO_PASSWORD_FOUND\"\nblanks = \"        \"\nacidnum = 0\ncmpnum  = 0\ncvtnum  = 0\nfound.   = \"NO\"\ncreate.0 = 0\nBYPASS. = 0\nsecrc = \"failed in T80ICOMP. no other information available\"\n/********************************************************/\n/* these are looked for in the modify routine           */\n/********************************************************/\nmodrule.0parse.0 = 6\nMODRULE.0PARSE.1 = \"LIBRARY \"\nMODRULE.0PARSE.2 = \"ACCESS \"\nMODRULE.0PARSE.3 = \"FACILITY \"\nMODRULE.0PARSE.4 = \"ACTION \"\nMODRULE.0PARSE.5 = \"UNTIL \"\nMODRULE.0PARSE.6 = \"PRIVPGM \"\nMODRULE.0PANEL   = \"SPIUPDT\"\n/********************************************************/\n/* The following words in position 1 cause the entire   */\n/* line to be skipped                                   */\n/********************************************************/\nlineskip.0 = 2\nlineskip.1 = \"TSS0300I\"\nlineskip.2 = \"ADMIN\"\n/********************************************************/\n/* these values wont even be translated during a modify */\n/********************************************************/\nHOLD = \"MODIFY\"\nBYPASS.0SUPRESS.HOLD.0 = 13\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\nBYPASS.0SUPRESS.HOLD.13 = \"ACID\"\n/********************************************************/\n/* these values wont even be translated during a balance*/\n/********************************************************/\nHOLD = \"BALANCE\"\nBYPASS.0SUPRESS.HOLD.0 = 12\nBYPASS.0SUPRESS.HOLD.1 = \"ACCESSORID\"\nBYPASS.0SUPRESS.HOLD.2 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.3 = \"NAME\"\nBYPASS.0SUPRESS.HOLD.4 = \"TYPE\"\nBYPASS.0SUPRESS.HOLD.5 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.6 = \"DEPTACID\"\nBYPASS.0SUPRESS.HOLD.7 = \"DIVACID\"\nBYPASS.0SUPRESS.HOLD.8 = \"ZONEACID\"\nBYPASS.0SUPRESS.HOLD.9 = \"ACID\"\nBYPASS.0SUPRESS.HOLD.10 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.11 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.12 = \"TUPT\"\n/********************************************************/\n/* end of values not to   be translated during a modify */\n/********************************************************/\nHOLD = \"TRANSLATE\"\nBYPASS.0SUPRESS.HOLD.0 = 6\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nBYPASS.0SUPRESS.HOLD.6 = \"ADMINBY\"\nHOLD = \"REBUILD\"\nBYPASS.0SUPRESS.HOLD.0 = 5\nBYPASS.0SUPRESS.HOLD.1 = \"LASTUSED\"\nBYPASS.0SUPRESS.HOLD.2 = \"CREATED\"\nBYPASS.0SUPRESS.HOLD.3 = \"TCONS\"\nBYPASS.0SUPRESS.HOLD.4 = \"TRBA\"\nBYPASS.0SUPRESS.HOLD.5 = \"TUPT\"\nhold = \"COMPARE\"\nBYPASS.HOLD.0 = 11\nBYPASS.HOLD.1 = \"ACCESSORID\"\nBYPASS.HOLD.2 = \"NAME\"\nBYPASS.HOLD.3 = \"TYPE\"\nBYPASS.HOLD.4 = \"CREATED\"\nBYPASS.HOLD.5 = \"LASTUSED\"\nBYPASS.HOLD.6 = \"DIVACID\"\nBYPASS.HOLD.7 = \"DEPARTMENT\"\nBYPASS.HOLD.8 = \"DIVISION\"\nBYPASS.HOLD.9 = \"DEPTACID\"\nBYPASS.HOLD.10= \"ZONEACID\"\nBYPASS.HOLD.11= \"* SEGMENT\"\nBYPASS.HOLD.12 = \"* TCONS\"\nBYPASS.HOLD.13 = \"* TRBA\"\nBYPASS.HOLD.14 = \"* TUPT\"\nHOLD = \"PERMIT\"\nBYPASS.HOLD.0 = 15\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.5 = \"AUTHORITY LASTUSED\"\nBYPASS.HOLD.6 = \"BASE SEGMENT\"\n/* BYPASS.HOLD.7 = \"* ACID \"  */\n/* commented above due to the need for admin auth to function */\nBYPASS.HOLD.7 = \"INSTDATA ACID \"\nBYPASS.HOLD.8 = \"BASE DEPTACID\"\nBYPASS.HOLD.9  = \"BASE DIVACID\"\nBYPASS.HOLD.10 = \"BASE ZONEACID\"\nBYPASS.HOLD.12 = \"* PASSWORD\"\nBYPASS.HOLD.13 = \"AUTHORITY ACID\"\nBYPASS.HOLD.14 = \"AUTHORITY ACIDS\"\nBYPASS.HOLD.15 = \"* TCONS\"\nBYPASS.HOLD.16 = \"* TRBA\"\nBYPASS.HOLD.17 = \"* TUPT\"\nBYPASS.HOLD.18 = \"* ADMIN\"\nBYPASS.HOLD.19 = \"* ACIDS\"\nHOLD = \"REVOKE\"\nBYPASS.HOLD.0 = 12\nBYPASS.HOLD.1 = \"BASE ACCESSORID\"\nBYPASS.HOLD.2 = \"BASE NAME\"\nBYPASS.HOLD.3 = \"BASE TYPE\"\nBYPASS.HOLD.4 = \"BASE DIVACID\"\nBYPASS.HOLD.5 = \"BASE ZONEACID\"\nBYPASS.HOLD.6 = \"AUTHORITY CREATED\"\nBYPASS.HOLD.7 = \"* LASTUSED\"\nBYPASS.HOLD.8  = \"AUTHORITY ACID\"\nBYPASS.HOLD.9  = \"BASE ZONEACID\"\nBYPASS.HOLD.10= \"* TCONS\"\nBYPASS.HOLD.11= \"* TRBA\"\nBYPASS.HOLD.12 = \"* TUPT\"\naccessor.0 = 0\ncreate_num = 0\nDATA = \"ALL,EXPIRE\"\n/*****************************************************************/\n/*****************************************************************/\n/* all variables are initialized.....the main section(s) follow  */\n/*****************************************************************/\n/*****************************************************************/\nq=dl(,,\" Basic initialization complete, execution begins.\")\n /*****************************************************************/\n /*****************************************************************/\n /* Below is the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif functype = \"RESOURCE\" then do\n  signal on error name badres\n  acidnum = 0\n  q=dl(,,\" Resource processing started\")\n  /*****************************************************************/\n  /* Lets either issue the tss list or read in the data from file  */\n  /*****************************************************************/\n  if acidlist /= \"BYPASS\" then do\n    ss = outtrap(\"HOLD.\",5000)\n    call vparse acidlist\n    signal on error name badres\n    ADDRESS TSO \"TSS whohas \"w.1\"(\"w.2\")\"\n  end\n  /*****************************************************************/\n  /* I code the two ifs this way because an else when in multiple  */\n  /* loops is confusing...dir                                      */\n  /*****************************************************************/\n  if acidlist = \"BYPASS\" then do\n    signal on error name baddsn\n    /*****************************************************************/\n    /* Lets read in the DSN and break it up into different variables */\n    /*****************************************************************/\n    q=dl(,,\" Bypass option specified, allocating input DSN\")\n    address ispexec \"vget ds1 profile\"\n    address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n    address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n    address tso \"free ddn(inds1)\"\n  end\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    if word(line,1) = \"TSS0300I\" then iterate l\n    IF (GOTOWNER = \"YES\") & (index(line,\"XAUTH \") > 0) then do\n      parse var line drop keep\n      line = \"XA \"strip(newtype) strip(keep)\n    end\n    if (index(line,\"OWNER(\") > 0) then do\n      acidnum = acidnum + 1\n      parse var line newtype drop 'OWNER(' owner ')' drop2\n                           /* below we save the starting line #  */\n                           /* of each acid.. not sure why        */\n      accessor.acidnum = l\n      name = owner\n      acids.acidnum = name\n      acidlst.name.0 = 0\n      gotowner = \"YES\"\n      q=dl(,\"RESOURCE\",\"owner = \" acidnum \"name = \" owner )\n    end\n    if (index(line,\"ACID(\") > 0) then do\n      /* lets grab the acid */\n      parse var line drop 'ACID(' name ')' drop2\n    /*****************************************************************/\n    /* In resources the ACID with the auth is way to the right on    */\n    /*  the report so we note each of them for future reference      */\n    /*  Note the .name portion of the below variable insures that    */\n    /*  even if one ACID has authorites in multiple areas of the     */\n    /*  output, it is counted only once. The classic variable named  */\n    /*  variable....                                                 */\n    /*****************************************************************/\n      if found.name = \"NO\" then do\n        acidnum = acidnum + 1\n        accessor.acidnum = l\n        acids.acidnum = name\n        found.name = \"yes\" /* actually any non  NO value works */\n      end\n      temp1 = acidlst.name.0\n      if datatype(temp1) /= \"NUM\" then acidlst.name.0 =0\n      q=dl(,resource,\"acidnum = \" acidnum \"name = \" name )\n    end\n    parse var line keep 'ACID(' drop2 ')'\n    line = keep\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = line\n    acidlst.name.0 = temp\n    q=dl(,,\" Total acids referenced in input is \" acidnum )\n  end\nend\n /*****************************************************************/\n /*****************************************************************/\n /* End of   the special translate area for resource functions    */\n /*****************************************************************/\n /*****************************************************************/\nif  functype = \"RESOURCE\" then signal evaluate\nif acidlist = \"BYPASS\" then do\n  /*****************************************************************/\n  /* Lets read in the DSN and break it up into different variables */\n  /*****************************************************************/\n  acidnum = 0\n  q=dl(\"tsa101d\",,\" Bypass option specified, allocating input dsn\")\n  address ispexec \"vget ds1 profile\"\n  address tso \"alloc ddn(inds1) dsn(\"ds1\") shr reus\"\n  address mvs \"EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)\"\n  address tso \"free ddn(inds1)\"\n  do l = 1 to hold.0\n    hold.l = translate(hold.l,\" \",hex00) /* kill the hex 00s */\n    line = hold.l\n    call vparse line\n    if w.1 = \"PASSWORD\" THEN do\n      password.name = w.3\n    end\n    if w.1 = \"ACCESSORID\" THEN do\n      acidnum = acidnum + 1\n      accessor.acidnum = l\n      name = w.3\n      acids.acidnum = w.3\n      acidlst.name.0 = 0\n      /* say \"acidnum = \" acidnum \"name = \" name */\n    end\n    /* say \"acidlst.\"name\".\"temp */\n    temp = acidlst.name.0 + 1\n    acidlst.name.temp = hold.l\n    acidlst.name.0 = temp\n  end\n  q=dl(\"tsa101d\",,\" Total acids contained in input DSN is \" acidnum)\nend\nelse do\n  call vparse acidlist\n  acidnum = words\n  accessor.0  = 1\n  accessor.1  = 1\n  do t = 1 to acidnum\n    name = acids.t\n    acidlst.name.0    = 0\n    /* each acid receives its own list area.. should be one */\n  end\n  signal on error name badacid\n  do r = 1 to acidnum\n    /***********************************************/\n    /** here we break up the passed args into the **/\n    /** ACIDS. variable so we can step thru them  **/\n    /***********************************************/\n    acids.r = w.r\n    hold = w.r\n    ss = outtrap(acidlst.hold.,5000)\n    q=dl(\"tsa101d\",,\" Listing ACID \"hold\" with data \"data \".\" )\n    ADDRESS TSO \"TSS LIST(\"hold\") DATA(\"DATA\")\"\n  end\nend\n/*************************************************/\n/*************************************************/\n/** below we create  the translated ID stream   **/\n/*************************************************/\n/*************************************************/\nq=dl(\"tsa101d\",,\" Evaluation of TSS generated data begins.\" )\nevaluate: nop  /* a branch to point for a resource convert */\n/*************************************************/\n/*************************************************/\n/** The below routine does the exact same thing **/\n/** for both resource and standard output, since**/\n/** the variable structure created above is the **/\n/** same for either.                            **/\n/*************************************************/\n/*************************************************/\nlinenum = 0\nlinehold= 0\nif debug.flow = \"YES\" then do\n  say \"TSA101D Evaluate routine in control values as follows:\"\n  say \"acidnum:  \" acidnum\n  say \"accessor.0\" accessor.0\n  say \"accessor.1\" accessor.1\nend\nrules = 0\ndo num = 1 to acidnum\n  /************************************************/\n  /**This outer loop is once for each acid passed**/\n  /** to me. Dave 18 June 99                     **/\n  /************************************************/\n  segment = \"BASE\"\n  if functype = \"RESOURCE\" then segment = \"AUTHORITY\"\n  prev_name = name\n  prev_type = \" \"\n                   /***********************************************/\n  name = acids.num /* everything in the below loop uses this name */\n                   /***********************************************/\n  if debug.flow = \"YES\" then do\n    say \"tsa101d: Evaluation of acid # \"num\" begins.\" name\n    holdaq = acidlst.name.0\n    say \"        Rule entries:\" holdaq\n  end\n  if name = \"RDT\" then do\n    SAY  \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    secrc = \"TSA102E: Unique ACID RDT not supported. Function aborted.\"\n    address ispexec \"vput secrc profile\"\n    exit 0\n  end\n  q=dl(\"tsa101d\",,\" Acidlst.\"name\".0 is\" acidlst.name.0)\n  do a1 = 1 to acidlst.name.0\n    concat = \"NO\"\n    /* */\n    /* the below statements just clear the variables... */\n    setf = setval(rules,0flag,hex00)\n/*  acidrul.name.a1.0flag    = hex00\n    acidrul.name.a1.0concat  = \"NO\"\n    acidrul.name.a1.0segment = \" \"\n    acidrul.name.a1.0type = \" \"\n    acidrul.name.a1.0restext = \" \"\n    acidrul.name.a1.0resname = \" \"\n    setf = setval(rules,0restext,\" \")\n    setf = setval(rules,0type,\" \")\n    setf = setval(rules,0segment,\" \")\n    setf = setval(rules,0concat,\"NO\")\n    setf = setval(rules,0resname,\" \") */\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = acidlst.name.a1\n    if word(acidlst.name.a1,1) /= \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,59)\n    if word(acidlst.name.a1,1) = \"INSTDATA\" then\n      line = substr(acidlst.name.a1,1,72)\n    /************************************************************/\n    /* the only field we do not trncate past col 59 is instdata */\n    /************************************************************/\n    line = translate(line,\" \",hex00) /* kill the hex 00s */\n    first11 = substr(line,1,11)\n    if line = blank59 then iterate a1\n    if first11 /= \"           \" then prevline_first11 = first11\n    if first11 = \"           \" then do\n      line = prevline_first11||substr(line,12)\n    end\n    if debug.trans = \"YES\" then do\n      say \"TSA101D: Translation starting for below data:\"\n      say \"         \"line\n    end\n    do skipit = 1 to lineskip.0\n      if word(line,1) = lineskip.skipit then iterate a1\n    end\n    if substr(line,1,2) = \"  \" then do\n      concat = \"YES\"\n    /*acidrul.name.a1.0concat  = \"YES\" */\n      setf = setval(rules,0concat,\"YES\")\n    end\n    first11 = substr(line,1,11)\n    /* below we take 2 words and make one for first 11 */\n    if words(first11) = 2 then\n      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)\n    line = first11||substr(line,12)\n    line = strip(line)\n    line = translate(line,\" \",\"=\") /* replace = with spaces */\n    if word(line,1) = \"XA\" then line = \"XA\"||substr(line,4)\n    if index(line,\"UNTIL(\") <> 0 then do\n      parse var line z1 'UNTIL(' z2 ')' z3\n      line = z1 \"UNTIL\" z2 z3\n    end\n    if index(line,\"TIMES(\") <> 0 then do\n      parse var line z1 'TIMES(' z2 ')' z3\n      line = z1 \"TIMES\" z2 z3\n    end\n    call vparse line               /* fill the w. variables */\n    if w.1 = \"INSTDATA\" then do\n      segment = \"INSTDATA\"\n      q=dl(\"tsa101d\",TRANS,\" Segment changed to \"segment \"for \" name)\n      save_idata = substr(line,14)\n    end\n    if w.1 = \"-----------\" then do\n      segment = w.2||w.3\n      if w.2 = \"SEGMENT\" then segment = w.3\n      q=dl(\"tsa101d\",TRANS,\" Segment changed to \"segment \"for \" name)\n    end\n    if w.1 = \"LASTUSED\" then segment = \"AUTHORITY\"\n    if w.1 = \"CREATED\" then segment = \"AUTHORITY\"\n    if w.1 = \"LCFFAC\" then do\n      q=dl(\"tsa101d\",trans,\" lcf detected:\" w.2)\n      savefac = w.2\n      iterate a1\n    end\n    if (w.1 = \"EXMPCMDS\") | (w.1 = \"AUTHCMDS\") then do\n      q=dl(\"tsa101d\",trans,\" lcf area input line:\",\n      w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8)\n      w.1 = w.1\".\"savefac\n      q=dl(\"tsa101d\",trans,\" lcf area reformated line:\",\n      w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8)\n    end\n    if w.1 = \"-----------\" then iterate a1\n    skipit = \"NO\"\n    if bypass.0supress.function.0 > 0 then do\n      do supnum = 1 to bypass.0supress.function.0\n        if debug.bypass = \"YES\" then\n          say bypass.0supress.function.supnum \"data:\" w.1\n        if w.1 = bypass.0supress.function.supnum then skipit = \"YES\"\n        if (skipit = \"YES\") & (debug.trans = \"YES\") then\n          say \"Translate skiprule tripped:\" function w.1\n      end\n    end\n    if skipit = \"YES\" then linehold = linehold - 1\n    if linehold < 0 then linehold = 0\n    if skipit = \"YES\" then iterate a1\n    repeat = \"NO\"\n    if concat = \"NO\" then do\n      prev_type = type\n      prev_resource = resource\n      type = strip(w.1)\n      resource = strip(w.2)\n      if (prev_type = type) & (prev_resource = resource) &,\n         (functype /= \"RESOURCE\") then\n        repeat = \"YES\"\n    end\n    duplicat = \" \"\n    if concat = \"YES\" then do\n      tzq1 = strip(line)\n      hold = getval(rules,0restext)\n/*    acidrul.name.rules.0restext = strip(hold) tzq1 */\n      setv = setval(rules,0restext,strip(hold) tzq1)\n      /***************************************************/\n      /* add line to current value string and set concat */\n      /***************************************************/\n      /*  say \"T80ICOMP: Concat rule built\",    */\n      /*  \"n=\"name \"t=\"type \"r=\"resource hold   */\n /*   acidrul.name.rules.0concat  = \"YES\" */\n      setf = setval(rules,0concat,\"YES\")\n /*   say \"Setting concat to yes for record \" rules  */\n /*   hold1 = acidrul.name.rules.0concat */\n      hold = restext(rules)\n      q=dl(\"tsa101d\",trans,\" Concat rule \",\n      \"n=\"name \"t=\"type \"r=\"resource \"h=\" hold)\n    end\n    if concat = \"YES\" then iterate a1\n    rules = rules + 1\n/*  acidrul.name.a1.0concat  = \"NO\"  */\n    setf = setval(rules,0ACID,name)\n    setf = setval(rules,0concat,\"NO\")\n/*  acidrul.name.rules = segment type resource\n    acidrul.name.rules.0segment = segment\n    acidrul.name.rules.0type    = type\n    acidrul.name.rules.0resname = resource */\n    setf = setval(rules,\"RESET\",segment type resource)\n    setf = setval(rules,0segment,segment)\n    setf = setval(rules,0type,type)\n    setf = setval(rules,0resname,resource)\n    if resource = \"SEGMENT\" then iterate a1\n    /*********************************************/\n    /* set to blanks in case we have no 3rd word */\n    /*********************************************/\n/*  acidrul.name.rules.0restext = \" \"  */\n    Setf = setval(rules,0restext,\" \")\n    do t1 = 3 to words\n      hold = getval(rules,0restext)\n/*    acidrul.name.rules.0restext = strip(hold) strip(w.t1)  */\n      setf = setval(rules,0restext,strip(hold) strip(w.t1))\n      if getval(rules,0type) = \"INSTDATA\" then do\n      setf = setval(rules,0restext,save_idata)\n      setf = setval(rules,0resname,\"INSTDATA\")\n      end\n    end\n    q=dl(\"tsa101d\",trans,\" Type/Rname/Text =\" getval(rules,0type) \"/\",\n    getval(rules,0resname)\"/\",\n    getval(rules,0restext) )\n  end\n  /* acidrul.name.0 = rules */\n  linenum = linenum + rules\nend\nq=dl(\"Total lines of translated data is:\" linenum )\nallacid.0 = rules\nq=dl(\"tsa101d\",,\" Translation streams have been built.\",\n  \"Starting function check.\")\n/**********************************************************/\n/**The message below should only be seen if no function   */\n/**routine sets the secrc variable. Normally this would   */\n/**indicate that this routine was called with an invalid  */\n/**function parameter, or we did a translate function.    */\n/**********************************************************/\nsecrc = \"TSA107I: Translation complete, no other routine invoked.\"\n/**********************************************************/\n/**Below are the various functions that will use the data */\n/**********************************************************/\nif (function = \"PERMIT\") | (function = \"REVOKE\"),\n   | (FUNCTION = \"REBUILD\") then do\n  q=dl(\"tsa101d\",,\" Permit/rebuild/revoke area in control.\")\n  call makeacid function\n  if function = \"REBUILD\" then function = \"PERMIT\"\n  do t = 1 to allacid.0\n    q=dl(\"tsa101d\",,\" Starting to process LINE #\" t )\n    call getadata t\n    hold = next\n    record_number = t\n    name = allacid.t.0acid\n    q=dl(\"tsa101d\",,\" acid recnum next\" name record_number hold)\n    call convert function hold\n    trace off\n    secrc = \"Conversion completed.\"\n    address ispexec \"vput secrc profile\"\n  end\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    if makeauth = \"YES\" then do\n      cvtnum = cvtnum - 1\n      address tso \"free ddn(outds2)\"\n      address tso \"alloc ddn(outds2) dsn(\"ds2\") mod reus\"\n    end\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    if makeauth = \"YES\" then\n    secrc = \"TSA523I: Sample authority stream created output is in\" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"MODIFY\" then do\n  if debug.modify = \"YES\" then\n    call snapshot\n  call off error\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\n  Thisrec = 1\n  outnum = linenum\n  panel_code = 0\n  name = acids.1 /* we  only modify one acid */\n  q=dl(\"tsa101d\",,\" MODIFY starting to process ACID:\" name )\n  do until panel_code /= 0\n    call fillscr\n    address ispexec \"display panel(SPIPROF)\"\n    /* thisrec is the rec at the top of the screen */\n    if OPT = \"NEXTM\" then thisrec = thisrec + 14\n    if OPT = \"PREVM\" then thisrec = thisrec - 14\n    panel_code = rc\n    call getopt /* scan the screen for an option */\n    if panel_code = 0 then do t = 1 to 14\n      if f.t  = 'S' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" S found on line\" t )\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        modrule.0panel = \"SPISHOW\"\n        call modrule  /* a read only call with above setting */\n      end\n      if f.t  = 'D' then do\n        q=dl(\"tsa101d\",modify,\" D found on line\" t)\n        f.t = \" \"\n        interpret \"f\"||t \"= ''\"\n        y = t + thisrec - 1\n        segment  = segment(y)\n        type     = type(y)\n        resource = resname(y)\n        restext  = restext(y)\n        record_number = y\n        zqd = setflag(y,\"*DELETE\")   /* mark this record as deleted */\n     /* acidrul.name.y = segment type resource */\n        setf = setval(y,\"RESET\",segment type resource,)\n        hold = segment type resource restext\n        call convert \"REVOKE\" hold\n      end\n      if f.t  = 'M' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" M found on line\" t )\n        interpret \"f\"||t \"= ''\"\n        seccode = \"OK\"\n        if authnum < 8  then call secure\n        y  = t + thisrec - 1\n        q=dl(\"tsa101d\",\"MODIFY\",\" t=\" t \"thisrec=\" thisrec )\n        q=dl(\"tsa101d\",\"MODIFY\",\" Subscript is now:\" y )\n        if seccode = \"OK\" then do\n          segment  = segment(y)\n          type     = type(y)\n          resource = resname(y)\n          restext  = restext(y)\n          record_number = y\n          hold = segment type resource restext\n          SAY  \"TSA101D:\"\n          say \"MODIFY:segment type resource \"\n          say \"      \"hold\n          say \" calling convert for revoke stream\"\n          call convert \"REVOKE\" hold\n          modrule.0panel = \"SPIUPDT\"\n          call modrule\n          /* back from modify  we use new RSNAME  now */\n          /* modrule creates the variable conlist     */\n          say  \"back from modify  rsname is \"rsname\n          say  \"back from modify  modrule.newrs is \" modrule.newrs\n          setf = setflag(y,'*MODIFY')\n          /* */\n          setf = setval(y,0concat,\"YES\")\n        /*acidrul.name.y.0concat = \"YES\"\n          acidrul.name.y = segment type rsname  */\n          setf = setval(y,\"RESET\",segment type rsname,)\n          /*\n          acidrul.name.y.0resname  = rsname\n          */\n          setf = setval(y,0resname,rsname)\n          /*\n          acidrul.name.y.0restext  = modrule.newrs\n          */\n          setf = setval(y,0restext,modrule.newrs)\n          /* */\n          call convert \"PERMIT\" conlist\n          call fillscr\n          /* call snapshot */\n        end\n        if seccode \\= \"OK\" then do\n          q=dl(\"tsa101d\",,\" secure routine failed access \")\n          type.hold1 = \"*secure\"\n        end\n        f.t = \" \"\n      end\n      if f.t  = 'A' then do\n        q=dl(\"tsa101d\",\"MODIFY\",\" A found on line\" t)\n        interpret \"f\"||t \"= ''\"\n        f.t = \" \"\n        f0 = \"\"\n        do temp3 = outnum to t by - 1\n          before = temp3 - 1\n          f.temp3 = f.before\n          interpret \"f\"||temp3 \"= f\"||before\n        end\n        outnum = outnum + 1\n        acidrul.name.0 = outnum\n        fill = thisrec + t - 1\n        target = fill + 1\n/*      say \"T80ICOMP:addition routine entered outnum=\" outnum\n        say \"T80ICOMP:addition routine entered target=\" target\n        say \"T80ICOMP:addition routine entered thisrec=\" thisrec\n        say \"T80ICOMP:addition routine entered fill=\" fill\n        say \"Looping from \"outnum \"to \"target                    */\n        do q = outnum to target by -1\n          q1 = q - 1\n          /* Say \"moving record \"q1 \"to record \" q   */\n          acidrul.name.q = acidrul.name.q1\n          /*** zzzzebra **/\n          acidrul.name.q.0segment = acidrul.name.q1.0segment\n          f = setval(q,0segment,getval(q1,0segment))\n          acidrul.name.q.0flag    = acidrul.name.q1.0flag\n          f = setval(q,0flag,getval(q1,0flag))\n          acidrul.name.q.0type    = acidrul.name.q1.0type\n          f = setval(q,0type,getval(q1,0type))\n          acidrul.name.q.0restext = acidrul.name.q1.0restext\n          f = setval(q,0restext,getval(q1,0restext))\n          acidrul.name.q.0resname = acidrul.name.q1.0resname\n          f = setval(q,0resname,getval(q1,0resname))\n        end\n     /* say \"y is now \" y \"fill is now \" fill     */\n        modrule.0panel = \"SECUPDT\"\n        q=dl(\"tsa101d\",\"MODIFY\",\" Calling modrule\")\n        call modrule\n        acidrul.name.fill.0concat = \"YES\"\n        setit = setval(fill,0concat,\"YES\")\n        setit = setflag(fill,\"*NEWRULE\")\n        setit = setval(fill,0flag,\"*NEWRULE\")\n        acidrul.name.fill.0type     = type\n        setit = setval(fill,0type,type)\n        acidrul.name.fill.0segment  = segment\n        setit = setval(fill,0segment,segment)\n        acidrul.name.fill.0resname  = rsname\n        setit = setval(fill,0resname,rsname)\n        acidrul.name.fill.0restext  = modrule.newrs\n        acidrul.name.fill.0restext  = modrule.newrs\n        record_number = fill\n        call convert \"PERMIT\" conlist\n        f.t = \" \"\n        call fillscr\n      end\n    end\n  end\n  q=dl(\"tsa101d\",,\" leaving modify\")\n  secrc = \"Conversion completed.\"\n  address ispexec \"vput secrc profile\"\n  if screen = \"YES\" then do z1 = 1 to cvtnum\n    say cvtcmd.z1\n  end\n  if screen /= \"YES\" then do\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \"@@\"\n    if MAKEAUTH = \"YES\" then\n      cvtnum = cvtnum - 1\n    \"EXECIO \"create.0\" DISKW outds2 (FINIS STEM create.)\"\n    \"EXECIO \"cvtnum\" DISKW outds2 (FINIS STEM cvtcmd.)\"\n    address tso \"free ddn(outds2)\"\n    secrc = \"TSA109I: Complete. Output stream written to \" ds2\n    address ispexec \"vput secrc profile\"\n  end\n  exit 0\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\nif function = \"TRANSLATE\" then say \"**OUTPUTAREA**\"\n/*\nif function = \"TRANSLATE\" then\n  say \"acidrul.name array || multiline ? || segment || data \"\nif function = \"TRANSLATE\" then do q = 1 to acidnum\n  name = acids.q\n  say \"**NEWACID** \" name\n  do t = 1 to acidrul.name.0\n    bypass = \"no\"\n    type = word(acidrul.name.t,2)\n    do q1 = 1 to bypass.function.0\n      if type = bypass.function.q1 then bypass = \"YES\"\n    end\n    if bypass = \"YES\" then iterate t\n    l1 = acidrul.name.t.0concat\n    call getdata t\n    say t l1 next\n  end\nend\n*/\nif function = \"TRANSLATE\" then do qt = 1 to allacid.0\n    say qt allacid.qt.0ACID,\n         allacid.qt allacid.qt.0restext\nend\n/************************************************/\n/************************************************/\n/************************************************/\n/************************************************/\naddress ispexec \"vput secrc profile\"\nexit 0\n/************/\nmakeacid: procedure expose password. name accessor. acidnum acidlst.,\n  acids. create_num create. screen  newpass debug. makeacid. convert.\nparse arg function\nif function /= \"REBUILD\" then return\nq=dl(\"tsa101d\",\"MAKEACID\",\" Making ACID:\" function )\nown_str   =  \"\"\nowner     =  \"\"\ndept      =  \"\"\nzone      =  \"\"\ndiv       =  \"\"\ndo t = 1 to acidnum\n  count = 1\n  name = acids.t\n  if name = \"ALL\" then return\n  if name = \"STC\" then return\n  done = \"no\"\n  do until done = \"YES\"\n    line = acidlst.name.count\n    call vparse line\n    if w.1 = \"CREATED\" then done = \"YES\"\n    if count > acidlst.name.0 then done = \"YES\"\n    if w.1 = \"TYPE\" then ACID_type = w.3\n    IF W.4 = \"NAME\" THEN acid_NAME = W.6 W.7 W.8 W.9\n    IF W.1 = \"TYPE\" THEN acid_TYPE = W.3\n    if acid_type = \"MASTER\" then return\n    IF acid_TYPE = \"CENTRAL\" THEN acid_TYPE = \"SCA\"\n    /**************************************************/\n    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */\n    /**************************************************/\n    IF W.4 = \"C/A\"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||\"CA\"\n    IF W.3 = \"DIV\"  THEN acid_TYPE = \"VCA\"\n    IF W.3 = \"LIMITED\" THEN acid_TYPE = \"LSCA\"\n    IF (W.1 = \"ZONE\") & (W.2 = \"ACID\")  THEN ZONE = W.4\n    IF (W.1 = \"DEPT\") & (W.2 = \"ACID\")  THEN DEPT = W.4\n    IF (W.1 = \"DIV\") & (W.2 = \"ACID\")  THEN DIV = W.4\n    count = count + 1\n  end\n  user_flag = \"YES\"\n  IF acid_type = \"TYPE\"     THEN USER_FLAG = \"$$\"\n  IF acid_type = \"DIVISION\" THEN USER_FLAG = \"NO\"\n  IF acid_type = \"GROUP\"    THEN USER_FLAG = \"NO\"\n  IF acid_type = \"DIV\"      THEN acid_type= \"VCA\"\n  IF acid_type = \"DEPT\"     THEN USER_FLAG = \"NO\"\n  IF acid_type = \"PROFILE\"  THEN USER_FLAG = \"NO\"\n  IF acid_type = \"ZONE\"     THEN USER_FLAG = \"NO\"\n  if zone \\= \" \" then owner = \"ZONE\"\n  if zone \\= \" \" then area = zone\n  if div  \\= \" \" then owner = \"DIV\"\n  if div  \\= \" \" then area  =  div\n  if dept \\= \" \" then owner = \"DEPT\"\n  if dept \\= \" \" then area  =  dept\n  if ( owner \\= \"\" ) & ( area \\= \"\" ) then do\n    own_str =  owner\"(\"area\")\"\n    q=dl(\"tsa101d\",\"MAKEACID\", \"makacid resolved to:\" own_str )\n  end\n  create_num = create_num + 1\n  if password.name /= \"NO_PASSWORD_FOUND\" then do\n    newpass = password.name\n  end\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  CREATE.CREATE_NUM = \" TSS CRE(\"ANAME\") NAME('\"ACID_NAME\"') +\"\n  if makeacid.0auth = \"YES\" then create_num = create_num -1\n  IF USER_FLAG = \"YES\" THEN\n    T2 = own_str\" TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"\n  ELSE\n    T2=  own_str\" TYPE(\"acid_TYPE\")\"\n  /*                                                      */\n  /*IF OWNER = \"OWNER\" THEN                               */\n  /*  T2 = \"   TYPE(\"acid_TYPE\") PASSWORD(\"NEWPASS\")\"     */\n  /*                                                      */\n  q=dl(\"tsa101d\",\"MAKEACID\",\" Makeacid type for \"name\" is :\" acid_type)\n  IF acid_TYPE = \"DIVISION\" THEN T2 = \" TYPE(\"acid_TYPE\")\" own_str\n  IF acid_TYPE = \"ZONE\" THEN T2 = \"   TYPE(\"acid_TYPE\")\"\n  IF USER_FLAG = \"$$\" THEN DO\n    SAY \"*********************************************************\"\n    say \"TSA104E: Makeacid routine aborting due to lack of user type\"\n    SAY \"TSA104E:   acid = \"name\n    SAY \"*********************************************************\"\n    RETURN\n  END\n  DIV = \"\"\n  TYPE = \"\"\n  DEPT = \"\"\n  ZONE = \"\"\n  CREATE_NUM = CREATE_NUM + 1\n  CREATE.CREATE_NUM = \"  \"T2\n  CREATE_NUM = CREATE_NUM + 1\n  if makeacid.0custom = \"YES\" then do\n    thecmd = makeacid.0custom.command\n    parse var thecmd q1 '$$' q2\n    aname = name\n    if convert.0newid = \"YES\" then aname = convert.0name\n    create.create_num = q1||aname||q2\n    create_num = create_num + 1\n  end\n  CREATE.CREATE_NUM = \"  \"\n  CREATE.0 = CREATE_NUM\nend\n/* say \"leaving makeacid dept = \" dept  */\nq=dl(\"tsa101d\",,\n\"makeacid\",\"leaving ma # out = \"create_num create.1 create.2)\nif screen = \"YES\" then do t1 = 1 to create_num\n  say create.t1\nend\nreturn\n/************/\nconvert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,\n  instcon,\n  acidrul. cvtnum concat lcffac debug. convert. record_number allacid.\nparse arg function segment inline\nq=dl(\"tsa101d\",,\" convert called with \" function segment inline)\nname = getval(record_number,0acid)\noname = name\nq=dl(\"tsa101d\",,\" Output ACID name: \" oname)\nconcat = getval(record_number,0concat)\nif debug.newgdata = \"YES\" then concat = allacid.record_number.0concat\nif oname = \"*ALL*\" then oname = \"ALL\"\nif convert.0newid = \"YES\" then oname = convert.0name\nq=dl(\"tsa101d\",,\" Outname for con is \" oname \"concat is\" concat  )\nq=dl(\"tsa101d\",,\" Confor \"name\":\"function segment \">\"||inline||\"<\" )\ncmd_set = \"ADD REM\"\ninword1 = word(inline,1)\nif words(inline) = 1 then return\nparse var inline gone fulline\nif segment = \"ADMINISTRATIONAUTHORITIES\" THEN do\n  cmd_set = \"ADMIN DEADMIN\"\n  xa = \"YES\"\n  concat = \"YES\"\n  if index(inline,\"*ALL*\") <> 0 then do\n    parse var inline hold0 '*ALL*' hold1\n    inline = hold0||\"ALL\"||hold1\n  end\nend\ncmd = word(cmd_set,1)\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\n/*************************************************/\n/** the reformatter area                        **/\n/** for converting stuff that is unique and cant**/\n/** be handled by the lower 'standard' area     **/\n/** Word parsing has not occured yet so we can  **/\n/** actually change the input line if we want   **/\n/*************************************************/\nif (inword1 = \"BYPASSING\") | (inword1 = \"ATTRIBUTES\"),\n  then do\n  hold = translate(substr(inline,11),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\")\" hold\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return /* we have converted the line so lets leave */\nend\nif (inword1 = \"LCFFAC\") then do\n  lcffac = word(inline,2)\n  if debug.convert = \"YES\" then\n    say \"  Reformatter area completed convert. returning.\"\n  return  /* we have converted the line so lets leave */\nend\nif (inword1 = \"XAVOLUME\") then do\n  /*********************************************************/\n  /* a volume generic of (d,g) or (t,g) is invalid so we   */\n  /* handle it here.                                       */\n  /*********************************************************/\n  where_gen = index(inline,\",G)\")\n  if where_gen /= 0 then do\n    q=dl(\"tsa101d\",convert,\" Vol generic, Input dsn line \"inline )\n     parse var inline hz1  ',' hz2\n    inline = hz1||hz2\n    q=dl(\"tsa101d\",convert,\" Reformatted vol generic line \"inline)\n  end\n  where_gen = index(inline,\"(D)\")\n  if where_gen /= 0 then do\n    q=dl(\"tsa101d\",convert,\" Disk ref, Input dsn line \"inline )\n     parse var inline hz1  '(D)' hz2\n    inline = strip(hz1,t)||'(D)' hz2\n    q=dl(\"tsa101d\",convert,\" Reformatted Disk line \"inline)\n  end\nend\nif (inword1 = \"XADATASET\") then do\n  /*********************************************************/\n  /* dataset is not a valid tss resource so we make it DSN */\n  /* and let it fall through to the standard area, we do   */\n  /* NOT return. We just make the resource valid and let   */\n  /* the lower routine handle the rest.. DIR 14 april 2000 */\n  /*********************************************************/\n  q=dl(\"tsa101d\",convert,\" Input dsn line \"inline )\n  inline = \"XADSN\"||substr(inline,10)\n  q=dl(\"tsa101d\",convert,\" Reformatted dsn line \"inline)\nend\nif (substr(inword1,1,9) = \"AUTHCMDS.\"),\n   | (substr(inword1,1,9) = \"EXMPCMDS.\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  lcmd = word(inline,2)\n  lcffac = substr(inword1,10)\n  hold = \"(\"lcmd\n  scmd = \"XCMD\"\n  if (substr(inword1,1,9) = \"AUTHCMDS.\") then scmd = \"CMD\"\n  Do wcnt = 3 to words(inline)\n    lcmd = word(inline,wcnt)\n    hold = hold\",\"lcmd\n  end\n  hold = hold\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") \"SCMD\"(\"lcffac\",\"hold\")\"\n  q=dl(\"tsa101d\",convert,\" Reformat area completed convert. returning.\")\n  return\nend\nif (inword1 = \"INSTDATA\") then do\n  /*********************************************************/\n  /* This command syntax is so weird I am just going to    */\n  /* the entire thing here.                                */\n  /*                                                       */\n  /*                                     DIR 11 may 2007   */\n  /*********************************************************/\n  hold = translate(substr(inline,19),\" \",\",\")\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") -\"\n  cvtnum = cvtnum + 1\n  if instcon = \"NO\" then hold = \"000000\"\n  cvtcmd.cvtnum = \" INSTDATA('\"hold\"')\"\n  q=dl(\"tsa101d\",convert,\" Reformat area done convert. returning.\")\n  return\nend\nif (inword1 = \"UID\") then do\n  /*********************************************************/\n  /* Leading zeroes cause a syntax error so this routine   */\n  /* is just to remove them.                               */\n  /*                                                       */\n  /*                                     DIR 14 april 2000 */\n  /*********************************************************/\n  theuid = word(inline,2)\n  theuid = theuid + 0  /* strip the leading zeroes */\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = \" TSS \"cmd\"(\"oname\") UID(\"theuid\")\"\n  if (uidcon = \"NO\") & (theuid / = 0 )  then\n    cvtcmd.cvtnum = \" %giveuid \" oname defgroup\n  q=dl(\"tsa101d\",convert,\" Reformat area done convert. returning.\")\n  return\nend\n/*************************************************/\n/** end of the reformatter area                 **/\n/*************************************************/\ncall vparse inline\n/*************************************************/\n/** the preprocessing area                      **/\n/*************************************************/\nIF (FUNCTION = \"REVOKE\") & (WORDPOS(\"UNTIL\",INLINE) /= 0 ) THEN DO\n  WTGT = WORDPOS(\"UNTIL\",INLINE)\n  do moveto = wtgt to words  /* shift everything left two words */\n    movefrom = moveto + 2\n    w.moveto = w.movefrom\n  end\n  words = words - 2\nend\n/*************************************************/\n/** Below we change words to valid command      **/\n/** parameters                                  **/\n/*************************************************/\nIf w.1 = \"VOLUMES\" then w.1 = \"VOLUME\"\nIF SEGMENT = \"ADMINISTRATIONAUTHORITIES\"  THEN do\n  If w.1 = \"FACILITIES\" then w.1 = \"FACILITY\"\n  If w.1 = \"LISTDATA\" then w.1 = \"DATA\"\n  IF W.1 = \"SCOPEACID\" THEN W.1 = \"SCOPE\"\nend\nif w.1 = \"MASTERFAC\" then w.1 = \"MASTFAC\"\nIF W.1 = \"PROFILE\" THEN CONCAT = \"YES\"\nIF W.1 = \"FACILITY\" THEN CONCAT = \"YES\"\n  /*************************************************/\n  /** above to support profile expiration        **/\n  /*************************************************/\nif w.1 = \"LOCKTIME\" then do\n  words = 2                 /* drop the junk */\n  if w.5 /= \"*ALL*\" then w.2 = (w.2\",\"w.5)\n  w.1 = \"LTI\"\nend\nholdz = w.1\nif convert.0fulline.holdz = \"YES\"  then do\n  /*************************************************/\n  /** If we have a fulline resource text field   **/\n  /** this is the place we handle it.            **/\n  /*************************************************/\n  reshold = convert.0resource.holdz\n  cvtnum = cvtnum + 1\n  aname = name\n  if convert.0newid = \"YES\" then aname = convert.0name\n  cvtcmd.cvtnum = \" TSS \"CMD\"(\"aname\")\" reshold\"('\"fulline\"')\"\n  return\nend\nif w.1 = \"SITRAN\" then do\n  words = 2                 /* drop the junk */\n  if w.4 /= \"*ALL*\" then w.2 = (w.2\",\"w.4)\n  w.1 = \"SIT\"\nend\nif name = \"STC\" then do\n  if w.1 /= \"STC\" then return\n  if w.2 = \"*DEF*\" then w.2 = \"DEFAULT\"\n  HOLD  = \" TSS \"CMD\"(STC) PROCNAME(\"W.2\")                           \"\n  hold = substr(hold,1,35)\n  HOLD  = hold \"ACID(\"W.4\")\"\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum = hold\n  return\nend\n/*************************************************/\n/** end of the preprocessing area               **/\n/*************************************************/\ntype = w.1\nresource = w.2\ntchk = w.2\nif type = \"XADSN\" then tchk = \"XADATASET\"\n/* the record number variable below is the record requested from */\n/* the getdata routine or you can manually set it prior to a     */\n/* convert call                                                  */\nif getval(record_number,0concat) = \"YES\" then concat = \"YES\"\nxa = \"NO\"\nif substr(type,1,2) = \"XA\" then do\n  xa = \"YES\"\n  cmd_set = \"PER REV\"\n  /* concat = \"YES\" */\n  hold = getval(record_number,0concat)\n  if hold = \"YES\" then concat = \"YES\"\n  if debug.convert = \"YES\" then say \"tsa101d XA\",\n   \"type =\"type \"res=\"resource \"name=\"name,\n   \"concat = \" concat\n  type = substr(type,3)\n  w.1 = type\nend\nif function = \"REVOKE\" then cmd = word(cmd_set,2)\nif function = \"PERMIT\" then cmd = word(cmd_set,1)\nq=dl(\"tsa101d\",convert,\" Resource is \"resource \"concat is\" concat )\nrulehold = 0\ndo q1 = 1 to bypass.function.0\n  hold1 = word(bypass.function.q1,1)\n  hold = word(bypass.function.q1,2)\n  type_check = type\n  if xa = \"YES\" then type_check = \"XA\"type\n  if (hold1 = \"*\") | (hold1 = segment) then seg_match = \"YES\"\n  if type_CHECK = hold then type_match = \"YES\"\n  if (type_match = \"YES\") & (seg_match = \"YES\" ) then bypass = \"YES\"\n  if (bypass = \"YES\") & (rulehold = 0 ) then rulehold = q1\n  seg_match  = \"NO\"\n  type_match = \"NO\"\nend\n/*                                                */\nq=dl(\"tsa101d\",\"CONVERT\",\"Checking bypass rule for:\")\nq=dl(\"tsa101d\",\"CONVERT\",bypass.function.rulehold)\nif bypass = \"YES\" then do\n  q=dl(\"tsa101d\",\"CONVERT\",\" bypass rule tripped, Rule is below:\")\n  q=dl(\"tsa101d\",\"CONVERT\",bypass.function.rulehold)\n  return\nend\n/*******************************************************/\n/* Now we create two command streams for the input the */\n/* multi value (which is a command with multiple parms)*/\n/* and the stack value( which is multiple commands     */\n/* stacked together in one variable to be broken apart */\n/* later). Most of the time all you should have to do  */\n/* is select which of the command types is valid to    */\n/* the input resource. If this is not the case you have*/\n/* to put code in the pre or post formatting area.     */\n/*                                                     */\n/* If you suspect these areas are incorrect set the    */\n/* debug.mutlcon variable to \"YES\" at the very         */\n/* beginning of the exec and use the WRITEDEBUG        */\n/* command to see the interim values.                  */\n/*                                 DIR 14 April 2000   */\n/*******************************************************/\noutput = \" TSS \"cmd\"(\"oname\")\"\nskeleton = \" TSS \"cmd\"(\"oname\")\"\nhold = \"\"\nmulti = output\n/* the multi value is the tss command with multiple parms */\nstack   = output\ndo c1 = 1 to words by 2\n  next = c1 + 1\n  multi = multi w.c1\"(\"w.next\")\"\nend\ndo c1 = 2 to words\n  hold = hold\"|\"stack w.1\"(\"w.c1\")\"\nend\nstack = hold\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\n/* say \"Stack: =\" stack  */\n/* stack value is mutliple tss commands generated by one line */\n/*                                                   */\n/*if (function = \"PERMIT\") & ( xa /= \"YES\") then do  */\n/*  do c1 = 2 to words                               */\n/*    hold = hold w.c1                               */\n/*  end                                              */\n/*  output = output w.1\"(\"hold\")\"                    */\n/*end                                                */\noutput = multi\nif (function = \"REVOKE\") & (cmd = \"REM\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"REVOKE\") & (cmd = \"REV\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif (function = \"PERMIT\") | (function = \"REBUILD\") then do\n  if concat = \"YES\" then output = multi\n  if concat /= \"YES\" then output = stack\nend\nif debug.multcon = \"YES\" then do\n  say \"  Multi  rule  is =\" multi\n  say \"  Stack  rule  is =\" stack\n  say \"  Concat value is =\" concat\nend\nparse var output tz1  '()' tz2\noutput = tz1 tz2\nif debug.convert = \"YES\" then do\n  say \"tsa101d: ***** CONVERT OUTPUT IS NOW :\"\n  say \"  \" output\nend\nif index(output,\"|\") <> 0 then do\n  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,\n  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,\n  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20\n  do w = 1 to 20\n    if ot.w /= \"\" then do\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  ot.w\n    end\n  end\nend\nif index(output,\"|\") = 0 then do\n  if length(output) > 60 then do\n    parse var output w1 w2 w3 w4\n    cvtnum = cvtnum + 1\n    cvtcmd.cvtnum = \" \"w1 w2 w3 \"-\"\n    output = \"    \"w4\n    if length(output) > 60 then do\n      parse var output w1 w2 w3\n      cvtnum = cvtnum + 1\n      cvtcmd.cvtnum =  \" \"w1 w2 \"-\"\n      output = \"    \"w3\n    end\n  end\n  cvtnum = cvtnum + 1\n  cvtcmd.cvtnum =  output\nend\nreturn\n/*********************/\n/*********************/\n/*********************/\n/*********************/\nseeya: nop\nif sysenv = \"FORE\" then do\n  say  \"T80ICOMP: error in line \"sigl\n  address ispexec \"vput secrc profile\"\n  X = SOURCELINE(SIGL)\n  say x\nend\nexit\n/************/\nvparse: procedure expose words w.\nparse arg invar\nw. = \"\"\nwords = words(invar)\ndo t = 1 to words\n  w.t = word(invar,t)\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nbadacid: nop\nsecrc = \"TSA105E: TSS list command failed for ACID\" acids.r\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR.\"\n  say \"passed acidlist was unlistable, check validity of acid\" acids.r\n  say \"and your TOP SECRET authority.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nbaddsn: nop\nsecrc = \"TSA106E: Unable to retrieve data to support bypass mode\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR. in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadres: nop\nsecrc =,\n \"TSA108E: TSS command failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS whohas \"w.1\"(\"w.2\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\nbadrdt: nop\nsecrc =,\n \"TSA110E: RDT list failed, check resource type, name and authority\"\nif sysenv = \"FORE\" then do\n  address ispexec \"vput secrc profile\"\n  say \"FATAL ERROR in line\" sigl\n  say \"Passed DSN was invalid, check validity of DSN\" ds1\n  say \"and environment variables.\"\n  say \"CMD issued: TSS list(rdt) resclass(\"w.1\")\"\n  say \"TSS RESPONSE was:\"\n  say hold.1 hold.2\n  exit  8\nend\nsay secrc\nexit\n/************************/\n/************************/\n/************************/\n/************************/\nfillscr: procedure expose thisrec outnum type. rsname. access. t,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,\n a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,\n type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,\n access1 access2 access3 access4 access5 access6 access7 access8,\n access9 access10 access11 access12 access13 access14 type14,\n rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,\n rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,\n f. allacid. name hex00 debug. linenum function balout\nOPT = \" \"\nq=dl(\"tsa101d\",fillscr,\" Fillscr invoked. Thisrec=\" thisrec )\nif function = \"BALANCE\" then outnum = balout\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T80ICOMP: TOP OF DATA REACHED\"\nEND\nh1 = linenum - 13\ntempz1 = linenum\n/* save this value for the display below*/\nq=dl(\"tsa101d\",\"FILLSCR\",\" h1=\" h1 \"acidrul.\"name\".0=\" tempz1 )\nif h1 < 1 then h1 = 1\n/*******************************************************/\n/* Thisrec is the record at the top of the screen      */\n/* H1 is the highest record number which should EVER   */\n/* be at the top of the screen                         */\n/*******************************************************/\nIF (THISREC > h1) & (thisrec <> 1)  THEN DO\n  THISREC = OUTNUM - 13\n  MSG = \"T80ICOMP: BOTTOM OF DATA REACHED\"\n  q=dl(\"tsa101d\",FILLSCR,\" Bottom of data thisrec set to :\"thisrec)\nEND\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T80ICOMP: TOP OF DATA REACHED\"\nEND\nif debug.fillscr = \"YES\" then do\n  say \"FILLSCR: thisrec=\" thisrec\n  say \"tsa101d     filling screen:\",\n    \"outnum=\"outnum \"thisrec=\"thisrec \"h1=\"h1\nend\ndo cnt = 1 to 14\n  fill = thisrec + cnt - 1\n  script = fill\n  interpret \"f.\"cnt \"=  f\"||cnt\n  /* dont need segment here for doc                   */\n  maxdata = acidrul.name.0\n  q=dl(\"tsa101d\",fillscr,\"fillscr calling with subscript:\" script)\n  q=dl(\"tsa101d\",fillscr,\"maxdata is:\"imaxdata )\n  segment       = segment(script)\n  type          = type(script)\n  type.fill     = type\n  if substr(type.fill,1,2) = \"XA\" then type.fill = substr(type.fill,3)\n  /*********************************************/\n  /* remove the XA for filling the screen only */\n  /*********************************************/\n  resource.fill = resname(script)\n  resource = resource.fill\n  fchk = getflag(script)\n  if debug.fillscr = \"YES\" then do\n    say \"tsa101d fillscr segment=\"segment\n    say \"   type=\"type \"resource=\"resource \"fchk=\"fchk\n  end\n  if fchk /= hex00 then do\n    type.fill = getflag(fill)\n    if debug.fillscr = \"YES\" then do\n      say \"fillscr: type overlayed type, resource =\" type resource\n      say \"fillscr: NEWTYPE  =\" type.fill\n    end\n  end\n  /* hold = segment type resource respass\n  hold = restext(fill)\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR restext:\" hold\n  parse var hold h1 'ACCESS ' access dropoff  */\n  access.fill = access(fill)\n  interpret \"type\"||cnt \" =  type.fill\"\n  interpret \"rsname\"||cnt \"= resource.fill\"\n  interpret \"access\"||cnt  \"=  access.fill\"\n  l = type.fill resource.fill access.fill\n  if debug.fillscr = \"YES\" then\n     say \"FILLSCR output:\" l\n  /* call convert function hold  */\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nGetopt: procedure expose f.,\n f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT\nOPT = \" \"\ndo t = 1 to 14\n  interpret \"f.\"t \"=  f\"||t\nend\nRETURN\n/************************/\n/************************/\n/************************/\n/************************/\nsecure: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\nsnapshot: procedure expose name acidrul. next allacid.\nq=dl(\"tsa101d\",,\" Dumping allacid array\")\ndo qt = 1 to allacid.0\n    say qt allacid.qt.0ACID,\n         allacid.qt allacid.qt.0restext\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/************************/\nsnaplist: procedure expose  name acidrul. next acidlst.\nq=dl(\"tsa101d\",,\" Dumping acidlst array for \" name )\ndo out = 1 to acidlst.name.0\n  t = acidlst.name.out\n  say t\nend\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndelrule: nop\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\n/****************************************************************/\ngetadata: procedure expose allacid. name next,\n  getdata. debug.\n/****************************************************************/\n/* this routine passes the next translated data line for an acid*/\n/****************************************************************/\narg record_number\nt = record_number\nif debug.getdata = \"YES\" then do\n  say \"tsa101d Getadata invoked with:\" record_number\n  say \"New Getadata results:\"\n  say \"t=\"allacid.t\n  say \"acid=\"allacid.t.0acid\n  say \"segment=\"allacid.t.0segment\n  say \"type=\"allacid.t.0type\n  say \"resname=\"allacid.t.0resname\n  say \"restext=\"allacid.t.0restext\n  say \"*******\"\nend\ndebug.newgdata = \"YES\"\nsegment  = strip(allacid.t.0segment)\ntype     = strip(allacid.t.0type)\nresource = strip(allacid.t.0resname)\ntheres   = strip(allacid.t.0restext)\nif debug.Getdata = \"YES\" then do\n  say \"TSA101D: Getadata base resource:\" allacid.t\n  say \"TSA101D: Getadata resource data:\" theres\nend\nnext = segment type resource theres\nif debug.getdata = \"YES\" then\n  say \"TSA101D: Getdata returning:\" next\ngetdata.0segment  = segment\ngetdata.0type     = type\ngetdata.0resource = resource\nreturn\n/************************/\n/************************/\n/************************/\n/************************/\ndeblank: NOP\narg in\ndeblnk.0out = \"\"\ndo deblnk = 1 to words(in)\n  deblnk.0out = deblnk.0out word(in,deblnk)\nend\nresult = deblnk.0out\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsegment: NOP\narg tempin\nresult = getval(tempin,0segment)\n/* say \"Segment returning\" result */\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\n/*******************************************************/\n/*******************************************************/\n/**Gets the access from a string parens must be gone  **/\n/**prior to invocation.                               **/\n/*******************************************************/\n/*******************************************************/\nACCESS: NOP\narg tempin\ntempt   = restext(tempin)\nparse var tempt h1 'ACCESS ' access dropoff\nresult = access\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\ntype: NOP\narg tempin\nresult = getval(tempin,0type)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nrestext: NOP\narg tempin\nresult = getval(tempin,0restext)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nsetflag: NOP\ntempin  = arg(1)\ntheflag = arg(2)\nsay \"SETFLAG: setting record number \" tempin \" flag to \" theflag\nacidrul.name.tempin.0flag = theflag\nsetv = setval(tempin,0flag,theflag)\nreturn 0\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\ngetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**Gets the allacid array variable specified.         **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nresult = allacid.record.varname\nif substr(result,1,8) = \"ALLACID.\" then result = \"\"\nif debug.getval = \"YES\" then\n  say \"GETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"is\" result\nreturn result\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\n/*******************************************************/\nsetval: NOP\n/*******************************************************/\n/*******************************************************/\n/**sets the allacid array variable to specified value **/\n/*******************************************************/\n/*******************************************************/\nrecord  = arg(1)\nvarname = arg(2)\nnewvalue= arg(3)\nif debug.setval = \"YES\" then\n  say \"SETVAL: SIGL\" sigl\" rec #\" record \" val:\" varname \"to\" newvalue\nallacid.record.varname = newvalue\nif varname = \"RESET\" then\nallacid.record  = newvalue\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ndl: NOP\n/**********************************************************/\n/** This routine checks to see if the debug flag is set  **/\n/** for a certain routine, and if it is issues the given **/\n/** msg to the log. It enables me to not have an if every**/\n/** time I want to write a msg          July 2003        **/\n/**********************************************************/\nmsgid  = arg(1)\nfield  = arg(2)\nthemsg = arg(3)\nupper msgid field\nD.1 = \"FLOW\"\nD.2 = \"MULTCON\"\nD.3 = \"CONVERT\"\nD.4 = \"MAKEACID\"\nD.5 = \"MODIFY\"\nD.6 = \"GETDATA\"\nD.7 = \"FILLSCR\"\nD.8 = \"MODRULE\"\nD.9 = \"RESOURCE\"\nD.10= \"TRANS\"\nd.0 = 10\nif msgid = \"\" then msgid = \"TSA101D\"\nif field = \"\" then field = \"FLOW\"\nfchk = \"BAD\"\ndo ck = 1 to d.0\n  if field = d.ck then fchk = \"OK\"\nend\nif fchk = \"BAD\" then do\n  say \"********************\"\n  say \"********************\"\n  say \"********************\"\n  say \"**debuglog routine invoked with :\" field\n  say \"********************\"\n  say \"********************\"\n  say \"********************\"\nend\nif debug.field = \"YES\" then do\n  outmsg = msgid\"*\"themsg\n  if length(outmsg) > 80 then do\n    outmsg2 = substr(outmsg,81)\n    outmsg = substr(outmsg,1,80)\n    say outmsg\n    say \"       * \"outmsg2\n  end\n  else say outmsg\nend\nreturn 0\n/************************/\n/************************/\n/************************/\n/************************/\ngetflag: NOP\ntempin  = arg(1)\nres    = getval(tempin,0flag)\n/* say \"getflag: \" res */\nreturn res\n/************************/\n/************************/\n/************************/\n/************************/\nresname: NOP\narg tempin\nresult = getval(tempin,0resname)\nreturn result\n/************************/\n/************************/\n/************************/\n/************************/\nmodrule: procedure expose thisrec outnum type. rsname. access. t,\n rsname  library type access facility action until privpgm other,\n f. name acidrul. conlist modrule. rstype debug.,\n fill_override allacid.\n /*************************************************************/\n /*************************************************************/\n /** This routine displays a screen and returns the variable **/\n /** conlist which is preformatted for a call to the convert **/\n /** routine.                                                **/\n /*************************************************************/\n /** output                                                  **/\n /** modrule.newrs        the new resource value             **/\n /**        rsname        the new resource name              **/\n /**        conlist       preformatted convert input         **/\n /*************************************************************/\nOPT = \" \"\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Initial: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nfill = thisrec + t - 1\nif debug.modrule = \"YES\" then\n  say \"MODRULE: Resolved: t=\"t \"thisrec=\"thisrec \"Fill=\"fill\nif fill_override /= 0 then do\n  fill = fill_override\n  fill_override = 0\n  if debug.modrule = \"YES\" then\n  say \"MODRULE: fill_overide found is :\" fill_override \"ACID=\" name\n  /*******************************************************************/\n  /* this fill_override variable allows the balance routine to       */\n  /* bypass normal processing and pass me the subscript.             */\n  /*******************************************************************/\nend\ninterpret \"f.\"t \"=  f\"||t\n/* dont need segment here for doc                   */\nsegment = segment(fill)\ntype    = type(fill)\nresource= resname(fill)\nrsname  = resname(fill)\nmodrule.newrs = \"\"\nhold = restext(fill)\ndo modcnt = 1 to modrule.0parse.0\n  target = modrule.0parse.modcnt\n  interpret target \" =  ''\"\n  if index(hold,target) <> 0 then do\n    parse var hold h1 (target) gotit dropoff\n    hold = h1 dropoff\n    say \"modrule:parse hit #\"modcnt\" setting \" target \"to\" gotit\n    say \"modrule:remaining line\" hold\n    interpret   target \" =  gotit\"\n    /* modrule.newrs = modrule.newrs target gotit    */\n    /* say \"modrule: new resource is \" modrule.newrs   */\n  end\nend\nother = hold\nother = Deblank(other)\nl = rsname library type access facility action until privpgm other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:prepanel\" l\naddress ispexec \"vput (action access library until type rsname) profile\"\naddress ispexec \"vput (facility privpgm ) profile\"\naddress ispexec \"addpop poploc(data2)\"\n/* address ispexec \"setmsg msg(tssm000) msgloc(popmsg)\" */\naddress ispexec \"display panel(\"modrule.0panel\")\"\naddress ispexec \"rempop\"\nconlist = segment type rsname\nif access   /= \" \" then conlist = conlist \"ACCESS \" access\nif facility /= \" \" then conlist = conlist \"FAC \" facility\nif action   /= \" \" then conlist = conlist \"ACTION \"action\nif until    /= \" \" then conlist = conlist \"UNTIL \"until\nif privpgm  /= \" \" then conlist = conlist \"PRIVPGM \"privpgm\nif other    /= \" \" then conlist = conlist other\nif debug.modrule = \"YES\" then\n  say \"MODRULE:postpanel\" conlist\ndo p = 4 to words(conlist)\n  modrule.newrs = modrule.newrs word(conlist,p)\nend\nif debug.modrule = \"YES\" then\n  say \"Modrule: final conlist\" conlist\n/* call convert function hold  */\nRETURN\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n/******************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80JCARD": {"ttr": 12547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x04\\x00\\x04\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x18\\x00<\\x00<\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.04", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:18:04", "lines": 60, "newlines": 60, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** INSERTS A JOBNAME AND MAYBE A USER= CARD INTO A      **/\n/** SAMPLE JCL DECK WHICH ALREADY IS SYNTACTICALLY VALID **/\n/**********************************************************/\n/** EXEC NAME        : T80JCARD                          **/\n/** LAST MODIFIED    : 15 MAY 95                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** DSN     : THE DSNAME OF THE OUTPUT JCL STREAM        **/\n/** JPARM   : \"SUPER\" OR BLANKS                          **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS6     : THE DSNAME IF THE SAMPLE JOB               **/\n/** DISP    : THE OUTPUT FILE ALLOCATION DISPOSITION     **/\n/** MSCA    : THE ID TO INCLUDE IN A USER= CARD IF NEEDED**/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - NONE                         **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (NEEDS VGETS)               **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/.A                **/\n/**                                                      **/\n/**********************************************************/\nARG DSN JPARM\nADDRESS ISPEXEC\n\"ISPEXEC VGET DS6 PROFILE\"\n\"ISPEXEC VGET MSCA PROFILE\"\nSAY \"TSA101D: T80JCARD: IS IN CONTROL WITH PARMS : \" DSN JPARM\nADDRESS TSO \"ALLOC DDN(JCFILE) DSN(\"DS6\") SHR REUS\"\nJNAME= JPARM\nIF JPARM = '' THEN JNAME = \"TSSJOB\"\nTIME = TIME(NORMAL)\nT12 = SUBSTR(TIME,1,2)\nT45 = SUBSTR(TIME,4,2)\nIF JPARM = \"RANDOM\" THEN\n  JNAME= \"TSSJ\"T12||T45\nADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DSN\") SHR REUS\"\nADDRESS MVS \"EXECIO * DISKR JCFILE (FINIS STEM LINE.)\"\nJOBCARD_INSERT = 99\nDO Q = 8 TO 1 BY -1 /* LETS FIND WHERE THE JOBCARD ENDS */\n  INLINE = LINE.Q\n  IF SUBSTR(INLINE,1,3) = \"//*\" THEN JOBCARD_INSERT = Q - 1\n  IF SUBSTR(INLINE,1,2) = \"/*\" THEN JOBCARD_INSERT = Q - 1\n  IF INDEX(INLINE,\"EXEC\") > 0  THEN JOBCARD_INSERT = Q - 1\nEND\nSAY \"TSA101D: T80JCARD JOBCARD ENDS PRIOR TO LINE\" JOBCARD_INSERT\nIF JPARM = \"SUPER\" THEN DO\n  JNAME= \"TSSJ\"T12||T45\n  LINE.JOBCARD_INSERT= \"// \"WORD(LINE.JOBCARD_INSERT,2)||\",USER=\"MSCA\n  SAY \"TSA101D: JCARD ADDITION : \" LINE.JOBCARD_INSERT\nEND\nLEN1= LENGTH(LINE.1)\nHOLD = SUBSTR(LINE.1,11)\nLINE.1= \"//\"JNAME HOLD\nADDRESS MVS \"EXECIO * DISKW OUTFILE (FINIS STEM LINE.)\"\nADDRESS TSO \" FREE DDN(JCFILE)  \"\nADDRESS TSO \" FREE DDN(OUTFILE) \"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80LISTP": {"ttr": 12549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x06\\x01\\x01\\x19?\\x01\\x07\\x13\\x0f\\x10\\x18\\x00Q\\x00Q\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-07-12T00:00:00", "modifydate": "2007-05-10T10:18:06", "lines": 81, "newlines": 81, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T80LISTP                          **/\n/** LAST MODIFIED    : 11 JUL 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE VALID TSS DEFINED ID                   **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  ACID IF NOT PASSED AS AN ARG.                       **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         MSG2                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T80FDIV T80GETPW     **/\n/**                                                      **/\n/**********************************************************/\nARG ACID\nIF ACID = \" \" THEN ADDRESS ISPEXEC \"VGET ACID  PROFILE\"\nSAY \"T80LISTP: HAS CONTROL\"\nSAY \"T80LISTP: CALLING T80FDIV\"\nSYSSCMD = SYSVAR(SYSSCMD)\nSYSPCMD = SYSVAR(SYSPCMD)\nSYSICMD = SYSVAR(SYSICMD)\nSYSNEST = SYSVAR(SYSNEST)\nSYSRACF = SYSVAR(SYSRACF)\nSAY \"I=\"SYSICMD \"P=\" SYSPCMD \"S=\" SYSSCMD \"RACF= \" SYSRACF\nADDRESS TSO \"%T80FDIV \"ACID\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\nSAY \"T80LISTP: BACK FROM  T80FDIV WITH SECRC OF\" SECRC\nIF SECRC = \"LIST FUNCTION FAILED.\" THEN DO\n  ADDRESS TSO \"%T80GETPW \" ACID\n  ADDRESS ISPEXEC \" VGET SECRC PROFILE \"\n  IF SECRC \u00ac= \"$ERROR\" THEN\n    SECRC = \"THAT IDS PASSWORD = \" SECRC\n  ELSE\n    SECRC = \"FAILED. THAT ID DOES NOT EXIST IN UADS OR TOP SECRET\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC = \"AUTHORIZATION FAILED.\" THEN DO\n  SECRC = \"FAILED. YOUR TOP SECRET AUTHORIZATION IS INADEQUATE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC \u00ac= \"CUSTDIV\" THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"THAT ID IS NOT DEFINED AS AN EXTERNAL CUSTOMER. \"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    IF SUBSTR(ACID            ,8,1) = \"@\" THEN DO\n      MSG2 = \"THAT IS A GHOST ENTRY, TRY LISTING THE ID WITHOUT THE @\"\n      ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\n    END\n    EXIT 00\n    END\n  ELSE DO\n    MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY LISTABLE\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nADDRESS TSO \"%T80GDAT \"ACID\" ATTRIBUTES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF INDEX(SECRC,\"SUSPEND\") \u00ac=  0 THEN DO\n  MSG2 =  \"THIS ID IS SUSPENDED, YOU MUST UNSUSPEND TO USE\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nADDRESS TSO \"T80GDAT \"ACID\" PASSWORD PW\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF ( SECRC = \"$NOTFOUND\" ) | ( SECRC = \"$BADTSS\" )  THEN DO\n  MSG2 = \"THE IDS PASSWORD IS NOT RETRIEVABLE. CONTACT TECH SUPPORT\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nELSE\n  SECRC = \"THE IDS PASSWORD  = \"SECRC\nTHEEND: NOP\nADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80LSTO": {"ttr": 12551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x07\\x00\\x08\\x00\\x98(/\\x01\\x07\\x13\\x0f\\x10\\x18\\x000\\x00.\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.07", "flags": 0, "createdate": "1998-10-09T00:00:00", "modifydate": "2007-05-10T10:18:08", "lines": 48, "newlines": 46, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX THE WONDER DOG */\n ARG ACID DATA DS1 DISP\n HEX00 = '00'X\n /* DISP = \"SHR\" */\n SYSENV = SYSVAR(SYSENV)\n SAY HEX00\n SECRC = \"FAILED IN T80LSTO. CHECK ACIDS VALIDITY\"\n secrc = secrc||\" and your current authority\"\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n   ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n END\n IF DISP = \"\" THEN DISP = SHR\n SIGNAL ON ERROR NAME SEEYA\n SS = OUTTRAP('OUTLINE.')\n  /******************************************************************/\n  /* THIS EXEC PRINTS OUTPUT TO A DSN.                              */\n  /* IT IS VERY SIMPLE......DAVE 20 MAY 91                          */\n  /******************************************************************/\nIF DATA  = \"  \" THEN  DATA=\"ALL\"\nIF DATA  = \"ALLPW\" THEN  DATA=\"ALL,PASSWORD\"\nIF DATA  = \"DATAAREA\" THEN DO\n  ADDRESS ISPEXEC \"VGET DATAAREA PROFILE\"\n  DATA = DATAAREA\nEND\n\nSAY \"T80LSTO: ALLOCATING DSN\" DS1\n\"ALLOC DDN(OUTFILE) DSN(\"DS1\") \"DISP\" REUS\"\ntrace off\nSAY \"T80LSTO: CALLING TSS FOR LIST OF ID \" ACID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nDO I = 1 TO OUTLINE.0\n  /****************************/\n  /* REPLACE X'00' WITH X'40' */\n  /****************************/\n  OUTLINE.I=TRANSLATE(OUTLINE.I,\" \",HEX00)\n  IF LENGTH(OUTLINE.I) > 79 THEN  OUTLINE.I = SUBSTR(OUTLINE.I,1,79)\nEND\n\"EXECIO * DISKW OUTFILE ( FINIS STEM OUTLINE.)\"\n\"FREE DDN(OUTFILE)\"\n secrc = \"function completed. output in \" ds1\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/* NOTE THAT NO NORMAL COMPLETION MESSAGE IS ISSUED */\nSEEYA: NOP\n\"FREE DDN(OUTFILE)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80MAINT": {"ttr": 12553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\t\\x01\\x04\\t?\\x01\\x07\\x13\\x0f\\x10\\x18\\x009\\x00:\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2004-04-02T00:00:00", "modifydate": "2007-05-10T10:18:09", "lines": 57, "newlines": 58, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOG                                  **/\n/**********************************************************/\n/** EXEC NAME        : T80maint                          **/\n/** LAST MODIFIED    :  3 31 2004                        **/\n/**********************************************************/\n/** a front end exec for the idat exec that will suspend **/\n/** or unsuspend or whatever and then call the instdata  **/\n/** routine to maintain instdata                         **/\n/**                                                      **/\n/**********************************************************/\n/**********************************************************/\n/**********************************************************/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**                                                      **/\n/**********************************************************/\n/**  COA1DIR UNSUSPEND */\n/**                                                      **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : %T80idat             **/\n/**********************************************************/\nARG ACID Function data\nfunction = strip(function)\nsignal off error\naddress tso\nSelect\n  when function= \"UNSUSPEND\" then do\n    thecmd = \"%T80idat\" acid function\n    \" \"thecmd\n    drc = rc\n    thecmd = \"tss rem(\"acid\") SUSPEND\"\n    \" \"thecmd\n    address ispexec \"vget secrc profile\"\n  end\n  when function= \"SUSPEND\" then do\n    thecmd = \"%T80idat\" acid function\n    \" \"thecmd\n    drc = rc\n    thecmd = \"tss add(\"acid\") SUSPEND\"\n    \" \"thecmd\n    address ispexec \"vget secrc profile\"\n  end\n  when function= \"INSTDATA\" then do\n    new_enum  = substr(newidata                 ,1,10)\n    new_code  = code.function\n  end\n  otherwise secrc = \"Failed. Unknown function\" function\n            address ispexec \"vput secrc profile\"\n            say secrc\nEnd\nsay secrc drc\nexit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80PER": {"ttr": 12555, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x11\\x00\\x990O\\x01\\x07\\x13\\x0f\\x10\\x18\\x00g\\x00g\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-10-31T00:00:00", "modifydate": "2007-05-10T10:18:11", "lines": 103, "newlines": 103, "modlines": 0, "user": "COA1DIR"}, "text": "/*REXX*/\nARG ACID RESTYPE RESNAME ACCESS DAYS\nSIGNAL OFF ERROR\nSECRC = \"T80PER FAILED WITH ERRORS\"\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nRES.0 = 3\nRES.1 = \"DATASET\"\nRES.2 = \"JESSPOOL\"\nRES.2 = \"VOL\"\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE ASTERISK WITH Z */\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = RESTYPE THEN VALID = \"YES\"\nEND\nIF VALID /= \"YES\" THEN DO\n  SAY \"T80PER: RESTYPE NOT SUPPORTED. RESTYPE = \" RESTYPE\n  MSG2 = \"THE FOLLOWING RESTYPE WAS NOT RECOGNIZED\" RESTYPE\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  EXIT 08\nEND\nACTION = \"ACTION(FAIL)\"\nIF DAYS /= \" \" THEN DAYCMD = \"FOR(\"DAYS\")\"\nSLASH = INDEX(\"/\",DAYS)\nIF SLASH > 0 THEN DAYCMD = \"UNTIL(\"DAYS\")\"\nDAY1 = WORD(DAYS,1)\nSIGNAL NOCHECK\nRESCHK = TRANSLATE(RESNAME,\"Z\",\"*\") /* REPLACE DOTS WITH SPACES */\nACCCHK = ACCESS\nQ = OUTTRAP(HOLD.,5)\nIF ACCESS = \"ALL\" THEN ACCCHK = \"ALTER\"\nIF ACCESS = \"REMOVE\" THEN ACCCHK = \"ALTER\"\nSAY \"T80PER: ACTION IS NOW\" ACTION \". DAYS VALUE IS \" DAYS\nSAY \"T80PER: RES IS \" RESNAME\nSAY \"********CHECK IS BELOW **************\"\nSAY \" TSSCHECK(\"RESTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\nX5 = TSSCHECK(RESTYPE,RESCHK,ACCCHK,\"NOMSG\")\nSAY \"********CHECK IS BELOW **************\"\nSAY \"T80PER: TSSCHECK RETURN CODE IS \" X5\nIF X5 \u00ac= \"OK\"  THEN DO\n  SECRC = \"YOU CANNOT GRANT THAT LEVEL OF ACCESS TO THAT RESOURCE.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 04\nEND\nSAY         \"TSS LIST(\"ACID\") DATA(NAME)\"\nNOCHECK: NOP\nADDRESS TSO\nIF ACCESS = \"REVOKE\" THEN DO\n  Q = OUTTRAP(REVOKE.)\n  SAY \"T80PER: REVOKE FUNTION STARTED\"\n  \"TSS REV(\"ACID\") DSN(\"DSNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"REVOKE FUNCTION SUCCESSFULL FOR ID \"ACID\n  ELSE DO\n    SECRC = \"REVOKE RETURNED NON ZERO RCODE OF \" RCODE\n    IF WORD(REVOKE.1,1) = \"TSS0384E\" THEN\n      SECRC = \"FAILED. CHECK THAT DSN IS IN PROFILE EXACTLY AS ENTERED.\"\n    SAY SECRC \"TSS REASON IS :\"\n    SAY \"TSS TEXT REASON IS :\"\n    SAY REVOKE.1\n    SAY REVOKE.2\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\n/********************************/\n/* LETS ACTUALLY DO THE WORK... */\n/********************************/\nQ = OUTTRAP(OUT.,5)\nIF RESTYPE = \"DATASET\" THEN RESTYPE = \"DSN\"\nIF ACCESS = \"REMOVE\" THEN DO\n  \"TSS REV(\"ACID\") \"RESTYPE\"(\"RESNAME\")\"\n  RCODE = RC\n  IF RCODE = 0 THEN\n    SECRC = \"AUTHORITY REMOVED FOR ID \"ACID\".\"\n  ELSE DO\n    SECRC = \"REMOVE RETURNED NON ZERO RCODE OF \"RCODE\n    MSG2 = OUT.1\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nIF DAYS = \" \" THEN\n  \"TSS PER(\"ACID\") \"RESTYPE\"(\"RESNAME\") ACCESS(\"ACCESS\")\" ACTION\nELSE\n  \"TSS PER(\"ACID\") DSN(\"RESNAME\")\",\n  \"ACCESS(\"ACCESS\")\" DAYCMD ACTION\nRCODE = RC\nIF RCODE = 0 THEN\n  secrc = \"TSA521I: permit function successful for id\" acid\nELSE DO\n  secrc = \"TSA522I: permit returned non zero rcode of \"rcode\n  MSG2 = OUT.1\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80PMENU": {"ttr": 12557, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x12\\x00\\x98#/\\x01\\x07\\x13\\x0f\\x10\\x18\\x02\\x96\\x02\\x96\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1998-08-20T00:00:00", "modifydate": "2007-05-10T10:18:12", "lines": 662, "newlines": 662, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added  security checking for datsets                 **/\n/**********************************************************/\n/** added  privpgm support 11 nov 97                     **/\n/**********************************************************/\n/** added  support for the STC record by creating        **/\n/** the DELTRUNC. variable to be referenced in deletes   **/\n/**********************************************************/\n/** added  support for the user TSO area. dir 1 oct 97   **/\n/**********************************************************/\n/** Fixed truncation of last data line and added sitran  **/\n/** support.     dave 29 aug 97                          **/\n/**********************************************************/\n/** NOW SUPPORTS LCF CMDS     DIR 28 AUG 97              **/\n/**********************************************************/\n/** MODIFY PROFILES IN A PANEL BASED ENVIRONMENT         **/\n/** LOTS  OF SAYS   TO FACILITATE DEBUGGING...           **/\n/**********************************************************/\n/** EXEC NAME        : T80PMENU                          **/\n/** LAST MODIFIED    : 25 MAR 97                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    :  THE PROFILE TO MANIPULATE                 **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** DISP    : THE DISP OF THE BATCH FILE                 **/\n/** DS3     : THE BATCH FILE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**********************************************************/\n/** ARRAY VARIABLES                           EXAMPLE    **/\n/**------------------------------------------------------**/\n/** CMD  = THE VALID COMMANDS FOR THIS ENTRY   \"ADD REM\" **/\n/** TYPE = THE RESOURCE TYPE                   \"DATASET\" **/\n/** RSNAME= THE RESOURCE NAME                  \"SYS1.  \" **/\n/** ACCESS=THE ACCESS LEVEL                    \"UPDATE \" **/\n/** ACTION=THE ACTION TO TAKE                  \"FAIL   \" **/\n/** UNTIL= THE EXPIRATION DATE OF RULE  \"UNTIL(03/30/97)\"**/\n/** LIBRARY = THE RUNTIME LIBRARY       \"SYS1.LINKLIB   \"**/\n/** FACILITY= THE AUTHD FAC FOR ACCESS  \"TSO,BATCH      \"**/\n/** OTHER   = ANYTHING ELSE             \"DAYS(MON.TUE)  \"**/\n/** DELTRUNC= Number of words to retain of the resource \"**/\n/**           name when doing a delete function.         **/\n/**------------------------------------------------------**/\n/** OUTNUM=THE # OF INPUT RESOURCE LINES                 **/\n/** OUT_COUNT = THE # OF OUTPUT CHANGES                  **/\n/** BATFILE.  = THE ACTUAL CHANGES TO BE WRITTEN TO DS3  **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nCALL OFF ERROR\nHEX00 = '00'X\nDISP = \"SHR\"\nSYSENV = SYSVAR(SYSENV)\nSECRC = \"FAILED IN T80PMENU. CHECK ACIDS VALIDITY\"\nSECRC = SECRC||\" AND YOUR CURRENT AUTHORITY\"\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ADDRESS ISPEXEC \"VGET DISP PROFILE\"\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET DS3 PROFILE\"\n  ZPF07 = \"PREVM\"\n  ZPF19 = \"PREVM\"\n  ZPF08 = \"NEXTM\"\n  ZPF20 = \"NEXTM\"\n  \"ISPEXEC VPUT ZPF07  PROFILE\"\n  \"ISPEXEC VPUT ZPF08  PROFILE\"\n  \"ISPEXEC VPUT ZPF19  PROFILE\"\n  \"ISPEXEC VPUT ZPF20  PROFILE\"\nEND\nDELTRUNC. =  0\nF0        =  \" \"\nUNTIL.    =  \" \"\nACCESS.   =  \" \"\nRSNAME.   =  \" \"\nOTHER.    =  \" \"\nLIBRARY.  =  \" \"\nFACILITY. =  \" \"\nPGM.      =  \" \"\nCOMMAND_FALLTHRU = \"ADD REM\"\nCMD.      =  \"PER REV\"\nACTION.   =  \" \"\nIF DISP = \"\" THEN DISP = SHR\nSIGNAL ON ERROR NAME BYEBYE\nDATA=\"ALL,EXPIRE\"\nIF MODE = \"ONLINE\" THEN DO\n  SAY \"T80PMENU: ALLOCATING DSN\" DS3\n  ADDRESS TSO \"%T80JCARD\" DS3\n  \"ALLOC DDN(BJCL) DSN(\"DS3\") MOD REUS\"\nEND\nSAY \"T80PMENU: CALLING TSS FOR LIST OF ID \" ACID\nSS = OUTTRAP('INLINE.')\nSIGNAL ON ERROR NAME BADID\n\"TSS LIST(\"ACID\") DATA(\"DATA\")\"\nRCODE = RC\nSIGNAL ON ERROR NAME BYEBYE\nTHISREC = 3\nOUT_COUNT = 0\nOUTNUM = 0\nSAY \"T80PMENU: HAS A TOTAL RECORD COUNT OF \" inline.0\nDO I = 1 TO INLINE.0\n  LINE = INLINE.I\n  LINE = TRANSLATE(LINE,\" \",\"=\") /* REPLACE = WITH SPACES */\n  /***********************************************************/\n  /** Kill those = signs.. very important to know for the   **/\n  /** lower loop...    Dave 29 Aug 97                       **/\n  /***********************************************************/\n  NEXT = I + 1\n  NEXTLINE = INLINE.NEXT\n  /****************************/\n  /* SAVE THE LAST LINE HEADER*/\n  /****************************/\n  FIRST13 = SUBSTR(LINE,1,13)\n  IF FIRST13 \\= \"             \" THEN SAVE13 = FIRST13\n  IF SUBSTR(LINE,1,2) = \"XA\" THEN DO  /* KILL THE OWNER STATEMENT */\n    LINE = SUBSTR(LINE,1,59)\n  END\n  Q = NEXT\n  /***********************************************************/\n  /** Reformatter area                                      **/\n  /** The lower loop operates on the principal that each    **/\n  /** line contains enough data to recreate any command     **/\n  /** pertaining to the resources mentioned there.          **/\n  /** I created this area for LCF commands, where lines do  **/\n  /** not mention the facilites that they are affecting     **/\n  /** nor do they mention the type of resource they are     **/\n  /** securing. So I 'proprogate' the first 13 chars of     **/\n  /** the line that does have this data to the lower        **/\n  /** lines.      DAVE 29 AUG 97                            **/\n  /***********************************************************/\n  IF (SAVE13 = \" AUTH CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"AUTH CMDS  \"||LINE\n  IF (SAVE13 = \" EXMP CMDS  \") & (FIRST13 = \"             \") THEN\n    LINE = \"EXMP CMDS  \"||LINE\n  IF SAVE13 = \" AUTH CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  IF SAVE13 = \" EXMP CMDS  \" THEN SAY \"REFORMATTED LINE:\"LINE\n  /****************************/\n  /** END OF REFORMATTER AREA**/\n  /****************************/\n  PARSE VAR LINE W.1 W.2 W.3 W.4 W.5 W.6 W.7,\n  W.8 W.9 W.10 W.11 W.12\n  IF FIRST13 = \"LCF FAC     \" THEN LCFFAC = W.3\n  IF W.1 = \"XA\" THEN DO\n    OUTNUM = OUTNUM + 1\n    CMD.OUTNUM = \"PER REV\"\n    IF W.2 = \"DATASET\" THEN W.2 = \"DSN\" /* FIX FOR ADD/PER WITH DSNS*/\n    TYPE.OUTNUM = W.2\n    RSNAME.OUTNUM = W.3\n    UNTIL.OUTNUM = W.4\n    ITERATE I\n  END\n  IF W.1 = \"ACCESS\" THEN DO\n    ACCESS.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"LIBRARY\" THEN DO\n    LIBRARY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FAC\" THEN DO\n    FACILITY.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"DAYS\" THEN DO\n    OTHER.OUTNUM = \"DAYS(\"W.2\")\"  W.3 W.4 W.5 W.6 W.7 W.8 W.9\n    OTHER.OUTNUM = STRIP(OTHER.OUTNUM)\n    ITERATE I\n  END\n  IF W.1 = \"BYPASSING\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n  IF W.1 = \"STC\" THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"PROCNAME(\"W.2\") acid(\"w.4\")\"\n    DELTRUNC.OUTNUM = 1 /* TO DEL THIS RULE ONLY USE WORD # 1 */\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$BYPASS\"\n    ITERATE I\n  END\n/*************************************************/\n/* SITRAN     = M3CL      FACILITY   = FINTST1   */\n/* TSS ADD(CONSPROF) SIT(M3CL,FINTST1)           */\n/*************************************************/\n  IF W.1 = \"SITRAN\"   THEN DO\n    OUTNUM = OUTNUM + 1\n    RSNAME.OUTNUM = \"SIT(\"W.2\",\"W.4\")\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$SITRAN\"\n    ITERATE I\n  END\n  IF (W.1 = \"AUTH\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"CMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF (W.1 = \"EXMP\") & (W.2 = \"CMDS\")  THEN DO\n    OUTNUM = OUTNUM + 1\n    TEMPLIST = W.3\n    IF W.4 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.4\n    IF W.5 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.5\n    IF W.6 \\= \" \" THEN TEMPLIST = TEMPLIST\",\"W.6\n    RSNAME.OUTNUM = \"XCMD(\"LCFFAC\",(\"TEMPLIST\"))\"\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$LCFCMD\"\n    ITERATE I\n  END\n  IF W.1 = \"ATTRIBUTES\" THEN DO\n    RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    TYPE.OUTNUM = \"$$ATTRIB\"\n    ITERATE I\n  END\n  IF W.1 = \"PRIVPGM\" THEN DO\n    PGM.OUTNUM = W.2 W.3 W.4 W.5 W.6\n    ITERATE I\n  END\n  IF W.1 = \"ACTION\" THEN DO\n    ACTION.OUTNUM = W.2\n    ITERATE I\n  END\n  IF W.1 = \"FACILITY\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = \"FACILITY\" ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  END\n  /*************************************************/\n  /* below is the processing for the tso area      */\n  /* note that it checks handles all tso prefixed  */\n  /* words............  dir 1 oct 97               */\n  /*************************************************/\n  IF SUBSTR(W.1,1,3) = \"TSO\" THEN DO\n    OUTNUM = OUTNUM + 1\n    TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n    CMD.OUTNUM = \"ADD REM\"\n    ITERATE I\n  /*************************************************/\n  /* Below is the area for words to ignore         */\n  /*************************************************/\n  END\n  IF W.3 = \"NAME\" THEN iterate i\n  IF W.1 = \"DEPT\" THEN ITERATE I\n  IF W.1 = \"ZONE\" THEN ITERATE I\n  IF W.1 = \"DIV\" THEN ITERATE I\n  IF W.1 = \"TYPE\" THEN ITERATE I\n  IF W.1 = \"CREATED\" THEN ITERATE I\n  IF W.1 = \"TSS0300I\" THEN ITERATE I\n  IF W.1 = \"LAST\" THEN ITERATE I\n  IF W.1 = \"ACID\" THEN ITERATE I\n  /*************************************************/\n  /* Below is the area to change fallthru defaults */\n  /*************************************************/\n  IF W.1 = \"LIST\" & W.2 = \"DATA\"  THEN do\n    w.1 = \"DATA\";w.2 = w.3;w.3 = \" \"\n  end\n  IF INDEX(W.2,\"*ALL*\") THEN DO\n    PARSE VAR W.2  TZ1 '*ALL*' TZ2\n    W.2 = TZ1||\"ALL\"TZ2\n  END\n  IF W.2 = \"ADMINISTRATION\" & W.3 = \"AUTHORITIES\"  THEN\n    COMMAND_FALLTHRU = \"ADMIN DEADMIN\"\n  /*************************************************/\n  /* below is the fall thru area                   */\n  /* I take my best guess at the command           */\n  /*      ............  dir 29 jan 99              */\n  /*************************************************/\n  OUTNUM = OUTNUM + 1\n  TYPE.OUTNUM = W.1 ; RSNAME.OUTNUM = W.2\n  CMD.OUTNUM =  command_fallthru\n  ITERATE I\nEND\n/*******************************************************/\n/*******************************************************/\n/** End of loop now we create the output lines DIR    **/\n/*******************************************************/\n/*******************************************************/\nOUTNUM = OUTNUM + 1\nIF OUTNUM < 15 THEN DO A = OUTNUM TO 15\n  CMD.A      = \"PER REV\"\n  TYPE.A        = \" \"\n  RSNAME.A      = \" \"\n  ACCESS.A      = \" \"\n  OUTNUM = 15\nEND\nCALL FILLSCR\nSCANSCR: NOP\nDO T = 1 TO 14\n  IF F.T  = 'S' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    CALL SHOWRULE\n  END\n  IF F.T  = 'D' THEN DO\n    F.T = \" \"\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN  CALL DELRULE\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T80PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'M' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    SECCODE = \"OK\"\n    IF AUTHNUM < 8  THEN CALL SECURE\n    HOLD1  = T + THISREC - 1\n    IF SECCODE = \"OK\" THEN DO\n      CALL DELRULE\n      SAY \"T80PMENU: TYPE AFTER RULE PROCESSING IS \" TYPE.T\n      FLAG = \"*MODIFY\"\n      CALL MODRULE\n    END\n    IF SECCODE \\= \"OK\" THEN do\n      SAY \"T80PMENU: SECURE ROUTINE FAILED ACCESS \"\n      TYPE.HOLD1 = \"*SECURE\"\n    END\n    F.T = \" \"\n  END\n  IF F.T  = 'A' THEN DO\n    INTERPRET \"F\"||T \"= ''\"\n    F.T = \" \"\n    F0 = \"\"\n    DO TEMP3 = OUTNUM TO T BY - 1\n      BEFORE = TEMP3 - 1\n      F.TEMP3 = F.BEFORE\n      INTERPRET \"F\"||TEMP3 \"= F\"||BEFORE\n    END\n    OUTNUM = OUTNUM + 1\n    FILL = THISREC + T - 1\n    TARGET = FILL + 1\n    SAY \"T80PMENU: RECNUM IS  \" FILL\n    SAY \"T80PMENU: ACCESS IS  \"ACCESS.FILL\n    SAY \"T80PMENU: TYPE IS    \"TYPE.FILL\n    SAY \"T80PMENU: RSNAME IS  \"RSNAME.FILL\n    DO Q = OUTNUM TO TARGET BY -1\n      Q1 = Q - 1\n      FACILITY.Q = FACILITY.Q1\n      ACTION.Q   = ACTION.Q1\n      PGM.Q      = PGM.Q1\n      LIBRARY.Q  = LIBRARY.Q1\n      ACCESS.Q   = ACCESS.Q1\n      TYPE.Q     = TYPE.Q1\n      UNTIL.Q    = UNTIL.Q1\n      RSNAME.Q   = RSNAME.Q1\n    END\n    FLAG = \"*NEWRULE\"\n    CALL MODRULE\n    F.T = \" \"\n  END\nEND\nCALL FILLSCR\nADDRESS ISPEXEC \"DISPLAY PANEL(\"SECPROF\")\"\nCALL FILLSCR\nIF RC > 0 THEN SIGNAL BYEBYE\n/* IF OPT = \"NEXTM\" THEN THISREC = THISREC + 14         */\n/*IF OPT = \"PREVM\" THEN THISREC = THISREC - 14           */\nsay \"option is \"opt\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"F\") THEN OPT = \" \"\nIF (WORDS(OPT) = 1) &  (WORD(OPT,1) = \"FIND\") THEN OPT = \" \"\nIF WORDS(OPT) = 1 THEN SIGNAL NOLOOP\nIF (WORD(OPT,1) = \"FIND\") | (WORD(OPT,1) = \"F\") then do\n  HOLD2 = WORD(OPT,2)\n  TGTNUM = OUTNUM - 14\n  HIT = \"NO\"\n  DO TF1 = THISREC TO OUTNUM\n    IF INDEX(TYPE.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(RSNAME.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF INDEX(ACCESS.TF1,HOLD2) > 0 THEN HIT = \"YES\"\n    IF HIT = \"YES\" THEN THISREC = TF1\n    IF HIT = \"YES\" THEN LEAVE\n  END\n  IF THISREC > TGTNUM THEN THISREC = TGTNUM\nEND\nnoloop: nop\nIF WORD(OPT,1) = \"PREVM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC - 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = THISREC - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = 1\nend\nIF WORD(OPT,1) = \"NEXTM\" THEN DO\n  IF WORDS(OPT) = 1 THEN THISREC = THISREC + 14\n  HOLD2 = WORD(OPT,2)\n  IF DATATYPE(HOLD2) = \"NUM\" THEN THISREC = OUTNUM - HOLD2\n  IF HOLD2  = \"M\" THEN THISREC = OUTNUM - 14\nEND\nIF OPT = \"QUIT\" THEN SIGNAL BYEBYE\nOPT = \" \"\nSIGNAL SCANSCR\nSAY \"T80PMENU : OUTNUM = \" OUTNUM\nBYEBYE: NOP\n/*DO X = 1 TO OUTNUM                                                */\n/*  BATFILE.X =  X CMD.X TYPE.X RSNAME.X UNTIL.X ACCESS.X LIBRARY.X,*/\n/*  ACTION.X                                                        */\n/*END                                                               */\n\"EXECIO \"OUT_COUNT\" DISKW BJCL ( FINIS STEM BATFILE.)\"\n SECRC = \"FUNCTION COMPLETED. OUTPUT IN \" DS3\n IF MODE = \"BATCH\" THEN\n   SECRC = \"FUNCTION COMPLETED. OUTPUT APPENDED TO BATCH FILE.\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nBADID: NOP\n SECRC = \"ID LIST FAILED, CHECK YOUR AUTHORITIES AND IDS EXISTANCE\"\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n/********************************************************************/\n/********************************************************************/\n/********************************************************************/\nSEEYA: NOP\n\"FREE DDN(BATFILE)\"\nEXIT 0\n/******************************************************************/\n/**  THE SHOWRULE SECTION                                        **/\n/******************************************************************/\nSHOWRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. OTHER.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nSAY \"T80PMENU: TEMP IS \" TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nRSNAME   = RSNAME.TEMP\nSAY \"T80PMENU: INSIDE SHOWRULE ROUTINE\"\nSAY \"T80PMENU: ACTION IS   \"  ACTION\nSAY \"T80PMENU: FACILITY IS \"  FACILITY\nSAY \"T80PMENU: PGM IS      \"  PGM\nSAY \"T80PMENU: ACCESS IS   \"  ACCESS\nSAY \"T80PMENU: LIBRARY IS  \"  LIBRARY\nSAY \"T80PMENU: UNTIL IS    \"  UNTIL\nSAY \"T80PMENU: TYPE IS     \"  TYPE\nSAY \"T80PMENU: RSNAME IS   \"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECSHOW)\"\nADDRESS ISPEXEC \"REMPOP\"\nRETURN\n/*******************************************************/\n/**              THE SECURITY CHECK                   **/\n/*******************************************************/\nSECURE: PROCEDURE EXPOSE TYPE. RSNAME. ACCESS. T,\n       ACTION. THISREC CMD. FLAG,\n       ACID OTHER. SECCODE\n/**********************/\n/* VARIABLE INIT AREA */\n/**********************/\nCALL OFF ERROR\nVALID = \"NO\"\nTEMP   = T + THISREC - 1\nOUT_RNAME = RSNAME.TEMP\nACCESS   = ACCESS.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T80PMENU(SECURE): MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nRES.0 = 2\nRES.1 = \"DSN\"\nRES.2 = \"JESSPOOL\"\n/**********************/\n/* VARIABLE CHECK AREA*/\n/**********************/\nDO Q = 1 TO RES.0\n  IF RES.Q = TYPE THEN VALID = \"***DISABLED***\"\nEND\nIF TYPE = \"*SECURE\" THEN SECCODE = 16\nSAY \"MODRULE VALID IS\" VALID\nIF VALID = \"YES\" THEN DO\n  RESCHK = TRANSLATE(RSNAME,\"Z\",\"*\") /* REPLACE * WITH zzzzzz */\n  ACCCHK = \"ALTER\"\n  IF TYPE = \"DSN\" THEN TYPE = \"DATASET\"\n  RSTYPE = STRIP(TYPE)\n  /* Q = OUTTRAP(HOLD.,5)  */\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \" TSSCHECK(\"RSTYPE\",\"RESCHK\",\"ACCCHK\",NOMSG)\"\n  SECCODE = TSSCHECK(RSTYPE,RESCHK,ACCCHK,\"NOMSG\")\n  SAY \"********CHECK IS BELOW **************\"\n  SAY \"T80PMENU(MODRULE): TSSCHECK RETURN CODE IS \" SECCODE\nEND\nRETURN\n/*******************************************************/\n/******************************************************************/\n/**  THE MODRULE SECTION                                         **/\n/******************************************************************/\n/*******************************************************/\nMODRULE: PROCEDURE EXPOSE TYPE. RSNAME. UNTIL. ACCESS. LIBRARY. T,\n       ACTION. FACILITY. THISREC PGM. CMD. BATFILE. OUT_COUNT FLAG,\n       ACID OTHER. SECCODE\nCALL OFF ERROR\nOUT_COUNT = OUT_COUNT + 1\nSAY \"T80PMENU: RECNUM IS \" FILL\nTEMP   = T + THISREC - 1\nSAY \"T80PMENU: RECNUM IS \" TEMP\nOUT_CMD = WORD(CMD.TEMP,1)\nOUT_RNAME = RSNAME.TEMP\nACTION   = ACTION.TEMP\nFACILITY = FACILITY.TEMP\nPGM      = PGM.TEMP\nACCESS   = ACCESS.TEMP\nOTHER    = OTHER.TEMP\nLIBRARY  = LIBRARY.TEMP\nUNTIL    = UNTIL.TEMP\nTYPE     = TYPE.TEMP\nSAY \"T80PMENU: MODRULE TYPE WAS :\" TYPE\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = FLAG TYPE\nSAY \"T80PMENU: MODRULE TYPE WAS :\" TYPE\nRSNAME   = RSNAME.TEMP\nSAY \"T80PMENU: INSIDE MODRULE  ROUTINE\"\nSAY \"T80PMENU: ACTION IS\"  ACTION\nSAY \"T80PMENU: FACILITY IS \"  FACILITY\nSAY \"T80PMENU: PGM IS\"  PGM\nSAY \"T80PMENU: ACCESS IS\"  ACCESS\nSAY \"T80PMENU: LIBRARY IS\"  LIBRARY\nSAY \"T80PMENU: UNTIL IS\"  UNTIL\nSAY \"T80PMENU: TYPE IS\"  TYPE\nSAY \"T80PMENU: RSNAME IS\"  RSNAME\nADDRESS ISPEXEC \"VPUT (ACTION ACCESS LIBRARY UNTIL TYPE RSNAME) PROFILE\"\nADDRESS ISPEXEC \"VPUT (FACILITY PGM) PROFILE\"\nADDRESS ISPEXEC \"ADDPOP POPLOC(DATA2)\"\n/* ADDRESS ISPEXEC \"SETMSG MSG(TSSM000) MSGLOC(POPMSG)\" */\nADDRESS ISPEXEC \"DISPLAY PANEL(SECUPDT)\"\nRCODE = RC\nADDRESS ISPEXEC \"REMPOP\"\nIF RCODE > 0 THEN DO\n  OUT_COUNT = OUT_COUNT - 1  /* KILL THE DELETE ENTRY */\n  TYPE.TEMP = TYPE           /* RESET THE TYPE FIELD */\n  MSG = \" MODIFY ABORTED DUE TO PANEL RETURN CODE.\"\n  RETURN\nEND\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"RSNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  H = H||TYPE||\"(\"RSNAME\") + \"\nEND\nBATFILE.OUT_COUNT = H\nH =  ''\nOUT_COUNT = OUT_COUNT + 1\nIF LENGTH(UNTIL) = 8 THEN UNTIL = \"UNTIL(\"UNTIL\")\"\nIF ACCESS <> '' THEN H = H||\"ACCESS(\"ACCESS\") \"\nIF LIBRARY <> '' THEN DO\n  H = H||\"LIBRARY(\"LIBRARY\") + \"\n  BATFILE.OUT_COUNT = \"  \"||H\n  H =  ''\n  OUT_COUNT = OUT_COUNT + 1\nEND\nIF PGM <> '' THEN H = H||\"PRIVPGM(\"PGM\") \"\nIF UNTIL  <> '' THEN H = H||\" \"UNTIL\nIF ACTION <> '' THEN H = H||\" ACTION(\"ACTION\") \"\nIF FACILITY <> '' THEN H = H||\" FAC(\"FACILITY\") \"\nIF OTHER <> '' THEN H = H OTHER\nBATFILE.OUT_COUNT = \"  \"||H\nPGM.TEMP      = PGM\nACCESS.TEMP   = ACCESS\nLIBRARY.TEMP  = LIBRARY\nACTION.TEMP   = ACTION\nFACILITY.TEMP = FACILITY\nUNTIL.TEMP    = UNTIL\nRSNAME.TEMP    = RSNAME\nRETURN\n/******************************************************************/\n/** THE DELETE RULE SECTION                                      **/\n/******************************************************************/\nDELRULE: PROCEDURE EXPOSE TYPE. RSNAME. T ACID,\n        THISREC UPDATE. CMD. BATFILE. OUT_COUNT DELTRUNC.\nCALL OFF ERROR\nTEMP   = T + THISREC - 1\nOUT_COUNT = OUT_COUNT + 1\nTYPE= TYPE.TEMP\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nIF SUBSTR(STRIP(TYPE),1,1) = \"*\" THEN\n  TYPE     = WORD(TYPE.TEMP,2) WORD(TYPE.TEMP,3)\nTYPE.TEMP = \"*DELETE\" TYPE.TEMP\nOUT_ACID = ACID\nOUT_CMD = WORD(CMD.TEMP,2)\nOUT_RNAME = RSNAME.TEMP\nOUT_TRUNC = DELTRUNC.TEMP\n/******************************/\n/** truncate the rsname maybe**/\n/******************************/\nIF OUT_TRUNC = 1 THEN OUT_RNAME = WORD(OUT_RNAME,1)\nIF OUT_TRUNC = 2 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2)\nIF OUT_TRUNC = 3 THEN\n  OUT_RNAME = WORD(OUT_RNAME,1) WORD(OUT_RNAME,2) WORD(OUT_RNAME,3)\nIF SUBSTR(TYPE,1,1) = \"*\" THEN TYPE = WORD(TYPE,2) WORD(TYPE,3)\nIF INDEX(TYPE,\"$$\") THEN\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"OUT_RNAME\nELSE DO\n  H = \"TSS \"OUT_CMD||\"(\"ACID\") \"\n  /*                         */\n  H = H||TYPE||\"(\"OUT_RNAME\")\"\nEND\nBATFILE.OUT_COUNT = H\n/* SAY OUT_COUNT */\n/* SAY H*/\nRETURN\nFILLSCR: PROCEDURE EXPOSE THISREC OUTNUM TYPE. RSNAME. ACCESS. T,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 TYPE1 TYPE2 TYPE3,\n TYPE4 TYPE5 TYPE6 TYPE7 TYPE8 TYPE9 TYPE10 TYPE11 TYPE12 TYPE13,\n ACCESS1 ACCESS2 ACCESS3 ACCESS4 ACCESS5 ACCESS6 ACCESS7 ACCESS8,\n ACCESS9 ACCESS10 ACCESS11 ACCESS12 ACCESS13 ACCESS14 TYPE14,\n RSNAME1 RSNAME2 RSNAME3 RSNAME4 RSNAME5 RSNAME6 RSNAME7 RSNAME8,\n RSNAME9 RSNAME10 RSNAME11 RSNAME12 RSNAME13 RSNAME14,\n F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F.\nOPT = \" \"\nIF THISREC < 1 THEN DO\n   THISREC = 1\n   MSG = \"T80PMENU: TOP OF DATA REACHED\"\nEND\nIF (THISREC > OUTNUM - 14)  THEN DO\n  THISREC = OUTNUM - 14\n  MSG = \"T80PMENU: BOTTOM OF DATA REACHED\"\nEND\nDO T = 1 TO 14\n  FILL = THISREC + T - 1\n  INTERPRET \"F.\"T \"=  F\"||T\n  IF WORDS(TYPE.FILL) > 2 THEN DO\n    SAY \"T80PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n    TYPE.FILL = WORD(TYPE.FILL,1) WORD(TYPE.FILL,3)\n    SAY \"T80PMENU: SCREEN ROUTINE TYPE IS \" TYPE.FILL\n  END\n  INTERPRET \"TYPE\"||T \" =  TYPE.FILL\"\n  INTERPRET \"RSNAME\"||T \"= RSNAME.FILL\"\n  INTERPRET \"ACCESS\"||T  \"=  ACCESS.FILL\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80PWHO": {"ttr": 12802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x05\\x00\\x14\\x00\\x97 /\\x01\\x07\\x13\\x0f\\x10\\x18\\x00\\x8d\\x00\\x8d\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.05", "flags": 0, "createdate": "1997-07-21T00:00:00", "modifydate": "2007-05-10T10:18:14", "lines": 141, "newlines": 141, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** added an exit with rc=8 for a bad tss id.             */\n/**********************************************************/\n/** Changed to use T80gdat for type processing            */\n/** should be faster for departments and divisions than   */\n/** the older routine.  Dave                              */\n/**********************************************************/\n/** Changed to support all listopt parm which allows      */\n/** all IDs to be listed including departments profiles   */\n/** and security administrators.           Dave           */\n/**********************************************************/\n/**********************************************************/\n/** NO SAYS CAUSE  THIS PGM IS EXPECTED TO WRITE OUTPUT  **/\n/** DATA DIRECTLY TO THE SCREEN.   DAVE                  **/\n/**********************************************************/\n/** EXEC NAME        : T80PWHO                           **/\n/** LAST MODIFIED    : 15 July 97                        **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** PROF    : THE TARGET ID OF THE LIST.                 **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :  N/A                 **/\n/**                                                      **/\n/**********************************************************/\nARG PROF LISTALL\nENV = SYSVAR(SYSENV)\nsecrc = \"List function failed. ACID may be invalid.\"\nIF ENV = \"FORE\" THEN DO\n  ADDRESS TSO \"%T80GDAT \"PROF\" TYPE\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  TYPE = SECRC\n  IF TYPE = \"$BADTSS\" THEN EXIT 08\n  secrc = \"List function failed. ACID may be invalid.\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  IF TYPE = \"MASTER\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"PROFILE\" THEN NORMFLAG = \"YES\"\n  IF TYPE = \"DIVISION\" THEN DIVFLAG = \"YES\"\n  IF TYPE = \"DEPT\" THEN DEPTfLAG = \"YES\"\n  IF TYPE = \"ZONE\" THEN ZONEFLAG = \"YES\"\nEND\nIF ENV /= \"FORE\" THEN DO\n  SPACES = \"                                \"\n  Q = OUTTRAP(\"TYPE.\")\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(BASIC)\"\n  DO T = 1 TO TYPE.0\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DIVISION\") THEN\n      DIVFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"DEPT\") THEN\n      DEPTFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"MASTER\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"PROFILE\") THEN\n      NORMFLAG = \"YES\"\n    IF (WORD(TYPE.T,1) = \"TYPE\") & (WORD(TYPE.T,3)= \"ZONE\") THEN\n      ZONEFLAG = \"YES\"  /* FOR LATER ENHANCEMENTS */\n  END\nEND\nIF NORMFLAG = \"YES\" THEN DO\n   ACID.1   = PROF\n   CALL PRINTDPT /* A DEPT OR PROFILE WAS GIVEN. NO PROBLEM. */\n   EXIT 00\nEND\nIF ZONEFLAG = \"YES\" THEN DO     /* ZONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) ZONE(\"PROF\") TYPE(USER)\"\nEND\nIF DEPTFLAG = \"YES\" THEN DO     /* DEPT PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DEPT(\"PROF\") TYPE(USER)\"\nEND\nIF DIVFLAG = \"YES\" THEN DO     /* DIVISIONAL PROCESSING HERE */\n  Q = OUTTRAP(\"OFF\")\n  IF LISTALL = \"YES\" THEN,\n    ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") \"\n  ELSE ADDRESS TSO \"TSS LIST(ACIDS) DATA(NAME) DIV(\"PROF\") TYPE(USER)\"\nEND\n/*                       */\nSECRC = \"FUNCTION COMPLETED NORMALLY.\"\nIF ENV = \"FORE\" THEN\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\nPRINTDPT: PROCEDURE EXPOSE ACID. LISTALL\nDO IDNUM = 1 TO 4\n  Q = OUTTRAP(\"TYPE.\")\n  IF ACID.IDNUM = \"  \" THEN RETURN\n  IF ACID.IDNUM = \"ACID.\"IDNUM THEN RETURN\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(BASIC)\"\n  IF LISTALL = \"YES\" THEN SAY ACID.IDNUM\n  Q = OUTTRAP(\"OFF.\",0)\n  NORMAL = \"NO\"\n  DO T = 1 TO TYPE.0\n    W1 = WORD(TYPE.T,1)\n    W3 = WORD(TYPE.T,3)\n    IF W1 = \"TYPE\" THEN DO\n      IF W3 = \"DEPT\" THEN NORMAL = \"YES\"\n      IF W3 = \"MASTER\" THEN NORMAL = \"YES\"\n      IF W3 = \"PROFILE\" THEN NORMAL = \"YES\"\n      IF NORMAL = \"NO\" THEN DO\n        SAY ACID.IDNUM /* AN UNUSUAL USER */\n        ITERATE IDNUM\n      END\n    END\n  END\n  /********************************************************/\n  /* SINCE WE ARE HERE THIS ACID MUST BE A DEPARTMENT!    */\n  /********************************************************/\n  Q = OUTTRAP(\"OUT.\")\n  ADDRESS TSO \"TSS LIST(\"ACID.IDNUM\") DATA(ACIDS)\"\n  Q = OUTTRAP(\"OFF.\",0)\n  GOFLAG = \"NO\"\n  DO T = 1 TO OUT.0\n    IF WORD(OUT.T,1) = \"ACIDS\" THEN GOFLAG = \"YES\"\n    IF WORD(OUT.T,1) = \"TSS0300I\" THEN LEAVE\n    IF WORD(OUT.T,1) = \"TSS300I\" THEN LEAVE\n    IF GOFLAG = \"YES\" THEN DO\n      /*SAY \"OUT.T IS  \"OUT.T */\n      PRT.1 = SUBSTR(OUT.T,14,8)\n      PRT.2 = SUBSTR(OUT.T,26,8)\n      PRT.3 = SUBSTR(OUT.T,38,8)\n      PRT.4 = SUBSTR(OUT.T,50,8)\n      DO X = 1 TO 4\n        IF PRT.X = \"*NONE*\" THEN PRT.X = \"  \"\n        IF PRT.X \u00ac= \"  \" THEN SAY PRT.X\n        PRT.X = \"  \"\n      END\n    END\n  END\n  ADDRESS TSO \"TSS LIST(\"PROF\") DATA(ACIDS)\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80RENA": {"ttr": 12804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x16\\x01\\x00\\x16\\x7f\\x01\\x07\\x13\\x0f\\x10\\x18\\x00Q\\x00Q\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2007-05-10T10:18:16", "lines": 81, "newlines": 81, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX */\n/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** THIS IS AN IMS ONLY EXEC DON NOT USE ON CSS LPAR     **/\n/**********************************************************/\n/** EXEC NAME        : T80RENA                           **/\n/** LAST MODIFIED    : 15 DEC 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID                                   **/\n/** NEW_ACID: WHAT YOU WANT IT RENAMED TO                **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  NONE                                                **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : XXXXXXX XXXXXXX      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID NEW_ACID\nSAY \"T80RENA: IN CONTROL WITH PARMS :\" ACID NEW_ACID\nADDRESS TSO\nNEW_LENGTH = LENGTH(NEW_ACID)\nIF NEW_LENGTH = 2 THEN DO\n  SAY \"T80RENA: TARGET ACID IS BEING RESOLVED DUE TO LENGTH\"\n  NEW_ACID = NEW_ACID||SUBSTR(ACID,3)\n  SAY \"T80RENA: TARGET ACID IS RESOLVED TO : \" NEW_ACID\nEND\nCALL OFF ERROR\nADDRESS ISPEXEC \"VGET ZSYSID \"; SYSID = ZSYSID\nSAY \"T80RENA: SYSID IS :\" SYSID\nif sysid = \"CSS1\" then secrc = \"rename function is invalid on CSS LPAR.\"\nif sysid = \"CSS1\" then signal seeya\nSECRC = \"THE RENAME FUNCTION HAS COMPLETED.\"\nRCODE = 0\nNEWD1  =  SUBSTR(DATA,1,2)\nNEWDPT =    NEWD1\"DEPT\"\n/*******************************************************/\n/** HERE IS THE IMS CHANGE SECTION.                   **/\n/** SYSA SYSB AND SYSC                                **/\n/*******************************************************/\n  SAY \"T80RENA: WE ARE ENTERING IMS RENAME LOGIC \"\n  \"%IMSALIAS\"  NEW_ACID\n  IF RC = 4 THEN SECRC = \"FUNCTION COMPLETE. TSO AUTHS MAY NEED TO BE\",\n   \"CHECKED.\"\n  RCODE = 0\n  \"TSS RENAME( \"ACID\") ACID(\"NEW_ACID\")\"\n  \"%TSSAUDU \" NEW_ACID\n  \"%TSSAUDR \" ACID\n  IF SYSDSN(\"'SYS1.TSOUSERS(\"NEW_ACID\")'\") /= \"OK\" THEN\n    \"%RXREPRO SYS1.TSOUSERS(\"ACID\") SYS1.TSOUSERS(\"NEW_ACID\")\"\n  \"%UADRENA \"ACID  NEW_ACID\n  /* \"%REPLACE SYS1.TSOUSERS(\"NEW_ACID\")\" ACID NEW_ACID*/\n  \"TSS REP(\"NEW_ACID\") TSOCOMMAND('PROFILE PREFIX(\"NEW_ACID\")')\"\n  \"TSS LIST( \"NEWDPT\") DATA(NAME)\"\n  IF RC = 0 THEN ADDRESS TSO \"TSS MOVE(\"NEW_ACID\") DEPT(\"NEWDPT\")\"\n  Q = OUTTRAP('LINE.')\n  \"LISTC LEVEL(\"ACID\")\"\n  Q = OUTTRAP('NULL.') /* LETS NOT SCREW UP OUR DATA NOW !  */\n  SAY \"I AM RENAMING \"LINE.0 \"DATASETS.\"\n  DO X = 1 TO LINE.0\n    PARSE VAR LINE.X W.1 W.2 W.3 W.4\n    IF W.1 = \"NONVSAM\" THEN DO\n      PARSE VAR W.3 HLQ \".\" LOWLQ\n       SAY \"RENAME '\"W.3\"' '\"NEW_ACID\".\"LOWLQ\"'\"\n      \"RENAME '\"W.3\"' '\"NEW_ACID\".\"LOWLQ\"'\"\n       IF RC /= 0 THEN SAY \"RENAME FOR \"W.3 \"FAILED!\"\n    END\n  END\n  \"%IMSDALIA\" ACID\nIF RCODE /= 0 THEN SECRC = \"ERRORS ENCOUNTERED. CHECK ID STATUS\"\n\"%UADRENAM\" ACID  NEW_ACID\nseeya: nop\nSAY \"T80RENA:\" SECRC\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80REPL": {"ttr": 12806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x17\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x18\\x00)\\x00)\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:18:17", "lines": 41, "newlines": 41, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX THE WONDER DOG */\nARG ACID PROFOLD PROFNEW\nSAY ACID PROFOLD PROFNEW\nPROFHOLD = PROFNEW /* SAVE ORIGINAL PARM FOR T80INS */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\".\") /* REPLACE DOTS WITH SPACES */\nPROFNEW = TRANSLATE(PROFNEW,\" \",\"_\") /* REPLACE BARS WITH SPACES */\nSAY \"T80REPL: \" ACID PROFOLD PROFNEW\nADDRESS ISPEXEC\n/********************************************************************/\n/***  THIS EXEC REPLACES ONE PROFILE IN A TOP SECRET ACID WITH    ***/\n/***  ONE OR MORE OTHER PROFILES. IT REQUIRES THAT T80INS         ***/\n/***  BE AVAILABLE TO DO INSERTIONS.....DIR 26 APRIL 93           ***/\n/********************************************************************/\nWORDNUM = WORDS(PROFOLD)\nIF WORDNUM > 1 THEN DO\n  SECRC = \"YOU MUST SPECIFY ONLY 1 PROFILE FOR REPLACEMENT\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nSAY \"T80REPL: CALLING T80FLOC\"\nADDRESS TSO \"%T80FLOC\" ACID PROFOLD\nSAY \"T80REPL: BACK FROM T80FLOC\"\n\" VGET SECRC PROFILE\"\nPLACE = SECRC\nSAY \" PLACE IS \" PLACE\nIF (PLACE = \"ERROR\") | ( PLACE= 0 ) THEN DO\n  SECRC = \"ERROR LOCATING \"PROFOLD \"IN ACID.. REPLACE ABORTED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT\nEND\nADDRESS TSO \"TSS REM(\"ACID\") PROF(\"PROFOLD\")\"\nSIGNAL ON ERROR NAME BADPROF\nSAY \"T80REPL: CALLING T80INS\"\nADDRESS TSO \"%T80INS\" ACID PROFHOLD PLACE\nSECRC = \"PROFILE REPLACE COMPLETED.\"\n  \"VPUT SECRC PROFILE\"\n  EXIT 00\nBADPROF: NOP\nSECRC = PROFOLD \"WAS IN PLACE \"PLACE\", HOWEVER INSERTION OF \",\n  PROFNEW \"FAILED!\"\n  \"VPUT SECRC PROFILE\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80REPPW": {"ttr": 12808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x19\\x01\\x00\\x16\\x7f\\x01\\x07\\x13\\x0f\\x10\\x18\\x00V\\x00S\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2007-05-10T10:18:19", "lines": 86, "newlines": 83, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T80REPPW                          **/\n/** LAST MODIFIED    : 11 JUL 94                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE VALID TSS DEFINED ID                   **/\n/** NEWPW   : A VALID 1 - 8 CHR NEW PASSWORD             **/\n/**                                                      **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**  ACID IF NOT PASSED AS AN ARG.                       **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         MSG2                         **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : T80FDIV TSSPWDR      **/\n/**                                 T80GDAT              **/\n/**********************************************************/\nARG ACID NEWPW\nIF ACID = \" \" THEN ADDRESS ISPEXEC \"VGET ACID  PROFILE\"\nSAY \"T80REPPW: HAS CONTROL\"\nSAY \"T80REPPW: CALLING T80FDIV\"\nADDRESS TSO \"%T80FDIV \"ACID\nADDRESS ISPEXEC \"VGET MODE PROFILE\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nADDRESS ISPEXEC \"VGET UIDTABLE PROFILE\"\nADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\nSAY \"T80REPPW: BACK FROM  T80FDIV WITH SECRC OF\" SECRC\nIF SECRC = \"AUTHORIZATION FAILED.\" THEN DO\n  SECRC = \"FAILED. YOUR TOP SECRET AUTHORIZATION IS INADEQUATE.\"\n  ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n  EXIT 00\nEND\nIF SECRC = \"CUSTDIV\" THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"THAT IS DEFINED AS AN EXTERNAL CUSTOMER. TRY LISTPW\"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    EXIT 00\n    END\n  ELSE DO\n   MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY CHANGEABLE.\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nIF (SECRC = \"CENTRAL\") | (SECRC = \"MASTER\") THEN DO\n  IF AUTHNUM < 10 THEN DO\n    SECRC = \"YOU ARE NOT AUTHORIZED TO CHANGE THAT ID.\"\n    ADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\n    EXIT 00\n    END\n  ELSE DO\n   MSG2 = \"SUPER (AUTH = 10) INVOKED. PASSWORD NOT NORMALLY CHANGEABLE.\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nADDRESS TSO \"%T80GDAT \"ACID\" ATTRIBUTES\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF INDEX(SECRC,\"SUSPEND\") /=  0 THEN DO\n  MSG2 =  \"THIS ID IS SUSPENDED, YOU MUST UNSUSPEND TO USE\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\nEND\nADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(\"NEWPW\",60,EXP)\"\nIF MODE = \"BATCH\" THEN DO\n  BJCL.1 = \" TSS REP(\"ACID\") PASSWORD(\"NEWPW\",60,EXP)\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  SECRC = \"THE BATCH FILE WAS UPDATED WITH COMMAND TO REPLACE PWORD\"\n  SIGNAL THEEND\nEND\nADDRESS TSO \"T80GDAT \"ACID\" PASSWORD PW\"\nADDRESS ISPEXEC \"VGET SECRC PROFILE\"\nIF ( SECRC = \"$NOTFOUND\" ) | ( SECRC = \"$BADTSS\" )  THEN DO\n/*\n  MSG2 = \"THE IDS PASSWORD IS NOT RETRIEVABLE. CONTACT TECH SUPPORT\"\n  ADDRESS ISPEXEC \" VPUT MSG2 PROFILE \"\n  */\n  secrc = \"Reset command issued.\"\nEND\nELSE\n  secrc = \"The ids password is now  = \"secrc\nTHEEND: NOP\nADDRESS ISPEXEC \" VPUT SECRC PROFILE \"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80RESET": {"ttr": 12810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00 \\x00\\x993?\\x01\\x07\\x13\\x0f\\x10\\x18\\x00\\x10\\x00\\x0f\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1999-11-29T00:00:00", "modifydate": "2007-05-10T10:18:20", "lines": 16, "newlines": 15, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX THE WONDER DOG */\nsignal off error\narg acid newpass\nrcode = 0\naddress tso\nsay \"tss rem(\"acid\") asuspend \"\n\"tss rem(\"acid\") asuspend \"\nrcode = rcode + rc\nsay \"tss rem(\"acid\") suspend \"\n\"tss rem(\"acid\") suspend \"\nrcode = rcode + rc\nsay \"tss rep(\"acid\") password(\"newpass\")\"\n\"tss rep(\"acid\") password(\"newpass\")\"\nrcode = rcode + rc\nexit 0\nexit rcode\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80TSO": {"ttr": 12812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\"\\x01\\x005o\\x01\\x07\\x13\\x0f\\x10\\x18\\x01[\\x01[\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-12-21T00:00:00", "modifydate": "2007-05-10T10:18:22", "lines": 347, "newlines": 347, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T80TSO                            **/\n/** LAST MODIFIED    : 21 SEP 98                         **/\n/**********************************************************/\n/**********************************************************/\n/** CHANGED TO MAKE MORE GENERIC                         **/\n/**********************************************************/\n/** CHANGED TO ALLOW DEFINITION OF UNOWNED RESOURCES     **/\n/**********************************************************/\n/**----------------INPUT REQUIRED -----------------------**/\n/** VAR                VALID VALUES                      **/\n/** ACTION  : DEFAULTS ADDPROC ADDACCT DEFACCT DEFPROC   **/\n/**           DEFSIZE  DEFUNIT MAXSIZE REMACCT TSOAUTH   **/\n/** ACID    : ANY VALID TSS ACID                         **/\n/** LPROC   : ANY VALID PREDEFINED (TO TSS) PROC         **/\n/** ACCTNUM : ANY VALID PREDEFINED (TO TSS) ACCOUNT      **/\n/** UNIT    : ANY VALID UNIT                             **/\n/** SIZE    : ANY VALID SIZE                             **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00 08 16                     **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                                                      **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES                             **/\n/** ISPF ENVIRONMENT   : NOT NEEDED, BUT WILL USE        **/\n/** EXECS CALLED WITHIN THIS EXEC : T80INS               **/\n/**                                                      **/\n/**********************************************************/\nSYSENV = SYSVAR(SYSENV)\nMSG2 = \"NO UNUSUAL CONDITIONS WERE FOUND.\"\nARG ACTION ACID LPROC ACCTNUM UNIT SIZE\n/*                                             */\nIF SYSENV = \"FORE\" THEN DO\n  ADDRESS ISPEXEC \"VGET AUTHNUM PROFILE\"\n  ADDRESS ISPEXEC \"VGET BOOKSEC PROFILE\"\nEND\nELSE DO\n  AUTHNUM = 10\n  BOOKSEC = \"NO\"\nEND\n/*IF SUBSTR(ACID         ,8,1) = \"@\" THEN DO                      */\n/*  MSG2 = \"WARNING: THE ID YOU HAVE GIVEN ME IS A GHOST ID.\"     */\n/*  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"   */\n/*  ELSE SAY SECRC                                                */\n/*END                                                             */\nIF (LENGTH(ACID) > 8) & ( SUBSTR(ACID        ,8,1) \u00ac= \"@\" ) THEN DO\n  SECRC = \"THE ID YOU HAVE GIVEN ME IS TOO LONG MAX IS 7 CHRS\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  ELSE SAY SECRC\n  EXIT 00\nEND\nSIGNAL ON ERROR NAME NOTSSID\nQ = OUTTRAP(DROPIT.,5)\nADDRESS TSO \"TSS LIST(\"ACID\") DATA(NAME)\"\nSIGNAL OFF ERROR\nX5 = \"OK\"\nSAY \"T80TSO: RECEIVED  CONTROL ACTION=\" ACTION \"ACID=\"ACID\nSAY \"T80TSO: PROC=\"LPROC\" ACCT=\"ACCTNUM\" UNIT=\"UNIT \"SIZE=\"SIZE\n/**************************************************/\n/* IF THE RESOURCE IS NOT OWNED ADD IT TO TSODEPT */\n/**************************************************/\nIF (AUTHNUM > 8) & (ACTION \u00ac= \"TSOAUTH\")  THEN DO\n  Q = OUTTRAP(DROPOUT.,5)\n  /* SAY \"T80TSO: CHECKING THAT ALL RESOURCES ARE OWNED \" */\n  TSS_RESOURCE = LPROC\n  ADDRESS TSO \" TSS WHOOWNS TSOPROC(\"LPROC\")\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T80TSO: I AM ADDING THE LPROC TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOPROC(\"LPROC\")\"\n  END\n  TSS_RESOURCE = ACCTNUM\n  ADDRESS TSO \" TSS WHOOWNS TSOACCT(\"ACCTNUM\")\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T80TSO: I AM ADDING THE ACCTNUM TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOACCT(\"ACCTNUM\")\"\n  END\n  TSS_RESOURCE = \"JCL\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(JCL)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T80TSO: I AM ADDING THE JCL AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(JCL)\"\n  END\n  TSS_RESOURCE = \"OPER\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(OPER)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T80TSO: I AM ADDING THE OPER AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(OPER)\"\n  END\n  TSS_RESOURCE = \"ACCT\"\n  ADDRESS TSO \" TSS WHOOWNS TSOAUTH(ACCT)\"\n  IF RC \u00ac= 0 THEN DO\n    SAY \"T80TSO: I AM ADDING THE ACCT AUTH TO TSODEPT\"\n    ADDRESS TSO \" TSS ADD(TSODEPT) TSOAUTH(ACCT)\"\n  END\n  SAY \"T80TSO: RESOURCE OWNER CHECKING COMPLETED.\"\nEND\n/**************************************************/\n/* END OF OWNERSHIP RESOLUTION.                   */\n/**************************************************/\nQ = OUTTRAP(OUT.,5)\nSIGNAL ON ERROR NAME SEEYA\n/* ACTION =DEFAULTS */\nIF (ACTION = \"DEFAULTS\") | (ACTION = \"DEFTSO\") THEN DO\n  SAY \"T80TSO: ATTEMPTING TO DEFINE ALL TSO AUTHS\"\n  SAY \"T80TSO: REMOVING ANY OLD PERMISSIONS FOR\" LPROC ACCTNUM\n  IF ACCTNUM \u00ac= \"NIL\" THEN DO\n    IF BOOKSEC = \"YES\" THEN\n      X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS*/\n    ELSE X5 = \"OK\"\n  END\n  SAY \"T80TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOAUTH(JCL)\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLPROC(\"LPROC\")\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS REM(\"ACID\") TSOLSIZE(\"SIZE\")\"\n  SAY \"T80TSO: DEFINING NEW TSO DEFAULTS.\"\n  SIGNAL ON ERROR NAME NOTSSDEF\n  Q = OUTTRAP(OUT.,5)\n  TSS_RESOURCE = \"LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\n  TSS_RESOURCE = \"ACCT NUM\" ACCTNUM\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  TSS_RESOURCE = \"JCL\"\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOAUTH(JCL)\"\n  SIGNAL ON ERROR NAME SEEYA\n  Q = OUTTRAP(OUT.,5)\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOUNIT(\"UNIT\")\"\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLPROC(\"LPROC\")\"\n  IF ACCTNUM \u00ac= \"NIL\" THEN\n    ADDRESS TSO \" TSS ADD(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLSIZE(\"SIZE\")\"\n  SAY \"T80TSO: CALLING T80INS FOR PROFILE INSERTION\"\n  ADDRESS TSO \"%T80INS\" ACID \"TSOPROF 9\"\n  SAY  \"T80TSO: BACK FROM T80INS WITH RC OF\" RC\nEND\nIF ACTION = \"ADDPROC\" THEN DO\n  SAY \"T80TSO: REVOKING ID FROM PROC\" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \"TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T80TSO: PERMITTING ID TO PROC\" LPROC\n  ADDRESS TSO \"TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\nEND\nIF ACTION = \"ADDACCT\" THEN DO\n  SAY \"T80TSO: REVOKING ID FROM ACCT\" ACCTNUM\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME NOBOOK\n  SAY \"T80TSO: PERMITTING ID TO ACCT\" ACCTNUM\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T80TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"DEFACCT\" THEN DO\n  SIGNAL OFF ERROR\n  ADDRESS TSO \"%T80GDAT \" ACID \"TSOLACCT  TSO\"\n  ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  BOOK = SECRC\n  IF BOOK = \"\" THEN SAY \"T80TSO: NO DEFAULT BOOK NUMBER DEFINED \"\n  IF BOOK = \"\" THEN BOOK  = \"$NOTFOUND\"\n  /********************************************************/\n  /* DOES HE HAVE A CURRENT DEFAULT TSS BOOK NUMBER ??    */\n  /********************************************************/\n  IF (BOOK = \"$BADTSS\") |  (BOOK = \"$NOTFOUND\") THEN NOP\n  ELSE DO\n    /********************************************************/\n    /* CAN HE OVERLAY THE CURRENT DEFAULT BOOK NUMBER ??    */\n    /********************************************************/\n    BOOK = SECRC\n    IF BOOKSEC = \"YES\" THEN\n      X5 = TSSCHECK(\"BOOKNUM\",BOOK,\"UPDATE\")  /* CAN THEY DO THIS */\n    ELSE X5 = \"OK\"\n    SAY \"T80DEL: TSSCHECK RETURN CODE IS \" X5\n    IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKREMA\n  END\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T80TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SAY \"T80TSO: REVOKING ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME NOBOOK\n  SAY \"T80TSO: PERMITTING ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SAY \"T80TSO: MAKING IDS DEFAULT ACCT\" ACCTNUM\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"DEFPROC\" THEN DO\n  SIGNAL OFF ERROR\n  SAY \"T80TSO: REVOKING LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T80TSO: PERMITTING LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOPROC(\"LPROC\")\"\n  SAY \"T80TSO: MAKING IDS DEFAULT LOGON PROC\" LPROC\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLPROC(\"LPROC\")\"\n  PDSN = \"'MVS.TSO.PROCLIB(\"LPROC\")'\"\n  /* SAY SYSDSN(PDSN) */\n  IF SYSDSN(PDSN)  = \"MEMBER NOT FOUND\" THEN DO\n    MSG2 = \"LOGON PROC CHANGED, BUT \"PDSN\" WAS NOT FOUND\"\n    IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n    SAY \"T80TSO:\" MSG2\n  END\nEND\nIF ACTION = \"DEFSIZE\" THEN DO\n  SAY \"T80TSO: MAKING IDS DEFAULT LOGON SIZE\" SIZE\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOLSIZE(\"SIZE\")\"\nEND\nIF ACTION = \"DEFUNIT\" THEN DO\n  SAY \"T80TSO: MAKING IDS DEFAULT LOGON UNIT\" UNIT\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOUNIT(\"UNIT\")\"\nEND\nIF ACTION = \"MAXSIZE\" THEN DO\n  SAY \"T80TSO: MAKING IDS MAXIMUM REGION SIZE\" SIZE\n  ADDRESS TSO \" TSS ADD(\"ACID\") TSOMSIZE(\"SIZE\")\"\nEND\nIF ACTION = \"REMACCT\" THEN DO\n  SAY \"T80TSO: REVOKING ID FROM ACCOUNT \" ACCTNUM\n  IF BOOKSEC = \"YES\" THEN\n    X5 = TSSCHECK(\"BOOKNUM\",ACCTNUM,\"UPDATE\")  /* CAN THEY DO THIS */\n  ELSE X5 = \"OK\"\n  SAY \"T80TSO: TSSCHECK RETURN CODE IS \" X5\n  IF X5 \u00ac= \"OK\"  THEN SIGNAL BOOKAUTH\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOACCT(\"ACCTNUM\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"REMPROC\" THEN DO\n  SAY \"T80TSO: REVOKING ID FROM LOGON PROC \" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOPROC(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\nEND\nIF ACTION = \"TSOAUTH\" THEN DO\n  SAY \"T80TSO: REVOKING ID FROM AUTHS \" LPROC\n  SIGNAL OFF ERROR\n  ADDRESS TSO \" TSS REV(\"ACID\") TSOAUTH(\"LPROC\")\"\n  SIGNAL ON ERROR NAME SEEYA\n  SAY \"T80TSO: PERMITTING ID TO \" LPROC\n  ADDRESS TSO \" TSS PER(\"ACID\") TSOAUTH(\"LPROC\")\"\nEND\nSAY \"T80TSO: CHECKING FOR TSO AREA COMPLETENESS.\"\nSAY \" \"\nSIGNAL OFF ERROR\nIF (ACTION \u00ac= \"DEFAULTS\") & (ACTION \u00ac= \"DEFTSO\") THEN DO\n  ADDRESS TSO \"%T80GDAT \"ACID\" TSOLACCT TSO\"\n  IF SYSENV = \"FORE\" THEN\n    ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  DEFAULT_ACCT = SECRC\n  SAY \"T80TSO: IDS DEFAULT ACCOUNT IS \" DEFAULT_ACCT\n  ADDRESS TSO \"%T80GDAT \"ACID\" TSOLPROC TSO\"\n  IF SYSENV = \"FORE\" THEN\n    ADDRESS ISPEXEC \"VGET SECRC PROFILE\"\n  DEFAULT_PROC = SECRC\n  SAY \"T80TSO: IDS DEFAULT LPROC IS \" DEFAULT_PROC\n  IF (DEFAULT_PROC = \"$NOTFOUND\") THEN DO\n    MSG2 = \"ID HAS NO DEFAULT PROC IN TSS,\"\n    MSG2 = MSG2 \"MAY NEED THE DEFTSO CMD ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\n  IF (DEFAULT_ACCT = \"$NOTFOUND\") THEN DO\n    MSG2 = \"ID HAS NO DEFAULT ACCOUNT IN TSS,\"\n    MSG2 = MSG2 \"MAY NEED THE DEFTSO CMD ISSUED.\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSAY \"T80TSO: FALL THRU AREA REACHED. SETTING MSG AND EXITING\"\nSAY \" \"\nSECRC = ACTION \"FUNCTION COMPLETED\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nELSE SAY SECRC MSG2\nEXIT 0\nSEEYA: NOP\nSAY \"T80TSO: **FATAL** ERROR OCCURRED IN LINE :\" SIGL\nTEMP = SOURCELINE(SIGL)\nSAY \"T80TSO: LINE\" SIGL \"=\" TEMP\nIF RC = 8 THEN DO\n  SECRC = \"FUNCTION FAILED. CONFIRM VALIDITY (OWNERSHIP) OF DATA\"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY \"T80TSO: *************************************************\"\n  SAY \"T80TSO: EXITING WITH RC = 08 PROBABLE TSS COMMAND FAILURE\"\n  SAY \"T80TSO: *************************************************\"\n  EXIT 8\nEND\nNOBOOK: NOP\nSAY \"T80TSO: ERROR OCCURRED IN LINE :\" SIGL\nTEMP = SOURCELINE(SIGL)\nSAY \"T80TSO: LINE\" SIGL \"=\" TEMP\nIF RC = 8 THEN DO\n  SECRC = \"FUNCTION FAILED. BOOK NUMBER MAY NOT EXIST \"\n  IF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  SAY \"T80TSO: EXITING WITH RC = 08 PROBABLE TSS OWNERSHIP ERROR.\"\n  EXIT 8\nEND\nSAY \"T80TSO: *************************************************\"\nSAY \"T80TSO: EXITING WITH RC = 16 !  FATAL ERROR.\"\nSAY \"T80TSO: *************************************************\"\nEXIT 1\nNOTSSDEF: NOP\nSAY \"T80TSO: A PERMIT ERROR OCCURRED IN LINE:\" SIGL\nSECRC = \"ABORTED.\" TSS_RESOURCE\" IS UNOWNED IN TSS.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY OUT.1\nSAY OUT.2\nSAY OUT.3\nSAY \"T80TSO: \"SECRC\nEXIT 8\nNOTSSID: NOP\nSAY \"T80TSO: THE ID YOU HAVE GIVEN DOES NOT EXIST\"\nSECRC = \"ABORTED. NO SUCH TOP SECRET ID, UNDER YOUR OWNERSHIP.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T80TSO: \"SECRC\nEXIT 8\n\nBOOKAUTH: NOP\nSAY TSSCHECK RCODE WAS X5\nSECRC = \"YOU ARE NOT AUTHORIZED FOR THIS BOOK FUNCTION. BOOK= \" ACCTNUM\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T80TSO: \"SECRC\nEXIT 8\n\nBOOKREMA: NOP\nSAY TSSCHECK RCODE WAS X5\nSECRC = \"YOU CANT OVERLAY BOOK VALUE = \"BOOK\". TRY ADDACCT INSTEAD.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T80TSO: \"SECRC\nEXIT 8\n\nTSSNOADD: NOP\nSAY \"T80TSO: AN OWNERSHIP ERROR OCCURRED IN LINE:\" SIGL\nSECRC = \"ABORTED.\" TSS_RESOURCE\" OWNERSHIP RESOLUTION FAILED IN TSS.\"\nIF SYSENV = \"FORE\" THEN ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nSAY \"T80TSO: \"SECRC\nEXIT 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80TSSIM": {"ttr": 12814, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00$\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x18\\x00*\\x00*\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:18:24", "lines": 42, "newlines": 42, "modlines": 0, "user": "COA1DIR"}, "text": "/* REXX THE WONDER DOG */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* WARNING: THE SETUP FOR THE EXECIOS IS NOT NORMAL!! IT IS A WORK   */\n/* AROUND FOR A PROBLEM WITH THE TSSSIM PROGRAM. DO NOT CHANGE THE   */\n/* MOD ALLOCATION, AS IT IS WHAT LETS THE PROCESS WORK!!             */\n/*********************************************************************/\n/*********************************************************************/\n/* ROUTES THE OUTPUT OF A TSSSIM COMMAND TO A DATASET OF YOUR CHOICE */\n/*********************************************************************/\n ARG ACID RTYPE RNAME FACILITY ACCESS DSOUT\n SAY \"ACID RTYPE RNAME FACILITY ACCESS DSOUT\"\n SAY ACID RTYPE RNAME FACILITY ACCESS DSOUT\n IF RTYPE = \"VOLUME\" THEN RTYPE = \"DASDVOL\"\n IF RTYPE = \"VOL\" THEN RTYPE = \"DASDVOL\"\n ADDRESS ISPEXEC \"VGET DS1 PROFILE\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"ALLOC DDN(SIM$$OUT) DSN(\"DSOUT\") SHR REUS\"\n OUT.1 = \"  LOGON ACID(\"ACID\") FAC(\"FACILITY\") TRACE \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \"ALLOC DDN(OUTFILE) DSN(\"DS1\") MOD REUS\"\n OUT.1 = \"  $\"RTYPE\"(\"RNAME\") ACCESS(\"ACCESS\")  \"\n IF ACCESS = \".NA.\" THEN\n   OUT.1 = \"  $\"RTYPE\"(\"RNAME\")\"\n IF RTYPE = \"DSN\" THEN\n   OUT.1 = \"  $\"RTYPE\"('\"RNAME\"') ACCESS(\"ACCESS\")  \"\n ADDRESS MVS \"EXECIO * DISKW OUTFILE ( FINIS STEM OUT.)\"\n ADDRESS TSO \" FREE DDN(OUTFILE)\"\n ADDRESS TSO \"ALLOC DDN(SIM$$IN) DSN(\"DS1\") SHR REUS\"\n ADDRESS TSO \"TSSSIM\"\n ADDRESS TSO \" FREE DDN(SIM$$IN)\"\n ADDRESS TSO \" FREE DDN(SIM$$OUT)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80UNDEL": {"ttr": 12816, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00&\\x00\\x955/\\x01\\x07\\x13\\x0f\\x10\\x18\\x00:\\x00:\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1995-12-18T00:00:00", "modifydate": "2007-05-10T10:18:26", "lines": 58, "newlines": 58, "modlines": 0, "user": "COA1DIR"}, "text": "/** rexx                                                 **/\n/**********************************************************/\n/** REMOVED UADS STEP .....................              **/\n/**********************************************************/\n/** BASELINE BASELINE BASELINE BASELINE BASELINE BASELINE**/\n/**********************************************************/\n/** EXEC NAME        : T80UNDEL                          **/\n/** LAST MODIFIED    : 31 MAR 99                         **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ACID TO BE RECREATED                   **/\n/** MODE    : THE MODE \"ONLINE\" OR \"BATCH\"               **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/** DS1     : A FLAT FILE LRECL 80                       **/\n/** DS2     : A FLAT FILE LRECL 80                       **/\n/** DSBACK  : A PDS CONATAINING MEMBER (ACID)            **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : YES (BUT IT NEEDS VGETS !)      **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC : RXREPRO T44CON       **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nADDRESS TSO\nADDRESS ISPEXEC \"VGET DS1 PROFILE\"\nADDRESS ISPEXEC \"VGET DS2 PROFILE\"\nADDRESS ISPEXEC \"VGET DSBACK PROFILE\"\nACID_COPY = \"'\"DSBACK\"(\"ACID\")'\"\nUADS_COPY = \"'\"UADSBACK\"(\"ACID\"0)'\"\nIF SYSDSN(ACID_COPY) \u00ac= \"OK\" THEN DO\n  say \"enqueue failed on\" acid_copy\n  secrc = \"Acid not resurrectable, no backup available. sorry\"\n  ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n  EXIT 00\nEND\nIF MODE = \"ONLINE\" THEN DO\n  /* \"SMCOPY FDS(\"ACID_COPY\") TDS(\"DS1\") NOTRANS\"*/\n  ADDRESS TSO \"%RXREPRO \" ACID_COPY DS1\n  ADDRESS TSO \"%T80ICOMP  REBUILD BYPASS\"\n  ADDRESS TSO \"SUBMIT\" DS2\n  secrc = \"Job submitted to resurrect id \" acid\". check uads entries\"\n  END\nELSE DO\n  BJCL.1 = \"  %RXREPRO \"ACID_COPY DS1\n  BJCL.2 = \"  ISPSTART CMD(%T80ICOMP REBUILD ACID  ) NEWAPPL(TSS)\"\n  BJCL.3 = \"  SUBMIT\" DS2\n  BJCL.4 = \"  \"\n  ADDRESS MVS \"EXECIO 4 DISKW BJCL ( FINIS STEM BJCL.)\"\n  secrc = \"Batch file has been updated with resurrection stream.\"\nEND\nADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T80USUS": {"ttr": 12818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x00'\\x01\\x00\\x16\\x7f\\x01\\x07\\x13\\x0f\\x10\\x18\\x00N\\x00F\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "2000-06-15T00:00:00", "modifydate": "2007-05-10T10:18:27", "lines": 78, "newlines": 70, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX THE WONDER DOGG                                 **/\n/**********************************************************/\n/** CHANGED THE TSOUSERS LOOKUP                          **/\n/**********************************************************/\n/**********************************************************/\n/** EXEC NAME        : T80USUS                           **/\n/** LAST MODIFIED    : 04 apr 2001                       **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE ID TO UNSUSPEND                        **/\n/** ARG2    :                                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/**                                                      **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :                      **/\n/**                                                      **/\n/**********************************************************/\n ARG ACID MODE PWVAL\n /*******************************************************/\n /* dont use mode currently but it is here if I need it */\n /*******************************************************/\n say \"T80USUS: in control with parms \" acid mode pwval\n SYSENV = SYSVAR(SYSENV)\n SIGNAL OFF ERROR\n ADDRESS TSO \"%T80IDAT \"ACID\" UNSUSPEND\"\n idat_drc= rc\n OTT = OUTTRAP(OUT,0)  /* TRAP EVERYTHING */\n say \"T80USUS: IDATA drc:\" idat_drc\n ADDRESS TSO \"%T80GDAT \"ACID\" ATTRIBUTES\"\n ADDRESS ISPEXEC \"VGET SECRC \"\n ADDRESS TSO \"TSS REMOVE(\"ACID\") SUSPEND\"\n IF PWVAL = \"SAME\" THEN  DO\n   say \"T80USUS: issuing  address tso tss rep(\"acid\") password(*,60)\"\n   ADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(*,60)\"\n END\n ELSE DO\n   say \"T80USUS: issuing address tso tss rep(\"acid\") password(\"pwval\")\"\n   ADDRESS TSO \"TSS REP(\"ACID\") PASSWORD(\"PWVAL\")\"\n END\n say \"T80USUS: attributes are \" secrc\n if secrc = \"$BADACID\" then do\n   secrc = \"That ID doesn't exist or you cannot administer it\"\n   signal badid\n end\n IF POS(\"ASUSPEND\",SECRC) \\= 0 THEN ADMIN_SUSPEND = \"YES\"\n IF POS(\"ADMIN SUSPEND\",SECRC) \\= 0 THEN ADMIN_SUSPEND = \"YES\"\n SIGNAL ON ERROR NAME BADID\n say \"T80USUS: received control env is \"sysenv\n CHKACID = ACID\n IF LENGTH(ACID) = 8 THEN CHKACID = SUBSTR(ACID,1,7)\n IF ( SYSENV = \"FORE\" ) & ( ACID= \" \" ) THEN\n   ADDRESS ISPEXEC \"VGET ACID PROFILE\"\n SECRC = \"Retrieval failed for ID:\" ACID\n say \"T80USUS: calling TSS for ACID\" acid\n IF ADMIN_SUSPEND = \"YES\" THEN DO\n   SECRC = \"ID is ASUSPENDED, you are not authorized to remove\"\n   say \"T80USUS: ACID is admin suspended removing asuspend\"\n   ADDRESS TSO \" TSS REM(\"ACID\") ASUSPEND\"\n   say \"T80USUS: ACID was Admin suspended setting message\"\n   MSG2 = \"Warning: ID was manually suspended by an administrator!\"\n   ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n END\n SECRC = \"ID unsuspend sucessful for \"ACID\n IF SYSENV = \"FORE\" THEN\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n else say \"T80USUS:\" secrc\n EXIT 00\n BADID: RCODE = RC\n say \"T80USUS: entering error recovery from line \" sigl \"code = \" rcode\n IF SYSENV = \"FORE\" THEN DO\n   ADDRESS ISPEXEC \"VPUT SECRC PROFILE\"\n EXIT 08\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "T90ADD": {"ttr": 13577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00F\\x01\\x07)/\\x01\\t\\x04O\\x14\"\\x01\\x8c\\x01\\x84\\x00\\x00\\xc3\\xd6\\xc1\\xf1\\xc4\\xc9\\xd9@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-10-19T00:00:00", "modifydate": "2009-02-13T14:22:46", "lines": 396, "newlines": 388, "modlines": 0, "user": "COA1DIR"}, "text": "/** REXX                                                 **/\n/**********************************************************/\n/** EXEC NAME        : T90ADD                            **/\n/** LAST MODIFIED    :  24 OCt 2007                      **/\n/**********************************************************/\n/** Added Employee number to panel field.                **/\n/**********************************************************/\n/** Added smarts to routine to insert the password parm  **/\n/** on the create if it doesn't exist and honor it if it **/\n/** does dir july 2 2003                                 **/\n/**********************************************************/\n/** added variable for default department vget           **/\n/**********************************************************/\n/** changed acid variable manipulation so that the acid  **/\n/** variable remains a little more stable.               **/\n/**                                .....DIR 19 AUGUST 96 **/\n/**********************************************************/\n/**********************************************************/\n/** ADDED LOGIC TO DETERMINE IF ID HAS DSNS CATLGD IN    **/\n/** MASTER CAT YET HAS NO ALIAS        DIR  11 MAY 95    **/\n/**********************************************************/\n/**********************************************************/\n/**                                                      **/\n/**----------------INPUT REQUIRED -----------------------**/\n/** PASSED ARGS        VALID VALUES                      **/\n/** ACID    : THE TSS ACID TO BE ADDED.                  **/\n/** MODE    : BATCH OR ONLINE                            **/\n/** ISPF VGETS         VALID VALUES                      **/\n/** TO NUMEROUS TO MENTION LOTS OF TSSINI VALUES         **/\n/**----------------OUTPUT PRODUCED-----------------------**/\n/** VALID CONDITION CODES - 00                           **/\n/** ISPF VARIABLES        - SECRC                        **/\n/**                         DATAAREA                     **/\n/**----------------REQUIREMENTS--------------------------**/\n/** CAN RUN STANDALONE : NO                              **/\n/** ISPF ENVIRONMENT   : YES                             **/\n/** EXECS CALLED WITHIN THIS EXEC :         TSSAUDU      **/\n/**                                                      **/\n/**********************************************************/\nARG ACID MODE\nSAY \"T90ADD: CONTROL RECEIVED PARMS = \" ACID MODE\nADDRESS ISPEXEC\n\"VGET AUD       PROFILE\"\n\"VGET DEF       PROFILE\"\n\"VGET DS1       PROFILE\"\n\"VGET DS2       PROFILE\"\n\"VGET DS3       PROFILE\"\n\"VGET DS4       PROFILE\"\n\"VGET DS5       PROFILE\"\n\"VGET DS6       PROFILE\"\n\"VGET MSG2      PROFILE\"\n\"VGET PROD      PROFILE\"\n\"VGET TSOSIZE   PROFILE\"\n\"VGET TSOUNIT   PROFILE\"\n\"VGET TSOPROC   PROFILE\"\n\"VGET TVER      PROFILE\"\nSIGNAL OFF ERROR\n/**********************************************************/\n/** below I am checking that the id doesnot have dsns    **/\n/** cataloged to the master catalog. if it does the      **/\n/** user wont be able to catalog his own datasets. this  **/\n/** will cause allocate errors that are hard to track.   **/\n/** i may make this a seperate callable exec but for     **/\n/** now it is included here    dave 11 may 95            **/\n/**********************************************************/\nDATEHOLD = DATE('U')\nMONTHNUM = SUBSTR(DATEHOLD,1,2)\nADDRESS TSO \"%T80GDAT \"ACID \"NAME\"\nOLDID = RC\noutct = 40\nBOOK = \"NIL\"\nBOOK1 = \"NIL\"\nSAY \"TSA101D: T90ADD  EXISTANCE CHECK RC IS \" OLDID\nIF OLDID = 0 THEN DO\n  msg2 = \"This id exists currently, readdition will fail upon\",\n  \"execution\"\n  ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\nEND\n/**************************************/\n/* get the default department         */\n/**************************************/\nADDRESS ISPEXEC \"VGET DEFDEPT PROFILE\"\nADDRESS ISPEXEC \"VGET TSOALIAS PROFILE\"\nIF TSOALIAS = \"YES\" THEN DO\n  ADDRESS TSO \"LISTC ENT('\"ACID\"')\"\n  SAY \"TSA101D: T90ADD  ALIAS CHECK IS \" RC\n  ALIAS_CODE = RC\n  ADDRESS TSO \"LISTC LEVEL('\"ACID\"')\"\n  SAY \"TSA101D: T90ADD  LEVEL CHECK IS \" RC\n  LEVEL_CODE = RC\n  IF (ALIAS_CODE \u00ac= 0) & (LEVEL_CODE =0)  THEN DO\n    msg2 = \"The id has no alias, yet has dsns cataloged, expect\",\n    \"severe allocation errors\"\n    ADDRESS ISPEXEC \"VPUT MSG2 PROFILE\"\n  END\nEND\nSIGNAL ON ERROR NAME ABORT\n/**********************************************************/\n/** END OF DSN ALIAS / LEVEL CHECKING                    **/\n/**********************************************************/\nLINE.  = \" \"\nALEN   = LENGTH(ACID)\nBILLA  = \"N\"\nCODE   = 0\nCURSOR = \"NAME\"\nDEFINE = \"NAME('\"NAME\"') DEPT(D0) TYPE(USER)\"\nFIRST2 = SUBSTR(ACID,1,2)\nGOTDEF = \"NO\"\nLOGON  = TSOPROC\nNDEPT  = FIRST2||\"DEPT\"\nif defdept /= \"NONE\" then ndept = defdept\nPROF   = \" \"\nPWORD  = \"PASSWORD,60,EXP\"\nSECDEF. = \" \"\nsecrc  = \"T90ADD did not complete normally. please check the id.\"\nS2     = ALEN - 1\nTYPE   =  \"USER\"\nWARNED = \"NO\"\n\"VPUT SECRC PROFILE\"\nPW = \"PASSWORD\"\nDPNL   = \"SPIADD\"\nBASIC_ACID = \" \"\nAUDU.0 =   1\nAUDU.1 =   \"%ADDLOCAL\" ACID NDEPT\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER) PASSWORD(\"PW\",60,EXP)\"\n/****************************************************/\n/** the tso authority stream is below              **/\n/****************************************************/\n/*                                                                  */\n/*batchtso.0 = 3                                                    */\n/*batchtso.1 = \" \"                                                  */\n/*batchtso.2 = \"ISPSTART CMD(%\"TVER\"TSO DEFAULTS +\"                 */\n/*batchtso.3 = \" \"ACID LOGON BOOK1 TSOUNIT TSOSIZE\") NEWAPPL(TSS)\"  */\n/*onlintso.0 = 1                                                    */\n/*onlintso.1 =\"%\"TVER\"TSO DEFAULTS\" ACID LOGON BOOK1 TSOUNIT TSOSIZE*/\n/*                                                                  */\n/****************************************************/\n/** beginning of the panel loop                    **/\n/** beginning of the panel loop                    **/\n/****************************************************/\nAGAIN: NOP\nCALL FILLSCR\n\"DISPLAY PANEL(\"DPNL\")  CURSOR(\"CURSOR\")\"\nmsg2 = \" \"\nsay \"name is \" name\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER) PASSWORD(\"PW\",60,EXP)\"\nsay \"enum is \" enum\nRCODE = RC\nif enum = \" \" then do\n  msg2 = \"Employee number must be provided.\"\n  cursor= \"ENUM\"\n  signal again\nend\nenum = substr(enum                                 ,1,20)\nenum = enum||initial\nNAME = TRANSLATE(NAME,\" \",\"'\") /* REPLACE TICS WITH SPACES */\nSAY \"TSA101D: T90ADD  PANEL RCODE IS \"RCODE\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ERRMSG\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\n  /******************************************************/\nGETNAME: NOP\nCNT1 = 0\nNORMAL: NOP\nMEMBER = mem\nIF MEM = \"\" THEN MEMBER = NDEPT\nmem = member\nSAY \"TSA101D: CHECKING FOR DEFAULT DEPT AUTHORITIES\" DEF\"(\"MEMBER\")\"\nIF SYSDSN(\"'\"DEF\"(\"MEMBER\")'\") = \"OK\" THEN DO\n  say \"tsa101d: T90ADD  default authority group found for in \" def bin\n  address tso \"alloc ddn(secdef) dsn('\"def\"(\"member\")') shr reus\"\n  address mvs \"execio * diskr secdef ( finis stem secdef.)\"\n  address tso \"free ddn(secdef)\"\n  /******************************************************/\n  /***                                                ***/\n  /*** NOTE: THE FIRST LINE OF THE DSN MUST HAVE A    ***/\n  /*** CREATE PARM IN IT! IF THERE IS NO MEMBER I     ***/\n  /*** ASSIGN A VALUE TO SECDEF.1                     ***/\n  /***                                                ***/\n  /******************************************************/\n  SECDEF.1 = \"NAME('\"NAME\"')\" SECDEF.1\n  GOTDEF = \"YES\"\nEND\nELSE Do\n  secdef.1 = define /* if no member we just create a 1 liner */\n  if enum /= \" \" then\n    secdef.2 = \"TSS add(\"acid\") instdata('\"enum netid\"')\"\nEND\nsay \"T90ADD: secdef.1 is\" secdef.1\nsay \"T90ADD: secdef.2 is\" secdef.2\ntrace off\nDO T = 1 TO 40\n  /******************************************************/\n  /***                                                ***/\n  /*** ONCE HERE THERE HAS TO BE A SECDEF.1 VALUE AND ***/\n  /*** IT HAS IS    COMPRISED OF VALID 'CREATE' PARMS ***/\n  /*** FOR TOP SECRET. THE REST OF THE SECDEF. STRING ***/\n  /*** MAY CONTAIN commands to be issued by the       ***/\n  /*** system sight unseen.                           ***/\n  /******************************************************/\n  if index(secdef.t,\"$$\") /= 0 then do\n    say \" T90ADD: $$ substitution string found in secdef\"\n    parse var secdef.t q1 '$$' q2\n    secdef.t = q1||acid||q2\n    say \" T90ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$DEPT$\") /= 0 then do\n    say \" T90ADD: $DEPT$ substitution string found in secdef\"\n    parse var secdef.t q1 '$DEPT$' q2\n    secdef.t = q1||ndept||q2\n    say \" T90ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$ENUM$\") /= 0 then do\n    say \" T90ADD: $ENUM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$ENUM$' q2\n    secdef.t = q1||Enum||q2\n    say \" T90ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$MEM$\") /= 0 then do\n    say \" T90ADD: $MEM$ substitution string found in secdef\"\n    parse var secdef.t q1 '$MEM$' q2\n    secdef.t = q1||member||q2\n    say \" T90ADD: resolved secdef is \"secdef.t\n  end\n  if index(secdef.t,\"$OPID$\") /= 0 then do\n    say \" T90ADD: $OPID$ substitution string found in secdef\"\n    parse var secdef.t q1 '$OPID$' q2\n    opid = substr(acid,5,3)\n    secdef.t = q1||opid||q2\n    say \" T90ADD: resolved secdef is \"secdef.t\n  end\n  LINE.T =  strip(secdef.t)\n  say t line.t\nEND\nSCRDISP: NOP\nCALL FILLSCR\nMSG=\"CHANGE DEFAULT COMMAND STREAM IF NEEDED AND HIT ENTER.\"\nIF GOTDEF = \"NO\" THEN\n  MSG=\"NO DEFAULT AUTHORITY STREAM FOUND. ENTER COMMANDS.\"\nPNLDISP: NOP\n\"ISPEXEC DISPLAY PANEL(\"DPNL\")\"\nRCODE = RC\nSAY \"T90ADD: PANEL RCODE IS \"RCODE\nIF MEM /= MEMBER THEN SECDEF. = \" \"\nIF MEM /= MEMBER THEN SIGNAL NORMAL\nNAME = SUBSTR(NAME                  ,1,20)\nCALL FILLDOT\nIF RCODE = 8 THEN SIGNAL ABORT\nIF RCODE = 4 THEN SIGNAL ABORT\nIF OPTION = \"X\" THEN SIGNAL ABORT\nIF OPTION = \"END\" THEN SIGNAL ABORT\n/******************************************************************/\n/******************************************************************/\nCOMMIT: NOP\n/*\nDEFINE = \"NAME('\"NAME\"') DEPT(\"NDEPT\") TYPE(USER)\"\nDEFINE = DEFINE \"              \"\nLINE.1 = DEFINE\n*/\nIF PW \u00ac= \" \" THEN PWORD = PW||\",60,EXP\"\nELSE PW = \"PASSWORD\"\nIF MODE = \"BATCH\" THEN DO\n  SAY \"T90ADD: BATCH MODE DETECTED. ALLOCATING \" DS5 \"TO BJCL DDN\"\n  ADDRESS TSO \"ALLOC DDN(BJCL) DSN(\"DS5\") MOD REUS\"\n  BJCL.1= \"TSS CREATE(\"ACID\") password(\"pword\")  +\"\n  ADDRESS MVS \"EXECIO 1 DISKW BJCL ( FINIS STEM BJCL.)\"\n  ADDRESS MVS \"EXECIO \"OUTCT\" DISKW BJCL ( FINIS STEM LINE.)\"\n  /**********************************************************/\n  /*ADDRESS MVS,                                               */\n  /* \"EXECIO \"batchtso.0\" DISKW BJCL ( FINIS STEM batchtso.)\"  */\n\n  SAY \"T90ADD: WRITING DATA TO BJCL DDNAME\"\n  ADDRESS MVS \"EXECIO * DISKW BJCL ( FINIS STEM AUDU.)\"\n  CODE = RC\n  IF CODE = 0 THEN SECRC =\"BATCH FILE UPDATED WITH ADD COMMANDS.\"\n  SIGNAL OFF ERROR\n  SIGNAL BYE1\nEND\nTSSCMD = \"YES\"\nADDRESS TSO\nSAY \"T90ADD: ISSUING THE TSS ADD COMMAND FOR THE ID\"\nif index(line.1,\"PASSWORD\") = 0 then do\n  line.1 = line.1 \"PASSWORD(\"PW\",60,EXP)\"\n  SAY \"T90ADD: Inserting default password into create stream\"\nend\nSAY \"T90ADD: TSS CRE(\"ACID\")\" LINE.1\n\"TSS CREATE(\"ACID\")\"  LINE.1\nCODE = RC\nSAY \"T90ADD: THE TSS ADD COMMAND FINISHED WITH A RCODE OF \" CODE\nSIGNAL OFF ERROR\nDO T = 2 TO OUTCT\n   say \"T90ADD: issuing command:\" line.t\n   IF LINE.T < > \" \" THEN\n   ADDRESS TSO \" \"LINE.T\nEND\n/* ADDRESS TSO \"%TSSAUDU \" ACID    */\nSPACES= \"                                                          \"\nSYSDATE = DATE(U)\nBYE:  NOP\nSIGNAL OFF ERROR\nIF  MODE= \"SKIPIT\" THEN DO\n  SAY \"T90ADD: VERSION 5.2 TSO DEFAULTS BEING SET\"\n  BOOK1 = WORD(BOOK,1)\n  rcode = 0\n  do cmdnum = 1 to audu.0\n    say \"T90ADD: issuing cmd : \"onlintso.cmdnum\n    address tso onlintso.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T90ADD: rcode from cmd is \" holdrc\n  end\n  do cmdnum = 1 to audu.0\n    say \"T90ADD: issuing cmd : \"audu.cmdnum\n    address tso audu.cmdnum\n    holdrc = rc\n    rcode = holdrc + rcode\n    say \"T90ADD: rcode from cmd is \" holdrc\n  end\n  ADDRESS ISPEXEC\n  IF RCODE > 0 THEN DO\n    \"VGET SECRC PROFILE\"\n    msg2 = \"defaults tso setup has failed, check book authorities\"\n    \"VPUT MSG2 PROFILE\"\n    SIGNAL BYE1\n  END\n  SAY \"T90ADD: VERSION 5.0 TSO DEFAULTS HAVE BEEN SET\"\nEND\nJUSTUADS: NOP\nCODE = RC\nSIGNAL ON ERROR NAME BADALIAS\n\nif code = 0 then secrc =\"TSA202I: ACID added. no errors encountered.\"\nBYE1:  NOP\nSIGNAL OFF ERROR\nADDRESS ISPEXEC\n\"VPUT SECRC PROFILE\"\n DATAAREA = ACID\n\"VPUT DATAAREA PROFILE\"\nEXIT 0\nERRMSG: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA201E: Errors encountered. check acid status \"\n  SIGNAL BYE1\nBADALIAS: NOP\n  IF CODE = 0 THEN\n    secrc= \"alias addition failed check acid status \"\n  else secrc = secrc \"and alias addition failed\"\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  SIGNAL BYE1\nABORT: NOP\n  CODE = 9 /* TELL THE BYE ROUTINE THERE IS AN ERROR.*/\n  secrc= \"TSA200E: Function aborted. acid not added. SIGL:\" sigl\n  SIGNAL BYE1\n/****************************************************************/\n/*  ERROR ROUTINE MESSAGE DISPLAYS.........DIR                  */\n/****************************************************************/\nFILLDOT: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE.1 = LINE1\n  LINE.2 = LINE2\n  LINE.3 = LINE3\n  LINE.4 = LINE4\n  LINE.5 = LINE5\n  LINE.6 = LINE6\n  LINE.7 = LINE7\n  LINE.8 = LINE8\n  LINE.9 = LINE9\n  LINE.10= LINE10\n  LINE.11= LINE11\n  LINE.12= LINE12\n  LINE.13= LINE13\n  LINE.14= LINE14\n  LINE.15= LINE15\nRETURN\nFILLSCR: PROCEDURE EXPOSE LINE1 LINE2 LINE3 LINE4 LINE5 LINE6,\n  LINE7 LINE8 LINE9 LINE10 LINE11 LINE12 LINE13 LINE14 LINE15 LINE.\n  LINE1 = LINE.1\n  LINE2 = LINE.2\n  LINE3 = LINE.3\n  LINE4 = LINE.4\n  LINE5 = LINE.5\n  LINE6 = LINE.6\n  LINE7 = LINE.7\n  LINE8 = LINE.8\n  LINE9 = LINE.9\n  LINE10= LINE.10\n  LINE11= LINE.11\n  LINE12= LINE.12\n  LINE13= LINE.13\n  LINE14= LINE.14\n  LINE15= LINE.15\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT526/CBT.V500.FILE526.PDS/REXX.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT526/CBT.V500.FILE526.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}