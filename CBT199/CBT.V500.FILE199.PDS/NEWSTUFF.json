{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "IBMUSER", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20050807123736000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2704156, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "IBMUSER.COLE.PDS", "INMMEMBR": "IBMUSER.COLE.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2704156, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2704156, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"IBMUSER.COLE.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12304, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "050219", "DS1SCEXT": "b'\\x80m\\x10'", "DS1SCALO": "b'P\\x00\\x00-'", "DS1LSTAR": "b'\\x00(\\x03'", "DS1TRBAL": "b'\\x16\\xfa'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8fH\\x00\\x00\\x04\\x89-`'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8fH\\x00\\x00\\x04\\x89-`'", "b'X\\xf35\\xd0\\x00\\x00\\x01;\\x00\\x0e\\x01=\\x00\\x0e\\x00\\x1f'", "b'X\\xf35\\xd0\\x00\\x00\\x01>\\x00\\x00\\x01?\\x00\\x07\\x00\\x17'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"ASM2ZAP": {"ttr": 1796, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "BLKSPTRK": {"ttr": 1281, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "./ ADD NAME=ASMJCL   0101-99126-99126-0841-00042-00042-00000-DBCOLE6\n//ASMBPT   JOB (CSW,UPS),'540-456-8536',CLASS=A,MSGCLASS=D,\n//             MSGLEVEL=(1,1),NOTIFY=R9999,TIME=1439\n//*\n//*\n//***********************************************************\n//*                                                         *\n//*      SAMPLE JCL TO ASSEMBLE AND LINKEDIT THE BLKSPTRK   *\n//*      PROGRAM.                                           *\n//*                                                         *\n//***********************************************************\n//*\n//ASM     EXEC PGM=ASMA90,REGION=0M,\n// PARM='TERM,TEST,OBJECT,NODECK,LINECOUNT(109),RENT' <====LINECOUNT===\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//*\n//***********************************************************\n//*                                                         *\n//* THE FOLLOWING MACLIB IS AVAILABLE FROM WWW.COLESOFT.COM *\n//*                                                         *\n//         DD  DSN=DBCOLE.MACLIB,DISP=SHR <======================DSN===\n//*                                                         *\n//***********************************************************\n//*\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=DISK,SPACE=(CYL,(15,5)),\n//             DISP=(,PASS)\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJSET,UNIT=DISK,SPACE=(CYL,(1,1),RLSE),\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DSN=DBCOLE.EXPORT.BLKSPTRK(BLKSPTRK),DISP=SHR <===DSN===\n//*\n//LKED    EXEC PGM=IEWL,REGION=1024K,\n//             PARM='RENT,TEST,XREF,LET,LIST,NCAL',\n//             COND=(0,LT)\n//SYSLMOD  DD  DSN=DBCOLE.LOAD,DISP=SHR <========================DSN===\n//SYSUT1   DD  DSN=&&SYSUT1,DISP=(OLD,DELETE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJSET,DISP=(OLD,DELETE)\n//SKIPTHIS DD  *\n         ALIAS BPT\n         NAME  BLKSPTRK(R)\n./ ADD NAME=BLKSPTRK 0100-99126-99126-0831-01190-01190-00000-DBCOLE6\nBPT      TITLE 'BLKSPTRK -- PHYSICAL BLOCKS PER DASD TRACK CALCULATER'\n************************************************************* 11/84 DBC\n*                                                           * 11/84 DBC\n* MODULE NAME = BLKSPTRK.                                   * 11/84 DBC\n*                                                           * 11/84 DBC\n* DESCRIPTIVE NAME = PHYSICAL BLOCKS PER DASD TRACK         * 11/84 DBC\n*                    CALCULATOR.                            * 11/84 DBC\n*                                                           * 11/84 DBC\n* STATUS = RELEASE 9707.                                    * 07/97 DBC\n*                                                           * 11/84 DBC\n* FUNCTION = A TSO COMMAND THAT DISPLAYS TRACK CAPACITIES   * 11/84 DBC\n*            FOR ANY SET OF DASD DEVICES, FOR ANY GIVEN     * 11/84 DBC\n*            COMBINATION OF KEY LENGTHS, BLOCK SIZES,       * 11/84 DBC\n*            AND/OR BLOCK COUNTS.                           * 11/84 DBC\n*                                                           * 11/84 DBC\n* PROCESSOR = OS/VS ASSEMBLER.                              * 11/84 DBC\n*                                                           * 11/84 DBC\n* TYPE = TSO COMMAND PROCESSOR.                             * 11/84 DBC\n*                                                           * 11/84 DBC\n* ATTRIBUTES = REENTRANT, REFRESHABLE, REUSABLE.            * 11/84 DBC\n*                                                           * 11/84 DBC\n* AUTHOR = DAVID B. COLE.                                   * 11/84 DBC\n*                                                           * 11/84 DBC\n************************************************************* 11/84 DBC\n*                                                           * 07/97 DBC\n* This program is copyrighted (c) 1997 by David B. Cole.    * 07/97 DBC\n*                                                           * 07/97 DBC\n* This program is distributed freely and may be reproduced  * 07/97 DBC\n* and redistributed without restriction other than:         * 07/97 DBC\n*   - This copyright and usage/warranty/liability           * 07/97 DBC\n*     restriction statement (\"Legal Statement\") may not be  * 07/97 DBC\n*     modified or removed.                                  * 07/97 DBC\n*   - A similar Legal Statement located in this program's   * 07/97 DBC\n*     Online Help file may not be removed.                  * 07/97 DBC\n*   - This program's Online Help File must be installed in  * 07/97 DBC\n*     a suitable \"help library\" (such as SYS1.HELP) so that * 07/97 DBC\n*     users may see both the Legal Statement as well as     * 07/97 DBC\n*     usage instruction.                                    * 07/97 DBC\n*                                                           * 07/97 DBC\n* This program is distributed without warranty of any kind, * 07/97 DBC\n* including (without limitation) warranties of              * 07/97 DBC\n* merchantability and of fitness for a particular purpose.  * 07/97 DBC\n* It is up to the user to make his own determination of the * 07/97 DBC\n* usefulness of this program in his own system.             * 07/97 DBC\n*                                                           * 07/97 DBC\n* The user agrees not to hold me ( David B. Cole) liable    * 07/97 DBC\n* for any damage whatsoever, and the user agrees to         * 07/97 DBC\n* indemnify me against third parties for any action arising * 07/97 DBC\n* from the user's use, modification, and/or redistribution  * 07/97 DBC\n* of this program.                                          * 07/97 DBC\n*                                                           * 07/97 DBC\n* This program may be modified freely so long as all        * 07/97 DBC\n* modifications are clearly marked both internally and      * 07/97 DBC\n* externally to distinguish them from the distributed code  * 07/97 DBC\n* and functionallity.                                       * 07/97 DBC\n*                                                           * 07/97 DBC\n* As a courtesy, please notify me if you discover any bugs  * 07/97 DBC\n* or if you need or have made any code changes. (I of       * 07/97 DBC\n* of course do not guarantee either that I will or that I   * 07/97 DBC\n* will not make any future changes or corrections.)         * 07/97 DBC\n*                                                           * 07/97 DBC\n* My contact information as of JUL97 is:                    * 07/97 DBC\n*                                                           * 07/97 DBC\n*     Name:                David B. Cole                    * 07/97 DBC\n*     Country:             USA                              * 07/97 DBC\n*     Telephone:           540-456-8536                     * 07/97 DBC\n*     FAX:                 540-456-6658                     * 07/97 DBC\n*     E-mail:              davidbcole@aol.com               * 07/97 DBC\n*     Website:             www.colesoft.com                 * 07/97 DBC\n*                                                           * 07/97 DBC\n*     Snail Mail:          Cole Software                    * 07/97 DBC\n*                          736 Fox Hollow Road              * 07/97 DBC\n*                          Afton, VA 22920                  * 07/97 DBC\n*                          USA                              * 07/97 DBC\n*                                                           * 07/97 DBC\n************************************************************* 07/97 DBC\n         EJECT ,                                              07/97 DBC\n************************************************************* 11/84 DBC\n*                                                           * 11/84 DBC\n* ENTRY POINT = BLKSPTRK.                                   * 11/84 DBC\n*                                                           * 11/84 DBC\n* ALIAS NAME = BPT.                                         * 11/84 DBC\n*                                                           * 11/84 DBC\n* COMMAND FORMAT = BLKSPTRK (<DEVTYPE> ...)                 * 11/84 DBC\n*                  KEYLEN(<KEY_LENGTH> ...)                 * 11/84 DBC\n*                  BLKSIZE(<BLOCK_SIZE>|#<BLOCK_COUNT>|0 ...) 11/84 DBC\n*                                                           * 11/84 DBC\n* ANY NUMBER OF DEVICE TYPES, KEY LENGTHS AND BLOCK SIZES   * 11/84 DBC\n* MAY BE GIVEN. A MATRIX IS DISPLAYED SHOWING TRACK         * 11/84 DBC\n* CAPACITIES FOR ALL COMBINATIONS OF THE GIVEN PARAMETERS.  * 11/84 DBC\n*                                                           * 11/84 DBC\n* THE KEYLEN PARAMETER CAN BE OMITTED IN WHICH CASE THE     * 11/84 DBC\n* TRACK CAPACITIES WILL BE CALCULATED FOR BLOCKS WITHOUT    * 11/84 DBC\n* KEYS. EQUIVALENTLY, KEYLEN(0) MAY BE GIVEN.               * 11/84 DBC\n*                                                           * 11/84 DBC\n* THE BLKSIZE PARAMETER ALSO CAN BE OMITTED IN WHICH CASE   * 11/84 DBC\n* THE SIZE OF THE LARGEST BLOCK (CONSIDERING THE GIVEN OR   * 11/84 DBC\n* OMITTED KEY LENGTH(S)) THAT CAN BE CONTAINED ON A TRACK   * 11/84 DBC\n* IS DISPLAYED FOR EACH DEVICE TYPE REQUESTED.              * 11/84 DBC\n* EQUIVALENTLY, BLKSIZE(0) MAY BE GIVEN.                    * 11/84 DBC\n*                                                           * 11/84 DBC\n* IF A BLKSIZE VALUE IS GIVEN AS #N (E.G., #6), THEN IT IS  * 11/84 DBC\n* INTERPRETED AS A BLOCK COUNT INSTEAD OF A BLOCK SIZE. IN  * 11/84 DBC\n* THIS CASE THE BLOCK SIZE DISPLAYED WILL BE THE LARGEST    * 11/84 DBC\n* FOR WHICH N BLOCKS CAN FIT ON A TRACK FOR EACH DEVICE     * 11/84 DBC\n* TYPE REQUESTED (TAKING INTO CONSIDERATION KEY LENGTH      * 11/84 DBC\n* VALUES, IF ANY).                                          * 11/84 DBC\n*                                                           * 11/84 DBC\n************************************************************* 11/84 DBC\n*                                                           * 07/97 DBC\n*  Last Change Date - 07/10/97                              * 07/97 DBC\n*                                                           * 07/97 DBC\n*  Reorganized the device data tables and removed unused    * 07/97 DBC\n*  fields.                                                  * 07/97 DBC\n*                                                           * 07/97 DBC\n*  Added support for 3390, 3995, and 9345 devices.          * 07/97 DBC\n*                                                           * 07/97 DBC\n*  Corrected the residue calculations for all devices.      * 07/97 DBC\n*                                                           * 07/97 DBC\n*  Corrected block count calculations for 2311, 2314, and   * 07/97 DBC\n*  2321 devices (devices that use tolerance factors).       * 07/97 DBC\n*                                                           * 07/97 DBC\n************************************************************* 07/97 DBC\n         EJECT ,\nBLKSPTRK START ,\nBPT      EQU   BLKSPTRK            ALIAS NAME\n         SPACE 3\n         #REGS R                   STANDARD REGISTER EQUATES\n         EJECT\n************************************************************* 07/97 DBC\n* Track calculation data for all IBM dasd devices.          * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\nCONSTANT DSECT ,                   DEVICE DESCRIPTIVE DATA\nTRKCAP   DS    HL2                 TRACK CAPACITY.            07/97 DBC\nFLAG     DS    B                   CONTROL FLAGS              07/97 DBC\nDVC2BOV  EQU   X'08'               OVERHEAD IS SINGLE HALFWORD\nDVCCELLS EQU   X'10'               DEVICE IS CELLULAR         11/84 DBC\nDVCFTOL  EQU   X'01'               DEVICE USES TOLERENCE FACTOR\nFORMULA2 EQU   X'02'               CALCULATE TRACK CAPACITIES 07/97 DBC\n*                                  USING \"FORMULA 2\".         07/97 DBC\n         SPACE 1                                              07/97 DBC\nFACTORS  DS    0X                  MISC CALCULATION FACTORS   07/97 DBC\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* The following fields contain overhead data and factors    * 07/97 DBC\n* for noncellular devices.                                  * 07/97 DBC\n************************************************************* 07/97 DBC\n         ORG   FACTORS                                        07/97 DBC\nROVRHD   DS    XL3                 RECORD OVERHEAD.           07/97 DBC\nTOLER    DS    HL2                 TOLERANCE FACTOR.          07/97 DBC\n         DS    X                   RESERVED                   07/97 DBC\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* The following fields contain overhead data and factors    * 07/97 DBC\n* for early cellular devices (3375 and 3380).               * 07/97 DBC\n************************************************************* 07/97 DBC\n         ORG   FACTORS                                        07/97 DBC\nDCELLSIZ DS    X                   DEVICE'S CELL SIZE         07/97 DBC\nD3380CO  DS    HL2                 COUNT AREA OVERHEAD        07/97 DBC\nD3380KDO DS    HL2                 KEY OR DATA AREA OVERHEAD  07/97 DBC\n         DS    X                   RESERVED                   07/97 DBC\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* The following fields contain overhead data and factors    * 07/97 DBC\n* for later cellular devices (3390 and later). The          * 07/97 DBC\n* calculation formula is based on information found in \"IBM * 07/97 DBC\n* 3990 Storage Control Reference\" (GA32-0099-05). The       * 07/97 DBC\n* formula is:                                               * 07/97 DBC\n*   ((DL+F6+(F5*2-1)/(F5*2)*F4+F6+DL+(F1-1))/F1+F2)*F1      * 07/97 DBC\n*  +(((KL+F6+(F5*2-1)/(F5*2)*F4+F6+DL+(F1-1))/F1+F3)*F1)    * 07/97 DBC\n*   *(KL<>0)                                                * 07/97 DBC\n* where:                                                    * 07/97 DBC\n*   - DL = l'data                                           * 07/97 DBC\n*   - KL = l'key                                            * 07/97 DBC\n*   - F1, ..., F6 are factors given by the \"Read Device     * 07/97 DBC\n*     Characteristics\" CCW and are as documented in         * 07/97 DBC\n*     GA32-0099.                                            * 07/97 DBC\n*   - All divisions truncate the remainder.                 * 07/97 DBC\n* Basically, this formula means:                            * 07/97 DBC\n*   - The minimum allocation unit is a \"cell\" whose size is * 07/97 DBC\n*     F1 bytes.                                             * 07/97 DBC\n*   - The count area and its leading gap requires F2-F3     * 07/97 DBC\n*     cells.                                                * 07/97 DBC\n*   - The gaps in front of key areas (if any) and data      * 07/97 DBC\n*     areas each require F3 cells.                          * 07/97 DBC\n*   - If no key is given, then no overhead is taken for it. * 07/97 DBC\n*   - Data within key areas and data areas have an overhead * 07/97 DBC\n*     of:                                                   * 07/97 DBC\n*       - F6 bytes per area,                                * 07/97 DBC\n*       - Plus F4 bytes for every F5*2 bytes of data.       * 07/97 DBC\n*     Presumedly, this overhead is ECC overhead of some     * 07/97 DBC\n*     sort.                                                 * 07/97 DBC\n************************************************************* 07/97 DBC\n         ORG   FACTORS                                        07/97 DBC\n         DS    X                   DCELLSIZ (\"F1\" FACTOR)     07/97 DBC\nD3390F2  DS    X                   CNT+DATA OVERHEAD (CELLS)  07/97 DBC\nD3390F3  DS    X                   KEY OVERHEAD (CELLS)       07/97 DBC\nD3390F4  DS    X                   ECC(?) OHEAD MULTIPLIER    07/97 DBC\nD3390F5  DS    X                   ECC(?) OHEAD DIVISOR/2     07/97 DBC\nD3390F6  DS    X                   ECC(?) OHEAD INCRIMENT     07/97 DBC\n         SPACE 1                                              07/97 DBC\n         ORG   ,                   RELOCATE HIGH              07/97 DBC\nKDEVSIZE EQU   *-CONSTANT          DDD ENTRY SIZE\n         SPACE 3\n         IKJCPPL ,                 COMMAND PROCESSOR PARAMETER LIST\n         SPACE 3\n         IKJPPL ,                  PARSE PARAMETER LIST\nPPLLEN   EQU   *-PPL               LIST LENGTH\n         EJECT\n         #DSA  ,                   DATA STORAGE AREA\nDSAWORK  DS    D                   WORK AREA\nDSABUFF  DS    CL80                MESSAGE BUFFER AND WORK AREA\nDSAECB   DS    A                   ECB USED BY PARSE\nDSAPDL   DS    A                   PARSE PARAMETER DESCRIPTER LIST PTR\n         DS    0A\nDSAPPL   DS    XL(PPLLEN)          PARSE PARAMETER LIST\nSAVC3390 DS    10A                 RSA FOR CPA3390            07/97 DBC\nSAVOBPT  DS    5A                  RSA FOR OLDBPT             07/97 DBC\nDSALEN   EQU   *-DSA               DSA LENGTH\n         EJECT\nBLKSPTRK #ENTER SAVTYPE=(RENT,DSALEN) STANDARD REENTRANT ENTRY LINKAGE\n         LR    R11,R13             COPY DSA PTR\n         USING DSA,R11             DECLARE DSA BASE\n         SPACE 3\n*        INITIALIZE A PARAMETER LIST FOR PARSE AND THEN LINK TO IT\n         SPACE 1\n         LR    R2,R1               GET THE CPPL POINTER\n         USING CPPL,R2             DECLARE A BASE FOR IT\n         LA    R1,DSAPPL           POINT TO THE PPL\n         USING PPL,R1              DECLARE A BASE FOR IT\n         L     R0,CPPLUPT          INITIALIZE -\n         ST    R0,PPLUPT            UPT POINTER\n         L     R0,CPPLECT          INITIALIZE -\n         ST    R0,PPLECT            ECT POINTER\n         MVI   DSAECB,0            CLEAR AN ECB FOR PARSE\n         LA    R0,DSAECB           INITIALIZE -\n         ST    R0,PPLECB            ECB POINTER\n         L     R0,=V(PCL)          INITIALIZE -\n         ST    R0,PPLPCL            PCL POINTER\n         LA    R0,DSAPDL           INITIALIZE -\n         ST    R0,PPLANS            PDL POINTER POINTER\n         L     R0,CPPLCBUF         INITIALIZE -\n         ST    R0,PPLCBUF           CBUF POINTER\n         ST    R13,PPLUWA          INITIALIZE VLDTY CHK WA PTR\n         DROP  R2                  RELEASE CPPL BASE\n         DROP  R1                  RELEASE PPL BASE\n         LINK  EP=IKJPARS          PARSE THE INVOKING OPERANDS\n         LTR   R15,R15             PARSE OK?\n         BZ    PARSOK              YES, PROCEED\n         CVD   R15,DSAWORK         NO, CNVRT RC TO DECIMAL\n         UNPK  DSABUFF(2),DSAWORK+6(2) CNVRT TO EBCDIC\n         OI    DSABUFF+1,X'F0'     FIX THE FUCKING SIGN\n         LA    R4,DSABUFF          POINT TO EBCDIC RC\n         LA    R5,1                GET ITS MACHINE LENGTH\n         LA    R1,PARSFMSG-1       POINT TO ERROR MSG\n         LR    R3,R15              SAVE THE RC\n         BAL   R2,TPUTERRM         GO ISSUE THE ERROR MSG\n         LR    R15,R3              RESTORE THE RC\n         B     EXITGOOD            GO RETURN TO TMP\nPARSOK   EQU   *\n         SPACE 3\n************************************************************* 07/97 DBC\n* Display copyright, legal reference, and title messages.   * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LA    R1,=C' '                                       07/97 DBC\n         LA    R0,1                                           07/97 DBC\n         TPUT  (1),(0),R           SEND SPACER                07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LA    R1,COPYRIGH                                    07/97 DBC\n         LA    R0,L'COPYRIGH                                  07/97 DBC\n         TPUT  (1),(0),R           SEND COPYRIGHT STATEMENT   07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LA    R1,LEGALRF1                                    07/97 DBC\n         LA    R0,L'LEGALRF1                                  07/97 DBC\n         TPUT  (1),(0),R           SEND LEGAL REFERENCE MSG   07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LA    R1,LEGALRF2                                    07/97 DBC\n         LA    R0,L'LEGALRF2                                  07/97 DBC\n         TPUT  (1),(0),R           SEND REST OF LEGAL REF.    07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LA    R1,=C' '                                       07/97 DBC\n         LA    R0,1                                           07/97 DBC\n         TPUT  (1),(0),R           SEND SPACER                07/97 DBC\n         SPACE 1\n         LA    R1,TITLE            POINT TO TITLE\n         LA    R0,TITLEN           GET ITS LENGTH\n         TPUT  (1),(0),R           SEND IT\n         SPACE 3\n************************************************************* 07/97 DBC\n* Start a triple loop to display a matrix of the requested  * 07/97 DBC\n* data.                                                     * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\n         L     R3,DSAPDL           @'PARSE DESCRIPTOR LIST    07/97 DBC\n         LA    R3,PDLDEVT-PDL(,R3) PNT TO DEVICE PARAMETER    07/97 DBC\n*                                  CHAIN                      07/97 DBC\nDEVTLOOP CLI   0(R3),X'FF'         OMITTED VALUE?\n         BE    DEVTNEXT            YES, LOOP FOR NEXT\n         MVI   DSABUFF,C' '        NO, CLEAR MSG BUFFER\n         MVC   DSABUFF+1(TITLEN-1),DSABUFF\n         L     R1,0(,R3)           POINT TO DEVTYPE STRING\n         LH    R15,4(,R3)          GET ITS LENGTH\n         BCTR  R15,0               CONVERT TO MACHINE LENGTH\n         MVC   DSABUFF+TITDEVT(*-*),0(R1) (EXECUTED INSTRUCTION)\n         EX    R15,*-6             COPY TO MSG BUFFER\n         IC    R6,0(,R3)           GET THE DDD INDEX\n         N     R6,=X'0000007F'     ISSOLATE IT\n         MH    R6,=Y(KDEVSIZE)     CONVERT TO OFFSET\n         LA    R6,#(R6)            --> DEVICE DESCRIPTER DATA\n         USING CONSTANT,R6         DECLARE A BASE\n         SPACE 3\n         L     R5,DSAPDL           @'PARSE DESCRIPTOR LIST    07/97 DBC\n         LA    R5,PDLKEYL-PDL(,R5) POINT TO KEYLEN(S) CHAIN   07/97 DBC\nKEYLLOOP CLI   0(R5),X'FF'         OMITTED ENTRY?\n         BE    KEYLNEXT            YES, SKIP\n         MVC   DSABUFF+TITKEYL(3),=X'202120' NO, EDIT MASK\n         L     R10,0(,R5)          GET KEYLENGTH VALUE        07/97 DBC\n         CVD   R10,DSAWORK         CONVERT TO DECIMAL         07/97 DBC\n         ED    DSABUFF+TITKEYL-1(4),DSAWORK+6 CNVRT TO EBCDIC\n         SPACE 3\n************************************************************* 07/97 DBC\n* Capacity Calculation Loop: Extract the next BLKSIZE       * 07/97 DBC\n* paremeter and proceed according to whether it's a block   * 07/97 DBC\n* size or a block count.                                    * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\n         L     R4,DSAPDL           @'PARSE DESCRIPTOR LIST    07/97 DBC\n         LA    R4,PDLBLKS-PDL(,R4) PNT TO BLKSIZE(S) CHAIN    07/97 DBC\nBLKSLOOP CLC   0(4,R4),=4C'*'      OMITTED ENTRY?             07/97 DBC\n         BE    BLKSNEXT            YES, SKIP\n         MVC   DSABUFF+TITBLKS(5),=X'2020202120' NO, EDIT MASK\n         SPACE 1                                              07/97 DBC\n         ICM   R9,15,0(R4)         GET GIVEN BLKSIZE; DEFAULT WANTED?\n         BP    SIZGIVEN            NO, USE GIVEN VALUE        07/97 DBC\n         LA    R15,1               (TREAT \"0\" AS \"#1\")        11/84 DBC\n         BZ    CNTGIVEN            YES, PROCESS AS B(#1)      07/97 DBC\n         LPR   R15,R9              NO, GET N OF B(#N)         11/84 DBC\n         SPACE 3                                              07/97 DBC\n************************************************************* 07/97 DBC\n* The user has given a block count and wants to know what's * 07/97 DBC\n* the largest blksize that will yeald that block/track      * 07/97 DBC\n* count.                                                    * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              11/84 DBC\nCNTGIVEN SR    R9,R9               CLEAR                      07/97 DBC\n         ICM   R9,3,TRKCAP         YES, GET TRACK CAPACITY    11/84 DBC\n         SR    R7,R7               CLEAR\n         TM    FLAG,DVCCELLS       CELLULAR DEVICE?           11/84 DBC\n         BNZ   CNT3380             YES, USE NEWER FORMULAS    07/97 DBC\n         SPACE 1                                              11/84 DBC\n************************************************************* 07/97 DBC\n* Count calculation for pre-cellular devices.               * 07/97 DBC\n************************************************************* 07/97 DBC\n         LR    R1,R9               GET TRK CAPACITY           07/97 DBC\n         TM    FLAG,DVC2BOV        LB_OVHD = NLB_OVHD?        11/84 DBC\n         BNZ   DFLOHOK             YES, SKIP                  11/84 DBC\n         IC    R7,ROVRHD+1         GET LB_OVHD                11/84 DBC\n         SR    R1,R7               TAKE AWAY FROM TRK_CAP     07/97 DBC\n         IC    R7,ROVRHD           GET NLB_OVHD               11/84 DBC\n         AR    R1,R7               ADD TO TRK_CAP TO GET A    07/97 DBC\n*                                  \"VIRTUAL\" CAPACITY THAT    07/97 DBC\n*                                  PRETENDS THAT ALL BLOCKS   07/97 DBC\n*                                  HAVE EQUAL OVERHEAD.       07/97 DBC\nDFLOHOK  DS    0H                                             07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R0,R0                                          07/97 DBC\n         DR    R0,R15              GET #'BYTES NEEDED PER RCD 07/97 DBC\n         LR    R9,R1               SAVE                       07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LTR   R10,R10             ARE RECORDS KEY'D?         07/97 DBC\n         BNZ   OLDKEYDZ            YES, SKIP                  07/97 DBC\n         IC    R7,ROVRHD+2         GET UNKEYED UNDERHEAD      07/97 DBC\n         ALR   R9,R7               ADD TO BYTES AVAILABLE FOR 07/97 DBC\n*                                  DATA AREA                  07/97 DBC\nOLDKEYDZ SR    R9,R10              DECRIMENT KL FROM SPACE    07/97 DBC\n*                                  AVAILABLE FOR THE DL.      07/97 DBC\n         SPACE 1                                              07/97 DBC\n         IC    R7,ROVRHD           GET NLB_OHEAD              07/97 DBC\n         TM    FLAG,DVC2BOV        IS OVERHEAD GIVEN AS TWO   07/97 DBC\n*                                  SINGLE BYTES?              07/97 DBC\n         BZ    OLDOHDOK            YES, PROCEED               07/97 DBC\n         ICM   R7,3,ROVRHD         GET OVERHEAD APPLICABLE TO 07/97 DBC\n*                                  ALL BLOCKS                 07/97 DBC\nOLDOHDOK SR    R9,R7               TAKE OVERHEAD AWAY FROM    07/97 DBC\n*                                  LENGTH AVAILABLE FOR       07/97 DBC\n*                                  A DATA AREA. IS THERE ANY  07/97 DBC\n*                                  ROOM LEFT FO A DARA AREA?  07/97 DBC\n         BP    OLDOHDZ             YES, PROCEED               07/97 DBC\n         LA    R9,1                NO, THE USER HAS GIVEN A   07/97 DBC\n*                                  BLOCK COUNT THAT IS MORE   07/97 DBC\n*                                  THAN CAN BE WRITTEN PER    07/97 DBC\n*                                  TRACK. LOAD DL=1 TO SHOW   07/97 DBC\n*                                  THE USER THE MAXIMUM       07/97 DBC\n*                                  NUMBER OF BLOCKS WRITABLE  07/97 DBC\n*                                  PER TRACK.                 07/97 DBC\nOLDOHDZ  DS    0H                                             07/97 DBC\n         SPACE 1                                              07/97 DBC\n         TM    FLAG,DVCFTOL        DOES A TOLERANCE FACTOR    07/97 DBC\n*                                  APPLY?                     07/97 DBC\n         BZ    SIZGIVEN            NO, MY NUMBERS ARE GOOD.   07/97 DBC\n         CLC   TOLER,=X'0200'      IS THE TOLERANCE FACTOR    07/97 DBC\n*                                  NULL?                      07/97 DBC\n         BE    SIZGIVEN            YES, AOK SO FAR.           07/97 DBC\n         LA    R0,1                GET A ONE                  07/97 DBC\n         CLR   R15,R0              WAS THE GIVEN BLKCNT=1?    07/97 DBC\n         BE    SIZGIVEN            YES, TOLERANCE FACTOR DOES 07/97 DBC\n*                                  NOT APPLY TO LAST BLK.     07/97 DBC\n         CLR   R9,R0               DID I DEVOLVE TO FORCING   07/97 DBC\n*                                  BLKSIZE=1?                 07/97 DBC\n         BE    SIZGIVEN            YES, STICK WITH THAT       07/97 DBC\n*                                  THOUGHT.                   07/97 DBC\n         SPACE 1                                              07/97 DBC\nOLDTOLLP BAL   R14,OLDBPT          DETERMINE THE BPT FIT FOR  07/97 DBC\n*                                  THE TRIAL DL (R9)          07/97 DBC\n         CLR   R1,R15              AS MANY AS THE USER ASKED  07/97 DBC\n*                                  FOR?                       07/97 DBC\n         BNL   SIZGIVEN            YES, GO WITH IT            07/97 DBC\n         BCT   R9,OLDTOLLP         DECRIMENT DL AND TRY AGAIN 07/97 DBC\n         LA    R9,1                DEVOLVE TO DISPLAYING DL=1 07/97 DBC\n         B     SIZGIVEN            DONE HERE                  07/97 DBC\n         SPACE 1                                              11/84 DBC\n************************************************************* 07/97 DBC\n* Count calculation for early cellular devices (3375s and   * 07/97 DBC\n* 3380s).                                                   * 07/97 DBC\n************************************************************* 07/97 DBC\nCNT3380  IC    R7,DCELLSIZ         GET CELL SIZE              07/97 DBC\n         LR    R1,R9               GET TRKCAP                 11/84 DBC\n         SR    R0,R0               CLEAR                      11/84 DBC\n         DR    R0,R7               GET # CELLS AVAILABLE      11/84 DBC\n         SR    R0,R0               CLEAR                      11/84 DBC\n         DR    R0,R15              GET # CELLS AVAIL PER RCD  11/84 DBC\n         TM    FLAG,FORMULA2       USE \"FORMULA 2\"?           07/97 DBC\n         BNZ   CNT3390             YES, GO HANDLE             07/97 DBC\n         SPACE 1                                              07/97 DBC\n         MR    R0,R7               CNVRT BACK TO BYTES        11/84 DBC\n         LR    R9,R1               AND COPY BACK TO R9        11/84 DBC\n         SPACE 1                                              07/97 DBC\n         LTR   R1,R10              ANY KEYS?                  07/97 DBC\n         BZ    NWNOKYS1            NO, SKIP                   11/84 DBC\n         AH    R1,D3380KDO         YES, ADD KEY-AREA OVERHEAD 07/97 DBC\n         SR    R0,R0               CLEAR FOR DIVIDE           11/84 DBC\n         DR    R0,R7               GET # CELLS NEEDED         11/84 DBC\n         MR    R0,R7               CNVRT BACK TO ROUNDED UP   11/84 DBC\n*                                  BYTES                      11/84 DBC\n         SR    R9,R1               DECR SPACE FOR DATA        11/84 DBC\nNWNOKYS1 DS    0H                                             07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SH    R9,D3380CO          DECR FOR COUNT AREA OVHD   07/97 DBC\n         LR    R1,R9               COPY                       11/84 DBC\n         SR    R0,R0               CLEAR                      11/84 DBC\n         DR    R0,R7               GET # CELLS AVAILABLE FOR  11/84 DBC\n*                                  DATA AREA (+ OVERHEAD)     11/84 DBC\n         MR    R0,R7               CNVRT BACK TO ROUNDED DOWN 11/84 DBC\n*                                  BYTES                      11/84 DBC\n         AR    R1,R7               ADD IN SPACE IN THE REST - 11/84 DBC\n         BCTR  R1,0                 OF THE LAST CELL          11/84 DBC\n         SPACE 1                                              07/97 DBC\n         LA    R9,1                ASSUME MINIMUM BLKSIZE     07/97 DBC\n         SH    R1,D3380KDO         DECR DATA AREA OVERHEAD    07/97 DBC\n         BNP   SIZGIVEN            TOO MANY BLKS TO FIT. GO   07/97 DBC\n*                                  WITH MINIMUM BLKSIZE TO    07/97 DBC\n*                                  SHOW THE USER THE MOST     07/97 DBC\n*                                  BLKS HE CAN HAVE PER TRK.  07/97 DBC\n         LR    R9,R1               COPY BACK TO R9            11/84 DBC\n         B     SIZGIVEN            DONE HERE                  07/97 DBC\n         SPACE 1                                              11/84 DBC\n************************************************************* 07/97 DBC\n* Count calculation for later cellular devices (3390s and   * 07/97 DBC\n* later).                                                   * 07/97 DBC\n************************************************************* 07/97 DBC\nCNT3390  LR    R9,R1               SAVE #'CELLS NEEDED/RCD    07/97 DBC\n         LTR   R1,R10              KEYED RCDS?                07/97 DBC\n         BZ    NOKY3390            NO, SKIP                   07/97 DBC\n         BAL   R14,CPA3390         COMPUTE #'CELLS FOR KEY    07/97 DBC\n         SLR   R9,R1               #'CELLS LEFT FOR DATA+CNT  07/97 DBC\nNOKY3390 DS    0H                                             07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R1,R1                                          07/97 DBC\n         IC    R1,D3390F2          #'CELLS USED BY CNT+GAP    07/97 DBC\n         SLR   R9,R1               TAKE IT OUT                07/97 DBC\n         IC    R1,D3390F3          #'CELLS USED BY GAP        07/97 DBC\n         AR    R9,R1               ADD IT BACK IN TO GET      07/97 DBC\n*                                  #'CELLS AVAILABLE FOR      07/97 DBC\n*                                  DATA. ARE THERE ANY?       07/97 DBC\n         BNP   NODL3390            NO, USER ERROR.            07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LR    R2,R9               SAVE #'CELLS FOR DATA AREA 07/97 DBC\n         MR    R8,R7               CNVRT TO #'BYTES           07/97 DBC\nDLLP3390 LR    R1,R9               COPY TEST L'DATA           07/97 DBC\n         BAL   R14,CPA3390         FIGURE HOW MAY CELLS IT    07/97 DBC\n*                                  WILL NEED                  07/97 DBC\n         CLR   R1,R2               WOULD THAT DL FIT?         07/97 DBC\n         BNH   SIZGIVEN            YES, DONE HERE             07/97 DBC\n         BCT   R9,DLLP3390         LOOP TO TRY SMALLER DL     07/97 DBC\n         SPACE 1                                              07/97 DBC\nNODL3390 LA    R9,1                THE USER HAS GIVEN A BLOCK 07/97 DBC\n*                                  COUNT GREATER THAN THE     07/97 DBC\n*                                  MOST BLOCKS POSSIBLE PER   07/97 DBC\n*                                  TRK. LOAD MINIMUM BLKSIZE  07/97 DBC\n*                                  TO SHOW THE USER THE MAX   07/97 DBC\n*                                  POSSIBLE BLK COUNT.        07/97 DBC\n         SPACE 3                                              07/97 DBC\n************************************************************* 07/97 DBC\n* I (now) have a blksize. Calculate how many blocks of this * 07/97 DBC\n* size can fit per track.                                   * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\nSIZGIVEN CVD   R9,DSAWORK          CONVERT TO DECIMAL         07/97 DBC\n         ED    DSABUFF+TITBLKS-1(6),DSAWORK+5 CNVRT TO EBCDIC\n         SPACE 1                                              07/97 DBC\n         TM    FLAG,DVCCELLS       CELLULAR DEVICE?           11/84 DBC\n         BNZ   SIZ3380             YES, GO HANDLE             07/97 DBC\n         SPACE 1                                              11/84 DBC\n************************************************************* 07/97 DBC\n* Size calculation for pre-cellular devices.                * 07/97 DBC\n************************************************************* 07/97 DBC\n         BAL   R14,OLDBPT          GO CALCULATE               07/97 DBC\n         LR    R15,R1              GET BPT VALUE              07/97 DBC\n         LR    R14,R0              GET USABLE RESIDUE         07/97 DBC\n         B     GOTRESDU            PROCEED                    07/97 DBC\n         SPACE 1                                              11/84 DBC\n************************************************************* 07/97 DBC\n* Size calculation for early cellular devices (3375s and    * 07/97 DBC\n* 3380s).                                                   * 07/97 DBC\n************************************************************* 07/97 DBC\nSIZ3380  SR    R7,R7                                          07/97 DBC\n         IC    R7,DCELLSIZ         GET CELL SIZE              07/97 DBC\n         TM    FLAG,FORMULA2       USE \"FORMULA 2\"?           07/97 DBC\n         BNZ   SIZ3390             YES, GO HANDLE             07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LTR   R1,R9               GET DATALEN; EOF?          07/97 DBC\n         BNZ   NWNTEOF             NO, PROCEED                11/84 DBC\n         LR    R1,R7               YES, DATA AREA STILL TAKES 11/84 DBC\n*                                  A CELL                     11/84 DBC\nNWNTEOF  DS    0H                                             07/97 DBC\n         SPACE 1                                              07/97 DBC\n         AH    R1,D3380KDO         ADD DATA AREA OVERHEAD AND 07/97 DBC\n*                                  ROUND-UP INCRIMENT         07/97 DBC\n         SR    R0,R0               CLEAR                      11/84 DBC\n         DR    R0,R7               CNVRT TO CELL COUNT        11/84 DBC\n         LR    R9,R1               SAVE                       07/97 DBC\n         SPACE 1                                              11/84 DBC\n         LTR   R15,R10             COPY KEYLEN; ANY?          07/97 DBC\n         BZ    NWNOKYS2            NO, SKIP                   11/84 DBC\n         AH    R15,D3380KDO        ADD OVERHEAD & ROUND-UP    07/97 DBC\n*                                  INCRIMENT                  07/97 DBC\n         SR    R14,R14                                        07/97 DBC\n         DR    R14,R7              CNVRT TO CELL COUNT        11/84 DBC\n         ALR   R1,R15              ACCUMULATE                 07/97 DBC\nNWNOKYS2 LR    R0,R15              SAVE KEY CELL CNT (OR 0)   07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LH    R15,D3380CO         GET COUNT AREA OHEAD       07/97 DBC\n         ALR   R15,R7              PREPATE TO -               07/97 DBC\n         BCTR  R15,0                ROUND UP                  07/97 DBC\n         SLR   R14,R14                                        07/97 DBC\n         DR    R14,R7              CNVRT OHEAD TO CELL CNT    07/97 DBC\n         ALR   R0,R15              ACCUMULATE                 07/97 DBC\n         SPACE 1                                              07/97 DBC\n         ALR   R1,R15              GET THE TOTAL #'CELLS      07/97 DBC\n*                                  NEEDED FOR THE RECORD.     07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SR    R15,R15             CLEAR                      11/84 DBC\n         ICM   R15,3,TRKCAP        GET L'TRACK                11/84 DBC\n         SLR   R14,R14                                        07/97 DBC\n         DR    R14,R7              GET #'CELLS/TRACK          07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R14,R14                                        07/97 DBC\n         DR    R14,R1              R15 = #'RECORDS/TRACK      07/97 DBC\n*                                  R14 = #'CELLS LEFT OVER    07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SR    R14,R0              DECRIMENT RESIDUE BY       07/97 DBC\n*                                  #'CELLS NEEDED FOR COUNT   07/97 DBC\n*                                  AND KEY (IF ANY). ARE      07/97 DBC\n*                                  THERE ANY CELLS LEFT FOR   07/97 DBC\n*                                  DATA?                      07/97 DBC\n         BNP   NORD3380            NO, NO USABLE RESIDUE      07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LR    R1,R9               @'DATA CELLS               07/97 DBC\n         MR    R0,R7               @'DATE BYTES (INCL OHEAD)  07/97 DBC\n         LR    R8,R1               SAVE                       07/97 DBC\n         SPACE 1                                              07/97 DBC\nFIGR3380 LR    R1,R8               COPY PROPOSED DL           07/97 DBC\n         AH    R1,D3380KDO         ADD OHEAD + ROUND-UP       07/97 DBC\n         SLR   R0,R0                                          07/97 DBC\n         DR    R0,R7               CNVRT TO CELLS             07/97 DBC\n         CLR   R1,R14              WILL THIS DL FIT WITHIN    07/97 DBC\n*                                  THE RESIDUE?               07/97 DBC\n         BNH   RDUE3380            YES, GREAT!                07/97 DBC\n         BCT   R8,FIGR3380         TRY SMALLER DL             07/97 DBC\n         SPACE 1                                              07/97 DBC\nNORD3380 SLR   R14,R14             THERE IS NO USEFUL RESIDUE 07/97 DBC\n         B     GOTRESDU            GO DISPLAY                 07/97 DBC\nRDUE3380 LR    R14,R8              GET LARGEST FITTING DL     07/97 DBC\n         B     GOTRESDU            GO DISPLAY                 07/97 DBC\n         SPACE 1                                              11/84 DBC\n************************************************************* 07/97 DBC\n* Size calculation for later cellular devices (3390s and    * 07/97 DBC\n* later).                                                   * 07/97 DBC\n************************************************************* 07/97 DBC\nSIZ3390  LTR   R1,R9               L'DATA REQ'D; EOF RECORD?  07/97 DBC\n         BNZ   EOFZ3390            NO, PROCEED                07/97 DBC\n         LR    R1,R7               EOF'S STILL NEED A CELL    07/97 DBC\nEOFZ3390 BAL   R14,CPA3390         #'CELLS FOR DATA AREA      07/97 DBC\n         LR    R9,R1               SAVE                       07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LTR   R1,R10              KEY'D RCDS?                07/97 DBC\n         BZ    NOKZ3390            NO, SKIP                   07/97 DBC\n         BAL   R14,CPA3390         COMPUTE #'CELLS NEEDED     07/97 DBC\n         ALR   R9,R1               ADD IT IN                  07/97 DBC\nNOKZ3390 LR    R8,R1               SAVE #'CELLS FOR KEY AREA  07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R0,R0                                          07/97 DBC\n         SLR   R1,R1                                          07/97 DBC\n         IC    R1,D3390F2          #'CELLS FOR CNT+GAP        07/97 DBC\n         IC    R0,D3390F3          #'CELLS FOR GAP ONLY       07/97 DBC\n         SLR   R1,R0               #'CELLS FOR CNT ONLY       07/97 DBC\n         ALR   R9,R1               ADD IN TO GET #'CELLS      07/97 DBC\n*                                  NEEDED PER RECORD          07/97 DBC\n         ALR   R8,R1               ACCUMULATE #'NON-DATA-AREA 07/97 DBC\n*                                  CELLS PER RECORD           07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R15,R15                                        07/97 DBC\n         ICM   R15,3,TRKCAP        #'BYTES/TRK                07/97 DBC\n         SLR   R14,R14                                        07/97 DBC\n         DR    R14,R7              #'CELLS/TRK                07/97 DBC\n         SLR   R14,R14                                        07/97 DBC\n         DR    R14,R9              R15 = #'BLKS/TRK           07/97 DBC\n*                                  R14 = #'CELLS RESIDUE      07/97 DBC\n         LR    R9,R14              SAVE                       07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R14,R14             ASSUME NO USEFUL RESIDUE   07/97 DBC\n         SR    R9,R8               DECR L'RESIDUE BY #'NON-   07/97 DBC\n*                                  DATA-AREA CELLS PER RCD.   07/97 DBC\n*                                  IS THE RESIDUE BIG ENOUGH  07/97 DBC\n*                                  TO ALLOW A DATA AREA?      07/97 DBC\n         BNP   GOTRESDU            NO, DONE HERE              07/97 DBC\n         SPACE 1                                              07/97 DBC\n         LR    R1,R9               #'CELLS IN RESIDUE THAT    07/97 DBC\n*                                  ARE AVAILABLE FOR A DATA   07/97 DBC\n*                                  AREA                       07/97 DBC\n         MR    R0,R7               CNVRT TO BYTES             07/97 DBC\n         LR    R8,R1               SAVE                       07/97 DBC\nRDUE3390 LR    R1,R8               GET TEST BLKSIZE           07/97 DBC\n         BAL   R14,CPA3390         CNVRT 2 DATA AREA CELL CNT 07/97 DBC\n         CR    R1,R9               WILL FIT INTO RESIDUE?     07/97 DBC\n         BNH   GRDU3390            YES, GOT IT!               07/97 DBC\n         BCT   R8,RDUE3390         NO, TRY NEXT SMALLER BSIZE 07/97 DBC\n         SLR   R14,R14             RESIDUE NOT LARGE ENUF TO  07/97 DBC\n*                                  BE USEFUL                  07/97 DBC\n         B     GOTRESDU            DONE HERE                  07/97 DBC\nGRDU3390 LR    R14,R8              SAVE MAX BLKSIZE THAT WILL 07/97 DBC\n*                                  FIT INTO THE RESIDUE       07/97 DBC\n         SPACE 3                                              07/97 DBC\n************************************************************* 07/97 DBC\n* R15 now contains the number of blocks (of the given size) * 07/97 DBC\n* that will fit on a track. R14 contains the largest        * 07/97 DBC\n* additional block size that can fit on the same track. I   * 07/97 DBC\n* can now display this information, then loop to compute    * 07/97 DBC\n* the next set of numbers.                                  * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\nGOTRESDU MVC   DSABUFF+TITRSDU(5),=X'2020202120' EDIT MASK\n         CVD   R14,DSAWORK         CNVRT RESIDUE TO DECIMAL\n         ED    DSABUFF+TITRSDU-1(6),DSAWORK+5 CNVRT TO EBCDIC\n         MVC   DSABUFF+TITBPT(5),=X'2020202120' GET EDIT MASK 11/84 DBC\n         CVD   R15,DSAWORK         CNVRT BPT TO DECIMAL       11/84 DBC\n         ED    DSABUFF+TITBPT-1(6),DSAWORK+5 CNVRT TO EBCDIC  11/84 DBC\n         SPACE 3\n         LA    R1,DSABUFF          POINT TO MESSAGE\n         LA    R0,TITLEN           GET ITS LENGTH\n         TPUT  (1),(0),R           SEND THE MESSAGE\n         SPACE 3\n************************************************************* 07/97 DBC\n* Several loops bottom out here. Loop until done.           * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\nBLKSNEXT ICM   R4,7,9(R4)          NO, CHAIN TO NEXT BLKSIZE; ANY?\n         BNZ   BLKSLOOP            YES, LOOP TO PROCESS\nKEYLNEXT ICM   R5,7,9(R5)          CHAIN TO NEXT KEYLEN; ANY?\n         BNZ   KEYLLOOP            YES, LOOP TO PROCESS\n         DROP  R6                  DONE W/CONSTANT BASE       07/97 DBC\nDEVTNEXT ICM   R3,7,9(R3)          NO, CHAIN TO NEXT DEVICE TYPE; ANY?\n         BNZ   DEVTLOOP            YES, LOOP TO PROCESS\n         SPACE 3\n************************************************************* 07/97 DBC\n* All done. return to caller.                               * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SR    R15,R15             SET AOK RC\nEXITGOOD #EXIT ((R14,R12)),RC=(R15) RETURN TO TMP\n         EJECT ,                                              07/97 DBC\n************************************************************* 07/97 DBC\n*                                                           * 07/97 DBC\n* OLDBPT -- This routine computes the number of blocks of   * 07/97 DBC\n* a given size that can fit on a track for non-cellular     * 07/97 DBC\n* dasd devices.                                             * 07/97 DBC\n*                                                           * 07/97 DBC\n* It also determines the largest additional block that      * 07/97 DBC\n* can fit following the equal-size blocks.                  * 07/97 DBC\n*                                                           * 07/97 DBC\n* INPUTS:                                                   * 07/97 DBC\n*   - R6 points to the CONSTANT entry for the dasd device   * 07/97 DBC\n*     in question.                                          * 07/97 DBC\n*   - R9 contains a data area length (BLKSIZE).             * 07/97 DBC\n*   - R10 contains a key length or equals 0.                * 07/97 DBC\n*   - R14 points back to my caller.                         * 07/97 DBC\n*                                                           * 07/97 DBC\n* RETURN 0(,R14):                                           * 07/97 DBC\n*   - R1 contains the computed blocks/track number.         * 07/97 DBC\n*   - R0 contains the usable track residue.                 * 07/97 DBC\n*   - All other registers are restored.                     * 07/97 DBC\n*                                                           * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\n         USING CONSTANT,R6         DCL DASD CONSTANTS BASE    07/97 DBC\nOLDBPT   STM   R14,R2,SAVOBPT      SAVE REGISTERS             07/97 DBC\n         SR    R2,R2               CLEAR FOR \"IC\"'S           07/97 DBC\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* Setup R0 for computing the not-last-block size, and R1    * 07/97 DBC\n* for computing the last-block size.                        * 07/97 DBC\n************************************************************* 07/97 DBC\n         LA    R1,0(R10,R9)        GET KEYLEN+BLKSIZE         07/97 DBC\n         LR    R0,R1               COPY FOR NOT-LAST-BLOCK\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* If appropriate, apply a tolerance factor to all           * 07/97 DBC\n* not-last-blocks.                                          * 07/97 DBC\n************************************************************* 07/97 DBC\n         TM    FLAG,DVCFTOL        APPLY TOLERANCE FACTOR TO \u00acLAST-BLK?\n         BZ    NTOLF               NO, SKIP\n         MH    R0,TOLER            YES, DO SO\n         SRL   R0,9                DROP THE FRACTION\nNTOLF    DS    0H                                             07/97 DBC\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* If the blocks are unkeyed, then apply an underhead to     * 07/97 DBC\n* both not-last-blocks and last-blocks.                     * 07/97 DBC\n************************************************************* 07/97 DBC\n         LTR   R10,R10             ANY KEY?                   07/97 DBC\n         BNZ   GOTOVNK             YES, SKIP KEY-UNDERHEAD    07/97 DBC\n         IC    R2,ROVRHD+2         NO, GET UNDERHEAD VALUE    07/97 DBC\n         SR    R0,R2               ADJUST NOT-LAST-BLOCK      07/97 DBC\n         SR    R1,R2               ADJUST LAST-BLOCK          07/97 DBC\nGOTOVNK  DS    0H                                             07/97 DBC\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* Apply possibly differing overheads to not-last-blocks and * 07/97 DBC\n* last-blocks.                                              * 07/97 DBC\n************************************************************* 07/97 DBC\n         IC    R2,ROVRHD           ASSUME NOT 2305            07/97 DBC\n         TM    FLAG,DVC2BOV        OVERHEAD IS 2 BYTES?\n         BZ    GOTNLB              NO, GOT NOT-LAST-BLOCK OVERHEAD\n         ICM   R2,3,ROVRHD         GET ANY-BLOCK-OVERHEAD     07/97 DBC\nGOTNLB   AR    R0,R2               ADD NOT-LAST-BLOCK OHEAD   07/97 DBC\n         SPACE 1                                              07/97 DBC\n         TM    FLAG,DVC2BOV        2305, ETC.?\n         BO    GOTLB               YES, GOT ANY-BLOCK-OVERHEAD\n         IC    R2,ROVRHD+1         NO, GET LAST-BLOCK OHEAD   07/97 DBC\nGOTLB    AR    R1,R2               GET LAST-BLOCK LENGTH      07/97 DBC\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* Compute the number of equal-size blocks that can fit on   * 07/97 DBC\n* a track. Also, figure out the number of bytes remaining   * 07/97 DBC\n* following those blocks.                                   * 07/97 DBC\n************************************************************* 07/97 DBC\n         SR    R15,R15                                        07/97 DBC\n         ICM   R15,3,TRKCAP        GET L'TRACK                11/84 DBC\n         SR    R14,R14                                        07/97 DBC\n         DR    R14,R0              GET NOT-LAST-BLOCK COUNT   07/97 DBC\n         CR    R14,R1              ROOM FOR LAST BLOCK?\n         BNL   OLDADD1             YES, GO ADD ONE            07/97 DBC\n         ALR   R14,R0              ADJUST L'RESIDUE TO -      07/97 DBC\n         SLR   R14,R1               ACCOUNT FOR THE -         07/97 DBC\n*                                    SHORTNESS OF THE LAST -  07/97 DBC\n*                                     BLOCK.                  07/97 DBC\n         B     OLDEQULZ            PROCEED                    07/97 DBC\n         SPACE 1                                              07/97 DBC\nOLDADD1  LA    R15,1(,R15)         COUNT SHORT LAST BLOCK     07/97 DBC\n*                                  (SHORT DUE ONLY TO         07/97 DBC\n*                                  OVERHEAD DIFFERENCES)      07/97 DBC\n         SR    R14,R1              REMOVE FROM RESIDUE        07/97 DBC\nOLDEQULZ DS    0H                                             07/97 DBC\n         SPACE 1                                              11/84 DBC\n************************************************************* 07/97 DBC\n* Now, compute the BLKSIZE (DL) of the largest additional   * 07/97 DBC\n* block that can still fit into the track's residue. The    * 07/97 DBC\n* formula is: R14+(R1-R0)-(R1-R9), which reduces to         * 07/97 DBC\n* R14-(R0-R9). Where:                                       * 07/97 DBC\n*    EO-TRK---------------------------------------------+   * 07/97 DBC\n*    R14------------------------------------------++++++\u00a6   * 07/97 DBC\n*    R1------------------------------------+++++++\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6   * 07/97 DBC\n*    R0---------+++++++++++                \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6   * 07/97 DBC\n*               \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6                \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6   * 07/97 DBC\n*               -----------                \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6   * 07/97 DBC\n*    R9-----------+++                      \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6   * 07/97 DBC\n*    R10--------++\u00a6\u00a6\u00a6                      \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6   * 07/97 DBC\n*    SO-TRK----+\u00a6\u00a6\u00a6\u00a6\u00a6                      \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6   * 07/97 DBC\n*              \u00a6\u00a6\u00a6---                      \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6------\u00a6   * 07/97 DBC\n*              \u00a6--                         -------      \u00a6   * 07/97 DBC\n*    TRACK---> \u00a6KKDDD------KKDDD------ ... KKDDD--______\u00a6   * 07/97 DBC\n*                                          -------          * 07/97 DBC\n*                                          \u00a6\u00a6\u00a6\u00a6\u00a6\u00a6\u00a6          * 07/97 DBC\n*    LAST-BLK------------------------------+++++++          * 07/97 DBC\n************************************************************* 07/97 DBC\n         SR    R14,R0              DECR RESIDUE BY THE KEY -  07/97 DBC\n         AR    R14,R9               AND OVERHEAD OF AN -      07/97 DBC\n*                                    ADDITIONAL NLB. THIS -   07/97 DBC\n*                                     YEALDS THE AMOUNT OF -  07/97 DBC\n*                                      THE RESIDUE THAT IS -  07/97 DBC\n*                                       AVAILABLE FOR USER -  07/97 DBC\n*                                        DATA. IS THERE -     07/97 DBC\n*                                         ENOUGH SPACE -      07/97 DBC\n*                                          LEFT?              07/97 DBC\n         BNM   OLDRET              YES, NEARLY DONE           07/97 DBC\n         SR    R14,R14             NO, CLEAR RESIDUE\n         SPACE 1                                              07/97 DBC\n************************************************************* 07/97 DBC\n* Done. Return to caller w/values in R0 and R1.             * 07/97 DBC\n************************************************************* 07/97 DBC\nOLDRET   ST    R15,SAVOBPT+12      RETURN BPT VIA R1          07/97 DBC\n         ST    R14,SAVOBPT+8       RETURN RESIDUE VIA R0      07/97 DBC\n         LM    R14,R2,SAVOBPT      RESTORE REGISTERS          07/97 DBC\n         BR    R14                 RETURN TO CALLER           07/97 DBC\n         DROP  R6                  DONE W/CONSTANT BASE       07/97 DBC\n         EJECT ,                                              07/97 DBC\n************************************************************* 07/97 DBC\n*                                                           * 07/97 DBC\n* CPA3390 -- This routine computes the number of cells      * 07/97 DBC\n* needed (on a 3390 or newer DASD) per data area or key     * 07/97 DBC\n* area. This includes all area overheads as well as the gap * 07/97 DBC\n* preceeding the area.                                      * 07/97 DBC\n*                                                           * 07/97 DBC\n* The computation does not include the number of cells      * 07/97 DBC\n* needed for a standard count field.                        * 07/97 DBC\n*                                                           * 07/97 DBC\n* This routine assumes that the gap and overhead            * 07/97 DBC\n* calculations required for key and data areas are the      * 07/97 DBC\n* same.                                                     * 07/97 DBC\n*                                                           * 07/97 DBC\n* INPUTS:                                                   * 07/97 DBC\n*   - R1 contains the area's size, in bytes.                * 07/97 DBC\n*   - R6 points to the current #-table entry, mapped by the * 07/97 DBC\n*     CONSTANT dsect.                                       * 07/97 DBC\n*   - R14 points back to my caller.                         * 07/97 DBC\n*                                                           * 07/97 DBC\n* RETURN 0(,R14):                                           * 07/97 DBC\n*   - R1 contains the number of cells required for an area  * 07/97 DBC\n*     containing the given number of bytes.                 * 07/97 DBC\n*   - All other registers are restored.                     * 07/97 DBC\n*                                                           * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\nCPA3390  STM   R14,R7,SAVC3390     SAVE REGISTERS             07/97 DBC\n         LR    R15,R1              COPY #'DATA (OR KEY) BYTES 07/97 DBC\n         LR    R7,R6               COPY @'CONSTANTS           07/97 DBC\n         USING CONSTANT,R7         DCL ITS BASE               07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R6,R6                                          07/97 DBC\n         IC    R6,D3390F6          ECC FIELD WIDTH            07/97 DBC\n         ALR   R15,R6              ACCUMULATE                 07/97 DBC\n         SLR   R5,R5                                          07/97 DBC\n         IC    R5,D3390F5          W/2'ECC PROTECTED AREA     07/97 DBC\n         ALR   R5,R5               W'ECC PROTECTED AREA       07/97 DBC\n         ALR   R15,R5              PREPARE TO -               07/97 DBC\n         BCTR  R15,0                ROUND UP                  07/97 DBC\n         SLR   R14,R14                                        07/97 DBC\n         DR    R14,R5              COMPUTE ECC'S RUNNING      07/97 DBC\n*                                  OVERHEAD                   07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R4,R4                                          07/97 DBC\n         IC    R4,D3390F4          ECC FIELD WIDTH            07/97 DBC\n         MR    R14,R4              ADJUST THE OVERHEAD        07/97 DBC\n         SPACE 1                                              07/97 DBC\n         ALR   R15,R6              ADD IN ECC FIXED OVERHEAD  07/97 DBC\n         SPACE 1                                              07/97 DBC\n         AL    R15,SAVC3390+12     ADD OVERHEAD TO DATA LEN   07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R1,R1                                          07/97 DBC\n         IC    R1,DCELLSIZ         DEVICE'S CELL SIZE         07/97 DBC\n         ALR   R15,R1              PREPARE TO -               07/97 DBC\n         BCTR  R15,0                ROUND UP                  07/97 DBC\n         SLR   R14,R14                                        07/97 DBC\n         DR    R14,R1              CONVERT BYTE LENGTH TO A   07/97 DBC\n*                                  CELL COUNT.                07/97 DBC\n         SPACE 1                                              07/97 DBC\n         SLR   R3,R3                                          07/97 DBC\n         IC    R3,D3390F3          #'CELLS/GAP                07/97 DBC\n         ALR   R15,R3              ACCUMULATE                 07/97 DBC\n         SPACE 1                                              07/97 DBC\n         ST    R15,SAVC3390+12     PASS TO CALLER VIA R1      07/97 DBC\n         LM    R14,R7,SAVC3390     RESTORE REGISTERS          07/97 DBC\n         DROP  R7                  DONE W/CONSTANT BASE       07/97 DBC\n         BR    R14                 RETURN TO CALLER           07/97 DBC\n         #DROP                     RELEASE PROGRAM BASE\n         DROP  ,                   RELEASE ALL BASES\n         EJECT\nDEVTCHK  #ENTER ESDTYPE=NONE,SAVTYPE=RENT DEVT OPND CHK RTNE\n         L     R12,=A(BLKSPTRK)    ADJUST BASE ADDRESS\n         USING BLKSPTRK,R12        REDECLRAE THE PGM BASE\n         LM    R2,R3,0(R1)         POINT TO PDE AND DSA\n         LR    R11,R3              LOAD NORMAL DSA BASE\n         USING DSA,R11             DECLARE DSA BASE\n         L     R4,0(,R2)           NO, POINT TO STRING\n         CLI   0(R4),C'*'          OMITTED VALUE?\n         BNE   DNTSTAR             NO, PROCEED\nDSTAR    MVI   0(R2),X'FF'         YES, REMEMBER\n         B     EXITOK              RETURN TO PARSE\nDNTSTAR  LH    R5,4(,R2)           GET ITS LENGTH\n         BCTR  R5,0                CNVRT TO MACHINE LENGTH\n         TM    6(R2),X'80'         OMITTED?\n         BNO   DSTAR               YES, SKIP\n         LTR   R5,R5               NO, NULL?\n         BM    DSTAR               YES, SKIP\n         SR    R15,R15             NO, CLEAR FOR TABLE SCAN\n         LA    R1,LKUPDVTB-LKUPDNME-1 POINT TO TABLE\nLKUPLOOP LA    R1,LKUPDNME+1(R15,R1) POINT TO NEXT ENTRY\n         CLI   0(R1),X'FF'         END OF TABLE?\n         BE    LKUPFAIL            YES, BAD STRING\n         IC    R15,LKUPDNLN(,R1)   NO, GET ENTRY'S LENGTH\n         CR    R15,R5              RIGHT ENTRY?\n         BNE   LKUPLOOP            NO, KEEP LOOPING\n         CLC   0(*-*,R4),LKUPDNME(R1) (EXECUTED INSTRUCTION)\n         EX    R15,*-6             MAYBE, CHECK AGAIN\n         BNE   LKUPLOOP            NO, KEEP LOOPING\n         MVC   0(1,R2),LKUPDNDX(R1) YES, SAVE THE DEVICE TYPE\n         B     EXITOK              GO RETURN TO PARSE\n         DROP  ,                   RELEASE BASES\n         EJECT\nBLKSCHK  #ENTER ESDTYPE=NONE,SAVTYPE=RENT BLKSIZE CHECKING ROUTINE\n         L     R12,=A(BLKSPTRK)    RESET THE BASE REGISTER\n         USING BLKSPTRK,R12        REDECLARE IT\n         LM    R2,R3,0(R1)         POINT TO PDE AND DSA\n         LR    R11,R3              LOAD DSA BASE\n         USING DSA,R11             DECLARE DSA BASE\n         L     R4,0(,R2)           POINT TO BLKSIZE STRING\n         CLI   0(R4),C'*'          ASTERISK?\n         BNE   BNTSTAR             NO, PROCEED\nBSTAR    MVC   0(4,R2),=4C'*'      YES, SIGNEL OPND OMITTED   11/84 DBC\n         B     EXITOK              RETURN TO PARSE\nBNTSTAR  LH    R5,4(,R2)           GET ITS LENGTH\n         BCTR  R5,0                CONVERT TO MACHINE LENGTH\n         TM    6(R2),X'80'         OMITTED?\n         BNO   BSTAR               YES, GO REMEMBER\n         LTR   R5,R5               NO, NULL?\n         BM    BSTAR               YES, GO REMEMBER\n         SPACE 1                                              11/84 DBC\n         LA    R14,1               NO, ASSUME BLKSIZE         11/84 DBC\n         CLI   0(R4),C'#'          BLOCK COUNT GIVEN?         11/84 DBC\n         BNE   BNTCNT              NO, PROCEED                11/84 DBC\n         SR    R5,R14              YES, DECR L'DIGITS; NULL?  11/84 DBC\n         BM    BSTAR               YES, TREAT AS B(0)         11/84 DBC\n         AR    R4,R14              NO, --> DIGITS             11/84 DBC\n         LNR   R14,R14             SET \"BLOCK COUNT\" SIGNAL   11/84 DBC\nBNTCNT   TM    0(R4),C'0'          VALID DIGIT?               11/84 DBC\n         BNO   EXITFAIL            NO, ERROR                  11/84 DBC\n         SPACE 1                                              11/84 DBC\n         PACK  DSAWORK(8),0(*-*,R4) (EXECUTED INSTRUCTION)\n         EX    R5,*-6              YES, PACK THE STRING\n         CVB   R15,DSAWORK         CONVERT TO BINARY\n         C     R15,=X'0000FFFF'    CHECK FOR MAX VALUE        11/84 DBC\n         BH    BLKS2LRG            ERROR\n         MR    R14,R14             OK, IF BLK_CNT; THEN MAKE  11/84 DBC\n*                                  NEGATIVE                   11/84 DBC\n         ST    R15,0(,R2)          RETURN THE CONVERTED VALUE\n         B     EXITOK              GO RETURN TO PARSE\n         DROP  ,                   RELEASE BASES\n         EJECT\nKEYLCHK  #ENTER ESDTYPE=NONE,SAVTYPE=RENT KEYLEN VALIDITY CHECK\n         L     R12,=A(BLKSPTRK)    RESET BASE ADDRESS\n         USING BLKSPTRK,R12        REDECLARE IT\n         LM    R2,R3,0(R1)         POINT TO PDE AND DSA\n         LR    R11,R3              LOAD DSA BASE\n         USING DSA,R11             DECLARE DSA BASE\n         L     R4,0(,R2)           POINT TO KEYLEN VALUE STRING\n         CLI   0(R4),C'*'          IGNORE THIS?\n         BNE   KNTSTAR             NO, PROCEED\n         MVI   0(R2),X'FF'         YES, SIGNEL IT\n         B     EXITOK              RETURN TO PARSE\nKNTSTAR  LH    R5,4(,R2)           GET ITS LENGTH\n         BCTR  R5,0                CONVERT TO MACHINE LENGTH\n         PACK  DSAWORK(8),0(*-*,R4) (EXECUTED INSTRUCTION)\n         EX    R5,*-6              PACK IT\n         CVB   R15,DSAWORK         CONVERT TO BINARY\n         C     R15,=A(255)         CHECK MAX VALUE\n         BH    KEYL2LRG            ERROR\n         ST    R15,0(,R2)          OK, RETURN CONVERTED VALUE\n         B     EXITOK              GO RETURN TO PARSE\n         DROP  ,                   RELEASE BASES\n         EJECT\n         USING BLKSPTRK,R12        DECLARE PROGRAM BASE\n         USING DSA,R11             DECLARE DSA BASE\n         SPACE 3\nEXITFAIL LA    R15,8               ERROR RC\n         B     EXIT\n         SPACE 1\nEXITOK   SR    R15,R15             SET AOK RC\nEXIT     #EXIT ((R14,R12)),RC=(R15) RETURN TO PARSE\n         SPACE 3\nLKUPFAIL LA    R1,LKUPFMSG-1\n         BAL   R2,TPUTERRM\n         B     EXITFAIL\n         SPACE 1\nBLKS2LRG LA    R1,BLKS2MSG-1\n         BAL   R2,TPUTERRM\n         B     EXITFAIL\n         SPACE 1\nKEYL2LRG LA    R1,KEYL2MSG-1\n         BAL   R2,TPUTERRM\n         B     EXITFAIL\n         SPACE 3\nTPUTERRM LA    R15,DSABUFF         GET SINK SCANNER\n         LTR   R5,R5               NULL OPERAND?\n         BM    OPNDNULL            YES, SKIP\n         MVC   DSABUFF(*-*),0(R4)  (EXECUTED INSTRUCTION)\n         EX    R5,*-6              NO, MOVE OPND TO MSG\n         ALR   R15,R5              ADVANCE SINK SCANNER\nOPNDNULL SR    R14,R14             CLEAR\n         IC    R14,0(,R1)          GET MSG LENGTH\n         MVC   1(*-*,R15),1(R1)    (EXECUTED INSTRUCTION)\n         EX    R14,*-6             MOVE MSG TO SINK\n         LA    R0,2(R14,R15)       POINT PAST EO MSG\n         LA    R1,DSABUFF          POINT TO START\n         SR    R0,R1               GET MSG LENGTH\n         TPUT  (1),(0),R           SEND THE MSG\n         BR    R2                  RETURN TO CALLER\n         DROP  ,                   RELEASE BASES\n         EJECT\n         PRINT NOGEN\n         SPACE 3\nPCL      IKJPARM DSECT=PDL\nPDLDEVT  IKJIDENT 'DASD DEVICE TYPE(S)',LIST,ASTERISK,UPPERCASE,       *\n               FIRST=ANY,OTHER=ANY,PROMPT='DASD DEVICE TYPE(S)',       *\n               MAXLNTH=10,VALIDCK=DEVTCHK,                             *\n               HELP='2301 2302 2303 2305-1 2305-2 2311 2314 2319 2321 3*\n               330 3340 3350 3375 3380 3390 3995-111 3995-113 3995-151 *\n               3995-153 OR 9345. ENTER AN ASTERISK TO SKIP THIS FIELD.'\nPDLBLKSK IKJKEYWD\n         IKJNAME 'BLKSIZE',SUBFLD=PCLBLKS\nPDLKEYLK IKJKEYWD\n         IKJNAME 'KEYLEN',SUBFLD=PCLKEYL\nPCLBLKS  IKJSUBF\nPDLBLKS  IKJIDENT 'NUMBER',LIST,ASTERISK,MAXLNTH=6,FIRST=ALPHANUM,     *\n               OTHER=NUMERIC,PROMPT='BLKSIZE',VALIDCK=BLKSCHK,         *\n               HELP='A PHYSICAL BLOCK LENGTH VALUE RANGING FROM 1 TO 65*\n               535 OR A # FOLLOWED BY A BLOCK COUNT (E.G., #6). ENTER A*\n                0 TO FIND THE MAXIMUM BLKSIZE. TO SKIP THIS FIELD, ENTE*\n               R AN ASTERISK.'                                11/84 DBC\nPCLKEYL  IKJSUBF\nPDLKEYL  IKJIDENT 'NUMBER',LIST,ASTERISK,MAXLNTH=3,FIRST=NUMERIC,      *\n               OTHER=NUMERIC,DEFAULT='0',VALIDCK=KEYLCHK,              *\n               HELP='A KEY LENGTH VALUE RANGING FROM 0 TO 255. TO SKIP *\n               THIS FIELD, ENTER AN ASTERISK.'\n         IKJENDP\n         SPACE 3\n         PRINT ON,GEN,NODATA\n         EJECT ,\n************************************************************* 07/97 DBC\n* The following data is extracted from various incarnations * 07/97 DBC\n* of MVS's Device Characteristics Table. This table is      * 07/97 DBC\n* pointed to by CVTZDTAB, indexed by UCBTBYT4, and mapped   * 07/97 DBC\n* by SYS1.MODGEN(IHADVCT). This table provides usable data  * 07/97 DBC\n* for all IBM devices up to and including 3380s (but not    * 07/97 DBC\n* beyond 3380s).                                            * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\n#        DS    0X                                             07/97 DBC\n         SPACE 1                                              07/97 DBC\n#2301    DS    0X                  2301 PARALLEL DRUM         07/97 DBC\n         DC    X'5003,04,BA3535,0200,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#2302    DS    0X                  2302 DISK STORAGE          07/97 DBC\n         DC    X'1378,01,511414,0219,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#2303    DS    0X                  2303 SERIAL DRUM           07/97 DBC\n         DC    X'131C,00,922626,0200,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#23051   DS    0X                  2305-1 FIXED HEAD STORAGE  07/97 DBC\n         DC    X'38E8,09,027ACA,0200,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#23052   DS    0X                  2305-2 FIXED HEAD STORAGE  07/97 DBC\n         DC    X'3A0A,09,01215B,0200,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#2311    DS    0X                  2311 DISK STORAGE DRIVE    07/97 DBC\n         DC    X'0E29,01,511414,0219,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#2314    DS    0X                  DIRECT ACCESS STORAGE      07/97 DBC\n#2319    DS    0X                  DIRECT ACCESS STORAGE      07/97 DBC\n         DC    X'1C7E,01,922D2D,0216,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#2321    DS    0X                  2321 DATA CELL DRIVE       07/97 DBC\n         DC    X'07D0,03,641010,0219,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#3330    DS    0X                  3330 DISK STORAGE          07/97 DBC\n         DC    X'336D,01,BFBF38,0200,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#3340    DS    0X                  3340 DISK                  07/97 DBC\n         DC    X'2157,01,F2F24B,0200,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#3350    DS    0X                  3350 NON-REMOVABLE DISK    07/97 DBC\n         DC    X'4B36,09,010B52,0200,00'                      07/97 DBC\n         SPACE 1                                              07/97 DBC\n#3375    DS    0X                  3375 NON-REMOVABLE DISK    07/97 DBC\n         DC    X'8CA0,10,20,00E0,00BF,00'                     07/97 DBC\n         SPACE 1                                              07/97 DBC\n#3380    DS    0X                  3380 NON-REMOVABLE DISK    07/97 DBC\n         DC    X'BB60,10,20,0100,010B,00'                     07/97 DBC\n         SPACE 3                                              07/97 DBC\n************************************************************* 07/97 DBC\n* Starting with 3390s, the track capacity formulas became   * 07/97 DBC\n* so complex that MVS's Device Characteristics Table could  * 07/97 DBC\n* no longer contain the necessary overheads and computation * 07/97 DBC\n* factors. Accordingly, the following data is based on      * 07/97 DBC\n* other sources.                                            * 07/97 DBC\n************************************************************* 07/97 DBC\n         SPACE 1                                              07/97 DBC\n#3995113 DS    0X                  3995-113 OPTICAL STORAGE   07/97 DBC\n#3995153 DS    0X                  3995-153 OPTICAL STORAGE   07/97 DBC\n#3390    DS    0X                  3390 NON-REMOVABLE DISK    07/97 DBC\n         DC    X'E5A2,12,22,13,09,06,74,06'                   07/97 DBC\n         SPACE 1                                              07/97 DBC\n#3995111 DS    0X                  3995-111 OPTICAL STORAGE   07/97 DBC\n#3995151 DS    0X                  3995-151 OPTICAL STORAGE   07/97 DBC\n         DC    X'D5A2,12,22,13,09,06,74,06'                   07/97 DBC\n         SPACE 1                                              07/97 DBC\n#9345    DS    0X                  9345 DISK                  07/97 DBC\n         DC    X'BC98,12,22,12,07,06,74,06'                   07/97 DBC\n         EJECT\nLKUPDVTB DC    AL1((#2301-#)/KDEVSIZE,3),C'2301'\n         DC    AL1((#2302-#)/KDEVSIZE,3),C'2302'\n         DC    AL1((#2303-#)/KDEVSIZE,3),C'2303'\n         DC    AL1((#23051-#)/KDEVSIZE,5),C'2305-1'\n         DC    AL1((#23052-#)/KDEVSIZE,5),C'2305-2'\n         DC    AL1((#2311-#)/KDEVSIZE,3),C'2311'\n         DC    AL1((#2314-#)/KDEVSIZE,3),C'2314'\n         DC    AL1((#2319-#)/KDEVSIZE,3),C'2319'\n         DC    AL1((#2321-#)/KDEVSIZE,3),C'2321'\n         DC    AL1((#3330-#)/KDEVSIZE,3),C'3330'\n         DC    AL1((#3340-#)/KDEVSIZE,3),C'3340'              07/97 DBC\n         DC    AL1((#3350-#)/KDEVSIZE,3),C'3350'\n         DC    AL1((#3375-#)/KDEVSIZE,3),C'3375'              11/84 DBC\n         DC    AL1((#3380-#)/KDEVSIZE,3),C'3380'              11/84 DBC\n         DC    AL1((#3390-#)/KDEVSIZE,3),C'3390'              07/97 DBC\n         DC    AL1((#3995111-#)/KDEVSIZE,7),C'3995-111'       07/97 DBC\n         DC    AL1((#3995113-#)/KDEVSIZE,7),C'3995-113'       07/97 DBC\n         DC    AL1((#3995151-#)/KDEVSIZE,7),C'3995-151'       07/97 DBC\n         DC    AL1((#3995153-#)/KDEVSIZE,7),C'3995-153'       07/97 DBC\n         DC    AL1((#9345-#)/KDEVSIZE,3),C'9345'              07/97 DBC\n         DC    X'FF'\n         SPACE 1\nLKUPDNDX EQU   0                   DEVICE TYPE\nLKUPDNLN EQU   LKUPDNDX+1          DEVICE NAME LENGTH\nLKUPDNME EQU   LKUPDNLN+1          DEVICE NAME\n         SPACE 3\n         LTORG\n         EJECT ,\nCOPYRIGH DC    C'BLKSPTRK - Copyright (c) 1997 - David B. Cole' /97 DBC\n         SPACE 3                                              07/97 DBC\nLEGALRF1 DC    C'For usage restrictions, either type TSO HELP BLKSPTRK,*\n               '                                              07/97 DBC\nLEGALRF2 DC    C'or see this program''s source code.'         07/97 DBC\n         SPACE 3                                              07/97 DBC\nTITLE    DS    0C\nTITDEVT  EQU   *-TITLE\n         DC    C'DEVICE      KEYLEN'\nTITKEYL  EQU   *-TITLE-3\n         DC    C'  BLKSIZE'\nTITBLKS  EQU   *-TITLE-5\n         DC    C'  BLOCKS/TRACK'\nTITBPT   EQU   *-TITLE-5\n         DC    C'  RESIDUE'\nTITRSDU  EQU   *-TITLE-5\nTITLEN   EQU   *-TITLE\n         SPACE 3\n         DC    AL1(L'LKUPFMSG-1)\nLKUPFMSG DC    C' - NOT A RECOGNIZABLE DASD DEVICE TYPE +'\n         SPACE 3\n         DC    AL1(L'BLKS2MSG-1)\nBLKS2MSG DC    C' - VALUE TOO LARGE FOR A BLKSIZE OR A BLOCK COUNT. MAX*\n                ALLOWED IS 65767 +'                           11/84 DBC\n         SPACE 3\n         DC    AL1(L'KEYL2MSG-1)\nKEYL2MSG DC    C' - VALUE TOO LARGE FOR A KEYLEN. MAX ALLOWED IS 255 +'\n         SPACE 3\n         DC    AL1(L'PARSFMSG-1)\nPARSFMSG DC    C' - PARSE ERROR CODE'\n         SPACE 3\n         END   BLKSPTRK\n./ ADD NAME=EXPORT   0100-99126-99126-1257-00016-00016-00000-DBCOLE2\n//XPORTBPT JOB (CSW,UPS),'540-456-8536',CLASS=A,MSGCLASS=D,\n//             MSGLEVEL=(1,1),NOTIFY=R9999,TIME=1439\n//*\n//CLEANUP EXEC PGM=IEFBR14\n//SCRATCH  DD  DSN=DBCOLE.EXPORT.BLKSPTRK.XMIT,\n//             UNIT=SYSALLDA,SPACE=(TRK,0),DISP=(MOD,DELETE)\n//*\n//TRANSMIT EXEC PGM=IKJEFT01\n//SYSTSPRT DD  SYSOUT=*\n//TEST     DD  DSN=DBCOLE.EXPORT.BLKSPTRK,DISP=SHR\n//MESSAGE  DD  DSN=DBCOLE.EXPORT.BLKSPTRK(README),DISP=SHR\n//SYSTSIN  DD  *\nXMIT BLKSPTRK.USER +\n     DSNAME('DBCOLE.EXPORT.BLKSPTRK') +\n     MSGDDNAME(MESSAGE) +\n     OUTDSNAME('DBCOLE.EXPORT.BLKSPTRK.XMIT')\n./ ADD NAME=README   0102-99126-99126-1256-00080-00074-00000-DBCOLE2\nYou are reading DBCOLE.EXPORT.BLKSPTRK(README).\n\n\nBLKSPTRK is a TSO command processor that computes DASD track capacities\nand residues for any given BLKSIZE and/or KEYLEN for a large number of\nIBM DASD devices. (Yeah, I know \"DASD devices\" is redundant. Sorry.)\n\nThe BLKSPTRK.ZIP file contains the following files:\n\n  - BLKSPTRK.ALC is the assembler source code for the program.\n\n  - TSO-HELP.TXT is a TSO help file for the program. It should be\n    copied into your local version of the SYS1.HELP file.\n\n  - JCL.TXT is sample JCL for assembling and link editing the program\n\nAll of the files are encoded in ASCII. When uploading them to your\nmainframe, ASCII-to-EBCDIC translation should be enabled.\n\nAssembling BLKSPTRK will require a macro library available from Cole\nSoftware's web site (www.colesoft.com). The file there is named\nMACROS.ZIP. You will have to obtain and install these macros before you\nwill be able to complete the installation of BLKSPTRK.\n\nTo install BLKSPTRK, do the following:\n\n  - Obtain and install Cole Software's macro library (MACROS.ZIP).\n\n  - Use WINZIP or PKUNZIP (or whatever) to decompress and extract the\n    the BLKSPTRK.ALC, TSO-HELP.TXT, and JCL.TXT files from BLKSPTRK.ZIP.\n\n  - Upload the three files to your mainframe. Make sure that\n    ASCII-to-EBCDIC translation is turned on.\n\n  - Upload the files to a library whose DCB attributes are RECFM=FB,\n    LRECL=80, and BLKSIZE=n*80.\n\n  - !!! READ THE HELP MEMBER FOR COPYRIGHT INFORMATION, USAGE\n    RESTRICTIONS, AND CONTACT INFORMATION (not to mention program usage\n    instructions too).\n\n  - Copy the HELP member to a suitable TSO HELP library (such as\n    SYS1.HELP). Rename it to BLKSPTRK, and give it an alias of BPT.\n\n  - Check out the JCL member for sample JCL to assemble and linkedit\n    the BLKSPTRK program.\n\n  - Assemble the BLKSPTRK member using both system macros and private\n    macros available from Cole Software. Specify PARM=RENT for the\n    assembly.\n\n  - Linkedit the BLKSPTRK program into a suitable TSO load library.\n    Specify PARM=RENT (as well as other typical parameters). Assign BPT\n    as an alias.\n\n  - Try it out. Examples:\n        BPT (3380 3390 9345) BLKSIZE(#1 #2 #3 #200)\n        BPT (3380 3390 9345) BLKSIZE(1 99999) KEYLEN(0 1 255)\n        etc.\n\n\nCONTACT INFORMATION:\n\n    Name:                David B. Cole\n    Country:             USA\n\n    Telephone:           540-456-8536\n    FAX:                 540-456-6658\n    E-mail:              dbcole@cfw.com\n    Website:             www.colesoft.com\n\n    Snail Mail:          Cole Software\n                         736 Fox Hollow Road\n                         Afton, VA 22920\n                         USA\n\n\n\n\n\n./ ADD NAME=TSOHELP  0100-99126-99126-0832-00195-00195-00000-DBCOLE6\n)F FUNCTION\n  The BLKSPTRK command calculates direct access storage device track\n  capacities. For a given list of device types, this command will\n  display exactly how many blocks of a given size (with or without\n  keys) will fit on each track.\n\n  This command also computes the usable track residue showing the\n  largest block that will still fit at the end of a track that has been\n  filled with blocks all of the given size.\n  This program is copyrighted (c) 1997 by David B. Cole.\n\n\n  LEGAL INFORMATION:\n\n      This program is copyrighted (c) 1997 by David B. Cole.\n\n      This program is distributed freely and may be reproduced and\n      redistributed without restriction other than:\n        - This copyright and usage/warranty/liability restriction\n          statement (\"Legal Statement\") may not be modified or removed.\n        - A similar Legal Statement located in this program's source\n          code also may not be removed.\n        - This Online Help File must be installed in a suitable \"help\n          library\" (such as SYS1.HELP) so that users may see both the\n          Legal Statement as well as usage instruction.\n\n      This program is distributed without warranty of any kind,\n      including (without limitation) warranties of merchantability and\n      of fitness for a particular purpose. It is up to the user to make\n      his own determination of the usefulness of this program in his\n      own system.\n\n      The user agrees not to hold me (David B. Cole) liable for any\n      damage whatsoever, and the user agrees to indemnify me against\n      third parties for any action arising from the user's use,\n      modification, and/or redistribution of this program.\n\n      This program may be modified freely so long as all modifications\n      are clearly marked both internally and externally to distinguish\n      them from the distributed code and functionallity.\n\n      As a courtesy, please notify me if you discover any bugs or if\n      you need or have made any code changes. (I of of course do not\n      guarantee either that I will or that I will not make any future\n      changes or corrections.)\n\n      My contact information as of JUL97 is:\n\n          Name:                David B. Cole\n          Country:             USA\n          Telephone:           540-456-8536\n          FAX:                 540-456-6658\n          E-mail:              davidbcole@aol.com\n          Website:             www.colesoft.com\n\n          Snail Mail:          Cole Software\n                               736 Fox Hollow Road\n                               Afton, VA 22920\n                               USA\n\n)X SYNTAX\n             BLKSPTRK (devtype devtype ...)\n                      BLKSIZE(<size or #count> <size or #count> ...)\n                      KEYLEN(length length ...)\n  Alias    - BPT\n  Default  - BLKSPTRK BLKSIZE(#1) KEYLEN(0)\n  Required - at least one devtype\n\n  Note     - Lists of values may be given for both the devtype,\n             BLKSIZE, and KEYLEN operands. When lists are given,\n             BLKSPTRK will produce a matrix of all value combinations.\n             The size of the report will be the product of the number\n             of values given in each list. Example:\n\n                 BPT (2314 3380 9345) BLKSIZE(1 99999 #2) KEY(0 1)\n\n             This causes BLKSPTRK to product an 18 line report.\n\n)O OPERANDS\n))devtype -\n         This operand is required. It must contain a list of one or\n         more direct access storage device types. (e.g. 3330, 2305-2,\n         etc.).  If more than one device type is given, then the list\n         must be enclosed within parentheses. Currently (JUL97) the\n         following device types are recognized:\n               2301     (parallel drum)\n               2302     (disk)\n               2303     (serial drum)\n               2305-1   (drum, 2 logical tracks per physical track)\n               2305-2   (drum, 1 logical track  per physical track)\n               2311     (removable disk)\n               2314     (removable disk)\n               2319     (same as 2314)\n               2321     (data cell)\n               3330     (removable disk)\n               3340     (disk)\n               3350     (disk)\n               3375     (disk)\n               3380     (disk)\n               3390     (disk)\n               3995-111 (removable optical disk - CD-ROM)\n               3995-113 (removable optical disk - CD-ROM)\n               3995-151 (removable optical disk - CD-ROM)\n               3995-153 (removable optical disk - CD-ROM)\n               9345     (rack-mounted disk)\n\n         Notes:\n\n           - In JUL97 I extensively verified program output against\n             published track capacity tables for the following devices:\n                 2305-1 2305-2 3330 3350 3380 3390 and 9345.\n             The program output matched the published data for all\n             tested devices except the 2305-1 drum.\n\n           - For 2305-1 drums, the BLKSPTRK program disagreed with\n             the published information relating to the maximum size\n             blocks that can fit n times per track for the following\n             values of \"n\":\n                 #5 #7 #8 #15 #18 #21 #23 #24 #27 #52 and #36.\n             In each case the reported maximum blksize was one byte\n             greater than the published maximum blksize.\n\n             This descrepancy did not occur for any other tested DASD,\n             and in particular it did not occur for 2305-2 drums!\n\n             It is possible that for the 2305-1 drum, the computation\n             factors and parameters used by BLKSPTRK might be\n             incorrect; however, it is also possible that the published\n             tables themselves are wrong. But at this point (JUL97) it\n             is both too late and not worth it to double check those\n             factors.\n\n             For what it's worth, the published capacity tables were\n             found in GA26-1589-3: \"Reference Manual for IBM 2835\n             Storage Control and IBM 2305 Fixed Head Storage Module\".\n             The computation parameters used by BLKSPTRK for the 2305-1\n             are:\n                 DASD Type:                 Non-cellular\n                 Track Capacity:            X'38E8' bytes\n                 Overhead (all blocks):     X'027A'\n                 Unkeyed Block Underhead:   X'CA'\n                 Tolerance Factor (all but  X'0200' (X'0200' has no\n                 the last block):                   effect)\n\n))BLKSIZE -\n         This operand is optional. If omitted, then B(#1) is used. If\n         given, then it must specify a list of one or more physical\n         block sizes and/or block counts.\n\n         A block size is given as a plain number (e.g., B(6160)). A\n         block count is given preceded by a pound sign (e.g., B(#5)).\n\n         When a block count is given, BLKSPTRK displays the size of the\n         largest block that fits the given number of times on a track.\n\n         Notes:\n\n           - Giving a zero value is equivalent to giving #1. Thus, all\n             of the following are equilivant: BLKSIZE(#1) BLKSIZE(#0)\n             and BLKSIZE(0).\n\n           - Giving a block count that is higher than the most number\n             of blocks that can fit on a track causes BLKSPTRK to\n             devolve to showing the maximum number of blocks (1 byte in\n             size) that will fit per track. Thus, the following are\n             equivalent: BLKSIZE(#200) and BLKSIZE(1).\n\n           - Giving a block size that is larger than the largest block\n             that can fit on a track causes BLKSPTRK to devolve to\n             showing the largest block that will fit. Thus, the\n             following are equivalent: BLKSIZE(99999) and BLKSIZE(#1).\n\n         Example:\n\n         BPT (3380 3390) BLKSIZE(#1 #200) KEY(0 1)\n         This produces a 8-line report (4 lines for each disk) showing\n         (a) the largest block that will fit on a track (#1) and (b)\n         the most number of blocks that will fit per track (#200). The\n         information is shown both for keyed (KEY(1)) and unkeyed\n         (KEY(0)) blocks.\n\n))KEYLEN -\n         This operand is optional. If omitted, then a zero value is\n         used. if given, then it may specify one or more key lengths to\n         be used in the track capacity calculations.\n\n         Example:\n\n         BPT (3380 3390) BLKSIZE(#1 #200) KEY(0 1)\n         This produces a 8-line report (4 lines for each disk) showing\n         (a) the largest block that will fit on a track (#1) and (b)\n         the most number of blocks that will fit per track (#200). The\n         information is shown both for keyed (KEY(1)) and unkeyed\n         (KEY(0)) blocks.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSCOPY": {"ttr": 257, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "./ ADD NAME=ASMJCL   0100-05218-05218-1502-00038-00038-00000-DBCOLE9\n//@DSCOPY  JOB (CSW,UPS),'540-456-8536',CLASS=A,\n//             MSGLEVEL=(1,1),NOTIFY=R9999,TIME=1439\n//*\n//*\n//***********************************************************\n//*                                                         *\n//* Sample JCL to assemble and linkedit the DSCOPY program. *\n//*                                                         *\n//***********************************************************\n//*\n//ASM     EXEC PGM=ASMA90,REGION=0M,\n// PARM='TERM,TEST,OBJECT,NODECK,LINECOUNT(109)' <=========LINECOUNT===\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//*\n//***********************************************************\n//*                                                         *\n//* The following MACLIB is available from WWW.COLESOFT.COM *\n//*                                                         *\n//         DD  DSN=DBCOLE.MACLIB,DISP=SHR <======================DSN===\n//*                                                         *\n//***********************************************************\n//*\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=DISK,SPACE=(CYL,(15,5)),\n//             DISP=(,PASS)\n//SYSTERM  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJSET,UNIT=DISK,SPACE=(CYL,(1,1),RLSE),\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DSN=DBCOLE.DSCOPY.EXPORT(DSCOPY),DISP=SHR <=======DSN===\n//*\n//LKED    EXEC PGM=IEWL,REGION=0M,\n//             PARM='TEST,XREF,LET,LIST,NCAL',\n//             COND=(0,LT)\n//SYSLMOD  DD  DSN=DBCOLE.LOAD(DSCOPY),DISP=SHR <================DSN===\n//SYSUT1   DD  DSN=&&SYSUT1,DISP=(OLD,DELETE)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&&OBJSET,DISP=(OLD,DELETE)\n./ ADD NAME=DSCOPY   0101-05218-05218-1643-01976-01761-00000-DBCOLEA\nDSCOPY   TITLE 'DSCOPY - Description'                         08/05 Z17 DSCOPY\n***********************************************************************\n*                                                                     *\n* The DSCOPY program is copyrighted (c) 1972-2005 by David B. Cole.   *\n* All rights reserved.                                                *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* DESCRIPTION                                                         *\n*                                                                     *\n* DSCOPY is a general purpose program which copies data sets          *\n* sequentially.  It allows the user to copy sequential files, BDAM    *\n* files (i.e.  REGIONAL(1) files in PL/I or direct access files in    *\n* FORTRAN), and single members of partitioned data sets from any      *\n* valid input device (e.g. card reader, disk drive, or tape drive) to *\n* any valid output device (e.g.  printer, card punch, disk drive, or  *\n* tape drive).  The advantage of this utility over others having the  *\n* same function is that DSCOPY is considerably more efficient and     *\n* faster (more that twice as fast as the IBM utility IEBGENER, for    *\n* example).  It takes full advantage of OS data management facilities *\n* in order to optimize as much as possible the data transfer rate.    *\n*                                                                     *\n* DSCOPY has the following features:                                  *\n*                                                                     *\n* 1.) All information needed is specified through JCL or through the  *\n*     PARM field. No control dataset (SYSIN, for example) is needed.  *\n*                                                                     *\n* 2.) DSCOPY can perform any number of seperate copies in one jobstep *\n*     (subject, of course, to OS limits on the number of DD cards     *\n*     permitted within a job or step).                                *\n*                                                                     *\n* 3.) Input datasets may be sequential, direct, or individual members *\n*     of partitioned data sets, or a concatenation of any combination *\n*     of the above with any combination of DCB attributes (RECFM,     *\n*     LRECL, and BLKSIZE).                                            *\n*                                                                     *\n* 4.) Any record format is allowed (fixed, variable, undefined) for   *\n*     input, and it may be changed to any other record format for     *\n*     output. In addition, logical record lengths and/or block sizes  *\n*     may also be changed. All such changes are automaticly           *\n*     accomodated for (see below).                                    *\n*                                                                     *\n* Here is a simple example of the invocation of DSCOPY:               *\n*    //...      JOB CARD       ...                                    *\n*    //*                                                              *\n*    //A       EXEC PGM=DSCOPY                                        *\n*    //SYSPRINT DD  SYSOUT=A                                          *\n*    //IN01     DD  DSN=       ... etc.                               *\n*    //OUT01    DD  DSN=       ... etc.                               *\n*    //IN02     DD  DSN=       ... etc.                               *\n*    //OUT02    DD  DSN=       ... etc.                               *\n*    //         .                                                     *\n*    //         .                                                     *\n*    //         .                                                     *\n*    //         etc.                                                  *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* LEGAL INFORMATION:                                                  *\n*                                                                     *\n* This program is copyrighted (c) 1972-2005 by David B. Cole. All     *\n* rights reserved.                                                    *\n*                                                                     *\n* This program is distributed freely and may be reproduced and        *\n* redistributed without restriction other than:                       *\n*   - This copyright and usage/warranty/liability restriction         *\n*     statement (\"Legal Statement\") may not be modified or removed.   *\n*   - A similar Legal Statement located in this program's source code *\n*     also may not be removed.                                        *\n*                                                                     *\n* This program is distributed without warranty of any kind, including *\n* (without limitation) warranties of merchantability and of fitness   *\n* for a particular purpose. It is up to the user to make his own      *\n* determination of the usefulness of this program in his own system.  *\n*                                                                     *\n* The user agrees not to hold either David B. Cole or Cole Software,  *\n* LLC or any person affiliated with Cole Software, LLC (collectively  *\n* \"COLE\") liable for any injury or damage whatsoever.                 *\n*                                                                     *\n* Further, the user agrees to indemnify COLE against third parties    *\n* for any action arising from the user's use, misuse, modification,   *\n* and/or redistribution of this program.                              *\n*                                                                     *\n* This program may be modified freely so long as all modifications    *\n* are clearly marked both internally and externally to distinguish    *\n* them from the distributed code and functionality.                   *\n*                                                                     *\n* As a courtesy, please notify David Cole if you discover any bugs or *\n* if you need or have made any code changes. (COLE, of course, does   *\n* not guarantee that any future changes or corrections wither will or *\n* will not be made.)                                                  *\n*                                                                     *\n* Contact information as of AUG05 is:                                 *\n*                                                                     *\n*     Name:                David B. Cole                              *\n*     Country:             USA                                        *\n*     Telephone:           540-456-8536                               *\n*     FAX:                 540-456-6658                               *\n*     E-mail:              dbcole@colesoft.com                        *\n*     Website:             www.colesoft.com                           *\n*                                                                     *\n*     Snail Mail:          Cole Software                              *\n*                          736 Fox Hollow Road                        *\n*                          Afton, VA 22920                            *\n*                          USA                                        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* PACKAGING:                                                          *\n*                                                                     *\n* The DSCOPY.ZIP file contains the following files:                   *\n*                                                                     *\n*   - DSCOPY.ALC is the assembler source code for the program.        *\n*                                                                     *\n*   - JCL.TXT is sample JCL for assembling and link editing the       *\n*     program.                                                        *\n*                                                                     *\n* All of the files are encoded in ASCII. When uploading them to your  *\n* mainframe, ASCII-to-EBCDIC translation should be enabled.           *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* INSTALLATION:                                                       *\n*                                                                     *\n* Assembling DSCOPY will require a macro library available from Cole  *\n* Software's web site (www.colesoft.com). The file there is named     *\n* MACROS.ZIP. You will have to obtain and install these macros before *\n* you will be able to complete the installation of DSCOPY.            *\n*                                                                     *\n* To install DSCOPY, do the following:                                *\n*                                                                     *\n*   - Obtain and install Cole Software's macro library (MACROS.ZIP).  *\n*                                                                     *\n*   - Use WINZIP or PKUNZIP (or whatever) to decompress and extract   *\n*     the DSCOPY.ALC, and JCL.TXT files from DSCOPY.ZIP.              *\n*                                                                     *\n*   - Upload the two files to your mainframe. Make sure that          *\n*     ASCII-to-EBCDIC translation is turned on.                       *\n*                                                                     *\n*   - Upload the files to a library whose DCB attributes are          *\n*     RECFM=FB, LRECL=80, and BLKSIZE=n*80.                           *\n*                                                                     *\n*   - Check out the JCL member for sample JCL to assemble and         *\n*     linkedit the DSCOPY program.                                    *\n*                                                                     *\n*   - Assemble the DSCOPY member using both system macros and private *\n*     macros available from Cole Software.                            *\n*                                                                     *\n*   - Linkedit the DSCOPY program into a suitable load library.       *\n*                                                                     *\n*   - Try it out.                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* USAGE:                                                              *\n*                                                                     *\n*  1.) DDNAMEs for input must be of the form INx where x is any       *\n*      alphameric character string of from 0 to 5 characters in       *\n*      length.                                                        *\n*                                                                     *\n*  2.) DDNAMEs for output must be of the form OUTx where x is as in   *\n*      (1) above.                                                     *\n*                                                                     *\n*  3.) Copy operations are performed from each //INx DD card to a     *\n*      corresponding //OUTx DD card (e.g. from //INA to //OUTA, from  *\n*      //IN9999A to OYT9999A, from //IN to //OUT, from //INTRASH to   *\n*      //OUTTRASH, etc.). Clearly, there must exist a one to one      *\n*      correspondence between the input DD cards and the output DD    *\n*      cards.                                                         *\n*                                                                     *\n*  4.) Copy operations are performed in the order of the ascending    *\n*      EBCDIC coalating sequence of x. In the following example, the  *\n*      copies are performed in the order shown (*regardless* of the   *\n*      sequence in which the DD cards are actually presented):        *\n*          1st //IN      to //OUT                                     *\n*          2nd //INA     to //OUTA                                    *\n*          3rd //INTRASH to //OUTTRASH                                *\n*          4th //IN01    to //OUT01                                   *\n*          5th //IN02    to //OUT02                                   *\n*          6th //IN1     to //OUT1                                    *\n*          7th //IN10    to //OUT10                                   *\n*          8th //IN2     to //OUT2                                    *\n*          9th //IN9999A to //OUT9999A                                *\n*      Watch out for pitfalls here! Note in particular, that a copy   *\n*      from //IN10 to //OUT10 will occur *before* a copy from //IN2   *\n*      to //OUT2. (This may matter, for example, if you're writing to *\n*      tape.)                                                         *\n*                                                                     *\n*  5.) Input block sizes must be available to DSCOPY from either      *\n*      DSCBs, tape labels, or JCL. If other necessary DCB parameters  *\n*      are missing, then defaults are taken (see below).              *\n*                                                                     *\n*  6.) Keyed direct access files (e.g. PL/I REGIONAL(2) and           *\n*      regional(3) files) may be copied, but the keys themselves      *\n*      won't be copied. The resulting output file will be sequential  *\n*      unless DSORG=DA is coded in the JCL.                           *\n*                                                                     *\n*  7.) A SYSPRINT DD card (e.g. //SYSPRINT DD SYSOUT=*) must be       *\n*      included in the JCL. This DD card specifies a message data set *\n*      for DSCOPY.  It's DCB is DSORG=PS, RECFM=UA, LRECL=121,        *\n*      BLKSIZE=121). Any attempt to override this is ignored.         *\n*                                                                     *\n*  8.) If any necessary DCB atributes are missing, then the following *\n*      conversions are performed:                                     *\n*                                                                     *\n*      a.) If the input's DSORG is missing, then DSORG=PS is used.    *\n*                                                                     *\n*      b.) If the output's DSORG is missing, then DSORG=PS is used.   *\n*                                                                     *\n*      c.) If the input's RECFM is missing, then RECFM=U is used.     *\n*                                                                     *\n*      d.) If the output's RECFM is missing, then the input's RECFM   *\n*          is used.                                                   *\n*                                                                     *\n*      e.) If the input's BLKSIZE is missing, then an error condition *\n*          is reported.                                               *\n*                                                                     *\n*      f.) If the output's BLKSIZE is missing, then the input's       *\n*          BLKSIZE is used. Exceptions:                               *\n*                                                                     *\n*            - If the input's RECFM=V while the output's RECFM<>V     *\n*              then the input's BLKSIZE-4 is used.                    *\n*                                                                     *\n*            - If the input's RECFM<>V while the output's RECFM=V,    *\n*              then the input's BLKSIZE+4 is used.                    *\n*                                                                     *\n*      g.) If the input's LRECL is missing, then the input's BLKSIZE  *\n*          is used. Exception:                                        *\n*                                                                     *\n*            - If the input's RECFM=V, then the input's BLKSIZE-4 is  *\n*              used.                                                  *\n*                                                                     *\n*      h.) If the output's LRECL is missing, then the output's        *\n*          BLKSIZE is used. Exception:                                *\n*                                                                     *\n*            - If the output's RECFM=V, then the output's BLKSIZE - 4 *\n*              is used.                                               *\n*                                                                     *\n*      i.) In the case of concatenated input, any settings that are   *\n*          made for the output data set that are based on the         *\n*          characteristics of the input data set, are based on the    *\n*          chatacteristics of the *first* DD card in the input        *\n*          concatenation.                                             *\n*                                                                     *\n*      j.) The above listed conversions are (if required) applied in  *\n*          the same order in which they are listed. For example,      *\n*          conversion (f) will be applied before conversion (h).      *\n*                                                                     *\n*  9.) If the LRECL for the output data set is to be different from   *\n*      the LRECL for the input data set, then there are three cases:  *\n*                                                                     *\n*      A.) Output's LRECL > input's LRECL:                            *\n*                                                                     *\n*            - In this case, if the output's RECFM=F, then the unused *\n*              portion of each output record is filled with blanks    *\n*              (I.e. the record is right-padded with blanks).         *\n*                                                                     *\n*      b.) Output's LRECL < input's LRECL *but* the entire input      *\n*          record is still desired in the output data set:            *\n*                                                                     *\n*            - In this case, the input record is spanned onto as many *\n*              output records as is required. Note that this is the   *\n*              default action.                                        *\n*                                                                     *\n*     c.) Output's LRECL < input's LRECL and only that portion of the *\n*         input record that will fit on one output record is desired: *\n*                                                                     *\n*           - In this case each input record that is too long is      *\n*             truncated before it is written to the output data set.  *\n*             In order to use this truncation facility, the user must *\n*             code TRUNCATE in the EXEC statement's PARM= field.      *\n*             Notes:                                                  *\n*                                                                     *\n*               - If TRUNCATE is coded, then truncation will occur    *\n*                 for all copy operations in the jobstep.             *\n*                                                                     *\n*               - If truncate is not coded, then spanning will occur  *\n*                 for all copy operations.                            *\n*                                                                     *\n*               - WARNING! If spanning occurs, and the output file's  *\n*                 RECFM is V or VS, the spanning will *not* be        *\n*                 compatible with RECFM=VS!                           *\n*                                                                     *\n* 10.) DSCOPY generates a completion code with the following values:  *\n*                                                                     *\n*        0  - Execution completed without errors                      *\n*                                                                     *\n*        4  - One of the following \"concerns\" occurred:               *\n*                                                                     *\n*               a.) When DSCOPY was called as a subroutine, too many  *\n*                   arguements were passed (see below).               *\n*                                                                     *\n*               b.) When DSCOPY was called as a subroutine, the third *\n*                   arguement was invalid (see below).                *\n*                                                                     *\n*               c.) For a //INx or a //OUTx DDNAME, a corresponding   *\n*                   //OUTx or //INx DDNAME was not found.             *\n*                                                                     *\n*        8  - One or more copy operations was either suppressed or    *\n*             terminated for some reason.                             *\n*                                                                     *\n*        12 - The program was terminated before any copies were       *\n*             attempted.                                              *\n*                                                                     *\n* 11.) PARM FIELD PROCESSING: There are several controls that DSCOPY  *\n*      accepts via the parm field. The general syntax is:             *\n*                                                                     *\n*        - Their form is either \"keyword\" or \"keyword=value\".         *\n*                                                                     *\n*        - They may be given in any order.                            *\n*                                                                     *\n*        - They must be separated from each other by blanks or commas.*\n*                                                                     *\n*        - Keyword names must be given in full; abbreviations are not *\n*          checked for.                                               *\n*                                                                     *\n*        - Also, redundancies are not checked for; each instance of a *\n*          particular keyword overrides and nullifies all prior       *\n*          instances.                                                 *\n*                                                                     *\n*        - These controls apply to *all* copies performed by DSCOPY.  *\n*                                                                     *\n*      The following controls are supported:                          *\n*                                                                     *\n*          TRUNCATE                                                   *\n*          When copying long records into output files with short     *\n*          LRECLs, this cause DSCOPY to truncate the record. (Omit    *\n*          this keyword if you want longs records to be spanned into  *\n*          the output file.)                                          *\n*                                                                     *\n*          START=number                                               *\n*          This causes copying to start with the given input record   *\n*          NUMBER. NUMBER-1 RECORDS ARE SKIPPED. THE DEFAULT IS       *\n*          START=1.                                                   *\n*                                                                     *\n*          STOP=number                                                *\n*          This causes copying to stop after the given input record   *\n*          number IS REACHED AND COPIED. (THE FIRST INPUT RECORD,     *\n*          *REGARDLESS* of whether or not it is actually copied, is   *\n*          record number 1.)  The default is to copy until input EOF  *\n*          is reached.                                                *\n*                                                                     *\n*          COUNT=number                                               *\n*          This causes copying to stop after the given number of      *\n*          input records have been copied. The default is to copy     *\n*          until input EOF is reached.                                *\n*                                                                     *\n*          IMPORTANT! When COUNT=number is given, the given or        *\n*          implied START=number control is incrimented by the given   *\n*          COUNT= value for each successive copy. This makes it       *\n*          easier to segment large files into smaller ones via        *\n*          suitable multiple copy requests.                           *\n*                                                                     *\n*      NOTES:                                                         *\n*                                                                     *\n*        - If COUNT= and STOP= conflict, then copying will stop at    *\n*          whichever event occurs first.                              *\n*                                                                     *\n*        - If COUNT=0 or if STOP= is less than START=, then no        *\n*          records are copied.                                        *\n*                                                                     *\n*        - All numbers are treated as being unsigned 32-bit. They may *\n*          range from 0 to 4g.                                        *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* TECHNICAL INFORMATION:                                              *\n*                                                                     *\n* 1.) DSCOPY uses QSAM for all I/O.                                   *\n*                                                                     *\n* 2.) Chained scheduling (OPTCD=C) is used wherever possible. It is   *\n*     not possible for input data sets with RECFM=U. It is also not   *\n*     possible when the BLKSIZE is sufficiently large and the region  *\n*     is sufficently small that only one buffer can be generated.     *\n*                                                                     *\n* 3.) DSCOPY is serially reusable.                                    *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n* DYNAMIC INVOCATION:                                                 *\n*                                                                     *\n*  DYNAMIC INVOCATION:                                                *\n*      \"DSCOPY\" CAN BE EITHER LINK-EDITED INTO OR DYNAMICLY INVOKED   *\n*      BY A USER'S PROGRAM AND USED AS A SUBROUTINE.  WHEN THIS IS    *\n*      DONE, \"DSCOPY\" EXPECTS TO BE PASSED UP TO THREE ARGUEMENTS:    *\n*                                                                     *\n*      1.) THE FIRST ARGUEMENT WILL BE USED AS A PARM FIELD           *\n*                                                                     *\n*      2.) THE SECOND ARGUEMENT IS A LIST OF \"DDNAME\" PREFIXES TO     *\n*          BE USED IN PLACE OF \"IN\" AND \"OUT\".  THE LIST MAY ALSO     *\n*          CONTAIN A REPLACEMENT \"DDNAME\" FOR THE \"SYSPRINT\" DATA     *\n*          SET.                                                       *\n*                                                                     *\n*      3.) THE THIRD ARGUEMENT IS AN EBCDIC NUMBER TO BE USED AS      *\n*          THE STARTING VALUE OF \"X\" IN THE MESSAGE \"COPY # X\".       *\n*                                                                     *\n*      ANY OR ALL ARGUEMENTS MAY BE EITHER OMITTED OR NULL IN WHICH   *\n*      CASE THE OBVIOUS DEFAULTS WILL BE TAKEN.                       *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* EXAMPLES OF INVOCATION:                                             *\n*                                                                     *\n*                                                                     *\n*     1.) FOR \"ASSEMBLER\" USERS:                                      *\n*                  .                                                  *\n*                  .                                                  *\n*                  .                                                  *\n*        ALL ARGUEMENTS GIVEN (NOTE: ANY ARGUEMENTS MAY STILL BE      *\n*        NULL):                                                       *\n*                  LINK  EP=DSCOPY,PARAM=(PARM-2,DDNAMES,CPYCNT)      *\n*                                                                     *\n*        SOME ARGUEMENTS NOT GIVEN:                                   *\n*                  LINK  EP=DSCOPY,PARAM=(,DDNAMES)                   *\n*                  .                                                  *\n*                  .                                                  *\n*                  .                                                  *\n*        PARM FIELD GIVEN:                                            *\n*                  DC    Y(L'PARM)                            07/96   *\n*         PARM     DC    C'TRUNCATE,COUNT=10000'              07/96   *\n*                                                                     *\n*        NULL PARM FIELD GIVEN:                                       *\n*                  DC    Y(0)                                 07/96   *\n*         PARM     DS    0X                                   07/96   *\n*                                                                     *\n*        COMPLETE DDNAME LIST GIVEN:                                  *\n*         DDNAMES  DC    Y(48)               LENGTH OF LIST           *\n*                  DC    CL8'INPUT'          CHANGE \"IN\" PREFIX TO    *\n*         *                                  \"INPUT\"                  *\n*                  DC    CL8'OUTPUT'         CHANGE \"OUT\" PREFIX TO   *\n*         *                                  \"OUTPUT\"                 *\n*                  DC    3XL8'00'            UNUSED ENTRIES           *\n*                  DC    CL8'PRINTER'        CHANGE \"SYSPRINT\"        *\n*         *                                  DDNAME TO \"PRINTER\"      *\n*                                                                     *\n*        PARTIAL DDNAME LIST GIVEN:                                   *\n*         DDNAMES  DC    Y(16)               LENGTH OF LIST           *\n*                  DC    CL8' '              DON'T CHANGE THE \"IN\"    *\n*         *                                  PREFIX                   *\n*                  DC    CL8'O'              CHANGE THE \"OUT\"         *\n*         *                                  PREFIX TO \"O\"            *\n*                                                                     *\n*        NULL DDNAME LIST GIVEN:                                      *\n*         DDNAME   DC    Y(0)                DDNAME LIST LENGTH       *\n*                                                                     *\n*        NOTE: BLANKS AND BINARY ZEROS ARE TREATED EQUVALENTLY IN     *\n*        THE DDNAME LIST ENTRIES - E.G. \" DC CL8'A' \" IS TREATED      *\n*        THE SAME WAY AS \" DC C'A',XL7'00' \".                         *\n*                                                                     *\n*        STARTING COPY NUMBER GIVEN:                                  *\n*         CPYCNT   DC    Y(3)                COPY # LENGTH            *\n*                  DC    C'200'              STARTING COPY #          *\n*                                                                     *\n*        NULL COPY NUMBER GIVEN:                                      *\n*         CPYCNT   DC    Y(0)                CPY # LENGTH             *\n*                                                                     *\n*                                                                     *\n*     2.) FOR \"FORTRAN\" USERS:                                        *\n*               .                                                     *\n*               .                                                     *\n*               .                                                     *\n*        NOTE THAT THE FIRST ELEMENT IN EACH ARAY DESCRIBED BELOW     *\n*        GIVES THE LENGTH IN BYTES OF THE REMAINDER OF THE ARAY.      *\n*                                                                     *\n*        PARM FIELD GIVEN:                                            *\n*               INTEGER*2 PARM(9)/8,'TR','UN','CA','TE'/      07/96   *\n*                                                                     *\n*        NULL PARM FIELD GIVEN:                                       *\n*               INTEGER*2 PARM/0/                                     *\n*                                                                     *\n*        COMPLETE DDNAME LIST GIVEN:                                  *\n*         C CHANGE \"IN\" PREFIX TO \"ABC\"                               *\n*         C CHANGE \"OUT\" PREFIX TO \"DE\"                               *\n*         C CHANGE \"SYSPRINT\" TO \"PRT\"                                *\n*               INTEGER*2 DDNAME(25)/48,'AB','C ',2*'  ','DE',        *\n*              X15*'  ','PR','T ',2*0/                                *\n*                                                                     *\n*        PARTIAL DDNAME LIST GIVEN:                                   *\n*         C DON'T CHANGE THE \"IN\" PREFIX                              *\n*         C DON'T CHANGE THE \"OUT\" PREFIX                             *\n*         C CHANGE \"SYSPRINT\" TO \"PAPER\"                              *\n*               INTEGER*2 DDNAME(25)/48,20*0,'PA','PE','R ','  '/     *\n*                                                                     *\n*        NULL DDNAME LIST GIVEN:                                      *\n*         C DON'T CHANGE ANY \"DDNAME\"'S                               *\n*               INTEGER*2 DDNAME/0/                                   *\n*                                                                     *\n*        NOTE: TRAILING BLANKS AND TRAILING ZEROS ARE TREATED         *\n*        EQUIVALENTLY IN THE DDNAME LIST ENTRIES - E.G. THE           *\n*        FOLLOWING ARE EQUIVALENT:                                    *\n*               INTEGER*2 DDNAME(5)/8,'A ',3*'  '/                    *\n*               INTEGER*2 DDNAME(5)/8,'A ',3*0/                       *\n*                                                                     *\n*        STARTING COPY NUMBER GIVEN:                                  *\n*               INTEGER*2 CPYCNT(3)/4,'77','34'/                      *\n*                                                                     *\n*        NULL COPY NUMBER GIVEN:                                      *\n*               INTEGER CPYCNT/0/                                     *\n*               .                                                     *\n*               .                                                     *\n*               .                                                     *\n*        ALL ARGUEMENTS GIVEN (NOTE: ANY ARGUEMENTS MAY STILL BE      *\n*        NULL):                                                       *\n*               CALL DSCOPY(PARM,DDNAME,CPYCNT)                       *\n*                                                                     *\n*        SOME ARGUEMENTS NOT GIVEN:                                   *\n*               CALL DSCOPY(PARM)                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* \"DSCOPY\" \"JCL\" EXAMPLES:                                            *\n*      //... JOB CARD ...                                             *\n*      //A EXEC PGM=DSCOPY                                            *\n*      //SYSPRINT DD SYSOUT=A                                         *\n*      //IN DD *                                                      *\n*      DATA CARD 1                                                    *\n*      DATA CARD 2                                                    *\n*      .                                                              *\n*      .                                                              *\n*      .                                                              *\n*      DATA CARD N                                                    *\n*      /*                                                             *\n*      //OUT DD SYSOUT=A                                              *\n*      //* THE ABOVE COPIES THE DATA CARDS ONTO THE PRINTER.          *\n*                                                                     *\n*                                                                     *\n*      //INA DD DSN=DATASET,UNIT=2314,VOL=SER=DISK,DISP=SHR           *\n*      // DD DSN=PDS(MEMBER),UNIT=2314,VOL=SER=DISK1,DISP=SHR         *\n*      // DD DSN=PDS(MEMBER1),UNIT=2314,VOL=SER=DISK1,DISP=SHR        *\n*      // DD *                                                        *\n*      DATA CARD 1                                                    *\n*      DATA CARD 2                                                    *\n*      /*                                                             *\n*      // DD DSN=DATASET2,UNIT=2400,VOL=SER=TAPE,DISP=SHR,            *\n*      // DCB=(RECFM=VB,LRECL=20,BLKSIZE=7294),LABEL=(2,NL)           *\n*      //OUTA DD DSN=DATASET3,UNIT=SYSDA,SPACE=(TRK,(10,10)),         *\n*      // DCB=RECFM=U,DISP=(,PASS)                                    *\n*      //* THIS IS AN EXAMPLE OF INPUT CONCATINATION, MIXED INPUT     *\n*      //* DCB ATRIBUTES, CHANGE OF ATRIBUTES FROM THE INPUT DATA     *\n*      //* SET TO THE OUTPUT DATA SET, AND USE OF DEFAULT ATRIBUTES   *\n*      //* FOR THE OUTPUT DATA SET (THE OUTPUT \"BLKSIZE\" IS ASSUMED   *\n*      //* TO BE EQUAL TO THE \"BLKSIZE\" OF THE FIRST INPUT DATA       *\n*      //* SET).                                                      *\n*                                                                     *\n***********************************************************************\n         TITLE 'DSCOPY -- Change History'                     07/96 DBC\n************************************************************* 08/05 DBC\n*                                                           * 08/05 DBC\n* Last Change Date - August 6, 2005                         * 08/05 DBC\n*                                                           * 08/05 DBC\n* Repackaged DSCOPY for shareware distribution via the      * 08/05 DBC\n* Internet.                                                 * 08/05 DBC\n*                                                           * 08/05 DBC\n* Added a copyright statement and summary legalese to the   * 08/05 DBC\n* SYSPRINT output.                                          * 08/05 DBC\n*                                                           * 08/05 DBC\n* Added a README file to the distribution package           * 08/05 DBC\n* containing extensive legalese and a comprehensive         * 08/05 DBC\n* installation and usage instructions.                      * 08/05 DBC\n*                                                           * 08/05 DBC\n* Ditto for the sorce code: Added extensive legalese,       * 08/05 DBC\n* installation instructions, and a reqork of the usage      * 08/05 DBC\n* instructions.                                             * 08/05 DBC\n*                                                           * 08/05 DBC\n* Replaced all obsolete DBCOLE.MACLIB macros with their     * 08/05 DBC\n* current versions so that this program can be successively * 08/05 DBC\n* assembler using the DBCOLE.MACLIB library available from  * 08/05 DBC\n* www.colesoft.com.                                         * 08/05 DBC\n*                                                           * 08/05 DBC\n* Updated obsolete contact information.                     * 08/05 DBC\n*                                                           * 08/05 DBC\n************************************************************* 08/05 DBC\n         SPACE 3                                              08/05 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n* Last Change Date - July 18, 1996                          * 07/96 DBC\n*                                                           * 07/96 DBC\n* Added support for PARM field keywords                     * 07/96 DBC\n*                                                           * 07/96 DBC\n* Added improved statistics messages to the SYSPRINT        * 07/96 DBC\n* output.                                                   * 07/96 DBC\n*                                                           * 07/96 DBC\n* Added unit-of-work commentary headers throughout the      * 07/96 DBC\n* code.                                                     * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         TITLE 'DSCOPY -- $PRINT MACRO'                             DBC\n         MACRO\n&N       $PRINT &MSGADR\n&N       LA    R15,&MSGADR-1       PNT TO MSG LEN FLD\n         BAL   R14,PUTSYSP         GO TO MSG PRTING ROUTINE\n         MEND\n         TITLE 'DSCOPY -- INITAL DEFFINITIONS'\n         GBLA  &MAXBUFS            MAX NUMBER OF BUFFERS\n         GBLA  &MINGET             MIN GETMAIN\n         SPACE 3\n*MAXBUFS SETA  50                  ALLOW 50 BUFS / DS\n&MAXBUFS SETA  5                   ALLOW 50 BUFS / DS  12/3/79     JRB\n&MINGET  SETA  60*1024+2*((96*&MAXBUFS+2047)/2048*2048)+2*(80+8)   JRB\n*        ALLOW SPACE FOR:\n*        OPEN, CLOSE, FDR/ABR DS NOT FOUND EXIT,                   JRB\n*        AND QSAM ROUTINES (60*1024) (WAS 6*1024) )                JRB\n*        SUFFICENT 2K BLOCKS FOR 96 BYTE IOB'S/ICB'S FOR EACH DCB\n*        MINIMAL BUFFER POOLS (FOR EMERGENCIES)\n         SPACE 1\n&MINGET  SETA  (&MINGET+15)/16*16  ROUND TO DUOBLE-DOUBLE WORD LENGTH\n         SPACE 3\n         #REGS R                                              08/05 DBC\n         TITLE 'DSCOPY -- INITALIZATION AND PARAMETER PROCESSING'\nDSCOPY   #ENTER SAVTYPE=(LOCAL,    STD NONREENTRANT RSA       08/05 DBC*\n               DSCSAVE),           RSA'S NAME                 08/05 DBC*\n               BASES=2             2 BASES (R13 AND R12)      08/05 DBC\n         MVI   RCD+1,0             ZERO THE RETURN CODE       08/05 DBC\n         MVC   IDDNAME(L'DCBDDNAM),=CL8'IN' INIT DDNAME\n         MVC   ODDNAME(L'DCBDDNAM),=CL8'OUT' INIT DDNAME\n         MVC   PRTDDNAM,=CL8'SYSPRINT' INIT DDNAME\n         ZAP   CPY#,=P'1'          INIT COPY COUNT\n         MVI   FLAG,0              CLEAR ALL FLAGS\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*             INPUT PARAMETERS PROCESSING                   * 07/96 DBC\n*                                                           * 07/96 DBC\n* I ACCEPT UP TO THREE INPUT PARAMETERS:                    * 07/96 DBC\n*     1ST - A STANDARD PARM FIELD                           * 07/96 DBC\n*     2ND - A SUBSTITUTE DDNAME LIST.                       * 07/96 DBC\n*     3RD - A STARTING COPY NUMBER.                         * 07/96 DBC\n* THE LAST USED PLIST SLOT MUST BE HI-FLAGGED.              * 07/96 DBC\n*                                                           * 07/96 DBC\n* SEE IF I HAVE RECEIVED ANY PARAMETERS AT ALL.             * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LTR   R7,R1               COPT PLIST PTR; ANY GIVEN? 07/96 DBC\n         BZ    NOPARAMS            NOPE; SKIP *ALL* THIS      07/96 DBC\n         LM    R2,R4,0(R7)         LOAD THE ENTIRE PLIST      07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*        2ND PARAMETER PROCESSING: DDNAMES LIST             * 07/96 DBC\n*                                                           * 07/96 DBC\n* (NOTE, PARM FIELD ANALYSIS (1ST PARAMATER PROCESSING) IS  * 07/96 DBC\n* POSTPONED UNTIL AFTER I OPEN SYSPRINT. THIS IS BECAUSE    * 07/96 DBC\n* PARM FIELD PROCESSING WILL GENERATE MESSAGES, BUT I DON'T * 07/96 DBC\n* KNOW WHAT MY SYSPRINT DDNAME IS UNTIL I CHECK FOR A       * 07/96 DBC\n* DDNAMES LIST {2ND PARAMETER}).                            * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LTR   R2,R2               IS THERE A 2ND PARAMETER?  07/96 DBC\n         BM    NOPARAMS            NO, SKIP OUT\n         LA    R5,0(,R3)           YES, CLEAR HI BYTE OF ITS ADR\n         LTR   R5,R5               IS 2ND PARAMETER OMITTED?\n         BZ    NODDN               YES, SKIP OUT\n         TM    7(R7),X'01'         NO, IS IT 1/2 WD ALIGNED?  07/96 DBC\n         BZ    DDNOK1              YES, CONTINUE\nBDDDN    OI    FLAG,BADDDNM        NO, SET ERROR FLAG\n         B     NODDN\nDDNOK1   LH    R0,0(,R3)           GET LENGTH OF DDN LIST\n         LTR   R0,R0               IS IT NULL?\n         BZ    NODDN               YES, SKIP OUT\n         BM    BDDDN               NO, IT'S INVALID; ERROR\n         TM    1(R3),X'07'         NO, IS LEN A MULT OF 8?\n         BNZ   BDDDN               NO, ERROR\n         SRL   R0,3                YES, GET # OF ENTRIES\n         SH    R3,=Y(L'DCBDDNAM-2) PNT TO LIST - 1 ENTRY\n         LA    R5,DDNPTRTB-4       PNT TO OUTPUT PTR TBL - 1 ENTRY\nDDNLP    LA    R3,L'DCBDDNAM(,R3)  PNT TO NEXT LIST ENTRY\n         CLI   0(R5),X'FF'         AT END OF PTR TBL?\n         BE    MUSTB0              YES, LIST ENTRY MUST BE 0\n         LA    R5,4(,R5)           NO, PNT TO NEXT PTR ENTRY\n         L     R6,0(,R5)           GET OUTPUT PTR\n         LTR   R6,R6               IS THERE ONE?\n         BZ    MUSTB0              NO, LIST ENTRY MUST BE 0\n         OC    0(L'DCBDDNAM,R3),0(R3) NO, IS LIST ENTRY 0?\n         BZ    DDNLPN              YES, GO TO NEXT ENTRY\n         TM    0(R3),X'BF'         NO, IS 1ST BYTE 0 OR BLANK?\n         BZ    BDDDN               YES, ERROR\n         MVC   0(L'DCBDDNAM,R6),0(R3) NO, MVC NEW DDN TO OUTPUT LOC\n         B     DDNLPN              GO PROCESS NEXT ENTRY\nMUSTB0   OC    0(L'DCBDDNAM,R3),0(R3) IS LIST ENTRY 0?\n         BNZ   BDDDN               NO, ERROR\nDDNLPN   BCT   R0,DDNLP            YES, GO PROCESS NEXT ENTRY\nNODDN    DS    0H                                             07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*     3RD PARAMETER PROCESSING: STARTING COPY NUMBER        * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         TM    4(R7),X'80'         IS THERE A 3RD PARAMETER?  07/96 DBC\n         BO    NOPARAMS            NO, SKIP OUT\n         LA    R4,0(,R4)           YES, ZERO HI BYTE OF ADR\n         LTR   R4,R4               IS 3RD PARAMETER OMITTED?\n         BZ    NOCPY#              YES, SKIP OUT\n         TM    11(R7),X'01'        NO, IS 1/2 WD ALIGNED?     07/96 DBC\n         BZ    CPY#OK1             YES, CONTINUE\nBDCPY#   OI    FLAG,BADCPY#        NO, SET ERROR FLAG\n         B     NOCPY#              SKIP OUT\nCPY#OK1  LH    R0,0(,R4)           GET PARAMETER LENGTH\n         LTR   R15,R0              SAVE FOR LATER; IS PARAM NULL?\n         BZ    NOCPY#              YES, SKIP OUT\n         BM    BDCPY#              NO, IF NEG. THEN ERROR\n         CH    R0,=Y(4)            NO, IS LENGTH TOO BIG?\n         BH    BDCPY#              YES, ERROR\nCPY#LP   LA    R4,1(,R4)           NO, PNT TO NEXT DIGIT\n         CLI   1(R4),C'0'          IS IT A DIGIT?\n         BL    BDCPY#              NO, ERROR\n         CLI   1(R4),C'9'          MAYBE, IS IT A DIGIT?\n         BH    BDCPY#              NO, ERROR\n         BCT   R0,CPY#LP           YES, GO CHECK NEXT DIGIT\n         SR    R4,R15              PNT BACK TO START OF PARAM\n         BCTR  R15,0               GET MACHINE LENGTH\n         EX    R15,CPY#PK          PACK GIVEN VALUE INTO CURRENT FLD\nNOCPY#   DS    0H                                             07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*     4TH PARAMETER PROCESSING: TOO MANY PARAMETERS         * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         TM    8(R7),X'80'         ARE THERE EXTRA OPERANDS?  07/96 DBC\n         BO    NOPARAMS            NO, FINISHED\n         OI    FLAG,TOOMP          YES, SET ERROR FLAG\nNOPARAMS DS    0H                                             07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* OPEN SYSPRINT AND INTRODUCE MYSELF.                       * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         OPEN  (SYSPRINT,OUTPUT)   TRY TO OPEN MSG DATASET    07/96 DBC\n         MVI   RCD+1,12            SET BAD RETURN CODE        07/96 DBC\n         TM    PRTOFLGS,X'10'      WAS OPEN OK?\n         BZ    EXIT                NO, GIVE UP\n         MVI   RCD+1,0             RESET RETURN CODE               JRB\n         SPACE 1                                              07/96 DBC\n         $PRINT CRIGHT             NAME AND COPYRIGHT         08/05 DBC\n         $PRINT LEGAL1             LEGALESE                   08/05 DBC\n         $PRINT LEGAL2             LEGALESE                   08/05 DBC\n         $PRINT LEGAL3             LEGALESE                   08/05 DBC\n         $PRINT LEGAL4             LEGALESE                   08/05 DBC\n         $PRINT LEGAL5             LEGALESE                   08/05 DBC\n         $PRINT LEGAL6             LEGALESE                   08/05 DBC\n         $PRINT LEGAL7             LEGALESE                   08/05 DBC\n         $PRINT SKIP3              WHITE SPACE                08/05 DBC\n         $PRINT DSCP               PRINT TITLE                08/05 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* IF PARAMETER PROCESSING ERRORS HAVE OCCURRED, THEN        * 07/96 DBC\n* EXPLAIN IT TO DUMMY HERE.                                 * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         TM    FLAG,TOOMP          TOO MANY OPERANDS?\n         BZ    #POK                NO, CONTINUE\n         MVI   RCD+1,4             YES, SET RET CDE\n         $PRINT TMEIPL             PRINT ERROR MESSAGE\n#POK     DS    0H                                             07/96 DBC\n         SPACE 1                                              07/96 DBC\n         TM    FLAG,BADCPY#        VALID COPY PARAMETER?      07/96 DBC\n         BZ    C#OK                YES, CONTINUE\n         MVI   RCD+1,4             NO, SET RET CODE\n         $PRINT IC#                PRINT ERROR MESSAGE\nC#OK     DS    0H                                             07/96 DBC\n         SPACE 1                                              07/96 DBC\n         TM    FLAG,BADDDNM        VALID DDNAME LIST?         07/96 DBC\n         BZ    DOK                 YES, CONTINUE\n         MVI   RCD+1,12            NO, SET RET CODE\n         $PRINT IDL                PRINT ERROR MSG\nDOK      DS    0H                                             07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*    1ST PARAMETER PROCESSING (FINALLY): THE PARM FIELD     * 07/96 DBC\n*                                                           * 07/96 DBC\n* SEE WHETHER OR NOT I EVEN HAVE A PARM FIELD. ISSUE AN     * 07/96 DBC\n* INFO MESSAGE IF I DON'T.                                  * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LTR   R7,R7               ARE THERE ANY PARAMETERS   07/96 DBC\n*                                  AT ALL?                    07/96 DBC\n         BZ    NOPARM              NO, GO ISSUE MSG           07/96 DBC\n         L     R1,0(,R7)           @'PARM FIELD               07/96 DBC\n         LA    R1,0(,R1)           PURIFY THE PARM FIELD PTR  07/96 DBC\n         LTR   R1,R1               IS THERE A PARM FIELD?     07/96 DBC\n         BZ    NOPARM              NO, GO ISSUE MESSAGE       07/96 DBC\n         LH    R3,0(,R1)           GET L'PARM FIELD           07/96 DBC\n         LTR   R3,R3               IS IT NULL?                07/96 DBC\n         BNZ   GOTPARM             NO, GO CHECK IT OUT        07/96 DBC\n         SPACE 1                                              07/96 DBC\nNOPARM   $PRINT PFN                \"PARM FIELD: NONE\"         07/96 DBC\n         B     PARMZ               DONE HERE                  07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* I'VE GOT A PARM FIELD. DETERMINE ITS LENGTH, EXTRACT IT,  * 07/96 DBC\n* AND UPCASE IT.                                            * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nGOTPARM  CL    R3,=A(L'PFTEXT)     IS L'PARM VALID AND        07/96 DBC\n*                                  REASONABLE?                07/96 DBC\n         BNH   PLENOK              YES, PROCEED               07/96 DBC\n         $PRINT PFIL               ISSUE ERROR MESSAGE        07/96 DBC\n         MVI   RCD+1,12            I'M GONNA ABORT            07/96 DBC\n         B     PARMZ               BLOW OUTTA HERE            07/96 DBC\nPLENOK   DS    0H                                             07/96 DBC\n         SPACE 1                                              07/96 DBC\n         OC    PFTEXT-1(*-*),1(R1) (EXECUTED)                 07/96 DBC\n         EX    R3,*-6              COPY PARM FIELD TO MSG     07/96 DBC\n*                                  BUFFER AND UPCASE IT.      07/96 DBC\n         SPACE 1                                              07/96 DBC\n         MVI   PFTEXT-1,C' '       CLEAN UP GARBAGE           07/96 DBC\n         CLC   PFTEXT,PFTEXT-1     IS THE PARM FIELD ALL      07/96 DBC\n*                                  BLANK?                     07/96 DBC\n         BE    NOPARM              YEP, AIN'T GOT ONE AFTER   07/96 DBC\n*                                  ALL.                       07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* OK, NOW IT'S TIME TO SCAN THE PARM FIELD. FIRST, DISPLAY  * 07/96 DBC\n* IT. THEN SET UP BXH SCAN CONTROLS, THEN STRIP OFF LEADING * 07/96 DBC\n* BLANKS AND COMMAS.                                        * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LA    R0,PFLEN-L'PFTEXT(,R3) L'PARM FIELD MSG        07/96 DBC\n         STC   R0,PF-1             STORE FOR PUTSYSP          07/96 DBC\n         $PRINT PF                 DISPLAY THE PARM FIELD     07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LA    R1,PFTEXT-1         @'UPCASED PARM FIELD -1    07/96 DBC\n         LA    R2,1                BXH INCRIMENT              07/96 DBC\n         ALR   R3,R1               BXH LIMIT                  07/96 DBC\n         SPACE 1                                              07/96 DBC\nPARMLP1  BALR  R14,0               TOL: STRIP LEADING BLANKS  07/96 DBC\n         BXH   R1,R2,PARMZ         ADVANCE                    07/96 DBC\n         CLI   0(R1),C' '          LEADING BLANK?             07/96 DBC\n         BER   R14                 YES, LOOP                  07/96 DBC\n         CLI   0(R1),C','          LEADING COMMA?             07/96 DBC\n         BER   R14                 YES, LOOP                  07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* IDENTIFY THE NEXT KEYWORD                                 * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LA    R4,PARMKEYS-(PKYWORD+1) LOAD KEYWORD TBL SCANR 07/96 DBC\n         SLR   R5,R5               CLEAR KEYWORD LENGTH REG   07/96 DBC\n         BALR  R14,0               TOL: KEYWORD TABLE SCAN    07/96 DBC\n         LA    R4,PKYWORD+1(R5,R4) ADVANCE TO NEXT TABLE SLOT 07/96 DBC\n         IC    R5,PKYEXLEN(,R4)    GET ITS TEXT LENGTH -1     07/96 DBC\n         CLC   PKYWORD(*-*,R4),0(R1) (EXECUTED)               07/96 DBC\n         EX    R5,*-6              RIGHT TRIAL KEYWORD YET?   07/96 DBC\n         BLR   R14                 NOT YET, KEEP SCANNING     07/96 DBC\n         BH    BADPARM             NOPE, MISSED. ERROR        07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LA    R1,1(R5,R1)         ADVANCE THE PARM FLD SCANR 07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* EXTRACT THE KEYWORD'S VALUE/MEANING AND \"STORE\" IT INTO   * 07/96 DBC\n* THE ASSOCIATED VALUE SINK. DO FLAG KEYWORDS FIRST.        * 07/96 DBC\n* (THEY'RE EASY.)                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         ICM   R15,15,PKYSINK(R4)  @'VALUE SINK; EXIST?       07/96 DBC\n         BZ    BADPARM             NOPE; SOMEHOW I MATCHED    07/96 DBC\n*                                  THE TABLE DELIMITER        07/96 DBC\n         ICM   R4,1,PKYOIFLG(R4)   GET KEYWORD'S MEANING      07/96 DBC\n*                                  FLAG. IS THERE ONE?        07/96 DBC\n         BZ    GET#                NO, THIS IS NOT A FLAG     07/96 DBC\n*                                  KEYWORD                    07/96 DBC\n         SPACE 1                                              07/96 DBC\n         CLI   0(R1),C' '          IS DELIMITER OK?           07/96 DBC\n         BE    PSETFLAG            YES, PROCEED               07/96 DBC\n         CLI   0(R1),C','          CHECK AGAIN                07/96 DBC\n         BNE   BADPARM             NO, ERROR.                 07/96 DBC\n         SPACE 1                                              07/96 DBC\nPSETFLAG OI    0(R15),*-*          (EXECUTED)                 07/96 DBC\n         EX    R4,*-4              STORE THE KEYWORD'S        07/96 DBC\n*                                  MEANING                    07/96 DBC\n         B     PARMLP1             DONE HERE. LOOP TO SCAN    07/96 DBC\n*                                  FOR THE NEXT KEYWORD.      07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* THE KEYWORD HAS A NUMERIC VALUE. EXTRACT IT, VCHECK IT,   * 07/96 DBC\n* AND STORE IT.                                             * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nGET#     L     R5,0(,R15)          GET KEYWORD'S PRIOR VALUE  07/96 DBC\n         CLR   R1,R3               IS THERE ENOUGH ROOM LEFT  07/96 DBC\n*                                  IN THE PARM FIELD FOR THE  07/96 DBC\n*                                  KEYWORD TO HAVE A VALUE?   07/96 DBC\n         BH    PARMGOT#            NO, THE KEYWORD HAS A NULL 07/96 DBC\n*                                  VALUE. LEAVE ITS PRIOR (OR 07/96 DBC\n*                                  ORIGINAL) VALUE            07/96 DBC\n*                                  UNDISTURBED.               07/96 DBC\n         TM    0(R1),C'0'          IS THE KEYWORD DIRECTLY    07/96 DBC\n*                                  FOLLOWED BY A NUMERIC      07/96 DBC\n*                                  VALUE?                     07/96 DBC\n         BNO   PARMLP3Z            NOPE, THE KEYWORD'S VALUE  07/96 DBC\n*                                  IS NULL.                   07/96 DBC\n         SPACE 1                                              07/96 DBC\n         SLR   R5,R5               CLEAR THE VALUE ACCUMULATR 07/96 DBC\n         BCTR  R1,0                BACK OFF THE SCANNER A     07/96 DBC\n*                                  LITTLE.                    07/96 DBC\n         BALR  R14,0               TOL: DECIMAL # EXTRACTION  07/96 DBC\n         BXH   R1,R2,PARMGOT#      ADVANCE TO NEXT DIGIT      07/96 DBC\n         TM    0(R1),C'0'          IS IT A DIGIT?             07/96 DBC\n         BNO   PARMLP3Z            NO, HOPE IT'S A VALID      07/96 DBC\n*                                  DELIMITER.                 07/96 DBC\n         M     R4,=F'10'           DECIMAL SHIFT THE          07/96 DBC\n*                                  ACCUMULATER                07/96 DBC\n         LTR   R4,R4               DID 32-BIT OVERFLOW        07/96 DBC\n*                                  OCCUR?                     07/96 DBC\n         BNZ   BADPARM             YES, ERROR.                07/96 DBC\n         IC    R4,0(,R1)           EXTRACT THE DIGIT          07/96 DBC\n         N     R4,=X'0000000F'     PURIFY IT.                 07/96 DBC\n         ALR   R5,R4               ACCUMULATE IT; DID A CARRY 07/96 DBC\n*                                  OCCUR?                     07/96 DBC\n         BC    3,BADPARM           YES, ERROR.                07/96 DBC\n         BR    R14                 LOOP FOR NEXT DIGIT        07/96 DBC\n         SPACE 1                                              07/96 DBC\nPARMLP3Z CLI   0(R1),C' '          EO-# BUT NOT EO-PARM;      07/96 DBC\n*                                  VALID DELIMITER?           07/96 DBC\n         BE    PARMGOT#            YES, PROCEED               07/96 DBC\n         CLI   0(R1),C','          VALID DELIMITER?           07/96 DBC\n         BNE   BADPARM             NO, ERROR.                 07/96 DBC\n         SPACE 1                                              07/96 DBC\nPARMGOT# ST    R5,0(,R15)          STORE THE EXTRACTED VALUE  07/96 DBC\n         B     PARMLP1             LOOP FOR NEXT PARM         07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* PARM FIELD ERROR. POINT OUT THE ERROR, THEN ABORT.        * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nBADPARM  MVC   PFTEXT,PFTEXT-1     CLEAR THE PARM DATA        07/96 DBC\n         MVI   0(R1),C'*'          FLAG THE ERROR POINT       07/96 DBC\n         MVC   PF,=C' ERROR-----> '                           07/96 DBC\n         #TEST SIZE=(L'PF,EQ,13)   DEPENDANCY CHECK           07/96 DBC\n         $PRINT PF                 DISPLAY THE ERROR MESSAGE  07/96 DBC\n         MVI   RCD+1,12            SET \"ABORT\" RC             07/96 DBC\nPARMZ    DS    0H                                             07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n* END OF ALL PARAMETER PROCESSING. ABORT IF SIGNIFICANT     * 07/96 DBC\n* ERRORS WERE FOUND.                                        * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         CLI   RCD+1,8             SHOULD I GIVE UP?          07/96 DBC\n         BNL   CLOSEPRT            YES, DO SO                 07/96 DBC\n         TITLE 'DSCOPY -- COPY PROCESSING SETUP'              07/96 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*                COPY PROCESSING SETUP                      * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LA    R1,INDCB            NO, PNT TO INDCB\n         BAL   R14,GETPFXLN        GO SET INDDNAM COMPARE PARAMS\n         LA    R1,OUTDCB           PNT TO OUTDCB\n         BAL   R14,GETPFXLN        GO SET OUTDDNAM COMPARE PARAMS\n         GETMAIN VC,LA=GETMQTY,A=GETMADR GET CORE FOR BUFFERS\n         LTR   R15,R15             WAS MIN REQUEST GOTTEN?\n         BZ    GTMOK               YES, CONTINUE\n         MVI   RCD+1,12            NO, SET RET CODE\n         $PRINT IC                 PRINT ERROR MSG\n         B     CLOSEPRT            QUIT\nGTMOK    L     R1,GETMADR          PNT TO GETMAIN'ED CORE\n         ST    R1,INBUFCB          INIT INPUT BUFFER PTR\n         A     R1,GETMADR+4        PNT TO END OF GOTTEN CORE\n         L     R0,GETMQTY          GET AMMOUNT TO GIVE BACK TO OS\n         SH    R0,=Y(2*(80+8))     ADJUST FOR MIN BUF REQUIREMENT\n         SR    R1,R0               PNT TO START OF CORE TO FREE\n         FREEMAIN R,LV=(0),A=(1)   GIVE OS SOME ELBOW ROOM\n         L     R1,GETMADR+4        GET ORIGINAL L'GOTTEN CORE 07/96 DBC\n         LA    R1,2*(80+8)(,R1)    AJD FOR MIN BUF REQUIREMENT\n         S     R1,GETMQTY          ADJUST FOR FREED CORE\n         ST    R1,GETMADR+4        SAVE LEN FOR FINAL FREEMAIN\n         SRL   R1,1                GET BUF SPACE FOR EA DCB\n         LR    R0,R1               REPLICATE\n         A     R1,GETMADR          PNT TO OUTPUT BUFFER AREA\n         ST    R1,OUTBUFCB         INIT OUTPUT BUFFER PTR\n         SH    R0,=Y(8)            ADJUST AMMOUNT FOR BUF CNTRL BLK\n         ST    R0,MAXCR            SAVE FOR LATER\n         L     R1,CVTPTR           PNT TO CVT\n*        L     R1,CVTTCBP-CVTDSECT(,R1) PNT TO NEW/OLD TCB PTRS\n         L     R1,0(,R1)           POINT TO TCB POINTER.           JRB\n         L     R1,4(,R1)           PNT TO OUR TCB\n         L     R1,12(,R1)          PNT TO TIOT\n         LA    R1,24(,R1)          PNT TO 1ST DD ENTRY IN TIOT\n         ST    R1,TIOTADR          SAVE IT\n         TITLE 'DSCOPY -- DATASET COPY LOOP'                  07/96 DBC\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*                  DATASET COPY LOOP                        * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nCOPYLP   NI    FLAG,TRUNC          CLEAR MOST OF FLAG BYTE\n         NI    FLAG2,0             CLEAR FLAG BYTE\n         BAL   R14,ITIOT           GO FIND NEXT INPUT DDNAME\nOTIOTLP  BAL   R14,OTIOT           FIND NEXT OUTPUT DDN TO COPY\nENDTST   TM    FLAG,OUTEND+INEND   BOTH DDNAMES MISSING?\n         BO    FREECORE            YES, END OF PROGRAM\n         MVC   COPYTIT+8(3),EDMSK+8 NO, SET UP -\n         ED    COPYTIT+7(4),CPY#    COPY TITLE\n         AP    CPY#,=P'1'          INCR CPY COUNT FOR NEXT\n         $PRINT SKIP3              SKIP A FEW LINES           07/96 DBC\n         $PRINT COPYTIT            PRINT THE COPY TITLE\n         CLC   INWORK(L'DCBDDNAM),OUTWORK IS THE IN/OUT PAIR MATCHED?\n         BE    OPEN                YES, GO START COPYING\n         BH    INMSNG              NO, INPUT DDNAME MISSING\n         OI    FLAG,OUTMISS        NO, FLAG OUTPUT DDNAME MISSING\n         B     PUTDDNMS            CONTINUE\nINMSNG   OI    FLAG,INMISS         FLAG INPUT DDNAME MISSING\nPUTDDNMS MVI   PRNTM+1,INMISS      SET INPUT DDNAME MISSING TEST MASK\n         LA    R2,INDCB            GET INPUT DCB\n         BAL   R14,PRNTDDCC        GO PRINT INPUT DDNAME (IF ANY)\n         MVI   PRNTM+1,OUTMISS     SET OUTPUT DDNAME MISSING TEST MASK\n         LA    R2,OUTDCB           GET OUTPUT DCB\n         BAL   R14,PRNTDDCC        GO PRINT OUTPUT DDNAME (IF ANY)\n         TM    FLAG,INMISS         IS INPUT DDNAME MISSING?\n         BO    OTIOTLP             YES, GO GET NEXT OUTPUT DDNAME\n         BAL   R14,ITIOT           GO FIND NEXT INPUT DDNAME\n         B     ENDTST              LOOP BACK\n         SPACE 1                                              07/96 DBC\nOPEN     LA    R8,1                COUNTER INCRIMENT          07/96 DBC\n         SR    R9,R9               INIT INPUT RECORD COUNT    07/96 DBC\n         SR    R10,R10             INIT OUTPUT RECORD COUNT\n         SLR   R11,R11             INIT INPUT RECORDS COPIED  07/96 DBC\n         SP    INCNT,INCNT         INIT INPUT DATA SET COUNT\n         LA    R1,INDCB            PNT TO INPUT DCB\n         BAL   R14,DCBINIT         GO (RE)INITALIZE DCB\n         LA    R1,OUTDCB           PNT TO OUTPUT DCB\n         BAL   R14,DCBINIT         GO (RE)INITALIZE OUTPUT DCB\n         OPEN  (IN,(INPUT,LEAVE),OUT,(OUTPUT,LEAVE)) OPEN DS'S\n         TM    INOFLGS,X'10'       IS THE INPUT DCB OPENED?\n         BZ    NOCOPY              NO, GO SAY SO\n         TM    OUTOFLGS,X'10'      YES, IS THE OUTPUT DCB OPENED?\n         BZ    NOCOPY              NO, GO SAY SO\n         TM    FLAG,CPYSUPRS       YES, SHOULD COPY BE SUPPRESSED?\n         BZ    OPENOK              NO, GO COPY\nNOCOPY   $PRINT CS                 NO, SAY SO\n         CLI   RCD+1,8             IS RET CODE HIGH ENOUCH?\n         BNL   CLOSE               YES, GO MAKE SURE DS'S ARE CLOSED\n         MVI   RCD+1,8             NO, RESET RET CODE\n         B     CLOSE               GO CLOSE THE OTHER DATA SET\n         TITLE 'DSCOPY -- COPY ROUTINE'\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*               LOGICAL RECORD COPY LOOP                    * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nOPENOK   NI    FLAG,255-REREAD     TURN OFF REREAD FLAG\n         OI    FLAG2,CONCAT        FLAG ICO CONCAT FOR INEXIT\n         LH    R4,LRECL            GET OUTPUT DATA LENGTH\n         SPACE 1                                              07/96 DBC\nGET      CL    R9,STOP#            HAVE I COPIED THE STOP     07/96 DBC\n*                                  RECORD?                    07/96 DBC\n         BNL   WRAPUP              YES, TERMINATE THIS COPY   07/96 DBC\n         CL    R11,COUNT#          HAVE I COPIED THE REQUIRED 07/96 DBC\n*                                  NUMBER OF RECORDS?         07/96 DBC\n         BNL   WRAPUP              YES, TERMINATE THIS COPY   07/96 DBC\n         SPACE 1                                              07/96 DBC\n         GET   IN                  GET AN INPUT RECORD        07/96 DBC\n         TM    FLAG,REREAD         HAS CONCATINATION OCCURED?\n         BZ    NOREREAD            NO, CONTINUE\n         TM    INOFLGS,X'10'       YES, WAS DATA SET REOPENED OK?\n         BO    OPENOK              YES, GO REREAD\n         $PRINT CT                 NO, ISSUE MESSAGE\n         B     WRAPUP              GO WRAP UP THIS COPY\n         SPACE 1                                              07/96 DBC\nNOREREAD ALR   R9,R8               INCR RECORDS IN COUNTER    07/96 DBC\n         CL    R9,START#           HAVE I REACHED THE START   07/96 DBC\n*                                  RECORD?                    07/96 DBC\n         BL    GET                 NOT YET, SKIP              07/96 DBC\n         ALR   R11,R8              COUNT COPIED RECORD        07/96 DBC\n         LR    R2,R1               SAVE INPUT RCD PTR\n         SPACE 1                                              07/96 DBC\nINGT     B     *-*                 INPUT RECFM GATE\n         SPACE 1                                              07/96 DBC\nINU      DS    0H                  INPUT RECFM=U\nINF      LH    R3,INLRECL          INPUT RECFM=F: GET LRECL\n         B     PUT                 GO WRITE RCD\n         SPACE 1                                              07/96 DBC\nINV      MVC   HWD,0(R2)           INPUT RECFM=V: GET RCD LENGTH\n         LH    R3,HWD              GET LRECL\n         SH    R3,=Y(4)            GET DATA LENGTH\n         LA    R2,4(,R2)           PNT TO DATA FIELD\n         SPACE 1                                              07/96 DBC\nPUT      ALR   R10,R8              INCR RECORDS OUT COUNTER   07/96 DBC\n         LR    R5,R3               SAVE INPUT DATA LENGTH\n         CR    R3,R4               COMPARE INPUT VS OUTPUT DATA LENGTHS\n         BNH   OUTGT               IF INPUT NOT LONG, CONTINUE\n         LR    R5,R4               ELSE, ADJUST INPUT LENGTH\n         SPACE 1                                              07/96 DBC\nOUTGT    B     *-*                 OUTPUT RECFM GATE\n         SPACE 1                                              07/96 DBC\nOUTU     STH   R5,OUTLRECL         SET OUTPUT LRECL\n         PUT   OUT                 GET OUTPUT BUFFER\n         SPACE 1                                              07/96 DBC\nMVCRCD   BAL   R14,MVC             MOVE RCD TO OUTPUT BUFFER\n         ALR   R1,R5               ADVANCE TO Z'SINK          08/05 DBC\n         ALR   R2,R5               ADVANCE TO Z'SOURCE        08/05 DBC\nTRUNCTST TM    FLAG,TRUNC          DO WE SPAN THE RECORD?\n         BO    GET                 NO, GO GET NEXT RCD\n         SR    R3,R4               YES, IS RDC TOO LONG?\n         BNP   GET                 NO, GO GET NEXT RCD\n         B     PUT                 YES, GO PUT NEXT RD SEGMENT\n         SPACE 1                                              07/96 DBC\nOUTF     PUT   OUT                 GET OUTPUT BUFFER\n         BAL   R14,MVC             MOVE RDC TO OUTPUT BUFFER\n         ALR   R1,R5               ADVANCE TO Z'SINK          08/05 DBC\n         ALR   R2,R5               ADVANCE TO Z'SOURCE        08/05 DBC\n         LR    R5,R3               RESTORE INPUT LRECL\n         SR    R5,R4               COMPARE INPUT VS OUTPUT RCD LENGTHS\n         BNM   TRUNCTST            IF \u00ac SHORT, GO TST 4 TRUNCATION\n         MVI   0(R1),C' '          SET INITAL PAD BLANK\n         LPR   R5,R5               GET PADDING LENGTH\n         BCTR  R5,0                DECR FOR INITAL PAD BLANK\n         LTR   R5,R5               WAS INITAL SUFFICENT?\n         BNP   GET                 YES, GO GET NEXT RCD\n         LR    R2,R1               NO, GET SOURCE PAD PTR\n         LA    R1,1(,R1)           GET OUTPUT PAD PTR\n         BAL   R14,MVC             GO PAD OUT RCD\n         ALR   R1,R5               ADVANCE TO Z'SINK          08/05 DBC\n         ALR   R2,R5               ADVANCE TO Z'SOURCE        08/05 DBC\n         B     GET                 GO GET NEXT RCD\n         SPACE 1                                              07/96 DBC\nOUTV     LA    R6,4(,R5)           ADJUST FOR LENGTH FIELD\n         STH   R6,HWD              SET UP LENGTH FIELD\n         STH   R6,OUTLRECL         SET OUTPUT LRECL\n         PUT   OUT                 GET OUTPUT BUFFER\n         MVC   0(4,R1),HWD         MVC LENGTH FIELD TO RECORD\n         LA    R1,4(,R1)           PNT PAST LENGTH FIELD\n         B     MVCRCD              GO MOVE RECORD TO BUFFER\n         TITLE 'DSCOPY -- END OF COPY ROUTINE'\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*               END-OF-FILE PROCESSING                      * 07/96 DBC\n*                                                           * 07/96 DBC\n* DISPLAY THE FOLLOWING:                                    * 07/96 DBC\n*   - THE 1ST INPUT RECORD# COPIED.                         * 07/96 DBC\n*   - THE LAST INPUT RECORD# COPIED.                        * 07/96 DBC\n*   - THE NUMBER OF INPUT RECORDS COPIED.                   * 07/96 DBC\n*   - THE NUMBER OF OUTPUT RECORDS WRITTEN.                 * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nWRAPUP   MVI   RIO,C'0'            CCC                        07/96 DBC\n         MVC   RIOWHICH(5),=C'FIRST'                          07/96 DBC\n         MVC   RIOINOUT(L'INNME),INNME                        07/96 DBC\n         MVI   RIOPLURL,C' '                                  07/96 DBC\n         MVC   RIOVERB(7),=C'COPIED '                         07/96 DBC\n         L     R0,START#           #'1ST RECORD COPIED        07/96 DBC\n         BAL   R14,PUTTOTL         COMPLETE AND SEND THE MSG  07/96 DBC\n         SPACE 1                                              07/96 DBC\n         MVI   RIO,C' '            CCC                        07/96 DBC\n         MVC   RIOWHICH(5),=C' LAST'                          07/96 DBC\n         LR    R0,R9               #'LAST RECORD COPIED       07/96 DBC\n         BAL   R14,PUTTOTL         COMPLETE AND SEND THE MSG  07/96 DBC\n         SPACE 1                                              07/96 DBC\n         MVC   RIOWHICH(5),=C'TOTAL'                          07/96 DBC\n         MVI   RIOPLURL,C'S'                                  07/96 DBC\n         LR    R0,R11              #'INPUT RECORDS COPIED     07/96 DBC\n         BAL   R14,PUTTOTL         COMPLETE AND SEND THE MSG  07/96 DBC\n         SPACE 1                                              07/96 DBC\n         MVC   RIOINOUT(L'OUTNME),OUTNME                      07/96 DBC\n         MVC   RIOVERB(7),=C'WRITTEN'                         07/96 DBC\n         LR    R0,R10              #'OUTPUT RECORDS WRITTEN   07/96 DBC\n         BAL   R14,PUTTOTL         COMPLETE AND SEND THE MSG  07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* IF A COUNT= VALUE WAS GIVEN, THEN INCRIMENT THE START=    * 07/96 DBC\n* VALUE BY THE COUNT= VALUE. THIS MAKES IT EASIER TO        * 07/96 DBC\n* SEGMENT A VERY LARGE DATASET INTO SEVERAL SMALLER ONES    * 07/96 DBC\n* VIA SUCCESSIVE COPIES.                                    * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         L     R0,COUNT#           GET THE COUNT= VALUE       07/96 DBC\n         CL    R0,=X'FFFFFFFF'     WAS ONE GIVEN?             07/96 DBC\n         BE    SEGMENTZ            NO, FORGET IT              07/96 DBC\n         SPACE 1                                              07/96 DBC\n         L     R15,START#          GET START= VALUE           07/96 DBC\n         ALR   R15,R0              INCRIMENT; OVERFLOW?       07/96 DBC\n         BC    12,NEWSTART         NO, PROCEED                07/96 DBC\n         L     R15,=X'FFFFFFFF'    TRUNCATE TO MAX VALUE      07/96 DBC\nNEWSTART ST    R15,START#          STORE                      07/96 DBC\nSEGMENTZ DS    0H                                             07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* FINALLY, CLUSE THE FILES AND LOOP TO PERFORM NEXT COPY.   * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nCLOSE    CLOSE (IN,LEAVE,OUT,LEAVE) CLOSE THE DATA SETS\n         B     COPYLP              GO PERFORM NEXT COPY       07/96 DBC\n         TITLE 'DSCOPY -- END OF PROGRAM ROUTINE'\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*              END-OF-PROGRAM PROCESSING                    * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nFREECORE FREEMAIN V,A=GETMADR      FREE THE BUFFERS\nCLOSEPRT $PRINT SKIP3              SKIP A FEW MSG LINES       07/96 DBC\n         CLI   RCD+1,12            IS RET CODE TERMINAL?\n         BL    PUTEOP              NO, GO PRT NORMAL EOP MSG\n         $PRINT PT                 YES, PUT PGM TERMINATE MSG\n         B     GETRCD              GO PROCESS RET CODE\nPUTEOP   $PRINT EOP                ISSUE EOP MSG\nGETRCD   LH    R2,RCD              GET RETURN CODE\n         MVC   RCDMSG+15(3),EDMSK+8 MOVE EDIT MASK TO MSG\n         CVD   R2,CVDWA            CNVRT RETURN CODE TO DEC\n         ED    RCDMSG+14(4),CVDWA+6 EDIT RCD INTO MSG\n         $PRINT RCDMSG             ISSUE RET CODE MSG\n         CLOSE (SYSPRINT,LEAVE)    CLOSE THE MESSAGE DATA SET\n         FREEPOOL SYSPRINT         FREE ITS BUFFERS\nEXIT     DS    0H                  RECEIVE BRANCHES\n         LH    R15,RCD             GET THE RETURN CODE        07/96 DBC\n         #EXIT ((R14,R12)),RC=(R15) RETURN TO CALLER          08/05 DBC\n         TITLE 'DSCOPY -- DCBINIT (1ST LEVEL SUBROUTINE) - (RE) INITALI*\n               ZE DCB''S FOR OPEN'\n         USING DCBDSECT,R1         DECLARE DCB BASE\nDCBINIT  MVI   DCBRECFM,0          INIT RECFM\n         MVI   DCBOPTCD,0          INIT OPTCD\n         STH   R9,DCBLRECL         ZERO LRECL\n         STH   R9,DCBBLKSI         ZERO BLKSIZE\n         BR    R14                 RETURN\n         DROP  R1                  KILL DCB BASE\n         TITLE 'DSCOPY -- GETPFXLN (1ST LEVEL SUBROUTINE) - GENERATE DD*\n               NAME COMPARE AND SHIFT VALUES'\n         USING DCBDSECT,R1         DECLARE DCB BASE\nGETPFXLN LA    R0,L'DCBDDNAM       GET MAX DDNAME LENGTH\n         LA    R15,DDNAME+L'DCBDDNAM PNT TO END OF DDNAME\nPFXLNLP  BCTR  R0,0                DECRIMENT PREFIX LENGTH\n         BCTR  R15,0               DECRIMENT CHARACTER PTR\n         TM    0(R15),X'BF'        PNTING TO ZERO OR BLANK?\n         BNZ   PFXLPND             NO, BREAK LOOP\n         MVI   0(R15),0            YES, ENSURE TRAILING ZERO\n         B     PFXLNLP             LOOP TO NEXT CHARACTER\nPFXLPND  STH   R0,PFXLN            SAVE PREFIX MACHING LENGTH\n         AH    R0,=Y(1)            GET ACTUAL LENGTH\n         SLL   R0,3                CNVRT TO BIT COUNT\n         STH   R0,SFXLN            SAVE IT FOR LATER SHIFT LOGICALS\n         BR    R14                 RETURN\n         DROP  R1                  KILL DCB BASE\n         TITLE 'DSCOPY -- INEXIT (1ST LEVEL SUBROUTINE) - INPUT DCB EXI*\n               T'\nINEXIT   ST    R14,SAVE14A         SAVE RETURN ADDRESS\n         LA    R2,IN               GET DCB ADDRESS\n         USING DCBDSECT,R2         DECLARE DCB BASE\n         MVC   SAVESA(18*4),0(R13) SAVE THE SAVE AREA\n         OI    INOFLGS,X'08'       FLAG POSSIBLE INPUT CONCATINATION\n         OI    FLAG,REREAD         FLAG POSSIBLE CONCAT REREAD\n         AP    INCNT,=P'1'         INCR INPUT DATA SET COUNT\n         MVC   IN#+19(3),EDMSK+8   MOVE EDIT MASK TO MESSAGE\n         ED    IN#+18(4),INCNT     EDIT COUNT INTO MSG\n         $PRINT IN#                PRINT INPUT CONCAT SEQ MSG\n         MVI   DDNMSG,C' '         SET NEXT MSG'S CARRAGE CNTL\n         BAL   R14,PRNTNMES        DO FURTHER PROCESSING\n         BC    8,EXITERR           IF ERROR, QUIT\n         NI    FLAG,255-UNITRCD    DON'T CONFUSE OUTEXIT\n         LA    R3,INGT             PNT TO INPUT F, V, OR U GATE\n         BAL   R14,GETRECFM        PROCESS RECFM\n         OC    INBLKSI,INBLKSI     IS BLKSIZE GIVEN?\n         BNZ   IPROCLRC            YES, CONTINUE\n         $PRINT BLKSIERR           NO, PRINT ERROR MESSAGE\n         B     EXITERR             QUIT\nIPROCLRC BAL   R14,GETBUFS         GET BUFFERS\n         BC    8,EXITERR           IF ERROR, QUIT\n         LH    R14,LRECL           SAVE OUTPUT'S LRECL ICO CONCAT\n         STH   R15,LRECL           SET INPUT'S LRECL\n         TM    FLAG2,CONCAT        IS THIS A CONCATINATION?\n         BZ    EXITRTRN            NO, EXIT TO OPEN\n         LR    R15,R14             YES, GET OUTPUT'S LRECL\n         B     OVSIMSG             GO PRINT DATA LEN COMPARE MSG\nEXITERR  MVI   DCBRECFM,X'C0'      BAD DCB INFORMATION -\n         MVC   DCBBLKSI,=Y(80)      CORRECT DCB SO OPEN WONT ABEND\n         OI    FLAG,CPYSUPRS       FLAG TO SUPPRESS COPYING\n         LA    R3,80               GET BUFFER LENGTH\n         LA    R5,1                GET BUFNO\n         LA    R14,EXITRTRN        GET RETURN ADDRESS\n         ST    R14,SAVE14B         SAVE IT\n         B     ERRBUILD            MAKE OPEN HAPPY: BUILD SOME BUFFERS\nEXITRTRN MVC   0(18*4,R13),SAVESA  RESTORE THE SAVE AREA\nLEVL1RET L     R14,SAVE14A         RESTORE RETURN ADDRESS\n         BR    R14                 RETURN\n         DROP  R2                  KILL DCB ADDRESSABILITY\n         TITLE 'DSCOPY -- IOERR (1ST LEVEL SUBROUTINE) - SYNAD EXIT'\nIOERR    SYNADAF ACSMETH=QSAM      GET SYNAD MESSAGE\n         L     R13,4(,R13)         RESTORE BASE REGISTER\n         CLC   133(3,R1),=AL3(SYSPRINT) IS ERROR ON SYSPRINT?\n         BNE   NOABND              NO, CONTINUE\n         LA    R15,82              YES, GET LENGTH OF WTO\n         SLL   R15,16              SHIFT TO 1ST 1/2 WORD\n         O     R15,=X'00008000'    SET MCS BIT\n         ST    R15,46(,R1)         INIT WTO PREFIX FIELD\n         LA    R15,X'20'           GET ROUTE CODE (11)\n         ST    R15,128(,R1)        INIT WTO SUFIX FIELD\n         WTO   MF=(E,46(R1))       ISSUE I/O ERROR MSG\n         ABEND 1,DUMP              GIVE UP\nNOABND   LA    R15,37(,R1)         PNT TO START OF ERROR MSG\n         MVC   0(13,R15),=C'!0I/O ERROR: ' SET MSG LEN & PREFIX\n         BAL   R14,PUTSYSP         GO PRINT MSG\n         $PRINT CT                 ISSUE COPY ENDED MSG\n         L     R13,8(,R13)         RESTORE SYNAD SAVE AREA PTR\n         DROP  R13                 MAIN BASE NOT USABLE AGAIN\n         SR    R15,R15             SET NEG R15 TO -\n         BCTR  R15,0                SIGNEL SYNADRLS\n         SVC   68                  ISSUE SYNADRLS\n         USING DSCSAVE,R13         MAIN BASE RESTORED BY SYNADRLS\n         CLI   RCD+1,8             IS RET CODE ALREADY HIGH?\n         BNL   WRAPUP              YES, GO WRAP UP COPY\n         MVI   RCD+1,8             NO, SET RET CODE\n         B     WRAPUP              GO WRAP UP COPY\n         TITLE 'DSCOPY -- MVC (1ST LEVEL SUBROUTINE) - CHARACTER MOVING*\n                ROUTINE'\nMVC      #XXC  MVC,                OPERATION                  08/05 DBC*\n               (R1),               TO POINTER                 08/05 DBC*\n               (R2),               FROM POINTER               08/05 DBC*\n               (R5),               LENGTH                     08/05 DBC*\n               MF=SUBROUTINE       FORM TO GENERATE           08/05 DBC\n         TITLE 'DSCOPY -- OUTEXIT (1ST LEVEL SUBROUTINE) - OUTPUT DCB E*\n               XIT'\nOUTEXIT  ST    R14,SAVE14A         SAVE RETURN ADDRESS\n         LA    R2,OUTDCB           PNT TO OUTPUT DCB\n         USING DCBDSECT,R2         DECLARE DCB BASE\n         MVC   SAVESA(18*4),0(R13) SAVE THE SAVE AREA\n         MVI   DDNMSG,C'0'         SET NEXT MSG CARRAGE CONTROL\n         BAL   R14,PRNTNMES        GO DO FURTHER PROCESSING\n         BC    8,EXITERR           IF ERROR, QUIT\n         CLI   OUTRECFM,0          IS RECFM GIVEN?\n         BNE   RFNTNULL            YES, STAY WITH IT\n         MVC   OUTRECFM,INRECFM    NO, GET INPUT'S RECFM\nRFNTNULL TM    FLAG,UNITRCD        UNIT RECORD DEVICE?\n         BZ    GOGETRFM            NO, CONTINUE\n         NI    OUTRECFM,255-X'10'  YES, KILL BLOCKING\nGOGETRFM LA    R3,OUTGT            PNT TO OUTPUT F-V-U GATE\n         BAL   R14,GETRECFM        GO PROCESS RECFM\n         OC    OUTBLKSI,OUTBLKSI   IS BLKSIZE GIVEN?\n         BNZ   OPROCLRC            YES, GO PROCESS\n         OC    OUTBLKSI,INBLKSI    NO, GET INPUT'S; ALSO OMITTED?\n         BZ    EXITERR             YES, QUIT\n         OC    OUTLRECL,OUTLRECL   NO, IS LRECL GIVEN?\n         BNZ   OPROCLRC            YES, GO PROCESS\n         MVC   OUTLRECL,INLRECL    NO, USE INPUT'S\nOPROCLRC BAL   R14,GETBUFS         GO GET OUTPUT BUFFERS\n         BC    8,EXITERR           IF ERROR, QUIT\n         TM    FLAG,CPYSUPRS       COPY ALREADY SUPPRESSED?\n         BO    EXITRTRN            YES, QUIT EXIT\nOVSIMSG  LA    R1,27               GET MESSAGE LENGTH\n         MVI   RLC+20,C'='         ASSUME OUT LRECL = IN LRECL\n         CH    R15,LRECL           CMPR RTRN'ED DATA LEN W INPUT'S\n         BE    PUTRLC              IF =, GO PRINT MSG\n         STH   R15,LRECL           MUST = OUTPUT DATA LEN\n         BH    OGTI                IF >, GO MODIFY MSG\n         MVI   RLC+20,C'<'         LESS; SET MSG\n         LA    R1,L'RLC            ADJUST MSG LENGTH\n         MVC   RLC+44(15),=CL15'WHEN NECESSARY' ADJUST MSG\n         MVC   RLC+35(8),=CL8' \"SPAN\"' ASSUME SPANNING\n         TM    FLAG,TRUNC          DO WE REALLY TRUNCATE ON LONG RCDS?\n         BZ    PUTRLC              NO, GO PRINT MSG\n         MVC   RLC+35(8),=CL8'TRUNCATE' YES, SAY SO\n         B     PUTRLC              GO PRINT MSG\nOGTI     MVI   RLC+20,C'>'         SAY OUTPUT > INPUT\n         TM    OUTRECFM,X'40'      IS RECFM F?\n         BO    PUTRLC              NO, GO PRINT MSG\n         LA    R1,L'RLC            YES, ADJUST MSG LENGTH\n         MVC   RLC+35(24),=C'PAD WITH BLANKS ON RIGHT' ADJ MSG\nPUTRLC   STC   R1,RLC-1            SET MSG LENGTH\n         $PRINT RLC                PRINT THE MSG\n         B     EXITRTRN            GO RETURN TO OPEN\n         DROP  R2                  KILL DCB ADDRESSABILITY\n         TITLE 'DSCOPY -- PUTTOTL (1ST LEVEL SUBROUTINE) - PUT RECORDS *\n               COPIED MESSAGES'\n************************************************************* 07/96 DBC\n*                                                           * 07/96 DBC\n*                    PUTTOTL                                * 07/96 DBC\n*                                                           * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         USING DCBDSECT,R1         DECLARE DCB BASE\nPUTTOTL  ST    R14,SAVE14A         SAVE RETURN ADDRESS\n         MVC   RIOCOUNT+1(L'RIOCOUNT-1),=X'20206B2020206B2020206B202120*\n               '                   XX-GIG EDIT MASK           07/96 DBC\n         CVD   R0,CVDWA            CNVRT COUNT RO DECIMAL     07/96 DBC\n         ED    RIOCOUNT,CVDWA+2    CNVRT TO TEXT              07/96 DBC\n         $PRINT RIO                PRINT THE MESSAGE\n         B     LEVL1RET            GO RETURN\n         DROP  R1                  KILL DCB BASE\n         TITLE 'DSCOPY -- TIOTSRCH (1ST LEVEL SUBROUTINE) - DDNAME SEAR*\n               CHING ROUTINE'\nITIOT    MVI   TIOTSMSK+1,INEND    SET INPUT LIST EXHAUSTED BIT\n         LA    R2,INDCB            PNT TO INPUT DCB\n         B     TIOTSRCH            SEARCH FOR DDNAME\nOTIOT    MVI   TIOTSMSK+1,OUTEND   SET OUTPUT LIST EXHAUSTED TEST BIT\n         LA    R2,OUTDCB           PNT TO OUTPUT DCB\n         USING DCBDSECT,R2         DECLARE DCB BASE\nTIOTSRCH NI    FLAG,255-INMISS-OUTMISS TURN OFF DDNMAE MISSING BITS\n         SR    R0,R0               ZERO FOR GETTING DD ENTRY LENGTHS\n         L     R15,TIOTADR         PNT TO 1ST DD ENTRY\n         MVI   WORK,X'FF'          SET NEW DDNAME TO -\n         MVC   WORK+1(L'DCBDDNAM-1),WORK HIGHEST COALATE\n         MVC   TIOTCLC+1(1),PFXLN+1 GET DDNAME PREFIX LEN\nTIOTLP   AR    R15,R0              PNT TO NEXT DD ENTRY\n         IC    R0,0(,R15)          GET ITS LENGTH\n         LTR   R0,R0               PAST LAST ENTRY?\n         BZ    TIOTLPND            YES, QUIT LOOP\nTIOTCLC  CLC   DDNAME(*-*),4(R15)  NO, DDNAME HAS PROPER PREFIX?\n         BNE   TIOTLP              NO, LOOP BACK\n         CLC   DDNAME(L'DCBDDNAM),4(R15) YES, IS DDNAME TOO LOW?\n         BNL   TIOTLP              YES, LOOP BACK\n         CLC   WORK(L'DCBDDNAM),4(R15) NO, IS DDNAME TOO HIGH?\n         BNH   TIOTLP              YES, LOOP BACK\n         MVC   WORK(L'DCBDDNAM),4(R15) NO, SAVE IT AS NEW LOW\n         ST    R15,TIOTP           SAVE DD ENTRY PTR\n         B     TIOTLP              LOOP BACK TO CHECK NEXT ENTRY\nTIOTLPND MVC   DDNAME(L'DCBDDNAM),WORK SET NEW DDNAME\n         CLI   WORK,X'FF'          IS THERE A NEW DDNAME?\n         BNE   SETSFX              YES, GO ISOLATE SUFFIX\nTIOTSMSK OI    FLAG,*-*            NO, FLAG DDNAME MISSING\nSETSFX   LM    R0,R1,DDNAME        GET THE DDNAME\n         STM   R0,R1,DCBDDNAM      SET DDNAME INTO DCB\n         LH    R15,SFXLN           GET SUFFIX SHIFT VALUE\n         SLDL  R0,0(R15)           SHIFT OUT UNLIKE PREFIX\n         STM   R0,R1,WORK          SAVE SUFFIX FOR COMPARES\n         OC    WORK(L'DCBDDNAM),=CL8' ' ENSURE TRAILING BLANKS\n         BR    R14                 RETURN\n         DROP  R2                  KILL DCB ADDRESSABILITY\n         TITLE 'DSCOPY -- GETBUFS (2ND LEVEL SUBROUTINE) - CHK LRECL &&*\n                BLKSIZE AND GET BUFFERS'\n         USING DCBDSECT,R2         DECLARE DCB BASE\nGETBUFS  ST    R14,SAVE14B         SAVE RETURN ADDRESS\n         LH    R3,DCBLRECL         GET LRECL\n         LH    R5,DCBBLKSI         GET BLKSIZE\n         TM    DCBRECFM,X'C0'      IS RECFM=U?\n         BNM   USETLRCL            YES, GO FORCE LRECL=BLKSIZE\n         LTR   R3,R3               NO, LRECL OMITTED?\n         BZ    USETLRCL            YES, GO SET IT\n         TM    FLAG,UNITRCD        NO, OUTPUT ON UNIT RCD?\n         BO    SETUR               YES, GO SET BLKSIZE\n         TM    DCBRECFM,X'10'      NO, OUTPUT BLOCKED?\n         BO    PRNTLRCL            YES, GO PRINT VALUES\nUSETLRCL LR    R3,R5               NO, SET LRECL=BLKSIZE\n         TM    DCBRECFM,X'80'      IS RECFM=V?\n         BO    SETLRCL             NO, GO PRINT LRECL\n         SH    R3,=Y(4)            YES, ADJUST LRECL\nSETLRCL  STH   R3,DCBLRECL         RESET LRECL\n         B     PRNTLRCL            GO PRINT IT\nSETUR    LR    R5,R3               NO, SET BLKSIZE=LRECL\n         TM    DCBRECFM,X'80'      RECFM=F?\n         BO    SETBLKSI            YES, CONTINUE\n         LA    R5,4(,R5)           NO, RECFM=V; ADJUST BLKSIZE\nSETBLKSI STH   R5,DCBBLKSI         RESET THE BLKSIZE\nPRNTLRCL MVC   IOLRL+8(5),=C'LRECL' SET MSG TO LRECL\n         MVC   IOLRL+18(6),EDMSK+5 MOVE EDIT MASK INTO MSG\n         CVD   R3,CVDWA            CNVRT LRECL TO DEC\n         ED    IOLRL+17(7),CVDWA+5 EDIT LRECL INTO MSG\n         MVI   IOLRL-1,L'IOLRL     SET MSG LENGTH\n         $PRINT IOLRL              PRINT THE MSG\n         MVC   IOLRL+8(7),=CL7'BLKSIZE' SET MSG TO BLKSIZE\n         MVC   IOLRL+18(6),EDMSK+5 MOVE EDIT MASK TO MSG\n         CVD   R5,CVDWA            CNVRT BLKSIZE TO DEC\n         ED    IOLRL+17(7),CVDWA+5 EDIT BLKSIZE INTO MSG\n         $PRINT IOLRL              PRINT THE MSG\n         TM    DCBRECFM,X'C0'      IS RECFM=U?\n         BNM   BUILDBUF            YES, GO BUILD BUFFERS\n         TM    DCBRECFM,X'80'      NO, IS RECFM=F?\n         BO    TSTF                YES, GO TEST VALIDITY\n         SH    R5,=Y(8)            NO, RECFM=V, IS BLKSIZE OK?\n         BP    TSTVLRCL            YES, CONTINUE\n         MVC   LENERR+8(7),=CL7'BLKSIZE' NO, SET ERR MSG TO BLKSIZE\n         $PRINT LENERR             PRINT IT\n         B     L2ERRRET            GO SIGNEL ERROR AND RETURN\nTSTVLRCL SH    R3,=Y(4)            IS LRECL BIG ENOUGH?\n         BP    BUILDBUF            YES, GO BUILD BUFFERS\n         MVC   LENERR+8(7),=CL7'LRECL' NO, SET ERR MSG TO LRECL\n         $PRINT LENERR             PRINT THE MSG\n         B     L2ERRRET            GO SIGNEL ERROR AND RETURN\nTSTF     SR    R4,R4               ZERO R4 FOR DEVIDE\n         DR    R4,R3               GET BLOCKING FACTOR\n         LTR   R4,R4               WAS DIVISION EVEN?\n         BZ    BUILDBUF            YES, GO BUILD BUFFERS\n         $PRINT FIXLNERR           NO, ISSUE ERROR MSG\n         B     L2ERRRET            GO SIGNEL ERROR AND RETURN\nBUILDBUF NI    DCBBFALN,255-X'01'  TRN OFF BUFFER ALIGN BIT\n         L     R5,MAXCR            GET MAX CORE FOR BUFFERS\n         LH    R3,DCBBLKSI         GET BLKSIZE\n         LA    R3,3(,R3)           ROUND -\n         SRL   R3,2                 UP TO -\n         SLL   R3,2                  FULLWORD LENGTH\n         SR    R4,R4               ZERO R4 FOR DEVIDE\n         DR    R4,R3               GET # OF BUFFERS TO BUILD\n         CH    R5,=Y(&MAXBUFS)     TOO MANY BUFFERS?\n         BNH   SETBUF#             NO, GO BUILD THEM\n         LH    R5,=Y(&MAXBUFS)     YES, SET MAX # OF BUFS\nSETBUF#  LA    R4,31               GET MSG LENGTH\n         CH    R5,=Y(1)            HOW MANY BUFFERS CAN BE BUILT?\n         BNL   BUFGOTN             AT LEAST 1; CONTINUE\n         $PRINT NOBUFS             NONE, ISSUE ERROR MSG\n         B     L2ERRRET            GO SIGNEL ERROR AND RETURN\nBUFGOTN  BH    MORETHN1            MORE THAN 1 BUFFER CAN BE BUILT\n         TM    DCBOPTCD,X'20'      ONLY 1 BUF; IS CHN SCHED ON?\n         BZ    MORETHN1            NO, CONTINUE\n         NI    DCBOPTCD,255-X'20'  YES, TURN IT OFF\n         LA    R4,L'BUF#           ADJ MSG LEN TO SAY SO\nMORETHN1 MVC   BUF#+1(3),NME       SET MSG NAME\n         MVC   BUF#+20(3),EDMSK+8  MOVE EDIT MASK TO MSG\n         CVD   R5,CVDWA            CNVRT # OF BUFS TO DEC\n         ED    BUF#+19(4),CVDWA+6  EDIT IT INTO MSG\n         STC   R4,BUF#-1           SET MSG LENGTH\n         $PRINT BUF#               PRINT THE MSG\nERRBUILD STC   R5,DCBBUFNO         SET BUFNO IN DCB\n         LR    R0,R5               GET # OF BUFS FOR BUILD\n         SLL   R0,16               SHIFT TO 1ST 1/2 WD\n         OR    R0,R3               OR IN BUFFER LENGTH\n         L     R1,DCBBUFCB         PNT TO BUFFER AREA\n         BUILD (1),(0)             BUILD THE BUFFERS\n         LR    R15,R3              GET DATA LEN 4 RTN (ASSUMING U)\n         TM    DCBRECFM,X'C0'      RECFM=U?\n         BNM   LEVL2RET            YES, GO RETURN\n         LH    R15,DCBLRECL        NO, GET DATA LEN FOR RECFM=F\n         TM    DCBRECFM,X'80'      RECFM=F?\n         BO    LEVL2RET            YES, GO RETURN\n         SH    R15,=Y(4)           NO, RECFM=V; SET DATA LEN\n         B     LEVL2RET            GO RETURN\n         DROP  R2                  KILL DCB ADDRESSABILITY\n         TITLE 'DSCOPY -- GETRECFM (2ND LEVEL SUBROUTINE) - RECORD FORM*\n               AT PROCESSING'\n         USING DCBDSECT,R2         DECLARE DCB BASE\nGETRECFM ST    R14,SAVE14B         SAVE RETURN REGISTER\n         MVC   IOLRL+1(3),NME      SET MSG NAME\n         MVC   IOLRL+18(6),IOLRL+17 CLEAR RECFM CODES FROM MSG\n         LA    R1,IOLRL+18         PNT TO RECFM CODES OUTPUT POINT\n         MVI   0(R1),C'U'          ASSUME RECFM=U\n         MVC   2(2,R3),SU          SET GATE\n         TM    DCBRECFM,X'C0'      IS RECFM=U?\n         BM    TESTF               NO, CONTINUE\n         OI    DCBRECFM,X'C0'      YES, BUE FORCE IT\n         B     TESTOTHR            GO TEST OTHER RECFM BITS\nTESTF    MVI   0(R1),C'F'          ASSUME RECFM=F\n         MVC   2(2,R3),SF          SET GATE\n         TM    DCBRECFM,X'80'      IS RECFM=F?\n         BO    TESTOTHR            YES, GO TEST OTHER BITS\n         MVI   0(R1),C'V'          NO, RECFM=V\n         MVC   2(2,R3),SV          SET GATE\nTESTOTHR LA    R15,5               LOAD LOOP CONTROL\nRECFMLP  LA    R14,TMASKS-1(R15)   PNT TO TESTING MASK\n         MVC   RECFMTM+1(1),0(R14) MOVE IT TO TM INSTRUCTION\nRECFMTM  TM    DCBRECFM,*-*        IS THE BIT ON?\n         BZ    RECFMLPN            NO, LOOP\n         LA    R14,RECFMS-1(R15)   YES, PNT TO CORRESPONDING CODE\n         LA    R1,1(,R1)           INCR OUTPUT PTR\n         MVC   0(,R1),0(R14)       MOVE CODE TO MSG\nRECFMLPN BCT   R15,RECFMLP         LOOP TO NEXT\n         LR    R15,R1              SAVE FOR LATER\n         S     R1,=A(IOLRL-1)      GET MSG LENGTH\n         C     R2,=A(IN)           ARE WE PROCESSING THE INPUT?\n         BNE   RECFMSL             NO, GO PRINT MSG\n         TM    DCBRECFM,X'C0'      YES, IS RECFM=U?\n         BM    RECFMSL             NO, GO PRINT MSG\n         TM    DCBOPTCD,X'20'      YES, IS CHAINED SCHEDULING STILL ON?\n         BZ    RECFMSL             NO, GO PRINT MSG\n         NI    DCBOPTCD,255-X'20'  YES, TURN IT OFF\n         MVC   1(32,R15),BUF#+31   SAY SO\n         LA    R1,32(,R1)          AJUST MSG LEN\nRECFMSL  STC   R1,IOLRL-1          SET MSG LENGTH\n         MVC   IOLRL+8(7),=CL7'RECFM' SET MSG TO RECFM\n         $PRINT IOLRL              PRINT RECFM MSG\n         B     LEVL2RET            GO RETURN\n         DROP  R2                  KILL DCB ADDRESSABILITY\n         TITLE 'DSCOPY -- PRNTNMES (2ND LEVEL SUBROUTINE) - PROCESS DSN*\n               AME ETC'\n         USING DCBDSECT,R2         DECLARE DCB BASE\nPRNTNMES ST    R14,SAVE14B         SAVE RETURN ADDRESS\n         MVI   PRNTM+1,0           SET NULL MASK FOR DDNAME PRTING\n         LR    R1,R2               GET DCB ADDRESS FOR DDNAME PRINTING\n         BAL   R14,PRNTDDNM        GO PRINT DDNAME\n         L     R4,TIOTP            PNT TO DD ENTRY IN TIOT\n         SR    R3,R3               POINT TO ...                    JRB\n         ICM   R3,7,17(R4)         ... UCB.                        JRB\n         USING UCBDSECT,R3         DECLARE UCB BASE\n         MVC   DSNMSG+1(3),NME     SET MSG NAME\n         MVC   DSNMSG+10(3),=C' IS MISSING' INIT MSG\n         OI    DCBOPTCD,X'20'      FORCE CHAINED SCHEDULING\n         L     R4,DCBDEBAD         PNT TO OPEN WORK AREA\n         USING OPENWKA,R4          DECLARE WORK AREA BASE\n         CLC   JFCBDSNM(9),=CL9'NULLFILE' IS DATA SET A DUMMY?\n         BNE   NOTDUMMY            NO, CONTINUE\n         MVC   DSNMSG+14(5),=C'DUMMY' YES, SAY SO\n         MVC   DSNMSG+19(32),BUF#+31 SAY NO CHAINED SCHEDULING\n         NI    DCBOPTCD,255-X'20'  PREVENT CHAINED SCHEDULING\n         LA    R5,51               GET MSG LENGTH\n         B     PUTDSNMG            GO PRINT MSG\nNOTDUMMY TM    JFCBTSDM,X'20'      IS DATA SET OS SPOOLED?\n         BZ    NOTOSPOL            NO, CONTINUE\n         MVC   DSNMSG+14(10),=C'OS SPOOLED' YES, SAY SO\n         LA    R5,24               GET MSG LENGTH\n         B     PUTDSNMG            GO PRINT MSG\nNOTOSPOL TM    UCBTBYT3,UCB3TAPE+UCB3DACC IS DS REALLY A DATA SET?\n         BNZ   REALDS              YES, CONTINUE\n         MVC   DSNMSG+14(11),=C'UNIT RECORD' NO, SAY SO (SORT OF)\n         NI    DCBRECFM,255-X'10'  TURN OFF BLOCKING BIT\n         OI    FLAG,UNITRCD        FLAG UNIT RECORD DEVICE\n         LA    R5,25               GET MSG LENGTH\n         B     PUTDSNMG            GO PRINT MSG\nREALDS   TM    JFCBIND2,X'01'      IS DATA SET TEMPORARY?\n         BZ    NOTTEMP             NO, CONTINUE\n         MVC   DSNMSG+14(9),=C'TEMPORARY' YES, SAY SO\n         LA    R5,DSNMSG+22        PNT TO LAST NON-BLANK IN MSG\n         B     PDSMEM              GO SEE IF THERE EXISTS A PDS MEMBER\nNOTTEMP  MVC   DSNMSG+10(3),=C'N =' ADJUST MSG\n         MVC   DSNMSG+14(44),JFCBDSNM PUT DSN INTO MSG\n         LA    R5,DSNMSG+58        FIND -\nDSNBLP1  BCTR  R5,0                 END -\n         CLI   0(R5),C' '            OF -\n         BE    DSNBLP1                DSNAME\nPDSMEM   TM    JFCBIND1,JFCBPMEM+X'02' PDS MEMBER OR GENERATION DS?\n         BZ    SETDSNLN            NO, GO GET MSG LENGTH\n         MVI   1(R5),C'('          YES, ADJ MSG\n         MVC   2(8,R5),JFCBELNM    PUT ELEMENT NAME INTO MSG\nDSNBLP2  BCTR  R5,0                FIND -\n         CLI   10(R5),C' '          FIRST -\n         BE    DSNBLP2               NON-BLANK\n         LA    R5,11(,R5)          POINT TO IT\n         MVI   0(R5),C')'          ADJ MSG\nSETDSNLN LA    R6,DSNMSG-1         PNT TO START OF MSG\n         SR    R5,R6               GET MSG LENGTH\nPUTDSNMG STC   R5,DSNMSG-1         SET MSG LENGTH\n         $PRINT DSNMSG             PRINT THE MESSAGE\n         TM    JFCDSORG,X'02'      IS DATA SET A PDS?\n         BZ    NOTPDS              NO, CONTINUE\n         TM    JFCBIND1,JFCBPMEM   DOES JCL PNT TO 1 MEMBER?\n         BO    NOTPDS              YES, CONTINUE\n         $PRINT PDSERR             NO, PRINT ERROR MSG\nL2ERRRET SR    R0,R0               SET ERROR CC\n         B     LEVL2RET            GO RETURN\nNOTPDS   LTR   R3,R3               IS THERE A UCB?\n         BZ    ISDUMMY             NO, BYPASS PRINTING MSG\n         MVC   CUUMSG+1(3),NME     YES, SET MSG NAME\n         MVC   CUUMSG+L'CUUMSG-3(3),UCBNAME SET CUU ADR INTO MSG\n         $PRINT CUUMSG             PRINT THE MSG\nISDUMMY  LH    R5,JFCBFLSQ         GET TAPE FILE SEQ NUMBER (IF ANY)\n         LTR   R5,R5               IS UNIT A TAPE?\n         BZ    NOTTAPE             NO, BYPASS MSG PRINTING\n         MVC   FILESEQ#+1(3),NME   YES, SET MSG NAME\n         CVD   R5,CVDWA            CNVRT SEQ # TO DEC\n         MVC   FILESEQ#+22(6),EDMSK+5 MOVE EDIT MASK TO MSG\n         ED    FILESEQ#+21(7),CVDWA+5 EDIT FILE SEQ # INTO MSG\n         $PRINT FILESEQ#           PRINT THE MSG\nNOTTAPE  LTR   R13,R13             SET SUCCESSFUL CC\nLEVL2RET L     R14,SAVE14B         RESTORE RETURN ADDRESS\n         BR    R14                 RETURN\n         DROP  R2,R3,R4            KILL CONTROL BLOCK ADDRESSABILITIES\n         TITLE 'DSCOPY -- PRNTDDNM (3RD LEVEL SUBROUTINE) - PRINT DDNAM*\n               ES BEING COPIED (IF ANY)'\n         USING DCBDSECT,R2         DECLARE DCB BASE\nPRNTDDCC MVI   DDNMSG,C' '         SET ASA CARRAGE CONTROL\nPRNTDDNM ST    R14,SAVE14C         SAVE THE RETURN REGISTER\n         MVC   DDNMSG+1(3),NME     GENERATE -\n         MVC   DDNMSG+14(2),=C': '  THE -\n         MVC   DDNMSG+16(L'DCBDDNAM),DDNAME DDNAME -\n         MVI   DDNMSG+16+L'DCBDDNAM,C' ' MESSAGE\nPRNTM    TM    FLAG,*-*            IS DDNAME REALLY MISSING?\n         BZ    PRTDDNMS            NO, GO PRINT MESSAGE\n         MVC   DDNMSG+14(11),=C' IS MISSING' RESET THE MESSAGE\n         CLI   RCD+1,4             IS RET CODE >= 4?\n         BNL   PRTDDNMS            YES, GO PRINT MESSAGE\n         MVI   RCD+1,4             NO, SET RET CODE\nPRTDDNMS $PRINT DDNMSG             ISSUE THE MESSAGE\nLEVL3RET L     R14,SAVE14C         RESTORE RETURN REGISTER\n         BR    R14                 RETURN\n         DROP  R2                  KILL DCB BASE\n         TITLE 'DSCOPY -- PUTSYSP (4TH LEVEL SUBROUTINE) - MESSAGE PRIN*\n               TING ROUTINE'\nPUTSYSP  ST    R14,SAVE14D         SAVE RETURN REGISTER\n         MVC   PRTLRECL+1(1),0(R15) SET MESSAGE LENGTH INTO LRECL\n         LA    R0,1(,R15)          POINT TO MESSAGE\n         PUT   SYSPRINT,(0)        ISSUE THE MESSAGE\nLEVL4RET L     R14,SAVE14D         RESTORE THE RETURN ADDRESS\n         BR    R14                 RETURN\n         TITLE 'DSCOPY -- DATA - DCB''S'\n         PRINT NOGEN               DON'T NEED DCB EXPANSIONS\nIN       #DCBD DSORG=QS            DEFINE INDCB NAMES         07/96 DBC\n         ORG   INDCB               ORG TO OVERLAY WITH DCB    08/05 DBC\nIN       DCB   DSORG=PS,MACRF=GL,EODAD=WRAPUP,EXLST=INEX,EROPT=ACC,    *\n               SYNAD=IOERR         INPUT DCB\nINTIOTP  DS    A                   PTR TO CURRENT ENTRY IN ITOT\nINWORK   DS    2A                  WORK AREA\nIDDNAME  DS    2A                  DDNAME SAVE AREA\nSINU     DC    S(INU)              INPUT RECFM=U GATE\nSINF     DC    S(INF)              INPUT RECFM=F GATE\nSINV     DC    S(INV)              INPUT RECFM=V GATE\nINPFXLN  DS    Y                   DDNAME PREFIX LENGTH\nINSFXLN  DS    Y                   DDNAME PREFIX LEN IN BITS\nINNME    DC    CL3' IN'            DCB NAME\n         SPACE 3\nOUT      #DCBD DSORG=QS            DEFINE OUTDCB NAMES        08/05 DBC\n         ORG   OUTDCB              ORG TO OVERLAY WITH DCB\nOUT      DCB   DSORG=PS,MACRF=PL,EXLST=OUTEX,EROPT=ACC,SYNAD=IOERR\nOUTTIOTP DS    A                   PTR TO CURRENT ENTRY IN TIOT\nOUTWORK  DS    2A                  WORK AREA\nODDNAME  DS    2A                  DDNAME SAVE AREA\nSOUTU    DC    S(OUTU)             OUTPUT RECFM=U GATE\nSOUTF    DC    S(OUTF)             OUTPUT RECFM=F GATE\nSOUTV    DC    S(OUTV)             OUTPUT RECFM=V GATE\nOUTPFXLN DS    Y                   DDNAME PREFIX MACHINE LENGTH\nOUTSFXLN DS    Y                   DDNAME PREFIX LENGTH IN BITS\nOUTNME   DC    CL3'OUT'            DCB NAME\n         SPACE 3\nPRT      #DCBD DSORG=QS            DEFINE PRTDCB NAMES        08/05 DBC\n         ORG   PRTDCB              ORG TO OVERLAY WITH DCB\nSYSPRINT DCB   DSORG=PS,MACRF=PM,EROPT=ACC,SYNAD=IOERR,RECFM=UA,       *\n               BLKSIZE=121,BUFNO=1,LRECL=121 MSG DCB\n         PRINT GEN                 END OF DCB'S               07/96 DBC\n         TITLE 'DSCOPY -- DATA - MISCELLANIOUS'               07/96 DBC\nCVDWA    DS    D                   DOUBLE WORD WORK AREA\nTIOTADR  DS    A                   PTR TO 1ST DD ENTRY IN TIOT\nSAVESA   DS    18A                 DCB EXIT SAVE AREA SAVE AREA\nSAVE14A  DS    A                   R14 1ST LEVEL SAVE AREA\nSAVE14B  DS    A                   R14 2ND LEVEL SAVE AREA\nSAVE14C  DS    A                   R14 3RD LEVEL SAVE AREA\nSAVE14D  DS    A                   R14 4TH LEVEL SAVE AREA\nGETMADR  DS    2A                  RETURN AREA FOR VARIABLE GETMAIN\nGETMQTY  DC    A(&MINGET,X'FFFFF8') VARIABLE GETMAIN PARAMETERS\nMAXCR    DS    A                   MAX CORE FOR BUFS FOR EA DCB\nINEX     DC    0A(0),X'85',AL3(INEXIT) INPUT DCB EXIT ADDRESS\nOUTEX    DC    0A(0),X'85',AL3(OUTEXIT) OUTPUT DCB EXIT ADDRESS\n         SPACE 1\n*        NOTE: THE 4TH BYTE PRECEEDING THE FOLLOWING TABLE MUST NOT BE\n*        X'FF'.\nDDNPTRTB DS    0A                  TABLE FOR CHANGING DDNAMES\n         DC    A(IDDNAME)          INDCB DDNAME ADDRESS\n         DC    A(ODDNAME)          OUTDCB DDNAME ADDRESS\n         DC    3A(0)               NON-APPLICABLE ENTRIES\n         DC    A(PRTDDNAM)         PRTDCB DDNAME ADDRESS\n         DC    X'FF'               END OF TABLE\n         SPACE 1\nFLAG     DS    X                   FLAG BYTE\nTRUNC    EQU   X'01'               TRUNCATION COPY FLAG\nINMISS   EQU   X'02'               MISSING INPUT DDNAME FLAG\nBADDDNM  EQU   X'04'               BAD DDNAME LIST\nOUTMISS  EQU   X'04'               MISSING OUTPUT DDNAME FLAG\nBADCPY#  EQU   X'08'               BAD 1ST COPY NUMBER\nREREAD   EQU   X'08'               CONCAT EOF REREAD BIT\nINEND    EQU   X'10'               INPUT DDNAMES EXHAUSTED\nTOOMP    EQU   X'10'               TOO MANY PASSED PARAMETERS\nOUTEND   EQU   X'20'               OUTPUT DDNAMES EXHAUSTED\nUNITRCD  EQU   X'40'               UNIT RECORD DEVICE BEING OPENED\nCPYSUPRS EQU   X'80'               ABEND C03 PROCESSING FLAG\n         SPACE 1\nFLAG2    DS    X                   FLAG BYTE\nCONCAT   EQU   X'01'               POSSIBLE CONCATINATION FLAG\n         SPACE 1\nCPY#PK   PACK  CPY#,2(*-*,R4)      PACK NEW 1ST COPY NUMBER\nHWD      DC    2Y(0)               RECFM=V LENGTH FIELD HOLDER\nRCD      DC    Y(0)                RETURN CODE\nLRECL    DS    Y                   OUTPUT DATA LENGTH\nCPY#     DC    PL2'0'              NEXT COPY NUMBER\nINCNT    DC    PL2'0'              INPUT DATA SET COUNTER\nEDMSK    DC    X'2020206B2020206B202120' EDIT MASK\nTMASKS   DC    X'0204200810'       RECFM=M,A,T,S,B\nRECFMS   DC    C'MATSB'            RECFM CODES\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* PARTIAL COPY CONTROLS                                     * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         DS    0F                                             07/96 DBC\nSTART#   DC    X'00000001'         START AT NTH RECORD        07/96 DBC\nSTOP#    DC    X'FFFFFFFF'         STOP AFTER NTH RECORD      07/96 DBC\nCOUNT#   DC    X'FFFFFFFF'         COPY N RECORDS             07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* PARM FIELD PARSING CONTROLS. THE TABLE MUST BE SORTED BY  * 07/96 DBC\n* KEYWORD TEXT.                                             * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\nPARMKEYS DS    0X                                             07/96 DBC\n         DC    AL4(COUNT#),AL1(0,5),C'COUNT='                 07/96 DBC\n         DC    AL4(START#),AL1(0,5),C'START='                 07/96 DBC\n         DC    AL4(STOP#),AL1(0,4),C'STOP='                   07/96 DBC\n         DC    AL4(FLAG),AL1(TRUNC,7),C'TRUNCATE'             07/96 DBC\n         DC    AL4(0),AL1(0,0),X'FF' TABLE DELIMITER          07/96 DBC\n         SPACE 1                                              07/96 DBC\nPKYSINK  EQU   0,4                 @'VALUE SINK               07/96 DBC\nPKYOIFLG EQU   PKYSINK+L'PKYSINK,1 FOR FLAGS, BIT TO TURN ON  07/96 DBC\nPKYEXLEN EQU   PKYOIFLG+L'PKYOIFLG,1 L'KEYWORD TEXT -1        07/96 DBC\nPKYWORD  EQU   PKYEXLEN+L'PKYEXLEN KEYWORD TEXT               07/96 DBC\n         SPACE 3                                              07/96 DBC\n************************************************************* 07/96 DBC\n* LOCAL LITERALS                                            * 07/96 DBC\n************************************************************* 07/96 DBC\n         SPACE 1                                              07/96 DBC\n         LTORG ,                   LITTERALS HERE\n         TITLE 'DSCOPY -- DATA - MESSAGES'\n         DC    AL1(L'SKIP1)                                   07/96 DBC\nSKIP1    DC    C'  '                                          07/96 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'SKIP3)                                   07/96 DBC\nSKIP3    DC    C'- '                                          07/96 DBC\n         SPACE 3                                              08/05 DBC\n         DS    AL1\nIOLRL    DC    C' ***PUT ******* = ******'\n         DS    CL32\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'DDNMSG)\nDDNMSG   DC    CL25'****PUT DDNAME'\n         SPACE 3                                              08/05 DBC\n         DS    AL1\nDSNMSG   DC    CL68' ***PUT DS'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'CUUMSG)\nCUUMSG   DC    C' ***PUT FIRST DEVICE ADDRESS IS ***'\n         SPACE 3                                              08/05 DBC\n         DS    AL1\nBUF#     DC    C' ***PUT IS ASSIGNED *** BUFFERS - CHAINED SCHEDULING S*\n               UPPRESSED'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'FILESEQ#)\nFILESEQ# DC    C' ***PUT TAPE FILE # = **,***'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'COPYTIT)\nCOPYTIT  DC    C'-COPY # ***'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'CS)\nCS       DC    C'0COPY SUPPRESSED'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'CT)\nCT       DC    C' COPY TERMINATED'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(CRIGHT_L)                                  08/05 DBC\nCRIGHT   DC    C'1DSCOPY - Copyright (c) David B. Cole, '     08/05 DBC\n         DC    C'1972-2005. All rights reserved.'             08/05 DBC\nCRIGHT_L EQU   *-CRIGHT                                       08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(LEGAL1_L)                                  08/05 DBC\nLEGAL1   DC    C'0This program is distributed '               08/05 DBC\n         DC    C'without warranty of any kind, '              08/05 DBC\n         DC    C'including'                                   08/05 DBC\nLEGAL1_L EQU   *-LEGAL1                                       08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(LEGAL2_L)                                  08/05 DBC\nLEGAL2   DC    C' (without limitation) '                      08/05 DBC\n         DC    C'warranties of merchantability '              08/05 DBC\n         DC    C'and of fitness for a'                        08/05 DBC\nLEGAL2_L EQU   *-LEGAL2                                       08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(LEGAL3_L)                                  08/05 DBC\nLEGAL3   DC    C' particular purpose. It is up '              08/05 DBC\n         DC    C'to the user to make his own '                08/05 DBC\n         DC    C'determination'                               08/05 DBC\nLEGAL3_L EQU   *-LEGAL3                                       08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(LEGAL4_L)                                  08/05 DBC\nLEGAL4   DC    C' of the '                                    08/05 DBC\n         DC    C'usefulness of this program in '              08/05 DBC\n         DC    C'his own system. '                            08/05 DBC\nLEGAL4_L EQU   *-LEGAL4                                       08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(LEGAL5_L)                                  08/05 DBC\nLEGAL5   DC    C'0For additional restrictions, see the '      08/05 DBC\n         DC    C'README file located in this'                 08/05 DBC\nLEGAL5_L EQU   *-LEGAL5                                       08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(LEGAL6_L)                                  08/05 DBC\nLEGAL6   DC    C' program''s '                                08/05 DBC\n         DC    C'distribution library '                       08/05 DBC\n         DC    C'(originally named DBCOLE.DSCOPY.EXPORT,'     08/05 DBC\nLEGAL6_L EQU   *-LEGAL6                                       08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(LEGAL7_L)                                  08/05 DBC\nLEGAL7   DC    C' and availble for download from '            08/05 DBC\n         DC    C'www.colesoft.com).'                          08/05 DBC\nLEGAL7_L EQU   *-LEGAL7                                       08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'DSCP)\nDSCP     DC    C'-DATA SET COPYING PROGRAM'                   08/05 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'PFN)                                     07/96 DBC\nPFN      DC    C' PARM FIELD: NONE'                           07/96 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(PFILLEN)                                   07/96 DBC\nPFIL     DC    C'0INVALID PARM FIELD LENGTH '                 07/96 DBC\n         DC    C'(NEGATIVE OR GREATER THAN 108)'              07/96 DBC\n         #TEST SIZE=(L'PFTEXT,EQ,108) TRUTH CHECK             07/96 DBC\nPFILLEN  EQU   *-PFIL              L'MSG                      07/96 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(*-*)                                       07/96 DBC\nPF       DC    C'0PARM FIELD: '                               07/96 DBC\nPFTEXT   DC    CL(121-L'PF)' '                                07/96 DBC\nPFLEN    EQU   *-PF                MAX L'MSG                  07/96 DBC\n         DC    C' '                TRAILER                    07/96 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'EOP)\nEOP      DC    C'-END OF PROGRAM'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'LENERR)\nLENERR   DC    C' ERROR: ******* IS TOO SMALL FOR RECFM=V'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'FIXLNERR)\nFIXLNERR DC    C' ERROR: BLKSIZE MUST BE A MULTIPLE OF LRECL FOR RECFM=*\n               F'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'BLKSIERR)\nBLKSIERR DC    C' ERROR: BLKSIZE NOT GIVEN FOR INPUT DATA SET'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'PDSERR)\nPDSERR   DC    C' ERROR: DATA SET IS PARTITIONED'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'NOBUFS)\nNOBUFS   DC    C' ERROR: INSUFFICENT CORE FOR BUFFERS'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'IC)\nIC       DC    C' GETMAIN OF &MINGET BYTES FAILED'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'IN#)\nIN#      DC    C'0 INPUT DATA SET # ***'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(IC#LEN)                                    07/96 DBC\nIC#      DC    C' INVALID STARTING COPY NUMBER GIVEN - '      07/96 DBC\n         DC    C'\"1\" WILL BE USED'                            07/96 DBC\nIC#LEN   EQU   *-IC#                                          07/96 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'IDL)\nIDL      DC    C' INVALID DDNAME LIST'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'IPF)\nIPF      DC    C' INVALID PARM FIELD'\n         SPACE 3                                              08/05 DBC\n         DS    AL1\nRLC      DC    CL59' OUTPUT DATA LENGTH * INPUT - WILL'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'PT)\nPT       DC    C'-PROGRAM TERMINATED'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(RIOLEN)                                    07/96 DBC\nRIO      DC    C'*'                CCC: 0/BLANK               07/96 DBC\nRIOWHICH DC    C'*****',C' '       FIRST/LAST/TOTAL           07/96 DBC\nRIOINOUT DC    C'***',C'PUT RECORD' IN/OUT                    07/96 DBC\nRIOPLURL DC    C'*',C' '           S/BLANK                    07/96 DBC\nRIOVERB  DC    C'*******',C' = '   COPIED/WRITTEN             07/96 DBC\nRIOCOUNT DC    C' **,***,***,***'                             07/96 DBC\nRIOLEN   EQU   *-RIO                                          07/96 DBC\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'RCDMSG)\nRCDMSG   DC    C' RETURN CODE = ***'\n         SPACE 3                                              08/05 DBC\n         DC    AL1(L'TMEIPL)\nTMEIPL   DC    C' TOO MANY ARGUEMENTS IN PARAMETER LIST - EXTRA ARGUEME*\n               NTS IGNORED'\n         TITLE 'DSCOPY -- DSECTS'\n         PRINT  NOGEN                                         07/96 DBC\nSYMDEL   DSECT ,                                              07/96 DBC\n         SPACE 3                                              07/96 DBC\nDCBDSECT DSECT\n         #DCBD DSORG=QS                                       08/05 DBC\nTIOTP    DS    A                   CURRENT DD ENTRY PTR\nWORK     DS    2A                  WORK AREA\nDDNAME   DS    2A                  DDNAME SAVE AREA\nSU       DS    S                   RECFM=U GATE SETTING\nSF       DS    S                   RECFM=F GATE SETTING\nSV       DS    S                   RECFM=V GATE SETTING\nPFXLN    DS    Y                   DDNMAE PREFIX MACHINE LEN (BYTES)\nSFXLN    DS    Y                   DDNAME PREFIX LEN (BITS)\nNME      DS    CL3                 DCB NAME\n         SPACE 3                                              07/96 DBC\nCVTDSECT DSECT\n         CVT   DSECT=YES,LIST=YES                                  JRB\n         SPACE 3                                              07/96 DBC\nUCBDSECT DSECT\n         IEFUCBOB ,\n         SPACE 3                                              07/96 DBC\nOPENWKA  DSECT\n         ORG   OPENWKA+100\n         IEFJFCBN ,\n         SPACE 3                                              07/96 DBC\n         END   ,                                              07/96 DBC\n./ ADD NAME=README   0105-05218-05218-1530-00375-00080-00375-DBCOLEA\nThe DSCOPY program is copyrighted (c) 1972-2005 by David B. Cole. All\nrights reserved.\n\nYou are reading DBCOLE.DSCOPY.EXPORT(README).\n\n\n\nDESCRIPTION\n\nDSCOPY is a general purpose program which copies data sets\nsequentially.  It allows the user to copy sequential files, BDAM files\n(i.e.  REGIONAL(1) files in PL/I or direct access files in FORTRAN),\nand single members of partitioned data sets from any valid input device\n(e.g. card reader, disk drive, or tape drive) to any valid output\ndevice (e.g.  printer, card punch, disk drive, or tape drive). The\nadvantage of this utility over others having the same function is that\nDSCOPY is considerably more efficient and faster (more that twice as\nfast as the IBM utility IEBGENER, for example). It takes full advantage\nof OS data management facilities in order to optimize as much as\npossible the data transfer rate.\n\nDSCOPY has the following features:\n\n1.) All information needed is specified through JCL or through the PARM\n    field. No control dataset (SYSIN, for example) is needed.\n\n2.) DSCOPY can perform any number of seperate copies in one jobstep\n    (subject, of course, to OS limits on the number of DD cards\n    permitted within a job or step).\n\n3.) Input datasets may be sequential, direct, or individual members of\n    partitioned data sets, or a concatenation of any combination of the\n    above with any combination of DCB attributes (RECFM, LRECL, and\n    BLKSIZE).\n\n4.) Any record format is allowed (fixed, variable, undefined) for\n    input, and it may be changed to any other record format for output.\n    In addition, logical record lengths and/or block sizes may also be\n    changed. All such changes are automaticly accomodated for (see\n    below).\n\nHere is a simple example of the invocation of DSCOPY:\n   //...      JOB CARD       ...\n   //*\n   //A       EXEC PGM=DSCOPY\n   //SYSPRINT DD  SYSOUT=A\n   //IN01     DD  DSN=       ... etc.\n   //OUT01    DD  DSN=       ... etc.\n   //IN02     DD  DSN=       ... etc.\n   //OUT02    DD  DSN=       ... etc.\n   //         .\n   //         .\n   //         .\n   //         etc.\n\n\n\nLEGAL INFORMATION:\n\nThis program is copyrighted (c) 1972-2005 by David B. Cole. All rights\nreserved.\n\nThis program is distributed freely and may be reproduced and\nredistributed without restriction other than:\n  - This copyright and usage/warranty/liability restriction statement\n    (\"Legal Statement\") may not be modified or removed.\n  - A similar Legal Statement located in this program's source code\n    also may not be removed.\n\nThis program is distributed without warranty of any kind, including\n(without limitation) warranties of merchantability and of fitness for a\nparticular purpose. It is up to the user to make his own determination\nof the usefulness of this program in his own system.\n\nThe user agrees not to hold either David B. Cole or Cole Software, LLC\nor any person affiliated with Cole Software, LLC (collectively \"COLE\")\nliable for any injury or damage whatsoever.\n\nFurther, the user agrees to indemnify COLE against third parties for\nany action arising from the user's use, misuse, modification, and/or\nredistribution of this program.\n\nThis program may be modified freely so long as all modifications are\nclearly marked both internally and externally to distinguish them from\nthe distributed code and functionality.\n\nAs a courtesy, please notify David Cole if you discover any bugs or if\nyou need or have made any code changes. (COLE, of course, does not\nguarantee that any future changes or corrections wither will or will\nnot be made.)\n\nContact information as of AUG05 is:\n\n    Name:                David B. Cole\n    Country:             USA\n    Telephone:           540-456-8536\n    FAX:                 540-456-6658\n    E-mail:              dbcole@colesoft.com\n    Website:             www.colesoft.com\n\n    Snail Mail:          Cole Software\n                         736 Fox Hollow Road\n                         Afton, VA 22920\n                         USA\n\n\n\nPACKAGING:\n\nThe DSCOPY.ZIP file contains the following files:\n\n  - DSCOPY.ALC is the assembler source code for the program.\n\n  - JCL.TXT is sample JCL for assembling and link editing the program.\n\nAll of the files are encoded in ASCII. When uploading them to your\nmainframe, ASCII-to-EBCDIC translation should be enabled.\n\n\n\nINSTALLATION:\n\nAssembling DSCOPY will require a macro library available from Cole\nSoftware's web site (www.colesoft.com). The file there is named\nMACROS.ZIP. You will have to obtain and install these macros before you\nwill be able to complete the installation of DSCOPY.\n\nTo install DSCOPY, do the following:\n\n  - Obtain and install Cole Software's macro library (MACROS.ZIP).\n\n  - Use WINZIP or PKUNZIP (or whatever) to decompress and extract the\n    DSCOPY.ALC, and JCL.TXT files from DSCOPY.ZIP.\n\n  - Upload the two files to your mainframe. Make sure that\n    ASCII-to-EBCDIC translation is turned on.\n\n  - Upload the files to a library whose DCB attributes are RECFM=FB,\n    LRECL=80, and BLKSIZE=n*80.\n\n  - Check out the JCL member for sample JCL to assemble and linkedit\n    the DSCOPY program.\n\n  - Assemble the DSCOPY member using both system macros and private\n    macros available from Cole Software.\n\n  - Linkedit the DSCOPY program into a suitable load library.\n\n  - Try it out.\n\n\n\nUSAGE:\n\n 1.) DDNAMEs for input must be of the form INx where x is any\n     alphameric character string of from 0 to 5 characters in length.\n\n 2.) DDNAMEs for output must be of the form OUTx where x is as in (1)\n     above.\n\n 3.) Copy operations are performed from each //INx DD card to a\n     corresponding //OUTx DD card (e.g. from //INA to //OUTA, from\n     //IN9999A to OYT9999A, from //IN to //OUT, from //INTRASH to\n     //OUTTRASH, etc.). Clearly, there must exist a one to one\n     correspondence between the input DD cards and the output DD cards.\n\n 4.) Copy operations are performed in the order of the ascending EBCDIC\n     coalating sequence of x. In the following example, the copies are\n     performed in the order shown (*regardless* of the sequence in\n     which the DD cards are actually presented):\n         1st //IN      to //OUT\n         2nd //INA     to //OUTA\n         3rd //INTRASH to //OUTTRASH\n         4th //IN01    to //OUT01\n         5th //IN02    to //OUT02\n         6th //IN1     to //OUT1\n         7th //IN10    to //OUT10\n         8th //IN2     to //OUT2\n         9th //IN9999A to //OUT9999A\n     Watch out for pitfalls here! Note in particular, that a copy from\n     //IN10 to //OUT10 will occur *before* a copy from //IN2 to //OUT2.\n     (This may matter, for example, if you're writing to tape.)\n\n 5.) Input block sizes must be available to DSCOPY from either DSCBs,\n     tape labels, or JCL. If other necessary DCB parameters are\n     missing, then defaults are taken (see below).\n\n 6.) Keyed direct access files (e.g. PL/I REGIONAL(2) and regional(3)\n     files) may be copied, but the keys themselves won't be copied. The\n     resulting output file will be sequential unless DSORG=DA is coded\n     in the JCL.\n\n 7.) A SYSPRINT DD card (e.g. //SYSPRINT DD SYSOUT=*) must be included\n     in the JCL. This DD card specifies a message data set for DSCOPY.\n     It's DCB is DSORG=PS, RECFM=UA, LRECL=121, BLKSIZE=121). Any\n     attempt to override this is ignored.\n\n 8.) If any necessary DCB atributes are missing, then the following\n     conversions are performed:\n\n     a.) If the input's DSORG is missing, then DSORG=PS is used.\n\n     b.) If the output's DSORG is missing, then DSORG=PS is used.\n\n     c.) If the input's RECFM is missing, then RECFM=U is used.\n\n     d.) If the output's RECFM is missing, then the input's RECFM is\n         used.\n\n     e.) If the input's BLKSIZE is missing, then an error condition is\n         reported.\n\n     f.) If the output's BLKSIZE is missing, then the input's BLKSIZE\n         is used. Exceptions:\n\n           - If the input's RECFM=V while the output's RECFM<>V then\n             the input's BLKSIZE-4 is used.\n\n           - If the input's RECFM<>V while the output's RECFM=V, then\n             the input's BLKSIZE+4 is used.\n\n     g.) If the input's LRECL is missing, then the input's BLKSIZE is\n         used. Exception:\n\n           - If the input's RECFM=V, then the input's BLKSIZE-4 is\n             used.\n\n     h.) If the output's LRECL is missing, then the output's BLKSIZE is\n         used. Exception:\n\n           - If the output's RECFM=V, then the output's BLKSIZE - 4 is\n             used.\n\n     i.) In the case of concatenated input, any settings that are made\n         for the output data set that are based on the characteristics\n         of the input data set, are based on the chatacteristics of the\n         *first* DD card in the input concatenation.\n\n     j.) The above listed conversions are (if required) applied in the\n         same order in which they are listed. For example, conversion\n         (f) will be applied before conversion (h).\n\n 9.) If the LRECL for the output data set is to be different from the\n     LRECL for the input data set, then there are three cases:\n\n     A.) Output's LRECL > input's LRECL:\n\n           - In this case, if the output's RECFM=F, then the unused\n             portion of each output record is filled with blanks (I.e.\n             the record is right-padded with blanks).\n\n     b.) Output's LRECL < input's LRECL *but* the entire input record\n         is still desired in the output data set:\n\n           - In this case, the input record is spanned onto as many\n             output records as is required. Note that this is the\n             default action.\n\n    c.) Output's LRECL < input's LRECL and only that portion of the\n        input record that will fit on one output record is desired:\n\n          - In this case each input record that is too long is\n            truncated before it is written to the output data set. In\n            order to use this truncation facility, the user must code\n            TRUNCATE in the EXEC statement's PARM= field. Notes:\n\n              - If TRUNCATE is coded, then truncation will occur for\n                all copy operations in the jobstep.\n\n              - If truncate is not coded, then spanning will occur for\n                all copy operations.\n\n              - WARNING! If spanning occurs, and the output file's\n                RECFM is V or VS, the spanning will *not* be compatible\n                with RECFM=VS!\n\n10.) DSCOPY generates a completion code with the following values:\n\n       0  - Execution completed without errors\n\n       4  - One of the following \"concerns\" occurred:\n\n              a.) When DSCOPY was called as a subroutine, too many\n                  arguements were passed (see below).\n\n              b.) When DSCOPY was called as a subroutine, the third\n                  arguement was invalid (see below).\n\n              c.) For a //INx or a //OUTx DDNAME, a corresponding\n                  //OUTx or //INx DDNAME was not found.\n\n       8  - One or more copy operations was either suppressed or\n            terminated for some reason.\n\n       12 - The program was terminated before any copies were\n            attempted.\n\n11.) PARM FIELD PROCESSING: There are several controls that DSCOPY\n     accepts via the parm field. The general syntax is:\n\n       - Their form is either \"keyword\" or \"keyword=value\".\n\n       - They may be given in any order.\n\n       - They must be separated from each other by blanks or commas.\n\n       - Keyword names must be given in full; abbreviations are not\n         checked for.\n\n       - Also, redundancies are not checked for; each instance of a\n         particular keyword overrides and nullifies all prior\n         instances.\n\n       - These controls apply to *all* copies performed by DSCOPY.\n\n     The following controls are supported:\n\n         TRUNCATE\n         When copying long records into output files with short LRECLs,\n         this cause DSCOPY to truncate the record. (Omit this keyword\n         if you want longs records to be spanned into the output file.)\n\n         START=number\n         This causes copying to start with the given input record\n         number. Number-1 records are skipped. The default is START=1.\n\n         STOP=number\n         This causes copying to stop after the given input record\n         number is reached and copied. (The first input record,\n         *regardless* of whether or not it is actually copied, is\n         record number 1.)  The default is to copy until input EOF is\n         reached.\n\n         COUNT=number\n         This causes copying to stop after the given number of input\n         records have been copied. The default is to copy until input\n         EOF is reached.\n\n         IMPORTANT! When COUNT=number is given, the given or implied\n         START=number control is incrimented by the given COUNT= value\n         for each successive copy. This makes it easier to segment\n         large files into smaller ones via suitable multiple copy\n         requests.\n\n     NOTES:\n\n       - If COUNT= and STOP= conflict, then copying will stop at\n         whichever event occurs first.\n\n       - If COUNT=0 or if STOP= is less than START=, then no records\n         are copied.\n\n       - All numbers are treated as being unsigned 32-bit. They may\n         range from 0 to 4g.\n\n\n\nTECHNICAL INFORMATION:\n\n1.) DSCOPY uses QSAM for all I/O.\n\n2.) Chained scheduling (OPTCD=C) is used wherever possible. It is not\n    possible for input data sets with RECFM=U. It is also not possible\n    when the BLKSIZE is sufficiently large and the region is\n    sufficently small that only one buffer can be generated.\n\n3.) DSCOPY is serially reusable.\n\n\n\nDYNAMIC INVOCATION:\n\nDSCOPY can be invoked as a subroutine by other programs. For details,\nsee commentary within DSCOPY's sopurce code.\n\n./ ADD NAME=XMITMSG  0100-05218-05218-1644-00048-00048-00000-DBCOLEA\nThe DSCOPY program is copyrighted (c) 1972-2005 by David B. Cole. All\nrights reserved.\n\nThis program is distributed freely and may be reproduced and\nredistributed without restriction other than:\n  - This copyright and usage/warranty/liability restriction statement\n    (\"Legal Statement\") may not be modified or removed.\n  - A similar Legal Statement located in this program's source code\n    also may not be removed.\n\nThis program is distributed without warranty of any kind, including\n(without limitation) warranties of merchantability and of fitness for a\nparticular purpose. It is up to the user to make his own determination\nof the usefulness of this program in his own system.\n\nThe user agrees not to hold either David B. Cole or Cole Software, LLC\nor any person affiliated with Cole Software, LLC (collectively \"COLE\")\nliable for any injury or damage whatsoever.\n\nFurther, the user agrees to indemnify COLE against third parties for\nany action arising from the user's use, misuse, modification, and/or\nredistribution of this program.\n\nThis program may be modified freely so long as all modifications are\nclearly marked both internally and externally to distinguish them from\nthe distributed code and functionality.\n\nAs a courtesy, please notify David Cole if you discover any bugs or if\nyou need or have made any code changes. (COLE, of course, does not\nguarantee that any future changes or corrections wither will or will\nnot be made.)\n\nContact information as of AUG05 is:\n\n    Name:                David B. Cole\n    Country:             USA\n    Telephone:           540-456-8536\n    FAX:                 540-456-6658\n    E-mail:              dbcole@colesoft.com\n    Website:             www.colesoft.com\n\n    Snail Mail:          Cole Software\n                         736 Fox Hollow Road\n                         Afton, VA 22920\n                         USA\n\nFor additional information, read the README file.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MACROS": {"ttr": 2305, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SCHEDRUN": {"ttr": 5889, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "XREFASM": {"ttr": 9476, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT199/CBT.V500.FILE199.PDS/NEWSTUFF.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT199/CBT.V500.FILE199.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}