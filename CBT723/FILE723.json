{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012652000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE723.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE723.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x04'", "DS1TRBAL": "b'\\x9f\\xc6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xfa\\x00\\x05\\x04\\xfa\\x00\\x08\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x05)O\\x01\\x05)O\\x10\\x08\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-10-21T00:00:00", "modifydate": "2005-10-21T10:08:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-470"}, "text": "REGULAR CBT TAPE - VERSION 470    FILE:  723\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT470.FILE723\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 8 MEMBERS COUNTED; CUMULATIVE SIZE IS 640 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/21/05    10:08:17    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00!\\x01\\x05'?\\x01\\x05'?\\tY\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-09-30T00:00:00", "modifydate": "2005-09-30T09:59:21", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "Sam,\n\nCan you check out this small bit of ISPF code for me?  It\nconsists of two small COBOL programs and one panel.  Compile and\nlink the COBOL into some load library accessible to ISPF\n(ISPLLIB, STEPLIB or TSOLIB tasklib) and slap the panel into some\nISPPLIB as member name SHOWMEMP.\n\nInvoke as: Command ===> TSO SHOWMEM\n\nIt's no big deal or anything.  It just shows 24/31 bit memory\nlimits, usage and how much is still available.  You can get the\nsame thing (an TONS of other stuff) by using ISPVCALL STATUS from\nOption 6 (TSO) of ISPF.  I wrote it more to demonstrate how to put\nan ISPF \"wrapper\" around generic code (callable from anywhere).\nThis is why one of the programs is named CLCCSTOR (the \"generic\"\nsubroutine) and the other one has as its name, the command name:\nSHOWMEM.\n\nIf everything hangs together, toss it on the CBT tape.  One\nadvantage that the little dialog has is that as you press enter,\nthe amounts can change.  If an ISPF user starts new screens or\nedit sessions, more memory is consumed and pressing enter will\n\"refresh\" the numbers. With ISPVCALL STATUS, you'd have to end\nthe View/Edit of the trace file and reinvoke ISPVCALL STATUS to\nget the numbers to \"refresh\".\n\nJim Moore\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE723": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x05)O\\x01\\x05)O\\x10\\x04\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-10-21T00:00:00", "modifydate": "2005-10-21T10:04:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "CBT-470"}, "text": "//***FILE 723 is from Jim Moore, and contains some application      *   FILE 723\n//*           code to show how much storage is available to your    *   FILE 723\n//*           session.  CLCCSTOR and SHOWMEM provide this service   *   FILE 723\n//*           from an ISPF environment.  SHOWSTOR provides a        *   FILE 723\n//*           similar service for an IDMS/DC environment.           *   FILE 723\n//*                                                                 *   FILE 723\n//*           email:  JB Moore<conlogco@comcast.net>                *   FILE 723\n//*                                                                 *   FILE 723\n//*     This is a small bit of ISPF code to show 24/31 bit          *   FILE 723\n//*     memory limits, usage, and how much is still available.      *   FILE 723\n//*     It consists of two small COBOL programs and one panel.      *   FILE 723\n//*     Compile and link the COBOL into some load library           *   FILE 723\n//*     accessible to ISPF (ISPLLIB, STEPLIB or TSOLIB tasklib)     *   FILE 723\n//*     and slap the panel into some ISPPLIB as member name         *   FILE 723\n//*     SHOWMEMP.                                                   *   FILE 723\n//*                                                                 *   FILE 723\n//*     You can get the same thing (an TONS of other stuff) by      *   FILE 723\n//*     using ISPVCALL STATUS from Option 6 (TSO) of ISPF.  I       *   FILE 723\n//*     wrote it more to demonstrate how to put an ISPF             *   FILE 723\n//*     \"wrapper\" around generic code (callable from anywhere).     *   FILE 723\n//*     This is why one of the programs is named CLCCSTOR (the      *   FILE 723\n//*     \"generic\" subroutine) and the other one has as its          *   FILE 723\n//*     name, the command name:  SHOWMEM.                           *   FILE 723\n//*                                                                 *   FILE 723\n//*     Invoke as: Command ===> TSO SHOWMEM                         *   FILE 723\n//*                                                                 *   FILE 723\n//*     The panel contents is renewable when you press ENTER.       *   FILE 723\n//*                                                                 *   FILE 723\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLCCSTOR": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x05'?\\x01\\x05'?\\tR\\x00J\\x00J\\x00\\x00\\xd1\\xd4\\xd6\\xd6\\xd9\\xc5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-09-30T00:00:00", "modifydate": "2005-09-30T09:52:00", "lines": 74, "newlines": 74, "modlines": 0, "user": "JMOORE"}, "text": "000100 Identification Division.\n000200 Program-ID. CLCCSTOR Is Initial.\n000300 Author. JB Moore - Concentrated Logic Incorporated.\n000400 Environment Division.\n000500*\n000600*REMARKS: -------------------------------------------------------*\n000700* Cobol Compile-Time Parms:-->>> TRUNC(BIN) MANDATORY!!!!!       *\n000800* Or, declare all Binary fields COMP-5 if compiler supports it.  *\n000900*                                                                *\n001000* PARM=(RENT,RMODE(ANY),SSRANGE,APOST,DYN,OFFSET,LIB,            *\n001100* MAP,XREF,TRUNC(BIN),NUMPROC(PFD),DATA(31))                     *\n001200*                                                                *\n001300* Binder (Link-Edit) Parms:                                      *\n001400*                                                                *\n001500* PARM='LET,LIST,MAP,XREF,RENT'                                  *\n001600* ============================================================== *\n001700* This program is meant to be called, never a \"PGM=\". It will    *\n001800* return the following five fields to the caller:                *\n001900*                                                                *\n002000* 1) 24-bit max amount of storage                                *\n002100* 2) 24-bit used amount of storage                               *\n002200* 3) 31-bit max amount of storage                                *\n002300* 4) 31-bit used amount of storage                               *\n002400* 5) REGION amount for address space                             *\n002500*                                                                *\n002600* Nothing is passed on input. No Working-Storage needed.         *\n002700* MUST have \"AMODE(31)\" for Local Data Area (\"LDA-Block\").       *\n002800*END-REMARKS.----------------------------------------------------*\n002900*\n003000 Data Division.\n003100 Linkage Section.\n003200 01  Return-Storage-Values            Binary.\n003300     05  LS-Max-24-Bit-Value          Pic S9(08).\n003400     05  LS-Used-24-Bit-Value         Pic S9(08).\n003500     05  LS-Max-31-Bit-Value          Pic S9(08).\n003600     05  LS-Used-31-Bit-Value         Pic S9(08).\n003700     05  LS-Region                    Pic S9(08).\n003800\n003900 01  PSA-Block.\n004000     05                               Pic  X(548).\n004100     05  PSAAOLD                      Pointer.\n004200\n004300 01  ASCB-Block.\n004400     05                               Pic  X(04).\n004500         88  ASCB-Literal             Value \"ASCB\".\n004600     05                               Pic  X(44).\n004700     05  ASCBLDA                      Pointer.\n004800\n004900 01  LDA-Block.\n005000     05                               Pic  X(04).\n005100         88  LDA-Literal              Value \"LDA \".\n005200     05                               Pic  X(200).\n005300     05  REGION-Value                 Pic S9(08) Binary.\n005400     05  Max-24-Bit-Value             Pic S9(08) Binary.\n005500     05                               Pic  X(04).\n005600     05  Max-31-Bit-Value             Pic S9(08) Binary.\n005700     05                               Pic  X(12).\n005800     05  Used-24-Bit-Value            Pic S9(08) Binary.\n005900     05                               Pic  X(04).\n006000     05  Used-31-Bit-Value            Pic S9(08) Binary.\n006100/\n006200 Procedure Division Using Return-Storage-Values.\n006300     Initialize Return-Storage-Values.\n006400     Set Address of PSA-Block     To Null.\n006500     Set Address of ASCB-Block    To PSAAOLD.\n006600     If ASCB-Literal\n006700        Set Address of LDA-Block  To ASCBLDA\n006800        If LDA-Literal\n006900           Move REGION-Value      To LS-Region\n007000           Move Max-24-Bit-Value  To LS-Max-24-Bit-Value\n007100           Move Max-31-Bit-Value  To LS-Max-31-Bit-Value\n007200           Move Used-24-Bit-Value To LS-Used-24-Bit-Value\n007300           Move Used-31-Bit-Value To LS-Used-31-Bit-Value.\n007400     Goback.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWMEM": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x05'?\\x01\\x05'?\\tR\\x01\\x07\\x01\\x07\\x00\\x00\\xd1\\xd4\\xd6\\xd6\\xd9\\xc5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-09-30T00:00:00", "modifydate": "2005-09-30T09:52:00", "lines": 263, "newlines": 263, "modlines": 0, "user": "JMOORE"}, "text": "000100 Identification Division.\n000200 Program-Id. Showmem.\n000300 Author. Jim Moore - Concentrated Logic Incorporated.\n000400*--Remarks.------------------------------------------------------*\n000500* Compile Options To Use:                                        *\n000600*                                                                *\n000700* Parm=(Rent,Dyn,Offset,Noseq,Quote,Noadv,Source,Map,Xref)       *\n000800*                                                                *\n000900* Link-Edit Options To Use:                                      *\n001000*                                                                *\n001100* Parm=(Let,List,Map,Xref,Rent)                                  *\n001200*                                                                *\n001300* -------------------------------------------------------------- *\n001400* This program is a COBOL ISPF dialog function. It calls the     *\n001500* program named CLCCSTOR to retrieve storage limits and in-use   *\n001600* amounts from the Local Data Area (IHALDA). It then calculates  *\n001700* the amount of \"Available 24 and 31\" storage and displays a     *\n001800* pop-up with all values.                                        *\n001900*                                                                *\n002000* It uses the &DAS (\"Display As\") variable to adjust the way     *\n002100* the values appear in the pop-up: As \"K\", \"M\" or \"B\" - kilo,    *\n002200* meg or edited bytes.                                           *\n002300*                                                                *\n002400* Bytes is the default and is the most accurate representation.  *\n002500* \"K\" is a bit less accurate but easier to read. \"M\" is the      *\n002600* \"granular\" but is probably easiest of all to read.             *\n002700*                                                                *\n002800* The &DAS variable is stored in whatever NEWAPPL profile pool   *\n002900* the dialog is executed in.                                     *\n003000*                                                                *\n003100*                                                                *\n003200*----------------------------------------------------------------*\n003300 Environment Division.\n003400 Data Division.\n003500 Working-Storage Section.\n003600 01  Misc-Fields.\n003700     05  Ispf-Talking-To-Me  Pic S9(08) Binary.\n003800         88  Pf3-Pressed     Value 8.\n003900 01  Ispf-Api-Services.\n004000     05  Vdefine             Pic  X(08) Value \"VDEFINE\".\n004100     05  Vput                Pic  X(08) Value \"VPUT\".\n004200     05  Setmsg              Pic  X(08) Value \"SETMSG\".\n004300     05  Addpop              Pic  X(08) Value \"ADDPOP\".\n004400     05  Rempop              Pic  X(08) Value \"REMPOP\".\n004500     05  Display-It          Pic  X(08) Value \"DISPLAY\".\n004600 01  Ispf-Api-Parameters.\n004700     05  Fixd                Pic  X(08) Value \"FIXED\".\n004800     05  Char                Pic  X(08) Value \"CHAR\".\n004900     05  Copy-It             Pic  X(08) Value \"(COPY)\".\n005000     05  Ispz000             Pic  X(08) Value \"ISPZ000\".\n005100     05  Isplink             Pic  X(08) Value \"ISPLINK\".\n005200     05  Main-Panel          Pic  X(08) Value \"SHOWMEMP\".\n005300     05  Profpool            Pic  X(08) Value \"PROFILE\".\n005400     05  Buf-Len             Pic S9(08) Binary.\n005500 01  Other-Parameters.\n005600     05  Clccstor            Pic  X(08) Value \"CLCCSTOR\".\n005700 01  Ispf-Literals.\n005800     05  Storage-Char-24     Pic  X(19)\n005900         Value \"(MAX24,USD24,AVL24)\".\n006000     05  Storage-Char-31     Pic  X(24)\n006100         Value \"(MAX31,USD31,REGN,AVL31)\".\n006200     05  Shortmsg            Pic  X(10)\n006300         Value \"(ZMSG000S)\".\n006400     05  Longmsg             Pic  X(10)\n006500         Value \"(ZMSG000L)\".\n006600     05  Display-Flag        Pic  X(05)\n006700         Value \"(DAS)\".\n006800 01  Function-Pool.\n006900     05  Edit-Storage-Values-24.\n007000         10  Max-24          Pic Zz,Zzz,Zzz.\n007100         10  Max-24-R        Redefines\n007200             Max-24          Pic  X(10).\n007300         10  Used-24         Pic Zz,Zzz,Zzz.\n007400         10  Used-24-R       Redefines\n007500             Used-24         Pic  X(10).\n007600         10  Avail-24        Pic Zz,Zzz,Zzz.\n007700         10  Avail-24-R      Redefines\n007800             Avail-24        Pic  X(10).\n007900     05  Edit-Storage-Values-31.\n008000         10  Max-31          Pic Z,Zzz,Zzz,Zzz.\n008100         10  Max-31-R        Redefines\n008200             Max-31          Pic  X(13).\n008300         10  Used-31         Pic Z,Zzz,Zzz,Zzz.\n008400         10  Used-31-R       Redefines\n008500             Used-31         Pic  X(13).\n008600         10  Region-Size     Pic Z,Zzz,Zzz,Zzz.\n008700         10  Region-Size-R   Redefines\n008800             Region-Size     Pic  X(13).\n008900         10  Avail-31        Pic Z,Zzz,Zzz,Zzz.\n009000         10  Avail-31-R      Redefines\n009100             Avail-31        Pic  X(13).\n009200     05  Zmsg000s            Pic  X(24) Value Spaces.\n009300     05  Zmsg000l            Pic  X(76) Value Spaces.\n009400     05  Display-As          Pic  X(01) Value Spaces.\n009500         88  Display-As-K    Value \"K\".\n009600         88  Display-As-M    Value \"M\".\n009700         88  Display-As-B    Value \"B\".\n009800 01  Return-Storage-Values   Binary.\n009900     05  Max-24-Bit-Value    Pic S9(08).\n010000     05  Used-24-Bit-Value   Pic S9(08).\n010100     05  Max-31-Bit-Value    Pic S9(08).\n010200     05  Used-31-Bit-Value   Pic S9(08).\n010300     05  Region-Value        Pic S9(08).\n010400 01  Available-24            Pic S9(08) Binary.\n010500 01  Available-31            Pic S9(08) Binary.\n010600 01  Divisor                 Pic S9(08) Binary.\n010700 01  Generic-K-Number        Pic S9(06)V9(02).\n010800 01                          Redefines Generic-K-Number.\n010900     05  Gn-K-Integer        Pic  9(06).\n011000     05  Gn-K-Decimal        Pic Sv9(02).\n011100 01  Generic-M-Number        Pic S9(04)V9(01).\n011200 01  Gn-K-Edit-Area.\n011300     05  Gn-K-Edit           Pic  Zzz,Zz9.\n011400     05                      Pic  X(01) Value \"K\".\n011500 01  Gn-M-Edit-Area.\n011600     05  Gn-M-Edit           Pic  Z,Zz9.9.\n011700     05                      Pic  X(01) Value \"M\".\n011800 Linkage Section.\n011900 01  Passed-Linkage.\n012000     05  Parm-Debug          Pic  X(100).\n012100/\n012200 Procedure Division Using Passed-Linkage.\n012300     Move Length   Of Max-24     To Buf-Len.\n012400     Call Isplink  Using Vdefine Storage-Char-24\n012500                         Edit-Storage-Values-24 Char Buf-Len.\n012600     Move Length   Of Max-31     To Buf-Len.\n012700     Call Isplink  Using Vdefine Storage-Char-31\n012800                         Edit-Storage-Values-31 Char Buf-Len.\n012900     Move Length   Of Zmsg000s   To Buf-Len.\n013000     Call Isplink  Using Vdefine Shortmsg Zmsg000s Char Buf-Len.\n013100     Move Length   Of Zmsg000l   To Buf-Len.\n013200     Call Isplink  Using Vdefine Longmsg Zmsg000l Char Buf-Len.\n013300     Move Length   Of Display-As To Buf-Len.\n013400     Call Isplink  Using Vdefine Display-Flag\n013500                         Display-As Char Buf-Len Copy-It.\n013600\n013700     Perform Until Pf3-Pressed\n013800       Call Clccstor Using Return-Storage-Values\n013900       Move Max-24-Bit-Value   To Max-24\n014000       Move Used-24-Bit-Value  To Used-24\n014100       Move Max-31-Bit-Value   To Max-31\n014200       Move Used-31-Bit-Value  To Used-31\n014300       Move Region-Value       To Region-Size\n014400       Compute Available-24 =\n014500         (Max-24-Bit-Value - Used-24-Bit-Value)\n014600       Move Available-24       To Avail-24\n014700       Compute Available-31 =\n014800         (Max-31-Bit-Value - Used-31-Bit-Value)\n014900       Move Available-31       To Avail-31\n015000       Perform 1000-Check-Display-Format Thru 1000-Exit\n015100       Call Isplink            Using Addpop\n015200       Call Isplink            Using Display-It Main-Panel\n015300       Move Return-Code        To Ispf-Talking-To-Me\n015400       Call Isplink            Using Rempop\n015500       Call Isplink            Using Vput Display-Flag Profpool\n015600     End-Perform.\n015700\n015800     Goback.\n015900/\n016000 1000-Check-Display-Format.\n016100     Move 1                  To Divisor.\n016200     Evaluate True\n016300        When Display-As-K\n016400           Move 1024         To Divisor\n016500        When Display-As-M\n016600           Move 1024000      To Divisor\n016700     End-Evaluate.\n016800\n016900     If Display-As-K\n017000*       24-Bit Max\n017100        Compute Generic-K-Number Rounded =\n017200        (Max-24-Bit-Value / Divisor)\n017300        If Gn-K-Decimal Not = Zeros\n017400          Add 1 To Gn-K-Integer\n017500        End-If\n017600        Move Gn-K-Integer To Gn-K-Edit\n017700        Move Gn-K-Edit-Area To Max-24-R\n017800*       24-Bit Used\n017900        Compute Generic-K-Number Rounded =\n018000         (Used-24-Bit-Value / Divisor)\n018100        If Gn-K-Decimal Not = Zeros\n018200          Add 1 To Gn-K-Integer\n018300        End-If\n018400        Move Gn-K-Integer To Gn-K-Edit\n018500        Move Gn-K-Edit-Area To Used-24-R\n018600*       24-Bit Available\n018700        Compute Generic-K-Number Rounded =\n018800         (Available-24 / Divisor)\n018900        If Gn-K-Decimal Not = Zeros\n019000          Add 1 To Gn-K-Integer\n019100        End-If\n019200        Move Gn-K-Integer To Gn-K-Edit\n019300        Move Gn-K-Edit-Area To Avail-24-R\n019400*       31-Bit Max\n019500        Compute Generic-K-Number Rounded =\n019600         (Max-31-Bit-Value / Divisor)\n019700        If Gn-K-Decimal Not = Zeros\n019800          Add 1 To Gn-K-Integer\n019900        End-If\n020000        Move Gn-K-Integer To Gn-K-Edit\n020100        Move Gn-K-Edit-Area To Max-31-R\n020200*       31-Bit Used\n020300        Compute Generic-K-Number Rounded =\n020400         (Used-31-Bit-Value / Divisor)\n020500        If Gn-K-Decimal Not = Zeros\n020600          Add 1 To Gn-K-Integer\n020700        End-If\n020800        Move Gn-K-Integer To Gn-K-Edit\n020900        Move Gn-K-Edit-Area To Used-31-R\n021000*       31-Bit Available\n021100        Compute Generic-K-Number Rounded =\n021200         (Available-31 / Divisor)\n021300        If Gn-K-Decimal Not = Zeros\n021400          Add 1 To Gn-K-Integer\n021500        End-If\n021600        Move Gn-K-Integer To Gn-K-Edit\n021700        Move Gn-K-Edit-Area To Avail-31-R\n021800*       Region Amount\n021900        Compute Generic-K-Number Rounded =\n022000         (Region-Value / Divisor)\n022100        If Gn-K-Decimal Not = Zeros\n022200          Add 1 To Gn-K-Integer\n022300        End-If\n022400        Move Gn-K-Integer To Gn-K-Edit\n022500        Move Gn-K-Edit-Area To Region-Size-R\n022600     Else\n022700     If Display-As-M\n022800*       24-Bit Max\n022900        Compute Generic-M-Number Rounded =\n023000        (Max-24-Bit-Value / Divisor)\n023100        Move Generic-M-Number To Gn-M-Edit\n023200        Move Gn-M-Edit-Area   To Max-24-R\n023300*       24-Bit Used\n023400        Compute Generic-M-Number Rounded =\n023500        (Used-24-Bit-Value / Divisor)\n023600        Move Generic-M-Number To Gn-M-Edit\n023700        Move Gn-M-Edit-Area   To Used-24-R\n023800*       24-Bit Available\n023900        Compute Generic-M-Number Rounded =\n024000        (Available-24      / Divisor)\n024100        Move Generic-M-Number To Gn-M-Edit\n024200        Move Gn-M-Edit-Area   To Avail-24-R\n024300*       31-Bit Max\n024400        Compute Generic-M-Number Rounded =\n024500        (Max-31-Bit-Value / Divisor)\n024600        Move Generic-M-Number To Gn-M-Edit\n024700        Move Gn-M-Edit-Area   To Max-31-R\n024800*       31-Bit Used\n024900        Compute Generic-M-Number Rounded =\n025000        (Used-31-Bit-Value / Divisor)\n025100        Move Generic-M-Number To Gn-M-Edit\n025200        Move Gn-M-Edit-Area   To Used-31-R\n025300*       31-Bit Available\n025400        Compute Generic-M-Number Rounded =\n025500        (Available-31      / Divisor)\n025600        Move Generic-M-Number To Gn-M-Edit\n025700        Move Gn-M-Edit-Area   To Avail-31-R\n025800*       Region Amount\n025900        Compute Generic-M-Number Rounded =\n026000        (Region-Value      / Divisor)\n026100        Move Generic-M-Number To Gn-M-Edit\n026200        Move Gn-M-Edit-Area   To Region-Size-R.\n026300 1000-Exit. Exit.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWMEMP": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x05'?\\x01\\x05'?\\tR\\x00\\x18\\x00\\x18\\x00\\x00\\xd1\\xd4\\xd6\\xd6\\xd9\\xc5@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-09-30T00:00:00", "modifydate": "2005-09-30T09:52:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "JMOORE"}, "text": ")ATTR\n? TYPE(OUTPUT) CAPS(ON)  INTENS(LOW) JUST(RIGHT)\n_ TYPE(INPUT)  CAPS(ON)  INTENS(HIGH)\n% TYPE(TEXT)             INTENS(HIGH) SKIP(ON)\n+ TYPE(TEXT)             INTENS(LOW)  SKIP(ON)\n)BODY WINDOW(66,10)\n%\n%Command ===>_ZCMD\n%\n%---------24-Bit---------  ---------31-Bit--------- -----\"REGION\"\n)MODEL\n+Maximum...:?Z          +  Maximum...:?Z          +?Z           +\n+Used......:?Z          +  Used......:?Z          +\n+Available.:?Z          +  Available.:?Z          +\n+\n+Display as:_Z+(K, M or B - Kilobytes, Megabytes or Bytes)\n)INIT\n.ZVARS = '(MAX24,MAX31,REGN,USD24,USD31,AVL24,AVL31,DAS)'\n&ZWINTTL = 'Storage - Maximums, Used and Available'\nIF (&DAS = '')\n    &DAS = 'B'\n)PROC\nVER (&DAS,LIST,B,K,M)\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWSTO#": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x17\\x01\\x05)O\\x01\\x05)O\\tW\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-10-21T00:00:00", "modifydate": "2005-10-21T09:57:17", "lines": 26, "newlines": 26, "modlines": 0, "user": "SBGOLOB"}, "text": "Sam,\n\nThe Assembler code is attached.  Note that this is for CA-IDMS\n(DC only, no DB).  If you know the CICS macro-set, perhaps you\ncould convert this to run in CICS as well.\n\nIn the code, any macro (or DSECT) that begins with a # or @ sign\nis a CA-IDMS macro.#GETSTG is like GETMAIN, #LINEOUT is straight\nscreen line mode (no BMS mapping, like REXX say), #FREESTG like\nFREEMAIN and so on.  @MODE assembles non-executable code,\nbranched around.\n\nAll of the \"MVS\" stuff should be identical (PSA, ASCB,LDA, etc).\n\nAlso for CICS, in the comments at the front of the program,\nsubstitute DFHRPL for CDMSLIB and PPT for \"SYSGEN a program\".\nThe Dynamic DCMT (think CEMT) thingies are just a temporary way\nto get the program/task in place on-the-fly without bouncing the\nregion.\n\nDoes CICS have that too?\n\nHave a whack at it.\n\nJim\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWSTOR": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00F\\x01\\x05)O\\x01\\x05)O\\tY\\x00\\xb9\\x00\\xb9\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-10-21T00:00:00", "modifydate": "2005-10-21T09:59:46", "lines": 185, "newlines": 185, "modlines": 0, "user": "SBGOLOB"}, "text": "* In order to use this program, it must be assembled and linked into\n* a load library that is allocated to CDMSLIB for a CV. Program\n* should be 31-bit, reentrant. Also, you will need to SYSGEN a\n* program and a task to invoke the program.\n*\n* Here's the \"Dynamic\" DCMTs to get it going:\n*\n* DCMT V DYN PRO *.SHOWSTOR ASSEM REENT .\n* DCMT V DYN TAS SHOWSTOR INV PRO *.SHOWSTOR LOC ANY .\n*\n* Then, just type SHOWSTOR at ENTER NEXT TASK CODE.\n*\n*RETRIEVAL                             . -----------------------------\n*NODMLIST                              . This program is for use under\n*                                      . CA-IDMS DC and OS/390 z/OS.\n*                                      . -----------------------------\n*                                      . By Jim Moore - ConLogCo\n*                                      .\n*                                      . This program gets control w/\n*                                      . DC register conventions. R10\n*                                      . points to IDMS CSA, R9 to TCE.\n*                                      .\n*                                      . Its sole purpose is to look\n*                                      . into the IBM control block\n*                                      . named the Local Data Area\n*                                      . (IHALDA Dsect) to determine:\n*                                      .\n*                                      . Current 24-bit stg Max & use\n*                                      . Current 31-bit stg Max & use\n*                                      . Current REGION= value\n*                                      . How close to defined max?\n*                                      . Display them on the screen\nSHOWSTOR RSECT                         . ------------------------------\nSHOWSTOR AMODE 31                      . 31-bit, Fully Reentrant\nSHOWSTOR RMODE ANY                     . 31-bit - MUST RUN 31-BIT!!!\n         PRINT NOGEN                   . No macro expand in SYSPRINT\n         LR    R12,R15                 . Get R15 into R12 for base\n         USING SHOWSTOR,R12            . Base the RSECT using R12\n         USING STORAGE,R11             . Base for GETSTG storage\n         USING CSA,R10                 . Base the CSA (R10 auto-set)\n         USING ASCB,R9                 . Base the ASCB (TCE not needed)\n         USING LDA,R8                  . Base the LDA (IBM, IHALDA)\n         USING PSA,R0                  . Base the PSA (IBM, IHAPSA)\n         SR  R0,R0                     . Clear R0\n         #GETSTG TYPE=(USER,SHORT),PLIST=*,LEN=STORLEN,STGID='ISTG',   X\n               COND=(ALL),ADDR=(R11),INIT=X'40'\n         L   R9,PSAAOLD                . Current ASCB address X'224'\n         CLC ASCBASCB,=C'ASCB'         . Pointing to ASCB?\n         BE  LDABASE                   . Yes, Get LDA\n         MVC SCRNLINE(14),=C'ASCB NOT FOUND'\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=SCRNLINE\n         B   EOJ                       . No, Who knows? Not MVS?\nLDABASE  DS  0H                        .-------------------------------\n         L   R8,ASCBLDA                . Current LDA Addr into R8\n         CLC LDAID,=C'LDA '            . Pointing to LDA?\n         BE  MAINLINE                  . Yes, Get Storage fields\n         MVC SCRNLINE(13),=C'LDA NOT FOUND'\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=SCRNLINE\n         B   EOJ                       . No, Who knows? Not 31-bit?\n         @MODE MODE=IDMSDC             .-------------------------------\n         DC  C' SHOWSTOR BY JIM MOORE' . Author\n         DC  C' &SYSASM '              . Names of Assembler\n         DC  C' &SYSDATC '             . Full date w/4-digit year\n         DC  C' &SYSTIME '             . Time\n         DC  C'COPYRIGHT - CONCENTRATED LOGIC INC - 2000,2005'\nMAINLINE DS  0H                        . CV number stored in CSA\n*--------------------------------------.----------------------------\n         LH  R6,CSADCVID               . Load CV Number into R6\n         CVD R6,DWORD                  . Convert to packed\n         UNPK CHARVALU,DWORD           . Unpack it\n         OI  CHARVALU+15,X'F0'         . Force \"F\" sign\n         MVC HDR,HEAD1                 . Move heading lit to GETSTG\n         MVC HDR+22(3),CHARVALU+13     . Move unpacked CV number\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=HDR\n         MVC SCRNLINE+1(18),=C'24 Bit Max For CV '\n         MVC SCRNLINE+19(3),HDR+22     . Move in CV number\n         MVC REGMASK1,WSMASK           . Move MASK to acquired stg\n         L   R6,LDALIMIT               . Load 24-bit limit into R6\n         CVD R6,DWORD                  . Convert R6 to packed\n         MVC S24MAX,DWORD              . Save 24-bit max amount\n         ED  REGMASK1,DWORD            . Edit the amount\n         MVC SCRNLINE+23(20),REGMASK1  . Move the amount\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=SCRNLINE,        X\n               OPTNS=(NOWAIT),COND=CANC,CANCXIT=RETURN\n         MVC SCRNLINE,SPACES           . Clear screen line\n         MVC SCRNLINE+1(18),=C'24 Bit Used By CV '\n         MVC SCRNLINE+19(3),HDR+22     . Move in CV number\n         MVC REGMASK1,WSMASK           . Move MASK to acquired stg\n         MVC REGMASK2,WSMASK           . Move MASK to acquired stg\n         L   R6,LDALOAL                . Load 24-bit inuse into R6\n         CVD R6,DWORD                  . Convert to packed\n         MVC S24USE,DWORD              . Save 24-bit used amount\n         ZAP TOTALU,S24USE             . Zap TOTALU with 24bit used\n         ED  REGMASK1,DWORD            . Edit the amount\n         MVC SCRNLINE+23(20),REGMASK1  . Move the amount\n         SP  S24MAX,S24USE             . Determine available\n         ED  REGMASK2,S24MAX           . Edit the amount available\n         MVC SCRNLINE+44(20),REGMASK2  . Move the amount available\n         MVC SCRNLINE+65(9),AVLIT      . Move Lit 'Available'\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=SCRNLINE,        X\n               OPTNS=(NOWAIT),COND=CANC,CANCXIT=RETURN\n         MVC SCRNLINE,SPACES           . Clear screen line\n         MVC SCRNLINE+1(18),=C'31 Bit Max For CV '\n         MVC SCRNLINE+19(3),HDR+22     . Move in CV number\n         MVC REGMASK1,WSMASK           . Move MASK to acquired stg\n         L   R6,LDAELIM                . Load 31-bit limit into R6\n         CVD R6,DWORD                  . Convert to packed\n         MVC S31MAX,DWORD              . Save 31-bit max amount\n         ED  REGMASK1,DWORD            . Edit the amount\n         MVC SCRNLINE+23(20),REGMASK1  . Move the amount\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=SCRNLINE,        X\n               OPTNS=(NOWAIT),COND=CANC,CANCXIT=RETURN\n         MVC SCRNLINE,SPACES           . Clear screen line\n         MVC SCRNLINE+1(18),=C'31 Bit Used By CV '\n         MVC SCRNLINE+19(3),HDR+22     . Move in CV number\n         MVC REGMASK1,WSMASK           . Move MASK to acquired stg\n         MVC REGMASK2,WSMASK           . Move MASK to acquired stg\n         L   R6,LDAELOAL               . Load 31-bit inuse into R6\n         CVD R6,DWORD                  . Convert to packed\n         MVC S31USE,DWORD              . Save 31-bit used amount\n         AP  TOTALU,S31USE             . Add 31bit to 24bit used\n         ED  REGMASK1,DWORD            . Edit the amount\n         MVC SCRNLINE+23(20),REGMASK1  . Move the amount\n         SP  S31MAX,S31USE             . Determine available\n         ED  REGMASK2,S31MAX           . Edit the amount available\n         MVC SCRNLINE+44(20),REGMASK2  . Move the amount available\n         MVC SCRNLINE+65(9),AVLIT      . Move Lit 'Available'\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=SCRNLINE,        X\n               OPTNS=(NOWAIT),COND=CANC,CANCXIT=RETURN\n         MVC SCRNLINE,SPACES           . Clear screen line\n         MVC SCRNLINE+1(17),=C'REGION= From JCL '\n         MVC REGMASK1,WSMASK           . Move MASK to acquired stg\n         L   R6,LDAREGRQ               . Load 31-bit inuse into R6\n         CVD R6,DWORD                  . Convert to packed\n         ED  REGMASK1,DWORD            . Edit the amount\n         MVC SCRNLINE+23(20),REGMASK1  . Move the amount\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=SCRNLINE,        X\n               OPTNS=(NOWAIT),COND=CANC,CANCXIT=RETURN\n         MVC SCRNLINE,SPACES           . Clear screen line\n         MVC SCRNLINE+1(19),=C'Total Storage Used '\n         MVC REGMASK1,WSMASK           . Move MASK to acquired stg\n         ED  REGMASK1,TOTALU           . Edit the amount\n         MVC SCRNLINE+23(20),REGMASK1  . Move the amount\n         MVC SCRNLINE+52(22),=C'(Used 24 Bit + 31 Bit)'\n         #LINEOUT OUTLEN=LINELEN,LRB=SYSPLIST,OUTAREA=SCRNLINE,        X\n               OPTNS=(NOWAIT),COND=CANC,CANCXIT=RETURN\nRETURN   DS 0H                         .-------------------------------\n         #FREESTG STGID='ISTG'         . Free acquired storage\nEOJ      #RETURN                       . Adios, muchachos\nHEAD1    DS  0CL80                     . Heading line\n         DC  C'=Storage From LDA===CV============== Bytes ============'\n         DC  C'=========================' . Screen Header\nAVLIT    DC  C'Available'              . 'Available' literal\nSPACES   DC  CL80' '                   . 80 blanks\nWSMASK   DC  X'402020206B2020206B2020206B2020206B202021'\n*              /\\      /\\              .             /\\\n*            PadChar  Comma            . Significance Character\n         YREGS ,                       . IBM Register macro\n         LTORG ,                       . Force LIT-POOL here\nSTORAGE  DSECT ,                       .-------------------------------\nSCRNLINE DS 0CL80                      . The Screen Line\nSNAME    DS CL32                       .    Type of Storage\nSAMT     DS CL10                       .    Limit/In-Use\nSEXTRA   DS CL38                       .    Extra data\nLINELEN  EQU *-SCRNLINE                .\nHDR      DS CL80                       . The screen header\n         DS 0F                         .-------------------------------\nREGMASK1 DS XL20                       . Move WSMASK here\nREGMASK2 DS XL20                       . Here too - preserve reentrancy\nS24MAX   DS PL8                        . 24 bit storage max\nS24USE   DS PL8                        . 24 bit storage in use\nS31MAX   DS PL8                        . 31 bit storage max\nS31USE   DS PL8                        . 31 bit storage in use\nSYSPLIST DS 6F                         . CA-IDMS \"ParmList\" area\nDWORD    DS D                          . Convert to Decimal Work Area\nCHARVALU DS CL16                       . Unpack Work Area\n         DS CL1                        . Slack\nTOTALU   DS PL8                        . Total 24bit + 31bit used\nSTORLEN  EQU *-STORAGE                 .------DBMS and OS Dsects-------\n         DS 0F                         .\n         COPY #CSADS                   . Common Storage Area (CA-IDMS)\n         IHALDA                        . LocalDataArea       (IBM VSM)\n         IHAASCB DSECT=YES,LIST=NO     . AddressSpaceCntlBlk (IBM DFP)\n         IHAPSA  DSECT=YES,LIST=NO     . PrefixedSaveArea    (IBM DFP)\n         END ,                         . ------------------------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT723/FILE723.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT723", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}