{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012507000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE628.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE628.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\n'", "DS1TRBAL": "b'\\x0cZ'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x8f\\x00\\x07\\x04\\x8f\\x00\\n\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04D\\x00\\x00\\x01\\x043\\x7f\\x01\\x043\\x7f\\x077\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf8@@@'", "ispf": {"version": "04.68", "flags": 0, "createdate": "2004-12-02T00:00:00", "modifydate": "2004-12-02T07:37:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-468"}, "text": "REGULAR CBT TAPE - VERSION 468    FILE:  628\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT468.FILE628\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,129 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/02/04    07:37:10    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00V\\x01\\x03\\x12\\x9f\\x01\\x042\\x8f\\x13X\\x00w\\x00n\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2003-05-09T00:00:00", "modifydate": "2004-11-23T13:58:56", "lines": 119, "newlines": 110, "modlines": 0, "user": "FAJA"}, "text": "/*REXX*****************************************************************\n**                                                                   **\n** NAME     - TCPDUMP                                                **\n**                                                                   **\n** VERSION  - 1.1                                                    **\n**                                                                   **\n** FUNCTION - Converts an OS/390 or z/OS TCP/IP packet trace file    **\n**            into tcpdump format. You can download the resulting    **\n**            output file to a PC (in binary mode) and analyze it    **\n**            using Ethereal (a freebie from www.ethereal.com) or    **\n**            any other network analyzer software that supports      **\n**            the tcpdump file format.                               **\n**                                                                   **\n** SYNTAX   - TCPDUMP \u00ddoutdsn \u00ddindsn\u00a8\u00a8 (options                      **\n**                                                                   **\n**            Where,                                                 **\n**                                                                   **\n**            outdsn = Output tcpdump dataset (RECFM=VB/1600 is best).*\n**                     The output dataset is specified first because **\n**                     you are most likely to want to re-specify this**\n**                     parameter.  You generally set the input trace **\n**                     dataset name once and re-use it for subsequent**\n**                     traces. Both the input and output dataset     **\n**                     names are remembered across invocations so    **\n**                     you do not have to re-specify them each time. **\n**                                                                   **\n**                     If you initially specify a PDS dataset and    **\n**                     member name - e.g. MY.PDS(MYDUMP1) - then you **\n**                     can specify just a member name the next time  **\n**                     - e.g. MYDUMP2 - and the last PDS will be     **\n**                     used. By specifying '..' for 'outdsn' you     **\n**                     will be prompted to enter a new dataset name. **\n**                                                                   **\n**                     A typical session might look like:            **\n**                                                                   **\n**                     1. a. Capture a packet trace to sys1.trace    **\n**                        b. Convert it to tcpdump format by:        **\n**                           tso tcpdump                             **\n**                           Enter input dataset name:               **\n**                           'sys1.trace'                            **\n**                           Enter output dataset name:              **\n**                           'a.b.c(d1)'                             **\n**                        c. FTP 'a.b.c(d1)' to your PC and open it  **\n**                           using ethereal.                         **\n**                                                                   **\n**                     2. a. Capture another packet trace to         **\n**                           sys1.trace                              **\n**                        b. Convert it to tcpdump format in the     **\n**                           same PDS but this time into member d2:  **\n**                           tso tcpdump d2                          **\n**                        c. FTP 'a.b.c(d2)' to your PC and open it  **\n**                           using ethereal.                         **\n**                                                                   **\n**                     3. a. Capture another packet trace to         **\n**                           sys1.trace                              **\n**                        b. Convert it to tcpdump format but this   **\n**                           time in a different PDS:                **\n**                           tcpdump ..                              **\n**                           Enter output dataset name:              **\n**                           'd.e.f(d3)'                             **\n**                        c. FTP 'd.e.f(d3)' to your PC and open it  **\n**                           using ethereal.                         **\n**                                                                   **\n**                                                                   **\n**            indsn  = Input trace dataset (output from CTRACE).     **\n**                                                                   **\n**            options= ETHERNET  - for ETHERNET II frame type (this  **\n**                                 is the default and is usually ok).**\n**                     TOKENRING - for 802.2 frame type.             **\n**                     FDDI      - for FDDI frame type.              **\n**                     ATM       - for ATM RFC1483 frame type.       **\n**                     LANE      - for ATM LAN Emulation frame type. **\n**                                                                   **\n**                     RANGE \u00ddstart \u00ddend\u00a8\u00a8                           **\n**                               - convert only packets between      **\n**                                 packet number 'start' and 'end'.  **\n**                                 'start' defaults to 1.            **\n**                                 'end' defaults to the last packet.**\n**                                                                   **\n**                     TRACE \u00ddstart \u00ddend\u00a8\u00a8                           **\n**                               - display a brief summary of packets**\n**                                 between 'start' and 'end'.        **\n**                                                                   **\n**                     DEBUG \u00ddstart \u00ddend\u00a8\u00a8                           **\n**                               - display a more detail for packets **\n**                                 between 'start' and 'end'.        **\n**                                                                   **\n**                     ONLY      - ONLY means quit when the 'end'    **\n**                                 packet is reached (when TRACE or  **\n**                                 DEBUG is also specified).         **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1. The format of the input trace file is release       **\n**               dependent. Version 1.1 works with OS/390 2.10 and   **\n**               z/OS 1.1 to 1.4.                                    **\n**                                                                   **\n**            2. The frametype does not seem to be critical to       **\n**               Ethereal (it seems to ignore it) so you can let it  **\n**               default to ETHERNET if you like.                    **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew Armstrong <andrew_armstrong(at)unwired.com.au>  **\n**                                                                   **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20041123 AJA Handle a wrapped trace file properly.     **\n**            20041105 AJA Replace deprecated find() with wordpos(). **\n**                         Removed flawed attempt to retrieve MAC    **\n**                         address associated with IP address.       **\n**                         Removed the PING option accordingly.      **\n**                         A fake MAC address is generated from the  **\n**                         link name and IP address.                 **\n**            20030502 AJA Cleaned up and documented.                **\n**            20030130 AJA Initial version                           **\n**                                                                   **\n**********************************************************************/\n\n------------------------------END OF README-----------------------------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE1": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x01\\x03\\x13\\x1f\\x01\\x042\\x8f\\x14\\x00\\x00#\\x00#\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-05-11T00:00:00", "modifydate": "2004-11-23T14:00:27", "lines": 35, "newlines": 35, "modlines": 0, "user": "FAJA"}, "text": "Subject: cbt contribution (tcpdump)\nDate: Fri, 9 May 2003 14:07:30 +1000\nFrom: \"Andrew Armstrong\" <aarmstrong@mail.fairfax.com.au>\nTo: <sbgolob@cbttape.org>\n\nHi Sam,\n\nThis is my first CBT contribution.\n\nIt is a Rexx procedure that will convert a TCP/IP packet trace\n(ctrace) dataset into Unix tcpdump format.\n\nI use it so that I can browse OS/390 packet traces on Windows in\nfull color using the freeware packet capture/decoder program\ncalled Ethereal (www.ethereal.com). Ethereal is supported on many\nother platforms and using it is IMHO far superior to trawling\nthrough a printed packet trace.\n\nIt has been tested on OS/390 2.10 and z/OS 1.4 and depends on the\n(undocumented) format of the ctrace dataset.\n\n\nCheers,\nAndrew Armstrong\nSystem Programmer.\n\n44 Fallon Drive\nDural NSW 2158\nAUSTRALIA\n\nprimary email: andrew_armstrong@unwired.com.au\nalternate email: aarmstrong@mail.fairfax.com.au\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE628": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04D\\x00\\x00\\x01\\x043\\x7f\\x01\\x043\\x7f\\x076\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf8@@@'", "ispf": {"version": "04.68", "flags": 0, "createdate": "2004-12-02T00:00:00", "modifydate": "2004-12-02T07:36:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT-468"}, "text": "//***FILE 628 is from Andrew Armstrong and contains a REXX exec     *   FILE 628\n//*           to analyze an OS390 TCP/IP packet trace file.         *   FILE 628\n//*                                                                 *   FILE 628\n//*   Program Description:                                          *   FILE 628\n//*                                                                 *   FILE 628\n//*     Converts an OS390 TCP/IP packet trace file into tcpdump     *   FILE 628\n//*     format.  You can download the output file to a PC (in       *   FILE 628\n//*     binary mode) and analyze it using Ethereal (a freebie       *   FILE 628\n//*     from www.ethereal.com) or any other network analyzer        *   FILE 628\n//*     software that supports tcpdump file format.                 *   FILE 628\n//*                                                                 *   FILE 628\n//*   email: andrew_armstrong@unwired.com.au                        *   FILE 628\n//*          aarmstrong@mail.fairfax.com.au                         *   FILE 628\n//*                                                                 *   FILE 628\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GPL": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00Y\\x01\\x03\\x12\\x9f\\x01\\x03\\x12\\x9f\\x10\\t\\x01\\x1c\\x01\\x1c\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-05-09T00:00:00", "modifydate": "2003-05-09T10:09:59", "lines": 284, "newlines": 284, "modlines": 0, "user": "FAJA"}, "text": "            GNU GENERAL PUBLIC LICENSE\n               Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n\n            GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n             END OF TERMS AND CONDITIONS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TCPDUMP": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00 \\x01\\x042\\x8f\\x01\\x042\\x8f\\x13R\\x02\\x99\\x02\\x99\\x00\\x00\\xc6\\xc1\\xd1\\xc1@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-11-23T00:00:00", "modifydate": "2004-11-23T13:52:20", "lines": 665, "newlines": 665, "modlines": 0, "user": "FAJA"}, "text": "/*REXX*****************************************************************\n*                                                                     *\n* TCPDUMP v1.1 - CTrace-to-tcpdump format converter                   *\n*                                                                     *\n* Copyright (C) 2003-2005 Andrew J. Armstrong                         *\n* andrew_armstrong(at)unwired.com.au                                  *\n*                                                                     *\n* This program is free software; you can redistribute it and/or modify*\n* it under the terms of the GNU General Public License as published by*\n* the Free Software Foundation; either version 2 of the License, or   *\n* (at your option) any later version.                                 *\n* This program is distributed in the hope that it will be useful,     *\n* but WITHOUT ANY WARRANTY; without even the implied warranty of      *\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the       *\n* GNU General Public License for more details.                        *\n* You should have received a copy of the GNU General Public License   *\n* along with this program; if not, write to the Free Software         *\n* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307*\n*                                                                     *\n**********************************************************************/\n\n/*REXX*****************************************************************\n**                                                                   **\n** NAME     - TCPDUMP                                                **\n**                                                                   **\n** VERSION  - 1.1                                                    **\n**                                                                   **\n** FUNCTION - Converts an OS/390 or z/OS TCP/IP packet trace file    **\n**            into tcpdump format. You can download the resulting    **\n**            output file to a PC (in binary mode) and analyze it    **\n**            using Ethereal (a freebie from www.ethereal.com) or    **\n**            any other network analyzer software that supports      **\n**            the tcpdump file format.                               **\n**                                                                   **\n** SYNTAX   - TCPDUMP \u00ddoutdsn \u00ddindsn\u00a8\u00a8 (options                      **\n**                                                                   **\n**            Where,                                                 **\n**                                                                   **\n**            outdsn = Output tcpdump dataset (RECFM=VB/1600 is best).*\n**                     The output dataset is specified first because **\n**                     you are most likely to want to re-specify this**\n**                     parameter.  You generally set the input trace **\n**                     dataset name once and re-use it for subsequent**\n**                     traces. Both the input and output dataset     **\n**                     names are remembered across invocations so    **\n**                     you do not have to re-specify them each time. **\n**                                                                   **\n**                     If you initially specify a PDS dataset and    **\n**                     member name - e.g. MY.PDS(MYDUMP1) - then you **\n**                     can specify just a member name the next time  **\n**                     - e.g. MYDUMP2 - and the last PDS will be     **\n**                     used. By specifying '..' for 'outdsn' you     **\n**                     will be prompted to enter a new dataset name. **\n**                                                                   **\n**                     A typical session might look like:            **\n**                                                                   **\n**                     1. a. Capture a packet trace to sys1.trace    **\n**                        b. Convert it to tcpdump format by:        **\n**                           tso tcpdump                             **\n**                           Enter input dataset name:               **\n**                           'sys1.trace'                            **\n**                           Enter output dataset name:              **\n**                           'a.b.c(d1)'                             **\n**                        c. FTP 'a.b.c(d1)' to your PC and open it  **\n**                           using ethereal.                         **\n**                                                                   **\n**                     2. a. Capture another packet trace to         **\n**                           sys1.trace                              **\n**                        b. Convert it to tcpdump format in the     **\n**                           same PDS but this time into member d2:  **\n**                           tso tcpdump d2                          **\n**                        c. FTP 'a.b.c(d2)' to your PC and open it  **\n**                           using ethereal.                         **\n**                                                                   **\n**                     3. a. Capture another packet trace to         **\n**                           sys1.trace                              **\n**                        b. Convert it to tcpdump format but this   **\n**                           time in a different PDS:                **\n**                           tcpdump ..                              **\n**                           Enter output dataset name:              **\n**                           'd.e.f(d3)'                             **\n**                        c. FTP 'd.e.f(d3)' to your PC and open it  **\n**                           using ethereal.                         **\n**                                                                   **\n**                                                                   **\n**            indsn  = Input trace dataset (output from CTRACE).     **\n**                                                                   **\n**            options= ETHERNET  - for ETHERNET II frame type (this  **\n**                                 is the default and is usually ok).**\n**                     TOKENRING - for 802.2 frame type.             **\n**                     FDDI      - for FDDI frame type.              **\n**                     ATM       - for ATM RFC1483 frame type.       **\n**                     LANE      - for ATM LAN Emulation frame type. **\n**                                                                   **\n**                     RANGE \u00ddstart \u00ddend\u00a8\u00a8                           **\n**                               - convert only packets between      **\n**                                 packet number 'start' and 'end'.  **\n**                                 'start' defaults to 1.            **\n**                                 'end' defaults to the last packet.**\n**                                                                   **\n**                     TRACE \u00ddstart \u00ddend\u00a8\u00a8                           **\n**                               - display a brief summary of packets**\n**                                 between 'start' and 'end'.        **\n**                                                                   **\n**                     DEBUG \u00ddstart \u00ddend\u00a8\u00a8                           **\n**                               - display a more detail for packets **\n**                                 between 'start' and 'end'.        **\n**                                                                   **\n**                     ONLY      - ONLY means quit when the 'end'    **\n**                                 packet is reached (when TRACE or  **\n**                                 DEBUG is also specified).         **\n**                                                                   **\n**                                                                   **\n** NOTES    - 1. The format of the input trace file is release       **\n**               dependent. Version 1.1 works with OS/390 2.10 and   **\n**               z/OS 1.1 to 1.4.                                    **\n**                                                                   **\n**            2. The frametype does not seem to be critical to       **\n**               Ethereal (it seems to ignore it) so you can let it  **\n**               default to ETHERNET if you like.                    **\n**                                                                   **\n**                                                                   **\n** AUTHOR   - Andrew Armstrong <andrew_armstrong(at)unwired.com.au>  **\n**                                                                   **\n**                                                                   **\n** HISTORY  - Date     By  Reason (most recent at the top please)    **\n**            -------- --- ----------------------------------------- **\n**            20041123 AJA Handle a wrapped trace file properly.     **\n**            20041105 AJA Replace deprecated find() with wordpos(). **\n**                         Removed flawed attempt to retrieve MAC    **\n**                         address associated with IP address.       **\n**                         Removed the PING option accordingly.      **\n**                         A fake MAC address is generated from the  **\n**                         link name and IP address.                 **\n**            20030502 AJA Cleaned up and documented.                **\n**            20030130 AJA Initial version                           **\n**                                                                   **\n**********************************************************************/\n\n  numeric digits 20\n\n  arg sOutDSN sInDSN'('sOptions')'\n\n  address TSO 'CLEAR'\n\n  parse source . . sMe .\n  say 'TCPD001I' sMe': Ctrace-to-tcpdump format converter v1.1'\n\n  g. = 0\n  call getOptions sOptions\n\n  address ISPEXEC 'VGET (TCPDUMPI TCPDUMPO) PROFILE'\n\n  TCPDUMPI = getDSN('TCPD002I Enter input dataset name:',,\n                     sInDSN, TCPDUMPI)\n  TCPDUMPO = getDSN('TCPD002I Enter output dataset name:',,\n                     sOutDSN,TCPDUMPO)\n  say 'TCPD003I Converting' TCPDUMPI 'to' TCPDUMPO\n\n  if g.!OPT.RANGE\n  then select\n    when g.!OPT.RANGE.0 = 0 then,\n         say 'TCPD004I Converting all'\n    when g.!OPT.RANGE.0 = 1 then,\n         say 'TCPD004I Converting from' g.!OPT.RANGE.1\n    otherwise,\n         say 'TCPD004I Converting from packet' g.!OPT.RANGE.1,\n                                   'to packet' g.!OPT.RANGE.2\n  end\n\n  if g.!OPT.TRACE\n  then select\n    when g.!OPT.TRACE.0 = 0 then,\n         say 'TCPD005I Tracing all'\n    when g.!OPT.TRACE.0 = 1 then,\n         say 'TCPD005I Tracing from' g.!OPT.TRACE.1\n    otherwise,\n         say 'TCPD005I Tracing from' g.!OPT.TRACE.1,\n                                'to' g.!OPT.TRACE.2\n  end\n\n  call Prolog\n\n  g.!HEADERLEN = 70\n  g.!PACKET    = 0\n  g.!WRITTEN   = 0\n\n  call skipToStartOfTrace  /* ...may not be the first record */\n\n  if g.!STARTOFTRACE = 0   /* If trace starts at the first record */\n  then call extractPackets /* ...until EOF */\n  else do\n    call readTraceRecord   /* Read first record after wrap point */\n    if g.!RC = 0\n    then do\n      call extractPackets  /* ...from wrap point to EOF */\n      say 'TCPD008I Wrapped after packet' g.!PACKET\n    end\n    call closeFile 'INPUT'\n    call readTraceRecord\n    call extractPackets    /* ...from start of file to wrap point */\n  end\n\n  call Epilog\nexit\n\nreadTraceRecord: procedure expose g.\n  'EXECIO 1 DISKR INPUT (STEM g.'\n  g.!RC = rc\nreturn\n\nextractPackets: procedure expose g.\n  do while g.!RC = 0 & \\g.!QUIT\n    parse var g.1 17 sBlk +4 22 cFlag +1 sSeq +2\n    if sSeq = '0001'x\n    then parse var g.1 181 sData /* First chunk of a trace buffer */\n    else parse var g.1 183 sData /* Remaining chunks */\n    sPackets = ''\n    do while g.!RC = 0 & cFlag = g.!CONTINUATION\n      sPackets = sPackets || sData\n      call readTraceRecord\n      parse var g.1 17 sBlk +4 22 cFlag +1 sSeq +2 183 sData\n    end\n    sPackets = sPackets || sData\n    do while \\g.!QUIT & length(sPackets) > 0\n      parse var sPackets sHeader +(g.!HEADERLEN) sPackets\n      parse var sHeader,\n                sPrevChunkLen +2, /* Length of previous chunk    */\n                sThisChunkLen +2, /* Length of this chunk        */\n                sJunk2        +6, /* ?                           */\n                sTOD1         +8, /* A Time-Of-Day clock value   */\n                cFlag1        +1, /* Flag: partial data          */\n                cFlag2        +1, /* Flag: packet direction      */\n                sJunk3        +4, /* ?                           */\n                sPacketLen    +2, /* Length of this packet       */\n                sLinkName    +16, /* Link name presenting packet */\n                sSourceIP     +4, /* Source IP address           */\n                sDestIP       +4, /* Destination IP address      */\n                sTOD2         +8, /* Another TOD clock value     */\n                sSourcePort   +2, /* Source port number          */\n                sDestPort     +2, /* Destination port number     */\n                sJunk4        +6  /* ?                           */\n      if sThisChunkLen = '' then leave\n\n      if g.!OPT.DEBUG then call showDebug\n\n      nChunkLen  = c2d(sThisChunkLen) - g.!HEADERLEN\n      parse var sPackets sPacket +(nChunkLen) sPackets\n      if isSet(cFlag1,g.!PARTIAL_PACKET) then iterate\n\n      call emitPcapPacket\n\n    end\n    call readTraceRecord\n    if cFlag = g.!WRAP_POINT then leave\n  end\nreturn\n\nskipToStartOfTrace: procedure expose g.\n  say 'TCPD006I Finding start of trace'\n  'EXECIO 1 DISKR INPUT (STEM g.'\n  do nSkip = 0 while rc = 0\n    parse var g.1 22 cFlag +1\n    if cFlag = g.!WRAP_POINT then leave\n    'EXECIO 1 DISKR INPUT (STEM g.'\n  end\n  g.!RC = rc\n  g.!STARTOFTRACE = nSkip\n  say 'TCPD007I Trace data starts at record' g.!STARTOFTRACE+1\nreturn\n\n/*\n* Parse the specified options line and build global variables\n* representing the keyword options and any values they may have.\n*\n* Global variables set are:\n*\n*  g.!OPT.keyword   = 1 if keyword is present (else = 0)\n*  g.!OPT.keyword.0 = count of numeric values appearing after keyword\n*  g.!OPT.keyword.1 = first numeric value after keyword\n*  g.!OPT.keyword.2 = second numeric value after keyword\n*  g.!OPT.keyword.n = nth numeric value after keyword\n*\n*/\ngetOptions: procedure expose g.\n  arg sOptions\n  do i = 1 to words(sOptions)\n    sOption = word(sOptions,i)\n    if datatype(sOption,'UPPERCASE') /* i.e. a keyword */\n    then call getOption(sOption)\n  end\nreturn\n\ngetOption: procedure expose g. sOptions\n  arg sOption\n  n = wordpos(sOption,sOptions)\n  g.!OPT.sOption    = n > 0\n  if n > 0\n  then do\n    j = 0\n    do i = n+1 to words(sOptions),\n       while datatype(word(sOptions,i),'NUMBER') /* i.e. a value */\n       j = j + 1\n       g.!OPT.sOption.j = word(sOptions,i)\n    end\n    g.!OPT.sOption.0 = j /* ...number of numeric values after keyword */\n  end\nreturn\n\nshowDebug:\n  if g.!PACKET = 0 then return\n  if g.!OPT.DEBUG.0 = 0 /* ...DEBUG all */             |,\n    (g.!OPT.DEBUG.0 = 1 & g.!PACKET >= g.!OPT.DEBUG.1) |,\n    (g.!OPT.DEBUG.0 = 2 & g.!PACKET >= g.!OPT.DEBUG.1,\n                        & g.!PACKET <= g.!OPT.DEBUG.2)\n  then do\n    sLink = strip(translate(sLinkName,'.',xrange('00'x,'3f'x)))\n    if isSet(cFlag2,g.!OUTBOUND_PACKET)\n    then sDataFlow = c2i(sSourceIP)':'c2d(sSourcePort),\n                     '---'sLink'-->',\n                     c2i(sDestIP)':'c2d(sDestPort)\n    else sDataFlow = c2i(sDestIP)':'c2d(sDestPort),\n                     '<--'sLink'---',\n                     c2i(sSourceIP)':'c2d(sSourcePort)\n/*\nnnnnnn pc=xxxx cl=xxxx j2=xxxxxxxxxxxx\n       t1=xxxxxxxxxxxxxxxx yyyy/mm/dd hh:mm:ss.nnnnnn f1=xx f2=xx\n       j3=xxxxxxxx\n       t2=xxxxxxxxxxxxxxxx yyyy/mm/dd hh:mm:ss.nnnnnn pl=nnnnn\n       aaa.bbb.ccc.ddd:eeeee---kkkkkkkkkkkkkkkk-->aaa.bbb.ccc.ddd:eeeee\n       j4=xxxxxxxxxxxx\n*/\n    say right(g.!PACKET,6,'0'),\n               'pc='c2x(sPrevChunkLen ),\n               'cl='c2x(sThisChunkLen ),\n               'j2='c2x(sJunk2        )\n    say '      ',\n               't1='c2x(sTOD1         ) getTimeStamp(c2d(sTOD1)),\n               'f1='c2x(cFlag1        ),\n               'f2='c2x(cFlag2        )\n    say '      ',\n               'j3='c2x(sJunk3        )\n    say '      ',\n               't2='c2x(sTOD2         ) getTimeStamp(c2d(sTOD2)),\n               'pl='c2x(sPacketLen    )\n    say '      ',\n               sDataFlow\n    say '      ',\n               'j4='c2x(sJunk4        )\n  end\n  if g.!OPT.ONLY & g.!PACKET >=g.!OPT.DEBUG.2\n  then g.!QUIT = 1\nreturn\n\nisSet: procedure\n  parse arg cFlag,cMask\nreturn bitand(cFlag,cMask) = cMask\n\nOut: procedure\n  parse arg sData\n  push sData\n  'EXECIO 1 DISKW OUTPUT'\nreturn\n\n/*\n* Prompt the user if necessary for a dataset name and return only\n* if the dataset exists. The user can force the use of the last\n* dataset by specifying '.' and can ask to be prompted for a new\n* dataset by specifying '..'.\n*\n*/\ngetDSN: procedure\n  parse arg sPrompt,sArg,sVar\n\n  select\n    when sArg = ''   then sDSN = sVar\n    when sArg = '.'  then sDSN = sVar\n    when sArg = '..' then sDSN = ''\n    otherwise             sDSN = sArg\n  end\n\n  if sDSN = ''\n  then do                  /* Prompt if no current value */\n    say sPrompt\n    pull sDSN\n    if sDSN = ''\n    then call Abort 'TCPD015I No value supplied'\n  end\n  else do\n    if isMemberName(sDSN) & pos('(',sVar) > 0\n    then do                /* Use new member in same PDS */\n      parse var sVar sDataset'('\n      sDSN = sDataset'('sDSN')'\n    end\n  end\n\n  sResult = SYSDSN(sDSN)\n\n  select\n    when sResult = 'OK'               then return sDSN\n    when sResult = 'MEMBER NOT FOUND' then return sDSN\n    otherwise call Abort 'TCPD011E' sDSN':' sResult\n  end\nexit\n\nAbort: procedure expose g.\n  parse arg sMsg\n  say sMsg\n  say 'TCPD016W Awwooga, Awwooga, Abandon ship.'\nexit\n\nisMemberName: procedure\n  arg sMember\n  if length(sMember) > 8 then return 0\n  if length(sMember) = 0 then return 0\n  if datatype(left(sMember,1),'WHOLE') then return 0\nreturn datatype(substr(sMember,2),'ALPHANUMERIC')\n\nProlog:\n  /* cFlag values ... */\n  g.!WRAP_POINT           = '00'x\n  g.!CONTINUATION         = '01'x\n  g.!LAST_IN_TRACE_BUFFER = '02'x\n\n  /* cFlag1 values ... */\n  g.!PARTIAL_PACKET       = '01'x\n\n  /* cFlag2 values ... */\n  g.!OUTBOUND_PACKET      = '01'x\n\n  g.!LAST_TOD = 0\n  g.!FIRST_TOD = 0\n\n  g.!TCPDUMP_MAGIC         = 'd4c3b2a1'x\n  g.!PCAP_VERSION_MAJOR    = u_short(2)\n  g.!PCAP_VERSION_MINOR    = u_short(4)\n\n  /* From libpcap-0.7.1.tar.gz (bpf.h and savefile.c) ... */\n  g.!LINKTYPE_ETHERNET     = u_int32(1)\n  g.!LINKTYPE_TOKEN_RING   = u_int32(6)\n  g.!LINKTYPE_FDDI         = u_int32(10)\n  g.!LINKTYPE_ATM_RFC1483  = u_int32(100)\n  g.!LINKTYPE_ATM_LANE8023 = u_int32(110)\n\n  select\n    when g.!OPT.TOKENRING then g.!LINKTYPE = g.!LINKTYPE_TOKEN_RING\n    when g.!OPT.FDDI      then g.!LINKTYPE = g.!LINKTYPE_FDDI\n    when g.!OPT.LANE      then g.!LINKTYPE = g.!LINKTYPE_ATM_LANE8023\n    when g.!OPT.ATM       then g.!LINKTYPE = g.!LINKTYPE_ATM_RFC1483\n    otherwise                  g.!LINKTYPE = g.!LINKTYPE_ETHERNET\n  end\n\n  g.!PROTOCOL_TCPIP       = u_short(8)\n\n  /* 1 Year = 365 days 5 hours 48 minutes 45.51 seconds (no joke) */\n  g.!EPOCH = trunc((70*(((365*24+5)*60+48)*60+45.51)+380)*1000000)\n  g.!DAYLIGHT_ADJ = 3600 * 1000000      /* 1 hour in microseconds    */\n\n  g.!TZ = mvsvar('symdef','lhr') - mvsvar('symdef','hr')\n\n  g.!THIS_ZONE    = u_int32(-g.!TZ*3600) /* gmt to local correction  */\n  g.!SIG_FIGS     = u_int32(0)          /* accuracy of timestamps    */\n  g.!SNAP_LEN     = u_int32(65535)      /* max len saved of each pkt */\n  g.!FILE_HEADER  = g.!TCPDUMP_MAGIC      ||,\n                    g.!PCAP_VERSION_MAJOR ||,\n                    g.!PCAP_VERSION_MINOR ||,\n                    g.!THIS_ZONE          ||,\n                    g.!SIG_FIGS           ||,\n                    g.!SNAP_LEN           ||,\n                    g.!LINKTYPE\n\n\n  call Alloc 'INPUT' TCPDUMPI\n  call Alloc 'OUTPUT' TCPDUMPO\n  call emitPcapFileHeader\nreturn\n\nemitPcapFileHeader:\n  call Out g.!FILE_HEADER\nreturn\n\nemitPcapPacket:\n  g.!PACKET = g.!PACKET + 1\n\n  nTOD = c2d(sTOD2)\n  if nTOD < g.!LAST_READ_TOD\n  then do\n    nDiff = (g.!LAST_READ_TOD - nTOD) / 4096 / 1000000\n    say 'TCPD009W Time warp at packet' g.!PACKET '-',\n        'time went backwards by' format(nDiff,,3) 'seconds.'\n  end\n  if g.!FIRST_READ_TOD = 0\n  then do\n    g.!FIRST_READ_TOD = nTOD\n    g.!FIRST_READ_PKT = g.!PACKET\n  end\n  g.!LAST_READ_TOD = nTOD\n  g.!LAST_READ_PKT = g.!PACKET\n\n  sTimeStamp = ctime(sTOD2)\n  sCaptureLen = u_int32(14+nChunkLen)\n  sWireLen = sCaptureLen\n  sDA = getMacAddr(sDestIP,   sLinkName)\n  sSA = getMacAddr(sSourceIP, sLinkName)\n  sFrame = sDA || sSA || g.!PROTOCOL_TCPIP || sPacket\n\n  if \\g.!OPT.RANGE |,\n     (g.!OPT.RANGE & g.!OPT.RANGE.0 > 0 & g.!PACKET >= g.!OPT.RANGE.1)\n  then do\n    call Out sTimeStamp || sCaptureLen || sWireLen || sFrame\n    g.!WRITTEN = g.!WRITTEN + 1\n    if g.!FIRST_WRITE_TOD = 0\n    then do\n      g.!FIRST_WRITE_TOD = nTOD\n      g.!FIRST_WRITE_PKT = g.!PACKET\n    end\n    g.!LAST_WRITE_TOD = nTOD\n    g.!LAST_WRITE_PKT = g.!PACKET\n    if g.!OPT.RANGE & g.!OPT.RANGE.0 = 2 & g.!PACKET >= g.!OPT.RANGE.2\n    then g.!QUIT = 1\n  end\n  if g.!OPT.TRACE then call showTrace\nreturn\n\nshowTrace:\n/*\n#nnnnnn lllll <start of packet in hex>...<end of packet in hex>\n*/\n  if g.!OPT.TRACE.0 = 0 /* ...trace all */             |,\n    (g.!OPT.TRACE.0 = 1 & g.!PACKET >= g.!OPT.TRACE.1) |,\n    (g.!OPT.TRACE.0 = 2 & g.!PACKET >= g.!OPT.TRACE.1,\n                        & g.!PACKET <= g.!OPT.TRACE.2)\n  then say 'TCPD010I #'left(g.!PACKET,6) right(nChunkLen,5),\n            c2x( left(sPacket,20))'...'\n\n  if g.!OPT.ONLY & g.!PACKET >= g.!OPT.TRACE.2\n  then g.!QUIT = 1\nreturn\n\n/*\n* Return a fake MAC address for the given IP address.\n* The address returned is in the format: xxxxxxxxccdd\n* ...where xxxxxxxx is the last four bytes of the link name\n*      and aabbccdd is the binary IP v4 address.\n* The link name is most likely something like EN0 or LINKB40\n* i.e. the rightmost bytes being the most variable.\n* We put the four rightmost bytes of the link name at the front of\n* the fake MAC address. This allows you to tell Ethereal to\n* color-code packets based on the OSA link they passed through.\n*/\ngetMacAddr: procedure expose g.\n  parse arg sIPAddr,sLinkName\nreturn right(strip(sLinkName),4)right(sIPAddr,2)\n\n\n/*\n* Convert TOD clock value to a ctime representation\n*/\nctime: procedure expose g.\n  parse arg sTOD\n  nTOD = c2d(sTOD) / 4096                   /* usecs since 1900 */\n  nTOD = nTOD - g.!EPOCH - g.!DAYLIGHT_ADJ  /* usecs since 1970 */\n  nSecs = trunc(nTOD/1000000)               /* secs since 1970 */\n  nMicrosecs =  trunc(nTOD - nSecs*1000000) /* usecs into the day */\n  sSecs = u_int32(nSecs)\n  sMicrosecs = u_int32(nMicrosecs)\n  sTimeStamp = sSecs || sMicrosecs\nreturn sTimeStamp\n\n\n/*\n* Return an unsigned short integer\n*/\nu_short: procedure\n  arg nNumber\nreturn reverse(d2c(nNumber,2))\n\n/*\n* Return an unsigned 32-bit integer\n*/\nu_int32: procedure\n  arg nNumber\nreturn reverse(d2c(nNumber,4))\n\n\n\nEpilog:\n  address ISPEXEC 'VPUT (TCPDUMPI TCPDUMPO) PROFILE'\n  call Free 'INPUT'\n  call Free 'OUTPUT' 'DISKW'\n  call Log 'First written',g.!FIRST_WRITE_TOD,g.!FIRST_WRITE_PKT\n  call Log 'Last written ',g.!LAST_WRITE_TOD,g.!LAST_WRITE_PKT\n  call SaySpan g.!FIRST_WRITE_TOD,g.!LAST_WRITE_TOD\n  say 'TCDP999I Done'\nreturn\n\nLog: procedure expose g.\n  parse arg sMsg,nTOD,nPacket\n  say 'TCPD013I' sMsg getTimeStamp(nTOD) '#'nPacket\nreturn\n\nSaySpan: procedure expose g.\n  parse arg nTODFirst,nTODLast\n  say 'TCPD014I Spanning     ',\n      format((nTODLast - nTODFirst) / 4096000000,19,6) 'seconds'\nreturn\n\n/*\n* Convert a TOD clock value into a human readable date and time\n* Note: this routine expects your machine's TOD clock to be UTC.\n*/\ngetTimeStamp: procedure expose g.\n  arg nTOD                                    /* TOD clock in decimal */\n  nTodDays = nTod / 4096 / 1000000 / 86400    /* days since 1900      */\n  nTodDays = nTodDays + g.!TZ/24              /* +/- timezone         */\n  nRexxDays = 693595 + trunc(nTodDays)        /* days since 0000      */\n  nFractionOfDay = nTodDays - trunc(nTodDays)\n  nSecsIntoDay = nFractionOfDay * 86400       /* secs since midnight  */\n  nHH = trunc(nSecsIntoDay / 3600)            /* hour since midnight  */\n  nSecsIntoHour = nSecsIntoDay - nHH * 3600\n  nMM = trunc(nSecsIntoHour / 60)             /* minute of the hour   */\n  nSS = nSecsIntoHour - nMM * 60              /* seconds              */\n\n  sYYYYMMDD = date('STANDARD', nRexxDays, 'BASE')\n\n  sTimeStamp =  translate('abcd/ef/gh',sYYYYMMDD,'abcdefgh'),\n                right(nHH,2,'0')':'  ||,\n                right(nMM,2,'0')':'  ||,\n                translate(format(nSS,2,6),'0',' ')\nreturn sTimeStamp        /* yyyy/mm/dd hh:mm:ss.nnnnnn */\n\n/*\nConvert a binary IP address into dotted decimal format\n*/\nc2i: procedure\n  parse arg c1 +1 c2 +1 c3 +1 c4 +1\nreturn c2d(c1)'.'c2d(c2)'.'c2d(c3)'.'c2d(c4)\n\nAlloc:\n  arg sDD sDSN sOptions\n  if sOptions = '' then sOptions = 'SHR'\n  call Free sDD\n  address TSO 'ALLOC DD('sDD') DSN('sDSN')' sOptions\nreturn\n\nFree:\n  arg sDD sOption\n  if sOption <> 'DISKW' then sOption = 'DISKR'\n  x = outtrap('o.')\n  address TSO\n  'EXECIO 0' sOption sDD '(FINIS'\n  'FREE DD('sDD')'\n  address\n  x = outtrap('OFF')\nreturn\n\ncloseFile: procedure expose g.\n  arg sDD sOption\n  if sOption <> 'DISKW' then sOption = 'DISKR'\n  x = outtrap('o.')\n  address TSO\n  'EXECIO 0' sOption sDD '(FINIS'\n  address\n  x = outtrap('OFF')\nreturn\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT628/FILE628.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT628", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}