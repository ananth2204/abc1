{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "SVM    ", "INMTNODE": "TEST", "INMTUID": "SVM    ", "INMFTIME": "20030806165944000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1058148, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 4000, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "SYS3.UTILITY.SOURCE.TEST", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1058148, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1058148, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SYS3.UTILITY.SOURCE.TEST": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 4000, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "030218", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\xc0\\x00\\x00\\x02'", "DS1LSTAR": "b'\\x00\\x10\\x0e'", "DS1TRBAL": "b'\\x0e\\xe0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x07`\\x00\\x04\\x9a\\xedp'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x07`\\x00\\x04\\x9a\\xedp'", "b'P\\xf3\\xa5\\xa0\\x00\\x00\\x05\\xc1\\x00\\x00\\x05\\xc5\\x00\\x0e\\x00K'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$OPENR": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x00\\x01\\x025?\\x01\\x03!\\x8f\\x087\\x03I\\x035\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2002-12-19T00:00:00", "modifydate": "2003-08-06T08:37:00", "lines": 841, "newlines": 821, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH    EXEC PGM=ASMA90,REGION=4M,\n//        PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST    <== hlq.MACLIB\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD  *\n*=====================================================================*\n     TITLE '$OPEN: Dynamic OPEN-READ-UPDATE-WRITE-CLOSE interface'\n*---------------------------------------------------------------------*\n* History of Changes (last comes first):\n*\n* ?????????? SVM OPENC - create dataset with the same attrs\n*                    as currently open (DCB must point to it)\n*                    use default space attr or pass in bufaddr(?)\n*                    then open as another DDName\n* 02/03/2003 SVM Fixed minor bugs\n* 01/24/2003 SVM Modified to return to A-31 caller\n* 01-07-2002 SVM Added Write for PDS member\n* 10-24-2001 SVM Created by old program\n*.....................................................................*\n* FUNCTION:\n*               1) Allocates & processes Dataset using DYNALLOC.\n*               2) Read/write DASD datasets with DSORG=PO or PS.\n*                  Use BSAM.\n*               3) PO and no MEMBER - reads PDS directory blocks.\n*                  Use BPAM, BSAM.\n*               4) Supports RECFM=F/FB/FBA/V/VB/VBA/U.\n*\n* PARM ($PARM DSECT):\n*               R1=Addr of word containing Addr of the following\n*               structure: > is input, < is output parm:\n*                 RC       DS F      <Return Code\n*                 DSNAME   DS CL44   >Dataset Name\n*                 MEMBER   DS CL8    >PDS Member Name/blanks\n*                 VOLUME   DS CL6    >Volume Name/blanks\n*                 RECLEN   DS H      <Current Record Length\n*                 DCBADDR  DS F     ><DCB Address\n*                 BUFADDR  DS F     ><Buffer Address\n*                 LENGTH   DS F      <Data Length in Buffer (bytes)\n*                 RECADDR  DS A      <Current Record Addr\n*\n* ENTRY POINTS:\n*\n*               $OPENx Allocates and Opens the Data Set:\n*               - If PDS and Member is blank - Open Directory.\n*               - If DCBADDR=0, allocate DCB, BUFFER and SVMPAR6.\n*               - If re-open other Member in PDS BLDL+POINT used.\n*               - If re-open same PS dataset, POINT used.\n*               - If Other Dsn/Vol, $CLOSE is forced before $OPEN.\n*               - If was WRITE, $CLOSE is forced before re-opening.\n*               - If I/O error, then buffer contains SYNAD message.\n*\n*               $OPEN, - Open the DataSet for Input.\n*               $OPENI - Open the DataSet for Input.\n*               $OPENU - Open the DataSet for Update.\n*               $OPENW - Open the DataSet for Output.\n*                        When used for PDS, create/replace the MEMBER\n*                      - If the member exists, Buffer will contain\n*                        its directory entry (TTRZ in col 12-15)\n*\n*               $CLOSE - Close the DataSet, Unallocate Data Set.\n*\n*               $READ  - Read Block of Data to Buffer,\n*                        or reset record addr/length to the next rec,\n*                        Set Data buffer Length = Block size.\n*                        If RECFM=FB,FBA,VB,VBA,VBS then\n*                        set/reset Current Record Length and Address.\n*                        If PO and no MEMBER, read Dir Block (BLDL).\n*\n*               $WRITE - UPDATE: Rewrite current block from Buffer.\n*                      - OUTPUT: Write block to dataset from Buffer.\n*                      - RECFM=FB: Caller program must maintain record\n*                        blocking. Block length if different than\n*                        BLKSIZE must be placed to LENGTH.\n*                      - RECFM=U: the current block length must\n*                        be placed to RECLEN.\n*\n* ATTRIBUTES:\n*               REENTRANT, AMODE=24.\n* !             Caller might have AMODE=31, but must\n* !             allocate SAVAREA and $PARM below 16M.\n* !             and use BASSM for call.\n*---------------------------------------------------------------------\n* Use in PL/I:\n*               DECLARE $OPEN ENTRY RETURNS(BIT(1))\n*               RETURNed value '1'B is equivalent to RC=0.\n*   example:    DO WHILE($READ(RAPMPTR));\n*                  Process record just read;\n*                  END; /*EOF or error encountered */\n*--------------------------------------------------------------------\n* Use in MVS:\n*               1. LINK.\n*               2. LOAD then CALL. (BASSM from above 16M)\n*               3. Call as a EP Link Edited into the same pgm.\n* Register Use:\n*               R12  - Base of program\n*               R13  - Base of WA\n*               R4   - DCB\n*               R5   - PARM\n*               R7   - SVMPAR6\n*               R8   - Copy of R1\n*\n* Extenals:     SVMALC6 - DYNALLOC inteface\n*--------------------------------------------------------------------\n         EJECT\n*--------------------------------------------------------------------\n$OPEN    CSECT\n         SPLEVEL SET=2                 REQUEST MVS/XA MACROS\n$OPEN    AMODE 24\n$OPEN    RMODE 24\n*--------------------------------------------------------------------\n         $PARM                         PARM data structure\n*PARM     DSECT\n*RC       DS   F                       <Return Code\n*DSNAME   DS   CL44                    >Dataset Name\n*MEMBER   DS   CL8                     >PDS Member Name (optional)\n*VOLUME   DS   CL6                    <>Volume Name     (optional)\n*RECLEN   DS   H                      < Current Record Length\n*TYPE     EQU   RECLEN            work  Open type (for OPEN only)\n*DCBADDR  DS   A                      <>DCB Address\n*OLDTYPE  EQU   DCBADDR               < After OPEN (saved TYPE)\n*BUFADDR  DS   A                      <>Buffer Address\n*LENGTH   DS   F                      < Data Length in Buffer (bytes)\n*RECADDR  DS   A                      < Current Record Addr\n*---------------------------------------------------------------------\n$OPEN    CSECT\n*\n*        List of entry points:\n*\n         ENTRY $CLOSE,$READ,$WRITE,$OPENI,$OPENU,$OPENW\n$OPENI   SAVE (14,12)                  Save registers\n         LA    R2,0                    Set Switch offset\n         LA    R3,0                    Set Base Offset\n         B     92(R15)\n$OPENU   SAVE (14,12)                  Save registers\n         LA    R2,20                   Set Switch offset\n         LA    R3,16                   Set Base Offset\n         B     76(R15)\n$OPENW   SAVE (14,12)                  Save registers\n         LA    R2,16                   Set Switch offset\n         LA    R3,32                   Set Base Offset\n         B     60(R15)\n$READ    SAVE  (14,12)                 Save registers\n         LA    R2,4                    Set Switch offset\n         LA    R3,48                   Set Base Offset\n         B     44(R15)\n$WRITE   SAVE  (14,12)                 Save registers\n         LA    R2,8                    Set Switch offset\n         LA    R3,64                   Set Base Offset\n         B     28(R15)\n$CLOSE   SAVE  (14,12)                 Save registers\n         LA    R2,12                   Set Switch offset\n         LA    R3,80                   Set Base Offset\n*======================================================================\n* Common Continuation:                 Prolog Section\n         SR    R15,R3                  Addr $OPEN\n         LR    R12,R15\n         USING $OPEN,R12               Set the Base for $OPEN\n         L     R5,0(R1)                R5=Addr of Paramater\n         LA    R5,0(R5)                Clear leftmost byte\n         USING $PARM,R5                Set the Base for $PARM\n         LR    R8,R1                   Save R1 until EXIT\n* Obtain WA storage:\n         GETMAIN RC,LV=LENGWA,SP=1     Get RAM for WA\n         LTR   R15,R15                 If OK\n         BNZ   E#NOMAIN                N\n         ST    R13,4(R1)               Store old in new\n         ST    R1,8(R13)               Store new in old\n         LR    R13,R1                  Switch to new SaveArea\n         USING WA,R13                  Address WorkArea\n*---------------------------------------------------------------------\n* Switch to the requested function:\n         LA    1,SWITCH\n         LA    1,0(2,1)\n         BR    1\nSWITCH   B     OPENI\n         B     READ\n         B     WRITE\n         B     CLOSE\n         B     OPENW\n         B     OPENU\n*---------------------------------------------------------------------*\n*        $OPEN: Check Parameters:\n*---------------------------------------------------------------------*\nOPENU    MVI   TYPE,UPDATE             Set Update\n         B     OPEN\nOPENW    MVI   TYPE,OUTPUT             Set Output (invalid for PO)\n         B     OPEN\nOPENI    MVI   TYPE,INPUT              Set Input\n*        B     OPEN\nOPEN     XC    RC(4),RC                Clear RC\n*\n         CLI   DSNAME,C' '             DSNAME not blank?\n         BE    E#NODSN                 Error: No DSNAME\n         SR    R4,R4\n         ICM   R4,7,DCBADDR+1          DCB Address exists?\n         LTR   R4,R4\n         BNZ   OLDDCB                  Y - Check if can re-use it\n         B     ALLOCATE                N - Allocate Data Set\n*\nREALLOC  BAL   R10,CLOSER\n         B     ALLOCATE\n*---------------------------------------------------------------------*\n*    R4->DCB: Check if it can be just re-opened\n*---------------------------------------------------------------------*\n         USING IHADCB,R4               DCB mapping\n         USING SVMPAR6,R7              Set Base for SVMPAR6\nOLDDCB   L     R7,DCBEXLST\n         SLL   R7,8                    Addr of old SVMPAR6\n         SRL   R7,8                    Addr of old SVMPAR6\n* --- mistery, but LA R7,0(R7) leaves 1st byte as X'10' ---?????\n         CLC   DSNAME(44),TDSN         Same DSNAME ?\n         BNE   REALLOC                 Y\n*\n         CLC   VOLUME(6),TVOL          Same VOLUME ?\n         BNE   REALLOC                 N - Close and Reallocate\n*\n         CLI   OLDTYPE,OUTPUT          Was OUTPUT?\n         BE    REALLOC                 Y - Close and Reallocate\n*\n         CLI   TYPE,OUTPUT             Now Output ?\n         BE    REALLOC                 Y - Close and Reallocate\n*\n         CLI   MEMBER,C' '             IF MEMBER=blank\n         BE    CKOLDMEM                Y - Check old member\n         CLI   STOWLST,C' '            N - Old member blank?\n         BE    REALLOC                     Y - re-allocate\n         B     CHGMEM                      N - switch member\n*\nCKOLDMEM CLI   STOWLST,C' '            Y - Old member blank?\n         BE    REOPENPS                    Y - Re-open PS dataset\n         B     REALLOC                     N - re-allocate\n*----------------------------------------------------------------------\n* Switch Member in the same PDS for Input/Update:\n*----------------------------------------------------------------------\nCHGMEM   L     R3,BUFADDR              Prepare\n         LA    R0,1                    Parameter\n         STH   R0,0(R3)                for BLDL\n         LA    R0,58                   in the 1-st word\n         STH   R0,2(R3)                of the Buffer\n         MVC   4(8,R3),MEMBER\n         BLDL  (4),(3)                 Get Directory elem into Buffer\n         LTR   R15,R15\n         BNZ   E#NOMEMB\n         POINT (4),12(3)               Point DCB to the Member\n         LA    R0,60                   Set data length=60\n         ST    R0,LENGTH               Done\n         B     NORMEXIT\n*----------------------------------------------------------------------\n* Re-Open the same PS dataset:\n*----------------------------------------------------------------------\nREOPENPS L     R0,TTRZ                 TTRZ\n         LTR   R0,R0\n         BZ    E#DCBOPN                Error: No TTRZ in DCB\n         POINT (4),TTRZ                Position to file top\n         XC    LENGTH(4),LENGTH        Clear Length\n         XC    RECLEN(2),RECLEN        Clear RECLEN & TYPE in $PARM\n         B     NORMEXIT                Done\n*=====================================================================*\n*        Allocate the New Data Set\n*---------------------------------------------------------------------*\nALLOCATE DS    0H\n         LA    R0,TLEN                 Length of SVMPAR6\n         A     R0,SP1\n         GETMAIN R,LV=(0),LOC=BELOW    Get RAM for SVMPAR6\n         LTR   R15,R15                 If OK\n         BNZ   E#NOMAI2                N\n*- Fill parameter for allocate:\n         LR    R7,R1                   Addr of SVMPAR6\n         XC    SVMPAR6(TLEN),SVMPAR6   Clear SVMPAR6\n         MVC   TDSN(44),DSNAME         Move Dsname to SVMPAR6\n         MVC   TVOL(6),VOLUME          Move Volume to SVMPAR6\n         MVC   TDDN(8),=CL8' '         Clear TDDN  in SVMPAR6\n*- Call Dynalloc Interface (R1->SVMPAR6):\n*\n         CALL  SVMALC6                 DYNALLOC interface\n*\n         LTR   R15,R15\n         BNZ   E#NODD                  Dynalloc failed\n*- Return VOLUME if blank:\n         CLC   VOLUME,=C'      '\n         BNE   CHKORG\n         MVC   VOLUME(6),TVOL\n*\nCHKORG   DS    0H\n         TM    TDSORG,DCBDSGPO         DSORG=PO ?\n         BNO   CHKPS                   N - Check if PS\n         CLI   TYPE,OUTPUT               PO & output ?\n         BNE   MKDCB                     N - proceed with make DCB\n         CLI   MEMBER,C' '                 PO & output & no member ?\n         BE    E#DSORG                     Y - Error\n         B     MKDCB                       N - proceed\n*\nCHKPS    TM    TDSORG,DCBDSGPS         DSORG=PS ?\n         BO    IFMEMB                  Y-Check Member Name\n         TM    TDSORG,DCBDSGDA         DSORG=DA ?\n         BNO   E#DSORG                 Error: DSORG not supported\nIFMEMB   CLI   MEMBER,C' '\n         BNE   E#PO                    Error: MEMBER for DSORG=PS/DA\n*\n*=====================================================================*\n*        Create new DCB & DECB,\n*        OPEN DCB,\n*        R4-DCB, R5-$PARM, R7-SVMPAR6.\n*---------------------------------------------------------------------*\nMKDCB    DS    0H\n         LA    R0,LENDCBS              DCB + DECB + STOW\n         A     R0,SP1\n         GETMAIN R,LV=(0) SP=1         Get RAM\n         LR    R4,R1                   R4=Addr of DCB\n         ST    R4,DCBADDR              Store DCBADDR in $PARM\n         XC    0(LENDCBS,R4),0(R4)     Clear DCB storage\n         MVC   DCB(DCBLNGPO),DCBCPO    Init DCB as PO\n         ST    R7,DCBEXLST             Save Addr of SVMPAR6 in DCB\n*\n* Fill DCB & DECB1:\n*\n         TM    TDSORG,DCBDSGPO         DSORG=PO ?\n         BO    CHKMEMB                 Y\n         MVI   DCBDSORG,DCBDSGPS       N - Re-set DSORG to PS\n         B     INTDECB\n*\nCHKMEMB  CLI   MEMBER,C' '\n         BNE   INTDECB                 MEMBER is present\n*\n* No MEMBER for PO: Set to Read Directory:\n*\n         MVI   DCBRECFM,DCBRECF        RECFM=F\n         MVC   DCBBLKSI(2),=H'256'     BLKSIZE=256\n         MVC   DCBLRECL(2),=H'256'     LRECL=256\n*\n* Fill DECB:\n*\nINTDECB  MVC   DECB1(DECB1LN),DECB1C   Init DECB1 (next to DCB)\n         STCM  R4,7,DECBDCBA+1         Store Addr of DCB->DECB\n*                                      (except 0-byte with type)\n         MVC   DCBDDNAM(8),TDDN        Copy allocated DDNAME to DCB\n*\n         MVC   OLDTYPE(1),TYPE         Set type in $PARM.DCBADDR\n         XC    RECLEN(2),RECLEN        Clear RECLEN & TYPE in $PARM\n*\n* OPEN the DCB:\n*\n*        WTO   '$OPEN: Now opening DCB...',ROUTCDE=11\nNULL     LA    R1,DCBADDR              PARM for OPEN\n*-------------------\n         SVC   19                      OPEN DCB\n*-------------------\n*        WTO   '$OPEN: Open DCB complete...',ROUTCDE=11\n         TM    DCBOFLG,DCBOFOPN        Is DCB opened ?\n         BNO   OPENFAIL\n         XC    LENGTH(4),LENGTH        Clear LENGTH\n         XC    TTRZ(4),TTRZ            Clear TTRZ in DCB\n*----------------------------------------------------------------------\n* Get RAM for Buffer:\n*----------------------------------------------------------------------\nGETBUF   LH    R0,DCBBLKSI             Get DCBBLKSI\n         XC    BUFADDR(4),BUFADDR      Clear BUFADDR\n         GETMAIN RC,LV=(0),SP=1        Get RAM for Buffer\n         LTR   R15,R15\n         BNZ   OPENFAIL                No RAM available\n         ST    R1,BUFADDR\n         XC    LENGTH(4),LENGTH        Clear LENGTH\n*----------------------------------------------------------------------\n* If write to member, do not check if the member exists,\n* Else If MEMBER is present, Find the Member (R1=Addr of Buffer):\n*----------------------------------------------------------------------\n* Store MEMBER name to STOWLST:\nSETSTOW  MVC   STOWLST(8),MEMBER       Set STOW list\n         XC    STOWLST+8(4),STOWLST+8  (used for OUTPUT only)\n         CLI   MEMBER,C' '\n         BE    NOTEPS\n         CLI   OLDTYPE,OUTPUT          If OUTPUT, do not read Dir\n         BE    EXIT\n* If Read/Update, Then Read Dir entry to Buffer and set TTRZ:\n         LA    R0,1\n         STH   R0,0(R1)\n         LA    R0,58\n         STH   R0,2(R1)\n         MVC   4(8,R1),MEMBER\n         LR    R3,R1                   Point R3->Buffer\n         BLDL  (4),(3)                 Read Dir Element to Buffer\n         LTR   R15,R15\n         BNZ   E#NOMEMB\n         POINT (4),12(3)\n         L     R0,12(R3)\n         ST    R0,TTRZ                 Save TTRZ in DCB\n         B     EXIT                    Exit\n*======================================================================\n* PS-dataset: Store the top TTRZ:\n*----------------------------------------------------------------------\nNOTEPS   LA    R1,1                    TTRZ top of PS-dataset\n         ST    R1,TTRZ                 Store TTRZ in DCB\n         B     EXIT\n*======================================================================\n* OPEN FAILED:\n*----------------------------------------------------------------------\nOPENFAIL LR    R1,R7\n*\n         CALL  SVMDEL6                 Unallocate Data Set\n*\n         BAL   R14,FREEPAR             Remove SVMPAR6\n         BAL   R14,FREEBUF             Remove Buffer (if exists)\n         BAL   R14,FREEDCB             Remove DCB (if exists)\n         B     E#NOOP                  Error: OPEN FAILED\n*======================================================================\n* Remove just SVMPAR6 when Bad parameter Error:\n*----------------------------------------------------------------------\nOPRETU   LR    R1,R7                   Addr of SVMPAR6\n*\n         CALL  SVMDEL6                 Unallocate Data Set\n*\n         BAL   R14,FREEPAR             Delete SVMPAR6\n         B     EXIT\n*======================================================================\nNORMEXIT DS    0H                      WTO 'NORMEXIT',ROUTCDE=11\n         SR   R15,R15\n         ST   R15,RC\n         B    EXIT\n*======================================================================\n* Common Exit routine:\n*----------------------------------------------------------------------\nEXIT     DS    0H\n         LR    R1,R13                  Addr of WA\n         L     R13,4(R13)              Restore addr of old Savarea\n         FREEMAIN R,LV=LENGWA,A=(1),SP=1 Free Workarea\n*- WA    removed\nEXIT1    DS    0H                      Exit after \"No RAM for WA\"\n         L     R15,RC\n*\n* If two parms, return BIT(1)=(R15=0) for PL/I\n*\n         TM    0(R8),X'80'             Check VL BIT\n         BO    END                     Not 0 - One parm\n         L     R8,4(R8)                2-nd parm\n         L     R8,0(R8)                Addr of bit(8) string\n         LTR   R15,R15\n         BZ    TRUE\nFALSE    MVI   0(R8),0                 RETURN FALSE\n         B     END\nTRUE     MVI   0(R8),X'80'             RETURN TRUE\nEND      DS    0H\n*  Modified to return to AMODE-31 caller:\n*        RETURN (14,12),RC=(15)\n         L     R14,R12(0,R13)\n         LM    R0,R12,20(R13)\n         BSM   0,R14\n*\n*======================================================================\n*  Free SVMPAR6 area:\nFREEPAR  DS    0H\n*        WTO   '$OPEN: Executing FREEPAR...',ROUTCDE=11\n         LR    R1,R7                   Take from Base register\n         LTR   R1,R1\n         BZ    NOPRM6\n         LA    R0,TLEN\n         A     R0,SP1\n         FREEMAIN R,LV=(0),A=(1) SP=1  Free SVMPAR6 area\nNOPRM6   BR    R14\n*======================================================================\n*  Free DCB area:\nFREEDCB  DS    0H\n*        WTO   '$OPEN: Executing FREEDCB...',ROUTCDE=11\n         SR    R1,R1\n         ICM   R1,7,DCBADDR+1          Take from $PARM\n         LTR   R1,R1\n         BZ    NODCB\n         LA    R0,LENDCBS\n         A     R0,SP1\n         FREEMAIN R,LV=(0),A=(1) SP=1  Free DCB & DECB area\n         XC    DCBADDR(4),DCBADDR      Clear DCBADDR in $PARM\nNODCB    BR    R14\n*======================================================================\n*  Free Buffer area: DCB must exist\nFREEBUF  DS    0H\n*        WTO   '$OPEN: Executing FREEBUF...',ROUTCDE=11\n         L     R1,BUFADDR              Take from $PARM\n         LTR   1,1\n         BZ    NOBUF\n         LH    R0,DCBBLKSI\n         A     R0,SP1\n         FREEMAIN R,LV=(0),A=(1)       Free Buffer area in SP=1\n         XC    BUFADDR(4),BUFADDR      Clear BUFADDR\n         XC    LENGTH(4),LENGTH        Clear LENGTH\n         XC    RECADDR(4),RECADDR      Clear RECADDR\n         XC    RECLEN(2),RECLEN        Clear RECLEN - save Type!\nNOBUF    BR    R14\n*=====================================================================*\n*        SET RETURN CODES\n*---------------------------------------------------------------------*\n*\nE#NODD   MVI  RC+3,4                   Dynalloc failed\n         B    EXIT\nE#NOOP   MVI  RC+3,16                  OPEN error or no RAM for Buffer\n         B    EXIT\nE#NODSN  MVI  RC+3,24                  DSNAME invalid\n         B    EXIT\nE#NOMEMB MVI  RC+3,28                  MEMBER not found\n         B    EXIT      Do not close - other member might be requested\n*32 - End Of File, see $READ\n*\nE#DSORG  MVI  RC+3,36                  DSORG not supported\n         B    OPRETU\n*40 - I/O error, see $READ\n*\nE#PO     MVI  RC+3,44                  MEMBER present for PS\n         B    OPRETU\nE#NORADR MVI  RC+3,52                  READ, but Addr of DCB=0\n         B     RETRD\nE#NOROPN MVI  RC+3,56                  READ, but DCB is not Opened\n         B     RETRD\nE#NOMAIN MVI  RC+3,60                  Cannot obtain RAM (WA)\n         B     EXIT1\nE#NOMAI2 MVI  RC+3,60                  Cannot obtain RAM (SVMPAR6)\n         B     EXIT\nE#NOWADR MVI  RC+3,64                  WRITE, but Addr(DCB) or Buffer=0\n         B     RETWR\nE#NOWOPN MVI  RC+3,68                  WRITE, but DCB is not Opened\n         B     RETWR\nE#DCBOPN MVI  RC+3,72                  Re-Open PS, but no TTRZ avail.\n         B    EXIT\nE#STWER  MVI  RC+3,76                  STOW failed for adding member\n         B    CLOSE1\n*=====================================================================*\n*        CLOSE DATASET, release SVMPAR6, DCB, BUFFER\n*        Come here from $CLOSE\n*---------------------------------------------------------------------*\nCLOSE    LA    R10,EXIT                Addr of Exit: EXIT or\n*                                      to OPEN (when DSNAME change)\n*        Come here from REALLOC:\n*                                      to OPEN (when DSNAME change)\nCLOSER   XC    RC(4),RC\n         SR    R4,R4\n         ICM   R4,7,DCBADDR+1\n         LTR   R4,R4                   DCB present ?\n         BZ    RETCL                   DCB not present\n* If Previous was PDS Member output - store member:\n         TM    DCBDSORG,DCBDSGPO       DSORG=PO ?\n         BNO   CLOSE1                  N\n         CLI   OLDTYPE,OUTPUT          PO & Was Output?\n         BNE   CLOSE1                  N\n*        WTO   '$CLOSE: Issuing STOW...',ROUTCDE=11\n         STOW  (4),STOWLST,R           Add/Replace the member\n*\nCLOSE1   BAL   R14,FREEBUF\n         TM    DCBOFLG,DCBOFOPN        Is DCB opened ?\n         BNO   UNALLOC                 DCB is not Opened\n*\n         CLOSE ((4))                   Close DCB\n*\n* Deallocate DDNAME (SVMPAR6.DDN):\n*\nUNALLOC  L     R7,DCBEXLST\n         SLL   R7,8\n         SRL   R7,8                    Clear 1st byte\n         LR    R1,R7                   Addr of SVMPAR6\n*\n         CALL  SVMDEL6                 Unallocate Data Set\n*\n         BAL   R14,FREEPAR\n*\n         BAL   R14,FREEDCB\n*\nRETCL    L     R15,RC\n         BR    R10                     Exit (EXIT or OPEN)\n*=====================================================================*\n*        $READ: Read Data block, locate Record:\n*---------------------------------------------------------------------*\n*\n* Check Parameters:\n*\nREAD     XC    RC(4),RC\n         SR    R4,R4\n         ICM   R4,7,DCBADDR+1\n         LTR   R4,R4\n         BZ    E#NORADR                Error: No DCBADDR\n         L     R2,BUFADDR\n         LTR   R2,R2\n         BZ    E#NORADR                Error: No BUFADDR\n         TM    DCBOFLG,DCBOFOPN        Is DCB opened ?\n         BNO   E#NOROPN                Error: DCB not Opened\n         L     R7,DCBEXLST\n         SLL   R7,8\n         SRL   R7,8\n*\n* R2=Addr of Buffer: Check for block of Data\n*\n         LH    REG,RECLEN              R3\n         LTR   REG,REG                 R3\n         BZ    RDNXTBLK                Read 1-st Block\n*                                      (In OPEN RECLEN was cleared)\n         TM    DCBRECFM,BLOCKED\n         BNO   RDNXTBLK                Not Blocked - Read Block\n*\n* Blocked Format:\n*\n*        WTO   'Blocked format',ROUTCDE=11\n         TM    DCBRECFM,UNDEF\n         BO    RDNXTBLK                Not Blocked - Read Block\n         TM    DCBRECFM,FIXED\n         BNO   VARY1                   Not Fixed - Variable\n*\n* Fixed Format:\n*\n         LH    REG,DCBLRECL\n         STH   REG,RECLEN\nMOVETEK  A     REG,RECADDR\n         ST    REG,RECADDR             Next Record\n         S     REG,BUFADDR\n         C     REG,LENGTH\n         BNL   RDNXTBLK                End of Block reached\n         B     RETRD                   Record located\n*\n* VB - Format:\n*\nVARY1    LH    REG,RECLEN\n         A     REG,RECADDR             Addr of Index of Next Record\n         ST    REG,RECADDR             Save temporarily\n         S     REG,BUFADDR             Offset\n         C     REG,LENGTH\n         BNL   RDNXTBLK                End of Block reached\n         L     REG,RECADDR             Restore Addr of Index of Record\n*\n* Set Length and position of V-record REG->Record Index\n*\nGETVREC  MVC   RECLEN(2),0(REG)        Not aligned\n         LA    REG,4(REG)              Record Text Addr\n         ST    REG,RECADDR             - Stored\n         LH    REG,DCBLRECL\n         LTR   REG,REG                 If DCBLRECL not =0\n         BNZ   GETV1                   Skip to compare to DCBLRECL\n         LH    REG,RECLEN              Rec length with Index\n         C     REG,LENGTH              Compare to Length of Data\n         BNH   GETVREC1                No RDW error\n         B     GETVERR\nGETV1    LH    REG,RECLEN              Rec length with Index\n         CH    REG,DCBLRECL\n         BNH   GETVREC1                No RDW error\n*\nGETVERR  MVI   RC+3,76                 Error length of V-record\n         NI    RECLEN,0                leave not more than 255\n         LH    REG,RECLEN              Rec length with Index\nGETVREC1 SH    REG,=H'4'               Rec length without Index\n         STH   REG,RECLEN              - Stored\n         B     RETRD                   Exit\n*\n* Read Block of Data:\n*\nRDNXTBLK READ  DECB1,SF,DCB,(R2),'S',MF=E\n         CHECK DECB1\nGETLAST  LH    R3,DCBBLKSI             DCBBLKSI\n         L     R6,DCBIOBA              DCBIOBA\n         LH    R6,22(R6)               Number of Free bytes\n         SR    R3,R6                   Number of Occupied bytes\n         ST    R3,LENGTH               ->LENGTH\n*\n* Locate (1-st) Record:\n*\n         TM    DCBRECFM,UNDEF\n         BO    UNBLOCKD                U - Format\n         TM    DCBRECFM,VARYING\n         BO    VARY2                   V - Format\n*\n* Fixed Format:\n*\n         TM    DCBRECFM,BLOCKED\n         BO    BLOCKED1\n*\n* Not Blocked:\n*\nUNBLOCKD MVC   RECADDR(4),BUFADDR      Addr = BUFADDR\n         L     REG,LENGTH\n         STH   REG,RECLEN\n*        WTO   'UNBLOCKD',ROUTCDE=11\n         B     RETRD                   Exit\n*\n* Blocked Format:\n*\nBLOCKED1 LH    REG,DCBLRECL\n         STH   REG,RECLEN              Length = LRECL\n         L     REG,BUFADDR\n         ST    REG,RECADDR             Addr = BUFADDR\n*        WTO   'BLOCKED1',ROUTCDE=11\n         B     RETRD                   Exit\n*\n* V - Format:\n*\nVARY2    L     REG,BUFADDR\n         LA    REG,4(REG)              Skip Block Index\n         B     GETVREC\n* Exit from $READ:\nRETRD    B     EXIT\n*----------------------------------------------------------------------\nEODAD    MVI   RC+3,32                 ** End Of File **\n         B     RETRD\n*\nSYNAD    DS    0H\n         SYNADAF ACSMETH=BPAM\n         LH    R3,DCBBLKSI             DCBBLKSI\n         LA    R0,77                   Text length-1\n         CR    R0,R3\n         BL    SYNORM\n         SR    R0,R3\n         LA    R1,50(R0,R1)            Start address\n         LA    R0,1\n         SR    R3,R0                   Length-1\n         LA    R6,1(R3)                Length\n         ST    R6,LENGTH               Store to LENGTH\n         STH   R6,RECLEN\n         EX    R3,SYMVC\n         B     SYEND\nSYMVC    MVC   0(1,R2),0(R1)\nSYNORM   MVC   0(78,R2),50(R1)\n         LA    R6,78                   Text Length\n         ST    R6,LENGTH               Store to LENGTH\n         STH   R6,RECLEN\nSYEND    MVI   RC+3,40                 ** I/O Error **\n         MVC   RECADDR(4),BUFADDR\n         SYNADRLS\n         B     RETRD\nFIXED    EQU   DCBRECF                 X'80'\nVARYING  EQU   DCBRECV                 X'40'\nBLOCKED  EQU   DCBRECBR                X'10'\nUNDEF    EQU   DCBRECU                 X'C0'\nREG      EQU   3                       Work Register for Read\nINPUT    EQU   X'80'                   Open mode\nUPDATE   EQU   X'84'                   Open mode\nOUTPUT   EQU   X'8F'                   Open mode\n*=====================================================================*\n*        $WRITE: Write Block of Data from Buffer\n*---------------------------------------------------------------------*\n*\n* Check Parameters:\n*\nWRITE    XC    RC(4),RC\n         SR    R4,R4\n         ICM   R4,7,DCBADDR+1\n         LTR   R4,R4\n         BZ    E#NOWADR                Error: No DCBADDR\n         L     R2,BUFADDR\n         LTR   R2,R2\n         BZ    E#NOWADR                Error: No BUFADDR\n         TM    DCBOFLG,DCBOFOPN        Is DCB opened ?\n         BNO   E#NOWOPN                Error: DCB not Opened\n*\n* R2=Addr of Buffer, Execute Write:\n*\n         TM    DCBRECFM,UNDEF          Undef records ?\n         BNO   WNEXT                   N - just write\n* Set data length for U-records:\n*        WTO   '$WRITE: Writing U- block...',ROUTCDE=11\n         LH    R3,RECLEN\n         WRITE DECB1,SF,DCB,(R2),(R3),MF=E Write/Update block\n         CHECK DECB1\n         B     RETWR\n*\nWNEXT    TM    DCBRECFM,BLOCKED        Blocked records ?\n         BNO   WNORM                   N - just write\n         LH    R3,DCBBLKSI             Save DCBBLKSI\n         C     R3,LENGTH               Length = Blocksize ?\n         BE    WNORM                   Y - (re)write regular block\nWLAST    DS    0H                      N - (re)write the last/U block\n         MVC   DCBBLKSI(2),LENGTH+2    Copy Length to DCBBLKSI\n*        WTO   '$WRITE: Writing short block...',ROUTCDE=11\n*\nWNORM    DS    0H\n         WRITE DECB1,SF,DCB,(R2),MF=E Write/Update block\n         CHECK DECB1\n         STH   R3,DCBBLKSI              Restore DCBBLKSI\n* Exit from $WRITE:\nRETWR    DS    0H\n         B     EXIT\n*=====================================================================*\n*        CONSTANTS for OPEN/CLOSE\n*---------------------------------------------------------------------*\n         DS    0F\nSP1      DC    XL4'01000000'           Indicate SP=1\n*\n*        Descriptive Macros:\n*\n         READ DECB1C,SF,DCBCPO,,MF=L     BLOK DECB1\nDECB1LN  EQU  *-DECB1C\nDCBCPO   DCB  MACRF=(R,W),DSORG=PO,EODAD=EODAD,SYNAD=SYNAD\n*DCBCPS   DCB  MACRF=(RP,WP),DSORG=PS,EODAD=EODAD,SYNAD=SYNAD\n*---------------------------------------------------------------------\n*        DSECTS:\n*---------------------------------------------------------------------\n         DCBD DSORG=PO,DEVD=DA\nDCBDECB  EQU   IHADCB\nDCB      EQU   IHADCB\n         ORG   IHADCB+DCBLNGPO+4       (DCB+92)\nTTRZ     DS    A\n*\nLENDCB   EQU   *-DCB                   96\nDECB1    DS    0H\nDECBECB  DS    A\nDECBTYPE DS    H\nDECBLEN  DS    H\nDECBDCBA DS    A\nDECBAREA DS    A\nDECBINDA DS    A\n*\nSTOWLST  DS    CL8,AL4                 STOW area (MEMBER,TTR,C)\nLENDCBS  EQU   *-DCB                   Total data length\n*\nSVMPAR6  SVMPAR6 DSECT=YES             Parm for SVMALC6/SVMDEL6\nTLEN     EQU   *-SVMPAR6\n*\nWA       DSECT\nS        DS    18F\nTYPE     DS    X\n         DS    0D\nLENGWA   EQU   *-WA\n*\n$OPEN    CSECT\n         YREGS\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,\n//        PARM='CAL,LIST,MAP,RENT,RMOD=24,AMOD=24',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LINKLIB.TEST   <== IRXFLOC lib\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST      <== hlq.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//         DD *\n     ALIAS $OPENU\n     ALIAS $OPENW\n     ALIAS $OPENI\n     ALIAS $CLOSE\n     ALIAS $READ\n     ALIAS $WRITE\n     NAME  $OPEN(R)\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "A31ESD": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x01\\x03\\x10\\x0f\\x01\\x03!\\x8f\\x08A\\x05t\\x05U\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2003-04-10T00:00:00", "modifydate": "2003-08-06T08:41:00", "lines": 1396, "newlines": 1365, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='OBJECT,NODECK,NOXREF,BATCH,RENT'\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST   <== hlq.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n         TITLE 'A31ESD - Name Area Initialization in A31TABS'\n*---------------------------------------------------------------------\n* 04/22/03 SVM Added fields to PTAB, changed PDS entry processing\n* 04/02/03 SVM Re-created from BV.A31ESD for amode=31\n*\n* Reads ESD, RLD and SYM records from load module,\n* Crates and inits tables: CTAB, DTAB and NTAB inside PTAB area\n* All P#AREA from old PTAB are considered empty.\n*\n* Use from PL/I:\n* CALL A31ESD(D#,PTAB); OPTIONS(ASM INTER RETCODE)\n* In:   R1->list of 2 addresses (C VL),\n*       A1=Addr of parm (D#) block for $OPEN,\n*       A2=Addr of PTAB area to be filled with the program data.\n*       (see IRXF@PGM for example of use)\n*\n* Out:   R15=0-normal\n*            4-No SYM, NTAB contains entries for CSECT and EP only\n*            8-OVLY program - not supported\n*           12-No ESD, CTAB contains dummy entry for the program,\n*              NTAB contains entry for EP at offset 0.\n*           16-Error when OPEN load library\n*           20-RAM shortage\n*           24-Cannot LOAD EP=$OPENI\n*\n* Reentrant, LOADs and CALLs $OPEN to access load library.\n*---------------------------------------------------------------------\n         YREGS\nA31ESD   BEGIN\n$WRK     WORK  LV=$WRKLEN,LOC=BELOW\n         B     START\n*\nEXIT     L     R3,A$OPEN\n         LTR   R3,R3\n         BZ    FINX\n         DELETE EP=$OPENI\n         LTR   R15,R15\n         BZ    FINX\n**       WTO   'A31ESD: DELETE EP=$OPENI failed',ROUTCDE=11\nFINX     L     R15,RC\n         FIN\n*\nSTART    XC    A$OPEN,A$OPEN\n         XC    RC,RC\n         MVC   PARMLIST(8),0(R1)       Copy Parameter list\n         OI    PARMLIST,VL             Set VL for $OPEN\n**       LA    R2,PARMLIST             Switch to the copy\n*---------------------------------------------------------------------*\n*-                                                                    *\n*---------------------------------------------------------------------*\n**       LOAD  EP=A3CVT\n**       LR    3,0\n**       IC    3,C#FLAGS(3)\n**       STC   3,W#DEBUG\n*        WTO   'A31ESD: Calling $OPENI...',ROUTCDE=11\n         LOAD  EP=$OPENI,ERRET=LOADERR\n         ST    R0,A$OPEN\n         LR    R1,R0\n         LA    R0,$CLSOFFS(R1)\n         ST    R0,A$CLOSE\n         LA    R0,$REDOFFS(R1)\n         ST    R0,A$READ\n*\n         MVI   RC+3,NOTOPEN\n         LA    R1,PARMLIST             Restore R1\n         L     R15,A$OPEN\n         BASSM R14,R15                 ***> CALL $OPEN\n         LTR   R15,R15\n         BZ    GOODOPEN                $OPEN good\n*- OPEN failed:\n*        WTO   'A31ESD: OPEN FAILED',ROUTCDE=11  *** DEBUG ***\n         MVI   RC+3,NOTOPEN\n         B     EXIT\n*- LOAD failed:\nLOADERR  DS    0H\n         WTO   'LOAD EP=$OPEN failed',ROUTCDE=11\n         MVI   RC+3,NO$OPEN\n         B     EXIT\n*- OPEN GOOD: Init PTAB, if empty (except P#NEXT & P#ADDR):\nGOODOPEN XC    SYMFOUND(4),SYMFOUND    Drop Flag of SYM presence\n         MVI   RC+3,NOESD\n         L     R11,PTABADDR            R11=Addr of PTAB\n         USING PTAB,R11                Tell Assembler\n         L     R10,D##ADDR             R10=Addr of D#\n         USING D#,R10                  Tell Assembler\n         L     R9,D#BUF                R9->Input buffer\n         USING PDS24,R9\n*\n         MVC   OVERFL(4),=XL4'00FFFFFF' Mask \"No overlay\"\n         TM    PDS2ATR1,PDS2OVLY       Ovly ?\n         BNO   NOOVL                   No\n         MVI   OVERFL,X'0F'            Mask \"Overlay\"\nNOOVL    DS    0H\n         MVC   P#SIZE+1(3),PDS2STOR    ==> P#SIZE=Program size\n         MVC   P#ENTRY+1(3),PDS2EPA    ==> P#ENTRY=Addr of Entry\n         MVC   P#NAME(8),D#MEM         ==> P#NAME=Program Name\n         MVC   P#DSN,D#DSN             ==> P#DSN=Load lib name\n         MVC   P#VOL,D#VOL             ==> P#VOL=Volser for lib\n         MVC   P#ATR1(2),PDS2ATR1      ==> P#ATR1 and P#ATR2\n         MVC   P#FLAG(1),PDS2FTB2      ==> P#FLAG = PDS2FTB2\n         NI    P#FLAG,X'7F'            shut bit 0 (alias indicatior)\n         MVC   P#ANAME(8),#BLANKS      clear\n         XC    P#AENTRY(4),P#AENTRY    clear\n*- Init service fields in PTAB:\n         LA    3,P#DATA\n         ST    3,P#AFREE               ==> P#AFREE-> Start of OBL.data\n         SR    3,3\n         ST    3,P#CTAB                ==> P#CTAB\n*---------------------------------------------------------------------*\n*-- Fields built by BLDL (ref IHAPDS + 4): mapping & processing:\n*    basic section: 33 bytes                      present if:\n*    SCTR section :  8 bytes (not supported here) PDS2ATR1=X'04'\n*    Alias section: 11 bytes (alias only)         PDS2INDC=X'80'\n*    SSI section  :  4 bytes (aligned to H)       PDS2FTB1=X'10'\n*    APF section  :  2 bytes                      PDS2FTB1=X'08'\n*    Large prog   : 19 bytes >16M, not supported  PDS2FTB1=X'40'\n*---------------------------------------------------------------------*\n*INDC     EQU   17                      Indicators PDS2INDC\n*PDS2ATR  EQU   26                      Flags  in PDS\n*SIZE     EQU   28                      Pgm size offset in PDS\n*EPADDR   EQU   33                      Rel EP addr offset in PDS\n*FTBO     EQU   36                      Flags\n*AL3      EQU   39                      Alias sect\n*SIWD     EQU   40                    ? SSI (3 bytes, if not alias)\n*ASSI     EQU   50                    ? SSI (3 bytes, if alias)\n         LA    R1,PDSS01               start of next (SCTR) sect ?\n         TM    PDS2ATR1,PDS2SCTR       SCTR present ?\n         BNO   NOSCTR1                 no\n         LA    R1,PDSS01LN(R1)         advance position to alias sect\nNOSCTR1  TM    PDS2INDC,PDS2ALIS       alias ?\n         BNO   PROCSSI\n*-- Process alias: replace P#NAME and P#ADDR by main program data:\n         MVC   P#ANAME(8),P#NAME       ==> P#ANAME\n         MVC   P#AENTRY(4),P#ENTRY     ==> P#AENTRY\n     LR  3,1\n     LR  1,3\n         MVC   P#ENTRY+1(3),0(R1)      ==> P#ENTRY=Addr of main entry\n         MVC   P#NAME(8),3(R1)         ==> P#NAME=Main Program Name\n         OI    P#FLAG,X'80'            ==> indicate alias\n         LA    R1,PDSS02LN(R1)         advance position to SSI sect\n*-- Store SSI:  (usually overwritten by SSI from compiler records)\nPROCSSI  TM    PDS2FTB1,PDS2SSI        SSI present?\n         BNO   NOSSI                   No\n         LA    R1,1(R1)                align pos to halfword:\n         SRL   R1,1                    /2\n         SLL   R1,1                    *2\n         MVC   P#SSI(4),0(R1)          ==> P#SSI\n         LA    R1,PDSS03LN(R1)         advance position to APF sect\n*-- process APF:\nNOSSI    XC    P#ACODE(1),P#ACODE      clear\n         CLI   0(R1),X'00'             not present\n         BE    LARGE                   no AC\n         MVC   P#ACODE(1),1(R1)        ==> P#ACODE\n*-- process large:\nLARGE    LA    R1,PDSS04LN(R1)         advance position to large sect\n         TM    PDS2FTB2,PDS2BIG        Large program sect present?\n         BNO   CHKERR                  no\n         MVC   P#SIZE(4),1(R1)         ==> P#SIZE\n         MVC   P#ENTRY(4),5(R1)        ==> P#ENTRY\n         TM    PDS2INDC,PDS2ALIS       alias ?\n         BNO   CHKERR                  no\n         MVC   P#AENTRY(4),9(R1)       ==> P#AENTRY\n*-- indicate unsupported SCTR:\nCHKERR   TM    PDS2ATR1,PDS2SCTR       if SCTR\n         BO    ESDEND                  signal error if SCTR\n*\n*---------------------------------------------------------------------*\n*- Process ESD: Store SCECT to CTAB,\n*- Add NTAB element for each EP\n*---------------------------------------------------------------------*\nESD      SR    6,6                     Current # of ESD element\n*- Read block:\nNEXTESD  LA    1,PARMLIST              Restore R1\n         L     15,A$READ\n         BASSM 14,15                   ***> CALL $READ\n         LTR   15,15\n         BNZ   ESDEND                  Probably IO error\n         CLI   0(9),X'80'\n         BE    ESDEND                  IDR: end of ESD & SYM records\n         CLI   0(9),X'20'\n         BE    PROCESD                 This is a ESD block\n*- SYM?\n         CLI   0(9),X'40'              Type SYM ?\n         BNE   NEXTESD                 No\n         MVI   SYMFOUND+3,1            Flag SYM present\n         B     NEXTESD                 This block is not ESD\n*- Process ESD block: R7=element counter\nPROCESD  MVI   RC+3,NOSYM              Error expected\n         LH    7,6(9)                  Block size (260)\n         SRL   7,4                     How many elements in the block\n         LA    8,8(9)                  Addr of the 1st element\n         USING E#,8\n*- Check the next ESD element:\nTESTELM  LA    6,1(6)                  Element #\n         NI    E#TYPE,X'0F'            Clear left half-byte of type\n         SR    1,1\n         IC    1,E#TYPE                type\n         CH    1,=H'5'\n         BH    NEXTELM                 type>5 (PR,NULL,WX)-> HE HAS TIP\n         CH    1,=H'1'\n         BE    NEXTELM                 TIP=1 (LD) - skip\n         CH    1,=H'2'\n         BE    NEXTELM                 TIP 2 (ER) - skip\n         NC    E#SEG(4),OVERFL         Clear segm # if not Ovly\n         TM    E#SEG,X'0E'             1 < Segment # < 16 - Ovly\n         BZ    NOOVLY\n         MVI   RC+3,OVERLAY            Skip overlay segments\n         B     NEXTELM                 Error: OVERAY NOT SUPPORTED\n*- Good - store as a new element:\nNOOVLY   BAL   14,GETNEWC              R11->element CTAB\n         B     ESDEND1                 If not available\n         DROP  11                      USING\n         USING CTAB,11\n         XC    C#NTAB(4),C#NTAB        => C#NTAB\n         XC    C#NEXT(4),C#NEXT        => C#NEXT\n         STC   1,C#DTAB+3              => C#DTAB temp store type\n         STC   1,C#TYPE                => C#TYPE\n         L     1,LASTCTAB\n         ST    11,0(1)                 Store addr of this CTAB\n         LA    1,C#NEXT\n         ST    1,LASTCTAB              Update LASTCTAB\n         MVC   C#ADDR+1(3),E#ADDR      => C#ADDR\n**chg    L     1,E#TYPE\n**chg    LA    1,0(1)                  Addr\n**chg    ST    1,C#ADDR                => C#ADDR\n         MVC   C#DTAB(3),C#ADDR+1      C#DTAB = AL3(ADDR),XL1(TIP)\n**                                     for sort\n         MVC   C#NAME(8),E#NAME        => C#NAME\n         MVC   C#SIZE+1(3),E#LEN       => C#SIZE\n**chg    L     1,E#SEG\n**chg    LA    1,0(1)                  Addr\n**chg    ST    1,C#SIZE                => C#SIZE length\n         ST    6,C#BASE                => C#BASE = Priv. # of element\n*- Read next ESD element:\nNEXTELM  LA    8,E#LENGTH(8)           Addr of next element\n         BCT   7,TESTELM\n*- Block end:\n         B     NEXTESD\n*- End of ESD:\nESDEND   CLI   RC+3,NOESD\n         BNE   ESDEND1                 ESD records found\n*- No ESD records: add a dummy CTAB:\n         BAL   14,GETNEWC              R11->CTAB element\n         B     ESDEND1                 Not available (?)\n         DROP  11                      USING\n         USING CTAB,11\n         XC    C#NTAB(4),C#NTAB        => C#NTAB TIP1=0 (No names)\n         XC    C#NEXT(4),C#NEXT        => C#NEXT\n         XC    C#DTAB(4),C#DTAB        => C#DTAB TIP=CSECT (X'00')\n         L     1,LASTCTAB\n         ST    11,0(1)                 Store this CTAB addr\n         LA    1,C#NEXT\n         ST    1,LASTCTAB              Update LASTCTAB\n         L     14,PTABADDR             Addr of PTAB\n         USING PTAB,14\n         MVC   C#ADDR(4),P#ENTRY       => C#ADDR\n         MVC   C#NAME(8),P#NAME        => C#NAME\n         MVC   C#SIZE(4),P#SIZE        => C#SIZE\n         DROP  14                      USING\n         XC    C#BASE(4),C#BASE        => C#BASE\n         B     NSORT                   Complete processing\n*---------------------------------------------------------------------*\n*- Sort CTABS by C#DTAB, that means here\n*- ascending by address (offset) and type\n*---------------------------------------------------------------------*\nESDEND1  LR    9,11                    Last CTAB addr\n         L     7,PTABADDR              PTAB\n         USING PTAB,7                  Tell Assembler\n         LA    6,P#CTAB                Addr of 1st reference\n         DROP  7                       USING\n         LR    8,11                    Addr of 1st CTAB\nSORTRUN  SR    0,0                     exchange flag\n         L     11,0(6)                 Take 1st CTAB\n         LR    7,6                     Addr of 1st reference\nNXTCTAB  L     10,C#NEXT               2nd = next\n         LTR   10,10\n         BZ    NXTPASS                 End of pass\n         DROP  11                      USING\n         USING CTAB,10\n         L     1,C#DTAB                Addr + type in the next\n         DROP  10                      USING\n         USING CTAB,11\n         C     1,C#DTAB                Compare to previous\n         BL    EXCHANGE\n         LA    7,C#NEXT                New previous\n         LR    11,10                   1st = 2nd\n         B     NXTCTAB\n*- Exchange elements:\nEXCHANGE ST    10,0(7)                 Ref to current\n         DROP  11                      USING\n         USING CTAB,10\n         L     1,C#NEXT   \u00a210!\n         ST    11,C#NEXT  \u00a210!         Ref from curren\n         LA    7,C#NEXT   \u00a210!         Addr of prev reference\n         DROP  10                      USING\n         USING CTAB,11\n         ST    1,C#NEXT   \u00a211!         reference from next\n         LA    0,1                     exchange present?\n         B     NXTCTAB                 11 now is 2nd\nNXTPASS  LTR   0,0\n         BZ    SORTEND                 No exchange\n         B     SORTRUN\n*=\nSORTEND  DS    0H\n*        WTO   'SORT ENDED',ROUTCDE=11\n*---------------------------------------------------------------------*\n*- Clean-up CTAB:\n*- Clear C#DTAB, temp retain CSECT # in C#BASE,\n*- For ENTRY place CTAB addr into C#DTAB,\n*- For ENTRY (X'03') store CSECT addr to C#BASE\n*---------------------------------------------------------------------*\n         L     1,PTABADDR              PTAB addr\n         USING PTAB,1\n         L     1,P#CTAB                Addr of 1st CTAB\n         DROP  1                       USING\n         LR    11,1                    \"\"\"\"\n         SR    0,0                     for type\nCLRLOOP  DS    0H\n         LTR   11,11\n         BZ    CLREND                  End of pass\n         XC    C#DTAB(4),C#DTAB        clear C#DTAB\n**chg    L     0,C#DTAB                C#DTAB+3 = type\n**chg    SLL   0,24                    Shift type to left byte\n**chg    ST    0,C#DTAB                and store and clear C#DTAB\n*- RLD:  XC    C#BASE(4),C#BASE        clear  C#BASE\n         CLI   C#TYPE,LR               LABEL REFERENCE (Entry Point)\n         BE    NXT#LR                  yes\n*- CSECT: Store CTAB addr:\n         LR    1,11                    Store Addr of CSECT.CTAB\n         B     NXTCLR\n*- Entry Point: Store CTAB of CSECT and size:\nNXT#LR   DS    0H\n**chg    O     1,C#DTAB                save type\n         ST    1,C#DTAB                store addr of CSECT.CTAB\n         DROP  11                      USING\n         USING CTAB,1                  CSECT\n         L     3,C#ADDR\n         A     3,C#SIZE                Addr of end of CSECT\n         DROP  1                       USING\n         USING CTAB,11\n         S     3,C#ADDR                Size from EP to the end\n         ST    3,C#SIZE\nNXTCLR   L     11,C#NEXT               2nd = next\n         B     CLRLOOP\n*-\n         DROP  11                      USING\nCLREND   CLI   SYMFOUND+3,1\n         BNE   SYMENDX                 SYM not present\n         CLI   RC+3,OVERLAY\n         BE    GETSYM0                 RC set\n         MVI   RC+3,0\nGETSYM0  DS    0H\n*        WTO   'SYM PROCESSING STARTED',ROUTCDE=11\n*---------------------------------------------------------------------*\n*                                                                     *\n*- Fill NTAB chains for CSECT using SYM records,                      *\n*- chains for DTAB and their chains for NTAB if any                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*- Special use of R4:\n*- R4=8 (NOESD) - Wrong CSECT\n*- R4=0         - CSECT correct, wrong DSECT\n*- R4=4 (NOSYM) - CSECT correct, wrong DSECT\n         XC    ENDFILE,ENDFILE         End of File flag: EOF <> 0\n         USING D#,10                   to access buffer\n**       LA    2,PARMLIST\n         L     10,D##ADDR              R10=Addr of D#\n**       LA    10,0(10)                drop VL bit\nGETSYM   SR    4,4\n         LA    R1,PARMLIST\n         L     15,A$OPEN\n         BASSM 14,15                   ***> CALL  $OPEN\n         L     9,D#BUF                 R9-> input block\n         SR    6,6                     See NEXTELMS\nNEXTBLK  LTR   6,6\n         BZ    READ\n*- Save remainder of SYM block:\n         LA    7,S#REST\n         EX    6,MVCS                  MVC 0(R6,R7),0(R5)\n         LR    5,7                     Reset R5 to S#REST\nREAD     LA    R1,PARMLIST\n         L     15,A$READ\n         BASSM 14,15                   ***> CALL  $READ\n         LTR   15,15\n         BZ    CONTINUE\n*-RLD :  MVI   RC+3,NOSYM              Unexpected end of SYM\n         B     SYMEND\nCONTINUE CLI   0(9),X'80'\n         BE    SYMEND                  IDR - End of ESD & SYM\n         CLI   0(9),X'40'\n         BNE   NEXTBLK                 not a SYM-block\n         CLI   1(9),X'00'\n         BNE   NEXTBLK                 not a SYM-block\n         DROP  8                       USING\n         USING Y#,8                    Map SYM\n         LA    8,4(9)                  Addr of 1st SYM card\n         USING S#,7                    SYM element\n*- R8-> start of SYM card\nNEXTCARD LA    3,Y#LENGTH(8)           Addr of the end of new record\n         S     3,D#BUF                 Length to the end of new record\n         C     3,D#LAST                Length to the end of block\n         BH    NEXTBLK                 Block exhosted\n         CLC   Y#SYM(3),=C'SYM'\n         BNE   NEWCARD                 Not a SYM(?) ...\n         LA    7,Y#INF                 R7-> 1st SYM element\n         MVC   Y#LENS(2),Y#LEN         Save Y#LEN\n         B     NEXTELMS\nNEWCARD  LA    8,Y#LENGTH(8)           Next card\n         B     NEXTCARD\n*- Prepare to analyse SYM element:\n*- R6=length of prev remainder, R5=addr of remainder\n*- If R6=0, attach the remander to the left\nNEXTELMS LTR   6,6\n         BZ    PROCELM                 No remainder\n         SR    7,6\n         BCTR  7,0                     New SYM element address\n         EX    6,MVCS                  Attach remainder to the left\n         SR    6,6                     and clear R6\n*- R7-> SYM element\nPROCELM  LA    5,S#NAME                R5 - pointer to current position\n         MVI   SYMNAME,C' '\n         MVC   SYMNAME+1(7),SYMNAME    Clear SYMNAME\n*** debug\n*        SAY   'SYM=',S#ORG,20\n*\n         CLI   S#ORG,X'68'\n         BE    FIN2                    Skip EQU with no name\n*\n         TM    S#ORG,X'08'\n         BO    GETOTHER                Unnamed element\nGETNAME  SR    3,3\n         IC    3,S#ORG\n         SLL   3,29\n         SRL   3,29                    R3 = name length - 1\n         EX    3,MVCN                  Copy name to SYMNAME\n         LA    5,1(3,5)                addr + length = next pos\n**       LA    5,1(5)                  next position\nGETOTHER SR    3,3\n         ST    3,SYMKRATN              Default multiplier\n         TM    S#ORG,X'80'\n         BNO   NODATA                  Not data type\n*- Element type data:\n*- Detect type of data:\n         SR    3,3\n         IC    3,0(5)\n         LR    14,3\n         SRL   3,2                     type/4 = type # = I\n         LA    15,SYMTYPE              Symbolic type names\n         IC    3,0(3,15)               Select I-I type\n         STC   3,SYMTYPE1              Store type to SYMTYPE1\n         LA    5,1(5)                  next position\n         CH    14,H9\n         BL    LEN2                    length in 2 bytes:\n*- Length in 1 byte:\n         SR    3,3\n         IC    3,0(5)                  R3 = length - 1\n         LA    3,1(3)                  length\n         STH   3,SYMLEN\n         LA    5,1(5)\n         B     KRATN\n*- length in 2 bytes:\nLEN2     SR    3,3\n         IC    3,0(5)\n         SLL   3,8\n         IC    3,1(5)\n         LA    3,1(3)                  length\n         LA    5,2(5)\n         STH   3,SYMLEN\n*- Store multiplier if any:\nKRATN    MVC   SYMKRATN(4),=F'1'       No multiplier - take 1\n         TM    S#ORG,X'40'\n         BNO   MAS                     no multiplier\n         MVC   SYMKRATN+1(3),0(5)      Store multiplier\n         LA    5,3(5)                  next position\n*- Skip MACSTAB, if present:\nMAS      TM    S#ORG,X'20'\n         BNO   FIN#DATA                No MACSTAB\n         LA    5,2(5)                  Skip MACSTAB\n*- Skip data element if no name and multiplier = 0:\n*- (like  DS 0H)\nFIN#DATA CLI   SYMNAME,C' '\n         BNE   FIN                     Name present\n         L     3,SYMKRATN\n         LTR   3,3\n         BNZ   FIN                     Multiplier <> 0\n         B     FIN2                    Skip element\n*- Not data type convert type:\nNODATA   SR    3,3\n         IC    3,S#ORG\n         SRL   3,4                     keep 4 bits\n         STC   3,SYMTYPE1\n         OI    SYMTYPE1,X'F0'\n*\n*- Non-data type: 1st 4 bits are X'F'\n*        C'0'  blank\n*        C'1'  CSECT\n*        C'2'  DSECT\n*        C'3'  COMMON\n*        C'4'  machine instruction\n*        C'5'  CCW\n*        C'6'  relocatable EQU,\n*              named LTORG,\n*              named CNOP,\n*              named ORG\n         TM    S#ORG,X'70'\n         BNZ   CMD                     not balnk\n*- C'0' : blank:\n         SR    3,3\n         IC    3,0(5)                  length\n         STH   3,SYMLEN\n         LA    5,1(5)                  skip length\n         B     FIN\n*- CMD,CCW,EQU - element, make length zero because unknown:\nCMD      SR    3,3\n         STH   3,SYMLEN\n         TM    S#ORG,X'40'\n         BO    FIN                     not CSECT\n*---------------------------------------------------------------------*\n*- CSECT & COMMON - static areas, and relative address                *\n*- of fields are equal to the sum of relative CSECT addr and          *\n*- field offset in the CSECT.                                         *\n*- DSECT - dynamic area, its position is defined by a base register   *\n*- Base register # and value can change with program execution        *\n*- It is up to the user to determine if it is currently valid.        *\n*---------------------------------------------------------------------*\nSECT     TM    S#ORG,X'10'             CSECT or COMMON ?\n         BNO   DSECT                   This is DSECT\n*- Set up CSECT:\n         BAL   14,GETCTAB              Set up NTAB chain\n         LTR   11,11\n         BNZ   FIN3                    Expected to present\n*        WTO   'A31ESD: CSECT not found for SYM',ROUTCDE=11\n         LA    4,NOESD                 No CSECT\n         B     FIN2\nFIN3     SR    4,4                     \"Correct CSECT\"\n*- Add element to NTAB for CSECT if the first:\n         L     14,CTABADDR\n         USING CTAB,14\n**chg    CLI   C#TYPE1,C##SYM\n**chg    BE    FIN2                    Already there\n         MVI   C#TYPE1,C##SYM          ==> Get type\n         B     FIN                     ready to add\n         DROP  14                      USING\nDSECT    BAL   14,GETDTAB              Set up DTAB chain\n         B     FIN2                    DSECT not yet needed\n*- Advance to next element:\nFIN2     DS    0H\n         CLI   ENDFILE,1\n         BE    SYMENDA                 process reminder\n         SR    6,6\n         LH    6,Y#LENS                R6 = length SYM card\n         LR    1,5                     current position\n         LA    3,Y#INF                 start of inf\n         SR    1,3                     offset to next elem from inf\n         SR    6,1                     length of inf remainder\n         CH    6,H20\n         BL    SMALL                   remains less than 20 bytes\n*- remains more than 20 bytes\n         SR    6,6\n         LR    7,5\n         B     PROCELM\n*- Remainder might contain no entire element:\nSMALL    LA    8,Y#LENGTH(8)           Next card\n         BCTR  6,0                     length-1 for MVC (R6>1)\n         B     NEXTCARD\n*- Store SYM element in NTAB:\nFIN      BAL   14,GETNEWN              R11->new NTAB\n         B     FIN2                    If not available\n         L     14,TABREF\n**chg    IC    3,0(14)                 save left byte\n         ST    11,0(14)                attach element\n**chg    STC   3,0(14)                 restore left byte\n         USING NTAB,11\n         ST    11,NTABADDR\n         LA    14,N#NEXT\n         ST    14,TABREF               ==> TABREF\n         SR    14,14\n         ST    14,N#NEXT               ==> N#NEXT\n         ST    14,N#R1                 ==> N#R1\n         LA    14,8\n         STC   14,N#NMLN               ==> Name length <==\n         IC    14,SYMTYPE1\n         STC   14,N#TYPE               ==> N#TYPE\n         MVC   N#NAME(8),SYMNAME       ==> N#NAME\n         SR    R3,R3\n         ICM   R3,B'0111',S#ADDR\n**chg    L     3,S#ORG\n**chg    LA    3,0(3)                  Address\n         ST    3,N#ADDR                ==> N#ADDR\n         LH    3,SYMLEN\n         ST    3,N#SIZE                ==> N#SIZE\n         STH   3,N#INT                 ==> N#INT, until user updates\n         MVC   N#DIM(4),SYMKRATN       ==> N#DIM\n*- Update  D#SIZE, if DSECT:\n         L     14,DTABADDR\n         LTR   14,14\n         BZ    NODSIZE                 not a DSECT\n         USING DTAB,14\n         L     3,N#ADDR\n         L     1,N#DIM                 Array dimension\n         LTR   1,1\n         BP    DSCYCLE\n         LA    1,1\nDSCYCLE  A     3,N#SIZE                advance to next element\n         BCT   1,DSCYCLE\n* R3-> End of element:\n         C     3,D#SIZE\n         BNH   NODSIZE\n         ST    3,D#SIZE\n         DROP  14                      USING\nNODSIZE  DS    0H\n* If type and multiplier = 0, set type EQU:\n         TM    N#TYPE,X'F0'\n         BO    FIN2                    not data type\n         L     3,SYMKRATN\n         LTR   3,3\n         BNZ   FIN2                    multiplier > 0\n         MVI   N#TYPE,X'F6'            type EQU\n         ST    3,N#SIZE                Zero length\n         STH   3,N#INT                 Zero\n         B     FIN2\n*---------------------------------------------------------------------*\n*- End of SYM records:                                                *\n*---------------------------------------------------------------------*\nSYMEND   LTR   6,6                     0 or length of remainder - 1\n         BZ    SYMENDX                 no remainder\n         MVI   ENDFILE,1               remainder for FIN2\n         LA    6,1(6)                  restore length of remainder\n         STH   6,Y#LENS                save length of remainder\n*- Continue processing remainder:\nSYMENDA  LH    6,Y#LENS                R6= length of inf of SYM card\n         LR    1,5                     Current position\n         LA    3,S#REST                Start of inf\n         SR    1,3                     Offset of next elem from inf\n         SR    6,1                     length of inf remainder\n         CH    6,H4\n         BL    SYMENDX                 remains less than 4 bytes\n*- Remains more than 4 bytes:\n         SR    6,6\n         LR    7,5\n         B     PROCELM\nSYMENDX  DS    0H\n*---------------------------------------------------------------------*\n*                                                                     *\n*  Process  IDR-records CSECT (they come all together)\n*  (Fill CSECT processing date)\n*                                                                     *\n*---------------------------------------------------------------------*\n**       LA    2,PARMLIST\n         L     10,D##ADDR              R10=Addr of D#\n**       LA    10,0(10)                drop VL bit\n         USING D#,10\n         L     9,D#BUF\nIDRTEST  L     11,PTABADDR             Addr  PTAB\n         USING PTAB,11\n         CLI   0(9),X'80'\n         BNE   IDREND\n         TM    2(9),X'04'              Compiler ?\n         BO    IDRREC                  Process\n         CLI   P#SSI,0\n         BNE   IDRREAD                 SSI present do not search LKED\n         TM    2(9),X'02'              LKED ?\n         BZ    IDRREAD                 no\n*---------------------------------------------------------------------*\n*- LKED record: fill P#SSI:\n*---------------------------------------------------------------------*\n         MVC   P#SSI(3),15(9)\n         B     IDRREAD                 Next record\n*---------------------------------------------------------------------*\n*  Compiler record:\n*  Mark sections listed, then fill the dates\n*---------------------------------------------------------------------*\nIDRREC   SR    6,6\n         IC    6,1(9)                  Record length\n         LA    6,1(6,9)                R6= Addr of record end\n         LA    5,3(9)                  R5= Addr of data in record\nIDRCPRC  MVC   WCNUM(2),0(5)           CESD elem # (unaligned)\n         NI    WCNUM,B'01111111'       Drop last-flag\n         LH    7,WCNUM\n         BAL   14,SETCTAB              Find CTAB by number\n         B     IDRREAD                 if not found\n         L     11,CTABADDR\n         USING CTAB,11\n         MVI   C#SSIFLG,C#PUTSSI       Mark C#SSI\n         TM    0(5),X'80'\n         BNZ   IDRCSSI                 Last in the list: fill SSI\n         LA    5,2(5)\nIDRNXTC  CR    5,6                     Record end ?\n         BL    IDRCPRC                 no - process next element\nIDRREAD  LA    R1,PARMLIST\n         L     15,A$READ\n         BASSM 14,15                   ***> CALL  $READ\n         LTR   15,15\n         BZ    IDRTEST                 Record read\n         B     IDREND                  no record read\n*---------------------------------------------------------------------*\n*  Get and fill SSI to the marked sections:\n*---------------------------------------------------------------------*\nIDRCSSI  MVC   WCSSI(3),15(5)          Read part or whole SSI\n         LA    7,18(5)                 Addr of end of SSI\n         SR    7,6                     Length of passed remainder\n         BP    IDRCSSI1                Only part of SSI in cur record\n*- Usually: Whole SSI is in the current record\n         LA    5,18(5)                 advance pointer\n         B     IDRWSSI                 store SSI\n*- Not whole SSI is in current record:\nIDRCSSI1 CH    7,=H'3'\n         BNL   IDRCSSI2                SSI is in the next record\n*- Rare: SSI is splitted (R7<3 = length of remainder of SSI):\n*        WTO 'A31ESD: Splitted SSI encountered',ROUTCDE=11\nCUT      LA    R1,PARMLIST\n         L     15,A$READ               Read next record\n         BASSM 14,15                   ***> CALL  $READ\n         LTR   15,15\n         BNZ   IDREND                  no record read\n         LA    5,3(7,9)                R5= Addr of SSI begin\n*- Attach SSI continuation:\n         LA    6,WCSSI+2\n         SR    6,7                     Where to write\nMORE1    IC    15,2(7,9)               Read a byte of SSI\n         STC   15,0(7,6)               Write the byte\n         BCT   7,MORE1                 Repeate until R7 > 0\n         B     IDRCSSI3                Store SSI\n*- Sometimes: whole SSI in the next record:\nIDRCSSI2 SH    7,=H'3'                 SSI offset in record data\n         LA    R1,PARMLIST\n         L     15,A$READ\n         BASSM 14,15                   ***> CALL  $READ\n         LTR   15,15\n         BNZ   IDREND                  no record\n         LA    5,3(7,9)                R5= Addr of SSI\n         MVC   WCSSI(3),0(5)           Store SSI\n         LA    5,3(5)                  Advance pointer\nIDRCSSI3 SR    6,6\n         IC    6,1(9)                  Record length\n         LA    6,1(6,9)                R6= Addr of record end\n*- Store SSI to the marked CTAB:\nIDRWSSI  L     11,PTABADDR             PTAB\n         L     11,P#CTAB-PTAB(11)      1st CTAB\nIDRCW    LTR   11,11\n         BZ    IDRNXTC                 No more CTABs\n         TM    C#SSIFLG,C#PUTSSI       Marked CTAB?\n         BNO   IDRCWN                  CTAB not marked\n         MVC   C#SSI(3),WCSSI          Copy SSI\nIDRCWN   L     11,C#NEXT\n         B     IDRCW                   Loop by CTAB\n*-\nC#SSIFLG EQU   C#SSI\nC#PUTSSI EQU   X'FF'\n*---------------------------------------------------------------------*\n*- Fill FORTRAN-G names:                                              *\n*---------------------------------------------------------------------*\nIDREND   DS    0H\n*IDREND   LA    1,PARMLIST\n*         L     15,A$FORT\n*         BALR  14,15                   ***> CALL  A31FORT\n*         CH    15,H20                  TEST RC A31FORT\n*         BNL   NSORT                   Table overflow\n*---------------------------------------------------------------------*\n*- Add A- & V-const from RLD-records:\n*---------------------------------------------------------------------*\n**       LA    2,PARMLIST\n         LA    R1,PARMLIST\n         L     15,A$OPEN\n         BASSM 14,15                   ***> CALL  $OPEN\n         L     9,D#BUF                 R9-> input block\n         L     10,D##ADDR              R10=Addr of D#\n**       LA    10,0(10)\n         L     9,D#BUF\n*        B     TESTRLD                 Process record:\nREADRLD  LA    R1,PARMLIST\n         L     15,A$READ\n         BASSM 14,15                   ***> CALL  $READ\n         LTR   15,15\n         BNZ   NSORT                   End of file\n         USING RLDREC,9                Map RLD record\n*- Record type:\nTESTRLD  CLI   RL#TYPE,RL#RLD\n         BE    PROCRLD                 RLD\n         CLI   RL#TYPE,RL#CRLD\n         BE    PROCRLD                 CRLD\n         CLI   RL#TYPE,RL#CLAST\n         BE    PROCRLD                 CRLD-last\n         CLI   RL#TYPE,RL#LAST\n         BNE   READRLD                 Other: skip it\nPROCRLD  CLC   RL#NULL,=XL3'000000'\n         BNE   READRLD                 Not RLD\n         LH    6,RL#RLCNT              Data size for RLD\n         LTR   6,6\n         BZ    READRLD                 No RLD-data\n         LA    8,RL#DATA\n         AR    6,8                     Addr of RLD-data end\n         DROP  8                       USING\n         USING RLDATA,8\n*---------------------------------------------------------------------*\n*  R6=Addr of data end, R8=Addr of data\n*- Process triplets: (R,P,(F,A))\n*---------------------------------------------------------------------*\nPROCRP   LH    7,RD#P                  Section # with reference\n         BAL   14,SETCTAB              R11-> Last NTAB or CTAB\n         B     READRLD                 If CTAB not found\n         LA    7,RD#F                  1st element FA\n         LTR   11,11\n         BNZ   GETCTYP                 found\n*        WTO   'A31ESD.PROCRP: ESD not found',ROUTCDE=11\n         B     NSORT                   Fatal error\nGETCTYP  L     4,CTABADDR\n         DROP  11                      USING\n         USING CTAB,4\nPROCFA   CLI   C#TYPE1,C'A'\n         BE    NEXTFA                  SYM present - do not need RLD\n         SR    5,5\n         IC    5,0(7)                  F (XXXXLLST)\n         SLL   5,24\n         SRL   5,28                    Keep R5='XXXX'\n         CH    5,=H'1'\n         BH    NEXTFA\n*- Add  NTAB:\n         BAL   14,GETNEWN              R11-> new NTAB\n         B     NSORT                   not available\n         L     14,TABREF\n**chg    IC    15,0(14)                Save left byte\n         ST    11,0(14)                Attach element\n**chg    STC   15,0(14)                Restore left byte\n         USING NTAB,11\n         ST    11,NTABADDR\n         LA    14,N#NEXT\n         ST    14,TABREF               ==> TABREF\n         SR    14,14\n         ST    14,N#NEXT               ==> N#NEXT\n         ST    14,N#R1                 ==> N#R1\n         LA    14,8\n         STC   14,N#NMLN               ==> Name length <==\n         MVC   N#NAME,=CL8'        '   ==> Name (empty)\n         LTR   5,5\n         BZ    *+12\n         MVI   N#TYPE,C'V'             ==> V type\n         B     *+8\n         MVI   N#TYPE,C'A'             ==> A type\n         IC    5,RD#F\n         SLL   5,28\n         SRL   5,30                    Keep  R5='LL'\n         LA    5,1(5)                  R5=R5+1= Constant length\n         ST    5,N#SIZE                ==> N#SIZE\n         STH   5,N#INT                 ==> N#INT\n         LA    5,1\n         ST    5,N#DIM                 ==> N#DIM\n         SR    R5,R5\n         ICM   R5,B'0111',1(R7)        RD#A = offset in the program\n**       L     5,0(7)                  RD#A = offset in the program\n**       LA    5,0(5)                  Cut RD#F\n         S     5,C#ADDR                Offset in CSECT\n         ST    5,N#ADDR                ==> N#ADDR\nNEXTFA   TM    0(7),1                  Last FA for RP ?\n         LA    7,4(7)                  Next FA or RP\n         BNZ   PROCFA                  Not last FA\n         CR    7,6\n         BNL   READRLD                 End of data in record\nNEXTRP   LR    8,7                     Addr of next RP\n         B     PROCRP\n         DROP  4                       USING CTAB\n*---------------------------------------------------------------------*\n*- Sort  NTABs by N#ADDR and clear C#BASE:\n*---------------------------------------------------------------------*\nNSORT    LA    4,PARMLIST\n         L     4,4(4)                  PTAB\n         USING PTAB,4\n         L     5,P#CTAB                1st CTAB\n         USING CTAB,5\n*- Loop by CTAB, R5->*\nNXTCTAB3 LTR   5,5\n         BZ    SORTEND2                End of Sort\n         CLI   C#TYPE,LR\n         BNE   NOTENTRY                CSECT\n*- Entry Point: Save C#BASE=QCTAB, add NTAB((4),NAME,ADDR):\nPRENTRY  L     7,C#DTAB                Addr CSECT elem\n**chg    LA    7,0(7)                  cut type\n         ST    7,C#BASE                store to ENTRY.CTAB\n         DROP  5                       USING CTAB\n         USING CTAB,7\n         L     11,C#NTAB               1st NTAB\n         CLI   C#TYPE1,0               SYM present?\n         BNE   GETCTAB3                SYM, SYMDB -> next CTAB\n*- No SYM: create LR-element and take next CTAB:\n         L     14,C#ADDR-CTAB(5)       Addr of LR\n         C     14,C#ADDR               Compare to addr of CSECT\n         BE    NOFICT                  equal - do not add NTAB\n         LR    3,11                    save old C#NTAB\n         BAL   14,GETNEWN              R11-> New NTAB (for LR)\n         B     GETCTAB3     not avail: no change - not sort\n         USING NTAB,11\n         ST    11,C#NTAB               Attach NTAB\n**chg    ST    11,SAVNTAB              Attach NTAB, save C#TYPE1\n**chg    MVC   C#NTAB+1(3),SAVNTAB+1   copy 3 bytes\n         XC    NTAB(N#LENGTH),NTAB     ==> clear all fields\n         ST    3,N#NEXT                ==> N#NEXT\n         MVC   N#NAME(8),C#NAME-CTAB(5)   ==> N#NAME for LR\n         MVI   N#TYPE,Z#STMT           ==> N#TYPE\n         LA    6,C#NTAB                for CSORT\n         L     14,C#ADDR-CTAB(5)       Addr of LR\n         S     14,C#ADDR               Offset of LR\n         ST    14,N#ADDR               ==> N#ADDR\n         BAL   2,SORTRUN2\n         DROP  7                       USING CTAB\n         USING CTAB,5\nNOFICT   XC    C#DTAB(4),C#DTAB        Clear  C#DTAB\n**chgT   XC    C#DTAB+1(3),C#DTAB+1    Clear  C#DTAB\n         B     GETCTAB3                Next CTAB\n*-\nNOTENTRY XC    C#BASE,C#BASE\n         LA    6,C#NTAB                Addr of pointer to NTAB chain\n         L     11,C#NTAB               1st NTAB\n         CLI   C#TYPE1,C'A'            Only RLD?\n         BE    CSORT                   For SYM do not need dummy\n         CLI   C#TYPE,0                CSECT (or COMMON)\n         BNE   CSORT                   For not CSECT not need dummy\n*- No NTAB for CTAB except RLD: Create dummy and take next CTAB:\nPUTFICT  CLC   N#ADDR,NULL\n         BE    CSORT                   NTAB with addr=0 exists\n         LR    3,11                    save old C#NTAB\n         BAL   14,GETNEWN              R11-> new NTAB (for dummy)\n         B     CSORT                   - not available\n         ST    11,C#NTAB               Attach NTAB\n**chg    ST    11,SAVNTAB              Attach NTAB, save C#TYPE1\n**chg    MVC   C#NTAB+1(3),SAVNTAB+1   Copy 3 bytes\n         XC    NTAB(N#LENGTH),NTAB     ==> clear all fields\n         ST    3,N#NEXT                ==> N#NEXT\n         MVC   N#NAME,C#NAME           ==> N#NAME\n         MVI   N#TYPE,Z#CSECT          ==> N#TYPE\n         LTR   3,3                     If no other NTAB,\n         BZ    GETCTAB3                take next CTAB, no DTAB\n*-\nCSORT    BAL   2,SORTRUN2              Sort NTAB for CTAB     8\n*- Now Sort DTAB chains:\n         L     3,C#DTAB                1st DTAB for CTAB\n**chg    LA    3,0(3)                  cut C#TYPE\n         USING DTAB,3\nNXTDTAB3 LTR   3,3\n         BZ    GETCTAB3                No more DTAB -> next CTAB\n         LA    6,D#NTAB                Addr of pointer to NTAB chain\n         L     11,D#NTAB               Addr of NTAB\n         LTR   11,11\n         BZ    GETDTAB3                No NTAB for DTAB\n         BAL   2,SORTRUN2              Sort NTAB\nGETDTAB3 L     3,D#NEXT                Next DTAB\n         B     NXTDTAB3\n*-\nGETCTAB3 L     5,C#NEXT\n         B     NXTCTAB3\n*\n*- Sort loop by passes: R6-> Addr of 1st NTAB (C#NTAB)\n*\nSORTRUN2 DS    0H\n**chg    L     11,0(6)                 C#NTAB\n**chg    ST    11,SAVNTAB              Save C#TYPE1\nSORTRUN3 SR    0,0                     Clear exchange flag\n         L     11,0(6)                 1st NTAB\n         LTR   11,11\n         BZ    NXTPASS2                No elements\n         LR    7,6                     Addr 1st reference\n*- Loop by NTAB in the pass:\nNXTNTAB2 L     10,N#NEXT               2nd = next\n         LTR   10,10\n         BZ    NXTPASS2                end of pass\n         DROP  11                      USING\n         USING NTAB,10\n         L     1,N#ADDR                addr in next\n         DROP  10                      USING\n         USING NTAB,11\n         C     1,N#ADDR                compare to previous\n         BL    EXCHANG2\n         LA    7,N#NEXT                new previous\n         LR    11,10                   1st = 2nd\n         B     NXTNTAB2                continue by NTAB\n*- Exchange elements:\nEXCHANG2 ST    10,0(7)                 Ref to current\n         DROP  11                      USING\n         USING NTAB,10\n         L     1,N#NEXT   \u00a210!         old\n         ST    11,N#NEXT  \u00a210!         new\n         LA    7,N#NEXT   \u00a210!         Addr of previous reference\n         DROP  10                      USING\n         USING NTAB,11\n         ST    1,N#NEXT   \u00a211!         reference from next\n         LA    0,1                     set exchange flag\n         B     NXTNTAB2                11 now the 2nd\nNXTPASS2 LTR   0,0\n         BNZ   SORTRUN3                next pass\n*- Sort end for CSECT tables\n**chg    IC    11,SAVNTAB\n**chg    STC   11,0(6)                 Restore C#TYPE1\n         BR    2                       Exit\n*=\nSORTEND2 DS    0H\n*        WTO   'SYM SORT ENDED',ROUTCDE=11\n* Continue processing:\n*=======================================\nCLOSE    DS    0H\n*        LA    1,PARMLIST\n*        L     15,A$CLOSE\n*        BASSM 14,15                   ***> CALL $CLOSE\n*        LTR   15,15\n*        BZ    CLOSEOK\n*        WTO   'A31ESD: CLOSE FAILED',ROUTCDE=11\n*        B     EXIT\n*CLOSEOK  DS    0H        'A31ESD: CLOSE SUCCESSFUL',ROUTCDE=11\n         B     EXIT\n*======================================================================\n* Subroutine for setting CTAB by number of ESD,\n* coming in R7 (and kept in C#BASE).\n* Output:\n* R11-> Last NTAB or CTAB (if no NTAB)\n* Addr of CTAB stored in CTABADDR\n* If CTAB found, exit to R14+4\n* If CTAB found, exit to R14\n*-------------------------------------------------\n*- Search for  CTAB:\nSETCTAB  LA    11,PARMLIST\n         L     11,4(11)                PTAB\n         DROP  4,11                    USING\n         USING PTAB,11\n         L     11,P#CTAB               1st  CTAB\n         DROP  5,11                    USING\n         USING CTAB,11\nTSTCNUM  C     7,C#BASE\n         BE    SETCNTB                 CTAB found\n         L     11,C#NEXT\n         LTR   11,11\n         BZ    SETCERR                 not found: R11=0\n         B     TSTCNUM\n*- Fill CTABADDR, DTABADDR, TABREF:\nSETCNTB  ST    11,CTABADDR\n         XC    DTABADDR(4),DTABADDR    clear DTABADDR\n         XC    NTABADDR(4),NTABADDR    clear NTABADDR\n         LA    11,C#NTAB\n         ST    11,TABREF               Addr of the last reference\n         L     11,CTABADDR\n         CLC   C#NTAB,=F'0'            Addr of 1st NTAB=0 ?\n         BE    SETCEXIT                No NTAB\n         L     11,C#NTAB               1st NTAB\n*- Find the last NTAB:\n         DROP  11                      USING\n         USING NTAB,11\nTSTNTB   CLC   N#NEXT(4),=F'0'\n         BE    TSTNEXIT                R11-> last NTAB\n         L     11,N#NEXT\n         B     TSTNTB\n*- Last NTAB found: fill NTABADDR & TABREF:\nTSTNEXIT ST    11,NTABADDR\n         LA    11,N#NEXT\n         ST    11,TABREF\n         L     11,NTABADDR\nSETCEXIT B     4(14)\nSETCERR  BR    14\n*=====================================================================\n* Subroutine to set\n* R11-> last NTAB or CTAB (if no NTAB)\n* by CSECT name, stored in SYMNAME\n* Addr of CTAB will be stored to CTABADDR\n* Addr of NTAB will be stored to NTABADDR\n* Addr of last reference .#NEXT stored to TABREF\n* DTABADDR will be cleared\n* Exit:  R14\n*-------------------------------------------------\n*- Search for CTAB:\nGETCTAB  LA    11,PARMLIST\n         L     11,4(11)                PTAB\n         DROP  11                      USING\n         USING PTAB,11\n         L     11,P#CTAB               1st CTAB\n         DROP  11                      USING\n         USING CTAB,11\nTSTCNAM  CLC   SYMNAME(8),C#NAME\n         BE    GETCNTB                 CTAB found\n         L     11,C#NEXT\n         LTR   11,11\n         BZ    GETCEXIT                not found: R11=0\n         B     TSTCNAM\n*-> Entry for known CTAB: R11->CTAB, R14->exit\n*- Fill CTABADDR, DTABADDR, TABREF:\nGETCNTB  ST    11,CTABADDR\n         XC    DTABADDR(4),DTABADDR    clear DTABADDR\n         XC    NTABADDR(4),NTABADDR    clear NTABADDR\n         LA    11,C#NTAB\n         ST    11,TABREF               Addr of last reference\n         L     11,CTABADDR\n         CLC   C#NTAB+1(3),=F'0'       Addr of 1st NTAB=0 ?\n         BE    GETCEXIT                No NTAB\n         L     11,C#NTAB               1st NTAB\n*- Find the last NTAB:\n         DROP  11                      USING\n         USING NTAB,11\nTSTCNTB  CLC   N#NEXT(4),=F'0'\n         BE    TSTCEXIT                R11-> last NTAB\n         L     11,N#NEXT\n         B     TSTCNTB\n*- Last NTAB found: fill NTABADDR & TABREF:\nTSTCEXIT ST    11,NTABADDR\n         LA    11,N#NEXT\n         ST    11,TABREF\n         L     11,NTABADDR\nGETCEXIT BR    14\n*=====================================================================\n* Subroutine to set\n* R11-> last NTAB or DTAB (if no NTAB)\n* by DSECT name, stored in SYMNAME.\n* Addr of CTAB taken from CTABADDR\n* Addr of NTAB will be stored in NTABADDR\n* Addr of DTAB will be stored in DTABADDR\n* Addr of last reference .#NEXT stored in TABREF\n* Exit:  R14\n*-------------------------------------------------\nGETDTAB  DS    0H\n*- POICKAT\u00d3 CTAB:\n         L     11,CTABADDR\n         DROP  11                      USING\n         USING CTAB,11\n         L     11,C#DTAB               1st  DTAB\n         LTR   11,11\n         BNZ   TSTDNAM                 Search DTAB\n*- DTAB not yet set - create DTAB chain\n         L     11,CTABADDR\n         LA    11,C#DTAB\n         ST    11,TABREF               ==> TABREF\n         DROP  11,3                    USING\n         USING DTAB,11\n*- New DTAB: TABREF->.#NEXT\nNEWDTAB  ST    14,SAVE14#1\n         BAL   14,GETNEWD              R11-> New DTAB\n         B     NEWDTABX                not available\n*- Attach new DTAB to DTAB chain:\n         L     14,TABREF\n**chg    IC    3,0(14)                 save left byte\n         ST    11,0(14)                attach to the chain\n**chg    STC   3,0(14)                 restore left byte\n         ST    11,DTABADDR             ==> DTABADDR\n         SR    14,14\n         DROP  11                      USING\n         USING DTAB,11\n         ST    14,D#NEXT               ==> D#NEXT\n         MVC   D#NAME(8),SYMNAME       ==> D#NAME\n         ST    14,D#NTAB               ==> D#NTAB\n         ST    14,D#BASE               ==> D#BASE\n         ST    14,D#ADDR               ==> D#ADDR\n         L     14,CTABADDR\n         ST    14,D#CTAB               ==> D#CTAB\n         LA    14,D#NTAB\n         ST    14,TABREF               ==> TABREF ready\nNEWDTABX L     14,SAVE14#1\n         B     GETDEXIT\n*- DTAB exists - search this DTAB by name:\nTSTDNAM  CLC   SYMNAME(8),D#NAME\n         BE    GETDNTB                 DTAB found\n         CLC   D#NEXT,=F'0'\n         BE    NEWDTAB1                not found: create\n         L     11,D#NEXT\n         B     TSTDNAM\n*- DTAB not found - create new\nNEWDTAB1 LA    11,D#NEXT\n         ST    11,TABREF               ==>TABREF\n         B     NEWDTAB\n*- DTAB found: fill  DTABADDR, TABREF:\nGETDNTB  ST    11,DTABADDR             ==>DTABADDR\n         LA    11,D#NTAB\n         ST    11,TABREF               ==> TABREF\n         L     11,DTABADDR\n         CLC   D#NTAB,=F'0'            Addr of 1st NTAB=0 ?\n         BE    GETDEXIT                no NTAB\n         L     11,D#NTAB               1st NTAB\n*- Find the last NTAB:\n         DROP  11                      USING\n         USING NTAB,11\nTSTDNTB  CLC   N#NEXT(4),=F'0'\n         BE    TSTDEXIT                R11-> last NTAB\n         L     11,N#NEXT\n         B     TSTDNTB\n*- Last NTAB found: fill NTABADDR & TABREF:\nTSTDEXIT ST    11,NTABADDR\n         LA    11,N#NEXT\n         ST    11,TABREF               ==> TABREF\n         L     11,NTABADDR\nGETDEXIT BR    14\n*=====================================================================\n* Subroutine to get address to store new CTAB or NTAB\n* HOBOGO CTAB, DTAB ILI NTAB.\n* If not available, allocate more space\n* Enter:    R1          -> For GETNEWV Name length\n* Exit:     R14+4       -> R11= addr of NTAB element\n*           R14         -> RAM not available, table not changed\n*                          RC=NOSPACE\n*-------------------------------------------------\nGETNEWC  SAVE  (14,12)\n         LA    7,C#LENGTH              CTAB element length\n         B     GETAREA\nGETNEWD  SAVE  (14,12)\n         LA    7,D#LENGTH              DTAB element length\n         B     GETAREA\n*- NTAB element with variable name length (R1=name length):\nGETNEWV  SAVE  (14,12)\n         LA    7,N#LENGTH-8(1)         NTAB elem length and name\n         B     GETAREA\n*- Standard NTAB size:\nGETNEWN  DS    0H\nGETNEW   SAVE  (14,12)\n         LA    7,N#LENGTH              defaul element length\n*- R7=element length required. Check if space available in P#DATA:\nGETAREA  DS    0H\n         L     11,PTABADDR             Addr PTAB\n         DROP  11                      USING\n         USING PTAB,11\n*- Get free element: R7=requested length\nGETELEM  L     1,P#AFREE               R1=Addr of new element\n         LA    2,0(7,1)                Addr of end of new element\n         C     2,P#AEND                End of P#DATA\n         BH    GETERROR                P#DATA overflow\n         ST    2,P#AFREE               ==> advance P#AFREE\n*- normal exit:\nGETEXIT  SR    15,15\n         ST    1,64(13)                replace R11 by R1\n         L     3,P#CTAB\n         LTR   3,3\n         BNZ   GETEXIT0                P#CTAB exists- continue\n*- Initialize LAST*:\n         LA    3,P#CTAB\n         ST    3,LASTCTAB              Store address\n         SR    3,3\n         ST    3,LASTNTAB\nGETEXIT0 LM    14,12,12(13)\n         SR    15,15\n         B     4(14)                   normal end\n*- Error exit:\nGETERROR DS    0H\n         LA    15,NOSPACE\n         ST    15,RC\n         LM    14,12,12(13)\n         BR    14                      error exit\n         DROP  11                      USING\n*---------------------------------------------------------------------\n* C O N S T A N T S  and  D S E C T S\n*---------------------------------------------------------------------\n$CLSOFFS EQU   80                      X'50' offset of $CLOSE ep\n$REDOFFS EQU   48                      X'30' offset of $READ ep\n*A$FORT   DC    V(A31FORT)\nNULL     DC    F'0'\nVL       EQU   X'80'                   VL-BIT\nNO$OPEN  EQU   24\nNOSPACE  EQU   20\nNOTOPEN  EQU   16\nNOESD    EQU   12\nOVERLAY  EQU   8\nSCTR     EQU   12\nNOSYM    EQU   4\nMVCS     MVC   0(0,7),0(5)\nMVCN     MVC   SYMNAME(0),0(5)\nH20      DC    H'20'\nH9       DC    H'9'\nH8       DC    H'8'\nH4       DC    H'4'\nSYMTYPE  DC    C'CXBXFHEDAYSVPZL'\n#BLANKS  DC    8C' '\n         DS    0F\nMAXH     DC    X'00007FFF'             Max halfword\n         LTORG\n*---------------------------------------------------------------------\n*- PDS ENTRY:\nPDS24    DSECT\n         DS    F                       add offset 4 bytes\n         IHAPDS DSECT=NO\n*---------------------------------------------------------------------\n*- Program table:\nPTAB     DSECT\n         COPY  $PTAB\n*---------------------------------------------------------------------\n*- $OPEN parameter mapping\nD#       DSECT\nD#RC     DS    F                       return code\nD#DSN    DS    CL44                    DSNAME\nD#MEM    DS    CL8                     MEMBER\nD#VOL    DS    CL6                     VOLSER\nD#LEN    DS    H                       record length\nD#DCB    DS    F                       DCB address\nD#BUF    DS    F                       Buffer address\nD#LAST   DS    F                       Data length in buffer\nD#RECA   DS    F                       Record addr in buffer\n*---------------------------------------------------------------------\n*- Element of CTAB:\nCTAB     DSECT\n         COPY  $CTAB\n*---------------------------------------------------------------------\n*- Element of DTAB:\nDTAB     DSECT\n         COPY  $DTAB\n*---------------------------------------------------------------------\n*- Element of NTAB:\nNTAB     DSECT\n         COPY  $NTAB\n*---------------------------------------------------------------------\n*- SYM record header:\nY#       DSECT\nY#X02    DS    XL1\nY#SYM    DS    CL3'SYM'\nY#BL6    DS    CL6' '\nY#LEN    DS    XL2                     Unaligned\nY#BL4    DS    CL4' '\nY#INF    DS    0H                      Information (data)\nY#LENGTH EQU   80                      SYM record size\n*---------------------------------------------------------------------\n*- SYM element header:\nS#       DSECT\nS#ORG    DS    XL1                     element organization\nS#ADDR   DS    AL3                     relative address\nS#NAME   DS    0H                      name and other fields.\n*---------------------------------------------------------------------\n*- ESD element:\nE#       DSECT\nE#NAME   DS    CL8                     Name\nE#TYPE   DS    XL1                     Type\nE#ADDR   DS    AL3                     CSECT addr\nE#SEG    DS    XL1                     Overlay segment #\nE#LEN    DS    AL3                     Section length or\n*                                      # of free element (for EP)\nE#LENGTH EQU   *-E#                    ESD element size (16 bytes)\n*---------------------------------------------------------------------\n*- WORKAREA:\n$WRK     DSECT\n         DS    18F                     SAVEAREA\nSYMNAME  DS    CL8                     Part of SYM element\nSYMKRATN DS    F\nSYMLEN   DS    H\nSYMTYPE1 DS    X\nPARMLIST DS    5F                      Copy of parmlist\nD##ADDR  EQU   PARMLIST\nPTABADDR EQU   PARMLIST+4\n*- If module is searched by address:\nW#NAME   DS    CL8                     Name of left nearest entry\nW#ADDR   DS    A                       It's address\nW#LEN    DS    H                       Length of variable\nW#OFS    DS    H                       Variable offset from neighbor\nW#TYPE   DS    X\n         ORG   W#TYPE\nW#MLEN   DS    F                       Module name or data multiplier\n*-\nY#LENS   DS    H                       Copy of Y#LEN\nS#REST   DS    CL20                   Copy of remainder SYM for NEXTBLK\nSECTADDR DS    F\nSECTSIZE DS    F\nSECTNAME DS    CL8\nPARMNAME DS    CL8\n*- DOBABKI DL\u00f9 A31:\nLASTCTAB DS    A\nLASTNTAB DS    A\nSYMFOUND DS    F                       Flag SYM present\nCTABADDR DS    A                       Addr of current CTAB\nDTABADDR DS    A                       Addr of current DTAB or 0\nNTABADDR DS    A                       Wrk: save addr of NTAB\nSAVE14#1 DS    F                       Wrk: save R14\nTABREF   DS    A                       Addr of last .#NEXT\nRC       DS    F\nOVERFL   DS    F                       Mask to clear segment #\nSAVNTAB  DS    A\nWCNUM    DS    H\nWCSSI    DS    3X\nENDFILE  DS    X\nW#DEBUG  DS    X                       Flag debug from A3CVT\nSAVETYP  DS    X                       Save left byte\nA$OPEN   DS    A\nA$READ   DS    A\nA$CLOSE  DS    A\nRETC     DS    F\n         DS    0D\n$WRKLEN  EQU   *-$WRK                  workarea size\n         COPY  $RLD\n         COPY  $RLDATA\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='NCAL,MAP,RMOD=ANY,AMOD=31,RENT',\n//        COND=(8,LE)\n//*YSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST    <== hlq.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(A31ESD) <== *.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSN4DDN": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\x105\\x00\\xe1\\x00\\xe5\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T10:35:00", "lines": 225, "newlines": 229, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'DSN4DDN  REXX function DSN4DDN'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 02-24-2003 SVM Fixed SWAREQ call -> LOSEPAX=YES\n* 03-06-2003 SVM Changed to RMODE=ANY\n* 09-20-2002 SVM Created\n*.....................................................................\n*\n* FUNCTION:     Check if DD is allocated to a dataset.\n*               Search TIOT DD entries for DDNAME specified as a\n*               parm. If DD entry is not found, return null.\n*               If DD entry is found, get JFCB and return JFCBDSN\n*               (See also L_DDN function for more return)\n*\n* Sample use:   dsn = DSN4DDN('SYSUT1')\n*               If dsn <> '' Then /* DD found - process */\n*               Else Say 'SYSUT1 - ddname missing'\n*\n* PARAMETERS:   ddname\n*\n* OUTPUT:       R15 = 0\n*               dsname, if ddname is allocated\n*               null,   if ddname is not allocated to a dataset\n*\n* ATTRIBUTES:   REENTRANT, AMODE=31, RMODE=ANY\n*---------------------------------------------------------------------\n         EJECT\n*---------------------------------------------------------------------\nDSN4DDN  BEGIN A=31,R=31\nWRK      WORK  LV=WRKL,LOC=BELOW\n         B     START\n*\nEXIT     SR    R15,R15\n         FIN\n*--------------------\n* REGISTER EQUATES:\n* R9  -> EVALBLOCK result block\n* R10 -> IRXEFPL   parm block\n* R11 -> ENVBLOCK  environment block\n*- Set REXX environment:\nSTART    DS    0H\n         LR    R10,R1                  IRXEFPL\n         USING EFPL,R10                - parm list\n         LR    R11,R0                  ENVBLOCK\n         USING ENVBLOCK,R11            - externals\n         L     R9,EFPLEVAL\n         L     R9,0(R9)                EVALBLOCK\n         USING EVALBLOCK,R9            - result\n* get parm #1 (DDNAME)\n         LA    R2,1                    Ask for parm #1\n         BAL   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LTR   R4,R4\n         BZ    EMPTY\n         BCTR  R4,0                    length - 1\n         MVC   DDNAME,=8C' '\n         EX    R4,MVCDDN               copy parm to DDNAME\n*- locate 1st TIOT DD-entry\n         L     R15,CVTPTR\n         USING CVT,R15\n         L     R15,CVTTCBP\n         L     R15,PSATOLD-PSATNEW(R15)\n         USING TCB,R15\n         L     R15,TCBTIO\n         USING TIOT1,R15\n         LA    R15,TIOENTRY           1st DD-entry\n         ST    R15,TIOE1              save it\n         DROP  R15\n*- search for DDNAME in TIOT DD entries:\n         L     R4,TIOE1\nDDLOOP   SR    R7,R7\n         IC    R7,0(R4)                 DDentry length\n         LTR   R7,R7                    If = 0\n         BZ    EMPTY                    Not found\n         CLC   DDNAME,4(R4)\n         BE    FOUND                    does match\nNEXTDD   LA    R4,0(R7,R4)              Advance to next TIOT DD entry\n         B     DDLOOP\n*\n*- Match found: locate JFCB using SWAREQ:\nFOUND    DS    0H\n         LA    R5,EPA                  GET ADDRESS OF THE EPA\n         ST    R5,SWEPAPTR             INITIALIZE EPA POINTER\n         USING ZB505,R5                ESTABLISH ADDRESSABILITY TO EPA\n         XC    SWAEPAX,SWAEPAX         INITIALIZE THE EPA\n         MVC   SWVA,12(R4)             MV SVA OF JFCB INTO EPA\n         SWAREQ FCODE=RL,EPA=SWEPAPTR,MF=(E,SWAPARMS),UNAUTH=YES\n         L    R6,SWBLKPTR              POINT TO THE JFCB\n         USING JFCB,R6                 ADDRESS JFCB\n         MVC   DSNAME(44),JFCBDSNM     save dsn\n         B     RETDSN                  Leave\n*\n         DROP  R6\n         DROP  R5\n*\n*---------------------------------------------------------------------*\n* Return parameter as a result:                                       *\n*    (std length of EVDATA is 250 bytes, to replace EVALBLOCK,        *\n*    call IRXRLT and put new address into EFLEVAL)                    *\n*---------------------------------------------------------------------*\n*\nEMPTY    SR    R4,R4\n         ST    R4,EVALBLOCK_EVLEN      Store Result length\n         B     EXIT\n*\nRETDSN   DS    0H\n         LA    R4,DSNAME+1             2nd char\n         LA    R2,1                    increment\n         LA    R3,DSNAME+L'DSNAME-1    Last char\nLOOP     CLI   0(R4),C' '\n         BE    CUT\n         BXLE  R4,R2,LOOP\n* R4-> blank or next char after DSN\nCUT      LA    R2,DSNAME+1\n         SR    R4,R2                   length(DSN) - 1\n         EX    R4,MVCDSN               Move parm text to result\n         LA    R4,1(R4)                length(DSN)\n         ST    R4,EVALBLOCK_EVLEN      Store Result length\n         B     EXIT\n*---------------------------------------------------------------------*\n*        S U B R O U T I N E S                                        *\n*---------------------------------------------------------------------*\n* GET input parameter (addr,length) by number:                        *\n*    entry :  R2=parm # (not changed)                                 *\n*    use   :  R15 (return 0, when parm is found)                      *\n*    return:  to R14, R3=parm addr, R4=parm length (0, if not found)  *\n*---------------------------------------------------------------------*\nGETPARM  DS    0H\n         LR    R15,R2\n         SR    R4,R4                   make length zero\n         L     R3,EFPLARG              A(1st parm)\n         B     GETPL1                  go into loop\nGETPL    LA    R3,8(R3)                next parm\nGETPL1   CLC   0(8,R3),PARMEND\n         BER   R14                     not found\n         BCT   R15,GETPL\n* parm found:\n         L     R4,4(R3)                parm length\n         L     R3,0(R3)                parm addr\n         BR    R14\n*=====================================================================*\n*        CONSTANTS                                                    *\n*---------------------------------------------------------------------*\n         DS    0F\nPARMEND  DC    8X'FF'\nSWAPARMC SWAREQ MF=L,FCODE=RL\nLSWA     EQU   *-SWAPARMC\nMVCDDN   MVC   DDNAME(0),0(R3)              move parm to DDNAME\nMVCDSN   MVC   EVALBLOCK_EVDATA(0),DSNAME   move DSNAME to return buf\n         LTORG\n         EJECT\n*---------------------------------------------------------------------*\n*        LOCAL WORK AREA                                              *\n*---------------------------------------------------------------------*\n         SPACE 1\nWRK      DSECT\nWRKSAVE  DS    18F                     REGISTER SAVE AREA\nTIOE1    DS F\nSWEPAPTR DS F\nDSNAME   DS    CL44\nDDNAME   DS    CL8\nSWAPARMS SWAREQ MF=L\nEPA      DS    CL28                    Appears to use 26 bytes...\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         EJECT\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\n         REGS\n* REXX specific DSECTs:\n         IRXEFPL DSECT=YES             REXX parameter list\n         IRXEVALB                      REXX evaluation block EVALBLOCK\n         IRXEXTE                       REXX vector of external ep\n         IRXENVB                       REXX environment block ENVBLOCK\n* SYSTEM SPECIFIC DSECTS:\n         CVT DSECT=YES\n         IEFJESCT\n         PRINT GEN\n         IEFZB505 LOCEPAX=YES\nTIOT     DSECT\n         IEFTIOT1\n         PRINT NOGEN\n         IKJTCB  DSECT=YES\n         IHAPSA\nJFCB     DSECT\n         IEFJFCBN\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='CALL,MAP,RENT,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(DSN4DDN) <==*.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* test changes, if any:\n//GO      EXEC PGM=IRXJCL,COND=(8,LE),\n//        PARM='PW'\n//SYSEXEC  DD DSN=SYS3.UTILITY.EXEC.SHARE,DISP=SHR         <== hlq.EXEC\n//STEPLIB  DD DSN=SYS3.UTILITY.LOADLIB.TEST,DISP=SHR       <== hlq.LOAD\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSUDUMP DD SYSOUT=*\n//ABNLIGNR DD DUMMY                                  <== Disable CW AA\n//TEMPL    DD *\n Say 'DSN4DDN('TEMPL')='||DSN4DDN('TEMPL')\n Say 'DSN4DDN('MISSING')='||DSN4DDN('MISSING')\n Say \"DSN4DDN('')=\"||DSN4DDN('')\n Say 'DSN4DDN()='||DSN4DDN()\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRX@MGCR": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\x08F\\x00\\x94\\x00\\x95\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T08:46:00", "lines": 148, "newlines": 149, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program IRX@MGCR\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST  <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'IRX@MGCR Linked subroutine to do MGCR macro from REXX'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 02-13-2003 SVM Created\n*.....................................................................\n*\n* FUNCTION:\n*               Issue a parameter text as a console\n*                  REPLY or START command\n*\n* Sample use:   REXX: ADDRESS TSO \"CALL *(pgmname) '\"command\"'\"\n*               JCL:  // EXEC PGM=IRX@MGCR,PARM='command'\n*               command must be up to 90 chars long\n*\n* INPUT:\n*               Std EXEC PARM: R1->addr->(len,text)\n* OUTPUT:\n*               R15 = 0\n* ATTRIBUTES:\n*               REENTRANT, R=24, A=31, APF-authorised, TSO-authorised\n*               (place to load lib that is in LINKLIST\n*               and include the pgm name to AUTHPGM list in IKJTSO00)\n*---------------------------------------------------------------------\n         EJECT\n*---------------------------------------------------------------------\nIRX@MGCR BEGIN R=24\nWRK      WORK  LV=WRKL\n         B     START\nEXIT     L     R15,RC\n         FIN\n*---------------------------------------------------------------------\nSTART    DS    0H\n         XC    RC(4),RC\n         L     R10,0(R1)               - parm addr\n         LH    R4,0(R10)               - parm length\n         STH   R4,PARMLEN              save\n         LA    R3,2(R10)               - parm text\n         ST    R3,PARMTXTA             save\n*---------------------------------------------------------------------*\n*  Get Master Console CNID\n*---------------------------------------------------------------------*\n         L     R2,16                   CVT\n         USING CVT,R2\n         L     R3,CVTCUCB              UCMBASE\n         USING UCM,R3\n         LR    R4,R3\n         AH    R4,=H'-4'               GO BACK 4 SPACES\n         L     R4,0(R4)                UCM PREFIX\n         USING UCMPRFX,R4\n         XR    R15,R15\n         USING UCMLIST,R14\n         IC    R15,UCMID               GET THE CONSOLE ID\n         STH   R15,MASTCONS\n*---------------------------------------------------------------------*\n*   Make PARM for MGCR\n*---------------------------------------------------------------------*\n         LH    R4,PARMLEN\n         L     R3,PARMTXTA\n         LTR   R5,R4\n         BZ    EXIT                    no parm - no action\n         LA    R5,4(R5)                length + 4\n         STH   R5,REPLYCMD             clear flags1 and set length\n         XC    REPLYCMD+2(2),REPLYCMD+2 clear flags2\n         MVC   REPLYTXT(90),#BLANKS    clear REPLYCMD\n         BCTR  R5,0                    length-1 for MVC\n         EX    R5,MVCPARM              copy text\n*\n*  Authorised code:\n*\n         MODESET MODE=SUP,KEY=ZERO\n         LH     R0,MASTCONS\n         LA     R1,REPLYCMD\n         SVC    34                       ISSUE SVC 34 (MGCR)\n         MODESET KEY=NZERO,MODE=PROB\n*\n*  :End of authorised code\n*\n         B      EXIT\n*=====================================================================*\n*        CONSTANTS                                                    *\n*---------------------------------------------------------------------*\n         DS    0F\nMVCPARM  MVC   REPLYTXT(1),0(R3)        PARM to REPLYCMD\n#BLANKS  DC    CL90' '                  MESSAGE TEXT\n         LTORG\n         EJECT\n*---------------------------------------------------------------------*\n*        LOCAL WORK AREA                                              *\n*---------------------------------------------------------------------*\n         SPACE 1\nWRK      DSECT\nWRKSAVE  DS    18F                     REGISTER SAVE AREA\nRC       DS    F                       RC to return in R15\n* command buffer for MGCR: mapped by IEZMGCR DSECT\n         DS    0F\nREPLYCMD DC    H'0',H'0'     REAL LENGTH, ZERO\nREPLYTXT DC    CL90' '\nREPLYLEN EQU   *-REPLYCMD          Length of command buffer\n*\nDSCODES  DS    XL4\nMASTCONS DS    H\nPARMLEN  DS    H\nPARMTXTA DS    A\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         EJECT\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\n         PUSH  PRINT\n         PRINT NOGEN\n         REGS\n         CVT   DSECT=YES,LIST=NO\n         IHAORE\n* UCM, UCMPRFX, UCMLIST(?)\nUCM      DSECT\n         IEECUCM LIST=NO\n         IHAWQE\n         IHAPSA\n         POP   PRINT\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='CALL,MAP,RENT,AC=1,RMOD=24,AMOD=31',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LINKLIB(IRX@MGCR)  <== LINKLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//\n//* Before running this test, refresh LLA (F LLA,REFRESH) !\n//*\n//GO      EXEC PGM=IRX@MGCR,COND=(8,LE),\n//        PARM='R 10,U'\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXF@ALC": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x01\\x03\\x06/\\x01\\x03!\\x8f\\t0\\x01\\x83\\x01k\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2003-03-03T00:00:00", "modifydate": "2003-08-06T09:30:00", "lines": 387, "newlines": 363, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'IRXF@ALC REXX function L_ALC and L_FRE'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 07-10-2003 SVM Added WTP if IRXSAY not available (in OPS)\n* 03-03-2002 SVM Created\n*.....................................................................\n*\n* FUNCTION:     Same as\n*               \"TSO ALLOC DA('\"dsn\"') FI('\"ddn\"') VOLUME('\"vol\"') SHR\"\n*               Can be used outside TSO environment.\n*\n* SAMPLE USE:   dsn = 'MY.DATA.SET(MEMBER)'\n*               If L_ALC(ddname,dsname)\n*               Then Do\n*                  /* process ddname */\n*                  Call L_FRE(ddname)\n*               End\n*               Else Say 'Error opening data set'\n*\n* Parameters:   ddn,dsn,vol\n*               ddn - required, specifies to what ddname allocate\n*                     the dataset.\n*               dsn - required, full dataset name to be allocated.\n*                     Can include PDS member name.\n*                     No apostrophes allowed.\n*                     No HLQ will be added to the dsn.\n*               vol - optional. If omitted, will locate by a catalog.\n*               Dataset will be allocated with DISP=SHR.\n*\n* Return:       If error:\n*                    Say error/warning message,\n*               n/a: R15>0 - \"Incorrect call to procedure\"\n*                    result = '0' datatset was not allocated\n*               If allocated,\n*                    result = '1' normal execution response\n*\n* Attributes:   Reus, reentrant, AMODE=31,RMODE=ANY\n*\n* Externals:    SVMALC6 (used by LOAD and CALL)\n*--------------------------------------------------------------------\nWRK      DSECT\n         DS    18F\nSVMPAR6  DS    0F\n         SVMPAR6\nTLEN     EQU   *-SVMPAR6\nRETC     DS    F\nENVBLKA  DS    A\nDSNLEN   DS    H\nLTDSN    EQU   L'TDSN\nDDNLEN   DS    H\nLTDDN    EQU   L'TDDN\nVOLLEN   DS    H\nLTVOL    EQU   L'TVOL\nEPADDR   DS    A\nMSGLEN   DS    H                       For WTP\nMSG      DS    CL40                    MSG length must be ERRMSGL\n* parm for IRXSAY:\nA1       DS    A\nA2       DS    A\nA3       DS    A\nA4       DS    A\nA5       DS    A\nP1       DS    CL8                     function requested\nP2       DS    A                       addr os data\nP3       DS    F                       length of data\nP4       DS    A                   IRXENVB optional, R0 is alternative\nP5       DS    A                       RC and VL bit\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         REGS\n*--------------------------------------------------------------------\nIRXF@ALC BEGIN A=31\n         SR    R6,R6                   indicate L_ALC\n         B     COMMON\n         ENTRY IRXF@FRE\nOFFSET   EQU   *-IRXF@ALC\nIRXF@FRE SAVE  (14,12)\n         LA    R6,4                    indicate L_FREE\n         LA    R3,OFFSET\n         LR    R12,R15\n         SR    R12,R3                  set base to IRXF@LOC\n*\nCOMMON   DS    0H                      common continuation\nWRK      WORK  LV=WRKL,LOC=BELOW\n         B     START\n*\nFIN      L     R3,EPADDR\n         LTR   R3,R3\n         BZ    FIN0\n         DELETE EP=SVMALC6\n         LTR   R15,R15\n         BZ    FIN0\nFIN0     SR    R15,R15\n**       L     R15,RETC\n         FIN\n*--------------------\n* REGISTER EQUATES:\n* R6  -> entry type (0 = L_ALC, else - L_FREE\n* R9  -> EVALBLOCK result block\n* R10 -> IRXEFPL   parm block\n* R11 -> ENVBLOCK  environment block\n*--------------------------------------------------------------------\n*- Set REXX environment:\nSTART    DS    0H\n         ST    R0,ENVBLKA              save it\n         LR    R10,R1                  IRXEFPL\n         USING EFPL,R10                - parm list\n         LR    R11,R0                  ENVBLOCK\n         USING ENVBLOCK,R11            - externals\n         L     R9,EFPLEVAL\n         L     R9,0(R9)                EVALBLOCK\n         USING EVALBLOCK,R9            - result\n*        LA    R8,SHVBLK\n*        USING SHVBLOCK,R8             - to set variables\n*        BAL   R14,SETSHV\n* Set response = 1 (as a default)\n         MVI   EVALBLOCK_EVDATA,C'1'   return 1\n         LA    R7,1\n         ST    R7,EVALBLOCK_EVLEN\n         SR    R7,R7\n         ST    R7,EPADDR               clear\n         ST    R7,RETC                 clear\n         XC    SVMPAR6(TLEN),SVMPAR6   clear\n         MVC   TDDN(LTDDN),#BLANKS     clear\n         MVC   TDSN(LTDSN),#BLANKS     Clear\n         MVC   TVOL(LTVOL),#BLANKS     Clear\n*--------------------------------------------------------------------\n* Read parameter 1 (ddname), if no - error\n*--------------------------------------------------------------------\n*      WTO 'Reading ddname...',ROUTCDE=11\n         LA    R2,1\n         BAL   R14,GETPARM             R3=addr, R4=length\n         LA    R5,#ERR12\n         LTR   R4,R4\n         BZ    ERROR                   no ddn passed\n         C     R4,LLTDDN\n         BH    ERROR                   too long\n         STH   R4,DDNLEN               save ddn length\n         BCTR  R4,R0\n         EX    R4,#MOVDDN              copy ddn\n*\n         LTR   R6,R6\n         BNZ   PROCESS\n*--------------------------------------------------------------------\n*  Read parameter 2 (dsname), if no - error\n*--------------------------------------------------------------------\n*      WTO 'Reading dsname...',ROUTCDE=11\n         LA    R2,2\n         BAL   R14,GETPARM             R3=addr, R4=length\n         LA    R5,#ERR11\n         LTR   R4,R4\n         BZ    ERROR                   no dsn passed\n         C     R4,LLTDSN\n         BH    ERROR                   too long\n         STH   R4,DSNLEN               save dsn length\n         MVC   TDSN(LTDSN),#BLANKS\n         BCTR  R4,R0\n         EX    R4,#MOVDSN              copy dsn\n*--------------------------------------------------------------------\n* Read parameter 3 (volume), if no - pass blanks\n*--------------------------------------------------------------------\n*      WTO 'Reading volume...',ROUTCDE=11\n         SR    R4,R4\n         ST    R4,VOLLEN               set to 0\n         LA    R2,3\n         BAL   R14,GETPARM             R3=addr, R4=length\n         LA    R5,#ERR13\n         LTR   R4,R4\n         BZ    PROCESS                 no vol passed\n         C     R4,LLTVOL\n         BH    ERROR                   too long\n         STH   R4,VOLLEN               save vol length\n         BCTR  R4,R0\n         EX    R4,#MOVVOL              copy vol\n*\nPROCESS  DS    0H\n*      WTO 'Loading SVMALC6...',ROUTCDE=11\n         LOAD  EP=SVMALC6,ERRET=LOADERR\n         ST    R0,EPADDR\n         LR    R1,R0\n         LTR   R6,R6\n         BZ    CONT2\n         LA    R1,DELOFFS(R1)\n         ST    R1,EPADDR\nCONT2    LA    R1,SVMPAR6              store SVMDEL6\n**       CALL  SVMALC6 or SVMDEL1\n         L     R15,EPADDR\n         BASSM R14,R15\n         LTR   R15,R15\n         LA    R5,#ERR3\n         BNZ   ERROR\n*  Call successful:\n         B     EXIT\n*--------------------------------------------------------------------\n* EXIT:\n*--------------------------------------------------------------------\n* Normal exit:\nEXIT     DS    0H\n*      WTO 'Normal end...',ROUTCDE=11\n         B     FIN\n*\n* Error exit:\nLOADERR  DS    0H\n         LA    R5,#ERR2                Load error\nERROR    DS    0H\n*      WTO 'Error...',ROUTCDE=11\n         USING ERRBLK,R5\n         MVC   RETC(4),ERRCODE\n         MVC   MSG(ERRMSGL),ERRMSG\n         LTR   R6,R6\n         BZ    ERROR1\n         MVC   MSG(L'#PREFIX),#PREFIX  change prefix to L_FRE\n* make parm for IRXSAY:\nERROR1   MVC   P1(8),=CL8'WRITE'       function request\n         LA    R1,MSG\n         ST    R1,P2                   string addr\n         LA    R1,ERRMSGL\n         ST    R1,P3                   string length\n         ST    R11,P4                  ENVBLOCK\n         XC    P5(4),P5                clear RC\n         DROP  R5\n* make addr list:\n         LA    R1,P1\n         ST    R1,A1\n         LA    R1,P2\n         ST    R1,A2\n         LA    R1,P3\n         ST    R1,A3\n         LA    R1,P4\n         ST    R1,A4\n         LA    R1,P5\n         ST    R1,A5\n         OI    A5,X'80'                set VL bit\n* call program:\n         LA    R1,A1                   parm list addr\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXSAY              addr IRXSAY\n         DROP  R15\n         LTR   R15,R15\n         BZ    NOSAY\n         BALR  R14,R15                 Call IRXSAY\n         B     RESPOND\n* WTP message instead of Saying:\nNOSAY    LA    R1,MSGLEN\n         ST    R1,A1\n         OI    A1,X'80'\n         LA    R1,ERRMSGL\n         STH   R1,MSGLEN\n         LA    R1,A1\n         CALL  WTP\n*\n* Set Response to '0':\nRESPOND  MVI   EVALBLOCK_EVDATA,C'0'   return 1\n         LA    R1,1\n         ST    R1,EVALBLOCK_EVLEN\n         B     FIN\n*--------------------------------------------------------------------\n*  Subroutines:\n*---------------------------------------------------------------------*\n* GET input parameter (addr,length) by number:                        *\n*    entry :  R2=parm # (not changed)                                 *\n*    use   :  R15 (return 0, when parm is found)                      *\n*    return:  to R14, R3=parm addr, R4=parm length (0, if not found)  *\n*---------------------------------------------------------------------*\nGETPARM  DS    0H\n         LR    R15,R2\n         SR    R4,R4                   make length zero\n         L     R3,EFPLARG              A(1st parm)\n         B     GETPL1                  go into loop\nGETPL    LA    R3,8(R3)                next parm\nGETPL1   CLC   0(8,R3),PARMEND\n         BER   R14                     not found\n         BCT   R15,GETPL\n* parm found:\n         L     R4,4(R3)                parm length\n         L     R3,0(R3)                parm addr\n         BR    R14\n*--------------------------------------------------------------------\n*  Constants:\n*\n#PREFIX  DC    C'L_FRE:'\nDELOFFS  EQU   40                      Offset for EP=SVMDEL6\nLLTDSN   DC    A(LTDSN)\nLLTDDN   DC    A(LTDDN)\nLLTVOL   DC    A(LTVOL)\nPARMEND  DC    8X'FF'\n#MOVDSN  MVC   TDSN(0),0(R3)\n#MOVDDN  MVC   TDDN(0),0(R3)\n#MOVVOL  MVC   TVOL(0),0(R3)\n#BLANKS  DC    CL54' '\n*  Error messages: MSG length must be ERRMSGL\n#ERR11   DC    F'12'                   No parm\n         DC    CL40'L_ALC: Error - DSNAME missing/invalid  '\n#ERR12   DC    F'12'                   No parm\n         DC    CL40'L_ALC: Error - DDNAME missing/invalid  '\n#ERR13   DC    F'12'                   No parm\n         DC    CL40'L_ALC: Error - VOLUME serial invalid   '\n#ERR2    DC    F'12'                   No SVMALC6\n         DC    CL40'L_ALC: Error - SVMALC6 cannot be LOADed'\n#ERR3    DC    F'00'                   Dynalloc failed\n         DC    CL40'L_ALC: Warning - DYNALLOC failed       '\n         LTORG\n*--------------------------------------------------------------------\n* Mapping:\n*--------------------------------------------------------------------\nERRBLK   DSECT\nERRCODE  DS    F\nERRMSG   DS    CL40\nERRMSGL  EQU   *-ERRMSG\n         IRXEFPL DSECT=YES             REXX parameter list\n         IRXEVALB                      REXX evaluation block EVALBLOCK\n         IRXEXTE                       REXX vector of external ep\n         IRXENVB                       REXX environment block ENVBLOCK\n         END   IRXF@ALC\n//*\n//LKED    EXEC PGM=HEWLKED,\n//        PARM='RENT,CALL,MAP,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//         DD  *\n     ALIAS IRXF@FRE\n     NAME  IRXF@ALC(R)\n//*\n//* test changes, if any:\n//*O      EXEC PGM=IKJEFT1B,COND=(8,LE),\n//*       PARM='%PW'\n//GO      EXEC PGM=IRXJCL,COND=(8,LE),\n//        PARM='PW'\n//SYSEXEC  DD DSN=SYS3.UTILITY.EXEC.SHARE,DISP=SHR   <== hlq.EXEC\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//         DD DISP=SHR,DSN=SYS3.UTILITY.LINKLIB      <== IRXFLOC lib\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//ABNLIGNR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//SNAP     DD SYSOUT=*\n//TEMPL    DD *\n ifile = 'TESTDD'\n idsn = 'SYS3.UTILITY.PS.TEST'\n ivol='RAMC15'\n x = IRXF@ALC()\n    Say 'IRXF@ALC() response =' x\n x = IRXF@ALC(idsn)\n    Say 'IRXF@ALC(longddn) response =' x\n x = IRXF@ALC(ifile,idsn||idsn||idsn||idsn)\n    Say 'IRXF@ALC(ifile,longdsn) response =' x\n x = IRXF@ALC(ifile,idsn,ivol)\n    Say 'IRXF@ALC(correct) response =' x\n    \"EXECIO * DISKR\" ifile \"(STEM inrec. FINIS\"\n    Say inrec.0 'records read from' ifile\n    Do i = 1 To inrec.0\n    /* Say inrec.i */\n       End\n    x = IRXF@FRE()\n    Say 'IRXF@FRE() response =' x\n    x = IRXF@FRE(ifile)\n    Say 'IRXF@FRE(ifile) response =' x\n idsn='SYS3.UTILITY.MACLIB.TEST(SVMPAR6)'\n x = IRXF@ALC(ifile,idsn)\n    Say 'IRXF@ALC(dsn(mem)) response =' x\n    \"EXECIO * DISKR\" ifile \"(STEM inrec. FINIS\"\n    Say inrec.0 'records read from' ifile\n    Do i = 1 To inrec.0\n    /* Say inrec.i */\n       End\n    x = IRXF@FRE(ifile)\n    Say 'IRXF@FRE(ifile) response =' x\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXF@DDN": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\t\\x01\\x02>\\x01\\xcc\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T09:01:00", "lines": 574, "newlines": 460, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'IRXF@DDN REXX function L_DDN'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 07-10-2003 SVM Added WTP if IRXSAY not available (in OPS)\n* 05-16-2003 SVM Added SYSMEMBER for dsn(member)\n* 05-02-2003 SVM Added 4-digit unit processing\n* 04-24-2003 SVM Added Say error msg\n* 02-25-2003 SVM Fixed SWAREQ call -> LOSEPAX=YES  )\n*                    Added limited processing for non-dasd\n* 01-03-2003 SVM Created using SVM0025 (old LISTDDN)\n*.....................................................................\n*\n* FUNCTION:     Create a limited number of LISTDSI variables.\n*               Variables that have no data will be cleared to null.\n*               (See TSO/E REXX Reference. TSO/E External functions\n*               for the variables names).\n*               SYSRACFA is assigned RACF access available for the\n*               owner of the job/task executing this function.\n*               SYSUTYPE is assigned to unit type (DISK, TAPE).\n*               Works outside TSO environment.\n*               Works with either disk and/or tape datasets.\n*\n* Sample use:   If L_DDN('SYSUT1') Then\n*                  /* use returned variables */\n*\n* PARAMETERS:   ddname\n*           or  DDNAME+n    n - number in DD concatenation\n*\n* OUTPUT:       R15 = 0\n*               Result = 1 - normal end\n*               Result = 1 - normal end\n*               Result = 0 (all vars cleared)\n*                  - no parm\n*                  - ddname not found\n*\n* ATTRIBUTES:   REENTRANT, AMODE=31, RMODE=ANY\n*\n* EXTERNALS:    SVM0033 - shared with IRXF@DSN common module\n*                         that sets up REXX variables\n*---------------------------------------------------------------------\n         EJECT\n*---------------------------------------------------------------------\n.* Macro to help clear variable: &N is a name of var name constant\n         MACRO\n         STORE &N,&C=SHVSTORE\n         AIF   ('&N' EQ '').NON\n         LA    R1,&N\n         ST    R1,SHVNAMA               --> store name addr\n         LA    R1,L'&N\n         ST    R1,SHVNAML               --> Store name length\n         MVI   SHVCODE,&C               --> Set \"store\" code\n         BAL   R14,CALLXCOM             - create variable\n.NON     ANOP\n         MEND\n*\nIRXF@DDN  BEGIN A=31,R=31                                                0000062\nWRK      WORK  LV=WRKL,LOC=BELOW\n         B     START\n*\nEXIT     SR    R15,R15\n         FIN\n*--------------------\n* REGISTER EQUATES:\n* R6  -> JFCB\n* R7  -> TIOT entry\n* R8  -> SHVBLOCK\n* R9  -> EVALBLOCK result block\n* R10 -> IRXEFPL   parm block\n* R11 -> ENVBLOCK  environment block\n*---------------------------------------------------------------------\n*- Set REXX environment:\nSTART    DS    0H\n         ST    R0,ENVBLKA              save it\n         LR    R10,R1                  IRXEFPL\n         USING EFPL,R10                - parm list\n         LR    R11,R0                  ENVBLOCK\n         USING ENVBLOCK,R11            - externals\n         L     R9,EFPLEVAL\n         L     R9,0(R9)                EVALBLOCK\n         USING EVALBLOCK,R9            - result\n         LA    R8,SHVBLK\n         USING SHVBLOCK,R8             - to set variables\n         BAL   R14,SETSHV\n         MVI   EVALBLOCK_EVDATA,C'1'   Store result value\n         LA    R4,1\n         ST    R4,EVALBLOCK_EVLEN      Store Result length\n*---------------------------------------------------------------------*\n*- Init all variables to '', drop SYSDDNAME:\n*---------------------------------------------------------------------*\n*        WTO   'Clearing Variables...',ROUTCDE=11\n         BAL   R14,CLEAR\n* get parm #1 (DDNAME)\n         LA    R2,1                    Counter in ddname+n\n         BAL   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LA    R15,#ERR1\n         LTR   R4,R4\n         BZ    ERROR                   no parm passed\n         BAL   R14,SPLITDD             R4=new length, R2=# of DD\n         ST    R4,DDLEN\n         BCTR  R4,0                    length - 1\n         MVC   DDNAME,=8C' '\n         EX    R4,MVCDDN               copy parm to DDNAME\n         MVC   DDN(8),DDNAME           === store DDNAME ===\n*---------------------------------------------------------------------*\n*- locate 1st TIOT DD-entry and lookup\n*---------------------------------------------------------------------*\n*        WTO   'Searching TIOT...',ROUTCDE=11\n         XC    EPA,EPA\n         L     R15,CVTPTR\n         USING CVT,R15\n         L     R15,CVTTCBP\n         L     R15,PSATOLD-PSATNEW(R15)\n         USING TCB,R15\n         L     R15,TCBTIO\n         USING TIOT1,R15\n         LA    R15,TIOENTRY            1st DD-entry\n         ST    R15,TIOE1               save it\n         DROP  R15                     USING\n*- search for DDNAME in TIOT DD entries: R1=0 or DD number in DD concat\n         L     R7,TIOE1\nDDLOOP   SR    R4,R4\n         IC    R4,0(R7)                 DDentry length\n         LA    R15,#ERR2\n         LTR   R4,R4                    If = 0\n         BZ    ERROR                    DD not found\n         CLC   DDNAME,4(R7)\n         BNE   NEXTDD                   Iterate\n         LTR   R2,R2\n         BZ    RDDN                     no number -> found\n         MVC   DDNAME(8),#BLANKS        now look for blanks\n         BCTR  R2,0                     drop counter by 1\nNEXTDD   LA    R7,0(R4,R7)              Advance to next TIOT DD entry\n         B     DDLOOP\n*\n*---------------------------------------------------------------------*\n* Return zero or non-zero RC:\n*---------------------------------------------------------------------*\n*\n*\n*---------------------------------------------------------------------*\n* Assign dataset variables: R7 -> TIOT DD entry,\n*---------------------------------------------------------------------*\n*- DDNAME FOUND: Store VOLSER and UNIT, Return SYSDDNAME:\nRDDN     DS    0H\n*        WTO   'RDDN...',ROUTCDE=11\n         SR    R4,R4\n         ICM   R4,7,17(R7)              R4 -> Tiot Unit addr\n         USING UCBOB,R4\n         MVC   UTYPE(4),UCBTYP          Copy UCBTYP\n         MVC   VOL(6),UCBVOLI           === Store VOL ===\n         CLC   UCBWGT+1(3),=C'UCB'      Check for 4-digit UNIT\n         BE    FOURDGTS                 yes\n         MVC   UNIT(4),UCBWGT           === Store UNIT ===\n         MVI   UNIT,C'0'\n         B     LOCJFCB\nFOURDGTS UNPK  D(5),UCBCHAN(3)          take 4-digit address\n         MVC   UNIT(4),D                === store UNIT ===\n         DROP  R4                       USING\n*---------------------------------------------------------------------\n*- Locate JFCB (set R6) using SWAREQ:\nLOCJFCB  DS    0H\n*        WTO 'Locating JFCB...',ROUTCDE=11\n         LA    R5,EPA                  GET ADDRESS OF THE EPA\n         ST    R5,SWEPAPTR             INITIALIZE EPA POINTER\n         USING ZB505,R5                ESTABLISH ADDRESSABILITY TO EPA\n         XC    SWAEPAX,SWAEPAX         INITIALIZE THE EPA\n         MVC   SWVA,12(R7)             MV SVA OF JFCB INTO EPA\n         SWAREQ FCODE=RL,EPA=SWEPAPTR,MF=(E,SWAPARMS),UNAUTH=YES\n         L     R6,SWBLKPTR             POINT TO THE JFCB\n         USING JFCB,R6                 ADDRESS JFCB\n         MVC   DSN(44),JFCBDSNM        Store DSN\n         DROP  R5                      USING\n         DROP  R6                      USING\n*---------------------------------------------------------------------*\n*- Call SVM0033 to set up variables:\n         LA    R1,DDN\n         ST    R1,P1\n         LA    R1,DSN\n         ST    R1,P2\n         LA    R1,UNIT\n         ST    R1,P3\n         LA    R1,VOL\n         ST    R1,P4\n         LA    R1,UTYPE\n         ST    R1,P5                   no VL\n         ST    R6,P6                   JFCB addr\n         LA    R1,P1\n         L     R0,ENVBLKA\n         CALL  SVM0033                 Set all variables\n         B     EXIT\n*=====================================================================*\n*        S U B R O U T I N E S                                        *\n*---------------------------------------------------------------------*\n* Clear (empty) all variables:\n*---------------------------------------------------------------------*\nCLEAR    ST    R14,SAV2R14\n         LA    R3,DDNAME\n         ST    R3,SHVVALA               --> store value addr\n         SR    R1,R1                    set value length = 0\n         ST    R1,SHVVALL               --> store value length\n         STORE #DSN\n         STORE #MEMNM\n         STORE #VOL\n         STORE #UNIT\n         STORE #DSORG\n         STORE #RECFM\n         STORE #LRECL\n         STORE #BLKSI\n         STORE #KEYLE\n         STORE #UNITS\n         STORE #PRIMA\n         STORE #SECND\n         STORE #DIRBA\n         STORE #DIRBU\n         STORE #MEMBS\n         STORE #CRDT\n         STORE #EXPDT\n         STORE #REFD\n         STORE #EXTEN\n         STORE #PASSW\n         STORE #RACF\n         STORE #UPDAT\n         STORE #UTYPE\n* Set SYSDDNAME:\n         STORE #DDN,C=SHVDROPV          --> DROP SYSDDNAME\n         L     R14,SAV2R14\n         BR    R14\n*---------------------------------------------------------------------*\n* Set IRXEXCOM parameters:\n*---------------------------------------------------------------------*\nSETSHV   DS    0H\n* (re)make addr list:\n         LA    R1,#EXCOM\n         ST    R1,A1                   A1 = Addr of module name\n         XC    A2(8),A2                clear A2 and A3\n         LA    R1,SHVBLK\n         ST    R1,A4                   A4 -> SHVBLOCK\n         OI    A4,X'80'                set VL bit\n* (re)fill SHVBLOCK:\n         XC    SHVNEXT(SHVBLEN),SHVNEXT clear it all\n         BR    R14\n*--------------------------------------------------------------------*\n* Call IRXEXCOM:\n*--------------------------------------------------------------------*\nCALLXCOM ST    R14,SAVER14\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXEXCOM            addr IRXEXCOM\n         DROP  R15                     USING\n         LA    R1,A1                   parm list addr\n         LR    R0,R11                  point to ENVBLOCK\n         BALR  R14,R15                 Call IRXEXCOM\n         ST    R15,SAVERC              save return code\n         L     R14,SAVER14             restore return address\n         BR    R14\n*---------------------------------------------------------------------*\n* Strip number left: value: D, length: R1.\n*    Set R1 to new length, set R2 to new addr\n*---------------------------------------------------------------------*\nSTRIPL   STM   R3,R5,WRKSAVE2\n         LA    R2,D                     start with 1st char\n         LA    R5,1                     Min result length\n         LNR   R4,R5                    Increment = -1\nLOOPN    CLI   0(R2),C'0'\n         BNE   CUTN\n         LA    R2,1(R2)                 put start to next char\n         BXH   R1,R4,LOOPN              cut length by 1\n*  R2-> leftmost non-zero, R1 = new length\nCUTN     LM    R3,R5,WRKSAVE2\n         BR    R14\n*---------------------------------------------------------------------*\n* GET input parameter (addr,length) by number:                        *\n*    entry :  R2=parm # (not changed)                                 *\n*    use   :  R15 (return 0, when parm is found)                      *\n*    return:  to R14, R3=parm addr, R4=parm length (0, if not found)  *\n*---------------------------------------------------------------------*\nGETPARM  DS    0H\n         LR    R15,R2\n         SR    R4,R4                   make length zero\n         L     R3,EFPLARG              A(1st parm)\n         B     GETPL1                  go into loop\nGETPL    LA    R3,8(R3)                next parm\nGETPL1   CLC   0(8,R3),PARMEND\n         BER   R14                     not found\n         BCT   R15,GETPL\n* parm found:\n         L     R4,4(R3)                parm length\n         L     R3,0(R3)                parm addr\n         BR    R14\n*---------------------------------------------------------------------*\n* SPLIT ddname+nn to ddname and nn\n*    Set R2 to nn, update R4 = length of ddname\n*    uses R1\n*---------------------------------------------------------------------*\nSPLITDD  STM   R5,R14,WRKSAVE2\n         LR    R5,R3                    save R3\n         LA    R2,1\n         LR    R1,R3                    R1 -> start of ddname\n         AR    R3,R4\n         BCTR  R3,0                     R3 -> last char of ddname\nSLOOP    CLI   0(R1),C'+'\n         BE    SFOUND\n         BXLE  R1,R2,SLOOP              check next char\n         B     SZERO\n*  R1-> '+'\nSFOUND   LR    R4,R1\n         SR    R4,R5                    set R4 to new length\n*  check if nn is decimal digits:\n         LA    R1,1(R1)\n         LR    R6,R1                    R6 -> start of nn\nSLOOP2   TM    0(R1),X'F0'\n         BNO   SZERO\n         BXLE  R1,R2,SLOOP2             check next char\n*  Store nn to D aligned right:\n         LR    R2,R1\n         SR    R2,R6                    R2 = length of nn\n         BNP   SZERO                    if length = 0\n         C     R2,#8\n         BH    SZERO                    if length > 8\n         LA    R1,D+8\n         SR    R1,R2                    start of nn in D\n         MVC   D(8),#ZEROES\n         BCTR  R2,0                     length - 1\n         EX    R2,MVCNN                 move nn to D\n         NI    D+7,X'CF'                set sign '+'\n*  Convert nn to binary and store to R1\n         PACK  D(8),D(8)\n         CVB   R2,D\n         B     SRETNN\n*  NN not specified or invalid - set to 0\nSZERO    DS    0H\n         SR    R2,R2                    nn = 0\nSRETNN   LR    R3,R5                    restore R3\nSEXIT    LM    R5,R14,WRKSAVE2\n         BR    R14\n*--------------------------------------------------------------------\n* Error processing: Say message and return '0':\n* R15 -> ERRBLK\nERROR    DS    0H\n         USING ERRBLK,R15\n*        MVC   RETC(4),ERRCODE\n         MVC   MESSAGE(ERRMSGL),ERRMSG store for WTP\n* make parm for IRXSAY:\n         MVC   P1(8),=CL8'WRITE'       function request\n         LA    R1,ERRMSG\n         ST    R1,P3                   string addr\n         LA    R1,ERRMSGL\n         ST    R1,P4                   string length\n         ST    R11,P5                  ENVBLOCK\n*        XC    P5(4),P5                clear RC\n* make addr list:\n         LA    R1,P1\n         ST    R1,A1\n         LA    R1,P3\n         ST    R1,A2\n         LA    R1,P4\n         ST    R1,A3\n         LA    R1,P5\n         ST    R1,A4\n*        LA    R1,P5\n*        ST    R1,A5\n         OI    A4,X'80'                set VL bit\n* call program:\n         LA    R1,A1                   parm list addr\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXSAY              addr IRXSAY\n         DROP  R15                     USING\n         LTR   R15,R15\n         BZ    NOSAY                   Say not available\n         BALR  R14,R15                 Call IRXSAY\n         B     ERRFIN\n* WTP message instead of Saying:\nNOSAY    LA    R1,MSGLEN\n         ST    R1,A1\n         OI    A1,X'80'\n         LA    R1,ERRMSGL\n         STH   R1,MSGLEN\n         LA    R1,A1\n         CALL  WTP\n*\nERRFIN   MVI   EVALBLOCK_EVDATA,C'0'   Return '0'\n         B     EXIT\n*\n*=====================================================================*\n*        CONSTANTS                                                    *\n*---------------------------------------------------------------------*\n         DS    0F\nPARMEND  DC    8X'FF'\nMVCDDN   MVC   DDNAME(0),0(R3)              move parm to DDNAME\nMVCNN    MVC   0(0,R1),0(R6)                move parm to D\n#EXCOM   DC    C'IRXEXCOM'                  REXX module name\n#DSN     DC    C'SYSDSNAME'                 variable name\n#DDN     DC    C'SYSDDNAME'                 variable name\n#VOL     DC    C'SYSVOLUME'                 variable name\n#UNIT    DC    C'SYSUNIT'                   variable name\n#DSORG   DC    C'SYSDSORG'                  variable name\n#RECFM   DC    C'SYSRECFM'                  variable name\n#LRECL   DC    C'SYSLRECL'                  variable name\n#BLKSI   DC    C'SYSBLKSIZE'                variable name\n#KEYLE   DC    C'SYSKEYLEN'                 variable name\n#UNITS   DC    C'SYSUNITS'                  variable name\n#PRIMA   DC    C'SYSPRIMARY'                variable name\n#SECND   DC    C'SYSSECONDS'                variable name\n#DIRBA   DC    C'SYSADIRBLK'                variable name\n#DIRBU   DC    C'SYSUDIRBLK'                variable name\n#MEMBS   DC    C'SYSMEMBERS'                variable name\n#CRDT    DC    C'SYSCREATE'                 variable name\n#EXPDT   DC    C'SYSEXDATE'                 variable name\n#REFD    DC    C'SYSREFDATE'                variable name\n#EXTEN   DC    C'SYSEXTENTS'                variable name\n#PASSW   DC    C'SYSPASSWORD'               variable name\n#RACF    DC    C'SYSRACFA'                  variable name\n#UPDAT   DC    C'SYSUPDATED'                variable name\n#UTYPE   DC    C'SYSUTYPE'                  variable name (added)\n#MEMNM   DC    C'SYSMEMBER'                 variable name (added)\n#ZERO    DC    F'0'\n#ZEROES  DC    C'00000000'\n#BLANKS  DC    C'        '                  const\n#8       DC    F'8'\n#ERR1    DC    F'12'                   No parm\n         DC    CL40'L_DDN: Error - no parm passed          '\n#ERR2    DC    F'12'                   No DDNAME\n         DC    CL40'L_DDN: Error - DDNAME not found        '\n         DS    0F\n         LTORG\n         EJECT\n*---------------------------------------------------------------------*\n*        LOCAL WORK AREA                                              *\n*---------------------------------------------------------------------*\n         SPACE 1\nERRBLK   DSECT\nERRCODE  DS    F\nERRMSG   DS    CL40\nERRMSGL  EQU   *-ERRMSG\n*\nWRK      DSECT\nWRKSAVE  DS    18F                     REGISTER SAVE AREA\nWRKSAVE2 DS    18F                     REGISTER SAVE AREA\nD        DS    D\nTIOE1    DS    F\nSWEPAPTR DS F\nSWAPARMS SWAREQ MF=L\nEPA      DS    CL28                    Appears to use 26 bytes...\nDDNAME   DS    CL8\nDDN      DS    CL8\nDDLEN    DS    F\n*- Function call parameter:\n*- R0 -> env block IRXENVB\n*- R1 -> following parameter list:\nA1       DS    A\nA2       DS    A\nA3       DS    A\nA4       DS    A\nA5       DS    A\nA6       DS    A\n* parameter values:\nSHVBLK   DS    8F'0'                   IRXSHVB instance\n*- R1 -> following parameter list for SVM0033:\nP1       DS    A\nP2       DS    A\nP3       DS    A\nP4       DS    A\nP5       DS    A\nP6       DS    A\nENVBLKA  DS    A                       save ENVBLOCK address\nSAVERC   DS    F                       retcode from IRXEXCOM\nSAVER14  DS    F                       save R14\nSAV2R14  DS    F                       save R14\nDSN      DS    44C\nUNIT     DS    F\nVOL      DS    6C\nUTYPE    DS    4C\nMSGLEN   DS    H                       For WTP\nMESSAGE  DS    CL40                    For WTP\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         EJECT\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\n         YREGS\n* REXX specific DSECTs:\n         IRXEFPL DSECT=YES             REXX parameter list\n         IRXEVALB                      REXX evaluation block EVALBLOCK\n         IRXEXTE                       REXX vector of external ep\n         IRXENVB                       REXX environment block ENVBLOCK\n         IRXSHVB                       REXX shared variables block\n* SYSTEM SPECIFIC DSECTS:\n         CVT DSECT=YES\n         IEFJESCT\n         IEFZB505 LOCEPAX=YES\n         IKJTCB  DSECT=YES\n         IHAPSA\nTIOT     DSECT\n         IEFTIOT1\nJFCB     DSECT\n         IEFJFCBN\n         IEFUCBOB\n         PRINT GEN\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='CALL,MAP,RENT,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(IRXF@DDN) <=*.LOAD  0351000\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* Test changes, if any:\n//*TEP1   EXEC PGM=IKJEFT1B,\n//*       PARM='%PW'\n//STEP1   EXEC PGM=IRXJCL,\n//        PARM='PW'\n//SYSEXEC  DD DISP=SHR,DSN=SYS3.UTILITY.EXEC.SHARE         <== hlq.EXEC\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSUDUMP DD  SYSOUT=*\n//SNAP     DD  SYSOUT=*\n//ABNLIGNR DD  DUMMY                                   <- abend-aid\n//TESTDD   DD DISP=SHR,DSN=SYS1.LINKLIB\n//*TESTDD   DD DISP=SHR,DSN=SOME.GDG(0)\n//*ESTDD   DD DISP=SHR,DSN=RESERVE3,UNIT=CART,LABEL=3,VOL=SER=FDR53T\n//*UNIT=DASD,VOL=SER=TSTTS1\n//TEMPL    DD *\n dd = 'TESTDD'\n result = IRXF@DDN()\n Say 'DD=' 'Result=' result\n result = IRXF@DDN('XXXXXXXX')\n Say 'DD=XXXXXXXX' 'Result=' result\n result = IRXF@DDN(dd)\n Say 'DD='dd 'Result=' result\n Say ' SYSDSNAME='   SYSDSNAME\n Say ' SYSDDNAME='   SYSDDNAME\n Say ' SYSMEMBER='   SYSMEMBER\n Say ' SYSVOLUME='   SYSVOLUME\n Say ' SYSUNIT='     SYSUNIT\n Say ' SYSUTYPE='    SYSUTYPE\n Say ' SYSDSORG='    SYSDSORG\n Say ' SYSRECFM='    SYSRECFM\n Say ' SYSLRECL='    SYSLRECL\n Say ' SYSBLKSIZE='  SYSBLKSIZE\n Say ' SYSKEYLEN='   SYSKEYLEN\n Say ' SYSUNITS='    SYSUNITS\n Say ' SYSPRIMARY='  SYSPRIMARY\n Say ' SYSSECONDS='  SYSSECONDS\n Say ' SYSADIRBLK='  SYSADIRBLK\n Say ' SYSMEMBERS='  SYSMEMBERS\n Say ' SYSUDIRBLK='  SYSUDIRBLK\n Say ' SYSCREATE='   SYSCREATE\n Say ' SYSEXDATE='   SYSEXDATE\n Say ' SYSREFDATE='  SYSREFDATE\n Say ' SYSEXTENTS='  SYSEXTENTS\n Say ' SYSPASSWORD=' SYSPASSWORD\n Say ' SYSRACFA='    SYSRACFA\n Say ' SYSUPDATED='  SYSUPDATED\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXF@DOM": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\t\\x06\\x00w\\x00z\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T09:06:00", "lines": 119, "newlines": 122, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program IRX@MGCR\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'IRXF@DOM REXX function L_DOM'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 02-20-2003 SVM Created using CTB file 386 IRXF@DOM (L_DOM)\n*                    Changes:\n*                    - ignore empty parm, always return rc=0\n*.....................................................................\n*\n* FUNCTION:     Delete message from operator console\n*                  identified by parm=msgid\n*\n* Sample use:   msgid = L_WTO(message,'b')\n*               ...\n*               call L_DOM(msgid) /* remove message */\n*\n* PARAMETERS:   msgid - returned by L_WTO function\n*\n* OUTPUT:       R15 = 0\n*               '1' - normal execution response\n*               '0' - no parm or rc<>0 from DOM\n*\n* ATTRIBUTES:   REENTRANT, AMODE=31, RMODE=ANY\n*--------------------------------------------------------------------\nIRXF@DOM BEGIN\n         REGS\n         BAKR  R14,0\n         LR    R12,R15\n         LR    R02,R01\n         USING IRXF@DOM,R12\n         USING EFPL,R02\n         L     R03,EFPLARG\n         L     R04,EFPLEVAL\n         USING ARGTABLE_ENTRY,R03\n         L     R04,0(R04)\n         USING EVALBLOCK,R04\n         MVI   EVALBLOCK_EVDATA,C'1'   default: return '1'\n         LA    R09,1\n         ST    R09,EVALBLOCK_EVLEN\n*--------------------------------------------------------------------\n* Get parameter = message ID\n*--------------------------------------------------------------------\n         L     R05,ARGTABLE_ARGSTRING_PTR\n         LTR   R05,R05\n         BM    FINNOK\n         L     R06,ARGTABLE_ARGSTRING_LENGTH\n         LTR   R06,R06\n         BZ    FINNOK\n         C     R06,=F'4'\n         BNE   FINNOK\n         L     R06,0(R05)\n*--------------------------------------------------------------------\n* Remove message by message ID\n*--------------------------------------------------------------------\n         DOM   MSG=(R06)\n         LTR   R15,R15\n         BZ    EXIT\nFINNOK   MVI   EVALBLOCK_EVDATA,C'0'\n*--------------------------------------------------------------------\n* EXIT\n*--------------------------------------------------------------------\nEXIT     SR    R15,R15\n         PR\n         LTORG\n*--------------------------------------------------------------------\n* MAPS\n*--------------------------------------------------------------------\n         IRXEFPL\n         IRXARGTB\n         IRXEVALB\n         END   IRXF@DOM\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='RENT,CALL,MAP,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(IRXF@DOM) <=*.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* test changes, if any:\n//*O      EXEC PGM=IKJEFT1B,COND=(8,LE),\n//*       PARM='%PW'\n//GO      EXEC PGM=IRXJCL,COND=(8,LE),\n//        PARM='PW'\n//SYSEXEC  DD DISP=SHR,DSN=SYS3.UTILITY.EXEC.SHARE         <== hlq.EXEC\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSUDUMP DD SYSOUT=*\n//TEMPL    DD *\n x = L_WTO('Red Test message-ignore','A','S')\n Say 'Red Message ID from L_WTO =' C2X(x)\n call FWAIT('5s')\n x = IRXF@DOM(x)\n Say 'RC from L_DOM =' x\n x = L_WTO('White Test message-ignore','B')\n Say 'White Message ID from L_WTO =' C2X(x)\n call FWAIT('5s')\n x = IRXF@DOM(x)\n Say 'RC from L_DOM =' x\n x = IRXF@DOM('')\n Say 'Test L_DOM with empty parm:'\n Say 'RC from L_DOM =' x\n EXIT\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IRXF@DSN": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\t\\x11\\x02e\\x01\\xda\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T09:11:00", "lines": 613, "newlines": 474, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//* ASSEMBLE AND LINK PROGRAM\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'IRXF@DSN REXX function L_DSN'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 07-10-2003 SVM Added WTP if IRXSAY not available (in OPS)\n* 05-20-2003 SVM Added SYSMEMBER (cleared to '')\n*            and GDG support\n* 04-24-2003 SVM Added Say error msg\n* 02-27-2003 SVM Fixed SWAREQ call -> LOSEPAX=YES\n*                    Added limited processing for non-dasd\n* 01-03-2003 SVM Created using SVM0026 (old LISTDSN)\n*.....................................................................\n*\n* FUNCTION:     Create a limited number of LISTDSI variables.\n*               Dsname is located by catalog.                            0000007\n*               Variables that have no data will be cleared to null.\n*               (See TSO/E REXX Reference. TSO/E External functions\n*               for the variables names).\n*               SYSRACFA is assigned RACF access available for the       0000011\n*               owner of the job/task executing this function.\n*               SYSUTYPE is assigned to unit type (DISK, TAPE).\n*               SYSDDNAME is assigned if dsname is allocated.\n*               Works outside TSO environment.\n*               Works with either disk and/or tape datasets.\n*\n* Sample use:   If L_DSN(dsname) Then\n*                  /* use returned variables */\n*\n* PARAMETERS:   dsname\n*\n* OUTPUT:       R15 = 0\n*               Result = 1 - normal end\n*               Result = 0 (all vars cleared)\n*                  - no parm\n*                  - dsname not located\n*\n* ATTRIBUTES:   REENTRANT, AMODE=31, RMODE=ANY\n*\n* EXTERNALS:    SVM0033 - shared with IRXF@DSN common module\n*                         that sets up REXX variables\n*               SVM0030 - return UNIT for Volume\n*---------------------------------------------------------------------\n         EJECT\n*---------------------------------------------------------------------\n.* Macro to help clear variable: &N is a name of var name constant\n         MACRO\n         STORE &N,&C=SHVSTORE\n         AIF   ('&N' EQ '').NON\n         LA    R1,&N\n         ST    R1,SHVNAMA               --> store name addr\n         LA    R1,L'&N\n         ST    R1,SHVNAML               --> Store name length\n         MVI   SHVCODE,&C               --> Set \"store\" code\n         BAL   R14,CALLXCOM             - create variable\n.NON     ANOP\n         MEND\n*\nIRXF@DSN  BEGIN A=31,R=31                                                0000062\nWRK      WORK  LV=WRKL,LOC=BELOW\n         B     START\n*\nEXIT     SR    R15,R15\n         FIN\n*--------------------\n* REGISTER EQUATES:\n* R6  -> JFCB\n* R7  -> TIOT entry\n* R8  -> SHVBLOCK\n* R9  -> EVALBLOCK result block\n* R10 -> IRXEFPL   parm block\n* R11 -> ENVBLOCK  environment block\n*---------------------------------------------------------------------\n*- Set REXX environment:\nSTART    DS    0H\n         ST    R0,ENVBLKA              save it\n         LR    R10,R1                  IRXEFPL\n         USING EFPL,R10                - parm list\n         LR    R11,R0                  ENVBLOCK\n         USING ENVBLOCK,R11            - externals\n         L     R9,EFPLEVAL\n         L     R9,0(R9)                EVALBLOCK\n         USING EVALBLOCK,R9            - result\n         LA    R8,SHVBLK\n         USING SHVBLOCK,R8\n         BAL   R14,SETSHV\n         MVI   EVALBLOCK_EVDATA,C'1'   Store result value\n         LA    R4,1\n         ST    R4,EVALBLOCK_EVLEN      Store Result length\n*---------------------------------------------------------------------*\n*- Init all variables to '', drop SYSDDNAME:\n*---------------------------------------------------------------------*\n*        WTO   'Clearing Variables...',ROUTCDE=11\n         BAL   R14,CLEAR\n* get parm #1 (DSNAME)\n         LA    R2,1\n         BAL   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LA    R15,#ERR1\n         LTR   R4,R4\n         BZ    ERROR                   Error: no parm passed\n         ST    R4,DSLEN\n         BCTR  R4,0                    length - 1\n         MVC   DSN(44),#BLANKS\n         EX    R4,MVCDSN               === Store DSN ===\n         XC    JFCBA(4),JFCBA          by default - not available\n* locate volume by catalog and replace DSN by a real name for GDG:\n*        WTO   'Locating VOLSER by catalog...',ROUTCDE=11\n         LA    R1,DSN\n         BAL   R14,LOCATE               === If R15=0, VOL is set ===\n*---------------------------------------------------------------------*\n*- locate 1st TIOT DD-entry and lookup (R5->EPA)\n*---------------------------------------------------------------------*\nSEARCHDD DS    0H\n*        WTO   'Searching TIOT...',ROUTCDE=11\n         XC    EPA,EPA\n         L     R15,CVTPTR\n         USING CVT,R15\n         L     R15,CVTTCBP\n         L     R15,PSATOLD-PSATNEW(R15)\n         USING TCB,R15\n         L     R15,TCBTIO\n         USING TIOT1,R15\n         LA    R15,TIOENTRY            1st DD-entry\n         ST    R15,TIOE1               save it\n         DROP  R15                      USING\n*\n*- search if DSNAME allocated in some TIOT DD:\n         MVI   DDFOUND,C'N'            initiate DDFOUNG flag\n         L     R7,TIOE1\nDDLOOP   SR    R4,R4\n         IC    R4,0(R7)                 DDentry length\n         LTR   R4,R4                    If = 0\n         BZ    NODDNAME                 DD not found\n         CLI   4(R7),C' '               If not blank,\n         BE    SKIPMVC\n         MVC   DDNAME(8),4(R7)          === Store DDNAME ===\nSKIPMVC  DS    0H\n*  we might want to allow DDNAME+n here later...\n*  Set up SWA for SWAREQ and locate JFCB:\n         LA    R5,EPA                   GET ADDRESS OF THE EPA\n         ST    R5,SWEPAPTR              INITIALIZE EPA POINTER\n         USING ZB505,R5                 ESTABLISH ADDRESSABILITY TO EPA\n         XC    SWAEPAX,SWAEPAX          INITIALIZE THE EPA\n         MVC   SWVA,12(R7)              MV SVA OF JFCB INTO EPA\n*\n         SWAREQ FCODE=RL,EPA=SWEPAPTR,MF=(E,SWAPARMS),UNAUTH=YES\n*\n         L     R6,SWBLKPTR              POINT TO THE JFCB\n         USING JFCB,R6                  ADDRESS JFCB\n         CLC   DSN(44),JFCBDSNM         compare dsn\n         BNE   NEXTDD                   Iterate\n* Found DD referring DSN:\n         DROP  R5                       USING\n*        WTO   'DDNAME found',ROUTCDE=11\n         MVI   DDFOUND,C'Y'\n         ST    R6,JFCBA                 === Store JFCB address ===\n         SR    R4,R4\n         ICM   R4,7,17(R7)              R4 -> Tiot Unit addr\n         DROP  R6                       USING\n         USING UCBOB,R4\n         MVC   UTYPE(4),UCBTYP          === Store UCBTYP ===\n         MVC   VOL(6),UCBVOLI           === Store VOLSER ===\n         CLC   UCBWGT+1(3),=C'UCB'      Check for 4-digit UNIT\n         BE    FOURDGTS                 yes\n         MVC   UNIT(4),UCBWGT           === Store UNIT ===\n         MVI   UNIT,C'0'\n         B     RDDN\n*\nFOURDGTS UNPK  D(5),UCBCHAN(3)          take 4-digit address\n         MVC   UNIT(4),D                === store UNIT ===\n         B     RDDN                     Exit loop\n         DROP  R4                       USING\n*\nNEXTDD   LA    R7,0(R4,R7)              Advance to next TIOT DD entry\n         B     DDLOOP\n*\n* DDNAME not found:\nNODDNAME DS    0H\n*        WTO   'DDNAME not found',ROUTCDE=11\n         B     RDDN\n*---------------------------------------------------------------------*\n* Assign dataset variables:\n*---------------------------------------------------------------------*\nRDDN     DS    0H\n*- process VOLUME: if DDNAME found, take from TIOT\n*        WTO   'Processing VOLUME...',ROUTCDE=11\n         CLI   DDFOUND,C'Y'\n         BE    VFROMT\n* locate volume by catalog:\n*        WTO   'Locating VOLSER by catalog...',ROUTCDE=11\n         LA    R1,DSN\n         BAL   R14,LOCATE               === If R15=0, VOL is set ===\n         LTR   R15,R15\n         BZ    PRCVOL\n* If DSN not found, set up SYSDSNAME variable and return error:\n         LA    R3,DSN-1\n         LA    R1,DSN+43\n         LA    R2,1                    increment\n         LNR   R2,R2                   -1\nLOOP     CLI   0(R1),C' '\n         BNE   LOOPE\n         BXH   R1,R2,LOOP\n*  R1-> blank or next char after DSN\nLOOPE    SR    R1,R3                   length of DSNAME\n         ST    R1,SHVVALL              --> store value length\n         LA    R1,DSN\n         ST    R1,SHVVALA              --> store value addr\n         STORE #DSN\n*        WTO   'Error in LOCATE...',ROUTCDE=11\n         LA    R15,#ERR2\n         B     ERROR                   error in LOCATE\n* get VOL from TIOT -> UCB\nVFROMT   DS    0H\n*        WTO   'Locating VOLSER by TIOT...',ROUTCDE=11\n*\nPRCVOL   DS    0H\n*---------------------------------------------------------------------*\n*- process UNIT: If DDname found, R4 -> Unit entry\n*                Else Locate unit by volume\n*        WTO   'Processing UNIT...',ROUTCDE=11\n         CLI   DDFOUND,C'Y'\n         BE    UFROMT\n* locate UNIT by volume:\n*        WTO   'Locating UNIT by VOLSER...',ROUTCDE=11\n         MVC   UNIT(4),=C'????'         == default UNIT ==\n         MVI   UTYPE+2,X'80'            == default UTYPE=tape ==\n         LA    R1,VOL\n         ST    R1,A1\n         LA    R1,UNIT\n         ST    R1,A2\n         LA    R1,UTYPE+2\n         ST    R1,A3\n         LA    R1,A1\n         CALL  SVM0030                  Get Unit by VOLSER\nUFROMT   DS    0H\n*---------------------------------------------------------------------*\n*- Call SVM0033 to set up variables:\n         CLI   DDFOUND,C'Y'\n         BE    SETDD\n         MVC   DDNAME(8),#BLANKS\nSETDD    DS    0H\n         LA    R1,DDNAME\n         ST    R1,P1\n         LA    R1,DSN\n         ST    R1,P2\n         LA    R1,UNIT\n         ST    R1,P3\n         LA    R1,VOL\n         ST    R1,P4\n         LA    R1,UTYPE\n         ST    R1,P5\n         L     R1,JFCBA\n         ST    R1,P6\n         LA    R1,P1\n         L     R0,ENVBLKA\n         CALL  SVM0033\n         B     EXIT                    normal end\n*=====================================================================*\n*        S U B R O U T I N E S                                        *\n*---------------------------------------------------------------------*\n* Clear (empty) all variables:\n*---------------------------------------------------------------------*\nCLEAR    ST    R14,SAV2R14\n         LA    R3,DDNAME\n         ST    R3,SHVVALA               --> store value addr\n         SR    R1,R1                    set value length = 0\n         ST    R1,SHVVALL               --> store value length\n         STORE #DSN\n         STORE #VOL\n         STORE #UNIT\n         STORE #DSORG\n         STORE #RECFM\n         STORE #LRECL\n         STORE #BLKSI\n         STORE #KEYLE\n         STORE #UNITS\n         STORE #PRIMA\n         STORE #SECND\n         STORE #DIRBA\n         STORE #DIRBU\n         STORE #MEMBS\n         STORE #CRDT\n         STORE #EXPDT\n         STORE #REFD\n         STORE #EXTEN\n         STORE #PASSW\n         STORE #RACF\n         STORE #UPDAT\n         STORE #UTYPE\n         STORE #MEMNM\n* Set SYSDDNAME:\n         STORE #DDN,C=SHVDROPV          --> DROP SYSDDNAME\n         L     R14,SAV2R14\n         BR    R14\n*---------------------------------------------------------------------*\n* Set IRXEXCOM parameters:\n*---------------------------------------------------------------------*\nSETSHV   DS    0H\n* (re)make addr list:\n         LA    R1,#EXCOM\n         ST    R1,A1                   A1 = Addr of module name\n         XC    A2(8),A2                clear A2 and A3\n         LA    R1,SHVBLK\n         ST    R1,A4                   A4 -> SHVBLOCK\n         OI    A4,X'80'                set VL bit\n* (re)fill SHVBLOCK:\n         XC    SHVNEXT(SHVBLEN),SHVNEXT clear it all\n         BR    R14\n*--------------------------------------------------------------------*\n* Call IRXEXCOM:\n*--------------------------------------------------------------------*\nCALLXCOM ST    R14,SAVER14\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXEXCOM            addr IRXEXCOM\n         DROP  R15                      USING\n         LA    R1,A1                   parm list addr\n         LR    R0,R11                  point to ENVBLOCK\n         BALR  R14,R15                 Call IRXEXCOM\n         ST    R15,SAVERC              save return code\n         L     R14,SAVER14             restore return address\n         BR    R14\n* LOCATE VOLSER by DSName in catalog:                                 *\n*    entry :  R1 = addr of 44-char DSNAME                             *\n*    use   :  R15 (return 0, when VOLSER is located), R1 - work       *\n*    return:  to R14, R15 = RC, set VOL                               *\n*---------------------------------------------------------------------*\nLOCATE   DS    0H\n         ST    R14,SAVER14             save return\n         MVC   VOL(6),#BLANKS          clear VOL\n         MVC   WARE(LCAT),CATALOG\n         ST    R1,WARE+4               parm 2 - DSN addr\n         LA    R1,WACAT\n         ST    R1,WARE+12              parm 4 - workarea\n         LA    R1,WARE                 parm for LOCATE\n         SVC   26                      LOCATE\n         LTR   15,15\n         BNZ   LOCATEX\n         MVC   VOL(6),WACAT+6          Set VOL\nLOCATEX  L     R14,SAVER14\n         BR    R14\n*---------------------------------------------------------------------*\n* GET input parameter (addr,length) by number:                        *\n*    entry :  R2=parm # (not changed)                                 *\n*    use   :  R15 (return 0, when parm is found)                      *\n*    return:  to R14, R3=parm addr, R4=parm length (0, if not found)  *\n*---------------------------------------------------------------------*\nGETPARM  DS    0H\n         LR    R15,R2\n         SR    R4,R4                   make length zero\n         L     R3,EFPLARG              A(1st parm)\n         B     GETPL1                  go into loop\nGETPL    LA    R3,8(R3)                next parm\nGETPL1   CLC   0(8,R3),PARMEND\n         BER   R14                     not found\n         BCT   R15,GETPL\n* parm found:\n         L     R4,4(R3)                parm length\n         L     R3,0(R3)                parm addr\n         BR    R14\n*--------------------------------------------------------------------\n* Error processing: Say message and return '0':\n* R15 -> ERRBLK\nERROR    DS    0H\n         USING ERRBLK,R15\n*        MVC   RETC(4),ERRCODE\n         MVC   MESSAGE(ERRMSGL),ERRMSG store for WTP\n* make parm for IRXSAY:\n         MVC   P1(8),=CL8'WRITE'       function request\n         LA    R1,ERRMSG\n         ST    R1,P3                   string addr\n         LA    R1,ERRMSGL\n         ST    R1,P4                   string length\n         ST    R11,P5                  ENVBLOCK\n*        XC    P5(4),P5                clear RC\n* make addr list:\n         LA    R1,P1\n         ST    R1,A1\n         LA    R1,P3\n         ST    R1,A2\n         LA    R1,P4\n         ST    R1,A3\n         LA    R1,P5\n         ST    R1,A4\n*        LA    R1,P5\n*        ST    R1,A5\n         OI    A4,X'80'                set VL bit\n* call program:\n         LA    R1,A1                   parm list addr\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXSAY              addr IRXSAY\n         DROP  R15                      USING\n         LTR   R15,R15\n         BZ    NOSAY\n         BALR  R14,R15                 Call IRXSAY\n         B     ERRFIN\n* WTP message instead of Saying:\nNOSAY    LA    R1,MSGLEN\n         ST    R1,A1\n         OI    A1,X'80'\n         LA    R1,ERRMSGL\n         STH   R1,MSGLEN\n         LA    R1,A1\n         CALL  WTP\n*\nERRFIN   MVI   EVALBLOCK_EVDATA,C'0'   Return '0'\n         B     EXIT\n*=====================================================================*\n*        CONSTANTS                                                    *\n*---------------------------------------------------------------------*\n         DS    0F\nPARMEND  DC    8X'FF'\nMVCDSN   MVC   DSN(0),0(R3)                 move parm to DSNAME\nMVCNN    MVC   0(0,R1),0(R6)                move parm to D\n#EXCOM   DC    C'IRXEXCOM'                  REXX module name\n#DSN     DC    C'SYSDSNAME'                 variable name\n#DDN     DC    C'SYSDDNAME'                 variable name\n#VOL     DC    C'SYSVOLUME'                 variable name\n#UNIT    DC    C'SYSUNIT'                   variable name\n#DSORG   DC    C'SYSDSORG'                  variable name\n#RECFM   DC    C'SYSRECFM'                  variable name\n#LRECL   DC    C'SYSLRECL'                  variable name\n#BLKSI   DC    C'SYSBLKSIZE'                variable name\n#KEYLE   DC    C'SYSKEYLEN'                 variable name\n#UNITS   DC    C'SYSUNITS'                  variable name\n#PRIMA   DC    C'SYSPRIMARY'                variable name\n#SECND   DC    C'SYSSECONDS'                variable name\n#DIRBA   DC    C'SYSADIRBLK'                variable name\n#DIRBU   DC    C'SYSUDIRBLK'                variable name\n#MEMBS   DC    C'SYSMEMBERS'                variable name\n#CRDT    DC    C'SYSCREATE'                 variable name\n#EXPDT   DC    C'SYSEXDATE'                 variable name\n#REFD    DC    C'SYSREFDATE'                variable name\n#EXTEN   DC    C'SYSEXTENTS'                variable name\n#PASSW   DC    C'SYSPASSWORD'               variable name\n#RACF    DC    C'SYSRACFA'                  variable name\n#UPDAT   DC    C'SYSUPDATED'                variable name\n#UTYPE   DC    C'SYSUTYPE'                  variable name (added)\n#MEMNM   DC    C'SYSMEMBER'                 variable name (added)\n#ZERO    DC    F'0'\n#ZEROES  DC    C'00000000'\n#BLANKS  DC    CL60' '\n         DS    0F\nCATALOG  CAMLST NAME,CATALOG,,CATALOG\nLCAT     EQU   *-CATALOG\n#ERR1    DC    F'12'                   No parm:\n         DC    CL40'L_DSN: Error - no parm passed          '\n#ERR2    DC    F'12'                   LOCATE error:\n         DC    CL40'L_DSN: Dataset not found               '\n         LTORG\n         EJECT\nERRBLK   DSECT\nERRCODE  DS    F\nERRMSG   DS    CL40\nERRMSGL  EQU   *-ERRMSG\n*---------------------------------------------------------------------*\n*        LOCAL WORK AREA                                              *\n*---------------------------------------------------------------------*\n         SPACE 1\nWRK      DSECT\nWRKSAVE  DS    18F                     REGISTER SAVE AREA\nWRKSAVE2 DS    18F                     REGISTER SAVE AREA\nD        DS    D\nTIOE1    DS F\nSWEPAPTR DS F\nSWAPARMS SWAREQ MF=L\nEPA      DS    CL28                   EPA uses 26 bytes ...\nDDNAME   DS    CL8\nDSN      DS    CL44\nDSLEN    DS    F\nUNIT     DS    F\nUTYPE    DS    F\nVOL      DS    6C\nWARE     CAMLST NAME,WARE,,WARE       space for parm\nWACAT    DS    265C                   LOCATE work area\n*- Function call parameter:\n*- R0 -> env block IRXENVB\n*- R1 -> following parameter list:\nA1       DS    A\nA2       DS    A\nA3       DS    A\nA4       DS    A\nA5       DS    A\nA6       DS    A\n* parameter values:\nSHVBLK   DS    8F'0'                   IRXSHVB instance\n*- R1 -> following parameter list for SVM0028:\nP1       DS    A\nP2       DS    A\nP3       DS    A\nP4       DS    A\nP5       DS    A\nP6       DS    A\nSAVERC   DS    F                       retcode from IRXEXCOM\nSAVER14  DS    F                       save R14\nSAV2R14  DS    F                       save R14\n*LISTD    CAMLST SEARCH,JFCBDSNM,WVOL,W140\nLISTD    DS    0F                      CAMLST\n         DS    A                       = #LISTD\n         DS    A                       (DSN)\n         DS    A                       (VOL)\n         DS    A                       (W140)\n*\nENVBLKA  DS    A\nJFCBA    DS    A\nDDFOUND  DS    C\nMSGLEN   DS    H                       For WTP\nMESSAGE  DS    CL40                    For WTP\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         EJECT\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\n         REGS\n* REXX specific DSECTs:\n         IRXEFPL DSECT=YES             REXX parameter list\n         IRXEVALB                      REXX evaluation block EVALBLOCK\n         IRXEXTE                       REXX vector of external ep\n         IRXENVB                       REXX environment block ENVBLOCK\n         IRXSHVB                       REXX shared variables block\n* SYSTEM SPECIFIC DSECTS:\n         CVT DSECT=YES\n         IEFJESCT\n         IEFZB505 LOCEPAX=YES\n         IKJTCB  DSECT=YES\n         IHAPSA\nTIOT     DSECT\n         IEFTIOT1\nJFCB     DSECT\n         IEFJFCBN\n         IEFUCBOB                      UCB MACRO ID\n         PRINT GEN\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='CALL,MAP,RENT,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(IRXF@DSN) <=*.LOAD  0351000\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* Test changes, if any:\n//*\n//*TEP1   EXEC PGM=IKJEFT1B,\n//*       PARM='%PW'\n//STEP1   EXEC PGM=IRXJCL,COND=(8,LE),\n//        PARM='PW'\n//SYSEXEC  DD DISP=SHR,DSN=SYS3.UTILITY.EXEC.SHARE         <== hlq.EXEC\n//*UNIT=DASD,VOL=SER=TSTTS1\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//*UNIT=DASD,VOL=SER=TSTTS1\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSUDUMP DD  SYSOUT=*\n//SNAP     DD  SYSOUT=*\n//ABNLIGNR DD  DUMMY                                       <== Abenaid\n//TESTDD   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST\n//         DD DISP=SHR,DSN=SYS1.LINKLIB\n//*ESTDD   DD DISP=SHR,DSN=RESERVE3,UNIT=CART,LABEL=3,VOL=SER=FDR53T\n//TEMPL    DD *\n dsn = 'SYS1.LINKLIB'\n result = IRXF@DSN()\n Say 'DSN=' 'Result=' result\n result = IRXF@DSN('XXXXXXXX')\n Say 'DSN=XXXXXXXX' 'Result=' result\n /* Test return of new GDG dsname: */\n result = IRXF@DSN('SYST.TESTGDG.PDF(+1)')\n Say \"DSN='SYST.TESTGDG.PDF(+1)' Result=\" result\n Say ' SYSDSNAME='   SYSDSNAME\n result = IRXF@DSN(dsn)\n Say 'DSN='dsn 'Result=' result\n Say ' SYSDSNAME='   SYSDSNAME\n Say ' SYSDDNAME='   SYSDDNAME\n Say ' SYSMEMBER='   SYSMEMBER\n Say ' SYSVOLUME='   SYSVOLUME\n Say ' SYSUNIT='     SYSUNIT\n Say ' SYSUTYPE='    SYSUTYPE\n Say ' SYSDSORG='    SYSDSORG\n Say ' SYSRECFM='    SYSRECFM\n Say ' SYSLRECL='    SYSLRECL\n Say ' SYSBLKSIZE='  SYSBLKSIZE\n Say ' SYSKEYLEN='   SYSKEYLEN\n Say ' SYSUNITS='    SYSUNITS\n Say ' SYSPRIMARY='  SYSPRIMARY\n Say ' SYSSECONDS='  SYSSECONDS\n Say ' SYSADIRBLK='  SYSADIRBLK\n Say ' SYSMEMBERS='  SYSMEMBERS\n Say ' SYSUDIRBLK='  SYSUDIRBLK\n Say ' SYSCREATE='   SYSCREATE\n Say ' SYSEXDATE='   SYSEXDATE\n Say ' SYSREFDATE='  SYSREFDATE\n Say ' SYSEXTENTS='  SYSEXTENTS\n Say ' SYSPASSWORD=' SYSPASSWORD\n Say ' SYSRACFA='    SYSRACFA\n Say ' SYSUPDATED='  SYSUPDATED\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXF@FWT": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x01\\x03\\x12\\x0f\\x01\\x03!\\x8f\\x103\\x01\\xc5\\x01\\xc3\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2003-04-30T00:00:00", "modifydate": "2003-08-06T10:33:00", "lines": 453, "newlines": 451, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='OBJECT,NODECK,NOXREF,BATCH,RENT'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'L_FWT REXX subroutine/function for Wait modify/interval'       00000\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 05-02-2003 SVM     Fixed EXTRACT and TIMEXIT for reenterability\n* 04-30-2003 SVM Created from FWAIT                                        00000\n*                    Used data module SVM00000 to keep timer ECB\n*                    for reenterability. SVMLOAD returns addr of\n*                    this data module.\n*.....................................................................\n* FUNCTION:     1) Enable modify operator commands\n*               2) Set interval and wait until either interval expires\n*                  or stop/modify command issued\n*               3) If modify/stop was requested, return 'STOP'\n*                  or command, if interval has expired, return null.\n*\n* Sample use:\n*               /* Set program to wait for modify: */\n*                  reply = L_FWT()\n*               /* Set program to wait for either modify or timer: */\n*                  reply = L_FWT(interval)\n*\n*               If no parameter, just wait for modify.\n*               Parameter format: xxxxm or xxxxs\n*                  xxxx - decimal number, 1-4 digits,\n*                  m - interval in minutes (upper/lower case)\n*                  s - interval in seconds (upper/lower case)\n*\n* PARAMETERS:   interval\n*\n* OUTPUT:       R15 = non-zero, if parm is invalid of data module\n*                  cannot be loaded.\n*               returns string to REXX program:\n*                  if interval has expired, reply = ''\n*                  if stop/modify, reply = 'STOP' or command text\n*\n* ATTRIBUTES:   Reentrant, Amode=31, Rmode=Any\n*\n* Referenses:   IBM TSO Extensions for MVS. REXX/MVS Reference\n*               Version 2 Release 5\n*               Document Number SC28-1883-07\n*               File Number S370/390-39\n* Externals:\n*               SVMLOAD (by call), SVM00000 (by LOAD)\n*---------------------------------------------------------------------\n         EJECT\n*---------------------------------------------------------------------\nWRK      DSECT\nWRKSAVE  DS    18F                     REGISTER SAVE AREA\nSAVE14   DS    14F                     local save area\nRC       DS    F                       RC to return in R15\nD        DS    D                       work for conversion\nCOMAREA  DS    F                       addr of common area\nCOMMAND  DS    80C                     field for result\nCMDLEN   DS    F                       result length\nINTERVAL DS    F                       interval value\n*\nECBLIST  DS    0F\nECBA1    DS    F                       Stop/Modify ECB Address\nECBA2    DS    F                       Stimer ECB address\n* EXTRACT parameters:\nEXTR     EXTRACT ,FIELDS=(COMM),MF=L\nEXTRL    EQU   *-EXTR\n*\nINTUNIT  DS    C                       interval units (m or s)\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n*=====================================================================\nIRXF@FWT BEGIN                                                             00000\nWRK      WORK  LV=WRKL\n         B     START\nEXIT     L     R15,RC\n         FIN\n*---------------------------------------------------------------------\n* REGISTER Use:\n* R9  -> EVALBLOCK result block\n* R10 -> IRXEFPL   parm block\n* R11 -> ENVBLOCK  environment block\n* R12 -> CSECT base\n* R13 -> WRK base\n*---------------------------------------------------------------------\n*  Set addressability for REXX environment:\n*---------------------------------------------------------------------\nSTART    DS    0H\n         XC    RC(4),RC\n         LR    R10,R1                  IRXEFPL\n         USING EFPL,R10                - parm list\n         LR    R11,R0                  ENVBLOCK\n         USING ENVBLOCK,R11            - externals\n         L     R9,EFPLEVAL\n         L     R9,0(R9)                EVALBLOCK\n         USING EVALBLOCK,R9            - result\n*---------------------------------------------------------------------\n*  Get and check parm #1:\n*---------------------------------------------------------------------\n*     WTO 'IRXF@FWT started',ROUTCDE=11\n         XC    INTERVAL,INTERVAL       Clear timer interval\n         LA    R2,1                    Set input parm number\n         BAS   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LTR   R4,R4                   Copy length to R8\n         BZ    NOPARM\n         BAS   R14,GETINTVL            Extract INTERVAL value\n         LTR   R15,R15\n         BNZ   ERROR\nNOPARM   DS    0H\n*---------------------------------------------------------------------\n*  Enable Modify command:\n*---------------------------------------------------------------------\n         BAS   R14,TINIT               And set COMAREA\n*---------------------------------------------------------------------\n*  Set ECBA1 for modify command:\n*---------------------------------------------------------------------\n         L     R4,COMAREA              load\n         L     R5,0(R4)                Get Stop/Modify ECB address\n         ST    R5,ECBA1                Put in ECBLIST\n*---------------------------------------------------------------------\n*  If interval specified,  then set timer and ECBA2:\n*---------------------------------------------------------------------\n         L     R7,INTERVAL\n         LTR   R7,R7\n         BZ    NOTIMER                no - just check for Modify\n* Locate TIMECB in a data module (for reenterability):\n         LA    R1,SADDR\n         CALL  SVMLOAD                R15 = addr of module\n         LTR   R8,R15                 R8 = addr of data module\n         BZ    ERROR\n         USING SVM00000,R8\n         LA    R6,TIMECB\n         ST    R6,ECBA2               Set ECB addr in the list\n         OI    ECBA2,X'80'            Set VL bit\n         XC    TIMECB,TIMECB\n*     WTO 'IRXF@FWT setting timer',ROUTCDE=11\n         STIMER REAL,TIMEXIT,BINTVL=INTERVAL  Set timer interval\n         B     WAIT\n*---------------------------------------------------------------------\n*  if no interval specified, wait just for modify:\n*---------------------------------------------------------------------\nNOTIMER  OI    ECBA1,X'80'             Set VL bit\n*\n*---------------------------------------------------------------------\n*              W A I T   F O R   E V E N T S :\n*---------------------------------------------------------------------\n*\nWAIT     WAIT  ECBLIST=ECBLIST,LONG=YES     Wait until an event occurs\n*\n*---------------------------------------------------------------------\n*  Process events: if timer was specified, check timer ECB first:\n*---------------------------------------------------------------------\n         L     R7,INTERVAL\n         LTR   R7,R7                   Interval was set ?\n         BZ    MODIFY1                  - no\n         TM    TIMECB,X'40'            Has timer expired?\n         BO    PRCTIMER                yes - Go process\n*     WTO 'TTIMER CANCEL...',ROUTCDE=11\n         TTIMER CANCEL                 cancel timer\n*---------------------------------------------------------------------\n*  Otherwise process modify command:\n*---------------------------------------------------------------------\nMODIFY1  DS    0H\n*     WTO 'IRXF@FWT Modify received',ROUTCDE=11\n         L     R4,COMAREA                   -> Comm Area\n         LA    R6,4(,R4)                    -> CIB Address\n         L     R5,0(,R6)                    -> CIB\n         LTR   R5,R5                        Is CIB address present ?\n         BNZ   CHECKCIB                     Yes, go check it\n*     WTO 'Internal error: no CIB'\n         ABEND 1,DUMP                       No Cib, Scream and shout !\n         SPACE\nCHECKCIB DS    0H\n         USING CIB,R5\n         CLI   CIBVERB,CIBMODFY             Is this a modify command ?\n         BE    MODIFY                       Yes, Go Process\n         SPACE 1\n*---------------------------------------------------------------------\n*  Stop command issued - acknowledge and exit\n*---------------------------------------------------------------------\n         SPACE 1\n*     WTO 'IRXF@FWT Stop command accepted',ROUTCDE=11\n         LA    R6,4                         Message to display\n         ST    R6,CMDLEN\n         MVC   COMMAND(4),=C'STOP'          Store text\n         B     MODEND\n*---------------------------------------------------------------------\n*  Modify Command Issued - Process and delete CIB\n*---------------------------------------------------------------------\n         SPACE 1\nMODIFY   DS    0H\n         LH    R7,CIBDATLN                  Get length of data\n         ST    R7,CMDLEN                    store\n         BCTR  R7,0                         -1 for execute\n         EX    R7,MVCOPER                   Isolate Command\n         OC    COMMAND,BLANKS               Make it upper case\n*---------------------------------------------------------------------\n*  Delete the CIB (note this clears the ECB if it is the last CIB)\n*                 (which it is because we set CIBCTR=1           )\n*---------------------------------------------------------------------\nMODEND   DS    0H\n         L     R5,COMAREA\n         LA    R6,4(,R4)                    -> Address of CIB\n         L     R5,0(,R6)                    Get CIB address\n         QEDIT ORIGIN=(R6),BLOCK=(R5)       Delete the modify CIB\n         B     RESULT\n*---------------------------------------------------------------------\n*  Process timer expiration:\n*---------------------------------------------------------------------\nPRCTIMER SR    R6,R6                        Empty reply\n         ST    R6,CMDLEN\n*     WTO 'IRXF@FWT Timer interval expired',ROUTCDE=11\n         B     RESULT\n*---------------------------------------------------------------------\n*  Return Result\n*---------------------------------------------------------------------\nRESULT   L     R4,CMDLEN\n         ST    R4,EVALBLOCK_EVLEN      Store Result length =1\n         LTR   R4,R4\n         BZ    NOTEXT\n         BCTR  R4,R0                   length - 1 for EX MVC\n         EX    R4,MVCCMD\nNOTEXT   B     EXIT\n*---------------------------------------------------------------------\n*  No/invalid parm specified:\n*---------------------------------------------------------------------\nERROR    SR    R15,R15\n         ST    R15,CMDLEN\n         LA    R15,ERRC\n         ST    R15,RC\n         B     RESULT\n*---------------------------------------------------------------------\n*  Initialize job for Modify commands, store common address:\n*---------------------------------------------------------------------\nTINIT    DS    0H\n         LA    R5,4                         result length\n         ST    R5,CMDLEN                    store result length\n         LA    R4,COMAREA\n         XC    EXTR(EXTRL),EXTR             clear\n*     WTO 'Before EXTRACT',ROUTCDE=11\n         EXTRACT (R4),FIELDS=(COMM),MF=(E,EXTR)\n*     WTO 'After  EXTRACT',ROUTCDE=11\n*not rent EXTRACT (R4),FIELDS=(COMM)         Get address of Comm Area\n         L     R4,COMAREA                   Load it\n         ST    R4,COMMAND                   Put in result\n         L     R5,0(R4)                     Get Stop/Modify ECB address\n         ST    R5,ECBA1                     Store in ECB list\n         LA    R6,4(,R4)                    -> Address of CIB\n         L     R5,0(,R6)                    Get CIB address\n         LTR   R5,R5                        Is there a Start CIB ?\n         BZ    NOCIB                        no, skip delete\n         SPACE\n         QEDIT ORIGIN=(R6),BLOCK=(R5)       Delete the start CIB\n         SPACE 1\nNOCIB    DS    0H\n* Issue QEDIT to allow modify to be issued against this job. The\n* CIBCTR value specifies how many modifies can be outstanding before\n* the message 'modify rejected, task busy' is issued. If this program\n* is to be driven by automation, the value of 1 should perhaps be\n* increased a tad\n         QEDIT ORIGIN=(R6),CIBCTR=1         Allow Modify to be issued\n         BR    R14\n*        B     RESULT\n*\n*=====================================================================\n*        S U B R O U T I N E S\n*---------------------------------------------------------------------\n* GET input parameter (addr,length) by number:\n*    entry :  R2=parm # (not changed)\n*    use   :  R15 (return 0, when parm is found)\n*    return:  to R14, R3=parm addr, R4=parm length (0, if not found)\n*---------------------------------------------------------------------\nGETPARM  DS    0H\n         LR    R15,R2\n         SR    R4,R4                   make length zero\n         L     R3,EFPLARG              A(1st parm)\n         B     GETPL1                  go into loop\nGETPL    LA    R3,8(R3)                next parm\nGETPL1   CLC   0(8,R3),PARMEND\n         BER   R14                     not found\n         BCT   R15,GETPL\n* parm found:\n         L     R4,4(R3)                parm length\n         L     R3,0(R3)                parm addr\n         BR    R14\n*---------------------------------------------------------------------\n*  Convert interval to binary:\n*    entry :  R3=parm address, R4=parm length xxxxm or xxxxs\n*    use   :  R15 (return 1, when parm is invalid)\n*    result:  set INTERVAL in 0.01 second units\n*---------------------------------------------------------------------\nGETINTVL DS    0H\n         STM   R1,R14,SAVE14\n         LR    R5,R4\n         BCTR  R5,R0                   length of number\n* save units char:\n         IC    R6,0(R5,R3)             units char\n         STC   R6,INTUNIT              save units\n* check length:\n         LA    R6,1\n         CR    R5,R6\n         BL    GETERR                  length < 1\n         LA    R6,4\n         CR    R5,R6\n         BH    GETERR                  length > 4\n* convert number to binary:\n         SR    R6,R5                   offset = 4 - length\n         LA    R7,D+4\n         LA    R7,0(R6,R7)             R7 = target = D + 4 + offset\n         BCTR  R5,R0                   R5 = length - 1\n         LA    R6,0(R5,R3)             last digit\n         NI    0(6),X'CF'              set sign (F4 -> C4)\n         XC    D,D                     clear D\n         EX    R5,MVCPAR2              copy num to D+4\n         LA    R6,D+4\n         PACK  0(4,R6),0(4,R6)         convert to packed dec\n         CVB   R6,D                    convert to binary\n         ST    R6,INTERVAL             store\n* process units:\n         OI    INTUNIT,X'40'           convert to Upper case\n         CLI   INTUNIT,C'S'\n         BE    GETSECS\n         LA    R7,60                   convert minutes to seconds\n         M     R6,INTERVAL             R7 = 60 * INTERVAL\n         ST    R7,INTERVAL\nGETSECS  LA    R7,100                  conbert to 0.01 secs\n         M     R6,INTERVAL\n         ST    R7,INTERVAL\n         B     GETNORM\nGETERR   LA    R15,1\n         B     GETRET\nGETNORM  SR    R15,R15\nGETRET   LM    R1,R14,SAVE14\n         BR    R14\n*=====================================================================\n*        CONSTANTS\n*---------------------------------------------------------------------\n         DS    0F\nPARMEND  DC    8X'FF'\nMVCOPER  MVC   COMMAND(0),CIBDATA\nMVCPAR2  MVC   0(0,R7),0(R3)\nMVCCMD   MVC   EVALBLOCK_EVDATA,COMMAND\nBLANKS   DC    CL80' '\nERRC     EQU   1\n         LTORG\n         EJECT\n*=====================================================================\n*  Stimer exit - post mainline\n*  (Not reentrant because of TIMECB. It must be abs address)\n*---------------------------------------------------------------------\n         DROP  R12\nTIMEXIT  DS    0H\n         STM   14,12,12(13)            Save Registers\n         LR    R12,R15\n         USING TIMEXIT,R12\nSAVAREA  WORK  LV=SAVAREAL\n         LA    R1,SADDR\n         CALL  SVMLOAD                R15 = addr of module\n         LTR   R8,R15                 R8 = addr of data module\n         BZ    TEXIT\n         USING SVM00000,R8\n         LA    R2,TIMECB                    Load ECB address\n         POST  (R2)                         Post mainline\n*     WTO 'POST done...',ROUTCDE=11\n         SPACE\nTEXIT    FIN\n*TEXIT    L     R13,4(R13)                   Restore sav area\n*         LM    R14,R12,12(R13)              Restore registers\n*         BR    R14                          Get out of this place\n*TIMECB   DS    F                            Timer ECB\nSADDR    DC    A(SLEN)\nSLEN     DC    AL2(8)\nSNAME    DC    C'SVM00000'                  Data module\n         LTORG\nSAVAREA  DSECT\n         DS    18F\nSAVAREAL EQU   (*-SAVAREA+7)/8*8\n*\n*=====================================================================\n*        DSECTS\n*---------------------------------------------------------------------\nSVM00000 SVM00000 DSECT=YES\n         PUSH  PRINT\n         PRINT NOGEN\n         YREGS\nCIB      DSECT\n         IEZCIB\n         CVT   DSECT=YES\n         IHAASCB\n         IHAASVT\n*---------------------------------------------------------------------\n* REXX specific DSECTs:\n*---------------------------------------------------------------------\n         IRXEFPL DSECT=YES             REXX parameter list\n         IRXEVALB                      REXX evaluation block EVALBLOCK\n         IRXEXTE                       REXX vector of external ep\n         IRXENVB                       REXX environment block ENVBLOCK\n         POP   PRINT\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='CALL,RENT,MAP,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(IRXF@FWT) <=*.LOAD    03510\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* HOW TO RUN TEST:\n//*\n//* When on GO, issue\n//*   F SVM,OPERATOR\n//* then\n//*   P SVM\n//* then wait 10 seconds for termination\n//* Joblog must contain:\n//*   +Reply from IRXF@FWT: OPERATOR\n//*   +Reply from IRXF@FWT: STOP\n//*   +Reply from IRXF@FWT:\n//* SYSTSPRT must end with:\n//* IRX0040I Error running PW, line XXX: Incorrect call to routine\n//*\n//*O      EXEC PGM=IKJEFT1B,COND=(8,LE),\n//*       PARM='%PW'\n//GO      EXEC PGM=IRXJCL,COND=(8,LE),\n//        PARM='PW'\n//SYSEXEC  DD DISP=SHR,DSN=SYS3.UTILITY.EXEC.SHARE         <== hlq.EXEC\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//         DD DISP=SHR,DSN=SYS3.UTILITY.LINKLIB.TEST    <== IRXFLOC lib\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//TEMPL    DD *\n Call L_WTO('Issue \"F jobname,OPERATOR\"')\n repl = IRXF@FWT('60s')\n call L_WTO('Reply from IRXF@FWT:' repl)\n Call L_WTO('Issue \"P jobname\"')\n repl = IRXF@FWT('60s')\n call L_WTO('Reply from IRXF@FWT:' repl)\n Call L_WTO('Now wait 5 s')\n repl = IRXF@FWT('5s')\n call L_WTO('Reply from IRXF@FWT:' repl)\n Say 'Invalid call to L_FWT:'\n repl = IRXF@FWT('123456')\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXF@PDS": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\r\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\t'\\x02\\x88\\x02u\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@\"", "ispf": {"version": "01.13", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T09:27:00", "lines": 648, "newlines": 629, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='OBJECT,NODECK,NOXREF,BATCH,RENT'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*-------------------------------------------------------------------\n     TITLE 'IRXF@PDS REXX function L_PDS'\n*-------------------------------------------------------------------\n* History of Changes (last comes first):\n* 07-10-2003 SVM Added WTP if IRXSAY not available (in CA/OPS)\n* 03/17/03 SVM Added error processing\n* 03/05/03 SVM Created\n*\n* Compare to LISTPDS testing results (CEE.SCEELKED, 7904 members):\n*          VIRT   SYS    EXT    SYS      EXCP   SRVC   CPU,s\n* IRXF@PDS 248k   352k   420k   10104k   1476    75K   1.38\n* LISTPDS  228k   876k  1420k   10172k   1487   162K   2.82\n*.....................................................................\n*   Runs in both TSO (IKJEFT1B) and non-TSO environment (IRXJCS)\n*\n* FUNCTION:     Open PO dataset,\n*               Allocate member list table\n*               Read PO dataset and fill member list\n*               Adjust EVSIZE and copy members to EVDATA.\n*               If member has aliases, put them in 'ALIAS()'\n*               after the primary member name.\n*               Use blanks to separate primary members,\n*               Use comma to separate aliases.\n*\n* Sample use:   dsn='...'; memlist=L_PDS(dsn)\n*\n* PARAMETERS:   dsn,vol\n*               dsnname - required\n*               volume  - optional or blanks\n*\n* OUTPUT:       Result - string of members and aliases\n*               If Error - R15>0 (\"Incorrect call to procedure\")\n*               - no parm,\n*               - no $OPEN program\n*               - no dataset\n*               - too many members\n*               If warning - R15=0, result=null\n*               - not a PDS\n*               - no members\n*               Say error/warning message.\n* Attributes:\n*               reentrant, AMODE=31,RMODE=ANY\n* Externals:\n*               $OPEN - dynalloc/read interface module (A=24)\n*                            LOADed and CALLed\n*--------------------------------------------------------------------\nIRXF@PDS BEGIN A=31\nWRK      WORK  LV=WRKL,LOC=BELOW\n         B     START\n*--------------------------------------------------------------------\n*  Exit the program - clean up first:\nEXIT     DS    0H\n         L     R3,DATADDR\n         LTR   R3,R3\n         BZ    EXT2\n         L     R2,DATALEN\n         FREEMAIN RU,A=(R3),LV=(R2)\nEXT2     L     R3,$OPENADR\n         LTR   R3,R3\n         BZ    FIN\n         DELETE EP=$OPENI\n         LTR   R15,R15\n         BZ    FIN\nFIN      L     R15,RETC\n         FIN\n*--------------------\n* REGISTER EQUATES:\n* R9  -> EVALBLOCK result block\n* R10 -> IRXEFPL   parm block\n* R11 -> ENVBLOCK  environment block\n*---------------------------------------------------------------------\n*- Set REXX environment:\nSTART    LR    R10,R1                  IRXEFPL\n         USING EFPL,R10                - parm list\n         LR    R11,R0                  ENVBLOCK\n         USING ENVBLOCK,R11            - externals\n         L     R9,EFPLEVAL\n         L     R9,0(R9)                EVALBLOCK\n         USING EVALBLOCK,R9            - result\n*\n         SR    R2,R2                   By default:\n         ST    R2,RETC                 return rc = 0\n         ST    R2,EVALBLOCK_EVLEN      return empty value\n* get parm #1 (DSNAME)\n         LA    R2,1\n         BAL   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LTR   R4,R4\n         LA    R15,#ERR1\n         BZ    ERROR                   no parm\n         BCTR  R4,0                    length - 1\n         MVC   DSNAME(44),#BLANKS\n         EX    R4,MVCDSN               copy parm to DSNAME\n* get parm #2 (VOLUME)\n         MVC   VOLUME(6),#BLANKS\n         LA    R2,2\n         BAL   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LTR   R4,R4\n         BZ    NOVOL                   blank\n         BCTR  R4,0                    length - 1\n         EX    R4,MVCVOL               copy parm to VOLUME\nNOVOL    DS    0H\n*---------------------------------------------------------------------\n*  $OPEN Input Dataset to read directory:\n         MVC   MEMBER(8),#BLANKS       Clear MEMBER to read Directory\n         XC    RECLEN(NUMLEN),RECLEN   Nullify other fields\n**       WTO   'TEST: Calling $OPENI...',ROUTCDE=11\n         LA    R15,$PARM\n         ST    R15,$PADDR              Set $PADDR\n         OI    $PADDR,X'80'            Set VL bit\n         LOAD  EP=$OPENI,ERRET=LOADERR\n         ST    R0,$OPENADR\n         LR    R1,R0\n         LA    R0,$CLSOFFS(R1)\n         ST    R0,$CLOSADR\n         LA    R0,$REDOFFS(R1)\n         ST    R0,$READADR\n*---------------------------------------------------------------------\n*  Allocate space for member list, 12 bytes for each member:\n*  R8=# of members\nALLOC    DS    0H\n         L     R8,#MAXMEM\n         LA    R5,12\n         MR    R4,R8                   R4||R5 = R5 * R8\n         ST    R5,DATALEN              store data length\n         GETMAIN RU,LV=(R5),LOC=RES\n         ST    R1,DATADDR              store data addr\n*---------------------------------------------------------------------\n*  Open PDS directory and read member entries,\n*  put aliases from bottom to top and members from top to bottom\n*  into allocated work area:\n**       WTO   'TEST: Calling $OPENI...',ROUTCDE=11\n         LA    R1,$PADDR\n**    CALL  $OPENI\n         L     R15,$OPENADR\n         BASSM R14,R15\n         LTR   R15,R15\n         LA    R15,#ERR3\n         BNZ   ERROR                   Cannot open data set\nREAD2    DS    0H\n         L     R4,DCBAD\n         USING IHADCB,R4\n         TM    DCBDSORG,DCBDSGPO\n         LA    R15,#ERR4\n         BNO   ERROR                   not PO dataset - ret null\n         DROP  R4\n*\n         L     R8,DATADDR              R8 -> 1st data element\n         ST    R8,MEMBEND              Init memb list end addr\n         LA    R6,DLEN                 R6 = data elem length\n         LR    R7,R8\n         A     R7,DATALEN\n         ST    R7,DATAEND              Store end of data addr\n         ST    R7,ALIAS                Init alias list addr\n         SR    R3,R3                   R3 = member counter\nTREAD2   DS    0H\n**       WTO   'TEST: TREAD2 loop...',ROUTCDE=11\n         LA    R1,$PADDR\n**    CALL  $READ\n         L     R15,$READADR\n         BASSM R14,R15\n         LTR   R15,R15\n         BNZ   TREND2                  end of file\n*  Read dir entries:\n         L     R2,RECADDR\n         LH    R1,0(R2)                blk length\n         LA    R0,0(R1,R2)             next to last used byte\n         LA    R2,2(R2)                1st entry\n         USING ENTRY,R2\nLOOP2    SR    R1,R1\n         ICM   R1,8,COUNTER\n         SLL   R1,3                    use 5 bits\n         SRL   R1,26                   length of DATA\n         LA    R1,12(R1)               length of ENTRY\n         CLC   NAME(8),#MAX            end of directory -\n         BE    TREND2                  leave\n         LA    R3,1(R3)                advance member counter\n         C     R3,#MAXMEM\n         BNH   GOOD\n         LA    R15,#ERR6\n         B     ERROR                   too many - increase #MAXMEM\nGOOD     TM    COUNTER,#ALIAS\n         BO    PRCALS\n*  Process member ENTRY:\n         USING DENTRY,R8\n         MVC   DENTRY(DLEN),ENTRY\n         AR    R8,R6                   to next elem\n         ST    R8,MEMBEND              save addr of member list end\n         DROP  R8\n         B     PRCANY\n* Process alias  ENTRY:\n         USING DENTRY,R7\nPRCALS   SR    R7,R6                   To Next position\n         MVC   DENTRY(DLEN),ENTRY\n         OI    DENTRY+DLEN-1,#MARK     Mark as non-processed alias\n         ST    R7,ALIAS                save 1st alias address\n         DROP  R7\n*  Common processing:\nPRCANY   LA    R2,0(R1,R2)             next entry ?\n         CR    R2,R0                   compare to block end\n         BNL   TREAD2                  next block\n         B     LOOP2                   next entry\n*  R8,MEMBEND-> member list end\n*  R7,ALIAS  -> alias list start\nTREND2   DS    0H\n         ST    R3,MEMBERS              store real number of members\n         LTR   R15,R15\n         BZ    TCLOSE\n**       WTO   'EOF reached',ROUTCDE=11\n*---------------------------------------------------------------------\n*  Close Input Dataset:\nTCLOSE   DS    0H\n**       WTO   'TEST: Calling $CLOSE...',ROUTCDE=11\n         LA    R1,$PADDR\n**       CALL  $CLOSE\n         L     R15,$OPENADR\n         BASSM R14,R15\n         LTR   R15,R15\n         BZ    CHKALS\n**       WTO 'TEST: $CLOSE failed',ROUTCDE=11\n*---------------------------------------------------------------------\n*  Build a chain of mambers and aliases using TTRC field as\n*  addr of next in chain:\n*  - local register equates:\nM0       EQU   R0                      start of member list\nMN       EQU   R1                      next member addr\nMC       EQU   R2                      current member addr\nME       EQU   R3                      end of member list\nA0       EQU   R4                      start of alias list\nAN       EQU   R5                      next alias  addr\nAC       EQU   R6                      current alias  addr\nAE       EQU   R7                      end of alias  list\nMX       EQU   R8                      current chain end\n*\nCHKALS   DS    0H\n         L     R3,MEMBERS\n         LTR   R3,R3\n         LA    R15,#ERR5               No members in PDS\n         BZ    ERROR\n**       WTO 'CHKALS...',ROUTCDE=11\n         LA    M0,DLEN\n         ST    M0,DLENF                store DLEN\n         L     M0,DATADDR              1st member\n         L     ME,MEMBEND              end of member list\n         L     A0,ALIAS                1st alias\n         L     AE,DATAEND              end of alias list\n         S     AE,DLENF                last alias\n         LR    MN,M0                   1st member\n         CR    M0,ME                   If 1st = end\n         BNE   NX1\n         SR    MN,MN                   set next mem to 0 - no members\nNX1      DS    0H\n         CR    A0,AE                   if 1st <= last\n         BNH   MLOOP\n         SR    AE,AE                   set next alias = 0 - no aliases\n*  Loop by members:\nMLOOP    DS    0H\n         LTR   MN,MN\n         BZ    MFIN                    no more members to process\n         LR    MC,MN\n         LA    MN,DLEN(MC)             addr of next member\n         CR    MN,ME                   if next >= end\n         BL    NX3\n         SR    MN,MN                   set next = 0\nNX3      LR    MX,MC                   set chain link to current mem\n         MVC   TTRX(3),TTR-ENTRY(MC)   store TTR of current member\n         LR    AN,AE                   start from AE\n*  Internal loop by aliaces (search aliaces for the member):\nALOOP    LTR   AN,AN\n         BZ    AFIN                    no more aliases to process\n         LR    AC,AN\n         S     AN,DLENF                addr of prev alias\n         CR    AN,A0                   if prev < start\n         BNL   NX4\n         SR    AN,AN                   set next = 0\nNX4      CLI   COUNTER-ENTRY(AC),#MARK   processed?\n         BNE   ALOOP                   yes - skip it\n         CLC   TTR-ENTRY(3,AC),TTRX    If alias.ttr = ttrx\n         BNE   NX5\n         ST    AC,TTR-ENTRY(MX)        link alias to chain\n         LR    MX,AC                   advance chain link\nNX5      B     ALOOP                   consider next alias\n*\nAFIN     ST    MN,TTR-ENTRY(MX)        link next member to chain\n         B     MLOOP\n*\nMFIN     DS    0H\n**       WTO   'Getting EVALBLOCK...',ROUTCDE=11\n*---------------------------------------------------------------------\n*  Get bigger EVALBLOCK, if needed:\n         L     R2,MEMBERS              # of members\n         MHI   R2,$MLEN                length of EVDATA required\n         L     R6,EVALBLOCK_EVSIZE     save to show\n         BAL   R14,GETBIG\n*---------------------------------------------------------------------\n*  Copy members to EVDATA in format 'mem (al) (al) mem mem (al) mem...'\n**       WTO   'Copying members to EVDATA',ROUTCDE=11\n         L     R1,MEMBERS\n         L     MC,DATADDR              from\n         LA    MX,EVALBLOCK_EVDATA     to\n         L     A0,ALIAS\nCPLOOP   BAL   R14,COPYM               copy member to EVDATA\n         L     MC,DTTR-DNAME(MC)       next member in chain\n         LTR   MC,MC\n         BZ    CPLEAVE\n         BCT   R1,CPLOOP\n*\nCPLEAVE  DS    0H\n         CLI   PREV,#A\n         BNE   SETEVLEN\n         MVI   0(MX),C')'              close alias list\n         LA    MX,1(MX)                shift output pos\nSETEVLEN LA    MC,EVALBLOCK_EVDATA\n         SR    MX,MC\n         ST    MX,EVALBLOCK_EVLEN\n         SR    R15,R15\n         B     EXIT\n*---------------------------------------------------------------------*\n*- Error EXIT: R15 -> ERRBLK\nLOADERR  LA    R15,#ERR2               Load error\nERROR    DS    0H\n         USING ERRBLK,R15\n         MVC   RETC(4),ERRCODE\n         MVC   MESSAGE(ERRMSGL),ERRMSG store for WTP\n* make parm for IRXSAY:\n         MVC   P1(8),=CL8'WRITE'       function request\n         LA    R1,ERRMSG\n         ST    R1,P2                   string addr\n         LA    R1,ERRMSGL\n         ST    R1,P3                   string length\n         ST    R11,P4                  ENVBLOCK\n         XC    P5(4),P5                clear RC\n* make addr list:\n         LA    R1,P1\n         ST    R1,A1\n         LA    R1,P2\n         ST    R1,A2\n         LA    R1,P3\n         ST    R1,A3\n         LA    R1,P4\n         ST    R1,A4\n         LA    R1,P5\n         ST    R1,A5\n         OI    A5,X'80'                set VL bit\n* call program:\n         LA    R1,A1                   parm list addr\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXSAY              addr IRXSAY\n         DROP  R15\n         LTR   R15,R15\n         BZ    NOSAY\n         BALR  R14,R15                 Call IRXSAY\n         B     EXIT\n* WTP message instead of Saying:\nNOSAY    LA    R1,MSGLEN\n         ST    R1,A1\n         OI    A1,X'80'\n         LA    R1,ERRMSGL\n         STH   R1,MSGLEN\n         LA    R1,A1\n         CALL  WTP\n         B     EXIT\n*\n*=====================================================================*\n*        S U B R O U T I N E S                                        *\n*---------------------------------------------------------------------*\n* GET input parameter (addr,length) by number:                        *\n*    entry :  R2=parm # (not changed)                                 *\n*    use   :  R15 (return 0, when parm is found)                      *\n*    return:  to R14, R3=parm addr, R4=parm length (0, if not found)  *\n*---------------------------------------------------------------------*\nGETPARM  DS    0H\n         LR    R15,R2\n         SR    R4,R4                   make length zero\n         L     R3,EFPLARG              A(1st parm)\n         B     GETPL1                  go into loop\nGETPL    LA    R3,8(R3)                next parm\nGETPL1   CLC   0(8,R3),PARMEND\n         BER   R14                     not found\n         BCT   R15,GETPL\n* parm found:\n         L     R4,4(R3)                parm length\n         L     R3,0(R3)                parm addr\n         BR    R14\n*---------------------------------------------------------------------*\n* Copy data member name from data to EVDATA,\n*    separate with a blank, put alias into '()'\n*    Use local Regs definition and values\n*    MC(R2) - current member to copy\n*    MX(R8) - where to copy (update after copy)\n*    A0(R4) - alias list start\n*    AC(R6), AE(R7), MN(R1) = work regs\n*---------------------------------------------------------------------*\nCOPYM    STM   R14,R7,S2\n         CR    MC,A0                    if alias\n         BL    CMEM                     not alias\n* alias:\n         CLI   PREV,#A\n         MVI   PREV,#A                  update PREV to \"Alias\"\n         BE    CAA\n*  prev was member:\nCMA      MVC   0(#LMA,MX),#MA           start alias list with #MA\n         LA    MX,#LMA(MX)              shift output pos\n         B     CNXT1\n*  prev was alias:\nCAA      MVI   0(MX),C','               separate aliaces with a comma\n         LA    MX,1(MX)                 shift output pos\n         B     CNXT1\n*  member:\nCMEM     CLI   PREV,#A\n         MVI   PREV,#M\n         BNE   CNXT1\n*  prev was alias:\nCAM      MVC   0(2,MX),=C') '           end alias (alias list)\n         LA    MX,2(MX)                 shift output pos\n*  prev was member:\n*        Member already has a trailing blank\n* copy non-blank chars of member name:\nCNXT1    LR    MN,MC                    R1 - first char\n         LA    AE,7(MC)                 R7 - last char\n         LA    AC,1                     R6 - incr\nCLOOP    CLI   0(MN),C' '\n         BE    CLOOPE                   leave on blank\n         BXLE  MN,AC,CLOOP              until AN\n* MN -> blank or next char after DNAME\nCLOOPE   SR    MN,MC                    length\n         LTR   MN,MN                    null -\n         BZ    CNXT2                    move one char anyway\n         BCTR  MN,0                     length-1 for MVC\nCNXT2    EX    MN,CMVCNAM               copy memb name chars\n         LA    MN,1(MN)                 back to length\n         AR    MX,MN                    shift output position\n         CLI   PREV,#M                  if it is a member\n         BNE   COPYEND                  no\n         MVI   0(MX),C' '               put a blank\n         LA    MX,1(MX)                 shift output pos\nCOPYEND  LM    R14,R7,S2\n         BR    R14\nCMVCNAM  MVC   0(0,MX),0(MC)\n*---------------------------------------------------------------------*\n* GET bigger EVALBLOCK by calling IRXRLT:                             *\n*    (std length of EVDATA is 250 bytes, to replace EVALBLOCK,        *\n*    call IRXRLT and put new address into EFLEVAL)                    *\n*    entry :  R2=new data length (must be 16M>=l>=0                   *\n*    return:  to R9 -> new evalblock, R15=rc from IRXRLT              *\n*---------------------------------------------------------------------*\nGETBIG   STM   R14,R1,S2\n         SR    R15,R15\n         LR    R1,R2                   Check if it fits:\n         SRL   R1,3                    R2/8 (in doublewords)\n         LA    R1,2(R1)                required EVSIZE\n         C     R1,EVALBLOCK_EVSIZE\n         BNH   GETBRET                 fits\n         LA    R1,FUNC                 set parm addr list\n         ST    R1,PA#1\n         LA    R1,EVBADDR\n         ST    R1,PA#2\n         LA    R1,EVDTLEN\n         ST    R1,PA#3\n         OI    PA#3,x'80'              set VL bit\n         MVC   FUNC(8),#GETBLK         Set parm values\n         XC    EVBADDR(4),EVBADDR\n         ST    R2,EVDTLEN\n         LR    R0,R11\n         LA    R1,PA#1\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXRLT              IRXRLT entry addr\n         DROP  R15\n         BALR  R14,R15                 Call IRXRLT\n         LTR   R15,R15\n         BNZ   GETBRET\n         L     R9,EVBADDR              Update addr of EVALBLOCK\nGETBRET  ST    R15,S2+4\n         LM    R14,R1,S2\n         BR    R14\n*=====================================================================\n*  Constants:\n*---------------------------------------------------------------------\n#MA      DC    C' ALIAS('              start of alias list\n#LMA     EQU   *-#MA                   length of #MA\n#A       EQU   C'A'                    PREV was alias\n#M       EQU   C'M'                    PREV was member\n#MAXMEM  DC    F'15000'                max # of members can process\n$MLEN    EQU   14                     Average length of entry in EVDATA\n$CLSOFFS EQU   80                      X'50' offset of $CLOSE ep\n$REDOFFS EQU   48                      X'30' offset of $READ ep\n#EVDFLT  DC    F'250'                  Standard EVDATA max len\n#ALIAS   EQU   X'80'                   flag 'alias' in COUNTER byte\n#MARK    EQU   X'FF'                   flag member has alias(es)\nPARMEND  DC    8X'FF'\n#BLANKS  DC    CL44' '\n#MAX     DC    8X'FF'\n#GETBLK  DC    C'GETBLOCK'                  func for IRXRLT\nMVCDSN   MVC   DSNAME(0),0(R3)              move parm to DSNAME\nMVCVOL   MVC   VOLUME(0),0(R3)              move parm to VOLUME\nMVCRET   MVC   EVALBLOCK_EVDATA(0),DSNAME   move DSNAME to return buf\n#ERR1    DC    F'12'                   No parm\n         DC    CL40'L_PDS: Error - no parm passed          '\n#ERR2    DC    F'12'                   No $OPEN\n         DC    CL40'L_PDS: Error - $OPEN cannot be LOADed  '\n#ERR3    DC    F'12'                   Open failed\n         DC    CL40'L_PDS: Error - Cannot open data set    '\n#ERR4    DC    F'00'                   Not PDS\n         DC    CL40'L_PDS: Warning - Dataset is not a PDS  '\n#ERR5    DC    F'00'                   No members\n         DC    CL40'L_PDS: Warning - PSD directory empty   '\n#ERR6    DC    F'12'                   No members\n         DC    CL40'L_PDS: Error - Too many members        '\n         LTORG\n*=====================================================================\n*  Mapping:\n*---------------------------------------------------------------------\nWRK      DSECT\nS        DS    18F\nS2       DS    18F\nVALUE    DS    D\nD        DS    2D\nRETC     DS    A\n*- $PARM map for $OPEN:\n$PADDR   DC    X'80'                   Std Parm addr list\n         DC    AL3($PARM)              Actually AL4\n$PARM    DS    0F\nRC       DC    F'0'                    <Return Code\nDSNAME   DC    44C' '                  >Dataset Name\nMEMBER   DC    8C' '                   >PDS Member Name/blanks\nVOLUME   DC    6C' '                   >Volume Name/blanks\nRECLEN   DC    H'0'                    <Current Record Length\nTYPE     EQU   RECLEN\nDCBAD    DC    F'0'                   ><DCB Address\nBUFADDR  DC    F'0'                   ><Buffer Address\nLENGTH   DC    F'0'                    <Data Length in Buffer (bytes)\nRECADDR  DC    F'0'                    <Current Record Addr\nNUMLEN   EQU   *-RECLEN\n*- end of $PARM map\n*- Parm for IRXRLT:\nPA#1     DS    A                     > Addr of function\nPA#2     DS    A                      <Addr of A(new EVALBLOCK)\nPA#3     DS    A                     > Requested length of EVDATA,VL\nFUNC     DS    CL8                     =C'GETBLOCK'\nEVBADDR  DS    A\nEVDTLEN  DS    F\n*- end of parm for IRXRLT\n$OPENADR DS    A                       addr of $OPENI\n$CLOSADR DS    A                       addr of $CLOSE\n$READADR DS    A                       addr of $READ\n*- data area variables:\nMEMBERS  DS    F                       # of member entries\nDATALEN  DS    F                       length of data allocated\nDATADDR  DS    A                       addr of data allocated\nDATAEND  DS    A                       addr of end of data\nMEMBEND  DS    A                       addr of last prim member\nALIAS    DS    A                       addr of alias list in data\nMEMPTR   DS    A                       wrk\nTTRX     DS    F                       wrk\nDLENF    DS    F                       wrk\nPREV     DS    CL1\n*- Function call parameter:\n*- R0 -> env block IRXENVB\n*- R1 -> following parameter list:\nA1       DS    A\nA2       DS    A\nA3       DS    A\nA4       DS    A\nA5       DS    A\nA6       DS    A\n* parameter values:\nP1       DS    CL8                     function requested\nP2       DS    A                       addr os data\nP3       DS    F                       length of data\nP4       DS    A                   IRXENVB optional, R0 is alternative\nP5       DS    A                       RC and VL bit\n**\nMSGLEN   DS    H                       For WTP\nMESSAGE  DS    CL40                    For WTP\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH\n*\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\nERRBLK   DSECT\nERRCODE  DS    F\nERRMSG   DS    CL40\nERRMSGL  EQU   *-ERRMSG\n         PRINT NOGEN\n         REGS\n* REXX specific DSECTs:\n         IRXEFPL DSECT=YES             REXX parameter list\n         IRXEVALB                      REXX evaluation block EVALBLOCK\n         IRXEXTE                       REXX vector of external ep\n         IRXENVB                       REXX environment block ENVBLOCK\n* DCB mapping:\n         DCBD  DSORG=PO,DEVD=DA\n* DATA element:\nDENTRY   DSECT\nDNAME    DS    CL8\nDTTR     DS    XL3\nDFLAG    DS    XL1\nDLEN     EQU   *-DENTRY\n*\n* PO directory entry map:\nENTRY    DSECT\nNAME     DS    CL8\nTTR      DS    XL3\nCOUNTER  DS    XL1\nDATA     DS    XL1\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,COND=(8,LE),\n//        PARM='RENT,REUS,CAL,MAP,AC=1,RMOD=ANY,AMOD=31'\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(IRXF@PDS) <=*.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* test changes, if any:\n//GO      EXEC PGM=IKJEFT1B,COND=(8,LE),\n//        PARM='%PW'\n//SYSEXEC  DD DISP=SHR,DSN=SYS3.UTILITY.EXEC.SHARE         <== hlq.EXEC\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSUDUMP DD SYSOUT=*\n//TEMPL    DD *\n dsn = 'CEE.SCEELKED'  /* big PDS */\n result = IRXF@PDS(dsn)\n Say 'DD='dsn 'RC=' rc\n Say 'Good Result=' result\n dsn = 'SYS3.UTILITY.PS.TEST'\n result = IRXF@PDS(dsn)\n Say 'Bad  Result=' result\n result = IRXF@PDS()\n EXIT\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXF@PGM": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x01\\x03\\t/\\x01\\x03!\\x8f\\t4\\x02\\xc8\\x02t\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2003-04-02T00:00:00", "modifydate": "2003-08-06T09:34:00", "lines": 712, "newlines": 628, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='TEST,OBJECT,NODECK,NOXREF,BATCH,RENT'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*-------------------------------------------------------------------\n     TITLE 'SVM0037  REXX function L_PGM'\n*-------------------------------------------------------------------\n* History of Changes (last comes first):\n* 07-10-2003 SVM Added WTP if IRXSAY not available (in OPS)\n* 04/02/03 SVM Created\n*.....................................................................\n*   Runs in both TSO (IKJEFT1B) and non-TSO environment (IRXJCS)\n*\n* FUNCTION:     Open Load library member and read ESD,RLD,SYM data\n*               (if any) to the arrays that will be returned to\n*               the caller.\n*               Creates (if not already exist) a hidden variable\n*               value(dsname) that contains library data used for\n*               faster re-open. This variable will exist until\n*               the exec ends and is re-usable.\n*               See $PARM map for $OPEN for field description.\n* Sample use:\n*               If L_PGM(dsn,program,volume) Then Do\n*               /* ... process variables  */\n*               See also MAPPGM exec in hlq.EXEC libarary\n*               for a sample variables processing and print data\n*\n* PARAMETERS:   dsn,program,volume\n*               dsn     - required, must be a load library name\n*               program - required, member name\n*               volume  - optional, can be omitted, blanks or null\n*\n* OUTPUT:       Result ='1' - normal, '0' - abnormal\n*               R15 = 0\n*               If abnormal call to routine:\n*               Say message:\n*               - no dsname specified\n*               - no program specified\n*               - $OPEN program cannot be LOADed\n*               - no dataset or open error\n*               - no member in library\n*               - not a PDS\n*               - RAM shortage\n*               - Overlay and SCTR programs not supported.\n*               If Normal, creates REXX variables:\n*               PTAB - string mapped by the following structure:\n*               - p#name   CL8 main program name\n*               - p#entry  F   entry point offset\n*               - p#size   F   program size, bytes\n*               -          X   reserved\n*               - p#ssi    XL3 ssi (date of linkage)\n*               - p#ac     BL1 program authorization code\n*               - p#at1    BL1 copy of PDS2ATR1 (ref IHAPDS)\n*               - p#at2    BL1 copy of PDS2ATR2 (ref IHAPDS)\n*               - p#ft2    BL1 copy of PDS2FTB2 (ref IHAPDS),\n*                              but bit0 = PDS2ALIS (alias flag)\n*               - p#aname  CL8 alias name (if member is an alias)\n*               - p#aentry F   alias entry point offset\n*               CTAB.i (i=1,2,...) - section data\n*               - c#name   CL8 CSECT name\n*               - c#addr   F   section offset in the program\n*               - c#size   F   section size, bytes\n*               - c#type   X   type 00-SD,03-LR,04-PC,05-Common\n*               - c#ssi    XL3 section compilation date\n*               DTAB.i (j=1,2,...) - DSECT data\n*               - d#name   CL8 section name\n*               - d#addr   F   zeroes\n*               - d#size   F   section size, bytes\n*               - d#type   X   type\n*               - d#num    AL3 number of parent CTAB (i)\n*               CTAB.i.n (i=1,2,..., n=1,2,...) - csect field data\n*               - n#name   CL8 field name\n*               - n#addr   F   field offset in section\n*               - n#size   F   field length, bytes\n*               - n#type   X   field type\n*               - n#mult   AL3 filed multiplier (20CL8 20=mult,8=size)\n*               DTAB.j.n (j=1,2,..., n=1,2,...) - dsect field data\n*               - n#name   CL8 field name\n*               - n#addr   F   field offset in section\n*               - n#size   F   field length, bytes\n*               - n#type   X   field type\n*               - n#mult   AL3 filed multiplier (20CL8 20=mult,8=size)\n*\n* Attributes:\n*               reentrant, AMODE=31,RMODE=ANY\n* Externals:\n*               $OPEN - dynalloc/read interface module (A=24)\n*                            LOADed and CALLed\n*--------------------------------------------------------------------\n.* Macro to handle variable: &N is a name of var name, constant\n         MACRO\n         STORE &N,&L,&C=SHVSTORE\n         AIF   ('&N' EQ '').NON\n&VAL     SETC  'L''&N'\n         AIF   ('&L' EQ '').C\n         AIF   ('&L'(1,1) NE '(').NREG\n.* -- Len is a (R):\n&VAL     SETC  '0&L'\n         AGO   .C\n.* -- Len is abs value:\n.NREG    ANOP\n&VAL     SETC  '&N'\n.C       LA    R1,&VAL\n         ST    R1,SHVNAML               --> Store name length\n         LA    R1,&N\n         ST    R1,SHVNAMA               --> store name addr\n         MVI   SHVCODE,&C               --> Set \"store\" code\n         BAL   R14,CALLXCOM             - process variable\n.NON     ANOP\n         MEND\n*--------------------------------------------------------------------\nIRXF@PGM BEGIN A=31\nWRK      WORK  LV=WRKL,LOC=BELOW\n         B     START\n*--------------------------------------------------------------------\n*  Exit the program - clean up first:\nEXIT     DS    0H\n         L     R3,DATADDR\n         LTR   R3,R3\n         BZ    FIN\n         L     R2,DATALEN\n         FREEMAIN RU,A=(R3),LV=(R2)\nFIN      SR    R15,R15\n         FIN\n*---------------------------------------------------------------------\n* REGISTER EQUATES:\n* R8  -> SHVBLOCK  variable access block\n* R9  -> EVALBLOCK result block\n* R10 -> IRXEFPL   parm block\n* R11 -> ENVBLOCK  environment block\n*---------------------------------------------------------------------\n*- Set REXX environment:\nSTART    LR    R10,R1                  IRXEFPL\n         USING EFPL,R10                - parm list\n         LR    R11,R0                  ENVBLOCK\n         USING ENVBLOCK,R11            - externals\n         L     R9,EFPLEVAL\n         L     R9,0(R9)                EVALBLOCK\n         USING EVALBLOCK,R9            - result\n         LA    R8,SHVBLK\n         USING SHVBLOCK,R8             - to set variables\n         BAL   R14,SETSHV\n*  set default return:\n         SR    R2,R2                   By default:\n         ST    R2,RETC                 return rc = 0\n         ST    R2,DATADDR              indicate RAM not allocated\n         LA    R2,1\n         ST    R2,EVALBLOCK_EVLEN      return result\n         MVI   EVALBLOCK_EVDATA,C'1'   '1'\n*---------------------------------------------------------------------\n*  get parm #1 (DSNAME)\n         LA    R2,1\n         BAL   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LTR   R4,R4\n         LA    R15,#NODSN\n         BZ    ERROR                   no parm\n         ST    R4,DSNLEN               store length\n         BCTR  R4,0                    length - 1\n         MVC   DSNAME(44),#BLANKS\n         EX    R4,MVCDSN               copy parm to DSNAME\n*---------------------------------------------------------------------\n*  Check if variable (dsname) exists, if not - create\n         LA    R1,DSNAME               where to store value\n         ST    R1,SHVVALA              store data addr\n         LA    R1,$PARMLEN             data length\n         ST    R1,SHVBUFL              store data length\n         L     R1,DSNLEN               real name length\n         STORE DSNAME,(R1),C=SHVFETCH  fetch variable\n* get parm #2 (MEMBER)\n         LA    R2,2\n         BAL   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LTR   R4,R4\n         LA    R15,#NOMEM\n         BZ    ERROR                   no parm\n         BCTR  R4,0                    length - 1\n         MVC   MEMBER(8),#BLANKS\n         EX    R4,MVCMEM               copy parm to DSNAME\n* get parm #3 (VOLUME)\n         MVC   VOLUME(6),#BLANKS\n         LA    R2,3\n         BAL   R14,GETPARM             R3=addr,R4=length (0=not found)\n         LTR   R4,R4\n         BZ    NOVOL                   blank\n         BCTR  R4,0                    length - 1\n         EX    R4,MVCVOL               copy parm to VOLUME\nNOVOL    DS    0H\n*---------------------------------------------------------------------\n*  Check if variable (dsname) exists, if not - create\n         CLI   SHVRET,SHVNEWV          did not exist?\n         BE    CREATE\n*        WTO   'Using existing $PARM:',ROUTCDE=11\n*      SAY   ,DSNAME,80\n         B     ALLOC\n*- create variable (dsname):\nCREATE   DS    0H\n*        WTO   'Creating $PARM...',ROUTCDE=11\n         XC    RECLEN(NUMLEN),RECLEN   Nullify other fields in $PARM\n         XC    RC(4),RC\n         XC    SHVNEXT(SHVBLEN),SHVNEXT clear it all\n         LA    R1,DSNAME\n         ST    R1,SHVVALA              store data addr\n         LA    R1,$PARMLEN\n         ST    R1,SHVVALL              store data length\n         L     R1,DSNLEN               real dsn length\n         STORE DSNAME,(R1)             store variable\n*---------------------------------------------------------------------\n*  Get data area for program data (PTAB, CTABs, NTABS, and DTABs)\nALLOC    DS    0H\n         USING PTAB,R2                 for P#DLEN  & P#LENGTH only\n         L     R2,=A(P#DLEN)           P#DATA length\n         LA    R2,P#LENGTH(R2)         add P#LENGTH for total\n         ST    R2,DATALEN              store data length (bytes)\n         GETMAIN RU,LV=(R2),LOC=RES\n         ST    R1,DATADDR              store data addr\n         LR    R2,R1\n*  Clear PTAB in Data:\n         MVI   0(R2),X'00'             set to clear\n         LR    R14,R2                  from\n         LA    R0,1(R2)                to\n         L     R1,DATALEN\n         BCTR  R1,0                    length\n         LR    R15,R1                  length\n         MVCL  R0,R14                  clear total PTAB\n*  Set required fields:\n         L     R1,=A(P#DLEN)           P#DATA size in bytes\n         SRL   R1,2                    /4 = size in words\n         ST    R1,P#ASIZE              ===> store P#ASIZE\n         LA    R1,P#DATA\n         ST    R1,P#AFREE              ===> store P#AFREE\n         L     R1,DATADDR\n         A     R1,DATALEN\n         ST    R1,P#AEND               ===> store P#AEND\n*  Call A31ESD:\n         ST    R2,A$PTAB\n         LA    R1,$PARM\n         ST    R1,A$PARM\n         LA    R1,A$PARM\n         CALL  A31ESD\n         CH    R15,H12\n         BNH   CONTINUE\n         LR    R1,R15\n         LA    R15,#NOOPN\n         CH    R1,=H'16'\n         BE    ERROR\n         LA    R15,#NORAM\n         CH    R1,=H'20'\n         BE    ERROR\n         LA    R15,#NOLOD\n         B     ERROR\n*---------------------------------------------------------------------\n*  R2->PTAB, R3->CTAB, R4->DTAB, R5->NTAB\n*  Create variable for PTAB:\nCONTINUE LA    R1,VVALUE\n         MVC   0(8,R1),P#NAME          store P#NAME\n         MVC   8(4,R1),P#ENTRY         store P#ENTRY\n         MVC   12(4,R1),P#SIZE         store P#SIZE\n         SR    R0,R0\n         ICM   R0,B'0111',P#SSI\n         ST    R0,16(R1)               store P#SSI\n         MVC   20(12,R1),P#ACODE       store flags & alias name\n         MVC   32(4,R1),P#AENTRY       store P#AENTRY\n         ST    R1,SHVVALA              set var addr\n         LA    R1,L'VVALUE             set var length\n         ST    R1,SHVVALL\n         LA    R1,L'#PTAB              var name length\n         STORE #PTAB,(R1)              store variable\n*        WTO   'PTAB created',ROUTCDE=11\n*        B     CDONE\n*-------------------------------------------------------------\n*  Create array variables for each CSECT and DSECT:\n         LA    R1,VVLEN                change length for others\n         ST    R1,SHVVALL              and store\n         XC    C#(2),C#                clear\n         USING CTAB,R3\n         USING DTAB,R4\n         L     R3,P#CTAB               1st CTAB\n         DROP  R2\nCLOOP    LTR   R3,R3\n         BZ    CDONE\n         XC    N#(2),N#\n         LA    R1,VVALUE               FILL CTAB:\n         MVC   0(8,R1),C#NAME          --\n         MVC   8(4,R1),C#ADDR          --\n         MVC   12(4,R1),C#SIZE         --\n         MVC   16(1,R1),C#TYPE         -- 0=SD, 3=LR, 4=PC, 5=CM\n         MVC   17(3,R1),C#SSI          --\n*    SHVVALA and SHVVALL remain the same (VVALUE and 20)\n*    update name and store REXX variable:\n         LH    R1,C#                   CTAB array counter\n         LA    R1,1(R1)                advance counter\n         STH   R1,C#                   update counter\n         LR    R0,R1                   counter value for SETNAME\n         MVC   VNAME(L'VNAME),#BLANKS\n         MVC   VNAME(L'#CTAB),#CTAB    set name\n         LA    R1,VNAME+L'#CTAB        set index position\n         BAL   R14,SETNAME             set index, R1=len(ndx)-1\n         LA    R1,L'#CTAB+1(,R1)       set name length\n         STORE VNAME,(R1)              create variable\n*      SAY   'SHVBLOCK=',SHVBLOCK,32\n*      SAY   'NAME=',VNAME,12\n*      SAY   'C#=',C#,2\n*\n*  process NTAB for CTAB:\n         L     R1,SHVNAML              ctab name length\n         LA    R5,VNAME\n         AR    R5,R1                   end of ctab name\n         MVI   0(R5),C'.'\n         MVC   CNAME(L'VNAME),VNAME    store name prefix 'CTAB.n.'\n         LA    R1,1(R1)                length + 1 for '.'\n         ST    R1,CNLEN                store length of 'CTAB.x'\n*      SAY   'CTAB=',(R3),40\n         L     R5,C#NTAB\n         USING NTAB,R5\nNLOOP    LTR   R5,R5\n         BZ    NDONE\n         LA    R1,VVALUE\n         MVC   0(8,R1),N#NAME          set fields\n         MVC   8(4,R1),N#ADDR\n         MVC   12(4,R1),N#SIZE\n         MVC   16(1,R1),N#TYPE\n         MVC   17(3,R1),N#DIM+1\n*        SHVVALA and SHVVALL remain the same (VVALUE and 20)\n         LH    R1,N#\n         LA    R1,1(R1)                get array index\n         STH   R1,N#                   update array index\n         LR    R0,R1                   index for SETNAME\n         MVC   VNAME(L'VNAME),CNAME    clear name\n         LA    R1,VNAME                set\n         A     R1,CNLEN                    index position\n         BAL   R14,SETNAME             set index, R1=len(ndx)-1\n         A     R1,CNLEN\n         LA    R1,1(R1)                name length = cnlen + R1 + 1\n         STORE VNAME,(R1)              create variable\n*      SAY   'SHVBLOCK=',SHVBLOCK,32\n*      SAY   'NAME=',VNAME,12\n*      SAY   'VAL =',VVALUE,20\n         L     R5,N#NEXT               next NTAB\n         B     NLOOP\n*\n*  process DTAB\nNDONE    L     R4,C#DTAB\nDLOOP    LTR   R4,R4\n         BZ    DDONE                   no more DTAB\n         XC    N#(2),N#\n         LA    R1,VVALUE               FILL CTAB:\n         MVC   0(8,R1),D#NAME          --\n         XC    8(4,R1),8(R1)           -- D#addr\n         MVC   12(4,R1),D#SIZE         --\n         XC    16(2,R1),16(R1)         -- reserv\n         MVC   18(2,R1),C#             -- parent CTAB number\n*    SHVVALA and SHVVALL remain the same (VVALUE and 20)\n*    update name and store REXX variable:\n         LH    R1,D#                   CTAB array counter\n         LA    R1,1(R1)                advance counter\n         STH   R1,D#                   update counter\n         LR    R0,R1                   counter value for SETNAME\n         MVC   VNAME(L'VNAME),#BLANKS\n         MVC   VNAME(L'#DTAB),#DTAB    set name\n         LA    R1,VNAME+L'#DTAB        set index position\n         BAL   R14,SETNAME             set index, R1=len(ndx)-1\n         LA    R1,L'#DTAB+1(,R1)       set name length\n         STORE VNAME,(R1)              create variable\n*  process NTAB for DTAB:\n         L     R1,SHVNAML              ctab name length\n         LA    R5,VNAME\n         AR    R5,R1                   end of ctab name\n         MVI   0(R5),C'.'\n         MVC   DNAME(L'VNAME),VNAME    store name prefix 'DTAB.n.'\n         LA    R1,1(R1)                length + 1 for '.'\n         ST    R1,DNLEN                store length of 'DTAB.x'\n*      SAY   'DTAB=',(R4),32\n         L     R5,D#NTAB\n         USING NTAB,R5\nNLOOP2   LTR   R5,R5\n         BZ    NDONE2\n         LA    R1,VVALUE\n         MVC   0(8,R1),N#NAME          set fields\n         MVC   8(4,R1),N#ADDR\n         MVC   12(4,R1),N#SIZE\n         MVC   16(1,R1),N#TYPE\n         MVC   17(3,R1),N#DIM+1\n*        SHVVALA and SHVVALL remain the same (VVALUE and 20)\n         LH    R1,N#\n         LA    R1,1(R1)                get array index\n         STH   R1,N#                   update array index\n         LR    R0,R1                   index for SETNAME\n         MVC   VNAME(L'VNAME),DNAME    clear name\n         LA    R1,VNAME                set\n         A     R1,DNLEN                    index position\n         BAL   R14,SETNAME             set index, R1=len(ndx)-1\n         A     R1,DNLEN\n         LA    R1,1(R1)                name length = cnlen + R1 + 1\n         STORE VNAME,(R1)              create variable\n*      SAY   'SHVBLOCK=',SHVBLOCK,32\n*      SAY   'NTAB=',(R5),32\n*      SAY   'NAME=',VNAME,12\n*      SAY   'VAL =',VVALUE,20\n         L     R5,N#NEXT               next NTAB\n         B     NLOOP2\n*\nNDONE2   L     R4,D#NEXT\n         B     DLOOP\n*\nDDONE    L     R3,C#NEXT               next CTAB\n         B     CLOOP\n*\nCDONE    DS    0H\n*---------------------------------------------------------------------\n*  Update value(dsname)\n*        WTO   'Updating $PARM...',ROUTCDE=11\n         XC    SHVNEXT(SHVBLEN),SHVNEXT clear it all\n         LA    R1,DSNAME\n         ST    R1,SHVVALA              store data addr\n         LA    R1,$PARMLEN\n         ST    R1,SHVVALL              store data length\n         L     R1,DSNLEN               real dsn length\n         STORE DSNAME,(R1)             store variable\n         B     EXIT\n*--------------------------------------------------------------------\nERROR    EQU   *\n         USING ERRBLK,R15\n         MVC   RETC(4),ERRCODE\n         MVC   MESSAGE(ERRMSGL),ERRMSG store for WTP\n* make parm for IRXSAY:\n         MVC   P1(8),=CL8'WRITE'       function request\n         LA    R1,ERRMSG\n         ST    R1,P2                   string addr\n         LA    R1,ERRMSGL\n         ST    R1,P3                   string length\n         ST    R11,P4                  ENVBLOCK\n         XC    P5(4),P5                clear RC\n* make addr list:\n         LA    R1,P1\n         ST    R1,A1\n         LA    R1,P2\n         ST    R1,A2\n         LA    R1,P3\n         ST    R1,A3\n         LA    R1,P4\n         ST    R1,A4\n         LA    R1,P5\n         ST    R1,A5\n         OI    A5,X'80'                set VL bit\n* call program:\n         LA    R1,A1                   parm list addr\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXSAY              addr IRXSAY\n         DROP  R15\n         LTR   R15,R15\n         BZ    NOSAY\n         BALR  R14,R15                 Call IRXSAY\n         MVI   EVALBLOCK_EVDATA,C'0'   Return '0'\n         B     EXIT\n* WTP message instead of Saying:\nNOSAY    LA    R1,MSGLEN\n         ST    R1,A1\n         OI    A1,X'80'\n         LA    R1,ERRMSGL\n         STH   R1,MSGLEN\n         LA    R1,A1\n         CALL  WTP\n         MVI   EVALBLOCK_EVDATA,C'0'   Return '0'\n         B     EXIT\n*\n*=====================================================================*\n*        S U B R O U T I N E S                                        *\n*---------------------------------------------------------------------*\n* SETNAME - set array variable name.\n*    entry :  R0 = array index requested, R1=index position\n*    use   :  C#, N#, D# = array counters, R0, R15 - work\n*    return:  R1=name length, VNAME has correct array name\n*---------------------------------------------------------------------*\nSETNAME  STM   R2,R0,S2\n         LR    R2,R1                   save\n* R0=array index, R2=index position in VNAME\n         CVD   R0,VAL                  convert\n         UNPK  D(5),VAL(8)             to\n         OI    D+4,C'0'                decimal\n         LA    R1,5                    set index length\n         BAL   R14,STRIPL              R1 = index length - 1\n         EX    R1,MVCNDX1              copy index to name\nSETRET   LM    R2,R0,S2                return R1\n         BR    R14\nMVCNDX1  MVC   0(0,R2),D\n*---------------------------------------------------------------\n* Strip number left: value: D, index length: R1.\n*    Set R1 to new length of index\n*---------------------------------------------------------------\nSTRIPL   STM   R2,R5,WRKSAVE2\n         LA    R2,D                     start with 1st char\n         LA    R5,1                     Min result length\n         LNR   R4,R5                    Increment = -1\nLOOPN    CLI   0(R2),C'0'\n         BNE   CUTN\n         LA    R2,1(R2)                 advance position\n         BXH   R1,R4,LOOPN              cut length by 1\n*  R2-> leftmost non-zero, R1 = new length\nCUTN     BCTR  R1,0\n         EX    R1,MVCNDX                shift index left\n         LM    R2,R5,WRKSAVE2\n         BR    R14\nMVCNDX   MVC   D(0),0(R2)\n*---------------------------------------------------------------------*\n* GET input parameter (addr,length) by number:                        *\n*    entry :  R2=parm # (not changed)                                 *\n*    use   :  R15 (return 0, when parm is found)                      *\n*    return:  to R14, R3=parm addr, R4=parm length (0, if not found)  *\n*---------------------------------------------------------------------*\nGETPARM  DS    0H\n         LR    R15,R2\n         SR    R4,R4                   make length zero\n         L     R3,EFPLARG              A(1st parm)\n         B     GETPL1                  go into loop\nGETPL    LA    R3,8(R3)                next parm\nGETPL1   CLC   0(8,R3),PARMEND\n         BER   R14                     not found\n         BCT   R15,GETPL\n* parm found:\n         L     R4,4(R3)                parm length\n         L     R3,0(R3)                parm addr\n         BR    R14\n*---------------------------------------------------------------------*\n* Set IRXEXCOM parameters:\n*---------------------------------------------------------------------*\nSETSHV   DS    0H\n* (re)make addr list:\n         LA    R1,#EXCOM\n         ST    R1,A1                   A1 = Addr of module name\n         XC    A2(8),A2                clear A2 and A3\n         LA    R1,SHVBLK\n         ST    R1,A4                   A4 -> SHVBLOCK\n         OI    A4,X'80'                set VL bit\n* (re)fill SHVBLOCK:\n         XC    SHVNEXT(SHVBLEN),SHVNEXT clear it all\n         BR    R14\n*--------------------------------------------------------------------*\n* Call IRXEXCOM:\n*--------------------------------------------------------------------*\nCALLXCOM ST    R14,SAVER14\n*     STM   R0,R7,S2\n*     LM    R0,R7,SHVBLK\n*     CALL  WTOREGS\n*     LM    R0,R7,S2\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXEXCOM            addr IRXEXCOM\n         DROP  R15\n         LA    R1,A1                   parm list addr\n         LR    R0,R11                  point to ENVBLOCK\n         BALR  R14,R15                 Call IRXEXCOM\n         ST    R15,SAVERC              save return code\n         L     R14,SAVER14             restore return address\n         BR    R14\n*=====================================================================\n*  Constants:\n*---------------------------------------------------------------------\nPARMEND  DC    8X'FF'\n#EXCOM   DC    C'IRXEXCOM'             REXX module name\n#EVDFLT  DC    F'250'                  Standard EVDATA max len\n#BLANKS  DC    CL44' '\n#GETBLK  DC    C'GETBLOCK'                  func for IRXRLT\nMVCDSN   MVC   DSNAME(0),0(R3)              move parm to DSNAME\nMVCMEM   MVC   MEMBER(0),0(R3)              move parm to MEMBER\nMVCVOL   MVC   VOLUME(0),0(R3)              move parm to VOLUME\nH12      DC    H'12'\n#PTAB    DC    C'PTAB'                 var   name\n#CTAB    DC    C'CTAB.'                array name\n#DTAB    DC    C'DTAB.'                array name\n#NTAB    DC    C'NTAB.'                array name\nVVLEN    EQU   20                      CTAB/NTAB/DTAB length\n* Error blocks:\n#NOMEM   DC    F'16'\n         DC    CL40'L_PGM: Error - no MEMBER passed        '\n#NODSN   DC    F'16'\n         DC    CL40'L_PGM: Error - no DSNAME passed        '\n#NOOPN   DC    F'16'\n         DC    CL40'L_PGM: Error - Cannot open data set    '\n#NORAM   DC    F'16'\n         DC    CL40'L_PGM: Error - REGION too small        '\n#NOLOD   DC    F'16'\n         DC    CL40'L_PGM: Error - $OPEN cannot be LOADed  '\n         LTORG\n*=====================================================================\n*  Mapping:\n*---------------------------------------------------------------------\nWRK      DSECT\nS        DS    18F\nS2       DS    18F\nWRKSAVE2 DS    4F\nVAL      DS    D\nD        DS    2D\nSAVERC   DS    F                       RC from IRXEXCOM\nSAVER14  DS    F\nRCESD    DS    F\nSHVBLK   DS    8F'0'                   IRXSHVB area\nRETC     DS    F\nDSNLEN   DS    F\n*- $PARM map for $OPEN:\n$PARM    DS    0F\nRC       DC    F'0'                    <Return Code\nDSNAME   DC    44C' '                  >Dataset Name\nMEMBER   DC    8C' '                   >PDS Member Name/blanks\nVOLUME   DC    6C' '                   >Volume Name/blanks\nRECLEN   DC    H'0'                    <Current Record Length\nTYPE     EQU   RECLEN\nDCBAD    DC    F'0'                   ><DCB Address\nBUFADDR  DC    F'0'                   ><Buffer Address\nLENGTH   DC    F'0'                    <Data Length in Buffer (bytes)\nRECADDR  DC    F'0'                    <Current Record Addr\nNUMLEN   EQU   *-RECLEN\n$PARMLEN EQU   *-DSNAME\n*- end of $PARM map\n*- Parm for IRXRLT:\nPA#1     DS    A                     > Addr of function\nPA#2     DS    A                      <Addr of A(new EVALBLOCK)\nPA#3     DS    A                     > Requested length of EVDATA,VL\nFUNC     DS    CL8                     =C'GETBLOCK'\nEVBADDR  DS    A\nEVDTLEN  DS    F\n*- end of parm for IRXRLT\n*- Parmlist for A31ESD:\nA$PARM   DS    A\nA$PTAB   DS    A\n*- Data area variables:\nDATALEN  DS    F                       length of data allocated\nDATADDR  DS    A                       addr of data allocated\n*- Rexx Function call parameter:\n*- R0 -> env block IRXENVB\n*- R1 -> following parameter list:\nA1       DS    A\nA2       DS    A\nA3       DS    A\nA4       DS    A\nA5       DS    A\nA6       DS    A\n* parameter values:\nP1       DS    CL8                     function requested\nP2       DS    A                       addr os data\nP3       DS    F                       length of data\nP4       DS    A                   IRXENVB optional, R0 is alternative\nP5       DS    A                       RC and VL bit\n* to create variables:\nVNAME    DS    CL12                    variable name\nCNAME    DS    CL12                    variable name\nDNAME    DS    CL12                    variable name\nC#       DS    H                       current CTAB #\nD#       DS    H                       current DTAB #\nN#       DS    H                       current NTAB #\nCNLEN    DS    F                       current name length\nDNLEN    DS    F                       current name length\n         DS    0F\nVVALUE   DS    CL36                    variable value\nCTABADDR DS    A\nMSGLEN   DS    H                       For WTP\nMESSAGE  DS    CL40                    For WTP\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH\n*\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\nPTAB     DSECT\n         COPY  $PTAB\nCTAB     DSECT\n         COPY  $CTAB\nDTAB     DSECT\n         COPY  $DTAB\nNTAB     DSECT\n         COPY  $NTAB\nERRBLK   DSECT\nERRCODE  DS    F\nERRMSG   DS    CL40\nERRMSGL  EQU   *-ERRMSG\n*        PRINT NOGEN\n         YREGS\n* REXX specific DSECTs:\n         IRXEFPL DSECT=YES             REXX parameter list\n         IRXEVALB                      REXX evaluation block EVALBLOCK\n         IRXEXTE                       REXX vector of external ep\n         IRXENVB                       REXX environment block ENVBLOCK\n         IRXSHVB                       REXX shared variables block\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,COND=(8,LE),\n//        PARM='TEST,RENT,REUS,CAL,MAP,AC=1,RMOD=ANY,AMOD=31'\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(IRXF@PGM) <=*.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* test changes, if any:\n//GO      EXEC PGM=IRXJCL,COND=(8,LE),\n//        PARM='MAPPGM SYS3.UTILITY.LOADLIB.TEST,IRXF@PGM,N'\n//* To get program data put library and program name to parm above\n//* Append option ,N to include details\n//SYSEXEC  DD DISP=SHR,DSN=SYS3.UTILITY.EXEC.SHARE         <== hlq.EXEC\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSUDUMP DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXF@SRT": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x03\\x06_\\x01\\x03!\\x8f\\tA\\x01T\\x01X\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-03-06T00:00:00", "modifydate": "2003-08-06T09:41:00", "lines": 340, "newlines": 344, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'IRXF@SRT REXX function L_SRT'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 03-07-2003 SVM Created using CTB file 386 IRXF@SRT (L_SORT)\n*                    Changes:\n*                    - made reentrant, added comments\n*.....................................................................\n*\n* FUNCTION:     Sort data records in STACK,\n*               Returns sorted records to the STACK\n*\n* Sample use:   If L_SORT(\"SORT FIELDS=(5,4,CH,A)\",\"M\")\n*                    ...\n*                    Notes:\n*                    1) start of the field to sort must be\n*                       set to n+4, i.e. col #1 is FIELDS=(5,...\n*                    2) 'M' means put SORT messages to SYSOUT,\n*                       other value or omitted - no SYSOUT produced.\n*\n* OUTPUT:       If Error - \"Incorrect call to procedure\" (R15>0)\n*                    - no or empty parm\n*                    - RC>0 from SORT (bad parm)\n*               If OK,\n*                    result = '1' normal execution response\n*\n* Attributes:\n*               Reus, reentrant, AMODE=31,RMODE=ANY\n*--------------------------------------------------------------------\nWRK      DSECT\n         DS    18F\nIRXEP    DS    F                       Addr of IRXSTK\n*\n* Parm for IRXSTK:\nSTKFUNC  DS    CL8\nSTKDAT   DS    F\nSTKLEN   DS    F\nSTKRC    DS    F\nSTKENV   DS    F                       Addr of REXX ENV block\nSTKRCE   DS    F\nIRXSTKP  DS    0F\nP1       DC    A(STKFUNC)\nP2       DC    A(STKDAT)\nP3       DC    A(STKLEN)\nP4       DC    A(STKRC)\nP5       DC    A(STKENV)\nP6       DC    A(STKRCE+X'80000000')\n*\n* SORT 31-bit extended parm list: R1-> SORTPL1 (p.6-13)\nSORTPL1  DC    A(SORTCTL)\nSORTPL2  DC    A(SORTE15+X'80000000')  31 bit amode\nSORTPL3  DC    A(SORTE35+X'80000000')  31 bit amode\nSORTPL4  DS    A                       passed user const - ADDR(WRK)\nSORTPL5  DC    F'-1'\nSORTCTL  DS    0H                      31-bit SORT parm list\n         DC    AL2(SORTCTE-SORTCT1)\nSORTCT1  DC    C'                                           '\nSORTCT2  DC    C' RECORD TYPE=V,LENGTH=4096 '\nSORTCTU  DS    CL256                   SORT FIELDS+...\nSORTCTE  EQU   *\n*\nBUFF     DS    CL4100\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n*---------------------------------------------------------------------\nIRXF@SRT BEGIN A=31\nWRK      WORK  LV=WRKL\n         B     START\nFIN      EQU   *\n         FIN\n*--------------------------------------------------------------------\n* ESTABLISH REXX environment\n*---------------------------------------------------------------------\nSTART    LR    R02,R01\n         ST    R00,STKENV\n         USING EFPL,R02\n         L     R03,EFPLARG\n         L     R04,EFPLEVAL\n         USING ARGTABLE_ENTRY,R03\n         L     R04,0(R04)\n         USING EVALBLOCK,R04\n*---------------------------------------------------------------------\n* Get parm 1 - SORT FIELDS=statement\n*---------------------------------------------------------------------\n         L     R05,ARGTABLE_ARGSTRING_PTR\n         LTR   R05,R05                 check addr\n         BM    FINNOK                  error - no parm\n         L     R06,ARGTABLE_ARGSTRING_LENGTH\n         LTR   R06,R06\n         BZ    FINNOK                  error - empty parm\n         MVI   SORTCTU,C' '\n         MVC   SORTCTU+1(255),SORTCTU  clear\n         C     R06,F256                check length\n         BNH   HMOV\n         LA    R06,256                 truncate Statement to 256 char\nHMOV     BCTR  R06,R00\n         MVI   SORTCTU,C' '\n         MVC   SORTCTU+1(L'SORTCTU-1),SORTCTU\n         EX    R06,MOVCTU\n*---------------------------------------------------------------------\n* Get parm 2 - 'M'= MSGPRT, other - MSGPRT=NONE\n*---------------------------------------------------------------------\n         LA    R03,ARGTABLE_NEXT\n         L     R05,ARGTABLE_ARGSTRING_PTR\n         LTR   R05,R05                 no 2nd parm - set default\n         BM    NMSG\n         L     R06,ARGTABLE_ARGSTRING_LENGTH\n         LTR   R06,R06\n         BZ    NMSG                    no 2nd parm - set default\n         CLI   0(R05),C'M'\n         BE    SMSG\nNMSG     MVC   SORTCT1,SORTCTN         Do not produce SORT msgs\n         B     HSORT\nSMSG     MVC   SORTCT1,SORTCTM         Set produce SORT messages\n         B     HSORT\n*---------------------------------------------------------------------\n*  Link to SORT\n*---------------------------------------------------------------------\nHSORT    EQU   *\n*     WTO '--- Before sorting:',Routcde=11\n* Create IRXSTK parm list:\n         LA    R1,STKFUNC\n         ST    R1,P1\n         LA    R1,STKDAT\n         ST    R1,P2\n         LA    R1,STKLEN\n         ST    R1,P3\n         LA    R1,STKRC\n         ST    R1,P4\n         LA    R1,STKENV\n         ST    R1,P5\n         LA    R1,STKRCE\n         ST    R1,P6\n         OI    P6,X'80'\n*\n         LOAD  EP=IRXSTK\n         ST    R00,IRXEP               entry addr\n         MVC   STKFUNC,KPULL\n* Create 31-bit SORT parameter list:\n         LA    R1,SORTCTL\n         ST    R1,SORTPL1              A(SORTCTL)\n         L     R1,=V(SORTE15)\n         ST    R1,SORTPL2              A(SORTE15+X'80000000')\n         OI    SORTPL2,X'80'\n         L     R1,=V(SORTE35)\n         ST    R1,SORTPL3              A(SORTE35+X'80000000')\n         OI    SORTPL3,X'80'\n         ST    R13,SORTPL4             passed user const - A(WRK)\n         L     R1,=F'-1'\n         ST    R1,SORTPL5              F'-1' indicate end of parm\n*\n         LA    R1,SORTCTE-SORTCT1      length of data\n         STH   R1,SORTCTL              store length\n         MVC   SORTCT1(L'SORTCT1),#BLANKS\n         MVC   SORTCT2(L'SORTCT2),#SORTCT2  \"RECORD stmt\"\n         ST    R13,SORTPL4\n* Link to SORT routine:\n         LA    R01,SORTPL1\n         LINK  EP=SORT\n         LTR   R15,R15\n         BNZ   FINNOK                  error - SORT.RC>0\n* Return '1' as a normal end indicator:\n         LA    R08,1\n         ST    R08,EVALBLOCK_EVLEN\n         MVI   EVALBLOCK_EVDATA,C'1'\n*---------------------------------------------------------------------\n* EXIT\n*---------------------------------------------------------------------\nEXIT     SR    R15,R15\n         B     FIN\nFINNOK   LA    R15,16\n         B     FIN\n*---------------------------------------------------------------------\n* Constants\n*---------------------------------------------------------------------\nF256     DC    F'256'\nMOVCTU   MVC   SORTCTU(0),0(R05)\nKPULL    DC    CL8'PULL    '\nMOVDTA   MVC   0(0,R15),0(R14)\nSORTCTM  DC    C' OPTION HIPRMAX=0,DYNALLOC=OFF             '\nSORTCTN  DC    C' OPTION HIPRMAX=0,DYNALLOC=OFF,MSGPRT=NONE '\n#BLANKS  DC    80C' '\n#SORTCT2 DC    C' RECORD TYPE=V,LENGTH=4096 '\n*---------------------------------------------------------------------\n* Sort Exit 15: get input record\n*    user const comes at offset 4\n*---------------------------------------------------------------------\nSORTE15  CSECT\nSORTE15  AMODE 31\nSORTE15  RMODE ANY\n         DROP  R13\n         BAKR  R14,0\n         LR    R11,R15\n         USING SORTE15,R11             address itself\n         USING SORPE15,R01             address parm\n         L     R07,SORUEC              address WRK\n         DROP  R01\n         USING WRK,R07\n         LA    R01,IRXSTKP\n         L     R15,IRXEP\n         BALR  R14,R15                 Call IRXSTK to get record\n         LTR   R15,R15\n         BNZ   NOMAS                   EOF\n         L     R08,STKLEN\n         C     R08,F4092\n         BH    ERROR\n         LA    R08,4(R08)\n         STH   R08,BUFF\n         XC    BUFF+2(2),BUFF+2\n         LR    R01,R08\n         LR    R15,R08\n         LA    R00,BUFF+4\n         L     R14,STKDAT\n         MVCL  R00,R14\n*MSG15 EQU WTO15+8\n*      MVC MSG15(13),BUFF+4\n*WTO15 WTO   '1234567890123',ROUTCDE=11\n         LA    R01,BUFF                Return buff with record\n         LA    R15,12                  back to SORT\n         PR\nNOMAS    EQU   *\n*     WTO '--- After  sorting:',Routcde=11\n         LA    R15,8                   EOF\n         MVC   STKFUNC,KQUEUE          Re-set for EXITE35\n         PR\nERROR    LA    R15,16                  Terminate SORT\n         PR\nF4092    DC    F'4092'\nKQUEUE   DC    CL8'QUEUE'\nSORPE15  DSECT\nSORADD   DS    F\nSORUEC   DS    F\n         DROP  R07,R11\n*---------------------------------------------------------------------\n* Sort exit 35 - process output record\n*---------------------------------------------------------------------\nSORTE35  CSECT\nSORTE35  AMODE 31\nSORTE35  RMODE ANY\n         BAKR  R14,0\n         LR    R11,R15\n         USING SORTE35,R11\n         USING SORPE35,R01\n         L     R07,SORUEC2\n         L     R08,SORADIN\n         DROP  R01\n         LTR   R08,R08\n         BZ    NMS                     last record\n         USING WRK,R07\n         LH    R01,0(R08)\n         S     R01,FIJO4\n         ST    R01,STKLEN\n         LA    R01,4(R08)\n         ST    R01,STKDAT\n*MSG   EQU WTO+8\n*      MVC MSG(13),0(R01)\n*WTO   WTO   '1234567890123',ROUTCDE=11\n         LA    R01,IRXSTKP\n         L     R15,IRXEP\n         BALR  R14,R15                 Call IRXSTK to queue record\n         LTR   R15,R15\n         BNZ   ERRORS                  Error while queueing record\n         LA    R15,4                   flag \"delete\" this record\n         PR                            for SORT\nNMS      LA    R15,8                   disconnect E35\n         PR\nERRORS   LA    R15,16                  terminate sort\n         PR\nFIJO4    DC    F'4'\nSORPE35  DSECT\nSORADIN  DS    F                       addr of record from phase 3\nSORADOU  DS    F                       addr of record in output area\nSORUEC2  DS    F                       user address constant\n         DROP  R07,R11\n*---------------------------------------------------------------------\n* MAPS\n*---------------------------------------------------------------------\n         REGS\nD        DSECT\n         IRXEFPL\n         IRXARGTB\n         IRXEVALB\n         END   IRXF@SRT\n//*\n//LKED    EXEC PGM=HEWLKED,\n//        PARM='RENT,CALL,MAP,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(IRXF@SRT) <=*.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* test changes, if any:\n//*O      EXEC PGM=IKJEFT1B,COND=(8,LE),\n//*       PARM='%PW'\n//GO      EXEC PGM=IRXJCL,COND=(8,LE),\n//        PARM='PW'\n//SYSEXEC  DD DISP=SHR,DSN=SYS3.UTILITY.EXEC.SHARE         <== hlq.EXEC\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//ABNLIGNR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//TEMPL    DD *\n Say 'Function=L_SORT'\n l.0 = 5\n l.1 = '1958  ANDY   '\n l.2 = '1951  SERGEY '\n l.3 = '1984  NATASHA'\n l.4 = '1981  ANNA   '\n l.5 = '1980  LEYLA  '\n Do i = 1 To l.0\n    QUEUE l.i\n    Say i l.i\n    End\n imax = \"QUEUED\"()\n Say 'Queued before sort:' imax\n Say 'Result from L_SORT =' IRXF@SRT(\"SORT FIELDS=(5,4,CH,A)\",\"N\")\n imax = \"QUEUED\"()\n Say 'Queued after  sort:' imax\n Do i = 1 To imax\n    Parse PULL line\n    Say i line\n    End\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXF@WTO": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\tD\\x01<\\x017\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T09:44:00", "lines": 316, "newlines": 311, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program IRX@MGCR\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'IRXF@WTO REXX function L_WTO'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 05-02-2003 SVM     Fixed WTOR to be reentrant\n* 12-18-2002 SVM Created using CTB file 386 IRXF@WTO (L_WTO)\n*                    Changes:\n*                    - ignore 3rd parm if not authorized\n*                    - add RED message option (2nd parm = 'A')\n*                    - ignore if 1st parm (message) is empty\n*                    - support lower/upper case in parm 2 and 3\n*.....................................................................\n*\n* FUNCTION:     Issue message to operator console\n*               Wait and return reply\n*                  or return msgid for DOM or return '1'\n*\n* Sample use:   msgid = L_WTO(msg,type,'s')\n*               msg - message text, if omitted or empty,\n*                     nothing will be done\n*               type - optional message type:\n*                  default - regular (green) scrollable message\n*                  'B' or 'b' - white message sticking on the console\n*                               until this job ends.\n*                  'A' or 'a' - red message sticking on the console\n*                               until removed.\n*                  'R' or 'r' - get a response from operator\n*               sup - optional authorised execution flag\n*                  default - run not authorised\n*                  'S' or 's' - attempt MODESET to supervisor state\n*                  (sup option is not used/tested in this package)\n*\n* Return:     R15 = 0\n*             '0' - if no/null msg parm passed (no action)\n*              or if WTO/WTOR failed\n*             '1' - normal execution response for no type\n*             msgid - normal execution for type = 'B' or 'A'\n*             reply - normal execution for type = 'R'\n*\n* Attributes: REENTRANT, AMODE=31, RMODE=ANY\n*--------------------------------------------------------------------\nWRK      DSECT\n         DS    18F\nTXTLEN   DS    H\nTYPE     DS    C\nSUPS     DS    C\nAUTHST   DS    F\n* command buffer for WTO:\n         DS    0F\nWTORX    DS    A                   A(REPLY) + VL\n         DS    A                   A(ECBREPLY)\nWTOCMD   DS    H                   AL2(L'WTOTXT+4) (WTO)\n*                                  AL1(L'REPLY),AL1(L'WTOTXT+4) (WTOR)\nWTOCMD2  DS    H                   DESC codes\nWTOTXT   DC    CL122' '            text area\nDSCODES  DS    XL2                 DESC code\nRTCODES  DS    XL2                 Rout code\n*\nREPLY    DS    CL119\nECBREPLY DS    F\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         REGS\n*--------------------------------------------------------------------\nIRXF@WTO BEGIN A=31\nWRK      WORK  LV=WRKL\n         B     START\n*\nFIN      SR    R15,R15                 always 0\n         FIN\n*--------------------------------------------------------------------\nSTART    LR    R2,R1                   IRXEFPL\n         USING EFPL,R2                 - parm list\n* not    LR    R11,R0                  ENVBLOCK\n* used   USING ENVBLOCK,R11            - externals\n         L     R3,EFPLARG\n         L     R4,EFPLEVAL\n         USING ARGTABLE_ENTRY,R3\n         L     R4,0(R4)                EVALBLOCK\n         USING EVALBLOCK,R4            - result\n         MVI   TYPE,C'N'\n         MVI   SUPS,C'N'\n* Set response = 1 (as a default)\n         MVI   EVALBLOCK_EVDATA,C'1'   return 1\n         LA    R9,1\n         ST    R9,EVALBLOCK_EVLEN\n*--------------------------------------------------------------------\n* Read parameter 1 (message), if no - do nothing\n*--------------------------------------------------------------------\n         L     R5,ARGTABLE_ARGSTRING_PTR\n         LTR   R5,R5\n         BM    ERROR                   no parm passed\n         L     R6,ARGTABLE_ARGSTRING_LENGTH\n         LTR   R6,R6\n         BZ    ERROR                   null parm passed\n         C     R6,F122\n         BNH   MOVTWK\n         LA    R6,122                  truncate if too long\nMOVTWK   STH   R6,TXTLEN               save text length\n         BCTR  R6,R0\n         EX    R6,MOVWT                copy text\n         LA    R6,5(R6)                length + 4\n         STH   R6,WTOCMD               clear flags1 and store length\n         MVC   WTOCMD+2(2),#MCSFLGS    copy MCS flags\n*--------------------------------------------------------------------\n* Read parameter 2 (type) N-green, R-WTOR, B-white, A-red (alarm)\n*--------------------------------------------------------------------\n         LA    R3,ARGTABLE_NEXT\n         L     R5,ARGTABLE_ARGSTRING_PTR\n         LTR   R5,R5\n         BM    EXECUTE\n         L     R6,ARGTABLE_ARGSTRING_LENGTH\n         LTR   R6,R6\n         BZ    RP3\n         MVI   TYPE,C'R'\n         CLI   0(R5),C'R'\n         BE    RP3\n         CLI   0(R5),C'r'\n         BE    RP3\n         MVI   TYPE,C'B'\n         CLI   0(R5),C'B'\n         BE    RP3\n         CLI   0(R5),C'b'\n         BE    RP3\n         MVI   TYPE,C'A'\n         CLI   0(R5),C'A'\n         BE    RP3\n         CLI   0(R5),C'a'\n         BE    RP3\n         MVI   TYPE,C'N'               default\n*--------------------------------------------------------------------\n* Read parameter 3 (S - if APF, set supervisor state)\n*--------------------------------------------------------------------\nRP3      LA    R3,ARGTABLE_NEXT\n         L     R5,ARGTABLE_ARGSTRING_PTR\n         LTR   R5,R5\n         BM    EXECUTE\n         L     R6,ARGTABLE_ARGSTRING_LENGTH\n         LTR   R6,R6\n         BZ    EXECUTE                 null parm passed\n         MVI   SUPS,C'S'\n         CLI   0(R5),C'S'\n         BE    EXECUTE\n         CLI   0(R5),C's'\n         BE    EXECUTE\n         MVI   SUPS,C'N'               default\n*--------------------------------------------------------------------\n* EXECUTE requested command:\n*--------------------------------------------------------------------\nEXECUTE  CLI   SUPS,C'S'\n         BNE   EXECUT2\n         TESTAUTH FCTN=1               Check\n         ST    R15,AUTHST              (save)\n         LTR   R15,R15                 if auth\n         BNZ   EXECUT2                 you are not authorized...\n         MODESET KEY=ZERO,MODE=SUP     set supervisor state\nEXECUT2  LA    R1,WTOTXT               txt length\n         AH    R1,TXTLEN\n         MVC   2(2,R1),#RTCODES        copy rout codes\n         CLI   TYPE,C'N'\n         BE    HWTO                    green\n         CLI   TYPE,C'R'\n         BE    HWTOR                   WTOR\n         CLI   TYPE,C'A'\n         BE    HWTOA\n*--------------------------------------------------------------------\n* Issue sticked message:\n*--------------------------------------------------------------------\nHWTOB    MVC   0(2,R1),#DSCODEW        Make it white  it white\n         B     HWTO0\n*                                                     it RED\nHWTOA    MVC   0(2,R1),#DSCODER        Make it red\nHWTO0    SR    R0,R0\n         LA    R1,WTOCMD\n         SVC   35\n         LTR   R15,R15\n         BNZ   EXIT0                   WTO failed\n         ST    R1,EVALBLOCK_EVDATA     return msgid for DOM\n         LA    R9,4\n         ST    R9,EVALBLOCK_EVLEN\n         B     EXIT                    Normal exit\n*--------------------------------------------------------------------\n* Issue WTOR\n*--------------------------------------------------------------------\nHWTOR    XC    ECBREPLY,ECBREPLY            clear ECBREPLY\n         MVI   REPLY,C' '\n         MVC   REPLY+1(L'REPLY-1),REPLY     clear REPLY\n         LA    R1,REPLY\n         ST    R1,WTORX                     store REPLY addr\n         OI    WTORX,X'80'                  and set VL bit\n         LA    R1,ECBREPLY\n         ST    R1,WTORX+4                   store ECB addr\n         LA    R1,L'REPLY\n         STC   R1,WTORX+8                   store reply length\n*        MVC   WTOCMD2(2),#ZEROCOD          reset desc codes\n         SR    R0,R0\n         WTOR  MF=(E,WTORX)\n         LTR   R15,R15\n         BNZ   EXIT0                   WTOR failed\n         WAIT  ECB=ECBREPLY\n         MVC   EVALBLOCK_EVDATA(119),REPLY\n         LA    R9,119\n         LA    R5,EVALBLOCK_EVDATA+118\nSTRIPT   CLI   0(R5),C' '\n         BNE   SETL\n         BCTR  R5,R0\n         BCT   R9,STRIPT\nSETL     LTR   R9,R9\n         BNZ   SETL2\n         LA    R9,1\nSETL2    ST    R9,EVALBLOCK_EVLEN       return reply text\n         B     EXIT                     normal exit\n*--------------------------------------------------------------------\n* Issue green WTO:\n*--------------------------------------------------------------------\nHWTO     MVC   0(2,R1),#DSCODEG        Make it green\n         SR    R0,R0\n         LA    R1,WTOCMD\n         SVC   35\n         LTR   R15,R15\n         BNZ   EXIT0\n*--------------------------------------------------------------------\n* EXIT:\n*--------------------------------------------------------------------\n* Normal exit:\nEXIT     CLI   SUPS,C'S'\n         BNE   FIN\n         L     R15,AUTHST              Check\n         LTR   R15,R15                 if auth\n         BNZ   FIN                     you are not authorized\n         MODESET KEY=NZERO,MODE=PROB   remove supervisor state\n         B     FIN\n*\n* Error exit:\nEXIT0    CLI   SUPS,C'S'\n         BNE   ERROR\n         L     R15,AUTHST              Check\n         LTR   R15,R15                 if auth\n         BNZ   ERROR\n         MODESET KEY=NZERO,MODE=PROB   remove supervisor state\n* Set Response to '0':\nERROR    MVI   EVALBLOCK_EVDATA,C'0'   return 1\n         LA    R9,1\n         ST    R9,EVALBLOCK_EVLEN\n         B     FIN\n*--------------------------------------------------------------------\nMOVWT    MVC   WTOTXT(0),0(R5)\nF122     DC    F'122'\n#ZEROCOD DC    X'0000'                  DESC CODE for WTOR\n#MCSFLGS DC    B'1000000000000000'\n#DSCODEW DC    B'0100000000000000'      DESCRIPTOR CODE 2 (wht,rmv)\n#RTCODES DC    B'0000000000000000'      Routcde\n#DSCODER DC    B'0000000000100000'      DESCRIPTOR CODE 11 (red,stay)\n#DSCODEG DC    B'0010000000000000'      DESCRIPTOR CODE   (green,rmv)\n         LTORG\n*--------------------------------------------------------------------\n* Mapping:\n*--------------------------------------------------------------------\nD        DSECT\n         IRXEFPL\n         IRXARGTB\n         IRXEVALB\n         END   IRXF@WTO\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='RENT,CALL,MAP,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(IRXF@WTO) <=*.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* test changes, if any:\n//*O      EXEC PGM=IKJEFT1B,COND=(8,LE),\n//*       PARM='%PW'\n//GO      EXEC PGM=IRXJCL,COND=(8,LE),\n//        PARM='PW'\n//SYSEXEC  DD DISP=SHR,DSN=SYS3.UTILITY.EXEC.SHARE         <== hlq.EXEC\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  DUMMY\n//SYSUDUMP DD SYSOUT=*\n//TEMPL    DD *\n x = IRXF@WTO('Red Test message-ignore','A','S')\n Say 'Red Message,   response from IRXF@WTO (hex) =' C2X(x)\n call FWAIT(3s)\n x = L_DOM(x)\n Say 'RC from L_DOM =' x\n x = IRXF@WTO('White Test message-ignore','B')\n Say 'White Message, response from IRXF@WTO (hex) =' C2X(x)\n call FWAIT(3s)\n x = L_DOM(x)\n Say 'RC from L_DOM =' x\n x = IRXF@WTO('Green Test message-ignore')\n Say 'Green Message, response from IRXF@WTO =' x\n call FWAIT(3s)\n x = IRXF@WTO('Reply \"U\"','R')\n Say 'Reply =' x\n x = IRXF@WTO('','a')\n Say 'Null Message,  response from IRXF@WTO (hex) =' x\n x = IRXF@WTO()\n Say 'No parm,       response from IRXF@WTO (hex) =' x\n EXIT\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IRXFLOCJ": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\tG\\x00\\x8e\\x00d\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T09:47:00", "lines": 142, "newlines": 100, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* 07/10/03 SVM Added WTP subr for some functions\n//* 04/30/03 SVM Added IRXF@FWT replacing FWAIT\n//* 04/23/03 SVM Added IRXF@PGM\n//* 04/15/03 SVM Added IRXF@CND for CNVDATE (CBT file 216)\n//* 03/24/03 SVM Created using CBT 386 file IRXFLOCJ\n//*                  Include only functions specified below.\n//*\n//* When adding entry, change \"ENTRIES\" field!\n//*---------------------------------------------------------------------\n//IRXFLOC EXEC PGM=ASMA90,REGION=2048K,\n//            PARM=(NODECK,OBJECT)\n//SYSPRINT DD SYSOUT=*\n//SYSTERM  DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSLIN   DD DSN=&&TEMP1(IRXFLOC),DISP=(NEW,PASS),SPACE=(CYL,(1,1,1))\n//SYSIN    DD *\n*\nIRXFLOC  CSECT\nIRXFLOC  AMODE 31\nIRXFLOC  RMODE ANY\n         DC    CL8'IRXFPACK'            HEADER\n         DC    FL4'24'                  LENGTH OF HEADER\n         DC    FL4'12' <=============== change # of ENTRIES\n         DC    FL4'0'                   RESERVED\n         DC    FL4'32'                  LENGTH ADDR.\n* 1\n         DC    CL8'L_DOM   '            REXX NAME\n         DC    VL4(IRXF@DOM)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 2\n         DC    CL8'L_WTO   '            REXX NAME\n         DC    VL4(IRXF@WTO)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 3\n         DC    CL8'DSN4DDN '            REXX NAME\n         DC    VL4(DSN4DDN)             ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 4\n         DC    CL8'L_DDN   '            REXX NAME\n         DC    VL4(IRXF@DDN)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 5\n         DC    CL8'L_DSN   '            REXX NAME\n         DC    VL4(IRXF@DSN)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 6\n         DC    CL8'L_PDS   '            REXX NAME\n         DC    VL4(IRXF@PDS)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 7\n         DC    CL8'FWAIT   '            REXX NAME\n         DC    VL4(IRXF@FWT)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 8\n         DC    CL8'L_ALC   '            REXX NAME\n         DC    VL4(IRXF@ALC)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 9\n         DC    CL8'L_FRE   '            REXX NAME\n         DC    VL4(IRXF@FRE)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 10\n         DC    CL8'L_SORT  '            REXX NAME\n         DC    VL4(IRXF@SRT)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 11\n         DC    CL8'L_PGM   '            REXX NAME\n         DC    VL4(IRXF@PGM)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n* 12\n         DC    CL8'L_FWT   '            REXX NAME\n         DC    VL4(IRXF@FWT)            ADD.\n         DC    FL4'0'                   RESERV.\n         DC    CL8'        '            ENT. POINT\n         DC    CL8'        '            LOAD DD\n*\n         END   IRXFLOC\n//*\n//*---------------------------------------------------------------------\n//* Create new IRXFLOC and add to the hlq.LOAD lib as IRXFLOC1\n//*  (change the name or rename the member later in hlq.LOAD)\n//*---------------------------------------------------------------------\n//LINK     EXEC PGM=IEWL,REGION=256K,COND=(8,LE),\n//     PARM=('CALL,LET,LIST,MAP,XREF,RENT,AMODE=31,RMODE=ANY')\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LINKLIB.TEST        <== LINKLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(2,2)),DISP=NEW\n//SYSLIN   DD DSN=&&TEMP1(IRXFLOC),DISP=(SHR,PASS)\n//         DD *\n   INCLUDE SYSLIB(IRXF@DOM)\n   ENTRY   IRXF@DOM\n   INCLUDE SYSLIB(IRXF@WTO)\n   ENTRY   IRXF@WTO\n   INCLUDE SYSLIB(WTP)\n   ENTRY   WTP\n   INCLUDE SYSLIB(DSN4DDN)\n   ENTRY   DSN4DDN\n   INCLUDE SYSLIB(IRXF@DDN)\n   ENTRY   IRXF@DDN\n   INCLUDE SYSLIB(IRXF@DSN)\n   ENTRY   IRXF@DSN\n   INCLUDE SYSLIB(IRXF@PDS)\n   ENTRY   IRXF@PDS\n   INCLUDE SYSLIB(IRXF@ALC)\n   ENTRY   IRXF@ALC\n   INCLUDE SYSLIB(IRXF@FRE)\n   ENTRY   IRXF@FRE\n   INCLUDE SYSLIB(IRXF@SRT)\n   ENTRY   IRXF@SRT\n   INCLUDE SYSLIB(IRXF@PGM)\n   ENTRY   IRXF@PGM\n   INCLUDE SYSLIB(IRXF@FWT)\n   ENTRY   IRXF@FWT\n   ENTRY IRXFLOC\n   NAME IRXFLOC(R)\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFCHK": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\tV\\x010\\x010\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T09:56:00", "lines": 304, "newlines": 304, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//*  First modify JOB card and data set names to your environment\n//*  Assemble and Link program RACFCHK\n//*\n//*  Is been used in SYS3.ROSC.ETSOLIB to produce messages\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DSN=SYS1.AMODGEN,DISP=SHR\n//         DD  DSN=SYS3.RACFCHK.INSTALL,DISP=SHR        <== RACF MACLIB\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------*\n     TITLE 'RACFCHK  Check Authorisation status for DSN and UserID'\n*---------------------------------------------------------------------*\n* History of Changes (last comes first):                              *\n*                                                                     *\n* 02-27-2003 SVM Changed to std macros\n*                    Added check if RACF is active\n* 01-04-2001 SVM Created\n*.....................................................................*\n*                                                                     *\n* FUNCTION:\n*               1) Reads and validates parameter                      *\n*               1) Executes SVM0010 to Check authority                *\n*               2) Returns result in R15:\n*                   24: Invalid parameter\n*                   20: Unlimited access (not specified in RACF)\n*                   16: Alter access\n*                   12: Control access\n*                    8: Update access\n*                    4: Read access\n*                    0: No access\n*\n* How to use from REXX:\n*               par = ',,DSNAME'\n*               ADDRESS 'LINKMVS' 'RACFCHK' 'par'\n*               Select\n*                  When rc = 20 Then Say 'Unlimited'\n*                  When rc = 16 Then Say 'Alter'\n*                  When rc = 12 Then Say 'Control'\n*                  When rc = 8  Then Say 'Update'\n*                  When rc = 4  Then Say 'Read'\n*                  When rc = 0  Then Say 'Denied'\n*                  Otherwise         Say 'Error'\n*               End\n*\n* INPUT:\n*               R1        = addr(Parameter)\n*               Parameter = HL2(len)CLlen'Text'\n*               Text      = 'UserID,DATASET,Dsname'\n*               UserID    - 1 to 8 chars\n*               DATASET   - as written\n*               Dsname    - 1 to 44 chars\n*                                                                     *\n* ATTRIBUTES:\n*               REENTRANT,AMOD=31,RMOD=ANY\n* Externals:\n*               SVM0010                                               *\n*---------------------------------------------------------------------*\nRACFCHK  BEGIN\nWRK      WORK  LV=WRKLEN,LOC=RES\n         B     START\nEXIT     FIN   0H\n*\nSTART    DS    0H\n*   Check if RACF is active (used code from SHOWMVS, CBT file 492):\n         L     R15,CVTPTR              (16) CVT address\n         USING CVT,R15\n         ICM   R2,B'1111',CVTRAC       RCVT\n         BZ    ERROR                   No RACF\n         USING RCVT,R2\n         CLC   RCVTID,=C'RCVT'         Is this a RACF?\n         BNE   ERROR                   no\n         TM    RCVTSTAT,RCVTRNA        RACF Inactive?\n         BO    ERROR                   yes, exit\n         CLI   RCVTDSNL,0              Is it really RACF?\n         BZ    ERROR                   no, exit\n         DROP  R15\n         DROP  R2\n\n*   Extract and validate data from Parm to PAR0010:\n         MVI   PUSER,C' '\n         MVC   PUSER+1(7),PUSER    Clear PUSER\n         MVI   PDSN,C' '\n         MVC   PDSN+1(43),PDSN     Clear PDSN\n*\n         L     R1,0(R1)            Addr of EXEC parameter\n         LH    R5,0(,R1)           Param length\n         BCTR  R5,R0               Parm length - 1\n         LTR   R5,R5               Check if > 0\n         BNP   ERROR               No parm\n         LA    R5,2(R5,R1)         Parm last char addr\n         LA    R4,1                Loop step\n*\n         LA    R2,2(,R1)           Parm text addr\n         LR    R10,R2              Save start\n*\n*   Search for 1st comma:\nLOOP1    CLI   0(R2),C','          Comma?\n         BE    PRCUSER\n         BXLE  R2,R4,LOOP1         Next Char\n* - Comma not found:\n         B     ERROR\n*\nPRCUSER  LR    R9,R2               Comma position\n         SR    R9,R10              Field length\n         BZ    NEXT1               Empty - leave blank\n         C     R9,F08\n         BH    ERROR               Too long\n         BCTR  R9,R0               Len - 1\n*   Leave PUSER blank = Check it for myself\n         EX    R9,MVCUSR           Copy UserID from Parm to PUSER\n*\nNEXT1    LA    R2,1(R2)            Next field start\n         CR    R2,R5\n         BNL   ERROR\n         LR    R10,R2              Save start\n*\n*   Search for 2nd comma:\nLOOP2    CLI   0(R2),C','          Comma?\n         BE    PRCCLS\n         BXLE  R2,R4,LOOP2         Next Char\n* - Comma not found:\n         B     ERROR\n*\n*   We skip 2nd parameter,\n*   SVM0010 defaults it to DATASET\n*\nPRCCLS   LA    R10,1(R2)           Next field start\n         CR    R10,R5\n         BH    ERROR               DSN must be not empty\n*\nPRCDSN   LR    R9,R5\n         SR    R9,R10              Field length - 1\n         C     R9,F43\n         BH    ERROR               Too long\n         EX    R9,MVCDSN           Copy DSN from Parm\n         LA    R10,PAR0010         Addr to traslate\n         LA    R9,PRRET-PUSER-1    Length - 1 to translate\n         EX    R9,TRANSL           Translate to Upper case\n         B     CONT\n*\nMVCUSR   MVC   PUSER(1),0(R10)\nMVCDSN   MVC   PDSN(1),0(R10)\nTRANSL   TR    0(1,R10),TABELL\n*\nCONT     DS    0H\n*        MVC   SAVER1(4),=C'@@@@'  *TT Test eye catcher\n*        DC    X'0000'             *TT Test\n*   Prepare and Call SVM0010:\n         LA    R1,PAR0010\n         CALL  SVM0010\n*\n*   Process return codes:\n*\n         L     R2,PRRET\n         C     R2,F20              RACF REturn Code = X'14'\n         BE    OK\n         L     R15,F20             20 = \"Not protected\"\n         B     EXIT\n*\nOK       L     R15,PRREA           Return RACF Reason Code\n         B     EXIT\n*\nERROR    L     R15,F24             24 = Parm invalid\n         B     EXIT\n*---------------------------------------------------------------------\n*  Constants:\n*\n         DS    0D\nF08      DC    F'8'\nF10      DC    F'10'\nF20      DC    F'20'\nF24      DC    F'24'\nF43      DC    F'43'\n*\n*  TABLE FOR TRANSLATION OF LOWER TO UPPER CASE.\n*\n         DS    0D\nTABELL   DC    106AL1(*-TABELL)\n         DC    X'7C'                    ?    --> ?\n         DC    22AL1(*-TABELL)\n         DC    X'C1C2C3C4C5C6C7C8C9'    a - i --> A - I\n         DC    7AL1(*-TABELL)\n         DC    X'D1D2D3D4D5D6D7D8D9'    j - r --> J - R\n         DC    8AL1(*-TABELL)\n         DC    X'E2E3E4E5E6E7E8E9'      s - z --> S - Z\n         DC    22AL1(*-TABELL)          other\n         DC    X'7B'                    ?    --> ?\n         DC    15AL1(*-TABELL)          other\n         DC    X'5B'                    ?    --> ?\n         DC    47AL1(*-TABELL)          other\n*\n         LTORG\n*\n***********************************************************************\n*  WORKAREA IS A GETMAINED AREA USED\n*\nWRK      DSECT\n         DS    0D\nSAVE     DS    18F\nSAVER1   DS    F\nPAR0010  EQU    *\n         PAR0010\n         DS    0D\n*\nWRKLEN   EQU   *-WRK\n*\n         EJECT\n* SVM0010 Parm format.     Input:\n*PAR0010  EQU    *\n*PUSER    DS     CL8         User ID\n*PDSN     DS     CL44        DSNAME\n*                          Output:\n*PRRET    DS     F           RACF return code\n*PRREA    DS     F           RACF reason code\n*PSFRC    DS     F           SAF  return code\n*PSFRS    DS     F           SAF  reason code\n*\n         PRINT NOGEN\n         CVT   DSECT=YES\nRCVT     ICHPRCVT\n         EJECT\n         REGS\n         EJECT\n         END\n//*\n//* LINK EDIT the Program:\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='CALL,MAP,RENT,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(RACFCHK) -HLQ.LOAD\n//*YSLMOD  DD DISP=SHR,DSN=SYS3.ROSC.ETSOLIB(RACFCHK)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//* Test the Program:\n//* Empty parm: RC=24\n//GO1      EXEC PGM=RACFCHK,COND=(8,LE,ASMH)\n//* PARM=''\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//*\n//* No DSN: RC=24\n//GO2      EXEC PGM=RACFCHK,COND=(8,LE,ASMH),\n// PARM=','\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//*\n//* Empty DSN RC=24\n//GO3      EXEC PGM=RACFCHK,COND=(8,LE,ASMH),\n// PARM='s,,'\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//*\n//* Valid parm, 1-st Party request: RC=20 (Not protected)\n//GO4      EXEC PGM=RACFCHK,COND=(8,LE,ASMH),\n// PARM=',,SYS3.UTILITY.EXEC.SHARE'\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//*\n//* Valid parm, 1-st Party request: RC=16 (Alter)\n//GO5      EXEC PGM=RACFCHK,COND=(8,LE,ASMH),\n// PARM=',,SYS1.LINKLIB'                            - RACF prot ALTER\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//\n//* Valid parm, 1-st Party request: RC=12 (Control)\n//GO6      EXEC PGM=RACFCHK,COND=(8,LE,ASMH),\n// PARM=',,Cp.D2900001.Protectd.ForSVM.ASCNTL'      - RACF prot CONTROL\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//*\n//* Valid parm, 1-st Party request: RC=0 (No access)\n//GO7      EXEC PGM=RACFCHK,COND=(8,LE,ASMH),\n// PARM=',,Cp.D2900001.Protectd.ForSVM.ASNONE'      - RACF prot NONE\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//*\n//* Valid parm, 1-st Party request: RC=4 (Read)\n//GO8      EXEC PGM=RACFCHK,COND=(8,LE,ASMH),\n// PARM=',,Cp.D2900001.Protectd.ForSVM.ASREAD'      - RACF prot READ\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//*\n//* Valid parm, 1-st Party request: RC=8 (Update)\n//GO9      EXEC PGM=RACFCHK,COND=(8,LE,ASMH),\n// PARM=',,Cp.D2900001.Protectd.ForSVM.ASUPD'       - RACF prot UPDATE\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//\n//*************************************************\n//* Valid Parm, 3-rd party request: not yet supported by this program\n//GO3      EXEC PGM=RACFCHK,COND=((8,LE,ASMH),EVEN),\n// PARM='USERID,DATASET,Cp.D2900001.Protectd.ForSVM'\n//STEPLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST         - HLQ.LOAD\n//SYSUDUMP DD SYSOUT=*\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVMALC6": {"ttr": 3337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x03\\x13_\\x01\\x03!\\x8f\\tW\\x01|\\x01u\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2003-05-15T00:00:00", "modifydate": "2003-08-06T09:57:00", "lines": 380, "newlines": 373, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH    EXEC PGM=ASMA90,REGION=4M,\n//         PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST     <== hlq.MACLIB\n//SYSUT1   DD  UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD  *\n*=====================================================================\n     TITLE 'SVM0006: DYNALLOC interface'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 05-15-2003 SVM Added allocation of existing GDG: dsn=MY.GDG(0/-1/..)\n* 03-13-2003 SVM Fixed SNAP operations to be reenrant\n* 03-03-2003 SVM Updated to alloc for a given DDNAME (if any)\n*                    and optional dsn(member)\n* 01-17-2002 SVM Updated to BEGIN-WORK-FIN\n* 10-24-2001 SVM Created\n*.....................................................................\n*\n* FUNCTION:\n*               1) Converts Parm to SVC 99 data structure.\n*               2) Invokes SVC 99 for Dynalloc/Unalloc.\n*               3) If Dynalloc then returns DDNAME and DSORG in Parm.\n*               4) Returns RC from SVC 99 to caller in R15.\n*               5) Linkedited to $OPEN interface program\n*               Note: Does not set \"Permanent Alloc\" X'0052' attribute\n*\n* PARM (SVMPAR6 DSECT):\n*               R1 = Addr of the following data structure:\n*               TDDN     ><CL8  Dynalloc-in/out, Unalloc-input\n*               TDSORG    <XL2  Dynalloc-output, Unalloc-n/a\n*               TDSN     > CL54 Dynalloc-input,  Unalloc-n/a\n*                          can include optional pds member:\n*                          'dsname(member)'\n*               TVOL     ><CL6  Dynalloc-in/out, Unalloc-n/a\n*               TERR      <XL4  Both-Copy of S99ERROR and S99INFO\n* OUTPUT:\n*               R15 > 0 - parm error or dynalloc error\n* ENTRY POINTS:\n*               SVMALC6 - Dynalloc\n*               SVMDEL6 - Unalloc\n* ATTRIBUTES:\n*               REENTRANT, AMODE=24\n*---------------------------------------------------------------------\n         EJECT\n*---------------------------------------------------------------------\nSVMALC6  BEGIN A=24,R=24\n         SR    R7,R7                   Indicate ALLOCATE\n         B     COMMON                  Goto Common continuation\n         ENTRY SVMDEL6\nE1OFFST  EQU   *-SVMALC6\nSVMDEL6  SAVE  (14,12)                 Save registers\n         LA    R7,4                    Indicate DELETE\n         LA    R3,E1OFFST              Set Entry Offset\n         LR    R12,R15                 ->SVMDEL6\n         SR    R12,R3                  Set Base to SVMALC6\n*=====================================================================\n* Common Continuation                  Prolog Section\nCOMMON   DS    0H\nWA       WORK  LV=WALEN,LOC=BELOW\n         LA    R10,0(R1)\n         USING SVMPAR6,R10             Address Parameter\n*---------------------------------------------------------------------\n* Fill in the Data structure for SVC 99:\n         LA    R4,WRB                  Addr of S99RB\n         USING S99RB,R4                Set Base for S99RB\n* Make Parm address list:\n         ST    R4,WRBPTR               Set S99RB addr in RBPTR\n         OI    WRBPTR,S99RBPND         Set VL bit in RBPTR\n* Make S99RB:\n         XC    S99RB(RBLEN),S99RB      Clear RB\n         MVI   S99RBLN,RBLEN           Set the Length of RB\n         MVI   S99VERB,S99VRBAL        Set Verb Code = ALLOC\n         LA    R5,WRBX                 Addr of S99RBX\n         ST    R5,S99S99X              Set Addr of RBX in RB\n         LA    R5,WTUP1                Addr of TU Pointer List\n         ST    R5,S99TXTPP             Set Addr of TUP list in RB\n* Make S99RBX to produce WTO warnings for User:\n         LA    R5,WRBX                 Addr of RBX\n         USING S99RBX,R5               Set Base for S99RBX\n         XC    S99RBX(RBXLEN),S99RBX   Clear S99RBX entirely\n         MVC   S99EID(6),EID           Set EID (C'S99RBX')\n         MVI   S99EVER,S99RBXVR        Set Version\n         OI    S99EOPTS,S99EIMSG       Set Flag to Put Messages\n         OI    S99EOPTS,S99EWTP        Set Flag to WTO Messages\n         OI    S99FLAG1,S99NOMNT       Set Flag1 to no mount\n         OI    S99FLAG1,S99GDGNT       Set Flag1 to always Locate GDG\n*    Uncomment the one you need:\n*        MVI   S99EMGSV,S99XINFO       Set Msg Level Info\n         MVI   S99EMGSV,S99XWARN       Set Msg Level Warning\n*        MVI   S99EMGSV,S99XSEVE       Set Msg Level Sever Error\n*---------------------------------------------------------------------\n* Switch to Continue depending on Entry point requested function\n         LA    R1,SWITCH1\n         B     0(R7,R1)                Switch by Entry\nSWITCH1  B     DYN1                    - Dynalloc\n         B     DEL1                    - Unalloc\n*---------------------------------------------------------------------\n* Make Text Unit Pointer List for Dynalloc:\nDYN1     DS    0H\n* Check for dsn(member):\n         MVI   DSN,C' '\n         MVC   DSN+1(43),DSN           clear DSN\n         MVC   MEMBER(8),#BLANKS       clear MEMBER\n         LA    R3,TDSN                 first char of tdsn\n         LA    R1,TDSN+L'TDSN-1        last char of tdsn\n         LA    R2,1\n         LNR   R2,R2                   step = -1\nLOOP1    CLI   0(R1),C')'              search backward for ')'\n         BE    FOUND1\n         BXH   R1,R2,LOOP1\n         B     NOMEM1\n* R1-> ')'\nFOUND1   ST    R1,SECOND\nLOOP2    CLI   0(R1),C'('              search backward for '('\n         BE    FOUND2\n         BXH   R1,R2,LOOP2\n         B     ERRORPAR\n* R1-> '('  Check if it is member name or GDG:\nFOUND2   CLI   1(R1),C'+'\n         BE    PRCGDG\n         CLI   1(R1),C'-'\n         BE    PRCGDG\n         CLI   1(R1),C'0'\n         BL    PRCMEM\n         CLI   1(R1),C'9'\n         BH    PRCMEM\n* Process GDG: LOCATE the real DSN\nPRCGDG   MVC   DSN(44),TDSN\n         LA    R1,DSN                  Build CAMLST1 parms:\n         ST    R1,CAMLST1+4\n         LA    R1,LOCAREA\n         ST    R1,CAMLST1+12\n         SR    R1,R1\n         ST    R1,CAMLST1\n         ST    R1,CAMLST1+8\n         IC    R1,=AL1(68)\n         STC   R1,CAMLST1              Indicate 'CAMLST NAME'\n*\n         LOCATE CAMLST1                Reset DSN to real name\n         LTR   R15,R15                 (e.g. A.B.G0012V00)\n         BNZ   ERRORPAR\n         B     DYN12\n*\nPRCMEM   LR    R2,R1\n         SR    R2,R3\n         BCTR  R2,0                    dsn length - 1 for MVC\n         EX    R2,MOVDSN               copy dsn\n         LA    R1,1(R1)                Next to '('\n         L     R2,SECOND\n         SR    R2,R1                   member len\n         BCTR  R2,0                    member len-1 for MVC\n         EX    R2,MOVMEMB              copy member name\n         B     DYN12\nNOMEM1   DS    0H\n         MVC   DSN(44),TDSN            copy\nDYN12    DS    0H\n*---------------------------------------------------------------------\n* Make text unit pointer list for Dynalloc:\n*        WTO   'SVMALC6: Create Allocation...'\n         LA    R6,WTUDSN               Addr of 1-st TU\n         ST    R6,WTUP1                Set the 1-st TU ptr\n         LA    R6,WTUSTS               Addr of 2-nd TU\n         ST    R6,WTUP2                Set the 2-nd TU ptr\n         LA    R6,WTUDDN               Addr of 3-rd TU\n         ST    R6,WTUP3                Set the 3-rd TU ptr\n         LA    R6,WTUORG               Addr of 4-th TU\n         ST    R6,WTUP4                Set the 4-th TU ptr\n         LA    R6,WTUVOL               Addr of 5-th TU\n         ST    R6,WTUP5                Set the 5-th TU ptr\n         LA    R6,WTUMEM               Addr of 6-th TU\n         ST    R6,WTUP6                Set the 6-th TU PTR\n         OI    WTUP6,S99TUPLN          Set VL bit in 6-th TU ptr\n         CLI   MEMBER,C' '             Member present ?\n         BNE   WITHMEM                 yes\n         OI    WTUP5,S99TUPLN          Set VL bit in 5-th TU ptr\nWITHMEM  DS    0H\n* Copy Data to Text Units:\n         MVC   WTUDSN(DSNLEN),DSNTU    Set to DSNAME Template\n         MVC   WDSN(44),DSN            Copy DSN from Parm\n         MVC   WTUMEM(MEMLEN),MEMTU    Set to MEMBER Template\n         MVC   WMEM(8),MEMBER          Copy MEMBER\n         MVC   WTUSTS(STSLEN),STSTU    Set to DISP Template\n         MVC   WTUDDN(DDNLEN),RETDDN   Set to Return DDNAME Template\n         CLC   TDDN(8),=8C' '          If PARM.DDN is blank\n         BE    DYN11                   Y- skip\n         MVC   WTUDDN(2),DALDDN        N - Reset key to Input DDNAME\n         MVC   WDDN(8),TDDN            and Copy DDN from Parm\nDYN11    MVC   WTUORG(ORGLEN),RTORG    Set to Return DSORG Template\n         MVC   WTUVOL(VOLLEN),RTVOL    Set to Return VOLSER Template\n         CLC   TVOL(6),=6C' '          If PARM.VOL is blank\n         BE    CONTINUE                Y- skip\n         MVC   WTUVOL(2),DALVOL        N - Reset key to Input Volume\n         MVC   WVOL(6),TVOL            and Copy VOL from Parm\n         B     CONTINUE                Common Continuation\n*---------------------------------------------------------------------\n* Re-Set RB and Text Units for Unallocate:\nDEL1     DS    0H\n*        WTO   'SVMALC6: Delete Allocation...'\n         MVI   S99VERB,S99VRBUN        RB: Set Verb Code = UNALLOCATE\n         LA    R6,WTUDDN               Addr of 1-st TU\n         MVC   WTUDDN(DDNLEN),RETDDN   Set to Return DDNAME Template\n         MVC   WTUDDN(2),DALDDN        Reset DDNAME Key to Input\n         MVC   WDDN(8),TDDN            Copy DDNAME from Parm\n         L     R5,S99TXTPP             Load Addr of TUP list from RB\n         ST    R6,0(,R5)               Set the 1-st TU ptr\n         OI    0(R5),S99TUPLN          Set VL bit for last TU ptr\n         B     CONTINUE\n*=====================================================================\n* Call DYNALLOC:\nCONTINUE LA    R1,WRBPTR               Put Addr of RBPTR in Reg 1\n*\n         DYNALLOC                      Invoke DYNALLOC\n*\n         MVC   TERR(4),S99ERROR        Copy S99ERROR & S99INFO to Parm\n         LR    R2,R15\n         LTR   R15,R15                 Check RC\n         BZ    DONE                    OK\n*---------------------------------------------------------------------\nERROR    DS    0H\n*        WTO   'SVMALC6: Dynalloc Error (RC>0), see SNAP'\n* Output SNAP dump for debug:\n         MVC   SNAPDCB(#SNAPDCL),#SNAPDCB\n         MVC   SNAPC(#SNAPCL),#SNAPC\n         LA    R1,SNAPDCB\n         ST    R1,SNAPDAD\n         MVI   SNAPDAD,X'8F'           INDICATE OPEN FOR OUTPUT\n         LA    R1,SNAPDAD\n         SVC   19                      OPEN\n*        OPEN  (SNAPDCB,OUTPUT)\n         LA    R2,SNAPDCB\n         SNAP  DCB=(R2),MF=(E,SNAPC)   ID=245,PDATA=ALL\n         LA    R1,SNAPDAD\n         MVI   0(R1),X'80'\n         SVC   20                      CLOSE\n*        CLOSE SNAPDCB\n         LA    R15,ERRCODE\n         B     EXIT\n*\nERRORPAR DS    0H\n         WTO   'SVMALC6: DSN(MEMBER) invalid or GDG not found',        X\n               ROUTCDE=11\n         LA    R15,ERRCODE\n         B     EXIT\nDONE     DS    0H\n*---------------------------------------------------------------------\n* Switch to Continue depending on Entry point requested function\n         LA    R1,SWITCH2\n         B     0(R7,R1)                Switch by Entry\nSWITCH2  B     DYN2                    - Dynalloc\n         B     EXIT                    - Unalloc\n*---------------------------------------------------------------------\n* Copy returned data to Parm fields:\nDYN2     MVC   TDDN(8),WDDN            Set SVMPAR6.TDDN\n         MVC   TDSORG(2),WORG          Set SVMPR6.DSORG\n         CLC   TVOL(6),=6C' '          If PARM.VOL is blank\n         BNE   EXIT                    N - skip\n         MVC   TVOL(6),WVOL            Set Parm.VOL\n         B     EXIT\n*======================================================================\nEXIT     FIN\n*---------------------------------------------------------------------\n* Constants and DSECTs:\nERRCODE  EQU   4\n#BLANKS  DC     CL8' '\nMOVDSN   MVC   DSN(0),TDSN\nMOVMEMB  MVC   MEMBER(0),0(R1)\nRBLEN    EQU   (S99RBEND-S99RB)        24\nRBXLEN   EQU   36\nDSNTU    DC    AL2(DALDSNAM)           0002 Template for Input DSNAME\n         DC    X'0001'\n         DC    X'002C'                      Set length to 44\n         DC    44C' '\nDSNLEN   EQU   *-DSNTU                      Length of template\nSTSTU    DC    AL2(DALSTATS)           0004 Template for Input DISP\n         DC    X'0001'\n         DC    X'0001'\n         DC    X'08'                        08=SHR\n         DC    X'00'                        keep aligned at halfword\nSTSLEN   EQU   *-STSTU                      Length of template\nRETDDN   DC    AL2(DALRTDDN)           0055 Template for Output DDN\n         DC    X'0001'\n         DC    X'0008'\n         DC    8C' '\nDDNLEN   EQU   *-RETDDN                     Length of template\nRTORG    DC    AL2(DALRTORG)           0057 Template for Output DSORG\n         DC    X'0001'\n         DC    X'0002'\n         DC    2X'0'\nORGLEN   EQU   *-RTORG                      Length of template\nRTVOL    DC    AL2(DALRTVOL)           005D Template for Output VOLSER\n         DC    X'0001'\n         DC    X'0006'\n         DC    6C' '\nVOLLEN   EQU   *-RTVOL                      Length of template\nMEMTU    DC    AL2(DALMEMBR)           0003 Template for Input MEMBER\n         DC    X'0001'\n         DC    X'0008'                      length=8\n         DC    8C' '\nMEMLEN   EQU   *-MEMTU                      Length of template\nEID      DC    C'S99RBX'\nDALDDN   DC    AL2(DALDDNAM)           0001 Key for input DDN\nDALVOL   DC    AL2(DALVLSER)           0010 Key for input VOLSER\n*\n#SNAPC   SNAP  DCB=#SNAPDCB,MF=L,ID=245,PDATA=ALL\n#SNAPCL  EQU   *-#SNAPC\n#SNAPDCB DCB BLKSIZE=882,DSORG=PS,LRECL=125,MACRF=(W),RECFM=VBA,       *\n               DDNAME=SNAP\n#SNAPDCL EQU   *-#SNAPDCB\n         LTORG\n*----------------------------------------------------------------------\nWA       DSECT\nS        DS    18F                     Savearea\nWRBPTR   DS    A                       Pointer to S99RB\nWRB      DS    XL(RBLEN)               S99RB\nWRBX     DS    XL(RBXLEN)              S99RBX\nWTUP1    DS    A                       TUP 1\nWTUP2    DS    A                       TUP 2\nWTUP3    DS    A                       TUP 3\nWTUP4    DS    A                       TUP 4\nWTUP5    DS    A                       TUP 5\nWTUP6    DS    A                       TUP 6\nWTUDSN   DS    XL(DSNLEN)              TU 1 - DSN\nWDSN     EQU   WTUDSN+6                   DSN position\nWTUSTS   DS    XL(STSLEN)              TU 2 - DISP\nWSTS     EQU   WTUSTS+6                   DISP position\nWTUDDN   DS    XL(DDNLEN)              TU 3 - DDNAME (ret)\nWDDN     EQU   WTUDDN+6                   DDN position\nWTUORG   DS    XL(ORGLEN)              TU 4 - DSORG  (ret)\nWORG     EQU   WTUORG+6                   DSORG position\nWTUVOL   DS    XL(VOLLEN)              TU 5 - VOLUME (ret)\nWVOL     EQU   WTUVOL+6                   VOL position\nWTUMEM   DS    XL(MEMLEN)              TU 6 - MEMBER\nWMEM     EQU   WTUMEM+6                   MEM position\n*\nSECOND   DS    F                       work\nDSN      DS    CL44\nMEMBER   DS    CL8\nSNAPDAD  DS    A\nSNAPDCB  DCB BLKSIZE=882,DSORG=PS,LRECL=125,MACRF=(W),RECFM=VBA,       *\n               DDNAME=SNAP\nSNAPC    SNAP  PDATA=ALL,MF=L\n         DS    0D\nCAMLST1  DS    0F\n         DS    AL1(68)\n         DS    AL1(0)\n         DS    AL1(0)\n         DS    AL1(0)\n         DS    A(DSN)\n         DS    A(0)\n         DS    A(LOCAREA)\nLOCAREA  DS    0D\n         DS    XL256\n         DS    2D\nWALEN    EQU   *-WA\n*\nSVMALC6  CSECT\nSVMPAR6  SVMPAR6 DSECT=YES             PARM data structure\n         YREGS                         General Regs\n         IEFZB4D0                      S99 Dsects\n         IEFZB4D2                      S99 Mnemonics for Text Units\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,\n//        PARM='LET,NCAL,LIST,MAP,RENT,RMOD=24,AMOD=24',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST       <== hlq.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//         DD  *\n     ALIAS SVMDEL6\n     NAME  SVMALC6(R)\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SVMLOAD": {"ttr": 3588, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x03\\x12\\x0f\\x01\\x03!\\x8f\\x10\\x01\\x00a\\x00^\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-04-30T00:00:00", "modifydate": "2003-08-06T10:01:00", "lines": 97, "newlines": 94, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//         EXEC ASMACLG,PARM.C='LIST,RENT',\n// COND.L=(8,LE),PARM.L='AMODE=31,RMODE=ANY,RENT',\n// COND.G=(8,LE),PARM.G='SVM00000'              <== module name to load\n//C.SYSLIB  DD DISP=SHR,DSN=SYS1.MACLIB\n//          DD DISP=SHR,DSN=SYS1.MODGEN\n//          DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST     <== hlq.MACLIB\n//C.SYSPRINT DD SYSOUT=*\n//C.SYSIN DD *\n*---------------------------------------------------------------------\n      TITLE 'SVMLOAD program to find/load a module'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 04/30/03 SVM Created for IRXF@FWT fo locate SVM00000\n*---------------------------------------------------------------------\n* FUNCTION:\n*              Either find module addr if already loaded, or\n*              LOAD it and return address.\n* INPUT:\n*              R1->addr(PDATA)\n*              PDATA  DS H (length)\n*                     DS CLlength (module name)\n*\n* OUTPUT:\n*              R15 = 0 - not found and not loaded\n*              R15 = addr of entry point (normal end)\n* ATTRIBUTES:\n*              Reenrant, RMODE=ANY\n*---------------------------------------------------------------------\nSVMLOAD  BEGIN\nWRK      WORK  LV=WRKLEN\n         B     START\nEXIT     FIN\n* - Check parm:\nSTART    L     R1,0(R1)                PARM\n         LH    R15,0(R1)               length\n         LTR   R15,R15\n         BZ    EXIT                    No parm - return 0\n         BCTR  R15,0                   length-1\n         MVC   NAME,=CL8' '\n         EX    R15,MVCNAME             copy to NAME\n* - Search if module is already loaded:\n         L     R1,CVTPTR               CVT address\n         USING CVT,R1\n         L     R1,CVTTCBP\n         L     R2,PSATOLD-PSATNEW(R1)  My TCB\n         DROP  R1\n         USING TCB,R2\n         L     R4,TCBLLS               LLE chain\n         USING LLE,R4\n         USING CDENTRY,R3\nLOOP     LTR   R4,R4\n         BZ    END\n         L     R3,LLECDPT               CDE for this LLE\n         CLC   CDNAME(8),NAME\n         BE    FOUND\n         L     R4,LLECHN                next LLE\n         B     LOOP\n* - Module not found - try to LOAD:\nEND      DS    0H\n         LOAD EPLOC=NAME,ERRET=LOADERR\n         ST    R0,ADDR\n         B     RETURN\n* - Module found - return address\nFOUND    DS    0H\n         MVC   ADDR(4),CDENTPT\nRETURN   DS    0H\n*       SAY 'SVM00000 addr=',ADDR,4\n         L     R15,ADDR\n         B     EXIT\n* - If LOAD not successful:\nLOADERR  SR    R15,R15\n         B     EXIT\n*-------------------\nMVCNAME  MVC   NAME(0),2(R1)\n         LTORG\nWRK      DSECT\nS        DS    18F\nADDR     DS    A\nNAME     DS    CL8\nWRKLEN   EQU   *-WRK\n         YREGS\n         CVT     DSECT=YES             CVT\n         IKJTCB  DSECT=YES             TCB\n         IHAPSA\n*        IHARB\n         IHACDE\n         IHALLE\n         END\n//L.SYSLMOD DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(SVMLOAD) <=*.LOAD\n//*L.SYSLIB  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST     <== hlq.LOAD\n//G.STEPLIB DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST      <== hlq.LOAD\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVM00000": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x01\\x03\\x12\\x0f\\x01\\x03!\\x8f\\x10\\x05\\x00$\\x00$\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2003-04-30T00:00:00", "modifydate": "2003-08-06T10:05:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='OBJECT,NODECK,NOXREF,BATCH'\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------*\n     TITLE 'SVM00000  Data module - only LOAD'\n*---------------------------------------------------------------------*\n* History of Changes (last comes first):\n*\n* 04/30/03 SVM Created\n*.....................................................................*\n*\n* FUNCTION:\n*               1) Contain shared data, must be in the same library\n*                  as IRXFLOC.\n* ATTRIBUTES:\n*               Only Load\n*---------------------------------------------------------------------*\nSVM00000 START\nSVM00000 RMODE   ANY\n         SVM00000\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='RMOD=ANY,OL',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LINKLIB(SVM00000)   <== LINKLIB\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVM0010": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\x10\"\\x00t\\x00t\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T10:22:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//*  First modify JOB card and data set names to your environment\n//*  Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DSN=SYS1.AMODGEN,DISP=SHR\n//         DD  DSN=SYS3.RACFCHK.INSTALL,DISP=SHR      <== RACF maclib\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------*\n     TITLE 'SVM0010  Inqury Authorisation status for DSN and UserID'\n*---------------------------------------------------------------------*\n* History of Changes (last comes first):\n*\n* 02-27-2003 SVM Changed to std macros\n* 01-04-2001 SVM Created\n*.....................................................................*\n*\n* FUNCTION:\n*               1) Executes RACROUTE REQUEST=AUTH macro to check\n*                  the authorisation level for UserID and DSN.\n*                     If PUSER - blank, do 1st party request.\n*                     Else do 3-rd party request (to do later...)\n*               2) Copy RACF return codes to a parameter data fields\n*\n* INPUT:\n*               R1 -> Data structure (see PAR0010 macro).\n*\n* ATTRIBUTES:\n*        REENTRANT, AMOD=31, RMOD=ANY\n*---------------------------------------------------------------------*\nSVM0010  BEGIN\nWRK      WORK  LV=WRKLEN,LOC=RES\n         B     START\nEXIT     FIN\n*\nSTART    LR    R5,R1               ORIGINAL PARAMETER\n         USING PARM,R5\n         LA    R8,RACLAB           To\n         LA    R10,RACLA1          From\n         L     R9,RACLEN           Data length\n         LR    R11,R9              Data length\n         MVCL  R8,R10              Copy data to WORK\n*\n         LA    R7,PDSN             Point to Dsname\n         LA    R4,PUSER            Point to Userid\n         LA    R8,RACLAB           Point to PARAMETER LIST IN RACF\n         USING SAFP,R8\n         LA    R2,WRKD\n         CLI   PUSER,C' '\n         BE    REQ1\n*\n* 3rd party request here - implement later (must have key=0 and Sup).\n*\nREQ1     RACROUTE REQUEST=AUTH,ENTITY=((7)),                           +\n               WORKA=((2)),MF=(E,RACLAB)\n*\nCONT     MVC   PRRET(4),SAFPRRET\n         MVC   PRREA(4),SAFPRREA\n         MVC   PSFRC(4),SAFPSFRC\n         MVC   PSFRS(4),SAFPSFRS\n         LA    R15,0\n         B     EXIT\n*----------------------------------------------------------------------\n*  CONSTANTS\n*\nRACLA1 RACROUTE REQUEST=AUTH,CLASS='DATASET',STATUS=ACCESS,            X\n               DSTYPE=M,RELEASE=1.9.2,MF=L\nRACLEN   DC    A(*-RACLA1)\n         LTORG\n*----------------------------------------------------------------------\n*  WORKAREA\n*\nWRK      DSECT\n         DS    0D\nSAVE     DS    18F\nRACLAB RACROUTE REQUEST=AUTH,CLASS='DATASET',STATUS=ACCESS,            X\n               DSTYPE=M,RELEASE=1.9.2,MF=L\nWRKD     DS    512C\n         DS    0D\n*\nWRKLEN   EQU   *-WRK\n*\n         EJECT\nPARM     DSECT\n         PAR0010\n* Parameter format         Input:\n*PUSER    DS     CL8         User ID\n*PDSN     DS     CL44        DSNAME\n*                          Output:\n*PRRET    DS     F           RACF return code\n*PRREA    DS     F           RACF reason code\n*PSFRC    DS     F           SAF  return code\n*PSFRS    DS     F           SAF  reason code\n*\n         PRINT NOGEN\n         EJECT\n         REGS\n         EJECT\n         ICHSAFP\n         EJECT\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='NCAL,RENT,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(SVM0010) <= *.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//\n//* Test this Program with RACFCHK\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVM0028": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\x10$\\x00\\xbf\\x00\\xbe\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T10:24:00", "lines": 191, "newlines": 190, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First  modify JOB card and dataset names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*-------------------------------------------------------------------\n     TITLE 'SVM0028  Module returns allocated/used dir blocks'\n*-------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 03/05-2003 SVM Changed to LOAD and call $OPEN\n* 12-19-2002 SVM Created using $TOPEN1\n*.....................................................................\n*\n* FUNCTION:\n*                    Open PO dataset, calculate total and used\n*                    directory blocks and return in R15\n* INPUT:\n*                    Standard parm interface\n*                        parm1 DS CL44 - dsnname\n*                        parm2 DS CL6  - volume (might be blanks)\n*\n* OUTPUT:\n*                        parm3 DS H - # of dir blocks\n*                        parm4 DS H - # of used dir blocks\n*                        parm5 DS H - # of members\n* Attributes:\n*                    reentrant, AMODE=31,RMODE=Any\n* Externals:\n*                    $OPEN - dynalloc interface module\n*--------------------------------------------------------------------\nSVM0028  BEGIN A=31\nWRK      WORK    LV=WRKL,LOC=BELOW\n         B       START\nEXIT     L     R3,$OPENADR\n         LTR   R3,R3\n         BZ    FIN\n         DELETE EP=$OPENI\n         LTR   R15,R15\n         BZ    FIN\n**       WTO   'DELETE EP=$OPENI failed',ROUTCDE=11\nFIN      FIN\n*---------------------------------------------------------------------\n*  Open Input Dataset to read directory:\nSTART    LA    R15,$PARM\n         ST    R15,$PADDR              Set $PADDR\n         OI    $PADDR,X'80'            Set VL bit\n         LM    R1,R5,0(R1)             Load parm addresses:\n* R1->DSN, R2->VOL, R3->ablk, R4->ublk, R5->memb\n         MVC   DSNAME(44),0(R1)\n         MVC   VOLUME(6),0(R2)\n         MVC   MEMBER(8),#BLANKS       Clear MEMBER to read Directory\n         XC    RECLEN(NUMLEN),RECLEN   Nullify other fields\n*        WTO   'TEST: Calling $OPENI...',ROUTCDE=11\n         LOAD  EP=$OPENI\n         ST    R0,$OPENADR\n         LR    R1,R0\n         LA    R0,$CLSOFFS(R1)\n         ST    R0,$CLOSADR\n         LA    R0,$REDOFFS(R1)\n         ST    R0,$READADR\n*\n         LA    R1,$PADDR\n*        CALL  $OPENI\n         L     R15,$OPENADR\n         BASSM R14,R15\n         LTR   R15,R15\n         BZ    TREAD0\n*        WTO   'TEST: $OPEN failed',ROUTCDE=11\n         SR    R15,R15\n         B     EXIT\n*  Read Input Dir blocks:\nTREAD0   DS    0H\n*        WTO   'TEST: Calling $READ loop...',ROUTCDE=11\n         SR    R9,R9                   Dir block counter\n         SR    R6,R6                   Used dir block counter\n         SR    R7,R7                   Flag Last used found\n         SR    R8,R8                   # of members\nTREAD    LA    R1,$PADDR\n*        CALL  $READ\n         L     R15,$READADR\n         BASSM R14,R15\n         LTR   R15,R15\n         BNZ   TCLOSE                  end of file\n         LTR   R7,R7                   Check if unused block\n         BNZ   CALC0                   unused block\n* Read dir entries:\n         L     R2,RECADDR\n         LH    R1,0(R2)                blk length\n         LA    R0,0(R1,R2)             next to last used byte\n         LA    R2,2(R2)                1st entry\n         USING ENTRY,R2\nLOOP     SR    R1,R1\n         ICM   R1,8,COUNTER\n         SLL   R1,3                    use 5 bits\n         SRL   R1,26                   length of DATA\n         LA    R1,12(R1)               length of ENTRY\n* process member ENTRY:\n         CLC   NAME(8),#MAX\n         BE    LAST\n         LA    R8,1(R8)                # of members\n         LA    R2,0(R1,R2)             next entry\n         CR    R2,R0\n         BNL   NOTLAST\n         B     LOOP\n*\nLAST     LA    R7,1                    last: R7 > 0\n*        WTO   'SVM0028: #MAX detected',ROUTCDE=11\nNOTLAST  LA    R6,1(R6)                # of used blocks\nCALC0    LA    R9,1(R9)                # of blocks\n         B     TREAD\n*\n*  Close Input Dataset:\nTCLOSE   DS    0H\n         STH   R9,0(R3)                store ablk\n         STH   R6,0(R4)                store ublk\n         STH   R8,0(R5)                store memb\n*        WTO   'TEST: Calling $CLOSE...',ROUTCDE=11\n         LA    R1,$PADDR\n*        CALL  $CLOSE\n         L     R15,$OPENADR\n         BASSM R14,R15\n         LTR   R15,R15\n         BNZ   CLSERR\n         SR    R15,R15\n         B     EXIT\nCLSERR   DS    0H\n*        WTO 'TEST: $CLOSE failed',ROUTCDE=11\n*- Error EXIT:\nEEXIT    DS    0H\n         LA    R15,16\n         B     EXIT\n*-------------------\n*  Constants:\n*-------------------\n#BLANKS  DC    CL8' '\n#MAX     DC    8X'FF'\n$CLSOFFS EQU   80                      X'50' offset of $CLOSE ep\n$REDOFFS EQU   48                      X'30' offset of $READ ep\n         LTORG\n*-------------------\nWRK      DSECT\nS        DS    18F\nRESULT   DS    F\n$PADDR   DC    X'80'                   Std Parm addr list\n         DC    AL3($PARM)              Actually AL4\n*- $PARM map for $OPEN:\n$PARM    DS    0F\nRC       DC    F'0'                    <Return Code\nDSNAME   DC    44C' '                  >Dataset Name\nMEMBER   DC    8C' '                   >PDS Member Name/blanks\nVOLUME   DC    6C' '                   >Volume Name/blanks\nRECLEN   DC    H'0'                    <Current Record Length\nTYPE     EQU   RECLEN\nDCBAD    DC    F'0'                   ><DCB Address\nBUFADDR  DC    F'0'                   ><Buffer Address\nLENGTH   DC    F'0'                    <Data Length in Buffer (bytes)\nRECADDR  DC    F'0'                    <Current Record Addr\nNUMLEN   EQU   *-RECLEN\n*- end of $PARM map\n$OPENADR DS    A                       addr of $OPENI\n$CLOSADR DS    A                       addr of $CLOSE\n$READADR DS    A                       addr of $READ\nWRKL     EQU   *-WRK\n* PO directory entry map:\nENTRY    DSECT\nNAME     DS    CL8\nTTR      DS    XL3\nCOUNTER  DS    XL1\nDATA     DS    XL1\n*\nSVM0028  CSECT\n         YREGS\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,COND=(8,LE),\n//        PARM='RENT,REUS,NCAL,MAP,AC=1,RMOD=ANY,AMOD=31'\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(SVM0028) <= *.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//\n//* Test with IRXF@DDN, IRXF@DSN\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVM0030": {"ttr": 3602, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\t\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\x10'\\x00k\\x00^\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@\"", "ispf": {"version": "01.09", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T10:27:00", "lines": 107, "newlines": 94, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------*\n     TITLE 'SVM0030 Find UCB for VOLSER'\n*---------------------------------------------------------------------*\n* History of Changes (last comes first):\n*\n* 05-02-2003 SVM Added 4-digit unit processing\n* 02-25-2003 SVM Changed to return UCBTYP+2 in 1st byte of R15\n* 11-08-2002 SVM Created\n*.....................................................................*\n*\n* FUNCTION:\n*               Find UCB for VOLSER\n*\n* INPUT:        R1 = A(A(VOLUME),A(UNIT),A(UTYPE))\n*               VOLSER DS  CL6\n*               UNIT   DS  CL4\n*               UTYPE  DS  XL1\n* OUTPUT:\n*               R15=0 - not found\n*               R15>0 - UCB (i.e. C'x37A')\n*               1st byte of R15 (x) has UCBTYP+2 byte\n* ATTRIBUTES:\n*               REENTRANT, AMODE=31, RMODE=ANY\n*               Uses UCBSCAN COPY\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\nWRK      DSECT\nWRKSAVE  DS    18F                     REGISTER SAVE AREA\nD        DS    D\nVOL      DS    6C\n         DS    0D\nX100     DS    100C                    UCBSCAN WORKAREA\nX48      DS    48X                     COPY OF THE UCB\n         UCBSCAN PLISTVER=MAX,MF=(L,UPRM)\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         EJECT\n         REGS\n*---------------------------------------------------------------------*\nSVM0030  BEGIN\nWRK      WORK  LV=WRKL,LOC=BELOW\n         B     START\nEXIT     FIN\n*---------------------------------------------------------------------*\nSTART    LR    R8,R1                   save parmlist addr\n         L     R1,0(R8)                addr of VOL\n         MVC   VOL(6),0(R1)\n* Find UCB for VOLSER:\n         XC    X100(100),X100          Clear Workarea\n         LA    R2,VOL\n         LA    R4,X48\n         LA    R3,X100\n*\n UCBSCAN COPY,WORKAREA=(3),UCBAREA=(4),VOLSER=(2),MF=(E,UPRM,COMPLETE)\n*\n         LTR   R15,R15\n         BZ    FOUND\n* not found:\n         B     EXIT\n         USING UCBOB,R4\nFOUND    LA    R4,X48\n         L     R1,8(R8)                 addr of UTYPE\n         MVC   0(1,R1),UCBTYP+2\n         L     R1,4(R8)                 addr of UNIT\n         CLC   UCBWGT+1(3),=C'UCB'\n         BE    FOURDGTS\n         MVC   0(4,R1),UCBWGT           UCB chars\n         MVI   0(R1),C'0'\n         SR    R15,R15\n         B     EXIT\nFOURDGTS UNPK  D(5),UCBCHAN(3)          take 4-digit address\n         MVC   0(4,R1),D                UCB chars\n         SR    R15,R15\n         B     EXIT\n*=====================================================================*\n*        CONSTANTS\n*---------------------------------------------------------------------*\n         DS    0F\n         LTORG\n         EJECT\n         DSECT\n         IEFUCBOB                      UCB MACRO ID\n*        CVT   DSECT=YES\n         EJECT\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,\n//        PARM='NCAL,MAP,RENT,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(SVM0030) <= *.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SVM0033": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03!\\x8f\\x10)\\x03\\xc8\\x03}\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-08-06T10:29:00", "lines": 968, "newlines": 893, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* First modify JOB card and data set names to your environment\n//* Assemble and Link program/module\n//*\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      <== hlq.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------\n     TITLE 'SVM0033  external module for IRXL@DDN and IRXF@DSN'\n*---------------------------------------------------------------------\n* History of Changes (last comes first):\n*\n* 05-16-2003 SVM Added SYSMEMBER for dsn(member)\n* 05-14-2003 SVM Updated to process VIO datasets\n* 05-02-2003 SVM Added 4-digit unit processing\n* 02-27-2003 SVM Added limited processing for non-DASD\n*                    and RACF verification\n* 01-03-2003 SVM Created from old LISTDSN (SVM0025)\n*.....................................................................\n*\n* FUNCTION:\n*               Gets parms: DDN, DSN, UNIT, VOL, UCBTYP, JFCB addr\n*               Reads DSCB1 from disk or JFCB from SWA\n*               Inquires REXX DSN access level for current userid\n*\n* INPUT:\n*               R0 -> IRXENVB (environment block)\n*               R1 -> A1,A2,A3,A4,A5,A6 (parameter list)\n*               A1 = addr(DDN)    (length = 8)\n*               A2 = addr(DSN)    (length = 44)\n*               A3 = addr(UNIT)   (length = 4)\n*               A4 = addr(VOL)    (length = 6)\n*               A5 = addr(UCBTYP) (length = 4)\n*               A6 = addr(JFCB)   (length = 4) or 0\n*\n* OUTPUT:\n*               R15 = 0\n*               Created and assigned REXX variables (see list below)\n* ATTRIBUTES:\n*        REENTRANT, AMODE=31, RMODE=ANY\n*\n* EXTERNALS:\n*               SVM0028 - read PDS directory\n*                  $OPEN - dynalloc/read interface\n*               RACFCHK - inquire RACF protection level interface\n*                  SVM0010 - inquire RACF protection level\n*---------------------------------------------------------------------\n         EJECT\n*---------------------------------------------------------------------\n.* Macro to help clear variable: &N is a name of var name constant\n         MACRO\n         STORE &N,&C=SHVSTORE\n         AIF   ('&N' EQ '').NON\n         LA    R1,&N\n         ST    R1,SHVNAMA               --> store name addr\n         LA    R1,L'&N\n         ST    R1,SHVNAML               --> Store name length\n         MVI   SHVCODE,&C               --> Set \"store\" code\n         BAL   R14,CALLXCOM             - create variable\n.NON     ANOP\n         MEND\n*\nSVM0033  BEGIN A=31,R=31                                                 0000062\nWRK      WORK  LV=WRKL,LOC=BELOW\n         B     START\nEXIT     SR    R15,R15\n         FIN\n*--------------------\n* REGISTER EQUATES:\n* R6  -> JFCB/DSCB1\n* R8  -> SHVBLOCK\n* R9  -> EVALBLOCK result block\n* R10 -> IRXEFPL   parm block\n* R11 -> ENVBLOCK  environment block\n*---------------------------------------------------------------------\nSTART    EQU   *\n*- Receive parameters:\n         L     R2,0(R1)                A1\n         MVC   DDN(8),0(R2)\n         L     R2,4(R1)                A2\n         MVC   DSN(44),0(R2)\n         L     R2,8(R1)                A3\n         MVC   UNIT(4),0(R2)\n         L     R2,12(R1)               A4\n         MVC   VOL(6),0(R2)\n         L     R2,16(R1)               A5\n         MVC   UTYPE(4),0(R2)\n         L     R2,20(R1)               A6\n         ST    R2,JFCBA\n*- Set REXX environment:\n*        LR    R10,R1                  IRXEFPL\n*        USING EFPL,R10                - parm list\n         LR    R11,R0                  ENVBLOCK\n         USING ENVBLOCK,R11            - externals\n*        L     R9,EFPLEVAL\n*        L     R9,0(R9)                EVALBLOCK\n*        USING EVALBLOCK,R9            - result\n         LA    R8,SHVBLK\n         USING SHVBLOCK,R8\n         BAL   R14,SETSHV\n*---------------------------------------------------------------------*\n*- Process DDNAME:\n*\nRDDN     EQU   *\n*        WTO   'RDDN...',ROUTCDE=11\n         LA    R3,DDN-1\n         LA    R1,DDN+7\n         LA    R2,1                     increment\n         LNR   R2,R2                    -1\nLOOPDDN  CLI   0(R1),C' '\n         BNE   LOOPEDDN\n         BXH   R1,R2,LOOPDDN\n*  R1-> blank or next char after DDNAME\nLOOPEDDN SR    R1,R3                   length of DDNAME\n         ST    R1,SHVVALL              --> store value length\n         LA    R1,DDN\n         ST    R1,SHVVALA              --> store value addr\n         STORE #DDN\n*---------------------------------------------------------------------*\n*- process SYSUTYPE (UCBTYP)\n*        WTO 'Processing UTYPE...',ROUTCDE=11\n         MVC   VALUE(4),=C'DISK'\n         LA    R1,4\n         TM    UTYPE+2,X'20'           disk?\n         BO    PUTYPE\n         MVC   VALUE(4),=C'TAPE'\n         TM    UTYPE+2,X'80'           tape?\n         BO    PUTYPE\n         MVC   VALUE(4),=C'COMM'\n         TM    UTYPE+2,X'40'\n         BO    PUTYPE\n         MVC   VALUE(5),=C'DISPL'\n         LA    R1,5\n         TM    UTYPE+2,X'10'\n         BO    PUTYPE\n         MVC   VALUE(5),=C'OTHER'\nPUTYPE   EQU   *\n         ST    R1,SHVVALL              --> store value length\n         LA    R1,VALUE\n         ST    R1,SHVVALA              --> store value addr\n         STORE #UTYPE\n*---------------------------------------------------------------------*\n*  Now it is either Disk or Tape dataset:\n*\n         TM    UTYPE+2,X'20'           disk?\n         BO    CONT1\n         TM    UTYPE+2,X'80'           tape?\n         BNO   ALLDONE                 Exit if not TAPE or DASD\nCONT1    EQU   *\n*---------------------------------------------------------------------*\n*- process VOLUME:\n*        WTO   'Processing VOLSER...',ROUTCDE=11\n         LA    R3,VOL-1                VOLSER-1\n         LA    R1,VOL+5                VOLSER+5\n         LA    R2,1\n         LNR   R2,R2                   incr = -1\nVOLLOOP  CLI   0(R1),C' '\n         BNE   VOLLOOPE\n         BXH   R1,R2,VOLLOOP\n* R1 = VOL Length\nVOLLOOPE SR    R1,R3                   VOL length\n         ST    R1,SHVVALL              --> store value length\n         LA    R3,VOL\n         ST    R3,SHVVALA              --> store value addr\n         STORE #VOL\n*---------------------------------------------------------------------*\n*- process UNIT:\nGETUNIT  EQU   *\n*        WTO 'Processing UNIT...',ROUTCDE=11\n         LA    R1,UNIT                 UNIT\n         ST    R1,SHVVALA              --> store value addr\n         LA    R1,4\n         ST    R1,SHVVALL              --> store value length\n         STORE #UNIT\n*---------------------------------------------------------------------*\n*- process DSNAME:\n*        WTO 'Processing DSN...',ROUTCDE=11\n         LA    R3,DSN-1\n         LA    R1,DSN+43\n         LA    R2,1                    increment\n         LNR   R2,R2                   -1\nLOOP     CLI   0(R1),C' '\n         BNE   LOOPE\n         BXH   R1,R2,LOOP\n*  R1-> blank or next char after DSN\nLOOPE    SR    R1,R3                   length of DSNAME\n         ST    R1,SHVVALL              --> store value length\n         STH   R1,LDSN                 ==> store for further use\n         LA    R1,DSN\n         ST    R1,SHVVALA              --> store value addr\n         STORE #DSN\n*---------------------------------------------------------------------*\n*- Get RACF RC:\nGETRACF  LH    R1,LDSN                 take DSN length\n         LA    R1,L'PARPFX(,R1)        add length of PARPFX\n         STH   R1,LPAR                 set LPAR\n         LA    R1,LPAR\n         ST    R1,APAR                 set APAR\n         MVC   PARPFX(2),=C',,'        set PARPFX\n         LA    R1,APAR\n         CALL  RACFCHK                 Get RACROUTE rc\n         ST    R15,RACFRC              store rc for future use\n*=====================================================================*\n*- If Disk, goto LOCATE DSCB1:\n*\n         CLC   UNIT+1(3),=C'VIO'       VIO?\n         BE    TAKEJFCB                - yes\n         TM    UTYPE+2,X'20'           Disk ?\n         BO    LOCATEIT                - yes\n*=====================================================================*\n*  For Tape dataset and VIO take data fields from JFCB:\n*\nTAKEJFCB CLC   JFCBA(4),=A(0)          JFCB available ?\n         BE    ALLDONE                 - no\n         CLC   RACFRC(4),=F'0'         if 'NO ACCESS'\n         BE    ALLDONE                 skip opening dataset\n*        WTO  'Processing JFCB...',ROUTCDE=11\n         L     R6,JFCBA\n         USING JFCB,R6\n         SR    R7,R7                   flag \"was opened\"\n         CLI   JFCDSORG,X'00'          If opened\n         BNE   OPENED                  - yes: skip OPEN\n*        WTO   'Opening dataset...',ROUTCDE=11\n         MVC   DCB(#DCBSIZE),#DCB\n         LA    R1,DCB\n         USING IHADCB,R1\n         MVC   DCBDDNAM(8),DDN         Set dcbddnam\n         ST    R1,DCBADDR\n         MVI   DCBADDR,X'80'           Set input\n         LA    R1,DCBADDR\n         SVC   19                      OPEN\n         LA    R1,DCB\n         TM    DCBOFLG,DCBOFOPN        Opened ?\n         BNO   ALLDONE                 Cannot open\n         LA    R7,1                    flag \"was not opened\"\n*        WTO   'Opened OK...',ROUTCDE=11\n         DROP  R1                      USING\n*- when dataset is in dd concatenation, JFCB will not be updated:\nOPENED   CLI   JFCDSORG,X'00'          If JFCB updated?\n         BE    ALLDONE                 - not quite: skip\n*\n*  copy data from JFCB to workarea and close DCB:\nCOPYJ    MVC   @DSORG(1),JFCDSORG      copy DSORG\n         MVC   @RECFM(1),JFCRECFM      copy RECFM\n         MVC   @BLKSI(2),JFCBLKSI      copy BLKSIZE\n         MVC   @LRECL(2),JFCLRECL      copy LRECL\n         MVC   @CRDT(3),JFCBCRDT       copy CRDT\n         MVC   @XPDT(3),=F'0'\n         TM    JFCBFLG3,JFCBEXP\n         BNO   NOEXDT\n         MVC   @XPDT(3),JFCBXPDT       copy EXPDT\nNOEXDT   MVC   @UNITS(1),JFCBCTRI      copy Space Units\n         MVC   @PQTY(3),JFCBPQTY       copy primary units\n         MVC   @SQTY(3),JFCBSQTY       copy secondary units\n         MVC   @KEYLE(1),JFCKEYLE      copy key length\n         MVI   FROMJFCB,YES            Set From JFCB flag\n         DROP  R6                      USING\n         LTR   R7,R7                   If \"was opened\"\n         BZ    CONT2                   - yes, do not close\n         LA    R1,DCBADDR\n         MVI   DCBADDR,X'80'           set VL bit\n         SVC   20                      CLOSE\n         B     CONT2\n*=====================================================================*\n*  locate datatset on DASD volume and use DSCB1:\n*\nLOCATEIT EQU   *\n*        WTO 'Locating DSCB on VOLUME...',ROUTCDE=11\n         MVC   LISTD(4),#LISTD          const\n         LA    R1,DSN\n         ST    R1,LISTD+4               DSN\n         LA    R1,VOL\n         ST    R1,LISTD+8               VOL\n         LA    R1,W140\n         ST    R1,LISTD+12              DSCB area\n*        WTO   'Obtaining DSCB...',ROUTCDE=11\n         OBTAIN LISTD\n         LTR   R15,R15\n         BNZ   EXIT                     Obtain failed\n*        WTO   'Obtain successful',ROUTCDE=11\n         LA    R6,W140\n         USING DS1+44,R6\n*  copy data from DS1 to workarea:\n         MVC   @DSORG(1),DS1DSORG      copy DSORG\n         MVC   @RECFM(1),DS1RECFM      copy RECFM\n         MVC   @BLKSI(2),DS1BLKL       copy BLKSIZE\n         MVC   @LRECL(2),DS1LRECL      copy LRECL\n         MVC   @CRDT(3),DS1CREDT       copy CRDT\n         MVC   @XPDT(3),DS1EXPDT       copy EXPDT\n         MVC   @UNITS(1),DS1SCAL1      copy units\n         MVC   @KEYLE(1),DS1KEYL       copy key length\nPRIM     SR    R2,R2\n         ICM   R2,3,DS1EXT1+2          lower CC\n         TM    DS1SCAL1,DS1CYL         in Cylinders?\n         BO    PRIM1                   - no\n         LR    R1,R2                   calculate tracks:\n         SLL   R1,4                    *16\n         SR    R1,R2                   *15\n         SR    R2,R2\n         ICM   R2,3,DS1EXT1+4          lower HH\n         AR    R2,R1                   Lower relative track #\n*\nPRIM1    SR    R1,R1\n         ICM   R1,3,DS1EXT1+6          higher CC\n         TM    DS1SCAL1,DS1CYL         in Cylinders?\n         BO    PRIM2                   - no\n         LR    R3,R1\n         SLL   R3,4                    *16\n         SR    R3,R1                   *15\n         SR    R1,R1\n         ICM   R1,3,DS1EXT1+8          higher HH\n         AR    R1,R3                   higher relative track #\nPRIM2    SR    R1,R2\n         LA    R1,1(,R1)               higher - lower + 1 (trks)\n         STCM  R1,7,@PQTY              copy PRIMARY\n         MVC   @SQTY(3),DS1SCAL3       copy Secondatry\n*\n         MVI   FROMJFCB,0              set From JFCB flag\n*=====================================================================*\n*- common continuation for DSCB1 and JFCB processing:\n*\nCONT2    EQU   *\n*---------------------------------------------------------------------*\n*- process MEMBER:\n*        WTO 'Processing MEMBER...',ROUTCDE=11\n         CLC   JFCBA(4),=A(0)          JFCB available ?\n         BE    NOMEMB                  - no JFCB\n         L     R4,JFCBA\n         USING JFCB,R4\n*\n         TM    @DSORG,DS1DSGPO\n         BNO   NOMEMB                  - not PDS\n         LA    R3,JFCBELNM-1\n         LA    R1,JFCBELNM+7\n         LA    R2,1                    increment\n         LNR   R2,R2                   -1\nMLOOP    CLI   0(R1),C' '\n         BNE   MLOOPE\n         BXH   R1,R2,MLOOP\n*  R1-> blank or next char after MEMBER\nMLOOPE   SR    R1,R3                   length of MEMBER name\n         ST    R1,SHVVALL              --> store value length\n         LA    R1,JFCBELNM\n         ST    R1,SHVVALA              --> store value addr\n         STORE #MEMNM\n         DROP  R4                      USING\nNOMEMB   DS    0H\n*---------------------------------------------------------------------*\n*- process DSORG:\nDSORG    EQU   *\n*        WTO 'DSORG...',ROUTCDE=11\n         LA    R1,2                    DSORG value length\n         MVC   VALUE(2),=C'PS'\n         TM    @DSORG,DS1DSGPS\n         BO    SETORG\n         MVC   VALUE(2),=C'PO'\n         TM    @DSORG,DS1DSGPO\n         BNO   DSORG1\n         TM    DS1SMSFG,DS1PDSEX\n         BNO   DSORG01\n         LA    R1,3\n         MVC   VALUE(3),=C'HFS'\n         B     SETORG\nDSORG01  TM    DS1SMSFG,DS1PDSE\n         BNO   SETORG\n         LA    R1,4\n         MVC   VALUE(4),=C'PDSE'\n         B     SETORG\n*\nDSORG1   MVC   VALUE(2),=C'IS'\n         TM    @DSORG,DS1DSGIS\n         BO    SETORG\n         MVC   VALUE(2),=C'DA'\n         TM    @DSORG,DS1DSGDA\n         BO    SETORG\n* Check for VSAM:\n         LA    R1,4\n         MVC   VALUE(4),=C'VSAM'\n         TM    DS1DSORG+1,DS1ORGAM\n         BNO   RECFM                  Unknown\nSETORG   TM    @DSORG,DS1DSGU\n         BNO   SETORG1\n         LA    R2,VALUE\n         AR    R2,R1                   Next char in VALUE\n         MVI   0(R2),C'U'              Unmovable\n         LA    R1,1(R1)                DSORG length\nSETORG1  ST    R1,SHVVALL               --> store value length\n         LA    R1,VALUE\n         ST    R1,SHVVALA               --> store value addr\n         STORE #DSORG\n*---------------------------------------------------------------------*\n*- process RECFM:\nRECFM    DS    0H\n*        WTO 'RECFM...',ROUTCDE=11\n         LA    R1,1\n         LA    R2,VALUE\n         MVI   VALUE,C'U'\n         TM    @RECFM,DS1RECFU\n         BO    RECFM4\n         MVI   VALUE,C'F'\n         TM    @RECFM,DS1RECFF\n         BO    RECFM2\n         MVI   VALUE,C'V'\n         TM    @DSORG,DS1RECFV\n         BO    RECFM2\n         B     LRECL\nRECFM2   TM    @RECFM,DS1RECFB       Blocked?\n         BNO   RECFM3\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         MVI   0(R2),C'B'\nRECFM3   TM    @RECFM,DS1RECFS       Std blocks(F)\n         BNO   RECFM4\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         MVI   0(R2),C'S'\nRECFM4   TM    @RECFM,DS1RECFT       Trk overflow?\n         BNO   RECFM5\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         MVI   0(R2),C'T'\nRECFM5   TM    @RECFM,DS1RECFA       CC in ASCII?\n         BNO   RECFM51\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         MVI   0(R2),C'A'\n         B     RECFM6\nRECFM51  TM    @RECFM,DS1RECMC       CC in Machine code?\n         BNO   RECFM6\n         LA    R1,1(R1)\n         LA    R2,1(R2)\n         MVI   0(R2),C'M'\nRECFM6   ST    R1,SHVVALL               --> store value length\n         LA    R1,VALUE\n         ST    R1,SHVVALA               --> store value addr\n         STORE #RECFM\n*---------------------------------------------------------------------*\n*- process LRECL:\n*        WTO 'LRECL...',ROUTCDE=11\nLRECL    SR    R1,R1\n         ICM   R1,3,@LRECL\n         CVD   R1,VALUE                convert\n         UNPK  D(5),VALUE(8)           to char\n         OI    D+4,C'0'                suppress sign\n         LA    R1,5                    Data length\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #LRECL\n*---------------------------------------------------------------------*\n*- process BLKSIZE:\n*        WTO 'BLKSI...',ROUTCDE=11\nBLKSIZE  SR    R1,R1\n         ICM   R1,3,@BLKSI\n         CVD   R1,VALUE                convert\n         UNPK  D(5),VALUE(8)           to char\n         OI    D+4,C'0'                suppress sign\n         LA    R1,5                    Data length\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #BLKSI\n*---------------------------------------------------------------------*\n*- process CREATION date:\n*        WTO 'CREAT...',ROUTCDE=11\nCREATE   SR    R1,R1\n         ICM   R1,1,@CRDT              YY\n         LTR   R1,R1\n         BZ    NOCRDT                  0 - undefined\n         LA    R1,1900(R1)             1900+yy\n         CVD   R1,VALUE                convert\n         UNPK  D(4),VALUE(8)           to char\n         OI    D+3,C'0'                suppress sign\n         L     R2,D                    save year\n         ICM   R1,3,@CRDT+1            DDDD\n         CVD   R1,VALUE                convert\n         UNPK  D+4(4),VALUE(8)         to char\n         OI    D+7,C'0'                suppress sign\n         ST    R2,D\n         MVI   D+4,C'/'\n         LA    R1,8                    Data length\n         LA    R2,D\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #CRDT\nNOCRDT   EQU   *\n*---------------------------------------------------------------------*\n*- process EXIRATION date:\n*        WTO 'EXPDT...',ROUTCDE=11\nEXPDT    SR    R1,R1\n         ICM   R1,1,@XPDT              YY\n         LTR   R1,R1\n         BZ    EEXPDT\n         LA    R1,1900(R1)             1900+yy\n         CVD   R1,VALUE                convert\n         UNPK  D(4),VALUE(8)           to char\n         OI    D+3,C'0'                suppress sign\n         L     R2,D                    save year\n         ICM   R1,3,@XPDT+1            DDDD\n         CVD   R1,VALUE                convert\n         UNPK  D+4(4),VALUE(8)         to char\n         OI    D+7,C'0'                suppress sign\n         ST    R2,D\n         MVI   D+4,C'/'\n         LA    R1,8                    Data length\n         B     EXPDT1\nNOEXPDT  CVD   R1,VALUE                convert\n         UNPK  D(7),VALUE(8)           to char\n         OI    D+6,C'0'                suppress sign\n         LA    R1,1                    Data length\nEXPDT1   LA    R2,D\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #EXPDT\nEEXPDT   DS    0H\n*---------------------------------------------------------------------*\n*- process RACF protection flags:\n*        WTO 'RACF....',ROUTCDE=11\nRACF     DS    0H\n* process rc = offset (0, 4, ..., 24):\n         LA    R2,#RA0                 list of value addresses\n         A     R2,RACFRC               add offset (from call)\n         L     R2,0(R2)                addr of value length\n         SR    R1,R1\n         ICM   R1,B'0011',0(R2)        load value length\n         LA    R2,2(,R2)               load value addr\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #RACF\n*=====================================================================*\n*- quit processing if TAPE:\n*\n         TM    UTYPE+2,X'20'\n         BNO   ALLDONE                 Exit, if non-DASD\n*=====================================================================*\n*- process PASSWORD protection flags:\n*        WTO 'PASSW...',ROUTCDE=11\nPASSWD   TM    FROMJFCB,YES\n         BO    EPASSWD\n         LA    R1,4\n         LA    R2,VALUE\n         MVC   VALUE(4),=C'NONE'\n         TM    DS1DSIND,DS1IND10\n         BNO   PASSWD1\n         MVC   VALUE(4),=C'READ'\n         TM    DS1DSIND,DS1IND04\n         BO    PASSWD1                 1 - read/write protected\n         MVC   VALUE(4),=C'WRITE'      0 - write protected\n         LA    R1,5\nPASSWD1  ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #PASSW\nEPASSWD  DS    0H\n*---------------------------------------------------------------------*\n*- process KEYLEN (?):\n*        WTO 'KEYLE...',ROUTCDE=11\nKEYLEN   SR    R1,R1\n         IC    R1,@KEYLE\n         CVD   R1,VALUE                convert\n         UNPK  D(5),VALUE(8)           to char\n         OI    D+4,C'0'                suppress sign\n         LA    R1,2                    Data length\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #KEYLE\n*---------------------------------------------------------------------*\n*- process ALLOC UNITS:\n*        WTO 'UNITS...',ROUTCDE=11\nUNITS    MVC   VALUE(8),=C'CYLINDER'\n         LA    R1,8\n         TM    @UNITS,DS1CYL\n         BO    UNITS1\n         MVC   VALUE(5),=C'TRACK'\n         LA    R1,5\n         TM    @UNITS,DS1TRK\n         BO    UNITS1\n         MVC   VALUE(5),=C'BLOCK'\n         LA    R1,5\n         TM    @UNITS,DS1AVR\n         BO    UNITS1\n         MVC   VALUE(5),=C'ABSTR'\n         LA    R1,5\n         CLI   DS1SCAL1,DS1DSABS\n         BE    UNITS1\n         B     EUNITS                   not recognized ?\n*        LA    R1,8\nUNITS1   ST    R1,SHVVALL               --> store value length\n         LA    R2,VALUE\n         ST    R2,SHVVALA               --> store value addr\n         STORE #UNITS\nEUNITS   DS    0H\n*---------------------------------------------------------------------*\n*- process LAST REFERENCED date:\n*        WTO 'REFDT...',ROUTCDE=11\nREFD     TM    FROMJFCB,YES\n         BO    EREFD\n         SR    R1,R1\n         ICM   R1,1,DS1REFD            YY\n         LTR   R1,R1\n         BZ    EREFD                   0 - undefined\n         LA    R1,1900(R1)             1900+yy\n         CVD   R1,VALUE                convert\n         UNPK  D(4),VALUE(8)           to char\n         OI    D+3,C'0'                suppress sign\n         L     R2,D                    save year\n         ICM   R1,3,DS1REFD+1          DDDD\n         CVD   R1,VALUE                convert\n         UNPK  D+4(4),VALUE(8)         to char\n         OI    D+7,C'0'                suppress sign\n         ST    R2,D\n         MVI   D+4,C'/'\n         LA    R1,8                    Data length\n         LA    R2,D\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #REFD\nEREFD    EQU   *\n*---------------------------------------------------------------------*\n*- process number of extents:\n*        WTO 'EXTEN...',ROUTCDE=11\nEXTENTS  TM    FROMJFCB,YES\n         BO    EEXTENTS\n         SR    R1,R1\n         ICM   R1,1,DS1NOEPV\n         LTR   R1,R1\n         BZ    EEXTENTS                0 - undefined\n         CVD   R1,VALUE                convert\n         UNPK  D(7),VALUE(8)           to char\n         OI    D+6,C'0'                suppress sign\n         LA    R1,7                    Data length\n         LA    R2,D\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #EXTEN\nEEXTENTS DS    0H\n*---------------------------------------------------------------------*\n*- process PRIMARY Allocation: 15 tracks on Cylinder:\n* (anybody is welcome to code DASD type recognition here)\n*        WTO 'PRIMA...',ROUTCDE=11\nPRIMARY  SR    R1,R1\n         ICM   R1,7,@PQTY\n         LTR   R1,R1\n         BNP   EPRIMARY                - undefined\n         CVD   R1,VALUE                convert\n         UNPK  D(7),VALUE(8)           to char\n         OI    D+6,C'0'                suppress sign\n         LA    R1,7                    Data length\n         LA    R2,D\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #PRIMA\nEPRIMARY DS    0H\n*---------------------------------------------------------------------*\n*- process SCONDARY Allocation:\n*        WTO 'SECON...',ROUTCDE=11\nSECONDS  SR    R1,R1\n         ICM   R1,7,@SQTY\n         CVD   R1,VALUE                convert\n         UNPK  D(7),VALUE(8)           to char\n         OI    D+6,C'0'                suppress sign\n         LA    R1,7                    Data length\n         LA    R2,D\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #SECND\nESECONDS DS    0H\n*---------------------------------------------------------------------*\n*- process Updated flags:\n*        WTO 'UPDAT...',ROUTCDE=11\nUPDAT    TM    FROMJFCB,YES\n         BO    EUPDAT\n         LA    R1,2\n         LA    R2,VALUE\n         MVC   VALUE(2),=C'NO'\n         TM    DS1DSIND,DS1IND02\n         BNO   UPDAT1\n         MVC   VALUE(3),=C'YES'\n         LA    R1,3\nUPDAT1   ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #UPDAT\nEUPDAT   DS    0H\n*---------------------------------------------------------------------*\n*- process DIRECTORY blocks Allocation:\nDIRBA    EQU   *\n*        WTO 'DIRBA...',ROUTCDE=11\n         CLC   RACFRC(4),=F'0'\n         BE    NODIRBA                 No read access\n         TM    @DSORG,DS1DSGPO\n         BNO   NODIRBA                 It is not PO dataset\n         LA    R1,DSN\n         ST    R1,P1\n         LA    R1,VOL\n         ST    R1,P2\n         LA    R1,DIRBLKS\n         ST    R1,P3\n         LA    R1,UDIRBLK\n         ST    R1,P4\n         LA    R1,MEMBERS\n         ST    R1,P5\n         LA    R1,P1\n         CALL  SVM0028                 Get dir blk #\n* total:\n         SR    R1,R1\n         LH    R1,DIRBLKS\n         LTR   R1,R1\n         BZ    NODIRBA                 0 - undefined\n         CVD   R1,VALUE                convert\n         UNPK  D(7),VALUE(8)           to char\n         OI    D+6,C'0'                suppress sign\n         LA    R1,7                    Data length\n         LA    R2,D\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #DIRBA\n* used:\n         SR    R1,R1\n         LH    R1,UDIRBLK\n         CVD   R1,VALUE                convert\n         UNPK  D(7),VALUE(8)           to char\n         OI    D+6,C'0'                suppress sign\n         LA    R1,7                    Data length\n         LA    R2,D\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #DIRBU\n* members:\n         SR    R1,R1\n         LH    R1,MEMBERS\n         CVD   R1,VALUE                convert\n         UNPK  D(7),VALUE(8)           to char\n         OI    D+6,C'0'                suppress sign\n         LA    R1,7                    Data length\n         LA    R2,D\n         BAL   R14,STRIPL              Remove zeros at left\n         ST    R1,SHVVALL               --> store value length\n         ST    R2,SHVVALA               --> store value addr\n         STORE #MEMBS\nNODIRBA  EQU   *\nALLDONE  EQU   *\n*        WTO   'All done...',ROUTCDE=11\n         B     EXIT\n*=====================================================================*\n*        S U B R O U T I N E S                                        *\n*---------------------------------------------------------------------*\n* Set IRXEXCOM parameters:\n*---------------------------------------------------------------------*\nSETSHV   EQU   *\n* (re)make addr list:\n         LA    R1,#EXCOM\n         ST    R1,A1                   A1 = Addr of module name\n         XC    A2(8),A2                clear A2 and A3\n         LA    R1,SHVBLK\n         ST    R1,A4                   A4 -> SHVBLOCK\n         OI    A4,X'80'                set VL bit\n* (re)fill SHVBLOCK:\n         XC    SHVNEXT(SHVBLEN),SHVNEXT clear it all\n         BR    R14\n*--------------------------------------------------------------------*\n* Call IRXEXCOM:\n*--------------------------------------------------------------------*\nCALLXCOM ST    R14,SAVER14\n         L     R15,ENVBLOCK_IRXEXTE    addr IRXEXTE\n         USING IRXEXTE,R15\n         L     R15,IRXEXCOM            addr IRXEXCOM\n         DROP  R15                     USING\n         LA    R1,A1                   parm list addr\n         LR    R0,R11                  point to ENVBLOCK\n         BALR  R14,R15                 Call IRXEXCOM\n         ST    R15,SAVERC              save return code\n         L     R14,SAVER14             restore return address\n         BR    R14\n*---------------------------------------------------------------------*\n* Strip number left: value: D, length: R1.\n*    Set R1 to new length, set R2 to new addr\n*---------------------------------------------------------------------*\nSTRIPL   STM   R3,R5,WRKSAVE2\n         LA    R2,D                     start with 1st char\n         LA    R5,1                     Min result length\n         LNR   R4,R5                    Increment = -1\nLOOPN    CLI   0(R2),C'0'\n         BNE   CUTN\n         LA    R2,1(R2)                 put start to next char\n         BXH   R1,R4,LOOPN              cut length by 1\n*  R2-> leftmost non-zero, R1 = new length\nCUTN     LM    R3,R5,WRKSAVE2\n         BR    R14\n*=====================================================================*\n*        CONSTANTS                                                    *\n*---------------------------------------------------------------------*\nYES      EQU   X'01'                        flag\n         DS    0F\nPARMEND  DC    8X'FF'\nMVCNN    MVC   0(0,R1),0(R6)                move parm to D\n#EXCOM   DC    C'IRXEXCOM'                  REXX module name\n#DSN     DC    C'SYSDSNAME'                 variable name\n#DDN     DC    C'SYSDDNAME'                 variable name\n#VOL     DC    C'SYSVOLUME'                 variable name\n#UNIT    DC    C'SYSUNIT'                   variable name\n#DSORG   DC    C'SYSDSORG'                  variable name\n#RECFM   DC    C'SYSRECFM'                  variable name\n#LRECL   DC    C'SYSLRECL'                  variable name\n#BLKSI   DC    C'SYSBLKSIZE'                variable name\n#KEYLE   DC    C'SYSKEYLEN'                 variable name\n#UNITS   DC    C'SYSUNITS'                  variable name\n#PRIMA   DC    C'SYSPRIMARY'                variable name\n#SECND   DC    C'SYSSECONDS'                variable name\n#DIRBA   DC    C'SYSADIRBLK'                variable name\n#DIRBU   DC    C'SYSUDIRBLK'                variable name\n#MEMBS   DC    C'SYSMEMBERS'                variable name\n#CRDT    DC    C'SYSCREATE'                 variable name\n#EXPDT   DC    C'SYSEXDATE'                 variable name\n#REFD    DC    C'SYSREFDATE'                variable name\n#EXTEN   DC    C'SYSEXTENTS'                variable name\n#PASSW   DC    C'SYSPASSWORD'               variable name\n#RACF    DC    C'SYSRACFA'                  variable name\n#UPDAT   DC    C'SYSUPDATED'                variable name\n#UTYPE   DC    C'SYSUTYPE'                  variable name (added)\n#MEMNM   DC    C'SYSMEMBER'                 variable name (added)\n#ZERO    DC    F'0'\n#ZEROES  DC    C'00000000'\n#BLANKS  DC    C'        '                  const\n#8       DC    F'8'\n#DCB     DCB   DDNAME=SYSUT1,MACRF=(R),DSORG=PS\n#DCBSIZE EQU   *-#DCB\n         DS    0F\n* Macro  CAMLST SEARCH,...   to read DSCB\n#LISTD   DC    AL1(193)\n         DC    AL1(0)\n         DC    AL1(0)\n         DC    AL1(0)\n* RACF access constants:\n#RA0     DC    A(#NA)\n#RA4     DC    A(#RA)\n#RA8     DC    A(#UA)\n#RA12    DC    A(#CA)\n#RA16    DC    A(#AA)\n#RA20    DC    A(#TA)\n#RA24    DC    A(#ER)\n#NA      DC    AL2(L'##NA)\n##NA     DC    CL2'No'\n#RA      DC    AL2(L'##RA)\n##RA     DC    CL4'Read'\n#UA      DC    AL2(L'##UA)\n##UA     DC    CL6'Update'\n#CA      DC    AL2(L'##CA)\n##CA     DC    CL7'Control'\n#AA      DC    AL2(L'##AA)\n##AA     DC    CL5'Alter'\n#TA      DC    AL2(L'##TA)\n##TA     DC    CL9'Unlimited'\n#ER      DC    AL2(L'##ER)\n##ER     DC    CL5'????'\n         LTORG\n         EJECT\n*---------------------------------------------------------------------*\n*        LOCAL WORK AREA                                              *\n*---------------------------------------------------------------------*\n         SPACE 1\nWRK      DSECT\nWRKSAVE  DS    18F                     REGISTER SAVE AREA\nWRKSAVE2 DS    18F                     REGISTER SAVE AREA\nDDN      DS    CL8\nVALUE    DS    D\nD        DS    2D\nDIR      DS    D\nDIRBLKS  EQU   DIR\nUDIRBLK  EQU   DIR+2\nMEMBERS  EQU   DIR+4\nRACFRC   DS    F\n*- Function call parameter:\n*- R1 -> following parameter list for SVM0028:\nP1       DS    A\nP2       DS    A\nP3       DS    A\nP4       DS    A\nP5       DS    A\n*- R0 -> env block IRXENVB\n*- R1 -> following parameter list:\nA1       DS    A\nA2       DS    A\nA3       DS    A\nA4       DS    A\nA5       DS    A\nA6       DS    A\n* parameter values:\nSHVBLK   DS    8F'0'                   IRXSHVB instance\n*\nSAVERC   DS    F                       retcode from IRXEXCOM\nSAVER14  DS    F                       save R14\nSAV2R14  DS    F                       save R14\n*LISTD    CAMLST SEARCH,DSN,WVOL,W140\nLISTD    DS    0F                      CAMLST\n         DS    A                       = #LISTD\n         DS    A                       (DSN)\n         DS    A                       (VOL)\n         DS    A                       (W140)\n*\nW140     DS    140C                    96 bytes F1 DSCB, 5 bytes CCHHR\nUNIT     DS    F\nUTYPE    DS    4C\nJFCBA    DS    A\n* Next 4 fields must go together, used as a parm for RACFCHK call\nAPAR     DS    A\nLPAR     DS    H\nPARPFX   DS    CL2\nDSN      DS    44C\n*\nLDSN     DS    H\nVOL      DS    6C\nDCBADDR  DS    A\nDCB      DCB   DDNAME=SYSUT1,MACRF=(R),DSORG=PS\n@DSORG   DS    X\n@RECFM   DS    X\n@BLKSI   DS    H\n@LRECL   DS    H\n@CRDT    DS    XL3\n@XPDT    DS    XL3\n@UNITS   DS    X\n@PQTY    DS    XL3\n@SQTY    DS    XL3\n@KEYLE   DS    X\nFROMJFCB DS    X\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         EJECT\n*---------------------------------------------------------------------*\n*        DSECTS                                                       *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\n         REGS\n* REXX specific DSECTs:\n         IRXEFPL DSECT=YES             REXX parameter list\n         IRXEVALB                      REXX evaluation block EVALBLOCK\n         IRXEXTE                       REXX vector of external ep\n         IRXENVB                       REXX environment block ENVBLOCK\n         IRXSHVB                       REXX shared variables block\n* SYSTEM SPECIFIC DSECTS:\n         DCBD DSORG=PS,DEVD=TA\n         PRINT GEN\nDS1      DSECT\n         IECSDSL1 (1)\n*UCB      DSECT\n*         IEFUCBOB\nJFCB     DSECT\n         IEFJFCBN\nJFCBL    EQU   *-JFCB\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='RENT,NCAL,MAP,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(SVM0033) <= *.LOAD  0351000\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//\n//* Test with IRXF@DDN, IRXF@DSN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WTP": {"ttr": 4108, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x03\\x19\\x1f\\x01\\x03!\\x8f\\x101\\x00Y\\x00_\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-07-10T00:00:00", "modifydate": "2003-08-06T10:31:00", "lines": 89, "newlines": 95, "modlines": 0, "user": "SVM"}, "text": "//jobname JOB (account),userid,CLASS=S,MSGCLASS=Y,REGION=4M\n//*\n//* ASSEMBLE AND LINK PROGRAM\n//ASMH EXEC PGM=ASMA90,REGION=4M,\n// PARM='RENT,OBJECT,NODECK,NOXREF,BATCH'\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS3.UTILITY.MACLIB.TEST      ==> hlq.MACLIB\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//SYSIN    DD *\n*---------------------------------------------------------------------*\n     TITLE 'WTP parm program'\n*---------------------------------------------------------------------*\n* History of Changes (last comes first):                              *\n*                                                                     *\n* 01-03-2003 SVM Fixed a bug...\n* 05-24-2002 SVM Created\n*.....................................................................*\n*                                                                     *\n* FUNCTION:                                                           *\n*               1) WTO parm string, used for debug only               *\n*                                                                     *\n* INPUT:        Standard EXEC PARM:                                   *\n*               R1-> AL4(PARM)            Addr of length              *\n*               PARM   DS  H(K'TEXT)      length of text (halfword)   *\n*               TEXT   DS  CL...          text                        *\n* OUTPUT:                                                             *\n*               Messages on hardcpy log (WTP) containing the TEXT     *\n*                                                                     *\n* ATTRIBUTES:                                                         *\n*               REENTRANT                                             *\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\nPARM     DSECT\nPLEN     DS    H\nPTXT     DS    C\n*\nWRK      DSECT\nWRKSAVE  DS    18F                     REGISTER SAVE AREA\nMESS     DS    256C\nWRKL     EQU   (*-WRK+7)/8*8           WORK AREA LENGTH, words\n         EJECT\n         REGS\n*---------------------------------------------------------------------*\nWTP      BEGIN\nWRK      WORK  LV=WRKL\n         B     START\n*\nEXIT     FIN\n*---------------------------------------------------------------------*\nSTART    L     R2,0(R1)                Addr of PARM\n         USING PARM,R2\n         LH    R3,PLEN                 Length\n         LTR   R3,R3\n         BZ    EXIT                    Exit if no text\n         MVC   MESS+2(2),WTO0+2        copy WTO0 part 1\n         BCTR  R3,0                    len-1 for EX\n         EX    R3,MVCPARM              copy text\n         LA    R3,5(R3)                len+4 for WTP\n         STH   R3,MESS                 copy length\n         LA    R4,MESS\n         LA    R4,0(R3,R4)             end of text\n         MVC   0(4,R4),WTO0+4          copy WTO0 part 2\n* Display message:\nDISPL    LA    R1,MESS\n         SVC   35\n         SR    R15,R15\n         B     EXIT                    BRANCH TO COMMON EXIT\n*=====================================================================*\n*        CONSTANTS                                                    *\n*---------------------------------------------------------------------*\n         DS    0F\nMVCPARM  MVC   MESS+4(0),PTXT\nWTO0     WTO '',MF=L,ROUTCDE=11\n         LTORG\n         EJECT\n         END\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='NCAL,MAP,RENT,AC=1,RMOD=ANY,AMOD=31',\n//        COND=(8,LE)\n//SYSLMOD  DD DISP=SHR,DSN=SYS3.UTILITY.LOADLIB.TEST(WTP)  <== hlq.LOAD\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)\n//*\n//GO       EXEC PGM=*.LKED.SYSLMOD,COND=(8,LE),\n//   PARM='037E'\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT588/CBT.V500.FILE588.PDS/ASM.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT588/CBT.V500.FILE588.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}