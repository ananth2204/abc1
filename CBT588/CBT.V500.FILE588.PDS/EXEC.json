{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "SVM    ", "INMTNODE": "TEST", "INMTUID": "SVM    ", "INMFTIME": "20030808163828000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 3120, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "SVM    .TEST.EXEC.NEW", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SVM    .TEST.EXEC.NEW": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 3120, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3339, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "030220", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\xc0\\x00\\x00\\x01'", "DS1LSTAR": "b\"\\x00'\\x0e\"", "DS1TRBAL": "b'kr'"}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x07\\x10\\x00\\x04\\x9a\\xedP'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x07\\x10\\x00\\x04\\x9a\\xedP'", "b'P\\xf3\\x9e\\xb8\\x00\\x00\\x00\\xea\\x00\\x00\\x00\\xea\\x00\\x0e\\x00\\x0f'", "b'P\\xf3\\x9e\\xb8\\x00\\x00\\x02\\x0c\\x00\\x00\\x02\\x0c\\x00\\x0e\\x00\\x0f'", "b'P\\xf3\\x9e\\xb8\\x00\\x00\\x01\\x94\\x00\\x00\\x01\\x94\\x00\\x0e\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"#": {"ttr": 7184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x03\\x15\\x7f\\x01\\x03\\x15\\x7f\\x15(\\x00\\x8c\\x00\\x87\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-06-06T00:00:00", "modifydate": "2003-06-06T15:28:00", "lines": 140, "newlines": 135, "modlines": 0, "user": "SVM"}, "text": "/*********************************************************************/\n/*                               REXX                                */\n/*********************************************************************/\n/* Purpose: Queue an ISPTART command for batch and ALLOC ISPF DD's   */\n/*          if they aren't already allocated in the JCL              */\n/*-------------------------------------------------------------------*/\n/* Syntax:  $ command                                                */\n/*-------------------------------------------------------------------*/\n/* Parms: command    - the command to format with all parms          */\n/*                                                                   */\n/* Notes: Intended to be used in batch - normal IKJEFT01 JCL         */\n/*        Any unique DD/DSN's must be added manually to the JCL      */\n/*********************************************************************/\n/*                      Change Log                                   */\n/*                                                                   */\n/*  Author       Date      Reason                                    */\n/*  --------    ---------  ----------------------------------------- */\n/*  R. Zenuk    Sep 1997   Initial Creation                          */\n/*  R. Zenuk    10/21/98   Fixed a Comment                           */\n/*  R. Zenuk    02/25/00   Add ALLOCs in case ISPF DD's missing      */\n/*                                                                   */\n/* From: Robert Zenuk (Robzenuk@AOL.COM)                             */\n/* Subject: Re: Antwort: Re: How can I run my REXX which edits ...   */\n/* Newsgroups: bit.listserv.tsorexx                                  */\n/* Date: 2002-02-15 11:05:31 PST                                     */\n/*                                                                   */\n/*********************************************************************/\n/* Set Defaults (add additional DSNs if needed - space delimited)    */\n/*********************************************************************/\n ispplib = \"'ISP.SISPPENU'\"\n ispslib = \"'ISP.SISPSENU'\"\n ispmlib = \"'ISP.SISPMENU'\"\n isptlib = \"'ISP.SISPTENU'\"\n isptxxx = \"'\"userid()\".\"mvsvar('SYMDEF','JOBNAME')\".ISPPROF'\"\n iebcopy = \"'SYS1.LINKLIB(IEBCOPY)'\"\n/*********************************************************************/\n/* SYSPRINT messages for IEBCOPY                                     */\n/*********************************************************************/\n copyout = 'Z'\n/*********************************************************************/\n/* Accept input parameters                                           */\n/*********************************************************************/\n arg command\n/*********************************************************************/\n/* Verify parms are present and valid (RC=20 if missing)             */\n/*********************************************************************/\n if command ='' then\n    do\n     say 'Command missing'\n     exit(20)\n    end\n/*********************************************************************/\n/* Verify default DSNs exist (RC=16 if any default DSNs are missing) */\n/*********************************************************************/\n if sysdsn(ispplib) <> 'OK' then\n    do\n     say ispplib 'is not cataloged'\n     exit(16)\n    end\n if sysdsn(ispslib) <> 'OK' then\n    do\n     say ispslib 'is not cataloged'\n     exit(16)\n    end\n if sysdsn(ispmlib) <> 'OK' then\n    do\n     say ispmlib 'is not cataloged'\n     exit(16)\n    end\n if sysdsn(isptlib) <> 'OK' then\n    do\n     say isptlib 'is not cataloged'\n     exit(16)\n    end\n if sysdsn(iebcopy) <> 'OK' then\n    do\n     say iebcopy 'is missing'\n     exit(16)\n    end\n/*********************************************************************/\n/* Check if any ISPF DD's are missing                                */\n/*********************************************************************/\n PLIBRC = listdsi('ISPPLIB' 'FILE')\n if PLIBRC <> 0 then \"ALLOC F(ISPPLIB) DA(\"ispplib\") SHR REU\"\n SLIBRC = listdsi('ISPSLIB' 'FILE')\n if SLIBRC <> 0 then \"ALLOC F(ISPSLIB) DA(\"ispslib\") SHR REU\"\n MLIBRC = listdsi('ISPMLIB' 'FILE')\n if MLIBRC <> 0 then \"ALLOC F(ISPMLIB) DA(\"ispmlib\") SHR REU\"\n/*********************************************************************/\n/* \"Temporary\" DSN for ISPTLIB, ISPTABL and ISPROF                   */\n/*********************************************************************/\n TLIBRC = listdsi('ISPTLIB' 'FILE')\n TABLRC = listdsi('ISPTABL' 'FILE')\n PROFRC = listdsi('ISPPROF' 'FILE')\n if (TLIBRC <> 0 | TABLRC <> 0 | PROFRC <> 0) then\n    do\n/*********************************************************************/\n/* Use IEBCOPY to copy contents of ISPTENU DLIB to ISPTXXX           */\n/*********************************************************************/\n    \"ALLOC F(SYSUT1) DA(\"isptlib\") SHR REU\"\n     ALLOCRC = RC\n     if ALLOCRC <> 0 then say isptlib 'allocation error RC='ALLOCRC\n/*********************************************************************/\n/* ALLOC ISPTXXX DISP=(NEW,DELETE)                                   */\n/*********************************************************************/\n    \"ALLOC F(SYSUT2) DA(\"isptxxx\") UNI(SYSDA) SPACE(1 1) CYLINDERS\",\n    \"LRECL(80) BLKSIZE(3120) DSORG(PO) DIR(5) NEW DELETE\"\n     ALLOCRC = RC\n     if ALLOCRC <> 0 then say isptlib 'allocation error RC='ALLOCRC\n    \"ALLOC F(SYSIN) DUMMY\"\n/*********************************************************************/\n/* If SYSPRINT is already in the JCL, use that DD                    */\n/*********************************************************************/\n     PRINTRC = listdsi('SYSPRINT' 'FILE')\n     if PRINTRC <> 0 then \"ALLOC F(SYSPRINT) SYSOUT(\"copyout\")\"\n    \"CALL\" iebcopy\n     COPYRC = RC\n     if COPYRC <> 0 then\n        do\n         say 'IEBCOPY error loading' isptxxx 'RC='COPYRC\n         exit(COPYRC)\n        end\n    end\n if TLIBRC <> 0 then \"ALLOC F(ISPTLIB) DA(\"isptxxx\") SHR REU\"\n if TABLRC <> 0 then \"ALLOC F(ISPTABL) DA(\"isptxxx\") SHR REU\"\n if PROFRC <> 0 then \"ALLOC F(ISPPROF) DA(\"isptxxx\") SHR REU\"\n/*********************************************************************/\n/* ISPLOG                                                            */\n/*********************************************************************/\n LOGRC = listdsi('ISPLOG' 'FILE')\n if LOGRC <> 0 then\n   \"ALLOC F(ISPLOG) SYSOUT  LRECL(125) BLKSIZE(129) RECFM(V A)\"\n/*********************************************************************/\n/* Queue the command                                                 */\n/*********************************************************************/\n queue 'ISPSTART CMD('command')'\n/*********************************************************************/\n/* exit                                                              */\n/*********************************************************************/\n shutdown: exit(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#CONS": {"ttr": 9232, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x03\\x07?\\x01\\x03!\\x8f\\x11\\x14\\x00[\\x00[\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-03-14T00:00:00", "modifydate": "2003-08-06T11:14:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "SVM"}, "text": "/* REXX  --------  #CONS: Get reply from console cmd  ---------------\n|                      works in TSO environment\n| FUNCTION:\n|                   Issue a console command and\n|                   return the system's reply messages\n|\n| INPUT:            Arg command\n|                   - console command requested to issue\n|\n| OUTPUT:\n|                   Returns RC |string  string present only if RC=0\n|                   returned reply records are separated by '|'\n|\n| History of changes (last comes first):\n|\n| 03/13/2003 SVM Updated to use SYSGETL when GETMSG doesn't work\n| 11/25/2002 SVM Updated for CHKTASK\n| 07/26/2002 SVM Created\n*/\n #prefix = 'CONS:'                     /* message prefix            */\n #sep = '|'                            /* Array separator in return */\n cart=\"TIME\"('S')                      /* Cmd cart code             */\n rc_ok = 0                             /* No error rc               */\n rc_nocons = 20                        /* Activation error          */\n rc_nodata = 4                         /* Empty/No reply            */\n rc_nocmd  = 8                         /* Empty/No command          */\n wait = 1                              /* seconds, GETMSG wait int  */\n\n Arg command\n Address TSO\n sep = #sep                            /* take default              */\n If \"LENGTH\"(command) = 0 Then Do\n    Say #prefix 'No/empty command requested'\n    Return(rc_nocmd)\n    End\n Else\n    Say #prefix \"Requested command:\" command\n\n /* Activate console: */\n mdisp = SYSVAR(\"SOLDISP\")             /* save SOLDISP              */\n \"CONSPROF SOLDISPLAY(NO)\"             /* reset to get solicited    */\n mdis1 = SYSVAR(\"UNSDISP\")             /* save UNSDISP              */\n \"CONSPROF UNSOLDISPLAY(NO)\"           /* reset to get unsolicited  */\n \"CONSOLE ACTIVATE\"\n\n /* Issue command: */\n If RC <> 0 Then Do\n    Say #prefix 'Console activation RC =' RC\n    ret = RC\n    End\n Else Do\n    \"CONSOLE SYSCMD(\"command\") CART(\"cart\")\"\n    If RC <> 0 Then\n       Say #prefix 'Console Syscmd RC =' RC\n    ret = rc_ok' '\n    n = 0\n    Do attempt = 1 to 20\n       getcode = GETMSG('CONMSG.','EITHER',,,wait)\n       /*Say #prefix 'Attempt='attempt 'Getcode='getcode*/\n       If getcode = 0 Then Do\n          getcode1 = getcode\n          Do i = 1 To conmsg.0\n             conmsg.i = \"STRIP\"(conmsg.i)\n             ret = ret||sep||conmsg.i\n             n = n + 1\n             End\n          End\n       Else Do\n          If attempt = 1 Then Do\n             getcode1 = getcode\n             ret = rc_nodata\n             End\n          Else LEAVE\n          End\n       End\n    Say #prefix 'Getcode =' getcode1,\n       ||',' n 'lines returned from console request in' attempt,\n       'attempts'\n\n    If n = 0 Then\n       ret = SYSGETL(command)\n\n    End\n\n \"CONSPROF SOLDISPLAY(\"mdisp\")\"        /* restore from mdisp */\n \"CONSPROF UNSOLDISPLAY(\"mdis1\")\"      /* restore from mdis1*/\n \"CONSOLE DEACTIVATE\"\n If RC <> 0 Then\n    Say #prefix 'Console deactivation RC =' RC\n Return(ret)\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#GETJOB": {"ttr": 9993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x03\\x07?\\x01\\x03\"\\x0f\\x10\\x17\\x00\"\\x00 \\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-03-14T00:00:00", "modifydate": "2003-08-08T10:17:00", "lines": 34, "newlines": 32, "modlines": 0, "user": "SVM"}, "text": "/* REXX  ....  #GETJOB - Return my JOBNAME and JOBNUM  ...........\n|                 runs in MVS and TSO environment\n|\n|  FUNCTION      Look for current JOB name and JES JOB id\n|                in system control blocks and return to caller\n|\n|  INPUT:        n/a\n|\n|  OUTPUT:       'JOBNAME JOBNUM USERID'\n|\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  08-08-2003 SVM Added check if JSAB exists\n|  08-09-2002 SVM Added Ownerid\n|  07-29-2002 SVM Created\n| -------------------------------------------------------------------\n*/\n tcb  = ptr(540)                             /* X'21C'               */\n ascb = ptr(548)                             /* X'224'               */\n jobname = \"STRIP\"(stg(ptr(tcb+12),8))       /* TCB -> TIOT          */\n jobnum  = stg(ptr(ptr(tcb+180)+316)+12,8)   /* TCB -> JSCB -> SSIB  */\n jsab = ptr(ptr(ascb+336)+168)               /* ASCB -> JSAB         */\n If jsab <> 0 Then\n    usid = \"STRIP\"(stg(jsab+44,8))\n Else usid = ''\n Return(jobname jobnum usid)\n/*-------------------------------------------------------------------*/\nPTR:\nReturn c2d(storage(d2x(Arg(1)),4))     /* Return decimal pointer     */\n/*-------------------------------------------------------------------*/\nSTG:\nReturn storage(d2x(Arg(1)),Arg(2))     /* Return storage pointed     */\n/*--------------------  End of #GETJOB program  -------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHKPROD": {"ttr": 6158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x01\\x03\\x04\\x1f\\x01\\x03\\x16/\\x11\\x00\\x003\\x00\\x1a\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2003-02-10T00:00:00", "modifydate": "2003-06-11T11:00:00", "lines": 51, "newlines": 26, "modlines": 0, "user": "SVM"}, "text": "/* REXX System check proc for PROD ----------------------------------\n|\n| NOTE: all names starting with \"#\" are reserved!\n|       #         - White message count.\n|       ##        - Red   message count.\n|\n| 06/04/03 SVM Added check for TCPIP, and -OK messages\n| 02/10/03 SVM Created as SYS1.REXX.CNTL(CHKPROD)\n*/\n    Call WHITE(#system': ' \"DATE\"() \"TIME\"(),\n       ||'  System check in progress...')\n    #final_wait = '15s'\n    last_msg = ##\n\n    If CHECK('CCITCP')   Then\n       Call GREEN(#p \"LEFT\"(#task,8) 'TCPIP devices are READY')\n    If CHECK('ROS60')    Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('ROS60DIS') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('CICSP390') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('CICSQ390') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('CICSD390') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('CICST390') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DATAP390') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DATAQ390') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DATAD390') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DATAT390') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DBSRVD')   Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DBSRVP1')  Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DBSRVP2')  Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DBSRVQ')   Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DBSRVT1')  Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('DBSRVT2')  Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n\n If ## = last_msg Then\n    Call WHITE(#p 'All tasks run properly...')\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CHKTEST": {"ttr": 6161, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x01\\x03\\x04\\x1f\\x01\\x03\\x16/\\x11\\x00\\x00\\x1f\\x00\\x0c\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2003-02-10T00:00:00", "modifydate": "2003-06-11T11:00:00", "lines": 31, "newlines": 12, "modlines": 0, "user": "SVM"}, "text": "/* REXX System check proc for TEST -------------------------------\n|\n| NOTE: all names starting with \"#\" are reserved!\n|       #         - White message count.\n|       ##        - Red   message count.\n|\n| 06/03/03 SVM Added check TCPIP\n| 02/10/03 SVM Created as SYS1.REXX.CNTL(CHKTEST)\n*/\n    Call WHITE(#system': ' \"DATE\"() \"TIME\"(),\n       ||'  System check in progress...')\n    #final_wait = '15s'\n    last_msg = ##\n\n    If CHECK('CCITCP') Then\n       Call GREEN(#p \"LEFT\"(#task,8) 'TCPIP devices are READY')\n    If CHECK('ROS60') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n    If CHECK('HTTPD') Then\n       Call GREEN(#p \"LEFT\"(#task,8) '- OK')\n\n If ## = last_msg Then\n    Call WHITE(#p 'All tasks run properly...')\n /* Optionally remove RED messages:\n | Else Do\n |    Call L_FWT(#wait)\n |    Do i = 1 To ##\n |       Call DOMR(i)\n |       End\n |    End\n */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DCPY": {"ttr": 9478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x01\\x03\\x06\\x9f\\x01\\x03!\\x8f\\x11\\x16\\x00K\\x00E\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2003-03-10T00:00:00", "modifydate": "2003-08-06T11:16:00", "lines": 75, "newlines": 69, "modlines": 0, "user": "SVM"}, "text": "/* REXX --------------  DCPY - DSN to DD writer  ------------------\n|                       runs in any environment\n|\n|  FUNCTION (used by FTPGET to copy from generic DSN to a ddname):\n|                Copy from dsn to a ddn, both passed as ARG.\n|\n|  INPUT:        Call DCPY(dsn ddn)\n|                Parm contains input dsname and output ddname\n|                separated by a blank. Both parameters required.\n|                No default for ddn. Dsname options:\n|                   dsn = 'dsname'\n|                   dsn = 'dsname(member)'\n|                   dsn = 'dsname(member),volser' or\n|                   dsn = 'dsname,volser'\n|                   dsn = 'dsname(member),volser' or\n|  OUTPUT:\n|                If ddn exists, copy there,\n|                If dsn or ddn do not exist, issue a message.\n|\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  03/10/2003 SVM updated to use L_ALC and L_FRE\n|  08/27/2002 SVM put idsn parm in front of ofile\n|  07/15/2002 SVM Created using SCPY\n| -------------------------------------------------------------------\n*/\n #prefix = 'DCPY:'\n dsn0 = ''\n ofile = ''\n ifile = 'DCPYDCPY'\n rc_error = 4\n rc_zero = 0\n\n Arg dsn0 ofile\n If dsn0 = '' Then Do\n    Say #prefix 'Input dsname missing'\n    RETURN rc_error\n    End\n Parse Value dsn0 With dsn ',' volume\n If \"SUBSTR\"(dsn,1,1) = \"'\" Then\n    Parse Value dsn With \"'\" dsn \"'\"\n\n If ofile = '' Then Do\n    Say #prefix 'Output ddname missing'\n    RETURN rc_error\n    End\n\n Say #prefix \"Allocating input file\" dsn0 \"as\" ifile\n If \\L_ALC(ifile,dsn,volume) Then Do\n    Say #prefix ifile 'cannot be allocated for' dsn0\n    RETURN rc_error\n    End\n\n \"EXECIO * DISKR\" ifile \"(STEM inrec. FINIS\"\n Call L_FRE(ifile)\n If RC > 0 Then Do\n    Say #prefix 'Input file' ifile '- read error' RC\n    RETURN rc_error\n    End\n\n Say #prefix 'Copying file' ifile 'to' ofile '...'\n If ofile <> 'SYSTSPRT' Then Do\n    \"EXECIO * DISKW\" ofile \"(STEM inrec. FINIS\"\n    If RC > 0 Then Do\n       Say #prefix 'Output to' ofile '- write error' RC\n       RETURN rc_error\n       End\n    End\n Else Do i = 1 To record.0\n    Say record.i\n    End\n Say #prefix 'Copy complete,' inrec.0 'records copied'\n RETURN rc_zero\n /*-----------------  End of DCPY program ---------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSNSTAT": {"ttr": 6150, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0f\\x00\\x00\\x01\\x03\\x15\\x7f\\x01\\x03\\x16\\x1f\\x08'\\x00_\\x00K\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@\"", "ispf": {"version": "01.15", "flags": 0, "createdate": "2003-06-06T00:00:00", "modifydate": "2003-06-10T08:27:00", "lines": 95, "newlines": 75, "modlines": 0, "user": "SVM"}, "text": "/* REXX  Show ISPF stats for selected datasets\n|\n|  INPUT:     dsname\u00dd,vol\u00a8\n|             dsname can be a prefix\n|\n|  OUTPUT:    DSNs with statistics that matched parameters concatenated\n|  cols:      via '|'. Each dsn record has the following words:\n|  1-44         1. dsname\n|  46-51        2. volser\n|  53-56        3. dsorg\n|  58-62        4. recfm\n|  64-68        5. lrecl\n|  70-74        6. blksize\n|  76-81        7. trks allocated\n|  83-85        8. % trks used\n|  87-89        9. # of extents\n|  91-94       10. unit type (e.g. 3390)\n| 100-109      11. crtdate    '2003/06/23'\n| 111-120      12. expdate or '***None***'\n| 122-131      13. refdate    '2003/06/23'\n|\n|  Externals: ISPF LMDINIT, LMDLIST - TSO ISPF environment\n|\n*/\n   #p = 'DSNSTAT:'\n   #bl = ' '\n   #sep = '|'\n   Arg parm\n   Select\n   When arg() > 1 Then Do\n      selcrit = \"STRIP\"(arg(1))\n      vol     = \"STRIP\"(arg(2))\n      end\n   When \"POS\"(',',parm) > 0 Then Do\n      Parse Var parm selcrit ',' vol\n      selcrit = \"STRIP\"(selcrit)\n      vol     = \"STRIP\"(vol)\n      End\n   Otherwise Do\n      selcrit = \"WORD\"(parm,1)\n      vol     = \"WORD\"(parm,2)\n      End\n   End\n   Say #p 'Volume    = \"'vol'\"'\n   Say #p 'Selection = \"'selcrit'\"'\n   If selcrit = '' Then selcrit = ' '  /* select all */\n\n   \"SUBCOM ispexec\"\n   IF RC = 0 THEN\n   ADDRESS ispexec\n   ELSE Do\n      Say #p 'ISPEXEC environment not available'\n      Return(20)\n      End\n\n   If vol <> '' Then\n      'LMDINIT' 'LISTID(ID)' 'LEVEL('selcrit')' 'VOLUME('vol')'\n   Else\n      'LMDINIT' 'LISTID(ID)' 'LEVEL('selcrit')'\n   If rc <> 0 Then Say #p 'LMDINIT.rc='rc\n\n/*  Get the list of datasets to file ID   */\n   'LMDLIST' 'LISTID('ID')',\n   'OPTION(SAVE)',                 /* save to dataset */\n   'DATASET('#bl')',               /* blank - list from beginning */\n   'STATS(Y)',                     /* with statistics */\n   'GROUP('DSNSTAT')'              /* dsn=USERID.DSNSTAT.DATASETS */\n   If rc <> 0 Then Say #p 'LMDLIST.rc ='rc\n   SAVE_RC = RC\n\n   'LMDFREE' 'LISTID('ID')'\n   If rc <> 0 Then Say #p 'LMDFREE.rc ='rc\n\n/* Read dsn stats from file ID            */\n   If SAVE_RC <> 0 Then Do\n      Say #p '- No datasets found'\n      Return('8')\n      End\n   ADDRESS 'TSO'                  /* CHANGE ADDRESS */\n\n/* Read member list & stats from ISPF output file: */\n   DATASET = SYSVAR(SYSUID)||'.DSNSTAT.DATASETS'\n   \"ALLOC DA('\"DATASET\"') F(ID) OLD\"  /* ALLOC OUTPUT DSN  */\n   \"EXECIO * DISKR ID (FINIS\"    /* READ MEMBERS INTO STACK */\n   \"FREE FI(ID)\"\n   #num = QUEUED()\n   Say #p 'File read, total records='#num ':'\n   If #num = 0 Then #ret = 4\n   Else #ret = 0\n   Do #num\n      Parse PULL line\n      If SYSVAR('SYSENV') <> 'BACK' Then Say line\n      Else #ret = #ret || #sep || \"STRIP\"(line)\n      End\n   RETURN(#ret)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSD": {"ttr": 9481, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x02\\x19\\x7f\\x01\\x03!\\x8f\\x11\\x16\\x00@\\x00@\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-07-16T00:00:00", "modifydate": "2003-08-06T11:16:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "SVM"}, "text": "/* REXX -----------  INSD - DD-to-program copy  --------------\n|                 runs in both MVS and TSO environments\n|\n|  FUNCTION:\n|                Read an input ddname and interprets\n|                the records as a REXX program segment\n|                Designed to be used for insertion of rexx\n|                customization code from some PDS member\n|                Use:     INTERPRET (INSD('REXXPARM'))\n|\n|  Sample use in rexx:\n|                INTERPRET(INSD('REXXPARM'))\n|\n|  INPUT:\n|                Parm containing input ddname\n|\n|  OUTPUT:\n|                Returns #string of REXX code that can be interpreted\n|\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  03/04/2003 SVM Revised\n|  07/16/2002 SVM Created\n| -------------------------------------------------------------------\n*/\n SIGNAL ON NOVALUE\n #prefix = 'INSD: '\n Parse Arg #inddn\n\n/*--------------------------------------------------------------------\n|| Read from #inddn:\n*/\n   Arg #inddn\n   Say #prefix'Including' #inddn\n   \"EXECIO * DISKR \"#inddn\" (STEM record. FINIS\"\n   #retc = RC\n   #string = ''\n   If record.0 > 0 Then\n      #string = \"STRIP\"(record.1)\n   Do i = 2 To record.0\n      l = \"LENGTH\"(#string)\n      Select\n      When l = 0 Then Nop\n      When \"SUBSTR\"(#string,l,1) = ',' Then\n         #string = \"SUBSTR\"(#string,1,l-1) || ' '\n      Otherwise\n         #string = #string || ';'\n      End\n      #string = #string || \"STRIP\"(record.i)\n      End\n   Drop record.\n   return(#string)\n\n/*-------------------------------------------------------------------\n|| Terminate application when Unitialized variable encountered\n*/\n\n  NOVALUE:\n    SIGNAL OFF NOVALUE\n    SAY #prefix\" - Uninitialized variable used:\"\n    SAY \"   \"sigl\":\" Sourceline( sigl )\n  EXIT 20\n/*------------------  End of INSD program  ------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAPPGM": {"ttr": 8451, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x03\\x15\\x7f\\x01\\x03 \\x9f\\x14\\x19\\x00\\xb2\\x00\\xae\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2003-06-06T00:00:00", "modifydate": "2003-07-28T14:19:00", "lines": 178, "newlines": 174, "modlines": 0, "user": "SVM"}, "text": " /* REXX caller to L_PGM             */\n /* CALLPGM(dsn,member,'N' or omit)  */\n Arg parm\n If \"POS\"('(',parm) > 0 Then\n    Arg dsn '(' member ')' . ',' option\n Else\n    Arg dsn ',' member ',' option\n /* For production use L_PGM,        */\n /* for testing changes use L_PGM:*/\n ret = L_PGM(dsn,member)\n /* ret = L_PGM(dsn,member)          */\n val = value(dsn)\n Parse Value val With . 53 p#vol 59 .\n /* Display $OPEN control block:     */\n /* Say 'Length='LENGTH(val)         */\n /* Say val                          */\n /* display variables                */\n /* Say 'L_PGM.rc='rc' result='result*/\n Say 'DSN    =' dsn\n Say 'Member =' member\n Say 'Option =' option\n If ret <> '1' Then EXIT\n Say 'Volume =' p#vol\n Parse Value ptab With 1 p#name 9 p#entry 13 p#size 17 . 18 p#ssi,\n 21 p#flags 25 p#aname 33 p#aentry\n Parse Value c2x(p#ssi) With 1 p#ssi 6 .\n If p#ssi = '00000' Then p#ssi = '        '\n Else Do\n    p#ssi = \"DATE\"('U',p#ssi,'J')\n    End\n Parse Value c2x(p#flags) With 1 p#ac 3 p#at1 5 p#at2 7 p#ft2\n Parse Value x2b(p#at1) With 1 p#rent 2 p#reus 3 p#ovly,\n    4 p#test 5 p#ol 6 p#sctr 7 p#exec 8 .\n Parse value x2b(p#at2) With . 5 p#ne 6 . 8 p#refr\n Parse Value x2b(p#ft2) With 1 p#alias 2 . 4 p#rmod 5 p#aamod 7 p#mamod\n If p#rmod Then p#rmod = 'ANY';Else p#rmod = '24'\n If p#mamod = '00' Then p#amod = '24';Else p#amod = '31'\n Say 'Name       Offset     Size Date/Mlt Type'\n p#entry = c2x(p#entry)\n If p#entry = '00000000' Then p#entry = '       0'\n Else p#entry = right(strip(p#entry,'l','0'),8,' ')\n p#size  = c2x(p#size)\n If p#size  = '00000000' Then p#size  = '       0'\n Else p#size = right(strip(p#size,'l','0'),8,' ')\n If p#alias Then Do\n    If p#aamod = '00' Then p#amod = '24';Else p#amod = '31'\n    Say p#aname p#aentry,\n        p#size,\n        'is alias of' p#name\n    End\n p#attr = ''\n If p#rent Then p#attr = p#attr 'RENT'\n If p#reus Then p#attr = p#attr 'REUS'\n If p#refr Then p#attr = p#attr 'REFR'\n If p#ovly Then p#attr = p#attr 'OVLY'\n If p#test Then p#attr = p#attr 'TEST'\n If p#ol   Then p#attr = p#attr 'OL'\n If p#sctr Then p#attr = p#attr 'SCTR'\n /* If p#exec Then p#attr = p#attr 'EXEC' */\n If p#ne   Then p#attr = p#attr 'NE'\n If p#ac ='01' Then p#attr = p#attr 'AC=1'\n Say p#name p#entry,\n    right(strip(p#size,'l','0'),8,' '),\n    p#ssi 'A='p#amod,\n    'R='p#rmod||p#attr\n ccomnt.00  = 'SD (Section Definition)'\n ccomnt.03  = 'LR (Label Reference)'\n ccomnt.04  = 'PC (Private Code)'\n ccomnt.05  = 'CB (Common Block)'\n ccomnt.01  = '?'\n ccomnt.02  = 'ER (External Reference)'\n ccomnt.06  = 'PR (Pseudo Register)'\n ccomnt.07  = 'NULL'\n ccomnt.0A = 'WER (Weak External Reference)'\n comnt.C  = 'Character'\n comnt.X  = 'Hexadecimal'\n comnt.B  = 'Binary'\n comnt.F  = 'Fixed Point Fullword'\n comnt.H  = 'Fixed Point Halfword'\n comnt.E  = 'Floating Point Fullword'\n comnt.D  = 'Floating Point Doubleword'\n comnt.A  = 'Address Fullword'\n comnt.Y  = 'Address Halfword'\n comnt.S  = 'Address Halfword'\n comnt.V  = 'External Address Fullword'\n comnt.P  = 'Packed Decimal'\n comnt.Z  = 'Packed Decimal'\n comnt.L  = 'Floating Point Doubleword'\n comnt.0  = 'Blank'\n comnt.1  = 'Csect start'\n comnt.2  = 'Fiction Section'\n comnt.3  = 'Common'\n comnt.4  = 'Machine Innstruction'\n comnt.5  = 'CCW'\n comnt.6  = 'Relocatable EQU'\n i = 1\n Say 'CSECTS:'\n Do WHILE(\"LEFT\"(ctab.i,5) <> 'CTAB.')\n    Parse Value ctab.i With 1 c#name 9 c#addr 13 c#size 17,\n    c#type 18 c#ssi .\n    c#type = C2X(c#type)\n    If c#type = '00' Then Do\n       Parse Value c2x(c#ssi) With 1 c#ssi 6 .\n       If c#ssi = '00000' Then c#ssi = '        '\n       Else Do\n          c#ssi = \"DATE\"('U',c#ssi,'J')\n          End\n       End\n    Else c#ssi = '        '\n    c#addr = c2x(c#addr)\n    If c#addr = '00000000' Then c#addr = '       0'\n    Else c#addr = right(strip(c#addr,'l','0'),8,' ')\n    c#size  = c2x(c#size)\n    If c#size  = '00000000' Then c#size  = '       0'\n    Else c#size = right(strip(c#size,'l','0'),8,' ')\n    Say c#name c#addr c#size c#ssi ccomnt.c#type\n    j = 1\n    If option = 'N' Then Do\n    Do WHILE(\"LEFT\"(ctab.i.j,5) <> 'CTAB.')\n       Parse Value ctab.i.j With 1 n#name 9 n#addr 13 n#size,\n       17 n#type 18 n#dim\n       n#addr = c2x(n#addr)\n       If n#addr = '00000000' Then n#addr = '       0'\n       Else n#addr = right(strip(n#addr,'l','0'),8,' ')\n       n#size  = c2x(n#size)\n       If n#size  = '00000000' Then n#size  = '       0'\n       Else n#size = right(strip(n#size,'l','0'),8,' ')\n       n#dim=c2x(n#dim)\n       If n#dim   = '00000000' Then n#dim   = '       0'\n       Else n#dim  = right(strip(n#dim ,'l','0'),8,' ')\n       Say n#name n#addr n#size n#dim '  ' n#type,\n       comnt.n#type\n       j = j + 1\n       End\n       End\n    i = i + 1\n    End\n If option <> 'N' Then EXIT\n i = 1\n If \"LEFT\"(dtab.1,5) <> 'DTAB.' Then Do\n    Say 'DSECTS: (Mlt for DSECT is the # of parent CSECT)'\n    End\n ccomnt.00  = 'SD (DSECT Definition)'\n Do WHILE(\"LEFT\"(dtab.i,5) <> 'DTAB.')\n    Parse Value dtab.i With 1 c#name 9 c#addr 13 c#size 17,\n    c#type 18 c#num\n    c#type = C2X(c#type)\n    c#addr = c2x(c#addr)\n    If c#addr = '00000000' Then c#addr = '       0'\n    Else c#addr = right(strip(c#addr,'l','0'),8,' ')\n    c#size  = c2x(c#size)\n    If c#size  = '00000000' Then c#size  = '       0'\n    Else c#size = right(strip(c#size,'l','0'),8,' ')\n    c#num   = c2x(c#num)\n    If c#num   = '000000' Then c#num  = '       0'\n    Else c#num  = right(strip(c#num ,'l','0'),8,' ')\n    Say c#name c#addr c#size c#num ' ',\n    ccomnt.c#type\n    j = 1\n    Do WHILE(\"LEFT\"(dtab.i.j,5) <> 'DTAB.')\n       Parse Value dtab.i.j With 1 n#name 9 n#addr 13 n#size,\n       17 n#type 18 n#dim\n       n#addr = c2x(n#addr)\n       If n#addr = '00000000' Then n#addr = '       0'\n       Else n#addr = right(strip(n#addr,'l','0'),8,' ')\n       n#size  = c2x(n#size)\n       If n#size  = '00000000' Then n#size  = '       0'\n       Else n#size = right(strip(n#size,'l','0'),8,' ')\n       n#dim=c2x(n#dim)\n       If n#dim   = '00000000' Then n#dim   = '       0'\n       Else n#dim  = right(strip(n#dim ,'l','0'),8,' ')\n       Say n#name n#addr n#size n#dim '  ' n#type,\n       comnt.n#type\n       j = j + 1\n       End\n    i = i + 1\n    End\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSSTAT": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x03\\x15\\x7f\\x01\\x03\\x16\\x1f\\x081\\x00c\\x00T\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-06-06T00:00:00", "modifydate": "2003-06-10T08:31:00", "lines": 99, "newlines": 84, "modlines": 0, "user": "SVM"}, "text": "/* REXX  Show ISPF stats for selected members in PDS\n|\n|  INPUT:     dsn\u00dd,member\u00a8\n|             MEMBER = selection wildcard\n|\n|  OUTPUT:    DSN with the PDS member records matching the\n|             member selection criteria with stats, concatenated\n|  cols:      via '|'. Each member record contains the following words:\n|  FB (source):\n|    1-8         1. member\n|   23-27        2. vv.mm\n|   29-36        3. crtdate   '03/07/25'\n|   38-45        4. chgdate   '03/07/25'\n|   47-51        5. chgtime   'hh:mm'\n|   53-57        6. size      (records)\n|   59-63        7. init      (records)\n|   65-69        8. mod\n|   71-78        9. userid\n|\n|  U (load):     1. member\n|                2. size       8 digits hexadecimal\n|                3. TTR        6 digits hexadecimal\n|                4. alias_of   name of main member or blank\n|  col 47   4 or 5. AC         auth code, 00 or 01\n|  col 51   5 or 6. amode      24 or 31\n|  col 54   6 or 7. rmode      ANY or 24\n|  col 58   others. attributes separated by blanks (RN RU TS OL etc.)\n|\n|  Externals: REXXTOOL MATCH function\n|             and ISPF LMINIT, LMMLIST - TSO ISPF environment\n*/\n   #p = 'PDSSTAT:'\n   #sep = '|'\n   Arg parm\n   Select\n   When arg() > 1 Then Do\n      dsname  = \"STRIP\"(arg(1))\n      selcrit = \"STRIP\"(arg(2))\n      end\n   When \"POS\"(',',parm) > 0 Then Do\n      Parse Var parm dsname ',' selcrit\n      dsname  = \"STRIP\"(dsname)\n      selcrit = \"STRIP\"(selcrit)\n      End\n   Otherwise Do\n      dsname  = \"WORD\"(parm,1)\n      selcrit = \"WORD\"(parm,2)\n      End\n   End\n\n   Say #p 'Dsname    = \"'dsname'\"'\n   Say #p 'Selection = \"'selcrit'\"'\n   If selcrit = '' Then selcrit = '*'  /* select all */\n\n   \"SUBCOM ispexec\"\n   IF RC = 0 THEN\n   ADDRESS ispexec\n   ELSE Do\n      Say #p 'ISPEXEC environment not available'\n      Return(20)\n      End\n\n   'LMINIT' 'DATAID(ID)' 'DATASET('''dsname''')' 'ENQ(SHR)'\n\n/* Get the list of members with stats to file ID */\n   'LMOPEN' 'DATAID('ID')'\n   'LMMLIST' 'DATAID('ID')' 'OPTION(SAVE)',  /* GET PDS MEMEMBER LIST */\n      'STATS(YES)' 'GROUP('ZZMEMB')'         /* WITH THE LMMSTATS     */\n   If rc <> 0 Then Say #p 'LMMLIST.rc ='rc\n   SAVE_RC = RC\n\n   'LMCLOSE' 'DATAID('ID')'\n   If rc <> 0 Then Say #p 'LMCLOSE.rc ='rc\n   'LMFREE' 'DATAID('ID')'\n   If rc <> 0 Then Say #p 'LMFREE.rc  ='rc\n\n/* Read member stats from file ID            */\n   If SAVE_RC <> 0 Then Do        /* IF MEMBERS WERE FOUND */\n      Say '- Dataset not found or no members'\n      Return(8)\n      End\n   ADDRESS 'TSO'                  /* CHANGE ADDRESS */\n\n/* Read member list & stats from ISPF output file: */\n   DATASET = SYSVAR(SYSUID)||'.ZZMEMB.MEMBERS'\n   \"ALLOC DA('\"DATASET\"') F(ID) OLD\"  /* ALLOC OUTPUT DSN  */\n   \"EXECIO * DISKR ID (FINIS\"    /* READ MEMBERS INTO STACK */\n   \"FREE FI(ID)\"\n   #num = QUEUED()\n   Say #p 'File read, total members='#num ':'\n   If #num = 0 Then #ret = 4\n   Else #ret = 0\n   Do #num\n      Parse PULL line\n      If MATCH(selcrit,\"WORD\"(line,1)) Then\n         If SYSVAR('SYSENV') <> 'BACK' Then Say line\n         Else #ret = #ret || #sep || \"STRIP\"(line)\n      End\n   RETURN(#ret)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PW": {"ttr": 9484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01b\\x00\\x00\\x01\\x02\\x11_\\x01\\x03!\\x8f\\x11\\x17\\x01\\x7f\\x00\\xd2\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.98", "flags": 0, "createdate": "2002-04-25T00:00:00", "modifydate": "2003-08-06T11:17:00", "lines": 383, "newlines": 210, "modlines": 0, "user": "SVM"}, "text": "/* REXX\n| ......................  PW - Parm Writer  .........................\n|  Hystory of changes (first comes last):\n|\n|  03-18-2003 SVM Fixed bug if parm from Arg is empty\n|  02-24-2003 SVM Added DSN4DDN call to check if Write ddname\n|                     and TEMPL ddname are available.\n|  09-23-2002 SVM Added DSN4DDN call to check if PARM ddname avail.\n|  06-26-2002 SVM Added parm concatenation from PARM ddname.\n|  06-04-2002 SVM Changed comments, added Signal ON Novalue.\n|                     Included output to file into procpack.\n|  05-17-2002 SVM added p10-p99, added continuation records.\n|                     renamed vars to #vars to avoid intererence\n|                     with interpreted variables\n|  04-25-2002 SVM Changed writing files sequence\n|  04-09-2002 SVM Created\n| -------------------------------------------------------------------\n|                runs in both MVS and TSO environment\n|\n|  PURPOSE:\n|                Create temporary files for further use in\n|                the next steps of the JOB.\n|                Execute in-line REXX\n|\n|  FUNCTION:\n|                1) Read and validate parameters from Arg and\n|                   optionally from PARM ddname (as Arg extension)\n|                   Parameters in list must be separated by '|'\n|                2) Read template file, parse 1st col to x\n|                   and cols 2 to 72 to record (ignore cols 73-80)\n|                Process each record:\n|                   a) Substitute parameters in place of names &n\n|                   where n is a parameter number, n=1,2,...,99\n|                   (use &1.1 to distinguish &1 from &11)\n|                   If at least one parameter present and all the\n|                   parameters present are empty, set flag empty.\n|                   Continuation records share the same flag empty.\n|                   b) Replace (%) if present by a generic (name)\n|                   c) process the resulting record:\n|                   - when x = alphanumeric,\n|                     write record to SYSUTx file\n|                     ignore all records with flag empty\n|                   - when x = blank, interpret record as REXX\n|                     program line, example:\n|                      \"CALL *(SEND) '&5' ASIS\"\n|                     - calls program SEND with user-supplied parm.\n|                     Every next record starting also with a blank\n|                     is processed with the previous as a\n|                     continuation. No flag empty is applicable.\n|                   - when x = + process this record as\n|                     a continuation.\n|                Advanced users: You can set values for parameters\n|                in REXX code: for param &n use variable name p.n\n|                Do not use name p in your code for anything else.\n|                See PWX, - write variable to a ddname,\n|                    PWI, - copy datadst(member) to an output ddname,\n|                    PWD, - copy input ddname to an output ddname,\n|                    LISTPDS - get list of PDS members (TSO env only)\n|\n|  INPUT:\n|                1) Parm containing: '&1|&2|...  '\n|                   parameter number defined by position.\n|                2) PARM ddname file might contain continuation of\n|                   parameter received from PARM.EXEC.\n|                2) Template file containing &n as a reference to\n|                   the specific parm. &n is replaced param value\n|                   (e.g. &11 is replaced by p.11 value)\n|                   Example: if &11 = A and &1 = B    then\n|                   &11 is replaced by 'A'\n|                   &1.1 is replaced by 'B1'\n|  OUTPUT:\n|                1) Creates files SYSUTx, x = any alphanumeric char\n|\n|  EXTERNALS:\n|                DSN4DDN - load module (REXX function)\n| -------------------------------------------------------------------\n*/\n\n Signal On Novalue                     /* Stop if unassigned var     */\n #prefix = 'PW:'                       /* Message prefix             */\n #cont_char = '+'                      /* placed in 1st column       */\n #separator = '|'                      /* Card separator for Parm    */\n #templ = 'TEMPL'                      /* Template file DDname       */\n #ddparm = 'PARM'                      /* parameter file ddname      */\n\n Parse Arg #parm\n\n /* Add optional continuation to #parm:                              */\n If DSN4DDN(#ddparm) <> '' Then Do\n    \"EXECIO * DISKR\" #ddparm \"(STEM #prm. FINIS\"\n    If #prm.0 > 0 Then Do\n       Say #prefix #ddparm 'file records read:'#prm.0\n       #i = 1\n       If #parm = '' Then Do\n          #parm = #separator || \"STRIP\"(#prm.1)\n          #i = 2\n          End\n       Do #i = #i to #prm.0\n          #parm = #parm || #separator || \"STRIP\"(#prm.#i)\n          End\n       Drop #prm.\n       End\n    Else\n       Say #prefix 'Optional PARM DD is empty'\n    End\n Else\n    Say #prefix 'Optional PARM DD is not specified'\n Say #prefix' Parm=\"'||#parm||'\"'\n\n/* Get positional parameters:                                        */\n #i = 0\n Do While(#parm <> '')\n    #i = #i + 1\n    #col = 'POS'(#separator,#parm)\n    If #col > 0 Then\n       Parse Var #parm p.#i (#separator) #parm\n    Else Do\n       p.#i = #parm\n       #parm = ''\n       End\n    End\n p.0 = #i\n\n Do #i = 1 to p.0\n    Say #prefix' p.'||#i||'=\"'||p.#i||'\"'\n    End\n\n Do #i = p.0 + 1 to 99\n    p.#i = ''\n    End\n\n/*-------------------------------------------------------------------\n|| Read template file to template array and process templates:\n*/\n\n #total_records = 0\n #retc = 0\n If DSN4DDN(#templ) <> '' Then\n    \"EXECIO * DISKR\" #templ \"(STEM #template. FINIS\"\n Else Do\n    #template.0 = 0\n    Say #prefix 'Optional' #templ 'DD is not specified'\n    End\n\n Say #prefix' - File read from ddn('||#templ,\n    ||') total records: ' || #template.0\n\n #xx = ' '\n #buffer = ''\n Do #I = 1 To #template.0\n    Parse Value #template.#I With #x 2 #record 72\n    Parse Upper Var #x #x\n\n    /* Process record: */\n    If (#x = #cont_char),\n       | (#x = ' ' & #xx = ' ') Then Do\n       /* process continuation record: */\n       Parse Value #procrec() With #parms_empty 2 #parms_found\n       Select\n       When #xx = ' ' Then Do\n          /* add record to command buffer: */\n          #record = 'STRIP'(#record)\n          #buflen = 'LENGTH'(#buffer)\n          Select\n          When #buflen=0 Then Nop\n          When 'SUBSTR'(#buffer,#buflen,1) = ',' Then\n             #buffer = 'SUBSTR'(#buffer,1,#buflen-1) || ' '\n          Otherwise\n             #buffer = #buffer || ';'\n          End\n          #buffer = #buffer || #record\n          End\n       When 'DATATYPE'(#xx,'A') Then Do\n          /* Array record to SYSUTx */\n          If 'LENGTH'(#record) > 0 Then Do\n             #total_records = #total_records + 1\n             #fid.#total_records = #xx\n             #frec.#total_records = #record\n             End\n          Else Say #prefix' * Empty record skipped'\n          #all_parms_found = #all_parms_found | #parms_found\n          #all_parms_empty = #all_parms_found,\n             & #all_parms_empty,\n             & #parms_empty\n          End\n       Otherwise Do\n          Say #prefix' * Continuation data invalid,',\n              'record skipped'\n          #retc = 'MAX'(4,#retc)\n          End\n       End\n       End\n    Else Do\n       /* process old package: */\n       Call #procpack\n       /* Start new   package: */\n       Parse Value #procrec() With #parms_empty 2 #parms_found\n       #xx = #x\n       #all_parms_found = 0\n       #all_parms_empty = 1\n       Select\n          When #xx = ' ' Then Do\n             /* add record to command buffer: */\n             #record = 'STRIP'(#record)\n             #buffer = #record\n             End\n          When 'DATATYPE'(#xx,'A') Then Do\n             /* Array record to SYSUTx */\n             If 'LENGTH'(#record) > 0 Then Do\n                #total_records = #total_records + 1\n                #fid.#total_records = #xx\n                #frec.#total_records = #record\n                End\n             Else Say #prefix' * empty record skipped'\n             #all_parms_found = #all_parms_found | #parms_found\n             #all_parms_empty = #all_parms_found,\n                & #all_parms_empty,\n                & #parms_empty\n             End\n          Otherwise Do\n             Say #prefix' * First   character invalid,',\n                 'record skipped'\n             #retc = 'MAX'(4,#retc)\n             End\n          End\n       End\n    Say #template.#i\n    End /* Do */\n Call #procpack\n\n/*-------------------------------------------------------------------\n|| E X I T\n*/\n\n Say #prefix' - Processing complete, max RC=' #retc\n Exit #retc\n\n/*-------------------------------------------------------------------\n|| S U B R O U T I N E S\n*/\n\n/*-------------------------------------------------------------------\n|| Write records to the SYSUTx files:\n*/\n\n #Write: PROCEDURE EXPOSE #total_records #fid. #frec. #prefix #retc\n Do #i = 1 To #total_records\n    #x = #fid.#i\n    If #x <> '' Then Do\n       /* collect all records with fid = x into stack and write      */\n       \"NEWSTACK\"\n       #n = 0\n       Do #j = #i To #total_records\n          If #fid.#j = #x then do\n             #n = #n + 1\n             #fid.#j = ''\n             QUEUE #frec.#j\n             End\n          End\n       #ddname = 'SYSUT'||#x\n       Say #prefix' - writing' #n 'records to file' #ddname '...'\n       If DSN4DDN(#ddname) <> '' Then Do\n       \"EXECIO * DISKW\" #ddname \"(FINIS\"\n          If RC = 20 Then Do\n             Say #prefix' * Error processing file' #ddname\n             #retc = 'MAX'(#retc,4)\n             End\n          End\n       Else\n          Say #prefix 'Requested' #ddname 'DD is not specified'\n       \"DELSTACK\"\n       End\n    End\n Return\n\n/*-------------------------------------------------------------------\n|| Procpack: Intrpret command buffer (if any):\n*/\n\n #procpack:\n If #buffer <> '' Then Do\n    /* interpret and clear command buffer: */\n\n    Signal Off Novalue                 /* ignore user code errors   */\n    INTERPRET (#buffer)\n    Signal On  Novalue\n\n    Say #prefix' - interpreted, RC='||RC\n    RC=\"ABS\"(RC)\n    #retc = 'MAX'(RC,#retc)\n    #buffer = ''\n    End\n If #xx <> ' ' Then Do\n    Do #j = #total_records By -1 To 1,\n       While(#fid.#j = #cont_char)\n       #fid.#j = #xx\n       End\n    If #all_parms_empty Then #total_records = 'MAX'(0,#j- 1)\n    If #total_records > 0 Then\n       Call #write\n    End\n Return\n\n/*------------------------------------------------------------------\n** Process parm substitutes in record, return all_pars_empty\n**   returns:  ab\n**   a: parms_empty (1/0), if no parms found in this rec, 1\n**   b: parms_found (1/0), parms found in this record\n*/\n\n #procrec: PROCEDURE EXPOSE p. #record #x #xx #cont_char\n #col = 1\n #parms_empty = 1\n #parms_found = 0\n #j = 'POS'('&',#record)\n\n Do While(#j > 0)\n    /* substitute parameter */\n    #col1 = #col + #j - 2\n    #col2 = #col + #j\n    #n1 = 'SUBSTR'(#record,#col2,1)\n    #n2 = 'SUBSTR'(#record,#col2+1,1)\n    #nn = 'SUBSTR'(#record,#col2,2)\n    #dot = 'SUBSTR'(#record,#col2+1,1)\n    Select\n       When 'DATATYPE'(#n1) = 'NUM',\n          & 'DATATYPE'(#n2) = 'NUM' Then Do\n          #param = p.#nn\n          #parms_empty = #parms_empty & (#param = '')\n          #parms_found = 1\n          #col2 = #col2 + 2\n          End\n       When 'DATATYPE'(#n1) = 'NUM' Then Do\n          #param = p.#n1\n          #parms_empty = #parms_empty & (#param = '')\n          #parms_found = 1\n          If #dot = '.' Then #col2 = #col2 + 2\n          Else               #col2 = #col2 + 1\n          End\n       Otherwise Do\n          /* this is not a parm: */\n          #param = ''\n          #col1 = #col2 - 1\n          End\n       End\n    #record = 'SUBSTR'(#record,1,#col1) || #param,\n       || 'SUBSTR'(#record,#col2)\n    #col = #col1 + 'LENGTH'(#param) + 1\n    #j = 'POS'('&','SUBSTR'(#record,#col))\n    End\n\n/* process generic name only for output records: */\n #output = ('DATATYPE'(#x,'A'),\n    | ((#x = #cont_char) & 'DATATYPE'(#xx,'A')))\n If #record <> '' & #output Then Do\n    #j = 'POS'('(%)',#record)\n    If #j > 0 Then Do\n       /* insert generic name */\n       #j = #j + 1\n       #record = 'SUBSTR'(#record,1,#j-1)||#generic_name(),\n          ||'SUBSTR'(#record,#j+1)\n       End\n    End\n Return(#parms_empty || #parms_found)\n\n/*-------------------------------------------------------------------\n|| Generate a generic name fo member\n*/\n #generic_name: PROCEDURE\n    parse value 'DATE'('u') with #mm '/' #dd '/' #yy\n    parse value 'TIME'('l') with #hh ':' #ii ':' #ss\n    parse var #ii 2 #min\n    return ('D' || #mm || #dd || #hh || #min)\n\n/*-------------------------------------------------------------------\n|| Terminate application when Unitialized variable encountered\n*/\n  NOVALUE:\n    SIGNAL OFF NOVALUE\n    SAY #prefix\" - Uninitialized variable used:\"\n    SAY \"   \"sigl\":\" Sourceline( sigl )\n  EXIT 20\n/*----------------------  End of PW program  ------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PWD": {"ttr": 9732, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x01\\x03\\x06?\\x01\\x03!\\x8f\\x11\\x17\\x00.\\x00)\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2003-03-04T00:00:00", "modifydate": "2003-08-06T11:17:00", "lines": 46, "newlines": 41, "modlines": 0, "user": "SVM"}, "text": "/* REXX -------------  PWD - DD-to-DD writer w/print -----------\n|                 runs in both MVS and TSO environments\n|\n|  FUNCTION:\n|                Read an input ddname and put records\n|                to the specified output ddname.\n|                Designed to be used from PW.\n|\n|  INPUT:\n|                Parm containing input ddname and output ddname.\n|                   'inddname outddname'\n|                If outddname missing, SYSTSPRNT is a default.\n|\n|  OUTPUT:\n|                Copies records from inddname to outddname.\n|\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  06-16-2003 SVM Strip trailing blanks when printing to SYSTSPRT\n|  03-20-2002 SVM Revised, added read rc check/exit\n|  06-24-2002 SVM Created\n| -------------------------------------------------------------------\n*/\n\n #prefix = 'PWD: '\n #ouddn = 'SYSTSPRT'\n Parse Arg #inddn #outddn\n If #outddn = '' Then #outddn = #ouddn\n\n \"EXECIO * DISKR \"#inddn\" (STEM record. FINIS\"\n #retc = RC\n If RC <> 0 Then Do\n    Say #prefix #inddn '- read error' RC', file skipped'\n    Return (#retc)\n    End\n Say #prefix'Including' record.0 'records from' #inddn 'to' #outddn\n Do i=1 To record.0\n    Say \"STRIP\"(record.i,'t')\n    End\n If #outddn <> #ouddn Then Do\n    \"EXECIO * DISKW \"#outddn\" (STEM record. FINIS\"\n    #retc = \"MAX\"(RC,#retc)\n    End\n Return(#retc)\n/*---------------------  End of PWD program  ------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PWDR": {"ttr": 7947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x03\\x07?\\x01\\x03\\x19\\x8f\\x08\\x14\\x00/\\x00/\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-03-14T00:00:00", "modifydate": "2003-07-17T08:14:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SVM"}, "text": "/* REXX --------------  PWDR - DDN-to-PARM reader  ----------------\n|                        runs in any environment\n|\n|  FUNCTION\n|                Copy from dd to a string, separating records by\n|                '|', then returns the string to caller\n|\n|  INPUT:\n|                Parm containing input ddname\n|                   'ddname'\n|\n|  OUTPUT:\n|                If dd exists, copy it to the returned string,\n|                If dd does not exist or not supplied, return ''\n|\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  07-15-2003 SVM Strip only trailing blanks\n|  03/20/0302 SVM Changed to return null when error\n|  07-08-2002 SVM Created\n| -------------------------------------------------------------------\n*/\n #prefix = 'PWDR:'\n separator = '|'\n string = ''\n ddname = ''\n Arg ddname\n If ddname = '' Then Do\n    Say #prefix 'Error - input ddname was not specified'\n    Return(string)\n    End\n ddname = \"STRIP\"(ddname)\n \"EXECIO * DISKR\" ddname \"(STEM inrec. FINIS\"\n If RC > 0 Then Do\n    Say #prefix 'Input file' ddname '- read error' RC\n    Return(string)\n    End\n Say #prefix ' -' inrec.0,\n    'records copied to parm from' ddname\n If inrec.0 = 0 Then Return(string)\n string = \"STRIP\"(inrec.1,'t')\n Do i = 2 to inrec.0\n    string = string || separator || \"STRIP\"(inrec.i,'t')\n    End\n Return(string)\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PWI": {"ttr": 7950, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x01\\x03\\x06?\\x01\\x03\\x19\\x7f\\x11A\\x00L\\x00.\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2003-03-04T00:00:00", "modifydate": "2003-07-16T11:41:00", "lines": 76, "newlines": 46, "modlines": 0, "user": "SVM"}, "text": "/* REXX ------------  PWI - DSN-to-DD writer w/print  --------------\n|                runs in any environment\n|\n|  FUNCTION:\n|                Read a text dataset or PDS member and put records\n|                to the specified output ddname using PWX subroutine.\n|                Print a copy to SYSTSPRT.\n|                Designed to be used from PW.\n|\n|  INPUT:        Call PWI(dsn ddn)\n|                Parm contains input dsname and output ddname\n|                separated by a blank. Second parameter is optional.\n|                Default ddn='SYSTSPRT'. Dsname options:\n|                   dsn = 'dsname'\n|                   dsn = 'dsname(member)'\n|                   dsn = 'dsname(member),volser' or\n|                   dsn = 'dsname,volser'\n|                   dsn = 'dsname(member),volser' or\n|\n|  OUTPUT:\n|                Copies records from dsn(member) to ddname.\n|\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  07-15-2003 SVM Strip trailing blanks when printing to SYSTSPRT\n|  03-04-2003 SVM Replaced ALLOC/FREE to L_ALC and L_FRE\n|  08-23-2002 SVM Changed ALLOC/FREE to work in MVS environment\n|  06-24-2002 SVM Created\n| -------------------------------------------------------------------\n*/\n\n #prefix = 'PWI: '\n dsn0 = ''\n ofile = ''\n ifile = 'PWIPWIPW'\n #ofile = 'SYSTSPRT'\n rc_error = 4\n rc_zero = 0\n\n Arg dsn0 ofile\n If dsn0 = '' Then Do\n    Say #prefix 'Input dsname missing'\n    RETURN rc_error\n    End\n Parse Value dsn0 With dsn ',' volume\n If \"SUBSTR\"(dsn,1,1) = \"'\" Then\n    Parse Value dsn With \"'\" dsn \"'\"\n\n If ofile = '' Then ofile = #ofile\n\n If \\L_ALC(ifile,dsn,volume) Then Do\n    Say #prefix ifile 'cannot be allocated for' dsn0\n    RETURN rc_error\n    End\n\n \"EXECIO * DISKR\" ifile \"(STEM record. FINIS\"\n Call L_FRE(ifile)\n If RC > 0 Then Do\n    Say #prefix 'Input file' ifile '- read error' RC\n    RETURN rc_error\n    End\n\n Say #prefix'Including' record.0 'records from' dsn 'to' ofile\n If ofile <> 'SYSTSPRT' Then Do\n    \"EXECIO * DISKW\" ofile \"(STEM record. FINIS\"\n    If RC > 0 Then Do\n       Say #prefix 'Output to' ofile '- write error' RC\n       RETURN rc_error\n       End\n    End\n Do i = 1 To record.0\n    Say \"STRIP\"(record.i,'t')\n    End\n RETURN rc_zero\n/*---------------------  End of PWI program  ------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PWP": {"ttr": 9735, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x01\\x03\\x06?\\x01\\x03!\\x8f\\x11\\x17\\x00/\\x00+\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2003-03-04T00:00:00", "modifydate": "2003-08-06T11:17:00", "lines": 47, "newlines": 43, "modlines": 0, "user": "SVM"}, "text": "/* REXX --------------  PWP - DD-to-DD writer ---------------\n|                 runs in both MVS and TSO environments\n|\n|  FUNCTION:\n|                Read an input ddname and put records\n|                to the output ddname (default SYSTSPRT)\n|                Designed to be used from PW for debug\n|\n|  INPUT:\n|                Parm containing input and, optionally, output ddname\n|                   'inddname outddname'\n|\n|  OUTPUT:\n|                Copies records from inddname to SYSTSPRT.\n|\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  03-20-2003 SVM Revised, added read rc check/exit\n|  07-19-2002 SVM Removed prefix, added outddname\n|  07-08-2002 SVM Created\n| -------------------------------------------------------------------\n*/\n\n #prefix = 'PWP: '\n #ouddn = 'SYSTSPRT'\n Parse Arg #inddn #outddn\n If #outddn = '' Then #outddn = #ouddn\n\n Say #prefix'Including' #inddn 'to' #outddn\n \"EXECIO * DISKR \"#inddn\" (STEM record. FINIS\"\n #retc = RC\n If RC <> 0 Then Do\n    Say #prefix #inddn '- read error' RC', file skipped'\n    Return (#retc)\n    End\n If #outddn = 'SYSTSPRT' Then\n    Do i = 1 To record.0\n       Say \"STRIP\"(record.i,'t')\n       End\n Else Do\n    \"EXECIO * DISKW \"#outddn\" (STEM record. FINIS\"\n    #retc = \"MAX\"(RC,#retc)\n    End\n Return(#retc)\n Exit\n/*---------------------  End of PWP program  ------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PWR": {"ttr": 7953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x01\\x03\\x06?\\x01\\x03 ?\\x13Y\\x00A\\x00;\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2003-03-04T00:00:00", "modifydate": "2003-07-22T13:59:00", "lines": 65, "newlines": 59, "modlines": 0, "user": "SVM"}, "text": "/* REXX --------------  PWR - DSN-to-PARM reader  ----------------\n|                 runs in both MVS and TSO environment\n|\n|  FUNCTION      Used in PW templates:\n|                Copy from dsn to a string, separating records by\n|                '|', then returns the string to caller\n|\n|  INPUT:\n|                Required parm containing input dsname\n|                   'dsname'\n|                   'dsname(member)'\n|                   'dsname(member),volser' or\n|                   'dsname,volser'\n|\n|  OUTPUT:\n|                If dsn exists, copy it to the returned string,\n|                If dsn does not exist or not supplied, return null\n|\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  07-15-2003 SVM Strip only trailing blanks\n|  07-08-2002 SVM Replaced TSO ALLOC/FREE by L_ALC and L_FRE\n|             to serve GDG(0) and better messaging.\n|  07-08-2002 SVM Created\n| -------------------------------------------------------------------\n*/\n #prefix = 'PWR:'\n ifile = 'PWRPWRPW'\n separator = '|'\n dsn0 = ''\n string = ''\n Arg dsn0\n If dsn0 = '' Then Do\n    Say #prefix 'Error - input dsname was not specified'\n    Return(string)\n    End\n\n dsn0 = \"STRIP\"(dsn0)\n Parse Value dsn0 With dsn ',' volume\n If \"SUBSTR\"(dsn,1,1) = \"'\" Then\n    Parse Value dsn With \"'\" dsn \"'\"\n\n If \\L_ALC(ifile,dsn,volume) Then Do\n    Say #prefix ifile 'cannot be allocated for' dsn0\n    Return(string)\n    End\n\n \"EXECIO * DISKR\" ifile \"(STEM inrec. FINIS\"\n Call L_FRE(ifile)\n If RC > 0 Then Do\n    Say #prefix 'Input dsn' dsn0 '- read error' RC\n    Return(string)\n    End\n Say #prefix ' -' inrec.0,\n    'records copied to parm from' dsn0\n If inrec.0 = 0 Then Return(string)\n string = \"STRIP\"(inrec.1,'t')\n /* Say inrec.1 */\n Do i = 2 to inrec.0\n    string = string || separator || \"STRIP\"(inrec.i,'t')\n    /* Say inrec.i */\n    End\n Return(string)\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PWX": {"ttr": 9738, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x01\\x03\\x19\\x7f\\x01\\x03!\\x8f\\x11\\x18\\x00\\xa3\\x00\\xa3\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2003-07-16T00:00:00", "modifydate": "2003-08-06T11:18:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "SVM"}, "text": "/* REXX -------------  PWX - Parm-to-DD writer  ------------------\n|                 runs in both MVS and TSO environments\n|\n|  PURPOSE:\n|                Use parm containing a sequence of template records\n|                separated by a selected character,\n|                to write the records to a specified ddname.\n|                Designed to be used from PW TEMPL REXX segments\n|                for JCL generation.\n|\n|  FUNCTION:\n|                Read template records from Arg,\n|                process each record:\n|                   a) Replace (%) (if present) by a generic\n|                      member name (8 char)\n|                   b) skip empty (blank) records\n|                   c) write records to the file\n|\n|  INPUT:\n|                Parm containing templates. Format of the parm:\n|                   'file template|template|...'\n|\n|  OUTPUT:\n|                Creates file. If multiple calls to PWX are used\n|                   set DISP=MOD in your JCL DD for the file.\n|\n|  EXTERNALS:    REXX functions:\n|                DSN4DDN - get DSN for DDN (check if DDN present)\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  07-15-2003 SVM Made output records 80 char long\n|  05-20-2003 SVM Added DDNAME check before writing\n|  03-04-2003 SVM Revised\n|  05-30-2002 SVM Created\n| -------------------------------------------------------------------\n*/\n\n SIGNAL ON NOVALUE\n #separator = '|'                      /* separator for templates  */\n #prefix = 'PWX: '\n #gmember = '%'\n #retc = 0\n Parse Arg #file #parm\n #file = Translate(#file)\n\n/*--------------------------------------------------------------------\n|| Get templates to a stem:\n*/\n\n #i = 0\n Do While(#parm <> '')\n    #i = #i + 1\n    #col = 'POS'(#separator,#parm)\n    If #col > 0 Then\n       Parse Var #parm #template.#i (#separator) #parm\n    Else Do\n       #template.#i = #parm\n       #parm = ''\n       End\n    End\n #template.0 = #i\n\n/*--------------------------------------------------------------------\n|| Process templates:\n*/\n\n #total_records = 0\n\n Do #I = 1 To #template.0\n    #record = #template.#I\n    If 'LENGTH'(#record) > 0 Then Do\n       call #procrec\n       #total_records = #total_records + 1\n       #frec.#total_records = #record\n       End\n    Else Say #prefix' - Empty record skipped'\n    End\n\n/*-------------------------------------------------------------------\n|| Write records to the file:\n*/\n\n If #file <> '' Then Do\n    Say #prefix 'Including' #total_records 'records from PARM to',\n       #file\n    #n = #total_records\n    Do #i = 1 to #n\n       Say #frec.#i\n       #frec.#i = \"LEFT\"(#frec.#i,80)\n       End\n    If DSN4DDN(#file) = '' Then Do\n       Say #prefix' - File DD name' #file 'not found'\n       #retc = 4\n       End\n    Else If #file <> 'SYSTSPRT' Then Do\n       \"EXECIO\" #n \"DISKW\" #file \"(STEM #frec. FINIS)\"\n       If RC = 20 Then Do\n          Say #prefix' - Error processing file' #file\n          #retc = 'MAX'(#retc,4)\n          #n = 0\n          End\n       End\n    End\n Else Do\n    Say #prefix' - File DD name missing or invalid'\n    #retc = 12\n    End\n\n/*-------------------------------------------------------------------\n|| E X I T\n*/\n\n RETURN #retc\n EXIT #retc\n\n/*===================================================================\n|| S U B R O U T I N E S\n*/\n\n/*------------------------------------------------------------------\n|| Process parm substitutes in record, return all_pars_empty\n||   returns:  ab\n||   a: parms_empty (1/0), if no parms found in this rec, 1\n||   b: parms_found (1/0), parms found in this record\n*/\n\n #procrec: PROCEDURE EXPOSE #record #gmember\n\n/* process generic name: */\n If #record <> '' Then Do\n    #s = '('||#gmember||')'\n    #j = 'POS'(#s,#record)\n    #l = \"LENGTH\"(#gmember)\n    If #j > 0 Then Do\n       /* insert generic name */\n       #j = #j + 1\n       #record = 'SUBSTR'(#record,1,#j-1)||#generic_name(),\n          ||'SUBSTR'(#record,#j+#l)\n       End\n    End\n Return('')\n\n/*-------------------------------------------------------------------\n|| Generate a generic name fo member\n*/\n #generic_name: PROCEDURE\n\n    parse value 'DATE'('u') with #mm '/' #dd '/' #yy\n    parse value 'TIME'('l') with #hh ':' #ii ':' #ss\n    parse var #ii 2 #min\n    return ('D' || #mm || #dd || #hh || #min)\n\n/*-------------------------------------------------------------------\n|| Terminate application when Unitialized variable encountered\n*/\n\n  NOVALUE:\n    SIGNAL OFF NOVALUE\n    SAY #prefix\" - Uninitialized variable used:\"\n    SAY \"   \"sigl\":\" Sourceline( sigl )\n  EXIT 20\n/*-------------------  End of PWX program  ------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RCTEST": {"ttr": 6671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x01\\x03\\x17\\x1f\\x01\\x03\\x17\\x1f\\t0\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-06-20T00:00:00", "modifydate": "2003-06-20T09:30:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SVM"}, "text": "/* REXX -- compare two parameters and exit with RC */\n Arg parm\n Select\n When arg() > 1 Then Do\n    par.1   = \"STRIP\"(arg(1))\n    par.2   = \"STRIP\"(arg(2))\n    end\n When \"POS\"(',',parm) > 0 Then Do\n    Parse Var parm par.1 ',' par.2\n    par.1   = \"STRIP\"(par.1)\n    par.2   = \"STRIP\"(par.2)\n    End\n Otherwise Do\n    par.1   = \"WORD\"(parm,1)\n    par.2   = \"WORD\"(parm,2)\n    End\n End\n/* Check the parameters: */\n If par.1 = par.2 Then EXIT(0)\n Else EXIT(8)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCPY": {"ttr": 9744, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x01\\x03\\x14/\\x01\\x03!\\x8f\\x11\\x18\\x00\\xb9\\x00\\xb5\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2003-05-22T00:00:00", "modifydate": "2003-08-06T11:18:00", "lines": 185, "newlines": 181, "modlines": 0, "user": "SVM"}, "text": "/* REXX --------------  SCPY - DD to DSN writer  ------------------\n|                       runs in TSO environment\n|\n|  FUNCTION (used as dummy converter/copy creator for splits):\n|                Copy from dd to a dsn, both passed as ARG.\n|                If copy successful, write message to a file.\n|\n|  INPUT:\n|                Parm containing input ddname and output dsname.\n|                  call SCPY(ifile dsn)\n|                defaults are: SENDFILE FTPUSER.TEMP.LOG\n|                dsn can contain PDS member name or GDG relative #:\n|                'ABC.MYPDS(MYMEMB)',  'ABC.MYGDG(+1)'.\n|                No HLQ will be added to the dsn given.\n|\n|  OUTPUT:\n|                If dsn exists, copy and reset LRECL and BLKSIZE.\n|                If dsn does not exist, create and copy there.\n|\n|  EXTERNALS:\n|                REXX functions:\n|                L_DDN - replacement for ListDSI that fails with VIO\n|                L_DSN - Replacement for ListDSI for dsn/GDG\n|                DSN4DDN -check if DD allocated\n| -------------------------------------------------------------------\n|  Hystory of changes (first comes last):\n|\n|  07-21-2003 SVM Stripped input parameters\n|  05-27-2003 SVM Updated for big files, VIO files and GDG\n|  07-02-2002 SVM Created\n| -------------------------------------------------------------------\n*/\n #prefix = 'SCPY:'\n #odsn = 'FTPUSER.TEMP.LOG'\n #ifile = 'SENDFILE'\n #ofile = 'FILESEND'\n #mfile = 'SCPYMSGF'\n\n dsn = ''\n ifile = ''\n Arg ifile parmdsn\n parmdsn=\"STRIP\"(parmdsn)\n ifile = \"STRIP\"(ifile)\n If parmdsn = '' Then parmdsn = #odsn\n dsn = \"'\"||parmdsn||\"'\"\n If ifile = '' Then ifile = #ifile\n\n/*-------------------------------------------------------------------\n|  Check input file (L_DDN works even it is VIO):\n*/\n If L_DDN(ifile) = 0 Then Do\n    Say #prefix 'Input file' ifile 'not found'\n    EXIT 8\n    End\n primary = SYSPRIMARY\n seconds = SYSSECONDS\n inrecfm = SYSRECFM\n inunits = SYSUNITS\n If inunits = 'BLOCK' Then\n    inunits = 'TRACK'\n inrecl  = SYSLRECL\n If primary = '' |,\n    seconds = '' |,\n    inrecfm = '' |,\n    inunits = '' |,\n    inrecl =  '' Then Do\n    /**** This should not ever happen, but... ****/\n /* Call L_WTO(#prefix 'Empty parm returned by L_DDN') */\n    Say #prefix 'Empty parm returned by L_DDN:'\n    Say '   SYSPRIMARY =' SYSPRIMARY\n    Say '   SYSSECONDS =' SYSSECONDS\n    Say '   SYSRECFM   =' SYSRECFM\n    Say '   SYSUNITS   =' SYSUNITS\n    say '   SYSLRECL   =' SYSLRECL\n    End\n\n/*-------------------------------------------------------------------\n|  Check output file: allocate if exists, create if not:\n|  (can use either DSN4DDN or L_DDN, L_DDN will update SYS* variables)\n*/\n If DSN4DDN(#ofile) <> '' Then Do\n    \"FREE DDNAME(\"#ofile\")\"\n    Say #prefix \"Freeing ddname \"#ofile\" ... RC=\"rc\n    End\n\n Parse Var parmdsn dsn1 '(' member ')'\n gdg = (\"DATATYPE\"(member) = 'NUM')\n If gdg Then old = L_DSN(parmdsn)\n Else        old = L_DSN(dsn1)\n If old Then Do\n    /*** Allocate existing ***/\n    If gdg Then dsn=\"'\"SYSDSNAME\"'\"\n    orecl = SYSLRECL\n    If orecl < inrecl Then Do\n       Say #prefix 'Changing LRECL='orecl 'to' inrecl 'for:' dsn\"...\"\n       End\n    \"ALLOC DD(\" || #ofile || \")\",\n       \"LRECL(\" || inrecl || \")\",\n       \"BLKSIZE(0)\",\n       \"DA(\" || dsn || \")\",\n       \"SHR\"\n    If RC <> 0 Then Do\n       Say #prefix 'Allocation for existing dsn' dsn 'failed'\n       EXIT 8\n       End\n    End\n Else Do\n    /*** Create new: ***/\n    recfm = \"SUBSTR\"(inrecfm,1,1)\n    Do i = 2 To \"LENGTH\"(inrecfm)\n       recfm = recfm \"SUBSTR\"(inrecfm,i,1)\n       End\n\n    If gdg Then dsn = \"'\"SYSDSNAME\"'\"\n    \"ALLOC DD(\" || #ofile || \")\",\n          \"DA(\" || dsn || \")\",\n          \"LRECL(\" || inrecl || \")\",\n          \"SPACE(\" || primary || \",\" || seconds || \")\",\n          \"RECFM(\" || recfm || \")\",\n          \"BLKSIZE(0)\",\n          \"NEW\",\n          inunits,\n          \"CATALOG\",\n          \"RELEASE\"\n    Say #prefix \"Allocating new \"dsn\" ... RC=\"rc\n\n    If RC <> 0 Then Do\n       Say #prefix 'Allocation failed' RC\n       EXIT 8\n       End\n    End\n\n/*-------------------------------------------------------------------\n|  Update dsn for GDG and copy data:\n*/\n If L_DDN(#ofile) Then\n    dsn = SYSDSNAME\n If member <> '' Then\n    If \"DATATYPE\"(member) <> 'NUM' Then\n       dsn = dsn || '('member')'\n msg.1 = 'Report saved to DSN =' dsn\n Say #prefix 'Copying file' ifile 'to' dsn '...'\n irec# = 0\n orec# = 0\n \"EXECIO 0 DISKW\" #ofile \"(OPEN\"\n If RC > 0 Then Do\n    Say #prefix 'Open error' RC 'file' #ofile\n    EXIT 8\n    End\n Do Forever /* Exit to EOF done by GETREC */\n    Call GETREC\n    \"EXECIO 1 DISKW\" #ofile\n    If RC > 0 Then Do\n       Say #prefix 'Write error' RC 'record' irec#\n       \"EXECIO 0 DISKW\" #ofile \"(FINIS\"\n       EXIT 8\n       End\n    Else orec# = orec# + 1\n    End\n\n EOF:\n \"EXECIO 0 DISKW\" #ofile \"(FINIS\"\n Say #prefix 'Copy complete,' orec#,\n    'records copied'\n\n/*-------------------------------------------------------------------\n|  Write optional message(s) to a temp file:\n*/\n If DSN4DDN(#mfile) <> '' Then Do\n    \"EXECIO * DISKW\" #mfile \"(STEM msg. FINIS\"\n    End\n EXIT\n\n/*-------------------------------------------------------------------\n|  Read a record from ifile:\n*/\nGETREC:\n \"EXECIO 1 DISKR\" ifile\n /* record in stack */\n If RC <> 0 Then Do\n    \"EXECIO 0 DISKR\" ifile \"(FINIS\"\n    Signal EOF\n    End\n irec# = irec# + 1\n Return\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHUTPROD": {"ttr": 8457, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01.\\x00\\x00\\x01\\x03\\x04\\x1f\\x01\\x03!?\\x08G\\x00\\xe0\\x00J\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.46", "flags": 0, "createdate": "2003-02-10T00:00:00", "modifydate": "2003-08-01T08:47:00", "lines": 224, "newlines": 74, "modlines": 0, "user": "SVM"}, "text": "/* REXX System shutdown sequence for PROD -------------\n|       Executed by the REXX program SYSCNTL as interpreted REXX code\n|       Program SYSCNTL is executed by CHKTASK started task.\n|\n| 08/01/03 SVM Added smart waiting for VTAM termination\n|          before stopping LLA, VLF and JES2.\n| 06/30/03 SVM Added STOP_REMAINING, chg to 'D R,R...'\n| 06/20/03 SVM CAdded optional shutdown for CICS* and DBSRV*, LLA, VLF\n| 05/21/03 SVM CReplaced FWAIT to L_FWT\n| 05/05/03 SVM CCorrected CA07ONL to CA7ONL\n| 04/23/03 DEB Added RIO and new printers\n| 02/26/03 SVM Created as a SYS1.REXX.CNTL(SHUTPROD)\n|\n| NOTE: all names starting with \"#\" are reserved!\n|       #         - White message count.\n|       ##        - Red   message count.\n|       #parm     - parm coming from EXEC CHKTASK,\n|                   in this exec used as simulation flag\n|       #simulate - simulate flag, used to control SYSCNTL console\n|                   functions\n|       #tasklist - original list of active tasks,\n|       #tsolist  - original list of active TSO users\n|          both #tasklist and #tsolist can be set at any time using\n|          #tasklist = ACTIVE()\n|          #tsolist  = TACTIVE()\n|       #wait     - wait interval between issuing STOP task commands\n|       #final_wait - wait interval before termination CHKTASK\n|       #FIN      - to terminate processing before end: Signal #FIN\n|       See SYSCNTL for details.\n*/\n/*-------------------------------------------------------------------\n|  Check simulation mode, confirm function and set waiting times:\n|       Use name \"#simulate\" for simulation flag.\n*/\n    #simulate = #parm\n    If #simulate <> '0' Then #simulate = 1\n\n    If #simulate Then\n       msg = \"Please reply 'U' to confirm SHUTDOWN\",\n          \"simulation, 'N' to cancel\"\n    Else\n       msg = \"Please reply 'U' to confirm SHUTDOWN, 'N' to cancel\"\n    rep=WTOR(msg)\n    If rep <> 'U' & rep <> 'u' Then Do\n       Call GREEN('Processing cancelled due to operator request')\n       Signal #FIN\n       End\n\n    If #simulate Then Do\n       Call WHITE(#p \"DATE\"() \"TIME\"(),\n          || '  Shutdown simulation in progress...')\n       #wait = '1s'                       /* wait between commands  */\n       #final_wait = '5s'                 /* wait before cleanup    */\n       End\n    Else Do\n       Call WHITE(#p \"DATE\"() \"TIME\"(),\n          ||'  Shutdown in progress...')\n       #wait = '4s'                       /* wait between commands  */\n       #final_wait = '20s'                /* wait before cleanup    */\n       End\n\n/*-------------------------------------------------------------------\n|  Ask operator,  if CICS*, DATA* of DBSRV* still active:\n*/\n    If  (\"POS\"(' CICS',#tasklist) > 0,\n       |\"POS\"(' DATA',#tasklist) > 0,\n       |\"POS\"(' DBSRV',#tasklist) > 0) & (#simulate = '0') Then Do\n       Call WHITE(#p 'Some CICS, DATA, or DBSRV regions',\n          'are active')\n       rep = WTOR('Reply \"U\" to continue shutdown,',\n          '\"N\" to terminate')\n       If rep <> 'U' & rep <> 'u' Then Do\n          Call GREEN(#p 'Shutdown terminated by operator')\n          Signal #FIN\n          End\n       Call DOM(#)\n       Call STOP('CICSP390')\n       Call STOP('CICSQ390')\n       Call STOP('CICSD390')\n       Call STOP('CICST390')\n       Call STOP('DBSRVD')\n       Call STOP('DBSRVP1')\n       Call STOP('DBSRVP2')\n       Call STOP('DBSRVQ')\n       Call STOP('DBSRVT1')\n       Call STOP('DBSRVT2')\n       End\n\n/*-------------------------------------------------------------------\n|  Show active TSO users, if any:\n|\n|   tso_msg1 = # + 1\n|   If #tsolist <> '' Then Do\n|      Call WHITE('TSO users still active:')\n|      Call DSP_ACTIVE(#tsolist)\n|      End\n|   tso_msg2 = #\n*/\n/*-------------------------------------------------------------------\n|  Stopping tasks:\n*/\n    Call STOP('ROS60')\n    Call STOP('ROS60DIS')\n    Call STOP('IF40')\n    Call STOP('RADAR')\n    Call STOP('DFS')\n    Call STOP('GRTASK')\n    Call STOP('XGSTART')\n    Call STOP('TDCAS')\n    CALL STOP('RIO')\n    Call STOP('TMONCICS')\n    Call STOP('TMVSMSTR')     /* stops TMONMVS and TMVSLFS  as well */\n    Call STOP('PRT')          /* stop remote printers */\n    Call STOP('AOP')\n    Call STOP('LOGON1')\n    Call STOP('LINE1')\n    Call STOP('CA7ONL')\n    Call STOP('CAD4PROC')\n    Call STOP('CA7ICOM')\n    Call STOP('CA11')\n    Call STOP('CA7XTRK')\n    Call STOP('CA7ONLT')\n    Call STOP('SVTS')\n    Call STOP('CTS')\n    Call STOP('CCITCP')\n    Call STOP('CCITCPGW')\n    Call STOP('ENF')\n    Call STOP('LSSHUBR')\n    Call STOP('LSSHUBM')\n    Call STOP('TCELFS')\n    Call STOP('RMF')\n    Call STOP('TSO')\n    Call STOP('LOGROUTE')\n    Call STOP('SYNCDSM')\n    Call STOP('SDSF')\n    Call STOP('ASCH')\n    Call STOP('APPC')\n    Call STOP('FFST')\n    Call STOP('DLF')\n    Call STOP('GPMSERVE')\n    Call STOP('FWKERN')\n    Call STOP('CRON6')\n    Call STOP('SYSLOGD5')\n\n/*-------------------------------------------------------------------\n|  Reply outstanding messages from stopping tasks. After Parse #CONS\n|  the #request value contains console requests and is used by REPLYIT\n*/\n    Call L_FWT(#wait)\n    Parse Value #CONS('D R,R,CN=MASTER') With rc #request\n    Call DISP_REPLY(#request)\n\n    Call REPLYIT('CATK0246' 'DDSSHUT')            /* CAD4PROC    */\n    Call REPLYIT('EPW0309I' 'YES')                /* FFST        */\n    Call REPLYIT('CAS9227A' 'Y')                  /* ENF         */\n    Call REPLYIT('IKT010D' 'FSTOP')               /* TSO         */\n\n/* Now remove messages about active TSO users:\n|   Do i = tso_msg1 By 1 To tso_msg2\n|      Call DOM(i)\n|      End\n*/\n/*-------------------------------------------------------------------\n|  Continue stopping tasks:\n*/\n\n    Call STOP('RACF')\n    Call STOP('WEBSRV')\n    Call STOP('TCPIPE')\n\n    Call STOP_REMAINING('LLA VLF JES2 DFSMSHSM BPXOINIT VTAM')\n\n    Call STOP('DFSMSHSM')\n    Call STOP('BPXOINIT')\n    Call STOP('VTAM')\n    /* Wait until remain CHKTASK,LLA,VLF and JES only 4 tasks */\n    Do 10\n       Call ACTIVE\n       If \"WORDS\"(#tasklist) > 4 Then\n          Call L_FWT(#wait)\n       Else LEAVE\n       End\n    Call STOP('LLA')\n    Call STOP('VLF')\n    Call STOP('JES2')\n\n/*-------------------------------------------------------------------\n|  Final messages:\n*/\n    Call L_FWT(#final_wait)\n    tasklist = ACTIVE()\n    tsolist = TACTIVE()\n    Call WHITE(#p 'Automatic Shutdown complete')\n    If \"WORDS\"(tasklist) > 1 Then Do\n       Call WHITE(#p 'Remaining active tasks:')\n       Call DSP_ACTIVE(tasklist)\n       End\n    If tsolist <> '' Then Do\n       Call WHITE(#p 'TSO users acive:')\n       Call DSP_ACTIVE(tsolist)\n       End\n\n    If \"POS\"('JES2',tasklist) > 0 Then Do\n       Call GREEN('Instructions to complete Shutdown manually:')\n       Call GREEN(' - if you are going to FORMAT or COLD START,')\n       Call GREEN('   enter \"W A\" to create final SYSLOG')\n       Call GREEN(' - when all reports are finished printing, enter:')\n       Call GREEN('   $P PRT3160')\n       Call GREEN('   $P PRT31602')\n       CALL GREEN('   $P PRT1145')\n       CALL GREEN('   $P PRT11452')\n       Call GREEN(' - after printers have drained, enter:')\n       Call GREEN('   C FSS3160')\n       Call GREEN('   C FSS31602')\n       CALL GREEN('   C FSS1145')\n       CALL GREEN('   C FSS11452')\n       Call GREEN(' - when JES2 \"All available functions complete\":')\n       Call GREEN('   $P JES2')\n       Call GREEN('   Z EOD')\n       End\n    Else Do\n       Call GREEN('-  Shutdown complete, ready for')\n       Call GREEN('   Z EOD')\n       End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHUTTEST": {"ttr": 8464, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x018\\x00\\x00\\x01\\x03\\x04\\x1f\\x01\\x03!?\\x08G\\x00\\xa6\\x001\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.56", "flags": 0, "createdate": "2003-02-10T00:00:00", "modifydate": "2003-08-01T08:47:00", "lines": 166, "newlines": 49, "modlines": 0, "user": "SVM"}, "text": "/* REXX System shutdown sequence for TEST -------------\n|       Executed by the REXX program SYSCNTL as interpreted REXX code\n|       Program SYSCNTL is executed by CHKTASK started task.\n|\n| 08/01/03 SVM Added smart waiting for VTAM termination\n|          before stopping LLA, VLF and JES2.\n| 06/30/03 SVM Added STOP_REMAINING, chg to 'D R,R...'\n| 05/21/03 SVM Replaced FWAIT by L_FWT\n| 04/24/03 DEB Added RIO and new printers\n| 02/26/03 SVM Created as SYS1.REXX.CNTL(SHUTTEST)\n|\n| NOTE: all names starting with \"#\" are reserved!\n|       #         - White message count.\n|       ##        - Red   message count.\n|       #parm     - parm coming from EXEC CHKTASK,\n|                   in this exec used as simulation flag\n|       #simulate - simulate flag, used to control SYSCNTL console\n|                   functions\n|       #tasklist - original list of active tasks,\n|       #tsolist  - original list of active TSO users\n|          both #tasklist and #tsolist can be set at any time using\n|          #tasklist = ACTIVE()\n|          #tsolist  = TACTIVE()\n|       #FIN      - to terminate processing before end: Signal #FIN\n|\n*/\n/*-------------------------------------------------------------------\n|  Check simulation mode, confirm function and set waiting times:\n*/\n    #simulate = #parm\n    If #simulate <> '0' Then #simulate = 1\n\n    If #simulate Then\n       msg = \"Please reply 'U' to confirm SHUTDOWN\",\n          \"simulation, 'N' to cancel\"\n    Else\n       msg = \"Please reply 'U' to confirm SHUTDOWN, 'N' to cancel\"\n    rep=WTOR(msg)\n    If rep <> 'U' & rep <> 'u' Then Do\n       Call GREEN('Processing cancelled due to operator request')\n       Signal #FIN\n       End\n\n    If #simulate Then Do\n       Call WHITE(#p \"DATE\"() \"TIME\"(),\n          ||'  Shutdown simulation in progress...')\n       #wait = '1s'                       /* wait between commands  */\n       #final_wait = '5s'                 /* wait before cleanup    */\n       End\n    Else Do\n       Call WHITE(#p \"DATE\"() \"TIME\"(),\n          ||'  Shutdown in progress...')\n       #wait = '4s'                       /* wait between commands  */\n       #final_wait = '20s'                /* wait before cleanup    */\n       End\n\n/*-------------------------------------------------------------------\n|  Show active TSO users:\n|\n|   tso_msg1 = # + 1\n|   If #tsolist <> '' Then Do\n|      tso_msg1 = WHITE(#p 'TSO users still active:')\n|      Call DSP_ACTIVE(#tsolist)\n|      End\n|   tso_msg2 = #\n*/\n/*-------------------------------------------------------------------\n|  Stopping tasks:\n*/\n    Call STOP('ROS60')\n    Call STOP('GRTASK')\n    Call STOP('XGSTART')\n    Call STOP('RIO')\n    Call STOP('TMVSMSTR')     /* stops TMONMVS and TMVSLFS  as well */\n    Call STOP('PRT')          /* stops remote printers */\n    Call STOP('AOP')\n    Call STOP('LOGON1')\n    Call STOP('LINE1')\n    Call STOP('CTS')\n    Call STOP('CCITCP')\n    Call STOP('ENF')\n    Call STOP('RMF')\n    Call STOP('TSO')\n    Call STOP('LOGROUTE')\n    Call STOP('SYNCDSM')\n    Call STOP('LSSHUBM')\n    Call STOP('SDSF')\n    Call STOP('ASCH')\n    Call STOP('APPC')\n    Call STOP('FFST')\n    Call STOP('DLF')\n\n/*-------------------------------------------------------------------\n|  Reply outstanding messages from FFST and  ENF: After Parse #CONS\n|  the #request value contains console requests and is used by REPLYIT\n*/\n    Call L_FWT(#wait)\n    Parse Value #CONS('D R,R,CN=MASTER') With rc #request\n    Call DISP_REPLY(#request)\n\n    Call REPLYIT('EPW0309I' 'YES')      /* FFST        */\n    Call REPLYIT('CAS9227A' 'Y')        /* ENF         */\n    Call REPLYIT('IKT010D' 'FSTOP')     /* TSO         */\n\n/* Remove old messages about Active TSO users:\n|   Do i = tso_msg1 By 1 To tso_msg2\n|      Call DOM(i)\n|      End\n*/\n/*-------------------------------------------------------------------\n|  Continue stopping tasks:\n*/\n    Call STOP('FWKERN')\n    Call STOP('CRON6')\n    Call STOP('SYSLOGD5')\n    Call STOP('RACF')\n    Call STOP('WEBSRV')\n    Call STOP('TCPIPE')\n\n    Call STOP_REMAINING('LLA VLF JES2 DFSMSHSM BPXOINIT VTAM')\n\n    Call STOP('DFSMSHSM')\n    Call STOP('BPXOINIT')\n    Call STOP('VTAM')\n    /* Wait until remain CHKTASK,LLA,VLF and JES only 4 tasks */\n    Do 10\n       Call ACTIVE\n       If \"WORDS\"(#tasklist) > 4 Then\n          Call L_FWT(#wait)\n       Else LEAVE\n       End\n    Call STOP('LLA')\n    Call STOP('VLF')\n    Call STOP('JES2')\n/*-------------------------------------------------------------------\n|  Final messages:\n*/\n    Call L_FWT(#final_wait)             /* wait until stop ends */\n    tasklist = ACTIVE()\n    tsolist = TACTIVE()\n    Call WHITE(#p 'Automatic Shutdown complete')\n    If \"WORDS\"(tasklist) > 1 Then Do\n       Call WHITE(#p 'Remaining active tasks:')\n       Call DSP_ACTIVE(tasklist)\n       End\n    If tsolist <> '' Then Do\n       Call WHITE(#p 'TSO users acive:')\n       Call DSP_ACTIVE(tsolist)\n       End\n\n    If \"POS\"('JES2',tasklist) > 0 Then Do\n       Call GREEN('Instructions to complete Shutdown manually:')\n       Call GREEN(' - when all reports are finished printing, enter:')\n       CALL GREEN('   $P PRT1145')\n       CALL GREEN('   $P PRT11452')\n       Call GREEN(' - after printers have drained, enter:')\n       CALL GREEN('   C FSS1145')\n       CALL GREEN('   C FSS11452')\n       Call GREEN(' - when JES2 \"All available functions complete\":')\n       Call GREEN('   $P JES2')\n       Call GREEN('   Z EOD')\n       End\n    Else Do\n       Call GREEN('-  Shutdown complete, ready for')\n       Call GREEN('   Z EOD')\n       End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSACTV": {"ttr": 9995, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\\x00\\x01\\x03\\x15o\\x01\\x03\"\\x0f\\x101\\x00R\\x00\\x1d\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2003-06-05T00:00:00", "modifydate": "2003-08-08T10:31:00", "lines": 82, "newlines": 29, "modlines": 0, "user": "SVM"}, "text": "/* REXX --------- Check if tast/job is active: -------------\n|                       TSO environment\n|\n| 08/08/03 SVM Added bypass tso status if under SUB=MSTR\n| 06/06/03 SVM Added TSO STATUS for old SYSACTV\n|          that extracted info from CSCBs.\n|\n| Called by SYSGETL exec (and others) to check if taskname is running\n|        Uses TSO STATUS jobname command output.\n|\n| Input parm:\n|        taskname - name to look for in the active task list\n|\n| Output:\n|        '0'   - task/job not found\n|        '1'   - task/job is executing, but JOBID not available\n|        jobid - task/job found executing\n|\n| System control blocks fields (ref: MVS Data Areas):\n|  cvtptr   = 16  addr of CVT pointer\n|  cvtmser  = 148 CVT offset of MASTER SCHEDULER RESIDENT DATA AREA\n|                 ptr). AREA starts with the pointer to CSCB chain\n|  chkey    = 8   offset of JOBNAME or STC Id or TSO User in CSCB\n|  chcls    = 16  offset of JOBNAME or STC or TSO proc name in CSCB\n|  chasid   = 30  offset of ASID of JOB/STC in CSCB\n|  chprocsn = 32  offset of PROCSTEP in CSCB\n|  chstep   = 64  offset of STEPNAME in CSCB, batch JOB only\n|  chcscbid = 216 offset of 'CSCB' acronym in CSCB\n|\n*/\n#p = 'SYSACTV:'\nArg taskname\ntaskname = \"LEFT\"(taskname,8,' ')\n\n/* Get and return JES jobid using TSO STATUS:                        */\n/* Check if this task runs under JES (or MSTR)                       */\n ascb = ptr(548)                             /* X'224'               */\n jsab = ptr(ptr(ascb + 336) + 168)           /* ASCB -> ASSB -> JSAB */\n If stg(jsab,4) = 'JSAB' Then Do\n    Call outtrap 'STEM.'\n    Address 'TSO' 'STATUS' taskname\n    Call outtrap 'OFF'\n    num = ''\n    Do a = stem.0 By -1 to 1 Until(num <> '')\n       Parse Var stem.a . 'JOB ' id '('num')' ex .\n       End\n    If num <> '' Then Do\n       Say #p \"LEFT\"(id,8) \"LEFT\"(num,8) ex\n       Return(num)\n       End\n    Else Do\n       Say #p \"LEFT\"(taskname,8) '- TSO STATUS returned no jobid'\n       Do a = stem.0 By -1 to 1\n          Say #p stem.a\n          End\n       End\n    End\n\n /* If not found, search CSCB chain */\n cscbptr=ptr(ptr(148+ptr(16)))               /* CVT -> CSCB chain    */\n Do WHILE(cscbptr <> 0)\n    nextptr = ptr(cscbptr)\n    /* Say \"D2X\"(cscbptr,8) \"D2X\"(nextptr,8) STG(cscbptr+8,224) */\n    If stg(cscbptr+216,4) <> 'CSCB' Then Leave\n    jobname = stg(cscbptr+16,8)\n    If jobname = taskname Then Do\n       /* If taskname = 'SDSF' Then Say STG(cscbptr,100) */\n       Say #p \"LEFT\"(taskname,8) '- CSCB found'\n       Return(1)\n       End\n    cscbptr = nextptr\n    End\n\n /* No jobs found: Exit. Message (if any) will be removed by system */\n Return(0)\n\n/*-------------------------------------------------------------------*/\nPTR:\nReturn c2d(storage(d2x(Arg(1)),4))     /* Return decimal pointer     */\n/*-------------------------------------------------------------------*/\nSTG:\nReturn storage(d2x(Arg(1)),Arg(2))     /* Return storage pointed     */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSCNTL": {"ttr": 8970, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\r\\x00\\x00\\x01\\x03\\x04\\x1f\\x01\\x03!\\x8f\\x11\\x13\\x03\\x14\\x01\\xf7\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "02.13", "flags": 0, "createdate": "2003-02-10T00:00:00", "modifydate": "2003-08-06T11:13:00", "lines": 788, "newlines": 503, "modlines": 0, "user": "SVM"}, "text": "/* REXX System Operator functions ---- run in TSO environment -------\n|\n| 07/31/03 SVM Added TIME to Console command message\n| 06/30/03 SVM Added STOP_REMAINING, STOP for HTTPD, OPS\n|          Changed $PJES2 to authorized request.\n| 06/10/03 SVM Added STOP segments for JES2 (S CHKTASK,..,SUB=MSTR ?)\n| 06/03/03 SVM Added STOP segments for CICS* and DBSRV*\n|          Added CHECK segment for TCPIP\n| 05/23/03 SVM Added date & time to \"Execution started\"\n| 05/05/03 SVM Replaced FWAIT by L_FWT\n| 05/05/03 SVM Check if active by calling SYSACTV. WTO message\n|          if task is not active\n| 04/24/03 DEBS397 Added RIO\n| 02/25/03 SVM Added SYSGETL call to get command response\n|          from SYSLOG if #CONS cannot get it.\n|          Renamed all variables to #... not to mix with user's vars.\n| 02/14/03 SVM Used just writtem IRX@MGCR in REPLYIT\n| 02/10/03 SVM Re-created for Operator automation\n|          Proc=chktask, pgm=syscntl\n| 11/20/02 SVM Created\n|\n| Runned by CHKTASK started task (SYS1.COMMON.PROCLIB)\n|        Components involved:\n|        1) CHKTASK - JCL proc for authorised started task\n|        2) SYSCNTL - REXX program you are looking at\n|        3) Function REXX code that is defined as REXXPARM DD\n|           and executed as a part of SYSCNTL.\n|        4) IRXFLOC - REXX function package that includes:\n|           L_WTO, L_DOM, L_FWT\n|        5) Authorised load module IRX@MGCR.\n|        6) External execs: AAPWX, AAINSD, SYSGETL.\n|\n| Directions:\n|        1) This program must be called by an authorised\n|           JCL proc. The proc must be authorized in RACF to issue\n|           all console commands (Modify, Stop, Cancel, Reply)\n|           and CICS console conmmands.\n|        2) Usually you do not modify this program. System specific\n|           function code must be written in REXX and placed into a\n|           PDS member defined as a REXXPARM DD statement.\n|           Currently see members in SYS1.REXX.CNTL.\n|           Member name is &OPTION.&SYSNAME\n|           &OPTION = function name, &SYSNAME = partition name.\n|           Example: SHUTPROD, CHKPROD, SHUTTEST.\n|           This code will be included and executed as a part of\n|           this program. Must be written in REXX,\n|           some restrictions apply.\n|        3) The function code can use subroutines included below\n|           and/or available REXX builtin functions.\n|           This program uses functions included to IRXFLOC pack\n|           originally coming from CBT file 386.\n|           Some functions were modified and others added to the pack.\n|           IRXFLOC load module must be placed in a load library and\n|           that must be defined as a STEPLIB or JOBLIB.\n|           See existing code as an examples for PROD and TEST.\n|        4) Stop sequences for known tasks are defined in STOP\n|           subroutine below.\n|           To add a new stop task code, if it is not just\n|           \"P taskname\", that is a default,\n|           someone must add a \"WHEN task=\" segment to STOP subroutine\n|           below that defines console command(s) to stop the task.\n|        5) Check sequence for known tasks are defined in CHECK\n|           subroutine below.\n|           To add a check for a new task, if it is not just search\n|           the task in the active task list (that is default),\n|           one must add a \"WHEN task =\" segment to CHECK subroutine.\n|        6) To reply outstanding console requests use REPLYIT.\n|           REPLYIT uses the value of \"#request\" variable\n|           that must be set by the following REXX command:\n|              Parse #CONS('D R,L,CN=MASTER') With #rc #request\n|           before calling REPLYIT.\n|           REPLYIT can work in two alternative ways:\n|           1) Use IRX@MGCR external program that must run authorised.\n|           This means it must be palced to\n|           a LINKLIST library and included to the authpgm list\n|           in IKJTSO00 member in SYS1.**.PARMLIB.\n|           2) If first method is not available, uncomment job\n|           submit statements in REPLYIT to start a batch job\n|           that would execute REPLY commands.\n|\n| PARM = 'system,parm' will be parsed and available for your code\n|        as variables \"#system\" and \"#parm\". Parm is optional.\n|\n| Externals:\n|        Load: L_WTO, L_DOM, L_FWT, IRX@MGCR\n|        Exec: INSD, PWX, SYSGETL, SYSACTV\n|\n*/\n/*--------------------------------------------------------------------\n| Set constants and init variables:\n*/\n SIGNAL ON NOVALUE\n Arg #system ',' #parm           /* optional #parm passed to REXXPARM */\n #simulate = 0                              /* 1=simulate, 0=real     */\n                                         /* can be reset by REXXPARM  */\n #wait = '3s'                               /* wait between commands  */\n #final_wait = '3s'                         /* wait before cleanup    */\n #sep = '|'                                 /* Line separator         */\n #p = #system':'                            /* optional message prefix*/\n #err.0  = '- Normal end'                   /* TSO CONSOLE codes      */\n #err.4  = '- No data returned'             /* TSO CONSOLE codes      */\n #err.8  = '- Empty command'                /* TSO CONSOLE codes      */\n #err.20 = '- Console deactivation error'   /* TSO CONSOLE codes      */\n #err.36 = '- Console authority invalid'    /* TSO CONSOLE codes      */\n #err.40 = '- Console activation error'     /* TSO CONSOLE codes      */\n #start = 1                                 /* flag 1st call to #CONS */\n # = 0                                      /* num of WHT msg on cons */\n ## = 0                                     /* num of RED msg on cons */\n\n Say #p 'Execution started:',\n    \"DATE\"('W')',' \"DATE\"() \"TIME\"()\n Say #p 'Parameters passed:'\n Say '  #system ='#system\n Say '  #parm   ='#parm\n\n /*--------------------------------------------------------------------\n |  Check system name and set active task list\n */\n\n If \"MVSVAR\"('SYSNAME') <> #system Then Do\n    Call WHITE('System is not' #system', processing terminated')\n    Signal #FIN\n    End\n\n #tasklist = ACTIVE()\n #tsolist  = TACTIVE()\n\n /*===================================================================\n |  User's code starts here: (define rexx code as ddname REXXPARM)\n | ===================================================================\n */\n\n INTERPRET(INSD('REXXPARM'))\n\n /*===================================================================\n |  User's code ends here. No unauthorised changes below this line!\n | ===================================================================\n |  Wait before final processing:\n */\n #FIN:\n #string = ''\n Do #i = 1 to #\n    #string = #string||#x.#i\n    End\n If #final_wait <> '' & #string <> '' Then\n    Say #p 'Final wait' #final_wait\n    #reply = L_FWT(#final_wait)\n\n /*-------------------------------------------------------------------\n |  Optional: remove WHITE messages from console, if any:\n */\n Do #i = 1 to #\n    Call DOM(#i)\n    End\n If #string <> '' Then\n    Say #p 'Message(s) removed'\n\n Say #p 'Execution Complete' \"TIME\"()\n EXIT\n\n /*===================================================================\n |  S U B R O U T I N E S\n |====================================================================\n */\n\n /*-------------------------------------------------------------------\n |  Check task status: Arg = task name  returns 1 if OK, else 0\n */\n CHECK:\n Arg #task\n #task = \"STRIP\"(#task)\n /* #taskname = ' '||#task||' '                 */\n #notact = #p #task 'is not running!'\n /* If (\"POS\"(#taskname,#tasklist) = 0) Then Do */\n If SYSACTV(#task) = '0' Then Do\n    Call RED(#notact)\n    Return(0)\n    End\n /* Additional processing for specific tasks: */\n Select\n    When #task = 'CCITCP' Then Do\n       /* display all devices that are not READY */\n       #cmd = 'D TCPIP,,N,DEV'\n       #txt  = 'DEVSTATUS: '\n       #txt1 = 'DEVSTATUS: READY'\n       Parse Value #CONS(#cmd) With #rc #reply\n       Call DISP_REPLY(#reply)\n       #i  = \"POS\"(#txt,#reply)\n       #i1 = \"POS\"(#txt1,#reply)\n       #notready = 0\n       Do While(#i > 0)\n          If #i <> #i1 Then Do\n             Parse Var #reply 'DEVNAME: ' #dev ' ' .\n             Parse Var #reply 'DEVNUM: '  #devnum (#sep) .\n             Parse Var #reply (#txt)   #devsts (#sep) .\n             #msg = #p 'TCPIP: DEVNAME:' #dev,\n                ||', DEVNUM:' #devnum,\n                ||', DEVSTATUS:' #devsts\n             Call RED(#msg)\n             #notready = 1\n             End\n          Parse Var #reply (#txt1) #reply\n          #i  = \"POS\"(#txt,#reply)\n          #i1 = \"POS\"(#txt1,#reply)\n          End\n       If #notready Then Return(0)\n       End\n    When #task = 'DBSRVD' ,\n       | #task = 'DBSRVP1',\n       | #task = 'DBSRVP2',\n       | #task = 'DBSRVQ' ,\n       | #task = 'DBSRVT1',\n       | #task = 'DBSRVT2' Then Do\n       /* Step must have pre-allocated ddname (same as task name) */\n       /* See CHKTASK jcl proc as an example                      */\n       #msg = #p #task 'is running but not operational!'\n       #txt = 'Errortext'\n       #reply = READDDN(#task)\n       Call DISP_REPLY(#reply)\n       If #reply = '' | \"POS\"(#txt,#reply) > 0 Then Do\n          Call RED(#msg)\n          Return(0)\n          End\n       End\n    When #task = 'ROS60',\n       | #task = 'ROS60DIS' Then Do\n       /* Check if Roscoe responds */\n       #cmd = 'F' #task||',STATUS'\n       Parse Value #CONS(#cmd) With #rc #reply\n       Call DISP_REPLY(#reply)\n       #msg = #p #task 'is not responding'\n       #txt = 'ROS131I'\n       If (\"POS\"(#txt,#reply) = 0 & #rc = 0) Then Do\n          Call RED(#msg)\n          Return(0)\n          End\n       End\n    When #task = 'DATAP390',\n       | #task = 'DATAQ390',\n       | #task = 'DATAD390',\n       | #task = 'DATAT390' Then Do\n       /* Check if database responds and in Multi-user mode */\n       #cmd = 'f' #task',comm status dest=console'\n       #msg = #p #task 'is not running in multi-user mode!'\n       #txt = 'MULTI-USER'\n       Parse Value #CONS(#cmd) With #rc #reply\n       Call DISP_REPLY(#reply)\n       If (\"POS\"(#txt,#reply) = 0 & #rc = 0) Then Do\n          Call RED(#msg)\n          Return(0)\n          End\n       End\n    When #task = 'CICSP390',\n       | #task = 'CICSQ390',\n       | #task = 'CICSD390',\n       | #task = 'CICST390' Then Do\n       /* Check if CICS responds */\n       #cmd = 'f' #task',CEMT I TAS'\n       #msg = #p #task 'is not responding'\n       #txt = 'CHKTASK'\n       Parse Value #CONS(#cmd) With #rc #reply\n       Call DISP_REPLY(#reply)\n       If (\"POS\"(#txt,#reply) = 0 & #rc = 0) Then Do\n          Call RED(#msg)\n          Return(0)\n          End\n       End\n    Otherwise Nop\n    End\n Return(1)\n\n/*--------------------------------------------------------------------\n| Stop remaining active tasks\n| Optional parm - list of tasks you do not want to be stopped yet.\n| Will attempt to stop whatever is in #tasklist active and not\n| in skip_list parsed from parm. Works in an arbitrary order.\n*/\n STOP_REMAINING:\n If #simulate Then Return(0)\n Call Active /* get fresh #tasklist */\n Arg #skip_list\n #skip_list = ' '||\"TRANSLATE\"(#skip_list,' ',',')||' ',\n    ||\"SYSVAR\"('SYSPROC')||' '\n Say #p 'Stopping remaining tasks...'\n Say #p 'Skip_list:' #skip_list\n #n = \"WORDS\"(#tasklist)\n Do #i = 1 To #n\n    #task_to_stop = ' '||\"WORD\"(#tasklist,#i)||' '\n    If \"POS\"(#task_to_stop,#skip_list) = 0 Then\n       Call STOP(#task_to_stop)\n    End\n Return(1)\n\n /*-------------------------------------------------------------------\n |  Issue STOP command for task specified: Arg = task name\n |  (here you can instruct the program how to stop specific tasks)\n */\n STOP:\n Arg #task\n #task = \"STRIP\"(#task)\n #chkactive = 1\n ##wait = #wait                         /* std wait by default */\n Select\n\n    When #task = 'CICSP390',\n       | #task = 'CICSQ390',\n       | #task = 'CICSD390',\n       | #task = 'CICST390' Then Do\n       #cmd = 'F' #task',CEMT SET TERM ALL OUTSERVICE',\n          || #sep'F' #task',DBOC SHUTDOWN',\n          || #sep'F' #task',CEMT P SHUT'\n       ##wait = '12s'                   /* special wait         */\n       End\n\n    When #task = 'DBSRVD' Then\n       #cmd = 'S JOB,N=DBSRVEJD'\n    When #task = 'DBSRVP1' Then\n       #cmd = 'S JOB,N=DBSRVEP1'\n    When #task = 'DBSRVP2' Then\n       #cmd = 'S JOB,N=DBSRVEP2'\n    When #task = 'DBSRVQ'  Then\n       #cmd = 'S JOB,N=DBSRVEJQ'\n    When #task = 'DBSRVT1' Then\n       #cmd = 'S JOB,N=DBSRVET1'\n    When #task = 'DBSRVT2' Then\n       #cmd = 'S JOB,N=DBSRVET2'\n\n    When #task = 'HTTPD'    Then #cmd = 'C HTTPD'\n    When #task = 'OPS'      Then #cmd = 'P OPSS'\n    When #task = 'ROS60'    Then #cmd = 'F ROS60,SHUTDOWN,NOW'\n    When #task = 'ROS60DIS' Then #cmd = 'F ROS60DIS,SHUTDOWN,NOW'\n    When #task = 'RIO'      then #cmd = 'F RIO,SHUTDOWN'\n    When #task = 'TMVSMSTR' Then #cmd = 'F TMVSMSTR,QU'\n /* When #task = 'TMVSLFS'  Then #cmd = 'F TMVSLFS,QU' */\n /* When #task = 'TMONMVS'  Then #cmd = 'F TMONMVS,QU' */\n    When #task = 'PRT'      Then Do\n       #cmd = 'S STOPPRT'\n       #chkactive = 0\n       End\n    When #task = 'AOP'      Then Do\n       #cmd = 'S AOPSTOP'\n       #chkactive = 0\n       End\n    When #task = 'LOGON1'   Then Do\n       #cmd = '$P LOGON1'\n       #chkactive = 0\n       End\n    When #task = 'LINE1'    Then Do\n       #cmd = '$P LINE1'\n       #chkactive = 0\n       End\n    When #task = 'CA7ONL'   Then DO\n       #cmd = 'F CA7ONL,/LOGON MASTER',\n          || #sep'F CA7ONL,/SHUTDOWN,Z3',\n          || #sep'F CA7ONL,/SHUTDOWN,Z3'\n       End\n    When #task = 'CAD4PROC' Then #cmd = 'F CAD4PROC,SHUTDOWN'\n    When #task = 'CA7ICOM'  Then #cmd = 'F CA7ICOM,STOP'\n    When #task = 'CA7ICOMT' Then #cmd = 'F CA7ICOMT,STOP'\n    When #task = 'CA11'     Then #cmd = '++SHUTDOWN ALL'\n    When #task = 'CA7ONLT'  Then Do\n       #cmd = 'F CA7ONLT,/LOGON MASTER',\n          || #sep'F CA7ONLT,/SHUTDOWN,Z3',\n          || #sep'F CA7ONLT,/SHUTDOWN,Z3'\n       End\n    When #task = 'CA7ONL'   Then Do\n       #cmd = 'F CA7ONL,/LOGON MASTER',\n          || #sep'F CA7ONL,/SHUTDOWN,Z3',\n          || #sep'F CA7ONL,/SHUTDOWN,Z3'\n       End\n    When #task = 'SVTS'     Then Do\n       #cmd = 'S SVTSVOFF',\n          || #sep'P SVTS'\n       End\n    When #task = 'CTS'      Then Do\n       #cmd = 'F CTS,STOP TLMS',\n          || #sep'P CTS'\n       End\n    When #task = 'CCITCP'   Then #cmd = 'C CCITCP'\n    When #task = 'CCITCPGW' Then #cmd = 'C CCITCPGW'\n    When #task = 'LOGROUTE' Then #cmd = 'P LOGROUTE.L'\n    When #task = 'ASCH'     Then #cmd = 'C ASCH'\n    When #task = 'APPC'     Then #cmd = 'C APPC'\n    When #task = 'RACF'     Then Do\n       #cmd = '#STOP'\n       #chkactive = 0\n       End\n    When #task = 'DLF'      Then Do\n       #cmd = 'F DLF,MODE=Q',\n          || #sep'P DLF'\n       End\n    When #task = 'CRON6'    Then #cmd = 'C CRON6'\n    When #task = 'SYSLOGD5' Then #cmd = 'C SYSLOGD5'\n    When #task = 'BPXOINIT' Then Do\n       #cmd = 'F BPXOINIT,SHUTDOWN=FORKINIT'\n       #chkactive = 0\n       End\n    When #task = 'VTAM'     Then #cmd = 'Z NET,QUICK'\n    When #task = 'FFST'     Then Do\n       #cmd = 'P FFST'\n       #task = 'EPWFFST'\n       End\n    When #task = 'JES2' Then Do\n       /* special processing for JES2 stop command: */\n       #cmd = '$PJES2'\n       Say\n       If #simulate Then Do\n          Call L_WTO(#cmd)\n          Say #p 'Simulate:' #cmd\n          End\n       Else Do\n          Call L_FWT(#wait)\n          /* try to wait until tasks end: */\n          Call ACTIVE\n          If \"WORDS\"(#tasklist) > 2 Then Do\n             Call DSP_ACTIVE(#tasklist)\n             #emsg = #p 'Tasks active - $PJES2 command skipped'\n             Call GREEN(#emsg)\n             End\n          Else Do\n             #cmd = '$PJES2'\n             Say #p 'System command issued:' #cmd\n             ADDRESS TSO \"CALL *(IRX@MGCR) '\"#cmd\"'\"\n             End\n          End\n       #cmd = ''\n       #chkactive = 0\n       End\n    Otherwise                   #cmd = 'P' #task\n    End\n\n If #chkactive Then Do\n    /* #taskname = ' '||#task||' '               */\n    /* If \"POS\"(#taskname,#tasklist) = 0 Then Do */\n    Say\n    If SYSACTV(#task) = '0' Then Do\n       #emsg = #p #task 'is not running - command(s) skipped'\n    /* Say #emsg */\n       Call GREEN(#emsg)\n       Return\n       End\n    End\n Do While(#cmd <> '')\n    Parse Value #cmd With #command (#sep) #cmd\n    Parse Value #CONS(#command) With #rc #reply\n    Call DISP_REPLY(#reply)\n    Call L_FWT(##wait)\n    End\n Return\n\n /*-------------------------------------------------------------------\n |  Display parm=#tasklist or #tsolist on console.\n |  Parm must be a list of words separated by blanks.\n |  Show words 6 in a row\n */\n DSP_ACTIVE: PROCEDURE EXPOSE WHITE #p # #x.\n Arg #parm\n #row = 6                              /* how many tasks in a row   */\n #n = \"WORDS\"(#parm)\n #line = ''\n #j=0\n Do #i = 1 to #n\n    #task = \"WORD\"(#parm,#i)\n    #line = #line || \"LEFT\"(#task,9)\n    #j = #j + 1\n    If #j = #row Then Do\n       Call WHITE(#line)\n       #j = 0\n       #line = ''\n       End\n    End\n If #line <> '' Then\n    Call WHITE(#line)\n Return\n\n /*-------------------------------------------------------------------\n |  Display console message and get response.\n |  Arg = message, returns response\n */\n WTOR: PROCEDURE EXPOSE #p\n Parse Arg #msg\n Say #p 'Request: ' #msg\n #response = L_WTO(#msg,'R')\n Say #p 'Response:' #response\n Return(#response)\n\n /*-------------------------------------------------------------------\n |  Display console message in green\n |  Arg = message, returns msgid (not used)\n */\n GREEN: PROCEDURE EXPOSE #p\n Parse Arg #msg\n Say #p 'Grn msg: ' #msg\n Call L_WTO(#msg)\n Return\n\n /*-------------------------------------------------------------------\n |  Display console message in red:\n |  Arg = message, returns msgid (used by L_DOM)\n */\n WHITE: PROCEDURE EXPOSE # #x. #p\n Parse Arg #msg\n Say #p 'Wht msg: ' #msg\n # = # + 1\n #x.# = L_WTO(#msg,'b')\n Return(#)\n\n /*-------------------------------------------------------------------\n |  Display console message in red:\n |  Arg = message, returns msgid (used by L_DOM)\n */\n RED: PROCEDURE EXPOSE ## ##x. #p\n Parse Arg #msg\n Say #p 'Red msg: ' #msg\n ## = ## + 1\n ##x.## = L_WTO(#msg,'a')\n Return(##)\n\n /*-------------------------------------------------------------------\n |  Set active task list using reply from 'D J,L'\n |  Issue D,j,L and store active task list in a returned string\n */\n ACTIVE:\n #tasklist = ' '\n #cmd_a = 'D J,L'\n #oldsim = #simulate\n #simulate = 0\n Parse Value #CONS(#cmd_a) With #rc #rep\n #simulate = #oldsim\n Parse Value #rep with (#sep) #string\n #i=0\n Do While(#string <> '')\n    Parse Var #string #line (#sep) #string\n    #i = #i + 1\n    If #i > 3 Then Do\n       Parse Value #line With 1 #t1 9 . 36 #t2 44 .\n       #tasklist = #tasklist \"STRIP\"(#t1) \"STRIP\"(#t2)\n       End\n    Say #line\n    End\n #tasklist = #tasklist || ' '\n Return(#tasklist)\n\n /*-------------------------------------------------------------------\n |  Set active TSO users list using reply from 'D TS,L'\n |  Issue D,TS,L and store active task list in a returned string\n */\n TACTIVE:\n #tsolist = ' '\n #cmd_a = 'D TS,L'\n #oldsim = #simulate\n #simulate = 0\n Parse Value #CONS(#cmd_a) With #rc #rep\n #simulate = #oldsim\n Parse Value #rep with (#sep) #string\n #i=0\n Do While(#string <> '')\n    Parse Var #string #line (#sep) #string\n    #i = #i + 1\n    If #i > 3 Then Do\n       Do #j = 1 By 2 To 7\n          #tsou = \"WORD\"(#line,#j)\n          If #tsou <> '' Then\n             #tsolist = #tsolist #tsou\n          End\n       End\n    Say #line\n    End\n #tsolist = #tsolist || ' '\n Return(#tsolist)\n\n /*-------------------------------------------------------------------\n |  Display reply splitted to separate lines:\n |  General pupose: display any reply returned by #CONS\n |  Arg = reply #string\n */\n DISP_REPLY: PROCEDURE EXPOSE #sep\n /* Display response line by line: */\n Parse Arg (#sep) #string\n Do While(#string <> '')\n    Parse Var #string #line (#sep) #string\n    Say #line\n    End\n Return\n\n /*-------------------------------------------------------------------\n |  Remove RED message from console:\n |  Arg = ## of msgid, msgid = ##x.##\n */\n DOMR: PROCEDURE EXPOSE ##x.\n Parse Arg ##\n if ##x.## <> '' Then Do\n    Call L_DOM(##x.##)\n    ##x.## = ''\n    End\n Return\n\n /*-------------------------------------------------------------------\n |  Remove WHITE message from console:\n |  Arg = # of msgid, msgid = #x.#\n */\n DOM: PROCEDURE EXPOSE #x.\n Parse Arg #\n if #x.# <> '' Then Do\n    Call L_DOM(#x.#)\n    #x.# = ''\n    End\n Return\n\n /*-------------------------------------------------------------------\n |  Issue console command and return reply from system:\n |  as 'rc |line 1|line 2|...|last line'\n |  Arg = connamd\n |  Returns string containing reply lines separated by #sep character\n |  When #simulate = 1 display the command, not issue.\n */\n #CONS:\n\n #prefix = #p 'CONS:'                  /* message prefix            */\n #cart=\"TIME\"('S')                     /* Cmd cart code             */\n #rc_ok = 0                            /* No error rc               */\n #rc_nocons = 20                       /* Activation error          */\n #rc_nodata = 4                        /* Empty/No reply            */\n #rc_nocmd  = 8                        /* Empty/No command          */\n #wait1 = 1                            /* seconds, GETMSG wait int  */\n /* each GETMSG takes at least twice as much time as wait (seconds) */\n\n Arg #command\n\n Say\n If #simulate Then Do\n    /* simulate console commands: */\n    call L_WTO(#command)\n    Say #p 'Simulate:' #command\n    Return(0)\n    End\n\n /* Execute comand for real: */\n Address TSO\n If \"LENGTH\"(#command) = 0 Then Do\n    If #start Then Do\n       /* indicate error call */\n       Say #prefix 'No/empty command requested'\n       Return(#rc_nocmd)\n       End\n    Else Do\n       /* close console and reset #start */\n       \"CONSPROF SOLDISPLAY(\"#mdisp\")\"    /* restore from mdisp     */\n       \"CONSPROF UNSOLDISPLAY(\"#mdis1\")\"  /* restore from mdis1     */\n       \"CONSOLE DEACTIVATE\"\n       If RC <> 0 Then\n          Say #prefix 'Console deactivation RC =' RC\n       Else\n          #start = 0                      /* drop \"1st call\" flag   */\n       Return(RC)\n       End\n    End\n Else\n    Say #prefix \"TIME\"() \"Requested command:\" #command\n\n If #start Then Do\n    /* activate console: */\n    #mdisp = SYSVAR(\"SOLDISP\")         /* save SOLDISP              */\n    \"CONSPROF SOLDISPLAY(NO)\"          /* reset to get solicited    */\n    #mdis1 = SYSVAR(\"UNSDISP\")         /* save UNSDISP              */\n    \"CONSPROF UNSOLDISPLAY(NO)\"        /* reset to get unsolicited  */\n    \"CONSOLE ACTIVATE\"\n    If RC <> 0 Then Do\n       /*---> Check if console is not available - only at 1st call */\n       #msg = #p #err.RC 'for' #command\n       Call L_WTO(#msg)\n       Say #msg\n       Signal #FIN\n       End\n    /*<--- End of console availability check */\n    #start = 0\n    Say #prefix 'Console activated'\n    #ret = RC\n    End\n\n \"CONSOLE SYSCMD(\"#command\") CART(\"#cart\")\"\n If RC <> 0 Then\n    Say #prefix 'Console Syscmd RC =' RC\n #ret = #rc_ok' '\n #n = 0\n Do #attempt = 1 to 20\n    #getcode = GETMSG('#conmsg.','EITHER',,,#wait1)\n    /*Say #prefix 'Attempt='#attempt 'Getcode='#getcode*/\n    If #getcode = 0 Then Do\n       #getcode1 = #getcode\n       Do #i = 1 To #conmsg.0\n          #conmsg.#i = \"STRIP\"(#conmsg.#i)\n          #ret = #ret||#sep||#conmsg.#i\n          #n = #n + 1\n          End\n       End\n    Else Do\n       If #attempt = 1 Then Do\n          #getcode1 = #getcode\n          #ret = #rc_nodata\n          End\n       Else LEAVE\n       End\n    End\n Say #prefix 'Getcode =' #getcode1,\n     ||',' #n 'lines returned from console in' #attempt,\n     'attempts'\n If #n = 0 Then\n    #ret = SYSGETL(#command)\n\n Return(#ret)\n\n /*-------------------------------------------------------------------\n |  Read from ddn to string:\n |  Arg: ddname to read from\n |  returns a string containing stripped records\n |  separated by #sep character\n */\n READDDN: PROCEDURE Expose #sep #p\n Parse Arg #ifile\n Say\n \"EXECIO * DISKR\" #ifile \"(STEM #inrec. FINIS\"\n If RC > 0 Then Do\n    Say #p 'Error - ddname' #ifile 'read error'\n    Return('')\n    End\n #string = \"STRIP\"(#inrec.1)\n Do i = 2 to #inrec.0\n    #string = #string||#sep||\"STRIP\"(#inrec.i)\n    End\n Say #p ' -' #inrec.0 'records read from' #ifile\n Return(#string)\n\n /*-------------------------------------------------------------------\n |  Reply to outstanding request:\n |  Arg = #msgid #reply\n |  msgid = system request message identitier, like IEC0128A,\n |  #reply = what to reply to this request if outstanding\n |  Before calling REPLYIT, create string REQUEST containing\n |  reply to D R,R,CN=MASTER. Use #CONS to create REQUEST:\n |     #cmd = 'D R,R,CN=MASTER'\n |     Parse Value #CONS(#cmd) With #rc #request\n */\n REPLYIT:\n Arg #msgid #msgrep\n #msgpos = \"POS\"(#msgid,#request)\n If #msgpos > 0 Then Do\n    #msgpos = #msgpos - 5\n    #msgnum = \"SUBSTR\"(#request,#msgpos,4)\n    #cmd = 'R' #msgnum||\",\"||#msgrep\n\n    If #simulate Then\n       Call GREEN(#cmd)\n    Else Do\n/*=== primary method of replying the request: =====================*/\n/*     Call authorised program SYS3.LINKLIB(IRX@MGCR):             */\n/*     (this is an example of how to use authorised prog in REXX   */\n/*     Cannot use #CONS because it has not AUTH=MASTER.            */\n/*     MGCR macro can send reply by name of master console         */\n/*     but needs to run under key=zero and mode=sup                */\n/*=================================================================*/\n       ADDRESS TSO \"CALL *(IRX@MGCR) '\"#cmd\"'\"\n/* === alternative simple method: submit a job: ===================*/\n/*     #par = '//CHKTASK1 JOB (3,290,0744,0),CPRS399,CLASS=S,',    */\n/*        ||'MSGCLASS=Y',                                          */\n/*        ||'|// EXEC PGM=IEFBR14',                                */\n/*        ||\"|// COMMAND '\"#cmd\"'\",                                */\n/*        ||'|//'                                                  */\n/*     If #simulate Then #outfile = 'SYSTSPRT'                     */\n/*     Else              #outfile = 'SUBMIT'                       */\n/*     Call PWX(#outfile #par)                                   */\n/*=================================================================*/\n       Say #p \"Reply command issued:\" #cmd\n       End\n    End\n Else\n    Say #p #msgid 'is not outstanding. Reply ignored'\n Return\n\n/*-------------------------------------------------------------------\n|| Terminate application when Unitialized variable encountered\n*/\n  NOVALUE:\n    SIGNAL OFF NOVALUE\n    SAY #p\" - Uninitialized variable used:\"\n    SAY \"   \"sigl\":\" \"SOURCELINE\"(sigl)\n  SIGNAL #FIN\n/*----------------------  End of program  --------------------------*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSGETL": {"ttr": 7441, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x01\\x03\\x05\\x9f\\x01\\x03\\x17_\\x14\\x01\\x00v\\x00I\\x00\\x00\\xe2\\xe5\\xd4@@@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2003-02-28T00:00:00", "modifydate": "2003-06-24T14:01:00", "lines": 118, "newlines": 73, "modlines": 0, "user": "SVM"}, "text": "/* REXX --------- Read task response from SYSLOG -------------\n|\n| 06/24/03 SVM Added SDSF check for running under sub=MSTR\n| 06/05/03 SVM Added search SDSF output by taskname\n| 05/05/03 SVM Added check if SDSF is active (good for shutdown)\n| 02/25/03 SVM Created\n|\n| Called by SYSCNTL exec to read the response for console command\n|        issued by SYSCNTL in case when GETMSG does not work.\n|        Uses SDSF batch call. See security settings below.\n|\n| Input parm:\n|        command issued to console\n|        Example: 'F ROSCOE,STATUSX'\n|\n| Output:\n|        string = 'rc |line1|line2|...|linen'\n|        rc = 0 if at least 1 line was found\n|        otherwise rc = 4\n|        each line or command response is separated by '|'.\n|\n| SDSF security setting example:\n|                To set a proper authorisation you might need a\n|                ISFPRM00 member in system PARMLIB.\n|                It must define a user group that has authority\n|                to use SDSF in batch, for example:\n|                   GROUP NAME(ISFBATC2),    /* define group       */\n|                   ILPROC(BATCH),           /* NTBL name          */\n|                   IUID(SYSPRGS),           /* NTBL name          */\n|                   AUTH(I,O,H,DA,ST,SE,PREF,LOG), /* funct allowed*/\n|                   CMDLEV(2),               /* command level      */\n|                   OWNER(USERID)            /* deafult owner      */\n|\n|                and definition for included logon procedures:\n|                   NTBL NAME(SYSPRGS)\n|                     NTBLENT STRING(CHKTASK),OFFSET(1)\n|                     ... other sysprogs ...\n|                   NTBL NAME(BATCH)         /* referred by GROUP  */\n|                     NTBLENT STRING(AFD)    /* for PGM=ISFAFD     */\n|                     NTBLENT STRING(BATCH)  /* for PGM=SDSF       */\n|        Having modified ISFPRM00 issue F SDSF,REFRESH\n|\n|        References:\n|                OS/390 V2R10.0 SDSF Customization and Security\n| Externals:\n|        EXECs: PWX, SYSACTV; LINKs: SDSF\n*/\n Arg sample                            /* Sample command to search   */\n #p = 'SYSGETL:'                       /* message prefix             */\n sdsf = 'SDSF'                         /* name of SDSF started task  */\n sep = '|'                             /* separator (see SYSCNTL     */\n logfile = 'LOGFILE'                   /* ddname for SDSF work file  */\n isfin = 'ISFIN'                       /* ddname for SDSF input file */\n errc = 4                              /* RC if nothing found        */\n par = 'WHO|OWNER|LOG S|PRT FILE '||logfile||'|PRT * 999|PRT CLOSE'\n                                       /* SDSF read SYSLOG commands  */\n sdsfid = SYSACTV(sdsf)\n /* Say #p 'SYSACTV(SDSF)='par */\n If sdsfid = '0' Then Do\n    /* SDSF is not active */\n    Say #p 'SDSF task is not active - cannot read SYSLOG'\n    RETURN(errc)\n    End\n If sdsfid = '1' Then Do\n    /* SDSF jes jobid not available - jes functions not available */\n    Say #p 'SDSF not available - cannot read SYSLOG'\n    RETURN(errc)\n    End\n\n Call PWX(isfin par)\n Address LINK \"SDSF\"\n \"EXECIO * DISKR\" logfile \"(STEM #log. FINIS\"\n Say #p #log.0 'records read from' logfile\n lsample = \"LENGTH\"(sample)\n par = ''\n i0 = 0\n\n /* first try to find by task's jobid: */\n taskname = \"WORD\"(\"TRANSLATE\"(sample,' ',','),2)\n jobidx = SYSACTV(taskname)\n If jobidx <> '0' & jobidx <> '1' Then Do\n    Say #p 'search' jobidx\n    Do i = 1 To #log.0\n       Parse Value #log.i With 38 jobid 46 junk 57 #log1.i\n       If jobid = jobidx Then Do\n          par = par||sep||#log1.i\n          i0 = i0 + 1\n          End\n       End\n    End\n If i0 > 0 Then Signal END\n\n /* else try to find what immediately follows the command: */\n found = 0\n jobid0 = ''\n Do i = #log.0 By -1 To 1\n    found = (sample = \"LEFT\"(#log.i,lsample))\n    If found Then Leave /* last occurence found in line i */\n    End\n If found Then Do\n    Do i = i + 1 To #log.0\n       Parse Value #log.i With 38 jobid 46 junk 57 #log.i\n       If jobid0 = '' Then Do\n          jobid0 = jobid\n          Say #p 'found' jobid0\n          End\n       If jobid = jobid0 Then Do\n          par = par||sep||#log.i\n          i0 = i0 + 1\n          End\n       End\n    End\n\n END:\n If par <> '' Then par = '0' par\n Else par = errc\n Say #p i0 'lines returned from SYSLOG'\n Return(par)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT588/CBT.V500.FILE588.PDS/EXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT588/CBT.V500.FILE588.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}