         TITLE 'MODLISTR - DISPLAY LINKEDIT INFORMATION - DATE/TIME/LEN+
               GTH OF MODULE, AND OTHER LINKEDIT ATTRIBUTES '
***********************************************************************
*                                                                     *
*        M   M OOOOO DDDD  L      III   SSSS TTTTT RRRR               *
*        MM MM O   O D   D L       I   S       T   R   R              *
*        M M M O   O D   D L       I    SSS    T   RRRR               *
*        M   M O   O D   D L       I       S   T   R  R               *
*        M   M OOOOO DDDD  LLLLL  III  SSSS    T   R   R              *
*                                                                     *
*  AUTHOR:      TKMILLE on 05/31/2006                                 *
*  LAST UPDATE: 04/06/2010 by TKMILLE                                 *
*                                                                     *
*  THIS PROGRAM ISSUES THE IEWBIND (BINDER) MACRO TO OBTAIN LINK-EDIT *
*  INFORMATION FOR DISPLAY FOR A PARTICULAR LOAD MODULE MEMBER.       *
*                                                                     *
*  THE ML (MODLIST) EXEC CALLS THIS PROGRAM - TKMILLE 04/10/2006      *
*                                                                     *
*      Examples:  MODLIST modulename                                  *
*                 MODLIST modulename   DUP                            *
*                                                                     *
*      (See Rexx Exec MODLIST for other examples of using the         *
*       MODLIST (ML) exec.)                                           *
*                                                                     *
* SAMPLE DISPLAY:                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*         M   M M   M M   M M   M M   M M   M M   M M   M             *
*         MM MM MM MM MM MM MM MM MM MM MM MM MM MM MM MM             *
*  SYx    M M M M M M M M M M M M M M M M M M M M M M M M       Date  *
*         M   M M   M M   M M   M M   M M   M M   M M   M       Time  *
*         M   M M   M M   M M   M M   M M   M M   M M   M             *
*                                                                     *
*mmmmmmmm Linked on 01/16/2006 (2006.016) at 14:35:52 LENGTH: 00000AFE*
*mmmmmmmm AM:  24 RM:  24 AC: 01 RN RU RF TTR: 00AE1F EPADDR: 00000A09*
*mmmmmmmm VOL/DSN: Z17001 DSN=SYS1.LINKLIB                    ORG: PO *
*mmmmmmmm SSI: 00112987   *** ALIAS NAME FOR MEMBER TTTTTTTT ***      *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*  CHANGE LOG (MOST RECENT CHANGES LISTED FIRST)                      *
*                                                                     *
*  Added support for calling MODLISTR as a subroutine from            *
*  another program.  The first parm is the membername to be           *
*  queried.  The second parm (optional), if included, will cause      *
*  program MODLISTR to return the results in a 100 byte user data     *
*  return area (See RETURN_INFO) in lieu of displaying the            *
*  results in file SYSPRINT.                                          *
*                                                                     *
*  SUPPORTED METHODS TO INVOKE MODLISTR:                              *
*                                                                     *
*  1>    FROM REXX OR CLIST IN TSOE ENVIRONMENT:                      *
*        "ALLOC FI(SYSPRINT) DA(*) REUSE"                             *
*        "ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE"              *
*                                                                     *
*        "CALL 'MODLISTR.LOADLIB(MODLISTR)' '"MEMBERNAME"'"           *
*        MODLISTR_RC  = RC                                            *
*                                                                     *
*  2>    FROM REXX TSOE ENVIRONMENT AS LINKMVS:                       *
*        "ALLOC FI(SYSPRINT) DA(*) REUSE"                             *
*        "ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE"              *
*                                                                     *
*        ADDRESS "LINKMVS" 'MODLISTR MEMBERNAME'                      *
*        MODLISTR_RC  = RC                                            *
*                                                                     *
*  3>    FROM REXX TSOE ENVIRONMENT AND RETURN THE RESULTS IN A       *
*        REXX VARIABLE (SEE WS-MODLISTR-RETURN-AREA FIELD BELOW       *
*        FOR THE VARIABLE STRING FORMAT) AS LINKPGM:                  *
*                                                                     *
*        "ALLOC FI(SYSPRINT) DA(*) REUSE"                             *
*        "ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE"              *
*                                                                     *
*        ADDRESS "LINKPGM" 'MODLISTR MEMBERNAME RETURN_AREA'          *
*        MODLISTR_RC  = RC                                            *
*                                                                     *
*  4>    CALL 'MODLISTR' DIRECTLY AS A BATCH PROGRAM:                 *
*        //STEPX    EXEC PGM=MODLISTR,PARM=MODULENAME                 *
*        //SYSPRINT DD  SYSOUT=*                                      *
*        //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB                       *
*                                                                     *
*  5>    FROM AN APPLICATION PROGRAM CALLING 'MODLISTR' AS A          *
*        SUBROUTINE WITH ONE PARAMETER:                               *
*        //STEPX    EXEC PGM=YOURPGM                                  *
*        //SYSPRINT DD  SYSOUT=*                                      *
*        //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB                       *
*     WHERE YOURPGM DOES...                                           *
*         01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.         *
*         01 WS-MODULE-NAME       PIC X(8).                           *
*         CALL WS-MODLISTR USING WS-MODULE-NAME.                      *
*     (WS-MODULE-NAME MUST BE PADDED WITH TRAILING BLANKS)            *
*     RESULTS ARE WRITTEN TO FILE SYSPRINT                            *
*                                                                     *
*         MODNAME   DS  CL8                                           *
*         CALL MODLISTR,(MODNAME),VL                                  *
*                                                                     *
*  6>    FROM AN APPLICATION PROGRAM CALLING 'MODLISTR' AS A          *
*        SUBROUTINE WITH TWO PARAMETERS:                              *
*        //SYSPRINT DD  SYSOUT=*                                      *
*        //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB                       *
*     where YOURPGM does...                                           *
*         01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.         *
*         01 WS-MODULE-NAME       PIC X(8).                           *
*         01 WS-MODLISTR-RETURN-AREA.                                 *
*            05 WS-RA-MODNAME-LEN PIC S9(4) COMP.                     *
*            05 WS-RA-MODNAME     PIC X(8).                           *
*            05 WS-RA-LK-GR-DATE  PIC X(10).                          *
*            05 WS-RA-LK-JUL-DATE PIC X(8).                           *
*            05 WS-RA-LK-TIME     PIC X(8).                           *
*            05 WS-RA-MODULE-LEN  PIC X(8).                           *
*            05 WS-RA-AMODE       PIC X(3).                           *
*            05 WS-RA-RMODE       PIC X(3).                           *
*            05 WS-RA-APFCD       PIC X(2).                           *
*            05 WS-RA-RENT        PIC X(2).                           *
*            05 WS-RA-REUS        PIC X(2).                           *
*            05 WS-RA-REFR        PIC X(2).                           *
*            05 WS-RA-TTR         PIC X(6).                           *
*            05 WS-RA-EPA         PIC X(8).                           *
*            05 WS-RA-ORG-POE     PIC X(1).                           *
*            05 WS-RA-TRUE-NAME   PIC X(8).                           *
*            05 WS-RA-SSI         PIC X(8).                           *
*            05 FILLER            PIC X(11).                          *
*                                                                     *
*         CALL WS-MODLISTR USING WS-MODULE-NAME,                      *
*                                WS-MODLISTR-RETURN-AREA.             *
*                                                                     *
*     (WS-MODULE-NAME must be padded with trailing blanks)            *
*     RESULTS ARE NOT WRITTEN TO FILE SYSPRINT                        *
*     Instead, the results are returned in WS-MODLISTR-RETURN-AREA    *
*     (a 100 byte return parameter from MODLISTR).                    *
*                                                                     *
*         MODNAME   DS  CL8                                           *
*         RETNAREA  DS  CL100                                         *
*         CALL MODLISTR,(MODNAME,RETNAREA),VL                         *
*                                                                     *
*  ------------------------------------------------------------------ *
*                                                                     *
*  PICKED THIS PROGRAM UP FROM THE WWW.XEPHON.COM WEB SITE (PROGRAM   *
*  'POBJINFO' AND ADDED TO IT.  ADDED A CALL TO PROGRAM 'JUL2GREG'    *
*  TO OBTAIN THE GREGORIAN DATE FROM THE JULIAN LINK-EDIT DATE.       *
*  CHANGED THE 'TPUT' MACROS TO 'PUT' TO SYSPRINT MACROS.             *
*                                                                     *
*  ADDED 3 ADDITIONAL LINES OF DISPLAY (SEE BELOW) INCLUDING THE      *
*  FOLLOWING FIELDS OBTAINED FROM THE PDS OR PDS/E MEMBER'S DIRECTORY *
*  RECORD:                                                            *
*                                                                     *
*   AMODE, RMODE, APF AUTH CODE, REENTRANT ATTR, REUSE ATTR, REFRESH  *
*   ATTR, TTR LOCATION, EPA ADDRESS, MEMBER'S DASD RESIDENT LOCATION  *
*   VOLSER/DATASET NAME, DSORG OF LIBRARY, ALIAS' TRUENAME (IF THE    *
*   MEMBER IS AN ALIAS NAME), AND SSI INFORMATION (IF PRESENT).       *
*                                                                     *
*  IT DISPLAYS 3 OR 4 LINES OF INFORMATION ON DDNAME 'SYSPRINT'       *
*  (4 LINES IF THE MEMBER IS AN ALIAS NAME) IF CALLED FROM REXX, TSO, *
*  OR FROM A SUBROUTINE WITH ONLY 1 PARAMETER.                        *
*                                                                     *
*     MEMBERNAME, LINKEDIT DATE (BOTH JULIAN AND GREGORIAN DATE),     *
*     LINKEDIT TIME, LENGTH OF THE LOAD MODULE, AMODE, RMODE,         *
*     APF AUTH CODE, REENTRANT ATTR, REUSE ATTR, REFRESH ATTR,        *
*     TTR LOCATION, EPA ADDRESS, MEMBER'S DASD RESIDENT LOCATION      *
*     VOLSER/DATASET NAME, DSORG OF LIBRARY, AND ALIAS' TRUENAME (IF  *
*     THE MEMBER IS AN ALIAS NAME (DISPLAYED ON LINE 4), AND SSI      *
*     INFORMATION (IF PRESENT).                                       *
*                                                                     *
*                                                                     *
*  ALSO MODIFIED THE PROGRAM TO BE REENTRANT.                         *
*                                                                     *
*       TKMILLE 04/28/2006                                            *
*                                                                     *
*  END OF CHANGE LOG                                                  *
*                                                                     *
*                                                                     *
*  OUTPUT FILES: //SYSPRINT (3 or 4 Line Display)                     *
*                                                                     *
*  RETURN CODES FROM MODLISTR:                                        *
*                                                                     *
*  0      => Successful call to MODLISTR                              *
*  4,8,12 => Various other return codes/reason codes from IEWBIND,    *
*              OBTAIN, AND RDJFCB macros.                             *
*                                                                     *
*    Attributes:  REENTRANT, REUSEABLE, AMODE 31, RMODE 24            *
*                                                                     *
***********************************************************************
*        HOUSEKEEPING                                                 *
***********************************************************************
MODLISTR CSECT
MODLISTR AMODE 31
MODLISTR RMODE 24
         SAVE  (14,12),,MODLISTR_ASSEMBLED_ON_&SYSDATC._&SYSTIME
         LR    R12,R15              Load entry address
         LA    R11,2048(,R12)       Chain R11 to R12 Base
         LA    R11,2048(,R11)
         USING MODLISTR,R12,R11     Declare entry base registers
         LR    R5,R1                Preserve passed parmlist address
         LR    R6,R13               Store SAVEAREA Backward link
         L     R3,=A(STORSIZE)      Size of storage to obtain
         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)
         ST    R1,8(,R13)           Set SAVEAREA Forward link
         LR    R13,R1               Address of obtained area
         USING STORAREA,R13         Addressability to obtained area
INITOBTN DS    0H                  Initialize the obtained storage area
         LR    R2,R13               Address of target of move (obtnd)
         L     R3,=A(STORSIZE)      Length of the target of move
         XR    R14,R14             From address (irrelevant with len=0)
         XR    R15,R15              Pad/Length to propagate in odd reg
         MVCL  R2,R14          Propagate binary zeroes in obtained area
         ST    R5,PARMLSTA          Store passed pointer to parms
         ST    R6,4(,R13)           Set SAVEAREA Backward link
         MVI   DISFLDSS,C' '
         MVC   DISFLDSS+1(DISFLDSL-1),DISFLDSS  Init the display fields
*********************************************************************
*        Main routine
*********************************************************************
         USING PSA,0                Define Prefixed Save Area
         L     R1,FLCCVT            Load CVT addresss
         USING CVT,R1               Map CVT
         MVC   LPARNAME,CVTSNAME    Save the lpar name
         DROP  R1
         LA    R8,PDSDIRAR
         USING PDS2,R8              Map PDS Directory Record
OPENSYSP DS    0H                   Open Sysprint Report file Output
         LA    R3,SYSPRINT          DCB to open
         MVC   SYSPRINT(SYSPRTIL),SYSPRTI
         MVC   WKOPENCL(OPENIL),OPENI
         LA    R4,WKOPENCL          OPEN/CLOSE work area
         OPEN  ((R3),OUTPUT),MODE=31,MF=(E,(R4))   OPEN SYSPRINT OUTPUT
         LTR   R15,R15              Good open ?
         BNZ   CLEANUP1             No
GETPARMS DS    0H                   Get Linkage Parms
         BAS   R5,CHECKPRM          Make sure module name passed
         LTR   R15,R15              Successful?
         BNZ   RETURN               No, get out
GETBUFFR DS    0H                   Get Binder Buffer
         BAS   R5,INITBUFF          Go obtain and initialize buffer
         LTR   R15,R15              Successful?
         BNZ   RETURN               No, get out
STARTDIA DS    0H                   Start Binder Dialog
         BAS   R5,STRTDIAG          Go start the binder dialog
         LTR   R15,R15              Successful?
         BNZ   CLEANUP3             No, get out
WORKMOD  DS    0H                   Create a Work Module
         BAS   R5,CRTWMOD
         LTR   R15,R15              Successful?
         BNZ   CLEANUP2             No, get out
SETLIST  DS    0H
         BAS   R5,SETOPT            Go set the LIST option to ALL
         LTR   R15,R15              Successful?
         BNZ   CLEANUP1             No, get out
INCLUDEM DS    0H
         BAS   R5,INCLMOD           Go INCLUDE the module
         LTR   R15,R15              Successful?
         BZ    GETGOODS             Yes
         BAS   R5,GET_MORE          Go get the dsn and volser
         LTR   R15,R15              Successful?
         BZ    GODISPLY             Yes
         B     CLEANUP1             No, get out
GETGOODS DS    0H                   Get all the goodies
         BAS   R5,STORDATA          Go get the required data
         LTR   R15,R15              Successful?
         BNZ   CLEANUP1             No, get out
GODISPLY DS    0H
         L     R1,PARMADR2          Check if second parm was passed
         C     R1,=F'0'             Was second parameter passed ?
         BE    SYSPRNT              No - Then print results
         MVC   0(RETURN_INFO_LEN,R1),RETURN_INFO  Yes - return results
         B     CLEANUP1
SYSPRNT  DS    0H
         BAS   R5,DISPLAY_RESULTS   Go Display the Results
CLEANUP1 DS    0H
         BAS   R5,DELWMOD           Go delete the workmod
CLEANUP2 DS    0H
         BAS   R5,ENDDIAG           Go end the dialog
CLEANUP3 DS    0H
         IEWBUFF FUNC=FREEBUF,TYPE=IDRB  , Free the buffer storage
RETURN   DS    0H
         LA    R3,SYSPRINT          DCB to close
         MVC   WKOPENCL(OPENIL),OPENI
         LA    R4,WKOPENCL          OPEN/CLOSE work area
         CLOSE ((R3)),MODE=31,MF=(E,(R4))
         L     R4,RETCODE           Pick up return code
         LR    R2,R13               Pointer to storage area
         L     R3,=A(STORSIZE)      Size of storage obtained
         L     R13,4(,R13)          Restore Caller's SAVEAREA address
         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)
         L     R14,12(,R13)         Restore R14
         LR    R15,R4               Load return code
         LM    R0,R12,20(R13)       Restore caller's registers
         BSM   0,R14                Return to caller in caller's Amode
**********************************************************************
*        This program can be called from a Rexx exec (or via jcl
*        directly) or from another program as a subroutine call.
*        If called as a subroutine, the user can optionally
*        return the results as a data parm in lieu of displaying the
*        results by passing a second parameter.
*        In all other cases, the results will be displayed on the
*        SYSPRINT report file.
*        Macro HOWCALLD is used to see how this program was called.
**********************************************************************
CHECKPRM DS    0H
         MVC   PARMADR2,=F'0'       Clear PARM2 address save area
         L     R1,PARMLSTA          Restore R1
         L     R7,0(,R1)
         ST    R7,PARMADR1          Store the First Parm Address
         HOWCALLD PARMCALL=PARMCALL , How was I called? Subr or Exec?
         B     HAVESUBR             I was called as a subroutine
PARMCALL DS    0H
         CLC   0(2,R7),=H'1'        Name must be at least 1 byte long
         BL    INVLPARM             Invalid parm passed
         CLC   0(2,R7),=H'8'        Must not be longer than 8 bytes
         BH    INVLPARM             Member Name Parm too long
         LH    R2,0(,R7)            Pick up the member name length
         LA    R3,2(,R7)            Pick up the member name address
         ST    R3,MEMNMADR          Save Member Name Address
         B     GETMEMB
HAVESUBR DS    0H
         L     R1,PARMLSTA          Subroutine call Get Parmlist addrs
         LR    R3,R7                Point to the member name in PARM1
         ST    R3,MEMNMADR          Save Member Name Address
         TM    0(R1),B'10000000'    Was a second parameter passed ?
         BO    NOPARM2              No  - results will be displayed
         L     R1,4(,R1)            Yes - results will be in PARM2
         ST    R1,PARMADR2          Save PARM2 address
NOPARM2  DS    0H
         BCTR  R3,0                 R3 will displace across membname
         LA    R2,0                 R2 will save the length
         BCTR  R2,0
GETMEML  DS    0H                   Determine Member name Length
         LA    R2,1(,R2)            Add one to length accumulator
         LA    R3,1(,R3)            Move accross one char in Membname
         C     R2,=F'7'             Index Reg > 7 ? (i.e. 8)
         BH    GETMEMB
         CLI   0(R3),C' '           Find End of member name ?
         BNE   GETMEML              No
GETMEMB  DS    0H
         L     R3,MEMNMADR
         STH   R2,MEMNAME           Save the member name length
         BCTR  R2,0                 Adjust the length for EX
         EX    R2,MVCNAME           Execute the MVC instruction
         XR    R15,R15              Clear return code
         B     CHECKPRX             Get out
MVCNAME  DS    0H
         MVC   MEMNAME8(0),0(R3)    Move parm into member name field
INVLPARM DS    0H
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'INVLP),INVLP
         PUT   SYSPRINT,SYSPRTAR
         LA    R15,4                Set return code
CHECKPRX DS    0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine obtains and initializes the buffer
**********************************************************************
INITBUFF DS    0H
         IEWBUFF FUNC=GETBUF,TYPE=IDRB
         LTR   R15,R15              Successful?
         BNZ   NOBUFF               No, failed
         IEWBUFF FUNC=INITBUF,TYPE=IDRB
         ST    R6,HEADER@           Preserve the header address
         ST    R7,ENTRY@            Preserve the entry address
         LTR   R15,R15              Successful?
         BZ    INITBUFX             Yes, get out
NOBUFF   DS    0H
         ST    R15,RETCODE          Store the return code
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'NOWKBUF),NOWKBUF
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSG(L'CODEMSG),CODEMSG
         UNPK  UNPACK9(9),RETCODE(5)
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   COEXMSG+14(8),UNPACK9
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG
         PUT   SYSPRINT,SYSPRTAR
         L     R15,RETCODE          Reload return code
INITBUFX DS    0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine starts the binder dialog
**********************************************************************
STRTDIAG DS    0H
         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW
         IEWBIND FUNC=STARTD,DIALOG=DTOKEN,FILES=FILENAME,             +
               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +
               MF=(E,IEWPLIST)
         L     R15,RETCODE          Look at the return code
         LTR   R15,R15              Successful?
         BZ    STRTDIAX             Yes, get out
NOSTART  DS    0H
         LR    R2,R15               Preserve return code
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'NODIAG),NODIAG
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSGA(CODEMSGL),CODEMSGA
         MVC   COEXFUNC(6),=CL6'STARTD'
         ST    R5,SAVE_R5
         BAS   R5,SHOWCODE          Go print return and reason codes
         L     R5,SAVE_R5
         LR    R15,R2               Reload return code
STRTDIAX DS    0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine creates a workmod with ACCESS intent
**********************************************************************
CRTWMOD  DS    0H
         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW
         IEWBIND FUNC=CREATEW,DIALOG=DTOKEN,                           +
               INTENT=ACCESS,WORKMOD=WTOKEN,                           +
               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +
               MF=(E,IEWPLIST)
         L     R15,RETCODE          Look at the return code
         LTR   R15,R15              Successful?
         BZ    CRTWMODX             Yes, get out
NOCREATE DS    0H
         LR    R2,R15               Preserve return code
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'NOWMOD),NOWMOD
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSGA(CODEMSGL),CODEMSGA
         MVC   COEXFUNC(7),=CL7'CREATEW'
         ST    R5,SAVE_R5
         BAS   R5,SHOWCODE          Go print return and reason codes
         L     R5,SAVE_R5
         LR    R15,R2               Reload return code
CRTWMODX DS    0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine sets the LIST option to SUMMARY
**********************************************************************
SETOPT   DS    0H
         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW
         IEWBIND FUNC=SETO,OPTION=OPTNLIST,                            +
               WORKMOD=WTOKEN,OPTVAL=SUMMARY,                          +
               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +
               MF=(E,IEWPLIST)
         L     R15,RETCODE          Look at the return code
         LTR   R15,R15              Successful?
         BZ    SETOPTX              Yes, get out
NOSETOPT DS    0H
         LR    R2,R15               Preserve return code
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'NOOPT),NOOPT
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSGA(CODEMSGL),CODEMSGA
         MVC   COEXFUNC(4),=CL4'SETO'
         ST    R5,SAVE_R5
         BAS   R5,SHOWCODE          Go print return and reason codes
         L     R5,SAVE_R5
         LR    R15,R2               Reload return code
SETOPTX  DS    0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine INCLUDEs the module
**********************************************************************
INCLMOD  DS    0H
         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW
         IEWBIND FUNC=INCLUDE,WORKMOD=WTOKEN,                          +
               DDNAME=INCLLIB,MEMBER=MEMNAME,INTYPE=NAME,              +
               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +
               MF=(E,IEWPLIST)
         L     R15,RETCODE          Look at the return code
         LTR   R15,R15              Successful?
         BZ    INCLMODX             Yes, get out
INCLWARN DS    0H
*   See IBM MANUAL SA22-7644-xx for return code / reason codes
*     RC=4 REAS=83000526
* An Unusual Condition was encountered while processing an input module
* This has been documented as a bad IDRZ record in the IBM knowledge
* database.
* CA-Endevor managed libraries have produced this condition due to
* CA-Endevor's footprint in the IDR record.
*
         C     R0,=X'83000526'      ACCEPTABLE WARNING? (Bad IDRZ rec)
         BNE   NOINCLUD              NO
         XR    R15,R15               YES, reset R15 and continue on
         B     INCLMODX
NOINCLUD DS    0H
         MVC   SAVE_RC,RETCODE      Preserve return code for later on
         MVC   SAVE_RSN,RSNCODE     Preserve reason code for later on
         ST    R15,SAVE_R15         Preserve R15         for later on
         MVI   SKP_BLDL,C'Y'        Indicate to skip the BLDL call
**********************************************************************
*        Defer printing error msg until the library dsn is obtained
*        from the vtoc later on.
**********************************************************************
INCLMODX DS    0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine gets the required data binder date/time
**********************************************************************
STORDATA DS    0H
         L     R6,HEADER@           Reload the header address
         L     R7,ENTRY@            Reload the buffer address
         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW
         IEWBIND FUNC=GETD,WORKMOD=WTOKEN,AREA=IEWBIDB,                +
               CURSOR=NULL,COUNT=NUMBYTES,CLASS=CLASS,                 +
               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +
               MF=(E,IEWPLIST)
         L     R15,RETCODE          Look at the return code
         CH    R15,=H'4'            Successful?
         BH    NOGETDTA             No
         CLC   IDB_DATE_BOUND,=6C'00'          Date available?
         BE    MOVETIME                        No
MOVEDATE DS    0H
         MVC   JUL2GREG_JUL_DATE(7),IDB_DATE_BOUND Date for conversion
         MVC   S0LKJLDT(4),IDB_DATE_BOUND         Julian Year
         MVI   S0LKJLDT+4,C'.'
         MVC   S0LKJLDT+5(3),IDB_DATE_BOUND+4     Juldays
***********************************************************************
* JUL2GREG is Julian-to-Gregorian Conversion program TKMILLE 04/10/2006
*    Input  Parameter => Julian Date    (YYYYDDD)
*    Return Parameter => Gregorian Date (YYYYMMDD)
***********************************************************************
         MVC   WKCALL(CALLIL),CALLI          INIT CALL PARMLIST
         LA    R13,SAVEAREA
GET_GREG DS    0H                            Call Program JUL2GREG
         CALL  JUL2GREG,(JUL2GREG_JUL_DATE,JUL2GREG_GREG_DATE),VL,     +
               MF=(E,WKCALL)
         LTR   R15,R15                       Good call?
         BNZ   MOVETIME                      No - Skip Greg Data Disply
GREGDATE DS    0H
         MVC   S0LKGRDT(2),JUL2GREG_GREG_DATE+4    Load Gregorian Month
         MVI   S0LKGRDT+2,C'/'
         MVC   S0LKGRDT+3(2),JUL2GREG_GREG_DATE+6  Load Gregorian Day
         MVI   S0LKGRDT+5,C'/'
         MVC   S0LKGRDT+6(4),JUL2GREG_GREG_DATE    Load Gregorian Year
MOVETIME DS    0H
         CLC   IDB_TIME_BOUND,=6C'00'          Time available?
         BE    GET_MORE                        No
         MVC   S0LKTIME(2),IDB_TIME_BOUND      First  part of time
         MVI   S0LKTIME+2,C':'
         MVC   S0LKTIME+3(2),IDB_TIME_BOUND+2  Second part of time
         MVI   S0LKTIME+5,C':'
         MVC   S0LKTIME+6(2),IDB_TIME_BOUND+4  Third  part of time
*
* ADDED CODE TO PICK UP OTHER FILEDS AS WELL FOR DISPLAY.
*    TKMILLE 04/21/2006
*
GET_MORE DS 0H
         LA    R9,IEWLIB           DCB ADDRESS
         USING IHADCB,R9           MAP DCB
READJFCB DS    0H
         MVC   IEWLIB(IEWLIBIL),IEWLIBI        RELOCATE DCB
         MVC   JFCBLIST(JFCBLSIL),JFCBLSI      RELOCATE JFCB EXIT LIST
         MVC   WKRDJFCB(RDJFCBIL),RDJFCBI      RELOCATE JFCB MACRO
         LA    R1,JFCBLIST
         STCM  R1,7,DCBEXLSA                   LOAD EXIT LIST ADDRESS
         LA    R1,JFCBAR
         STCM  R1,7,JFCBLIST+1                 LOAD JFCB BUFFER ADDRESS
*
         RDJFCB ((R9)),MF=(E,WKRDJFCB)      READ IN JFCB
*
         LTR   R15,R15             GOOD READ ?
         BZ    FMT1DSCB             YES
         ST    R15,RETCODE          NO
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'JFCBRERR),JFCBRERR
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSG(L'CODEMSG),CODEMSG
         UNPK  UNPACK9(9),RETCODE(5)
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   COEXMSG+14(8),UNPACK9
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG
         PUT   SYSPRINT,SYSPRTAR
         L     R15,RETCODE          Reload return code
         BR    R5                   Back to our caller
FMT1DSCB DS    0H
         MVC   CAMPRMLS(CAMLSTIL),CAMLSTI   INITIALIZE OBTAIN PARMLIST
         LA    R1,JFCBDSNM
         ST    R1,CAMLDSN
         LA    R1,JFCBVOLS
         ST    R1,CAMLVOL
         LA    R1,CAMWORK
         ST    R1,CAMLWRK
         LA    R1,CAMPRMLS
*
         OBTAIN CAMPRMLS           READ IN THE FORMAT 1 DSCB VTOC REC
*
         LTR   R15,R15             VTOC READ SUCCESSFUL?
         BZ    CHK_POE              YES
         ST    R15,RETCODE          NO
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'VTOCRERR),VTOCRERR
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSG(L'CODEMSG),CODEMSG
         UNPK  UNPACK9(9),RETCODE(5)
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   COEXMSG+14(8),UNPACK9
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG
         PUT   SYSPRINT,SYSPRTAR
         L     R15,RETCODE          Reload return code
         BR    R5                   Back to our caller
CHK_POE  DS    0H
***********************************************************************
*        HAVE A DSORG=PO (OR POE) DATASET ? IF NOT - ERROR SITUATION  *
***********************************************************************
         TM    DS1DSORG,DS1DSGPO   IS THIS A DSORG=PO (OR POE) DATASET?
         BNO   CLEARR15             NO, NOT DSORG PO OR POE
         TM    DS1SMSFG,DS1PDSE    IS THIS A PDS/E (POE) FILE ?
         BNO   OPEN_PDS            NO  - NOT A PDS/E FILE
         MVI   S2DSORG,C'E'
OPEN_PDS DS    0H
*
         CLI   SKP_BLDL,C'Y'
         BNE   OPEN_PD2
         ST    R15,TEMP_R15         Preserve return code
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'NOINCL),NOINCL
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSGA(CODEMSGL),CODEMSGA
         MVC   COEXFUNC(7),=CL7'INCLUDE'
         ST    R5,SAVE_R5
         BAS   R5,SHOWCODE          Go print return and reason codes
         L     R5,SAVE_R5
         L     R15,TEMP_R15         Preserve return code
         BR    R5                   Back to our caller
*
OPEN_PD2 DS    0H
         LA    R3,IEWLIB            DCB TO OPEN
         MVC   WKOPENCL(OPENIL),OPENI
         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA
         OPEN  ((R3),INPUT),MODE=31,MF=(E,(R4))   OPEN IEWLIB INPUT
         LTR   R15,R15              GOOD OPEN ?
         BZ    GET_REST             YES
         ST    R15,RETCODE          NO
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'OPENERR),OPENERR
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSG(L'CODEMSG),CODEMSG
         UNPK  UNPACK9(9),RETCODE(5)
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   COEXMSG+14(8),UNPACK9
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG
         PUT   SYSPRINT,SYSPRTAR
         L     R15,RETCODE          Reload return code
         BR    R5                   Back to our caller
GET_REST DS    0H
         MVC   PDSCNT,ONEH         NUMBER OF PDS MEMBERS 2B  RETURNED
         MVC   PDSDIRL,DIRLENG     LENGTH OF EACH PDS MEMBER RETURNED
         MVC   PDS2NAME,MEMNAME8   MEMBER FOR DIRECTORY TO BE RETURNED
*
         BLDL  IEWLIB,PDSLISTA     ISSUE BLDL MACRO
*
         LTR   R15,R15             BLDL SUCCESSFUL?
         BZ    GET_USRL             YES
         ST    R15,RETCODE          NO
         LA    R3,IEWLIB            DCB TO CLOSE
         MVC   WKOPENCL(OPENIL),OPENI
         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA
         CLOSE ((R3)),MODE=31,MF=(E,(R4))
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'BLDLERR),BLDLERR
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSG(L'CODEMSG),CODEMSG
         UNPK  UNPACK9(9),RETCODE(5)
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   COEXMSG+14(8),UNPACK9
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG
         PUT   SYSPRINT,SYSPRTAR
         L     R15,RETCODE          Reload return code
         BR    R5                   Back to our caller
*
GET_USRL DS    0H
         LA    R3,IEWLIB            DCB TO CLOSE
         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA
         CLOSE ((R3)),MODE=31,MF=(E,(R4))
         MVC   ONEBYTE,PDS2INDC      SAVE PDS2 INDICATOR BYTE
         NI    ONEBYTE,PDS2LUSR
         XR    R1,R1
         IC    R1,ONEBYTE            NBR OF HALF-WORDS IN USER DATA
         AR    R1,R1                 DOUBLE VALUE
         LA    R1,PDS2USRD-PDS2NAME(,R1) POINT TO END OF VAR USER DATA
         ST    R1,PDSDIRLN           SAVE ACTUAL PDS DIRECTORY LENGTH
GET_MODLEN DS  0H
         UNPK  UNPACK9(9),PDS2STOR(4)              GET MODULE LENGTH
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   S0MODLEN(L'UNPACK9-1),UNPACK9    MOVE MODULE LENGTH
GET_TTR  DS    0H
         UNPK  UNPACK7(7),PDS2TTRP(4)              GET TTR
         TR    UNPACK7(6),HEXCHAR
         MVI   UNPACK7+6,C' '
         MVC   S1TTR,UNPACK7              MOVE TTR TO DISPLAY AREA
GET_EPA  DS    0H
         UNPK  UNPACK9(9),PDS2EPA(4)      GET EP ADDRESS
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   S1EPA(L'UNPACK9-1),UNPACK9 MOVE EPA TO DISPLAY AREA
CHK_RENT DS    0H
         TM    PDS2ATR1,PDS2RENT          IS MODULE REENTRANT ?
         BNO   CHK_REUS                   NO  - NOT RENTRANT
         MVC   S1RENT,=CL2'RN'            YES -     RENTRANT
CHK_REUS DS    0H
         TM    PDS2ATR1,PDS2REUS          IS MODULE SERIALLY REUSEABLE?
         BNO   CHK_REFR                   NO  - NOT REUSEABLE
         MVC   S1REUS,=CL2'RU'            YES -     REUSEABLE
CHK_REFR DS    0H
         TM    PDS2ATR2,PDS2REFR          IS MODULE REFRESHABLE ?
         BNO   GET_AMODE                  NO  - NOT REFRESHABLE
         MVC   S1REFR,=CL2'RF'            YES -     REFRESHABLE
GET_AMODE DS   0H
         TM    PDS2INDC,PDS2ALIS      IS MEMBERNAME AN ALIAS ?
         BNO   GET_MAIN_AMODE           NO  - GET MAIN EP AMODE
         TM    PDS2FTB2,PDSAAMOD      TEST ALIAS AMODE
         BO    AMODE_ANY                AMODE = ANY
         BZ    AMODE_24                 AMODE =  24
         TM    PDS2FTB2,B'00001000'   TEST ALIAS AMODE = 31  ?
         BO    AMODE_31                 AMODE =  31
         B     AMODE_64                 AMODE =  64
GET_MAIN_AMODE DS 0H
         TM    PDS2FTB2,PDSMAMOD      TEST MAIN EP AMODE
         BO    AMODE_ANY                AMODE = ANY
         BZ    AMODE_24                 AMODE =  24
         TM    PDS2FTB2,B'00000010'   TEST MAIN EP AMODE = 31 ?
         BO    AMODE_31                 AMODE =  31
AMODE_64 DS    0H
         MVC   S1AMODE,=CL3' 64'        AMODE =  64
         B     GET_RMODE
AMODE_ANY      DS 0H
         MVC   S1AMODE,=CL3'ANY'        AMODE = ANY
         B     GET_RMODE
AMODE_31       DS 0H
         MVC   S1AMODE,=CL3' 31'        AMODE = 31
         B     GET_RMODE
AMODE_24       DS 0H
         MVC   S1AMODE,=CL3' 24'        AMODE = 24
GET_RMODE DS   0H
         TM    PDS2FTB2,PDSLRMOD      TEST RMODE ATTRIBUTE
         BO    RMODE_ANY                RMODE = ANY
         MVC   S1RMODE,=CL3' 24'        RMODE = 24
         B     CHK_OTHER_SECTIONS
RMODE_ANY DS   0H
         MVC   S1RMODE,=CL3'ANY'        RMODE = ANY
CHK_OTHER_SECTIONS  DS  0H
         LR    R4,R8                POINT TO START OF FIXED LENGTH AREA
         LA    R4,PDSBCLN-1(,R4)    POINT TO END OF FIXED LENGTH AREA
*
* CHECK FOR SCATTER SECTION
*
CHK_SCATR DS   0H
         TM    PDS2ATR1,PDS2SCTR         IS SCATTER SECTION present ?
         BNO   CHK_ALIAS                  NO
         LA    R4,1(,R4)             MOVE TO START OF SCATTER SECTION
         ST    R4,SCATOFFS           STORE SCATTER SECTION OFFSET
         LA    R4,PDSS01LN-1(,R4)    MOVE TO END OF SCATTER SECTION
*
* CHECK FOR ALIAS SECTION
*
CHK_ALIAS DS   0H
         TM    PDS2INDC,PDS2ALIS   IS ALIAS SECTION PRESENT ?
         BNO   CHK_SSI              NO  - MEMBER IS NOT AN ALIAS NAME
         LA    R4,1(,R4)             MOVE TO START OF ALIAS SECTION
         ST    R4,ALIASOFF           STORE ALIAS SECTION OFFSET
         LR    R2,R4
         LA    R2,PDS2MNM-PDSS02(,R2) POINT TO ALIAS TRUENAME
         MVC   S3TRUENM,0(R2)         GET ALIAS' TRUENAME
         LA    R4,PDSS02LN-1(,R4)     MOVE TO END OF ALIAS SECTION
*
* CHECK FOR SSI INFORMATION SECTION (ALIGNED ON A HALFWORD BOUNDARY)
*
CHK_SSI  DS    0H
         TM    PDS2FTB1,PDS2SSI      IS SSI SECTION PRESENT ?
         BNO   CHK_APF               NO
         LA    R4,1(,R4)             MOVE TO START OF SSI SECTION
         ST    R4,EVENODD
         TM    EVENODD+3,X'01'       Is this an odd number ?
         BNO   SKPALIGN                  No - already on hw boundary
         LA    R4,1(,R4)             MAKE HW ALIGNMENT - SHIFT 1 BYTE
*                                     (SSI SECTION IS ON HW BOUNDARY)
SKPALIGN DS    0H
         ST    R4,SSIOFFS            STORE SSI INFO SECTION OFFSET
         MVC   S3SSI(4),0(R4)        GET SSI
         UNPK  UNPACK9(9),S3SSI(5)
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   S3SSI,UNPACK9         MOVE SSI INFO TO DISPLAY AREA
         LA    R4,PDSS03LN-1(,R4)    MOVE TO END OF SSI SECTION
*
* CHECK FOR APF AUTHORIZATION SECTION
*
CHK_APF  DS    0H                  APF SECTION IS ASSUMED TO BE PRESENT
         LA    R4,1(,R4)             MOVE TO START OF APF SECTION
         ST    R4,APFOFFS            STORE APF SECTION OFFSET
         LR    R2,R4
         LA    R2,PDSAPFCT-PDSS04(,R2)
         MVC   S1APFCD,=CL2'00'           SET DEFAULT 00
         TM    PDS2FTB1,PDSAPFLG          IS APFCODE VALID ?
         BNO   GET_LRGOF                  NO  - NOT REENTRANT
         CLC   0(1,R2),XL00               APF AUTH CD LENGTH = 0 ?
         BE    GET_LRGOF                   YES
         CLC   0(1,R2),XL01               APF AUTH CD LENGTH = 1 ?
         BNE   GET_LRGOF                   NO
         LA    R2,1(R2)
         XR    R1,R1                      YES
         ICM   R1,B'0001',0(R2)           LOAD APF AUTH CODE (FL1)
         ST    R1,DOUBLE
         UNPK  UNPACK9(9),DOUBLE(5)       GET APF AUTH CODE
         TR    UNPACK9(8),HEXCHAR
         MVI   UNPACK9+8,C' '
         MVC   S1APFCD,UNPACK9+6        MOVE APF CODE TO DISPLAY AREA
         L     R4,APFOFFS
         LA    R4,PDSS04LN-1(,R4)     MOVE TO END OF APF SECTION
*
* CHECK FOR LARGE PROGRAM SECTION
*
GET_LRGOF DS   0H
         TM    PDS2FTB1,PDS2BIG    IS LARGE PGM SECTION PRESENT ?
         BNO   CLEARR15             NO
         LA    R4,1(,R4)             MOVE TO START OF LARGE PGM SECTION
         ST    R4,LRGOFFS            STORE LARGE PGM SECTION OFFSET
*
         DROP  R9
*
CLEARR15 DS    0H
         XR    R15,R15              Data successfully obtained
         B     STORDATX             Get out
NOGETDTA DS    0H
         LR    R2,R15               Preserve return code
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'NODATA),NODATA
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSGA(CODEMSGL),CODEMSGA
         MVC   COEXFUNC(4),=CL4'GETD'
         ST    R5,SAVE_R5
         BAS   R5,SHOWCODE          Go print return and reason codes
         L     R5,SAVE_R5
         LR    R15,R2               Reload return code
STORDATX DS    0H
         BR    R5                   Back to our caller
*
DISPLAY_RESULTS DS   0H
         CLI   SKP_BLDL,C'Y'           Was member found in lib ?
         BNE   DIS_DT_TM               Yes
**********************************************************************
*  Display Member Not Found Message
**********************************************************************
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         LA    R1,SYSPRTAR
         MVC   0(L'NOTFNDM1,R1),NOTFNDM1
         LA    R1,L'NOTFNDM1(,R1)
         LH    R2,MEMNAME           Get Member Length
         BCTR  R2,0                 Correct the length for EX Move
         EX    R2,MVCNAME2          Execute the MVC instruction
         LA    R1,1(R1,R2)
         MVC   0(L'NOTFNDM2,R1),NOTFNDM2
         LA    R1,L'NOTFNDM2(,R1)
         MVC   0(L'JFCBDSNM,R1),JFCBDSNM
         LA    R1,L'JFCBDSNM(,R1)
DSN_LEN  DS    0H                        Find end of dsn in msg
         CLI   0(R1),C' '                Look for a non-blank char
         BNE   DSN_LFND                  Found trailing dsn char
         BCT   R1,DSN_LEN
DSN_LFND DS    0H
         MVC   1(L'NOTFNDM3,R1),NOTFNDM3
         LA    R1,L'NOTFNDM3(,R1)
         MVC   1(L'LPARNAME,R1),LPARNAME
         PUT   SYSPRINT,SYSPRTAR
         B     DISPLAY_END
MVCNAME2 DS    0H
         MVC   0(0,R1),MEMNAME8
*
DIS_DT_TM DS   0H
*  DEBUGGING START
*        MVI   SYSPRTAR,C' '
*        MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
*        MVC   SYSPRTAR+1(80),PDS2
*        PUT   SYSPRINT,SYSPRTAR         DISPLAY THE DIRECTORY ENTRY
*  DEBUGGING END
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L_SYSREC0),SYSREC0
         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8
         MVC   SYSPRTAR+20(L'S0LKGRDT),S0LKGRDT
         MVC   SYSPRTAR+32(L'S0LKJLDT),S0LKJLDT
         CLC   IDB_TIME_BOUND,=6C'00'              Time available?
         BE    DIS_LENGTH                          No
         MVC   SYSPRTAR+46(L'S0LKTIME),S0LKTIME
DIS_LENGTH DS  0H
         MVC   SYSPRTAR+65(L'S0MODLEN),S0MODLEN
         MVC   SYSPRTAR+76(3),LPARNAME
         PUT   SYSPRINT,SYSPRTAR
*
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L_SYSREC1),SYSREC1
         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8
         MVC   SYSPRTAR+14(L'S1AMODE),S1AMODE
         MVC   SYSPRTAR+22(L'S1RMODE),S1RMODE
         MVC   SYSPRTAR+30(L'S1APFCD),S1APFCD
         MVC   SYSPRTAR+34(L'S1RENT),S1RENT
         MVC   SYSPRTAR+37(L'S1REUS),S1REUS
         MVC   SYSPRTAR+40(L'S1REFR),S1REFR
         MVC   SYSPRTAR+48(L'S1TTR),S1TTR
         MVC   SYSPRTAR+65(L'S1EPA),S1EPA
         PUT   SYSPRINT,SYSPRTAR
*
DISP_DSN DS    0H
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L_SYSREC2),SYSREC2
         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8
         MVC   SYSPRTAR+19(L'JFCBVOLS),JFCBVOLS
         MVC   SYSPRTAR+26(L'JFCBDSNM),JFCBDSNM
         MVC   SYSPRTAR+78(L'S2DSORG),S2DSORG
         PUT   SYSPRINT,SYSPRTAR
*
         CLI   SKP_BLDL,C'Y'           Was member found in lib ?
         BE    DISPLAY_END             No
*
         TM    PDS2FTB1,PDS2SSI      IS SSI SECTION PRESENT ?
         BO    DISPLAY_L3             YES - HAVE SOMETHING TO DISPLAY
         TM    PDS2INDC,PDS2ALIS     IS MEMBER AN ALIAS NAME  ?
         BNO   DISPLAY_END            NO  - MEMBER IS NOT AN ALIAS NAME
DISPLAY_L3 DS  0H
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8
         TM    PDS2FTB1,PDS2SSI      IS SSI SECTION PRESENT ?
         BNO   DISPLAY_AL             NO
         MVC   SYSPRTAR+9(6),=CL6' SSI: '
         MVC   SYSPRTAR+15(L'S3SSI),S3SSI
DISPLAY_AL DS  0H
         TM    PDS2INDC,PDS2ALIS     IS MEMBER AN ALIAS NAME  ?
         BNO   DISPLAY_L3_END         NO  - MEMBER IS NOT AN ALIAS NAME
         MVC   SYSPRTAR+23(29),=CL29'   *** ALIAS NAME FOR MEMBER '
         MVC   SYSPRTAR+52(L'S3TRUENM),S3TRUENM
         MVC   SYSPRTAR+60(4),=CL4' ***'
DISPLAY_L3_END DS  0H
         PUT   SYSPRINT,SYSPRTAR
DISPLAY_END DS 0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine deletes the workmod
**********************************************************************
DELWMOD  DS    0H
         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW
         IEWBIND FUNC=DELETEW,WORKMOD=WTOKEN,                          +
               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +
               MF=(E,IEWPLIST)
         L     R15,RETCODE          Look at the return code
         LTR   R15,R15              Successful?
         BZ    DELWMODX             Yes, get out
         LR    R2,R15               Preserve return code
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'NODEL),NODEL
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSGA(CODEMSGL),CODEMSGA
         MVC   COEXFUNC(7),=CL7'DELETEW'
         ST    R5,SAVE_R5
         BAS   R5,SHOWCODE          Go print return and reason codes
         L     R5,SAVE_R5
         LR    R15,R2               Reload return code
DELWMODX DS    0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine ends the dialog
**********************************************************************
ENDDIAG  DS    0H
         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW
         IEWBIND FUNC=ENDD,DIALOG=DTOKEN,                              +
               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +
               MF=(E,IEWPLIST)
         L     R15,RETCODE          Look at the return code
         LTR   R15,R15              Successful?
         BZ    ENDDIAGX             Yes, get out
         LR    R2,R15               Preserve return code
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'NOEND),NOEND
         PUT   SYSPRINT,SYSPRTAR
         MVC   COEXMSGA(CODEMSGL),CODEMSGA
         MVC   COEXFUNC(4),=CL4'ENDD'
         ST    R5,SAVE_R5
         BAS   R5,SHOWCODE          Go print return and reason codes
         L     R5,SAVE_R5
         LR    R15,R2               Reload return code
ENDDIAGX DS    0H
         BR    R5                   Back to our caller
**********************************************************************
*        This routine makes the return and reason codes printable
**********************************************************************
SHOWCODE DS    0H
         MVC   LOWBYTES,RETCODE     Move return and reason code in
         NC    LOWBYTES(8),=8X'F0'  Turn off the second part bytes
         TR    LOWBYTES(8),LEFTHALF
         MVC   HIGBYTES,RETCODE     Move return and reason code in
         NC    HIGBYTES(8),=8X'0F'  Turn off the first part bytes
         TR    HIGBYTES(8),RIGTHALF
         LA    R1,LOWBYTES         Where the first half of each byte is
         LA    R2,HIGBYTES          Where second half of each byte is
         LA    R3,WORKAREA          Where we want to move the data to
         LA    R4,8                 8 bytes to move
CODELOOP DS    0H
         MVC   0(1,R3),0(R1)        Move first half of byte
         LA    R3,1(,R3)            Bump up target pointer
         MVC   0(1,R3),0(R2)        Move second half of byte
         LA    R3,1(,R3)            Bump up target pointer
         LA    R1,1(,R1)            Bump up first-half-of-byte pointer
         LA    R2,1(,R2)            Bump up second-half-of-byte pointer
         BCT   R4,CODELOOP          Do for each of the bytes
         MVC   COEXMSG(CODEMSGL),CODEMSG
         MVC   COEXMSG+14(8),WORKAREA
         MVC   COEXMSG+36(8),WORKAREA+8
RCREASN  DS    0H
         CLI   COEXFUNC,C' '              IEWBIND MACRO ERROR ?
         BE    SHOWCODX                    NO
         MVI   SYSPRTAR,C' '               YES
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   COEXMEMB(L'MEMNAME8),MEMNAME8
         MVC   SYSPRTAR+1(COEXMSGL),COEXMSGA
         PUT   SYSPRINT,SYSPRTAR
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG
         PUT   SYSPRINT,SYSPRTAR
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'MANLMSG1),MANLMSG1
         PUT   SYSPRINT,SYSPRTAR
         MVI   SYSPRTAR,C' '
         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR
         MVC   SYSPRTAR+1(L'MANLMSG2),MANLMSG2
         PUT   SYSPRINT,SYSPRTAR
SHOWCODX DS    0H
         BR    R5
**********************************************************************
*    STATIC STORAGE FOLLOWS
**********************************************************************
         LTORG
INVLP    DC    C'MODLISTR error - Invalid member name passed.'
NOWKBUF  DC    C'MODLISTR error - Failed to obtain and init work buffer+
               .'
NODIAG   DC    C'MODLISTR error - Failed to START dialog.'
NOWMOD   DC    C'MODLISTR error - Failed to CREATE a workmod.'
NOOPT    DC    C'MODLISTR error - Failed to set LIST=SUMMARY option.'
NOINCL   DC    C'MODLISTR error - Failed to INCLUDE module.'
NODATA   DC    C'MODLISTR error - Failed to OBTAIN data for module.'
NODEL    DC    C'MODLISTR error - Failed to DELETE workmod.'
NOEND    DC    C'MODLISTR error - Failed to END dialog.'
NODATE   DC    C'MODLISTR error - Failed to obtain gregorian date.'
JFCBRERR DC    C'MODLISTR error - Error Reading JFCB for File IEWLIB.'
VTOCRERR DC    C'MODLISTR error - Error Reading Format 1 Vtoc.'
OPENERR  DC    C'MODLISTR error - Error Opening PDS File.'
BLDLERR  DC    C'MODLISTR error - Error Calling BLDL macro.'
*
INCLLIB  DC    H'6',C'IEWLIB'
CLASS    DC    H'6',C'B_IDRB'
*
CODEMSGA DC    0C
         DC    CL33'  IEWBIND macro error for module '
         DC    CL8'        '
         DC    CL16'.  IEWBIND FUNC='
         DC    CL8'        '
CODEMSGL EQU   *-CODEMSGA
*
NOTFNDM1 DC    C' MODULE "'
NOTFNDM2 DC    C'" NOT FOUND IN LIBRARY "'
NOTFNDM3 DC    C'" ON '
*
CODEMSG  DC    C'  Return Code=????????, Reason Code=????????'
*
MANLMSG1 DC    C'  See IBM MVS PROGRAM MANAGEMENT: ADVANCED FACILITIES +
               Manual (SA22-7644-xx)'
MANLMSG2 DC    C'      for BINDER API return code / reason code explana+
               tion.'
*
         IEWBIND PLISTVER,MF=(L,IEWPLSTW,0D)
IEWPLSTL EQU   *-IEWPLSTW
*
         IEWBUFF FUNC=MAPBUF,TYPE=IDRB,SIZE=1000,HEADREG=6,ENTRYREG=7, +
               VERSION=5
*
FILENAME DS    0F
         DC    F'0'                  Swap with next card to get BINDER
*        DC    F'2'                    messages displayed
         DC    CL8'TERM',F'8',A(TERM)
         DC    CL8'PRINT',F'8',A(TERM)
*
TERM     DC    CL7'IEWINFO'          DD-name messages will go to
OPTNLIST DC    H'4',C'LIST'          Option LIST=SUMMARY
SUMMARY  DC    H'7',C'SUMMARY'       Option LIST=SUMMARY
*
LEFTHALF DS    0CL240
         DC    X'F0',15X'00',X'F1',15X'00',X'F2',15X'00',X'F3'
         DC    15X'00',X'F4',15X'00',X'F5',15X'00',X'F6',15X'00',X'F7'
         DC    15X'00',X'F8',15X'00',X'F9',15X'00',X'C1',15X'00',X'C2'
         DC    15X'00',X'C3',15X'00',X'C4',15X'00',X'C5',15X'00',X'C6'
RIGTHALF DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'
*
HEXCHAR  EQU   *-C'0'
         DC    C'0123456789ABCDEF'
*
SYSPRTI  DS    0F
         DCB   DDNAME=SYSPRINT,MACRF=(PM),DSORG=PS,                    +
               LRECL=121,RECFM=F
SYSPRTIL EQU   *-SYSPRTI           LENGTH OF SYSPRTI
*
IEWLIBI  DS    0F
         DCB   DDNAME=IEWLIB,MACRF=(R),DSORG=PO,LRECL=0,RECFM=U,       +
               EXLST=*,DEVD=DA
IEWLIBIL EQU   *-IEWLIBI           LENGTH OF IEWLIBI
*
RDJFCBI        DS    0F
               RDJFCB  *,MF=L                   JFCB MACRO INIT AREA
RDJFCBIL       EQU   *-RDJFCBI                  LENGTH OF RDJFCBI
*
JFCBLSI        DS    0F
               DC    XL1'87',AL3(0)             INIT JFCB EXIT LIST
JFCBLSIL       EQU   *-JFCBLSI
*
OPENI          DS    0F
               OPEN  (*,OUTPUT),MODE=31,MF=L
OPENIL         EQU   *-OPENI                      LENGTH OF OPENI
*
CALLI          DS    0F
               CALL  ,(*,*),VL,MF=L
CALLIL         EQU   *-CALLI                      LENGTH OF CALLI
*
JUL2GREG       DC    V(JUL2GREG)         ADDRESS OF PGM JUL2GREG
*
CAMLSTI        DS    0F
               CAMLST SEARCH,1,2,3       OBTAIN PARMLIST INIT AREA
CAMLSTIL       EQU   *-CAMLSTI
*
ONEH           DC    H'1'
XL00           DC    XL1'00'
XL01           DC    XL1'01'
*
DIRLENG        DC    Y(PDS2LEN)
*
***********************************************************************
* DISPLAY LINE AREAS FOLLOW
***********************************************************************
SYSREC0     DC    0C
            DC    CL8'        '           MODULE MEMBER NAME
            DC    C' Linked on '
            DC    CL10'mm/dd/yyyy'        Gregorian Link Edit Date
            DC    C' ('
            DC    CL8'yyyy.ddd'           Julian    Link Edit Date
            DC    C')  at '
            DC    CL8'hh:mm:ss'           Link Edit Time of Day
            DC    C'   LENGTH: '
            DC    CL6'      '             Module Length
L_SYSREC0   EQU   *-SYSREC0
*
SYSREC1     DC    0C
            DC    CL8'        '           MODULE MEMBER NAME
            DC    C' AM: '
            DC    CL3'  '                 AMODE
            DC    C' RM: '
            DC    CL3'  '                 RMODE
            DC    C' AC: '
            DC    CL2'  '                 APF CODE
            DC    C'  '
            DC    CL2'  '                 REENTRANT ATTRIBUTE
            DC    C' '
            DC    CL2'  '                 REUSE ATTRIBUTE
            DC    C' '
            DC    CL2'  '                 REFRESH ATTRIBUTE
            DC    C' TTR: '
            DC    CL6'      '             TTR
            DC    C'   EPADDR: '
            DC    CL6'      '             EPA ADDRESS
L_SYSREC1   EQU   *-SYSREC1
*
SYSREC2     DC    0C
            DC    CL8'        '           MODULE MEMBER NAME
            DC    C' VOL/DSN: '
            DC    CL6'      '             VOLSER
            DC    C' '
            DC    44CL1' '                LOAD LIBRARY DATA SET NAME
            DC    C' ORG: PO'                      DSORG=PO
            DC    CL1' '                  LIBRARY DSORG DSORG=POE
L_SYSREC2   EQU   *-SYSREC2
*
**********************************************************************
*    DYNAMIC STORAGE FOLLOWS  (ACQUIRED STORAGE AREA)
**********************************************************************
STORAREA    DSECT ,                 REENTRANT STORAGE
SAVEAREA    DS    20F
PARMLSTA    DS    F                 Parameter List Address
PARMADR1    DS    F                 First  Parameter Address
PARMADR2    DS    F                 Second Parameter Address
MEMNMADR    DS    F                 Address of the passed Member Name
DTOKEN      DS    D                 Dialog token
WTOKEN      DS    D                 Workmod token
DOUBLE      DS    D                 General workarea
RETCODE     DS    F                 Return code
RSNCODE     DS    F                 Reason code
SAVE_RC     DS    F                 Saved Return code
SAVE_RSN    DS    F                 Saved Reason code
SAVE_R5     DS    F                 Store R5
SAVE_R15    DS    F                 Saved R15
TEMP_R15    DS    F                 Temp Store for R15
LOWBYTES    DS    CL8               Workarea to make codes printable
HIGBYTES    DS    CL8               Workarea to make codes printable
WORKAREA    DS    CL16              Print format return and reason code
NULL        DS    F                 Where binder should begin
NUMBYTES    DS    F                 Number of bytes returned to us
HEADER@     DS    F                 Address of IEW header
ENTRY@      DS    F                 Address of IEW data entry
*
LPARNAME    DS    CL8               LPAR Name
*
SYSPRINT    DS    0F,CL(SYSPRTIL)      SYSPRINT DCB RELOCATE AREA
IEWLIB      DS    0F,CL(IEWLIBIL)      IEWLIB   DCB RELOCATE AREA
WKOPENCL    DS    0F,CL(OPENIL)        OPEN/CLOSE MACRO RELOCATE AREA
WKCALL      DS    0F,CL(CALLIL)        CALL MACRO RELOCATE AREA
IEWPLIST    DS    0F,CL(IEWPLSTL)      IEWBIND PARMLIST RELOCATE AREA
WKRDJFCB    DS    0F,CL(RDJFCBIL)      RDJFCB MACRO RELOCATE AREA
*
JFCBLIST    DS    F                    JFCB EXIT LIST RELOCATE AREA
JFCBAR      DS    CL(JFCBLGTH)         RDJFCB WORK AREA BUFFER
            ORG   JFCBAR
            IEFJFCBN LIST=YES
*
SYSPRTAR    DS    CL121
*
**********************************************************************
* OBTAIN SEARCH PARAMETER LIST FOLLOWS
**********************************************************************
CAMPRMLS    DS    0F                CAMLST PARAMETER LIST
CAMLFUNC    DS    X                 FUNCTION
CAML2       DS    X                 NOT USED WITH SEARCH
CAML3       DS    X                 NOT USED WITH SEARCH
CAML4       DS    X                 NOT USED WITH SEARCH
CAMLDSN     DS    F                 CAMLIST DATASET NAME
CAMLVOL     DS    F                 CAMLIST VOLSER
CAMLWRK     DS    F                 CAMLIST WORK AREA
*
CAMWORK     DS    0D,CL148
            ORG   CAMWORK-44        RECORD KEY IS NOT RETURNED
            IECSDSL1 (1)            FORMAT 1 DSCB
            ORG   ,
*
**********************************************************************
* BLDL MACRO WORK AREA FOLLOWS
**********************************************************************
*
PDSLISTA    DS    0F                BLDL LIST ADDRESS
PDSCNT      DS    H                 NBR OF MEMBERS TO RETURN
PDSDIRL     DS    H                 RESERVED LENGTH OF EACH DIRECTORY
PDSDIRAR    DS    CL(PDS2LEN)       PDS DIRECTORY AREA
PDSLISTL    EQU   *-PDSLISTA
*
PDSDIRLN    DS    F         LENGTH OF PDS DIRECTORY RETURNED BY BLDL
SCATOFFS    DS    F         SCATTER SECTION OFFSET (IF PRESENT)
ALIASOFF    DS    F         ALIAS SECTION OFFSET  (IF PRESENT)
SSIOFFS     DS    F         SSI SECTION OFFSET    (IF PRESENT)
APFOFFS     DS    F         APF SECTION OFFSET    (ASSUMED PRESENT)
LRGOFFS     DS    F         LARGE PRORGRAM SECTION OFFSET (IF PRESENT)
ONEBYTE     DS    CL1
*
COEXMSGA    DS    0C
            DS    CL33
COEXMEMB    DS    CL8
            DS    CL16
COEXFUNC    DS    CL8
COEXMSGL    EQU   *-COEXMSGA
*
COEXMSG     DS    CL44
*
UNPACK7     DS    CL7
UNPACK9     DS    CL9
EVENODD     DS    F                   Check for even or odd number
*
***********************************************************************
* JUL2GREG is Julian-to-Gregorian Conversion program TKMILLE 04/10/2006
***********************************************************************
JUL2GREG_JUL_DATE  DS   ZL7           /* YYYYDDD  PASSED AS PARM   */
JUL2GREG_GREG_DATE DS   ZL8           /* YYYYMMDD RETURNED AS PARM */
*
DISFLDSS    DS    0C
*
SKP_BLDL    DS    CL1                 CALL BLDL INDICATOR
*
RETURN_INFO DS    0F                  RETURN AS PARM IF REQUESTED
MEMNAME     DS    H
MEMNAME8    DS    CL8                 MEMBER NAME PASSED AS PARM
*
S0LKGRDT    DS    CL10                LINK EDIT GREGORIAN DATE
S0LKJLDT    DS    CL8                 LINK EDIT JULIAN    DATE
S0LKTIME    DS    CL8                 LINK EDIT TIME OF DAY
S0MODLEN    DS    CL8                 MODULE LENGTH
*
S1AMODE     DS    CL3                 AMODE
S1RMODE     DS    CL3                 RMODE
S1APFCD     DS    CL2                 APF CODE
S1RENT      DS    CL2                 REENTRANT ATTRIBUTE
S1REUS      DS    CL2                 REUSE ATTRIBUTE
S1REFR      DS    CL2                 REFRESH ATTRIBUTE
S1TTR       DS    CL6                 TTR
S1EPA       DS    CL8                 EPA ADDRESS
*
S2DSORG     DS    CL1                 LIBRARY DSORG  DSORG=POE
*
S3TRUENM    DS    CL8                 ALIAS' TRUE NAME
S3SSI       DS    CL8                 SSI INFORMATION
*
RETURN_INFO_LEN EQU   *-RETURN_INFO
*
DISFLDSL    EQU   *-DISFLDSS
*
STORSIZE    EQU   *-STORAREA
*
            YREGS ,                        Register Equates
DSECDCBD    DCBD     DSORG=PO,DEVD=DA ,
DSECTPSA    IHAPSA   LIST=YES ,            Map PSA
DSECTCVT    CVT      DSECT=YES,LIST=YES ,  Map CVT
DSECTPDS    IHAPDS ,                       Map PDS and PDS/E Directory
PDS2LEN     EQU   *-PDS2                   Get length of IHAPDS dsect
            END
