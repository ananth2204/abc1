{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012712000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 646646, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE743.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE743.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0b\\t'", "DS1TRBAL": "b'.\\xc0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x0c\\x00\\x05\\x05\\r\\x00\\x01\\x00\\x0c'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00R\\x01\\x10\\x12\\x0f\\x01\\x10\\x12\\x0f\\x11C\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-04-30T00:00:00", "modifydate": "2010-04-30T11:43:52", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-479"}, "text": "REGULAR CBT TAPE - VERSION 479    FILE:  743\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT479.FILE743\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 24 MEMBERS COUNTED; CUMULATIVE SIZE IS 5,800 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/30/10    11:43:52    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x009\\x01\\x04'_\\x01\\x10\\x11o\\x11#\\x01F\\x00\\xa5\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2004-10-01T00:00:00", "modifydate": "2010-04-26T11:23:39", "lines": 326, "newlines": 165, "modlines": 0, "user": "TKMILLE"}, "text": " Last Update: 04/06/2010    Terry Miller\n                            ConocoPhillips\n                            tkmille@ConocoPhillips.com\n\n 04/26/2010 - V01.01.14\n\n Fixed a bug in the MODLIST Rexx Exec.  Changed the sysid\n (system name) from 3 characters displayed to 8 characters.\n\n 04/06/2010 - V01.01.13\n\n Fixed a bug in the MODLISTR program.  It was not freeing buffer\n storage obtained by the INITBUF function. Corrected the storage\n leak by adding a FREEBUF function to the program:\n    IEWBUFF FUNC=INITBUF\n\n 04/06/2010 - V01.01.12\n\n Fixed a bug in the MODLIST exec.\n\n 01/21/2010 - V01.01.12\n\n Modified MODLIST exec to use a temporary file for browsing the\n results with ISPF browse.\n\n 06/12/2007 - V01.01.11\n\n ADDED \"DA(dsname)\" and DSN((dsname)\" keyword paramters to the\n \"MODLIST\" Rexx exec to be used as alternate keyword parameters for\n the \"LIB(dsname)\" parameter to point to the library to be queried.\n\n 05/31/2007 - V01.01.10\n\n INCREASED THE SIZE OF THE MODULE LENGTH DISPLAY FIELD AND THE\n EP ADDRESS DISPLAY FIELD FROM 6 to 8 HEX CHARACTERS.  THESE TWO\n FIELDS WERE ALSO EXPANDED IN THE 100 BYTE LINKAGE PARM RETURNED\n WHEN USING A SECOND LINKAGE RETURN PARAMETER FIELD IN THE CALLER\n PROGRAM (PROGRAM THAT CALLS MODLISTR).\n NOTE: THIS CHANGE WILL REQUIRE CHANGES TO THE CALLER PROGRAM SINCE\n THE SIZE OF THESE TWO FIELDS HAS BEEN CHANGED.\n\n EXAMPLE CALL FROM AN COBOL APPLICATION PROGRAM CALLING 'MODLISTR' AS\n A SUBROUTINE WITH TWO PARAMETERS:\n\n     //SYSPRINT DD  SYSOUT=*\n     //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB\n  where YOURPGM does...\n      01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.\n      01 WS-MODULE-NAME       PIC X(8).\n      01 WS-MODLISTR-RETURN-AREA.\n         05 WS-RA-MODNAME-LEN PIC S9(4) COMP.\n         05 WS-RA-MODNAME     PIC X(8).\n         05 WS-RA-LK-GR-DATE  PIC X(10).\n         05 WS-RA-LK-JUL-DATE PIC X(8).\n         05 WS-RA-LK-TIME     PIC X(8).\n         05 WS-RA-MODULE-LEN  PIC X(8).\n         05 WS-RA-AMODE       PIC X(3).\n         05 WS-RA-RMODE       PIC X(3).\n         05 WS-RA-APFCD       PIC X(2).\n         05 WS-RA-RENT        PIC X(2).\n         05 WS-RA-REUS        PIC X(2).\n         05 WS-RA-REFR        PIC X(2).\n         05 WS-RA-TTR         PIC X(6).\n         05 WS-RA-EPA         PIC X(8).\n         05 WS-RA-ORG-POE     PIC X(1).\n         05 WS-RA-TRUE-NAME   PIC X(8).\n         05 WS-RA-SSI         PIC X(8).\n         05 FILLER            PIC X(11).\n\n      CALL WS-MODLISTR USING WS-MODULE-NAME,\n                             WS-MODLISTR-RETURN-AREA.\n\n  (WS-MODULE-NAME must be padded with trailing blanks)\n  RESULTS ARE NOT WRITTEN TO FILE SYSPRINT\n  Instead, the results are returned in WS-MODLISTR-RETURN-AREA\n  (a 100 byte return parameter from MODLISTR).\n\n  From an Assembler program:\n      MODNAME   DS  CL8\n      RETNAREA  DS  CL100\n      CALL MODLISTR,(MODNAME,RETNAREA),VL\n\n 03/19/2007 - V01.01.09\n\n CORRECTED ERROR WHEN REASON CODE 83000514 IS RETURNED FROM THE\n BINDER INCLUDE FUNCTION.  ALLOW \"MODULE NOT FOUND IN LIBRARY\"\n MESSAGE TO BE DISPLAYED.\n\n 02/09/2007 - V01.01.08\n\n CORRECTED THE ERROR DIAGNOSTICS DISPLAY FOR A FAILED BINDER INCLUDE\n FUNCTION.\n\n 01/02/2007 - V01.01.07\n\n ADDED THE 'CALLMODL' AND 'BIGLGET' REXX EXECS FOR TESTING.\n ADDED SSI INFORMATION DISPLAY.\n\n 09/27/2006 - V01.01.06\n\n CORRECTED THE RELOCATION OF THE RDJFCB MACRO.  IT WORKED OK AS\n IT WAS.  I WAS USING FILED 'JFCBAR' AS THE MACRO RELOCATE AREA AND\n FOR THE WORK BUFFER AREA.  I BROKE THIS UP INTO TWO FIELDS.\n\n 08/28/2006 - V01.01.05\n\n ADDED A MACRO CALLED \"HOWCALLD\" TO BE USED IN PROGRAM \"MODLISTR\".\n THE MACRO DETERMINS HOW THE PROGRAM WAS CALLED BY THE CALLER.\n\n Modification Level: V01.01.04\n\n Corrected the spelling of a few comments in the code.\n\n Modification Level: V01.01.03\n\n THIS PROGRAM ISSUES THE IEWBIND (BINDER) MACRO TO OBTAIN LINK-EDIT\n INFORMATION FOR DISPLAY FOR A PARTICULAR LOAD MODULE MEMBER AND\n DISPLAYS IT IN ISPF BROWSE.\n\n THE MODLIST EXEC CALLS THIS PROGRAM - TKMILLE 05/31/2006\n\n     Examples:  MODLIST  modulename\n                MODLIST  modulename   { dup }\n                ML       modulename\n\n CHANGE LOG (See member $CHANGES).\n\n 06/16/2006 - V01.01.01 Base Code\n\n I PICKED THIS PROGRAM UP FROM THE WWW.XEPHON.COM WEB SITE (PROGRAM\n 'POBJINFO' AND ADDED TO IT.  ADDED A CALL TO PROGRAM 'JUL2GREG'\n TO OBTAIN THE GREGORIAN DATE FROM THE JULIAN LINK-EDIT DATE.\n CHANGED THE 'TPUT' MACROS TO 'PUT' TO SYSPRINT MACROS.\n\n ADDED 3 ADDITIONAL LINES OF DISPLAY (SEE BELOW) INCLUDING THE\n FOLLOWING FIELDS OBTAINED FROM THE PDS OR PDS/E MEMBER'S DIRECTORY\n RECORD:\n\n AMODE, RMODE, APF AUTH CODE, REENTRANT ATTR, REUSE ATTR, REFRESH\n ATTR, TTR LOCATION, EPA ADDRESS, MEMBER'S DASD RESIDENT LOCATION\n VOLSER/DATASET NAME, DSORG OF LIBRARY, AND ALIAS' TRUENAME (IF\n THE MEMBER IS AN ALIAS NAME.\n\n IT DISPLAYS 3 OR 4 LINES OF INFORMATION ON DDNAME 'SYSPRINT'\n (4 LINES IF THE MEMBER IS AN ALIAS NAME):\n TO A WORK DATASET USING ISPF BROWSE TO DISPLAY THE RESULTS.\n\n   MEMBERNAME, LINKEDIT DATE (BOTH JULIAN AND GREGORIAN DATE),\n   LINKEDIT TIME, LENGTH OF THE LOAD MODULE, AMODE, RMODE,\n   APF AUTH CODE, REENTRANT ATTR, REUSE ATTR, REFRESH ATTR,\n   TTR LOCATION, EPA ADDRESS, MEMBER'S DASD RESIDENT LOCATION\n   VOLSER/DATASET NAME, DSORG OF LIBRARY, AND ALIAS' TRUENAME (IF\n   THE MEMBER IS AN ALIAS NAME (DISPLAYED ON LINE 4).\n\nmmmmmmmm Linked on 05/31/2006 (2006.151) at 14:35:52  LENGTH: 000012\nmmmmmmmm AM:  24 RM:  24 AC: 01 RN RU RF TTR:XXXXXX EPADDR: XXXXXX\nmmmmmmmm VOL/DSN: IPL001 DSN=SYS1.LINKLIB                   ORG: PO\nmmmmmmmm SSI: XXXXXXXX   *** ALIAS NAME FOR MEMBER TTTTTTTT ***\n\n   ALSO MODIFIED THE PROGRAM TO BE REENTRANT.\n\n   OUTPUT FILES: //SYSPRINT (3 or 4 Line Display)\n\n   RETURN CODES FROM MODLISTR:\n\n   0      => Successful call to MODLISTR\n   4,8,12 => Various other return codes/reason codes from IEWBIND,\n               OBTAIN, AND RDJFCB macros.\n\n  Added Mark Zelden's \"LPROG\" exec code into this MODLIST exec\n  to search for a module in the dynamic LNKLST and in the LPA.\n  Therefore, a module in storage can be searched and displayed.\n  (or duplicate module entries in the LinkList and LPA).\n\n\n Please report any bugs to TERRY MILLER at Tkmille@ConocoPhillips.Com\n\n INSTALLATION INSTRUCTIONS:\n\n THE INSTALLATION INTRUCTIONS ARE IN MEMBER \"$INSTALL\"\n\n MEMBER NAMES AND DESCRIPTIONS:\n\n     $$DOC     - THE DOCUMENTATION MEMBER FOR THE \"MODLISTR\" FACILITY.\n\n     $CHANGES  - CHANGE LOG OF THIS FACILITY SINCE IT WAS WRITTEN.\n\n     @FILEXXX  - THE CBT INDEX MEMBER FOR THE \"MODLISTR\" FACILITY.\n\n     $INSTALL  - THE COMPLETE SET OF INSTALLATION PROCEDURES FOR\n                 THE \"MODLISTR\" FACILITY.\n\n      INSTALL  - THE INSTALLATION EXEC. THIS EXEC PROMPTS FOR\n                 RUNTIME INSTALL INFORMATION AND THEN ALLOCATES\n                 THE RUNTIME LIBRARIES.  SEE MEMBER \"$INSTALL\"\n                 FOR THE COMPLETE SET OF INSTALL INSTRUCTIONS.\n\n     INSTALL1  - JCL TO ASSEMBLE THE TWO ASSEMBLER SOURCE PROGRAMS\n                 USED BY THE \"MODLISTR\" FACILITY. SEE MEMBER \"$INSTALL\"\n                 FOR THE COMPLETE SET OF INSTALL INSTRUCTIONS.\n\n     INSTALL2  - JCL TO COPY THE \"MODLIST\" REXX EXEC TO YOUR\n                 FACILITY'S SYSPROC LIBRARY. SEE MEMBER \"$INSTALL\"\n                 FOR THE COMPLETE SET OF INSTALL INSTRUCTIONS.\n\n     INSTALL3  - JCL TO COPY THE \"MODLIST\" ISPF HELP PANEL TO YOUR\n                 FACILITY'S SYSHELP LIBRARY. SEE MEMBER \"$INSTALL\"\n                 FOR THE COMPLETE SET OF INSTALL INSTRUCTIONS.\n\n  Rexx Execs:\n\n      MODLIST  - THE INVOKING REXX EXEC.  THIS EXEC SEARCHES THE\n                 LINKLIST AND LPA FOR A MODULE NAME IN STORAGE (OR\n                 ALTERNATELY IN A LOAD LIBRARY SPECIFIED) AND\n                 DISPLAYS THE LINK-EDIT INFORMATION.\n\n                 THIS REXX EXEC WILL BE PLACED INTO A \"SYSPROC\"\n                 LIBRARY DURING THE INSTALL PROCESS WHERE IT CAN\n                 BE INVOKED FROM EITHER FOREGROUND OR BACKGROUND TSO.\n\n      ML       - THE ALIAS EXEC FOR MODLIST (FOR THOSE WHO LIKE VERY\n                 FEW KEYSTROKES).\n\n  Programs:\n\n\n      MODLISTR  - THE PROGRAM WHICH DISPLAYS THE LINK-EDIT INFORMATION\n                 FOR A GIVEN MODULENAME.  THIS MEMBER IS THE SOURCE\n                 CODE WHICH MUST BE ASSEMBLED.  THIS PROGRAM IS\n                 CALLED BY EXEC \"MODLIST\".\n\n      JUL2GREG  - THIS PROGRAM CONVERTS A JULIAN DATE (YYYYDDD) TO A\n                 GREGORIAN DATE (YYYYMMDD).  IT IS LINKED INTO\n                 MODULE 'MODLISTR'.  IF AN INVALID JULIAN DATE IS\n                 PASSED AS A PARM TO THIS PROGRAM, THE GREGORIAN\n                 DATE RETURNED WILL BE BLANKS AND THE PROGRAM WILL\n                 COMPLETE WITH RC=12.\n\n\n\n\n  MODLIST exec Syntax:\n\n            MODLIST modulename { DUP      }\n            ML                 { ALL      }\n                               { LPA      }\n                               { LINK     }\n                               { LIST     }\n                               { LIB(dsname)  }\n                                      {VOL(vvvvvv)     }\n                                      {UNIT(xxxxxxxx)  }\n\n\n      Modulename - The modulename to be searched.  This parameter\n                   must always be specified and must precede the\n                   subparameters.\n\n\n      Subparameter Values and Explanations:\n\n      DUP        - Include duplicate entries.  Look for the module\n                   more than one load library. If the LPA and LINK\n                   subparameters are not included, the facility\n                   will look for all modules having this name in the\n                   scope of the LPA libraries and in the Linklist.\n\n      ALL        - Same as DUP.\n\n      LPA        - Look for the module in the LPA list of load\n                   libraries.  If the subparameter DUP or ALL is\n                   also included, it will list all of the entries\n                   with this modulename within the scope of the\n                   LPA List of load libraries.\n\n      LINK       - Look for the module in the LinkList of load\n                   libraries.  If the subparameter DUP or ALL is\n                   also included, it will list all of the entries\n                   with this modulename within the scope of the\n                   LinkList of load libraries.\n\n      LIST       - This subparameter will list all of the LPA\n                   libraries and LinkList libraries.  When this\n                   subparamter is specified, the modulename must\n                   also be included ahead of the LIST parameter.\n                   However, the modulename parameter is ignored, so\n                   it can be a dummy modulename such as 'X'.\n\n      LIB(dsname)- This subparameter tells the facilitiy to search\n                   only this Load Library for the modulename.\n\n      VOL(vvvvvv)- This subparameter can be used with the LIB\n                   subparameter to specify the Volser that the\n                   specified library resides on.\n\n      UNIT(xxxxx)- This subparameter can be used with the LIB and\n                   VOL subparameters to specify the UNIT of the\n                   specified Volser of the library.\n\n\n\n ASSUMPTIONS\n -----------\n\n   THIS FACILITY ASSUMES THE USE OF THE HIGH-LEVEL ASSEMBLER TO\n   ASSEMBLE THE TWO SOURCE PROGRAMS.\n\n   REXX EXEC 'CALLMODL' (USED FOR TESTING PROGRAM MODLISTR) ASSUMES\n   THAT THE EXTENDED DYNAMIC STEPLIB FACILITY PROVIDED BY CA-TSOPLUS\n   IS INSTALLED TO GIVE AN ALLOCATION FOR DDNAME \"STEPLIBX\".\n   OTHERWISE THE USER MUST CODE HIS OWN STEPLIB ALLOCATION IN LIEU\n   OF USING CA-TSOPLUS'S SOLUTION.\n\n\n CERTIFICATION\n -------------\n\n BATCH:\n\n   IT HAS BEEN CERTIFIED WITH Z/OS 1.7.\n\n PROBLEM REPORTING\n -----------------\n\n PLEASE REPORT ANY BUGS OR SUGGESTIONS FOR IMPROVEMENT TO:\n        TERRY MILLER AT Tkmille@ConocoPhillips.com\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CHANGES": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x016\\x00\\x02\\x01\\x054\\x7f\\x01\\x10\\x11o\\x11$\\x00\\xe0\\x00\\x01\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.54", "flags": 0, "createdate": "2005-12-13T00:00:00", "modifydate": "2010-04-26T11:24:02", "lines": 224, "newlines": 1, "modlines": 0, "user": "TKMILLE"}, "text": "                 MODLISTR Version Change History\n\n 04/26/2010 - V01.01.14\n\n Fixed a bug in the MODLIST Rexx Exec.  Changed the sysid\n (system name) from 3 characters displayed to 8 characters.\n\n 04/06/2010 - V01.01.13\n\n Fixed a bug in the MODLISTR program.  It was not freeing buffer\n storage obtained by the INITBUF function. Corrected the storage\n leak by adding a FREEBUF function to the program:\n    IEWBUFF FUNC=INITBUF\n\n 01/26/2010 - V01.01.12\n\n Fixed a bug in the MODLIST exec.\n\n 01/21/2010 - V01.01.12\n\n Modified MODLIST exec to use a temporary file for browsing the\n results with ISPF browse.\n\n 06/12/2007 - V01.01.11\n\n ADDED \"DA(dsname)\" and DSN((dsname)\" keyword paramters to the\n \"MODLIST\" Rexx exec to be used as alternate keyword parameters for\n the \"LIB(dsname)\" parameter to point to the library to be queried.\n\n 05/31/2007 - V01.01.10\n\n INCREASED THE SIZE OF THE MODULE LENGTH DISPLAY FIELD AND THE\n EP ADDRESS DISPLAY FIELD FROM 6 to 8 HEX CHARACTERS.  THESE TWO\n FIELDS WERE ALSO EXPANDED IN THE 100 BYTE LINKAGE PARM RETURNED\n WHEN USING A SECOND LINKAGE RETURN PARAMETER FIELD IN THE CALLER\n PROGRAM (PROGRAM THAT CALLS MODLISTR).\n NOTE: THIS CHANGE WILL REQUIRE CHANGES TO THE CALLER PROGRAM SINCE\n THE SIZE OF THESE TWO FIELDS HAS BEEN CHANGED.\n\n EXAMPLE CALL FROM AN COBOL APPLICATION PROGRAM CALLING 'MODLISTR' AS\n A SUBROUTINE WITH TWO PARAMETERS:\n\n     //SYSPRINT DD  SYSOUT=*\n     //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB\n  where YOURPGM does...\n      01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.\n      01 WS-MODULE-NAME       PIC X(8).\n      01 WS-MODLISTR-RETURN-AREA.\n         05 WS-RA-MODNAME-LEN PIC S9(4) COMP.\n         05 WS-RA-MODNAME     PIC X(8).\n         05 WS-RA-LK-GR-DATE  PIC X(10).\n         05 WS-RA-LK-JUL-DATE PIC X(8).\n         05 WS-RA-LK-TIME     PIC X(8).\n         05 WS-RA-MODULE-LEN  PIC X(8).\n         05 WS-RA-AMODE       PIC X(3).\n         05 WS-RA-RMODE       PIC X(3).\n         05 WS-RA-APFCD       PIC X(2).\n         05 WS-RA-RENT        PIC X(2).\n         05 WS-RA-REUS        PIC X(2).\n         05 WS-RA-REFR        PIC X(2).\n         05 WS-RA-TTR         PIC X(6).\n         05 WS-RA-EPA         PIC X(8).\n         05 WS-RA-ORG-POE     PIC X(1).\n         05 WS-RA-TRUE-NAME   PIC X(8).\n         05 WS-RA-SSI         PIC X(8).\n         05 FILLER            PIC X(11).\n\n      CALL WS-MODLISTR USING WS-MODULE-NAME,\n                             WS-MODLISTR-RETURN-AREA.\n\n  (WS-MODULE-NAME must be padded with trailing blanks)\n  RESULTS ARE NOT WRITTEN TO FILE SYSPRINT\n  Instead, the results are returned in WS-MODLISTR-RETURN-AREA\n  (a 100 byte return parameter from MODLISTR).\n\n  From an Assembler program:\n      MODNAME   DS  CL8\n      RETNAREA  DS  CL100\n      CALL MODLISTR,(MODNAME,RETNAREA),VL\n\n 03/19/2007 - V01.01.09\n\n CORRECTED ERROR WHEN REASON CODE 83000514 IS RETURNED FROM THE\n BINDER INCLUDE FUNCTION.  ALLOW \"MODULE NOT FOUND IN LIBRARY\"\n MESSAGE TO BE DISPLAYED.\n\n 02/09/2007 - V01.01.08\n\n CORRECTED THE ERROR DIAGNOSTICS DISPLAY FOR A FAILED BINDER INCLUDE\n FUNCTION.\n\n 01/02/2007 - V01.01.07\n\n ADDED THE 'CALLMODL' AND 'BIGLGET' REXX EXECS FOR TESTING.\n ADDED SSI INFORMATION DISPLAY.\n\n 09/27/2006 - V01.01.06\n\n CORRECTED THE RELOCATION OF THE RDJFCB MACRO.  IT WORKED OK AS\n IT WAS.  I WAS USING FILED 'JFCBAR' AS THE MACRO RELOCATE AREA AND\n FOR THE WORK BUFFER AREA.  I BROKE THIS UP INTO TWO FIELDS.\n\n 08/28/2006 - V01.01.05\n\n ADDED A MACRO CALLED \"HOWCALLD\" TO BE USED IN PROGRAM \"MODLISTR\".\n THE MACRO DETERMINS HOW THE PROGRAM WAS CALLED BY THE CALLER.\n\n 08/03/2006 - V01.01.04\n\n   Corrected the spelling of a few comments in the code.\n\n 07/19/2006 - V01.01.03\n\n   Fixed a halfword alignment error with the SSI segment present\n   in a PDS directory.  Caused the APF code to be reported\n   incorrectly.\n\n 06/23/2006 - V01.01.02\n\n   Added support for calling MODLISTR as a subroutine from\n   another program.  The first parm is the membername to be\n   queried.  The second parm (optional), if included, will cause\n   program MODLISTR to return the results in a 100 byte user data\n   return area (See RETURN_INFO) in lieu of displaying the\n   results in file SYSPRINT.\n\n   SUPPORTED METHODS TO INVOKE MODLISTR:\n\n   1>    FROM REXX OR CLIST IN TSOE ENVIRONMENT:\n         \"ALLOC FI(SYSPRINT) DA(*) REUSE\"\n         \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"\n\n         \"CALL 'MODLISTR.LOADLIB(MODLISTR)' '\"MEMBERNAME\"'\"\n         MODLISTR_RC  = RC\n\n   2>    FROM REXX TSOE ENVIRONMENT AS LINKMVS:\n         \"ALLOC FI(SYSPRINT) DA(*) REUSE\"\n         \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"\n\n         ADDRESS \"LINKMVS\" 'MODLISTR MEMBERNAME'\n         MODLISTR_RC  = RC\n\n   3>    FROM REXX TSOE ENVIRONMENT AND RETURN THE RESULTS IN A\n         REXX VARIABLE (SEE WS-MODLISTR-RETURN-AREA FIELD BELOW\n         FOR THE VARIABLE STRING FORMAT) AS LINKPGM:\n\n         \"ALLOC FI(SYSPRINT) DA(*) REUSE\"\n         \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"\n\n         ADDRESS \"LINKPGM\" 'MODLISTR MEMBERNAME RETURN_AREA'\n         MODLISTR_RC  = RC\n\n   4>    CALL 'MODLISTR' DIRECTLY AS A BATCH PROGRAM:\n         //STEPX    EXEC PGM=MODLISTR,PARM=MODULENAME\n         //SYSPRINT DD  SYSOUT=*\n         //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB\n\n   5>    FROM AN APPLICATION PROGRAM CALLING 'MODLISTR' AS A\n         SUBROUTINE WITH ONE PARAMETER:\n         //STEPX    EXEC PGM=YOURPGM\n         //SYSPRINT DD  SYSOUT=*\n         //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB\n      WHERE YOURPGM DOES...\n          01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.\n          01 WS-MODULE-NAME       PIC X(8).\n          CALL WS-MODLISTR USING WS-MODULE-NAME.\n      (WS-MODULE-NAME MUST BE PADDED WITH TRAILING BLANKS)\n      RESULTS ARE WRITTEN TO FILE SYSPRINT\n\n          MODNAME   DS  CL8\n          CALL MODLISTR,(MODNAME),VL\n\n   6>    FROM AN APPLICATION PROGRAM CALLING 'MODLISTR' AS A\n         SUBROUTINE WITH TWO PARAMETERS:\n         //SYSPRINT DD  SYSOUT=*\n         //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB\n      where YOURPGM does...\n          01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.\n          01 WS-MODULE-NAME       PIC X(8).\n          01 WS-MODLISTR-RETURN-AREA.\n             05 WS-RA-MODNAME-LEN PIC S9(4) COMP.\n             05 WS-RA-MODNAME     PIC X(8).\n             05 WS-RA-LK-GR-DATE  PIC X(10).\n             05 WS-RA-LK-JUL-DATE PIC X(8).\n             05 WS-RA-LK-TIME     PIC X(8).\n             05 WS-RA-MODULE-LEN  PIC X(6).\n             05 WS-RA-AMODE       PIC X(3).\n             05 WS-RA-RMODE       PIC X(3).\n             05 WS-RA-APFCD       PIC X(2).\n             05 WS-RA-RENT        PIC X(2).\n             05 WS-RA-REUS        PIC X(2).\n             05 WS-RA-REFR        PIC X(2).\n             05 WS-RA-TTR         PIC X(6).\n             05 WS-RA-EPA         PIC X(6).\n             05 WS-RA-ORG-POE     PIC X(1).\n             05 WS-RA-TRUE-NAME   PIC X(8).\n             05 FILLER            PIC X(23).\n\n          CALL WS-MODLISTR USING WS-MODULE-NAME,\n                                 WS-MODLISTR-RETURN-AREA.\n\n      (WS-MODULE-NAME must be padded with trailing blanks)\n      RESULTS ARE NOT WRITTEN TO FILE SYSPRINT\n      Instead, the results are returned in WS-MODLISTR-RETURN-AREA\n      (a 100 byte return parameter from MODLISTR).\n\n          MODNAME   DS  CL8\n          RETNAREA  DS  CL100\n          CALL MODLISTR,(MODNAME,RETNAREA),VL\n\n      (idea submitted by C. Perkerson).\n   ------------------------------------------------------------------\n\n ADDED A CHECK FOR A WARNING ISSUE FROM THE IEWBIND MACRO\n (FUNCTION=INCLUDE).  IF THE RC FROM THE IEWBIND MACRO IS 4 AND\n THE REASON CODE IS 8033526, THEN IGNORE THE WARNING EXCEPTION.\n\n SEE IBM MANUAL SA22-7644-02 FOR RETURN CODE / REASON CODES\n   RC=4 REAS=83000526 IS ACCEPTABLE - WRONG LENGTH PDS DIRECTORY\n \"AN UNUSUAL CONDITION WAS ENCOUNTERED WHILE PROCESSING AN INPUT MODULE\"\n\n 05/31/2006 - V01.01.01  - BASE RELEASE\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$INSTALL": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00#\\x01\\x06\\x02\\x7f\\x01\\x10\\x11o\\x112\\x00c\\x00\\x01\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "2006-01-27T00:00:00", "modifydate": "2010-04-26T11:32:23", "lines": 99, "newlines": 1, "modlines": 0, "user": "TKMILLE"}, "text": "\nInstallation Instructions:\n\n1) After RECEIVING THE XMIT file into a Dataset (You have already done\n   that or you would not be looking at this member), go to SPF option\n   6 command line and enter this command:\n\n      EXEC  'XXXXXXXX.MODLISTR(INSTALL)'\n\n   Where XXXXXXXX is the HLQ of this dataset.  The INSTALL Rexx exec\n   will tailor and copy the MODLISTR members to your runtime libraries\n   after prompting you for these 4 pieces of information:\n\n       1) Output Dataset name containing the PDS members\n          created by the RECEIVE INDS command (and is also\n          the dataset which contains this Rexx Exec).\n       2) The HLQ (High-Level Qualifier) to be used to install\n          the MODLISTR runtime libraries.\n       3) The Volser to be used to allocate the runtime\n          libraries and Logfile.\n       4) The Dataset name of the exec library concatenated\n          to ddname SYSPROC to copy the MODLIST exec into\n          for foreground invocation of exec MODLIST.\n\n   After prompting for these 3 pieces of information\n   it will tailor the install file members and the\n   user will then be ready to continue the install of\n   this product.\n\n2) After the INSTALL exec completes, the following members should\n   reside in the following libraries:\n\n        XXXXXXXX.MODLISTR.CNTL (Where XXXXXXXX is HLQ above):\n\n            INSTALL1\n            INSTALL2\n            INSTALL3\n\n        XXXXXXXX.MODLISTR.EXEC (Where XXXXXXXX is HLQ above):\n\n            ML\n            MODLIST\n            BIGLGET\n            BIGLET\n            CALLMODL\n            TSOTRAP\n\n        XXXXXXXX.MODLISTR.SOURCE and XXXXXXXX.MODLISTR.LOADLIB\n        should both be empty.\n\n\n3) Submit the following job to assemble the two programs used by\n   the MODLISTR facility. The assemble and link should recieve\n   a return code 0.  You will have to insert your installation's\n   jobcard before you submit the job.\n\n      SUB  'XXXXXXXX.MODLISTR.CNTL(INSTALL1)'\n\n   This job assembles the two programs used by the MODLISTR facility:\n\n        MODLISTR\n        JUL2GREG\n\n   Note, the object modules for these are also included in you would\n   prefer to just Link the modules.\n\n        MODLISTR  - $OBJECT1\n        JUL2GREG  - $OBJECT2\n\n4) Submit the following job to copy the MODLIST Rexx exec to your\n   SYSPROC concatenation library.  You will have to insert your\n   installation's jobcard before you submit the job.\n   You can optionally copy a second Rexx exec to your SYSPROC\n   concatenation library - Member ML.  This ML exec can front-end\n   the MODLIST exec if you want to invoke MODLIST with a shorter\n   alias-like name.\n\n      SUB  'XXXXXXXX.MODLISTR.CNTL(INSTALL2)'\n\n5) COPY and RENAME MEMBER 'XXXXXXXX.MODLISTR.CNTL(MODLISTH)' and\n   COPY and RENAME MEMBER 'XXXXXXXX.MODLISTR.CNTL(CALLMODH)'\n   into your ISPF facility Help library allocated to ddname\n   SYSHELP. Rename the member to MODLISTR using the following job.\n   You will have to insert your installation's jobcard before you\n   submit the job.\n\n      SUB  'XXXXXXXX.MODLISTR.CNTL(INSTALL3)'\n\n\n   You are now ready to use the facility.\n\n   From TSO, enter:\n\n      MODLIST  modulename\n      ML       modulename      (alias for MODLIST)\n\n      CALLMODL modulename  LIB(Library_Name)\n      CM       modulename  LIB(Library_Name)    (alias for MODLIST)\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$OBJECT1": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x11?\\x01\\x10\\x11?\\x17@\\x00t\\x00t\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-23T00:00:00", "modifydate": "2010-04-23T17:40:00", "lines": 116, "newlines": 116, "modlines": 0, "user": "TKMILLE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "$OBJECT2": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x10\\x11?\\x01\\x10\\x11?\\x17@\\x00\\x10\\x00\\x10\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-04-23T00:00:00", "modifydate": "2010-04-23T17:40:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "TKMILLE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "@FILE743": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04O\\x00F\\x01\\x10\\x12\\x0f\\x01\\x10\\x12\\x0f\\x11C\\x00\\x17\\x00\\x17\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf9@@@'", "ispf": {"version": "04.79", "flags": 0, "createdate": "2010-04-30T00:00:00", "modifydate": "2010-04-30T11:43:46", "lines": 23, "newlines": 23, "modlines": 0, "user": "CBT-479"}, "text": "//***FILE 743 is from Terry Miller and contains a facility to       *   FILE 743\n//*           List the LINK-EDIT (Binder) information for a given   *   FILE 743\n//*           Load Module in this format:                           *   FILE 743\n//*                                                                 *   FILE 743\n//*           Last Revision: 01/26/2010 V01.01.12                   *   FILE 743\n//*                                                                 *   FILE 743\n//*       MODLIST mmmmmmmm                                          *   FILE 743\n//*                                                                 *   FILE 743\n//*       mmmmmmmm Linked on 05/31/2006 (2006.151) at 14:35:52      *   FILE 743\n//*                LENGTH: 000001FA                                 *   FILE 743\n//*       mmmmmmmm AM:  24 RM:  24 AC: 01 RN RU RF TTR:XXXXXX       *   FILE 743\n//*                EPADDR: 00000000                                 *   FILE 743\n//*       mmmmmmmm VOL/DSN: IPL001 DSN=SYS1.LINKLIB                 *   FILE 743\n//*                ORG: PO                                          *   FILE 743\n//*       mmmmmmmm SSI: XXX  *** ALIAS NAME FOR MEMBER TTTTTTTT *** *   FILE 743\n//*                                                                 *   FILE 743\n//*       The load module can reside in the LinkList, LPA, or in    *   FILE 743\n//*       a specified load library (input to the MODLIST exec).     *   FILE 743\n//*                                                                 *   FILE 743\n//*       The report will be displayed in ISPF Browse.              *   FILE 743\n//*                                                                 *   FILE 743\n//*           email:  tkmille@conocophillips.com                    *   FILE 743\n//*                                                                 *   FILE 743\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AJUL2GRE": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x06\\x15\\x1f\\x01\\x07\\x00/!U\\x00\\x1d\\x01\\x15\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-05-31T00:00:00", "modifydate": "2007-01-02T21:55:51", "lines": 29, "newlines": 277, "modlines": 0, "user": "TKMILLE"}, "text": "//JUL2GREG JOB '                                               ', *LOS\n//  TIME=1440,MSGCLASS=Z,MSGLEVEL=1,NOTIFY=&SYSUID,REGION=0M\n//*PPJES LOS=5,MAN=TKM,PMED=M,AD='6D4 IC'\n//*MAIN LINES=(9999,W),FETCH=NONE,FAILURE=CANCEL,CLASS=SS\n//*MAIN CARDS=(9999,W,20)\n//*\n//ASSEMBLE EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSPUNCH DD DSN=&&LOADSET,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=SMPE.MODLISTR(JUL2GREG)\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASSEMBLE),\n//         PARM='LIST,LET,MAP,XREF,REUS,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//         DD DDNAME=SYSIN\n//SYSLIB   DD DISP=SHR,DSN=SMPE.MODLISTR.LOADLIB\n//SYSLMOD  DD DISP=SHR,DSN=SMPE.MODLISTR.LOADLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY JUL2GREG\n NAME  JUL2GREG(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AMODLIST": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00Y\\x01\\x06\\x15\\x1f\\x01\\x07\\x00/!U\\x00\\x1f\\x04h\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2006-05-31T00:00:00", "modifydate": "2007-01-02T21:55:59", "lines": 31, "newlines": 1128, "modlines": 0, "user": "TKMILLE"}, "text": "//AMODLIST JOB '                                               ', *LOS\n//  TIME=1440,MSGCLASS=Z,MSGLEVEL=1,NOTIFY=&SYSUID,REGION=0M\n//*PPJES LOS=5,MAN=TKM,PMED=M,AD='6D4 IC'\n//*MAIN LINES=(9999,W),FETCH=NONE,FAILURE=CANCEL,CLASS=SS\n//*MAIN CARDS=(9999,W,20)\n//*\n//ASSEMBLE EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SMPE.MODLISTR\n//SYSPUNCH DD DSN=&&LOADSET,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=SMPE.MODLISTR(MODLISTR)\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASSEMBLE),\n//         PARM='LIST,LET,MAP,XREF,REUS,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET\n//         DD DDNAME=SYSIN\n//SYSLIB   DD DISP=SHR,DSN=SMPE.MODLISTR.LOADLIB\n//SYSLMOD  DD DISP=SHR,DSN=SMPE.MODLISTR.LOADLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n INCLUDE SYSLIB(JUL2GREG)\n ENTRY MODLISTR\n NAME  MODLISTR(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BIGLET": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00X\\x01\\x063\\x9f\\x01\\x07\\x15o\\x150\\x00y\\x00Y\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "2006-12-05T00:00:00", "modifydate": "2007-06-05T15:30:58", "lines": 121, "newlines": 89, "modlines": 0, "user": "TKMILLE"}, "text": "/*************************************************************** REXX */\n/*                                                                    */\n/* MODULE NAME = BIGLET                                               */\n/*                                                                    */\n/* DESCRIPTIVE NAME = DISPLAY SYSTEM ID IN LARGE LETTERS              */\n/**********************************************************************/\n/*  MODULE  =  BIGLET                                                 */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 12/06/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 12/06/2006                         */\n/*                                                                    */\n/*  PURPOSE = This exec will call Rexx function BIGLGET to return     */\n/*            a string in large block letters (6 lines per block -    */\n/*            the 6th line is blank).   This Rexx exec will parse     */\n/*            the results and display the lines returned.             */\n/*            The maximum size of the string passed which will be     */\n/*            displayed in block letters is 11 characters.            */\n/*                                                                    */\n/*  Example Function Call to Rexx Function exec BIGLGET:              */\n/*                                                                    */\n/*      result  = BIGLGET(string)                                     */\n/*                                                                    */\n/*      result will have the returned value of:                       */\n/*                                                                    */\n/*      LINE001===>abcdefg..........<===LINE002===>abcdefg......<===  */\n/*      LINE003===>abcdefg..........<===LINE004===>abcdefg......<===  */\n/*      LINE005===>abcdefg..........<===LINE006===>             <===  */\n/*                                                                    */\n/*      Line 6 will contains spaces.  Each line will be from 1 to 80  */\n/*      characters in length and delimited as described above.        */\n/*                                                                    */\n/*  PARMS:  DEBUG  = The parameter which displays the statements as   */\n/*                   they are executed.                               */\n/**********************************************************************/\nArg parms\n\nTrace \"O\"\n\nuserid   = Userid()\nrtcd     = 0\n\ndebug     = \"\"\nnbr_words = words(parms)\n\nDo i = 1 to nbr_words\n   If ABBREV('DEBUG',word(parms,i),3) = 1  then Do\n      debug = \"DEBUG\"\n      parms = DELWORD(parms,i,1)\n      i = i - 1\n      iterate\n   End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nPARSE source . How_Called .\n\nenvirnmt = SYSVAR(\"sysenv\")\nnesting  = SYSVAR(\"sysnest\")\nsysicmd  = SYSVAR(\"sysicmd\")\nsyspcmd  = SYSVAR(\"syspcmd\")\nsysscmd  = SYSVAR(\"sysscmd\")\n\nIf envirnmt = \"BACK\" Then Signal Go_Display  /* Background Call ?     */\n\ntsotrap_flag = \"$$$TSOTRAP$$$\"  /* Tsotrap flag to be stored in parms */\nmy_exec      = sysicmd          /* Name of my Rexx Exec               */\nIf my_exec   = \"\" Then my_exec = \"WHOAMI\"   /* Insert name of my exec */\n\nIf SYSVAR(\"sysispf\") <> \"ACTIVE\"  Then Do\n /* Make a recursive call to this exec to invoke the ISPF environment */\n   parms = parms\" \"tsotrap_flag             /* Add tsotrap flag       */\n   \"ISPF CMD(%TSOTRAP\" my_exec parms \")\"\n   Return 0\nEnd\nElse Do\n  parm_word = WORDPOS(tsotrap_flag,parms)   /* Look for tsotrap flag  */\n  If parm_word = 0    Then Do\n    parms = parms\" \"tsotrap_flag            /* Add tsotrap flag       */\n    \"%TSOTRAP\" my_exec parms                /* Invoke TSOTRAP         */\n    Return 0\n  End\n  Else parms = DELWORD(parms,parm_word,1)   /* Remove tsotrap flag    */\nEnd\n\nnn      = 0\nstring  = Userid\nstring  = ARG(1)\n\nGet_Big_Block_Letters:\n\nresult      = BIGLGET(string)\nCall Display_Big_Block_Lines\n\nSignal  End_Up\n\nDisplay_Big_Block_Lines:\n\nparse_it    = result\n\nDo i = 1 to 999999\n  lit_start        = \"LINE\"||Right(i,3,\"0\")||\"===>\"\n  lit_end          = \"<===\"\n  pos_lit_st       = POS(lit_start,parse_it)\n  If pos_lit_st    = 0  Then LEAVE\n  pos_lit_end      = POS(lit_end,parse_it)\n  If pos_lit_end   = 0  Then LEAVE\n  line    = SUBSTR(parse_it,pos_lit_st + LENGTH(lit_start), ,\n                  pos_lit_end - pos_lit_st - LENGTH(lit_start))\n  Say line ;\n  parse_it   = SUBSTR(parse_it,pos_lit_end + LENGTH(lit_end), ,\n                  LENGTH(parse_it) - pos_lit_end - LENGTH(lit_end) +1)\nEnd\n\nReturn\n\nEnd_Up:\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BIGLGET": {"ttr": 786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x005\\x01\\x064\\x0f\\x01\\t\\x18\\x7f\\x10%\\x00\\x83\\x00\\x7f\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2006-12-06T00:00:00", "modifydate": "2009-07-06T10:25:35", "lines": 131, "newlines": 127, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*                                                                    */\n/*              BBBB   III   GGGG L      GGGG EEEEE TTTTT             */\n/*              B   B   I   G     L     G     E       T               */\n/*  MODULE  =   BBBB    I   G  GG L     G  GG EEEE    T               */\n/*              B   B   I   G   G L     G   G E       T               */\n/*              BBBB   III   GGGG LLLLL  GGGG EEEEE   T               */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 12/06/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 07/06/2009                         */\n/*                                                                    */\n/*  PURPOSE = This exec will receive a string and return it in        */\n/*            large block letters (6 lines per block - last line is   */\n/*            blank).                                                 */\n/*                                                                    */\n/*  Example Function Call to Rexx Function exec BIGLGET:              */\n/*                                                                    */\n/*      result  = BIGLGET(string)                                     */\n/*                                                                    */\n/*      result will have the returned value of:                       */\n/*                                                                    */\n/*      LINE001===>abcdefg..........<===LINE002===>abcdefg......<===  */\n/*      LINE003===>abcdefg..........<===LINE004===>abcdefg......<===  */\n/*      LINE005===>abcdefg..........<===LINE006===>             <===  */\n/*                                                                    */\n/*      The maximum size of the string passed which will be           */\n/*      displayed in block letters is 11 characters.                  */\n/*                                                                    */\n/*      Line 6 will contains spaces.  Each line will be from 1 to 80  */\n/*      characters in length and delimited as described above.        */\n/*                                                                    */\n/*  PARMS:  DEBUG  = The parameter which displays the statements as   */\n/*                   they are executed.                               */\n/*                                                                    */\n/**********************************************************************/\nArg parms\n\nTrace \"O\"\n\nuserid   = Userid()\nrtcd     = 0\n\ndebug     = \"\"\nnbr_words = words(parms)\n\nDo i = 1 to nbr_words\n   If ABBREV('DEBUG',word(parms,i),3) = 1  then Do\n      debug = \"DEBUG\"\n      parms = DELWORD(parms,i,1)\n      i = i - 1\n      iterate\n   End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nPARSE source . How_Called .\n\nIf How_Called = 'COMMAND' Then Do\n   Say \"This exec must be called as a Function or Subroutine Call ...\"\n   Return\nEnd\n\nenvirnmt = SYSVAR(\"sysenv\")\nnesting  = SYSVAR(\"sysnest\")\nsysicmd  = SYSVAR(\"sysicmd\")\nsyspcmd  = SYSVAR(\"syspcmd\")\nsysscmd  = SYSVAR(\"sysscmd\")\n\nInit_Big_Letters:\n\nT0='ABCDEFGHIJKLMNOPQRSTUVWXYZ#,$0123456789@%*/-()&+_\u00a2|>:;.?\"=!<\u00ac{ '\n\nT1=  '  A  BBBB  CCCCDDDD EEEEEFFFFF GGGGH   H III   JJJK  K L    M   M'\nT2=  ' A A B   BC    D   DE    F    G    H   H  I     J K K  L    MM MM'\nT3=  'A   ABBBB C    D   DEEEE FFFF G  GGHHHHH  I     J KK   L    M M M'\nT4=  'AAAAAB   BC    D   DE    F    G   GH   H  I  J  J K K  L    M   M'\nT5=  'A   ABBBB  CCCCDDDD EEEEEF     GGGGH   H III  JJ  K  K LLLLLM   M'\nT1=T1'N   NOOOOOPPPP  QQQ RRRR  SSSSTTTTTU   UV   VW   WX   XY   YZZZZZ'\nT2=T2'NN  NO   OP   PQ   QR   RS      T  U   UV   VW   W X X  Y Y    Z '\nT3=T3'N N NO   OPPPP Q Q QRRRR  SSS   T  U   UV   VW W W  X    Y    Z  '\nT4=T4'N  NNO   OP    Q  Q R  R     S  T  U   U V V WW WW X X   Y   Z   '\nT5=T5'N   NOOOOOP     QQ QR   RSSSS   T   UUU   V  W   WX   X  Y  ZZZZZ'\nT1=T1' # #       $$$$ 000   1  2222 3333 4  4 55555 666 77777 888  999 '\nT2=T2'#####     $ $  0  00 11      2    34  4 5    6       7 8   89   9'\nT3=T3' # #       $$$ 0 0 0  1     2  333 444445555 6666   7   888  9999'\nT4=T4'##### ,,    $ $00  0  1    2      3   4     56   6  7  8   8    9'\nT5=T5' # #   ,  $$$$  000  111 222223333    4 5555  666   7   888  999 '\nT1=T1' @@@ %%  %* * *    /        (  )    &&&   +         *    |   >   '\nT2=T2'@   @   %  ***    /        (    )  &      +        C*C   |    >  '\nT3=T3'@ @@   %  *****  /  -----  (    )   &&  +++++     C *    |     > '\nT4=T4'@     %    ***  /          (    )  &   &  +        C*C   |    >  '\nT5=T5' @@@@%  %%* * */            (  )    &&&&  +  _____  *    |   >   '\nT1=T1' ..   ..        ???  \" \"       ||     <        {{      '\nT2=T2' ..   ..       ?   ?     ===== ||    <         {{      '\nT3=T3'                  ?            ||   <   \u00ac\u00ac\u00ac\u00ac\u00ac  {{      '\nT4=T4' ..   ,,   ..    ?       =====       <      \u00ac  {{      '\nT5=T5' ..    ,   ..    ?             ..     <        {{      '\n\nline1 = \"\"\nline2 = \"\"\nline3 = \"\"\nline4 = \"\"\nline5 = \"\"\nline6 = \" \"\n\nBuild_Big_Block_Letters:\n\nstring = CENTER(Word(parms,1),11)\n\nDo i = 1 to LENGTH(string)\n  n = 1 + (INDEX(T0,TRANSLATE(SUBSTR(string,i,1))) -1) * 5\n  line1 = line1\" \"SUBSTR(T1,n,5)\n  line2 = line2\" \"SUBSTR(T2,n,5)\n  line3 = line3\" \"SUBSTR(T3,n,5)\n  line4 = line4\" \"SUBSTR(T4,n,5)\n  line5 = line5\" \"SUBSTR(T5,n,5)\nEnd\n\nline1  = \"LINE001===> \"||line1||\" <===\"\nline2  = \"LINE002===> \"||line2||\" <===\"\nline3  = \"LINE003===> \"||line3||\" <===\"\nline4  = \"LINE004===> \"||line4||\" <===\"\nline5  = \"LINE005===> \"||line5||\" <===\"\nline6  = \"LINE006===> \"||line6||\" <===\"\n\nEnd_Up:\nReturn line1 line2 line3 line4 line5 line6\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CALLMODH": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x07\\x00?\\x01\\x07\\x00?\\x085\\x00\\x18\\x00\\x18\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-01-03T00:00:00", "modifydate": "2007-01-03T08:35:21", "lines": 24, "newlines": 24, "modlines": 0, "user": "TKMILLE"}, "text": ")F FUNCTION - The CALLMODL exec is used to display Link-Edit (Binder)\n              information for a load module in a specific load\n              library.  The results are displayed on the screen.\n)X SYNTAX   -\n\n         CALLMODL   MODULENAME\n         CM\n                               { LIB(dsname)  }\n\n\n      Modulename - The modulename to be searched.  This parameter\n                   must always be specified and must precede any\n                   subparameters which are also specified.\n\n\n      Subparameter Values and Explanations:\n\n\n      LIB(dsname)- This subparameter tells the facilitiy to search\n                   this Load Library for the modulename.  If this\n                   subparameter is omitted, the facility will search\n                   in library 'SYS1.LINKLIB' as a default.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CALLMODL": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x003\\x01\\x07\\x00?\\x01\\x07\\x15\\x1f\\x17\\x06\\x00\\xe9\\x00\\xe4\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2007-01-03T00:00:00", "modifydate": "2007-05-31T17:06:33", "lines": 233, "newlines": 228, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX                                                              */\n/**********************************************************************/\n/*                                                                    */\n/*              CCCC   A   L     L     M   M OOOOO DDDD  L            */\n/*             C      A A  L     L     MM MM O   O D   D L            */\n/*  MODULE  =  C     A   A L     L     M M M O   O D   D L            */\n/*             C     AAAAA L     L     M   M O   O D   D L            */\n/*              CCCC A   A LLLLL LLLLL M   M OOOOO DDDD  LLLLL        */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# LAST UPDATE        TKMILLE 05/31/2007                         */\n/*                                                                    */\n/*  PURPOSE = This exec calls the MODLISTR program and returns        */\n/*            the argument string of link edit information            */\n/*            (100 bytes).                                            */\n/*                                                                    */\n/*            This is an alternative exec to the MODLIST exec.  It    */\n/*            can be used to test the MODLISTR program.  Returns      */\n/*            the link-edit information for a load module in a        */\n/*            linkage parameter (100 bytes) as if called by a program.*/\n/*            This exec requires the user to pass the load library    */\n/*            dataset name in addition to the load module name.       */\n/*                                                                    */\n/*  PARAMETERS:                                                       */\n/*                                                                    */\n/*            Member - The membername to query.  Must be the first    */\n/*                     parameter passed and must be a valid PDS or    */\n/*                     PDS/E member name in an executable Load Module.*/\n/*                                                                    */\n/*            LIB()  - The load library dataset name where the member */\n/*                     resides.  Must be a valid load library dataset */\n/*                     name.  You do not need to use tics or quotes   */\n/*                     around the dataset name.  If this parameter is */\n/*                     omitted, it will default to SYS1.LINKLIB.      */\n/*                                                                    */\n/*  Note: This exec assumes that CA-TSOPLUS is active on the system   */\n/*        in which the exec is executed.  This uses the extended      */\n/*        dynamic steplib allocation feature of CA-TSOPLUS.           */\n/*                                                                    */\n/*        It also calls exec BIGLGET as a REXX Function call to       */\n/*        return a string of data (less than 11 characters in length) */\n/*        in large block letters as a heading.                        */\n/*                                                                    */\n/**********************************************************************/\narg    parms\nAddress \"TSO\"\n\nenvirnmt = SYSVAR(\"sysenv\")\nnesting  = SYSVAR(\"sysnest\")\nsysicmd  = SYSVAR(\"sysicmd\")\nsyspcmd  = SYSVAR(\"syspcmd\")\nsysscmd  = SYSVAR(\"sysscmd\")\n\nmsg_stat = Msg(\"OFF\")\n\nmember   = \"\"\nlib      = \"SYS1.LINKLIB\"\nlibdflt  = \"Y\"\nrtcd     = 0\n\ndebug     = \"\"\nnbr_words = WORDS(parms)\n\nDo i = 1 to nbr_words\n     Select\n         When i = 1                                  Then Do\n              member = WORD(parms,1)\n         End\n         When ABBREV(\"DEBUG\",WORD(parms,i),3) = 1    Then Do\n              debug = \"DEBUG\"\n              parms = DELWORD(parms,i,1)\n              i = i - 1\n              Iterate\n         End\n         Otherwise   Nop\n     End\nEnd\n\nIf member = \"\" Then Do\n   Say \"Member name was not passed ...\"\n   Say \"Member name must be the first parameter passed to CALLMODL\"\n   Say \"CALLMODL exec bypassed ...\"\n   rtcd = 12\n   Signal End_Up\nEnd\n\nIf Length(member) < 1 | Length(member) > 8   Then Do\n   Say \"Member Length is invalid ...  Should be 1-8 characters in\",\n       \"length\"\n   Say \"Member Name passed =>\" member \"is invalid\"\n   Say \"CALLMODL exec bypassed ...\"\n   rtcd = 12\n   Signal End_Up\nEnd\n\nmember = LEFT(member,8,\" \")\n\nparse var parms  \"LIB(\" parse_value \")\"\nIf libdflt = \"Y\" & parse_value <> \"\"    Then Do\n   lib   = parse_value\n   lib   = Strip(lib,b,\"'\")       /* remove enclosed ticks    */\n   lib   = Strip(lib,b,'\"')       /* remove quotes            */\n   libdflt  = \"N\"\nEnd\n\nparse var parms  \"DSN(\" parse_value \")\"\nIf libdflt = \"Y\" & parse_value <> \"\"    Then Do\n   lib   = parse_value\n   lib   = Strip(lib,b,\"'\")       /* remove enclosed ticks    */\n   lib   = Strip(lib,b,'\"')       /* remove quotes            */\n   libdflt  = \"N\"\nEnd\n\nIf Length(lib) < 1 | Length(lib) > 44  Then Do\n   Say \"Library Length is invalid ...  Should be 1-44 characters in\",\n       \"length\"\n   Say \"Library Name passed =>\" lib \"is invalid\"\n   Say \"CALLMODL exec bypassed ...\"\n   rtcd = 12\n   Signal End_Up\nEnd\n\nCall_MODLISTR:\n\nsteplibx_lib  = \"$XXXXXXXX.$MODLISTR.LOADLIB\"\n\"ALLOC FI(STEPLIBX) DA('\"steplibx_lib\"' ***) SHR REUSE\"\nsteplibx_allocation = tsopext\n\n/* If my new lib is already in the concatenation, back it out      */\nIf POS(\"'\"steplibx_lib\"'\",steplibx_allocation) > 0 Then\n    \"ALLOC FI(STEPLIBX) DA(\"steplibx_allocation\") SHR REUSE\"\n\n\"ALLOC FI(SYSPRINT) DUMMY REUSE\"\n\"ALLOC FI(IEWLIB)   DA('\"lib\"') SHR REUSE\"\n\nreturn_arg = Copies(\" \",100)\n\nADDRESS \"LINKPGM\" 'MODLISTR member return_arg'\nmodlistr_rc  = rc\n\nClear\n\nSay ;\n\ndflt_lit   = \"default\"\nIf libdflt = \"N\"  Then  dflt_lit = \"specified\"\n\nresult_b = BIGLGET(member)\nCall Display_Big_Block_Lines\n\nSay \"MODLISTR Return Code         =>\" modlistr_rc\nSay \"Member Name Passed           =>\" member\nSay \"Library Dataset Name Passed  =>\" lib\nIf  SUBSTR(return_arg,37,6) = \"      \"  Then Do\n    Say \"Module not found in \"dflt_lit\" Library '\"lib\"'\"\n    Say ;\n    Signal End_Up\nEnd\nIf  SUBSTR(return_arg,74,8) <> \"        \"  Then ,\n    Say \"Member Name Returned         =>\" SUBSTR(return_arg,3,8),\n            \"   (Alias Name for Member\" SUBSTR(return_arg,74,8)\nElse ,\n    Say \"Member Name Returned         =>\" SUBSTR(return_arg,3,8)\nSay \"Link Edit Date (GREGORIAN)   =>\" SUBSTR(return_arg,11,10)\nSay \"Link Edit Date (JULIAN)      =>\" SUBSTR(return_arg,21,8)\nSay \"Link Edit Time (hh:mm:ss)    =>\" SUBSTR(return_arg,29,8)\nSay \"Module Length  (in Hex)      =>\" SUBSTR(return_arg,37,8)\nSay \"AMODE                        =>\" SUBSTR(return_arg,45,3)\nSay \"RMODE                        =>\" SUBSTR(return_arg,48,3)\nSay \"APF Code                     =>\" SUBSTR(return_arg,51,2)\nIf  SUBSTR(return_arg,53,2) = \"  \" Then ,\n    Say \"RENT                         => N\"\nElse ,\n    Say \"RENT                         => Y\"\nIf  SUBSTR(return_arg,55,2) = \"  \" Then ,\n    Say \"REUS                         => N\"\nElse ,\n    Say \"REUS                         => Y\"\nIf  SUBSTR(return_arg,57,2) = \"  \" Then ,\n    Say \"REFR                         => N\"\nElse ,\n    Say \"REFR                         => Y\"\nSay \"TTR Address (in Hex)         =>\" SUBSTR(return_arg,59,6)\nSay \"Entry Point Address (in Hex) =>\" SUBSTR(return_arg,65,8)\nIf  SUBSTR(return_arg,73,1) = \" \" Then ,\n    Say \"Dataset Organization         => PO\"\nElse ,\n    Say \"Dataset Organization         => POE\"\nSay \"SSI Information              =>\" SUBSTR(return_arg,82,8)\nSay ;\n\nBypass_Print:\n\nAddress \"TSO\"\nIf steplibx_allocation  = \"\" Then\n     \"FREE  FI(STEPLIBX)\"\nElse \"ALLOC FI(STEPLIBX) DA(\"steplibx_allocation\") SHR REUSE\"\n\nSignal End_Up\n\nDisplay_Big_Block_Lines:\n\nparse_it    = result_b\n\nDo i = 1 to 999999\n  lit_start        = \"LINE\"||Right(i,3,\"0\")||\"===>\"\n  lit_end          = \"<===\"\n  pos_lit_st       = POS(lit_start,parse_it)\n  If pos_lit_st    = 0  Then LEAVE\n  pos_lit_end      = POS(lit_end,parse_it)\n  If pos_lit_end   = 0  Then LEAVE\n  line    = SUBSTR(parse_it,pos_lit_st + LENGTH(lit_start), ,\n                  pos_lit_end - pos_lit_st - LENGTH(lit_start))\n  If i = 3  Then Do\n     dateg   = Substr(date(u),1,6)||Substr(date(s),1,4)\n     sysid   = Left(MVSVAR(sysname),3,\" \")\n     line    = Overlay(sysid,line,01,03)\n     line    = Overlay(dateg,line,68,10)\n  End\n  If i = 4  Then Do\n     time    = TIME()\n     line    = Overlay(time,line,69,08)\n  End\n  Say line ;\n  parse_it   = SUBSTR(parse_it,pos_lit_end + LENGTH(lit_end), ,\n                  LENGTH(parse_it) - pos_lit_end - LENGTH(lit_end) +1)\nEnd\n\nReturn\n\nEnd_Up:\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HOWCALLD": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x06$\\x0f\\x01\\x06$\\x1f\\x07Y\\x00Y\\x00X\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-08-28T00:00:00", "modifydate": "2006-08-29T07:59:46", "lines": 89, "newlines": 88, "modlines": 0, "user": "TKMILLE"}, "text": "         MACRO ,\n&NAME    HOWCALLD &PARMCALL=\n.********************************************************************\n.*  Determine the caller's method of calling.  If called as a\n.*  subroutine then exit the macro.  If called as an Execute\n.*  Parameter, then branch to the Label &PARMCALL.\n.*\n.*  Reg 1 must contain the original address value that it contained\n.*  on entry to the program calling this macro. Reg 1 is not\n.*  modified by this macro.  This macro generates reentrant code.\n.*\n.*  Assumptions:\n.*    1) This macro will only be able to distinguish the calling\n.*       method if the first parameter's first two bytes are\n.*       EBCDIC characters.  If the first two characters are not\n.*       EBCDIC (i.e Binary or Packed Decimal or some other format),\n.*       this logic will not function properly and the resultant\n.*       branching will be subject to error.\n.*    2) This macro assumes that the user proper has R1 set to the\n.*       value that it contained on entry to the program issueing\n.*       this macro.  Otherwise, the resultant branching will be\n.*       subject to error.\n.*\n.*  Required Operands:\n.*    1) PARMCALL - The branch-to procedure label to branch to if\n.*                  the macro determines that the present program\n.*                  was called via an execution parameter linkage\n.*                  convention. This operand must not be omitted.\n.*\n.*  Example Call:\n.*         HOWCALLD PARMCALL=LABEL1\n.*\n.*  Registers Used:\n.*    R0       - Work register. It will be set to 0 on exit.\n.*    R1       - must have the same value as R1 on entry to the\n.*               present program. It is not altered by this macro.\n.*    R2-R14   - not used.\n.*    R15      - work register altered by this macro. It will be\n.*               set to 0 on exit.\n.*\n.********************************************************************\n.*\n         AIF   ('&PARMCALL' EQ '').MNOTE1\n.*\n         L     15,0(,1)             Load the address of the exec parm\n.*                                  exec parm or subroutine call ?\n         SR    0,0                  Zero Reg  0\n         ICM   0,B'0011',0(15)      Got Parameter or Ex parm Length ?\n         N     0,=X'FFFF7FFF'       Turn off the high order sign bit\n.*                                  since the first 2 bytes of the\n.*                                  EBCDIC parm would be a negative\n.*                                  number as viewed as a binary\n.*                                  number.  Make it a positive value.\n         CH    0,=H'1024'           If hw > 1024, then assume you are\n.*                                  called as a subroutine using\n.*                                  standard subroutine parm list.\n.*                                  If hw value is < 1024 then assume\n.*                                  that you are called using an\n.*                                  Execute parm (ll + parameters).\n         LA    0,0                  Zero Reg  0 w/o affecting cond code\n         LA    15,0                 Zero Reg 15 w/o affecting cond code\n         BNH   &PARMCALL            We have an Execute Parm Call\n.********************************************************************\n.*  I WAS WAS CALLED USING JCL-PARM STYLE LINKAGE\n.*  R1    => ADDRESS OF LINKAGE PARAMETER WHICH POINTS TO:\n.*         1 . A 2-BYTE HW LINKAGE LENGTH (LENGTH OF PARM)\n.*             Followed by the PARM DATA\n.*             EXEC PGM=XXXXXXXX,PARM=\n.*        |\n.*        ------> FullWord1 Address of the Linkage Parameter\n.*                    |\n.*                    ------->  Half-word_Len + PARM (1 - 100 bytes)\n.********************************************************************\n.*  OTHERWISE, I WAS CALLED USING STANDARD SUBROUTINE LINKAGE\n.*  R1    => ADDRESS OF PARM ADDRESS LIST WHICH POINTS TO\n.*           AN ARRAY OF PARM ADDRESSES:\n.*   |\n.*   -------> FullWord1 (PARM ADDRESS for Parameter 1)\n.*   ------->     FullWord2 (PARM ADDRESS for Parameter 2)\n.*                     |   | etc.\n.*                     |   |\n.*                     |   ---> Parameter 2\n.*                     ----> Parameter 1\n.*********************************************************************\n         MEXIT\n.MNOTE1  MNOTE 8,'PARMCALL BRANCH-TO PROCEDURE LABEL WAS OMITTED'\n         MEXIT\n.*\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSTALL": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01F\\x00V\\x01\\x06\\x02\\x7f\\x01\\x10\\x11\\x7f\\x08\"\\x02l\\x03 \\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.70", "flags": 0, "createdate": "2006-01-27T00:00:00", "modifydate": "2010-04-27T08:22:56", "lines": 620, "newlines": 800, "modlines": 0, "user": "TKMILLE"}, "text": "/*  REXX - INSTALL (Tailor and Install the MODLISTR facility)         */\n/**********************************************************************/\n/*                                                                    */\n/*              III  N   N  SSSS TTTTT   A   L     L                  */\n/*               I   NN  N S       T    A A  L     L                  */\n/*  MODULE  =    I   N N N  SSS    T   A   A L     L                  */\n/*               I   N  NN     S   T   AAAAA L     L                  */\n/*              III  N   N SSSS    T   A   A LLLLL LLLLL              */\n/*                                                                    */\n/*  #\u00a2# AUTHOR             TKMILLE                                    */\n/*  #\u00a2# CREATED            TKMILLE 05/31/2006                         */\n/*  #\u00a2# LAST UPDATE        TKMILLE 04/26/2010                         */\n/*                                                                    */\n/*  PURPOSE = This exec will input the MODLISTR library and will      */\n/*            tailor the members according to the information         */\n/*            input by the user.  The exec will prompt the user       */\n/*            for the following 4 pieces of information and will      */\n/*            then copy the members into your runtime libraries.      */\n/*                                                                    */\n/*            1) Output Dataset name containing the PDS members       */\n/*               created by the RECEIVE INDS command (and is also     */\n/*               the dataset which contains this Rexx Exec).          */\n/*            2) The HLQ (High-Level Qualifier) to be used to install */\n/*               the MODLISTR runtime libraries.                      */\n/*            3) The Volser to be used to allocate the runtime        */\n/*               libraries and Logfile.                               */\n/*            4) The Dataset name of the exec library concatenated    */\n/*               to ddname SYSPROC to copy the MODLISTR exec into     */\n/*               for foreground invocation of exec MODLISTR.          */\n/*                                                                    */\n/*            After prompting for these four  pieces of information   */\n/*            it will tailor the install file members and the         */\n/*            user will then be ready to continue the install of      */\n/*            this product.                                           */\n/*                                                                    */\n/*  PARMS:                                                            */\n/*  (Required Parms):                                                 */\n/*                                                                    */\n/*          None                                                      */\n/*                                                                    */\n/*  (Optional Parms):                                                 */\n/*                                                                    */\n/*          DEBUG  =      The parameter which displays the statements */\n/*                        as they are executed.                       */\n/*  User Prompt Inputs:                                               */\n/*                                                                    */\n/*    Receive Dsn  -      The user will be prompted for the PDS       */\n/*                        dataset created (output) by the             */\n/*                        RECEIVE INDS command.                       */\n/*                                                                    */\n/*          HLQ    -      The user will be prompted for the HLQ for   */\n/*                        the runtime libraries.                      */\n/*                                                                    */\n/*   Sysproc Lib   -      The user will be prompted for the SYSPROC   */\n/*                        library dataset name to copy the MODLISTR   */\n/*                        Rexx exec into for foreground invocation.   */\n/*                                                                    */\n/*  Return Codes:                                                     */\n/*                                                                    */\n/*    0   - Successful execution of the exec                          */\n/*   12   - Unsuccessful execution of the exec                        */\n/*                                                                    */\n/**********************************************************************/\nversion_level = \"V01.01.14\"\nArg parms\nTrace \"O\"\nmsg_stat        = Msg(\"OFF\")\n\ndebug    = \"\"\nDo i = 1 to words(parms)\n         If ABBREV(\"DEBUG\",word(parms,i),3) = 1  then Do\n            debug = \"DEBUG\"\n            parms = DELWORD(parms,i,1)\n            i = i - 1\n            iterate\n         End\nEnd\nIf debug = \"DEBUG\"  then Do\n   Trace \"I\"\nEnd\n\nsysid   = Left(MVSVAR(sysname),3,\" \")\nrtcd               = 0\ninput_file_count   = 0\nmiddle_quals       = \"MODLISTR\"\n\nClear\nGet_receive_dataset_Name:\n\ndateg   = Substr(date(u),1,6)||Substr(date(s),1,4)\n\nSay \"***************************************************************\"||,\n\"****************\"\nSay \"*                                                                \",\n    \"            *\"\nSay \"*  \"dateg\"                 M  O  D  L  I  S  T  R              \",\n    \" \"time()\"  *\"\nSay \"*  \"sysid\"                 I  N  S  T  A  L  L  A  T  I  O  N    \",\n    \"                *\"\nSay \"***************************************************************\"||,\n\"****************\"\n\nPrompt_for_RECEIVE_Dataset_Name:\n\nSay ;\nSay \"Enter the dataset name created by the RECEIVE INDS command\",\n    \"or enter a\"\nSay \"NULL ENTRY to QUIT\"\nSay ;\nPull receive_dataset\nIf receive_dataset = \"\"         | ,\n   receive_dataset = \"END\"      | ,\n   receive_dataset = \"QUIT\"                      Then Do\n     Say ;\n     Say \"User Terminated the INSTALL exec ...\"\n     Say ;\n     Signal End_Up\nEnd\n\nreceive_dataset = STRIP(receive_dataset,both,\"'\") /* remove tics   */\nreceive_dataset = STRIP(receive_dataset,both,'\"') /* remove quotes */\n\nEdit_RECEIVE_Dataset_Name:\n\ncatlged  = Sysdsn(\"'\"receive_dataset\"'\")\n\nIf catlged =  \"UNAVAILABLE DATASET\"                   Then Do\n   Say ;\n   Say \"RECEIVE dataset entered is allocated to another task ...\"\n   Say \"RECEIVE dataset Dataset Name => '\"receive_dataset\"'\"\n   Say \"Free the RECEIVE dataset and Try again later ...\"\n   Signal End_Up\nEnd\n\nIf catlged <> \"OK\"                                    Then Do\n   Say ;\n   Say \"RECEIVE dataset entered is not cataloged or is invalid ...\"\n   Say \"RECEIVE dataset Dataset Name => '\"receive_dataset\"'\"\n   Say \"Re-enter the RECEIVE Dataset Name\"\n   Say ;\n   Signal Prompt_for_RECEIVE_Dataset_Name\nEnd\n\n\"ALLOC FI(INSTALL) DA('\"receive_dataset\"') SHR REUSE\"\nalloc_sysproc_rc = rc\n\"FREE  FI(INSTALL)\"\n\nIf alloc_sysproc_rc <> 0 Then Do\n   Say \"RECEIVE dataset Dataset Name => '\"receive_dataset\"'\"\n   Say \" File INSTALL could not be allocated.  Re-enter the INSTALL\",\n       \"Dataset Name\"\n   Signal Prompt_for_receive_dataset_Name\nEnd\n\nCheck_for_INSTALL_member:\n\nlistdsi   = LISTDSI(\"'\"receive_dataset\"(INSTALL)'\" DIRECTORY NORECALL)\nlistdsi_rc = rc\n\nIf listdsi_rc <> 0  Then Do\n   Say \"RECEIVE dataset Dataset Name => '\"receive_dataset\"'\"\n   Say \" Member INSTALL could not be found in RECEIVE\",\n       \"Dataset\"\n   Say \"Re-enter the RECEIVE Dataset Name\"\n   Signal Prompt_for_receive_dataset_Name\nEnd\n\nPrompt_for_Runtime_HLQ:\n\nSay ;\nSay \"Enter the High-Level Qualifer to use to install MODLISTR\",\n    \"or enter a\"\nSay \"NULL ENTRY to QUIT\"\nSay ;\nPull HLQ_name\nIf HLQ_name = \"\"                | ,\n   HLQ_name = \"END\"             | ,\n   HLQ_name = \"QUIT\"                             Then Do\n     Say ;\n     Say \"User Terminated the INSTALL exec ...\"\n     Say ;\n     Signal End_Up\nEnd\n\nIf LENGTH(HLQ_name) >  8  Then Do\n   Say \" HLQ length must not exceed 8 characters in length\"\n   Signal Prompt_for_Runtime_HLQ\n   Say ;\nEnd\n\nPrompt_for_Runtime_Volser:\n\nSay ;\nSay \"Enter the Volser to allocate the install runtime libraries\",\n    \"or enter a\"\nSay \"NULL ENTRY to QUIT\"\nSay ;\nPull Volser_runtime\nIf Volser_runtime = \"\"          | ,\n   Volser_runtime = \"END\"       | ,\n   Volser_runtime = \"QUIT\"                       Then Do\n     Say ;\n     Say \"User Terminated the INSTALL exec ...\"\n     Say ;\n     Signal End_Up\nEnd\n\nIf LENGTH(Volser_runtime) > 6 Then Do\n   Say \" Volser length must not exceed 6 characters in length\"\n   Signal Prompt_for_Runtime_Volser\n   Say ;\nEnd\n\nPrompt_for_SYSPROC_dataset_Name:\n\nSay ;\nSay \"Enter the SYSPROC dataset name to use to copy the MODLISTR exec\",\n    \"into or\"\nSay \"enter a NULL ENTRY to QUIT\"\nSay ;\nPull sysproc_dataset\nIf sysproc_dataset = \"\"         | ,\n   sysproc_dataset = \"END\"      | ,\n   sysproc_dataset = \"QUIT\"                      Then Do\n     Say ;\n     Say \"User Terminated the INSTALL exec ...\"\n     Say ;\n     Signal End_Up\nEnd\n\nsysproc_dataset = STRIP(sysproc_dataset,both,\"'\") /* remove ticks  */\nsysproc_dataset = STRIP(sysproc_dataset,both,'\"') /* remove quotes */\n\nEdit_sysproc_dataset_Name:\n\ncatlged  = Sysdsn(\"'\"sysproc_dataset\"'\")\n\nIf catlged <> \"OK\"                                    Then Do\n   Say ;\n   Say \"SYSPROC dataset entered is not cataloged or is invalid ...\"\n   Say \"SYSPROC dataset Dataset Name => '\"sysproc_dataset\"'\"\n   Say \"Re-enter the SYSPROC Dataset Name\"\n   Say ;\n   Signal Prompt_for_sysproc_dataset_Name\nEnd\n\n\"ALLOC FI($$ABC$$$)  DA('\"sysproc_dataset\"') SHR REUSE\"\nalloc_sysproc_rc = rc\n\n\"FREE  FI($$ABC$$$)\"\n\nIf alloc_sysproc_rc <> 0 Then Do\n   Say \" File SYSPROC could not be allocated.  Re-enter the SYSPROC\",\n       \"Dataset Name\"\n   Signal Prompt_for_SYSPROC_dataset_Name\nEnd\n\nAllocate_Runtime_Libraries:\n\nhigh_quals    = HLQ_name||\".\"||middle_quals\n\nexec_lib      = high_quals||\".EXEC\"\ncntl_lib      = high_quals||\".CNTL\"\nmaclib        = high_quals||\".MACLIB\"\nsource        = high_quals||\".SOURCE\"\nloadlib       = high_quals||\".LOADLIB\"\n\n\"DELETE '\"||exec_lib||\"'       PURGE\"\n\"DELETE '\"||cntl_lib||\"'       PURGE\"\n\"DELETE '\"||maclib||\"'         PURGE\"\n\"DELETE '\"||source||\"'         PURGE\"\n\"DELETE '\"||loadlib||\"'        PURGE\"\n\n\"ALLOC DA('\"||exec_lib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(05)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_exec     = rc\nIf alloc_exec     <> 0 Then Do\n   Say \" Error allocating space for the Rexx EXEC library\"\n   Say \" Rexx EXEC library Dataset Name => \" exec_lib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||cntl_lib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_cntl     = rc\nIf alloc_cntl     <> 0 Then Do\n   Say \" Error allocating space for the CNTL library\"\n   Say \" CNTL library Dataset Name => \" cntl_lib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||maclib||\"')       NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_maclib   = rc\nIf alloc_maclib   <> 0 Then Do\n   Say \" Error allocating space for the MACLIB library\"\n   Say \" MACLIB library Dataset Name => \" maclib\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||source||\"')       NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(03,02) DIR(03)\",\n      \"RECFM(F B) LRECL(080) BLKSIZE(0)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_source   = rc\nIf alloc_source   <> 0 Then Do\n   Say \" Error allocating space for the SOURCE library\"\n   Say \" MACLIB library Dataset Name => \" source\n   Signal End_Up\n   Say ;\nEnd\n\n\"ALLOC DA('\"||loadlib||\"')     NEW REUSE  UNIT(SYSDA)\",\n      \"DSORG(PO) TRACKS SPACE(02,02) DIR(03)\",\n      \"RECFM(U) LRECL(0) BLKSIZE(32760)\",\n      \"VOLUME(\"||Volser_runtime||\")\"\nalloc_loadlib  = rc\nIf alloc_loadlib  <> 0 Then Do\n   Say \" Error allocating space for the LOAD library\"\n   Say \" LOAD library Dataset Name => \" loadlib\n   Signal End_Up\n   Say ;\nEnd\n\nAssign_Input_Output_Files:\n\ninput_file_count = input_file_count + 1\n\n\"EXECIO 0 DISKR INPUT    (FINIS\"\n\"EXECIO 0 DISKW OUTPUT   (FINIS\"\n\"FREE FI(INPUT,OUTPUT)\"\n\nSelect\n   When input_file_count  =   1                    Then Do\n        input_dataset = receive_dataset||\"(MODLIST)\"\n        output_dataset = HLQ_name||\".MODLISTR.EXEC(MODLIST)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n        Signal Allocate_Input_Output_Files\n   End\n   When input_file_count  =   2                    Then Do\n        input_dataset = receive_dataset||\"(ML)\"\n        output_dataset = HLQ_name||\".MODLISTR.EXEC(ML)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n        Signal Allocate_Input_Output_Files\n   End\n   When input_file_count  =   3                    Then Do\n        input_dataset = receive_dataset||\"(BIGLGET)\"\n        output_dataset = HLQ_name||\".MODLISTR.EXEC(BIGLGET)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n        Signal Allocate_Input_Output_Files\n   End\n   When input_file_count  =   4                    Then Do\n        input_dataset = receive_dataset||\"(CALLMODL)\"\n        output_dataset = HLQ_name||\".MODLISTR.EXEC(CALLMODL)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the EXEC runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n        Signal Allocate_Input_Output_Files\n   End\n   When input_file_count  =   5                    Then Do\n        input_dataset = receive_dataset||\"(INSTALL1)\"\n        output_dataset = HLQ_name||\".MODLISTR.CNTL(INSTALL1)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   6                    Then Do\n        input_dataset = receive_dataset||\"(INSTALL2)\"\n        output_dataset = HLQ_name||\".MODLISTR.CNTL(INSTALL2)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   7                    Then Do\n        input_dataset = receive_dataset||\"(INSTALL3)\"\n        output_dataset = HLQ_name||\".MODLISTR.CNTL(INSTALL3)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n           Say \"RECEIVE dataset name is the same as the CNTL runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   8                    Then Do\n        input_dataset = receive_dataset||\"(HOWCALLD)\"\n        output_dataset = HLQ_name||\".MODLISTR.MACLIB(HOWCALLD)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n          Say \"RECEIVE dataset name is the same as the MACLIB runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   9                    Then Do\n        input_dataset = receive_dataset||\"(JUL2GREG)\"\n        output_dataset = HLQ_name||\".MODLISTR.SOURCE(JUL2GREG)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n          Say \"RECEIVE dataset name is the same as the SOURCE runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   When input_file_count  =   10                   Then Do\n        input_dataset = receive_dataset||\"(MODLISTR)\"\n        output_dataset = HLQ_name||\".MODLISTR.SOURCE(MODLISTR)\"\n        If input_dataset = output_dataset          Then Do\n           Say ;\n          Say \"RECEIVE dataset name is the same as the SOURCE runtime\",\n               \"library\"\n           Say \"Rename the RECEIVE INDS dataset name to make it\",\n           Say \"unique and then try this exec again.\"\n           Say ;\n           Signal End_Up\n        End\n   End\n   Otherwise Do\n        input_file_count  = input_file_count - 1\n        Signal End_Up\n   End\nEnd\n\nAllocate_Input_Output_Files:\n\n\"ALLOC FI(INPUT)   DA('\"input_dataset\"') SHR REUSE\"\nalloc_input_rc = rc\n\nIf alloc_input_rc <> 0 Then Do\n   Say \" RECEIVE INDS File could not be allocated   ...\"\n   Say \" RECEIVE INDS File => '\"input_dataset\"'\"\n   Signal End_Up\nEnd\n\n\"ALLOC FI(OUTPUT)  DA('\"output_dataset\"') SHR REUSE\"\nalloc_output_rc = rc\n\nIf alloc_output_rc <> 0 Then Do\n   Say \" RUNTIME File could not be allocated   ...\"\n   Say \" RUNTIME File => '\"output_dataset\"'\"\n   Say \" Make sure that job INSTALL1 has ben run before issuing\",\n       \"this exec!\"\n   Signal End_Up\nEnd\n\nSay ;\nSay \"Reading Input Receive Dataset   => '\"||input_dataset||\"'\"\nSay \"Creating Output Runtime Dataset => '\"||output_dataset||\"'\"\nSay ;\n\ninput_count = 0\n\nRead_Input_dataset_Loop:\n\ninput_count = input_count + 1\n\n\"EXECIO 1 DISKR INPUT    (STEM input. \"\nexecio_rc    = rc\nIf execio_rc = 2   Then ,        /* On end of file - Swap Files    */\n   Signal Assign_Input_Output_Files\nIf execio_rc <> 0  Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKR Rexx command for file\"\n       \"INPUT !!!\"\n   Say \"File INPUT was not properly allocated or is invalid\"\n   Say \"Input File =>\" input_dataset\n   Say \"Input File Input count is \" input_count\n   Say \"EXECIO Return Code is \"execio_rc\" !!!\"\n   Say \"Exec INSTALL is Terminated Prematurely      ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nlen_input = LENGTH(input.1)\n\np1  = POS(\"$XXXXXXXX.$\",input.1)\nIf p1  > 0                                         Then Do\n   part_1   = \"\"\n   If p1 > 1 Then Do\n      part_1  = SUBSTR(input.1,1,p1 - 1)\n   End\n   part_2   = HLQ_name||\".\"\n   part_3   = SUBSTR(input.1,p1 + 11,len_input - p1 + 11)\n   output.1 = LEFT(part_1||part_2||part_3,80,\" \")\n   Signal Write_Output_Record\nEnd\n\np2  = POS(\"XXXXXXXX.\",input.1)\nIf p2  > 0                                         Then Do\n   part_1   = \"\"\n   If p2 > 1 Then Do\n      part_1  = SUBSTR(input.1,1,p2 - 1)\n   End\n   part_2   = HLQ_name||\".\"\n   part_3   = SUBSTR(input.1,p2 + 9,len_input - p2 + 9)\n   output.1 = LEFT(part_1||part_2||part_3,80,\" \")\n   Signal Write_Output_Record\nEnd\n\np3  = POS(\"$MY.SYSPROC.LIB$\",input.1)\nIf p3  > 0                                         Then Do\n   part_1   = \"\"\n   If p3 > 1 Then Do\n      part_1  = SUBSTR(input.1,1,p3 - 1)\n   End\n   part_2   = sysproc_dataset\n   part_3   = SUBSTR(input.1,p3 + 16,len_input - p3 + 16)\n   output.1 = LEFT(part_1||part_2||part_3,80,\" \")\n   Signal Write_Output_Record\nEnd\n\np4  = POS(\"$MY.RECEIVE.LIB$\",input.1)\nIf p4  > 0                                         Then Do\n   part_1   = \"\"\n   If p4 > 1 Then Do\n      part_1  = SUBSTR(input.1,1,p4 - 1)\n   End\n   part_2   = receive_dataset\n   part_3   = SUBSTR(input.1,p4 + 16,len_input - p4 + 16)\n   output.1 = LEFT(part_1||part_2||part_3,80,\" \")\n   Signal Write_Output_Record\nEnd\n\noutput.1 = input.1\n\nWrite_Output_Record:\n\n\"EXECIO 1 DISKW OUTPUT   (STEM output. \"\nexecio_rc    = rc\nIf execio_rc <> 0  Then Do\n   Say ;\n   Say \"Error executing the EXECIO DISKW Rexx command for file\"\n       \"OUTPUT  !!!\"\n   Say \"File OUTPUT was not properly allocated or is invalid\"\n   Say \"or an I/O error was encountered\"\n   Say \"Input I/O count is \" input_count\n   Say \"EXECIO Return Code is \"execio_rc\" !!!\"\n   Say \"Exec INSTALL is Terminated Prematurely      ...\"\n   rtcd = 12\n   Signal End_up\nEnd\n\nSignal Read_Input_dataset_Loop\n\nEnd_Up:\n\n\"EXECIO 0 DISKR INPUT    (FINIS\"\n\"EXECIO 0 DISKW OUTPUT   (FINIS\"\n\"FREE FI(INPUT,OUTPUT)\"\n\"FREE DA('\"||exec_lib||\"')\"\n\"FREE DA('\"||cntl_lib||\"')\"\n\"FREE DA('\"||maclib||\"')\"\n\"FREE DA('\"||source||\"')\"\n\"FREE DA('\"||loadlib||\"')\"\n\nSay ;\nSay \"Number of Runtime Files Output =>\" input_file_count\nSay ;\nSay \"INSTALL exec return code is    =>\" rtcd\n\nReturn rtcd\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL1": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x009\\x01\\x06\\x02\\x7f\\x01\\x10\\to\\x15R\\x007\\x001\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2006-01-27T00:00:00", "modifydate": "2010-04-06T15:52:39", "lines": 55, "newlines": 49, "modlines": 0, "user": "TKMILLE"}, "text": "//INSTALL1 JOB ' ASSEMBLE THE TWO SOURCE PROGRAMS              ',\n//     TIME=(2,00),REGION=0M\n//*\n//* ASSEMBLE AND LINK THE \"JUL2GREG\" AND \"MODLISTR\" PROGRAMS\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//ASMJULGR EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSPUNCH DD DSN=&&OBJECT2,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.SOURCE(JUL2GREG)\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASMJULGR),\n//         PARM='LIST,LET,MAP,XREF,REUS,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&OBJECT2\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.LOADLIB\n//SYSLIB   DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.LOADLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n ENTRY JUL2GREG\n NAME  JUL2GREG(R)\n/*\n//ASMMODLS EXEC PGM=ASMA90,\n//         PARM='DECK,NOOBJECT,LINECOUNT(55)'\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.MACLIB\n//SYSPUNCH DD DSN=&&OBJECT1,DISP=(NEW,PASS,DELETE),UNIT=SYSDA,\n//         SPACE=(3200,(400,050),RLSE),\n//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)\n//SYSIN    DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.SOURCE(MODLISTR)\n//*\n//LINKEDIT EXEC PGM=IEWL,COND=(5,LT,ASMMODLS),\n//         PARM='LIST,LET,MAP,XREF,REUS,RENT'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&OBJECT1\n//         DD DDNAME=SYSIN\n//SYSLMOD  DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.LOADLIB\n//SYSLIB   DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.LOADLIB\n//SYSUT1   DD UNIT=SYSDA,SPACE=(23476,(150,50),RLSE)\n//SYSIN    DD *\n INCLUDE SYSLIB(JUL2GREG)\n ENTRY MODLISTR\n NAME  MODLISTR(R)\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL2": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x17\\x01\\x06\\x02\\x7f\\x01\\x10\\x11\\x7f\\x08$\\x00 \\x00\\r\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2006-01-27T00:00:00", "modifydate": "2010-04-27T08:24:17", "lines": 32, "newlines": 13, "modlines": 0, "user": "TKMILLE"}, "text": "//INSTALL2 JOB ' COPY THE MODLIST EXEC TO YOUR SYSPROC LIBRARY ',\n//     TIME=(2,00),REGION=0M\n//*\n//* COPY THE \"MODLIST\" EXEC TO YOUR SYSPROC LIBARARY FOR FOREGROUND\n//* INVOCATION FROM TSO.\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//COPYEXEC    EXEC PGM=IEBCOPY\n//SYSPRINT    DD SYSOUT=*\n//IN1         DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.EXEC\n//OUT1        DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSUT1      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSUT2      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSIN       DD *\n  COPY    OUTDD=OUT1,INDD=((IN1))\n       S M=BIGLGET\n       S M=MODLIST\n/*\n//* THE FOLLOWING EXEC IS OPTIONAL. IT IS AN ALIAS EXEC FOR\n//* THE 'MODLIST' EXEC (ABBREVIATED 'MODLIST').\n//\n//COPYML      EXEC PGM=IEBCOPY\n//SYSPRINT    DD SYSOUT=*\n//IN1         DD DISP=SHR,DSN=$XXXXXXXX.$MODLISTR.EXEC\n//OUT1        DD DISP=SHR,DSN=$MY.SYSPROC.LIB$\n//SYSUT1      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSUT2      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSIN       DD *\n  COPY    OUTDD=OUT1,INDD=((IN1))\n       S M=ML\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "INSTALL3": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x10\\x01\\x06\\x03/\\x01\\x07\\x00?\\x08C\\x00\\x16\\x00\\x17\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2006-02-01T00:00:00", "modifydate": "2007-01-03T08:43:10", "lines": 22, "newlines": 23, "modlines": 0, "user": "TKMILLE"}, "text": "//INSTALL3 JOB ' INSTALL THE SYSHELP ISPF HELP PANELS          ',\n//     TIME=(2,00),REGION=0M\n//*\n//* COPY THE \"MODLIST\" AND \"CALLMODL\" HELP MEMBERS TO YOUR SYSHELP\n//* LIBRARY FOR FOREGROUND HELP INFORMATION.\n//*\n//* INSERT YOUR INSTALLATION'S JOBCARD BEFORE SUBMITTING THIS JOB\n//*\n//* CHANGE THE SYSHELP LIBRARY NAME TO YOUR FACILITY'S SYSHELP\n//* LIBRARY DATASET NAME.\n//*\n//COPYHELP    EXEC PGM=IEBCOPY\n//SYSPRINT    DD SYSOUT=*\n//IN1         DD DISP=SHR,DSN=$MY.RECEIVE.LIB$\n//OUT1        DD DISP=SHR,DSN=OUR.SYSHELP.LIBRARY  <= CHANGE THIS LIB\n//SYSUT1      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSUT2      DD UNIT=SYSALLDA,SPACE=(TRK,(002,002))\n//SYSIN       DD *\n  COPY    OUTDD=OUT1,INDD=((IN1))\n       S M=((MODLISTH,MODLIST))\n       S M=((CALLMODH,CALLMODL))\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JUL2GREG": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x17\\x01\\x06\\x15\\x0f\\x01\\x07\"\\x0f\\x15\\x00\\x00\\xf8\\x04f\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2006-05-30T00:00:00", "modifydate": "2007-08-08T15:00:17", "lines": 248, "newlines": 1126, "modlines": 0, "user": "TKMILLE"}, "text": "         TITLE 'JUL2GREG - CONVERT JULIAN DATE TO GREGORIAN DATE'\n***********************************************************************\n*                                                                     *\n*  This program inputs a seven (7) digit Julian Date (YYYYDDD) and    *\n*  converts it to a Gregorian Date (YYYYMMDD) returned as a parm.     *\n*                                                                     *\n*  Leap Year Calculation Algorithm:                                   *\n*                                                                     *\n*  Rules:                                                             *\n*                                                                     *\n*    1) A year that is evenly divisible by 400 IS a Leap Year.        *\n*    2) A year that is evenly divisible by 100 IS NOT a Leap Year.    *\n*    3) A year that is evenly divisible by   4 IS a Leap Year.        *\n*                                                                     *\n*    (The rules are processed in this sequence.)                      *\n*                                                                     *\n*  Registers Used:                                                    *\n*                                                                     *\n*  R2     => Work Register                                            *\n*  R3     => Number of Days                                           *\n*  R4     => Work Register                                            *\n*  R5     => Branching Register                                       *\n*  R7     => Address of Julian Date Passed as Input                   *\n*  R8     => Address of Gregorian Date Returned as Output             *\n*  R13    => Save Area Pointer                                        *\n*                                                                     *\n*  Return Codes from JUL2GREG:                                        *\n*                                                                     *\n*  0      => Successful call to JUL2GREG                              *\n* 12      => Invalid Julian Date Passed as a parameter                *\n*                                                                     *\n*    Attributes:  REENTRANT, REUSEABLE, AMODE 31, RMODE ANY           *\n*                                                                     *\n***********************************************************************\n*        HOUSEKEEPING                                                 *\n***********************************************************************\nJUL2GREG CSECT\nJUL2GREG AMODE 31\nJUL2GREG RMODE ANY\n         SAVE  (14,12),,JUL2GREG_ASSEMBLED_ON_&SYSDATC._&SYSTIME\n         LR    R12,R15              Load entry address\n         USING JUL2GREG,R12         Declare entry base registers\n         LM    R7,R8,0(R1)          Preserve passed parmlist addresses\n         LR    R6,R13               Store SAVEAREA Backward link\n         LA    R3,STORSIZE          Size of storage to get and clear\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)           Set SAVEAREA Forward link\n         LR    R13,R1               Address of obtained area\n         USING STORAREA,R13         Addressability to obtained area\n         LR    R2,R13               Address of target of move (obtnd)\n         LA    R3,STORSIZE          Length of the target of move\n         XR    R14,R14             From address (irrelevant with len=0)\n         XR    R15,R15              Pad/Length to propagate in odd reg\n         MVCL  R2,R14          Propagate binary zeroes in obtained area\n         ST    R6,4(,R13)           Set SAVEAREA Backward link\n**********************************************************************\n*        This routine picks up and edits the julian date passed\n**********************************************************************\n         MVC   0(8,R8),BLANK8       Initialize Gregorian Date Returned\n         MVC   FEBDAYS,F28          Indicate Not a Leap Year (Default)\n         SR    R0,R0\n         ST    R0,RETCODE           Load Default Return Code = 0\n         MVC   YEAR,0(R7)           Load the Gregorian Year\n         LA    R2,7                 Initialize Counter\n         LR    R4,R7                Point to Julian Date Parameter\n         BAS   R5,EDITJULN          Edit the Passed Julian Date\n         SR    R0,R0\n         PACK  DOUBLE,0(4,R7)       Pack the Julian Year\n         CVB   R1,DOUBLE            Convert Julian Year to binary\n         D     R0,F400              Divide Year by 400 (yr/400)\n         LTR   R0,R0                Check Remainder for Zero\n         BNZ   CKCENTRY             Check For Even Century Year\n         MVC   FEBDAYS,F29          Indicate Leap Year\n         B     GETMTHDY\nCKCENTRY DS    0H\n         CLC   2(2,R7),CENT00       Check Even Century Year (yr/100)\n         BE    GETMTHDY             Yes - Then not a Leap Year\n         PACK  DOUBLE,0(4,R7)       Pack the Julian Year\n         SR    R0,R0\n         CVB   R1,DOUBLE            Convert Julian Year to binary\n         D     R0,F4                Divide Year by 4 (yr/4)\n         LTR   R0,R0                Check Remainder for Zero\n         BNZ   GETMTHDY             Not a Leap Year\n         MVC   FEBDAYS,F29          Indicate Leap Year\nGETMTHDY DS    0H\n         PACK  DOUBLE,4(3,R7)       Pack the Julian Days\n         CVB   R3,DOUBLE            Convert Julian Days to binary\nCHKJAN   DS    0H\n         C     R3,F31               Does the Date Fall in January ?\n         BH    CHKFEB               No\n         MVC   MONTH,JAN            Load Gregorian Month January\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKFEB   DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,FEBDAYS           Does the Date Fall in February ?\n         BH    CHKMAR               No\n         MVC   MONTH,FEB            Load Gregorian Month February\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKMAR   DS    0H\n         S     R3,FEBDAYS           Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in March ?\n         BH    CHKAPR               No\n         MVC   MONTH,MAR            Load Gregorian Month March\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKAPR   DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F30               Does the Date Fall in April ?\n         BH    CHKMAY               No\n         MVC   MONTH,APR            Load Gregorian Month April\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKMAY   DS    0H\n         S     R3,F30               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in May ?\n         BH    CHKJUNE              No\n         MVC   MONTH,MAY            Load Gregorian Month May\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKJUNE  DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F30               Does the Date Fall in June ?\n         BH    CHKJULY              No\n         MVC   MONTH,JUNE           Load Gregorian Month June\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKJULY  DS    0H\n         S     R3,F30               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in July ?\n         BH    CHKAUG               No\n         MVC   MONTH,JULY           Load Gregorian Month July\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKAUG   DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in August ?\n         BH    CHKSEPT              No\n         MVC   MONTH,AUG            Load Gregorian Month August\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKSEPT  DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F30               Does the Date Fall in September ?\n         BH    CHKOCT               No\n         MVC   MONTH,SEP            Load Gregorian Month September\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKOCT   DS    0H\n         S     R3,F30               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in October ?\n         BH    CHKNOV               No\n         MVC   MONTH,OCT            Load Gregorian Month October\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKNOV   DS    0H\n         S     R3,F31               Subtract Previous Month's Days\n         C     R3,F30               Does the Date Fall in November ?\n         BH    CHKDEC               No\n         MVC   MONTH,NOV            Load Gregorian Month November\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nCHKDEC   DS    0H\n         S     R3,F30               Subtract Previous Month's Days\n         C     R3,F31               Does the Date Fall in December ?\n         BH    BADJULDT             No - Bad Julian Date Passed\n         MVC   MONTH,DEC            Load Gregorian Month December\n         BAS   R5,GETGDAYS          Obtain Gregorian Days\n         B     LOADGREG\nEDITJULN DS    0H                   Edit Julian Date\n         CLI   0(R4),C'0'\n         BL    BADJULDT             Non-Numeric Julian Date Digit\n         CLI   0(R4),C'9'\n         BH    BADJULDT             Non-Numeric Julian Date Digit\n         LA    R4,1(R4)\n         BCT   R2,EDITJULN\n         CLC   4(3,R7),C366\n         BH    BADJULDT             Invalid Julian Date (Days > 366)\n         CLC   4(3,R7),C000\n         BNER  R5                   Have Valid Julian Date Passed\nBADJULDT DS    0H                   Invalid Julian Date Passed\n         LA    R1,12\n         ST    R1,RETCODE           Return with RC=12\n         B     RETURN\nGETGDAYS DS    0H\n         CVD   R3,DOUBLE\n         UNPK  DAYSWORK,DOUBLE+6(3)\n         MVC   DAY,DAYSWORK+1       Load Gregorian Days\n         BR    R5\nLOADGREG DS    0H\n         MVC   0(GREGL,R8),GREG_DATE  Load the Gregorian Date\nRETURN   DS    0H\n         L     R4,RETCODE           Pick up return code\n         LR    R2,R13               Pointer to storage area\n         LA    R3,STORSIZE          Size of storage to free\n         L     R13,4(,R13)          Restore Caller's SAVEAREA address\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\n         L     R14,12(,R13)         Restore R14\n         LR    R15,R4               Load return code\n         LM    R0,R12,20(R13)       Restore caller's registers\n         BSM   0,R14                Return to caller in caller's Amode\n**********************************************************************\n*    STATIC STORAGE FOLLOWS\n**********************************************************************\nBLANK8      DC    CL8'        '\nCENT00      DC    CL2'00'           Check Year for Even Century Year\nF4          DC    F'4'\nF28         DC    F'28'\nF29         DC    F'29'\nF30         DC    F'30'\nF31         DC    F'31'\nF400        DC    F'400'\nC366        DC    CL3'366'\nC000        DC    CL3'000'\nJAN         DC    CL2'01'\nFEB         DC    CL2'02'\nMAR         DC    CL2'03'\nAPR         DC    CL2'04'\nMAY         DC    CL2'05'\nJUNE        DC    CL2'06'\nJULY        DC    CL2'07'\nAUG         DC    CL2'08'\nSEP         DC    CL2'09'\nOCT         DC    CL2'10'\nNOV         DC    CL2'11'\nDEC         DC    CL2'12'\n            LTORG\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS  (GETMAINED AREA)\n**********************************************************************\nSTORAREA    DSECT ,                Reentrant Storage\nSAVEAREA    DS    20F\nFULL        DS    F                General workarea\nDOUBLE      DS    D                General workarea\nRETCODE     DS    F                Return code\nFEBDAYS     DS    F                Number of days in Feb for this year\nGREG_DATE   DS    0F               Gregorian Date to be Returned\nYEAR        DS    CL4              (YYYYMMDD)\nMONTH       DS    CL2\nDAY         DS    CL2\nGREGL       EQU   *-GREG_DATE      Length of Gregorian Date Returned\nDAYSWORK    DS    CL5\n*\nSTORSIZE    EQU   *-STORAREA\n*\n            YREGS                  Register Equates\n            END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ML": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\t\\x01\\x06\\x15\\x1f\\x01\\x07\\x00/\" \\x00\\x10\\x00\\x01\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2006-05-31T00:00:00", "modifydate": "2007-01-02T22:20:09", "lines": 16, "newlines": 1, "modlines": 0, "user": "TKMILLE"}, "text": "/* REXX - ML  (Front-end alias exec for the MODLIST Rexx exec)        */\n/*                                                                    */\n/*           M   M L                                                  */\n/*           MM MM L                                                  */\n/* MODULE =  M M M L                                                  */\n/*           M   M L                                                  */\n/*           M   M LLLLL                                              */\n/*                                                                    */\n/* AUTHOR:          - 05/31/2006                                      */\n/* LAST UPDATE:     - 01/02/2007                                      */\n/*                                                                    */\nArg parms\n\n\"%MODLIST\" parms\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODLIST": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x008\\x01\\x10\\x02o\\x01\\x10\\x11o\\x11%\\x02\\xb0\\x02\\xaf\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2010-01-26T00:00:00", "modifydate": "2010-04-26T11:25:38", "lines": 688, "newlines": 687, "modlines": 0, "user": "TKMILLE"}, "text": "/* REXX   - MODLIST (Module List)                                    */\n/*                                                                   */\n/*           M   M OOOOO DDDD  L      III   SSSS TTTTT               */\n/*           MM MM O   O D   D L       I   S       T                 */\n/*           M M M O   O D   D L       I    SSS    T                 */\n/*           M   M O   O D   D L       I       S   T                 */\n/*           M   M OOOOO DDDD  LLLLL  III  SSSS    T                 */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* AUTHOR:          - 05/31/2006                                     */\n/* LAST UPDATE:     - 04/26/2010                                     */\n/*                                                                   */\n/* Purpose:                                                          */\n/*         This exec will input a modulename from the terminal and   */\n/*         search the LPA List and Link List to search for the       */\n/*         module.  If a hit is found, a two-line module information */\n/*         BLDL display is echoed back to the terminal and the       */\n/*         search is terminated.                                     */\n/*                                                                   */\n/*         If the keywork \"DUP\" is added as a parm, the entire       */\n/*         list of LPA and LINKLIST datasets are searched and every  */\n/*         hit on the module is echoed back to the terminal.         */\n/*                                                                   */\n/*         If the parameter LIB(dsname) is passed as an optional     */\n/*         parm, only that library (dsname) is searched for the      */\n/*         module in question. Also, the user can pass the optional  */\n/*         paramters VOL(vvvvv) and/or UNIT(xxxxx) to specify the    */\n/*         library location instead of locating it thru the catalog. */\n/*                                                                   */\n/*         Display the module information via ISPF Browse.           */\n/*                                                                   */\n/* Syntax:                                                           */\n/*                                                                   */\n/*   MODLIST  modulename { DUP   (or ALL) }                          */\n/*                       { LPA      }                                */\n/*                       { LINK     }                                */\n/*                       { LIST     }                                */\n/*                       { LIB(dsname) }                             */\n/*                              {VOL(vvvvv)   }                      */\n/*                              {UNIT(xxxxx)  }                      */\n/*                                                                   */\n/*                                                                   */\n/* Valid OPTIONAL parameters:                                        */\n/*                    'DUP' or 'ALL' (list all duplicate entries),   */\n/*                    'LIST' (List all LPA & LINKLIST libraries),    */\n/*                    'LIB(mylib)' (Check only this libarary),       */\n/*                    'VOL(xxxxxx)' (Use this volser for mylib       */\n/*                    allocation), 'UNIT(xxxxx)' (Use this unit for  */\n/*                    mylib allocation.  Note, if the library name   */\n/*                    is passed as a non-keyword parameter, it must  */\n/*                    be at least eight characters in length.        */\n/*                                                                   */\n/* Example TSO Foreground Exec Calls:                                */\n/*                                                                   */\n/*  MODLIST m LPA (search only the LPALIST for member 'm' - display. */\n/*                the first hit against an LPA library).             */\n/*  ML m LPA     (same as the previous example above).               */\n/*  ML m LNK     (search only the LINKLIST libs for member 'm' -     */\n/*                display the first hit against an LINKLIST library).*/\n/*  ML m LINK    (same as LNK)                                       */\n/*  ML m         (search both LPALIST and LINKLIST libs for 'm' -    */\n/*                display the first hit against an LPA or a          */\n/*                LINKLIST library).                                 */\n/*  ML m DUP     (search both LPALIST and LINKLIST libs for all      */\n/*                 occurances of member 'm' - display all hits).     */\n/*  ML m ALL     (same as DUP)                                       */\n/*  ML m LIST    (List all of the LPA and LINKLIST libraries)        */\n/*  ML m LIB(SYS1.LINKLIB) - (List member 'm' - look at library      */\n/*                 'SYS1.LINKLIB' only)                              */\n/*  ML m LIB(SYS1.LINKLIB VOL(SYHRS1) - (List member 'm' - look at   */\n/*                 library 'SYS1.LINKLIB' on volume 'SYHRS1' only)   */\n/*  ML m SYS1.LOADLIB - (List member 'm' - look at library           */\n/*                 'SYS1.LOADLIB' only.  Note, the load library      */\n/*                 must be at least eight characters in length if    */\n/*                 specified this way without a keyword.             */\n/*                                                                   */\n/* Notes:                                                            */\n/*         This exec is modified from Mark Zelden's \"LPROG\" freeware */\n/*         Rexx exec.                                                */\n/*                                                                   */\n/* Change Log:                                                       */\n/*    Added program MODLISTR to display the LinkEdit Date, Time, and */\n/*       module length - TKMILLE 04/10/2006                          */\n/*    Changed the exec to always use BROWSE mode (ISPF Browse).      */\n/*                       TKMILLE 05/01/2006                          */\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/* Notes from Mark Zelden's \"LPROG\" exec.                            */\n/* NOTE: The dynamic APF and dynamic LNKLST code in this exec        */\n/*       use undocumented IBM control blocks and may break at        */\n/*       any time!                                                   */\n/*    ... tested on z/OS 1.4 up to z/OS 1.11                         */\n/*                                                                   */\n/* NOTE: The LNKLST SET displayed is the LNKLST SET of the address   */\n/*       space running this program, not necessarily the most        */\n/*       current one. For the current LNKLST SET either:             */\n/*                                                                   */\n/*       1) Run this exec in batch.                                  */\n/*       2) Log off and on TSO before executing this exec.           */\n/*       3) Issue SETPROG LNKLST,UPDATE,JOB=userid (Before execution)*/\n/*                                                                   */\n/*********************************************************************/\n/*                                                                   */\n/*********************************************************************/\n/*  CVTLLTA LAYOUT (OFFSET 1244 IN CVT): (STATIC LNKLST)             */\n/*         DESC                       LEN                            */\n/*         ------------------------   ---                            */\n/*         CONSTANT 'LLT '             4                             */\n/*         NUMBER OF ENTRIES           4                             */\n/*         LENGTH OF DSN               1                             */\n/*         DSN (PADDED WITH BLANKS)    44                            */\n/*********************************************************************/\n/*  LPAT LAYOUT  (OFFSET 0 IN CVTEPLPS / START OF EXT. LPA):         */\n/*         DESC                       LEN                            */\n/*         ------------------------   ---                            */\n/*         CONSTANT 'LPAT'             4                             */\n/*         NUMBER OF ENTRIES           4                             */\n/*         LENGTH OF DSN               1                             */\n/*         DSN (PADDED WITH BLANKS)    44                            */\n/*********************************************************************/\nversion_level = \"V01.01.14\"\nArg parms\nUpper parms\nTrace \"O\"\nmsg_stat = Msg(\"ON\")\nenvirnmt = Sysvar(\"sysenv\")\nnesting  = Sysvar(\"sysnest\")\nsysicmd  = Sysvar(\"sysicmd\")\nsyspcmd  = Sysvar(\"syspcmd\")\nsysscmd  = Sysvar(\"sysscmd\")\nrtcd     = 0\nUserid   = Userid()\nParse source . How_Called . . . . . Env . .\n\n/*******************************************************************/\n/* Invoke the ISPF environment and try again.                      */\n/*******************************************************************/\nIf SYSVAR('sysispf') <> \"ACTIVE\" & envirnmt <> \"BACK\"  Then Do\n   \"ISPF CMD(%MODLIST\" parms \")\"\n   rtcd = 0\n   Return\nEnd\n\nmember = WORD(parms,1)         /* Get the Load Module Member       */\nparms  = DELWORD(parms,1,1)    /* Remove the member from the parms */\n\nIf member = \"\" Then Do\n   Say \"Module name was not passed ...\"\n   Say \"MODLIST exec bypassed ...\"\n   rtcd = 12\n   Signal End_Up_2\nEnd\n\nIf Length(member) < 1 | Length(member) > 8   Then Do\n   Say \"Module Length is invalid ...  Should be 1-8 characters in\",\n       \"length\"\n   Say \"Module Name passed =>\" member \"is invalid\"\n   Say \"MODLIST exec bypassed ...\"\n   rtcd = 12\n   Signal End_Up_2\nEnd\n\nrandomq       = \"R\"||random(1000,9999)||random(100,999)\nsysprint_file = Userid\".$$ML$$.\"randomq\".SYSPRINT\"\n\ndup          = \"\"\nlpa          = \"\"\nlink         = \"\"\nlist         = \"\"\nlib          = \"\"\nmight_be_lib = \"\"\nvol          = \"\"\nunit         = \"SYSDA\"\nfind         = \"N\"\n\nnbr_words    = WORDS(parms)\ncurr_parm    = \"\"\nresidue      = \"\"\ndebug        = \"\"\n\nDo i = 1 to nbr_words    /* Parse through the execution parameters */\n  curr_parm = WORD(parms,i)\n  PARSE var curr_parm  \"LIB(\"   parse_value1 \")\"\n  PARSE var curr_parm  \"DA(\"    parse_value2 \")\"\n  PARSE var curr_parm  \"DSN(\"   parse_value3 \")\"\n  PARSE var curr_parm  \"VOL(\"   parse_value4 \")\"\n  PARSE var curr_parm  \"UNIT(\"  parse_value5 \")\"\n  SELECT\n     WHEN ABBREV(\"DEBUG\",curr_parm,3) = 1                     Then Do\n          debug = \"DEBUG\"\n          Iterate\n        End\n     WHEN parse_value1 <> \"\" &  lib = \"\"                      Then Do\n          lib   = parse_value1\n          Iterate\n        End\n     WHEN parse_value2 <> \"\" &  lib = \"\"                      Then Do\n          lib   = parse_value2\n          Iterate\n        End\n     WHEN parse_value3 <> \"\" &  lib = \"\"                      Then Do\n          lib   = parse_value3\n          Iterate\n        End\n     WHEN ABBREV('DUPLICATE',WORD(parms,i),3) = 1             Then Do\n          dup     = \"DUP\"\n          iterate\n        End\n     WHEN ABBREV('DUPS',WORD(parms,i),4) = 1                  Then Do\n          dup     = \"DUP\"\n          iterate\n        End\n     WHEN ABBREV('ALL',WORD(parms,i),3) = 1                   Then Do\n          dup     = \"DUP\"\n          iterate\n        End\n     WHEN WORD(parms,i) = \"LPA\"                               Then Do\n          lpa     = \"LPA\"\n          iterate\n        End\n     WHEN WORD(parms,i) = \"LINK\"                              Then Do\n          link    = \"LINK\"\n          iterate\n        End\n     WHEN WORD(parms,i) = \"LNK\"                               Then Do\n          link    = \"LINK\"\n          iterate\n        End\n     WHEN WORD(parms,i) = \"LIST\"                              Then Do\n          list    = \"LIST\"\n          iterate\n        End\n     WHEN LENGTH(WORD(parms,i)) > 8 & ,\n          POS(\"(\",WORD(parms,i)) = 0                          Then Do\n             might_be_lib = WORD(parms,i)\n             iterate\n        End\n     WHEN parse_value4 <> \"\" &  vol = \"\"                      Then Do\n          vol = parse_value4\n        End\n     WHEN parse_value5 <> \"\" &  unit = \"\"                     Then Do\n          unit = parse_value5\n        End\n     OTHERWISE Do\n          residue = curr_parm\n        End\n  End\nEnd\n\nIf debug = \"DEBUG\"  Then Do\n   Trace \"I\"\nEnd\n\nIf lib = \"\" & might_be_lib <> \"\" & POS(\"(\",might_be_lib) = 0  Then Do\n   lib   = might_be_lib\nEnd\n\nlib     = STRIP(lib,B,\"'\")          /* remove enclosed tics          */\nlib     = STRIP(lib,B,'\"')          /* remove quotes                 */\n\nCVT     = C2D(STORAGE(10,4))        /* MEMORY @ 16 POINTS TO CVT     */\nFMIDNUM = Storage(D2X(CVT - 32),7)           /* point to fmid        */\nSYSID   = LEFT(MVSVAR(\"sysname\"),8,\" \")\nSMCA    = CVT + 196                 /* ADD JESCT OFFSET (C4)         */\nSMCA    = D2X(SMCA)                 /* CONVERT TO HEX                */\nSMCA    = STORAGE(SMCA,4)           /* GET SMCA ADDRESS FROM CVT     */\nSMCA    = C2X(SMCA)                 /* CHARACTERIZE SMCA ADDRESS     */\nIf LEFT(SMCA,1) > 7 THEN DO         /* CHECK FOR 31 BIT ADDRESS      */\n   CHAR = LEFT(SMCA,1) - 8          /* REMOVE HIGH BIT FROM NIBBLE   */\n   SMCA = CHAR || RIGHT(SMCA,7)     /* REMAKE ADDRESS MINUS HIGH BIT */\nEnd\nSMCA    = X2D(SMCA)                 /* DECIMALIZE ADDRESS            */\nSMFID   = SMCA + 16                 /* POINT TO SMFID ( OFFSET 16 )  */\nSMFID   = D2X(SMFID)                /* HEXIFY ADDRESS OF SMFID       */\nSMFID   = STORAGE(SMFID,4)          /* GET SMFID FROM MEMORY         */\nDATETM = DATE('W')\", \"DATE('M')\" \"SUBSTR(DATE('S'),7,2)\", \"||,\n     SUBSTR(DATE('S'),1,4)\".\"SUBSTR(DATE('J'),3,3)\" AT \"TIME()\nUPPER DATETM\n\noption      = \"ALL\"\nIf lpa      = \"LPA\"      Then option = \"LPA\"\nIf link     = \"LINK\"     Then option = \"LINK\"\nIf link     = \"LNK\"      Then option = \"LINK\"\n\nIf option   = \"ALL\"      Then option_lit = \"LPA OR IN THE LINKLIST\"\nIf option   = \"LPA\"      Then option_lit = \"LPA\"\nIf option   = \"LINK\"     Then option_lit = \"THE LINKLIST\"\n\nAllocate_The_Files:\n\nmsg_stat = Msg(\"OFF\")\n\n\"DELETE '\"sysprint_file\"' PURGE\"   /* HDELETE IF MIGRATED  */\n\n\"ALLOC FI(SYSPRINT) DA('\"sysprint_file\"') MOD REUSE LRECL(121)\",\n       \"RECFM(F B) BLKSIZE(121) SPACE(20) TRACKS DSORG(PS)\"\n\nalloc_sysprint_rc = rc\n\nIf alloc_sysprint_rc <> 0  Then Do\n   Say \"Error encountered allocating the SYSPRINT output file ...\"\n   Say \"Return Code =\" alloc_sysprint_rc\n   Say \"MODLIST exec bypassed ...\"\n   rtcd = 12\n   Signal End_Up_2\nEnd\n\nmsg_stat = Msg(msg_stat)\n\nIf lib <> \"\"     Then Signal Have_A_Specific_Library\n\n\"ALLOC FI(SRCHLIST) NEW REUSE LRECL(80)\",\n       \"BLKSIZE(6160) RECFM(F B) SPACE(05,05) TRACKS DSORG(PS)\"\nalloc_srchlist_rc = rc\n\nIf alloc_srchlist_rc <> 0  Then Do\n   Say \"Error encountered allocating the SRCHLIST output file ...\"\n   Say \"Return Code =\" alloc_srchlist_rc\n   Say \"MODLIST exec bypassed ...\"\n   rtcd = 12\n   Signal End_Up_2\nEnd\n\nSearch_LPA_Libraries:\n\nIf OPTION = 'LPA' | OPTION = 'ALL'  Then Do\n  CVTSMEXT = C2d(Storage(D2x(CVT + 1196),4))  /* point to stg map ext*/\n  CVTEPLPS = C2d(Storage(D2x(CVTSMEXT+56),4)) /* point to stg map ext*/\n  NUMLPA   = C2d(Storage(D2x(CVTEPLPS+4),4)) /* # LPA libs in table  */\n  LPAOFF   = 8                               /* first ent in LPA tbl */\n  Do I = 1 to NUMLPA\n     LEN   = C2d(Storage(D2x(CVTEPLPS+LPAOFF),1)) /* length of entry */\n     LPDSN = Storage(D2x(CVTEPLPS+LPAOFF+1),LEN) /*DSN of LPA library*/\n     LPAOFF = LPAOFF + 44 + 1                  /* next entry in table*/\n     LPAPOS = Right(I,3)                       /*position in LPA list*/\n     RELLPPOS = Right('(+'I-1')',6)      /* relative position in list*/\n\n     If list = \"LIST\"    Then Do\n        sysprint.1 = lpdsn\n        \"EXECIO 1 DISKW SYSPRINT (STEM sysprint. \"\n        execiorc = rc\n     End\n     Else Do\n         srchlist.1 = lpdsn\n         \"EXECIO 1 DISKW SRCHLIST (STEM srchlist. \"\n         execiorc = rc\n     End\n  End\nEnd\n\n\nSearch_LINKLIST_Libraries:\n\nIf OPTION = 'LINK' |  OPTION = 'ALL' Then Do\n  If Substr(FMIDNUM,4,4) < 6602 then do\n    CVTLLTA  = C2d(Storage(D2x(CVT + 1244),4)) /* point to lnklst tbl*/\n    NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))  /* # LNK libs in table*/\n    LLTAPFTB = CVTLLTA + 8 + (NUMLNK*45)       /* start of LLTAPFTB  */\n    LNKOFF   = 8                               /*first ent in LBK tbl*/\n    LKAPFOFF = 0                              /*first ent in LLTAPFTB*/\n    Do I = 1 to NUMLNK\n       LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))  /* length of entry */\n       LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN) /* DSN of LNK lib  */\n       CHKAPF = Storage(D2x(LLTAPFTB+LKAPFOFF),1) /* APF flag        */\n       If  bitand(CHKAPF,'80'x) = '80'x then LKAPF = 'Y' /* flag on  */\n         else LKAPF = ' '                         /* APF flag off    */\n       LNKOFF = LNKOFF + 44 + 1                   /*next entry in tbl*/\n       LKAPFOFF = LKAPFOFF + 1            /* next entry in LLTAPFTB  */\n       LNKPOS = Right(I,3)                        /*position in list */\n       RELLKPOS = Right('(+'I-1')',6)   /* relative position in list */\n       If list = \"LIST\"    Then Do\n          sysprint.1 = lkdsn\n          \"EXECIO 1 DISKW SYSPRINT (STEM sysprint. \"\n          execiorc = rc\n       End\n       Else Do\n           srchlist.1 = lkdsn\n           \"EXECIO 1 DISKW SRCHLIST (STEM srchlist. \"\n           execiorc = rc\n       End\n    End\n  End\n  Else do  /* OS/390 1.2 and above - PROGxx capable LNKLST           */\n    ASCB     = C2d(Storage(224,4))               /* point to ASCB    */\n    ASSB     = C2d(Storage(D2x(ASCB+336),4))     /* point to ASSB    */\n    DLCB     = C2d(Storage(D2x(ASSB+236),4))     /* point to CSVDLCB */\n    SETNAME  = Storage(D2x(DLCB + 36),16)      /* LNKLST set name    */\n    SETNAME  = Strip(SETNAME,T)                /* del trailing blanks*/\n    CVTLLTA  = C2d(Storage(D2x(DLCB + 16),4))  /* point to lnklst tbl*/\n    LLTX     = C2d(Storage(D2x(DLCB + 20),4))  /* point to LLTX      */\n    NUMLNK   = C2d(Storage(D2x(CVTLLTA+4),4))  /* # LNK libs in table*/\n    LLTAPFTB = CVTLLTA + 8 + (NUMLNK*45)       /* start of LLTAPFTB  */\n    LNKOFF   = 8                               /*first ent in LLT tbl*/\n    VOLOFF   = 8                               /*first ent in LLTX   */\n    LKAPFOFF = 0                              /*first ent in LLTAPFTB*/\n    Do I = 1 to NUMLNK\n       LEN = C2d(Storage(D2x(CVTLLTA+LNKOFF),1))  /* length of entry */\n       LKDSN = Storage(D2x(CVTLLTA+LNKOFF+1),LEN) /* DSN of LNK lib  */\n       LNKVOL = Storage(D2x(LLTX+VOLOFF),6)       /* VOL of LNK lib  */\n       CHKAPF = Storage(D2x(LLTAPFTB+LKAPFOFF),1) /* APF flag        */\n       If  bitand(CHKAPF,'80'x) = '80'x then LKAPF = 'Y' /* flag on  */\n         else LKAPF = ' '                         /* APF flag off    */\n       LNKOFF   = LNKOFF + 44 + 1                 /*next entry in LLT*/\n       VOLOFF   = VOLOFF + 8                      /*next vol in LLTX */\n       LKAPFOFF = LKAPFOFF + 1            /* next entry in LLTAPFTB  */\n       LNKPOS   = Right(I,3)                      /*position in list */\n       RELLKPOS = Right('(+'I-1')',6)   /* relative position in list */\n       If list = \"LIST\"    Then Do\n          sysprint.1 = lkdsn\n          \"EXECIO 1 DISKW SYSPRINT (STEM sysprint. \"\n          execiorc = rc\n       End\n       Else Do\n          srchlist.1 = Copies(\" \",60)\n          srchlist.1 = Overlay(lkdsn,srchlist.1,1,44)\n          srchlist.1 = Overlay(lnkvol,srchlist.1,46,6)\n          \"EXECIO 1 DISKW SRCHLIST (STEM srchlist. \"\n          execiorc = rc\n       End\n    End\n  End\nEnd\n\n\"EXECIO 0 DISKW SRCHLIST (FINIS \"\nexeciorc = rc\n\nIf list = \"LIST\"      Then Do\n   \"FREE FI(SRCHLIST)\"\n   Signal End_Up\nEnd\n\nSet_Up_Search:\n\n\"EXECIO 0 DISKR SRCHLIST (OPEN \"\nexeciorc = rc\n\nIf execiorc <> 0 Then Do\n   \"EXECIO 0 DISKR SRCHLIST (FINIS \"\n   sysprint.1 = \"Error Obtaining LPA and LINKLIST datasets ...\"\n   sysprint.2 = \"The Search List File could not be opened  ...\"\n   sysprint.3 = \"MODLIST exec is bypassed ...\"\n   \"EXECIO 3 DISKW SYSPRINT (STEM sysprint. \"\n   execiorc = rc\n   rtcd = 12\n   Signal End_Up\nEnd\n\nlib_count = 0\n\n\nLoop_Search_Libraries:\n\n\"EXECIO 1 DISKR SRCHLIST (STEM srchlist. \"\nexeciorc = rc\n\nIf execiorc <> 0 & execiorc <> 2  Then Do    /* Error ? */\n   If lib_count = 0   Then Do\n      sysprint.1 = \"Error Obtaining LPA and LINKLIST datasets ...\"\n      sysprint.2 = \"MODLIST exec is bypassed ...\"\n      \"EXECIO 2 DISKW SYSPRINT (STEM sysprint. \"\n      execiorc = rc\n      rtcd = 12\n      Signal End_Up\n   End\nEnd\n\nIf execiorc = 2 Then Do    /* EOF ? */\n   \"EXECIO 0 DISKR SRCHLIST (FINIS \"\n   If find = \"N\"  Then Do\n      result_b = BIGLGET(member)\n      Call Display_Big_Block_Lines\n      sysprint.1  = \"MODULE\" '\"'member'\"' \"NOT FOUND IN\" option_lit ,\n           \"ON\" sysid\n      \"EXECIO 1 DISKW SYSPRINT (STEM sysprint. \"\n      execiorc = rc\n      rtcd = 12\n   End\n   Signal End_Up\nEnd\n\nlib_count = lib_count + 1        /* Increment # of dsns searched  */\n\ndsn     = Strip(SUBSTR(srchlist.1,1,44),T)\nvol     = Strip(SUBSTR(srchlist.1,46,6),B)\n\nIf SYSDSN(\"'\"dsn\"(\"member\")'\") = \"OK\" Then Do\n\n   msg_stat = MSG(\"OFF\")\n   listdsi_rc  = LISTDSI(\"'\"dsn\"'\" DIRECTORY NORECALL SMSINFO)\n   msg_stat = Msg(msg_stat)\n   If vol = \"\"  Then vol = Sysvolume\n\n   result_b = BIGLGET(member)\n   Call Display_Big_Block_Lines\n\n   pdse = \"N\"\n   If listdsi_rc < 5 & sysused = \"N/A\" then pdse = \"Y\"\n\n   \"ALLOC FI(IEWINFO) DA(*) REUSE\"\n   \"ALLOC FI(IEWLIB) DA('\"dsn\"') SHR REUSE\"\n\n   \"CALL *(MODLISTR)  '\"member\"'\"\n\n   MODLISTR_rc = rc\n\n   /* Say \"MODLISTR_rc From Call #1 =\" MODLISTR_rc  */\n\n   msg_stat = Msg(\"OFF\")\n   \"FREE FI(IEWLIB,IEWINFO)\"\n   msg_stat = Msg(msg_stat)\n\n   find = \"Y\"\n\n   If dup = \"DUP\" Then ,\n      Signal Loop_Search_Libraries\n   Else ,\n      Signal End_Up\n\nEnd\n\nSignal Loop_Search_Libraries\n\n\nHave_A_Specific_Library:\n\nmsg_stat = MSG(\"OFF\")\n\nIf vol <>  \"\" Then Do\n     \"ALLOC FI(IEWLIB) DA('\"lib\"') SHR REUSE\", /* For pgm MODLISTR */\n         \"VOL(\"vol\") UNIT(\"unit\")\"\n     alloc_rc = rc\nEnd\nElse Do\n     \"ALLOC FI(IEWLIB) DA('\"lib\"') SHR REUSE\"  /* For pgm MODLISTR */\n     alloc_rc = rc\nEnd\n\nmsg_stat = Msg(msg_stat)\n\nIf alloc_rc <> 0     Then Do\n   sysprint.1  = \"Dataset '\"lib\"' Not Cataloged or Catalog Can\",\n                 \"Not be accessed on\" sysid\n   \"EXECIO 1 DISKW SYSPRINT (STEM sysprint. \"\n   execiorc = rc\n   Signal End_Up\nEnd\n\npdse = \"N\"\n\nresult_b = BIGLGET(member)\nCall Display_Big_Block_Lines\n\nmsg_stat = MSG(\"OFF\")\nlistdsi_rc  = LISTDSI(\"'\"lib\"'\" DIRECTORY NORECALL SMSINFO)\nmsg_stat = Msg(msg_stat)\nvol = Sysvolume\nIf listdsi_rc < 5 & sysused = \"N/A\" then pdse = \"Y\"\n\n\"ALLOC FI(IEWINFO) DA(*) REUSE\"\n\"CALL *(MODLISTR)  '\"member\"'\"\nMODLISTR_rc = rc\n\nmsg_stat = Msg(\"OFF\")\n\n\"FREE FI(IEWLIB,IEWINFO)\"\n\nmsg_stat = Msg(msg_stat)\n\n/* Say \"MODLISTR_rc From Call #2 =\" MODLISTR_rc  */\n\nfind = \"Y\"                     /* Increment # of dsns displayed */\n\nSignal End_Up\n\n\nDisplay_Big_Block_Lines:\n\nsysprint.1 = \"    \"\n\"EXECIO 1 DISKW SYSPRINT (STEM sysprint.      \"\nexeciorc = rc\n\nparse_it    = result_b\n\nDo i = 1 to 999999\n  lit_start        = \"LINE\"||Right(i,3,\"0\")||\"===>\"\n  lit_end          = \"<===\"\n  pos_lit_st       = POS(lit_start,parse_it)\n  If pos_lit_st    = 0  Then LEAVE\n  pos_lit_end      = POS(lit_end,parse_it)\n  If pos_lit_end   = 0  Then LEAVE\n  line    = SUBSTR(parse_it,pos_lit_st + LENGTH(lit_start), ,\n                  pos_lit_end - pos_lit_st - LENGTH(lit_start))\n  If i = 3  Then Do\n     dateg   = Substr(date(u),1,6)||Substr(date(s),1,4)\n     line    = Overlay(sysid,line,02,08)\n     line    = Overlay(dateg,line,68,10)\n  End\n  If i = 4  Then Do\n     time    = TIME()\n     line    = Overlay(time,line,69,08)\n  End\n  sysprint.1 = line\n  \"EXECIO 1 DISKW SYSPRINT (STEM sysprint.      \"\n  execiorc = rc\n\n  parse_it   = SUBSTR(parse_it,pos_lit_end + LENGTH(lit_end), ,\n                  LENGTH(parse_it) - pos_lit_end - LENGTH(lit_end) +1)\n\nEnd\n\n\"EXECIO 0 DISKW SYSPRINT (STEM sysprint. FINIS\"\nexeciorc = rc\n\nReturn\n\nEnd_Up:\n\n\"EXECIO 0 DISKW SRCHLIST (FINIS \"  /* Close File if it is still open */\n\"EXECIO 0 DISKW SYSPRINT (FINIS \"  /* Close File if it is still open */\n\nmsg_stat = Msg(\"OFF\")\n\n\"FREE FI(SRCHLIST IEWLIB IEWINFO)\"\n\nmsg_stat = Msg(msg_stat)\n\n\"DELSTACK\"\n\nIf envirnmt = \"BACK\" Then Do                 /* Background Call ?  */\n   \"NEWSTACK\"\n   \"EXECIO * DISKR SYSPRINT (STEM sysprint. FINIS\"\n   Do i = 1 to sysprint.0\n      Say SUBSTR(sysprint.i,2,79)\n   End\n   \"DELSTACK\"\n   Say ;\n   Signal End_Up_2\nEnd\n\n/***************************************************************/\n/* Use the time value (hhmmss) as a suffix for a unique ddname */\n/*   for the browser file (in case it gets invoked multiple    */\n/*   times within a single ISPF session).  01/21/2010          */\n/***************************************************************/\n\ntimx      = TIME(\"N\")\ndd_suffix = SUBSTR(timx,1,2)||SUBSTR(timx,4,2)||SUBSTR(timx,7,2)\nbrowse_dd = \"DD\"||dd_suffix\nbrowse_dd = LEFT(browse_dd,8,\" \")\n\n\"ALLOC FI(\"browse_dd\")  NEW REUSE LRECL(121)\",\n        \"RECFM(F B) BLKSIZE(121) SPACE(02,02) TRACKS DSORG(PS)\"\nalloc_browser_rc = rc\n\nIf alloc_browser_rc <> 0  Then Do\n   browse_dd = \"SYSPRINT\"\n   Signal ISPF_Browse_the_Results\nEnd\n\n\"NEWSTACK\"\n\"EXECIO * DISKR SYSPRINT (FINIS \"    /* Read SYSPRINT and queue lines */\nQueue \"\"\n\"EXECIO * DISKW \"browse_dd\" (FINIS\"    /* Write lines to BROWSER File */\n\"DELSTACK\"\n\nISPF_Browse_the_Results:\n\n/*********************************************************************/\n/*  Browse all of the message lines in ISPF Browse mode.             */\n/*********************************************************************/\nAddress ISPEXEC \"LMINIT DATAID(DID) DDNAME(\"browse_dd\")\"\nAddress ISPEXEC \"ISPEXEC BROWSE DATAID(\"did\")\"         /* ISPF Browse */\nAddress ISPEXEC \"LMFREE DATAID(\"did\")\"\n\nmsg_stat = Msg(\"OFF\")\n\n\"FREE FI(\"browse_dd\")\"\n\nEnd_Up_2:\n\nmsg_stat = Msg(\"OFF\")\n\n\"FREE FI(SYSRPINT SRCHLIST IEWLIB IEWINFO)\"\n\"DELETE '\"sysprint_file\"' PURGE\"\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODLISTH": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00P\\x01\\x06\\x15\\x1f\\x01\\x07\\x17o\\x08&\\x00\\xca\\x00\\x01\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2006-05-31T00:00:00", "modifydate": "2007-06-25T08:26:50", "lines": 202, "newlines": 1, "modlines": 0, "user": "TKMILLE"}, "text": ")F FUNCTION - The MODLIST exec is used to determine what library\n              a load module resides in and also displays Link-Edit\n              (Binder) information about the load module.\n              The information is displayed in ISPF BROWSE mode if\n              the exec is invoked from the TSO foreground.\n)X SYNTAX   -\n\n         MODLIST    MODULENAME { DUP      }\n         ML                    { ALL      }\n                               { LPA      }\n                               { LINK     }\n                               { LIST     }\n                               { LIB(dsname)  }\n                               { DA(dsname)   }\n                               { DSN(dsname)  }\n                                      {VOL(vvvvvv)     }\n                                      {UNIT(xxxxxxxx)  }\n\n\n      Modulename - The modulename to be searched.  This parameter\n                   must always be specified and must precede the\n                   subparameters.\n\n\n      Subparameter Values and Explanations:\n\n      DUP        - Include duplicate entries.  Look for the module\n                   more than one load library. If the LPA and LINK\n                   subparameters are not included, the facility\n                   will look for all modules having this name in the\n                   scope of the LPA libraries and in the Linklist.\n\n      ALL        - Same as DUP.\n\n      LPA        - Look for the module in the LPA list of load\n                   libraries.  If the subparameter DUP or ALL is\n                   also included, it will list all of the entries\n                   with this modulename within the scope of the\n                   LPA List of load libraries.\n\n      LINK       - Look for the module in the LinkList of load\n                   libraries.  If the subparameter DUP or ALL is\n                   also included, it will list all of the entries\n                   with this modulename within the scope of the\n                   LinkList of load libraries.\n\n      LIST       - This subparameter will list all of the LPA\n                   libraries and LinkList libraries.  When this\n                   subparamter is specified, the modulename must\n                   also be included ahead of the LIST parameter.\n                   However, the modulename parameter is ignored, so\n                   it can be a dummy modulename such as 'X'.\n\n      LIB(dsname)- This subparameter tells the facilitiy to search\n                   only this Load Library for the modulename.\n\n      DA(dsname) - Same as LIB(dsname) - Alternate Keyword parm\n\n      DSN(dsname)- Same as LIB(dsname) - Alternate Keyword parm\n\n      VOL(vvvvvv)- This subparameter can be used with the LIB\n                   subparameter to specify the Volser that the\n                   specified library resides on.\n\n      UNIT(xxxxx)- This subparameter can be used with the LIB and\n                   VOL subparameters to specify the UNIT of the\n                   specified Volser of the library.\n\n      Valid OPTIONAL parameters:\n                   'DUP' or 'ALL' (list all duplicate entries),\n                   'LIST' (List all LPA & LINKLIST libraries),\n                   'LIB(mylib)' (Check only this libarary),\n                   'VOL(xxxxxx)' (Use this volser for mylib\n                   allocation), 'UNIT(xxxxx)' (Use this unit for\n                   mylib allocation.  Note, if the library name\n                   is passed as a non-keyword parameter, it must\n                   be at least eight characters in length.\n\n    Example TSO Foreground Exec Calls:\n\n    MODLIST m LPA (search only the LPALIST for member 'm' - display\n                   the first hit against an LPA library).\n    ML m LPA     (same as the previous example above).\n    ML m LNK     (search only the LINKLIST libs for member 'm' -\n                  display the first hit against an LINKLIST library).\n    ML m LINK    (same as LNK)\n    ML m         (search both LPALIST and LINKLIST libs for 'm' -\n                  display the first hit against an LPA or a\n                  LINKLIST library).\n    ML m DUP     (search both LPALIST and LINKLIST libs for all\n                   occurances of member 'm' - display all hits).\n    ML m ALL     (same as DUP)\n    ML m LIST    (List all of the LPA and LINKLIST libraries)\n    ML m LIB(SYS1.LINKLIB) - (List member 'm' - look at library\n                   'SYS1.LINKLIB' only)\n    ML m LIB(SYS1.LINKLIB VOL(SYHRS1) - (List member 'm' - look at\n                   library 'SYS1.LINKLIB' on volume 'SYHRS1' only)\n    ML m SYS1.LOADLIB - (List member 'm' - look at library\n                   'SYS1.LOADLIB' only.  Note, the load library\n                   must be at least eight characters in length if\n                   specified this way without a keyword.\n\n   06/23/2006:\n\n   Added support for calling MODLISTR as a subroutine from\n   another program.  The first parm is the membername to be\n   queried.  The second parm (optional), if included, will cause\n   program MODLISTR to return the results in a 100 byte user data\n   return area (See RETURN_INFO) in lieu of displaying the\n   results in file SYSPRINT.\n\n   SUPPORTED METHODS TO INVOKE MODLISTR:\n\n   1>    FROM REXX OR CLIST IN TSOE ENVIRONMENT:\n         \"ALLOC FI(SYSPRINT) DA(*) REUSE\"\n         \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"\n\n         \"CALL 'MODLISTR.LOADLIB(MODLISTR)' '\"MEMBERNAME\"'\"\n         MODLISTR_RC  = RC\n\n   2>    FROM REXX TSOE ENVIRONMENT AS LINKMVS:\n         \"ALLOC FI(SYSPRINT) DA(*) REUSE\"\n         \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"\n\n         ADDRESS \"LINKMVS\" 'MODLISTR MEMBERNAME'\n         MODLISTR_RC  = RC\n\n   3>    FROM REXX TSOE ENVIRONMENT AND RETURN THE RESULTS IN A\n         REXX VARIABLE (SEE WS-MODLISTR-RETURN-AREA FIELD BELOW\n         FOR THE VARIABLE STRING FORMAT) AS LINKPGM:\n\n         \"ALLOC FI(SYSPRINT) DA(*) REUSE\"\n         \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"\n\n         ADDRESS \"LINKPGM\" 'MODLISTR MEMBERNAME RETURN_AREA'\n         MODLISTR_RC  = RC\n\n   4>    CALL 'MODLISTR' DIRECTLY AS A BATCH PROGRAM:\n         //STEPX    EXEC PGM=MODLISTR,PARM=MODULENAME\n         //SYSPRINT DD  SYSOUT=*\n         //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB\n\n   5>    FROM AN APPLICATION PROGRAM CALLING 'MODLISTR' AS A\n         SUBROUTINE WITH ONE PARAMETER:\n         //STEPX    EXEC PGM=YOURPGM\n         //SYSPRINT DD  SYSOUT=*\n         //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB\n      WHERE YOURPGM DOES...\n          01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.\n          01 WS-MODULE-NAME       PIC X(8).\n          CALL WS-MODLISTR USING WS-MODULE-NAME.\n      (WS-MODULE-NAME MUST BE PADDED WITH TRAILING BLANKS)\n      RESULTS ARE WRITTEN TO FILE SYSPRINT\n\n      From an Assembler program:\n          MODNAME   DS  CL8\n          CALL MODLISTR,(MODNAME),VL\n      RESULTS ARE WRITTEN TO FILE SYSPRINT\n\n\n   6>    FROM AN APPLICATION PROGRAM CALLING 'MODLISTR' AS A\n         SUBROUTINE WITH TWO PARAMETERS:\n         //SYSPRINT DD  SYSOUT=*\n         //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB\n      where YOURPGM does...\n          01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.\n          01 WS-MODULE-NAME       PIC X(8).\n          01 WS-MODLISTR-RETURN-AREA.\n             05 WS-RA-MODNAME-LEN PIC S9(4) COMP.\n             05 WS-RA-MODNAME     PIC X(8).\n             05 WS-RA-LK-GR-DATE  PIC X(10).\n             05 WS-RA-LK-JUL-DATE PIC X(8).\n             05 WS-RA-LK-TIME     PIC X(8).\n             05 WS-RA-MODULE-LEN  PIC X(8).\n             05 WS-RA-AMODE       PIC X(3).\n             05 WS-RA-RMODE       PIC X(3).\n             05 WS-RA-APFCD       PIC X(2).\n             05 WS-RA-RENT        PIC X(2).\n             05 WS-RA-REUS        PIC X(2).\n             05 WS-RA-REFR        PIC X(2).\n             05 WS-RA-TTR         PIC X(6).\n             05 WS-RA-EPA         PIC X(8).\n             05 WS-RA-ORG-POE     PIC X(1).\n             05 WS-RA-TRUE-NAME   PIC X(8).\n             05 WS-RA-SSI         PIC X(8).\n             05 FILLER            PIC X(11).\n\n          CALL WS-MODLISTR USING WS-MODULE-NAME,\n                                 WS-MODLISTR-RETURN-AREA.\n\n      (WS-MODULE-NAME must be padded with trailing blanks)\n      RESULTS ARE NOT WRITTEN TO FILE SYSPRINT\n      Instead, the results are returned in WS-MODLISTR-RETURN-AREA\n      (a 100 byte return parameter from MODLISTR).\n\n      From an Assembler program:\n          MODNAME   DS  CL8\n          RETNAREA  DS  CL100\n          CALL MODLISTR,(MODNAME,RETNAREA),VL\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODLISTO": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x06\\x17/\\x01\\x06\\x17/\\t)\\x04S\\x04S\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-06-21T00:00:00", "modifydate": "2006-06-21T09:29:06", "lines": 1107, "newlines": 1107, "modlines": 0, "user": "TKMILLE"}, "text": "         TITLE 'MODLISTR - DISPLAY LINK-EDIT DATE/TIME/LENGTH'\n***********************************************************************\n*                                                                     *\n*  THIS PROGRAM ISSUES THE IEWBIND (BINDER) MACRO TO OBTAIN LINK-EDIT *\n*  INFORMATION FOR DISPLAY FOR A PARTICULAR LOAD MODULE MEMBER.       *\n*                                                                     *\n*  THE ML (MODLIST) EXEC CALLS THIS PROGRAM - TKMILLE 04/10/2006      *\n*                                                                     *\n*      Examples:  MODLIST modulename                                  *\n*                 MODLIST modulename   DUP                            *\n*                                                                     *\n*      (See Rexx Exec MODLIST for other examples of using the         *\n*       MODLIST (ML) exec.)                                           *\n*                                                                     *\n*  CHANGE LOG:                                                        *\n*                                                                     *\n*  PICKED THIS PROGRAM UP FROM THE WWW.XEPHON.COM WEB SITE (PROGRAM   *\n*  'POBJINFO' AND ADDED TO IT.  ADDED A CALL TO PROGRAM 'JUL2GREG'    *\n*  TO OBTAIN THE GREGORIAN DATE FROM THE JULIAN LINK-EDIT DATE.       *\n*  CHANGED THE 'TPUT' MACROS TO 'PUT' TO SYSPRINT MACROS.             *\n*                                                                     *\n*  ADDED 3 ADDITIONAL LINES OF DISPLAY (SEE BELOW) INCLUDING THE      *\n*  FOLLOWING FIELDS OBTAINED FROM THE PDS OR PDS/E MEMBER'S DIRECTORY *\n*  RECORD:                                                            *\n*                                                                     *\n*   AMODE, RMODE, APF AUTH CODE, REENTRANT ATTR, REUSE ATTR, REFRESH  *\n*   ATTR, TTR LOCATION, EPA ADDRESS, MEMBER'S DASD RESIDENT LOCATION  *\n*   VOLSER/DATASET NAME, DSORG OF LIBRARY, AND ALIAS' TRUENAME (IF    *\n*   THE MEMBER IS AN ALIAS NAME.                                      *\n*                                                                     *\n*  IT DISPLAYS 3 OR 4 LINES OF INFORMATION ON DDNAME 'SYSPRINT'       *\n*  (4 LINES IF THE MEMBER IS AN ALIAS NAME):                          *\n*                                                                     *\n*     MEMBERNAME, LINKEDIT DATE (BOTH JULIAN AND GREGORIAN DATE),     *\n*     LINKEDIT TIME, LENGTH OF THE LOAD MODULE, AMODE, RMODE,         *\n*     APF AUTH CODE, REENTRANT ATTR, REUSE ATTR, REFRESH ATTR,        *\n*     TTR LOCATION, EPA ADDRESS, MEMBER'S DASD RESIDENT LOCATION      *\n*     VOLSER/DATASET NAME, DSORG OF LIBRARY, AND ALIAS' TRUENAME (IF  *\n*     THE MEMBER IS AN ALIAS NAME (DISPLAYED ON LINE 4).              *\n*                                                                     *\n* mmmmmmmm Linked on 01/16/2006 (2006.016) at 14:35:52  LENGTH: 000012*\n* mmmmmmmm AM:  24 RM:  24 AC: 01 RN RU RF TTR:XXXXXX EPADDR: XXXXXX  *\n* mmmmmmmm VOL/DSN: Z17001 DSN=SYS1.LINKLIB                   ORG: PO *\n* mmmmmmmm *** ALIAS NAME FOR MEMBER TTTTTTTT ***                     *\n*                                                                     *\n*  ALSO MODIFIED THE PROGRAM TO BE REENTRANT.                         *\n*                                                                     *\n*       TKMILLE 04/28/2006                                            *\n*                                                                     *\n*  END OF CHANGE LOG                                                  *\n*                                                                     *\n*                                                                     *\n*  OUTPUT FILES: //SYSPRINT (3 or 4 Line Display)                     *\n*                                                                     *\n*  RETURN CODES FROM MODLISTR:                                        *\n*                                                                     *\n*  0      => Successful call to MODLISTR                              *\n*  4,8,12 => Various other return codes/reason codes from IEWBIND,    *\n*              OBTAIN, AND RDJFCB macros.                             *\n*                                                                     *\n*    Attributes:  REENTRANT, REUSEABLE, AMODE 31, RMODE 24            *\n*                                                                     *\n***********************************************************************\n*        HOUSEKEEPING                                                 *\n***********************************************************************\nMODLISTR CSECT\nMODLISTR AMODE 31\nMODLISTR RMODE 24\n         SAVE  (14,12),,MODLISTR_ASSEMBLED_ON_&SYSDATE._&SYSTIME\n         LR    R12,R15              Load entry address\n         LA    R11,2048(R12)        Chain R11 to R12 Base\n         LA    R11,2048(R11)\n         USING MODLISTR,R12,R11     Declare entry base registers\n         LR    R5,R1                Preserve passed parmlist address\n         LR    R6,R13               Store SAVEAREA Backward link\n         LA    R3,STORSIZE          Size of storage to get and clear\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)           Set SAVEAREA Forward link\n         LR    R13,R1               Address of obtained area\n         USING STORAREA,R13         Addressability to obtained area\nINITOBTN DS    0H                  Initialize the obtained storage area\n         LR    R2,R13               Address of target of move (obtnd)\n         LA    R3,STORSIZE          Length of the target of move\n         XR    R14,R14             From address (irrelevant with len=0)\n         XR    R15,R15              Pad/Length to propagate in odd reg\n         MVCL  R2,R14          Propagate binary zeroes in obtained area\n         ST    R5,PARMADDR          Store passed pointer to parms\n         ST    R6,4(,R13)           Set SAVEAREA Backward link\n         MVI   DISFLDSS,C' '\n         MVC   DISFLDSS+1(DISFLDSL-1),DISFLDSS  Init the display fields\n*********************************************************************\n*        Main routine\n*********************************************************************\nMAINROUT DS    0H\n         USING PSA,0                Define Prefixed Save Area\n         L     R1,FLCCVT            Load CVT addresss\n         USING CVT,R1               Map CVT\n         MVC   LPARNAME,CVTSNAME    Save the lpar name\n         DROP  R1\n         LA    R8,PDSDIRAR\n         USING PDS2,R8              Map PDS Directory Record\nOPENSYSP DS    0H                   Open Sysprint Report file Output\n         LA    R3,SYSPRINT          DCB to open\n         MVC   SYSPRINT(SYSPRTIL),SYSPRTI\n         MVC   WKOPENCL(OPENIL),OPENI\n         LA    R4,WKOPENCL          OPEN/CLOSE work area\n         OPEN  ((R3),OUTPUT),MODE=31,MF=(E,(R4))   OPEN SYSPRINT OUTPUT\n         LTR   R15,R15              Good open ?\n         BNZ   CLEANUP1             No\nGETPARMS DS    0H                   Get Linkage Parms\n         L     R1,PARMADDR          Get passed pointer to parms\n         BAS   R5,CHECKPRM          Make sure module name passed\n         LTR   R15,R15              Successful?\n         BNZ   RETURN               No, get out\nGETBUFFR DS    0H                   Get Binder Buffer\n         BAS   R5,INITBUFF          Go obtain and initialize buffer\n         LTR   R15,R15              Successful?\n         BNZ   RETURN               No, get out\nSTARTDIA DS    0H                   Start Binder Dialog\n         BAS   R5,STRTDIAG          Go start the binder dialog\n         LTR   R15,R15              Successful?\n         BNZ   RETURN               No, get out\nWORKMOD  DS    0H                   Create a Work Module\n         BAS   R5,CRTWMOD\n         LTR   R15,R15              Successful?\n         BNZ   CLEANUP2             No, get out\nSETLIST  DS    0H\n         BAS   R5,SETOPT            Go set the LIST option to ALL\n         LTR   R15,R15              Successful?\n         BNZ   CLEANUP1             No, get out\nINCLUDEM DS    0H\n         BAS   R5,INCLMOD           Go INCLUDE the module\n         LTR   R15,R15              Successful?\n         BZ    GETGOODS             Yes\n         BAS   R5,GET_MORE          Go get the dsn and volser\n         LTR   R15,R15              Successful?\n         BZ    GODISPLY             Yes\n         B     CLEANUP1             No, get out\nGETGOODS DS    0H                   Get all the goodies\n         BAS   R5,STORDATA          Go get the required data\n         LTR   R15,R15              Successful?\n         BNZ   CLEANUP1             No, get out\nGODISPLY DS    0H\n         BAS   R5,DISPLAY_RESULTS   Go Display the Results\nCLEANUP1 DS    0H\n         BAS   R5,DELWMOD           Go delete the workmod\nCLEANUP2 DS    0H\n         BAS   R5,ENDDIAG           Go end the dialog\nRETURN   DS    0H\n         LA    R3,SYSPRINT          DCB to close\n         MVC   WKOPENCL(OPENIL),OPENI\n         LA    R4,WKOPENCL          OPEN/CLOSE work area\n         CLOSE ((R3)),MODE=31,MF=(E,(R4))\n         L     R4,RETCODE           Pick up return code\n         LR    R2,R13               Pointer to storage area\n         LA    R3,STORSIZE          Size of storage to free\n         L     R13,4(,R13)          Restore Caller's SAVEAREA address\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\n         L     R14,12(,R13)         Restore R14\n         LR    R15,R4               Load return code\n         LM    R0,R12,20(R13)       Restore caller's registers\n         BSM   0,R14                Return to caller in caller's Amode\n**********************************************************************\n*        This routine picks up the passed module member name\n**********************************************************************\nCHECKPRM DS    0H\n         L     R1,0(R1)             Point to passed parm\n         CLC   0(2,R1),=H'1'        Name must be at least 1 byte long\n         BL    INVLPARM             Invalid parm passed\n         CLC   0(2,R1),=H'8'        Must not be longer than 8 bytes\n         BH    INVLPARM             Parm too long\n         LH    R2,0(R1)             Pick up the member name length\n         STH   R2,MEMNAME           Save the member length\n         BCTR  R2,0                 Correct the length\n         EX    R2,MVCNAME           Execute the MVC instruction\n         XR    R15,R15              Clear return code\n         B     CHECKPRX             Get out\nMVCNAME  DS    0H\n         MVC   MEMNAME8(0),2(R1)    Move parm into member name field\n*\nINVLPARM DS    0H\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'INVLP),INVLP\n         PUT   SYSPRINT,SYSPRTAR\n         LA    R15,4                Set return code\nCHECKPRX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine obtains and initializes the buffer\n**********************************************************************\nINITBUFF DS    0H\n         IEWBUFF FUNC=GETBUF,TYPE=IDRB\n         LTR   R15,R15              Successful?\n         BNZ   NOBUFF               No, failed\n         IEWBUFF FUNC=INITBUF,TYPE=IDRB\n         ST    R6,HEADER@           Preserve the header address\n         ST    R7,ENTRY@            Preserve the entry address\n         LTR   R15,R15              Successful?\n         BZ    INITBUFX             Yes, get out\nNOBUFF   DS    0H\n         ST    R15,RETCODE          Store the return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOWKBUF),NOWKBUF\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\nINITBUFX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine starts the binder dialog\n**********************************************************************\nSTRTDIAG DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=STARTD,DIALOG=DTOKEN,FILES=FILENAME,             +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    STRTDIAX             Yes, get out\nNOSTART  DS    0H\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NODIAG),NODIAG\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(6),=CL6'STARTD'\n         ST    R5,SAVER5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVER5\n         LR    R15,R2               Reload return code\nSTRTDIAX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine creates a workmod with ACCESS intent\n**********************************************************************\nCRTWMOD  DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=CREATEW,DIALOG=DTOKEN,                           +\n               INTENT=ACCESS,WORKMOD=WTOKEN,                           +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    CRTWMODX             Yes, get out\nNOCREATE DS    0H\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOWMOD),NOWMOD\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(7),=CL7'CREATEW'\n         ST    R5,SAVER5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVER5\n         LR    R15,R2               Reload return code\nCRTWMODX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine sets the LIST option to SUMMARY\n**********************************************************************\nSETOPT   DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=SETO,OPTION=OPTNLIST,                            +\n               WORKMOD=WTOKEN,OPTVAL=SUMMARY,                          +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    SETOPTX              Yes, get out\nNOSETOPT DS    0H\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOOPT),NOOPT\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(4),=CL4'SETO'\n         ST    R5,SAVER5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVER5\n         LR    R15,R2               Reload return code\nSETOPTX  DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine INCLUDEs the module\n**********************************************************************\nINCLMOD  DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=INCLUDE,WORKMOD=WTOKEN,                          +\n               DDNAME=INCLLIB,MEMBER=MEMNAME,INTYPE=NAME,              +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    INCLMODX             Yes, get out\nINCLWARN DS    0H\n*   See IBM MANUAL SA22-7644-02 for return code / reason codes\n*     RC=4 REAS=83000526 is acceptable - wrong length pds directory\n*An Unusual Condition was encountered while processing an input module\n*\n         C     R0,=X'83000526'      ACCEPTABLE WARNING?\n         BNE   NOINCLUD              NO\n         XR    R15,R15               YES, reset R15 and continue on\n         B     INCLMODX\nNOINCLUD DS    0H\n         MVC   RETCODE,SAVE_RC      Preserve return code for later on\n         MVC   RSNCODE,SAVE_RSN     Preserve reason code for later on\n         ST    R15,SAVE_R15         Preserve R15         for later on\n         MVI   SKP_BLDL,C'Y'        Indicate to skip the BLDL call\n**********************************************************************\n*        Defer printing error msg until the library dsn is obtained\n*        from the vtoc later on.\n**********************************************************************\nINCLMODX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine gets the required data binder date/time\n**********************************************************************\nSTORDATA DS    0H\n         L     R6,HEADER@           Reload the header address\n         L     R7,ENTRY@            Reload the buffer address\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=GETD,WORKMOD=WTOKEN,AREA=IEWBIDB,                +\n               CURSOR=NULL,COUNT=NUMBYTES,CLASS=CLASS,                 +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         CH    R15,=H'4'            Successful?\n         BH    NOGETDTA             No\n         CLC   IDB_DATE_BOUND,=6C'00'          Date available?\n         BE    MOVETIME                        No\nMOVEDATE DS    0H\n         MVC   JUL2GREG_JUL_DATE(7),IDB_DATE_BOUND Date for conversion\n         MVC   S0LKJLDT(4),IDB_DATE_BOUND         Julian Year\n         MVI   S0LKJLDT+4,C'.'\n         MVC   S0LKJLDT+5(3),IDB_DATE_BOUND+4     Juldays\n***********************************************************************\n* JUL2GREG is Julian-to-Gregorian Conversion program TKMILLE 04/10/2006\n*    Input  Parameter => Julian Date    (YYYYDDD)\n*    Return Parameter => Gregorian Date (YYYYMMDD)\n***********************************************************************\n         MVC   WKCALL(CALLIL),CALLI          INIT CALL PARMLIST\n         LA    R13,SAVEAREA\nGET_GREG DS    0H                            Call Program JUL2GREG\n         CALL  JUL2GREG,(JUL2GREG_JUL_DATE,JUL2GREG_GREG_DATE),VL,     +\n               MF=(E,WKCALL)\n         LTR   R15,R15                       Good call?\n         BNZ   MOVETIME                      No - Skip Greg Data Disply\nGREGDATE DS    0H\n         MVC   S0LKGRDT(2),JUL2GREG_GREG_DATE+4    Load Gregorian Month\n         MVI   S0LKGRDT+2,C'/'\n         MVC   S0LKGRDT+3(2),JUL2GREG_GREG_DATE+6  Load Gregorian Day\n         MVI   S0LKGRDT+5,C'/'\n         MVC   S0LKGRDT+6(4),JUL2GREG_GREG_DATE    Load Gregorian Year\nMOVETIME DS    0H\n         CLC   IDB_TIME_BOUND,=6C'00'          Time available?\n         BE    GET_MORE                        No\n         MVC   S0LKTIME(2),IDB_TIME_BOUND      First  part of time\n         MVI   S0LKTIME+2,C':'\n         MVC   S0LKTIME+3(2),IDB_TIME_BOUND+2  Second part of time\n         MVI   S0LKTIME+5,C':'\n         MVC   S0LKTIME+6(2),IDB_TIME_BOUND+4  Third  part of time\n*\n* ADDED CODE TO PICK UP OTHER FILEDS AS WELL FOR DISPLAY.\n*    TKMILLE 04/21/2006\n*\nGET_MORE DS 0H\n         LA    R9,IEWLIB           DCB ADDRESS\n         USING IHADCB,R9           MAP DCB\nREADJFCB DS    0H\n         LA    R3,IEWLIB                    DCB FOR RDJFCB\n         MVC   IEWLIB(IEWLIBIL),IEWLIBI\n         MVC   JFCBLIST(JFCBLSIL),JFCBLSI\n         MVC   JFCBAR(RDJFCBWL),RDJFCBW\n         LA    R1,JFCBLIST\n         STCM  R1,7,DCBEXLSA\n         LA    R1,JFCBAR\n         STCM  R1,7,JFCBLIST+1\n*\n         RDJFCB ((R9)),MF=(E,JFCBAR)        READ IN JFCB\n*\n         LTR   R15,R15             GOOD READ ?\n         BZ    FMT1DSCB             YES\n         ST    R15,RETCODE          NO\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'JFCBRERR),JFCBRERR\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\n         BR    R5                   Back to our caller\nFMT1DSCB DS    0H\n         MVC   CAMPRMLS(CAMLSTIL),CAMLSTI   INITIALIZE OBTAIN PARMLIST\n         LA    R1,JFCBDSNM\n         ST    R1,CAMLDSN\n         LA    R1,JFCBVOLS\n         ST    R1,CAMLVOL\n         LA    R1,CAMWORK\n         ST    R1,CAMLWRK\n         LA    R1,CAMPRMLS\n*\n         OBTAIN CAMPRMLS           READ IN THE FORMAT 1 DSCB VTOC REC\n*\n         LTR   R15,R15             VTOC READ SUCCESSFUL?\n         BZ    CHK_POE              YES\n         ST    R15,RETCODE          NO\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'VTOCRERR),VTOCRERR\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\n         BR    R5                   Back to our caller\nCHK_POE  DS    0H\n***********************************************************************\n*        HAVE A DSORG=PO (OR POE) DATASET ? IF NOT - ERROR SITUATION  *\n***********************************************************************\n         TM    DS1DSORG,DS1DSGPO   IS THIS A DSORG=PO (OR POE) DATASET?\n         BNO   CLEARR15             NO, NOT DSORG PO OR POE\n         TM    DS1SMSFG,DS1PDSE    IS THIS A PDS/E (POE) FILE ?\n         BNO   OPEN_PDS            NO  - NOT A PDS/E FILE\n         MVI   S2DSORG,C'E'\nOPEN_PDS DS    0H\n*\n         CLI   SKP_BLDL,C'Y'\n         BER   R5                   Back to our caller\n*\n         LA    R3,IEWLIB            DCB TO OPEN\n         MVC   WKOPENCL(OPENIL),OPENI\n         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA\n         OPEN  ((R3),INPUT),MODE=31,MF=(E,(R4))   OPEN IEWLIB INPUT\n         LTR   R15,R15              GOOD OPEN ?\n         BZ    GET_REST             YES\n         ST    R15,RETCODE          NO\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'OPENERR),OPENERR\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\n         BR    R5                   Back to our caller\nGET_REST DS    0H\n         MVC   PDSCNT,ONEH         NUMBER OF PDS MEMBERS 2B  RETURNED\n         MVC   PDSDIRL,DIRLENG     LENGTH OF EACH PDS MEMBER RETURNED\n         MVC   PDS2NAME,MEMNAME8   MEMBER FOR DIRECTORY TO BE RETURNED\n*\n         BLDL  IEWLIB,PDSLISTA     ISSUE BLDL MACRO\n*\n         LTR   R15,R15             BLDL SUCCESSFUL?\n         BZ    GET_USRL             YES\n         ST    R15,RETCODE          NO\n         LA    R3,IEWLIB            DCB TO CLOSE\n         MVC   WKOPENCL(OPENIL),OPENI\n         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA\n         CLOSE ((R3)),MODE=31,MF=(E,(R4))\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'BLDLERR),BLDLERR\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\n         BR    R5                   Back to our caller\nGET_USRL DS    0H\n         LA    R3,IEWLIB            DCB TO CLOSE\n         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA\n         CLOSE ((R3)),MODE=31,MF=(E,(R4))\n         MVC   ONEBYTE,PDS2INDC      SAVE PDS2 INDICATOR BYTE\n         NI    ONEBYTE,PDS2LUSR\n         XR    R1,R1\n         IC    R1,ONEBYTE            NBR OF HALF-WORDS IN USER DATA\n         AR    R1,R1                 DOUBLE VALUE\n         LA    R1,PDS2USRD-PDS2NAME(R1)  POINT TO END OF VAR.USER DATA\n         ST    R1,PDSDIRLN           SAVE ACTUAL PDS DIRECTORY LENGTH\nGET_MODLEN DS  0H\n         UNPK  UNPACK7(7),PDS2STOR(4)              GET MODULE LENGTH\n         TR    UNPACK7(6),HEXCHAR\n         MVI   UNPACK7+6,C' '\n         MVC   S0MODLEN(L'UNPACK7-1),UNPACK7    MOVE MODULE LENGTH\nGET_TTR  DS    0H\n         UNPK  UNPACK7(7),PDS2TTRP(4)              GET TTR\n         TR    UNPACK7(6),HEXCHAR\n         MVI   UNPACK7+6,C' '\n         MVC   S1TTR,UNPACK7              MOVE TTR TO DISPLAY AREA\nGET_EPA  DS    0H\n         UNPK  UNPACK7(7),PDS2EPA(4)      GET EP ADDRESS\n         TR    UNPACK7(6),HEXCHAR\n         MVI   UNPACK7+6,C' '\n         MVC   S1EPA,UNPACK7              MOVE EPA TO DISPLAY AREA\nCHK_RENT DS    0H\n         TM    PDS2ATR1,PDS2RENT          IS MODULE REENTRANT ?\n         BNO   CHK_REUS                   NO  - NOT RENTRANT\n         MVC   S1RENT,=CL2'RN'            YES -     RENTRANT\nCHK_REUS DS    0H\n         TM    PDS2ATR1,PDS2REUS          IS MODULE SERIALLY REUSEABLE?\n         BNO   CHK_REFR                   NO  - NOT REUSEABLE\n         MVC   S1REUS,=CL2'RU'            YES -     REUSEABLE\nCHK_REFR DS    0H\n         TM    PDS2ATR2,PDS2REFR          IS MODULE REFRESHABLE ?\n         BNO   GET_AMODE                  NO  - NOT REFRESHABLE\n         MVC   S1REFR,=CL2'RF'            YES -     REFRESHABLE\nGET_AMODE DS   0H\n         TM    PDS2INDC,PDS2ALIS      IS MEMBERNAME AN ALIAS ?\n         BNO   GET_MAIN_AMODE           NO  - GET MAIN EP AMODE\n         TM    PDS2FTB2,PDSAAMOD      TEST ALIAS AMODE\n         BO    AMODE_ANY                AMODE = ANY\n         BZ    AMODE_24                 AMODE =  24\n         TM    PDS2FTB2,B'00001000'   TEST ALIAS AMODE = 31  ?\n         BO    AMODE_31                 AMODE =  31\n         B     AMODE_64                 AMODE =  64\nGET_MAIN_AMODE DS 0H\n         TM    PDS2FTB2,PDSMAMOD      TEST MAIN EP AMODE\n         BO    AMODE_ANY                AMODE = ANY\n         BZ    AMODE_24                 AMODE =  24\n         TM    PDS2FTB2,B'00000010'   TEST MAIN EP AMODE = 31 ?\n         BO    AMODE_31                 AMODE =  31\nAMODE_64 DS    0H\n         MVC   S1AMODE,=CL3' 64'        AMODE =  64\n         B     GET_RMODE\nAMODE_ANY      DS 0H\n         MVC   S1AMODE,=CL3'ANY'        AMODE = ANY\n         B     GET_RMODE\nAMODE_31       DS 0H\n         MVC   S1AMODE,=CL3' 31'        AMODE = 31\n         B     GET_RMODE\nAMODE_24       DS 0H\n         MVC   S1AMODE,=CL3' 24'        AMODE = 24\nGET_RMODE DS   0H\n         TM    PDS2FTB2,PDSLRMOD      TEST RMODE ATTRIBUTE\n         BO    RMODE_ANY                RMODE = ANY\n         MVC   S1RMODE,=CL3' 24'        RMODE = 24\n         B     CHK_OTHER_SECTIONS\nRMODE_ANY DS   0H\n         MVC   S1RMODE,=CL3'ANY'        RMODE = ANY\nCHK_OTHER_SECTIONS  DS  0H\n         LR    R4,R8                POINT TO START OF FIXED LENGTH AREA\n         LA    R4,PDSBCLN-1(R4)     POINT TO END OF FIXED LENGTH AREA\n*\n* CHECK FOR SCATTER SECTION\n*\nCHK_SCATR DS   0H\n         TM    PDS2ATR1,PDS2SCTR         IS SCATTER SECTION present ?\n         BNO   CHK_ALIAS                  NO\n         LA    R4,1(R4)              MOVE TO START OF SCATTER SECTION\n         ST    R4,SCAADDR            STORE SCATTER SECTION ADDRESS\n         LA    R4,PDSS01LN-1(R4)     MOVE TO END OF SCATTER SECTION\n*\n* CHECK FOR ALIAS SECTION\n*\nCHK_ALIAS DS   0H\n         TM    PDS2INDC,PDS2ALIS   IS ALIAS SECTION PRESENT ?\n         BNO   CHK_SSI              NO  - MEMBER IS NOT AN ALIAS NAME\n         LA    R4,1(R4)              MOVE TO START OF ALIAS SECTION\n         ST    R4,ALIADDR            STORE ALIAS SECTION ADDRESS\n         LR    R2,R4\n         LA    R2,PDS2MNM-PDSS02(R2) POINT TO ALIAS TRUENAME\n         MVC   S3TRUENM,0(R2)        GET ALIAS' TRUENAME\n         LA    R4,PDSS02LN-1(R4)     MOVE TO END OF ALIAS SECTION\n*\n* CHECK FOR SSI INFORMATION SECTION\n*\nCHK_SSI  DS    0H\n         TM    PDS2FTB1,PDS2SSI    IS SSI SECTION PRESENT ?\n         BNO   CHK_APF              NO\n         LA    R4,1(R4)              MOVE TO START OF SSI SECTION\n         ST    R4,SSIADDR            STORE SSI INFO SECTION ADDRESS\n         LA    R4,PDSS03LN-1(R4)     MOVE TO END OF SSI SECTION\n*\n* CHECK FOR APF AUTHORIZATION SECTION\n*\nCHK_APF  DS    0H                  APF SECTION IS ASSUMED TO BE PRESENT\n         LA    R4,1(R4)              MOVE TO START OF APF SECTION\n         ST    R4,APFADDR            STORE APF SECTION ADDRESS\n         LR    R2,R4\n         LA    R2,PDSAPFCT-PDSS04(R2)\n         MVC   S1APFCD,=CL2'00'           SET DEFAULT 00\n         TM    PDS2FTB1,PDSAPFLG          IS APFCODE VALID ?\n         BNO   GET_LRGOF                  NO  - NOT RENTRANT\n         CLC   0(1,R2),XL00               APF AUTH CD LENGTH = 0 ?\n         BE    GET_LRGOF                   YES\n         CLC   0(1,R2),XL01               APF AUTH CD LENGTH = 1 ?\n         BNE   GET_LRGOF                   NO\n         LA    R2,1(R2)\n         XR    R1,R1                      YES\n         ICM   R1,B'0001',0(R2)           LOAD APF AUTH CODE (FL1)\n         ST    R1,DOUBLE\n         UNPK  UNPACK9(9),DOUBLE(5)       GET APF AUTH CODE\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   S1APFCD,UNPACK9+6          MOVE APF CODE TO DISPL AREA\n         L     R4,APFADDR\n         LA    R4,PDSS04LN-1(R4)     MOVE TO END OF APF SECTION\n*\n* CHECK FOR LARGE PROGRAM SECTION\n*\nGET_LRGOF DS   0H\n         TM    PDS2FTB1,PDS2BIG    IS LARGE PGM SECTION PRESENT ?\n         BNO   CLEARR15             NO\n         LA    R4,1(R4)              MOVE TO START OF LARGE PGM SECTION\n         ST    R4,LRGADDR            STORE LARGE PGM SECTION ADDRESS\n*\n         DROP  R9\n*\nCLEARR15 DS    0H\n         XR    R15,R15              Data successfully obtained\n         B     STORDATX             Get out\nNOGETDTA DS    0H\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NODATA),NODATA\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(4),=CL4'GETD'\n         ST    R5,SAVER5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVER5\n         LR    R15,R2               Reload return code\nSTORDATX DS    0H\n         BR    R5                   Back to our caller\n*\nDISPLAY_RESULTS DS   0H\n         CLI   SKP_BLDL,C'Y'           Was member found in lib ?\n         BNE   DIS_DT_TM               Yes\n**********************************************************************\n*  Display Member Not Found Message\n**********************************************************************\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         LA    R1,SYSPRTAR\n         MVC   0(L'NOTFNDM1,R1),NOTFNDM1\n         LA    R1,L'NOTFNDM1(R1)\n         LH    R2,MEMNAME           Get Member Length\n         BCTR  R2,0                 Correct the length for EX Move\n         EX    R2,MVCNAME2          Execute the MVC instruction\n         LA    R1,1(R1,R2)\n         MVC   0(L'NOTFNDM2,R1),NOTFNDM2\n         LA    R1,L'NOTFNDM2(R1)\n         MVC   0(L'JFCBDSNM,R1),JFCBDSNM\n         LA    R1,L'JFCBDSNM(R1)\nDSN_LEN  DS    0H                        Find end of dsn in msg\n         CLI   0(R1),C' '                Look for a non-blank char\n         BNE   DSN_LFND                  Found trailing dsn char\n         BCT   R1,DSN_LEN\nDSN_LFND DS    0H\n         MVC   1(L'NOTFNDM3,R1),NOTFNDM3\n         LA    R1,L'NOTFNDM3(R1)\n         MVC   1(L'LPARNAME,R1),LPARNAME\n         PUT   SYSPRINT,SYSPRTAR\n         B     DISPLAYX\nMVCNAME2 DS    0H\n         MVC   0(0,R1),MEMNAME8\n*\nDIS_DT_TM DS   0H\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L_SYSREC0),SYSREC0\n         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+20(L'S0LKGRDT),S0LKGRDT\n         MVC   SYSPRTAR+32(L'S0LKJLDT),S0LKJLDT\n         CLC   IDB_TIME_BOUND,=6C'00'              Time available?\n         BE    DIS_LENGTH                          No\n         MVC   SYSPRTAR+46(L'S0LKTIME),S0LKTIME\nDIS_LENGTH DS  0H\n         MVC   SYSPRTAR+65(L'S0MODLEN),S0MODLEN\n         MVC   SYSPRTAR+76(3),LPARNAME\n         PUT   SYSPRINT,SYSPRTAR\n*\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L_SYSREC1),SYSREC1\n         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+14(L'S1AMODE),S1AMODE\n         MVC   SYSPRTAR+22(L'S1RMODE),S1RMODE\n         MVC   SYSPRTAR+30(L'S1APFCD),S1APFCD\n         MVC   SYSPRTAR+34(L'S1RENT),S1RENT\n         MVC   SYSPRTAR+37(L'S1REUS),S1REUS\n         MVC   SYSPRTAR+40(L'S1REFR),S1REFR\n         MVC   SYSPRTAR+48(L'S1TTR),S1TTR\n         MVC   SYSPRTAR+65(L'S1EPA),S1EPA\n         PUT   SYSPRINT,SYSPRTAR\n*\nDISP_DSN DS    0H\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L_SYSREC2),SYSREC2\n         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+19(L'JFCBVOLS),JFCBVOLS\n         MVC   SYSPRTAR+26(L'JFCBDSNM),JFCBDSNM\n         MVC   SYSPRTAR+78(L'S2DSORG),S2DSORG\n         PUT   SYSPRINT,SYSPRTAR\n*\n         CLI   SKP_BLDL,C'Y'           Was member found in lib ?\n         BE    DISPLAYX                No\n*\n         TM    PDS2INDC,PDS2ALIS   IS MEMBER AN ALIAS NAME  ?\n         BNO   DISPLAYX             NO  - MEMBER IS NOT AN ALIAS NAME\n         MVI   SYSPRTAR,C' '                   YES - IS AN ALIAS NAME\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L_SYSREC3),SYSREC3\n         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+36(L'S3TRUENM),S3TRUENM\n         PUT   SYSPRINT,SYSPRTAR\nDISPLAYX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine deletes the workmod\n**********************************************************************\nDELWMOD  DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=DELETEW,WORKMOD=WTOKEN,                          +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    DELWMODX             Yes, get out\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NODEL),NODEL\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(7),=CL7'DELETEW'\n         ST    R5,SAVER5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVER5\n         LR    R15,R2               Reload return code\nDELWMODX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine ends the dialog\n**********************************************************************\nENDDIAG  DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=ENDD,DIALOG=DTOKEN,                              +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    ENDDIAGX             Yes, get out\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOEND),NOEND\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(4),=CL4'ENDD'\n         ST    R5,SAVER5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVER5\n         LR    R15,R2               Reload return code\nENDDIAGX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine makes the return and reason codes printable\n**********************************************************************\nSHOWCODE DS    0H\n         MVC   LOWBYTES,RETCODE     Move return and reason code in\n         NC    LOWBYTES(8),=8X'F0'  Turn off the second part bytes\n         TR    LOWBYTES(8),LEFTHALF\n         MVC   HIGBYTES,RETCODE     Move return and reason code in\n         NC    HIGBYTES(8),=8X'0F'  Turn off the first part bytes\n         TR    HIGBYTES(8),RIGTHALF\n         LA    R1,LOWBYTES         Where the first half of each byte is\n         LA    R2,HIGBYTES          Where second half of each byte is\n         LA    R3,WORKAREA          Where we want to move the data to\n         LA    R4,8                 8 bytes to move\nCODELOOP DS    0H\n         MVC   0(1,R3),0(R1)        Move first half of byte\n         LA    R3,1(R3)             Bump up target pointer\n         MVC   0(1,R3),0(R2)        Move second half of byte\n         LA    R3,1(R3)             Bump up target pointer\n         LA    R1,1(R1)             Bump up first-half-of-byte pointer\n         LA    R2,1(R2)             Bump up second-half-of-byte pointer\n         BCT   R4,CODELOOP          Do for each of the bytes\n         MVC   COEXMSG(CODEMSGL),CODEMSG\n         MVC   COEXMSG+14(8),WORKAREA\n         MVC   COEXMSG+36(8),WORKAREA+8\nRCREASN  DS    0H\n         CLI   COEXFUNC,C' '              IEWBIND MACRO ERROR ?\n         BE    SHOWCODX                    NO\n         MVI   SYSPRTAR,C' '               YES\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   COEXMEMB(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+1(COEXMSGL),COEXMSGA\n         PUT   SYSPRINT,SYSPRTAR\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\nSHOWCODX DS    0H\n         BR    R5\n**********************************************************************\n*    STATIC STORAGE FOLLOWS\n**********************************************************************\n         LTORG\nINVLP    DC    C'MODLISTR error - Invalid member name passed.'\nNOWKBUF  DC    C'MODLISTR error - Failed to obtain and init work buffer+\n               .'\nNODIAG   DC    C'MODLISTR error - Failed to START dialog.'\nNOWMOD   DC    C'MODLISTR error - Failed to CREATE a workmod.'\nNOOPT    DC    C'MODLISTR error - Failed to set LIST=SUMMARY option.'\nNOINCL   DC    C'MODLISTR error - Failed to INCLUDE module.'\nNODATA   DC    C'MODLISTR error - Failed to OBTAIN data for module.'\nNODEL    DC    C'MODLISTR error - Failed to DELETE workmod.'\nNOEND    DC    C'MODLISTR error - Failed to END dialog.'\nNODATE   DC    C'MODLISTR error - Failed to obtain gregorian date.'\nJFCBRERR DC    C'MODLISTR error - Error Reading JFCB for File IEWLIB.'\nVTOCRERR DC    C'MODLISTR error - Error Reading Format 1 Vtoc.'\nOPENERR  DC    C'MODLISTR error - Error Opening PDS File.'\nBLDLERR  DC    C'MODLISTR error - Error Calling BLDL macro.'\n*\nINCLLIB  DC    H'6',C'IEWLIB'\nCLASS    DC    H'6',C'B_IDRB'\n*\nCODEMSGA DC    0C\n         DC    CL33'  IEWBIND macro error for module '\n         DC    CL8'        '\n         DC    CL16'.  IEWBIND FUNC='\n         DC    CL8'        '\nCODEMSGL EQU   *-CODEMSGA\n*\nNOTFNDM1 DC    C' MODULE \"'\nNOTFNDM2 DC    C'\" NOT FOUND IN LIBRARY \"'\nNOTFNDM3 DC    C'\" ON '\n*\nCODEMSG  DC    CL44'  Return Code=????????, Reason Code=????????'\n*\n         IEWBIND PLISTVER,MF=(L,IEWPLSTW,0D)\nIEWPLSTL EQU   *-IEWPLSTW\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRB,SIZE=1000,HEADREG=6,ENTRYREG=7, +\n               VERSION=5\n*\nFILENAME DS    0F\n         DC    F'0'                  Swap with next card to get BINDER\n*        DC    F'2'                    messages displayed\n         DC    CL8'TERM',F'8',A(TERM)\n         DC    CL8'PRINT',F'8',A(TERM)\n*\nTERM     DC    CL7'IEWINFO'          DD-name messages will go to\nOPTNLIST DC    H'4',C'LIST'          Option LIST=SUMMARY\nSUMMARY  DC    H'7',C'SUMMARY'       Option LIST=SUMMARY\n*\nLEFTHALF DS    0CL240\n         DC    X'F0',15X'00',X'F1',15X'00',X'F2',15X'00',X'F3'\n         DC    15X'00',X'F4',15X'00',X'F5',15X'00',X'F6',15X'00',X'F7'\n         DC    15X'00',X'F8',15X'00',X'F9',15X'00',X'C1',15X'00',X'C2'\n         DC    15X'00',X'C3',15X'00',X'C4',15X'00',X'C5',15X'00',X'C6'\nRIGTHALF DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n*\nHEXCHAR  EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n*\nSYSPRTI  DCB   DDNAME=SYSPRINT,MACRF=(PM),DSORG=PS,                    +\n               LRECL=121,RECFM=F\nSYSPRTIL EQU   *-SYSPRTI           LENGTH OF SYSPRTI\n*\nIEWLIBI  DCB   DDNAME=IEWLIB,MACRF=(R),DSORG=PO,LRECL=0,RECFM=U,       +\n               EXLST=*,DEVD=DA\nIEWLIBIL EQU   *-IEWLIBI           LENGTH OF IEWLIBI\n*\nRDJFCBW        RDJFCB  *,MF=L                   JFCB WORK AREA INIT\nRDJFCBWL       EQU   *-RDJFCBW                  LENGTH OF RDJFCBW\n*\nJFCBLSI        DC    0F'0',XL1'87',AL3(0)       INIT JFCB PARMLIST\nJFCBLSIL       EQU   *-JFCBLSI\n*\nOPENI          OPEN  (*,OUTPUT),MODE=31,MF=L\nOPENIL         EQU   *-OPENI                      LENGTH OF OPENI\n*\nCALLI          CALL  ,(*,*),VL,MF=L\nCALLIL         EQU   *-CALLI                      LENGTH OF CALLI\n*\nJUL2GREG       DC    V(JUL2GREG)         ADDRESS OF PGM JUL2GREG\n*\nCAMLSTI        CAMLST SEARCH,1,2,3       OBTAIN PARMLIST INIT AREA\nCAMLSTIL       EQU   *-CAMLSTI\n*\nONEH           DC    H'1'\nXL00           DC    XL1'00'\nXL01           DC    XL1'01'\n*\nDIRLENG        DC    Y(PDS2LEN)\n*\n***********************************************************************\n* DISPLAY LINE AREAS FOLLOW\n***********************************************************************\nSYSREC0     DC    0C\n            DC    CL8'        '           MODULE MEMBER NAME\n            DC    C' Linked on '\n            DC    CL10'mm/dd/yyyy'        Gregorian Link Edit Date\n            DC    C' ('\n            DC    CL8'yyyy.ddd'           Julian    Link Edit Date\n            DC    C')  at '\n            DC    CL8'hh:mm:ss'           Link Edit Time of Day\n            DC    C'   LENGTH: '\n            DC    CL6'      '             Module Length\nL_SYSREC0   EQU   *-SYSREC0\n*\nSYSREC1     DC    0C\n            DC    CL8'        '           MODULE MEMBER NAME\n            DC    C' AM: '\n            DC    CL3'  '                 AMODE\n            DC    C' RM: '\n            DC    CL3'  '                 RMODE\n            DC    C' AC: '\n            DC    CL2'  '                 APF CODE\n            DC    C'  '\n            DC    CL2'  '                 REENTRANT ATTRIBUTE\n            DC    C' '\n            DC    CL2'  '                 REUSE ATTRIBUTE\n            DC    C' '\n            DC    CL2'  '                 REFRESH ATTRIBUTE\n            DC    C' TTR: '\n            DC    CL6'      '             TTR\n            DC    C'   EPADDR: '\n            DC    CL6'      '             EPA ADDRESS\nL_SYSREC1   EQU   *-SYSREC1\n*\nSYSREC2     DC    0C\n            DC    CL8'        '           MODULE MEMBER NAME\n            DC    C' VOL/DSN: '\n            DC    CL6'      '             VOLSER\n            DC    C' '\n            DC    44CL1' '                LOAD LIBRARY DATA SET NAME\n            DC    C' ORG: PO'                      DSORG=PO\n            DC    CL1' '                  LIBRARY DSORG DSORG=POE\nL_SYSREC2   EQU   *-SYSREC2\n*\nSYSREC3     DC    0C\n            DC    CL8'        '           MODULE MEMBER NAME\n            DC    C' *** ALIAS NAME FOR MEMBER '\n            DC    CL8'        '           ALIAS TRUENAME\n            DC    C' ***'\nL_SYSREC3   EQU   *-SYSREC3\n*\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS  (GETMAINED AREA)\n**********************************************************************\nSTORAREA    DSECT ,                 REENTRANT STORAGE\nSAVEAREA    DS    20F\nPARMADDR    DS    F                 Linkage Parameter List Address\nSAVER5      DS    F                 Store R5 for Nested branches\nDTOKEN      DS    D                 Dialog token\nWTOKEN      DS    D                 Workmod token\nDOUBLE      DS    D                 General workarea\nRETCODE     DS    F                 Return code\nRSNCODE     DS    F                 Reason code\nSAVE_RC     DS    F                 Saved Return code\nSAVE_RSN    DS    F                 Saved Reason code\nSAVE_R15    DS    F                 Saved R15\nLOWBYTES    DS    CL8               Workarea to make codes printable\nHIGBYTES    DS    CL8               Workarea to make codes printable\nWORKAREA    DS    CL16              Print format return and reason code\nNULL        DS    F                 Where binder should begin\nNUMBYTES    DS    F                 Number of bytes returned to us\nHEADER@     DS    F                 Address of IEW header\nENTRY@      DS    F                 Address of IEW data entry\n*\nLPARNAME    DS    CL8               LPAR Name\n*\nSYSPRINT    DS    CL(SYSPRTIL)      SYSPRINT DCB AREA\nIEWLIB      DS    CL(IEWLIBIL)      IEWLIB   DCB AREA\nWKOPENCL    DS    CL(OPENIL)        OPEN/CLOSE WORK AREA\nWKCALL      DS    CL(CALLIL)        CALL WORK AREA\nIEWPLIST    DS    CL(IEWPLSTL)      IEWBIND PARMLIST AREA\n*\nJFCBLIST    DS    F\nJFCBAR      DS    CL(RDJFCBWL)      RDJFCB WORK AREA\n            ORG   JFCBAR\n            IEFJFCBN LIST=YES\n*\nSYSPRTAR    DS    CL121\n*\n**********************************************************************\n* OBTAIN SEARCH PARAMETER LIST FOLLOWS\n**********************************************************************\nCAMPRMLS    DS    0F                CAMLST PARAMETER LIST\nCAMLFUNC    DS    X                 FUNCTION\nCAML2       DS    X                 NOT USED WITH SEARCH\nCAML3       DS    X                 NOT USED WITH SEARCH\nCAML4       DS    X                 NOT USED WITH SEARCH\nCAMLDSN     DS    F                 CAMLIST DATASET NAME\nCAMLVOL     DS    F                 CAMLIST VOLSER\nCAMLWRK     DS    F                 CAMLIST WORK AREA\n*\nCAMWORK     DS    0D,CL148\n            ORG   CAMWORK-44        RECORD KEY IS NOT RETURNED\n            IECSDSL1 (1)            FORMAT 1 DSCB\n            ORG   ,\n*\n**********************************************************************\n* BLDL MACRO WORK AREA FOLLOWS\n**********************************************************************\n*\nPDSLISTA    DS    0F                BLDL LIST ADDRESS\nPDSCNT      DS    H                 NBR OF MEMBERS TO RETURN\nPDSDIRL     DS    H                 RESERVED LENGTH OF EACH DIRECTORY\nPDSDIRAR    DS    CL(PDS2LEN)       PDS DIRECTORY AREA\nPDSLISTL    EQU   *-PDSLISTA\n*\nPDSDIRLN    DS    F         LENGTH OF PDR DIRECTORY RETURNED BY BLDL\nSCAADDR     DS    F         SCATTER SECTION ADDRESS (IF PRESENT)\nALIADDR     DS    F         ALIAS SECTION ADDRESS  (IF PRESENT)\nSSIADDR     DS    F         SSI SECTION ADDRESS    (IF PRESENT)\nAPFADDR     DS    F         APF SECTION ADDRESS    (ASSUMED PRESENT)\nLRGADDR     DS    F         LARGE PRORGRAM SECTION ADDRESS (IF PRESENT)\nONEBYTE     DS    CL1\n*\nCOEXMSGA    DS    0C\n            DS    CL33\nCOEXMEMB    DS    CL8\n            DS    CL16\nCOEXFUNC    DS    CL8\nCOEXMSGL    EQU   *-COEXMSGA\n*\nCOEXMSG     DS    CL44\n*\nUNPACK7     DS    CL7\nUNPACK9     DS    CL9\n*\n***********************************************************************\n* JUL2GREG is Julian-to-Gregorian Conversion program TKMILLE 04/10/2006\n***********************************************************************\nJUL2GREG_JUL_DATE  DS   ZL7           /* YYYYDDDD PASSED AS PARM   */\nJUL2GREG_GREG_DATE DS   ZL8           /* YYYYMMDD RETURNED AS PARM */\n*\nDISFLDSS    DS    0C\n*\nSKP_BLDL    DS    CL1                 CALL BLDL INDICATOR\n*\nMEMNAME     DS    H\nMEMNAME8    DS    CL8                 MEMBER NAME PASSED AS PARM\n*\nS0LKGRDT    DS    CL10                LINK EDIT GREGORIAN DATE\nS0LKJLDT    DS    CL8                 LINK EDIT JULIAN    DATE\nS0LKTIME    DS    CL8                 LINK EDIT TIME OF DAY\nS0MODLEN    DS    CL6                 MODULE LENGTH\n*\nS1AMODE     DS    CL3                 AMODE\nS1RMODE     DS    CL3                 RMODE\nS1APFCD     DS    CL2                 APF CODE\nS1RENT      DS    CL2                 REENTRANT ATTRIBUTE\nS1REUS      DS    CL2                 REUSE ATTRIBUTE\nS1REFR      DS    CL2                 REFRESH ATTRIBUTE\nS1TTR       DS    CL6                 TTR\nS1EPA       DS    CL6                 EPA ADDRESS\n*\nS2DSORG     DS    CL1                 LIBRARY DSORG  DSORG=POE\n*\nS3TRUENM    DS    CL8                 ALIAS' TRUE NAME\n*\nDISFLDSL    EQU   *-DISFLDSS\n*\nSTORSIZE    EQU   *-STORAREA\n*\n            YREGS                          Register Equates\nDSECDCBD    DCBD     DSORG=PO,DEVD=DA\nDSECTPSA    IHAPSA   LIST=YES              Map PSA\nDSECTCVT    CVT      DSECT=YES,LIST=YES    Map CVT\nDSECTPDS    IHAPDS                         Map PDS and PDS/E Directory\nPDS2LEN     EQU   *-PDS2                   Get length of IHAPDS macro\n            END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODLISTR": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01?\\x00\\x14\\x01\\x07\\x15\\x1f\\x01\\x10\\to\\x15X\\x058\\x05'\\x00\\x00\\xe3\\xd2\\xd4\\xc9\\xd3\\xd3\\xc5@@@\"", "ispf": {"version": "01.63", "flags": 0, "createdate": "2007-05-31T00:00:00", "modifydate": "2010-04-06T15:58:14", "lines": 1336, "newlines": 1319, "modlines": 0, "user": "TKMILLE"}, "text": "         TITLE 'MODLISTR - DISPLAY LINKEDIT INFORMATION - DATE/TIME/LEN+\n               GTH OF MODULE, AND OTHER LINKEDIT ATTRIBUTES '\n***********************************************************************\n*                                                                     *\n*        M   M OOOOO DDDD  L      III   SSSS TTTTT RRRR               *\n*        MM MM O   O D   D L       I   S       T   R   R              *\n*        M M M O   O D   D L       I    SSS    T   RRRR               *\n*        M   M O   O D   D L       I       S   T   R  R               *\n*        M   M OOOOO DDDD  LLLLL  III  SSSS    T   R   R              *\n*                                                                     *\n*  AUTHOR:      TKMILLE on 05/31/2006                                 *\n*  LAST UPDATE: 04/06/2010 by TKMILLE                                 *\n*                                                                     *\n*  THIS PROGRAM ISSUES THE IEWBIND (BINDER) MACRO TO OBTAIN LINK-EDIT *\n*  INFORMATION FOR DISPLAY FOR A PARTICULAR LOAD MODULE MEMBER.       *\n*                                                                     *\n*  THE ML (MODLIST) EXEC CALLS THIS PROGRAM - TKMILLE 04/10/2006      *\n*                                                                     *\n*      Examples:  MODLIST modulename                                  *\n*                 MODLIST modulename   DUP                            *\n*                                                                     *\n*      (See Rexx Exec MODLIST for other examples of using the         *\n*       MODLIST (ML) exec.)                                           *\n*                                                                     *\n* SAMPLE DISPLAY:                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*         M   M M   M M   M M   M M   M M   M M   M M   M             *\n*         MM MM MM MM MM MM MM MM MM MM MM MM MM MM MM MM             *\n*  SYx    M M M M M M M M M M M M M M M M M M M M M M M M       Date  *\n*         M   M M   M M   M M   M M   M M   M M   M M   M       Time  *\n*         M   M M   M M   M M   M M   M M   M M   M M   M             *\n*                                                                     *\n*mmmmmmmm Linked on 01/16/2006 (2006.016) at 14:35:52 LENGTH: 00000AFE*\n*mmmmmmmm AM:  24 RM:  24 AC: 01 RN RU RF TTR: 00AE1F EPADDR: 00000A09*\n*mmmmmmmm VOL/DSN: Z17001 DSN=SYS1.LINKLIB                    ORG: PO *\n*mmmmmmmm SSI: 00112987   *** ALIAS NAME FOR MEMBER TTTTTTTT ***      *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*  CHANGE LOG (MOST RECENT CHANGES LISTED FIRST)                      *\n*                                                                     *\n*  Added support for calling MODLISTR as a subroutine from            *\n*  another program.  The first parm is the membername to be           *\n*  queried.  The second parm (optional), if included, will cause      *\n*  program MODLISTR to return the results in a 100 byte user data     *\n*  return area (See RETURN_INFO) in lieu of displaying the            *\n*  results in file SYSPRINT.                                          *\n*                                                                     *\n*  SUPPORTED METHODS TO INVOKE MODLISTR:                              *\n*                                                                     *\n*  1>    FROM REXX OR CLIST IN TSOE ENVIRONMENT:                      *\n*        \"ALLOC FI(SYSPRINT) DA(*) REUSE\"                             *\n*        \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"              *\n*                                                                     *\n*        \"CALL 'MODLISTR.LOADLIB(MODLISTR)' '\"MEMBERNAME\"'\"           *\n*        MODLISTR_RC  = RC                                            *\n*                                                                     *\n*  2>    FROM REXX TSOE ENVIRONMENT AS LINKMVS:                       *\n*        \"ALLOC FI(SYSPRINT) DA(*) REUSE\"                             *\n*        \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"              *\n*                                                                     *\n*        ADDRESS \"LINKMVS\" 'MODLISTR MEMBERNAME'                      *\n*        MODLISTR_RC  = RC                                            *\n*                                                                     *\n*  3>    FROM REXX TSOE ENVIRONMENT AND RETURN THE RESULTS IN A       *\n*        REXX VARIABLE (SEE WS-MODLISTR-RETURN-AREA FIELD BELOW       *\n*        FOR THE VARIABLE STRING FORMAT) AS LINKPGM:                  *\n*                                                                     *\n*        \"ALLOC FI(SYSPRINT) DA(*) REUSE\"                             *\n*        \"ALLOC FI(IEWLIB)   DA('MY.LOADLIB') SHR REUSE\"              *\n*                                                                     *\n*        ADDRESS \"LINKPGM\" 'MODLISTR MEMBERNAME RETURN_AREA'          *\n*        MODLISTR_RC  = RC                                            *\n*                                                                     *\n*  4>    CALL 'MODLISTR' DIRECTLY AS A BATCH PROGRAM:                 *\n*        //STEPX    EXEC PGM=MODLISTR,PARM=MODULENAME                 *\n*        //SYSPRINT DD  SYSOUT=*                                      *\n*        //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB                       *\n*                                                                     *\n*  5>    FROM AN APPLICATION PROGRAM CALLING 'MODLISTR' AS A          *\n*        SUBROUTINE WITH ONE PARAMETER:                               *\n*        //STEPX    EXEC PGM=YOURPGM                                  *\n*        //SYSPRINT DD  SYSOUT=*                                      *\n*        //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB                       *\n*     WHERE YOURPGM DOES...                                           *\n*         01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.         *\n*         01 WS-MODULE-NAME       PIC X(8).                           *\n*         CALL WS-MODLISTR USING WS-MODULE-NAME.                      *\n*     (WS-MODULE-NAME MUST BE PADDED WITH TRAILING BLANKS)            *\n*     RESULTS ARE WRITTEN TO FILE SYSPRINT                            *\n*                                                                     *\n*         MODNAME   DS  CL8                                           *\n*         CALL MODLISTR,(MODNAME),VL                                  *\n*                                                                     *\n*  6>    FROM AN APPLICATION PROGRAM CALLING 'MODLISTR' AS A          *\n*        SUBROUTINE WITH TWO PARAMETERS:                              *\n*        //SYSPRINT DD  SYSOUT=*                                      *\n*        //IEWLIB   DD  DISP=SHR,DSN=MY.LOADLIB                       *\n*     where YOURPGM does...                                           *\n*         01 WS-MODLISTR          PIC X(8)  VALUE 'MODLISTR'.         *\n*         01 WS-MODULE-NAME       PIC X(8).                           *\n*         01 WS-MODLISTR-RETURN-AREA.                                 *\n*            05 WS-RA-MODNAME-LEN PIC S9(4) COMP.                     *\n*            05 WS-RA-MODNAME     PIC X(8).                           *\n*            05 WS-RA-LK-GR-DATE  PIC X(10).                          *\n*            05 WS-RA-LK-JUL-DATE PIC X(8).                           *\n*            05 WS-RA-LK-TIME     PIC X(8).                           *\n*            05 WS-RA-MODULE-LEN  PIC X(8).                           *\n*            05 WS-RA-AMODE       PIC X(3).                           *\n*            05 WS-RA-RMODE       PIC X(3).                           *\n*            05 WS-RA-APFCD       PIC X(2).                           *\n*            05 WS-RA-RENT        PIC X(2).                           *\n*            05 WS-RA-REUS        PIC X(2).                           *\n*            05 WS-RA-REFR        PIC X(2).                           *\n*            05 WS-RA-TTR         PIC X(6).                           *\n*            05 WS-RA-EPA         PIC X(8).                           *\n*            05 WS-RA-ORG-POE     PIC X(1).                           *\n*            05 WS-RA-TRUE-NAME   PIC X(8).                           *\n*            05 WS-RA-SSI         PIC X(8).                           *\n*            05 FILLER            PIC X(11).                          *\n*                                                                     *\n*         CALL WS-MODLISTR USING WS-MODULE-NAME,                      *\n*                                WS-MODLISTR-RETURN-AREA.             *\n*                                                                     *\n*     (WS-MODULE-NAME must be padded with trailing blanks)            *\n*     RESULTS ARE NOT WRITTEN TO FILE SYSPRINT                        *\n*     Instead, the results are returned in WS-MODLISTR-RETURN-AREA    *\n*     (a 100 byte return parameter from MODLISTR).                    *\n*                                                                     *\n*         MODNAME   DS  CL8                                           *\n*         RETNAREA  DS  CL100                                         *\n*         CALL MODLISTR,(MODNAME,RETNAREA),VL                         *\n*                                                                     *\n*  ------------------------------------------------------------------ *\n*                                                                     *\n*  PICKED THIS PROGRAM UP FROM THE WWW.XEPHON.COM WEB SITE (PROGRAM   *\n*  'POBJINFO' AND ADDED TO IT.  ADDED A CALL TO PROGRAM 'JUL2GREG'    *\n*  TO OBTAIN THE GREGORIAN DATE FROM THE JULIAN LINK-EDIT DATE.       *\n*  CHANGED THE 'TPUT' MACROS TO 'PUT' TO SYSPRINT MACROS.             *\n*                                                                     *\n*  ADDED 3 ADDITIONAL LINES OF DISPLAY (SEE BELOW) INCLUDING THE      *\n*  FOLLOWING FIELDS OBTAINED FROM THE PDS OR PDS/E MEMBER'S DIRECTORY *\n*  RECORD:                                                            *\n*                                                                     *\n*   AMODE, RMODE, APF AUTH CODE, REENTRANT ATTR, REUSE ATTR, REFRESH  *\n*   ATTR, TTR LOCATION, EPA ADDRESS, MEMBER'S DASD RESIDENT LOCATION  *\n*   VOLSER/DATASET NAME, DSORG OF LIBRARY, ALIAS' TRUENAME (IF THE    *\n*   MEMBER IS AN ALIAS NAME), AND SSI INFORMATION (IF PRESENT).       *\n*                                                                     *\n*  IT DISPLAYS 3 OR 4 LINES OF INFORMATION ON DDNAME 'SYSPRINT'       *\n*  (4 LINES IF THE MEMBER IS AN ALIAS NAME) IF CALLED FROM REXX, TSO, *\n*  OR FROM A SUBROUTINE WITH ONLY 1 PARAMETER.                        *\n*                                                                     *\n*     MEMBERNAME, LINKEDIT DATE (BOTH JULIAN AND GREGORIAN DATE),     *\n*     LINKEDIT TIME, LENGTH OF THE LOAD MODULE, AMODE, RMODE,         *\n*     APF AUTH CODE, REENTRANT ATTR, REUSE ATTR, REFRESH ATTR,        *\n*     TTR LOCATION, EPA ADDRESS, MEMBER'S DASD RESIDENT LOCATION      *\n*     VOLSER/DATASET NAME, DSORG OF LIBRARY, AND ALIAS' TRUENAME (IF  *\n*     THE MEMBER IS AN ALIAS NAME (DISPLAYED ON LINE 4), AND SSI      *\n*     INFORMATION (IF PRESENT).                                       *\n*                                                                     *\n*                                                                     *\n*  ALSO MODIFIED THE PROGRAM TO BE REENTRANT.                         *\n*                                                                     *\n*       TKMILLE 04/28/2006                                            *\n*                                                                     *\n*  END OF CHANGE LOG                                                  *\n*                                                                     *\n*                                                                     *\n*  OUTPUT FILES: //SYSPRINT (3 or 4 Line Display)                     *\n*                                                                     *\n*  RETURN CODES FROM MODLISTR:                                        *\n*                                                                     *\n*  0      => Successful call to MODLISTR                              *\n*  4,8,12 => Various other return codes/reason codes from IEWBIND,    *\n*              OBTAIN, AND RDJFCB macros.                             *\n*                                                                     *\n*    Attributes:  REENTRANT, REUSEABLE, AMODE 31, RMODE 24            *\n*                                                                     *\n***********************************************************************\n*        HOUSEKEEPING                                                 *\n***********************************************************************\nMODLISTR CSECT\nMODLISTR AMODE 31\nMODLISTR RMODE 24\n         SAVE  (14,12),,MODLISTR_ASSEMBLED_ON_&SYSDATC._&SYSTIME\n         LR    R12,R15              Load entry address\n         LA    R11,2048(,R12)       Chain R11 to R12 Base\n         LA    R11,2048(,R11)\n         USING MODLISTR,R12,R11     Declare entry base registers\n         LR    R5,R1                Preserve passed parmlist address\n         LR    R6,R13               Store SAVEAREA Backward link\n         L     R3,=A(STORSIZE)      Size of storage to obtain\n         STORAGE OBTAIN,LENGTH=(R3),LOC=(RES)\n         ST    R1,8(,R13)           Set SAVEAREA Forward link\n         LR    R13,R1               Address of obtained area\n         USING STORAREA,R13         Addressability to obtained area\nINITOBTN DS    0H                  Initialize the obtained storage area\n         LR    R2,R13               Address of target of move (obtnd)\n         L     R3,=A(STORSIZE)      Length of the target of move\n         XR    R14,R14             From address (irrelevant with len=0)\n         XR    R15,R15              Pad/Length to propagate in odd reg\n         MVCL  R2,R14          Propagate binary zeroes in obtained area\n         ST    R5,PARMLSTA          Store passed pointer to parms\n         ST    R6,4(,R13)           Set SAVEAREA Backward link\n         MVI   DISFLDSS,C' '\n         MVC   DISFLDSS+1(DISFLDSL-1),DISFLDSS  Init the display fields\n*********************************************************************\n*        Main routine\n*********************************************************************\n         USING PSA,0                Define Prefixed Save Area\n         L     R1,FLCCVT            Load CVT addresss\n         USING CVT,R1               Map CVT\n         MVC   LPARNAME,CVTSNAME    Save the lpar name\n         DROP  R1\n         LA    R8,PDSDIRAR\n         USING PDS2,R8              Map PDS Directory Record\nOPENSYSP DS    0H                   Open Sysprint Report file Output\n         LA    R3,SYSPRINT          DCB to open\n         MVC   SYSPRINT(SYSPRTIL),SYSPRTI\n         MVC   WKOPENCL(OPENIL),OPENI\n         LA    R4,WKOPENCL          OPEN/CLOSE work area\n         OPEN  ((R3),OUTPUT),MODE=31,MF=(E,(R4))   OPEN SYSPRINT OUTPUT\n         LTR   R15,R15              Good open ?\n         BNZ   CLEANUP1             No\nGETPARMS DS    0H                   Get Linkage Parms\n         BAS   R5,CHECKPRM          Make sure module name passed\n         LTR   R15,R15              Successful?\n         BNZ   RETURN               No, get out\nGETBUFFR DS    0H                   Get Binder Buffer\n         BAS   R5,INITBUFF          Go obtain and initialize buffer\n         LTR   R15,R15              Successful?\n         BNZ   RETURN               No, get out\nSTARTDIA DS    0H                   Start Binder Dialog\n         BAS   R5,STRTDIAG          Go start the binder dialog\n         LTR   R15,R15              Successful?\n         BNZ   CLEANUP3             No, get out\nWORKMOD  DS    0H                   Create a Work Module\n         BAS   R5,CRTWMOD\n         LTR   R15,R15              Successful?\n         BNZ   CLEANUP2             No, get out\nSETLIST  DS    0H\n         BAS   R5,SETOPT            Go set the LIST option to ALL\n         LTR   R15,R15              Successful?\n         BNZ   CLEANUP1             No, get out\nINCLUDEM DS    0H\n         BAS   R5,INCLMOD           Go INCLUDE the module\n         LTR   R15,R15              Successful?\n         BZ    GETGOODS             Yes\n         BAS   R5,GET_MORE          Go get the dsn and volser\n         LTR   R15,R15              Successful?\n         BZ    GODISPLY             Yes\n         B     CLEANUP1             No, get out\nGETGOODS DS    0H                   Get all the goodies\n         BAS   R5,STORDATA          Go get the required data\n         LTR   R15,R15              Successful?\n         BNZ   CLEANUP1             No, get out\nGODISPLY DS    0H\n         L     R1,PARMADR2          Check if second parm was passed\n         C     R1,=F'0'             Was second parameter passed ?\n         BE    SYSPRNT              No - Then print results\n         MVC   0(RETURN_INFO_LEN,R1),RETURN_INFO  Yes - return results\n         B     CLEANUP1\nSYSPRNT  DS    0H\n         BAS   R5,DISPLAY_RESULTS   Go Display the Results\nCLEANUP1 DS    0H\n         BAS   R5,DELWMOD           Go delete the workmod\nCLEANUP2 DS    0H\n         BAS   R5,ENDDIAG           Go end the dialog\nCLEANUP3 DS    0H\n         IEWBUFF FUNC=FREEBUF,TYPE=IDRB  , Free the buffer storage\nRETURN   DS    0H\n         LA    R3,SYSPRINT          DCB to close\n         MVC   WKOPENCL(OPENIL),OPENI\n         LA    R4,WKOPENCL          OPEN/CLOSE work area\n         CLOSE ((R3)),MODE=31,MF=(E,(R4))\n         L     R4,RETCODE           Pick up return code\n         LR    R2,R13               Pointer to storage area\n         L     R3,=A(STORSIZE)      Size of storage obtained\n         L     R13,4(,R13)          Restore Caller's SAVEAREA address\n         STORAGE RELEASE,LENGTH=(R3),ADDR=(R2)\n         L     R14,12(,R13)         Restore R14\n         LR    R15,R4               Load return code\n         LM    R0,R12,20(R13)       Restore caller's registers\n         BSM   0,R14                Return to caller in caller's Amode\n**********************************************************************\n*        This program can be called from a Rexx exec (or via jcl\n*        directly) or from another program as a subroutine call.\n*        If called as a subroutine, the user can optionally\n*        return the results as a data parm in lieu of displaying the\n*        results by passing a second parameter.\n*        In all other cases, the results will be displayed on the\n*        SYSPRINT report file.\n*        Macro HOWCALLD is used to see how this program was called.\n**********************************************************************\nCHECKPRM DS    0H\n         MVC   PARMADR2,=F'0'       Clear PARM2 address save area\n         L     R1,PARMLSTA          Restore R1\n         L     R7,0(,R1)\n         ST    R7,PARMADR1          Store the First Parm Address\n         HOWCALLD PARMCALL=PARMCALL , How was I called? Subr or Exec?\n         B     HAVESUBR             I was called as a subroutine\nPARMCALL DS    0H\n         CLC   0(2,R7),=H'1'        Name must be at least 1 byte long\n         BL    INVLPARM             Invalid parm passed\n         CLC   0(2,R7),=H'8'        Must not be longer than 8 bytes\n         BH    INVLPARM             Member Name Parm too long\n         LH    R2,0(,R7)            Pick up the member name length\n         LA    R3,2(,R7)            Pick up the member name address\n         ST    R3,MEMNMADR          Save Member Name Address\n         B     GETMEMB\nHAVESUBR DS    0H\n         L     R1,PARMLSTA          Subroutine call Get Parmlist addrs\n         LR    R3,R7                Point to the member name in PARM1\n         ST    R3,MEMNMADR          Save Member Name Address\n         TM    0(R1),B'10000000'    Was a second parameter passed ?\n         BO    NOPARM2              No  - results will be displayed\n         L     R1,4(,R1)            Yes - results will be in PARM2\n         ST    R1,PARMADR2          Save PARM2 address\nNOPARM2  DS    0H\n         BCTR  R3,0                 R3 will displace across membname\n         LA    R2,0                 R2 will save the length\n         BCTR  R2,0\nGETMEML  DS    0H                   Determine Member name Length\n         LA    R2,1(,R2)            Add one to length accumulator\n         LA    R3,1(,R3)            Move accross one char in Membname\n         C     R2,=F'7'             Index Reg > 7 ? (i.e. 8)\n         BH    GETMEMB\n         CLI   0(R3),C' '           Find End of member name ?\n         BNE   GETMEML              No\nGETMEMB  DS    0H\n         L     R3,MEMNMADR\n         STH   R2,MEMNAME           Save the member name length\n         BCTR  R2,0                 Adjust the length for EX\n         EX    R2,MVCNAME           Execute the MVC instruction\n         XR    R15,R15              Clear return code\n         B     CHECKPRX             Get out\nMVCNAME  DS    0H\n         MVC   MEMNAME8(0),0(R3)    Move parm into member name field\nINVLPARM DS    0H\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'INVLP),INVLP\n         PUT   SYSPRINT,SYSPRTAR\n         LA    R15,4                Set return code\nCHECKPRX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine obtains and initializes the buffer\n**********************************************************************\nINITBUFF DS    0H\n         IEWBUFF FUNC=GETBUF,TYPE=IDRB\n         LTR   R15,R15              Successful?\n         BNZ   NOBUFF               No, failed\n         IEWBUFF FUNC=INITBUF,TYPE=IDRB\n         ST    R6,HEADER@           Preserve the header address\n         ST    R7,ENTRY@            Preserve the entry address\n         LTR   R15,R15              Successful?\n         BZ    INITBUFX             Yes, get out\nNOBUFF   DS    0H\n         ST    R15,RETCODE          Store the return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOWKBUF),NOWKBUF\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\nINITBUFX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine starts the binder dialog\n**********************************************************************\nSTRTDIAG DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=STARTD,DIALOG=DTOKEN,FILES=FILENAME,             +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    STRTDIAX             Yes, get out\nNOSTART  DS    0H\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NODIAG),NODIAG\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(6),=CL6'STARTD'\n         ST    R5,SAVE_R5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVE_R5\n         LR    R15,R2               Reload return code\nSTRTDIAX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine creates a workmod with ACCESS intent\n**********************************************************************\nCRTWMOD  DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=CREATEW,DIALOG=DTOKEN,                           +\n               INTENT=ACCESS,WORKMOD=WTOKEN,                           +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    CRTWMODX             Yes, get out\nNOCREATE DS    0H\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOWMOD),NOWMOD\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(7),=CL7'CREATEW'\n         ST    R5,SAVE_R5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVE_R5\n         LR    R15,R2               Reload return code\nCRTWMODX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine sets the LIST option to SUMMARY\n**********************************************************************\nSETOPT   DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=SETO,OPTION=OPTNLIST,                            +\n               WORKMOD=WTOKEN,OPTVAL=SUMMARY,                          +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    SETOPTX              Yes, get out\nNOSETOPT DS    0H\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOOPT),NOOPT\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(4),=CL4'SETO'\n         ST    R5,SAVE_R5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVE_R5\n         LR    R15,R2               Reload return code\nSETOPTX  DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine INCLUDEs the module\n**********************************************************************\nINCLMOD  DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=INCLUDE,WORKMOD=WTOKEN,                          +\n               DDNAME=INCLLIB,MEMBER=MEMNAME,INTYPE=NAME,              +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    INCLMODX             Yes, get out\nINCLWARN DS    0H\n*   See IBM MANUAL SA22-7644-xx for return code / reason codes\n*     RC=4 REAS=83000526\n* An Unusual Condition was encountered while processing an input module\n* This has been documented as a bad IDRZ record in the IBM knowledge\n* database.\n* CA-Endevor managed libraries have produced this condition due to\n* CA-Endevor's footprint in the IDR record.\n*\n         C     R0,=X'83000526'      ACCEPTABLE WARNING? (Bad IDRZ rec)\n         BNE   NOINCLUD              NO\n         XR    R15,R15               YES, reset R15 and continue on\n         B     INCLMODX\nNOINCLUD DS    0H\n         MVC   SAVE_RC,RETCODE      Preserve return code for later on\n         MVC   SAVE_RSN,RSNCODE     Preserve reason code for later on\n         ST    R15,SAVE_R15         Preserve R15         for later on\n         MVI   SKP_BLDL,C'Y'        Indicate to skip the BLDL call\n**********************************************************************\n*        Defer printing error msg until the library dsn is obtained\n*        from the vtoc later on.\n**********************************************************************\nINCLMODX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine gets the required data binder date/time\n**********************************************************************\nSTORDATA DS    0H\n         L     R6,HEADER@           Reload the header address\n         L     R7,ENTRY@            Reload the buffer address\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=GETD,WORKMOD=WTOKEN,AREA=IEWBIDB,                +\n               CURSOR=NULL,COUNT=NUMBYTES,CLASS=CLASS,                 +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         CH    R15,=H'4'            Successful?\n         BH    NOGETDTA             No\n         CLC   IDB_DATE_BOUND,=6C'00'          Date available?\n         BE    MOVETIME                        No\nMOVEDATE DS    0H\n         MVC   JUL2GREG_JUL_DATE(7),IDB_DATE_BOUND Date for conversion\n         MVC   S0LKJLDT(4),IDB_DATE_BOUND         Julian Year\n         MVI   S0LKJLDT+4,C'.'\n         MVC   S0LKJLDT+5(3),IDB_DATE_BOUND+4     Juldays\n***********************************************************************\n* JUL2GREG is Julian-to-Gregorian Conversion program TKMILLE 04/10/2006\n*    Input  Parameter => Julian Date    (YYYYDDD)\n*    Return Parameter => Gregorian Date (YYYYMMDD)\n***********************************************************************\n         MVC   WKCALL(CALLIL),CALLI          INIT CALL PARMLIST\n         LA    R13,SAVEAREA\nGET_GREG DS    0H                            Call Program JUL2GREG\n         CALL  JUL2GREG,(JUL2GREG_JUL_DATE,JUL2GREG_GREG_DATE),VL,     +\n               MF=(E,WKCALL)\n         LTR   R15,R15                       Good call?\n         BNZ   MOVETIME                      No - Skip Greg Data Disply\nGREGDATE DS    0H\n         MVC   S0LKGRDT(2),JUL2GREG_GREG_DATE+4    Load Gregorian Month\n         MVI   S0LKGRDT+2,C'/'\n         MVC   S0LKGRDT+3(2),JUL2GREG_GREG_DATE+6  Load Gregorian Day\n         MVI   S0LKGRDT+5,C'/'\n         MVC   S0LKGRDT+6(4),JUL2GREG_GREG_DATE    Load Gregorian Year\nMOVETIME DS    0H\n         CLC   IDB_TIME_BOUND,=6C'00'          Time available?\n         BE    GET_MORE                        No\n         MVC   S0LKTIME(2),IDB_TIME_BOUND      First  part of time\n         MVI   S0LKTIME+2,C':'\n         MVC   S0LKTIME+3(2),IDB_TIME_BOUND+2  Second part of time\n         MVI   S0LKTIME+5,C':'\n         MVC   S0LKTIME+6(2),IDB_TIME_BOUND+4  Third  part of time\n*\n* ADDED CODE TO PICK UP OTHER FILEDS AS WELL FOR DISPLAY.\n*    TKMILLE 04/21/2006\n*\nGET_MORE DS 0H\n         LA    R9,IEWLIB           DCB ADDRESS\n         USING IHADCB,R9           MAP DCB\nREADJFCB DS    0H\n         MVC   IEWLIB(IEWLIBIL),IEWLIBI        RELOCATE DCB\n         MVC   JFCBLIST(JFCBLSIL),JFCBLSI      RELOCATE JFCB EXIT LIST\n         MVC   WKRDJFCB(RDJFCBIL),RDJFCBI      RELOCATE JFCB MACRO\n         LA    R1,JFCBLIST\n         STCM  R1,7,DCBEXLSA                   LOAD EXIT LIST ADDRESS\n         LA    R1,JFCBAR\n         STCM  R1,7,JFCBLIST+1                 LOAD JFCB BUFFER ADDRESS\n*\n         RDJFCB ((R9)),MF=(E,WKRDJFCB)      READ IN JFCB\n*\n         LTR   R15,R15             GOOD READ ?\n         BZ    FMT1DSCB             YES\n         ST    R15,RETCODE          NO\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'JFCBRERR),JFCBRERR\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\n         BR    R5                   Back to our caller\nFMT1DSCB DS    0H\n         MVC   CAMPRMLS(CAMLSTIL),CAMLSTI   INITIALIZE OBTAIN PARMLIST\n         LA    R1,JFCBDSNM\n         ST    R1,CAMLDSN\n         LA    R1,JFCBVOLS\n         ST    R1,CAMLVOL\n         LA    R1,CAMWORK\n         ST    R1,CAMLWRK\n         LA    R1,CAMPRMLS\n*\n         OBTAIN CAMPRMLS           READ IN THE FORMAT 1 DSCB VTOC REC\n*\n         LTR   R15,R15             VTOC READ SUCCESSFUL?\n         BZ    CHK_POE              YES\n         ST    R15,RETCODE          NO\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'VTOCRERR),VTOCRERR\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\n         BR    R5                   Back to our caller\nCHK_POE  DS    0H\n***********************************************************************\n*        HAVE A DSORG=PO (OR POE) DATASET ? IF NOT - ERROR SITUATION  *\n***********************************************************************\n         TM    DS1DSORG,DS1DSGPO   IS THIS A DSORG=PO (OR POE) DATASET?\n         BNO   CLEARR15             NO, NOT DSORG PO OR POE\n         TM    DS1SMSFG,DS1PDSE    IS THIS A PDS/E (POE) FILE ?\n         BNO   OPEN_PDS            NO  - NOT A PDS/E FILE\n         MVI   S2DSORG,C'E'\nOPEN_PDS DS    0H\n*\n         CLI   SKP_BLDL,C'Y'\n         BNE   OPEN_PD2\n         ST    R15,TEMP_R15         Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOINCL),NOINCL\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(7),=CL7'INCLUDE'\n         ST    R5,SAVE_R5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVE_R5\n         L     R15,TEMP_R15         Preserve return code\n         BR    R5                   Back to our caller\n*\nOPEN_PD2 DS    0H\n         LA    R3,IEWLIB            DCB TO OPEN\n         MVC   WKOPENCL(OPENIL),OPENI\n         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA\n         OPEN  ((R3),INPUT),MODE=31,MF=(E,(R4))   OPEN IEWLIB INPUT\n         LTR   R15,R15              GOOD OPEN ?\n         BZ    GET_REST             YES\n         ST    R15,RETCODE          NO\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'OPENERR),OPENERR\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\n         BR    R5                   Back to our caller\nGET_REST DS    0H\n         MVC   PDSCNT,ONEH         NUMBER OF PDS MEMBERS 2B  RETURNED\n         MVC   PDSDIRL,DIRLENG     LENGTH OF EACH PDS MEMBER RETURNED\n         MVC   PDS2NAME,MEMNAME8   MEMBER FOR DIRECTORY TO BE RETURNED\n*\n         BLDL  IEWLIB,PDSLISTA     ISSUE BLDL MACRO\n*\n         LTR   R15,R15             BLDL SUCCESSFUL?\n         BZ    GET_USRL             YES\n         ST    R15,RETCODE          NO\n         LA    R3,IEWLIB            DCB TO CLOSE\n         MVC   WKOPENCL(OPENIL),OPENI\n         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA\n         CLOSE ((R3)),MODE=31,MF=(E,(R4))\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'BLDLERR),BLDLERR\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSG(L'CODEMSG),CODEMSG\n         UNPK  UNPACK9(9),RETCODE(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   COEXMSG+14(8),UNPACK9\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         L     R15,RETCODE          Reload return code\n         BR    R5                   Back to our caller\n*\nGET_USRL DS    0H\n         LA    R3,IEWLIB            DCB TO CLOSE\n         LA    R4,WKOPENCL          OPEN/CLOSE WORK AREA\n         CLOSE ((R3)),MODE=31,MF=(E,(R4))\n         MVC   ONEBYTE,PDS2INDC      SAVE PDS2 INDICATOR BYTE\n         NI    ONEBYTE,PDS2LUSR\n         XR    R1,R1\n         IC    R1,ONEBYTE            NBR OF HALF-WORDS IN USER DATA\n         AR    R1,R1                 DOUBLE VALUE\n         LA    R1,PDS2USRD-PDS2NAME(,R1) POINT TO END OF VAR USER DATA\n         ST    R1,PDSDIRLN           SAVE ACTUAL PDS DIRECTORY LENGTH\nGET_MODLEN DS  0H\n         UNPK  UNPACK9(9),PDS2STOR(4)              GET MODULE LENGTH\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   S0MODLEN(L'UNPACK9-1),UNPACK9    MOVE MODULE LENGTH\nGET_TTR  DS    0H\n         UNPK  UNPACK7(7),PDS2TTRP(4)              GET TTR\n         TR    UNPACK7(6),HEXCHAR\n         MVI   UNPACK7+6,C' '\n         MVC   S1TTR,UNPACK7              MOVE TTR TO DISPLAY AREA\nGET_EPA  DS    0H\n         UNPK  UNPACK9(9),PDS2EPA(4)      GET EP ADDRESS\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   S1EPA(L'UNPACK9-1),UNPACK9 MOVE EPA TO DISPLAY AREA\nCHK_RENT DS    0H\n         TM    PDS2ATR1,PDS2RENT          IS MODULE REENTRANT ?\n         BNO   CHK_REUS                   NO  - NOT RENTRANT\n         MVC   S1RENT,=CL2'RN'            YES -     RENTRANT\nCHK_REUS DS    0H\n         TM    PDS2ATR1,PDS2REUS          IS MODULE SERIALLY REUSEABLE?\n         BNO   CHK_REFR                   NO  - NOT REUSEABLE\n         MVC   S1REUS,=CL2'RU'            YES -     REUSEABLE\nCHK_REFR DS    0H\n         TM    PDS2ATR2,PDS2REFR          IS MODULE REFRESHABLE ?\n         BNO   GET_AMODE                  NO  - NOT REFRESHABLE\n         MVC   S1REFR,=CL2'RF'            YES -     REFRESHABLE\nGET_AMODE DS   0H\n         TM    PDS2INDC,PDS2ALIS      IS MEMBERNAME AN ALIAS ?\n         BNO   GET_MAIN_AMODE           NO  - GET MAIN EP AMODE\n         TM    PDS2FTB2,PDSAAMOD      TEST ALIAS AMODE\n         BO    AMODE_ANY                AMODE = ANY\n         BZ    AMODE_24                 AMODE =  24\n         TM    PDS2FTB2,B'00001000'   TEST ALIAS AMODE = 31  ?\n         BO    AMODE_31                 AMODE =  31\n         B     AMODE_64                 AMODE =  64\nGET_MAIN_AMODE DS 0H\n         TM    PDS2FTB2,PDSMAMOD      TEST MAIN EP AMODE\n         BO    AMODE_ANY                AMODE = ANY\n         BZ    AMODE_24                 AMODE =  24\n         TM    PDS2FTB2,B'00000010'   TEST MAIN EP AMODE = 31 ?\n         BO    AMODE_31                 AMODE =  31\nAMODE_64 DS    0H\n         MVC   S1AMODE,=CL3' 64'        AMODE =  64\n         B     GET_RMODE\nAMODE_ANY      DS 0H\n         MVC   S1AMODE,=CL3'ANY'        AMODE = ANY\n         B     GET_RMODE\nAMODE_31       DS 0H\n         MVC   S1AMODE,=CL3' 31'        AMODE = 31\n         B     GET_RMODE\nAMODE_24       DS 0H\n         MVC   S1AMODE,=CL3' 24'        AMODE = 24\nGET_RMODE DS   0H\n         TM    PDS2FTB2,PDSLRMOD      TEST RMODE ATTRIBUTE\n         BO    RMODE_ANY                RMODE = ANY\n         MVC   S1RMODE,=CL3' 24'        RMODE = 24\n         B     CHK_OTHER_SECTIONS\nRMODE_ANY DS   0H\n         MVC   S1RMODE,=CL3'ANY'        RMODE = ANY\nCHK_OTHER_SECTIONS  DS  0H\n         LR    R4,R8                POINT TO START OF FIXED LENGTH AREA\n         LA    R4,PDSBCLN-1(,R4)    POINT TO END OF FIXED LENGTH AREA\n*\n* CHECK FOR SCATTER SECTION\n*\nCHK_SCATR DS   0H\n         TM    PDS2ATR1,PDS2SCTR         IS SCATTER SECTION present ?\n         BNO   CHK_ALIAS                  NO\n         LA    R4,1(,R4)             MOVE TO START OF SCATTER SECTION\n         ST    R4,SCATOFFS           STORE SCATTER SECTION OFFSET\n         LA    R4,PDSS01LN-1(,R4)    MOVE TO END OF SCATTER SECTION\n*\n* CHECK FOR ALIAS SECTION\n*\nCHK_ALIAS DS   0H\n         TM    PDS2INDC,PDS2ALIS   IS ALIAS SECTION PRESENT ?\n         BNO   CHK_SSI              NO  - MEMBER IS NOT AN ALIAS NAME\n         LA    R4,1(,R4)             MOVE TO START OF ALIAS SECTION\n         ST    R4,ALIASOFF           STORE ALIAS SECTION OFFSET\n         LR    R2,R4\n         LA    R2,PDS2MNM-PDSS02(,R2) POINT TO ALIAS TRUENAME\n         MVC   S3TRUENM,0(R2)         GET ALIAS' TRUENAME\n         LA    R4,PDSS02LN-1(,R4)     MOVE TO END OF ALIAS SECTION\n*\n* CHECK FOR SSI INFORMATION SECTION (ALIGNED ON A HALFWORD BOUNDARY)\n*\nCHK_SSI  DS    0H\n         TM    PDS2FTB1,PDS2SSI      IS SSI SECTION PRESENT ?\n         BNO   CHK_APF               NO\n         LA    R4,1(,R4)             MOVE TO START OF SSI SECTION\n         ST    R4,EVENODD\n         TM    EVENODD+3,X'01'       Is this an odd number ?\n         BNO   SKPALIGN                  No - already on hw boundary\n         LA    R4,1(,R4)             MAKE HW ALIGNMENT - SHIFT 1 BYTE\n*                                     (SSI SECTION IS ON HW BOUNDARY)\nSKPALIGN DS    0H\n         ST    R4,SSIOFFS            STORE SSI INFO SECTION OFFSET\n         MVC   S3SSI(4),0(R4)        GET SSI\n         UNPK  UNPACK9(9),S3SSI(5)\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   S3SSI,UNPACK9         MOVE SSI INFO TO DISPLAY AREA\n         LA    R4,PDSS03LN-1(,R4)    MOVE TO END OF SSI SECTION\n*\n* CHECK FOR APF AUTHORIZATION SECTION\n*\nCHK_APF  DS    0H                  APF SECTION IS ASSUMED TO BE PRESENT\n         LA    R4,1(,R4)             MOVE TO START OF APF SECTION\n         ST    R4,APFOFFS            STORE APF SECTION OFFSET\n         LR    R2,R4\n         LA    R2,PDSAPFCT-PDSS04(,R2)\n         MVC   S1APFCD,=CL2'00'           SET DEFAULT 00\n         TM    PDS2FTB1,PDSAPFLG          IS APFCODE VALID ?\n         BNO   GET_LRGOF                  NO  - NOT REENTRANT\n         CLC   0(1,R2),XL00               APF AUTH CD LENGTH = 0 ?\n         BE    GET_LRGOF                   YES\n         CLC   0(1,R2),XL01               APF AUTH CD LENGTH = 1 ?\n         BNE   GET_LRGOF                   NO\n         LA    R2,1(R2)\n         XR    R1,R1                      YES\n         ICM   R1,B'0001',0(R2)           LOAD APF AUTH CODE (FL1)\n         ST    R1,DOUBLE\n         UNPK  UNPACK9(9),DOUBLE(5)       GET APF AUTH CODE\n         TR    UNPACK9(8),HEXCHAR\n         MVI   UNPACK9+8,C' '\n         MVC   S1APFCD,UNPACK9+6        MOVE APF CODE TO DISPLAY AREA\n         L     R4,APFOFFS\n         LA    R4,PDSS04LN-1(,R4)     MOVE TO END OF APF SECTION\n*\n* CHECK FOR LARGE PROGRAM SECTION\n*\nGET_LRGOF DS   0H\n         TM    PDS2FTB1,PDS2BIG    IS LARGE PGM SECTION PRESENT ?\n         BNO   CLEARR15             NO\n         LA    R4,1(,R4)             MOVE TO START OF LARGE PGM SECTION\n         ST    R4,LRGOFFS            STORE LARGE PGM SECTION OFFSET\n*\n         DROP  R9\n*\nCLEARR15 DS    0H\n         XR    R15,R15              Data successfully obtained\n         B     STORDATX             Get out\nNOGETDTA DS    0H\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NODATA),NODATA\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(4),=CL4'GETD'\n         ST    R5,SAVE_R5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVE_R5\n         LR    R15,R2               Reload return code\nSTORDATX DS    0H\n         BR    R5                   Back to our caller\n*\nDISPLAY_RESULTS DS   0H\n         CLI   SKP_BLDL,C'Y'           Was member found in lib ?\n         BNE   DIS_DT_TM               Yes\n**********************************************************************\n*  Display Member Not Found Message\n**********************************************************************\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         LA    R1,SYSPRTAR\n         MVC   0(L'NOTFNDM1,R1),NOTFNDM1\n         LA    R1,L'NOTFNDM1(,R1)\n         LH    R2,MEMNAME           Get Member Length\n         BCTR  R2,0                 Correct the length for EX Move\n         EX    R2,MVCNAME2          Execute the MVC instruction\n         LA    R1,1(R1,R2)\n         MVC   0(L'NOTFNDM2,R1),NOTFNDM2\n         LA    R1,L'NOTFNDM2(,R1)\n         MVC   0(L'JFCBDSNM,R1),JFCBDSNM\n         LA    R1,L'JFCBDSNM(,R1)\nDSN_LEN  DS    0H                        Find end of dsn in msg\n         CLI   0(R1),C' '                Look for a non-blank char\n         BNE   DSN_LFND                  Found trailing dsn char\n         BCT   R1,DSN_LEN\nDSN_LFND DS    0H\n         MVC   1(L'NOTFNDM3,R1),NOTFNDM3\n         LA    R1,L'NOTFNDM3(,R1)\n         MVC   1(L'LPARNAME,R1),LPARNAME\n         PUT   SYSPRINT,SYSPRTAR\n         B     DISPLAY_END\nMVCNAME2 DS    0H\n         MVC   0(0,R1),MEMNAME8\n*\nDIS_DT_TM DS   0H\n*  DEBUGGING START\n*        MVI   SYSPRTAR,C' '\n*        MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n*        MVC   SYSPRTAR+1(80),PDS2\n*        PUT   SYSPRINT,SYSPRTAR         DISPLAY THE DIRECTORY ENTRY\n*  DEBUGGING END\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L_SYSREC0),SYSREC0\n         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+20(L'S0LKGRDT),S0LKGRDT\n         MVC   SYSPRTAR+32(L'S0LKJLDT),S0LKJLDT\n         CLC   IDB_TIME_BOUND,=6C'00'              Time available?\n         BE    DIS_LENGTH                          No\n         MVC   SYSPRTAR+46(L'S0LKTIME),S0LKTIME\nDIS_LENGTH DS  0H\n         MVC   SYSPRTAR+65(L'S0MODLEN),S0MODLEN\n         MVC   SYSPRTAR+76(3),LPARNAME\n         PUT   SYSPRINT,SYSPRTAR\n*\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L_SYSREC1),SYSREC1\n         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+14(L'S1AMODE),S1AMODE\n         MVC   SYSPRTAR+22(L'S1RMODE),S1RMODE\n         MVC   SYSPRTAR+30(L'S1APFCD),S1APFCD\n         MVC   SYSPRTAR+34(L'S1RENT),S1RENT\n         MVC   SYSPRTAR+37(L'S1REUS),S1REUS\n         MVC   SYSPRTAR+40(L'S1REFR),S1REFR\n         MVC   SYSPRTAR+48(L'S1TTR),S1TTR\n         MVC   SYSPRTAR+65(L'S1EPA),S1EPA\n         PUT   SYSPRINT,SYSPRTAR\n*\nDISP_DSN DS    0H\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L_SYSREC2),SYSREC2\n         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+19(L'JFCBVOLS),JFCBVOLS\n         MVC   SYSPRTAR+26(L'JFCBDSNM),JFCBDSNM\n         MVC   SYSPRTAR+78(L'S2DSORG),S2DSORG\n         PUT   SYSPRINT,SYSPRTAR\n*\n         CLI   SKP_BLDL,C'Y'           Was member found in lib ?\n         BE    DISPLAY_END             No\n*\n         TM    PDS2FTB1,PDS2SSI      IS SSI SECTION PRESENT ?\n         BO    DISPLAY_L3             YES - HAVE SOMETHING TO DISPLAY\n         TM    PDS2INDC,PDS2ALIS     IS MEMBER AN ALIAS NAME  ?\n         BNO   DISPLAY_END            NO  - MEMBER IS NOT AN ALIAS NAME\nDISPLAY_L3 DS  0H\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'MEMNAME8),MEMNAME8\n         TM    PDS2FTB1,PDS2SSI      IS SSI SECTION PRESENT ?\n         BNO   DISPLAY_AL             NO\n         MVC   SYSPRTAR+9(6),=CL6' SSI: '\n         MVC   SYSPRTAR+15(L'S3SSI),S3SSI\nDISPLAY_AL DS  0H\n         TM    PDS2INDC,PDS2ALIS     IS MEMBER AN ALIAS NAME  ?\n         BNO   DISPLAY_L3_END         NO  - MEMBER IS NOT AN ALIAS NAME\n         MVC   SYSPRTAR+23(29),=CL29'   *** ALIAS NAME FOR MEMBER '\n         MVC   SYSPRTAR+52(L'S3TRUENM),S3TRUENM\n         MVC   SYSPRTAR+60(4),=CL4' ***'\nDISPLAY_L3_END DS  0H\n         PUT   SYSPRINT,SYSPRTAR\nDISPLAY_END DS 0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine deletes the workmod\n**********************************************************************\nDELWMOD  DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=DELETEW,WORKMOD=WTOKEN,                          +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    DELWMODX             Yes, get out\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NODEL),NODEL\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(7),=CL7'DELETEW'\n         ST    R5,SAVE_R5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVE_R5\n         LR    R15,R2               Reload return code\nDELWMODX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine ends the dialog\n**********************************************************************\nENDDIAG  DS    0H\n         MVC   IEWPLIST(IEWPLSTL),IEWPLSTW\n         IEWBIND FUNC=ENDD,DIALOG=DTOKEN,                              +\n               RETCODE=RETCODE,RSNCODE=RSNCODE,VERSION=5,              +\n               MF=(E,IEWPLIST)\n         L     R15,RETCODE          Look at the return code\n         LTR   R15,R15              Successful?\n         BZ    ENDDIAGX             Yes, get out\n         LR    R2,R15               Preserve return code\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'NOEND),NOEND\n         PUT   SYSPRINT,SYSPRTAR\n         MVC   COEXMSGA(CODEMSGL),CODEMSGA\n         MVC   COEXFUNC(4),=CL4'ENDD'\n         ST    R5,SAVE_R5\n         BAS   R5,SHOWCODE          Go print return and reason codes\n         L     R5,SAVE_R5\n         LR    R15,R2               Reload return code\nENDDIAGX DS    0H\n         BR    R5                   Back to our caller\n**********************************************************************\n*        This routine makes the return and reason codes printable\n**********************************************************************\nSHOWCODE DS    0H\n         MVC   LOWBYTES,RETCODE     Move return and reason code in\n         NC    LOWBYTES(8),=8X'F0'  Turn off the second part bytes\n         TR    LOWBYTES(8),LEFTHALF\n         MVC   HIGBYTES,RETCODE     Move return and reason code in\n         NC    HIGBYTES(8),=8X'0F'  Turn off the first part bytes\n         TR    HIGBYTES(8),RIGTHALF\n         LA    R1,LOWBYTES         Where the first half of each byte is\n         LA    R2,HIGBYTES          Where second half of each byte is\n         LA    R3,WORKAREA          Where we want to move the data to\n         LA    R4,8                 8 bytes to move\nCODELOOP DS    0H\n         MVC   0(1,R3),0(R1)        Move first half of byte\n         LA    R3,1(,R3)            Bump up target pointer\n         MVC   0(1,R3),0(R2)        Move second half of byte\n         LA    R3,1(,R3)            Bump up target pointer\n         LA    R1,1(,R1)            Bump up first-half-of-byte pointer\n         LA    R2,1(,R2)            Bump up second-half-of-byte pointer\n         BCT   R4,CODELOOP          Do for each of the bytes\n         MVC   COEXMSG(CODEMSGL),CODEMSG\n         MVC   COEXMSG+14(8),WORKAREA\n         MVC   COEXMSG+36(8),WORKAREA+8\nRCREASN  DS    0H\n         CLI   COEXFUNC,C' '              IEWBIND MACRO ERROR ?\n         BE    SHOWCODX                    NO\n         MVI   SYSPRTAR,C' '               YES\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   COEXMEMB(L'MEMNAME8),MEMNAME8\n         MVC   SYSPRTAR+1(COEXMSGL),COEXMSGA\n         PUT   SYSPRINT,SYSPRTAR\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'COEXMSG),COEXMSG\n         PUT   SYSPRINT,SYSPRTAR\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'MANLMSG1),MANLMSG1\n         PUT   SYSPRINT,SYSPRTAR\n         MVI   SYSPRTAR,C' '\n         MVC   SYSPRTAR+1(L'SYSPRTAR-1),SYSPRTAR\n         MVC   SYSPRTAR+1(L'MANLMSG2),MANLMSG2\n         PUT   SYSPRINT,SYSPRTAR\nSHOWCODX DS    0H\n         BR    R5\n**********************************************************************\n*    STATIC STORAGE FOLLOWS\n**********************************************************************\n         LTORG\nINVLP    DC    C'MODLISTR error - Invalid member name passed.'\nNOWKBUF  DC    C'MODLISTR error - Failed to obtain and init work buffer+\n               .'\nNODIAG   DC    C'MODLISTR error - Failed to START dialog.'\nNOWMOD   DC    C'MODLISTR error - Failed to CREATE a workmod.'\nNOOPT    DC    C'MODLISTR error - Failed to set LIST=SUMMARY option.'\nNOINCL   DC    C'MODLISTR error - Failed to INCLUDE module.'\nNODATA   DC    C'MODLISTR error - Failed to OBTAIN data for module.'\nNODEL    DC    C'MODLISTR error - Failed to DELETE workmod.'\nNOEND    DC    C'MODLISTR error - Failed to END dialog.'\nNODATE   DC    C'MODLISTR error - Failed to obtain gregorian date.'\nJFCBRERR DC    C'MODLISTR error - Error Reading JFCB for File IEWLIB.'\nVTOCRERR DC    C'MODLISTR error - Error Reading Format 1 Vtoc.'\nOPENERR  DC    C'MODLISTR error - Error Opening PDS File.'\nBLDLERR  DC    C'MODLISTR error - Error Calling BLDL macro.'\n*\nINCLLIB  DC    H'6',C'IEWLIB'\nCLASS    DC    H'6',C'B_IDRB'\n*\nCODEMSGA DC    0C\n         DC    CL33'  IEWBIND macro error for module '\n         DC    CL8'        '\n         DC    CL16'.  IEWBIND FUNC='\n         DC    CL8'        '\nCODEMSGL EQU   *-CODEMSGA\n*\nNOTFNDM1 DC    C' MODULE \"'\nNOTFNDM2 DC    C'\" NOT FOUND IN LIBRARY \"'\nNOTFNDM3 DC    C'\" ON '\n*\nCODEMSG  DC    C'  Return Code=????????, Reason Code=????????'\n*\nMANLMSG1 DC    C'  See IBM MVS PROGRAM MANAGEMENT: ADVANCED FACILITIES +\n               Manual (SA22-7644-xx)'\nMANLMSG2 DC    C'      for BINDER API return code / reason code explana+\n               tion.'\n*\n         IEWBIND PLISTVER,MF=(L,IEWPLSTW,0D)\nIEWPLSTL EQU   *-IEWPLSTW\n*\n         IEWBUFF FUNC=MAPBUF,TYPE=IDRB,SIZE=1000,HEADREG=6,ENTRYREG=7, +\n               VERSION=5\n*\nFILENAME DS    0F\n         DC    F'0'                  Swap with next card to get BINDER\n*        DC    F'2'                    messages displayed\n         DC    CL8'TERM',F'8',A(TERM)\n         DC    CL8'PRINT',F'8',A(TERM)\n*\nTERM     DC    CL7'IEWINFO'          DD-name messages will go to\nOPTNLIST DC    H'4',C'LIST'          Option LIST=SUMMARY\nSUMMARY  DC    H'7',C'SUMMARY'       Option LIST=SUMMARY\n*\nLEFTHALF DS    0CL240\n         DC    X'F0',15X'00',X'F1',15X'00',X'F2',15X'00',X'F3'\n         DC    15X'00',X'F4',15X'00',X'F5',15X'00',X'F6',15X'00',X'F7'\n         DC    15X'00',X'F8',15X'00',X'F9',15X'00',X'C1',15X'00',X'C2'\n         DC    15X'00',X'C3',15X'00',X'C4',15X'00',X'C5',15X'00',X'C6'\nRIGTHALF DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'\n*\nHEXCHAR  EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n*\nSYSPRTI  DS    0F\n         DCB   DDNAME=SYSPRINT,MACRF=(PM),DSORG=PS,                    +\n               LRECL=121,RECFM=F\nSYSPRTIL EQU   *-SYSPRTI           LENGTH OF SYSPRTI\n*\nIEWLIBI  DS    0F\n         DCB   DDNAME=IEWLIB,MACRF=(R),DSORG=PO,LRECL=0,RECFM=U,       +\n               EXLST=*,DEVD=DA\nIEWLIBIL EQU   *-IEWLIBI           LENGTH OF IEWLIBI\n*\nRDJFCBI        DS    0F\n               RDJFCB  *,MF=L                   JFCB MACRO INIT AREA\nRDJFCBIL       EQU   *-RDJFCBI                  LENGTH OF RDJFCBI\n*\nJFCBLSI        DS    0F\n               DC    XL1'87',AL3(0)             INIT JFCB EXIT LIST\nJFCBLSIL       EQU   *-JFCBLSI\n*\nOPENI          DS    0F\n               OPEN  (*,OUTPUT),MODE=31,MF=L\nOPENIL         EQU   *-OPENI                      LENGTH OF OPENI\n*\nCALLI          DS    0F\n               CALL  ,(*,*),VL,MF=L\nCALLIL         EQU   *-CALLI                      LENGTH OF CALLI\n*\nJUL2GREG       DC    V(JUL2GREG)         ADDRESS OF PGM JUL2GREG\n*\nCAMLSTI        DS    0F\n               CAMLST SEARCH,1,2,3       OBTAIN PARMLIST INIT AREA\nCAMLSTIL       EQU   *-CAMLSTI\n*\nONEH           DC    H'1'\nXL00           DC    XL1'00'\nXL01           DC    XL1'01'\n*\nDIRLENG        DC    Y(PDS2LEN)\n*\n***********************************************************************\n* DISPLAY LINE AREAS FOLLOW\n***********************************************************************\nSYSREC0     DC    0C\n            DC    CL8'        '           MODULE MEMBER NAME\n            DC    C' Linked on '\n            DC    CL10'mm/dd/yyyy'        Gregorian Link Edit Date\n            DC    C' ('\n            DC    CL8'yyyy.ddd'           Julian    Link Edit Date\n            DC    C')  at '\n            DC    CL8'hh:mm:ss'           Link Edit Time of Day\n            DC    C'   LENGTH: '\n            DC    CL6'      '             Module Length\nL_SYSREC0   EQU   *-SYSREC0\n*\nSYSREC1     DC    0C\n            DC    CL8'        '           MODULE MEMBER NAME\n            DC    C' AM: '\n            DC    CL3'  '                 AMODE\n            DC    C' RM: '\n            DC    CL3'  '                 RMODE\n            DC    C' AC: '\n            DC    CL2'  '                 APF CODE\n            DC    C'  '\n            DC    CL2'  '                 REENTRANT ATTRIBUTE\n            DC    C' '\n            DC    CL2'  '                 REUSE ATTRIBUTE\n            DC    C' '\n            DC    CL2'  '                 REFRESH ATTRIBUTE\n            DC    C' TTR: '\n            DC    CL6'      '             TTR\n            DC    C'   EPADDR: '\n            DC    CL6'      '             EPA ADDRESS\nL_SYSREC1   EQU   *-SYSREC1\n*\nSYSREC2     DC    0C\n            DC    CL8'        '           MODULE MEMBER NAME\n            DC    C' VOL/DSN: '\n            DC    CL6'      '             VOLSER\n            DC    C' '\n            DC    44CL1' '                LOAD LIBRARY DATA SET NAME\n            DC    C' ORG: PO'                      DSORG=PO\n            DC    CL1' '                  LIBRARY DSORG DSORG=POE\nL_SYSREC2   EQU   *-SYSREC2\n*\n**********************************************************************\n*    DYNAMIC STORAGE FOLLOWS  (ACQUIRED STORAGE AREA)\n**********************************************************************\nSTORAREA    DSECT ,                 REENTRANT STORAGE\nSAVEAREA    DS    20F\nPARMLSTA    DS    F                 Parameter List Address\nPARMADR1    DS    F                 First  Parameter Address\nPARMADR2    DS    F                 Second Parameter Address\nMEMNMADR    DS    F                 Address of the passed Member Name\nDTOKEN      DS    D                 Dialog token\nWTOKEN      DS    D                 Workmod token\nDOUBLE      DS    D                 General workarea\nRETCODE     DS    F                 Return code\nRSNCODE     DS    F                 Reason code\nSAVE_RC     DS    F                 Saved Return code\nSAVE_RSN    DS    F                 Saved Reason code\nSAVE_R5     DS    F                 Store R5\nSAVE_R15    DS    F                 Saved R15\nTEMP_R15    DS    F                 Temp Store for R15\nLOWBYTES    DS    CL8               Workarea to make codes printable\nHIGBYTES    DS    CL8               Workarea to make codes printable\nWORKAREA    DS    CL16              Print format return and reason code\nNULL        DS    F                 Where binder should begin\nNUMBYTES    DS    F                 Number of bytes returned to us\nHEADER@     DS    F                 Address of IEW header\nENTRY@      DS    F                 Address of IEW data entry\n*\nLPARNAME    DS    CL8               LPAR Name\n*\nSYSPRINT    DS    0F,CL(SYSPRTIL)      SYSPRINT DCB RELOCATE AREA\nIEWLIB      DS    0F,CL(IEWLIBIL)      IEWLIB   DCB RELOCATE AREA\nWKOPENCL    DS    0F,CL(OPENIL)        OPEN/CLOSE MACRO RELOCATE AREA\nWKCALL      DS    0F,CL(CALLIL)        CALL MACRO RELOCATE AREA\nIEWPLIST    DS    0F,CL(IEWPLSTL)      IEWBIND PARMLIST RELOCATE AREA\nWKRDJFCB    DS    0F,CL(RDJFCBIL)      RDJFCB MACRO RELOCATE AREA\n*\nJFCBLIST    DS    F                    JFCB EXIT LIST RELOCATE AREA\nJFCBAR      DS    CL(JFCBLGTH)         RDJFCB WORK AREA BUFFER\n            ORG   JFCBAR\n            IEFJFCBN LIST=YES\n*\nSYSPRTAR    DS    CL121\n*\n**********************************************************************\n* OBTAIN SEARCH PARAMETER LIST FOLLOWS\n**********************************************************************\nCAMPRMLS    DS    0F                CAMLST PARAMETER LIST\nCAMLFUNC    DS    X                 FUNCTION\nCAML2       DS    X                 NOT USED WITH SEARCH\nCAML3       DS    X                 NOT USED WITH SEARCH\nCAML4       DS    X                 NOT USED WITH SEARCH\nCAMLDSN     DS    F                 CAMLIST DATASET NAME\nCAMLVOL     DS    F                 CAMLIST VOLSER\nCAMLWRK     DS    F                 CAMLIST WORK AREA\n*\nCAMWORK     DS    0D,CL148\n            ORG   CAMWORK-44        RECORD KEY IS NOT RETURNED\n            IECSDSL1 (1)            FORMAT 1 DSCB\n            ORG   ,\n*\n**********************************************************************\n* BLDL MACRO WORK AREA FOLLOWS\n**********************************************************************\n*\nPDSLISTA    DS    0F                BLDL LIST ADDRESS\nPDSCNT      DS    H                 NBR OF MEMBERS TO RETURN\nPDSDIRL     DS    H                 RESERVED LENGTH OF EACH DIRECTORY\nPDSDIRAR    DS    CL(PDS2LEN)       PDS DIRECTORY AREA\nPDSLISTL    EQU   *-PDSLISTA\n*\nPDSDIRLN    DS    F         LENGTH OF PDS DIRECTORY RETURNED BY BLDL\nSCATOFFS    DS    F         SCATTER SECTION OFFSET (IF PRESENT)\nALIASOFF    DS    F         ALIAS SECTION OFFSET  (IF PRESENT)\nSSIOFFS     DS    F         SSI SECTION OFFSET    (IF PRESENT)\nAPFOFFS     DS    F         APF SECTION OFFSET    (ASSUMED PRESENT)\nLRGOFFS     DS    F         LARGE PRORGRAM SECTION OFFSET (IF PRESENT)\nONEBYTE     DS    CL1\n*\nCOEXMSGA    DS    0C\n            DS    CL33\nCOEXMEMB    DS    CL8\n            DS    CL16\nCOEXFUNC    DS    CL8\nCOEXMSGL    EQU   *-COEXMSGA\n*\nCOEXMSG     DS    CL44\n*\nUNPACK7     DS    CL7\nUNPACK9     DS    CL9\nEVENODD     DS    F                   Check for even or odd number\n*\n***********************************************************************\n* JUL2GREG is Julian-to-Gregorian Conversion program TKMILLE 04/10/2006\n***********************************************************************\nJUL2GREG_JUL_DATE  DS   ZL7           /* YYYYDDD  PASSED AS PARM   */\nJUL2GREG_GREG_DATE DS   ZL8           /* YYYYMMDD RETURNED AS PARM */\n*\nDISFLDSS    DS    0C\n*\nSKP_BLDL    DS    CL1                 CALL BLDL INDICATOR\n*\nRETURN_INFO DS    0F                  RETURN AS PARM IF REQUESTED\nMEMNAME     DS    H\nMEMNAME8    DS    CL8                 MEMBER NAME PASSED AS PARM\n*\nS0LKGRDT    DS    CL10                LINK EDIT GREGORIAN DATE\nS0LKJLDT    DS    CL8                 LINK EDIT JULIAN    DATE\nS0LKTIME    DS    CL8                 LINK EDIT TIME OF DAY\nS0MODLEN    DS    CL8                 MODULE LENGTH\n*\nS1AMODE     DS    CL3                 AMODE\nS1RMODE     DS    CL3                 RMODE\nS1APFCD     DS    CL2                 APF CODE\nS1RENT      DS    CL2                 REENTRANT ATTRIBUTE\nS1REUS      DS    CL2                 REUSE ATTRIBUTE\nS1REFR      DS    CL2                 REFRESH ATTRIBUTE\nS1TTR       DS    CL6                 TTR\nS1EPA       DS    CL8                 EPA ADDRESS\n*\nS2DSORG     DS    CL1                 LIBRARY DSORG  DSORG=POE\n*\nS3TRUENM    DS    CL8                 ALIAS' TRUE NAME\nS3SSI       DS    CL8                 SSI INFORMATION\n*\nRETURN_INFO_LEN EQU   *-RETURN_INFO\n*\nDISFLDSL    EQU   *-DISFLDSS\n*\nSTORSIZE    EQU   *-STORAREA\n*\n            YREGS ,                        Register Equates\nDSECDCBD    DCBD     DSORG=PO,DEVD=DA ,\nDSECTPSA    IHAPSA   LIST=YES ,            Map PSA\nDSECTCVT    CVT      DSECT=YES,LIST=YES ,  Map CVT\nDSECTPDS    IHAPDS ,                       Map PDS and PDS/E Directory\nPDS2LEN     EQU   *-PDS2                   Get length of IHAPDS dsect\n            END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT743/FILE743.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT743", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}