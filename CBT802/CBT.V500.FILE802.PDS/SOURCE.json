{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20090205151457000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 8000, "INMRECFM": "VB", "INMDIR": 6, "INMDSNAM": "SBGOLOB.DELINKC.SOURCE", "INMMEMBR": "SBGOLOB.DELINKC.SOURCE", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SBGOLOB.DELINKC.SOURCE": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 8000, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 32, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "090036", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x0f'", "DS1LSTAR": "b'\\x00\\x01\\x07'", "DS1TRBAL": "b'4v'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8fQp\\x00\\x04\\x89 P'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8fQp\\x00\\x04\\x89 P'", "b'X\\xf54\\xb0\\x00\\x00\\x00\\xab\\x00\\x03\\x00\\xac\\x00\\x02\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"DELINKC": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\t\\x03o\\x01\\t\\x03o\\x10\\x14\\x048\\x048\\x00\\x00\\xd1\\xe6\\xc9\\xd5\\xe3\\xc5\\xd9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-02-05T00:00:00", "modifydate": "2009-02-05T10:14:00", "lines": 1080, "newlines": 1080, "modlines": 0, "user": "JWINTER"}, "text": "#include <string.h>\n#include <stdio.h>\n\n// ****************** structs ******************\n\ntypedef struct rld_tag * rld_ptr;\ntypedef struct rld_tag {\n    long    address;\n    rld_ptr next;\n    short   esd;\n    char    flgs;\n} rld_r;\n\ntypedef struct txt_tag * txt_ptr;\ntypedef struct txt_tag {\n    unsigned char * text;\n    long    textlen;\n    long    address;\n    txt_ptr next;\n} txt_r;\n\ntypedef struct esd_tag * esd_ptr;\ntypedef struct esd_tag {\n    long    address;\n    long    length;\n    esd_ptr next;\n    rld_ptr rld;\n    txt_ptr txt;\n    char  * idr;\n    char  * idy;\n    short   esd;\n    short   new_esd;\n    char    type;\n    char    name \u00dd9\u00a8;\n    char    flag;\n} esd_r;\n\ntypedef struct obj_tag * obj_ptr;\ntypedef struct obj_tag {\n    esd_ptr esd;\n    obj_ptr next;\n} obj_r;\n\ntypedef struct pds_tag * pds_ptr;\ntypedef struct pds_tag {\n    unsigned int ttrt:24;\n    unsigned int zero1:8;\n    unsigned int ttrn:24;\n    unsigned int zero2:8;\n    int rent:1; int reus:1; int ovly:1; int test:1; int load:1; int sctr:1; int exec:1; int blk1:1;\n    int flvl:1; int org0:1; int ep0:1;  int nrld:1; int nrep:1; int tstn:1; int lef:1;  int refr:1;\n    unsigned int stor1:8; // Size\n    unsigned int stor2:8; // Size\n    unsigned int stor3:8; // Size\n    unsigned int ftbl1:8; // corrected for alignment\n    unsigned int ftbl2:8; // corrected for alignment\n    unsigned int epa1:8;  // Entry Point Address\n    unsigned int epa2:8;  // Entry Point Address\n    unsigned int epa3:8;  // Entry Point Address\n    int aosle:1;int big:1;  int paga:1; int ssi:1;  int apflg:1; int pgmo:1;  int fill1:1; int fill2:1;\n    int fill3:1;int fill4:1;int fill5:1;int lrmod:1; unsigned int aamod:2; unsigned int mamod:2;\n    unsigned int ftb3:8;  // aux-data starts just past this byte\n} pds_r;\n\ntypedef struct sctr_tag * sctr_ptr;\ntypedef struct sctr_tag {\n    unsigned short slsz;\n    unsigned short ttsz;\n    unsigned short esdt;\n    unsigned short esdc;\n} sctr_r;\n\ntypedef struct alias_tag * alias_ptr;\ntypedef struct alias_tag {\n    unsigned int  epm:24; // Is aligned\n    unsigned char mnm \u00dd8\u00a8;\n} alias_r;\n\ntypedef struct ssi_tag * ssi_ptr;\ntypedef struct ssi_tag {\n    unsigned int chlvl:8;\n    unsigned int filler:1;\n    unsigned int force:1;\n    unsigned int usrch:1;\n    unsigned int emfix:1;\n    unsigned int depch:1;\n    unsigned int cmsgn:1;\n    unsigned int ptsgn:1;\n    unsigned int ibmmb:1;\n    unsigned int mbrsn:16;\n} ssi_r;\n\ntypedef struct apf_tag * apf_ptr;\ntypedef struct apf_tag {\n    unsigned int apfct:8;\n    unsigned int apfac:8;\n} apf_r;\n\n// ****************** member dir processing ******************\n\nstatic pds_ptr glob_p; // Mandatory pointer to the user-data\n\nstatic sctr_ptr  glob_sctr = NULL; // Optional aux. user-data pointers..\nstatic alias_ptr glob_alias = NULL;\nstatic ssi_ptr   glob_ssi = NULL;\nstatic apf_ptr   glob_apf = NULL;\n\nstatic          long alias = 0; // Was it an alias to a member?\nstatic          long link_edit_data_len = 0;\nstatic unsigned char link_edit_data \u00dd64\u00a8; // directory user-data\nstatic          long epa;    // Entry Point Address\n\n// ****************** member data processing ******************\n\nstatic long data = 0;        // Not initially, need a CTL Record first\n\nstatic long ctldcnt;         // Bytes in Control Data area\nstatic char ctldata \u00dd32768\u00a8; // Control Data - overkill on space though\nstatic long ctladdr;         // Address where program text would start\n\nstatic esd_ptr head = NULL;  // Full list of ESDs\nstatic obj_ptr objs = NULL;  // ESDs separated into discrete objects\nstatic long next_esd1;       // When rebuilding, this resequences ESD IDS\nstatic long next_esd2;       // When rebuilding, this resequences LD ESD IDS\n\n// ****************** create object processing ******************\n\nstatic unsigned char esd \u00dd80\u00a8 = {\n   0x02, 'E', 'S', 'D', ' ', ' ', ' ', ' ', ' ', ' ',0x00,0x10, ' ', ' ', ' ', ' ',\n    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '\n};\nstatic unsigned char txt \u00dd80\u00a8 = {\n   0x02, 'T', 'X', 'T', ' ',0x00,0x00,0x00, ' ', ' ',0x00,0x00, ' ', ' ',0x00,0x01\n};\nstatic unsigned char rld \u00dd80\u00a8 = {\n   0x02, 'R', 'L', 'D', ' ', ' ', ' ', ' ', ' ', ' ',0x00,0x00, ' ', ' ', ' ', ' '\n};\nstatic unsigned char end \u00dd80\u00a8 = {\n   0x02, 'E', 'N', 'D', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n    '1', '5', '7', '4', '1', 'S', 'C', '1', '0', '3', ' ', '0', '2', '0', '1', '0',\n    '9', '0', '0', '1', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',\n    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '0', '0', '0', '0', '0', '0', '0', '0'\n};\n\n// ****************** code ******************\n\nint add_esd (unsigned char * p, short esd) {\n    long i;\n    esd_ptr s;\n    esd_ptr e = (esd_ptr)malloc (sizeof (esd_r));\n    if (e) {\n        e->txt = NULL;\n        e->rld = NULL;\n        e->esd = esd;\n        e->idr = NULL;\n        e->idy = NULL;\n\n        memcpy (e->name, p, 8);\n        e->name \u00dd8\u00a8 = 0;\n        i = 7;\n        while (e->name \u00ddi\u00a8 == ' ')\n            e->name \u00ddi--\u00a8 = 0;\n\n        e->type = p \u00dd8\u00a8;\n        e->address = (p \u00dd9\u00a8 << 16) | (p \u00dd10\u00a8 << 8) | p \u00dd11\u00a8;\n        e->flag = p \u00dd12\u00a8;\n        e->length = (p \u00dd13\u00a8 << 16) | (p \u00dd14\u00a8 << 8) | p \u00dd15\u00a8;\n\n        if ((head == NULL) || // Empty - just add it\n            (e->type == 0x0A) || // Put WX records first so we skip them when building the objects\n            (head->address > e->address) || // Sort by addresses\n            ((head->type != 0x0A) &&    // As long as it's not a WX,\n             (head->address == e->address) &&\n             (e->type < head->type))) { // insert lower types first\n            e->next = head;\n            head = e;\n        } else {\n            s = head;\n            while ((s->next) &&\n                   ((s->next->address < e->address) ||\n                    (s->next->type == 0x0A) ||           // This type isn't 0x0A...\n                    ((s->next->address == e->address) && // If the address is equal,\n                     (e->type > s->next->type))))        // put SD records first.\n                s = s->next;\n\n            e->next = s->next;\n            s->next = e;\n        }\n        return (0);\n    }\n    printf (\"Out of memory allocating an ESD record\\n\");\n    return (1);\n}\n\nint add_rld (short f_esd, short s_esd, long address, short f) {\n    rld_ptr r;\n    rld_ptr t;\n    esd_ptr s = head;\n    while ((s) && (s->esd != s_esd))\n        s = s->next;\n\n    if (s) { // Found the correct location\n        r = (rld_ptr)malloc (sizeof (rld_r));\n        if (r) {\n            r->esd = f_esd;\n            r->address = address;\n            r->flgs = f & 0xFE;\n            r->next = NULL;\n            if (s->rld == NULL) {\n                s->rld = r;\n            } else {\n                t = s->rld;\n                while (t->next)\n                    t = t->next;\n                t->next = r;\n            }\n            return (0);\n        } else\n            printf (\"Out of memory allocating an RLD record\\n\");\n    } else\n        printf (\"Couldn't locate required ESD record (%04X)\\n\", s_esd);\n    return (1);\n}\n\nint splittxt (unsigned char * b, short l) { // l is not used\n    int i = 0;\n    short esd;\n    short len;\n    esd_ptr s;\n    txt_ptr t;\n    txt_ptr u;\n    char * c;\n\n    while (i < ctldcnt) {\n        esd = *((short *)(&(ctldata \u00ddi + 0\u00a8)));\n        len = *((short *)(&(ctldata \u00ddi + 2\u00a8)));\n\n        s = head;\n        while (s) {\n            if (s->esd == esd)\n                break;\n            s = s->next;\n        }\n        if (s == NULL) {\n            printf (\"Couldn't locate required ESD record (%04X)\\n\", esd);\n            return (1);\n        }\n        u = (txt_ptr)malloc (sizeof (txt_r));\n        if (u == NULL) {\n            printf (\"Out of memory creating a new txt record\\n\");\n            return (1);\n        }\n        u->text = (unsigned char *)malloc (len);\n        if (u->text == NULL) {\n            printf (\"Out of memory creating a new text area\\n\");\n            return (1);\n        }\n        memcpy (u->text, b, len);\n        u->textlen = len;\n        u->address = ctladdr - s->address; // Convert to relative address\n        u->next = NULL;\n        if (s->txt == NULL)\n            s->txt = u;\n        else {\n            t = s->txt;\n            while (t->next)\n                t = t->next;\n            t->next = u;\n        }\n        ctladdr += len;\n        b += len;\n        i += 4;\n    }\n    return (0);\n}\n\nint process (unsigned char * b, short l) { // l is not used\n    long  i;\n    long  j;\n    long  k;\n    short f_esd;\n    short s_esd;\n    short length;\n    unsigned char * p;\n    esd_ptr s;\n\n    short i_esd \u00dd127\u00a8; // max allowed for idr\n    char ts \u00dd20\u00a8; // space for a decoded IDR record + nul terminator\n\n    switch (b \u00dd0\u00a8) {\n        case 0x40: // SYM Record\n            break; // Do Nothing\n\n        case 0x10: // SCATTER/TRANSLATION Record\n            break; // Do Nothing\n\n        case 0x20: // CESD Record\n            f_esd = *((short *)(&(b \u00dd4\u00a8)));\n            length = *((short *)(&(b \u00dd6\u00a8)));\n            p = &(b \u00dd8\u00a8);\n            while (length >= 16) {\n                if (add_esd (p, f_esd++))\n                    return (1);\n                p += 16;\n                length -= 16;\n            }\n            break;\n\n        case 0x80: // IDR Record\n            if ((b \u00dd2\u00a8 & 0x0F) == 0x04) {        // Trans IDR\n                length = b \u00dd1\u00a8 + 1;\n                k = 3;\n                while (k < length) {\n                    i = 0;\n                    do {\n                        i_esd \u00ddi++\u00a8 = *((unsigned short *)&(b \u00ddk\u00a8));\n                        k += 2;\n                    } while ((i_esd \u00ddi-1\u00a8 & 0x8000) == 0);\n                    i_esd \u00ddi-1\u00a8 &= 0x7FFF; // Remove top bit\n                    k++; // skip nul byte\n                    j = 0;\n                    while (j < 10)\n                        ts \u00ddj++\u00a8 = b \u00ddk++\u00a8;\n                    while (j < 19) {\n                        ts \u00ddj++\u00a8 = (b \u00ddk\u00a8 >> 4) + '0';\n                        ts \u00ddj++\u00a8 = (b \u00ddk\u00a8 &0xF) + '0'; k++;\n                    }\n                    ts \u00ddj-1\u00a8 = 0; // didn't want the last char\n\n                    j = 0;\n                    while (j < i) { // for each esd found\n                        s = head;\n                        while (s) { // find the esd record\n                            if (s->esd == i_esd \u00ddj\u00a8) {\n                                s->idr = (char *)malloc (20); // add the idr data\n                                if (s->idr)\n                                    strcpy (s->idr, ts);\n                                break;\n                            }\n                            s = s->next;\n                        }\n                        j++;\n                    }\n                }\n            } else if ((b \u00dd2\u00a8 & 0x0F) == 0x08) { // Users IDR\n                length = b \u00dd1\u00a8 + 1;\n                k = 3;\n                while (k < length) {\n                    f_esd = *((unsigned short *)&(b \u00ddk\u00a8));\n                    k += 5; // Skip coded date\n                    j = b \u00ddk++\u00a8; // Get length\n\n                    s = head;\n                    while (s) { // find the esd record\n                        if (s->esd == f_esd) {\n                            s->idy = (char *)malloc (j + 1); // add the idy data\n                            if (s->idy) {\n                                memcpy (s->idy, &(b \u00ddk\u00a8), j);\n                                s->idy \u00ddj\u00a8 = 0;\n                            }\n                            break;\n                        }\n                        s = s->next;\n                    }\n                    k += j; // Is there a 'next' record?\n                }\n            } // else ignore this record\n            break;\n\n        case 0x01: // CTL Record\n        case 0x05:\n        case 0x0D:\n            data = 1;\n            ctldcnt = *((short *)(&(b \u00dd4\u00a8)));\n            ctladdr = *((long *)(&(b \u00dd8\u00a8))) & 0x00FFFFFF;\n            memcpy (ctldata, &(b \u00dd16\u00a8), ctldcnt);\n            break;\n\n        case 0x03: // RLD/CTL Record\n        case 0x07:\n        case 0x0F:\n            data = 1;\n            ctldcnt = *((short *)(&(b \u00dd4\u00a8)));\n            length = *((short *)(&(b \u00dd6\u00a8)));\n            ctladdr = *((long *)(&(b \u00dd8\u00a8))) & 0x00FFFFFF;\n            memcpy (ctldata, &(b \u00dd16 + length\u00a8), ctldcnt);\n            // *** Drop through ***\n\n        case 0x02: // RLD Record\n        case 0x06:\n        case 0x0E:\n            length = *((short *)(&(b \u00dd6\u00a8))); // May already be set :(\n            p = &(b \u00dd16\u00a8);\n            j = 1;\n            while (length > 0) {\n                if (j) {\n                    f_esd = *((short *)(&(p \u00dd0\u00a8)));\n                    s_esd = *((short *)(&(p \u00dd2\u00a8)));\n                    k = 4;\n                } else\n                    k = 0;\n                if ((p \u00ddk\u00a8 & 0x01) == 0x01)\n                    j = 0;\n                else\n                    j = 1;\n                if (add_rld (f_esd, s_esd, *((long *)(&(p \u00ddk\u00a8))) & 0x00FFFFFF, p \u00ddk\u00a8))\n                    return (1);\n                length -= (k + 4);\n                p += (k + 4);\n            }\n            break;\n    }\n    return (0);\n}\n\nesd_ptr add_o_esd (obj_ptr n, esd_ptr s, long ext) {\n    esd_ptr p = (esd_ptr)malloc (sizeof (esd_r));\n    if (p == NULL) {\n        printf (\"Out of memory creating a new esd\\n\");\n        return (NULL);\n    }\n    memcpy (p, s, sizeof (esd_r));\n    p->next = NULL;\n    p->rld = NULL;\n    if ((ext) || (p->type != 0x03)) // Not an LD - use the main counter\n        p->new_esd = next_esd1++;\n    else\n        p->new_esd = next_esd2++;\n\n    if ((ext) && (p->type != 0x0A)) // If not Weak, this is an external reference to it\n        p->type = 0x02;\n    else if (p->type == 0x03) // Is the Loadmodules type = LD\n        p->type = 0x01; // Convert it to object deck type LD\n\n    if (n->esd == NULL) // Add the new esd to the current end of the objects list\n        n->esd = p;\n    else {\n        s = n->esd;\n        while (s->next)\n            s = s->next;\n        s->next = p;\n    }\n    return (p);\n}\n\nint make (char * ifn) {\n    long i;\n    unsigned long j;\n    long k;\n    obj_ptr n = NULL;\n    obj_ptr o;\n    esd_ptr p;\n    esd_ptr s;\n    rld_ptr t;\n    txt_ptr u;\n    txt_ptr v;\n\n    s = head;\n    while (s) {\n        switch (s->type) {\n            case 0x00: // SD - Start a new object deck\n                next_esd1 = 1;\n                next_esd2 = 1;\n                o = (obj_ptr)malloc (sizeof (obj_r));\n                if (o == NULL) {\n                    printf (\"Out of memory creating a new object\\n\");\n                    goto makeerr;\n                }\n                o->esd = NULL;\n                o->next = NULL;\n                if (objs == NULL)\n                    objs = o;\n                else\n                    n->next = o;\n                n = o;\n                // *** Drop through ***\n\n            case 0x03: // LD - Add to the current object deck\n                if (n == NULL)\n                    break; // Can't happen\n\n                if (add_o_esd (n, s, 0) == NULL) // Add as a local define\n                    goto makeerr;\n\n                t = s->rld; // Any ERs? (Should only happen for SDs)\n                while (t) {\n                    p = n->esd; // Is the esd already in the object?\n                    while (p) {\n                        if (p->esd == t->esd)\n                            break;   // Yes\n                        p = p->next;\n                    }\n                    if (p == NULL) { // No\n                        p = head;    // Find it in the full list\n                        while (p) {\n                            if (p->esd == t->esd)\n                                break;\n                            p = p->next;\n                        }\n                        if (p) // Found it...\n                            p = add_o_esd (n, p, 1); // Add it as an external define\n                        else\n                            printf (\"Couldn't locate required ESD record (%04X)\\n\", t->esd);\n                    }\n                    if (p) { // Hope there's enough memory\n                        t->esd = p->new_esd; // Translate the loadmodule esd to the new objects one\n                        t->address -= n->esd->address;\n\n                        i = t->address; // find the base\n                        u = s->txt; // Now we have a localised RLD record, fix the txt pointers\n                        while (u) {\n                            if ((u->address <= i) && (u->address + u->textlen > i)) {\n                                i -= u->address; // Find the correct offset within the block\n                                if (p->type >= 2) { // It's external, just blank it out...\n                                    if ((t->flgs & 0xC) == 0xC) { // Check size of relocation\n                                        u->text \u00ddi++\u00a8 = 0;\n                                        if (u->textlen <= i) {i = 0; u = u->next;}\n                                    }\n                                    u->text \u00ddi++\u00a8 = 0;\n                                    if (u->textlen <= i) {i = 0; u = u->next;}\n                                    u->text \u00ddi++\u00a8 = 0;\n                                    if (u->textlen <= i) {i = 0; u = u->next;}\n                                    u->text \u00ddi\u00a8   = 0;\n                                    break;\n                                }\n                                v = u; // Remember start positions\n                                k = i;\n                                if ((t->flgs & 0xC) == 0xC) { // Check size of relocation\n                                    j = u->text \u00ddi++\u00a8 << 24;\n                                    if (u->textlen <= i) {i = 0; u = u->next;}\n                                } else\n                                    j = 0;\n                                j |= u->text \u00ddi++\u00a8 << 16;\n                                if (u->textlen <= i) {i = 0; u = u->next;}\n                                j |= u->text \u00ddi++\u00a8 << 8;\n                                if (u->textlen <= i) {i = 0; u = u->next;}\n                                j |= u->text \u00ddi\u00a8;\n\n                                j -= n->esd->address; // Fix the relocation\n\n                                i = k; // Reset to start\n                                u = v;\n                                if ((t->flgs & 0xC) == 0xC) { // Check size of relocation\n                                    u->text \u00ddi++\u00a8 = ((j >> 24) & 0xFF);\n                                    if (u->textlen <= i) {i = 0; u = u->next;}\n                                }\n                                u->text \u00ddi++\u00a8 = ((j >> 16) & 0xFF);\n                                if (u->textlen <= i) {i = 0; u = u->next;}\n                                u->text \u00ddi++\u00a8 = ((j >> 8) & 0xFF);\n                                if (u->textlen <= i) {i = 0; u = u->next;}\n                                u->text \u00ddi\u00a8   = ((j) & 0xFF);\n                                break; // All done\n                            }\n                            u = u->next;\n                        }\n                    } else {\nmakeerr:\n                        printf (\"Ending make for %s\\n\", ifn);\n                        return (1);\n                    }\n                    t = t->next;\n                }\n                if (s->rld) {// Should only happen for SDs\n                    if (s->type != 0) {\n                        printf (\"Unexpected RLD from ESD type %02X\\n\", s->type);\n                        goto makeerr;\n                    }\n                    n->esd->rld = s->rld;\n                }\n                break;\n\n            case 0x0A: // WX - Do nothing with these records, they are for reference only\n                break;\n        }\n        s = s->next;\n    }\n    return (0);\n}\n\nvoid dump (FILE * f, int parms, char * filename) {\n    long i;\n    long k;\n    long l = 1; // Line Numbers\n    char st \u00dd9\u00a8;\n    char ep \u00dd9\u00a8;\n    char op \u00dd80\u00a8;\n    char tp \u00dd80\u00a8;\n    obj_ptr o;\n    esd_ptr s;\n    rld_ptr t;\n    txt_ptr u;\n    char * reus_attr;\n    char * load_attr;\n    char * m;\n\n    ep \u00dd0\u00a8 = 0; // If no name, don't emit ENTRY\n    o = objs;\n    while (o) {\n        s = o->esd;\n        while (s) {\n            if ((ep \u00dd0\u00a8 == 0) && (s->address == epa)) // Found the entry name?\n                strcpy (ep, s->name);\n\n            *((short *)&(esd \u00dd14\u00a8)) = s->new_esd;\n            sprintf (st, \"%-8s\", s->name);\n            memcpy (&(esd \u00dd16\u00a8), st, 8);\n            esd \u00dd24\u00a8 = (unsigned char)s->type;\n            esd \u00dd25\u00a8 = 0;\n            esd \u00dd26\u00a8 = 0; // Address is zero except for LDs...\n            esd \u00dd27\u00a8 = 0;\n            if (s->type == 0) {        // SD\n                esd \u00dd28\u00a8 = (unsigned char)s->flag;\n                esd \u00dd29\u00a8 = (unsigned char)(s->length >> 16);\n                esd \u00dd30\u00a8 = (unsigned char)(s->length >> 8);\n                esd \u00dd31\u00a8 = (unsigned char)(s->length);\n            } else if (s->type == 1) { // LD\n                i = (s->address - o->esd->address); // Calculate correct offset\n                esd \u00dd25\u00a8 = (unsigned char)(i >> 16);\n                esd \u00dd26\u00a8 = (unsigned char)(i >> 8);\n                esd \u00dd27\u00a8 = (unsigned char)(i);\n                esd \u00dd28\u00a8 = ' ';\n                esd \u00dd29\u00a8 = 0;\n                esd \u00dd30\u00a8 = 0;\n                esd \u00dd31\u00a8 = 1;\n            } else {                   // ER/WX\n                esd \u00dd28\u00a8 = ' ';\n                esd \u00dd29\u00a8 = ' ';\n                esd \u00dd30\u00a8 = ' ';\n                esd \u00dd31\u00a8 = ' ';\n            }\n            sprintf (st, \"%08d\", l++); // Emit the line number\n            memcpy (&(esd \u00dd72\u00a8), st, 8);\n            fwrite (esd, 1, 80, f);\n            s = s->next;\n        }\n        u = o->esd->txt;\n        while (u) {\n            // trim textlen if it passes the obj size (happens due to U records?)\n            if ((u->next == NULL) &&\n                (u->address + u->textlen > o->esd->length)) // probably by 2/4 bytes\n                u->textlen -= ((u->address + u->textlen) - o->esd->length);\n\n            i = 0;\n            while (i < u->textlen) {\n                k = u->textlen - i;\n                if (k > 56)\n                    k = 56;\n                txt \u00dd5\u00a8 = (unsigned char)((u->address + i) >> 16);\n                txt \u00dd6\u00a8 = (unsigned char)((u->address + i) >> 8);\n                txt \u00dd7\u00a8 = (unsigned char)((u->address + i));\n                *((short *)&(txt \u00dd10\u00a8)) = k;\n                memcpy (&(txt \u00dd16\u00a8), &(u->text \u00ddi\u00a8), k);\n                if (k < 56) // Need to pad the record?\n                    memset (&(txt \u00dd16 + k\u00a8), 0x40, 56 - k);\n                sprintf (st, \"%08d\", l++); // Emit the line number\n                memcpy (&(txt \u00dd72\u00a8), st, 8);\n                fwrite (txt, 1, 80, f);\n                i += k;\n            }\n            u = u->next;\n        }\n        k = 1;\n        t = o->esd->rld;\n        while (t) {\n            i = 16;\n            memset (&(rld \u00dd16\u00a8), 0x40, 56);\n            while ((t) && (i + 4 + (k * 4) <= 72)) {\n                if (k) {\n                    rld \u00ddi++\u00a8 = (unsigned char)(t->esd >> 8);\n                    rld \u00ddi++\u00a8 = (unsigned char)(t->esd);\n                    rld \u00ddi++\u00a8 = 0;\n                    rld \u00ddi++\u00a8 = 1;\n                }\n                rld \u00ddi++\u00a8 = t->flgs;\n\n                if ((t->next) &&\n                    (t->esd == t->next->esd) &&\n                    (i + 3 + 4 <= 72)) {\n                    rld \u00ddi-1\u00a8 |= 1;\n                    k = 0;\n                } else\n                    k = 1;\n\n                rld \u00ddi++\u00a8 = (unsigned char)(t->address >> 16);\n                rld \u00ddi++\u00a8 = (unsigned char)(t->address >> 8);\n                rld \u00ddi++\u00a8 = (unsigned char)(t->address);\n\n                t = t->next;\n            }\n            rld \u00dd11\u00a8 = i - 16;\n            sprintf (st, \"%08d\", l++); // Emit the line number\n            memcpy (&(rld \u00dd72\u00a8), st, 8);\n            fwrite (rld, 1, 80, f);\n        }\n\n        if (o->esd->idr) // did we find an idr record?\n            memcpy (&(end \u00dd33\u00a8), o->esd->idr, 19);\n        sprintf (st, \"%08d\", l); // Emit the line number\n        memcpy (&(end \u00dd72\u00a8), st, 8);\n        fwrite (end, 1, 80, f);\n        o = o->next;\n        l = 1; // Line numbers back to 1 for the next object deck\n    }\n    s = head;\n    while (s) { // parse the esd records\n        if (s->idy) { // Has it got user IDENTIFY data?\n            memset (op, 0x40, 80);\n            sprintf (tp, \"IDENTIFY %s('%s')\", s->name, s->idy);\n            memcpy (&(op \u00dd1\u00a8), tp, strlen (tp));\n            fwrite (op, 1, 80, f);\n        }\n        s = s->next;\n    }\n    if (glob_p->ssi) {\n        memset (op, 0x40, 80);\n        memcpy (&(op \u00dd1\u00a8), \"SETSSI \", 7);\n        i = 0;\n        k = (long)glob_ssi - (long)glob_p;\n        while (i < 8) {\n            op \u00dd8 + i++\u00a8 = '0' + (link_edit_data \u00ddk\u00a8 >> 4);\n            op \u00dd8 + i++\u00a8 = '0' + (link_edit_data \u00ddk++\u00a8 & 0xF);\n        }\n        fwrite (op, 1, 80, f);\n    }\n    if ((glob_p->apflg) && (glob_apf->apfct == 0x01) &&\n                           (glob_apf->apfac == 0x01)) {\n        memset (op, 0x40, 80);\n        memcpy (&(op \u00dd1\u00a8), \"SETCODE AC(1)\", 13);\n        fwrite (op, 1, 80, f);\n    }\n    if (parms) {\n        reus_attr = \"NONE\";\n        if (glob_p->reus) reus_attr = \"SERIAL\";\n        if (glob_p->rent) reus_attr = \"RENT\";\n        if (glob_p->refr) reus_attr = \"REFR\";\n        if (glob_p->load) load_attr = \"OL\";\n        else              load_attr = \"NOOL\";\n        sprintf (tp, \"SETOPT PARM(REUS(%s),%s)\", reus_attr, load_attr);\n        memset (op, 0x40, 80);\n        memcpy (&(op \u00dd1\u00a8), tp, strlen (tp));\n        fwrite (op, 1, 80, f);\n\n        if (alias == 0)\n            i = glob_p->mamod;\n        else\n            i = glob_p->aamod;\n        if (i == 1) {\n            memset (op, 0x40, 80);\n            memcpy (&(op \u00dd1\u00a8), \"MODE AMODE(24)\", 14);\n            fwrite (op, 1, 80, f);\n        } else if (i == 2) {\n            memset (op, 0x40, 80);\n            if (glob_p->lrmod)\n                memcpy (&(op \u00dd1\u00a8), \"MODE AMODE(31),RMODE(ANY)\", 25);\n            else\n                memcpy (&(op \u00dd1\u00a8), \"MODE AMODE(31),RMODE(24)\", 24);\n            fwrite (op, 1, 80, f);\n        } else if (i == 3) {\n            memset (op, 0x40, 80);\n            memcpy (&(op \u00dd1\u00a8), \"MODE AMODE(ANY)\", 15);\n            fwrite (op, 1, 80, f);\n        }\n    }\n    if (ep \u00dd0\u00a8) {\n        memset (op, 0x40, 80);\n        memcpy (&(op \u00dd1\u00a8), \"ENTRY\", 5);\n        memcpy (&(op \u00dd7\u00a8), ep, strlen (ep));\n        fwrite (op, 1, 80, f);\n    }\n    if (parms) {\n        strcpy (tp, filename);\n        m = strstr (tp, \")\");\n        if (m) {\n            m \u00dd0\u00a8 = 0;\n            m = strstr (tp, \"(\");\n            if (m) {\n                m++; // Got the member name\n                strncpy (st, m, 8);\n                st \u00dd8\u00a8 = 0;\n                strupr (st);\n                memset (op, 0x40, 80);\n                sprintf (tp, \"NAME %s(R)\", st);\n                memcpy (&(op \u00dd1\u00a8), tp, strlen (tp));\n                fwrite (op, 1, 80, f);\n            }\n        }\n    }\n}\n/*\nvoid dump2 (FILE * f) {\n    long i;\n    obj_ptr o;\n    esd_ptr s;\n    rld_ptr t;\n    txt_ptr u;\n\n    o = objs;\n    while (o) {\n        s = o->esd;\n        while (s) {\n            fprintf (f, \"%02X %-8s %04X %06X %06X %02X\\n\",\n                s->type, s->name, s->new_esd, s->address, s->length, s->flag);\n            s = s->next;\n        }\n        u = o->esd->txt;\n        while (u) {\n            fprintf (f, \" TXT %06X %06X\\n\", u->address, u->textlen);\n            u = u->next;\n        }\n        i = 0;\n        t = o->esd->rld;\n        while (t) {\n            fprintf (f, \" %04X=>%06X\", t->esd, t->address);\n            t = t->next;\n            i++;\n            if ((i >= 6) || (t == NULL)) {\n                fprintf (f, \"\\n\");\n                i = 0;\n            }\n        }\n        fprintf (f, \"\\n\");\n        o = o->next;\n    }\n}\n\nvoid dump3 (FILE * f) {\n    long i;\n    obj_ptr o;\n    esd_ptr s;\n    rld_ptr t;\n    txt_ptr u;\n\n    s = head;\n    while (s) {\n        fprintf (f, \"%02X %-8s %04X %06X %06X %02X\\n\",\n            s->type, s->name, s->esd, s->address, s->length, s->flag);\n\n        u = s->txt;\n        while (u) {\n            fprintf (f, \" TXT %06X %06X\\n\", u->address, u->textlen);\n            u = u->next;\n        }\n        i = 0;\n        t = s->rld;\n        while (t) {\n            fprintf (f, \" %04X=>%06X\", t->esd, t->address);\n            t = t->next;\n            i++;\n            if ((i >= 6) || (t == NULL)) {\n                fprintf (f, \"\\n\");\n                i = 0;\n            }\n        }\n        s = s->next;\n    }\n}\n*/\n\n#define endmark \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\"\n#define SKIP_MASK ((int) 0x1F)\n#define ALIAS_MASK ((int) 0x80)\n\nlong get_link (char * infile) {\n    char   i \u00dd64\u00a8;\n    char   line \u00dd256\u00a8;\n    char   member \u00dd9\u00a8;\n    char * a;\n    char * c;\n    FILE * f;\n    long   j;\n    long   quit;\n    int    info_byte;\n    short  l;\n    short  b;\n    short  count;\n    short  skip;\n    long   rc = -1;\n\n    strcpy (i, infile);\n    a = strstr (i, \")\");\n    c = strstr (i, \"(\");\n    if ((a) && (c) && (a - c > 1)) {\n        a \u00dd0\u00a8 = 0;\n        c \u00dd0\u00a8 = 0;\n        c++; // c now points to the member\n        strupr (c);\n\n        f = fopen (i, \"rb,klen=0,lrecl=256,blksize=256,recfm=u,force\");\n        if (f) {\n            fread (&l, 1, 2, f); /* Skip U length */\n\n            quit = 0;\n            while (fread (line, 1, 256, f) == 256) {\n\n                a = &(line \u00dd2\u00a8);\n                b = ((short *)&(line \u00dd0\u00a8)) \u00dd0\u00a8;\n                count = 2;\n                while (count < b) {\n                    if (memcmp (a, endmark, 8) == 0) {\n                        quit = 1;\n                        break;\n                    }\n                    memcpy (member, a, 8);\n                    j = 7;\n                    while (member \u00ddj\u00a8 == ' ') j--;\n                    member \u00dd++j\u00a8 = 0;\n                    //a += 8;\n                    //i = (((int *)a) \u00dd0\u00a8) & 0xFFFFFF00; // TTR of member\n                    //a += 3; // All this is unused...\n                    a += 11;\n                    info_byte = (int)(*a);\n                    a++;\n                    skip = (info_byte & SKIP_MASK) * 2;\n                    if (strcmp (c, member) == 0) {\n                        if ((info_byte & ALIAS_MASK) != 0)\n                            alias = 1;\n                        if (skip >= 4) { // User data is present\n                            link_edit_data_len = skip;\n                            memcpy (link_edit_data, a, skip);\n                            rc = (((int *)a) \u00dd0\u00a8) & 0xFFFFFF00;\n                        }\n                        quit = 1;\n                        break;\n                    }\n                    a += skip;\n                    count += (8 + 4 + skip);\n                }\n                if (quit) break;\n                fread (&l, 1, 2, f); /* Skip U length */\n            }\n            fclose (f);\n        } else {\n            printf (\"get_link couldn't open the directory\\n\");\n        }\n    } else {\n        printf (\"get_link couldn't determine the member\\n\");\n    }\n    return (rc);\n}\n\nint main (int argc, char * argv \u00dd\u00a8) {\n    FILE * f;\n    FILE * o;\n    unsigned char b \u00dd32768\u00a8; // buffer space for a track\n    short l;\n    long ttr; // First-text-byte of loadmodule code TTR0 pointer\n    long i;\n    long rc = 8; // Assume the worst\n    long parm = 0;\n    long info = 0;\n\n    if ((argc != 3) && (argc != 4) && (argc != 5)) {\n        printf (\"Usage: DELINK //DSN:MY.LOAD(MYPGM) //DSN:MY.OBJ(MYPGM) {setopt} {info}\\n\");\n        printf (\"The setopt flag is optional: object deck will have various options set\\n\");\n        printf (\"The info flag is optional: directory flags will be printed\\n\");\n        return (rc);\n    }\n    i = 3;\n    while (i < argc) {\n        if (stricmp (argv \u00ddi\u00a8, \"info\") == 0) {\n            info = 1;\n        } else if (stricmp (argv \u00ddi\u00a8, \"setopt\") == 0) {\n            parm = 1;\n        } else {\n            printf (\"Invalid option specified: %s\\n\", argv \u00ddi\u00a8);\n            return (rc);\n        }\n        i++;\n    }\n    f = fopen (argv \u00dd1\u00a8, \"rb\");\n    if (f) {\n        ttr = get_link (argv \u00dd1\u00a8);\n        if (ttr == -1) {\n            fclose (f);\n            printf (\"get_link(%s) didn't find any user-data\\n\", argv \u00dd1\u00a8);\n            return (rc);\n        }\n        glob_p = (pds_ptr)&(link_edit_data \u00dd0\u00a8);\n        epa = (glob_p->epa1 << 16) | (glob_p->epa2 << 8) | glob_p->epa3;\n        if (info) {\n            //printf (\"get_link returned a user-data TTR of %08X\\n\", ttr);\n            i = 0;\n            printf (\"UserData: \");\n            while (i < link_edit_data_len)\n                printf (\"%02X\", link_edit_data \u00ddi++\u00a8);\n\n            printf (\"\\nXlated: \");\n            if (glob_p->rent)  printf (\"RENT \");\n            if (glob_p->reus)  printf (\"REUS \");\n            if (glob_p->ovly)  printf (\"OVLY \");\n            if (glob_p->test)  printf (\"TEST \");\n            if (glob_p->load)  printf (\"LOAD \");\n            if (glob_p->sctr)  printf (\"SCATTER \");\n            if (glob_p->exec)  printf (\"EXEC \");\n            if (glob_p->blk1)  printf (\"BLOCK \");\n            if (glob_p->flvl)  printf (\"FLVL \");\n            if (glob_p->org0)  printf (\"ZERO-ORG \");\n            if (glob_p->ep0)   printf (\"EP0 \");\n            else               printf (\"EP%06X \", epa);\n            if (glob_p->nrld)  printf (\"NRLD \");\n            if (glob_p->nrep)  printf (\"NREP \");\n            if (glob_p->tstn)  printf (\"TSTN \");\n            if (glob_p->lef)   printf (\"LEF \");\n            if (glob_p->refr)  printf (\"REFR \");\n            if (glob_p->ssi)   printf (\"SSI \");\n            if (glob_p->apflg) printf (\"APFLG \");\n            if (glob_p->lrmod) printf (\"LRMOD \");\n            printf (\"AMODE=A%d,M%d\", glob_p->aamod, glob_p->mamod);\n            printf (\"\\n\");\n        }\n\n        if (glob_p->sctr) { // Work out aux. pointers, we really only want the APF one though\n            glob_sctr = (sctr_ptr)((long)glob_p + 21);\n            if (alias)\n                glob_alias = (alias_ptr)((long)glob_sctr + 8);\n        } else {\n            if (alias)\n                glob_alias = (alias_ptr)((long)glob_p + 21);\n        }\n        if (glob_p->ssi) { // ssi\n            if (alias) {\n                glob_ssi = (ssi_ptr)((long)glob_alias + 11); // Is already half-word aligned\n            } else {\n                if (glob_p->sctr)\n                   glob_ssi = (ssi_ptr)((long)glob_sctr + 9); // 1-extra for halfword alignment\n                else\n                   glob_ssi = (ssi_ptr)((long)glob_p + 22); // 1 extra for halfword alignment\n            }\n        }\n        if (glob_p->apflg) {       // Find the correct offset:\n                              glob_apf = (apf_ptr)((long)glob_p + 21);\n            if (glob_p->sctr) glob_apf = (apf_ptr)((long)glob_sctr + 8);\n            if (alias)        glob_apf = (apf_ptr)((long)glob_alias + 11);\n            if (glob_p->ssi)  glob_apf = (apf_ptr)((long)glob_ssi + 4);\n        }\n        if ((alias) && (info)) {\n            memcpy (b, glob_alias->mnm, 8);\n            b \u00dd8\u00a8 = 0;\n            printf (\"Information: This is an alias of member: %s\\n\", b);\n        }\n        o = fopen (argv \u00dd2\u00a8, \"wb\");\n        if (o) {\n            while (fread (&l, 1, 2, f)) {\n                fread (b, 1, l, f);\n                if (data) {\n                    data = 0;\n                    if (splittxt (b, l)) {\n                        printf (\"Ending due to a detected error\\n\");\n                        goto err;\n                    }\n                } else {\n                    if (process (b, l)) {\n                        printf (\"Ending due to a detected error\\n\");\n                        goto err;\n                    }\n                }\n            }\n            if (make (argv \u00dd1\u00a8)) { // Build the object\n                printf (\"Ending due to a detected error\\n\");\n                goto err;\n            }\n            dump (o, parm, argv \u00dd1\u00a8); // Pass in the input filename (for the member-name)\n            printf (\"Object dumped without any errors\\n\");\n            rc = 0; // All OK\nerr:\n            fclose (o);\n        } else {\n            printf (\"Cannot open output file (%s)\\n\", argv \u00dd2\u00a8);\n        }\n        fclose (f);\n\n    } else {\n        printf (\"Cannot open input file (%s)\\n\", argv \u00dd1\u00a8);\n    }\n    return (rc);\n}\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT802/CBT.V500.FILE802.PDS/SOURCE.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT802/CBT.V500.FILE802.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}