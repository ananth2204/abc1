{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012505000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE625.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE625.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\r'", "DS1TRBAL": "b'UD'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x8e\\x00\\t\\x04\\x8e\\x00\\x0b\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04<\\x00\\x00\\x01\\x03\\x12\\x1f\\x01\\x03\\x12\\x1f\\x13\\t\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf0@@@'", "ispf": {"version": "04.60", "flags": 0, "createdate": "2003-05-01T00:00:00", "modifydate": "2003-05-01T13:09:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-460"}, "text": "REGULAR CBT TAPE - VERSION 460    FILE:  625\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT460.FILE625\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 3 MEMBERS COUNTED; CUMULATIVE SIZE IS 328 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   05/01/03    13:09:16    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE625": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04<\\x00\\x00\\x01\\x03\\x12\\x1f\\x01\\x03\\x12\\x1f\\x13\\x08\\x00 \\x00 \\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf6\\xf0@@@'", "ispf": {"version": "04.60", "flags": 0, "createdate": "2003-05-01T00:00:00", "modifydate": "2003-05-01T13:08:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "CBT-460"}, "text": "//***FILE 625 is contributed semi-anonymously and contains a REXX   *   FILE 625\n//*           exec that will recatalog datasets, based on a LISTCAT *   FILE 625\n//*           from their old catalog.  This REXX was developed      *   FILE 625\n//*           when moving from one datacenter to the other, where   *   FILE 625\n//*           the packs in the old datacenter were 3380's, and the  *   FILE 625\n//*           packs in the new datacenter were 3390's having the    *   FILE 625\n//*           same names as the old packs.                          *   FILE 625\n//*                                                                 *   FILE 625\n//*           email for questions:  sbgolob@cbttape.org             *   FILE 625\n//*                                 sbgolob@attglobal.net           *   FILE 625\n//*                                 sbgolob@aol.com                 *   FILE 625\n//*                                                                 *   FILE 625\n//*   More detailed description:                                    *   FILE 625\n//*                                                                 *   FILE 625\n//*         This REXX will attempt to read the output file from     *   FILE 625\n//*    a LISTCAT command and then uncatalog and recatalog all       *   FILE 625\n//*    the files listed.  The files will be recataloged to the      *   FILE 625\n//*    same pack name as they were originally cataloged on.         *   FILE 625\n//*    The purpose of this was to change the cataloging of all      *   FILE 625\n//*    files on a list of 3380 packs to 3390 packs when moving      *   FILE 625\n//*    to a new data center.  The LISTCAT was for just the 3380     *   FILE 625\n//*    packs and it did what was expected of it.  The program       *   FILE 625\n//*    may not handle all possible file types, but it should be     *   FILE 625\n//*    fairly easy to make the changes needed for them.             *   FILE 625\n//*                                                                 *   FILE 625\n//*         Under ISPF the input and output file names may          *   FILE 625\n//*    either be requested by the program or entered as             *   FILE 625\n//*    arguments on the command line.  Otherwise, it expects the    *   FILE 625\n//*    input to be in the DDNAME INPUT and the output will go to    *   FILE 625\n//*    the DDNAME OUTPUT so that it can easily be run in batch      *   FILE 625\n//*    mode.                                                        *   FILE 625\n//*                                                                 *   FILE 625\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FIXCAT": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x05\\x01\\x03\\x11\\x1f\\x01\\x03\\x11O\\x10\\x05\\x01\\x1c\\x00\\xd2\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-04-21T00:00:00", "modifydate": "2003-04-24T10:05:05", "lines": 284, "newlines": 210, "modlines": 0, "user": "SBGOLOB"}, "text": "/*============================ REXX =================================*/\n/*                                                                   */\n/*        This REXX will attempt to read the output file from a      */\n/*   LISTCAT command and then uncatalog and recatalog all the files  */\n/*   listed. The files will be recataloged to the same pack name as  */\n/*   they were originally cataloged on.  The purpose of this was to  */\n/*   change the cataloging of all files on a list of 3380 packs to   */\n/*   3390 packs when moving to a new data center.  The LISTCAT was   */\n/*   for just the 3380 packs and it did what was expected of it.     */\n/*   The program may not handle all possible file types, but it be   */\n/*   fairly easy to make the changes needed for them                 */\n/*                                                                   */\n/*        Under ISPF the input and output file names may either      */\n/*   be requested by the program or entered as arguments on the      */\n/*   command line.  Otherwise, it expects the input to be in the     */\n/*   DDNAME INPUT and the output will go to the DDNAME OUTPUT so     */\n/*   that it can easily be run in batch mode.                        */\n/*                                                                   */\n/*===================================================================*/\n\n     /* Don't run the allocation code if we're in ISPF mode          */\nIF SYSVAR('SYSISPF') \u00ac= 'ACTIVE' THEN SIGNAL NOALLOC\n\n     /* Get the possible argument from the command line              */\nPARSE UPPER ARG INPUT                      /* Get input line         */\n     /* If none was supplied ask for one and get it interactively    */\nIF LENGTH(INPUT) < 1 THEN DO               /* If none, ask operator. */\n  SAY 'Enter name on INPUT file containing catalog listing.'\n  PARSE PULL INPUT\n  IF LENGTH(INPUT) < 1 THEN DO             /* Blank line terminates  */\n    SAY 'PROGRAM TERMINATED BY TERMINAL INPUT.'\n    EXIT 4\n    END\n  END\n\n     /* Parse the input file name from the received argument         */\nPARSE VAR INPUT NAME INPUT                 /* Get inputted file name */\nSAY 'INPUT file name found as' NAME'.'\n     /* Attempt to allocate the input file and die if not good       */\n\"ALLOC F(INPUT) DA(\"NAME\") SHR REU\"\nLASTCC = RC\nIF LASTCC \u00ac= 0 THEN DO\n  SAY 'UNABLE TO OPEN INPUT FILE, RETURN CODE WAS' LASTCC'.'\n  EXIT 4\n  END\n\n     /* If we're out of arguments, get the output file name          */\nIF LENGTH(INPUT) < 1 THEN DO\n  SAY 'Enter name of OUPUT file for IDCAMS control statements.'\n  PARSE PULL INPUT\n  IF LENGTH(INPUT) < 1 THEN DO             /* Blank line terminates  */\n    SAY 'PROGRAM TERMINATED BY TERMINAL INPUT.'\n    EXIT 4\n    END\n  END\n\n     /* Get the output file name from the received argument          */\nPARSE VAR INPUT NAME INPUT                 /* Get inputted file name */\nSAY 'OUTPUT file name found as' NAME'.'\n     /* Allocate the output file name and die if unable to do so     */\nIF INPUT \u00ac= '*' THEN DO\n  \"ALLOC F(OUTPUT) DA(\"NAME\") SHR REU\"\n  LASTCC = RC\n  IF LASTCC \u00ac= 0 THEN DO\n    SAY 'UNABLE TO OPEN OUTPUT FILE, RETURN CODE WAS' LASTCC'.'\n    EXIT 4\n    END\n  END\n\n     /* End up here if no allocations or after allocating in and out */\nNOALLOC:   ,\n\n     /* Define the cataloging to be to a 3390 pack and print start   */\nNV = '3390'\nSAY 'Starting processing of input file.  DEVT of new vol will be' NV'.'\n\n     /* Initialize variables and counts to avoid problems            */\nNAME = ''\nTYPE = ''\nLINEAR = ''\nREADCD = 0\nNREC = 0\nNONNUM = 0\nVNUM = 0\nOUTCOUNT = 0\nFNAME = ''\nCNAME = ''\nINAME = ''\nDNAME = ''\nVOLS = ''\n\n     /* Now process the entire input file                            */\nDO WHILE READCD = 0\n\n  'EXECIO 1 DISKR INPUT'                   /* Read another record    */\n  READCD = RC                              /* And remember RC        */\n  IF READCD \u00ac= 0 THEN LEAVE                /* Leave at end or problem*/\n  NREC = NREC + 1                          /* Count another record   */\n\n  PARSE PULL LINE                          /* Get input off stack    */\n  LINE = SUBSTR(LINE,2)                    /* Go beyond slew char    */\n  ONE = WORD(LINE,1)                       /* Check the first word   */\n     /* Mark linear files so they can be properly recataloged        */\n  IF POS('LINEAR',LINE) > 0 THEN LINEAR = 'LINEAR '\n     /* If this is for a NONVSAM file set up the variables           */\n  IF ONE = 'NONVSAM' THEN DO\n    IF LENGTH(CNAME) > 0 THEN CALL VSAMOUT\n    FNAME = WORD(LINE,3)\n    CNAME = ''\n    INAME = ''\n    DNAME = ''\n    VOLS = ''\n    END\n     /* If this is the VOLSER definition, go ahead and recatalog     */\n  ELSE IF LEFT(ONE,8) = 'VOLSER--' THEN DO\n    IF LENGTH(FNAME) > 0 THEN DO\n      VOL = RIGHT(WORD(LINE,1),6)\n     /* If output goes to teh terminal, send it there                */\n      IF NAME = '*' THEN DO\n        SAY 'DELETE' FNAME 'NSCR'\n        SAY 'DEFINE NVSAM (NAME('FNAME') VOL('VOL') DEVT('NV'))'\n        END\n     /* Or else go to the defined output file                        */\n      ELSE DO\n        L1 = ' DEFINE NVSAM (NAME('FNAME') VOL('VOL') DEVT('NV'))'\n     /* If we need 2 lines, set them up                              */\n        IF LENGTH(L1) > 68 THEN DO\n          NOUT = 3\n          PUSH '       VOL('VOL') DEVT('NV'))'\n          PUSH ' DEFINE NVSAM (NAME('FNAME') -'\n          END\n     /* Or else we can put the define on 1 line                      */\n        ELSE DO\n          PUSH L1\n          NOUT = 2\n          END\n     /* Now push the delete command itself                           */\n        PUSH ' DELETE' FNAME 'NSCR'\n     /* And write the commands to the file and check results         */\n        EXECIO NOUT DISKW OUTPUT\n        HOLDRC = RC\n        IF RC \u00ac= 0 THEN DO\n          SAY 'Return code from writing to output file was' HOLDRC'.'\n          EXIT 8\n          END\n     /* Reset the LINEAR variable for the next file if needed        */\n        LINEAR = ''\n        END\n     /* Count files and output records created and reset file name   */\n      NONNUM = NONNUM + 1\n      OUTCOUNT = OUTCOUNT + NOUT\n      FNAME = ''\n      END\n     /* If there is a cluster name, check for an associated volume   */\n    ELSE IF LENGTH(CNAME) > 0 THEN DO\n      VOL = RIGHT(WORD(LINE,1),6)\n      IF POS(VOL,VOLS) = 0 THEN VOLS = VOLS VOL\n      END\n    END\n     /* If this is a cluster defining line record the name           */\n  ELSE IF ONE = 'CLUSTER ' THEN DO\n    IF LENGTH(CNAME) > 0 THEN CALL VSAMOUT\n    IF LEFT(WORD(LINE,3),4) \u00ac= '0000' THEN CNAME = WORD(LINE,3)\n    SAY 'CLUSTER FOUND' CNAME\n    END\n     /* Record the association data if there was a cluster named     */\n  ELSE IF ( ONE = 'ASSOCIATIONS ' ) & ( LENGTH(CNAME) > 0 ) THEN DO\n    'EXECIO 1 DISKR INPUT'\n    HOLDRC = RC\n    IF HOLDRC \u00ac= 0 THEN DO\n      SAY 'Return code from DATA association read was' HOLDRC'.'\n      RETURN\n      END\n    PARSE PULL LINE\n    IF LEFT(WORD(LINE,1),9) = 'DATA-----' THEN DO\n      DNAME = SUBSTR(WORD(LINE,1),10)\n      'EXECIO 1 DISKR INPUT'\n      HOLDRC = RC\n      IF HOLDRC \u00ac= 0 THEN DO\n        SAY 'Return code from INDEX association read was' HOLDRC'.'\n        RETURN\n        END\n      PARSE PULL LINE\n      IF LEFT(WORD(LINE,1),9) = 'INDEX----' THEN ,\n                 INAME = SUBSTR(WORD(LINE,1),10)\n      END\n    END\n     /* After the end of the input file, we'e done for this run      */\n  END\n\n     /* If the last file was a VSAM file make sure we treat it       */\nIF LENGTH(CNAME) > 0 THEN CALL VSAMOUT\n\n     /* Now print out the counters in case anyone is interested      */\nSAY 'End of file after' NREC 'records.'\nSAY NONNUM 'non VSAM files were done in' OUTCOUNT 'records.'\nSAY VNUM 'VSAM files were found.'\n\n     /* At the end, close out the output file gracefully             */\n'EXECIO 0 DISKR INPUT ( FINIS'             /* At end, close file     */\nHOLDRC = RC\nIF HOLDRC = 0 THEN DO\n  SAY 'Input file successfully closed.'\n  END\nELSE DO\n  SAY 'CLOSE of input file failed with a return code of' HOLDRC'.'\n  END\n\n     /* Return to do something else                                  */\nRETURN\n\n/*       E N D   O F   M A I N   P R O G R A M                       */\n\n/*          S T A R T   O F   V S A M O U T   R O U T I N E          */\n\n/*============================ REXX =================================*/\n/*                                                                   */\n/*        This routine will catalog a VSAM file and with its data    */\n/*   and cluster components.  It was written as an add on to the     */\n/*   main program after all the other things in the main program     */\n/*   were working, and it handled all the files on the packs that    */\n/*   had to be converted, although nothing was ever done on the      */\n/*   order of an exhaustive test.  Should any problems arise, the    */\n/*   skeleton can probably be changed slightly to handle the case    */\n/*   but that should be noted here.                                  */\n/*                                                                   */\n/*===================================================================*/\n\n     /* Catalog a VSAM file with date and cluster if not linear      */\nVSAMOUT:   ,\n     /* Assume that SYS1.VVDS will have already been set up          */\n  IF LEFT(CNAME,10) = 'SYS1.VVDS.' THEN RETURN\n     /* Start with things set to zero                                */\n  DASH = ' '\n  NOUT = 0\n     /* Now make an output line for all existing options and count   */\n  IF LENGTH(INAME) > 0 THEN DO\n    L1 = '      INDEX(NAME('INAME'))'\n    DASH = '-'\n    PUSH L1\n/*  SAY L1                               */\n    NOUT = 1\n    END\n  IF LENGTH(DNAME) > 0 THEN DO\n    L1 = '      DATA(NAME('DNAME'))' DASH\n    PUSH L1\n    END\n/*SAY L1                                 */\n  NOUT = NOUT + 1\n  L1 = '      VOLUME('VOLS ') RECATALOG' LINEAR') -'\n/*SAY L1                                 */\n  PUSH L1\n  NOUT = NOUT + 1\n  L1 = ' DEFINE CLUSTER(NAME('CNAME') -'\n  PUSH L1\n/*SAY L1                                 */\n  NOUT = NOUT + 1\n     /* Put the DELETE NSCR first in the output queue                */\n  L1 = ' DELETE' CNAME 'NSCR'\n  PUSH L1\n/*SAY L1                                 */\n  NOUT = NOUT + 1\n     /* Now write all the lines to the output file and check return  */\n  'EXECIO' NOUT 'DISKW OUTPUT'\n  HOLDRC = RC\n  IF RC \u00ac= 0 THEN DO\n    SAY 'Return code from writing to output file was' HOLDRC'.'\n    EXIT 8\n    END\n\n     /* Increase all the necessary counts and reset the variables    */\n  VNUM = VNUM + 1\n  OUTCOUNT = OUTCOUNT + NOUT\n  CNAME = ''\n  INAME = ''\n  DNAME = ''\n  VOLS = ''\n  LINEAR = ''\n\n     /* Our work here is done and we can return                      */\n  RETURN\n\n/*         E N D   O F   V S A M O U T   S U B R O U T I N E         */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT625/FILE625.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT625", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}