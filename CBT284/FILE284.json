{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011643000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 823004, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE284.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE284.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0e\\x06'", "DS1TRBAL": "b'r\\x9e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xf7\\x00\\r\\x01\\xf8\\x00\\x0c\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"CMSCRIPT": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x02\\xd1\\x02\\xd1\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 721, "newlines": 721, "modlines": 0, "user": "CBT249"}, "text": "CMSCRIPT TITLE     'SCRIPT -- CMS WATERLOO SCRIPT INTERFACE'\n***********************************************************************\n*                                                                     *\n*        WATERLOO SCRIPT INTERFACE FOR CMS                            *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PRINT     NOGEN               OVERALL PRINT CONTROL\nCMSCRIPT CSECT\n         STM       R14,R12,12(R13)     SAVE INVOKER'S REGISTERS\n         LR        R12,R15             ENTRY ADDRESS\n         USING     CMSCRIPT,R12        AND TELL THE ASSEMBLER\n         LA        R2,CMSSAREA         MY SAVE AREA\n         ST        R2,8(,R13)          FORWARD CHAIN MINE\n         ST        R13,4(,R2)          BACKWARD CHAIN TO CALLER'S\n         LR        R13,R2              MY SAVE AREA POINTER\n         SPACE\n         LA        X2,8(,R1)           START OF PLIST TO CHECK\n         CLI       0(X2),FF            END OF THE LINE .Q\n         BE        ERROMIT             ERROR IF YES\n         CLI       0(X2),C'('          START OF PARMS .Q\n         BE        ERROMIT             ERROR IF YES\n         SPACE\n         LR        R1,X2               START OF OPERAND\n         LA        R2,1                INCREMENT VALUE\n         LA        R3,7(,X2)           END OF OPERAND\nNEXTQCHK DS        0H\n         CLI       0(R1),C'?'          A QUERY .Q\n         BE        EXPLAIN             BRANCH IF YES\n         BXLE      R1,R2,NEXTQCHK      LOOK AT ALL EIGHT\n         SPACE\n         MVC       PDDNAME+8(8),0(X2)  FOR OVERRIDING DDNAMES\n         MVC       WMODE(2),DWMODE     SET DEFAULT MODE\n         MVC       ISTATEN(8),0(X2)    SET INPUT FILE NAME\n         XC        ODE(2),ODE          CLEAR ODE SPECIFICATION\n         LA        R1,ISTATE           POINT TO STATE PLIST\n         SVC       SVC202              CAN WE FIND IT .Q\n         DC        AL4(NOINFILE)       ERROR EXIT\n         L         X1,AFSTCOPY         GET ADDR OF FIRST COPY\n         L         R1,FSTL(,X1)        GET A(ADT) FROM FSTCOPY\n         USING     ADTSECT,R1          TELL ASSEMBLER\n         TM        ADTFLG1,ADTFRW      IS ORIGIN OF SCRIPT FILE R/W .Q\n         BO        USEIT               YES, WRITE BACK TO IT\n         CLI       ADTMX,C' '          NO, IS IT AN EXTENSION .Q\n         BE        CONTINUE            NO, DEFAULT TO PRIMARY DISK\n         MVC       ADTPARM(1),ADTMX    YES\n         LA        R1,ADTLIST          CALL ADTLKW FOR PARENT DISK\n         USING     NUCON,R0            NEED NUCLEUS TEMPORARILY\n         L         R15,AADTLKW         GET ENTRY ADDRESS\n         DROP      R0                  FORGET R0\n         BALR      R14,R15             DO THE LINE\n         BP        CONTINUE            IF PARENT NOT R/W DEFAULT\nUSEIT    DS        0H\n         MVC       WMODE(1),ADTM       IF R/W, USE FOR NEW FILES\n         DROP      R1\nCONTINUE DS        0H\n         EJECT\n*        BUMP TO OPTIONS\n         SPACE\n         LA        X2,8(,X2)           NEXT ENTRY IN PLIST\n         SR        R0,R0               ZERO WORK REG\n         STH       R0,PSPACE           ZERO O/S PARM\n         MVI       OPTOUT1,OPTOTERM    TERMINAL OUTPUT BY DEFAULT\n         MVI       OPTOUT2,OPTONOFI    NOT TO A FILE BY DEFAULT\n         SPACE\n         XC        PRFODE,PRFODE       CLEAR ODE SPECIFICATION\n         LA        R1,PRFSTATE         POINT TO 'PROFILE' STATE\n         SVC       SVC202              CAN WE FIND IT .Q\n         DC        AL4(NOPROFIL)       BRANCH IF NOT\n         LA        X1,PROFILE          POINT TO PARM\n         LA        R1,L'PROFILE-1      LENGTH-1\n         BAL       R14,SETENT          AND ENTER SAME\n         SPACE\nNOPROFIL DS        0H\n         MVI       OPTSCRSW,OPTSCRNO   ASSUME 'NOSCREEN' OPTION\n         USING     NUCON,R0            NEED NUCLEUS AGAIN\n         L         R1,ADEVTAB          GET ADDR OF DEVICE TABLE\n         DROP      R0\n         USING     DEVTAB,R1           AND TELL THE ASSEMBLER\n         LH        R3,CONSOLE          GET VIRT CONSOLE DEV ADDR\n         DROP      R1\n         DIAG      R3,R2,X'24'         DIAGNOSE FOR CONSOLE CLASS\n         CLM       R3,B'1000',GRAFCON  DISPLAY TYPE TERMINAL .Q\n         BNE       OPTSCHK             BRANCH IF NOT\n         MVI       OPTSCRSW,OPTSCROK   SET 'SCREEN' OPTION\n         SPACE\nOPTSCHK  DS        0H\n         CLI       0(X2),FF            AT THE END .Q\n         BE        FDEFIT              YES, GO TO FILEDEFS\n         CLI       0(X2),C'('          LEFT PAREN .Q\n         BE        OPTS01              YES, GO TO OPTIONS\n         B         ERRMUCH             TOO MANY FILES\n         SPACE\nOPTS01   DS        0H\n         LA        X2,8(,X2)           PAST LEFT PARAM\n         CLI       0(X2),FF            AT THE END .Q\n         BE        FDEFIT              BRANCH IF YES\n         CLI       0(X2),C')'          SAME THING\n         BE        FDEFIT              BRANCH IF YES\n         SPACE\n         LA        R1,7(,X2)           END OF PLIST ENTRY\nOPTS02   DS        0H\n         CLI       0(R1),C' '          A BLANK .Q\n         BNE       OPTS03              BRANCH OUT IF NOT\n         BCT       R1,OPTS02           DECREMENT AND BRANCH\nOPTS03   DS        0H\n         LR        X1,X2               TEMP ENTRY POINTER\n         SR        R1,X1               LENGTH-1 OF ENTRY\n         BZ        OPTS06              IF ZERO, JUST SET IT\n         SPACE\n         LA        R2,OPTOUTS          OUTPUT OPTIONS\nOPTS04   DS        0H\n         CLI       0(R2),X'FF'         AT THE END .Q\n         BE        OPTS06              BRANCH IF YES\n         CH        R1,8(,R2)           TOO SHORT TO BE CONSIDERED .Q\n         BL        OPTS05              BRANCH IF YES\n         EX        R1,OPTSCLC          IS THIS IT .Q\n         BNE       OPTS05              BRANCH IF NOT\n         EX        R0,10(,R2)          DO AS OPTION WANTS\n         EX        R0,14(,R2)          AND AGAIN\n         B         OPTS01              GET NEXT PARM\nOPTS05   DS        0H\n         LA        R2,L'OPTOUTS(,R2)   NEXT CANDIDATE\n         B         OPTS04              GO TRY IT\nOPTSCLC  CLC       0(*-*,R2),0(X2)     COMPARE FOR OUTPUT OPTION\n         SPACE\nOPTS06   DS        0H\n         CLI       0(X2),C'+'          START WITH '+' .Q\n         BE        OPTKW               YES, THEN IT'S A REF VAR\n         CLI       0(X2),C'&&'         START WITH '&' .Q\n         BE        OPTKW               YES, THEN IT'S A REF VAR\n         CLI       8(X2),C'('          NEXT ENTRY A LEFT PAREN .Q\n         BNE       OPTS07              BRANCH IF NOT\n         CLC       =CL8'SYSVAR',0(X2)  IS IT 'SYSVAR' .Q\n         BE        OPTVAR              BRANCH IF YES\nOPTS07   DS        0H\n         BAL       R14,SETENT          ALL HAS FAILED\n         B         OPTS01              GET NEXT PARM\n         SPACE\nSETENT   DS        0H\n         LR        R3,R1               SAVE REGISTER ONE\n         EX        R1,NUMCHK           CHECK FOR NUMERICS\n         LR        R1,R3               RESTORE REGISTER ONE\n         BNZ       SETALPH             IF NOT, ENTER WITH BLANK\nSETKWOP  DS        0H\n         LA        R2,PSPACE+1         PARM FIELD-1\n         LH        R3,PSPACE           LENGTH SO FAR\n         AR        R2,R3               CURRENT PTR\n         CLI       0(R2),C'='          EQUAL SIGN\n         BE        SETNEQ              BRANCH IF YES\n         LA        R2,1(,R2)           BUMP CURRENT POINTER\n         MVI       0(R2),C'='          ADD EQUALS\n         LA        R3,1(,R3)           BUMP CURRENT LENGTH\nSETNEQ   DS        0H\n         EX        R1,SETMVC           ADD OPERAND\n         LA        R3,1(R3,R1)         NEW LENGTH\n         STH       R3,PSPACE           UPDATE LENGTH\n         BR        R14                 RETURN TO CALLER\nSETMVC   MVC       1(*-*,R2),0(X1)     EXECUTED ADD PARM STRING\nNUMCHK   TRT       0(*-*,X1),NUMTABLE  EXECUTED CHECK FOR NUMERICS\n         SPACE\nSETALPH  DS        0H\n         LA        R2,PSPACE+1         PARM FIELD-1\n         LH        R3,PSPACE           LENGTH SO FAR\n         LTR       R3,R3               FIRST OPERAND .Q\n         BZ        SETNEQ              BRANCH IF YES\n         LA        R2,0(R2,R3)         CURRENT END POINTER\n         CLI       0(R2),C'='          ENDS WITH '=' .Q\n         BE        SETNEQ              YES, SOMETHING FANCY\n         LA        R2,1(,R2)           NEXT POSITION\n         MVI       0(R2),C' '          ADD BLANK DELIMITER\n         LA        R3,1(,R3)           BUMP CURRENT LENGTH\n         B         SETNEQ              ADD PARM\n         SPACE\nSETADD   DS        0H\n         LA        R2,PSPACE+1         PARM FIELD -1\n         LH        R3,PSPACE           LENGTH OF PARM\n         AR        R2,R3               NEXT CHARACTER\n         B         SETNEQ              ENTER ASIS\n         SPACE\nOPTKW    DS        0H\n         BAL       R14,SETENT          ENTER REF VARIABLE NAME\n         CLI       8(X2),FF            END OF THE LINE .Q\n         BE        OPTS01              YES, FORGET ELSE\n         CLI       8(X2),C')'          END OF THE LINE .Q\n         BE        OPTS01              YES, SAME THING\n         LA        X2,8(,X2)           REF VAR OPERAND POINTER\n         LA        R1,7(,X2)           END OF PLIST ENTRY\nOPTKW01  DS        0H\n         CLI       0(R1),C' '          A BLANK .Q\n         BNE       OPTKW02             BRANCH IF NOT\n         BCT       R1,OPTKW01          DECREMENT AND BRANCH\nOPTKW02  DS        0H\n         LR        X1,X2               TEMP ENTRY POINTER\n         SR        R1,X1               LENGTH-1 OF ENTRY\n         BNZ       OPTKW03             BRANCH IF NOT ZERO\n         CLI       0(X2),C'?'          PROMPT FOR INPUT .Q\n         BNE       OPTKW03             BRANCH IF NOT\n         BAL       R14,OPTPROMP        GO PROMPT FOR INPUT\nOPTKW03  DS        0H\n         BAL       R14,SETKWOP         ENTER REF VAR OPERAND\n         B         OPTS01              AND CONTINUE\n         SPACE\nOPTVAR   DS        0H\n         LA        X2,8(,X2)           BUMP OVER FIRST\n         CLI       8(X2),FF            END OF LINE .Q\n         BE        OPTS01              BRANCH IF YES\n         LA        X2,8(,X2)           BUMP OVER NEXT\n         CLI       0(X2),C')'          END OF SYSVAR .Q\n         BE        OPTS01              BRANCH IF YES\n         CLI       8(X2),FF            A SECOND PART .Q\n         BE        ERRMIS              NO, MISMATCHED PAIR\n         CLI       8(X2),C')'          SECOND PART .Q\n         BE        ERRMIS              NO, MISMATCHED PAIR\n         LA        X1,PLSYSVAR         POINT TO '+SYSVAR'\n         LA        R1,L'PLSYSVAR-1     LENGTH-1 OF SAME\n         BAL       R14,SETENT          ENTER SAME\n         LA        R1,7(,X2)           END OF FIRST HALF\nOPTV01   DS        0H\n         CLI       0(R1),C' '          TRAILING BLANK .Q\n         BNE       OPTV02              BRANCH IF NOT\n         BCT       R1,OPTV01           DECREMENT AND CONTINUE\nOPTV02   DS        0H\n         LR        X1,X2               OPTION POINTER\n         SR        R1,X1               LENGTH-1 OF SYSVAR QUALIFIER\n         BAL       R14,SETADD          ADD SAME TO END OF '+SYSVAR'\n         LA        R1,15(,X2)          END OF OPERAND\nOPTV03   DS        0H\n         CLI       0(R1),C' '          TRAILING BLANK .Q\n         BNE       OPTV04              BRANCH IF NOT\n         BCT       R1,OPTV03           DECREMENT AND BRANCH\nOPTV04   DS        0H\n         LA        X1,8(,X2)           POINT TO OPERAND\n         SR        R1,X1               LENGTH-1 OF OPERAND\n         BNZ       OPTV05              BRANCH IF NOT ZERO\n         CLI       0(X1),C'?'          PROMPT FOR INPUT .Q\n         BNE       OPTV05              BRANCH IF NOT\n         BAL       R14,OPTPROMP        GO PROMPT FOR INPUT\nOPTV05   DS        0H\n         BAL       R14,SETKWOP         ENTER OPERAND\n         B         OPTVAR              CHECK FOR MORE\n         SPACE\nPLSYSVAR DC        C'+SYSVAR'          SYSTEM VARIABLE SYMBOL\n         SPACE\nOPTPROMP DS        0H\n         LA        X1,PSPACE+1         PARM FIELD -1\n         AH        X1,PSPACE           LAST CHARACTER POINTER\n         LR        R1,X1               REMEMBER THAT\nOPTPR01  DS        0H\n         CLI       0(X1),C'+'          START OF KEYWORD .Q\n         BE        OPTPR02             BRANCH IF YES\n         CLI       0(X1),C'&&'         START OF KEYWORD .Q\n         BE        OPTPR02             BRANCH IF YES\n         BCT       X1,OPTPR01          DECREMENT AND TRY AGAIN\nOPTPR02  DS        0H\n         SR        R1,X1               LENGTH-1 OF ARGUMENT\n         EX        R1,OPTPRMVC         MOVE KEYWORD TO PROMPT\n         LA        R1,L'PROMPT+1(,R1)  TOTAL LENGTH SO FAR\n         LA        X1,PROMPT(R1)       POINT TO END\n         MVI       0(X1),C':'          ADD A COLON\n         LA        X1,1(,R1)           TOTAL WRITE LENGTH\n         WRTERM    PROMPT,(X1),EDIT=NO DISPLAY REQUEST TO USER\n         SPACE\n         LA        X1,PROMPT+L'PROMPT  READ AREA\n         RDTERM    (X1),EDIT=NO        GET USER'S REPLY\n         LTR       R1,R0               WAS IT NULL .Q\n         BNZ       OPTPR03             BRANCH IF NOT\n         LA        X1,PROMPT           POINT TO A BLANK\n         LA        R1,1                LENGTH OF ONE\nOPTPR03  DS        0H\n         BCTR      R1,0                LENGTH-1 OF STRING\n         BR        R14                 RETURN TO CALLER\nOPTPRMVC MVC       PROMPT+L'PROMPT(*-*),0(X1)  ENTER PROMPT ARGUMENT\n         EJECT\n*        OUTPUT OPTIONS AND FILEDEFS\n         SPACE\nFDEFIT   DS        0H\n         CLI       OPTSCRSW,OPTSCRNO   'NOSCREEN' OPTION REQUIRED .Q\n         BE        FDEFIT01            BRANCH IF YES\n         LA        X1,SCREEN           POINT TO OPTION\n         LA        R1,L'SCREEN-1       LENGTH-1\n         BAL       R14,SETENT          ENTER OPTION\n         SPACE\nFDEFIT01 DS        0H\n         LA        X1,FDEFTERM         TERMINAL OUTPUT\n         LA        R1,L'FDEFTERM-1     LENGTH-1\n         CLI       OPTOUT1,OPTOTERM    IS IT TERMINAL .Q\n         BE        FDEFIT02            BRANCH IF YES\n         LA        X1,FDEFPRNT         PRINTER OUTPUT\n         LA        R1,L'FDEFPRNT-1     LENGTH-1\nFDEFIT02 DS        0H\n         BAL       R14,SETENT          ENTER OPTION\n         SPACE\n         LA        X1,FDEFFILE         FILE OUTPUT\n         LA        R1,L'FDEFFILE-1     LENGTH-1\n         CLI       OPTOUT2,OPTOFILE    IS IT FILE .Q\n         BE        FDEFIT03            BRANCH IF YES\n         LA        X1,FDEFNOFI         NOFILE OUTPUT\n         LA        R1,L'FDEFNOFI-1     LENGTH-1\nFDEFIT03 DS        0H\n         BAL       R14,SETENT          ENTER OPTION\n         SPACE\n         SR        R1,R1               CLEAR WORK REG\n         IC        R1,OPTOUT1          GET OUTPUT TYPE\n         SR        R15,R15             CLEAR WORK REG\n         IC        R15,OPTOUT2         TER FILE TYPE\n         OR        R15,R1              COMBINE THE TWO\n         SLL       R15,2               TIMES FOUR\n         B         *+4(R15)            INDEX BRANCH ACCORDINGLY\n         B         FDEFTE                   TERMINAL\n         B         FDEFME                   MEMO\n         B         FDEFPR                   PRINTER\n         B         FDEFDI                   DISK\n         B         FDEFDU                   DUMMY\n         B         FDEFDU                   DUMMY\n         SPACE\nFDEFTERM DC        C'TERM'             TERMINAL OUTPUT\nFDEFPRNT DC        C'PRINT'            PRINTER OUTPUT\nFDEFFILE DC        C'FILE'             FILE OUTPUT\nFDEFNOFI DC        C'NOFILE'           NOFILE OUTPUT\n         SPACE\nFDEFPR   DS        0H\n         LA        R1,OUTPUTP          OUTPUT TO PRINTER\nFDEFSVC  DS        0H\n         SVC       SVC202              DO IT\n         DC        AL4(*+4)            IGNORE ERRORS\n         B         FDEFSYP             GO TO SYSTERM\n         SPACE\nFDEFDI   DS        0H\n         MVC       IERASEN(8),ISTATEN  FILE NAME\n         MVC       IERASET(8),OUTDTYP  FILE TYPE\n         MVC       IERASEM(2),WMODE    FILE MODE\n         LA        R1,IERASE           POINT TO ERASE PLIST\n         SVC       SVC202              ERASE LISTING FILE\n         DC        AL4(*+4)            IF ANY\n         LA        R1,OUTPUTD          OUTPUT TO DISK\n         MVC       OUTDNAM(8),ISTATEN  FILE NAME\n         MVC       OUTDMOD(2),WMODE    FILE MODE\n         B         FDEFSVC             GO AND DO IT\n         SPACE\nFDEFTE   DS        0H\n         LA        R1,OUTPUTT          OUTPUT TO TERMINAL\n         B         FDEFSVC             GO AND DO IT\n         SPACE\nFDEFDU   DS        0H\n         LA        R1,OUTPUTX          OUTPUT DUMMY\n         B         FDEFSVC             GO AND DO IT\n         SPACE\nFDEFME   DS        0H\n         MVC       IERASEN(8),ISTATEN  FILE NAME\n         MVC       IERASET(8),OUTMTYP  FILE TYPE\n         MVC       IERASEM(2),WMODE    FILE MODE\n         LA        R1,IERASE           POINT TO ERASE PLIST\n         SVC       SVC202              ERASE 'MEMO' FILE\n         DC        AL4(*+4)            IF ANY\n         LA        R1,OUTPUTM          OUTPUT TO DISK\n         MVC       OUTMNAM(8),ISTATEN  FILE NAME\n         MVC       OUTMMOD(2),WMODE    FILE MODE\n         B         FDEFSVC             GO AND DO IT\n         SPACE\nFDEFSYP  DS        0H\n         LA        R1,SYSTERM          ERROR FILE\n         SVC       SVC202              FILEDEF THAT\n         DC        AL4(*+4)            IGNORE ERRORS\n         SPACE\n         LA        R1,SYSCONS          INPUT TERMINAL FILE\n         SVC       SVC202              FILEDEF THAT\n         DC        AL4(*+4)            IGNORE ERRORS\n         SPACE\n         MVC       SYSUSRFM(2),WMODE   WORK FILE MODE\n         LA        R2,9                MAX NUMBER OF USER FILES\n         SR        R3,R3               START AT THE BEGINNING\nFDEFUSR  DS        0H\n         CVD       R3,DWORD            CONVERT TO DECIMAL\n         OI        DWORD+7,X'0F'       FIX THE SIGN\n         UNPK      SYSUSRDD+6(2),DWORD+6(2) ENTER FILE NUMBER\n         UNPK      SYSUSRFN+6(2),DWORD+6(2) AND AGAIN\n         LA        R1,SYSUSR           POINT TO FILEDEF\n         SVC       SVC202              AND DEFINE IT\n         DC        AL4(*+4)            IGNORE ERRORS\n         LA        R3,1(,R3)           BUMP FILE NUMBER\n         CR        R3,R2               DONE THEM ALL .Q\n         BNH       FDEFUSR             BRANCH IF NOT\n         SPACE\n         CLI       OPTSCRSW,OPTSCRNO   'NOSCREEN' OPTION REQUIRED .Q\n         BE        FDEFNSCR            BRANCH IF YES\n         LA        R1,CLEARSCR         TO CLEAR A SCREEN\n         SVC       SVC202              DO IT\n         DC        AL4(*+4)            IGNORE AN ERROR\n         SPACE\nFDEFNSCR DS        0H\n         STRINIT   ,                   INITIALIZE FREE STORAGE\n         LA        R1,PARMLIST         POINT TO PARM ADDRESSES\n         L         R15,VSCRIPT         GET SCRIPT ENTRY ADDRESS\n         BALR      R14,R15             GO DO IT IF YOU CAN\n         SPACE\nCMSRET   DS        0H\n         LR        R2,R15              SAVE RETURN CODE\n         LA        R1,FINIS            TO TERMINATE\n         SVC       SVC202              DO IT\n         DC        AL4(*+4)            IGNORE ERRORS\n         LA        R1,CLEARALL         CLEAR ALL MY FILEDEFS\n         SVC       SVC202              DO IT\n         DC        AL4(*+4)            IGNORING ALL ERRORS\n         LR        R15,R2              RESTORE RETURN CODE\n         L         R13,4(,R13)         RESTORE CALLER'S SAVE POINTER\n         L         R14,12(,R13)        RESTORE RETURN REGISTER\n         LM        R0,R12,20(R13)      RESTORE THE REST\n         BR        R14                 GO BACK\n         EJECT\n*        ERROR MESSAGES\n         SPACE\n         PRINT     NOGEN\nERROMIT  DS        0H\n         WRTERM    'OMITTED FILENAME'\n         LA        R15,20              RETURN CODE\n         B         CMSRET              AND QUIT\n         SPACE\nERRMUCH  DS        0H\n         WRTERM    'INVALID PARM SPECIFICATION'\n         LA        R15,20              RETURN CODE\n         B         CMSRET              AND QUIT\n         SPACE\nERRMIS   DS        0H\n         WRTERM    'ODD NUMBER OF SYSVAR ARGUMENTS'\n         LA        R15,20              RETURN CODE\n         B         CMSRET              AND QUIT\n         SPACE\nNOINFILE DS        0H\n         LA        R2,NOINMSG          MESSAGE AREA\n         MVC       NOINMSGN(8),ISTATEN      FILE NAME\n         MVC       NOINMSGN+9(8),ISTATEN+8  FILE TYPE\n         LA        R3,NOINMSGE-NOINMSG ERROR MESSAGE LENGTH\n         WRTERM    (R2),(R3)           DO IT\n         LA        R15,20              RETURN CODE\n         B         CMSRET              AND QUIT\n         SPACE\n*        USER QUERY\n         SPACE\nEXPLAIN  DS        0H\n         LA        R1,TYPEMEMO         POINT TO EXPLAIN PLIST\n         SVC       SVC202              DO IT\n         DC        AL4(*+4)            IGNORE ERRORS\n         SR        R15,R15             SET RETURN CODE\n         B         CMSRET              RETURN TO CALLER\n         EJECT\n*        DATA AND WORK AREA\n         SPACE\nCMSSAREA DC        18F'0'              O/S SAVE AREA\nDWORD    DC        D'0'                DOUBLE WORD WORK AREA\nPARMLIST DC        A(PSPACE)           PARM OPTIONS ADDRESS\n         DC        A(PDDOVER)          OVERRIDING DDNAMES ADDRESS\n         DC        X'80',AL3(SCRIPTTR) ROUTINE TRAP ADDRESSES\n         SPACE\nPSPACE   DC        H'0',CL256' '       O/S PARM AREA\nPDDOVER  DC        AL2((PDDEND-*-2)/16)  OVERRIDE COUNT\nPDDNAME  DC        CL8'SYSIN',CL8'*'     OVERRIDE NAMES\nPDDEND   EQU       *\n         SPACE\nOPTOUT1  DC        X'00'               OUTPUT OPTION ONE\nOPTOTERM EQU       X'00'*2                  TERMINAL OUTPUT\nOPTOPRNT EQU       X'01'*2                  PRINTER OUTPUT\nOPTODUMY EQU       X'02'*2                  DUMMY OUTPUT\nOPTOUT2  DC        X'00'               OUTPUT OPTION TWO\nOPTONOFI EQU       X'00'                    OUTPUT NOT TO A FILE\nOPTOFILE EQU       X'01'                    OUTPUT TO A FILE\n         SPACE\nSVC202   EQU       202                 CMS SVC\n         SPACE\nNOINMSG  DC        C'FILE '''\nNOINMSGN DC        CL17' '\n         DC        C''' NOT FOUND'\nNOINMSGE EQU       *\n         SPACE\nSCREEN   DC        C'SCREEN'           SCREEN PARM FOR CRTS\nGRAFCON  DC        X'40'               GRAPHICS DEVICE\nOPTSCRSW DC        X'00'               SCREEN OPTION SWITCH\nOPTSCRNO EQU       X'00'                    'NOSCREEN' OPTION\nOPTSCROK EQU       X'01'                    'SCREEN' OPTION\n         SPACE\nPROFILE  DC        C'PROFILE'          AUTO PROFILE OPTION\n         SPACE\n         DS        0H                  ALIGN POSSIBLE OPTIONS\nOPTOUTS  DS        0CL18               OUTPUT OPTIONS\n         DC        CL8'TERMINAL',AL2(1)\n         MVI       OPTOUT1,OPTOTERM         TERMINAL OUTPUT\n         MVI       OPTOUT2,OPTONOFI         AND NOT TO A FILE\n         DC        CL8'ONLINE  ',AL2(1)\n         MVI       OPTOUT1,OPTOTERM         TERMINAL OUTPUT\n         OI        OPTOUT2,X'00'            TO FILE OR NOT\n         DC        CL8'MEMO    ',AL2(3)\n         MVI       OPTOUT1,OPTOTERM         TERMINAL OUTPUT\n         MVI       OPTOUT2,OPTOFILE         AND TO A FILE\n         DC        CL8'PRINTER ',AL2(1)\n         MVI       OPTOUT1,OPTOPRNT         PRINTER OUTPUT\n         MVI       OPTOUT2,OPTONOFI         AND NOT TO A FILE\n         DC        CL8'PRT     ',AL2(1)\n         MVI       OPTOUT1,OPTOPRNT         PRINTER OUTPUT\n         MVI       OPTOUT2,OPTONOFI         AND NOT TO A FILE\n         DC        CL8'OFFLINE ',AL2(1)\n         MVI       OPTOUT1,OPTOPRNT         PRINTER OUTPUT\n         OI        OPTOUT2,X'00'            AND TO A FILE OR NOT\n         DC        CL8'DISK    ',AL2(1)\n         MVI       OPTOUT1,OPTOPRNT         PRINTER OUTPUT\n         MVI       OPTOUT2,OPTOFILE         AND TO A FILE\n         DC        CL8'NOPRINT ',AL2(3)\n         MVI       OPTOUT1,OPTODUMY         NO OUTPUT\n         MVI       OPTOUT2,OPTONOFI         AND NOT TO A FILE\n         DC        CL8'NOPRT   ',AL2(3)\n         MVI       OPTOUT1,OPTODUMY         NO OUTPUT\n         MVI       OPTOUT2,OPTONOFI         AND NOT TO A FILE\n         DC        CL8'FILE    ',AL2(1)\n         OI        OPTOUT1,X'00'            OUTPUT TARGET UNCHANGED\n         MVI       OPTOUT2,OPTOFILE         AND TO A FILE\n         DC        CL8'NOFILE  ',AL2(3)\n         OI        OPTOUT1,X'00'            OUTPUT TARGET UNCHANGED\n         MVI       OPTOUT2,OPTOFILE         AND TO A FILE\n         SPACE\n         DC        CL8'SCREEN  ',AL2(3)\n         MVI       OPTSCRSW,OPTSCROK        SET 'SCREEN' OPTION\n         OI        OPTSCRSW,X'00'           AND THAT'S ALL\n         DC        CL8'NOSCREEN',AL2(5)\n         MVI       OPTSCRSW,OPTSCRNO        SET 'NOSCREEN' OPTION\n         OI        OPTSCRSW,X'00'           AND THAT'S ALL\n         DC        8X'FF'\n         SPACE\nTYPEMEMO DC        0D'0',CL8'TYPE'\n         DC        CL8'SCRIPT'\n         DC        CL8'MEMO'\n         DC        CL8'Y'\n         DC        8X'FF'\n         SPACE\nISTATE   DC        0D'0',CL8'STATE'\nISTATEN  DC        CL8'*'\n         DC        CL8'SCRIPT'\nODE      DC        CL2'00'\n         DC        CL2'00'\nAFSTCOPY DC        A(*-*)              ADDR OF FST COPY LOCATION\n         SPACE\nPRFSTATE DC        0D'0',CL8'STATE'\n         DC        CL8'PROFILE'\n         DC        CL8'SCRIPT'\nPRFODE   DC        CL2'00'\n         DC        CL2'00'\nPRFFST   DC        A(*-*)\n         SPACE\nADTLIST  DC        0D'0',CL24' '\nADTPARM  DC        CL2'  '             CODE FOR ADTLKW CALLS\n         SPACE\nIERASE   DC        0D'0',CL8'ERASE'\nIERASEN  DC        CL8'*'              ERASE FILE NAME\nIERASET  DC        CL8'*'              ERASE FILE TYPE\nIERASEM  DC        CL8'**'             ERASE FILE MODE\n         DC        8X'FF'\n         SPACE\nFINIS    DC        0D'0',CL8'FINIS'\n         DC        3CL8'*'\n         DC        8X'FF'\n         SPACE\nCLEARALL DC        0D'0',CL8'FILEDEF'\n         DC        CL8'*'\nCLEARSCR DC        CL8'CLEAR'\n         DC        8X'FF'\n         SPACE\nPROMPT   DC        C' ENTER ',CL130' ' DISPLAY AND READ\n         SPACE\nWMODE    DC        C'**'               SOME FILE MODE\nDWMODE   DC        C'A1'               DEFAULT FILE MODE\n         SPACE\nNUMTABLE DC        256X'FF'\n         ORG       NUMTABLE+C'('\n         DC        X'00'               LEFT PAREN\n         ORG       NUMTABLE+C')'\n         DC        X'00'               RIGHT PAREN\n         ORG       NUMTABLE+C':'\n         DC        X'00'               COLON\n         ORG       NUMTABLE+C'K'\n         DC        X'00'               'K' FOR 1024\n         ORG       NUMTABLE+C'0'\n         DC        10X'00'             NUMBERS ZERO TO NINE\n         ORG\n         SPACE\nOUTPUTT  DC        0D'0',CL8'FILEDEF'\n         DC        CL8'SYSPRINT'\n         DC        CL8'TERMINAL'\n         DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'VA'\n         DC        CL8'BLOCK'\n         DC        CL8'240'\n         DC        CL8'LRECL'\n         DC        CL8'236'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nOUTPUTP  DC        0D'0',CL8'FILEDEF'\n         DC        CL8'SYSPRINT'\n         DC        CL8'PRINTER'\n         DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'VA'\n         DC        CL8'BLOCK'\n         DC        CL8'141'\n         DC        CL8'LRECL'\n         DC        CL8'137'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nOUTPUTD  DC        0D'0',CL8'FILEDEF'\n         DC        CL8'SYSPRINT'\n         DC        CL8'DISK'\nOUTDNAM  DC        CL8'*'\nOUTDTYP  DC        CL8'LISTING'\nOUTDMOD  DC        CL8'*'\n         DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'VA'\n         DC        CL8'BLOCK'\n         DC        CL8'141'\n         DC        CL8'LRECL'\n         DC        CL8'137'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nOUTPUTM  DC        0D'0',CL8'FILEDEF'\n         DC        CL8'SYSPRINT'\n         DC        CL8'DISK'\nOUTMNAM  DC        CL8'*'\nOUTMTYP  DC        CL8'MEMO'\nOUTMMOD  DC        CL8'*'\n         DC        CL8'('\n         DC        CL8'RECFM',CL8'V'\n         DC        CL8'BLOCK',CL8'141'\n         DC        CL8'LRECL',CL8'137'\n         DC        CL8'NOCHANGE',8X'FF'\n         SPACE\nOUTPUTX  DC        0D'0',CL8'FILEDEF'\n         DC        CL8'SYSPRINT',CL8'DUMMY'\n         DC        CL8'('\n         DC        CL8'RECFM',CL8'VA'\n         DC        CL8'BLOCK',CL8'141'\n         DC        CL8'LRECL',CL8'137'\n         DC        CL8'NOCHANGE',8X'FF'\n         SPACE\nSYSTERM  DC        0D'0',CL8'FILEDEF'\n         DC        CL8'SYSTERM'\n         DC        CL8'TERMINAL'\n         DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'VA'\n         DC        CL8'LRECL'\n         DC        CL8'137'\n         DC        CL8'BLOCK'\n         DC        CL8'141'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nSYSCONS  DC        0D'0',CL8'FILEDEF'\n         DC        CL8'SYSCONS'\n         DC        CL8'TERMINAL'\n         DC        CL8'('\n         DC        CL8'RECFM'\n         DC        CL8'V'\n         DC        CL8'LRECL'\n         DC        CL8'137'\n         DC        CL8'BLOCK'\n         DC        CL8'141'\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\nSYSUSR   DC        0D'0',CL8'FILEDEF'\nSYSUSRDD DC        CL8'SYSUSR**'\n         DC        CL8'DISK'\nSYSUSRFN DC        CL8'SYSUSR**'\n         DC        CL8'SCRIPT'\nSYSUSRFM DC        CL8'**'\n         DC        CL8'('\n         DC        CL8'NOCHANGE'\n         DC        8X'FF'\n         SPACE\n         DROP      ,                   FORGET ALL BASES\n         LTORG\n         EJECT\n*        TABLE OF VCONS TO DRIVE CMS LOADER\n         SPACE\nVSCRIPT  DC        V(SCRIPTW)          MAIN SCRIPT ROUTINE AND ENTRY\n         DC        V(SCRIPTFO)         FORMATTING AND LINKING ROUTINES\n         DC        V(SCRIPTOU)         SUBROUTINE FUNCTIONS\n         DC        V(SCRIPTCW)         CONTROL WORD PROCESSING\n         DC        V(SCRIPTRD)         READER ROUTINES\n         DC        V(SCRIPTHY)         HYPHENATION ROUTINES\n         DC        V(SCRIPTMC)         INCORE FORMATTING ROUTINES\n         DC        V(SCRIPTPM)         PARM SCANNER\n         DC        V(SCRIPTSY)         SYSTEM INTERFACE INTERFACE\n         DC        V(SYSINT)           SYSTEM INTERFACE\n         SPACE\n         ORG       CMSCRIPT+4096-8\n         SPACE\n         ADT\n         DEVTAB\n         FSTB\n         NUCON\n         EJECT\n        $SCRCVT    DSECT=YES,DOC=NOGEN\n         SPACE 2\n        $NSCDAT    DSECT=YES,DOC=NOGEN\n         SPACE 2\n         COPY      #DSECTS\nR2       EQU       COUNT               CMSCRIPT EQUIVALENT\nR3       EQU       TEMP                CMSCRIPT EQUIVALENT\nR12      EQU       BASE                CMSCRIPT EQUIVALENT\n         EJECT\nSCRIPTTR $VERSION ,                    IDENTIFY AND INITIALIZE\n         EJECT\n*        ENTER TEST ROUTINES HERE\n************************\n         SPACE\nSCRIPTTR CSECT     ,\n         DC        X'80',AL3(0)        MARK END OF THE LIST\n         SPACE\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NSCATS": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x02?\\x02?\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 575, "newlines": 575, "modlines": 0, "user": "CBT249"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "SCRIPTCW": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x00\\xda\\x00\\xda\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 218, "newlines": 218, "modlines": 0, "user": "CBT249"}, "text": "         COPY  $COPYWRT\nCWSCRIPT TITLE '         SCRIPT -- CONTROL WORD PROCESSING'\n        $SCRCVT DSECT=YES,DOC=NOGEN\n         SPACE\n        $NSCDAT DSECT=YES,DOC=NOGEN\n         SPACE 2\n         COPY  #DSECTS\n         EJECT\n***********************************************************************\n*                                                                     *\n*              CONTROL WORD PROCESSORS --- SCRIPTCW                   *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PRINT NOGEN               OVERALL PRINT CONTROL\nSCRIPTCW $VERSION ,\n         EJECT\n         COPY  #AB\n         EJECT\n         COPY  #AD\n         EJECT\n         COPY  #AP\n         EJECT\n         COPY  #AR\n         EJECT\n         COPY  #BM\n         EJECT\n         COPY  #BR\n         EJECT\n         COPY  #BS\n         EJECT\n         COPY  #BX\n         EJECT\n         COPY  #CE\n         EJECT\n         COPY  #CM\n         EJECT\n         COPY  #CO\n         EJECT\n         COPY  #CR\n         EJECT\n         COPY  #CS\n         EJECT\n         COPY  #CW\n         EJECT\n         COPY  #DA\n         EJECT\n         COPY  #DC\n         EJECT\n         COPY  #DO\n         EJECT\n         COPY  #DS\n         EJECT\n         COPY  #EF\n         EJECT\n         COPY  #EL\n         EJECT\n         COPY  #EM\n         EJECT\n         COPY  #EN\n         EJECT\n         COPY  #ER\n         EJECT\n         COPY  #FD\n         EJECT\n         COPY  #FE\n         EJECT\n         COPY  #FM\n         EJECT\n         COPY  #FO\n         EJECT\n         COPY  #FS\n         EJECT\n         COPY  #FV\n         EJECT\n         COPY  #GO\n         EJECT\n         COPY  #HD\n         EJECT\n         COPY  #HE\n         EJECT\n         COPY  #HI\n         EJECT\n         COPY  #HM\n         EJECT\n         COPY  #HS\n         EJECT\n         COPY  #HV\n         EJECT\n         COPY  #HW\n         EJECT\n         COPY  #IF\n         EJECT\n         COPY  #IL\n         EJECT\n         COPY  #IM\n         EJECT\n         COPY  #IN\n         EJECT\n         COPY  #JU\n         EJECT\n         COPY  #LA\n         EJECT\n         COPY  #LB\n         EJECT\n         COPY  #LE\n         EJECT\n         COPY  #LI\n         EJECT\n         COPY  #LL\n         EJECT\n         COPY  #LN\n         EJECT\n         COPY  #LS\n         EJECT\n         COPY  #NC\n         EJECT\n         COPY  #NF\n         EJECT\n         COPY  #NJ\n         EJECT\n         COPY  #NL\n         EJECT\n         COPY  #OC\n         EJECT\n         COPY  #OF\n         EJECT\n         COPY  #OJ\n         EJECT\n         COPY  #OO\n         EJECT\n         COPY  #OV\n         EJECT\n         COPY  #PA\n         EJECT\n         COPY  #PD\n         EJECT\n         COPY  #PE\n         EJECT\n         COPY  #PI\n         EJECT\n         COPY  #PL\n         EJECT\n         COPY  #PN\n         EJECT\n         COPY  #PP\n         EJECT\n         COPY  #PR\n         EJECT\n         COPY  #PS\n         EJECT\n         COPY  #PU\n         EJECT\n         COPY  #PV\n         EJECT\n         COPY  #QQ\n         EJECT\n         COPY  #QT\n         EJECT\n         COPY  #RA\n         EJECT\n         COPY  #RC\n         EJECT\n         COPY  #RD\n         EJECT\n         COPY  #RE\n         EJECT\n         COPY  #RO\n         EJECT\n         COPY  #RV\n         EJECT\n         COPY  #SA\n         EJECT\n         COPY  #SE\n         EJECT\n         COPY  #SI\n         EJECT\n         COPY  #SK\n         EJECT\n         COPY  #SP\n         EJECT\n         COPY  #SR\n         EJECT\n         COPY  #SS\n         EJECT\n         COPY  #SU\n         EJECT\n         COPY  #SY\n         EJECT\n         COPY  #TB\n         EJECT\n         COPY  #TE\n         EJECT\n         COPY  #TH\n         EJECT\n         COPY  #TI\n         EJECT\n         COPY  #TM\n         EJECT\n         COPY  #TR\n         EJECT\n         COPY  #UC\n         EJECT\n         COPY  #UD\n         EJECT\n         COPY  #UL\n         EJECT\n         COPY  #UN\n         EJECT\n         COPY  #UP\n         EJECT\n         COPY  #UR\n         EJECT\n         COPY  #US\n         EJECT\n         COPY  #WD\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRIPTFO": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x00\\xc6\\x00\\xc6\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 198, "newlines": 198, "modlines": 0, "user": "CBT249"}, "text": "FOSCRIPT TITLE '     MERGE, TRUNCATE, AND FORMAT ''SCRIPT'' OUTPUT'\n***********************************************************************\n*                                                                     *\n*              PARAMETER LIST                                         *\n*                                                                     *\n***********************************************************************\n         SPACE\nLKPMLIST DSECT\n         SPACE\nPMCHLOC  DS    A                   LOCATION OF CHARACTER STRING\nPMCHLNG  DS    F                   LENGTH OF CHARACTER STRING\nPMELFIR  DS    A                   LOCATION OF FIRST LINK ELEMENT\nPMELLST  DS    A                   LOCATION OF LAST LINK ELEMENT\nPMELLNG  DS    F                   LENGTH OF PRIMARY LINE\n         SPACE\nFOPMLIST DSECT\n         DS    F                   (SKIP OVER)\nFONOCHAR DS    F                   LENGTH OF STRING\nFOPFIRST DS    A                   LOC. OF FIRST LINK\nFOPLAST  DS    A                   LOC. OF LAST LINK\nFOPCOUNT DS    F                   NUMBER OF LINK BLOCKS\nFOIWSPC  DS    F                   INTER-WORD SPACES\n         DS    2F                  (SKIP OVER)\nNEWFIRST DS    A                   LOC. OF FIRST LINK\nNEWLAST  DS    A                   LOC. OF LAST LINK\nNEWCOUNT DS    F                   NUMBER OF LINK BLOCKS\nFOLL     DS    F                   LINE LENGTH PARAMETER\nFOPTAB   DS    A                   LOCATION OF TAB TABLE\nFOIND    DS    H                   INDENTATION FACTOR\nFOFUNCNT DS    H                   OFFSET/UNDENT MARGIN COUNT\nFOINDR   DS    H                   RIGHT INDENT VALUE\nFOJUVAL  DS    AL1                 JUSTIFY OPTION\nFOFOVAL  DS    AL1                 FORMAT OPTION  ***RESERVED***\n         DS    F                   *    UNUSED\n         DS    F                   *    UNUSED\n         SPACE\nFOSWTCH  DS    XL10                SWITCHES\n        $SCRCVT DSECT=YES,DOC=NOGEN\n         SPACE 2\n        $NSCDAT DSECT=YES,DOC=NOGEN\n         EJECT\n         COPY  #DSECTS\n         EJECT\n***********************************************************************\n*                                                                     *\n*              ROUTINES TO MERGE, TRUNCATE, AND FORMAT OUTPUT         *\n*                                                                     *\n*                             S.E. MADNICK                            *\n*                             SEPTEMBER 1, 1968                       *\n*                                                                     *\n*        THESE ROUTINES OPERATE UPON THE TOPOLOGICAL DATA STRUCTURE   *\n*        TO MERGE, TRUNCATE, AND FORMAT THE OUTPUT LINE AS DESCRIBED  *\n*        IN IBM CAMBRIDGE SCIENTIFIC CENTER REPORT 320-2023, \"SCRIPT: *\n*        AN ONLINE MANUSCRIPT PROCESSING SYSTEM\"                      *\n*                                                                     *\n*        MODIFIED BY WC ONEY, MARCH 17, 1970                          *\n*        CORRECT LOGIC FLAW WHICH ALLOWS NON-BLANK FILLING OF LINE    *\n*        OUT TO INDENT COLUMN WHEN PREVIOUS LINE WAS TOO LONG         *\n*        AND CONTAINED ONLY ONE OR TWO WORDS                          *\n*                                                                     *\n*        MODIFIED MARCH 20, 1974                                      *\n*      - INSERT DOUBLE BLANK AFTER A FULL STOP AT THE END             *\n*        OF ONE TEXT LINE FOLLOWED WITHOUT BREAK BY ANOTHER           *\n*      - TAB FILL CHARACTER SUPPORT                                   *\n*      - OFFSET/UNDENT SPACE INVIOLATE FOR BLANK INSERT               *\n*                                                                     *\n*        MODIFIED FEBRUARY 1976                                       *\n*      - TO INCORPORATE USER HYPHENATION MODIFICATIONS FROM           *\n*        NEIL H. MURPHY FROM STANDARD OIL CO. OF CONCORD CALIF.       *\n***********************************************************************\n         SPACE\n         PRINT NOGEN               OVERALL PRINT CONTROL\n         SPACE\nSCRIPTFO $VERSION ,                ROUTINE INITIALIZE\n         EJECT\n         COPY  #MERGE\n         EJECT\n         COPY  #FOADD\n         EJECT\n         COPY  #FOHYPH\n         EJECT\n         COPY  #TABIT\n         EJECT\n         COPY  #TABITA\n         EJECT\n         COPY  #TABITC\n         EJECT\n         COPY  #TABITL\n         EJECT\n         COPY  #TABITR\n         EJECT\n         COPY  #TABCHK\n         EJECT\n         COPY  #TABPCC\n         EJECT\n         COPY  #TABFILL\n         EJECT\n         COPY  #ADJUST\n         EJECT\n         COPY  #PUNCADJ\n         EJECT\n         COPY  #CENTER\n         EJECT\n         COPY  #RIGHTAD\n         TITLE '     PUT ''SCRIPT'' INPUT INTO LINK FORMAT'\n***********************************************************************\n*                                                                     *\n*              ROUTINES TO PROCESS TOPOLOGICAL DATA STRUCTURE         *\n*                                                                     *\n*                                                                     *\n*                             SEPTEMBER 1, 1968                       *\n*                                                                     *\n*        THE TOPOLOGICAL DATA STRUCTURE IS USED FOR OUTPUT FORMATTING.*\n*        IT IS DESCRIBED IN IBM CAMBRIDGE SCIENTIFIC CENTER REPORT    *\n*        320-2023, \"SCRIPT: AN ONLINE MANUSCRIPT PROCESSING SYSTEM\".  *\n*        A BACKWARD POINTER HAS BEEN ADDED TO THE DATA STRUCTURE TO   *\n*        FACILITATE THE MERGING AND TRUNCATION PROCESS.               *\n*                                                                     *\n*        STANDARD PARAMETER LIST:                                     *\n*                                                                     *\n*        DC    A(LOC)         LOCATION OF CHARACTER STRING BUFFER     *\n*        DC    F'N1'          LENGTH OF CHARACTER STRING              *\n*        DC    A(POINT1)      LOCATION OF FIRST PRIMARY LINK ELEMENT  *\n*        DC    A(POINT2)      LOCATION OF LAST PRIMARY LINK ELEMENT   *\n*        DC    F'N2'          NUMBER OF PRIMARY LINK ELEMENTS         *\n*                                                                     *\n***********************************************************************\n         SPACE\n***********************************************************************\n*                                                                     *\n*        THE 'LINKPUT' ROUTINE HAS BEEN RECODED BASED ON A            *\n*        REWRITE BY SHMUEL METZ (TSM).  ITS PURPOSE WAS TO            *\n*        ACCEPT NON-CANONICAL INPUT AND MAKE THE ROUTINE              *\n*        SOMEWHAT EASIER TO UNDERSTAND.     JULY 1975.                *\n*                                                                     *\n***********************************************************************\n         EJECT\n         COPY  #LKINIT\n         EJECT\n         COPY  #LKADD\n         EJECT\n         COPY  #LKCHAIN\n         EJECT\n         COPY  #LKPUT\n         EJECT\n         COPY  #LKGESC\n         EJECT\n         COPY  #LKGETP\n         EJECT\n         COPY  #LKGETT\n         EJECT\n         COPY  #FO2741\n         EJECT\n         COPY  #FO1620\n         EJECT\n         COPY  #FOASM3\n         EJECT\n         COPY  #FOQUME\n         EJECT\n         COPY  #FOMYTE\n         EJECT\n***********************************************************************\n*                                                                     *\n*              REGISTER DEFINITIONS                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nPNEW     EQU   2                   TEMP POINTER TO START OF NEW STRING\nW        EQU   3                   WORD COUNTER\nP        EQU   4                   POINTER\nB        EQU   5                   LINK BLOCK COUNTER\nC        EQU   7                   CHARACTER (COLUMN) COUNTER\nM        EQU   8                   MULTIPLIER\nA        EQU   9                   ADJUSTMENT AMOUNT\nTABS     EQU   9                   TAB TABLE POINTER\nPOLD     EQU   14                  TEMP POINTER TO END OF OLD STRING\nR        EQU   14                  REMAINDER FOR ADJUST\nQ        EQU   15                  QUOTIENT FOR ADJUST\n         SPACE\n*                  INIT  PUT  GETP  GETT                              *\n*                                                                     *\n*R0      EQU   0   X     X    X     X\n*R1      EQU   1         X    X     X\n*COUNT   EQU   2   X     X\nPFOR     EQU   2              X     X\nPCHAR    EQU   3   X     X    X     X\nNEXT     EQU   4   X     X\nCOUNT2   EQU   5         X    X     X\nCUR      EQU   6         X\n*RETURN  EQU   6\nPDOWN    EQU   7              X     X\nBOT      EQU   7         X\nCOUNT3   EQU   8              X     X\nLAST     EQU   8   X     X\nCOL      EQU   9         X\nMULT     EQU   9              X     X\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCRIPTHY": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x00Y\\x00Y\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "CBT249"}, "text": "         COPY  $COPYWRT\nHYSCRIPT TITLE 'HYPHENATION MODULE FOR SCRIPT PROCESSOR'\n        $SCRCVT DSECT=YES,DOC=NOGEN\n         SPACE 2\n        $NSCDAT DSECT=YES,DOC=NOGEN\n         SPACE 2\n         COPY  #DSECTS\n         EJECT\n         PRINT NOGEN               OVERALL PRINT CONTROL\nSCRIPTHY $VERSION ,                IDENTIFICATION\n         USING SCRIPTHY,BASE       LOCAL DATA/CONSTANT AREA\n         EJECT\n***********************************************************************\n*                                                                     *\n*        THE HYPHENATION PACKAGE WHICH HAS BEEN IMBEDDED INTO         *\n*        THIS VERSION OF 'SCRIPT' IS BASED ON THE 'HYPHENATION/360'   *\n*        PACKAGE (360-DP-07X) FROM IBM.                               *\n*        IT HAS BEEN MODIFIED TO RUN ON 'OS' INSTEAD OF 'DOS',        *\n*        TO USE THE '$ENTER' AND '$EXIT' CALLING CONVENTIONS          *\n*        LIKE THE REST OF 'SCRIPT' AND TO MAINTAIN THE EXCEPTION      *\n*        WORD DICTIONARY IN MEMORY INSTEAD OF ON 2311S.\n*                                                                     *\n*        THE ORIGINAL PROGRAMME PACKAGE CONSISTS OF THREE PROGRAMS.   *\n*        THE FIRST IS 'HYPHEN' WHICH IS A CALLABLE SUBROUTINE TO      *\n*        DETERMINE THE HYPHENATION BREAK POINTS.                      *\n*        THE SECOND IS 'DEUHTEST' WHICH IS A STANDALONE PROGRAMME     *\n*        TO TEST INPUT WORDS AND PRODUCE UPDATE CARDS FOR THE         *\n*        EXCEPTION DICTIONARY.  THE FUNCTION OF THIS PROGRAMME        *\n*        IS REPLACED BY '.HY TEST WORD'.                              *\n*        THE THIRD IS 'DEUHMAINT' WHICH IS A STANDALONE PROGRAMME     *\n*        TO UPDATE THE EXCEPTION DICTIONARY.  THE FUNCTION OF THIS    *\n*        PROGRAMME IS REPLACED BY '.HY <ADD|CHANGE|DELETE>'.          *\n*                                                                     *\n*        FOR FURTHER INFORMATION REFER TO IBM MANUALS H20-0525        *\n*        (PROGRAM DESCRIPTION), H20-0526 (OPERATIONS), Y20-0208       *\n*        (SYSTEM) AND E20-0257 (APPLICATION DESCRIPTION -- THE        *\n*        ONE TO READ FOR AN OVERVIEW).                                *\n*                                                                     *\n***********************************************************************\n         EJECT\n         COPY  #HY\n         EJECT\n         COPY  #HYSCN\n         EJECT\n         COPY  #DCOMPOZ\n         EJECT\n         COPY  #DEUH01\n         EJECT\n         COPY  #DEUH02\n         EJECT\n         COPY  #DEUH03\n         EJECT\n         COPY  #DEUH04\n         EJECT\n         COPY  #DEUH05\n         EJECT\n         COPY  #DEUH06\n         EJECT\n         COPY  #DEUH07\n         EJECT\n         COPY  #DEUH08\n         EJECT\n         COPY  #DEUH09\n         EJECT\n         COPY  #DEUH10\n         EJECT\n         COPY  #DEUH11\n         EJECT\n         COPY  #DEUH12\n         EJECT\n         COPY  #DEUH13\n         EJECT\n         COPY  #DEUH15\n         EJECT\n         COPY  #DEUH16\n         EJECT\n         COPY  #DEUH18\n         EJECT\n         COPY  #DEUH24\n         EJECT\n         COPY  #DEUH25\n         EJECT\n         COPY  #DEUDATA\n         EJECT\n         COPY  #DEUH14\n         EJECT\n         COPY  #DEUH17\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRIPTMC": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x00`\\x00`\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 96, "newlines": 96, "modlines": 0, "user": "CBT249"}, "text": "         COPY  $COPYWRT\nMCSCRIPT TITLE '         SCRIPT -- INCORE FORMATTING'\n        $SCRCVT DSECT=YES,DOC=NOGEN\n         SPACE 2\n        $NSCDAT DSECT=YES,DOC=NOGEN\n         SPACE 2\n         COPY  #DSECTS\n         EJECT\n***********************************************************************\n*                                                                     *\n*              INCORE FORMATTING SUPPORT --- SCRIPTMC                 *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PRINT NOGEN             OVERALL PRINT CONTROL\nSCRIPTMC $VERSION ,                FOR IDENTIFICATION\n         EJECT\n         COPY  #BC\n         EJECT\n         COPY  #CB\n         EJECT\n         COPY  #CC\n         EJECT\n         COPY  #CD\n         EJECT\n         COPY  #CL\n         EJECT\n         COPY  #COLBAL\n         EJECT\n         COPY  #COLNEW\n         EJECT\n         COPY  #COLPAGE\n         EJECT\n         COPY  #COLPRT\n         EJECT\n         COPY  #COLSAVE\n         EJECT\n         COPY  #CP\n         EJECT\n         COPY  #CPFKNXT\n         EJECT\n         COPY  #CPFKPRT\n         EJECT\n         COPY  #DH\n         EJECT\n         COPY  #DHCLR\n         EJECT\n         COPY  #DM\n         EJECT\n         COPY  #EZ\n         EJECT\n         COPY  #FB\n         EJECT\n         COPY  #FK\n         EJECT\n         COPY  #FN\n         EJECT\n         COPY  #FNPRT\n         EJECT\n         COPY  #FNSAVE\n         EJECT\n         COPY  #HIDB\n         EJECT\n         COPY  #HIDTC\n         EJECT\n         COPY  #HL\n         EJECT\n         COPY  #HN\n         EJECT\n         COPY  #IX\n         EJECT\n         COPY  #IXCLR\n         EJECT\n         COPY  #IXDUMP\n         EJECT\n         COPY  #IXPROC\n         EJECT\n         COPY  #MC\n         EJECT\n         COPY  #MS\n         EJECT\n         COPY  #PT\n         EJECT\n         COPY  #RM\n         EJECT\n         COPY  #RMCOND\n         EJECT\n         COPY  #RMIMBED\n         EJECT\n         COPY  #RMNEXT\n         EJECT\n         COPY  #SC\n         EJECT\n         COPY  #TC\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRIPTOU": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x00v\\x00v\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 118, "newlines": 118, "modlines": 0, "user": "CBT249"}, "text": "         COPY  $COPYWRT\nOUSCRIPT TITLE '         SCRIPT -- SUBROUTINE CALLS'\n        $SCRCVT DSECT=YES,DOC=NOGEN\n         SPACE 2\n        $NSCDAT DSECT=YES,DOC=NOGEN\n         SPACE 2\n         COPY  #DSECTS\n         EJECT\n***********************************************************************\n*                                                                     *\n*              SUBROUTINES FOR SCRIPT --- SCRIPTOU                    *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PRINT NOGEN               OVERALL PRINT CONTROL\nSCRIPTOU $VERSION ,                IDENTIFY AND INITIALIZE\n         EJECT\n         COPY  #ARGINIT\n         EJECT\n         COPY  #BXHORIZ\n         EJECT\n         COPY  #BXVERT\n         EJECT\n         COPY  #DUMPIT\n         EJECT\n         COPY  #ERROUT\n         EJECT\n         COPY  #FLUSHSP\n         EJECT\n         COPY  #FREECEL\n         EJECT\n         COPY  #GETARG\n         EJECT\n         COPY  #GETCELL\n         EJECT\n         COPY  #GETNUM\n         EJECT\n         COPY  #GETQST\n         EJECT\n         COPY  #GETSYM\n         EJECT\n         COPY  #GETYESN\n         EJECT\n         COPY  #HEADCLR\n         EJECT\n         COPY  #HEADPRT\n         EJECT\n         COPY  #HEADSAV\n         EJECT\n         COPY  #IOADJ\n         EJECT\n         COPY  #IOPRINT\n         EJECT\n         COPY  #MAINOC\n         EJECT\n         COPY  #ODDEVN\n         EJECT\n         COPY  #OOPRT\n         EJECT\n         COPY  #OUSTAT\n         EJECT\n         COPY  #OVREMOV\n         EJECT\n         COPY  #PAGE\n         EJECT\n         COPY  #PAGEREA\n         EJECT\n         COPY  #PAGETOP\n         EJECT\n         COPY  #PNUMFMT\n         EJECT\n         COPY  #PRINT\n         EJECT\n         COPY  #PRINTNB\n         EJECT\n         COPY  #PRLIN\n         EJECT\n         COPY  #PRNUM\n         EJECT\n         COPY  #PRRCADD\n         EJECT\n         COPY  #PRSKSPC\n         EJECT\n         COPY  #PRTARG\n         EJECT\n         COPY  #PRTERM\n         EJECT\n         COPY  #PUTCONS\n         EJECT\n         COPY  #PUTPRT\n         EJECT\n         COPY  #PUTTERM\n         EJECT\n         COPY  #PUWORK\n         EJECT\n         COPY  #QUITS\n         EJECT\n         COPY  #READ\n         EJECT\n         COPY  #RGNMGR\n         EJECT\n         COPY  #SCRIPUT\n         EJECT\n         COPY  #SPACER\n         EJECT\n         COPY  #SPACEIM\n         EJECT\n         COPY  #SYMCLR\n         EJECT\n         COPY  #SYMSR\n         EJECT\n         COPY  #SYMUR\n         EJECT\n         COPY  #SYMUSL\n         EJECT\n         COPY  #VTRAPS\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRIPTPM": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x02\\x9f\\x02\\x9f\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 671, "newlines": 671, "modlines": 0, "user": "CBT249"}, "text": "         COPY  $COPYWRT\nPMSCRIPT TITLE '   INITIALIZE AND SCAN PARM FOR SCRIPT PROCESSOR'\n        $SCRCVT DSECT=YES,DOC=NOGEN\n         SPACE 2\n        $NSCDAT DSECT=YES,DOC=NOGEN\n         SPACE 2\n         COPY  #DSECTS\n         EJECT\n***********************************************************************\n*                                                                     *\n*              SCRIPTPM CSECT SUBROUTINE DEFINITION                   *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PRINT NOGEN               OVERALL PRINT CONTROL\nSCRIPTPM $VERSION ,                IDENTIFY AND INITIALIZE\n         EJECT\nPARMSCAN $ENTER ,\n         L     R1,PASSNO           GET CURRENT PASS NUMBER\n         LTR   R1,R1               FIRST TIME .Q\n         LA    R1,1(,R1)           BUMP PASS NUMBER BY ONE\n         ST    R1,PASSNO           UPDATE CURRENT PASS NUMBER\n         BNZ   STADONE             NOT FIRST TIME, SKIP SCAN\n         SPACE\n         L     R1,CVTPTR           PICK UP CVT POINTER\n         S     R1,F8               POINT TO CVT PREFIX\n         CLI   CVTRELNO(R1),C'C'   IS THIS CMS .Q\n         BNE   PARMSTSO            NO, GO TO CHECK TSO\n        $ON    PARMSWCH,CMSWS      TURN ON CMS SWITCH\n         B     PARMSREF            AND CONTINUE\n         SPACE\nPARMSTSO DS    0H\n         L     R1,CVTPTR           PICK UP CVT POINTER\n         TM    CVTDCB(R1),X'01'    IS THIS MVS .Q\n         L     R1,CVTTCBP(,R1)     ADDR NEXT/CURRENT TCB\n         BNO   NOTMVS              NO, THEN IT MUST BE OS/SVS\n         L     R1,12(,R1)          R1 -> ASCB\n         L     R1,60(,R1)          R1 -> TSB\n         LTR   R1,R1               IS THIS A TSO USER .Q\n         BZ    PARMSREF            NO, DON'T SET SWITCH\n         B     SETTSO              YES, SET SWITCH\nNOTMVS   DS    0H\n         L     R1,4(,R1)           R1 -> TCB\n         TM    TCBTSFLG(R1),TCBTSTSK    IN TSO FOREGROUND .Q\n         BZ    PARMSREF            BRANCH IF NOT\nSETTSO   DS    0H\n        $ON    PARMSWCH,TSOWS      TURN ON TSO SWITCH\n         SPACE\nPARMSREF DS    0H\n         L     X1,SRNTBBEG         ADDR OF START OF SYSTEM SYMBOLS\n         USING SYSREFS,X1          TELL THE ASSEMBLER\n         LA    R0,RNLN             LENGTH OF ONE SYSTEM ENTRY\n         LA    R1,@NULL            ADDR OF LAST ENTRY TO BE SEARCHED\n         STM   R0,R1,SRNTBLN       SAVE THEM AWAY TOO\n        $CALL  SYTIME              GET TIME AND DATE IN DECIMAL\n         ST    R0,SAVED0           STORE TIME OF DAY\n         UNPK  SAVED0(7),SAVED0(4) CHANGE TIME TO CHARACTER\n         MVC   @HOUR+RNCVAL-RND(2),SAVED0    PLACE HOUR\n         MVC   @MINUTE+RNCVAL-RND(2),SAVED0+2     PLACE MINUTE\n         MVC   @SECOND+RNCVAL-RND(2),SAVED0+4     PLACE SECONDS\n         MVC   @TIME+RNCVAL-RND+0(2),SAVED0  HOURS AGAIN\n         MVC   @TIME+RNCVAL-RND+3(2),SAVED0+2     MINUTES AGAIN\n         MVC   @TIME+RNCVAL-RND+6(2),SAVED0+4     SECONDS AGAIN\n         SR    R0,R0               MAKE YEAR.DAY DOUBLE WORD\n         STM   R0,R1,SAVED0        PUT YEAR.JULIAN DAY IN CORE\n         UNPK  @DAYOFY+RNCVAL-RND(3),SAVED0+6(2)  JULIAN DAY\n         UNPK  @YEAR+RNCVAL-RND(3),SAVED0+5(2)    YEAR IN DICTIONARY\n         MVC   @PYEAR+RNCVAL-RND+2(2),@YEAR+RNCVAL-RND AGAIN\n         CVB   R1,SAVED0           YEAR.DAY TO BINARY\n         LA    COUNT,1000          CONSTANT THOUSAND\n         DR    R0,COUNT            YEAR IN R1, DAY IN R0\n         BCTR  R1,0                (YR-1)\n         LR    TEMP,R1             (YR-1)\n         SRL   TEMP,2              (YR-1)/4\n         N     R1,F3               (YR-1) MOD4\n         MH    TEMP,H5             (YR-1)/4*5\n         AR    TEMP,R1             (YR-1)/4*5 + ((YR-1) MOD4)\n         AR    TEMP,R0             (YR-1)/4*5 + ((YR-1) MOD4) + DAYS\n         SR    COUNT,COUNT         DOUBLE WORD LONG\n         D     COUNT,F7            DAY OF THE WEEK\n         LR    TEMP,COUNT          PREPARE FOR INDEX MULT\n         LA    COUNT,L'ZDAYTAB     LENGTH OF ONE DAY ENTRY\n         MR    COUNT,COUNT         INDEX DAY NAME TABLE\n         LA    COUNT,ZDAYTAB(TEMP) POINT TO THE DAY\n         MVC   @DAYOFW+RNCVAL-RND(1),10(COUNT)    SET DAY NUMBER\n         MVC   @PDAYOFW+RNCLEN-RND(1),0(COUNT)    SET DAY LENGTH\n         MVC   @PDAYOFW+RNCVAL-RND(9),1(COUNT)    SET DAY NAME\n         IC    R1,ZFEBTAB(R1)      28 OR 29 DAYS IN FEB\n         STC   R1,ZFEB             AND SET IT\n         LA    R1,ZMONTAB-L'ZMONTAB     POINT AT MONTH TABLE\n         SR    TEMP,TEMP           CLEAR WORK REGISTER\nZLOOP    DS    0H\n         LA    R1,L'ZMONTAB(,R1)   POINT TO NEXT MONTH\n         IC    TEMP,0(R1)          PICK UP NUMBER OF DAYS IN MONTH\n         SR    R0,TEMP             SUBTRACT NUMBER DAYS IN MONTH\n         BP    ZLOOP               DONE IF ZERO OR NEGATIVE\n         AR    R0,TEMP             ADD BACK LAST MONTH\n         CVD   R0,SAVED0           CHANGE DAY OF MONTH TO DECIMAL\n         MVO   SAVED0(2),SAVED0+6(2)    ALIGN DAY IN BYTE\n         UNPK  @DAYOFM+RNCVAL-RND(3),SAVED0(2)    ENTER DAY OF MONTH\n         MVC   @MONTH+RNCVAL-RND(2),11(R1)   MONTH NUMBER\n         MVC   @PMONTH+RNCLEN-RND(1),1(R1)   MONTH NAME LENGTH\n         MVC   @PMONTH+RNCVAL-RND(9),2(R1)   MONTH NAME\n         SPACE\n         LA    R1,SDATEWRK         POINT TO DATE WORK AREA\n         MVI   0(R1),C' '          BLANK WORK AREA\n         MVC   1(L'SDATEWRK-1,R1),0(R1) ALL OF IT\n         SR    TEMP,TEMP           ZERO LENGTH REG\n         IC    TEMP,@PMONTH+RNCLEN-RND  LENGTH OF MONTH STRING\n         MVC   0(9,R1),@PMONTH+RNCVAL-RND    ENTER MONTH NAME\n         LA    R1,1(TEMP,R1)       NEXT CHARACTER\n         MVC   0(2,R1),@DAYOFM+RNCVAL-RND    ENTER DAY OF MONTH\n         CLI   0(R1),C'0'          TEST FOR LEADING ZERO\n         BNE   PARMNZDT            BRANCH IF NO LEADING ZERO\n         MVC   0(1,R1),1(R1)       MOVE SINGLE DIGIT TO START\n         BCTR  R1,0                BACKUP POINTER\nPARMNZDT DS    0H\n         LA    R1,2(,R1)           BUMP POINTER\n         MVI   0(R1),C','          COMMA\n         MVC   2(4,R1),@PYEAR+RNCVAL-RND     ENTER YEAR\n         DROP  X1\n         SPACE\n         SR    R0,R0               CLEAR RDW POINTER\n        $CALL  PUTTERM             OPEN ERROR FILE\n         BC    BPOS,PARMSTRT       BRANCH IF OPEN SUCCESSFUL\n         MVI   EFLAG057,ERRINFO    SET INFORMATION FLAG\n        $CALL  ERROUT              DISPLAY FIRST LINE TO OPERATOR\n         SPACE\nPARMSTRT DS    0H\n        $ON    PARMSWCH,(FEMPTY,FNOEMPTY)         DEFAULTS\n        $ON    PARMSWCH,(AFIRST,FFIRST,BCSWS)     MORE DEFAULTS\n         L     R1,PLSTSV           PARM LIST ADDRESS\n         L     R1,0(,R1)           GET ADDR OF ACTUAL LIST\n         LH    X1,0(,R1)           GET LENGTH OF PARM\n         LTR   X1,X1               IS IT NULL .Q\n         BZ    ENDSCN              BRANCH IF YES\n*                                                                     *\n*        INITIALIZE FOR SCAN                                          *\n*                                                                     *\n         LA    R1,2(,R1)           INITIALIZE FIELD SCAN POINTER\n         LA    X3,0(X1,R1)         LAST CHAR +1\n         ST    X3,PARMEND          AND SAVE IT\n*                                                                     *\n*        SCAN OFF ONE WORD                                            *\n*                                                                     *\nNEXTWORD DS    0H\n         LR    X3,R1               SAVE INITIAL ADDRESS\n         ST    X3,ERRSTART         IN CASE OF ERROR\n        $OFF   ERRSW,(ERRLPRN,ERREQU)   KILL DELIMITER SWITCHES\n         CLI   0(R1),C' '          IS A BLANK FIRST .Q\n         BNE   WORDSCAN            START SCANNING IF NOT\n         C     R1,PARMEND          TEST FOR END OF PARM\n         BNL   WORDEND             BRANCH IF THAT'S ALL\n         LA    R1,1(,R1)           NEXT CHAR\n         B     NEXTWORD            AND TRY AGAIN\nWORDSCAN DS    0H\n         C     R1,PARMEND          TEST FOR END\n         BNL   WORDEND             BRANCH IF AT END\n         CLI   0(R1),C','          TEST FOR COMMA\n         BE    WORDEND             BRANCH IF COMMA\n         CLI   0(R1),C' '          TEST FOR BLANK\n         BE    WORDEND             BRANCH IF BLANK\n         CLI   0(R1),C'='          TEST FOR EQUALS\n         BE    WORDEQU             BRANCH IF EQUAL\n         CLI   0(R1),C'('          TEST FOR LEFT PAREN\n         BE    WORDLPRN            BRANCH IF LEFT PAREN\n         OI    0(R1),C' '          UPPER CASE PARMS\n         LA    R1,1(,R1)           POINT AT NEXT CHAR\n         B     WORDSCAN            DO IT AGAIN\nWORDEQU  DS    0H\n        $ON    ERRSW,ERREQU        MARK EQUAL SIGN\n         CLI   0(X3),C'+'          KEYWORD START WITH PLUS .Q\n         BE    KWAMPL              YES, IT'S EASIER TO ENTER\n         CLI   0(X3),C'&&'         KEYWORD START WITH AMPERSAND .Q\n         BNE   WORDEND             BRANCH IF NOT\nKWAMPL   DS    0H\n         LA    R1,1(,R1)           BUMP PTR\n         C     R1,PARMEND          TEST FOR END .Q\n         BNL   KWFOUND             BRANCH IF YES\n         CLI   0(R1),C''''         QUOTED STRING .Q\n         BNE   KWNOQ01             BRANCH IF NOT\nKWQST01  DS    0H\n         LA    R1,1(,R1)           BUMP ONE MORE\n         C     R1,PARMEND          AT THE END .Q\n         BNL   KWFOUND             BRANCH IF YES\n         CLI   0(R1),C''''         ENDING QUOTE .Q\n         BNE   KWQST01             BRANCH IF NOT\n         LA    R1,1(,R1)           BUMP POINTER\n         C     R1,PARMEND          AT THE END .Q\n         BNL   KWFOUND             BRANCH IF YES\n         CLI   0(R1),C''''         DOUBLE QUOTE .Q\n         BNE   KWFOUND             OUT IF NOT\n         B     KWQST01             YES, TRY AGAIN\n         SPACE\nKWNOQ01  DS    0H\n         LA    R1,1(,R1)           BUMP ONE MORE\n         C     R1,PARMEND          AT THE END .Q\n         BNL   KWFOUND             BRANCH IF YES\n         CLI   0(R1),C','          COMMA .Q\n         BE    KWFOUND             BRANCH IF YES\n         CLI   0(R1),C' '          BLANK .Q\n         BE    KWFOUND             BRANCH IF YES\n         B     KWNOQ01             LOOP BACK OTHERWISE\n         SPACE\nKWFOUND  DS    0H\n         LR    X1,R1               LAST LETTER OF KW+1\n         SR    X1,X3               MINUS START\n         S     X1,F2               LESS AMPERSAND AND TERM CHAR\n         BNP   COMTEST             THAT WAS SHORT\n        $SAVE  ,                   SAVE CURRENT REGS\n         L     R1,BUFF3AD          POINT TO WORK AREA\n         LA    R1,4(,R1)           BUMP OVER RDW\n         MVC   0(B2LG,R1),BLANKS   CLEAR WORK AREA\n         MVC   0(L'SRCOM,R1),SRCOM ENTER SET CONTROL WORD\n         LA    TEMP,L'SRCOM(,R1)   TARGET FOR VALUE\n         EX    X1,KWMVCA           MOVE ARGUMENT\n         LA    TEMP,L'SRCOM(,X1)   LENGTH OF RESULT\n         LNR   R1,R1               ENTER FIFO\n        $CALL  HIDBADD             ENTER SAME\n        $RESTOR ,                  RESTORE CURRENT REGS\n         BC    BNEG,KWHIDBER       BRANCH IF ERROR\n         B     COMTEST             TEST FOR COMMAS\nKWMVCA   MVC   0(*-*,TEMP),1(X3)   EXECUTED MOVE KEYWORD ARGUMENT\n         SPACE\nKWHIDBER DS    0H\n         MVI   EFLAG024,ERRSET     NO SPACE AVAILABLE\n         B     PARMERR             GO TO ERROR RETURN\n         SPACE\nWORDLPRN DS    0H\n        $ON    ERRSW,ERRLPRN       MARK LEFT PAREN\n*                                                                     *\n*        COMPUTE PARM LENGTH                                          *\n*                                                                     *\nWORDEND  DS    0H\n         LR    X1,R1               LAST LETTER OF WORD+1\n         SR    X1,X3               MINUS FIRST LETTER\n         BZ    COMTEST             TEST FOR ZERO LENGTH\n         C     X1,F12              TEST FOR TOO LONG\n         BH    PARMERR             ERROR IF SO\n         BCTR  X1,0                LENGTH-1\n         LA    X2,OPTEST1          POINT TO START OF PARM TABLE\n        $IFNONE ERRSW,(ERREQU,ERRLPRN),NEXTOP BRANCH IF NOT KEYWORD\n         LA    X2,OPTEST2          POINT TO KEYWORD TABLE\nNEXTOP   DS    0H\n         CLI   0(X2),FF            AT THE END .Q\n         BE    PARMERR             ERROR IF SO\n         IC    COUNT,OPTPLEN(,X2)  GET MIN LENGTH-1 OF PARM\n         N     COUNT,F15           AND PURIFY\n         CR    X1,COUNT            IS THIS A CANDIDATE\n         BL    BXLEOPT             BRANCH IF NOT\n         EX    X1,OPTCLC           DO THE COMPARE\n         BE    FOUND               BRANCH IF EQUAL\nBXLEOPT  DS    0H\n         LA    X2,OPTPEND(,X2)     POINT TO NEXT\n         B     NEXTOP              AND TRY AGAIN\nOPTCLC   CLC   OPTPSTR(*-*,X2),0(X3)    COMPARE PARM NAMES\n*                                                                     *\n*        A MATCH HAS BEEN FOUND                                       *\n*                                                                     *\nFOUND    DS    0H\n         L     X1,OPTPADDR(X2)     GET ROUTINE ADDRESS\n         LA    RETURN,COMTEST      CHECK FOR COMMAS, ETC AFTER\n         BR    X1                  GO DO IT\n         SPACE\nSWTCHNM  DS    0H\n        $ON    PARMSWCH,NUSWS      TURN ON NUMBER SWITCH\nADJUST   DS    0H\n         MVC   DEFADJ+TAB3DEF,F30  SET ADJUST AMOUNT\n         BR    RETURN              AND TERMINATE\n         SPACE\nSWTCHNNM DS    0H\n        $OFF   PARMSWCH,NUSWS      TURN OFF NUMBER SWITCH\nUNADJUST DS    0H\n         MVC   DEFADJ+TAB3DEF,F0   REMOVE ADJUST AMOUNT\n        $OFF   PARMSWCH,NUSWS      TURN OFF NUMBER SWITCH\n         BR    RETURN              AND TERMINATE\n         SPACE\nSWCONT   DS    0H\n         MVC   DEFCONT+TAB3DEF,DEFCONT+TAB3MAX  MAXIMUM ERROR COUNT\n         BR    RETURN              AND TERMINATE\nSWCONTNO DS    0H\n         MVC   DEFCONT+TAB3DEF,DEFCONT+TAB3MIN  MINIMUM ERROR COUNT\n         BR    RETURN              AND TERMINATE\n         SPACE\nSWTCHFO  DS    0H\n        $OFF   PARMSWCH,(NFSWS,NCSWS)   TURN THEM ALL OFF\n         MVI   PARMJUV,JUVPOS      JUSTIFY LEFT AND RIGHT\n         BR    RETURN\nSWTCHNF  DS    0H\n        $ON    PARMSWCH,(NFSWS,NCSWS)   TURN THEM ALL ON\n         MVI   PARMJUV,JUVNEG      NO JUSTIFY\n         BR    RETURN              AND TERMINATE\n         SPACE\nSWTCHP6  DS    0H\n         LA    X3,3                TOP OF FORM LINE AT SIX LPI\n         ST    X3,DEFFFTO+TAB3DEF  SET IT\n         LA    X3,66               PAGE LENGTH FOR SIX LINES PER INCH\n         ST    X3,DEFPL+TAB3DEF    SET IT\n         BR    RETURN              THAT'S IT\nSWTCHP8  DS    0H\n         LA    X3,4                TOP OF FORM LINE AT EIGHT LPI\n         ST    X3,DEFFFTO+TAB3DEF  SET IT\n         LA    X3,88               PAGE LENGTH FOR EIGHT LINES PER INCH\n         ST    X3,DEFPL+TAB3DEF    SET IT\n         BR    RETURN              THAT'S IT\n         SPACE\nPAGPARM  DS    0H\n         BAL   RETURN,SWTCHDGT     ENTER FIRST OPERAND\n        $ON    PARMSWCH,NPSWS      SET NO PRINT SWITCH\n         CLC   DEFPAGS+TAB3DEF,F1  START ON PAGE ONE .Q\n         BNE   PAGPARON            BRANCH IF NOT\n        $OFF   PARMSWCH,NPSWS      PRINT FROM THE VERY START\nPAGPARON DS    0H\n         C     R1,PARMEND          ANY MORE PARM STRING TO CHECK .Q\n         BH    COMTEST             BRANCH OUT IF NOT\n         CLI   0(R1),C':'          A SECOND OPERAND .Q\n         BE    PAGPARML            BRANCH IF YES\n        $IFOFF ERRSW,ERRLPRN,COMTEST    CHECK FOR END IF NO PARENS\n         CLI   0(R1),C','          OTHERWISE A COMMA IS VALID\n         BNE   COMTEST             IF NOT, CHECK ENDING\nPAGPARML DS    0H\n         LA    X2,OPTPAGEL         POINT TO SECOND OPERAND ENTRY\n         BAL   RETURN,SWTCHDGT     ENTER SECOND VALUE\n         CLC   DEFPAGS+TAB3DEF,DEFPAGL+TAB3DEF    START GT LAST .Q\n         BH    PARMERR             ERROR IF NOT\n         B     COMTEST             CHECK THE ENDING\n         SPACE\nSWTCHEX  DS    0H\n         EX    R0,OPTPBITS(X2)     EXECUTE ONE INSTRUCTION\n         BR    RETURN              AND GO BACK\n         SPACE\nNUMDGT   DS    0H\n        $ON    PARMSWCH,NUSWS      TURN ON NUMBER SWITCH\n         B     SWTCHDGT            HANDLE NUMERIC OPERAND\n         SPACE\nLEGDGT   DS    0H\n        $ON    PARMSWCH,OUSWS      TURN ON LEGAL INTERPRETATION\n         B     SWTCHDGT            HANDLE NUMERIC OPERAND\nLINDGT   DS    0H\n        $OFF   PARMSWCH,OUSWS      SET TO LINENUMBER INTERPRETATION\n         B     SWTCHDGT            HANDLE NUMERIC OPERAND\n         SPACE\nSWTCHDGT DS    0H\n         LA    R1,1(,R1)           BUMP PAST DELIMITER\n         LR    X3,R1               FIRST DIGIT IN NUMBER\n         ST    X3,ERRSTART         IN CASE OF ERROR\nNUMSCAN  DS    0H\n         C     R1,PARMEND          TEST FOR END OF PARM\n         BNL   NUMEND              BRANCH IF WE'RE THERE\n         CLI   0(R1),C'0'          TEST FOR NUMERIC LOW\n         BL    NUMEND              BRANCH IF LOW\n         CLI   0(R1),C'9'          TEST FOR NUMERIC HIGH\n         BH    NUMEND              BRANCH IF HIGH\n         LA    R1,1(,R1)           POINT NEXT CHARACTER\n         B     NUMSCAN             NEXT CHECK\nNUMEND   DS    0H\n         LR    COUNT,R1            COMPUTE LENGTH OF NUMBER\n         SR    COUNT,X3            LESS START POSITION\n         BZ    PARMERR             ERROR IF NO DIGITS\n         C     COUNT,F7            TEST FOR TOO MANY DIGITS\n         BH    PARMERR             ERROR IF LARGER\n         BCTR  COUNT,0             LENGTH-1\n         EX    COUNT,PARMPACK      PACK INTO SAVED0\n         CVB   X3,SAVED0           CONVERT TO BINARY\n*                                                                     *\n*        TEST FOR NUMBER FOLLOWED BY K                                *\n*                                                                     *\n         C     R1,PARMEND          TEST FOR END OF PARM\n         BE    NOK                 BRANCH IF OK\n         CLI   0(R1),C'K'          FOLLOWED BY 'K' .Q\n         BNE   NOK                 BRANCH IF NOY\n         LA    R1,1(,R1)           POINT AT NEXT CHAR\n         SLA   X3,10               MULT BY 1024\n         BO    PARMERR             TEST FOR OVERFLOW\nNOK      DS    0H\n         L     COUNT,OPTPBITS(,X2) OFFSET OF TARGET\n         LA    COUNT,DEFAULTS(COUNT)    ADDRESS OF TARGET\n         C     X3,TAB3MIN(COUNT)   BIG ENOUGH .Q\n         BL    PARMERR             BRANCH IF TOO SMALL\n         CL    X3,TAB3MAX(COUNT)   SMALL ENOUGH .Q\n         BH    PARMERR             BRANCH IF TOO BIG\n         ST    X3,TAB3DEF(COUNT)   SET DEFAULT VALUE\n         BR    RETURN              AND GO BACK\n*                                                                     *\n*        CHECK FOR DELIMITERS AFTER PARM JUST SCANNED                 *\n*                                                                     *\nCOMTEST  DS    0H\n        $IFOFF ERRSW,ERRLPRN,COMTEST1   BRANCH IF NO LEFT PAREN\n         C     R1,PARMEND          ANY MORE PARM STRING TO CHECK .Q\n         BH    PARMERR             BRANCH IF NOT\n         CLI   0(R1),C')'          RIGHT PAREN\n         BE    BLKTEST             BRANCH IF YES\nCOMTEST1 DS    0H\n         C     R1,PARMEND          AT THE END .Q\n         BNL   ENDSCN              BRANCH IF THE END\n         CLI   0(R1),C' '          A BLANK TERMINATOR .Q\n         BE    BLKTEST             BRANCH IF YES\n         CLI   0(R1),C','          A COMMA TERMINATOR .Q\n         BNE   PARMERR             THEN HOW CAN THIS BE .Q\nBLKTEST  DS    0H\n         LA    R1,1(,R1)           POINT TO NEXT CHAR\n         B     NEXTWORD            AND GET NEXT PARAM\n*                                                                     *\n*        AT THE END OF THE LIST                                       *\n*                                                                     *\nENDSCN   DS    0H\n         MVC   ERCONT,DEFCONT+TAB3DEF   SET USER ERROR COUNT\n         SPACE\n        $IFOFF PARMSWCH,STATSWS,STADONE BRANCH IF NOT FULLSTATS\n         L     X3,VSCRICVT         COMMUNICATION VECTOR TABLE\n         USING SCRICVT,X3          AND TELL THE ASSEMBLER\n         LA    X1,VFSTATS          START OF ROUTINE ADDRESSES\n         LA    X2,L'VFSTATS        ENTRY LENGTH\n         LA    X3,VFSTATE          END OF ROUTINE ADDRESSES\n         DROP  X3\nSTALOOP  DS    0H\n         L     R1,0(,X1)           NEXT CANDIDATE\n         LTR   R1,R1               ANYTHING THERE .Q\n         BNP   STAFAIL             BRANCH IF NOT\n         USING SCVTDSCT,R1         CANDIDATE AREA\n         CLI   SCVTCCNT,X'47'      ENTRY SEQUENCE .Q\n         BE    STAFAIL             BRANCH IF YES\n         XC    SCVTCCNT,SCVTCCNT   ZERO ROUTINE CALL COUNT\n         DROP  R1\nSTAFAIL  DS    0H\n         BXLE  X1,X2,STALOOP       CHECK THEM ALL\n         NI    SCVTENY+1,X'0F'     ENABLE ROUTINE COUNTS\n         SPACE\nSTADONE  DS    0H\n         MVC   JUVAL,PARMJUV       SET DEFAULT JUSTIFY MODE\n         MVC   SWITCHS,PARMSWCH    SET SWITCHES\n        $IFOFF PARMSWCH,PROFSW,PARMPROF BRANCH IF PROFILE NOT SPECIFIED\n         LA    R1,IMPROF           THIS STRING WILL DO IT\n         LNR   R1,R1               INDICATE FIFO\n         LA    TEMP,L'IMPROF-1     LENGTH-1 REQUIRED\n        $CALL  HIDBADD             ENTER SAME\n         BC    BNEG,KWHIDBER       ERROR IF NO SPACE\n         SPACE\nPARMPROF DS    0H\n         XC    IFSTAK,IFSTAK       CLEAR IF STACK SETTINGS\n         SPACE\n         L     R1,TRINITAD         IDENTITY TRANSLATE TABLE ADDR\n         L     COUNT,TRANADI       POINT TO INPUT TRANSLATE TABLE\n         MVC   0(256,COUNT),0(R1)  INITIALIZE INPUT TRANSLATE TABLE\n         SPACE\n         MVC   TRANAD,TRANADO      ADDR OF OUTPUT TRANSLATE TABLE\n        $CALL  TRRESET             INITIALIZE OUTPUT TRANSLATE TABLE\n         SPACE\n         XC    ASRWORK,ASRWORK     CLEAR ANY TEMP LOCAL DICTIONARY\n         SPACE\n         SR    R0,R0               CLEAR WORK REGISTER\n         ST    R0,FLOFFSP          CLEAR BUFFERED SPACES\n         MVC   FLOFFCH,DEFFFCH+TAB3DEF  LEADING CHANNEL SKIP IS PENDING\n         STH   R0,RMARGIN          CLEAR RIGHT MARGIN\n         STH   R0,INDENTR          CLEAR RIGHT INDENT\n         STH   R0,PICNT            CLEAR PARAGRAPH INDENT\n         STH   R0,HICNT            CLEAR HANGING INDENT\n         STH   R0,SFNCNT           ZERO SYSTEM FOOTNOTE COUNT\n         STH   R0,FNSEP            ZERO FOOTNOTE MARGIN\n         XC    FMTOLD2(LFMTOLD2),FMTOLD2     CLEAR AREA\n         MVC   LLZ,DEFLL+TAB3DEF   SET LINE LENGTH\n         MVC   CLLZ,DEFLL+TAB3DEF  SET COLUMN LENGTH\n         XC    CLLZSAVE,CLLZSAVE   CLEAR COLUMN LENGTH SHADOW\n         MVC   PLZ(2),DEFPL+2      SET PAGE LENGTH\n         MVC   PLCT(2),DEFPL+2     AND AGAIN\n         MVC   TOPMRG,DEFTM+2      SET TOP MARGIN\n         MVC   BMMRG,DEFBM+2       BOTTOM MARGIN\n         SPACE\n         XC    CCAREA(CPFKFNL),CCAREA   QUEUED CONDITIONAL COLUMNS\n         XC    CPAREA(CPFKFNL),CPAREA   QUEUED CONDITIONAL KEEPS\n         XC    FBAREA(CPFKFNL),FBAREA   QUEUED FLOATING BLOCKS\n         XC    FKAREA(CPFKFNL),FKAREA   QUEUED FLOATING KEEPS\n         XC    FNAREA(CPFKFNL),FNAREA   QUEUED FOOTNOTES\n         XC    HNAREA(CPFKFNL),HNAREA   QUEUED HEADNOTES\n         XC    HNEAREA(CPFKFNL),HNEAREA QUEUED EVEN HEADNOTES\n         XC    HNOAREA(CPFKFNL),HNOAREA QUEUED ODD HEADNOTES\n         XC    SCAREA(CPFKFNL),SCAREA   QUEUED SINGLE COLUMN\n         XC    MCAREA(CPFKFNL*CDMAXC),MCAREA QUEUED MULTIPLE COLUMN\n         SPACE\n         MVI   ICORFLG,ICORNONE    INITIALLY NOT FORMATTING INCORE\n         MVI   ICOLFLG,ICOLNONE    INITIALLY NOT MULTI-COLUMN\n         XC    SCCOUNT,SCCOUNT     CLEAR NESTED SINGLE COLUMNS\n         XC    CDVALC(L'CDVALC),CDVALC  CLEAR MULTI-COLUMN OFFSETS\n         MVI   CDVALC+0,CDINIT1    FIRST COLUMN DEFAULT\n         MVI   CDVALC+1,CDINIT2    SECOND COLUMN DEFAULT\n         MVI   CDVALC+2,CDINIT3    THIRD COLUMN DEFAULT\n         SPACE\n         SR    R1,R1               CLEAR WORK REG\n         IC    R1,TDEVICE          OUTPUT DEVICE\n         L     X3,VSCRICVT         COMMUNICATION VECTOR TABLE\n         USING SCRICVT,X3          AND TELL THE ASSEMBLER\n         L     R1,VFO2741(R1)      OUTPUT DEVICE TABLE\n         ST    R1,VDEVICEA         REMEMBER SAME ADDRESS\n         DROP  X3\n         LTR   R1,R1               DOES IT EXIST .Q\n         BZ    PARMTDEV            BRANCH IF NOT\n         USING TDEVICEA,R1         AREA LOOKS LIKE THIS\n         L     R0,TDEVRESH         HORIZONTAL RESOLUTION\n         DROP  R1\n         SRDL  R0,32               PREPARE FOR A DIVIDE\n         D     R0,DEFCPI+TAB3DEF   DIVIDE BY CHARACTERS PER INCH\n         STH   R1,TDEVWID          SET CHARACTER WIDTH\n         SPACE\nPARMTDEV DS    0H\n         LA    R0,HYUSER           USER HYPHENATION INITIALLY\n         L     R1,VSCRICVT         COMMUNICATION VECTOR TABLE\n         L     R1,VHY-SCRICVT(,R1) HYPHENATION ROUTINE ADDRESS\n         LTR   R1,R1               HYPHENATION ROUTINE PRESENT .Q\n         BNZ   PARMHYOK            BRANCH IF YES\n         LA    R0,HYNONE           ELSE, NO HYPHENATION INITIALLY\nPARMHYOK DS    0H\n         ST    R0,HYLEVEL          SET INITIAL HYPHENATION LEVEL\n         MVC   HYTHRESH,DEFTRSH+TAB3DEF+2    INITIAL HYPHEN THRESHOLD\n         MVC   HYMINPT,DEFMNPT+TAB3DEF+2     INITIAL MINIMUM LENGTH\n         MVC   HYENDPT,DEFENDPT+TAB3DEF+2    INITIAL END MINIMUM LENGTH\n         MVC   HYSUPCNT,DEFHYSUP+TAB3DEF+2   AUTO HYPHENATION SUPPRESS\n         MVC   HYSUPWRK,HYSUPCNT   AND WORKING VALUE\n         SPACE\n         MVC   DARKVAL,DEFDARK+TAB3DEF+2     INIT AND DEFAULT DARK VAL\n         MVC   HDMRG,DEFHDMG+2     HEADING MARGIN\n         MVC   FTMRG,DEFFTMG+2     FOOTNOTE MARGIN\n         SPACE\n         L     R1,PACNTII          INITIAL INTEGER PART OF PAGE NUMBER\n         ST    R1,PACNTI           SET IT\n         L     R1,PACNTDI          INITIAL DECIMAL PART OF PAGE NUMBER\n         ST    R1,PACNTD           SET IT\n         MVC   PAGECNT,F1          INIT GLOBAL PAGE COUNT\n         XC    PNPREF,PNPREF       CLEAR PAGE NUMBER PREFIX\n         XC    PNSUFX,PNSUFX       CLEAR PAGE NUMBER SUFFIX\n         SPACE\n         MVC   PERIND(1),PERIND+1  WORKING CONTROL WORD SEPARATOR\n         MVC   PERNBIND(1),PERNBIND+1   WORKING NOBREAK CW INDICATOR\n         MVC   BSIND(1),BSIND+1    INITIAL USER BACKSPACE/HEX JOIN\n         MVC   BSHJ(1),BSHJ+1      AND ITS HEX JOIN ATTRIBUTE\n         MVC   TBIND(1),TBIND+1    INITIAL ADDITIONAL USER TAB\n         MVC   OCCHAR(1),OCCHAR+1  WORKING OVERLAY CHARACTER\n         XC    OCCNT,OCCNT         CLEAR OVERLAY CHAR LINE COUNT\n         SPACE\n        $CALL  UDRESET             INITIAL UNDERSCORE DEFINITION\n        $CALL  HEADCLR             INITIALIZE TITLE INFORMATION\n         LA    R1,HIDBANCH         POINT TO HIDDEN BUFFER ANCHOR\n        $CALL  HIDBDEL             INITIALIZE HIDDEN READ BUFFER\n        $CALL  DHCLR               INITIALIZE HEAD LEVEL TABLE\n         SPACE\n         LM    R1,TEMP,INDEXS      GET CONTROL WORD TABLE ADDRESSES\nENDSCN01 DS    0H\n         MVC   SPCTLW(2,R1),SPCTLI(R1)  RESET WORKING VALUE TO INITIAL\n         BXLE  R1,COUNT,ENDSCN01   GO TILL DONE\n         SPACE\n         MVC   ADJCNT(2),DEFADJ+2  SET ADJUST VALUE FOR CENTERING\n         XC    ADJCEVN,ADJCEVN     CLEAR EVEN PAGE ADJUST\n         XC    ADJCODD,ADJCODD     CLEAR ODD PAGE ADJUST\n         SPACE\n         L     R1,CWTABAD          GET ADDR OF CONTROL WORD SEP TAB\n         XC    0(256,R1),0(R1)     ZERO THE TABLE\n         MVI   C';'(R1),C';'       DEFAULT CONTROL WORD SEPARATOR\n         SPACE\n         L     R1,ESTABAD+4        GET ADDR OF INPUT ESCAPE CHAR TABLE\n         XC    0(256,R1),0(R1)     ZERO THE TABLE\n         XC    ESTABAD(4),ESTABAD  ZERO WORKING TABLE POINTER\n         SPACE\n         L     R1,CSTABAD          .CS TABLE ADDRESS\n         XC    0(L'CSTABLE,R1),0(R1)    ZERO INCLUDE STATUS\n         XC    L'CSTABLE(L'CSTABLE,R1),L'CSTABLE(R1)   AND CURRENT STAT\n         SPACE\n        $CALL  RCAINIT             INITIALIZE REV CODE STACK\n         SPACE\n         LH    R1,HDMRG            HEADING MARGIN\n         AH    R1,HSCNT            PLUS HEADING SPACE\n         CH    R1,TOPMRG           COMPARE WITH TOP MARGIN\n         BNH   ENDERR01            BRANCH IF OK\n         MVI   EFLAG041,ERRSET     ELSE SOMETHING WRONG\nENDERR01 DS    0H\n         LH    R1,FTMRG            FOOTING MARGIN\n         AH    R1,FSCNT            PLUS FOOTING SPACE\n         CH    R1,BMMRG            COMPARE WITH BOTTOM MARGIN\n         BNH   ENDERR02            BRANCH IF OK\n         MVI   EFLAG042,ERRSET     ELSE SOMETHING WRONG\nENDERR02 DS    0H\n         LH    R1,TOPMRG           TOP MARGIN\n         AH    R1,BMMRG            PLUS BOTTOM MARGIN\n         CH    R1,PLZ              COMPARE WITH PAGE LENGTH\n         BL    ENDERR03            BRANCH IF OK\n         MVI   EFLAG045,ERRSET     ELSE SET SOMETHING WRONG\n         SPACE\nENDERR03 DS    0H\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS DETECTED\n         BNZ   PARMERR             BRANCH IF YES\n         XC    ERRSTART,ERRSTART   CLEAR ERROR POINTER\n        $CC    POS                 SET SUCCESS CONDITION CODE\n*                                                                     *\n*        RETURN FROM WHENCE WE CAME                                   *\n*                                                                     *\nPARMRET  DS    0H\n        $EXIT  RC=0                AND RETURN TO CALLER\n         SPACE\nPARMERR  DS    0H\n         L     R1,PLSTSV           PARM LIST ADDR\n         L     R1,0(,R1)           GET ADDR OF ACTUAL LIST\n         LH    X1,0(,R1)           GET LENGTH OF PARM\n         STH   X1,BUFF2LGZ         SET PARM LENGTH\n         BCTR  X1,0                LENGTH-1 OF PARM\n         EX    X1,PARMIMVC         MOVE PARM TO BUFFER\n         L     X1,ERRSTART         ERROR START ADDRESS\n         SR    X1,R1               OFFSET OF ERROR\n         BCTR  X1,0                LESS LENGTH OF PARM LENGTH\n         BCTR  X1,0                DITTO\n         LA    X1,BUFF2(X1)        RELOCATED ERROR START ADDR\n         ST    X1,ERRSTART         SAVE AWAY FOR ERROR PROCESSING\n        $CC    NEG                 SET ERROR CONDITION CODE\n         B     PARMRET             AND GO TERMINATE\n         SPACE\nPARMIMVC MVC   BUFF2(*-*),2(R1)    EXECUTED MOVE PARM\n         EJECT\n*                                                                     *\n*        DATA AND WORK AREAS                                          *\n*                                                                     *\n         SPACE\nSRCOM    DC    C'.SR '             DUMMY CONTROL WORD\nIMPROF   DC    C'.IM PROFILE '     IF PROFILE OPTION SPECIFIED\n         SPACE\nERRSW    DC    X'00'               ERROR SWITCH\nERRLPRN  EQU   X'80'               LEFT PAREN SWITCH\nERREQU   EQU   X'40'               EQUAL SIGN SWITCH\nPARMEND  DC    A(*-*)              END OF PARM STRING\nPARMPACK PACK  SAVED0(8),0(*-*,X3) EXECUTED PACK\n         SPACE\nPARMJUV  DC    AL1(JUVPOS)         JUSTIFY LEFT AND RIGHT BY DEFAULT\nPARMSWCH DC    XL10'00'            WORK SWITCHES\n         SPACE\n         LTORG\n         SPACE\nCVTPTR   EQU   X'10'               CVT POINTER ADDRESS\nCVTRELNO EQU   4                   RELEASE NUMBER OFFSET FROM PREFIX\nCVTTCBP  EQU   X'00'               TCB ADDR PAIR POINTER\nCVTDCB   EQU   X'74'               OPERATING SYSTEM FLAGS\nTCBTSFLG EQU   X'94'               TIME SHARING FLAGS\nTCBTSTSK EQU   X'80'               TSO IS INITIALIZED AND READY\n         SPACE\nZDAYTAB  DS    0CL11               DAY CONVERSION TABLE\n         DC    AL1(6),C'Monday   2'\n         DC    AL1(7),C'Tuesday  3'\n         DC    AL1(9),C'Wednesday4'\n         DC    AL1(8),C'Thursday 5'\n         DC    AL1(6),C'Friday   6'\n         DC    AL1(8),C'Saturday 7'\n         DC    AL1(6),C'Sunday   1'\n         SPACE\nZFEBTAB  DC    AL1(28,28,28,29)\n         SPACE\nZMONTAB  DS    0CL13               MONTH CONVERSION TABLE\n         DC    AL1(31,7),C'January  01'\nZFEB     DC    AL1(*-*,8),C'February 02'\n         DC    AL1(31,5),C'March    03'\n         DC    AL1(30,5),C'April    04'\n         DC    AL1(31,3),C'May      05'\n         DC    AL1(30,4),C'June     06'\n         DC    AL1(31,4),C'July     07'\n         DC    AL1(31,6),C'August   08'\n         DC    AL1(30,9),C'September09'\n         DC    AL1(31,7),C'October  10'\n         DC    AL1(30,8),C'November 11'\n         DC    AL1(255,8),C'December 12'\n         EJECT\n         COPY  #OPTEST\n         SPACE\n         DROP  BASE2               DROP BASE REGISTER\n         EJECT\n         COPY  #SYSREFS\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SCRIPTRD": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x00\\xd9\\x00\\xd9\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 217, "newlines": 217, "modlines": 0, "user": "CBT249"}, "text": "         COPY  $COPYWRT\nRDSCRIPT TITLE '              READER MODULE FOR SCRIPT PROCESSOR'\n        $SCRCVT DSECT=YES,DOC=NOGEN\n         SPACE 2\n        $NSCDAT DSECT=YES,DOC=NOGEN\n         SPACE 2\n         COPY  #DSECTS\n         EJECT\n***********************************************************************\n*                                                                     *\n*              READER MODULE FOR SCRIPT PROCESSOR                     *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PRINT NOGEN               OVERALL PRINT CONTROL\nSCRIPTRD $VERSION ,\n         SPACE\n         USING DDBLOCK,RDD         POINTER TO CURRENT DDBLOCK\n         USING FILBLOCK,RFILE      POINTER TO CURRENT FILBLOCK\n         USING SCRIPTRD,BASE       LOCAL DATA\n         EJECT\n         COPY  #RDFILE\n         EJECT\n         COPY  #RDFINDF\n         EJECT\n         COPY  #RDSCANF\n         EJECT\n         COPY  #RDDDREP\n         EJECT\n         COPY  #RDPURON\n         EJECT\n         COPY  #RDPURGE\n         EJECT\n         COPY  #RDREWIN\n         EJECT\n         COPY  #RDLINE\n         EJECT\n         COPY  #RDRECD\n         EJECT\n         COPY  #RDEJCT\n         EJECT\n         COPY  #RDJIGG\n         EJECT\n         COPY  #RDPUSH\n         EJECT\n         COPY  #RDPOP\n         EJECT\n         COPY  #RDERROR\n         EJECT\n         COPY  #RDCLOSE\n         EJECT\n         COPY  #RDGBUFF\n         EJECT\n         COPY  #RDFBUFF\n         EJECT\n         COPY  #RDEXIT\n         EJECT\nSCRIPTRD CSECT ,                   AS YOU WERE\n*                                                                     *\n*  DATA AREAS                                                         *\n*                                                                     *\n         SPACE\nOPCLPARM DC    A(*-*)              PARM LIST FOR OPEN/CLOSE/RDJFCB\nOPCLOPEN OPEN  (*-*,(INPUT)),MF=L  OPEN LIST MODEL\nOPCLCLSE CLOSE (*-*),MF=L          CLOSE LIST MODEL\n         SPACE\nBLDLLIST DC    H'1,12'             PARM LIST FOR BLDL\nBLDLNAME DC    CL8'        '\nBLDLTTRK DC    XL4'00000000'\n         SPACE\nNEWDDNAM DS    CL8                 DDNAME WHICH IS BEING OPENED\nLOGDDNAM DS    CL8                 DDNAME BEFORE SUBSTITUTION\nFIRSTDD  DC    A(0,0)              -> FIRST, LAST DDBLOCK\n         SPACE\nH2000    DC    H'2000'             CONSTANT TWO THOUSAND (FOR 2321)\n         SPACE\nOPTWORK  DS    CL7                 EDIT WORK AREA\n         SPACE\nSCANFLAG DC    X'00'               FLAG FOR SCAN ROUTINE\nB$PSFRCE EQU   X'80'               FORCE DSORG=PS\nB$TERM   EQU   X'20'               THIS IS A TERMINAL FILE\n         SPACE\n         PUSH  PRINT\n         PRINT NOGEN\nSKELDCB  DCB   DDNAME=ANYNAME,DEVD=DA,MACRF=RP,DSORG=PS,               X\n               EODAD=RREOF,SYNAD=SYNAD,EXLST=RDEXLST\nDCBLEN   EQU   *-SKELDCB           LENGTH OF THE DCB\n         POP   PRINT\nDSORG$PS EQU   X'40'               DSORG=PS FLAG IN DCB\nDSORG$PO EQU   X'02'               DSORG=PO BIT\n         SPACE\n         DS    0F\nRDEXLST  DC    X'05',AL3(*-*)      OPEN EXIT ADDRESS\n         DC    X'87',AL3(JFCBAREA) JFCB READ AREA\n         SPACE\nTATABLOK DS    0F                  TEMPORARY DATA AREA\nTATALEN  DS    H                   LENGTH OF TEMPORARY DATA AREA\n         DS    H\nTATAAREA DS    CL240               AREA TO CONTAIN TEMPORARY LINE\n         SPACE\n         ORG   TATABLOK            AREA MAY BE REUSED\n         SPACE\nJFCBAREA DS    0F,CL176            AREA INTO WHICH JFCB GOES\nJFCBDSNM EQU   JFCBAREA+0          DATA SET NAME\nJFCBELNM EQU   JFCBAREA+44         ADDRESS OF MEMBER NAME\nJFCBTSDM EQU   JFCBAREA+52         JOB /DATA MANAGEMENT INTERFACE\nJFCDSORG EQU   JFCBAREA+98         DATA SET ORGANIZATION\n         SPACE\n         ORG\n         SPACE\nNEWRMQ   DC    A(*-*)              ADDRESS OF NEW REMOTE QUEUE START\nNEWDD    DC    A(*-*)              ADDRESS OF NEW DDBLOCK\nRECDADDR DC    A(*-*)              ADDRESS OF RECORD JUST READ\n         SPACE\nDWORD    DS    D                   DOUBLE WORD\n         SPACE\nZERONUMR DC    CL8'00000000'       8 BYTES WITH ZERO NUMERICS\n         SPACE\nCVTPTR   EQU   X'10'               -> CVT ADDRESS WORD\nCVTTCB   EQU   X'00'               OFFSET OF TCB PAIR ADDR IN CVT\nTCBTIO   EQU   X'0C'               -> TIOT ADDR IN THE TCB\n         DC    0D'00'\nSTATE    DC    CL8'STATE'          COMMAND\n         DC    CL8'********'       FILE NAME\n         DC    CL8'********'       FILE TYPE\nODE      DC    XL2'00'             FILE MODE\n         DC    XL2'00'             UNUSED\nAFSTCOPY DC    A(0)                ADDRESS OF FST COPY LOC\n         DC    8X'FF'              FENCE\n         SPACE\nFMSCR1   DC    CL8'SCRIPT'         PRIMARY SCRIPT TYPE\nFMSCR2   DC    CL8'SCRIPTLB'       SECONDARY SCRIPT TYPE\n         SPACE\n         DC    0D'0'\nFILEDEF  DC    CL8'FILEDEF'        COMMAND\nFDDDNAM  DC    CL8'********'       DDNAME\n         DC    CL8'DISK'\nFDNAME   DC    CL8'********'       FILENAME\nFDTYPE   DC    CL8'********'       FILETYPE\nFDMODE   DC    CL8'**'             FILEMODE\n         DC    CL8'('\n         DC    CL8'RECFM'\nFDRECFM  DC    CL8'*'\n         DC    CL8'LRECL'\nFDLRECL  DC    CL8'********'\n         DC    CL8'BLOCK'\nFDBLOCK  DC    CL8'********'\n*        DC    CL8'NOCHANGE'\n         DC    8X'FF'\nFDRECFMV EQU   C'V'                RECFM 'V'\n         SPACE\nCCHIDBUF DC    2A(0)               CARRIAGE CONTROL REC ADDR/LENGTH\n         SPACE\nRDASAPA  DC    C'1.PA  '           ASA PAGE EJECT\nRDASASP2 DC    C'-.SP 2'           ASA SPACE TWO\nRDASASP1 DC    C'0.SP 1'           ASA SPACE ONE\nRDASADC  DC    C'+.DC  '           ASA NO SPACE\n         SPACE\nRDMIPA   DC    X'8B',C'.PA  '      MACHINE EJECT IMMEDIATE\nRDMISP3  DC    X'1B',C'.SP 3'      MACHINE SPACE 3 IMMEDIATE\nRDMISP2  DC    X'13',C'.SP 2'      MACHINE SPACE 2 IMMEDIATE\nRDMISP1  DC    X'0B',C'.SP 1'      MACHINE SPACE 1 IMMEDIATE\nRDMINOP  DC    X'03',C'.CM  '      MACHINE NO-OP\n         SPACE\nRDMAPA   DC    X'89',C'.PA  '      MACHINE EJECT AFTER WRITE\nRDMASP3  DC    X'19',C'.SP 2'      MACHINE SPACE 3 AFTER WRITE\nRDMASP2  DC    X'11',C'.SP 1'      MACHINE SPACE 2 AFTER WRITE\nRDMASP1  DC    X'09',C'.CM  '      MACHINE SPACE 1 AFTER WRITE\nRDMADC   DC    X'01',C'.DC  '      MACHINE NO SPACE AFTER WRITE\n         SPACE\nRRRMBRS  DC    C'.BR'              REMOTE BREAK STRING IF 'SAVE'\n         SPACE\n         LTORG\n         EJECT\n         COPY  #DDBLOCK            DD BLOCK DEFINITION\n         EJECT\n*                                                                     *\n*  THIS BLOCK IS PASSED TO READLINE TO ASK THAT AN                    *\n*  LINE BE READ FROM THE CURRENT INPUT FILE                           *\n*                                                                     *\n         SPACE\nDATABLOK DSECT\nDATALEN  DS    H                   LENGTH OF DATAAREA\n         DS    H                   NOTE DATALEN IS SET TO LINE LENGTH\nDATAAREA DS    CL240               AREA TO CONTAIN LINE\n         SPACE 2\n*                                                                     *\n*  THIS DSECT DESCRIBES THE FILE STATUS TABLE                         *\n*                                                                     *\n         SPACE\nFST      DSECT\nFSTN     DS    CL8                 FILE NAME\nFSTT     DS    CL8                 FILE TYPE\nFSTD     DS    XL4                 DATE LAST WRITTEN\nFSTWP    DS    XL2                 POINTER TO ITEM TO BE WRITTEN\nFSTRP    DS    XL2                 POINTER TO ITEM LAST READ\nFSTM     DS    CL2                 FILE MODE\nFSTIC    DS    XL2\nFSTFCL   DS    XL2                 FIRST CHAIN LINK\nFSTFV    DS    CL1                 RECFM\nFSTFB    DS    XL1                 FLAG BYTE\nFSTIL    DS    XL4                 MAXIMUM ITEM LENGTH\nFSTDBC   DS    XL2                 NUMBER 800 BYTE BLOCKS\nFSTYR    DS    XL2                 YEAR LAST WRITTEM\n         EJECT\n*                                                                     *\n*  REGISTER DEFINITIONS                                               *\n*                                                                     *\n         SPACE\nRPARMPTR EQU   3                   SAVES POINTER TO PARM LIST\nRA       EQU   4                   WORK REGISTER\nRB       EQU   5                   WORK REGISTER\nRRMQ     EQU   7                   -> REMOTE QUEUE DESCRIPTOR\nRFILE    EQU   8                   -> CURRENT FILE BLOCK\nRDD      EQU   9                   -> CURRENT DDBLOCK\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRIPTSY": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x00+\\x00+\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "CBT249"}, "text": "         COPY  $COPYWRT\nSYSCRIPT TITLE '         SCRIPT -- SYSTEM DEPENDENT ROUTINES'\n        $SCRCVT DSECT=YES,DOC=NOGEN\n         SPACE 2\n        $NSCDAT DSECT=YES,DOC=NOGEN\n         SPACE 2\n         COPY  #DSECTS\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\n         EJECT\n***********************************************************************\n*                                                                     *\n*              SYSTEM DEPENDENT SUBROUTINES --- SCRIPTSY              *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PRINT NOGEN               OVERALL PRINT CONTROL\nSCRIPTSY $VERSION ,                IDENTIFY AND INITIALIZE\n         EJECT\n         COPY  #SYABEND\n         EJECT\n         COPY  #SYCONSW\n         EJECT\n         COPY  #SYFMAIN\n         EJECT\n         COPY  #SYGMAIN\n         EJECT\n         COPY  #SYSPIE\n         EJECT\n         COPY  #SYPUTOP\n         EJECT\n         COPY  #SYPUT\n         EJECT\n         COPY  #SYPUTCL\n         EJECT\n         COPY  #SYTEST\n         EJECT\n         COPY  #SYTIME\n         EJECT\n         COPY  #SYWTO\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SCRIPTW": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x04\\xb6\\x04\\xb6\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 1206, "newlines": 1206, "modlines": 0, "user": "CBT249"}, "text": "         COPY  $COPYWRT\nWSCRIPT  TITLE '          WATERLOO SCRIPT MAIN MODULE'\n***********************************************************************\n*        SCRIPT COMMAND MODULE                                        *\n*        WAS SPRT MODULE TO SUPPORT OLD 'PRINT' FORM OF SCRIPT.       *\n*        CHANGED 6/9/69 IN ORDER TO DELETE 'EDIT' FOR OF SCRIPT.      *\n*        SPRT ENTRY POINT CHANGED TO SCRIPT                           *\n*                                                                     *\n*        CHANGED 4/1/70 BY WC ONEY AS FOLLOWS --                      *\n*              (1) EVEN/ODD PAGE HEADINGS/FOOTINGS AND EJECTS.        *\n*              (2) FOOTNOTE CONTROL (.FN)                             *\n*              (3) CONSISTENT USE OF ASA CONTROL CHARACTERS.          *\n*              (4) EMPTY PAGE SUPPRESSION (.EM)                       *\n*              (5) LEADING BLANK LINE SUPPRESSION (.LS)               *\n*              (6) ONLINE PRINT FUNCTION (.PR)                        *\n*              (7) ONLINE READING FUNCTION (.RC)                      *\n*              (8) START AND STOP LIMITS FOR .IM AND .AP              *\n*              (9) ELIMINATION OF SEVERAL LOGIC FLAWS.                *\n*              (10) ROMAN NUMERAL PAGE NUMBERING                      *\n*              (11) REFERENCE NAME FUNCTIONS (.SR .UR 2PASS)          *\n*              (12) TRANSLATE FUNCTION (.TR)                          *\n*              (13) CONDITIONALS (.IF)                                *\n*              (14) DON'T COUNT FUNCTION (.DC)                        *\n*              (15) REMOTE SEQUENCES (.RM)                            *\n*              (16) RIGHT ADJUST FUNCTION (.RA)                       *\n***********************************************************************\n         SPACE\n***********************************************************************\n*              05-01-72 JOHN ATKINSON                                 *\n*              EXTENSIVE MODIFICATIONS WERE MADE TO REPLACE ALL OF THE*\n*              CMS I/O MACROS CALLS WITH A MINIMAL NUMBER OF OS I/O   *\n*              MACRO CALLS.  THIS WAS THE PREREQUISITE FOR ITS        *\n*              MOVE TO TSO                                            *\n*        THE FOLLOWING SECTIONS WERE REWRITTEN 05-01-72.              *\n*        (1)   SCAN OF PARAMETER LIST                                 *\n*        (2)   PROLOG-INITIALIZATION OF INPUT AND OUTPUT FILES.       *\n*        (3)   APPEND A NEW FILE (.AP)                                *\n*        (4)   IMBED AN ADDITIONAL FILE (.IM)                         *\n*        (5)   READ A CONTROL LINE (.RC)                              *\n*        (6)   READ A LINE AND TAKE NO ACTION (.RD)                   *\n*        (7)   INTERNAL FUNCTIONS SPACER,IOPRINT,READ,ERROR.          *\n*        (8)   ADDITIONAL INTERNAL FUNCTIONS OPNINPUT,CLOSFIL,SRCHSTK.*\n***********************************************************************\n         SPACE\n***********************************************************************\n*        04-01-73  W. DWYER                                           *\n*                                                                     *\n*        ALL INPUT FILE PROCESSING CODE REWRITTEN AND INCORPORATED    *\n*        INTO A SEPARATE CONTROL SECTION, 'SCRIPTRD'.                 *\n*                                                                     *\n*        THE OBJECT WAS TO MAKE THE USE OF .AP AND .IM ALMOST AS      *\n*        SIMPLE UNDER O/S AS IT WAS UNDER CMS                         *\n***********************************************************************\n         EJECT\nSCRIPTW  CSECT ,                   TO ORDER LISTING\n        $SCRCVT DSECT=NO,DOC=GEN\n         EJECT\n        $NSCDAT DSECT=NO,DOC=GEN\n         EJECT\n         COPY  #DSECTS\n         EJECT\n***********************************************************************\n*                                                                     *\n*                             INITIALIZATION                          *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PRINT NOGEN               MADNICK IS NARCISSITIC\nSCRIPTW $VERSION NAME=SCRIPT\n         SPACE\n         ENTRY MAIN,TRUEEND        SOME INTERESTING LABELS\n         SPACE\n         STM   R14,BASE,12(R13)    SAVE CALLER'S REGISTERS\n         LR    BASE,R15            TRANSFER CALLING BASE\n         USING SCRIPTW,BASE        PROGRAM BASE\n         LR    X1,R1               RETAIN PARM POINTER\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT INTERFACE\n         BAL   R14,4(,R15)         INIT SYSTEM INTERFACE CONTROL AREA\n         LR    TEMP,R13            SAVE OLD SAVE AREA ADDR\n         L     R13,=V(NSCDAT)      DATA BASE REGISTER\n         USING NSCDAT,R13          TELL THE ASSEMBLER\n         ST    R13,8(,TEMP)        BACKWARDS CHAIN POINTER\n         ST    TEMP,4(,R13)        FORWARDS CHAIN POINTER\n         LA    BASESAVE,SAVETABL   SAVE AREA STACK ADDRESS\n         ST    BASESAVE,SAVEINIT   RETAIN FOR FUTURE REFERENCE\n         SPACE\n         L     R15,=V(SCRIPTCW)    CONTROL WORD PROCESSOR\n         BALR  R14,R15             LET IT INITIALIZE\n         L     R15,=V(SCRIPTFO)    CHARACTER FORMATTER\n         BALR  R14,R15             LET IT INITIALIZE\n         L     R15,=V(SCRIPTHY)    HYPHENATION PROCESSOR\n         LTR   R15,R15             DOES IT EXIST .Q\n         BZ    *+6                 BRANCH IF NOT\n         BALR  R14,R15             LET IT INITIALIZE\n         L     R15,=V(SCRIPTMC)    COLUMN PROCESSOR\n         BALR  R14,R15             LET IT INITIALIZE\n         L     R15,=V(SCRIPTOU)    SUBROUTINE CALLS\n         BALR  R14,R15             LET IT INITIALIZE\n         L     R15,=V(SCRIPTPM)    PARM SCANNER\n         BALR  R14,R15             LET IT INITIALIZE\n         L     R15,=V(SCRIPTRD)    READ ROUTINE\n         BALR  R14,R15             LET IT INITIALIZE\n         L     R15,=V(SCRIPTSY)    SYSTEM INTERFACE ROUTINE\n         ST    R15,VSCRLAST        HIGHEST ROUTINE ADDR FOR DUMPS\n         BALR  R14,R15             LET IT INITIALIZE\n         SPACE\n         LR    R1,X1               RESTORE PARM LIST ADDR\n         ST    R1,PLSTSV           SAVE PARM LIST ADDR FOR PASS2\n         SPACE\n*  IF SUBSTITUTE DDNAME LIST IS PRESENT, ALTER OUR DCB'S              *\n         TM    0(R1),X'80'         IS THERE A SECOND PARM ADDR\n         BO    SPRT05              BRANCH OUT IF NOT\n         SPACE\n         L     X1,4(,R1)           GET ADDRESS OF SUBSTITUTION LIST\n         ST    X1,COMREPAD         STORE FOR I/O COORDINATOR\n         SPACE\n         TM    4(R1),X'80'         SECOND PARM THE LAST .Q\n         BO    SPRT05              BRANCH IF YES\n         L     TEMP,8(,R1)         GET THIRD PARM ADDRESS\n         ST    TEMP,COMPARM3       AND RETAIN FOR SUBSEQUENT USE\n        $CALL  VTRAPS              ENTER USER ROUTINES\n         BC    BPOS,SPRT05         BRANCH IF SUCCESSFUL\n         MVI   EFLAG001,ERRSET     PARM ERROR (IN EFFECT)\n         B     ERRQUIT             PRINT ERROR AND TERMINATE\nSPRT05   DS    0H\n         B     PASS2               START FIRST PASS\n         EJECT\n***********************************************************************\n*                                                                     *\n*   INITIALIZE STORAGE FOR FIRST OR SECOND PASS                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nPASS2    DS    0H\n         L     BASESAVE,SAVEINIT   INITIALIZE SAVE AREA STACK START\n        $CALL  PARMSCAN            PARM SCAN/INITIALIZE ROUTINE\n         BC    BPOS,PARMSCOK       BRANCH IF NO ERRORS\n         MVI   EFLAG001,ERRSET     SET ERROR FLAG\n         B     ERRQUIT             GO TO PRINT DIAGNOSTIC AND QUIT\n         SPACE\nPARMSCOK DS    0H\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS THE LAST PASS .Q\n         BE    SPIETEST            BRANCH IF YES\n        $OFF   SWITCHS,(NPSWS,STSWS)  NO, CLEAR PAGE XXX AND STOP\n         SPACE\nSPIETEST DS    0H\n        $IFON  SWITCHS,DBSWS,PARMPOST BRANCH IF DUMP WANTED\n         L     R1,=A(SPIEADDR)     SPIE RECOVERY ADDRESS\n        $CALL  SYSPIE              DEFINE EXIT\n         SPACE\nPARMPOST DS    0H\n        $CALL  LKINIT              INITIALIZE LINK STORAGE\n         BC    BNEG,ERRQUIT        IF ERROR, PRINT MSG AND QUIT\n         SPACE\n*   OPEN SCRIPT PRIMARY INPUT FILE NAMED 'SYSIN'                      *\n         SPACE\n         LA    R1,PRIMBLOK         TO PUT PRIMARY FILE ON INPUT LIST\n         MVC   PRIMGOTO,BLANKS     CLEAR GOTO TARGET\n         XC    PRIMARGC,PRIMARGC   CLEAR NUMBERED ARGUMENT COUNT\n         XC    PRIMFLAG,PRIMFLAG   ZERO PRIMARY INPUT FLAGS\n        $ON    PRIMFLAG,IO$IM      DO AN IMBED\n        $CALL  RDFILE              STACK AS THE FIRST FILE\n         SPACE\n         CLC   PASSNO,F1           IS THIS THE FIRST PASS .Q\n         BNE   QUIETON             BRANCH IF NOT\n        $IFON  SWITCHS,QUSWS,QUIETON    BRANCH IF QUIET MODE\n        $IFOFF TTYPE,TONLINE,QUIETON    BRANCH IF NOT ONLINE OUTPUT\n         SPACE\n         L     R1,WRKBUFFA         WORK BUFFER\n         XC    0(4,R1),0(R1)       CLEAR A RDW AREA\n         MVC   4(L'VERSN,R1),VERSN ENTER VERSION TEXT\n         LA    R0,4+L'VERSN        TOTAL LENGTH OF RESULT\n         STH   R0,0(,R1)           SET LENGTH IN RDW\n         LR    R0,R1               POINT TO RESULT\n        $CALL  PUTCONS             WRITE TO ONLINE TERMINAL\nQUIETON  DS    0H\n         SPACE\n*        OPEN THE PRIMARY OUTPUT FILE\n         SPACE\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS THE LAST PASS .Q\n         BNE   PARMMAIN            BRANCH AROUND IF NOT\n         SPACE\n         SR    R0,R0               CLEAR RDW POINTER\n        $CALL  PUTPRT              OPEN PRIMARY OUTPUT FILE\n         BC    BPOS,PARMMAIN       BRANCH IF SUCCESSFUL\n         MVI   EFLAG002,ERRTERM    TERMINAL ERROR\nERRQUIT  DS    0H\n         XC    ERCONT,ERCONT       UNABLE TO CONTINUE\n         B     ERRCHECK            GO TO PRINT DIAGNOSTIC\n         SPACE\nPARMMAIN DS    0H\n         EJECT\n***********************************************************************\n*                                                                     *\n*                             'MAIN' CONTROLLER                       *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAIN     DS    0H\n        $OFF   SWITCHS,FNOCT       CLEAR 'DON'T COUNT' SWITCH\nMAINDC   DS    0H\n         BAL   RETURN,ERRCHECK     CHECK ERROR SWITCHS\n        $IFOFF IFSTAK,IFELSE,MAIN01     BRANCH IF NOT AFTER .ELSE\n        $IFON  IFSTAK,IFDO,MAIN01  BRANCH IF IN DO GROUP\n         MVC   IFSTAK,IFSTAK+IFSTAKSP   POP THE .IF STACK\n         SPACE\nMAIN01   DS    0H\n        $CALL  READ                GET NEXT LOGICAL RECORD\n        $IFON  IFSTAK,IFDO,MAIN02  BRANCH IF WITHIN DO GROUP\n        $OFF   IFSTAK,(IFTHEN,IFELSE)   CLEAR OBJECT OF .TH AND .EL\n         SPACE\nMAIN02   DS    0H\n         LH    R1,URCNT            GET SUBSTITUTE SYMBOL COUNT\n         LTR   R1,R1               TEST WHAT IS LEFT\n         BNP   MAIN05              BRANCH IF NOTHING\n         CH    COUNT,H32767        IS THIS 'ON' CONDITION .Q\n         BE    MAIN03              BRANCH IF YES\n         BCTR  R1,0                DECREMENT REMAINDER BY ONE\nMAIN03   DS    0H\n         STH   R1,URCNT            UPDATE REMAINING COUNT\n         MVC   URMAXCNT(2),URMAXCNT+2   INITIALIZE SUBSTITUTION COUNT\nMAIN04   DS    0H\n         LA    R1,BUFF2-1          BLANK BEFORE START OF INPUT LINE\n         ST    R1,ARGSTART         POINTER TO RECORD START\n         AH    R1,BUFF2LGZ         PLUS RECORD LENGTH\n         ST    R1,ARGSTOP          STORE LAST ADDR IN RECORD\n        $CALL  UR                  PROCESS AS IF .UR COMMAND\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS .Q\n         BNZ   MAIN                BRANCH IF YES\n         LTR   R15,R15             NULL SUBSTITUTION RESULT .Q\n         BZ    MAIN                FORGET LINE IF YES\n         LH    R1,URMAXCNT         GET CURRENT SUBS LEFT\n         S     R1,F1               DECREMENT BY ONE\n         BM    MAIN06              LOOPING IF MINUS\n         STH   R1,URMAXCNT         UPDATE NUMBER LEFT\n        $IFON  SWITCHS,URSWS,MAIN04   RE-CHECK IF SUBSTITUTIONS MADE\nMAIN05   DS    0H\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS PRESENT .Q\n         BNZ   MAIN                BRANCH IF YES\n         SPACE\n         LH    R1,LICNT            GET LITERAL COUNT\n         S     R1,F1               DECREMENT BY ONE\n         BM    MAIN07              BRANCH IF NONE LEFT\n        $IFON  SWITCHS,LISWS,MAIN07     BRANCH IF LITERAL 'ON'\n         STH   R1,LICNT            UPDATE LITERAL COUNT\n         B     MAIN08              SKIP OVER TEST FOR PERIOD\n         SPACE\nMAIN06   DS    0H\n         MVI   EFLAG009,ERRSET     SET LOOPING ERROR FLAG\n         B     MAIN                AND GO BACK\n         SPACE\nMAIN07   DS    0H\n         CLI   BUFF2,C' '          FIRST CHARACTER A BLANK .Q\n         BE    MAIN08              YES, THAT'S NO CONTROL WORD\n         CLC   PERIND(1),BUFF2     FIRST CHAR CW INDICATOR .Q\n         BE    PERIOD              YES, HANDLE AS A COMMAND\n         CLC   PERNBIND(1),BUFF2   FIRST CHAR NOBREAK CW INDICATOR .Q\n         BE    PERIOD              YES, HANDLE AS A COMMAND\n         SPACE\nMAIN08   DS    0H\n        $IFON  SWITCHS,CSSWS,MAIN  FORGET IT IF IN COND SECTION\n         SPACE\n         BAL   RETURN,MAINLB       WITHIN A GOTO .Q\n         BC    BNEG,MAIN           BRANCH IF YES\n         SPACE\n        $OFF   IFSTAK,(IFCWTE,IFCWUR,IFCWIF) NOT .TH/.EL/.UR/.IF\n         BAL   RETURN,MAINIF       TEST INCLUSION\n         BC    BNEG,MAIN           BRANCH IF TO BE OMITTED\n         SPACE\n         BAL   RETURN,MAINES       GO CHECK FOR INPUT ESCAPE CHARS\n         BAL   RETURN,MAINBK       GO CHECK FOR USER BKSP AND HEX JOIN\n         BAL   RETURN,MAINTB       CHECK FOR USER TAB CHARACTERS\n         BAL   RETURN,MAINOI       PROCESS OVERLAY INPUT\n         SPACE\n         BAL   RETURN,MAINUHY      TEST USER HYPHENATIONS\n         SPACE\n         OC    OCCNT,OCCNT         OVERLAY CHARACTER COUNT ZERO .Q\n         BZ    MAIN09              BRANCH IF YES\n        $CALL  MAINOC              PERFORM THE OPERATION\n         SPACE\nMAIN09   DS    0H\n         LA    TEMP,BUFF2          FIRST CHAR OF INPUT\n         AH    TEMP,BUFF2LGZ       LAST CHAR +1 OF STRING\nMAIN10   DS    0H\n         BCTR  TEMP,0              LAST CHAR OF STRING\n         CLI   0(TEMP),C' '        A BLANK .Q\n         BE    MAIN11              BRANCH IF YES\n         CLI   0(TEMP),X'16'       A BACKSPACE .Q\n         BNE   MAIN13              BRANCH IF NOT\n         MVI   0(TEMP),C' '        REPLACE WITH A BLANK\nMAIN11   DS    0H\n         LH    R1,BUFF2LGZ         LENGTH OF STRING\n         S     R1,F1               LESS ONE\n         BNP   MAIN12              BRANCH IF NOTHING LEFT\n         STH   R1,BUFF2LGZ         UPDATE LENGTH\n         B     MAIN10              LOOP BACK AND TRY AGAIN\n         SPACE\nMAIN12   DS    0H\n         MVC   BUFF2(1),PERIND     ENTER CONTROL WORD INDICATOR\n         MVC   BUFF2+1(L'MNSIG),MNSIG   ADD SIGNAL CW AND OPERAND\n         LA    TEMP,L'MNSIG+1      LENGTH OF RESULT\n         STH   TEMP,BUFF2LGZ       ENTER LENGTH TO REPLACE BLANK LINE\n        $CALL  ARGINIT             INITIALIZE COMMAND POINTERS\n        $CALL  SITST               IS THERE SUCH A REMOTE .Q\n         BC    BOMIT,PERIOD        PROCESS SIGNAL IF YES\n         MVC   BUFF2(1),PERIND     ENTER CONTROL WORD INDICATOR\n         MVC   BUFF2+1(L'MNSKIP),MNSKIP ADD SKIP CONTROL WORD\n         LA    TEMP,L'MNSKIP+1     LENGTH OF RESULT\n         STH   TEMP,BUFF2LGZ       ENTER LENGTH TO REPLACE BLANK LINE\n        $CALL  ARGINIT             INITIALIZE COMMAND POINTERS\n         B     PERIOD              AND PROCESS THE COMMAND\nMNSIG    DC    C'SI SYSBLANK'      BLANK INPUT LINES FIRST DO THIS\nMNSKIP   DC    C'SK'               BLANK INPUT LINES NEXT DO THIS\n         SPACE\nMAIN13   DS    0H\n         L     X1,RCAREAAD         REVISION CODE WORK AREA\n         LTR   X1,X1               DOES ANY EXIST .Q\n         BZ    MAIN14              BRANCH IF NOT\n         USING RCAREA,X1           AREA LOOKS LIKE THIS\n         LH    R1,RCANFCNT         GET REMAINING ON/OFF COUNT\n         S     R1,F1               DECREMENT BY ONE\n         BM    MAIN14              BRANCH IF NOTHING THERE\n         STH   R1,RCANFCNT         SET NEW COUNT REMAINING\n         BNZ   MAIN14              BRANCH IF NOT THE LAST\n        $CALL  RCOFF               TURN OFF CURRENT RC\n         DROP  X1\n         SPACE\nMAIN14   DS    0H\n         CLI   BUFF2,C' '          IS FIRST CHAR A BLANK .Q\n         BE    BRKCHAR             YES, DON'T FILL AUTOMATICALLY\n         CLI   BUFF2,X'05'         IS FIRST CHAR A TAB .Q\n         BE    BRKCHAR             YES, DON'T FILL AUTOMATICALLY\n        $IFOFF SWITCHS,MASWS,NBRKCHAR CLEAR NOW IF NOT 'MARK' OPTION\n         CLI   BUFF2+1,X'16'       ALREADY DOUBLE CHARACTER .Q\n         BE    NBRKCHAR            YES, DON'T ADD ANY MORE\n         L     R1,BUFF3AD          TEMPORARY WORK BUFFER ADDR\n         MVC   4(B2LG,R1),BUFF2    SAVE ACTIVE BUFFER\n         MVC   BUFF2(2),=X'6D16'   UNDERSCORE BACKSPACE AT START\n         MVC   BUFF2+2(B2LG),4(R1) ADD THE ORIGINAL TEXT\n         LH    TEMP,BUFF2LGZ       GET LENGTH AGAIN\n         LA    TEMP,2(,TEMP)       BUMP BY TWO\n         STH   TEMP,BUFF2LGZ       UPDATE WITH NEW LENGTH\n         B     NBRKCHAR            NO BREAK CHARACTER\n         SPACE\nBRKCHAR  DS    0H\n        $ON    SWITCHS,JUADSWS     FORCE JUSTIFICATION AND OUTPUT\n        $CALL  PRINTNB             CLEAR OUT PRINT BUFFER\n         SPACE\nNBRKCHAR DS    0H\n         BAL   RETURN,MAINPI       PROCESS PARAGRAPH INDENT\n         BAL   RETURN,MAINHI       PROCESS HANGING INDENT\n         SPACE\n         LH    TEMP,BUFF2LGZ       SET LENGTH WITH LEADING BLANK\n         LA    TEMP,1(0,TEMP)      ..\n         ST    TEMP,PTCHLNG        ..\n         SPACE\n         LA    R1,PARMPUT          LINK UP NEW LINE\n        $CALL  LKPUT               WITH THE CURRENT\n         SPACE\n         LA    R1,LINKPARM         MERGE WITH OLD LINE, IF ANY\n        $CALL  MERGE               DO THE MERGE\n         SPACE\n         LH    TEMP,CECNT          GET .CE/.LA/.RA COUNT\n         LTR   TEMP,TEMP           ANY OUTSTANDING REQUESTS .Q\n         BNP   TFI                 BRANCH AROUND IF NOT\n         BCTR  TEMP,0              YES, DECREMENT COUNTER BY ONE\n         STH   TEMP,CECNT          UPDATE COUNTER\nTCERI01  DS    0H\n        $IFON  SWITCHS,CESWS,TCERI02    BRANCH IF CENTRE IS ON\n        $IFOFF SWITCHS,RASWS,DOPR  BRANCH IF NOT RIGHT ADJUST\n        $CALL  RIGHTAD             RIGHT ADJUST THE LINE\n         B     TCERI03             GO PRINT RIGHT FORMATTED LINE\nTCERI02  DS    0H\n        $CALL  CENTER              CENTRE THE LINE\nTCERI03  DS    0H\n        $CALL  PRINT               CLEAR THE PRINT BUFFER\n         LA    R1,LINKPARM         POINT TO PARM AREA\n        $CALL  MERGE               MERGE THE REMAINDER\n         OC    OLDCOUNT,OLDCOUNT   WAS THERE ANY REMAINDER LEFT .Q\n         BNZ   TCERI01             YES, PROCESS IT TOO\n         B     MAIN                NO, GET NEXT LINE\n         SPACE\nTFI      DS    0H\n        $IFON  SWITCHS,NFSWS,TAD   BRANCH IF IN 'NOFILL' MODE\n        $IFON  SWITCHS,FNOCT,DOPR  BRANCH IF DON'T COUNT MODE\n         SPACE\n         OC    PTELLNG,PTELLNG     ANY RESIDUE (LINE EXCEEDED) .Q\n         BZ    MAIN                NO, GET ANOTHER LINE\n         SPACE\nTAD      DS    0H\n         CLI   JUVAL,JUVNEG        'NO JUSTIFY' MODE .Q\n         BE    DOPR                BRANCH IF YES\n        $ON    SWITCHS,JUADSWS     ELSE PRINT WILL JUSTIFY CURRENT LINE\n         SPACE\nDOPR     DS    0H\n        $CALL  PRINT               CLEAR THE PRINT BUFFER\n        $OFF   SWITCHS,JUADSWS     CLEAR JUSTIFY CURRENT LINE SWITCH\n         LA    R1,LINKPARM         POINT TO PARM AREA\n        $CALL  MERGE               MERGE THE REMAINDER\n         OC    PTELLNG,PTELLNG     WAS THERE ANY REMAINDER LEFT .Q\n         BNZ   TFI                 YES, PROCESS IT\n         B     MAIN                NO, GET NEXT LINE\n         EJECT\n***********************************************************************\n*                                                                     *\n*              PRODUCE ALL ERROR DIAGNOSTICS HERE (SOME DAY)          *\n*                                                                     *\n***********************************************************************\n         SPACE\nERRCHECK DS    0H\n         OC    ERRFLGS,ERRFLGS     ANY ERRORS SET .Q\n         BZ    ERRCK01             BRANCH IF NONE\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n        $CALL  ERROUT              PRINT DIAGNOSTIC(S)\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\nERRCK01  DS    0H\n         XC    ERRSTART,ERRSTART   CLEAR ERROR COLUMN\n         BR    RETURN              RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*              USER BACKSPACE AND HEX JOIN                            *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAINBK   DS    0H\n         CLI   BSIND,C' '          BLANK FOR BACKSPACE .Q\n         BE    MAINBK04            YES, QUIT NOW\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         LA    R1,BUFF2-1          BEFORE FIRST CHAR OF INPUT STRING\n         LH    COUNT,BUFF2LGZ      LENGTH OF INPUT STRING\n         MVC   MAINBKCL+1(1),BSIND COS 'CLI' BEATS 'CLC'\n         L     R15,HEXTABAD        HEX TRANSLATE TABLE\n         XC    DECM,DECM           PREPARE FOR HEX CONVERSIONS\n         SPACE\nMAINBK01 DS    0H\nMAINBKCL CLI   1(R1),*-*           USER BACKSPACE CHAR .Q\n         BNE   MAINBK02            BRANCH IF NOT\n         MVI   1(R1),X'16'         REPLACE WITH REAL BACKSPACE\n         CLI   BSHJ,YNHJ           HEX JOIN OPTION IN EFFECT .Q\n         BNE   MAINBK02            BRANCH IF NOT\n         MVC   DECM+3(1),0(R1)     CHAR BEFORE BACKSPACE\n         TR    DECM+3(1),0(R15)    HEX EQUIVALENT\n         CLI   DECM+3,15           NOT A HEX CHAR .Q\n         BH    MAINBK02            BRANCH IF NOT\n         MVC   DECM+7(1),2(R1)     SECOND CHARACTER\n         TR    DECM+7(1),0(R15)    HEX EQUIVALENT\n         CLI   DECM+7,15           NOT A HEX CHAR .Q\n         BH    MAINBK02            BRANCH IF NOT\n         L     R0,DECM             FIRST HEX DIGIT\n         SLL   R0,4                IN ITS PROPER PLACE\n         A     R0,DECM+4           PLUS SECOND HEX DIGIT\n         STC   R0,0(,R1)           REPLACE IN THE INPUT STRING\n         LH    TEMP,BUFF2LGZ       LENGTH OF STRING\n         S     TEMP,F2             LENGTH-2\n         STH   TEMP,BUFF2LGZ       NEW LENGTH OF STRING\n         LA    TEMP,BUFF2(TEMP)    NEW END OF STRING\n         SR    TEMP,R1             LENGTH OF THE REMAINDER\n         EX    TEMP,MAINBKMV       MOVE OVER THE REMAINDER\n         B     MAINBK03            DON'T BUMP CHAR POINTER\nMAINBK02 DS    0H\n         LA    R1,1(,R1)           POINT TO NEXT CHAR\nMAINBK03 DS    0H\n         S     COUNT,F1            ONE CHARACTER MORE DONE\n         BP    MAINBK01            GO TILL DONE\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\nMAINBK04 DS    0H\n         BR    RETURN              AND RETURN TO CALLER\n         SPACE\nMAINBKMV MVC   1(*-*,R1),3(R1)     MOVE OVER BACKSPACE.HEX\n         EJECT\n***********************************************************************\n*                                                                     *\n*              ESCAPE CHARACTER ON INPUT                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAINES   DS    0H\n         L     R15,ESTABAD         ESCAPE SYMBOL TABLE ADDRESS\n         LA    R15,0(,R15)         CLEAR ESCAPE CHARACTER\n         LTR   R15,R15             IS THERE ANY ESCAPE CHAR .Q\n         BZ    MAINES03            BRANCH IF NOT\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         LA    R1,BUFF2            FIRST CHAR OF INPUT STRING\nMAINES01 DS    0H\n         LA    TEMP,BUFF2          FIRST CHAR OF INPUT STRING\n         AH    TEMP,BUFF2LGZ       LAST CHAR OF STRING +1\n         SR    TEMP,R1             LENGTH OF STRING REMAINDER\n         BNP   MAINES02            BRANCH IF AT THE END\n         BCTR  TEMP,0              LENGTH -1 OF REMAINDER\n         EX    TEMP,TESTESC        TEST FOR ESCAPE CHAR\n         BZ    MAINES02            BRANCH IF NO ESCAPE FOUND\n         LA    TEMP,BUFF2          FIRST CHAR OF STRING\n         AH    TEMP,BUFF2LGZ       LAST CHAR OF STRING +1\n         BCTR  TEMP,0              DECREMENT TO THE LAST\n         CR    TEMP,R1             IS ESCAPE LAST CHAR .Q\n         BNH   MAINES02            FORGET REPLACEMENT IF YES\n         LH    TEMP,BUFF2LGZ       LENGTH OF STRING\n         BCTR  TEMP,0              LENGTH -1\n         STH   TEMP,BUFF2LGZ       NEW LENGTH OF STRING\n         LA    TEMP,BUFF2(TEMP)    END OF STRING\n         SR    TEMP,R1             LENGTH OF REMAINDER\n         EX    TEMP,TESTMVC        MOVE OVER REMAINDER\n         L     TEMP,TRANADI        INPUT TRANSLATE TABLE\n         TR    0(1,R1),0(TEMP)     TRANSLATE CHAR AFTER ESCAPE\n         LA    R1,1(,R1)           BUMP OVER TRANSLATED CHARACTER\n         B     MAINES01            LOOK FOR NEXT\nMAINES02 DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\nMAINES03 DS    0H\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nTESTESC  TRT   0(*-*,R1),0(R15)    EXECUTED SEARCH FOR ESCAPE\nTESTMVC  MVC   0(*-*,R1),1(R1)     EXECUTED MOVE OVER ESCAPE\n         EJECT\n***********************************************************************\n*                                                                     *\n*              OVERLAY INPUT RECORD                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAINOI   DS    0H\nMAINOI01 DS    0H\n         L     X1,OIANCH           OVERLAY INPUT ANCHOR\n         LTR   X1,X1               ANYTHING THERE .Q\n         BZ    MAINOI06            BRANCH IF NONE\n         USING OODSECT,X1          TELL THE ASSEMBLER\n         L     COUNT,OOQCNT        GET OVERLAY COUNT LEFT\n         S     COUNT,F1            DECREMENT BY ONE\n         BNM   MAINOI02            BRANCH IF SOME LEFT\n        $SAVE ,                    SAVE CALLER'S REGISTERS\n         LA    R1,OIANCH-OOQFCHN+OODSECT     ANCHOR POINTER\n        $CALL  OVREMOV             DELETE EMPTY ELEMENT\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         B     MAINOI01            AND TRY AGAIN\n         SPACE\nMAINOI02 DS    0H\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         ST    COUNT,OOQCNT        UPDATE COUNT LEFT\n         LH    COUNT,OOQRDW        LENGTH OF OVERLAY LINE\n         LTR   COUNT,COUNT         ANY ARG PRESENT .Q\n         BNP   MAINOI05            BRANCH IF NONE\n         CH    COUNT,BUFF2LGZ      IS OVERLAY LONGER .Q\n         BNH   MAINOI03            BRANCH IF NOT\n         STH   COUNT,BUFF2LGZ      NEW LENGTH SAME AS OVERLAY\nMAINOI03 DS    0H\n         LA    R1,BUFF2-1(COUNT)   INPUT CHARACTER ADDRESS\n         CLI   0(R1),C' '          BLANK IN INPUT .Q\n         BNE   MAINOI04            BRANCH IF NOT\n         IC    R1,OOQDATA-1(COUNT) OVERLAY CHARACTER\n         STC   R1,BUFF2-1(COUNT)   ADD TO INPUT TEXT\nMAINOI04 DS    0H\n         BCT   COUNT,MAINOI03      DO ALL CHARACTERS IN INPUT\n         SPACE\nMAINOI05 DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         SPACE\nMAINOI06 DS    0H\n         BR    RETURN              RETURN TO CALLER\n         DROP  X1\n         EJECT\n***********************************************************************\n*                                                                     *\n*              PARAGRAPH INDENT ON INPUT                              *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAINPI   DS    0H\n         LH    R15,PICNT           GET PARAGRAPH INDENT VALUE\n         LTR   R15,R15             ANY VALUE PRESENT .Q\n         BNP   MNPI05              RETURN IF NOT\n         LH    R15,CECNT           GET .CE/.LA/.RA COUNT\n         LTR   R15,R15             ANY OUTSTANDING REQUESTS .Q\n         BP    MNPI05              RETURN IF YES\n        $IFON  SWITCHS,FNOCT,MNPI05     BRANCH IF DON'T COUNT\n        $IFON  SWITCHS,NFSWS,MNPI05     BRANCH IF NOFILL MODE\n         L     R15,OLDCOUNT        CHARACTER COUNT LEFT TO FORMAT\n         LTR   R15,R15             ANYTHING PRESENT .Q\n         BNZ   MNPI05              BRANCH IF NOT AFTER A BREAK\n         CLI   BUFF2,X'05'         1ST CHARACTER A TAB .Q\n         BE    MNPI05              FORGET INDENT IF YES\n        $SAVE  ,                   SAVE CALLER'S REGISTERS\n         L     R15,BUFF3AD         WORK BUFFER ADDRESS\n         LH    COUNT,BUFF2LGZ      LENGTH OF RECORD\n         LTR   COUNT,COUNT         TEST LENGTH\n         BNP   MNPI04              GO TO RETURN IF NOTHING\n         LA    R0,B2LG             MAXIMUM RECORD LENGTH\n         LR    R1,COUNT            LENGTH OF REMAINDER\n         AH    R1,PICNT            PLUS PARAGRAPH INDENT\n         CR    R1,R0               TOO BIG .Q\n         BNH   MNPI00              BRANCH IF NOT\n         MVI   EFLAG044,ERRWARN    RESULT RECORD WOULD OVERFLOW\n         B     MNPI04              GO TO RETURN\nMNPI00   DS    0H\n         EX    COUNT,MAINPISV      SAVE AWAY RECORD\n         LH    R1,PICNT            PARAGRAPH INDENT COUNT\n         EX    R1,MAINPICL         CLEAR INDENT AMOUNT\n         LA    TEMP,BUFF2(R1)      TARGET OF RESULT\nMNPI01   DS    0H\n         CLI   4(R15),C' '         BLANK IN BUFFER .Q\n         BNE   MNPI03              BRANCH IF NOT\n         BCT   COUNT,MNPI02        DECREMENT INPUT RECORD LENGTH\n         B     MNPI03              BUT DON'T FALL OFF THE FRONT\nMNPI02   DS    0H\n         LA    R15,1(,R15)         BUMP INPUT POINTER\n         BCT   R1,MNPI01           UP TO INDENT VALUE\nMNPI03   DS    0H\n         EX    COUNT,MAINPIRE      RESTORE REST OF BUFFER\n         AH    COUNT,PICNT         NEW STRING LENGTH\n         STH   COUNT,BUFF2LGZ      SET NEW LENGTH\nMNPI04   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\nMNPI05   DS    0H\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nMAINPISV MVC   4(*-*,R15),BUFF2    EXECUTED SAVE RECORD\nMAINPICL MVC   BUFF2(*-*),BLANKS   EXECUTED CLEAR RECORD START\nMAINPIRE MVC   0(*-*,TEMP),4(R15)  EXECUTED RESTORE RECORD\n         EJECT\n***********************************************************************\n*                                                                     *\n*              HANGING INDENT ON INPUT                                *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAINHI   DS    0H\n         OC    HICNT,HICNT         ANY HANGING INDENT DEFINED .Q\n         BZ    MNHI03              BRANCH IF NOT\n         OC    OFFLI,OFFLI         IS USER OFFSET OUTSTANDING .Q\n         BNZ   MNHI03              YES, FORGET THE AUTOMATIC\n         SPACE\n        $SAVE ,                    SAVE CALLER'S REGISTERS\n         LH    COUNT,HICNT         GET HANGING INDENT\n         C     COUNT,LLZ           COMPARE WITH LINE LENGTH\n         BH    MNHI01              TOO BIG IF GREATER\n         LH    TEMP,INDL           CLEAR OFFSET\n         SH    TEMP,OFFL            ..\n         STH   TEMP,INDL           ADJUST INDENTATION\n         SH    TEMP,UNDL           ..\n         BM    MNHI01              ERROR IF TOO BIG\n         STH   TEMP,RMARGIN        SET INDENTATION\n         STH   COUNT,OFFL          SET CURRENT VALUE\n         STH   COUNT,OFFLI         SET NEXT OFFSET VALUE\n         STH   COUNT,OFUNCNT       SET MARGIN VALUE FOR FORMAT\n         B     MNHI02              GO TO RETURN\nMNHI01   DS    0H\n         MVI   EFLAG016,ERRSET     HANGING INDENT FAILED\nMNHI02   DS    0H\n        $RESTOR ,                  RESTORE CALLER'S REGISTERS\n         SPACE\nMNHI03   DS    0H\n         BR    RETURN              AND RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*              USER TAB CHARACTER                                     *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAINTB   DS    0H\n         CLC   TBIND,TBIND+1       DEFAULT TAB CHARACTER .Q\n         BE    MAINTB02            YES, QUIT NOW\n         CLI   TBIND,C' '          BLANK FOR A TAB .Q\n         BE    MAINTB02            YES, QUIT NOW AGAIN\n         SPACE\n        $SAVE  ,                   SAVE CALLER'S REGS\n         L     X1,TRINITAD         IDENTITY TRANSLATE TABLE\n         SR    R1,R1               CLEAR WORK REG\n         IC    R1,TBIND            USER TAB CHARACTER\n         LA    R0,X'05'            THIS IS A REAL TAB\n         STC   R0,0(R1,X1)         ZAP IDENTITY TRANS TABLE\n         LH    COUNT,BUFF2LGZ      LENGTH OF INPUT STRING\n         S     COUNT,F1            LENGTH-1\n         BM    MAINTB01            BRANCH IF NOTHING\n         EX    COUNT,MAINTBTR      USER TABLE TO REAL TABS\nMAINTB01 DS    0H\n         STC   R1,0(R1,X1)         RESTORE IDENTITY TRANS TABLE\n        $RESTOR ,                  RESTORE CALLER'S REGS\n         SPACE\nMAINTB02 DS    0H\n         BR    RETURN              RETURN TO CALLER\n         SPACE\nMAINTBTR TR    BUFF2(*-*),0(X1)    USER TABS TO REAL TABS\n         EJECT\n***********************************************************************\n*                                                                     *\n*              'USER HYPHENATION' CHECK                        SOCOL  *\n*                                                                     *\n***********************************************************************\n         SPACE\nMAINUHY  DS    0H\n        $IFON  SWITCHS,NFSWS,MNUHY01    BRANCH IF NO FORMAT MODE\n         LH    TEMP,CECNT          GET .CE/.LA/.RA COUNT\n         LTR   TEMP,TEMP           ANY OUTSTANDING REQUESTS .Q\n         BP    MNUHY01             RETURN IF YES\n         LA    TEMP,HYUSER         USER HYPHENATION CODE\n         C     TEMP,HYLEVEL        IS THAT OUR CURRENT LEVEL .Q\n         BNE   MNUHY01             BRANCH IF NOT\n         LH    TEMP,BUFF2LGZ       LENGTH OF STRING\n         S     TEMP,F2             LENGTH LESS TWO\n         BM    MNUHY01             BRANCH IF NOT AT LEAST TWO LONG\n         LA    TEMP,BUFF2(TEMP)    POINT TO SECOND LAST CHARACTER\n         CLI   0(TEMP),C'A'-X'40'  COMPARE WITH LOWER 'A'\n         BL    MNUHY01             IF LESS, CANNOT BE A WORD\n         CLI   0(TEMP),C'Z'        COMPARE WITH UPPER 'Z'\n         BH    MNUHY01             IF MORE, CANNOT BE A WORD\n         CLI   1(TEMP),HYACHAR     IS LAST CHAR AN ACTUAL HYPHEN .Q\n         BNE   MNUHY01             BRANCH IF NOT\n         MVI   1(TEMP),HYUCHAR     MAKE IT INTERNAL HYPHEN CHARACTER\nMNUHY01  DS    0H\n         BR    RETURN              AND RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*              'PERIOD' --- PROCESS PRINT CONTROLS                    *\n*                                                                     *\n***********************************************************************\n         SPACE\nPERIOD   DS    0H\n        $IFON  SWITCHS,NCSWS,MAIN08  BRANCH IF CONTROLS TO BE IGNORED\n        $IFOFF SWITCHS,LISWS,PERNOLI BRANCH IF NOT LITERAL 'ON'\n         L     R1,BUFF3AD          POINT TO WORK BUFFER\n         MVC   0(B2LG+4,R1),BUFF2LGZ    SAVE ENTIRE INPUT LINE\n         SPACE\nPERNOLI  DS    0H\n         L     R1,CWTABAD          GET ADDR OF CONTROL WORD SEP TABLE\n         LH    X2,BUFF2LGZ         GET LENGTH OF INPUT\n         BCTR  X2,0                DECREMENT LENGTH BY ONE\n         EX    X2,TESTCW           TEST FOR CONTROL WORD SEPARATOR\n         BZ    PEREND              BRANCH IF NONE FOUND\n         LR    X3,R1               POINT TO FOUND SEPARATOR\n         MVI   0(X3),C' '          REPLACE CONTROL SEPARATOR BY BLANK\n         BL    CWFOUND             BRANCH IF MIDST ON INPUT LINE\n         STH   X2,BUFF2LGZ         REDUCE LENGTH AND IGNORE\n         B     PEREND              AND CONTINUE\n         SPACE\nCWFOUND  DS    0H\n         LA    X1,BUFF2            START OF INPUT AREA\n         SR    X1,X3               NEGATIVE LENGTH\n         LPR   X1,X1               MAKE IT POSITIVE\n         STH   X1,BUFF2LGZ         SET NEW LENGTH\n         SR    X2,X1               LENGTH OF REMAINDER\n         LA    R1,1(,X3)           SAVE DATA FROM HERE\n         LR    TEMP,X2             LENGTH OF AREA TO SAVE\n         BCTR  TEMP,0              LENGTH-1 OF AREA TO SAVE\n        $IFON  SWITCHS,LISWS,PERCWLI    BRANCH IF LITERAL 'ON'\n        $CALL  HIDBADD             SAVE AREA IN READ STACK\nPERCWLI  DS    0H\n         EX    X2,BLNKREST         BLANK REST OF INPUT\n         SPACE\nPEREND   DS    0H\n         BAL   RETURN,MAINES       GO CHECK FOR INPUT ESCAPE CHARS\n         BAL   RETURN,MAINBK       GO CHECK FOR USER BKSP AND HEX JOIN\n         BAL   RETURN,MAINTB       CHECK FOR USER TAB CHARACTERS\n         SPACE\n        $CALL  ARGINIT             SETUP FOR FIRST ARGUMENT\n         L     X1,ARGSTART         RETAIN FIRST ARG START ADDR\n         LTR   TEMP,TEMP           ANYTHING THERE BUT INDICATOR .Q\n         BZ    PERNRM              NOT REMOTE IF YES\n         CLC   0(1,COUNT),1(COUNT) DOUBLE INDICATOR .Q\n         BE    PERNAT              YES, ONLY NATIVE CONTROL WORDS\n         LA    R0,L'APIMNAME       MAXIMUM REMOTE NAME LENGTH\n         CR    TEMP,R0             TOO BIG TO TEST .Q\n         BH    PERRMOK             YES, LET IT THROUGH\n         LA    TEMP,RMNAMLEN-1(TEMP)    NAME LENGTH DEFINED ENTRY\n         CLI   0(TEMP),RMNAMDEF    ANY REMOTES OF LENGTH DEFINED .Q\n         BNE   PERNRM              BRANCH IF NOT\nPERRMOK  DS    0H\n        $IFON  SWITCHS,LISWS,PERNRM     BRANCH IF LITERAL 'ON'\n         CLI   1(COUNT),C'*'       START OF ASSEMBLER COMMENT .Q\n         BNE   PERNCMT             BRANCH IF NOT\n         CLI   2(COUNT),C' '       AND ONLY THAT .Q\n         BE    PERNRM              BRANCH IF YES\nPERNCMT  DS    0H\n         LA    R0,1(,COUNT)        POINT PAST INDICATOR\n         ST    R0,ARGSTART         SCAN NAME FROM THERE\n        $CALL  SITST               TEST AS A REMOTE NAME\n         BC    15-BOMIT,PERNRM     BRANCH IF NOT FOUND\n        $IFON  SWITCHS,CSSWS,MAIN  FORGET IT IF IN COND SECTION\n         SPACE\n         BAL   RETURN,MAINLB       WITHIN A GOTO .Q\n         BC    BNEG,MAIN           BRANCH IF YES\n         SPACE\n        $OFF   IFSTAK,(IFCWTE,IFCWUR,IFCWIF) NOT .TH/.EL/.UR/.IF\n         BAL   RETURN,MAINIF       TEST INCLUSION\n         BC    BNEG,MAIN           BRANCH IF TO BE OMITTED\n        $CALL  SIS                 SIGNAL IF OK\n         B     MAIN                AND CONTINUE\n         SPACE\nPERNAT   DS    0H\n         LA    COUNT,1(,COUNT)     POINT TO SECOND INDICATOR\n         CLC   0(1,COUNT),1(COUNT) ALTERNATE .LB .Q\n         BNE   PERNRM              BRANCH IF NOT\n         LA    X1,2(,COUNT)        ARGUMENT STARTS HERE\n         MVC   RMCW(2),=C'LB'      CHANGE TO EXPRESSABLE FORM\n         CLC   1(1,COUNT),2(COUNT) NATIVE ALTERNATE .LB .Q\n         BNE   PERNNUL             BRANCH IF NOT\n         LA    X1,3(,COUNT)        ARGUMENT STARTS HERE\n         B     PERNNUL             AND CONTINUE\n         SPACE\nPERNRM   DS    0H\n         MVC   RMCW(2),1(COUNT)    ALIGN CONTROL WORD\n         OC    RMCW(2),BLANKS      CONVERT TO UPPER CASE\n         CLI   RMCW,C' '           NULL CONTROL WORD .Q\n         BNE   PERNNUL             BRANCH IF NOT\n         MVC   RMCW(2),=C'NL'      CHANGE TO EXPRESSABLE FORM\nPERNNUL  DS    0H\n         ST    X1,ARGSTART         RESET FIRST ARG POINTER\n         LH    R0,RMCW             TEST VIA REGISTER\n         LM    X1,X3,INDEXS        SET INDEXS\nPERLOP   DS    0H\n         CH    R0,SPCTLW(,X1)      DOES CONTROL WORD MATCH .Q\n         BE    MATCH               BRANCH IF YES\n         BXLE  X1,X2,PERLOP        NO, TRY AGAIN\n        $IFON  SWITCHS,LISWS,PERLI BRANCH IF LITERAL 'ON'\n         CLI   1(COUNT),C'*'       ASSEMBLER TYPE COMMENT .Q\n         BNE   PERERR              IF NOT, AN ERROR\n         SPACE\n         L     X1,HIDBANCH         POINT TO HIDDEN BUFFER\n         USING HIDB,X1             AREA LOOKS LIKE THIS\n         LTR   X1,X1               ANY HIDDEN BUFFER PRESENT .Q\n         BZ    PERACMT             BRANCH IF NOT\n         USING HIDB,X1             AREA LOOKS THIS WAY\n         XC    HIDBLEN,HIDBLEN     ZERO LENGTH OF ANY REMAINING DATA\nPERACMT  DS    0H\n         B     MAIN                FULL LINE COMMENT ACCEPTED\n         SPACE\nPERERR   DS    0H\n        $IFON  SWITCHS,LISWS,PERLI BRANCH IF LITERAL 'ON'\n        $IFON  SWITCHS,CSSWS,MAIN  FORGET IT IF IN COND SECTION\n         BAL   RETURN,MAINLB       WITHIN A GOTO .Q\n         BC    BNEG,MAIN           BRANCH IF YES\n         MVI   EFLAG004,ERRSET     ILLEGAL CONTROL WORD\n         B     MAIN                AND CONTINUE\n         SPACE\nPERLI    DS    0H\n         L     R1,BUFF3AD          ORIGINAL WORK BUFFER\n         MVC   BUFF2LGZ(B2LG+4),0(R1)   RESTORE ORIGINAL LINE\n        $IFOFF SWITCHS,LISWS,MAIN07     PROCESS AS COMMAND\n         B     MAIN08              REPROCESS AS DATA\n         SPACE\nMATCH    DS    0H\n         LH    TEMP,SPCTLC(,X1)    GET CURRENT USE COUNT\n         LA    TEMP,1(,TEMP)       BUMP BY ONE\n         STH   TEMP,SPCTLC(,X1)    UPDATE WITH RESULT\n         SPACE\n        $OFF   IFSTAK,(IFCWTE,IFCWUR,IFCWIF) NOT .TH/.EL/.UR/.IF\n         LH    TEMP,SPCTLO(,X1)    OFFSET OF ROUTINE\n        $IFOFF SWITCHS,LISWS,MATCHUR    BRANCH IF NOT LITERAL 'ON'\n         CH    TEMP,=AL2(VLI-SCRICVT)   IS THIS '.LI' .Q\n         BNE   PERLI               BRANCH IF NOT\n         B     MATCHDN             CONTINUE\n         SPACE\nMATCHUR  DS    0H\n         CH    TEMP,=AL2(VUR-SCRICVT)   IS THIS .UR .Q\n         BNE   MATCHTH             BRANCH IF NOT\n        $ON    IFSTAK,IFCWUR       TURN ON .UR SWITCH\n         B     MATCHDN             AND GO CHECK\nMATCHTH  DS    0H\n         CH    TEMP,=AL2(VTH-SCRICVT)   IS THIS .TH .Q\n         BNE   MATCHEL             BRANCH IF NOT\n        $ON    IFSTAK,IFCWTE       TURN ON .TH SWITCH\n         B     MATCHDN             AND GO CHECK\nMATCHEL  DS    0H\n         CH    TEMP,=AL2(VEL-SCRICVT)   IS THIS .EL .Q\n         BNE   MATCHIF             BRANCH IF NOT\n        $ON    IFSTAK,IFCWTE       TURN ON .EL SWITCH\n         B     MATCHDN             GO AND CHECK\nMATCHIF  DS    0H\n         CH    TEMP,=AL2(VIF-SCRICVT)   IS THIS .IF .Q\n         BNE   MATCHDO             BRANCH IF NOT\n        $ON    IFSTAK,IFCWIF       TURN ON .IF SWITCH\n         B     MATCHDN             GO AND CHECK\nMATCHDO  DS    0H\n         CH    TEMP,=AL2(VDO-SCRICVT)   IS THIS .DO .Q\n         BNE   MATCHEN             BRANCH IF NOT\n        $ON    IFSTAK,IFCWUR       TURN ON .UR SWITCH\n         B     MATCHDN             GO AND CHECK\nMATCHEN  DS    0H\n         CH    TEMP,=AL2(VEN-SCRICVT)   IS THIS .EN .Q\n         BNE   MATCHNL             BRANCH IF NOT\n        $ON    IFSTAK,IFCWUR       TURN ON .UR SWITCH\n         B     MATCHDN             GO AND CHECK\nMATCHNL  DS    0H\n         CH    TEMP,=AL2(VNL-SCRICVT)   IS THIS .NL .Q\n         BNE   MATCHDN             BRANCH IF NOT\n        $ON    IFSTAK,IFCWUR       TURN ON .UR SWITCH\n         B     MATCHDN             GO AND CHECK\n         SPACE\nMATCHDN  DS    0H\n         BAL   RETURN,MAINIF       TEST INCLUSION\n         BC    BNEG,MAIN           BRANCH IF TO BE OMITTED\n         SPACE\n         LH    TEMP,SPCTLO(,X1)    GET OFFSET OF APPROPRIATE ROUTINE\n         CH    TEMP,=AL2(VCS-SCRICVT)   IS THIS .CS .Q\n         BE    MATCHCS             NO .CS TEST IF YES\n        $IFON  SWITCHS,CSSWS,MAIN  FORGET IF IN COND SECTION\nMATCHCS  DS    0H\n         CH    TEMP,=AL2(VUR-SCRICVT)   IS THIS .UR .Q\n         BE    MATCHGO             YES, LET IT THROUGH\n         CH    TEMP,=AL2(VLB-SCRICVT)   IS THIS .LB .Q\n         BE    MATCHGO             YES, LET IT THROUGH\n         SPACE\n         BAL   RETURN,MAINLB       WITHIN A GOTO .Q\n         BC    BNEG,MAIN           BRANCH IF YES\n         SPACE\nMATCHGO  DS    0H\n         L     R15,VSCRICVT        COMMUNICATIONS VECTOR ADDRESS\n         L     R15,0(TEMP,R15)     ROUTINE ENTRY ADDRESS\n         LTR   R15,R15             A REAL ADDRESS PRESENT .Q\n         BZ    PERERR              UNDEFINED CONTROL WORD IF NOT\n        $CALL  (R15)               GO TO APPROPRIATE ROUTINE\nTRUEEND  DS    0H\n         B     *+4(R15)            AS REQUIRED\n         B     MAIN                CONTINUE WITH NEXT RECORD\n         B     MAINDC              WRETDC - DON'T COUNT ENCOUNTERED\n         B     MAIN05              WRETNR - ANOTHER RECORD NOW PRESENT\n         B     TREND01             WRETQT - FINAL RECORD\n         B     TREND08             WRETQQ - FINAL RECORD QUIT IMMED\n         B     MAIN02              WRETSU - SUBSTITUTE ANOTHER RECORD\n         B     PERLI               WRETLI - RESTORE ORIGINAL LITERAL\n         B     TREND06             WRETPA - FINAL PAGE COMPLETE\n         SPACE\nTESTCW   TRT   BUFF2(*-*),0(R1)    TEST FOR CONTROL WORD SEPARATOR\nBLNKREST MVC   1(*-*,X3),0(X3)     BLANK REST OF BUFF2\n         EJECT\n***********************************************************************\n*                                                                     *\n*              IF TEST ROUTINE                                        *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER --   BAL   RETURN,MAINIF\n*                      WITH FLAGS SET IN IFSTAK\n*        ON EXIT  --   CC=BPOS IF RECORD TO BE PROCESSED\n*                      CC=BNEG IF RECORD TO BE IGNORED\n         SPACE\nMAINIF   DS    0H\n        $IFOFF IFSTAK,IFLAST,MNIF01     BRANCH IF NOT 1ST REC AFTER .IF\n        $IFON  IFSTAK,IFCWTE,MNIF01     BRANCH IF .TH OR .EL\n        $OFF   IFSTAK,IFLAST       RESET FIRST SWITCH\n        $ON    IFSTAK,IFTHEN       TREAT AS OBJECT OF IMPLIED .TH\nMNIF01   DS    0H\n        $IFON  IFSTAK,IFCWIF,MNIF03     BRANCH IF .IF\n        $IFON  IFSTAK,IFCWUR,MNIF07     BRANCH IF .UR, .DO OR .EN\n        $IFANY IFSTAK,(IFTHEN,IFELSE),MNIF05 OBJECT OF .TH OR .EL .Q\n        $IFON  IFSTAK,IFCWTE,MNIF07     BRANCH IF .TH OR .EL\nMNIF02   DS    0H\n         MVC   IFSTAK,IFSTAK+IFSTAKSP   POP THE 'IF' STACK ONE LEVEL\n         OC    IFSTAK,IFSTAK       ALL DONE .Q\n         BZ    MNIF07              YES, SUCCESSFUL RETURN\n        $IFON  IFSTAK,IFDO,MNIF05  POPPED TO 'DO', CONTINUE\n         B     MNIF02              GO POP ONCE MORE\nMNIF03   DS    0H\n        $IFANY IFSTAK,(IFTHEN,IFELSE),MNIF07 OBJECT OF .TH OR .EL .Q\nMNIF03A  DS    0H\n         MVC   IFSTAK,IFSTAK+IFSTAKSP   POP THE 'IF' STACK ONE LEVEL\n         OC    IFSTAK,IFSTAK       ALL DONE .Q\n         BZ    MNIF07              YES, SUCCESSFUL RETURN\n        $IFON  IFSTAK,IFDO,MNIF07  POPPED TO 'DO', SUCCESSFUL RETURN\n         B     MNIF03A             GO POP ONCE MORE\nMNIF04   DS    0H\n         MVC   IFSTAK,IFSTAK+IFSTAKSP   POP THE 'IF' STACK ONE LEVEL\n         OC    IFSTAK,IFSTAK       ALL DONE .Q\n         BZ    MNIF07              YES, SUCCESSFUL RETURN\n        $IFON  IFSTAK,IFDO,MNIF05  POPPED TO 'DO', CONTINUE\n         B     MNIF04              GO POP ONCE MORE\nMNIF05   DS    0H\n        $IFON  IFSTAK,IFELSE,MNIF06 BRANCH IF OBJECT OF ELSE\n        $IFON  IFSTAK,IFFALSE,MNIF08    OMIT IF FALSE FOR .TH\n         B     MNIF07              GO TO INCLUDE\nMNIF06   DS    0H\n        $IFON  IFSTAK,IFTRUE,MNIF08     OMIT IF TRUE FOR .EL\nMNIF07   DS    0H\n        $CC    POS                 SET INCLUDE CONDITION CODE\n         B     MNIF09              BRANCH TO RETURN\nMNIF08   DS    0H\n        $CC    NEG                 SET EXCLUDE CONDITION CODE\nMNIF09   DS    0H\n         BR    RETURN              AND RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*              GOTO LABEL FOUND ROUTINE                               *\n*                                                                     *\n***********************************************************************\n         SPACE\n*        TO ENTER --    BAL   RETURN,MAINLB\n*        ON EXIT  --    CC=BPOS  IF RECORD TO BE PROCESSED\n*                       CC=BNEG  IF RECORD TO BE IGNORED\n         SPACE\nMAINLB   DS    0H\n         CLI   LBGOTO,C' '         GOTO NOT IN EFFECT .Q\n         BE    MAINLB02            BRANCH IF YES\n         OC    LBGOTO(4),LBGOTO    A NUMERIC GOTO .Q\n         BNZ   MAINLB01            FORGET THIS LINE IF NOT\n         CLC   COMFILIT,LBGOTO+4   THIS THE GOTO TARGET .Q\n         BL    MAINLB01            BRANCH IF NOT\n         MVC   LBGOTO,BLANKS       CLEAR GOTO TARGET\n         B     MAINLB02            AND TAKE INCLUDE EXIT\nMAINLB01 DS    0H\n        $CC    NEG                 DON'T INCLUDE THIS RECORD\n         B     MAINLB03            GO TO RETURN\nMAINLB02 DS    0H\n        $CC    POS                 INCLUDE THIS RECORD\nMAINLB03 DS    0H\n         BR    RETURN              AND RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*        THIS ROUTINE PRINTS FOOTNOTES AND REMOTES WHICH              *\n*        REMAIN TO BE PROCESSED AT THE FINAL EOF                      *\n*                                                                     *\n***********************************************************************\n         SPACE\nTREND01  DS    0H\n        $ON    SWITCHS,JUADSWS     FORCE JUSTIFICATION AND OUTPUT\n        $CALL  PRINTNB             PRINT LAST LINE\n         SR    X3,X3               INITIALIZE FIRST TIME SWITCH\nTREND02  DS    0H\n        $CALL  PAGEREAL            PHYSICAL PAGE EJECT\n         CLI   ICORFLG,ICORNONE    CURRENTLY SAVING OUTPUT INCORE .Q\n         BNE   TREND05             MISSING END IF YES\n         OC    FNQCNT,FNQCNT       ANY FOOTNOTE LINES QUEUED .Q\n         BNZ   TREND02             BRANCH BACK IF YES\n         OC    CPQCNT,CPQCNT       ANY CONDITIONAL KEEP LINES .Q\n         BNZ   TREND02             BRANCH BACK IF YES\n         OC    CCQCNT,CCQCNT       ANY CONDITIONAL COLUMN QUEUED .Q\n         BNZ   TREND02             BRANCH BACK IF YES\n         OC    FKQCNT,FKQCNT       ANY FLOATING KEEP LINES .Q\n         BNZ   TREND02             BRANCH BACK IF YES\n         OC    FBQCNT,FBQCNT       ANY FLOATING BLOCK LINES .Q\n         BZ    TREND03             BRANCH IF NONE\n         MVC   CPAREA(CPFKFNL),FBAREA   MAKE FLOAT BLOCK LOOK LIKE .CP\n         XC    FBAREA(CPFKFNL),FBAREA   AND CLEAR FLOAT BLOCK\n         B     TREND02             CLEAR THOSE .CP'S\n         SPACE\n*        LOOK FOR A REMOTE WHICH CAN STILL BE TRIGGERED               *\n*        (THIS INSURES THAT WHAT CAN BE PRINTED WILL BE               *\n*        AND PREVENTS A POSSIBLE LOOP DUE TO SAVED REMOTES).          *\n         SPACE\nTREND03  DS    0H\n        $IFON  SWITCHS,FEMPTY,TREND06   DONE IF PAGE EMPTY\n         LTR   X3,X3               FIRST TIME TRYING TO TERMINATE .Q\n         LA    X3,1(,X3)           BUMP TIME COUNT\n         BNZ   TREND04             BRANCH IF NOT FIRST TIME\n        $CALL  RMNEXT              SET UP FOR NEXT REMOTE (IF ANY)\n         B     TREND02             AND TRY AGAIN\n         SPACE\nTREND04  DS    0H\n        $CALL  RMCLR               REMOVE ANY AND ALL REMOTES\n         B     TREND02             AND TRY AGAIN\n         SPACE\nTREND05  DS    0H\n         MVI   EFLAG006,ERRTERM    MISSING '.XX END' STATEMENT\n        $CALL  ERROUT              PRINT THE DIAGNOSTIC\n         B     TREND08             AND QUIT IMMEDIATELY\n         EJECT\n***********************************************************************\n*                                                                     *\n*  POSITION PAPER, IF NECESSARY, CLOSE FILES, AND EXIT                *\n*                                                                     *\n***********************************************************************\n         SPACE\nTREND06  DS    0H\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS LAST PASS .Q\n         BNE   TREND08             BRANCH IF NOT\n        $IFOFF TTYPE,TONLINE,TREND08    BRANCH IF NOT ONLINE\n        $IFON  TTYPE,TFILE,TREND08      BRANCH IF OUTPUT TO A FILE\n        $IFOFF SWITCHS,STSWS,TREND07    SKIP IF NO 'STOP' OPTION\n         MVC   CONSMAX,H1          READ ONE LINE FROM CONSOLE\n         MVC   CONSGOTO,BLANKS     CLEAR GOTO TARGET\n         XC    CONSFLAG,CONSFLAG   CLEAR CONSOLE FLAGS\n        $ON    CONSFLAG,(IO$JIGG,IO$SUPR,IO$EJCT) DO A LOT\n        $ON    CONSFLAG,IO$IM      AND IMBED THIS LAST OPERATION\n         LA    R1,CONSBLOK         TO IMBED THE CONSOLE FILE\n        $CALL  RDFILE              CALL THE INPUT COORDINATOR\n         SPACE\n         LA    R1,BUFF2LGZ         POINT TO READ TARGET\n        $CALL  RDLINE              READ ONE LINE\n         B     TREND08             AND QUIT\n         SPACE\nTREND07  DS    0H\n        $IFON  TTYPE,TSCREEN,TREND08    NO SPACE UP FOR A CRT\n         LA    COUNT,5             INTO NEXT PAGE BEFORE READY MSG\n        $CALL  SPACEIM             GO SPACE DOWN NOW\n         SPACE\nTREND08  DS    0H\n         SR    R1,R1               ZERO PARAMETER LIST\n        $CALL  RDFILE              TO CLOSE ALL INPUT FILES\n         SPACE\n        $CALL  STAKFREE            FREE ANY SAVE/RESTORE STACK\n         LA    R1,OOANCH           OUTPUT OVERLAY ANCHOR POINTER\n        $CALL  OVCLR               REMOVE ANY AND ALL\n         LA    R1,OIANCH           INPUT OVERLAY ANCHOR POINTER\n        $CALL  OVCLR               REMOVE ANY AND ALL\n         LA    R1,PEANCH           PERFORM STACK ANCHOR POINTER\n        $CALL  OVCLR               REMOVE ANY AND ALL\n        $CALL  RMCLR               CLEAR ANY REMOTES LEFT\n        $CALL  BXCLR               CLEAR ANY BOX BUILDING DATA\n         LA    R1,HNAREA           HEADNOTE DESCRIPTOR BLOCK\n        $CALL  HNCLR               CLEAR ANY PRESENT\n         LA    R1,HNEAREA          EVEN HEADNOTE DESCRIPTOR BLOCK\n        $CALL  HNCLR               CLEAR ANY PRESENT\n         LA    R1,HNOAREA          ODD HEADNOTE DESCRIPTOR BLOCK\n        $CALL  HNCLR               CLEAR ANY PRESENT\n         LA    R1,TBANCHR          PTR TO CURRENT USER TAB ANCHOR\n        $CALL  TBFREBLK            DELETE THEM IF PRESENT\n        $CALL  ERROUT              PRINT ANY TERMINATION ERRORS\n         SPACE\n         CLC   PASSNO,DEFPASOF+TAB3DEF  IS THIS LAST PASS .Q\n         BE    TREND10             YES, GO TO TERMINATION\n         L     R1,PLSTSV           NO, RESTORE P-LIST ADDRESS\n         B     PASS2               GO DO ANOTHER PASS\n         SPACE\nTREND10  DS    0H\n        $CALL  RCAFREE             RELEASE REVISION CODE WORK AREA\n         SR    R0,R0               NO POINTER FOR WORK FILE CLOSE\n         LA    R1,PUMAX            MAXIMUM POSSIBLE USER FILES\nTREND11  DS    0H\n        $CALL  PUWORK              CLOSE FILE, IF POSSIBLE\n         S     R1,F1               DECREMENT FILE NUMBER\n         BNM   TREND11             DO ALL FILES\n         SPACE\n         SR    R0,R0               ZERO ADDR TO FREE\n         SR    R1,R1               ZERO LENGTH TO FREE\n        $CALL  FREECELL            TERMINATE REGION MANAGER\n         SPACE\n        $IFOFF SWITCHS,STATSWS,TREND13  BRANCH IF NO STATISTICS\n        $CALL  OUSTAT              FORMAT AVAILABLE USAGE STATISTICS\n         SPACE\nTREND13  DS    0H\n         SR    R0,R0               CLEAR DATA POINTER\n         BCTR  R0,0                NEGATIVE MEANS CLOSE\n        $CALL  PUTPRT              CLOSE SYSPRINT OUTPUT FILE\n         SR    R0,R0               CLEAR DATA POINTER\n         BCTR  R0,0                NEGATIVE MEANS CLOSE\n        $CALL  PUTTERM             CLOSE SYSTERM ERROR FILE\n         SPACE\n        $CALL  VTRAPS              REVERSE ANY USER TRAPS\n         SPACE\n         LH    X1,RETCODE          PICKUP RETURN CODE\n         L     R13,4(,R13)         BACKWARD SAVE POINTER\n         L     R15,=V(SYSINT)      SYSTEM DEPENDENT INTERFACE\n         BAL   R14,8(,R15)         TERM SYSTEM INTERFACE CONTROL AREA\n         LR    R15,X1              SET RETURN CODE\n         RETURN (14,12),T,RC=(15)  RETURN TO O/S\n         EJECT\n***********************************************************************\n*                                                                     *\n*              LITERALS                                               *\n*                                                                     *\n***********************************************************************\n         SPACE\n         LTORG\n         SPACE\nSAVETABL DC    (SAVELEN*SAVEVLS/8)D'0'  STACKED REGISTER SAVE AREAS\n         EJECT\n***********************************************************************\n*                                                                     *\n*                             SPIE PROGRAM RECOVERY                   *\n*                                                                     *\n***********************************************************************\n         SPACE\n         PUSH  USING               SAVE ALL BASES\n         DROP  ,                   REMOVE ALL CURRENT\nSPIEADDR DS    0H\n         BALR  R15,0               TEMP BASE\n         USING *,R15               TELL THE ASSEMBLER\n         SPACE\n         L     COUNT,=V(NSCDAT)    COMMON WORK AREA\n         USING NSCDAT,COUNT        AND TELL THE ASSEMBLER\n         L     COUNT,DUMPAD        WHERE TO SAVE DATA\n         USING DUMPAREA,COUNT      AND UPDATE THE ASSEMBLER\n         ST    R13,DUMPREG+R13*4   SAVE ONE USER REG\n         STM   TEMP,BASE,DUMPREG+TEMP*4 SAVE BUNGLER'S REGS\n         MVC   DUMPREG+R14*4(8),12(R1)  SAVE R14 AND R15\n         MVC   DUMPREG+R0*4(12),20(R1)  SAVE R0, R1 AND R2\n         MVC   DUMPPSW(8),4(R1)    SAVE PSW\n         SPACE\n         L     R13,=V(NSCDAT)      DATA BASE REGISTER\n         USING NSCDAT,R13          TELL THE ASSEMBLER AGAIN\n         L     BASESAVE,SAVEINIT   SAVE AREA STACK ADDRESS\n         USING DUMPAREA,COUNT      BUT RETAIN DUMP AREA\n         SPACE\n         XC    ERCONT,ERCONT       TURN OFF CONTINUE COUNT\n         CLI   EFLAG998,ERRCLR     WAS IT A LOGIC ERROR .Q\n         BE    SPIEA01             BRANCH IF NOT\n         MVC   DUMPPSW+2(2),RETCODE  RESET INTERRUPT CODE\n         DROP  COUNT\n         B     SPIEA02             GO TO PROCESS ERROR MESSAGE\n         SPACE\nSPIEA01  DS    0H\n         MVI   EFLAG999,ERRTERM    TERMINAL PROGRAM CHECK ERROR\nSPIEA02  DS    0H\n        $CALL  ERROUT              PRINT THE DIAGNOSTIC\n         LA    R1,WRETQQ           QUICK TERMINATION CODE\n        $CALL  QUITS               GO THROUGH TERMINATION\n         SPACE\n         LTORG ,                   SPIE LITERALS\n         POP   USING               AS YOU WERE\n         EJECT\n         COPY  $SPCTLTB            COPY CONTROL WORDS\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSINT": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x05\\xb6\\x05\\xb6\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 1462, "newlines": 1462, "modlines": 0, "user": "CBT249"}, "text": "SYSINT   TITLE     'SYSTEM INTERFACE ROUTINE'\nSYSINT   CSECT     ,\n*\nR0       EQU       0\nR1       EQU       1\nR2       EQU       2\nR3       EQU       3\nR4       EQU       4\nR5       EQU       5\nR6       EQU       6\nR7       EQU       7\nR8       EQU       8\nR9       EQU       9\nR10      EQU       10\nR11      EQU       11\nR12      EQU       12\nR13      EQU       13\nR14      EQU       14\nR15      EQU       15\n*\n*        SYSTEM INTERFACE CONTROL AREA DESCRIPTION\n*\nSICA     DSECT     ,                   SYSTEM INTERFACE CONTROL AREA\nSICAID   DS        1F                  SICA ID FIELD\nBKWDPTR  DS        1F                  POINTER TO PREVIOUS SAVEAREA\nFWRDPTR  DS        1F                  POINTER TO NEXT SAVE AREA\nSAVEAREA DS        15F                 REMAINDER OF OS SAVEAREA\nUSERQORG DS        1F                  ORIGIN OF USER QUEUE\nSYSINTAD DS        1F                  ADDRESS OF SYSINT ROUTINE\nIOCBQORG DS        1F                  POINTER TO START OF IOCB QUEUE\nTRACEPTR DS        1F                  ADDRESS OF TRACE\nTRSETA   DS        1F                  ADDRESS OF SETAREA ROUTINE\nSYSCORE  DS        1F                  CORE TO BE LEFT FOR SYSTEM\nSICACEND DS        0F                  END OF COMMON PART OF SICA\nSICAPICA DS        2F                  SICA PICA FOR SPIE\nIOCODE   EQU       SICAPICA+6          RETURN CODE\nSPIEEXIT DS        4F                  SPACE FOR SPIE EXIT ROUTINE\nSPIEROUT DS        1F                  ADDRESS OF USER'S SPIE ROUTINE\nSPIER2   DS        1F                  SAVED VALUE OF USER'S R2\nSICAPIE  DS        14F                 SPACE TO SAVE PIE AND OPEN REGS\nTIMREXIT DS        3F                  SPACE FOR STIMER EXIT ROUTINE\nTIMRROUT DS        1F                  SPACE FOR USER'S STIMER EXIT\nSTIMERR2 DS        1F                  SPACE FOR USER'S R2 VALUE\nSICAPARM DS        4F                  WORK AREA\nPICASAVE DS        1F                  VALUE OF PICA POINTER ON ENTRY\nSICAEND  DS        0D                  END OF SICA\n*\nSICAPREF EQU       72                  LENGTH OF SICA PREFIX SECTION\n*\n*        IO CONTROL BLOCK DESCRIPTION\n*\nIOCB     DSECT     ,                   IO CONTROL BLOCK\nUSERAREA DS        256D                SPACE FOR USER-DEFINED PREFIX\nIODEF    DS        0F                  IO DEFINITION SECTION\nFILETYPE DS        1C                  FILE TYPE(ONE OF FOLLOWING)\nF$QSAM   EQU       1                   QSAM WITH NO ERROR RETURN CODES\nF$BSAM   EQU       2                   BSAM WITH NO ERROR RETURN CODES\nF$BPAM   EQU       3                   BPAM WITH NO ERROR RETURN CODES\nF$QSAMR  EQU       4                   QSAM WITH ERROR RETURN CODES\nF$BSAMR  EQU       5                   BSAM LOAD MODE(RELATIVE RECORD)\nF$BSAMK  EQU       6                   BSAM LOAD MODE(KEYED RECORD)\nF$BDAMR  EQU       7                   BDAM RELATIVE RECORD\nF$BDAMK  EQU       8                   BDAM KEYED RECORD\nUSERLNTH DS        1C                  LENGTH OF USER AREA IN DBLWORDS\nOPTIONS  DS        2C                  OPTIONS USED\nDDNAME   DS        2F                  FILE NAME\nRECFM    DS        1C                  RECFM\nRECMERGE DS        1C                  MASK TO MERGE RECFM BITS\nKEYLEN   DS        1C                  KEY LENGTH\nBUFNO    DS        1C                  NUMBER OF BUFFERS\nLRECL    DS        1H                  LRECL OR DEFAULT LRECL\nMAXLRECL DS        1H                  MAXIMUM LRECL\nBLKSI    DS        1H                  BLKSI(>0) OR DEFAULT BLKSI(<0)\nRKP      DS        1H                  OFFSET OF KEY IN RECORD\nTRACKLIM EQU       RKP                 NUMBER OF TRACKS\n         DS        1F                  RESERVED FOR FUTURE USE\nIODEFEND DS        0F                  END OF IODEF\nMAXRECNO DS        1F                  MAXIMUM RECORD NUMBER FOR BDAM\nIOCBLINK DS        1F                  LINK TO NEXT IOCB(AFTER OPEN)\nIOCBUSER DS        1F                  USER FIELD(NOT USED BY SYSINT)\nIOCBSYS  DS        1F                  POINTER TO SYSTEM DEPENDENT DATA\nIOCBCEND DS        0F                  END OF COMMON PART OF IOCB\n         DS        2F                  RESERVED\nIOCBDCB  DS        26F                 FILE DCB\nDCBBFTEK EQU       IOCBDCB+32\nDCBBLKSI EQU       IOCBDCB+62\nDCBBUFCB EQU       IOCBDCB+20\nDCBBUFNO EQU       IOCBDCB+20\nDCBCIND  EQU       IOCBDCB+60\nDCBDEBAD EQU       IOCBDCB+44\nDCBDEVT  EQU       IOCBDCB+17\nDCBDSORG EQU       IOCBDCB+26\nDCBDVTBL EQU       IOCBDCB+12\nDCBEODAD EQU       IOCBDCB+32\nDCBFDAD  EQU       IOCBDCB+05\nDCBIOBA  EQU       IOCBDCB+68\nDCBKEYLE EQU       IOCBDCB+16\nDCBLRECL EQU       IOCBDCB+82\nDCBMACR  EQU       IOCBDCB+50\nDCBNOTE  EQU       IOCBDCB+84\nDCBOFLGS EQU       IOCBDCB+48\nDCBOPTCD EQU       IOCBDCB+52\nDCBRECFM EQU       IOCBDCB+36\nDCBREL   EQU       IOCBDCB+17          NUMBER OF TRACKS OR BLOCKS(BDAM)\nDCBRELAD EQU       IOCBDCB+00\nDCBROUT  EQU       IOCBDCB+48          ADDR OF GET,PUT,READ,WRITE\nIOCBDECB DS        0F                  DECB\nDECBECB  DS        1F\nDECBTYPE DS        1H\nDECBLNTH DS        1H\nDECBDCBA DS        1F                  POINTER TO DCB\nDECBAREA DS        1F                  POINTER TO RECORD\nDECBIOBA DS        1F                  POINTER TO IOB\nDECKYADR DS        1F                  POINTER TO KEY\nDECRECPT DS        1F                  POINTER TO BLOCK REFERENCE\nDECNXADR DS        1F\nIOCBSICA DS        1F                  POINTER TO SICA\nCHECKSAV DS        1F\nVLIND    DS        1H                  4 FOR RECFM=V, 0 OTHERWISE\nOPENCODE DS        1C                  OPEN CODE\nFLAGS    DS        1C                  INTERNAL FLAGS\nREREADSW EQU       X'80'               UNLIKE CONCATENATION REREAD FLAG\nUNITFULL EQU       X'40'               VOLUME FULL FLAG\nSECALLOC EQU       X'20'               SECONDARY ALLOCATION FLAG\nIOCBEND  DS        0D\n*\nFILECHAR DSECT     ,\nFIMACRF  DS        1H                  FILE MACRF\nFIDSORG  DS        1C                  FILE DSORG\nFIFLAGS  DS        1C                  FILE FLAGS\n*\n*        FOLLOWING IS A LIST OF SYMBOLIC EQUATES FOR FIELDS IN\n*        VARIOUS OPERATING SYSTEM CONTROL BLOCKS\n*\nCVTPTR   EQU       16                  POINTER TO OS'S COMMUNICATION\n*                                      VECTOR TABLE(CVT)\nCVTTCBP  EQU       0                   PTR IN CVT TO TASK SWITCH CELL\nCVTCMS   EQU       7                   BYTE IN CVT WHICH IS 255 FOR CMS\nCVTDCB   EQU       116                 BYTE IN CVT FOR SYSTEM TYPE\nTCBPTR   EQU       4                   PTR IN TSC TO CURRENT TCB\nTCBTIOT  EQU       12                  PTR IN TCB TO TASK I/O TABLE\n*\n*        CONTROL BLOCK VALUES FROM CMS\n*\nFCBFIRST EQU       X'5C0'              PTR IN NUCON TO FIRST FCB\nFCBLINK  EQU       0                   PTR IN FCB TO NEXT FCB\nFCBDDNAM EQU       8                   DDNAME IN FCB\n*\nSYSINT   CSECT\n         USING     SICA,R13\n         USING     SYSINT,R15\nSYSINT$  B         SYSMAIN             000 - RESERVED\n         B         SYSINIT             004 - SYSINT INITIALIZATION\n         B         SYSTERM             008 - SYSINT TERMINATION\n         B         SYSGMAIN            012 - GETMAIN\n         B         SYSFMAIN            016 - FREEMAIN\n         B         SYSRMAIN            020 - CORE CLEANUP\n         B         SYSTEST             024 - LOOKUP DDNAME\n         B         SYSMOVE             028 - MOVE BLOCK OF MEMORY\n         B         SYSOPEN             032 - OPEN FILE\n         B         SYSCLOSE            036 - CLOSE FILE\n         B         SYSREAD             040 - READ FILE\n         B         SYSWRITE            044 - WRITE FILE\n         B         SYSGET              048 - GET FILE\n         B         SYSPUT              052 - PUT FILE\n         B         SYSNOTE             056 - NOTE FILE\n         B         SYSPOINT            060 - POINT FILE\n         B         SYSFIND             064 - FIND FILE\n         B         SYSSTOW             068 - STOW FILE\n         B         SYSSPIE             072 - SET PROGRAM INTERRUPT EXIT\n         B         SYSTIME             076 - GET TIME AND DATE\n         B         SYSSTIME            080 - SET TIMER INTERVAL\n         B         SYSTTIME            084 - TEST TIMER INTERVAL\n         B         SYSLOAD             088 - LOAD A LOAD MODULE\n         B         SYSDELT             092 - DELETE A LOAD MODULE\n         B         SYSWTO              096 - WRITE MESSAGE TO OPERATOR\n         B         SYSWTOR             100 - WRITE OPERATOR WITH REPLY\n         B         SYSABEND            104 - ABEND PROGRAM\n         B         SYSWTP              108 - WRITE TO PROGRAM LOG\n         B         GMENTRY             112 - INTERNAL ENTRY FOR SYSINT$\n*\n         ENTRY     SYSINT$\n         ENTRY     SYSINIT\n         ENTRY     SYSTERM\n         ENTRY     SYSGMAIN\n         ENTRY     SYSFMAIN\n         ENTRY     SYSRMAIN\n         ENTRY     SYSTEST\n         ENTRY     SYSMOVE\n         ENTRY     SYSOPEN\n         ENTRY     SYSCLOSE\n         ENTRY     SYSREAD\n         ENTRY     SYSWRITE\n         ENTRY     SYSGET\n         ENTRY     SYSPUT\n         ENTRY     SYSNOTE\n         ENTRY     SYSPOINT\n         ENTRY     SYSFIND\n         ENTRY     SYSSTOW\n         ENTRY     SYSSPIE\n         ENTRY     SYSTIME\n         ENTRY     SYSSTIME\n         ENTRY     SYSTTIME\n         ENTRY     SYSLOAD\n         ENTRY     SYSDELT\n         ENTRY     SYSWTO\n         ENTRY     SYSWTOR\n         ENTRY     SYSABEND\n         ENTRY     SYSWTP\n         DROP      R15\n*\nSYSMAIN  B         0(,R14)\n*\n*        SYSTEM INTERFACE INITIALIZATION ROUTINE\n*        THIS ROUTINE WILL CREATE A SYSTEM INTERFACE CONTROL AREA AND\n*        CHAIN IT ONTO THE SAVEAREA QUEUE SO THAT THE BACKWARD POINTER\n*        OF THE SICA POINTS TO THE SAVEAREA THAT WAS IN R13 WHEN THE\n*        ROUTINE WAS ENTERED. IF A SICA IS ALREADY ON THE BACKWARD\n*        SAVEAREA CHAIN QUEUE THEN IT'S ADDRESS IS RETURNED IN R1.\n*\n         USING     SYSINT,R15\nSYSINIT  LR        R1,R13              SAVE USER'S SAVEAREA POINTER\n         L         R2,SYSIDENT-SYSINT(,R15)  GET SICA ID\nINGSICA  C         R2,SICAID-SICA(,R1)  IS THIS THE SICA\n         BNE       INITNEXT            IF NOT THEN CONTINUE UP QUEUE\n         LA        R1,SICAPREF(,R1)    ADD ON PREFIX LENGTH\n         BR        R14                 AND RETURN TO CALLER\nINITNEXT L         R1,BKWDPTR-SICA(,R1)  OTHERWISE CONTINUE UP QUEUE\n         LTR       R1,R1               IS THIS THE END OF THE QUEUE\n         BNZ       INGSICA             IF NOT THEN CONTINUE\n         LA        R0,SICAEND-SICA+SICAPREF GET LENGTH OF SICA & PREFIX\n         LNR       R1,R0               SET R1 NEGATIVE FOR GETMAIN\n         SVC       10                  ISSUE GETMAIN SVC\n         BALR      R15,0               RESET BASE REGISTER\n         USING     *,R15               AND RESET USING\n         XC        0(256,R1),0(R1)     CLEAR FIRST 256 BYTES OF SICA\n         XC        256(SICAEND-SICA+SICAPREF-256,R1),256(R1) CLEAR REST\n         ST        R13,BKWDPTR-SICA(,R1) SET USER'S SAVEAREA AS BKWDPTR\n         ST        R1,FWRDPTR-SICA(,R13) SET USER'S FWRDPTR AS SICA\n         ST        R2,SICAID-SICA(,R1)  FOR FUTURE IDENTIFICATION\n         LR        R2,R13              SAVE OLD SAVEAREA ADDRESS\n         LR        R13,R1              SICA PREFIX BECOMES NEW SAVEAREA\n         MVC       SAVEAREA-SICA(60,R13),SAVEAREA-SICA(R2) MOVE SAVEAR\n         LA        R0,TERMROUT         GET ADDRESS OF TERMINATE ROUTINE\n         ST        R0,SAVEAREA-SICA(,R13)  SAVE IN SAVEAREA R14 SLOT\n         ST        R13,BKWDPTR+SICAPREF  SICA BKWDPTR=A(SICA PREFIX)\n         L         R0,ASYSINT          GET SYSINT ADDRESS\n         ST        R0,SYSINTAD+SICAPREF  SAVE IN SICA\n         MVI       SYSCORE+2+SICAPREF,X'10'  SET SYSTEM CORE TO 4K\n         L         R1,CVTPTR(,R0)      GET CVT POINTER\n         TM        CVTDCB(R1),X'02'    IS THIS A VS SYSTEM\n         BZ        *+8                 IF NOT THEN GO AROUND\n         MVI       SYSCORE+2+SICAPREF,X'30'  SET SYSTEM CORE TO 12K\n         MVC       SPIEEXIT+SICAPREF(SPIECOD1-SPIECODE),SPIECODE\n         LA        R0,SPIEEXIT+SICAPREF  LOAD ADDRESS OF SPIE ROUTINE\n         ST        R0,SICAPICA+SICAPREF STORE EXIT ROUTINE ADDR IN PICA\n         LA        R1,SICAPICA+SICAPREF  LOAD PARM REG FOR SPIE SVC\n         SVC       14                  ISSUE SPIE SVC\n         BALR      R15,0               RESET BASE REGISTER\n         USING     *,R15               AND RESET USING\n         ST        R1,PICASAVE+SICAPREF  SAVE CALLER'S PICA POINTER\n         SPM       R13                 SET PROGRAM MASK OFF\n         LA        R0,INITBR14         GET ADDRESS OF BR R14 INST\n         LR        R1,R0               GET ANOTHER ADDRESS OF BR R14\n         STM       R0,R1,TRACEPTR+SICAPREF  SAVE IN TRACE ADDRESSES\n         L         R1,0(,R2)           GET FIRST WORD OF CALLER'S SAVE\n         SR        R2,R1               CALCULATE DIFFERENCE\n         CL        R2,=F'64'           IS DIFFERENCE >=0 & <64\n         BNL       INITRET             IF NOT THEN RETURN\n         CLC       0(8,R1),=CL8'SUPRTRAC'  IS CALLER SUPRTRAC\n         BNE       INITRET             IF NOT THEN RETURN\n         MVC       TRACEPTR+SICAPREF(8),8(R1) MOVE OVER TRACE ADDRESSES\nINITRET  LA        R1,SICAPREF(,R13)   SET SICA PROPER FOR PROGRAM\nINITBR14 BR        R14                 AND RETURN TO CALLER\nSPIECODE L         R2,SPIER2-SPIEEXIT(,R15)  GET R2 SAVED VALUE\n         MVC       SICAPIE-SPIEEXIT(32,R15),0(R1)  SAVE PIE VALUE\n         L         R15,SPIEROUT-SPIEEXIT(,R15)  GET ADDR OF SPIE ROUT\n         BR        R15                 AND GO TO IT\nSPIECOD1 DC        0H'0'\nASYSINT  DC        A(SYSINT)\n         DROP      R15\n*\nTERMROUT L         R14,BKWDPTR-SICA(,R13)  GET PTR TO PREVIOUS SAVEAREA\n         STM       R0,R2,SAVEAREA+8-SICA(R14)  SAVE R0-R2\n         LR        R2,R15              SAVE R15 IN R2\n         L         R1,PICASAVE+SICAPREF  GET SAVED PICA POINTER\n         SVC       14                  ISSUE SPIE SVC TO RESTORE PICA\n         LR        R1,R13              MOVE SICA PREFIX POINTER TO R1\n         LA        R0,SICAEND-SICA+SICAPREF GET LENGTH OF SICA & PREFIX\n         LR        R13,R14             RESTORE PREVIOUS SAVEAREA PTR\n         SVC       10                  ISSUE FREEMAIN SVC\n         LR        R15,R2              RESTORE R15\n         LM        R0,R2,SAVEAREA+8-SICA(R13)  RESTORE R0-R2\n         L         R14,SAVEAREA-SICA(,R13)  GET CALLER'S R14\n         BR        R14                 AND RETURN TO CALLER\n*\n*        SYSTEM INTERFACE TERMINATION ROUTINE\n*        IF R13 CONTAINS THE ADDRESS OF THE SICA, THEN IT IS FREED\n*        AND R13 IS REPLACED BY THE SICA BKWDPTR FIELD.\n*\nSYSTERM  CLC       SICAID-SICA(4,R13),SYSIDENT-SYSINT(R15) SICA ?\n         BCR       7,R14               IF NOT THEN RETURN\n         L         R1,PICASAVE+SICAPREF  GET SAVED PICA POINTER\n         SVC       14                  ISSUE SPIE SVC TO RESTORE PICA\n         LR        R1,R13              MOVE SICA PREFIX ADDRESS INTO R1\n         L         R13,BKWDPTR-SICA(,R13)  GET PREVIOUS SAVEAREA PTR\n         LA        R0,SICAEND-SICA+SICAPREF GET LENGTH OF SICA & PREFIX\n         SVC       10                  ISSUE FREEMAIN SVC\n         BR        R14                 AND RETURN TO CALLER\n*\n*        GETMAIN ROUTINE\n*        INPUT  R0=MIN,R1=MAX\n*        OUTPUT R0=LENGTH,R1=ADDRESS\n*        REQUEST IS CONDITIONAL IF NEXT INST IS CONDITIONAL BRANCH\n*        CC=0 FOR SUCCESSFULL, CC=1 FOR NOT SUCCESSFULL\n*\nGMPARM   EQU       SAVEAREA+4\nGMMINMAX EQU       GMPARM+12           (MIN CORE,MAX CORE)\nGMRESULT EQU       GMMINMAX+8          (ADDR OF CORE,LNTH OF CORE)\nGMSAVR13 EQU       GMRESULT+8          SAVEAREA FOR SAVEAREA POINTER\n         USING     SYSINT,R15\nGETMAIN  LR        R0,R1               COPY R1 INTO R0\n         LR        R15,R11             FOR INTERNAL CALLERS\nSYSGMAIN SLL       R1,8                LEAVE BOTTOM BYTE 0\n         SLDL      R0,8                LEAVE BOTTOM 2 BYTES 0\n         LA        R14,0(,R14)         CLEAR UPPER BYTE OF R14\n         SLL       R15,8               MOVE R15 OVER 1 BYTE\n         SRDL      R14,8               MOVE R14 & R15 RIGHT 1 BYTE\n         OR        R1,R14              SAVE LOW 2 BYTES OF R14 IN R1\n         LR        R14,R13             SAVE CURRENT SAVEAREA POINTER\n         B         GMGSICA1\nGMGSICA  L         R13,BKWDPTR         GO BACK UP THE SAVEAREA QUEUE\nGMGSICA1 CLC       SICAID(4),SYSIDENT  IS THIS THE SICA PREFIX\n         BNE       GMGSICA             IF NOT THEN CONTINUE UP QUEUE\nGMENTRY  LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER\n         ST        R14,GMSAVR13        SAVE PREVIOUS SAVEAREA PTR\n         LR        R14,R1              RESTORE R14\n         SLDL      R14,8               RECOVER LOW BYTE OF R14\n         SRL       R15,8               RECOVER R15\n         SRDL      R0,8                SHIFT R0 & R1 RIGHT BY 1 BYTE\n         SRL       R1,8                RECOVER R1 VALUE\n         STM       R0,R1,GMMINMAX      SET UP MIN-MAX VALUES\n         LA        R0,GMMINMAX         SET UP ADDRESS OF MIN-MAX CELL\n         LA        R1,GMRESULT         SET UP ADDRESS OF RESULT CELL\n         STM       R0,R1,GMPARM        SET UP PARMATER LIST FOR GETMAIN\n         MVI       GMPARM+9,0          SET UP SUBPOOL ID\n         MVI       GMPARM+8,X'C0'      SET UP FLAGS FOR UNCONDITIONAL\n         CLI       0(R14),X'47'        IS THE NEXT INSTRUCTION A BRANCH\n         BNE       GMUNCON             IF NOT THEN LEAVE AS UNCON\n         TM        1(R14),X'F0'        IS IT A CONDITIONAL BRANCH\n         BNM       GMUNCON             IF NOT THEN LEAVE AS UNCON\n         MVI       GMPARM+8,X'E0'      SET UP FLAGS FOR CONDITIONAL\nGMUNCON  LA        R1,GMPARM           SET UP R1 FOR GETMAIN\n         SVC       4                   ISSUE GETMAIN SVC\n         OR        R15,R15             SET CC=0 FOR OK - CC=1 FOR NOT\n         L         R1,GMRESULT         GET ADDRESS OF CORE\n         L         R0,GMRESULT+4       GET LENGTH OF CORE\n         L         R13,GMSAVR13        RESTORE SAVEAREA POINTER\n         BR        R14                 RETURN TO CALLER\n         DROP      R15\n*\n*        FREEMAIN ONE CONTIGUOUS AREA\n*        INPUT R1=ADDRESS OF AREA TO FREEMAIN\n*              R0=LENGTH OF AREA\n*\n         USING     SYSINT,R15\nFREEMAIN LR        R15,R11             FOR INTERNAL CALLERS\nSYSFMAIN AH        R0,=H'7'            ROUND LENGTH TO DOUBLE WORD\n         N         R0,=F'-8'\n         SVC       10                  ISSUE FREEMAIN SVC\n         BR        R14                 AND RETURN TO CALLER\n         DROP      R15\n*\n*        RELEASE/CLEANUP\n*        INPUT R1=ADDRESS OF AREA TO FREEMAIN/CLEANUP\n*              R0=LENGTH OF AREA\n*        ROUTINE MUST FREEMAIN ALL ALLOCATED CORE AREAS WITHIN THE\n*        AREA BETWEEN R1 AND R1+R0\n*        REGISTER USAGE\n*        R2=START OF AREA TO FREE\n*        R3=END OF AREA TO FREE+1\n*        R4=CURRENT FQE POINTER\n*        R5=CURRENT LOW-BOUND OF AREA(DQE) TO FREE\n*        R6=CURRENT HIGH-BOUND OF AREA(DQE) TO FREE\n*        R10=CURRENT DQE POINTER\n*        R1=START OF CURRENT ALLOCATED AREA\n*        R0=END OF CURRENT ALLOCATED AREA\n*        METHOD IS TO SEARCH DOWN ALL FQE'S FOR THE REGION,FIND ALL\n*        ALLOCATED AREAS, AND FREE ANY PART WHICH OVERLAPS AREA TO FREE\n*\n         USING     SYSINT,R11\nRMSYSID  EQU       SAVEAREA+00\nSYSRMAIN STM       R2,R14,SAVEAREA+4\n         LR        R11,R15\n         LR        R2,R1               GET START OF AREA ADDRESS\n         LR        R3,R1               GET START OF AREA ADDRESS\n         AR        R3,R0               CALCULATE END OF AREA ADDRESS\n         L         R4,CVTPTR(,R0)      GET CVT POINTER\n         CLI       CVTCMS(R4),255      IS THIS CMS\n         BE        RMRETURN            IF SO THEN RETURN\n         MVC       RMSYSID(1),CVTDCB(R4)  SAVE SYSTEM TYPE BYTE\n         L         R4,CVTTCBP(,R4)     GET TASK SWITCH CELL POINTER\n         L         R4,TCBPTR(,R4)      GET ADDRESS OF CURRENT TASK\n         TM        RMSYSID,X'20'       IS THIS MFT\n         BNO       RMNOJST             IF NOT THEN USE CURRENT TASK\n         L         R1,44(,R4)          GET POINTER TO JOB STEP TASK\n         LTR       R1,R1               IF THERE ONE\n         BZ        RMNOJST             IF NOT THEN USE CURRENT\n         LR        R4,R1               USE JOB STEP TASK\nRMNOJST  L         R10,24(,R4)         GET POINTER TO MSS CELL\n         TM        RMSYSID,X'10'       IS THIS MVT\n         BO        RMSPQSYS            IF SO THEN GO FIND SPQE\n         L         R1,4(,R10)          GET START OF REGION ADDRESS\n         LTR       R1,R1               IS IT ALLOCATED ?\n         BNZ       *+8                 IF SO THEN SKIP NEXT\n         LA        R10,12(,R10)        MUST BE MFT WITH REGION IN LCS\n         L         R5,4(,R10)          LOW-BOUND=START OF REGION ADDR\n         L         R6,8(,R10)          HIGH-BOUND=END OF REGION ADDR\n         L         R4,0(,R10)          GET ADDRESS OF FIRST FQE\n         SR        R10,R10             INDICATE LAST DQE\n         B         RMSTART             PROCEED DOWN FQE CHAIN\nRMSPQELP L         R10,0(,R10)         ADVANCE TO NEXT SPQE\nRMSPQSYS TM        RMSYSID,X'13'       IS THIS VS2.2 ?\n         BNO       RMSPQE1\n         CLI       10(R10),0           IS THIS SUBPOOL ZERO\n         BNE       RMSPQELP            IF NOT THEN CONTINUE\n         TM        8(R10),X'80'        IS SUBPOOL SHARED\n         B         RMSPQTST            GO TO COMMON TEST\nRMSPQE1  CLI       4(R10),0            IS THIS SUBPOOL ZERO\n         BNE       RMSPQELP            IF NOT THEN CONTINUE SEARCH\n         TM        0(R10),X'80'        IS SUBPOOL SHARED\nRMSPQTST BNO       *+8                 IF NOT THEN HAVE SPQE\n         L         R10,4(,R10)         OTHERWISE GET PRIMARY SPQE\n         L         R10,4(,R10)         GET POINTER TO FIRST DQE\nRMDQELP  L         R6,8(,R10)          GET START OF DQE'S AREA\n         LA        R5,0(,R6)           LOW-BOUND=START OF DQE'S AREA\n         A         R6,12(,R10)         HIGH-BOUND=END OF DQE'S AREA\n         L         R4,0(,R10)          GET POINTER TO FIRST FQE\n         L         R10,4(,R10)         ADVANCE TO NEXT DQE\n         CR        R5,R3               IF LOW-BOUND<END OF AREA TO FREE\n         BL        RMSTART               THEN START DOWN FQE CHAIN\n         B         RMNXTDQE            OTHERWISE SKIP TO NEXT DQE\nRMFQELP  LR        R1,R5               ALLOC-AREA-START=LOW-BOUND\n         SR        R6,R6               ZERO CURRENT HIGH-BOUND\n         N         R4,=X'00FFFFFF'     IF THIS THE END OF THE FQE CHAIN\n         BZ        RMFQEEND            IS SO THEN SKIP NEXT\n         TM        RMSYSID,X'02'       IS THIS A VS SYSTEM\n         BZ        RMFQEOS             IF NOT USE ROUT FOR OS\n         TM        RMSYSID,X'10'       IS THIS VS2\n         BO        RMFQEVS2            IF SO THEN GO PROCESS\nRMFQEVS1 L         R6,4(,R4)           HIGH-BOUND=START OF FQE AREA\n         LR        R1,R6               COPY START OF FQE AREA\n         A         R1,8(,R4)           ALLOC-AREA-START=END OF FQE AREA\n         B         RMFQECOM            GO TO COMMON ROUTINE\nRMFQEVS2 L         R1,8(,R4)           ALLOC-AREA-START=END OF FQE AREA\n         LR        R6,R1               COPY END OF FQE AREA\n         S         R6,4(,R4)           HIGH BOUND=START OF FQE AREA\n         B         RMFQECOM            GO TO COMMON ROUTINE\nRMFQEOS  LR        R6,R4               HIGH BOUND=START OF FQE AREA\n         LR        R1,R6               COPY START OF FQE AREA\n         A         R1,4(,R4)           ALLOC-AREA-START=END OF FQE AREA\nRMFQECOM L         R4,0(,R4)           ADVANCE TO NEXT FQE\nRMFQEEND LA        R1,0(,R1)           CLEAR ANY FLAGS\n         CR        R1,R2               R1=MAXIMUM OF ALLOC-AREA-START\n         BNL       *+6                 AND\n         LR        R1,R2               START OF AREA TO FREE\n         CR        R0,R3               R0=MINIMUM OF ALLOC-AREA-END\n         BNH       *+6                 AND\n         LR        R0,R3               END OF AREA TO FREE\n         SR        R0,R1               CALCULATE LENGTH OF AREA TO FREE\n         BNP       *+6                 IF NOT POSITIVE SKIP THE SVC\n         SVC       10                  OTHERWISE ISSUE THE FREEMAIN SVC\nRMSTART  LA        R0,0(,R6)           ALLOC-AREA-END=HIGH-BOUND\n         CR        R0,R2               IF ALLOC-AREA-END > START OF\n         BH        RMFQELP               AREA TO FREE THEN LOOP\nRMNXTDQE N         R10,=X'00FFFFFF'    ARE THERE ANY MORE DQE'S\n         BNZ       RMDQELP             IF SO THEN CONTINUE\nRMRETURN LM        R2,R14,SAVEAREA+4   RESTORE CALLER'S REGISTERS\n         BR        R14                 AND RETURN\n         DROP      R11\n*\n*        TEST ROUTINE\n*        INPUT  R1=ADDR(DDNAME)\n*        OUTPUT R1=FILE POSITION INDICATOR\n*        CC=0 IF FILE EXISTS, CC=1 IF FILE DOES NOT EXIST\n*\n         USING     SYSINT,R15\nSYSTEST  STM       R2,R4,SAVEAREA      SAVE REGISTERS\n         L         R2,CVTPTR(,R0)      GET CVT POINTER\n         CLI       CVTCMS(R2),255      IS THIS CMS\n         BE        TESTCMS             IF SO THEN GO PROCESS\n         L         R2,CVTTCBP(,R2)     GET TASK SWITCH CELL POINTER\n         L         R2,TCBPTR(,R2)      GET ADDRESS OF CURRENT TASK\n         L         R2,TCBTIOT(,R2)     GET ADDRESS OF TIOT\n         LCR       R4,R2               SAVE COMPLEMENT FOR LATER\n         SR        R3,R3               CLEAR WORK REGISTER\nTESTLOOP AR        R2,R3               ADVANCE TO NEXT ENTRY\n         CLC       28(8,R2),0(R1)      COMPARE FOR FILE\n         BE        TESTRET             IF FOUND THEN STOP AND RETURN\n         IC        R3,24(,R2)          GET LENGTH OF CURRENT ENTRY\n         LTR       R3,R3               ARE WE AT END\n         BNZ       TESTLOOP            IF NOT THEN CONTINUE\nTESTRET1 OR        R13,R13             SET CC=1 FOR NOT FOUND\nTESTRET  LA        R1,4(R2,R4)         SET FILE POSITION INDICATOR\n         LM        R2,R4,SAVEAREA      RESTORE REGISTERS\n         BR        R14                 AND RETURN\nTESTCMS  L         R3,FCBFIRST(,R0)    GET START OF FILEDEF QUEUE\n         LCR       R4,R2               SAVE FOR LATER\nTESTCMS1 LA        R2,4(,R2)           BUMP RELATIVE POSITION POINTER\n         N         R3,=X'00FFFFFF'     IS THIS THE END OF THE QUEUE\n         BZ        TESTRET1            IF SO THEN RETURN 1 FOR NOT FND\n         CLC       FCBDDNAM(8,R3),0(R1)  COMPARE FOR DDNAME\n         BE        TESTRET             IF FOUND THEN STOP AND RETURN 0\n         L         R3,FCBLINK(,R3)     ADVANCE TO NEXT ENTRY\n         B         TESTCMS1            AND CONTINUE LOOP\n         DROP      R15\n*\n*        OPEN ROUTINE\n*        INPUT  R2=ADDR(IODEF SECTION OF IOCB)\n*               R1=OPEN CODE\n*        OUTPUT R2=ADDR(SYSTEM IOCB)\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSOPEN  LA        R2,0(,R2)           CLEAR UPPER BYTE OF R2\n         SLL       R1,24               GET OPEN CODE\n         OR        R2,R1               SAVE OPEN CODE\n         LR        R1,R13\n         L         R0,SYSIDENT-SYSINT(,R15)  GET SICA ID\nOPGSICA  L         R13,BKWDPTR         GO BACK UP SAVEAREA QUEUE\n         C         R0,SICAID           IS THIS THE SICA\n         BNE       OPGSICA-SYSINT(,R15) IF NOT THEN CONTINUE UP QUEUE\n         LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER\n         STM       R2,R15,SICAPIE      SAVE REGISTERS IN PIE\n         ST        R1,SICAPIE+(R13-R2)*4  SAVE R13\n         LR        R11,R15             LOAD BASE REGISTER\n         MVI       IOCODE+1,0\n         SR        R10,R10             CLEAR R10 FOR LENGTH\n         IC        R10,USERLNTH-IODEF(,R2)  GET LENGTH OF USER AREA\n         SLA       R10,3               CONVERT TO BYTES FROM DWORDS\n         LA        R0,IOCBEND-IODEF(,R10)   GET LENGTH OF IOCB\n         LCR       R1,R0               SET R1 NEGATIVE FOR GETMAIN\n         SVC       10                  GETMAIN SPACE FOR IOCB\n         AR        R10,R1              SET IOCB POINTER TO ADDR(IODEF)\n         SH        R10,=AL2(IODEF-IOCB)  REMOVE LENGTH OF PREFIX\n         XC        0(IOCBEND-IODEF,R1),0(R1)  ZERO USER'S AREA\n         XC        IODEF(IOCBEND-IODEF),IODEF  CLEAR IOCB\n         MVC       IODEF(IODEFEND-IODEF),0(R2)  MOVE IN INITIAL INFO\n         SR        R9,R9               CLEAR R9\n         IC        R9,FILETYPE         GET FILETYPE\n         SLL       R9,2                GET INDEX INTO FILECHAR TABLE\n         LA        R9,OPFILDEF(R9)     GET FILECHAR ENTRY\n         USING     FILECHAR,R9         SET UP USING FOR DSECT\n         MVC       OPENCODE(1),SICAPIE  GET OPEN CODE FROM TOP OF R2\n         MVC       DCBDSORG(1),FIDSORG  SET FILE DSORG\n         LA        R0,READEOF          SET EODAD FIELD\n         LA        R1,OPEXLST          SET ADDRESS OF EXLST\n         LM        R2,R3,DDNAME        SET DDNAME\n         LH        R4,FIMACRF          INSERT MACRF\n         SR        R5,R5               CHECK ROUTINE\n         LA        R6,IOERROR          SYNAD\n         CLI       FIDSORG,X'20'       IS THIS A BDAM FILE\n         BNE       *+8                 IF NOT THEN GO AROUND\n         LA        R6,OPBR14           OTHERWISE SET SYNAD TO BR R14\n         STM       R0,R6,DCBEODAD      STORE IN DCB\n         MVI       DCBOFLGS,X'0A'      SET DCBOFLGS\n         TM        DCBMACR,X'40'       IS THIS QSAM\n         BZ        *+8                 IF NOT THEN SKIP NEXT INST\n         MVI       DCBBUFCB+3,1        INDICATE OPEN TO GET BUFFERS\n         TM        OPENCODE,X'0F'      TEST OPEN CODE\n         BNZ       *+8                 IS IT OPEN FOR INPUT\n         MVI       DCBMACR+1,0         CLEAR OUTPUT FLAGS IF SO\n         BNO       *+8                 IS IT OPEN FOR OUTPUT\n         NI        DCBMACR,1           CLEAR INPUT FLAGS IF SO\n         CLI       BUFNO,128           IS THE BUFNO SPECIFIED\n         BNL       *+10                IF NOT THEN GO AROUND\n         MVC       DCBBUFNO(1),BUFNO   MOVE NUMBER OF BUFFERS TO DCB\n         MVC       IOCBLINK(4),IOCBQORG  ADD IOCB TO QUEUE\n         ST        R10,IOCBQORG\n         ST        R13,IOCBSICA        STORE SICA ADDRESS IN IOCB\n         OI        FLAGS,REREADSW      INDICATE OPEN EXIT TO EXLST RTN\n         LA        R0,IOCBDCB          GET ADDRESS OF DCB\n         ST        R0,DECBDCBA         AND STORE IT IN DECB\n         ST        R0,SICAPARM         AND IN PARM LIST FOR OPEN\n         ST        R0,IOCBSYS          STORE SYSTEM DEPENDENT POINTER\n         MVI       DECBTYPE,X'80'      INDICATE LENGTH TO COME FROM DCB\n         MVI       DCBBFTEK,X'42'      SET BFTEK\nOPENSVC  MVC       SICAPARM(1),OPENCODE  MOVE IN OPEN CODE\n         OI        SICAPARM,X'80'      INDICATE END OF OPEN PARM LIST\n         LA        R1,SICAPARM         SET PARM REG FOR OPEN\n         SVC       19                  ISSUE OPEN SVC\n         TM        DCBOFLGS,X'10'      DID DCB OPEN\n         BZ        OPENERR6            IF NOT THEN GIVE RETURN CODE 6\n*        CLI       DCBDSORG,X'20'      IS THIS A BDAM FILE\n*        BE        *+8                 IF SO THEN SKIP NEXT\n         NI        DCBCIND+1,255-X'08' STOP EOV FROM FREEING BUFFERS\n         CLI       FILETYPE,F$BDAMR    IS IT BDAM RELATIVE RECORD\n         BNE       *+10                IF NOT THEN SKIP NEXT\n         MVC       MAXRECNO+1(3),DCBREL GET NUMBER OF TRACKS OR BLOCKS\n         MVC       CHECKSAV(4),DCBROUT+4  SAVE CHECK/SYNC ROUTINE ADDR\n         L         R4,CVTPTR(,R0)      GET CVT POINTER\n         CLI       CVTCMS(R4),255      IS THIS CMS\n         BE        OPBLKOK             IF SO THEN SKIP NEXT\n         UNPK      SAVEAREA(3),DCBDEVT(2)  SEPARATE UPPER PARM OF DEVT\n         CLI       SAVEAREA,X'F2'      IS THE DEVICE DIRECT-ACCESS\n         BNE       OPBLKOK             IF NOT THEN SKIP THE NEXT CODE\n         L         R4,DCBDVTBL         GET PTR TO DEVICE TABLE ENTRY\n         LH        R0,4(,R4)           GET MAXIMUM BLKSIZE\n         CH        R0,=H'13165'        IS THIS A 3330\n         BNE       *+8                 IF NOT THEN GO AROUND\n         LH        R0,=H'13030'        GET CORRECT MAXIMUM BLKSIZE\n         CH        R0,BLKSI            COMPARE WITH BLKSIZE\n         BNL       OPBLKOK             IF MAX>=BLKSI THEN OK\n         OI        DCBCIND+1,X'10'     SET PERMANENT ERROR\n         STH       R0,DCBBLKSI         STORE MAXIMUM BLKSIZE\n         MVI       IOCODE+1,5          SET OPEN RETURN CODE\nOPBLKOK  EQU       *\nOPRETURN LR        R2,R10              SET SYSTEM IOCB ADDRESS IN R2\n         LH        R15,IOCODE          SET R15 TO RETURN CODE\n         LM        R3,R14,SICAPIE+4    RESTORE REGISTERS\nOPBR14   BR        R14                 AND RETURN TO CALLER\nOPENERR6 MVI       IOCODE+1,6          SET OPEN RETURN CODE TO 6\n         CLI       FILETYPE,F$QSAMR    IS THIS A RETURN CODE FILE\n         BNL       OPRETURN            IF SO THEN GIVE RETURN CODE 6\n         LM        R2,R3,DDNAME        LOAD DDNAME INTO REGS\n         L         R1,OPABCODE         SET ABEND CODE TO U0013\n         SVC       13                  ISSUE ABEND SVC\nOPABCODE DC        0F'0',X'8000',AL2(13)\nOPFILDEF EQU       *-4\n         DC        X'48504000'         F$QSAM\n         DC        X'24244000'         F$BSAM\n         DC        X'24240200'         F$BPAM\n         DC        X'48504000'         F$QSAMR\n         DC        X'20284000'         F$BSAMR\n         DC        X'20284000'         F$BSAMK\n         DC        X'29282000'         F$BDAMR\n         DC        X'31322000'         F$BDAMK\nOPEXLST  DC        0F'0',X'05',AL3(EXITROUT)\n         DC        0F'0',X'88',AL3(EXITB37)\nEXITROUT XI        FLAGS-IOCBDCB(R1),REREADSW  REVERSE REREADSW\n         TM        FLAGS-IOCBDCB(R1),REREADSW  IS EXIT FROM OPEN\n         BZ        EXITOPEN            IF SO THEN CONTINUE\n         LA        R0,IOCBDCB-IOCB     GET OFFSET OF DCB IN IOCB\n         SR        R1,R0               GET IOCB ADDRESS\n         MVC       DCBBUFNO-IOCB(1,R1),BUFNO-IOCB(R1)  RECOVER BUFNO\n         BR        R14                 AND RETURN TO EOV\nEXITOPEN MVC       DCBKEYLE(1),KEYLEN  SET KEY LENGTH FROM IOCB\n         L         R2,CVTPTR(,R0)      GET CVT POINTER\n         CLI       CVTCMS(R2),255      IS THIS CMS\n         BE        EXITCMS             IF SO THEN SKIP NEXT\n         L         R2,DCBDEBAD         GET POINTER TO OPEN WORK AREA\n         CLC       257(3,R2),=F'0'     IS THERE A SECONDARY ALLOCATION\n         BZ        *+8                 IF NOT THEN SKIP NEXT CODE\n         OI        FLAGS,SECALLOC      SET SECONDARY ALLOCATION FLAG\nEXITCMS  EQU       *\n         MVC       SICAPARM+4(1),DCBRECFM  SAVE FILE RECFM\n         TM        DCBRECFM,X'C0'      IS DCBRECFM TYPE DEFINED\n         BZ        EXRECFMD            IF NOT THEN USE DEFAULT RECFM\n         MVC       SICAPARM+5(1),DCBRECFM  MOVE DCBRECFM TO TEMP\n         XC        SICAPARM+5(1),RECFM     EXCLUSIVE OR WITH RECFM\n         OC        SICAPARM+5(1),RECMERGE  TURN MERGABLE BITS ON\n         XC        SICAPARM+5(1),RECMERGE  TURN MERGABLE BITS OFF\n         BZ        EXRECFM             IF ZERO THEN DCBRECFM IS OK\nEXRECFMD MVC       DCBRECFM(1),RECFM   OTHERWISE USE DEFAULT\nEXRECFM  MVC       RECFM(1),DCBRECFM   MERGE RECFM BACK INTO IOCB\n         TM        RECFM,X'80'         IS RECFM=V\n         BO        *+8                 IF NOT THEN GO AROUND\n         MVI       VLIND+1,4           SET LENGTH OF RCW TO 4\n         CLI       FILETYPE,F$QSAMR    IS THIS A RETURN CODE FILE\n         BNL       EXITRETC            IF SO THEN GO TO PROPER CODE\n         LH        R6,VLIND            PUT RCW LENGTH IN R6\n         LH        R4,LRECL            GET IOCB LRECL\n         LPR       R4,R4               MAKE LRECL POSITIVE\n         LH        R7,MAXLRECL         GET MAXIMUM LRECL\n         LTR       R7,R7               IS MAXLRECL SPECIFIED\n         BZ        EXLRECL             IF NOT THEN LRECL IS FORCED\n         LH        R5,DCBLRECL         PICK UP DCB LRECL FIELD\n         SR        R5,R6               SUBTRACT POSSIBLE RCW\n         BNP       EXLRECL             IF NO DCBLRECL THEN USE DEFAULT\n         LR        R4,R5               OTHERWISE USE DCBLRECL\n         CR        R4,R7               COMPARE WITH MAXIMUM\n         BNH       EXLRECL             IF NOT HIGH THEN IS OK\n         LR        R4,R7               OTHERWISE USE MAXIMUM\nEXLRECL  STH       R4,LRECL            SAVE FINAL LRECL IN IOCB\n         AR        R4,R6               ADD IN POSSIBLE RCW\n         STH       R4,DCBLRECL         SAVE IN DCB LRECL FIELD\n         LH        R7,BLKSI            GET IOCB BLKSI\n         LCR       R5,R7               COMPLEMENT AND TEST\n         BM        EXBLKSI             IF IOCB BLKSI>0 THEN IS FORCED\n         LH        R7,DCBBLKSI         PICK UP DCB BLKSI FIELD\n         LTR       R7,R7               IF BLKSI SPECIFIED ON DD, USE IT\n         BNZ       EXBLKSI\n         LTR       R7,R5               OTHERWISE USE DEFAULT\n         BNZ       EXBLKSI             IF DEFAULT\u00ac=0 THEN GO AND USE\n         LR        R7,R4               SET BLKSIZE=LRECL\n         AR        R7,R6               ADD IN BCW\nEXBLKSI  TM        DCBRECFM,X'40'      IS RECFM=F\n         BO        EXBLKSI1            IF NOT THEN GO AROUND\n         DR        R6,R4               DIVIDE BLKSIZE BY LRECL\n         MR        R6,R4               ROUND TO NEAREST MULTIPLE\n         LTR       R7,R7               IS BLKSI=0\n         BNZ       EXBLKSI1            IF NOT THEN CONTINUE\n         LR        R7,R4               SET BLKSI=LRECL\nEXBLKSI1 STH       R7,DCBBLKSI         STORE BLKSIZE IN DCB\n         STH       R7,BLKSI            STORE BLKSIZE IN IOCB\n         CLI       DCBBUFNO,0          HAS BUFNO BEEN SPECIFIED\n         BNE       EXBUFNO             IF SO THEN SKIP NEXT\n         XI        BUFNO,X'80'         REVERSE UPPER BIT OF BUFNO\n         CLC       DCBBLKSI(1),BUFNO   IS (BLKSI/256)>=CRITICAL BLKSI\n         BL        EXBUFNO             IF NOT THEN LEAVE BUFNO AS IS\n         MVI       DCBBUFNO,1          CHANGE BUFNO TO 1\nEXBUFNO  MVC       BUFNO(1),DCBBUFNO   SAVE BUFNO FOR EOV\n         BR        R14                 AND RETURN TO OPEN\nEXITRETC LR        R8,R14              SAVE RETURN ADDRESS\n         TM        OPENCODE,X'0F'      IS FILE OPEN FOR OUTPUT\n         BO        EXRRECFM            IF SO THEN RECFM IS OK\n         TM        SICAPARM+4,X'C0'    IS FILE RECFM DEFINED\n         BNZ       EXRECHEK            IF SO THEN CHECK IF COMPATIBLE\n         L         R2,CVTPTR(,R0)      GET CVT POINTER\n         CLI       CVTCMS(R2),255      IS THIS CMS\n         BE        EXRRECFM            IF SO THEN ACCEPT RECFM AS IS\n         B         EXITERR1            OTHERWISE GIVE ERROR 1\nEXRECHEK TM        DCBRECFM,X'C0'      IS RECFM=U\n         BO        EXRRECFM            IF SO THEN OK\n         XC        SICAPARM+4(1),DCBRECFM\n         TM        SICAPARM+4,X'C0'    ARE RECFMS COMPATIBLE\n         BNZ       EXITERR2            IF NOT THEN GIVE ERROR 2\nEXRRECFM LH        R1,BLKSI            GET FILE BLKSIZE\n         LTR       R0,R1               IS BLKSIZE>0\n         BP        EXRBLKSI            THEN IT IS FORCED\n         LH        R1,DCBBLKSI         GET MERGED IN BLKSIZE\n         LTR       R1,R1               HAS BLKSIZE BEEN SPECIFIED\n         BP        EXRBLKSI            AND IF ZERO THEN GIVE ERROR 1\n         LPR       R1,R0               CHECK IF ANY DEFAULT BLKSIZE\n         BZ        EXITERR1            AND IF ZERO THEN GIVE ERROR 1\nEXRBLKSI STH       R1,DCBBLKSI         STORE IN DCB BLKSIZE\n         STH       R1,BLKSI            AND IN BLKSI\n         CLI       FILETYPE,F$QSAMR    IS THIS RETURN CODE QSAM\n         BNE       EXNQSAMR            IF NOT THEN SKIP NEXT\n         LH        R2,LRECL            GET FILE LRECL\n         LTR       R2,R2               IS IT ZERO\n         BNZ       EXLRECOK            IF NOT THEN SKIP NEXT\n         LH        R2,DCBLRECL         GET MERGED IN LRECL\n         SH        R2,VLIND            REMOVE RCW LENGTH\n         BNP       EXITERR1            AND IF ZERO THEN GIVE ERROR 1\nEXLRECOK STH       R2,LRECL            STORE IN FILE LRECL\n         AH        R2,VLIND            ADD IN RCW LENGTH\n         STH       R2,DCBLRECL         AND IN DCB LRECL\n         SR        R0,R0               CLEAR R0 FOR DIVIDE\n         DR        R0,R2               DIVIDE BLKSIZE BY LRECL\n         TM        DCBRECFM,X'40'      IS RECFM=F\n         BO        EXITNOTF            IF NOT THEN GO AROUND\n         LTR       R0,R0               IS REMAINDER ZERO\n         BNZ       EXITERR4            IF NOT THEN GIVE ERROR 4\nEXITNOTF SR        R1,R1               CLEAR R1\n         IC        R1,DCBBUFNO         GET BUFNO\n         LTR       R1,R1               IS IT ZERO\n         BNZ       *+8                 IF NOT THEN SKIP NEXT\n         LA        R1,2                SET TO 2\n         MH        R1,BLKSI            MULTIPLY BY BLKSIZE\n         LA        R1,256(,R1)         ADD IN EXTRA\n         BAL       R14,GETMAIN         CALL GETMAIN\n         BNZ       EXITERR3            IF NOT ENOUGH GIVE ERROR 3\n         SVC       10                  FREE THE MEMORY\nEXNQSAMR NI        DCBOPTCD,255-1      CLEAR RELATIVE MODE FLAG\n         CLI       FILETYPE,F$BDAMR    IS THIS BDAM RELATIVE RECORD\n         BNE       *+8                 IF NOT THEN SKIP NEXT\n         MVI       DCBOPTCD,1          INSERT OPTCD\n         BR        R8                  AND RETURN\nEXITERR4 XI        IOCODE+1,7          SET IOCODE TO 4\nEXITERR3 XI        IOCODE+1,1          SET IOCODE TO 3\nEXITERR2 XI        IOCODE+1,3          SET IOCODE TO 2\nEXITERR1 XI        IOCODE+1,1          SET IOCODE TO 1\n         MVI       DCBRECFM,X'C0'      SET RECFM=U\n         LA        R1,16               SET BLKSI & LRECL TO 16\n         STH       R1,DCBLRECL         SET LRECL=16\n         STH       R1,DCBBLKSI         SET BLKSI=16\n         BR        R8                  RETURN TO OPEN\n         DROP      R9\n         USING     EXITB37,R15\nEXITB37  SH        R1,=AL2(IOCBDCB-IOCB)\n         LA        R15,2               EOV CODE FOR ABEND\n         CLI       FILETYPE-IOCB(R1),F$QSAMR  RETURN CODE TYPE ?\n         BCR       4,R14               IF NOT THEN ABEND\n         BCTR      R15,0               EOV CODE FOR TAKE SYNAD EXIT\n         L         R1,IOCBSICA-IOCB(,R1)  GET SICA POINTER\n         MVI       IOCODE+1-SICA(R1),2 SET IO RETURN CODE\n         BR        R14                 AND RETURN TO EOV\n         DROP      R15\n*\n*        CLOSE ROUTINE\n*        INPUT  R2=ADDR(SYSTEM IOCB)\n*               R1=CLOSE CODE\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSCLOSE LTR       R2,R2               IS THIS A NULL FILE\n         BCR       8,R14               IF SO THEN RETURN\n         STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\n         LA        R15,IOCBDCB         GET DCB ADDRESS\n         ST        R15,SICAPARM        SAVE IN CLOSE PARM LIST\n         STC       R1,SICAPARM         STORE CLOSE CODE\n         OI        SICAPARM,X'80'      INDICATE END OF CLOSE PARM LIST\n         LA        R1,SICAPARM         SET PARM REG FOR CLOSE\n         SVC       20                  ISSUE CLOSE SVC\n*        FREEPOOL  IOCBDCB             FREE BUFFER POOL\n         L         R15,DCBBUFCB        GET BUFCB POINTER\n         N         R15,=X'00FFFFFF'    IS THERE A BUFFER POOL\n         BZ        CLOSE1              IF NOT THEN GO AROUND\n         SR        R14,R14             CLEAR R14\n         IC        R14,5(,R15)         GET NUMBER OF BUFFERS\n         MH        R14,6(,R15)         MULTIPLY BY BUFFER LENGTH\n         LA        R0,8(,R14)          GET LENGTH INCLUDING BUFCB\n         LA        R1,0(,R15)          SET ADDRESS FOR FREEMAIN\n         SVC       10                  ISSUE FREEMAIN SVC\nCLOSE1   LA        R1,IOCBQORG         GET ADDR OF START OF IOCB QUEUE\n         SH        R1,=AL2(IOCBLINK-IOCB)  MAKE LOOK LIKE DUMMY IOCB\nCLOSLOOP LR        R2,R1               SAVE PREVIOUS POINTER\n         L         R1,IOCBLINK-IOCB(,R1)  ADVANCE TO NEXT IOCB\n         CR        R1,R10              IS THIS THE IOCB\n         BNE       CLOSLOOP            IF NOT THEN CONTINUE DOWN QUEUE\n         MVC       IOCBLINK-IOCB(4,R2),IOCBLINK-IOCB(R1)  DELINK IOCB\n         SR        R1,R1               CLEAR R1\n         IC        R1,USERLNTH         GET LENGTH OF USER AREA\n         SLA       R1,3                CONVERT TO BYTES FROM DWORDS\n         LA        R0,IOCBEND-IODEF(,R1)  GET LENGTH OF IOCB\n         LA        R1,IOCBEND          GET END OF IOCB\n         SR        R1,R0               GET START OF IOCB\n         SVC       10                  ISSUE FREEMAIN SVC\n         B         IORET               AND RETURN\n*\n*        GET ROUTINE\n*        INPUT  R1=ADDR OF TO AREA(MOVE MODE), OR R1=0(LOCATE MODE)\n*               R0=LENGTH OF TO AREA(MOVE MODE)\n*               R2=ADDR OF IOCB\n*        OUTPUT R1=ADDR OF RECORD(RCW NOT INCLUDED FOR RECFM=V)\n*               R0=LENGTH OF RECORD(RCW LENGTH NOT INCLUDED FOR V)\n*        CC=0 FOR OK, CC=1 FOR EOF,\n*        CC=3 FOR IO ERROR.\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSGET   STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\nREGET    NI        FLAGS,255-REREADSW  TURN OFF REREAD SWITCH\n*        GET       IOCBDCB\n         LA        R1,IOCBDCB          GET DCB ADDRESS FOR GET\n         L         R15,DCBROUT         LOAD GET ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL IT\n         TM        FLAGS,REREADSW      IS REREAD REQUIRED\n         BO        REGET               IF SO THEN DO IT\n         LH        R0,LRECL            LOAD LRECL IN CASE RECFM=F\n         TM        RECFM,X'40'         IS THIS RECFM F\n         BZ        GETCOM              IF SO THEN GO TO COMMON ROUTINE\n         TM        RECFM,X'C0'         IS IT RECFM U\n         BO        GETU                IF SO THEN GO PROCESS\n         MVC       SAVEAREA(2),0(R1)   ALIGN RCW\n         LH        R0,SAVEAREA         AND PUT IN R0\n         SH        R0,VLIND            SUBTRACT LENGTH OF RCW\n         LA        R1,4(,R1)           AND SKIP OVER RCW\n         B         GETCOM              GO TO COMMON ROUTINE\nGETU     L         R4,DCBIOBA          GET POINTER TO IOB PREFIX\n         LH        R0,BLKSI            GET SIZE OF READ\n         SH        R0,22(,R4)          SUBTRACT RESIDUAL COUNT\nGETCOM   LTR       R2,R2               IS RECORD TO BE MOVED\n         BZ        IORET0              IF NOT THEN RETURN ADDR AND LNTH\n         BAL       R14,MOVE            MOVE RECORD INTO AREA\nIORET0   CR        R0,R0               SET CC=0\nIORET    LH        R15,IOCODE          LOAD RETURN CODE\nRETURN   LR        R13,R12             RESTORE CALLER'S R13\n         LM        R2,R14,SAVEAREA     RESTORE CALLER'S REGISTERS\n         BR        R14                 AND RETURN\nREADEOF  DC        0H'0'               SET CC=3 FOR END-OF-FILE\nIORET1   OR        R13,R13             SET CC=1\n         B         IORET               AND RETURN\nIOERROR  MVC       DCBROUT+4(4),CHECKSAV  RESTORE CHECK ROUTINE ADDRESS\nIORET3   TM        *+1,1               SET CC=3\n         B         IORET               AND RETURN\nIOINIT   LR        R11,R15\n         LA        R10,0(,R2)          MOVE IOCB ADDR AND CLEAR FLAGS\n         LR        R12,R13             SAVE R13\n         L         R13,IOCBSICA        LOAD SICA POINTER\n         LPR       R3,R0               SAVE LENGTH\n         LR        R2,R1               SAVE AREA ADDRESS\n         STM       R10,R12,SICAPIE     SAVE REGS FOR LATER\n         MVI       IOCODE+1,0          INITIALIZE RETURN CODE\n         BR        R14\n         DROP      R11\n*\n*        PUT ROUTINE\n*        INPUT  R1=ADDR OF RECORD(RCW NOT INCLUDED FOR RECFM=V)\n*               R0=LENGTH OF RECORD(RCW LENGTH NOT INCLUDED FOR V)\n*               R2=ADDR OF IOCB\n*        OUTPUT R1=ADDR OF AREA FOR NEXT RECORD(LOCATE MODE)\n*        CC=0 FOR OK\n*        CC=3 AND R15=0 FOR IO ERROR\n*        CC=3 AND R15=1 FOR DATA SET IS FULL\n*        CC=3 AND R15=2 FOR DISK VOLUME IS FULL\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSPUT   STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\n         SH        R2,VLIND            SUBTRACT POSSIBLE RCW\n*        PUT       IOCBDCB,(1)\n         LR        R0,R2               MOVE AREA ADDRESS INTO R0\n         LA        R1,IOCBDCB          GET DCB ADDRESS FOR PUT\n         L         R15,DCBROUT         GET PUT ROUTINE ADDRESS\n         TM        OPENCODE,X'0F'      IS FILE OPEN FOR IO\n         BM        PUTX                IF SO THEN GO TO PUTX\n         MVC       SICAPARM(4),0(R2)   SAVE POSSIBLE RCW\n         TM        RECFM,X'80'         IS RECFM=V\n         BO        PUTNOTV             IF NOT THEN GO AROUND\n         AH        R3,VLIND            ADD ON RCW LENGTH\n         STH       R3,SAVEAREA         SAVE IN ALIGNED AREA\n         MVC       0(2,R2),SAVEAREA    AND MOVE IN RCW\n         XC        2(2,R2),2(R2)       AND MOVE IN ZERO\nPUTNOTV  LH        R4,DCBLRECL         SAVE LRECL FIELD\n         TM        RECFM,X'C0'         IS RECFM=U\n         BNO       *+8                 IF NOT THEN SKIP NEXT\n         STH       R3,DCBLRECL         SET LRECL\n         CLI       FILETYPE,F$QSAM     IS THIS QSAM\n         BE        *+10                IF SO THEN SKIP CHECK\n         MVC       DCBROUT+5(3),=AL3(CHECK)  MOVE IN CHECK ROUTINE\n         BALR      R14,R15             AND CALL PUT ROUTINE\n         MVC       DCBROUT+4(4),CHECKSAV  RESTORE CHECK ROUTINE ADDRESS\n         MVC       0(4,R2),SICAPARM    RESTORE POSSIBLE RCW\n         STH       R4,DCBLRECL         RESTORE LRECL\n         B         IORET0              AND RETURN\nPUTX     BAL       R14,4(,R15)         CALL PUTX ROUTINE\n         B         IORET0              AND RETURN\nCHECK    STM       R9,R12,SICAPIE+12   SAVE REGISTERS\n         LM        R10,R12,SICAPIE     RESTORE REGISTERS\n         TM        DCBCIND,X'20'       IS EXTENT FULL\n         BZ        CHECKRET            IF NOT THEN RETURN\n         CLI       DCBFDAD,15          ARE THERE 16 EXTENTS\n         BNL       CHECKERR            IF NOT THEN ERROR\n         TM        FLAGS,SECALLOC      IS THERE A SECONDARY ALLOCATION\n         BO        CHECKRET            IF SO THEN CONTINUE\nCHECKERR L         R9,DCBIOBA          GET IOB ADDRESS\n         NI        20(R9),X'FE'        TURN OFF CSW UNIT EXCEPTION BIT\n         NI        DCBCIND,255-X'20'   TURN OFF FULL BIT\n         OI        DCBCIND+1,X'10'     INDICATE PERMANENT IO ERROR\n         MVI       IOCODE+1,1          SET CODE FOR CALLER\n         B         IORET3              AND RETURN WITH IO ERROR\nCHECKRET L         R15,CHECKSAV        GET REAL CHECK ROUTINE ADDRESS\n         LM        R9,R12,SICAPIE+12   RESTORE REGISTERS\n         BR        R15                 AND GO TO IT\n         DROP      R11\n*\n*        READ ROUTINE\n*        INPUT  R1=ADDR OF BLOCK(BCW AND RCW INCLUDED FOR RECFM=V)\n*               R0=LENGTH OF BLOCK(BCW AND RCW INCLUDED FOR RECFM=V)\n*                  +N READ N BYTES\n*                  +1 READ BLKSIZE BYTES\n*                   0 READ BLKSIZE BYTES\n*                  -1 READ BLKSIZE BYTES\n*                  -N READ N BYTES\n*               R2=ADDR OF IOCB\n*               R3=RELATIVE RECORD NUMBER FOR RELATIVE FILES\n*                  A(TRACKNO,KEY ADDR) FOR DIRECT\n*        OUTPUT R1=ADDR(RECORD)\n*               R0=LENGTH(RECORD)\n*        CC=0 FOR OK, CC=1 FOR EOF,\n*        CC=3 FOR IO ERROR.\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSREAD  STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\n         MVI       DECBECB,X'7F'       INITIALIZE ECB\n         LH        R4,DCBBLKSI         SAVE BLKSIZE\n         CL        R3,=F'1'            HAS LENGTH BEEN SPECIFIED\n         BH        *+6                 IF SO THEN USE IT\n         LR        R3,R4               OTHERWISE USE BLKSIZE\n         STH       R3,DCBBLKSI         STORE LENGTH TO READ\n         CLI       FILETYPE,F$BDAMR    IS THIS A BDAM FILE\n         BNL       READBDAM            IF SO THEN GO TO BDAM CODE\n         ST        R2,DECBAREA         STORE AREA ADDRESS IN DECB\n         MVI       DECBTYPE+1,X'80'    INDICATE READ\nREREAD   NI        FLAGS,255-REREADSW  TURN OFF REREAD SWITCH\n*        READ      IOCBDECB\n         LA        R1,IOCBDECB         GET DCB ADDRESS FOR READ\n         L         R15,DCBROUT         LOAD READ ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL IT\n*        CHECK     IOCBDECB\n         LA        R1,IOCBDECB         LOAD DECB ADDRESS\n         L         R15,DCBROUT+4       LOAD CHECK ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL IT\n         TM        FLAGS,REREADSW      IS REREAD REQUIRED\n         BO        REREAD              IF SO THEN DO IT\n         L         R3,DECBIOBA         LOAD IOB POINTER\n         LH        R0,DCBBLKSI         GET READ LENGTH\n         SH        R0,14(,R3)          SUBTRACT RESIDUAL COUNT\n         STH       R4,DCBBLKSI         RESTORE BLKSIZE\n         B         IORET0              AND RETURN\nREADBDAM LA        R15,X'0148'         INITIALIZE FOR RELATIVE RECORD\n         L         R6,SAVEAREA+4-SICA(,R12)  GET KEY PARM FROM SAVED R3\nREADREL  LA        R7,DECKYADR+1       SET ADDRESS TO POINT TO NUMBER\n         BE        BDAMIO              IF RELATIVE THEN GO DO IO\n         LA        R15,X'004C'         SET TYPE FOR TRACKNO AND KEY\nREADKEY  LA        R7,2(,R6)           GET POINTER TO TRACK NUMBER\n         L         R6,4(,R6)           GET POINTER TO KEY\nBDAMIO   STH       R15,DECBTYPE        SAVE TYPE\n         STM       R6,R7,DECKYADR      STORE KEY POINTER AND TRACK PTR\n         ST        R2,DECBAREA         STORE AREA ADDRESS IN DECB\n*        READ      IOCBDECB\n         LA        R1,IOCBDECB         GET DCB ADDRESS FOR READ\n         L         R15,DCBROUT         LOAD READ ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL IT\n*        CHECK     IOCBDECB\n         LA        R1,IOCBDECB         LOAD DECB ADDRESS\n         L         R15,DCBROUT+4       LOAD CHECK ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL IT\n         L         R3,DECBIOBA         GET IOB POINTER\n         LH        R0,DCBBLKSI         GET BLKSIZE\n         SH        R0,14(,R3)          SUBTRACT RESIDUAL COUNT\n         STH       R4,DCBBLKSI         RESTORE BLKSIZE\n         TM        DECBECB+1,X'80'     WAS RECORD NOT FOUND\n         BO        IORET1              IF NOT FOUND THEN RETURN 1\n         TM        DECBECB+1,X'10'     WAS IT AN INVALID REQUEST\n         BZ        IORET0              IF VALID THEN RETURN 0\n         TM        DECBECB+2,X'11'     IF KEY BEGINS X'FF' OR NOT IN\n         BNZ       IORET1              DATA SET THEN RETURN 1\n         B         IORET0              OTHERWISE RETURN 0\n         DROP      R11\n*\n*        WRITE ROUTINE\n*        INPUT  R1=ADDR OF BLOCK(BCW AND RCW INCLUDED FOR RECFM=V)\n*               R0=LENGTH OF BLOCK(BCW AND RCW INCLUDED FOR RECFM=V)\n*                  +N WRITE N BYTES\n*                  +1 WRITE BLKSIZE BYTES\n*                   0 WRITE DUMMY RECORD FOR F$BSAMK RECFM=F\n*                     WRITE CAPACITY RECORD FOR F$BSAMK RECFM=V OR U\n*                     WRITE BLKSIZE BYTES FOR ALL OTHER FILES\n*                  -1 REWRITE BLKSIZE BYTES\n*                  -N REWRITE N BYTES\n*               R2=ADDR OF IOCB\n*               R3=RELATIVE RECORD NUMBER FOR RELATIVE FILES\n*                  A(TRACKNO,KEY ADDR) FOR DIRECT\n*        OUTPUT\n*        CC=0 FOR OK(FOR F$BSAMR OR F$BSAMK R15 SET AS FOR BSAM LOAD)\n*        CC=1 FOR EOF OR RECORD NOT FOUND(BDAM)\n*        CC=3 AND R15=0 FOR IO ERROR\n*        CC=3 AND R15=1 FOR DATA SET FULL\n*        CC=3 AND R15=2 FOR DISK PACK FULL\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSWRITE STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\n         MVI       DECBECB,X'7F'       INITIALIZE ECB\n         LH        R4,DCBBLKSI         SAVE BLKSIZE\n         CL        R3,=F'1'            HAS LENGTH BEEN SPECIFIED\n         BH        *+6                 IF SO THEN USE IT\n         LR        R3,R4               OTHERWISE USE BLKSIZE\n         STH       R3,DCBBLKSI         STORE LENGTH TO WRITE\n         TM        RECFM,X'80'         IS RECFM=V\n         BO        WRITNOTV            IF NOT THEN GO AROUND\n         SR        R15,R15             CLEAR R15\n         CLI       DCBDSORG,X'20'      IS THIS BDAM\n         BE        *+8                 IF SO THEN SKIP NEXT\n         IC        R15,KEYLEN          GET KEY LENGTH\n         AR        R15,R2              GET POINTER TO BCW\n         XC        SAVEAREA+2(2),SAVEAREA+2  INITIALIZE TO ZERO\n         STH       R3,SAVEAREA         SAVE IN ALIGNED AREA\n         MVC       0(4,R15),SAVEAREA   MOVE IN BCW\n         TM        RECFM,X'10'         ARE RECORDS BLOCKED\n         BO        WRITNOTV            IF SO THEN NO RCW\n         SH        R3,VLIND            GET LENGTH OF RECORD\n         STH       R3,SAVEAREA         SAVE IN ALIGNED AREA\n         MVC       4(4,R15),SAVEAREA   MOVE RCW INTO BUFFER\nWRITNOTV CLI       FILETYPE,F$BDAMR    IS THIS A BDAM FILE\n         BNL       WRITBDAM            IF SO THEN GO TO BDAM CODE\n         ST        R2,DECBAREA         STORE AREA ADDRESS IN DECB\n         MVI       DECBTYPE+1,X'20'    INITIALIZE TO WRITE RECORD(SF)\n         CLI       FILETYPE,F$BSAMR    IS THIS A BSAM LOAD MODE FILE\n         BNL       WRITLOAD            IF SO THEN GO TO BSAM LOAD CODE\n*        WRITE     IOCBDECB\n         LA        R1,IOCBDECB         GET DCB ADDRESS FOR WRITE\n         L         R15,DCBROUT         LOAD WRITE ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL IT\n*        CHECK     IOCBDECB\n         LA        R1,IOCBDECB         LOAD DECB ADDRESS FOR CHECK\n         L         R15,DCBROUT+4       LOAD CHECK ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL IT\n         STH       R4,DCBBLKSI         RESTORE BLKSIZE\n         B         IORET0              AND RETURN\nWRITLOAD BE        WRITREC             IF NOT KEYED THEN GO WRITE(SF)\n         LTR       R0,R0               IS THIS A RECORD WRITE\n         BP        WRITREC             IF SO THEN GO WRITE RECORD(SF)\n         MVI       DECBTYPE+1,X'04'    SET FOR CAPACITY RECORD(SZ)\n         TM        RECFM,X'40'         IS THIS RECFM=F\n         BNZ       WRITREC             IF NOT THEN GO WRITE CAPACITY\n         MVI       DECBTYPE+1,X'10'    CHANGE TO WRITE DUMMY RECORD(SD)\n*        WRITE     IOCBDECB\nWRITREC  LA        R1,IOCBDECB         LOAD DECB ADDRESS FOR WRITE\n         L         R15,DCBROUT         LOAD WRITE ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL IT\n         LR        R2,R15              SAVE RETURN CODE IN R2\n*        CHECK     IOCBDECB\n         LA        R1,IOCBDECB         LOAD DECB ADDRESS FOR CHECK\n         BAL       R14,CHECK           CALL CHECK ROUTINE\n         STH       R4,DCBBLKSI         RESTORE BLKSIZE\n         STC       R2,IOCODE+1         SAVE RETURN CODE\n         B         IORET0              AND RETURN\nWRITBDAM LA        R15,X'0140'         INITIALIZE FOR RELATIVE RECORD\n         L         R6,SAVEAREA+4-SICA(,R12)  GET KEY PARM FROM SAVED R3\n         BE        READREL             IF RELATIVE THEN GO DO WRITE\n         LA        R15,X'0042'         CHANGE TO ADD TYPE\n         LTR       R0,R0               IS THIS A REWRITE\n         BNM       READKEY             IF NOT THEN GO DO WRITE\n         LA        R15,X'0044'         CHANGE TO REWRITE TYPE\n         B         READKEY             GO DO WRITE\n         DROP      R11\n*\n*        NOTE ROUTINE\n*        INPUT  R2=ADDR OF IOCB\n*        OUTPUT R1=NOTE CONTROL INFORMATION SUITABLE FOR POINT\n*                  FOR DISK CTTTRR00 WHERE C=CONCATNO,\n*                           TTT=RELATIVE TRACK AND RR=RECORDNO\n*                  FOR TAPE BLOCK NUMBER IN BINARY\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSNOTE  STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\n         LA        R1,IOCBDCB          SET DCB ADDRESS FOR NOTE\n         L         R15,DCBNOTE         GET NOTE/POINT ROUTINE ADDRESS\n         BALR      R14,R15             AND CALL NOTE ROUTINE\n         IC        R0,DCBRELAD+3       GET CONCATENATION NUMBER IF DISK\n         SLL       R0,28               SHIFT INTO UPPER HBYTE OF WORD\n         OR        R1,R0               INSERT CONCATNO INTO ADDRESS\n         B         IORET0              AND RETURN\n         DROP      R11\n*\n*        POINT ROUTINE\n*        INPUT  R2=ADDR OF IOCB\n*               R1=NOTE CONTROL INFORMATION\n*               R0=0 FOR CURRENT RECORD\n*                  1 FOR NEXT RECORD\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSPOINT STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\n         AR        R1,R0               ADD IN NEXT RECORD INDICATOR\n         SR        R0,R0               CLEAR R0\n         SLDL      R0,4                MOVE CONCATNO IF DISK INTO R0\n         SRL       R1,4                FIX UP REMAINDER OF NOTE INFO\n         ST        R1,DECBAREA         SAVE INFO IN STORAGE\n         STC       R0,DCBRELAD+3       SAVE POSSIBLE CONCATNO IN DCB\n         LA        R1,IOCBDCB          SET DCB ADDRESS FOR POINT\n         LA        R0,DECBAREA         SET PARM REG FOR POINT\n         L         R15,DCBNOTE         GET NOTE/POINT ROUTINE ADDRESS\n         BAL       R14,4(,R15)         AND CALL POINT ROUTINE\n         B         IORET0              AND RETURN\n         DROP      R11\n*\n*        FIND ROUTINE\n*        INPUT  R2=ADDR OF IOCB\n*               R1=ADDR OF NAME OF MEMBER TO FIND\n*        OUTPUT\n*        CC=0 FOR FOUND, CC=1 FOR NOT FOUND, CC=2 FOR IO ERROR\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSFIND  STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\n         LR        R0,R1               SET PARM REG FOR FIND\n         LA        R1,IOCBDCB          SET DCB ADDRESS FOR FIND\n         LCR       R1,R1               INDICATE D TYPE FIND\n         SVC       18                  ISSUE FIND SVC\n         CH        R15,=H'8'           IS THERE AN IO ERROR\n         BE        IORET2              IF SO THEN RETURN 2\n         OR        R15,R15             SET CC=0 FOR FOUND,CC=1 FOR NOT\n         B         IORET               AND RETURN\n         DROP      R11\n*\n*        STOW ROUTINE\n*        INPUT  R2=ADDR OF IOCB\n*               R1=ADDR OF NAME OF MEMBER TO STOW\n*        OUTPUT\n*        CC=0 MEMBER REPLACED, CC=1 MEMBER ADDED\n*        CC=2 MEMBER NOT ADDED OR REPLACED(FULL OR IO ERROR)\n*\n         USING     SYSINT,R11\n         USING     IOCB,R10\nSYSSTOW  STM       R2,R15,SAVEAREA     SAVE REGISTERS\n         BAL       R14,IOINIT-SYSINT(,R15)\n         MVC       SICAPARM(8),0(R1)   MOVE OVER NAME\n         XC        SICAPARM+8(4),SICAPARM+8  ZERO TTR AND BITS\n         LA        R0,SICAPARM         LOAD ADDR OF STOW PARM\n         LA        R1,IOCBDCB          LOAD DCB ADDRESS\n         LCR       R1,R1               INDICATE TYPE R\n         SVC       21                  ISSUE STOW SVC\n         LTR       R15,R15             TEST RETURN CODE\n         BZ        IORET0              IF OK THEN RETURN 0\n         CH        R15,=H'8'           IS THE RETURN CODE 8\n         BE        IORET1              IF SO THEN RETURN 1\nIORET2   LTR       R13,R13             SET CC=2\n         B         IORET               AND RETURN\n         DROP      R11\n         DROP      R10\n*\n*        MOVE ROUTINE\n*        INPUT  R1=FROM-ADDRESS, R0=FROM-LENGTH\n*               R2=TO-ADDRESS, R3=TO-LENGTH\n*        IF FROM-RECORD IS LONGER THEN IT IS TRUNCATED\n*        IF FROM-RECORD IS SHORTER THEN TO-RECORD IS PADDED WITH BLANKS\n*\n         USING     SYSINT,R15\nMOVE     LR        R15,R11             FOR INTERNAL ENTRY\nSYSMOVE  STM       R0,R5,SAVEAREA      SAVE CALLER'S REGISTERS\n         LR        R4,R3               COPY TO-LENGTH\n         CR        R4,R0               IS RECORD TO BE PADDED\n         BNH       MOVEMAIN            IF NOT THEN COPY MAIN PART\n         LR        R4,R0               R4=MIN(TO-LENGTH,FROM-LENGTH)\n         LA        R5,0(R2,R4)         GET ADDR OF PART TO PAD\n         MVI       0(R5),C' '          INSERT FIRST BLANK\n         LA        R0,2(,R4)           CALCULATE FROM-LENGTH+2\n         SR        R3,R0               CALCULATE LENGTH OF VAR MVC\n         BM        MOVEMAIN            IF NEG THEN SKIP EX OF MVC\n         EX        R3,BLANKMVC         MVC  1(*-*,R5),0(R5)\nMOVEMAIN SH        R4,=H'257'          -1 FOR EX AND -256 FOR LAST\n         BM        MOVELAST            IF <0 THEN GO DO EX\nMOVELOOP MVC       0(256,R2),0(R1)     OTHERWISE MOVE 256 BYTES\n         LA        R2,256(,R2)         BUMP TO-ADDRESS\n         LA        R1,256(,R1)         BUMP FROM-ADDRESS\n         SH        R4,=H'256'          SUBTRACT 256 FROM COUNT\n         BNM       MOVELOOP            IF NOT NEG THEN LOOP\nMOVELAST EX        R4,MOVEMVC          MVC  0(*-*,R2),0(R1)\n         LM        R0,R5,SAVEAREA      RESTORE REGISTERS\n         BR        R14                 AND RETURN TO CALLER\nMOVEMVC  MVC       0(*-*,R2),0(R1)     MOVE MAIN PART OF DATA\nBLANKMVC MVC       1(*-*,R5),0(R5)     PROPAGATE BLANK DOWN RECORD\n         DROP      R15\n*\n*        SPIE ROUTINE\n*        INPUT  R0=PROGRAM CHECK MASK\n*               R1=ADDR OF SPIE EXIT ROUTINE\n*               R2=VALUE TO BE PRESERVED FOR EXIT\n*\n         USING     SYSINT,R11\nSYSSPIE  STM       R2,R14,SAVEAREA     SAVE REGISTERS\n         LR        R11,R15             GET BASE REGISTER\n         LR        R12,R13             SAVE USER'S R13\n         L         R10,SYSIDENT-SYSINT(,R15)  GET SICA ID\nSPGSICA  L         R13,BKWDPTR         GET BKWDPTR\n         C         R10,SICAID          COMPARE WITH SICA ID\n         BNE       SPGSICA             LOOP UNTIL FOUND\n         LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER\n         ST        R1,SPIEROUT         SAVE ADDRESS OF EXIT ROUTINE\n         STH       R0,SICAPICA+4       STORE MASK IN PICA\n         ST        R2,SPIER2           SAVE R2 VALUE FOR EXIT ROUTINE\n         LA        R1,SICAPICA         LOAD PARM REG FOR SPIE SVC\n         SVC       14                  ISSUE SPIE SVC\n         SPM       R13                 SET PROGRAM MASK OFF\n         B         RETURN              AND RETURN\n         DROP      R11\n*\n*        TIME ROUTINE\n*        OUTPUT R0=TIME OF DAY IN TIMER UNITS\n*               R1=DATE IN FORM 00 YY DD DF\n*\nSYSTIME  SR        R1,R1               INDICATE TIMER UNITS\n         SVC       11                  ISSUE TIME SVC\n         BR        R14                 AND RETURN\n*\n*        STIMER ROUTINE\n*        INPUT  R0=VALUE OF INTERVAL\n*               R1=ADDR OF EXIT ROUTINE(UPPER BYTE>0 FOR REAL TIMING)\n*               R2=VALUE TO BE PRESERVED FOR EXIT ROUTINE\n*\n         USING     SYSINT,R11\nSYSSTIME STM       R2,R14,SAVEAREA     SAVE REGISTERS\n         LR        R11,R15             GET BASE REGISTER\n         LR        R12,R13             SAVE USER'S R13\n         L         R10,SYSIDENT-SYSINT(,R15)  GET SICA ID\nSTGSICA  L         R13,BKWDPTR         GET BKWDPTR\n         C         R10,SICAID          COMPARE WITH SICA ID\n         BNE       STGSICA             LOOP UNTIL FOUND\n         LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER\n         MVC       TIMREXIT(10),TIMRCODE  INIT TIMER EXIT CODE\n         ST        R0,SICAPARM         STORE INTERVAL IN CORE\n         ST        R2,STIMERR2         SAVE EXIT VALUE OF R2\n         LA        R2,0(,R1)           CLEAR UPPER BYTE OF ADDRESS\n         ST        R2,TIMRROUT         SAVE TIMER EXIT ROUTINE ADDRESS\n         LA        R0,TIMREXIT         LOAD EXIT ROUTINE ADDRESS\n         CR        R1,R2               IS UPPER BYTE OF R1=0\n         BE        *+8                 IF SO THEN IS TASK INTERVAL\n         O         R0,=X'03000000'     SET CODE FOR REAL INTERVAL\n         LA        R1,SICAPARM         LOAD ADDR OF INTERVAL WORD\n         SVC       47                  ISSUE STIMER SVC\n         B         RETURN              AND RETURN\nTIMRCODE L         R2,STIMERR2-TIMREXIT(,R15)  LOAD R2 VALUE\n         L         R15,TIMRROUT-TIMREXIT(,R15)  GET EXIT ROUTINE ADDR\n         BR        R15                 AND GO TO IT\n         DROP      R11\n*\n*        TTIMER ROUTINE\n*        INPUT  R1=0 FOR CONTINUATION OF INTERVAL\n*                  1 FOR CANCELATION OF INTERVAL\n*                  2 FOR JOB STEP TIME REMAINING\n*        OUTPUT R0=REMAINDER OF STIMER INTERVAL IN TIMER UNITS\n*\n         USING     SYSINT,R15\nSYSTTIME C         R1,=F'2'            IS THIS JOB STEP INTERVAL\n         BE        JOBSTEP             IF SO THEN GO PROCESS\n         SVC       46                  ISSUE TTIMER SVC\n         BR        R14                 AND RETURN\nJOBSTEP  STM       R2,R14,SAVEAREA     SAVE REGISTERS\n         LR        R11,R15             LOAD BASE REGISTER\n         DROP      R15\n         USING     SYSINT,R11\n         L         R2,CVTPTR(,R0)      GET CVT POINTER\n         L         R0,=X'7FFFFFFF'     LOAD MAXIMUM TIME\n         CLI       CVTDCB(R2),X'10'    IS THIS MVT\n         BNE       JSTRET              IF NOT THEN RETURN MAXIMUM\n         L         R3,0(,R2)           GET TASK SWITCH CELL POINTER\n         L         R3,4(,R3)           GET CURRENT TASK ADDRESS\n         L         R3,124(,R3)         JOB STEP TCB ADDRESS\n         L         R3,132(,R3)         INITIATOR TCB ADDRESS\n         L         R3,120(,R3)         INITIATOR TQE ADDRESS\n         L         R2,88(,R2)          POINTER TO SHPC\nGETTIME  L         R4,12(,R3)          GET TOX\n         L         R5,80               GET TIMER VALUE\n         L         R6,0(,R2)           GET SHPC\n         C         R4,12(,R3)          CHECK FOR NO INTERRUPT\n         BNE       GETTIME             IF CHANGED MUST DO AGAIN\n         SRA       R5,1                (TIMER/2)\n         SR        R5,R6               (TIMER/2)-SHPC\n         AR        R5,R4               (TIMER/2)-SHPC+TOX\n         LR        R0,R5               SET VALUE IN RETURN REGISTER\nJSTRET   LM        R2,R14,SAVEAREA     RESTORE CALLER'S REGISTERS\n         BR        R14\n*\n*        LOAD ROUTINE\n*        INPUT  R1=ADDRESS OF NAME OF MODULE TO LOAD\n*               R2=ADDRESS OF IOCB TO LOAD ON(0 FOR STEPLIB ETC)\n*        OUTPUT R1=ENTRY POINT OF MODULE\n*               R0=LOAD POINT OF MODULE\n*        CC=0 FOR LOADED, CC=1 FOR NOT ENOUGH CORE, CC=2 FOR NOT FOUND\n*\n         USING     SYSINT,R11\nSYSLOAD  STM       R2,R14,SAVEAREA     SAVE REGISTERS\n         LR        R11,R15             SAVE BASE REGISTER\n         LR        R12,R13             SAVE USER'S R13\n         L         R10,SYSIDENT        GET SICA ID\nLOGSICA  L         R13,BKWDPTR         GET BKWDPTR\n         C         R10,SICAID          COMPARE WITH SICA ID\n         BNE       LOGSICA             LOOP UNTIL FOUND\n         LA        R13,SICAPREF(,R13)  GET ADDRESS OF SICA PROPER\n         L         R15,CVTPTR(,R0)     GET CVT POINTER\n         CLI       CVTCMS(R15),255     IS THIS CMS\n         BE        LOADCMS             IF SO THEN GO PROCESS\n         MVC       SICAPIE(4),=X'00010030'\n         MVC       SICAPIE+4(8),0(R1)  MOVE IN NAME\n         LTR       R2,R2               IS THERE A IOCB\n         BZ        *+8                 IF NOT THEN CONTINUE\n         LA        R2,IOCBDCB-IOCB(,R2)  OTHERWISE GET DCB ADDRESS\n         LR        R1,R2               PUT DCB ADDRESS OR 0 IN R1\n         LA        R0,SICAPIE          LOAD PARM ADDRESS FOR BLDL\n         SVC       18                  ISSUE BLDL SVC\n         LTR       R15,R15             TEST RETURN CODE FROM BLDL\n         BP        RETURN              IF NAME NOT FOUND THEN RETURN 2\n         L         R1,SICAPIE+28       GET LENGTH FROM PARM LIST\n         SRL       R1,8                GET LENGTH IN LOW PART\n         BAL       R14,GETMAIN         CALL GETMAIN ROUTINE\n         BNZ       RETURN              IF NO CORE THEN RETURN 1\n         BAL       R14,FREEMAIN        FREE CORE\n         LR        R1,R2               LOAD DCB ADDRESS FOR LOAD\n         LA        R0,SICAPIE+4        LOAD ADDRESS OF DE ENTRY\n         LCR       R0,R0               COMPLEMENT TO INDICATE DE-TYPE\n         SVC       8                   ISSUE LOAD SVC\n         LR        R1,R0               SAVE ENTRY POINT ADDRESS IN R1\n         MVI       SICAPIE+32,0        ZERO UPPER BYTE OF ENTRY OFFSET\n         S         R0,SICAPIE+32       GET LOAD POINT OF MODULE\n         CR        R0,R0               SET CC=0\n         B         RETURN              AND RETURN\nLOADCMS  LR        R0,R1               PUT NAME ADDRESS IN R0\n         SR        R1,R1               INDICATE NO DCB\n         SVC       8                   ISSUE LOAD SVC\n         LR        R1,R0               PUT ENTRY POINT IN R1\n         B         IORET0              RETURN 0\n         DROP      R11\n*\n*        DELETE ROUTINE\n*        INPUT  R1=ADDRESS OF NAME OF MODULE TO DELETE\n*        OUTPUT CC=0 FOR DELETED, CC=1 FOR NAME NOT FOUND\n*\nSYSDELT  LR        R0,R1               COPY ADDRESS OF NAME FOR SVC\n         SVC       9                   ISSUE DELETE SVC\n         OR        R15,R15             SET CONDITION CODE\n         BR        R14                 AND RETURN TO CALLER\n*\n*\n*        WTO, WTOR AND WTP ROUTINE\n*        INPUT  R1=ADDRESS OF TEXT TO WRITE\n*               R0=LENGTH OF TEXT TO WRITE\n*               R2=ADDRESS OF INPUT AREA FOR WTOR\n*               R3=LENGTH OF INPUT AREA FOR WTOR\n*\n         USING     SYSINT,R15\nSYSWTP   O         R1,=X'80000000'     SET WTP FLAG\n         DROP      R15                 DROP R15\n         USING     SYSINT,R11\nSYSWTO   SR        R2,R2               CLEAR R2 TO INDICATE WTO\nSYSWTOR  STM       R14,R12,SAVEAREA    SAVE REGISTERS\n         LR        R11,R15             LOAD BASE REGISTER\n         LR        R4,R1               SAVE ADDRESS OF STRING TO WRITE\n         LR        R5,R0               SAVE LENGTH OF STRING TO WRITE\n         LA        R0,144              GET LENGTH OF WORKAREA\n         LNR       R1,R0               SET R1 NEGATIVE FOR GETMAIN\n         SVC       10                  ISSUE GETMAIN SVC\n         LR        R6,R1               SAVE ADDRESS OF WORKAREA\n         ST        R2,0(,R6)           SAVE REPLY ADDRESS AREA\n         STC       R3,0(,R6)           SAVE REPLY ADDRESS LENGTH\n         EX        R5,WTORMVC          MVC 12(*-*,R6),0(R4)\n         LA        R0,4(,R5)\n         SLL       R0,16\n         ST        R0,8(,R6)           SAVE IN WTOR PARM LIST\n         MVI       10(R1),X'80'        TURN ON MCS FLAG\n         AR        R5,R1               DESCRIPTOR/ROUTING FLAGS\n         MVC       8(4,R5),=X'02004020'     DESC=7,ROUTCDE=(2,11)\n         LTR       R4,R4               IS THIS A WTP\n         BNM       *+8                 IF NOT THEN BRANCH AROUND\n         NI        10(R5),255-X'40'    TURN MAIN CONSOLE FLAG OFF\n         LA        R0,140(,R6)         GET ADDRESS OF WTOR ECB\n         ST        R0,4(,R6)           SAVE IN WTOR PARM LIST\n         MVI       140(R6),0           INITIALIZE ECB\n         LTR       R2,R2               IS THIS WTOR\n         BNZ       WTORCODE            IF SO THEN GO TO WTOR CODE\n         LA        R1,8(,R6)           SKIP OVER TO PROPER PARM FOR WTO\n         SVC       35                  ISSUE WTO SVC\n         B         WTOCOMN             AND BRANCH TO COMMON CODE\nWTORCODE SVC       35                  ISSUE WTOR SVC\n         LA        R1,140(,R6)         SET UP ECB ADDRESS FOR WAIT SVC\n         LA        R0,1                SET UP WAIT COUNT FOR WAIT SVC\n         SVC       1                   AND WAIT FOR REPLY\nWTOCOMN  LR        R1,R6               GET WORKAREA ADDRESS\n         LA        R0,144              GET WORKAREA LENGTH\n         SVC       10                  ISSUE FREEMAIN SVC\n         LM        R14,R12,SAVEAREA    RESTORE USER'S REGISTERS\n         BR        R14                 AND RETURN TO USER\nWTORMVC  MVC       12(*-*,R6),0(R4)    MVC TO MOVE STUFF TO WRITE\n         DROP      R11\n*\n*        ABEND ROUTINE\n*        INPUT  R1=ABEND PARM REGISTER\n*\nSYSABEND SVC       13                  ISSUE ABEND SVC\n*\nSYSIDENT DC        0F'0',C'SICA'\n         USING     SYSINT,R11\nSYSPATCH DC        8S(*)               PATCH AREA FOR SYSINT\n         DROP      R11\n         DC        0D'0'\n         LTORG\n         DC        0D'0'\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSOCRIPT": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x965\\x9f\\x00\\x965\\x9f\\x19T\\x07\\x7f\\x07\\x7f\\x00\\x00\\xc3\\xc2\\xe3\\xf2\\xf4\\xf9@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-24T00:00:00", "modifydate": "1996-12-24T19:54:00", "lines": 1919, "newlines": 1919, "modlines": 0, "user": "CBT249"}, "text": "*        ***   PREFACE NOTES FROM UNIVERSITY OF WATERLOO   ***\n*\n*        WE THANK THE AUTHORS FOR PASSING ON THIS TSO PROMPTER\n*        FOR \"SCRIPT\" AND TO OTHERS FOR SUBSEQUENT UPDATES.\n*\n*        IT IS NO FAULT OF THE AUTHORS THAT THIS INTERFACE ROUTINE\n*        HAS BECOME OUT OF DATE.  IT IS ENTIRELY DUE TO CHANGES\n*        AT WATERLOO THAT THEY COULD NOT HAVE FORSEEN.  SINCE\n*        THE UNIVERSITY OF WATERLOO IS NOT A TSO INSTALLATION\n*        IT WAS DECIDED NOT TO ATTEMPT TO UPDATE SOMETHING WE\n*        COULD NOT THEN TEST, BUT WE FELT OBLIGATED TO POINT\n*        OUT AREAS OF CHANGE --\n*\n*        'WORKSIZE=' IS NO LONGER A RECOGNIZED PARM.\n*        'SREFERENCE=' WHILE STILL RECOGNIZED HAS NO EFFECT.\n*\n*        'MEMO' OPTION NOT SUPPORTED BY INTERFACE\n*\n*        ***   END OF PREFACE NOTES   ***\n         EJECT\n***********************************************************************\n*\n*        TSO USE OF THE SCRIPT INTERFACE ROUTINE.\n*\n*        SYNTAX:\n*        SCRIPT IDSN '+SR=VALUE' LIBRARY(LDSN) PRINT(*|PDSN) OPTIONS\n*\n*        WHERE:\n*\n*        1. IDSN - THE PRIMARY SCRIPT INPUT FILE.\n*\n*        2. +SR=VALUE - EXTERNAL ASSIGNMENT OF SCRIPT VARIABLES\n*                       USED WITH .UR COMMANDS.\n*\n*        3. LDSN - USED TO IMBED FILES WITH .IM.\n*\n*        4. *    - SCRIPT OUTPUT TO TERMINAL.\n*           PDSN - SCRIPT OUTPUT TO DATA SET.\n*\n*        5. OPTIONS - SCRIPT OPTIONS, SEE SCRIPT USERS GUIDE.\n*\n*        NOTES:\n*\n*        1. THE ONLY REQUIRED OPERAND IS IDSN.\n*\n*\n*        2. * IS DEFAULT FOR PRINT OPERAND.\n*\n*        3. ALL DATA SET NAMES FOLLOW TSO NAMING CONVENTIONS.\n*           A DATA SET NAME ENCLOSED IN QUOTES IS FULLY QUALIFIED.\n*           A DATA SET NAME NOT ENCLOSED IN QUOTES HAS THE TSO\n*           USERID PREFIXED TO IT.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        USE OF MACROS CHECK, KEY, SUBJ, MOVEP1-MOVEP5.\n*\n*        THE KEY AND SUBF MACROS ARE USED TO GENERATE THE NECESSARY\n*        TSO INTERFACE TO TSO PARSE SERVICES.\n*        RANGE ERROR CHECKING ROUTINES ARE GENERATED USING MACRO CHECK.\n*        MACROS MOVEP1 THROUGH MOVEP5 ARE USED TO CREATE THE PARAMETER\n*        LIST FOR SCRIPT BEFORE IT IS CALLED.\n*        THESE MACROS ARE INTER-DEPENDENT AND MUST BE USED ARE SHOWN.\n*\n*        THE REASON THAT A PARAMETER LIST MUST BE CONSTRUCTED FROM THE\n*        LIST OF OPTIONS WHICH THE TSO USER REQUESTS IS THAT THE SYNTAX\n*        OF THE PARAMETER FIELD ON THE EXEC JCL CARD AND THE SYNTAX OF\n*        THE OPERANDS OF A TSO COMMAND DIFFER.\n*        FOR EXAMPLE;\n*\n*        JCL -> // EXEC PGM=NSCRIPT,PARM='CO,SEQC=1,PAGE=3:4'\n*        TSO -> SCRIPT DSNAME CO SEQC(1) PAGE(3:4)\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        THESE MACROS ARE USED AS FOLLOWS.\n*\n*        SCRIPT OPTIONS, NO SUBFIELD:\n*\n*          SCRIPT OPTION - CONTINUE/CO\n*                          NOCONTINUE/NOCO - DEFAULT\n*\n*        TO GENERATE THE TSO INTERFACE SO PARSE RECOGNIZES ALL 4 OF\n*        THE KEYWORDS, CONTINUE, CO, NOCONTINUE OR NOCO CODE;\n*\n*CO      KEY   (CO,CONTINUE)\n*NOCO    KEY   (NOCO,NOCONTINUE)\n*\n*        THE LABEL FIELD ON THE KEY MACRO MUST BE THE SHORT FORM OF THE\n*        SCRIPT OPTION.  THE OPERAND OF THE KEY MACRO IS A LIST OF ALL\n*        ALLOWABLE FORMS OF THIS OPTION.  ONLY NON-DEFAULT OPTIONS ARE\n*        GENERATED IN THE SCRIPT PARAMETER WHEN SCRIPT IS CALLED.\n*        THAT IS, IF A USER SPECIFIES THE NOCO OR NOCONTINUE OPTION,\n*        THIS OPTION IS NOT GENERATED WHEN SCRIPT IS CALLED, BECAUSE\n*        IT IS THE DEFAULT.\n*        SINCE THESE OPTIONS CANNOT HAVE A VALUE ASSIGNED TO THEM, NO\n*        RANGE CHECKING IS REQUIRED.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        SCRIPT OPTION, WITH SUBFIELD.\n*\n*          SCRIPT OPTION - DOWN=N\n*                          DO=N\n*\n*        TO GENERATE THE TSO INTERFACE FOR PARSE TO RECOGNIZE THIS\n*        SYNTAX, CODE;\n*\n*DO      KEY   (DO,DOWN),SUBF=YES\n*\n*        AGAIN, THE LABEL FIELD OF THIS MACRO MUST BE THE SHORT FORM\n*        OF THE SCRIPT OPTION.\n*        BECAUSE THERE IS A SUBFIELD ASSOCIATED WITH THIS OPTION, THE\n*        FOLLOWING MACROS MUST ALSO BE CODED.\n*\n*DO      SUBF  'DOWN NUMBER',3,'MUST BE 1 TO 130'\n*\n*        AGAIN, THE LABEL FIELD OF THIS MACRO MUST BE THE SHORT FORM\n*        OF THE SCRIPT OPTION.\n*        THE FIRST OPERAND IS THE PROMPT GIVEN TO THE TSO USER BY\n*        PARSE, IF THIS OPTION IS REQUIRED.\n*        THE SECOND OPERAND IS THE MAXIMUM LENGTH OF THE SUBFIELD.\n*        ALL SUBFIELDS ARE NUMERIC FOR SCRIPT.\n*        THE THIRD OPERAND IS THE PROMPT GIVEN BY PARSE WHEN A SYNTAX\n*        ERROR, LIKE NON-NUMERIC OR INCORRECT LENGTH, IS DETECTED.\n*        FURTHER, TO CHECK THAT THE RANGE SPECIFIED FOR THIS OPTION\n*        IS VALID FOR SCRIPT, CODE;\n*\n*        CHECK DO\n*DOSTR   DC    C'130',C'1'\n*ERDO    DC    C'** ERROR ** VALID RANGE FOR DOWN IS 1-130'\n*\n*        THE CHECK MACRO USES THE CONSTANTS DOSTR TO VERIFY THAT THE\n*        RANGE FOR THIS OPTION IS VALID FOR SCRIPT.  THE LENGTH OF THE\n*        FIRST (THE UPPER LIMIT) VARIES ACCORDING TO THE OPTION,\n*        BUT THE SECOND CONSTANT (THE LOWER LIMIT) MUST HAVE A\n*        LENGTH OF ONE.\n*        THE CHECK MACRO DISPLAYS THE MESSAGE DEFINED BY ERDO WHEN A\n*        RANGE ERROR IS DETECTED.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        THAT COVERS ALL CASES EXCEPT THE SCRIPT OPTION , PAGE.\n*        THE SUBF MACRO FOR OPTION PAGE IS;\n*\n*PA      SUBF  'FIRST PAGE NUMBER',6,'PAGE NUMBERS',RANGE=YES\n*\n*        THE RANGE OPERAND IS USED TO INFORM PARSE THAT A RANGE CAN\n*        BE SPECIFIED FOR THIS OPTION.\n*        AS WELL, THE CHECK MACRO FOR PAGE MUST BE;\n*\n*        CHECK PA,CHK=NO\n*\n*        SINCE THE PAGE OPTION MAY BE A SINGLE NUMBER OR A RANGE, THE\n*        RANGE CHECK IS NON-TRIVIAL, (BUT NOT IMPOSSIBLE).\n*        ALSO, THERE REALLY IS NO INVALID RANGE, OTHER THAN INFINITY,\n*        WHATEVER THAT IS FOR A DOCUMENT.\n*        THE CHK=NO OPERAND INHIBITS RANGE CHECKING FOR THIS OPTION.\n*        TSO PARSE WILL DETECT ANY SYNTAX ERRORS AND THAT IS SUFFICIENT\n*        FOR THIS OPTION.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        CREATION OF SCRIPT PARAMETER LIST:\n*\n*        KEEPING IN MIND THAT THE TSO USER SPECIFIES\n*\n*        PAGES(37:39) DO(60) CONTINUE\n*\n*        AND THAT SCRIPT EXPECTS\n*\n*        PAGE=37:39 DO=60 CO\n*\n*        THE MACROS MOVEP1 THROUGH MOVEP5 MUST BE USED TO TRANSFORM\n*        THE OPTIONS SO SCRIPT CAN RECOGNIZE THEM.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        MACRO MOVEP1 IS USED FOR OPTIONS WITHOUT SUBFIELDS.\n*\n*        MOVEP1 CO\n*        MOVEP1 NOMA\n*\n*        ONLY NON-DEFAULT OPTIONS MUST BE GENERATED, SO IF THE TSO USER\n*        REQUESTS NOCO, THIS IS NOT PASSED TO SCRIPT.\n*        AGAIN, THE OPERAND OF THE MOVEP1 MACRO MUST BE THE SHORT FORM\n*        OF THE SCRIPT OPTION.  MOVEP1 PASSES THIS OPTION TO SCRIPT\n*        ONLY IF THE TSO USER REQUESTED IT.  MOVEP1 DETERMINES WHETHER\n*        AN OPTION HAS BEEN SPECIFIED BY THE TSO USER BY EXAMINING THE\n*        FLAGS RETURNED BY TSO PARSE SERVICES.  THE AREA FOR THESE\n*        FLAGS IS CREATED BY THE KEY MACRO.  FOR MORE DETAILS ON TSO\n*        PARSE SERVICES, SEE THE IBM MANUAL, \"TCAM PROGRAMMERS GUIDE\"\n*        FORM GC30-2040.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        MACRO MOVEP3 IS USED TO GENERATE AN OPTION WITH A SUBFIELD.\n*\n*        MOVEP3 DO\n*        MOVEP3 PAS\n*\n*        THE OPERAND MUST BE THE SHORT FORM OF THE SCRIPT OPTION.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        SINCE THE PAGE OPTION MAY HAVE A RANGE AS THE SUBFIELD\n*        MACRO MOVEP5 IS USED SPECIFICALLY FOR THIS OPTION.\n*\n*        MOVEP5 PA\n*\n*        MACROS MOVEP2 AND MOVEP4 ARE USED INTERNALLY IN MOVEP1, MOVEP3\n*        AND MOVEP5.\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n*\n*        MACRO FLAG IS USED TO DETERMINE WHETHER OUTPUT IS ONLINE OR\n*        OFFLINE.\n*\n***********************************************************************\n         EJECT\n*\n*\n*       \"NSCRIPT\"   TSO   PROMPTER\n*\n*\n*    WRITTEN BY:           GABRIEL SILBERMAN\n*                          COMPUTER CENTER\n*                          TECHNION - ISRAEL INSTITUTE OF TECHNOLOGY\n*                          TECHNION CITY - HAIFA\n*                          ISRAEL\n         SPACE 1\n*    CORRECTED BY:         SHMUEL METZ\n*                          COMPUTER CENTER\n*                          TECHNION\n         SPACE 2\n*              THIS PROGRAM MAY NOT BE DISTRIBUTED WITHOUT PERMISSION.\n*              PERMISSION TO DISTRIBUTE IS EXPLICITLY GRANTED TO:\n         SPACE 1\n*                           GERHARD POSTPISCHIL\n*                           AMS COMPUTER CENTER\n         SPACE 1\n*                           SHARE, GUIDE, AND ALL COMMITTEES AND\n*                             WORKING GROUPS THEREOF,\n*                             INCLUDING SPLA AND ALL PROJECTS.\n         SPACE 1\n*                           UNIVERSITY OF WATERLOO\n*                           WATERLOO - ONTARIO\n*                           CANADA\n         EJECT\n         MACRO\n&L       MOVEP1 &NAME,&LABMVC=\n&L       CLI   ##&NAME.+1,0   /IF NOT SELECTED THEN IGNORE\n         BE    BP&NAME.\n&LABMVC  MOVEP2 &NAME.\nBP&NAME. EQU   *\n         SPACE 1\n         MEND\n         SPACE 3\n         MACRO\n&L       MOVEP2 &NAME,&SIGN=BLANK\n         LCLA   &LEN\n&LEN     SETA  K'&NAME\n&L       MVC   0(&LEN,R7),=C'&NAME.'    /MOVE PARAMETER TO STRING\n         AIF   ('&SIGN' EQ 'BLANK').NOSIGN\n         MVI   &LEN.(R7),&SIGN            /INSERT SIGN AFTER PARAM.\n.NOSIGN  ANOP\n         LA    R7,1+&LEN.(,R7)          /INCREMENT OFFSET\n         MEND\n         SPACE 3\n         MACRO\n         MOVEP3 &NAME\n         TM    ##&NAME.+6,PRESENT\n         BZ    BP&NAME.       /ABSENT,IGNORE\n         MOVEP2 &NAME.,SIGN=EQUAL\n         L     R5,##&NAME.    /PTR. TO NUMBER\n         MOVEP4 &NAME.\nBP&NAME. EQU   *\n         SPACE 1\n         MEND\n         SPACE 3\n         MACRO\n         MOVEP4 &NAME\n         LH    R4,##&NAME+4   /LENGTH OF NUMBER\n         BCTR  R4,0           /-1 FOR \"EX\"\n         EX    R4,MOVEPR4     /PARM. TO PLACE\n         LA    R7,1(R4,R7)       /UPDATE OFFSET\n         MVI   0(R7),BLANK    /INSERT BLANK AFTER NUMBER\n         LA    R7,1(,R7)      /UPDATE OFFSET\n         MEND\n         SPACE\n         MACRO\n         CHECK &OPT,&CHK=YES\n         GBLC  &MCSECT\n         LCLC  &LQUOTE\n&LQUOTE  SETC  'L'''\n&OPT.CK  EQU   *\n         AIF   ('&CHK' NE 'YES').NOCHK\n         STM   R14,R12,12(R13)\n         USING &OPT.CK,R15\n         L     R12,=A(&MCSECT)\n         L     R11,=A(VDCHECK)\n         DROP  R15\n         LA    R9,&LQUOTE&OPT.STR\n         LA    R7,&OPT.STR\n         LA    R5,0(R7,R9)\n         BAL   R6,GENCK\n         LA    R2,ER&OPT\n         LA    R0,&LQUOTE.ER&OPT\n         B     ERRTPUT\n         MEXIT\n.NOCHK   ANOP\n         SR    R15,R15\n         BR    R14\n         MEND\n         SPACE\n         MACRO\n&L       MOVEP5 &NAME\n&L       TM    ##&NAME.+6,PRESENT\n         BZ    BP&NAME.\n         L     R5,##&NAME\n         LH    R4,##&NAME.+4\n         AH    R4,##&NAME.+12\n         OC    ##&NAME.+12(2),##&NAME.+12\n         BNZ   NODECR\n         BCTR  R4,0\nNODECR   DS    0H\n         MOVEP2 &NAME.,SIGN=EQUAL\n         EX    R4,MOVEPR4\n         LA    R7,1(R4,R7)\n         MVI   0(R7),BLANK\n         LA    R7,1(,R7)\nBP&NAME  EQU   *\n         MEND\n         MACRO\n&L       FLAG  &KEY,&SW,&BIT\n&L       CLI   ##&KEY+1,0\n         BE    BF&KEY\n         OI    &SW,&BIT\nBF&KEY   DS    0H\n         MEND\n         MACRO\n&LABEL   KEY   &LIST,&SUB=NO\n         LCLA  &NUM\n         LCLC  &P\n&NUM     SETA  1\n&P       SETC  '##'\n         AIF   ('&SUB' EQ 'NO').NOSUB1\n&P       SETC  ''\n.NOSUB1  ANOP\n&P&LABEL IKJKEYWD\n.MORE1   ANOP\n         AIF   ('&SUB' EQ 'NO').NOSUB2\n         IKJNAME '&LIST(&NUM)',SUBFLD=S&LIST(1)\n         AGO   .MORE2\n.NOSUB2  ANOP\n         IKJNAME '&LIST(&NUM)'\n.MORE2   ANOP\n&NUM     SETA  &NUM+1\n         AIF   (&NUM LE N'&LIST).MORE1\n         MEND\n         MACRO\n&KEY     SUBF  &EXP,&LENGTH,&HELP,&RANGE=NO\n         LCLC  &RANG\n&RANG    SETC  ''\n         AIF   ('&RANGE' EQ 'NO').NORANG\n&RANG    SETC  'RANGE'\n.NORANG  ANOP\nS&KEY    IKJSUBF\n##&KEY   IKJIDENT &EXP,&RANG, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n               MAXLNTH=&LENGTH,FIRST=NUMERIC,OTHER=NUMERIC, XXXXXXXXXXXX\n               VALIDCK=&KEY.CK, XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n               HELP=&HELP\n         MEND\n         MACRO\n&L       ENDM  &DSECT=,&END=,&RC=\n&L       LA    R0,(&END-&DSECT)+18*4\n         LR    R1,R13\n         L     R13,4(0,R13)\n         FREEMAIN R,LV=(R0),A=(R1)\n         ST    &RC,16(0,R13)\n         LM    R14,R12,12(R13)\n         BR    R14\n         MEND\n         MACRO\n         MTITL &L\n         TITLE &L\n         MEND\n         MACRO\n         STITL &L\n         TITLE &L\n         MEND\n         MACRO\n         SAVEM &CSECTN,&DSECT=,&END=\n         GBLC  &MCSECT\n&MCSECT  SETC  '&CSECTN'\n&MCSECT  CSECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRA       EQU   10\nRB       EQU   11\nRC       EQU   12\nRD       EQU   13\nRE       EQU   14\nRF       EQU   15\n         STM   R14,R12,12(R13)\n         LR    R11,R1\n         LR    R12,R15\n         USING &MCSECT,R12\n         LA    R0,(&END-&DSECT)+18*4\n         GETMAIN R,LV=(R0)\n         LR    R15,R13\n         LR    R13,R1\n         ST    R13,8(0,R15)\n         ST    R15,4(0,R13)\n         USING &DSECT-18*4,R13\n         MEND\n         GBLC  &MCSECT\n         STITL 'SCRIPT -- PROMPTER FOR NSCRIPT -- GABRIEL SILBERMAN'\n         STITL 'INITIALIZATION'\nSCRIPT   SAVEM SCRIPT,DSECT=PPL,END=PPLEND\n         USING CPPL,R11\n         SPACE 1\n*\n***>   CALL IKJPARS\n*\n         SPACE 1\n         XC    ECB,ECB             /ZERO ECB\n         MVC   PPLCBUF,CPPLCBUF    /ADD. OF COMMAND BUFFER\n         MVC   PPLUPT,CPPLUPT      /ADD. OF UPT\n         MVC   PPLECT,CPPLECT      /ADD. OF ECT\n         LA    R4,ECB\n         ST    R4,PPLECB           /ADD. OF ECB\n         LA    R4,ANS\n         ST    R4,PPLANS           /ADD. OF ANSWER (FOR PARSE TO FILL)\n         MVC   PPLPCL,=A(PARSE)    /ADD. OF PCL\n         ST    R13,PPLUWA          /ADD. OF UWA (ADD. OF WORK AREA)\n         LA    R1,PPLUPT           /ADD. OF PARAMETER LIST\n         LINK  EP=IKJPARS\n         LTR   R15,R15             /TEST RETURN CODE\n         BNZ   PARSFAIL            /SQUAWK AND EXIT\n         STITL 'PARAMETER CONSTRUCTION AND ALLOCATIONS'\n         L     R10,ANS             /ADD. OF PDL\n         USING IKJPARMD,R10\n         SPACE 5\n*\n***>  PARAMETER EXAMINATION AND CONSTRUCTION OF STRING TO BE PASSED TO\n*    \"NSCRIPT\" .\n*\n*   THE FORMAT FOR THE PARAMETERS PASSED TO \"NSCRIPT\" ARE AS FOLLOWS :\n*\n*    R1 -->|00| P T R| ---> |LENGTH|STRING.........|\n*          |80| P T R| ---> |# OF ENTRIES|\n*                           |DDNAME|REPLACEMENT|\n*                             ............\n*                           |DDNAME|REPLACEMENT|\n*\n*   \"00\" AND \"80\" ARE BYTES , EACH \"PTR\" IS 3 BYTES LONG , ENTRIES IS\n* HALFWORD AND DDNAMES AND THEIR REPLACEMENTS ARE 8 BYTES LONG PADDED\n* WITH BLANKS IN THE RIGHT .\n*\n         EJECT\n         MVC   ALIASES(ALIEND-ALICONS),ALICONS  /CONSTANT DDNAMES\n         SPACE 1\n*\n*\n***>   ALLOCATE DATA SET(S) TO BE FORMATTED\n*\n*\n         SPACE 2\n         MVC   DAPLPSCB(4),CPPLPSCB /PTR TO PSCB\n         LA    R6,DA08CD            /PTR TO DAPB\n         ST    R6,DAPLDAPB\n         LA    R6,DSN               /ADD. OF FIRST PDE\n         ST    R6,CNCT1\n         MVI   RECFM,ZERO            /INITIALIZE\n         BAL   R4,SBRCNCT            /CONCAT SUBROUTINE\n         SPACE 3\n***> KEEP DDNAME\n         SPACE 1\n         USING DAPB0C,R9\n         SPACE 1\n         MVC   SYSIN+8(8),DA0CDDN\n         SPACE 2\n*\n***>  ALLOCATE \"LIB\" DATA SETS AND CONCATENATE THEM IF NECESSARY\n*\n         SPACE 1\n         LH    R6,LIB                /CHECK IF \"NOLIB\" SPECIFIED\n         CH    R6,HALFONE\n         BNE   SYSPRT                /\"NOLIB\" SPECIFIED\n         SPACE 1\n         MVC   CNCTLNG1(4),CNCTLNGT  /KEEP LENGTH OF DSN(S) AREA\n         ST    R9,CNCTADD            /KEEP ADD. OF DSN(S) AREA\n         LA    R6,LIBB               /ADD. OF FIRST PDE\n         ST    R6,CNCT1\n         BAL   R4,SBRCNCT            /CONCAT SUBROUTINE\n         SPACE 2\n***> KEEP DDNAME FOR SYSLIB\n         SPACE 1\n         MVC   SYSLIB+8(8),DA0CDDN\n         SPACE 1\n***>  SIGNAL 5 DDNAMES FOR \"NSCRIPT\"\n         SPACE 1\n         LH    R4,ALIASES\n         AH    R4,HALFONE\n         STH   R4,ALIASES     /4 -> 5\n         SPACE 2\n*\n***> ALLOCATE SYSPRINT AND CONTROL TO THE TERMINAL\n         MNOTE 4,'CHANGE TO MAKE CONTROL AND SYSPRINT PARAMETERS'\n*\n         SPACE 1\nSYSPRT   BAL   R5,TRMALC          /ALLOCATE SYSPRINT\n         SPACE 1\n***> KEEP DDNAME\n         SPACE 1\n         MVC   SYSTERM+8(8),DA1CDDN\n         SPACE 1\n         BAL   R5,TRMALC1         /ALLOCATE CONTROL\n         SPACE 1\n***> KEEP DDNAME\n         SPACE 1\n         MVC   SYSCONS+8(8),DA1CDDN\n         SPACE 3\n***> ALLOCATION OF \"SCRIPT\" (OUTPUT) FILE\n*\n         SPACE 1\n         LA    R6,PRINTT1         /ADD. OF OUTPUT DSNAME PDE\n         USING DSNDSECT,R6\n         L     R8,DSNPTRN         /PTR. TO DSNAME\n         CLI   0(R8),ASTERISK     /IS IT TERMINAL?\n         BNE   SCRNOTRM           /NO => NORMAL DSNAME\n         SPACE 2\n***>  ALLOCATE TERMINAL AS OUTPUT FILE\n         SPACE 1\n         BAL   R5,TRMALC1\n         SPACE 1\n         MVC   SYSPRINT+8(8),DA1CDDN\n         OI    SWITCH,ONLINE  INDICATE ONLINE OUTPUT\n         SPACE 1\n         B     SCRALEND                      /\"SCRIPT\" ALLOCATED\n         SPACE 2\nSCRNOTRM EQU   *\n         OI    SWITCH,OFFLINE INDICATE OFFLINE OUTPUT\n         SPACE 1\n***>  ALLOCATION OF DSNAME AS \"SCRIPT\" (OUTPUT) FILE\n         MNOTE 4,'ALLOW FOR PARTIALLY QUALIFIED DSNAME'\n         MNOTE 0,'QUALIFIER IS LIST: DSN->USERID.DSN.LIST'\n         SPACE 1\n*    TRY FIRST TO ALLOCATE AS \"OLD\" DATA SET\n         SPACE 1\n         MVC   DA08DDN(8),BLANKS8   /BLANK DDNAME FIELD\n         SPACE 1\n         LA    R5,DA08CD\n         ST    R5,DAPLDAPB            /PTR. TO DAPB\n         SPACE 1\n         BAL   R5,DAIRALOC            /ALLOCATE DSNAME\n         MVC   SYSPRINT+8(8),DA08DDN\n         SPACE 1\n         BZ    SCRALEND       /O.K.,ALLOCATION COMPLETED\n         SPACE 1\n*  CHECK IF THE DATA SET SHOULD BE ALLOCATED AS \"NEW\" .\n*  IN THAT CASE R.C. SHOULD BE 8 , THE R.C. FROM DYNAMIC ALLOCATION\n*  SHOULD BE X'1708' AND FROM CATALOG MANAGEMENT X'0008' .\n         SPACE 1\n         CH    R15,OLDDS1    /CHECK RETURN CODE\n         BNE   ERRANAL       /NOT TO BE ALLOCATED AS NEW\n         CLC   DA08DARC(4),OLDDS2  /SECOND CHECK(DYN. ALLOC. AND C.M.)\n         BNE   ERRANAL       /FAILED , ERROR\n         SPACE 2\n*  DATA  SET TO BE ALLOCATED AS \"NEW\"\n         SPACE 1\n         XR    R5,R5\n         ST    R5,DA08DARC         /ZERO R.C.'S\n         MVI   DA08DSP1,DSNEW      /CHANGE STATUS TO \"NEW\"\n         MVI   DA08DPS3,DSNEW      /CHANGE COND. DISP. TO \"DELETE\"\n         LA    R5,11               /LENGTH-1 OF SPACE PARMS.\n         CLC   DA08MNM(8),BLANKS8  /MEMBER SPECIFIED ?\n         BNE   NEWALL\n         LA    R5,4(R5)            /ADD LENGTH OF DIR. SPACE\n         SPACE 1\nNEWALL   EQU   *\n         EX    R5,MOVEDSNW         /MOVE SPACE CONSTANTS\n         OI    DA08CTL,UNITSTRK    /SIGNAL SPACE IN TRACKS\n         SPACE 2\n         BAL   R5,ALLOCDSN         /ALLOCATE AS \"NEW\"\n         SPACE 1\n         BNZ   ERRANAL             /UNSUCCESSFUL\n         SPACE 1\n         MVC   SYSPRINT+8(8),DA08DDN\n         SPACE 1\nSCRALEND EQU   *                      /DONE\n         STITL 'CALLING SEQUENCE'\n**> CALL PARAMETER BUILDING ROUTINE .\n         SPACE 1\n         L     R15,=A(BUILDPRM) /ADD. OF ROUTINE\n         BALR  R14,R15       /BRANCH TO ROUTINE\n         SPACE 3\n*\n***>  PUT SECOND PART OF PARAMETER LIST IN PLACE\n*\n         LA    R7,ALIASES\n         ST    R7,PRMSCR+4       /PTR. TO DDNAMES' LIST\n         OI    PRMSCR+4,PRESENT INDICATE END OF PARM LIST\n         SPACE 2\n*\n***>  SET UP \"STAX\" IN CASE OF ATTENTION\n*\n         SPACE 1\n         LA    R6,STXLST       /ADD. OF LIST FORM\n         L     R4,=A(ATTEN)    /ADD. OF ATTENTION HANDLING ROUTINE\n         STAX  (R4),MF=(E,(R6)),IBUF=(ATTIN,1),OBUF=(ATTOUT,L'ATTOUT), X\n               USADDR=TCBAD\n         SPACE 2\n*\n***> CALL \"NSCRIPT\"\n*\n         SPACE 1\n         MVI   ATTIN,ATT#C       /SIGNAL NORMAL END\n         LA    R1,PRMSCR         /ADD. OF PARM. LIST\n         LA    R2,ABENDC         /ADD. OF ABEND CODES BUFFER\n         MVC   ABENDC(3),BLANKS8 /BLANK BUFFER\n         L     R4,=A(STAEROUT)   /ADD. OF STAE EXIT ROUTINE\n         XC    ECB,ECB\n         LA    R6,ECB        /PTR. TO ECB\n         ATTACH EP=NSCRIPT,ECB=(R6),SF=(E,LATT),STAI=((R4),(R2)),      X\n               PURGE=HALT,ASYNCH=YES\n         SPACE 1\n         ST    R1,TCBAD      /KEEP TCB ADD.\n         WAIT  ECB=ECB\n         SPACE 1\n         CLC   ABENDC(3),BLANKS8      /SEE IF \"NSCRIPT\" ABENDED\n         BNE   NSCABND                /ABEND OCURRED\n         SPACE 1\n         SPACE 1\n         CLI   ATTIN,ATT#C   /EXITED NORMALLY ?\n         BNE   ABEXIT        /ABNORMAL EXIT FROM SUBTASK\n         SPACE 1\n         LTR   R15,R15       /TEST RETURN CODE FROM \"NSCRIPT\"\n         BNZ   NSCRERR       /GO ANALYZE TROUBLE\n         SPACE 1\nDTCH     EQU   *\n         SPACE 1\n         DETACH TCBAD\n         SPACE 1\n         B     DONEFREE\n         STITL 'ALLOCATION AND CONCATENATION OF DATA SETS'\nSBRCNCT  MVC   DA08CD(LFORMS-DA08CNST),DA08CNST  /CONTANTS TO PLACE\n         LA    R6,DSNAMEP             /ADD. OF DSN BUFFER\n         ST    R6,DA08PDSN\n         L     R6,CNCT1             /FIRST PDE OF LIST\n         SPACE 2\n*\n***> COUNT THE NUMBER OF SOURCE DATA SETS . IF MORE THAN ONE\n*   ALLOCATE SPACE FOR CONCATENATION BLOCK (DAIR '0C') .\n*\n         SPACE 1\n         XR    R3,R3               /ZERO COUNTER\nDSCOUNT  LA    R3,1(R3)            /INCREMENT COUNTER\n         TM    DSNNEXT,DSNLAST     /TEST FOR LAST\n         SPACE 1\n         L     R6,DSNNEXT          /NEXT DSN IF ANY - RC NOT CHANGED\n         BNO   DSCOUNT             /COUNT NEXT DSNAME IF ANY\n         SPACE 1\nDSPFF    LR    R2,R3               /KEEP NUMBER OF DATA SETS\n         SLL   R3,3                /MULTIPLY BY 8\n         LA    R3,12(R3)           /LENGTH OF CONCAT. BLOCK\n         ST    R3,CNCTLNGT         /KEEP LENGTH FOR FUTURE FREEMAIN\n         GETMAIN R,LV=(R3)\n         LR    R9,R1                /ADD. OF BLOCK\n         MVC   DA0CCD(CNCEND-CNCONS),CNCONS\n         STH   R2,DA0CNUMB          /# OF DATA SETS TO BE CONCATENATED\n         SPACE 1\nNOCNCT   L     R6,CNCT1             /FIRST PDE\n         LA    R1,DAPLUPT           /ADD. OF DAPL\n         ST    R1,FAILDAPL          /FOR POSSIBLE TROUBLES\n         LA    R2,DA0CDDN           /FIRST DDN INDEX\n         SPACE 2\nDSNLOOP  L     R8,DSNPTRN         /PTR TO DSNAME\n         CLI   0(R8),ASTERISK     /CHECK FOR TERMINAL\n         BE    TERMALC            /ALLOCATE TERMINAL AS INPUT FILE\n         SPACE 1\n         BAL   R5,DAIRALOC        /ALLOCATE DSNAME AS INPUT FILE\n         BNZ   ERRANAL            /ON ERROR PUTLINE AND ABORT\n         SPACE 1\n         MNOTE 0,'BYPASS IF SEQC=N SPECIFIED'\n***>   CHECK FOR RECFM=V IN FIRST DATA SET TO BE FORMATTED\n         SPACE 1\n         TM    RECFM,PRESENT      /ALREADY DONE ?\n         BO    NOFIRSTF           /YES , BYPASS\n         LA    R0,DSCBLEND-LOCWORK   /LENGTH OF WORK AREA\n         GETMAIN R,LV=(0)\n         LR    R7,R1              /KEEP ADD. OF AREA\n         MNOTE 4,'ALLOW FOR PARTIALLY QUALIFIED DSNAME'\n         MNOTE 0,'DSN->USERID.DSN ONLY IF IT EXISTS, OTHERWISE:'\n         MNOTE 0,'     USERID.DSN.MEMO'\n         MNOTE 0,'     USERID.DSN.SCRIPT'\n         MNOTE 0,'     USERID.DSN.TEXT'\n         MNOTE 0,' IN THAT ORDER'\n         USING DSCBF1,R7\n         MVC   DSCBL(4),CAMLSTL   /MOVE FLAGS FOR LOCATE\n         TM    DA08CTL,PREFIX     /USERID TO BE PREFIXED ?\n         BZ    NOPREF             / NO!\n         SPACE 1\n***>  PREFIX USERID TO DSNAME\n         SPACE 1\n         MVI   DSNVAL,BLANK       /BLANK BUFFER\n         MVC   DSNVAL+1(43),DSNVAL\n         L     R5,CPPLPSCB          /PTR. TO PSCB\n         USING PSCB,R5\n         XR    R15,R15\n         IC    R15,PSCBUSRL      /LENGTH OF USERID\n         BCT   R15,AFTMOVE\nMOVEID   MVC   DSNVAL(0),PSCBUSER\nAFTMOVE  EX    R15,MOVEID        /MOVE IN USERID\n         DROP  R5\n         LA    R5,DSNVAL         /ADD. OF DSNAME BUFFER\n         LR    R1,R5\n         LA    R1,1(R1,R15)      /OFFSET\n         MVI   0(R1),PERIOD      /PUT PERIOD\n         LH    R15,DSNAMEP       /LENGTH OF DSNAME\n         BCT   R15,AFTNAME\nMOVEDNM  MVC   1(0,R1),DSNAMEP+2\nAFTNAME  EX    R15,MOVEDNM       /MOVE DSNAME\n         B     AFTPREF           /DONE\n         SPACE 1\nNOPREF   LA    R5,DSNAMEP+2      /ADD. OF DSNAME BUFFER (NOT PREF)\n         SPACE 1\nAFTPREF  ST    R5,DSNPTR          /PTR. TO DSNAME BUFFER\n         XC    VOLPTR,VOLPTR      /ZERO VOLUME SERIAL\n         LA    R5,LOCWORK         /PTR. TO RESULT AREA\n         ST    R5,WORKPTR\n         MVI   RECFM,PRESENT      /SIGNAL DONE\n         SPACE 1\n         LOCATE DSCBL\n         SPACE 1\n         LTR   R15,R15          /TEST R.C.\n         BNZ   LOCERR           /R.C.\u00ac=0\n         SPACE 1\n         LA    R5,VOLSER        /PLACE OF VOLUME SERIAL\n         ST    R5,VOLPTR        /STORE PTR.\n         LA    R5,DS1FMTID      /PTR. TO RESULT AREA FOR OBTAIN\n         ST    R5,WORKPTR\n         MVI   DSCBL,OBTFLAG    /FLAGS FOR OBTAIN\n         SPACE 1\n         OBTAIN DSCBL\n         SPACE 1\n         LTR   R15,R15            /TEST RETURN CODE\n         BNZ   OBTAINER           /R.C.\u00ac=0\n         TM    DS1RECFM,RECFMV    /TEST FOR '40' BIT\n         BZ    FREEDSCB           /FAILED\n         TM    DS1RECFM,RECFMU    /TEST FOR '80' BIT\n         BO    FREEDSCB           /SUCCESS => RECFM=U\n         OI    RECFM,RECFMV       /SIGNAL RECFM=V\n         SPACE 1\nFREEDSCB EQU   *\n         SPACE 1\n         LA    R0,DSCBLEND-LOCWORK      /LENGTH OF AREA\n         LR    R1,R7                    /ADD. OF AREA\n         LA    R1,0(R1)                 /CLEAR HIGH ORDER BYTE\n         SVC   10                       /FREEMAIN SVC\n         SPACE 1\nNOFIRSTF EQU   *\n         SPACE 1\n*\n***> INSERT DDNAME IN CONCATENATION LIST .\n*\n         SPACE 1\n         MVC   0(8,R2),DA08DDN    /MOVE DDNAME\nINCRDDN  LA    R2,8(R2)           /NEXT ENTRY\n         SPACE 2\n         TM    DSNNEXT,DSNLAST       /TEST FOR LAST PDE\n         SPACE 1\n         L     R6,DSNNEXT            /ADD. OF NEXT PDE IF ANY\n         MVC   DA08DDN(8),BLANKS8    /BLANK DDNAME FIELD\n         BNO   DSNLOOP\n         SPACE 2\nDSNDONE  EQU   *\n         CLI   DA0CNUMB+1,1           /# OF ENTRIES > 1\n         BE    SOFDSN                 /NO - NO CONCAT NECESSARY\n         SPACE 2\n*\n***>  CONCATENATE DDNAMES\n*\n         SPACE 1\n         LA    R2,DA0CCD\n         ST    R2,DAPLDAPB       /PTR. TO DAPB\n         XC    ECB,ECB\n         LINK  EP=IKJDAIR,MF=(E,DAPLUPT)\n         LTR   R15,R15           /TEST RETURN CODE\n         BNZ   ERRANAL           /ON ERROR PUTLINE AND ABORT\n         SPACE 2\nSOFDSN   EQU   *\n         BR    R4           /RETURN\n         SPACE 3\n*\n***> ALLOCATE TERMINAL\n*\n         SPACE 1\nTERMALC  EQU   *\n         LA    R5,TRM1              /FOR SKIP\n         SPACE 2\nTRMALC   EQU   *\n         LA    R7,DA1CCD\n         ST    R7,DAPLDAPB       /PTR. TO DAPB\nTRMALC1  XC    ECB,ECB\n         MVC   DA1CCD(DA1CEND-DA1CONS),DA1CONS   /MOVE \"LIST\" FORM\n         LINK  EP=IKJDAIR,MF=(E,DAPLUPT)\n         LTR   R15,R15           /TEST RETURN CODE\n         BNZ   ERRANAL           /ON ERROR PUTLINE AND ABORT\n         SPACE 1\n         BR    R5                /RETURN OR SKIP\n         SPACE 1\nTRM1     MVC   0(8,R2),DA1CDDN   /DDNAME TO PLACE\n         LA    R7,DA08CD         /RESTORE PTR. TO CODE \"08\"\n         ST    R7,DAPLDAPB\n         B     INCRDDN           /BACK TO NORMAL\n         EJECT\n*\n*\n***>  ALLOCATION OF DSNAME BY DAIR CODE \"08\"\n*\n*\n         SPACE 1\nDAIRALOC LA    R0,DA08CD                                      ** TSM **\n         ST    R0,DAPLDAPB                                    ** TSM **\n         SPACE 1\n*\n**> AT ENTRY :  R5 POINTS TO RETURN ADDRESS\n*               R8 POINTS TO DSNAME\n*               R6 POINTS TO START OF PDE FOR THIS DSNAME\n*               R1 POINTS TO DAPL    -   WANNA BET?           ** TSM **\n*               DAPL IS ALREADY BUILT -  WANNA BET?           ** TSM **\n*               DDNAME FIELD IS BLANK\n*\n**>     EXIT :   BY    BR R5 .\n*                R15 CONTAINS RETURN CODE FROM DAIR\n*\n         SPACE 2\n         LH    R7,DSNLEN1           /LENGTH OF DSNAME\n         STH   R7,DSNAMEP\n         BCTR  R7,0\n         MVI   DSNAMEP+2,BLANK    /BLANK DSNAME BUFFER\n         MVC   DSNAMEP+3(43),DSNAMEP+2\n         EX    R7,MOVEDSN         /DSNAME TO PLACE\n         SPACE 1\n         TM    DSNFLG1,QUOTES     /DSNAME ENTERED BETWEEN QOUTES?\n         BO    QUOTED             / YES\n         MVI   DA08CTL,PREFIX     /USERID TO BE PREFIXED\n         B     MNMD\nQUOTED   MVI   DA08CTL,ZERO       /USERID NOT TO BE PREFIXED\n         SPACE 1\nMNMD     TM    DSNFLG2,PRESENT    /TEST FOR MEMBER NAME\n         BZ    PSWRD              /NONE\n         L     R8,DSNPTRM         /PTR TO MEMBER NAME\n         LH    R7,DSNLEN2         /LENGTH OF MEMBER NAME\n         BCTR  R7,0\n         MVC   DA08MNM(8),BLANKS8 /BLANK MEMBER NAME FIELD\n         EX    R7,MOVEMNM         /MEMBER NAME TO PLACE\n         SPACE 1\nPSWRD    TM    DSNFLG3,PRESENT    /TEST FOR PASSWORD\n         BZ    ALLOCDSN           /NONE\n         L     R8,DSNPTRP         /PTR TO PASSWORD\n         LH    R7,DSNLEN3         /LENGTH OF PASSWORD\n         BCTR  R7,0\n         MVC   DA08PSWD(8),BLANKS8 /BLANK PASSWORD FIELD\n         EX    R7,MOVEPSWD        /PASSWORD TO PLACE\n         SPACE 2\nALLOCDSN XC    ECB,ECB            /ZERO ECB\n         LINK  EP=IKJDAIR,MF=(E,DAPLUPT)\n         LTR   R15,R15            /TEST RETURN CODE\n         SPACE 1\n         BR    R5                /RETURN IF EVERYTHING O.K.\n         SPACE 1\n         DROP  R6\n         STITL 'EPILOG '\nSOF      ENDM  DSECT=PPL,END=PPLEND,RC=R4\n         SPACE 3\n*\n***>  FREE DATA SETS\n*\n         SPACE 1\nDONEFREE EQU   *\n         LA    R7,FLP1         /FIRST TIME -> FALL THROUGH\n         MVC   DA18CD(DA18END-DA18CONS),DA18CONS    /MOVE \"LIST\" FORM\n         LA    R2,DA18CD\n         ST    R2,DAPLDAPB         /PTR. TO DAPB\n         LH    R5,HALFONE      /TEST VALUE\n         XR    R4,R4           /ZERO RETURN CODE\nTWOFREE  LH    R2,DA0CNUMB         /NUMBER OF DDNAMES TO BE FREED\n         LA    R3,DA0CDDN          /START OF DDNAMES\nDOFREE   XC    ECB,ECB\n         SPACE 1\nFREELOOP MVC   DA18DDN(8),0(R3)    /MOVE DDNAME\n         LINK  EP=IKJDAIR,MF=(E,DAPLUPT)\n         LTR   R15,R15             /TEST RETURN CODE\n         BNZ   ERRANAL             /ON ERROR PUTLINE AND ABORT\n         SPACE 1\n         BR    R7                  /FALL OR RETURN\n         SPACE 1\nFLP1     LA    R3,8(R3)            /NEXT DDNAME TO BE FREED\n         BCT   R2,FREELOOP         /AGAIN ?\n         SPACE 2\n*\n***>  FREE THE SPACE ALLOCATED FOR CONCATENATION .\n*\n         SPACE 1\n         DROP  R9\n         L     R0,CNCTLNGT        /LENGTH OF AREA\n         LA    R1,0(R9)           /ADD. OF AREA\n         SVC   10                 /ISSUE FREEMAIN SVC\n         SPACE 1\n*\n***> CHECK IF THE AREA JUST FREED WAS FOR \"SYSLIB\" .\n*   (FIRST PASS) IF SO FREE ALSO THE AREA FOR \"DSN\" .\n*\n         SPACE 1\n         CH    R5,LIB            /CHECK FOR SECOND PASS (OR \"NOLIB\")\n         BNE   FREE2             / SECOND PASS (OR \"NOLIB\")=> DONE\n         SPACE 1\n         XC    LIB(2),LIB        /ZERO FOR SECOND PASS\n         L     R9,CNCTADD        /ADD. FOR DSN'S CONCAT AREA\n         MVC   CNCTLNGT(4),CNCTLNG1   /LENGTH OF AREA\n         B     TWOFREE           /FREE THIS AREA\n         SPACE 2\n*\n***> FREE \"SYSPRINT\" , \"CONTROL\" AND SCRIPT .\n*\n         SPACE 1\nFREE2    EQU   *\n         LA    R2,3        /NUMBER OF DDNAMES\n         LA    R3,SYSTERM+8   ADDRESS OF FIRST DDNAME\nFREEL2   BAL   R7,DOFREE   /FREE DDNAME\n         LA    R3,16(R3)   /NEXT DDNAME'S ADD.\n         BCT   R2,FREEL2\n         SPACE 1\n*\n***>  FREE PARAMETER AREA\n*\n         SPACE 1\n         L     R1,PRMSCR       /ADD. OF AREA\n         LH    R3,EQUS+4\n         LA    R0,MAXLEN(R3)   /LENGTH OF AREA\n         SVC   10              /ISSUE FREEMAIN SVC\n         SPACE 1\n         B     SOF         /DONE\n         STITL 'ERROR AND DIAGNOSTIC ROUTINES'\n***> ERROR IN \"NSCRIPT\"\n         SPACE 1\nNSCRERR  EQU   *\n         B     DTCH     ***> TEMPORARY <***\n         SPACE 1\n         LR    R4,R15      /FOR RETURN CODE PASSING\n         LA    R2,ER10     /ADD. OF MESSAGE\n         LA    R0,ER11-ER10  /LENGTH OF MESSAGE\n         B     MESSAGE     /TPUT AND ABORT\n         SPACE 3\nNSCABND  EQU   *\n*\n**>  \"NSCRIPT\" ABENDED\n*\n         SPACE 1\n         MVC   ABNDMSG(45),ER18      /MOVE TEMPLATE OF MESSAGE\n         SPACE 1\n*  USER CODE\n         LH    R2,ABENDC+1    LOAD ABEND CODE\n         LA    R3,4095\n         NR    R2,R3                 /ELIMINATE GARBAGE\n         CVD   R2,DWORK\n         OI    DWORK+7,COMPF        /PUT \"F\" IN LOWEST HALF BYTE\n         UNPK  ABNDMSG+41(4),DWORK+5(3)\n         SPACE 1\n*  SYSTEM CODE\n         UNPK  DWORK(5),ABENDC(3)   /UNPACK CODE + BYTE\n         MVC   ABNDMSG+28(3),DWORK  /MOVE RELEVANT PART\n         TR    ABNDMSG+28(3),TRTABLE /TRANSLATE HEX. CODES\n         LA    R2,ABNDMSG            /ADD. OF MESSAGE\n         LA    R0,45                 /LENGTH OF MESSAGE\n         SPACE 1\n         TPUT  (R2),(0)\n         SPACE 1\n         B     DONEFREE             /FREE AND EXIT\n         SPACE 3\n*\n***>  SUBTASK ABNORMALLY TERMINATED BY ATTENTION\n*\n         SPACE 1\nABEXIT   EQU   *\n         CLI   ATTIN,ATT#F        /FREE REQUESTED ?\n         BE    DONEFREE\n         SPACE 1\n*  \"ABEND\" WAS REQUESTED\n         LA    R4,69              /SIGNAL ABENDED\n         B     SOF\n         SPACE 3\nPARSFAIL LR    R4,R15             /ERROR CODE\n         LA    R2,ER9           /ERROR MESSAGE\n         LA    R0,ER10-ER9      /LENGTH OF MESSAGE\n         SPACE 3\nMESSAGE  TPUT  (R2),(0)\n         B     SOF\n         SPACE 3\n*\n***>  OBTAIN ERROR\n*\n         SPACE 1\nOBTAINER EQU   *\n         MVC   OBTERR(9),ER12          /\"OBTAIN\"\n         SPACE 1\nOBTLOC   EQU   *\n         MVC   OBTERR+9(L'ER11),ER11    /FIRST PART OF MESSAGE\n         CVD   R15,PDWORK              /CONVERT R.C.\n         OI    PDWORK+7,X'03'          /\"F\" IN LAST HALF BYTE\n         UNPK  OBTERR+9+L'ER11(2),PDWORK+6(2)  /UNPK & TO PLACE\n         SPACE 1\n         LR    R4,R15                  /ERROR CODE\n         SPACE 1\n         LA    R2,OBTERR               /ERROR MESSAGE\n         LA    R0,11+L'ER11            /LENGTH OF MESSAGE\n         SPACE 1\n         TPUT  (R2),(0)\n         SPACE 1\n*\n***>   FREE WORK AREA FOR OBTAIN\n*\n         SPACE 1\n         LA    R0,DSCBLEND-LOCWORK     /LENGTH OF AREA\n         LR    R1,R7                   /ADD. OF AREA\n         LA    R1,0(R1)                /CLEAR HIGH ORDER BYTE\n         SVC   10                      /FREEMAIN SVC\n         SPACE 1\n         B     SOF                     / END\n         SPACE 3\n*\n***>   LOCATE ERROR\n*\n         SPACE 1\nLOCERR   EQU   *\n         MVC   OBTERR(9),ER13          /\"LOCATE\"\n         B     OBTLOC                  /FURTHER PROCESS\n         SPACE 2\n         DROP  R7\n         EJECT\n*\n***>  ERROR ANALYSIS FOR DAIR USING DAIRFAIL(IKJEFF18)\n*\n         SPACE 2\nERRANAL  EQU   *\n         ST    R15,DAIRRC       /STORE R.C.\n         LA    R15,DAIRRC\n         ST    R15,FAILRC      /PTR TO R.C.\n         LA    R15,DAIRMSWR\n         ST    R15,FAILMSWR     /PTR TO ADD. OF MESSAGE WRITER\n         LA    R15,DAIRID\n         ST    R15,FAILID       /PTR TO I.D. OF C.P.\n         SPACE 1\n*   ATTACH\n         SPACE 1\n         XC    ECB,ECB\n         LA    R1,FAILDAPL      /ADD. OF PARAMETER LIST\n         LA    R6,ECB\n         ATTACH EP=IKJEFF18,ECB=(R6),SF=(E,LATT)\n         SPACE 1\n         ST    R1,TCBAD         /KEEP ADD. OF TCB\n         WAIT  ECB=ECB\n         SPACE 1\n         DETACH TCBAD           /DONE\n         L     R4,DAIRRC        /RETURN CODE FROM THE PROGRAM\n         B     SOF             /EXIT\n         EJECT\n         LTORG\n         STITL 'VALIDITY CHECK ROUTINES (VDCHECK CSECT)'\nVDCHECK  CSECT    ,     /CSECT FOR VALIDITY CHECK AND STAX/STAE .\n         USING VDCHECK,R11\n*\n***> VALIDITY CHECK ROUTINE FOR \"EQUALITIES\" .\n*\n         USING VALPAR,R1          /ADDRESSABILITY FOR PARAM. LIST\nEQUSCK   EQU   *\n*\n***>   VALIDITY CHECK ROUTINE FOR STRINGS OF THE FORM :\n*              +A=B  OR  &A=B\n*\n         STM   R14,R12,12(R13)\n         USING EQUSCK,R15\n         L     R12,=A(&MCSECT)\n         L     R11,=A(VDCHECK)      /ADD. OF START\n         DROP  R15\n         LR    R15,R13\n         L     R13,USERWORD\n         ST    R15,KEEPR\n         L     R10,PDEADR\n         USING QST,R10           /ADDRESSABILITY FOR PDE\n         LH    R9,QSTLNGT        /LOAD LENGTH OF STRING\n         BCTR  R9,0              /LENGTH-1\n         L     R8,QSTSTRP        /START OF STRING\n         DROP  R10\n         LR    R4,R8\n         AR    R4,R9            /END OF STRING ADD.\n         XR    R2,R2\n         EX    R9,TRTEX          /LOOK FOR NEXT DELIMITER\n         SPACE 2\n         B     BTAB1(R2)         /BRANCH WITH CODE RETURNED\nBTAB1    B     INV               /INVALID (NULL?)\n         B     FOP               / + OR & FOUND => START\n         SPACE 2\nINV      EQU   *\n*\n***>   INVALID PARAMETER(S) ENTERED\n*\n*  ERROR MESSAGE\n         LA    R2,ER1\n         LA    R0,L'ER1\n         B     ERRTPUT\n         SPACE 2\nFOP      EQU   *\n*\n***>   FIRST OPERAND START (+ OR &)\n*\n         LR    R7,R1             /ADD. OF + OR &\n         SR    R7,R8             /LENGTH OF STRING PARSED (-1)\nFOP1     LA    R7,1(,R7)\n         SR    R9,R7              /LENGTH REMAINING (-1)\n         LA    R8,1(R1)           /START ADD. FOR NEXT TRT\n         XR    R2,R2\n         EX    R9,TRTEX           /LOOK FOR \"=\"\n         B     BTAB2(R2)\n         SPACE 2\nBTAB2    B     INV                /NOTHING FOUND\n         B     INV                /NO \"=\" FOUND\n*\n***>  EQUAL SIGN\n*\n         LR    R7,R1\n         SR    R7,R8            /LENGTH OF PARAMETER (IDENTIFIER)\n         BNP   INV              /INVALID IF NO IDENTIFIER\n         LA    R7,1(,R7)        /LENGTH PARSED\n         LA    R8,1(R1)         /NEXT START ADD. FOR TRT\n         XR    R2,R2\n         SR    R9,R7            /LENGTH OF STRING TO BE PARSED\n         EX    R9,TRTEX\n         B     BTAB3(R2)\n         SPACE 2\nBTAB3    B     GOOD            /END OF STRING ??\n         B     NEXTEQ          /NEXT EQUALITY\n         B     INV             /INVALID (\"=\" AFTER \"=\")\n         SPACE 2\nGOOD     EQU   *\n         SR    R4,R1           /LENGTH OF  VALUE\n         BNP   INV             /NULL VALUE\n         B     RC0             /RETURN\n         SPACE 1\nNEXTEQ   EQU   *\n*\n***>  NEXT PARAMETER-VALUE PAIR\n*\n         LR    R7,R1\n         SR    R7,R8          /LENGTH OF VALUE\n         BNP   INV            /NULL VALUE\n         B     FOP1           /GO AGAIN TO FIND \"=\"\n         SPACE 1\nTRTEX    TRT   0(0,R8),VECT  /EXECUTE TRT ON QSTRING\n         SPACE 3\n         CHECK AD\n         CHECK CE\n         CHECK CH\n         CHECK DO\n         CHECK FNS\n         CHECK LIN\n         CHECK NU\n         CHECK PA,CHK=NO\n         CHECK PAS\n         CHECK RMS\n         CHECK SEQC\n         CHECK SRE\n         CHECK SRL\n         CHECK WO\n         SPACE 2\nRC0      XR    R15,R15\n         B     RET\n         SPACE 2\nERRTPUT  TPUT  (R2),(0)\n         SPACE 1\nRC8      LA    R15,8\n         B     RET\n         SPACE 3\nGENCK    LR    R15,R13\n         L     R13,USERWORD       /ADD. OF WORK AREA\n         ST    R15,KEEPR          /SAVE R13\n         L     R10,PDEADR\n         USING QST,R10\n         CH    R9,QSTLNGT\n         BLR   R6             ERROR IF GREATER THAN MAX\n         L     R8,QSTSTRP     /ADD. OF NUMBER\n         LH    R1,QSTLNGT     LENGTH OF USER VALUE\n         DROP R10\n         BCTR  R1,0           FOR EXECUTE\n         EX    R1,CLCEX       COMPARE WITH MAXIMUM VALUE\n         BHR   R6             ERROR IF VALUE GREATER THAN MAX\n         CLC   0(1,R5),0(R8)  COMPARE TO LOWER LIMIT\n         BNH   RC0            BRANCH IF LOWER LIMIT IS VALID\n         BR    R6             /RETURN TO CALLER (ERROR)\n         SPACE 1\nCLCEX   CLC   0(0,R8),0(R7)   /FOR LIMIT COMPARISON\n         SPACE 5\n*\n***>  RETURN SEQUENCE FOR VALIDITY CHECK ROUTINES .\n***>  R15 CONTAINS RETURN CODE , KEEPR   CONTAINS\n*   R13 TO POINT TO THE SAVE AREA .\n*\n         DROP  R1\nRET      EQU   *\n         L     R13,KEEPR      /RESTORE R13\n         ST    R15,16(R13)    /SAVE RETURN CODE\n         LM    R14,R12,12(R13)\n         BR    R14            /RETURN\n*\n         STITL 'ATTENTION HANDLING  (STAX)'\nATTEN    STM   R14,R12,12(R13)\n         USING ATTEN,R15\n         L     R12,=A(&MCSECT)\n         L     R11,=A(VDCHECK)\n         DROP  R15\n         USING ATTPARM,R1        /DSECT FOR ATT. PARM LIST\n         L     R3,ATTIBUF        /PTR. TO INPUT BUFFER\n         L     R5,ATTUSERP       /PTR. TO TCB FOR SUBTASK<9\n         DROP  R1\n         SPACE 1\nATTLOOP  EQU   *\n         SPACE 1\n*   ANALYZE THE INPUT FROM THE USER\n         CLI   0(R3),ATT#Q       /QUESTION MARK ?\n         BE    SECATTN           /SECOND LEVEL MESSAGE\n         SPACE 1\n         OI    0(R3),BLANK       /TRANSLATE TO UPPERCASE\n         CLI   0(R3),ATT#A       /ABEND REQUEST ?\n         BE    ATTABND\n         SPACE 1\n         CLI   0(R3),ATT#C       /CONTINUE ?\n         BE    ATTCONT\n         SPACE 1\n         CLI   0(R3),ATT#F       /FREE REQUEST ?\n         BNE   NWANSATT          /BAD REPLY , GET NEW ANSWER\n         SPACE 3\n*  FREE/ABEND REQUEST\n         SPACE 1\nATTABND  EQU   *\n* BUFFER CONTAINS CODE FOR PARENT TASK TO REACT\n         SPACE 1\n         LR    R1,R5          /PTR. TO ADD. OF SUBTASK'S TCB\n         SVC   62             /ISSUE DETACH SVC\n         B     ATTRET         /RETURN\n         SPACE 2\n*  CONTINUE REQUEST\n         SPACE 1\nATTCONT  EQU   *\n         TPUT  ER16,L'ER16     /WARN FOR MISSING LINES\n         SPACE 1\nATTRET   EQU   *\n         LM    R14,R12,12(R13)\n         BR    R14             /RETURN TO ORIGIN\n         SPACE 3\n*  SECOND LEVEL MESSAGE AND REQUEST FOR NEW ANSWER\n         SPACE 1\nSECATTN  EQU   *\n         TPUT  ER141,L'ER141\n         TPUT  ER142,L'ER142\n         TPUT  ER143,L'ER143\n         SPACE 1\n*  GET NEW ANSWER\n         SPACE 1\nNWANSATT EQU   *\n         SPACE 1\n*  FIRST , PRINT OUT REQUEST ; THEN GET NEW INPUT\n         SPACE 1\n         TPUT  ER15,L'ER15\n         SPACE 1\n         TGET  (R3),1\n         SPACE 1\n         B     ATTLOOP          /GO ANALYZE ANSWER\n         SPACE 5\nSTAEROUT EQU   *\n*\n**>  ABEND INTERCEPTING ROUTINE FOR ATTACHED \"NSCRIPT\"\n*\n         SPACE 1\n         STM   R14,R12,12(R13)\n         USING STAEROUT,R15\n         L     R12,=A(&MCSECT)\n         L     R11,=A(VDCHECK)\n         DROP  R15\n         USING STAEPLST,R1         /PARM. LIST GOTTEN\n         L     R2,STAEPARP         /ADD. OF CODES' BUFFER\n         MVC   0(3,R2),STAECODE    /MOVE CODES\n         DROP  R1\n         LA    R15,16\n         ST    R15,16(R13)         /RETURN CODE\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE 3\n         LTORG\n         SPACE 1\n         DROP  R11\n         STITL 'PARAMETER BUILDING (BUILDPRM CSECT)'\n*\n*  ROUTINE WHICH ANALYSES THE OUTPUT FROM \"PARSE\" AND\n* BUILDS THE PARAMETER TO BE PASSED TO \"NSCRIPT\" .\n*\n*  AT ENTRY :\n*           R14 - RETURN ADDRESS\n*           R15 - ENTRY ADDRESS\n*           R1  - ADDRESS OF PARSE RESULT DSECT\n*\n*  NOTHING RETURNED AT EXIT FROM CSECT . ALL RESULTS STORED IN\n* COMMON WORK AREA POINTED AT BY \"OLD\" R13 .\n*\n         SPACE 2\nBUILDPRM CSECT\n         DS    0H\n         USING BUILDPRM,R11\n         STM   R14,R12,12(R13)\n         LR    R11,R15\n         USING IKJPARMD,R10      /ADDRESSABILITY FOR PDL\n         SPACE 2\n*\n***>  ALLOCATE SPACE FOR PARAMETER STRING TO BE PASSED\n*\n         SPACE 2\n         LH    R4,EQUS+4     /LENGTH OF EQUS' STRING\n         LA    R4,MAXLEN(R4) /ADD MAX. LENGTH OF THE REST + 2(LENGTH)\n         LR    R0,R4         /KEEP LENGTH\n         SPACE 1\n         GETMAIN R,LV=(0)\n         SPACE 1\n         ST    R1,PRMSCR     /TO PARAM. LIST\n         XC    PRMSCR(1),PRMSCR  /ZERO FIRST BYTE\n         LR    R7,R1\n         LA    R7,2(R7)      /START FOR PARAMETERS\n         SPACE 1\n         MVI   0(R7),BLANK   /CLEAN BUFFER\n         SH    R4,HALF3      /SUBTRACT LENGTH FIELD AND 1 FOR \"EX\"\n         EX    R4,CLEANBUF\n         SPACE 1\n         MOVEP1 CO\n         MOVEP1 UN\n         MOVEP1 NOMA\n         MOVEP1 ON\n         FLAG  ON,SWITCH,ONLINE FLAG SWITCH IF ONLINE OUTPUT\n         FLAG  OF,SWITCH,OFFLINE  FLAG SWITCH IF OFFLINE OUTPUT\n         MOVEP1 TWOP\n         MOVEP1 QU\n         MOVEP1 SCR\n         MOVEP1 SI\n         MOVEP1 STAT\n         MOVEP1 ST\n         MOVEP1 TR\n         MOVEP1 NOUP\n         MOVEP1 NOWA\n         MOVEP3 AD\n         MOVEP3 CE\n         MOVEP3 CH\n         MOVEP3 DO\n         MOVEP3 FNS\n         MOVEP3 LIN\n         MOVEP3 NU\n         MOVEP3 PAS\n         MOVEP3 RMS\n         MOVEP3 SRE\n         MOVEP3 SRL\n         MOVEP3 WO\n         MOVEP5 PA\n***\n***      RESOLVE ONLINE, OFFLINE.\n***\n         TM    SWITCH,ONLINE  IS OUTPUT ONLINE?\n         BZ    NONLINE        BRANCH IF NOT ONLINE\n         MOVEP2 ON            TELL SCRIPT OUTPUT IS ONLINE\nNONLINE  DS    0H\n         TM    SWITCH,OFFLINE IS OUTPUT OFFLINE?\n         BZ    NOFFLINE       BRANCH IF NOT OFFLINE\n         MOVEP2 OF            TELL SCRIPT OUTPUT IS OFFLINE\nNOFFLINE DS    0H\n         LR    R6,R7\n         MOVEP2 SEQC,SIGN=EQUAL\n         TM    ##SEQC+6,PRESENT\n         BZ    SEQC1             /ABSENT,CHECK FOR RECFM=V\n         L     R5,##SEQC         /PTR. TO VALUE\n         CLI   0(R5),ASTERISK    /IS IT \"*\" ?\n         BE    BPSEQC1\n         MOVEP4 SEQC\n         B     BPSEQC\n         SPACE 1\nSEQC1    EQU   *\n*\n***>    CHECK FOR RECFM \"V\"\n*\n         SPACE 1\n         TM    RECFM,RECFMV     /IS IT \"V\" ?\n         BZ    BPSEQC1          /NO\n         MVI   0(R7),ONE        /PUT VALUE \"1\"\n         LA    R7,2(R7)         /UPDATE OFFSET\n         B     BPSEQC           /ENDED\n         SPACE 1\nBPSEQC1  LR    R7,R6\n         SPACE 1\nBPSEQC   EQU   *\n         SPACE 1\n*\n***> ADD \"EQUS\" AND CALCULATE THE ACTUAL LENGTH OF STRING\n*\n         SPACE 1\n         L     R1,PRMSCR             /ADD. OF START OF STRING\n         TM    EQUS+6,PRESENT\n         BZ    FINALEN         /NO EQUS, GO ON\n         LH    R4,EQUS+4       /LENGTH OF \"QSTRING\"\n         L     R5,EQUS         /PTR. TO \"QSTRING\"\n         BCTR  R4,0            /-1 FOR \"EX\"\n         EX    R4,MOVEPR4      /MOVE \"EQUS\" TO PLACE\n         LA    R7,2(R4,R7)     /UPDATE OFFSET\nFINALEN  SR    R7,R1           /END - START (-2)\n         SH    R7,HALF3        /LENGTH OF STRING\n         STH   R7,0(R1)        /STORE IN PLACE\n         SPACE 3\n         LM    R14,R12,12(R13)\n         BR    R14            /RETURN TO MAIN\n         SPACE 3\n         SPACE 1\n         DROP  R11\n         SPACE 2\n&MCSECT  CSECT\n         STITL 'PARAMETER CONTROL LIST FOR PARSE'\n         PRINT NOGEN\nPARSE    IKJPARM\n         SPACE 1\nDSN      IKJPOSIT DSTHING,LIST,PROMPT='DATA SET NAME'\n         SPACE 1\nEQUS     IKJPOSIT QSTRING,ASIS,VALIDCK=EQUSCK,                         *\n               HELP=('VALUES TO CREATE \".SR\" CONTROL LINES EXTERNALLY')\n*        IKJPOSIT STRING,SQSTRING,ASIS,VALIDCK=EQUSCK,\n*              HELP=('VALUES TO CREATE \".SR\" CONTROL LINES EXTERNALLY')\n         SPACE 1\nLIB      IKJKEYWD DEFAULT='NOLIBRARY'\n         IKJNAME 'LIBRARY',SUBFLD=SLIB\n         IKJNAME 'NOLIBRARY'\n         SPACE 1\n         SPACE 1\nPRINT    IKJKEYWD DEFAULT='PRINT'\n         IKJNAME  'PRINT',SUBFLD=SPRINT\nCO       KEY   (CO,CONTINUE)\nUN       KEY   (UN,UNFORMATTED)\nNOMA     KEY   (NOMA,NOMARK)\nON       KEY   (ON,ONLINE,TE,TERMINAL)\nTWOP     KEY   (TWOP,TWOPASS)\nQU       KEY   (QU,QUIET)\nSCR      KEY   (SCRE,SCREEN)\nSI       KEY   (SI,SINGLE)\nSTAT     KEY   (STAT,STATISTICS)\nST       KEY   (ST,STOP)\nTR       KEY   (TR,TRANSLATE)\nNOUP     KEY   (NOUP,NOUPPER)\nNOWA     KEY   (NOWA,NOWAIT)\n*****\n*****    DEFAULT KEYWORDS\n*****\nNOCO     KEY   (NOCO,NOCONTINUE)\nFO       KEY   (FO,FORMATTED)\nMA       KEY   (MA,MARK)\nOF       KEY   (OF,OFFLINE)\nONEP     KEY   (ONEP,ONEPASS)\nNOQU     KEY   (NOQU,NOQUIET)\nNOSCRE   KEY   (NOSCRE,NOSCREEN)\nNOSI     KEY   (NOSI,NOSINGLE)\nNOSTAT   KEY   (NOSTAT,NOSTATISTICS)\nNOST     KEY   (NOST,NOSTOP)\nNOTR     KEY   (NOTR,NOTRANSLATE)\nUP       KEY   (UP,UPPER)\nWA       KEY   (WA,WAIT)\nNOAD     KEY   (NOAD,NOADJUST)\nNOCE     KEY   (NOCE,NOCENTRE,NOCENTE,NOCENTER)\nNONU     KEY   (NONU,NONUMBER)\n*****\n*****    KEYWORDS WITH SUBFIELDS\n*****\nAD       KEY   (AD,ADJUST),SUB=YES\nCE       KEY   (CE,CENTRE,CENTE,CENTER),SUB=YES\nCH       KEY   (CH,CHANNEL),SUB=YES\nDO       KEY   (DO,DOWN),SUB=YES\nFNS      KEY   (FNS,FNSIZE),SUB=YES\nLIN      KEY   (LIN,LINENUMBER),SUB=YES\nNU       KEY   (NU,NUMBER),SUB=YES\nPA       KEY   (PA,PAGE),SUB=YES\nPAS      KEY   (PAS,PASSES),SUB=YES\nRMS      KEY   (RMS,RMSIZE),SUB=YES\nSEQC     KEY   (SEQC,SEQCOLUMN),SUB=YES\nSRE      KEY   (SRE,SREFERENCE),SUB=YES\nSRL      KEY   (SRL,SRLENGTH),SUB=YES\nWO       KEY   (WO,WORKSIZE),SUB=YES\nAD       SUBF  'ADJUST OFFSET',2,'MAX ADJUST'\nCE       SUBF  'ADJUST OFFSET',2,'MAX ADJUST'\nCH       SUBF  'CHANNEL NUMBER',1,'MUST BE 1 TO 9'\nDO       SUBF  'DOWN NUMBER',3,'MUST BE 1 TO 130'\nFNS      SUBF  'FOOT NOTE SIZE',4,'MAX FOOT NOTE SIZE'\nLIN      SUBF  'LINE NUMBER',3,'LINE'\nNU       SUBF  'LINE NUMBER, FILE NAME',3,'NUMBER'\nPA       SUBF  'FIRST PAGE NUMBER',6,'PAGE NUMBERS',RANGE=YES\nPAS      SUBF  'NUMBER OF PASSES',2,'NUMBER OF PASSES'\nRMS      SUBF  'MAX RECORDS PER REMOTE',4,'MAX REMOTE SIZE'\nSEQC     SUBF  'SEQUENCE NUMBER COLUMN',3,'SEQUENCE COLUMN'\nSRE      SUBF  'NUMBER OF SET REFERENCES',4,'MAX SET REFERENCES'\nSRL      SUBF  'LENGTH OF SET REFERENCE NAME',3,'MAX SET REF NAME'\nWO       SUBF  'WORK SIZE',5,'MAX WORK SIZE'\nSLIB     IKJSUBF\nLIBB     IKJPOSIT DSNAME,LIST\n         SPACE 1\nSPRINT   IKJSUBF\nPRINTT1  IKJPOSIT DSTHING,DEFAULT='*'\nPRINTT2  IKJKEYWD\n         IKJNAME  'T'\n         IKJNAME  'PC'\n         IKJNAME  'PS'\n         SPACE 3\n         IKJENDP\n         PRINT GEN\n         STITL 'CONSTANTS'\nTRTABLE  DC    256X'40'      /TR'S VECTOR\n         ORG   TRTABLE+X'F0'\n         DC    C'0123456789'\n         DC    C'ABCDEF'\n         ORG\n         SPACE 3\nVECT     DC    256X'00'      /TRT'S VECTOR\n         ORG   VECT+X'4E'\n         DC    X'04'         /SIGNAL \"+\"\n         ORG   VECT+X'50'\n         DC    X'04'         /SIGNAL \"&\"\n         ORG   VECT+X'7E'\n         DC    X'08'         /SIGNAL \"=\"\n         ORG\n         SPACE 1\n*   LIMITS FOR VALIDITY CHECK ROUTINES\n         SPACE 1\n***\n***      FORMAT OF LIMIT VALUES IS:\n***\n***      C'U...U'             UPPER LIMIT.\n***            THIS GIVES BOTH THE LENGTH AND VALUE OF THE LIMIT.\n***\nADSTR    DC    C'30',C'0'\nCESTR    DC    C'30',C'0'\nCHSTR    DC    C'9',C'1'\nDOSTR    DC    C'130',C'1'\nFNSSTR   DC    C'1024',C'1'\nLINSTR   DC    C'125',C'0'\nNUSTR    DC    C'100',C'0'\nPASTR    DC    C'32767',C'1'\nPASSTR   DC    C'10',C'1'\nRMSSTR   DC    C'1024',C'1'\nSEQCSTR  DC    C'240',C'0'\nSRESTR   DC    C'4096',C'1'\nSRLSTR   DC    C'240',C'4'\nWOSTR    DC    C'65536',C'1024'\n         EJECT\n*   ERROR MESSAGES\n         SPACE 1\nER1      DC    C'**>VALID FORMAT IS ''+K=V'' OR ''&&K=V'''\nERAD     DC    C'** ERROR ** VALID RANGE FOR ADJUST IS 0-30'\nERCE     DC    C'** ERROR ** VALID RANGE FOR CENTRE IS 0-30'\nERCH     DC    C'** ERROR ** VALID RANGE FOR CHANNEL IS 1-9'\nERDO     DC    C'** ERROR ** VALID RANGE FOR DOWN IS 1-130'\nERFNS    DC    C'** ERROR ** VALID RANGE FOR FNSIZE IS 1-1024'\nERLIN    DC    C'** ERROR ** VALID RANGE FOR LINENUMBER IS 0-125'\nERNU     DC    C'** ERROR ** VALID RANGE FOR NUMBER IS 0-100'\nERPA     DC    C'** ERROR ** VALID RANGE FOR PAGE IS 1-32767'\nERPAS    DC    C'** ERROR ** VALID RANGE FOR PASSES IS 1-10'\nERRMS    DC    C'** ERROR ** VALID RANGE FOR RMSIZE IS 1-1024'\nERSEQC   DC    C'** ERROR ** VALID RANGE FOR SEQCOLUMN IS 0-240'\nERSRE    DC    C'** ERROR ** VALID RANGE FOR SREFERENCE IS 1-4096'\nERSRL    DC    C'** ERROR ** VALID RANGE FOR SRLENGTH IS 4-240'\nERWO     DC    C'** ERROR ** VALID RANGE FOR WORKSIZE IS 1024-65536'\nER9      DC    C'**>PROBLEMS IN PARSE,NOTIFY THE SYSTEM''S GROUP'\nER10     DC    C'**> \"NSCRIPT\" ENDED DUE TO ERROR .'\nER11     DC    C' ERROR CODE  '\nER12     DC    C'**>OBTAIN'\nER13     DC    C'**>LOCATE'\nER142    DC    C'2) CONTINUE MEANS IGNORE ATTN.'\nER143    DC    C'3) ABEND    MEANS EXIT IMMEDIATELY'\nER141    DC    C'1) FREE     MEANS FREE DATA SETS AND EXIT'\nER15     DC    C'****> ENTER \"F\" , \"C\" OR \"A\" .'\nER16     DC    C'**> WARNING : LINES MAY BE MISSING FROM OUTPUT'\nER18     DC    C'COMPLETION CODES : SYSTEM -     , USER -     '\n         SPACE 1\nATTOUT   DC    C'**> ENTER \"F\"(FREE) ,\"C\"(CONTINUE) OR \"A\"(ABEND) +'\n         EJECT\n*\n***>   \"LIST\" FORMS FOR DAIR CODES 18 , 0C , 1C , 08 AND ATTACH\n*\n         SPACE 2\n         DS    0F\n         SPACE 1\nDA18CONS DC    X'0018'\n         DC    3H'0'\n         DC    F'0'\n         DC    2CL8' '\n         DC    CL2' '\n         DC    X'08'\n         DC    X'10'\n         DC    CL8' '\nDA18END  EQU   *\n         SPACE 2\nCNCONS   DC    X'000C'\n         DC    3H'0'\nCNCEND   EQU   *\n         SPACE 2\nDA1CONS  DC    X'001C'\n         DC    2H'0'\n         DC    X'00'\n         DC    X'08'\n         DC    2CL8' '\nDA1CEND  EQU   *\n         SPACE 2\nDA08CNST DC    X'0008'\n         DC    3H'0'\n         DS    A\n         DC    3CL8' '\n         DC    4F'0'\n         DC    2CL8' '\n         DC    3X'08'\n         DS    C\n         DC    AL3(0)\n         DS    C\nBLANKS8  DC    CL8' '\n         ATTACH SF=L,SHSPV=78\n         DC    F'0'         /ADD. OF MESSAGE WRITER\nHALFONE  DC    H'1'         /I.D. FOR C.P.\nLFORMS   EQU   *\n         SPACE 2\nALICONS  DC    H'4'\n         DC    CL16'SYSIN'\n         DC    CL16'SYSTERM'\n         DC    CL16'SYSCONS'\n         DC    CL16'SYSPRINT'\n         DC    CL16'SYSLIB'\nALIEND   EQU   *\nHALF3    DC    H'3'\n         SPACE 2\n*  TEST CONSTANTS FOR DATA SET TO BE ALLOCATED AS \"NEW\" .\n         SPACE 1\nOLDDS1   DC    H'8'\nOLDDS2   DC    X'17080008'\n         SPACE 1\n*   CONSTANTS FOR DAIR \"08\" (NEW DATA SET)\n         SPACE 1\nDAIRNEW  DC    F'1680'      /AVERAGE BLOCK SIZE\n         DC    F'1'         /NUMBER OF PRIMARY TRACKS\n         DC    F'1'         /  \"    \"  SECONDARY TRACKS\n         DC    F'28'        /NUMBER OF DIRECTORY BLOCKS (OPTIONAL)\n         SPACE 2\n*\n***>  FLAGS FOR CAMLST\n*\n         SPACE 1\n         DS    0F\nCAMLSTL  DC    AL1(68)\n         DC    AL1(0)\n         DC    AL1(0)\n         DC    AL1(0)\n         STITL 'EQUATES'\nZERO     EQU   X'00'\nPREFIX   EQU   X'20'\nBLANK    EQU   C' '\nQUOTES   EQU   X'40'\nPRESENT  EQU   X'80'\nDSNLAST  EQU   X'FF'\nMAXLEN   EQU   120    /MAXIMUM PARAMETER LENGTH\nEQUAL    EQU   C'='\nASTERISK EQU   C'*'\nONE      EQU   C'1'\nRECFMV   EQU   X'40'\nRECFMU   EQU   X'80'\nOBTFLAG  EQU   X'C1'     /FLAGS FOR OBTAIN\nPERIOD   EQU   C'.'\nDSNEW    EQU   X'04'\nUNITSTRK EQU   X'80'\nATT#A    EQU   C'A'\nATT#C    EQU   C'C'\nATT#F    EQU   C'F'\nATT#Q    EQU   C'?'\nCOMPF    EQU   X'03'\n         STITL 'INSTRUCTIONS FOR EX(ECUTE)'\nMOVEDSN  MVC   DSNAMEP+2(0),0(R8)\nMOVEMNM  MVC   DA08MNM(0),0(R8)\nMOVEPSWD MVC   DA08PSWD(0),0(R8)\nMOVEPR4  MVC   0(0,R7),0(R5)\nMOVEDSNW MVC   DA08BLK(0),DAIRNEW\nCLEANBUF MVC   1(0,R7),0(R7)\n         LTORG\n         STITL 'STORAGE AREAS AND DSECTS'\n         IKJPPL\n*\n***>   DAPL\n*\n         SPACE 2\nDAPLUPT  EQU   PPLUPT\nDAPLECT  EQU   PPLECT\nDAPLECB  EQU   PPLECB\nDAPLPSCB EQU   PPLPCL\nDAPLDAPB EQU   PPLANS\n         SPACE 3\nECB      DS    F\nANS      DS    F\nKEEPR    DS    F\nTCBAD    DS    F          /ADD. OF TCB FOR ATTACH-DETACH\n         SPACE 5\n*\n***>  LIST FORMS FOR DAIR CODE 08 AND ATTACH\n*\n         SPACE 2\nDA08CD   DS    CL2     /DAIR ENTRY CODE\nDA08FLG  DS    X       /FUNCTIOS TO BE PERFORMED WHEN RC=0\n         DS    X\nDA08DARC DS    H       /DYN ALLOC R.C.\nDA08CTRC DS    H       /CATALOG R.C.\nDA08PDSN DS    A       /PTR TO DSNAME\nDA08DDN  DS    CL8     /DDNAME\nDA08UNIT DS    CL8     /UNIT NAME\nDA08SER  DS    CL8     /VOLUME SERIAL\nDA08BLK  DS    F       /AVERAGE BLOCK LENGTH\nDA08PQTY DS    F       /PRIMARY SPACE QUANTITY\nDA08SQTY DS    F       /SECONDARY SPACE QUANTITY\nDA08DQTY DS    F       /DIRECTORY BLOCK QUANTITY\nDA08MNM  DS    CL8     /MEMBER NAME\nDA08PSWD DS    CL8     /PASSWORD\nDA08DSP1 DS    X       /DATA SET STATUS\nDA08DPS2 DS    X       /DATA SET DISPOSITION\nDA08DPS3 DS    X       /DATA SET CONDITIONAL DISPOSITION\nDA08CTL  DS    X       /FLAGS FOR DAIR\n         DS    CL3     /RESERVED\nDA08DSO  DS    CL1     /DSORG\nDA08ALN  DS    CL8     /ATTR-LIST-NAME\n         SPACE 2\nLATT     ATTACH SF=L\n         SPACE 2\nDAIRMSWR DS    F          /ADD. OF MESSAGE WRITER(IKJEFF02)\nDAIRID   DS    H          /I.D. FOR DAIRFAIL\n         SPACE 3\nDSNAMEP  DS    H,CL44     /BUFFER FOR DSNAME TO BE ALLOCATED\n         SPACE 1\nDAIRRC   DS    F         /DAIR RETURN CODE (R15)\n         SPACE 2\n*\n***>  DAIRFAIL PARAMETER LIST\n*\n         SPACE 1\nFAILDAPL DS    A         /PTR TO DAPL\nFAILRC   DS    A         /PTR TO R.C. (R15)\nFAILMSWR DS    A         /PTR TO ADD. OF MESSAGE WRITER\nFAILID   DS    A         /PTR TO I.D. OF C.P.\n         SPACE 2\n*\n***> DAIR CODE \"1C\" (ALLOCATE TERMINAL)\n*\n         SPACE 1\n         ORG   DSNAMEP+2     /OVERLAY ON DSNAME BUFFER (FWRD. BOUND)\nDA1CCD   DS    CL2           /ENTRY CODE \"1C\"\nDA1CFLG  DS    H             /RESERVED FIELD=0\nDA1CDARC DS    H             /R.C. FROM DYNAMIC ALLOC.\n         DS    X             /RESERVED=0\nDA1CCTL  DS    X             /CONTROL BYTE (PERMANENT ALLOC.)\nDA1CDDN  DS    CL8           /DDNAME\nDA1CALN  DS    CL8           /ATTR.-LIST NAME\n         ORG\n         SPACE 2\n*\n***> DAIR CODE \"18\" (FREE)\n*\n         SPACE 1\n         ORG   DA08CD         /OVERLAY DAIR CODE \"08\" (ALLOC.)\nDA18CD   DS    CL2            /ENTRY CODE \"18\"\nDA18FLG  DS    H              /FLAGS FOR DAIR TO SET\nDA18DARC DS    H              /DYNAMIC ALLOC. RETURN CODE\nDA18CTRC DS    H              /CATALOG RETURN CODE\nDA18PDSN DS    A              /PTR. TO DSNAME BUFFER\nDA18DDN  DS    CL8            /DDNAME\nDA18MNM  DS    CL8            /MEMBER NAME\nDA18SCLS DS    CL2            /SYSOUT CLASS (BLANK)\nDA18DPS2 DS    X              /NORMAL DISP. -> KEEP\nDA18CTL  DS    X              /UNALLOCATE PERM. ALLOC.\nDA18JBNM DS    CL8            /JOB NAME (BLANK)\n         ORG\n         SPACE 2\nCNCTLNGT DS    F                  /FOR LENGTH OF AREA FOR CONCAT.\n         SPACE 1\nCNCTLNG1 DS    F                  /SECOND LEVEL LENGTH FOR CONCAT\n         SPACE 1\nCNCTADD  DS    A                  /SECOND LEVEL ADD. OF CONCAT AREA\n         SPACE 1\nCNCT1    DS    A    /PTR. TO FIRST PDE FOR CONCAT\n         SPACE 1\nPRMSCR   DS    2A   /PARM. LIST FOR \"NSCRIPT\"\n         SPACE 1\nALIASES  DS    H    /# OF DDNAMES WITH ALIASES FOLLOWING\nSYSIN    DS    2CL8           PRIMARY INPUT FILE\nSYSTERM  DS    2CL8           SCRIPT ERROR MESSAGES\nSYSCONS  DS    2CL8           CONTROL FOR IMBEDS\nSYSPRINT DS    2CL8           SCRIPT OUTPUT\nSYSLIB   DS    2CL8  /LIBRARY (IES)\n         SPACE 1\nSTWAIT   DS    X      /\"STOP\" + \"WAIT\" FLAG\n         SPACE 1\nPRTETR   EQU   STWAIT   /\"TE\" + \"TR\" FLAG\n         SPACE 1\nRECFM    DS    X     /FLAG FOR RECFM\nSWITCH   DC    X'00'          SWITCHES\nONLINE   EQU   X'01'          ONLINE OUTPUT - IMPLICIT OR EXPLICIT\nOFFLINE  EQU   X'02'          OFFLINE OUTPUT - IMPLICIT OR EXPLICIT\n         SPACE 2\n***>   LIST FORM OF \"STAX\" + VARIABLES FOR IT\n         SPACE 1\nSTXLST   STAX  ATTEN,MF=L\n         SPACE 1\n         SPACE 1\nATTIN    DS    C              /INPUT BUFFER FOR ATTENTION\nABENDC   DS    CL3            /BUFFER FOR ABEND CODES\nDWORK    DS    D              /WORK AREA FOR CVD + UNPK\nABNDMSG  DS    CL45           /AREA FOR ABEND MESSAGE\n         SPACE 2\nPPLEND   EQU   *\n         EJECT\n         IKJCPPL\n         EJECT\nVALPAR   DSECT  ,       /DSECT FOR PARAMETERS PASSED TO VALIDCK\nPDEADR   DS    A\nUSERWORD DS    A\nVALMSG   DS    A        /ADD. FOR A SECOND LEVEL MESSAGE\n         EJECT\nATTPARM  DSECT   ,       /DSECT FOR PARM. LIST AT ATTENTION INT.\nATTTAIE  DS    A         /ADD. OF TAIE\nATTIBUF  DS    A         /ADD. OF INPUT BUFFER\nATTUSERP DS    A         /ADD. OF USER PTR.\n         EJECT\nQST      DSECT   ,      /DSECT FOR QSTRING PDE\nQSTSTRP  DS    A        /POINTER TO STRING\nQSTLNGT  DS    H        /LENGTH OF STRING\nQSTFLG   DS    X        /FLAGS\nQSTRSVD  DS    X        /RESERVED\n         EJECT\n         IKJDAP0C\nDA0CDDN  EQU   *\n         EJECT\nDSNDSECT DSECT    ,    /DSECT FOR DSTHING PDE (INCLUDING \"LIST\")\nDSNPTRN  DS    A      /POINTER TO DSNAME\nDSNLEN1  DS    H      /LENGTH OF DSNAME\nDSNFLG1  DS    C      /FLAGS\nDSNRSV1  DS    C      /RESERVED\nDSNPTRM  DS    A      /POINTER TO MEMBER NAME\nDSNLEN2  DS    H      /LENGTH OF MEMBER NAME\nDSNFLG2  DS    C      /FLAGS\nDSNRSV2  DS    C      /RESERVED\nDSNPTRP  DS    A      /POINTER TO PASSWORD\nDSNLEN3  DS    H      /LENGTH OF PASSWORD\nDSNFLG3  DS    C      /FLAGS\nDSNRSV3  DS    C      /RESERVED\nDSNNEXT  DS    A      /POINTER TO NEXT ENTRY IN THE LIST\n*                     /  IF LAST THEN X'FF' IN UPPER BYTE\n         EJECT\nDSCBF1   DSECT   ,        /DSECT FOR FORMAT 1 DSCB & LOCATE\nLOCWORK  DS    265C       /WORK AREA FOR LOCATE\n         ORG   LOCWORK+6\nVOLSER   DS    CL6        /VOLUME SERIAL (FROM LOCATE)\n         ORG\n         DS    CL7        /FILLER (FOR DOUBLE-WORD BOUNDARY)\n         SPACE 1\n*\n***>   \"LIST\" FORM FOR CAMLST\n*\n         SPACE 1\nDSCBL    EQU   *\n         DS    AL1         /FLAGS (3 BYTES)\n         DS    AL1\n         DS    AL1\n         DS    AL1         /NO OPTION THREE (0)\nDSNPTR   DS    A           /PTRS. TO PARAMETERS\nVOLPTR   DS    A\nWORKPTR  DS    A\nDSNVAL   DS    CL44        /BUFFER FOR PREFIXING USERID TO DSNAME\n         SPACE 1\n         ORG   LOCWORK\n         IECSDSL1 (1)\n         ORG\nOBTERR   EQU   DS1DSNAM     /WORK AREA FOR ERROR MESSAGE\nPDWORK   EQU   VOLPTR       /WORK AREA FOR \"CVD\"\nDSCBLEND EQU   *\n         EJECT\n         IKJPSCB\n         EJECT\nSTAEPLST DSECT   ,     /PARM. LIST PASSED TO STAI EXIT\nSTAEPARP DS    A       /ADD. OF PARM. LIST\nSTAEFLGS DS    C       /FLAGS\nSTAECODE DS    CL3     /COMPLETION CODES\nSTAEPSW  DS    D       /PSW AT ABEND\nSTAELPSW DS    D       /LAST PSW BEFORE ABEND\nSTAEREGS DS    16F     /REGS. 0-15 AT ABEND\nSTAEVARS DS    CL16    /P.P <=> SV.P.\n         SPACE 3\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT284/FILE284.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT284", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}