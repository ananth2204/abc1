{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012655000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE726.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE726.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x02'", "DS1TRBAL": "b'\\xda6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xfb\\x00\\n\\x04\\xfc\\x00\\x00\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\"/\\x01\\x06\"/\\x08\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-08-10T00:00:00", "modifydate": "2006-08-10T08:00:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-472"}, "text": "REGULAR CBT TAPE - VERSION 472    FILE:  726\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT472.FILE726\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 6 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,833 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/10/06    08:00:23    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE726": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04H\\x00\\x00\\x01\\x06\"/\\x01\\x06\"/\\x08\\x00\\x00A\\x00A\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf2@@@'", "ispf": {"version": "04.72", "flags": 0, "createdate": "2006-08-10T00:00:00", "modifydate": "2006-08-10T08:00:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "CBT-472"}, "text": "//***FILE 726 is from Ted MacNeil, and contains a REXX exec to      *   FILE 726\n//*           generate DEFINE statements for VSAM files, directly   *   FILE 726\n//*           from the file itself.  Details are explained below.   *   FILE 726\n//*                                                                 *   FILE 726\n//*     This code either displays a VSAM entry or writes the        *   FILE 726\n//*     IDCAMS control statement needed to define a VSAM file.      *   FILE 726\n//*     (MUST run under ISPF.)                                      *   FILE 726\n//*                                                                 *   FILE 726\n//*     From ISPF 3.4, type VC3 next to a VSAM data set             *   FILE 726\n//*                                                                 *   FILE 726\n//*     Further modified by Philippe Simon.  Please see members     *   FILE 726\n//*     VCP and VCP$$ for his version and explanation thereof.      *   FILE 726\n//*                                                                 *   FILE 726\n//*     email for Philippe Simon:  philippe_simon_55@yahoo.fr       *   FILE 726\n//*                                                                 *   FILE 726\n//*     Originally Written by Jim Connelley.  Jim's version is      *   FILE 726\n//*     included here as member VC.                                 *   FILE 726\n//*                                                                 *   FILE 726\n//*     No copyright.                                               *   FILE 726\n//*     If you want to, send your enhancements to                   *   FILE 726\n//*                                                                 *   FILE 726\n//*             email:  tedmacneil@bell.blackberry.net              *   FILE 726\n//*                                                                 *   FILE 726\n//*     Reason for this REXX:                                       *   FILE 726\n//*             I needed a method to clean up our old               *   FILE 726\n//*             VSAM with the keywords: REPLICATE, IMBED            *   FILE 726\n//*             and KEYRANGE. This was the fastest way.             *   FILE 726\n//*             Those parameters are caught but not                 *   FILE 726\n//*             written to control cards.                           *   FILE 726\n//*             I also added a few lines to do a:                   *   FILE 726\n//*             DELETE ------ PURGE at the front                    *   FILE 726\n//*             (Optional)                                          *   FILE 726\n//*                                                                 *   FILE 726\n//*     There are bugs, such as handling multi-volume files, but    *   FILE 726\n//*     that's where YOU come in.                                   *   FILE 726\n//*     (-- Ted MacNEIL -- I believe I fixed this bug, but I did    *   FILE 726\n//*                        not have any multi-volumes to test       *   FILE 726\n//*                        with.)                                   *   FILE 726\n//*                                                                 *   FILE 726\n//*     (-- The dependency on STEMVIEW was removed to either write  *   FILE 726\n//*      -- out to a file or stay inside a loop)                    *   FILE 726\n//*                                                                 *   FILE 726\n//*   Syntax:                                                       *   FILE 726\n//*                                                                 *   FILE 726\n//*     %VC3 VSAMDSN pds member DELETE                              *   FILE 726\n//*                                                                 *   FILE 726\n//*       VSAMDSN -- the VSAM FILE you wish to CLONE                *   FILE 726\n//*                  (if you specify quotes, they are removed)      *   FILE 726\n//*                                                                 *   FILE 726\n//*       pds     -- where to output the control cards (Optional)   *   FILE 726\n//*                - default: <userid>.VSAM.CONTROL.CARDS           *   FILE 726\n//*                                                                 *   FILE 726\n//*       member  -- the member name used to output the statements  *   FILE 726\n//*                  (Optional)                                     *   FILE 726\n//*                                                                 *   FILE 726\n//*       DELETE  -- Insert DELETE <entry> PURGE                    *   FILE 726\n//*               -- (Optional)                                     *   FILE 726\n//*                                                                 *   FILE 726\n//*     NOTE: 1. if PDS does not exist, this outputs to the screen  *   FILE 726\n//*                                                                 *   FILE 726\n//*           2. The only entry types supported are:                *   FILE 726\n//*              ignored and only the DEFINE ALIAS ... RELATE       *   FILE 726\n//*              will be output. There is not enough information    *   FILE 726\n//*              in the LISTCAT output to rebuild the catalogue.    *   FILE 726\n//*                                                                 *   FILE 726\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VC": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00F\\x01\\x05)O\\x01\\x05)o\\x10G\\x02\\n\\x01\\xf6\\x00\\x00\\xd1`\\xc3\\xd6\\xd5\\xd5@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2005-10-21T00:00:00", "modifydate": "2005-10-23T10:47:46", "lines": 522, "newlines": 502, "modlines": 0, "user": "J-CONN"}, "text": "/*------------------- REXX -----------------------------------*\n *                                                            *\n * This code either displays a VSAM entry or writes the       *\n * IDCAMS control statement needed to define a VSAM file.     *\n * (MUST run under ISPF)                                      *\n *                                                            *\n * From ISPF 3.4, type VC next to a VSAM data set             *\n *                                                            *\n * Originally Written by Jim Connelley.  No copyright.        *\n * Ifyawanna, (If you want to) send your enhancements to      *\n *                                                            *\n * Updated: 2005 -- Ted MacNEIL. Same disclaimer.             *\n *               -- I needed a method to clean up our old     *\n *                  VSAM with the keywords: REPLICATE, IMBED  *\n *                  and KEYRANGE. This was the fastest way.   *\n *                  Those parameters are caught but not       *\n *                  written to control cards.                 *\n *                  I also added a few lines to do a:         *\n *                  DELETE ------ PURGE at the front          *\n *                                                            *\n * There are bugs, such as handling multi-volume files, but   *\n * that's where YOU come in.                                  *\n * (-- Ted MacNEIL -- I believe I fixed this bug, but I did   *\n *  --             -- not have any multi-volumes to test with)*\n *                                                            *\n * (-- The dependency on STEMVIEW was removed to either write *\n *  -- out to a file or say inside a loop)                    *\n *                                                            *\n * CBTTAPE FILE 493                                           *\n *                                                            *\n *------------------------------------------------------------*\n * %VC3 VSAMDSN pds member                                    *\n *                                                            *\n *   VSAMDSN -- the VSAM FILE you wish to CLONE               *\n *              (if you specify quotes, they are removed)     *\n *                                                            *\n *   pds     -- where to output the control cards             *\n *            - default: <userid>.VSAM.CONTROL.CARDS          *\n *                                                            *\n *   member  -- the member name used to output the statements *\n *                                                            *\n *                                                            *\n *   NOTE: if PDS does not exist, this outputs to the screen  *\n *                                                            *\n *------------------------------------------------------------*\n */\ntrace\nparse arg data_set_name dsname member\n  indent = copies(' ',5)\n  address \"TSO\"\n  call init_variables\n  call execute_listcat\n  call process_listcat\n  call addkey \")\"        /* add closing paren */\n  out_line.0 = x         /* set total linecount */\n  call output_results\nexit 0\n\n/*------------------------------------------------------------*\n *                                                            *\n * process_listcat drives the processing of the LISTCAT       *\n * output.                                                    *\n *                                                            *\n *------------------------------------------------------------*\n */\nprocess_listcat:\ndo i = 1 to trap_line.0\n  parse var trap_line.i field1 the_rest\n  select\n    When field1 = 'NONVSAM' Then Do\n        say\n        say member || \":\" data_set_name \"NONVSAM (Possibly Migrated)\"\n        say\n        Exit 4\n        end\n    When field1 = 'CLUSTER' Then Do\n      big_state = 'CLUSTER'\n      Parse Var the_rest . object_name\n      x = 1\n      out_line.x = indent \"DEFINE CLUSTER (\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || object_name || \")\"\n      indent = copies(' ',10)\n      Call addkey \"INDEXED\"          /* KLUDGE default LINE 7 */\n      Call addkey \"SHAREOPTION(2 1)\" /* KLUDGE default LINE 8 */\n      End\n    When field1 = 'DATA' Then Do\n      big_state = 'DATA'\n      Parse Var the_rest . data_name\n      indent = copies(' ',5)\n      Call addkey \")\"\n      indent = copies(' ',1)\n      Call addkey \"DATA(\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || data_name || \")\"\n      volstate = \"VOLUMENOTDONE\"\n      indent = copies(' ',10)\n      End\n    When field1 = 'INDEX' Then Do\n      big_state = 'INDEX'\n      Parse Var the_rest . index_name\n      indent = copies(' ',5)\n      Call addkey \")\"\n      indent = copies(' ',1)\n      Call addkey \"INDEX(\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || index_name || \")\"\n      volstate = \"VOLUMENOTDONE\"\n      indent = copies(' ',10)\n      End\n    When field1 = 'HISTORY' Then Do\n      state = 'HISTORY'\n      End\n    When field1 = 'SMSDATA' Then Do\n      state = 'SMSDATA'\n      End\n    When field1 = 'RLSDATA' Then Do\n      state = 'RLSDATA'\n      End\n    When field1 = 'ASSOCIATIONS' Then Do\n      state = 'ASSOCIATIONS'\n      End\n    When field1 = 'ATTRIBUTES' Then Do\n      state = 'ATTRIBUTES'\n      End\n    When field1 = 'STATISTICS' Then Do\n      state = 'STATISTICS'\n      End\n    When field1 = 'ALLOCATION' Then Do\n      state = 'ALLOCATION'\n      End\n    When field1 = 'VOLUME' Then Do\n      state = 'VOLUME'\n      End\n    Otherwise\n      Select\n        When state = 'SMSDATA' Then Do\n          Call do_smsdata\n          End\n        When state = 'ATTRIBUTES' Then Do\n          Call do_attributes\n          End\n        When state = 'ALLOCATION' Then Do\n          Call do_allocation\n          End\n        When state = 'VOLUME' Then Do\n          Call do_volume\n          End\n        Otherwise\n          Nop\n      End /* Select state */\n  End /* Select field1 */\nEnd\n\nReturn\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_smsdata processes the keywords found under the SMSDATA  *\n * section of output from listcat command.                    *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_smsdata:\n\n  keyval = getkey('STORAGECLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"STORAGECLASS(\" || keyval || \")\"\n\n  keyval = getkey('MANAGEMENTCLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"MANAGEMENTCLASS(\" || keyval || \")\"\n\n  keyval = getkey('DATACLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"DATACLASS(\" || keyval || \")\"\n\n  keyval = getkey('BWO----' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"BWO(\" || keyval || \")\"\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_volume processes the keywords and values found under    *\n * under the volume section of the LISTCAT command.           *\n * Currently, we are only interested in the VOLUME keyword.   *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_volume:\n\n  keyval = getkey('VOLSER' trap_line.i)\n  If keyval /= '' & volstate /= \"VOLUMEDONE\" then do\n    Call addkey \"VOLUMES(\" || keyval || \")\"\n    volstate = \"VOLUMEDONE\"\n    end\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_allocation processes the keywords and values found      *\n * under the allocation section of the LISTCAT command.       *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_allocation:\n\n  keyval = getkey('SPACE-TYPE' trap_line.i)\n  If keyval /= '' Then\n    space_type = keyval\n\n  keyval = getkey('SPACE-PRI' trap_line.i)\n  If keyval /= '' Then\n    space_pri = keyval\n\n  keyval = getkey('SPACE-SEC' trap_line.i)\n  If keyval /= '' Then\n    Call addkey space_type || \"(\" || space_pri keyval || \")\"\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes process the non-default data under the       *\n * ATTRIBUTES section of output from the LISTCAT command.     *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_attributes:\n\n  If big_state = 'DATA' Then\n    Call do_attributes_data\n\n  If big_state = 'INDEX' Then\n    Call do_attributes_index\n\n  keyval = getkey('BUFSPACE' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"BUFFERSPACE(\" || keyval || \")\"\n\n  keyval = getkey('EXCPEXIT' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"EXCEPTIONEXIT(\" || keyval || \")\"\n\n  keyval = getkey('CISIZE' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"CONTROLINTERVALSIZE(\" || keyval || \")\"\n\n  position = pos('SHROPTNS',trap_line.i)\n  /*\n   *********************************************************\n   * This kludge took a while to understand, but since the *\n   * outputted values from LISTCAT puts this in a different*\n   * place than required for IDCAMS, that is what this code*\n   * handles  -- 2005: --tm                                *\n   *********************************************************\n   */\n  If position /= 0 Then Do\n    position = position + length('SHROPTNS(')\n    keyval = substr(trap_line.i,position,3)\n    out_line.8 = indent \"SHAREOPTIONS(\" || keyval || \") -\"\n    End\n\n  Call findkey \"WRITECHECK\"\n  Call findkey \"REUSE\"\n\n  /*\n   *********************************************************\n   * This kludge took a while to understand, but since the *\n   * outputted values from LISTCAT puts this in a different*\n   * place than required for IDCAMS, that is what this code*\n   * handles  -- 2005: --tm                                *\n   *********************************************************\n   */\n  If wordpos(\"NONINDEXED\",trap_line.i) /= 0 then do\n       out_line.7 = indent \"NONINDEXED\"\n       end\n  If wordpos(\"NUMBERED\",trap_line.i) /= 0 then do\n       out_line.7 = indent \"NUMBERED\"\n       end\n  If wordpos(\"LINEAR\",trap_line.i) /= 0 then do\n       out_line.7 = indent \"LINEAR\"\n       end\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes_data processes those keywords that are       *\n * only valid for the data portion of a cluster.        .     *\n * Currently these are KEYS(), RECORDSIZE(), erase and speed. *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_attributes_data:\n\n  keyval = getkey('KEYLEN' trap_line.i)\n  If keyval /= '' Then\n    keylen = keyval\n\n  keyval = getkey('RKP' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"KEYS(\" || keylen keyval || \")\"\n\n  keyval = getkey('AVGLRECL' trap_line.i)\n  If keyval /= '' Then\n    avglrecl = keyval\n\n  keyval = getkey('MAXLRECL' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"RECORDSIZE(\" || avglrecl keyval || \")\"\n\n  Call findkey \"ERASE\"\n /*\n  Call findkey \"SPEED\"\n  */\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes_index processes those keywords that are      *\n * only valid for the index portion of a cluster.             *\n * Currently these are REPLICATE and INBED.                   *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_attributes_index:\n  Return\n  Call findkey \"REPLICATE\"\n  Call findkey \"IMBED\"\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * getkey function scans a passed string for a                *\n * specific keyword.  If the keyword is found, getkey         *\n * returns a value associated with the keyword.               *\n *                                                            *\n * getkey is oriented to that ugly listcat output such as:    *\n *     STORAGECLASS -----SCPRIM                               *\n * example:                                                   *\n *  getkey('STORAGECLASS','STORAGECLASS -----SCPRIM')         *\n *                                                            *\n * getkey will return SCPRIM                                  *\n *                                                            *\n *------------------------------------------------------------*\n */\ngetkey: procedure\n  Parse Arg keyword  str\n  ret_str = ''\n  position = pos(keyword,str)\n  If position /= 0 Then Do\n    len = length(keyword)\n    position = position + len\n    len = 24  - len\n    ret_str = strip(strip(substr(str,position,len)),,'-')\n    If ret_str = '(NULL)' Then ret_str = ''\n    End\n  Return ret_str\n\n/*------------------------------------------------------------*\n *                                                            *\n * findkey scans for a passed string and if it is found,      *\n * adds the same string to the DEFINE statement.              *\n *                                                            *\n *------------------------------------------------------------*\n */\nfindkey:\n  Parse Arg keyword\n  If wordpos(keyword,trap_line.i) /= 0 Then\n    Call addkey keyword\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * addkey procedure simply adds a passed value to the         *\n * DEFINE statement that we are building.                     *\n *                                                            *\n * Put a check here for keywords such as recordsize(0 0)      *\n *   Return if found, because IDCAMS rejects such values      *\n *     as being 'out of range'.                               *\n *                                                            *\n *------------------------------------------------------------*\n */\naddkey: procedure expose out_line. x indent\n  Parse Arg keyword\n  length_keyword = length(keyword)\n  If length_keyword > 3 Then\n    If substr(keyword,length_keyword-2,3) = '(0)' Then\n      Return\n  If length_keyword > 5 Then\n    If substr(keyword,length_keyword-4,5) = '(0 0)' Then\n      Return\n  out_line.x = out_line.x \"-\"\n  x = x + 1\n  out_line.x = indent keyword\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * execute_listcat calls listcat command and handles return.  *\n *                                                            *\n *------------------------------------------------------------*\n */\nexecute_listcat:\ndata_set_name = strip(data_set_name,,\"'\")\ny = outtrap('trap_line.')\n\"listcat entry('\" || data_set_name || \"') all\"\nIf RC /= 0 Then Do\n  say\n  say member || \": '\" || data_set_name || \"' Not found\"\n  say\n  Exit 4\n  End\ny = outtrap('off')\nIf DATATYPE(trap_line.0)  /= 'NUM' Then Do\n  say\n  say member || \": No specification for\" data_set_name\n  say\n  Exit 4\n  End\nReturn\n\n/*------------------------------------------------------------*\n *                                                            *\n * init_variables is coded promarily so we can add comments   *\n * about the variables used in this REXX.                     *\n *                                                            *\n *------------------------------------------------------------*\n */\ninit_variables:\nif sysvar(\"SYSISPF\")\u00ac=\"ACTIVE\" then do\n   say \"Usage: %VC3 <ENTRY> pds member\"\n   say \"-pds- & -member- are optional.\"\n   say \"MUST run under ISPF!\"\n   exit 8\n   end\n\ndrop trap_line.                        /* trapped from listcat */\ndrop out_line.                         /* output array */\ndrop state                             /* currently parsing this */\ndrop object_name                       /* cluster name */\ndrop data_name                         /* data name */\ndrop index_name                        /* index name */\nx = 0                                  /* current output line */\nindent = copies(' ',1)\nreturn\n\n/*------------------------------------------------------------*\n *                                                            *\n * Generate the next member -- VSAM####                       *\n *                                                            *\n *------------------------------------------------------------*\n */\n\ngencount:\n  dummy = msg(\"OFF\")\n  address \"TSO\" \"DELETE VSAM.MEMBERS\"\n  dummy = msg(\"ON\")\n\n  address \"ISPEXEC\"\n    \"LMINIT   DATAID(ID) DATASET(\" || dsname || \") ENQ(SHR)\"\n    \"LMOPEN DATAID(\" || id || \")\"\n    \"LMMLIST DATAID(\" || id || \") OPTION(SAVE) GROUP(VSAM)\",\n            \"STATS(NO) PATTERN(VSAM*)\"\n    \"LMCLOSE  DATAID(\" || id || \")\"\n    \"LMFREE   DATAID(\" || id || \")\"\n\n    /* Special Case: Empty CONTROL CARDS dataset */\n    dummy = msg(\"OFF\")\n    if sysdsn('VSAM.MEMBERS') \u00ac= \"OK\" then do\n       return VSAM0001\n       end\n    dummy = msg(\"ON\")\n\n    address \"TSO\"\n      drop control.\n       \"ALLOC F(INMEM) DA(VSAM.MEMBERS) SHR\"\n       \"EXECIO * DISKR INMEM (FINIS STEM CONTROL.\"\n       \"FREE F(INMEM)\"\n       dummy = msg(\"OFF\")\n       \"DELETE VSAM.MEMBERS\"\n       dummy = msg(\"ON\")\n       i = control.0\n       lastmem = control.i\n       lastmem = strip(lastmem,,\" \")\n       lastmem = substr(lastmem,5)\n       if \u00acdatatype(lastmem,\"NUM\") then num = \"0001\"\n       else                             num = lastmem+1\n       if length(num) = 1 then num = \"000\" || num\n       if length(num) = 2 then num =  \"00\" || num\n       if length(num) = 3 then num =   \"0\" || num\n   return \"VSAM\" || num\n/*------------------------------------------------------------*\n *                                                            *\n * Output any results and then exit this exec.                *\n *                                                            *\n *------------------------------------------------------------*\n */\noutput_results:\n\nif length(dsname) < 1 then dsname = \"VSAM.CONTROL.CARDS\"\nif sysdsn(dsname) = \"OK\" then do\n   if length(member) < 1 then member = gencount()\n   address \"TSO\"\n   dummy = msg(\"OFF\")\n   \"FREE FI(VSAMCNTL)\"\n   dummy = msg(\"ON\")\n   \"ALLOC FI(VSAMCNTL) REUSE OLD DA(\" || dsname || \"(\" || member || \")\"\n   \"EXECIO * DISKW VSAMCNTL (FINIS STEM OUT_LINE.\"\n   \"FREE F(VSAMCNTL)\"\n   end\nelse do\n    do i=1 to out_line.0\n        say out_line.i\n        end\n    end\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VCP": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x06\"/\\x01\\x06\"/\\x07T\\x02\\x14\\x02\\x14\\x00\\x00\\xd7\\xc8\\xe2\\xc9\\xd4\\xd6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-08-10T00:00:00", "modifydate": "2006-08-10T07:54:00", "lines": 532, "newlines": 532, "modlines": 0, "user": "PHSIMON"}, "text": "/*------------------- REXX -----------------------------------*\n *                                                            *\n * This code either displays a VSAM entry or writes the       *\n * IDCAMS control statement needed to define a VSAM file.     *\n * (MUST run under ISPF)                                      *\n *                                                            *\n * From ISPF 3.4, type VC next to a VSAM data set             *\n *                                                            *\n * Originally Written by Jim Connelley.  No copyright.        *\n * Ifyawanna, (If you want to) send your enhancements to      *\n *                                                            *\n * Updated: 2005 -- Ted MacNEIL. Same disclaimer.             *\n *               -- I needed a method to clean up our old     *\n *                  VSAM with the keywords: REPLICATE, IMBED  *\n *                  and KEYRANGE. This was the fastest way.   *\n *                  Those parameters are caught but not       *\n *                  written to control cards.                 *\n *                  I also added a few lines to do a:         *\n *                  DELETE ------ PURGE at the front          *\n *                                                            *\n * There are bugs, such as handling multi-volume files, but   *\n * that's where YOU come in.                                  *\n * (-- Ted MacNEIL -- I believe I fixed this bug, but I did   *\n *  --             -- not have any multi-volumes to test with)*\n *                                                            *\n * (-- The dependency on STEMVIEW was removed to either write *\n *  -- out to a file or say inside a loop)                    *\n *                                                            *\n * CBTTAPE FILE 493                                           *\n *                                                            *\n *------------------------------------------------------------*\n * %VC3 VSAMDSN pds member                                    *\n *                                                            *\n *   VSAMDSN -- the VSAM FILE you wish to CLONE               *\n *              (if you specify quotes, they are removed)     *\n *                                                            *\n *   pds     -- where to output the control cards             *\n *            - default: <userid>.VSAM.CONTROL.CARDS          *\n *                                                            *\n *   member  -- the member name used to output the statements *\n *                                                            *\n *                                                            *\n *   NOTE: if PDS does not exist, this outputs to the screen  *\n *                                                            *\n *------------------------------------------------------------*\n */\ntrace\nparse arg data_set_name dsname member\n  indent = copies(' ',5)\n  address \"TSO\"\n  call init_variables\n  call execute_listcat\n  call process_listcat\n  call addkey \")\"        /* add closing paren */\n  out_line.0 = x         /* set total linecount */\n  call output_results\nexit 0\n\n/*------------------------------------------------------------*\n *                                                            *\n * process_listcat drives the processing of the LISTCAT       *\n * output.                                                    *\n *                                                            *\n *------------------------------------------------------------*\n */\nprocess_listcat:\ndo i = 1 to trap_line.0\n  parse var trap_line.i field1 the_rest\n  select\n    When field1 = 'NONVSAM' Then Do\n        say\n        say member || \":\" data_set_name \"NONVSAM (Possibly Migrated)\"\n        say\n        Exit 4\n        end\n    When field1 = 'CLUSTER' Then Do\n      big_state = 'CLUSTER'\n      Parse Var the_rest . object_name\n      x = 1\n      out_line.x = indent \"DEFINE CLUSTER (\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || object_name || \")\"\n      indent = copies(' ',10)\n      Call addkey \"INDEXED\"          /* KLUDGE default LINE 7 */\n      ilineindex = x      /* keep the line number for INDEX line */\n      Call addkey \"SHAREOPTION(2 1)\" /* KLUDGE default LINE 8 */\n      ilineshare = x      /* keep the line number for SHARE line */\n      End\n    When field1 = 'DATA' Then Do\n      big_state = 'DATA'\n      Parse Var the_rest . data_name\n      indent = copies(' ',5)\n      Call addkey \")\"\n      indent = copies(' ',1)\n      Call addkey \"DATA(\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || data_name || \")\"\n      volstate = \"VOLUMENOTDONE\"\n      indent = copies(' ',10)\n      End\n    When field1 = 'INDEX' Then Do\n      big_state = 'INDEX'\n      Parse Var the_rest . index_name\n      indent = copies(' ',5)\n      Call addkey \")\"\n      indent = copies(' ',1)\n      Call addkey \"INDEX(\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || index_name || \")\"\n      volstate = \"VOLUMENOTDONE\"\n      indent = copies(' ',10)\n      End\n    When field1 = 'HISTORY' Then Do\n      state = 'HISTORY'\n      End\n    When field1 = 'SMSDATA' Then Do\n      state = 'SMSDATA'\n      End\n    When field1 = 'RLSDATA' Then Do\n      state = 'RLSDATA'\n      End\n    When field1 = 'ASSOCIATIONS' Then Do\n      state = 'ASSOCIATIONS'\n      End\n    When field1 = 'ATTRIBUTES' Then Do\n      state = 'ATTRIBUTES'\n      End\n    When field1 = 'STATISTICS' Then Do\n      state = 'STATISTICS'\n      End\n    When field1 = 'ALLOCATION' Then Do\n      state = 'ALLOCATION'\n      End\n    When field1 = 'VOLUME' Then Do\n      state = 'VOLUME'\n      End\n    Otherwise\n      Select\n        When state = 'SMSDATA' Then Do\n          Call do_smsdata\n          End\n        When state = 'ATTRIBUTES' Then Do\n          Call do_attributes\n          End\n        When state = 'ALLOCATION' Then Do\n          Call do_allocation\n          End\n        When state = 'VOLUME' Then Do\n          Call do_volume\n          End\n        Otherwise\n          Nop\n      End /* Select state */\n  End /* Select field1 */\nEnd\n\nReturn\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_smsdata processes the keywords found under the SMSDATA  *\n * section of output from listcat command.                    *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_smsdata:\n\n  keyval = getkey('STORAGECLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"STORAGECLASS(\" || keyval || \")\"\n\n  keyval = getkey('MANAGEMENTCLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"MANAGEMENTCLASS(\" || keyval || \")\"\n\n  keyval = getkey('DATACLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"DATACLASS(\" || keyval || \")\"\n\n  keyval = getkey('BWO----' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"BWO(\" || keyval || \")\"\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_volume processes the keywords and values found under    *\n * under the volume section of the LISTCAT command.           *\n * Currently, we are only interested in the VOLUME keyword.   *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_volume:\n\n  keyval = getkey('VOLSER' trap_line.i)\n  If keyval /= '' & volstate /= \"VOLUMEDONE\" then do\n    Call addkey \"VOLUMES(\" || keyval || \")\"\n    volstate = \"VOLUMEDONE\"\n    end\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_allocation processes the keywords and values found      *\n * under the allocation section of the LISTCAT command.       *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_allocation:\n\n  keyval = getkey('SPACE-TYPE' trap_line.i)\n  If keyval /= '' Then\n    space_type = keyval\n\n  keyval = getkey('SPACE-PRI' trap_line.i)\n  If keyval /= '' Then\n    space_pri = keyval\n\n  keyval = getkey('SPACE-SEC' trap_line.i)\n  If keyval /= '' Then\n    Call addkey space_type || \"(\" || space_pri keyval || \")\"\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes process the non-default data under the       *\n * ATTRIBUTES section of output from the LISTCAT command.     *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_attributes:\n\n  If big_state = 'DATA' Then\n    Call do_attributes_data\n\n  If big_state = 'INDEX' Then\n    Call do_attributes_index\n\n  keyval = getkey('BUFSPACE' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"BUFFERSPACE(\" || keyval || \")\"\n\n  keyval = getkey('EXCPEXIT' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"EXCEPTIONEXIT(\" || keyval || \")\"\n\n  keyval = getkey('CISIZE' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"CONTROLINTERVALSIZE(\" || keyval || \")\"\n\n  position = pos('SHROPTNS',trap_line.i)\n  /*\n   *********************************************************\n   * This kludge took a while to understand, but since the *\n   * outputted values from LISTCAT puts this in a different*\n   * place than required for IDCAMS, that is what this code*\n   * handles  -- 2005: --tm                                *\n   *********************************************************\n   */\n  If position /= 0 Then Do\n    position = position + length('SHROPTNS(')\n    keyval = substr(trap_line.i,position,3)\n    out_line.ilineshare = indent \"SHAREOPTIONS(\" || keyval || \") -\"\n    End\n\n  Call findkey \"WRITECHECK\"\n  Call findkey \"REUSE\"\n\n  /*\n   *********************************************************\n   * This kludge took a while to understand, but since the *\n   * outputted values from LISTCAT puts this in a different*\n   * place than required for IDCAMS, that is what this code*\n   * handles  -- 2005: --tm                                *\n   *********************************************************\n   */\n  If wordpos(\"NONINDEXED\",trap_line.i) /= 0 then do\n       out_line.ilineindex = indent \"NONINDEXED\"\n       end\n  If wordpos(\"NUMBERED\",trap_line.i) /= 0 then do\n       out_line.ilineindex = indent \"NUMBERED\"\n       end\n  If wordpos(\"LINEAR\",trap_line.i) /= 0 then do\n       out_line.ilineindex = indent \"LINEAR\"\n       end\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes_data processes those keywords that are       *\n * only valid for the data portion of a cluster.        .     *\n * Currently these are KEYS(), RECORDSIZE(), erase and speed. *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_attributes_data:\n\n  keyval = getkey('KEYLEN' trap_line.i)\n  If keyval /= '' Then\n    keylen = keyval\n\n  keyval = getkey('RKP' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"KEYS(\" || keylen keyval || \")\"\n\n  keyval = getkey('AVGLRECL' trap_line.i)\n  If keyval /= '' Then\n    avglrecl = keyval\n\n  keyval = getkey('MAXLRECL' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"RECORDSIZE(\" || avglrecl keyval || \")\"\n\n  Call findkey \"ERASE\"\n /*\n  Call findkey \"SPEED\"\n  */\n\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes_index processes those keywords that are      *\n * only valid for the index portion of a cluster.             *\n * Currently these are REPLICATE and INBED.                   *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_attributes_index:\n  Return\n  Call findkey \"REPLICATE\"\n  Call findkey \"IMBED\"\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * getkey function scans a passed string for a                *\n * specific keyword.  If the keyword is found, getkey         *\n * returns a value associated with the keyword.               *\n *                                                            *\n * getkey is oriented to that ugly listcat output such as:    *\n *     STORAGECLASS -----SCPRIM                               *\n * example:                                                   *\n *  getkey('STORAGECLASS','STORAGECLASS -----SCPRIM')         *\n *                                                            *\n * getkey will return SCPRIM                                  *\n *                                                            *\n *------------------------------------------------------------*\n */\ngetkey: procedure\n  Parse Arg keyword  str\n  ret_str = ''\n  position = pos(keyword,str)\n  If position /= 0 Then Do\n    len = length(keyword)\n    position = position + len\n    len = 24  - len\n    ret_str = strip(strip(substr(str,position,len)),,'-')\n    If ret_str = '(NULL)' Then ret_str = ''\n    End\n  Return ret_str\n\n/*------------------------------------------------------------*\n *                                                            *\n * findkey scans for a passed string and if it is found,      *\n * adds the same string to the DEFINE statement.              *\n *                                                            *\n *------------------------------------------------------------*\n */\nfindkey:\n  Parse Arg keyword\n  If wordpos(keyword,trap_line.i) /= 0 Then\n    Call addkey keyword\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * addkey procedure simply adds a passed value to the         *\n * DEFINE statement that we are building.                     *\n *                                                            *\n * Put a check here for keywords such as recordsize(0 0)      *\n *   Return if found, because IDCAMS rejects such values      *\n *     as being 'out of range'.                               *\n *                                                            *\n *------------------------------------------------------------*\n */\naddkey: procedure expose out_line. x indent\n  Parse Arg keyword\n  length_keyword = length(keyword)\n  If length_keyword > 3 Then\n    If substr(keyword,length_keyword-2,3) = '(0)' Then\n      Return\n  If length_keyword > 5 Then\n    If substr(keyword,length_keyword-4,5) = '(0 0)' Then\n      Return\n  out_line.x = out_line.x \"-\"\n  x = x + 1\n  out_line.x = indent keyword\n  Return\n\n/*------------------------------------------------------------*\n *                                                            *\n * execute_listcat calls listcat command and handles return.  *\n *                                                            *\n *------------------------------------------------------------*\n */\nexecute_listcat:\ndata_set_name = strip(data_set_name,,\"'\")\ny = outtrap('trap_line.')\n\"listcat entry('\" || data_set_name || \"') all\"\nIf RC /= 0 Then Do\n  say\n  say member || \": '\" || data_set_name || \"' Not found\"\n  say\n  Exit 4\n  End\ny = outtrap('off')\nIf DATATYPE(trap_line.0)  /= 'NUM' Then Do\n  say\n  say member || \": No specification for\" data_set_name\n  say\n  Exit 4\n  End\nReturn\n\n/*------------------------------------------------------------*\n *                                                            *\n * init_variables is coded promarily so we can add comments   *\n * about the variables used in this REXX.                     *\n *                                                            *\n *------------------------------------------------------------*\n */\ninit_variables:\nif sysvar(\"SYSISPF\")\u00ac=\"ACTIVE\" then do\n   say \"Usage: %VC3 <ENTRY> pds member\"\n   say \"-pds- & -member- are optional.\"\n   say \"MUST run under ISPF!\"\n   exit 8\n   end\n\ndrop trap_line.                        /* trapped from listcat */\ndrop out_line.                         /* output array */\ndrop state                             /* currently parsing this */\ndrop object_name                       /* cluster name */\ndrop data_name                         /* data name */\ndrop index_name                        /* index name */\nx = 0                                  /* current output line */\nindent = copies(' ',1)\nreturn\n\n/*------------------------------------------------------------*\n *                                                            *\n * Generate the next member -- VSAM####                       *\n *                                                            *\n *------------------------------------------------------------*\n */\n\ngencount:\n  dummy = msg(\"OFF\")\n  address \"TSO\" \"DELETE VSAM.MEMBERS\"\n  dummy = msg(\"ON\")\n\n  address \"ISPEXEC\"\n    \"LMINIT   DATAID(ID) DATASET(\" || dsname || \") ENQ(SHR)\"\n    \"LMOPEN DATAID(\" || id || \")\"\n    \"LMMLIST DATAID(\" || id || \") OPTION(SAVE) GROUP(VSAM)\",\n            \"STATS(NO) PATTERN(VSAM*)\"\n    \"LMCLOSE  DATAID(\" || id || \")\"\n    \"LMFREE   DATAID(\" || id || \")\"\n\n    /* Special Case: Empty CONTROL CARDS dataset */\n    dummy = msg(\"OFF\")\n    if sysdsn('VSAM.MEMBERS') \u00ac= \"OK\" then do\n       return VSAM0001\n       end\n    dummy = msg(\"ON\")\n\n    address \"TSO\"\n      drop control.\n       \"ALLOC F(INMEM) DA(VSAM.MEMBERS) SHR\"\n       \"EXECIO * DISKR INMEM (FINIS STEM CONTROL.\"\n       \"FREE F(INMEM)\"\n       dummy = msg(\"OFF\")\n       \"DELETE VSAM.MEMBERS\"\n       dummy = msg(\"ON\")\n       i = control.0\n       lastmem = control.i\n       lastmem = strip(lastmem,,\" \")\n       lastmem = substr(lastmem,5)\n       if \u00acdatatype(lastmem,\"NUM\") then num = \"0001\"\n       else                             num = lastmem+1\n       if length(num) = 1 then num = \"000\" || num\n       if length(num) = 2 then num =  \"00\" || num\n       if length(num) = 3 then num =   \"0\" || num\n   return \"VSAM\" || num\n/*------------------------------------------------------------*\n *                                                            *\n * Output any results and then exit this exec.                *\n *                                                            *\n *------------------------------------------------------------*\n */\noutput_results:\n\nif length(dsname) < 1 then dsname = \"VSAM.CONTROL.CARDS\"\nif sysdsn(dsname) = \"OK\" then do\n   if length(member) < 1 then member = gencount()\n   address \"TSO\"\n   dummy = msg(\"OFF\")\n   \"FREE FI(VSAMCNTL)\"\n   dummy = msg(\"ON\")\n   \"ALLOC FI(VSAMCNTL) REUSE OLD DA(\" || dsname || \"(\" || member || \")\"\n   \"EXECIO * DISKW VSAMCNTL (FINIS STEM OUT_LINE.\"\n   \"FREE F(VSAMCNTL)\"\n   end\nelse do\n    do i=1 to out_line.0\n        say out_line.i\n        end\n    end\nreturn\n\nVC.TXT\n\nContent-Description:\n\t3735249834-VC.TXT\nContent-Type:\n\ttext/plain\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VCP$$": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x06\"/\\x01\\x06\"/\\x07V\\x005\\x005\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-08-10T00:00:00", "modifydate": "2006-08-10T07:56:04", "lines": 53, "newlines": 53, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     CBT file 726, Generate VSAM Define Statements\nFrom:        Philippe Simon <philippe_simon_55@yahoo.fr>\nDate:        Wed, 19 Jul 2006 11:19:30 +0200 (CEST)\nTo:          sknutson@cbttape.org, sbgolob@cbttape.org,\n             tedmacneil@bell.blackberry.net\n\nHello Ted, Sam & Sam,\n\nThank you very much for your work for CBT !\n\nI have downloaded yesterday the File 726, which\ngenerates the define cluster cards for a VSAM file.\nTo do this, a REXX procedure was developped, whose\nname is VC.\n\nI have found some misfits in my environment, but they\nare all corrected by a simple way...which i had some\ndifficulties to find and understand !\n\nThe VC REXX suppose that the generated line \"INDEXED\"\nis the 7th and that the generated line \"SHAREOPTION\"\nis the 8th. (Lines code 84 and 85.\n\nLater in the routine, there are some lines with these\nhardcoded line numbers :\nline 264 : out_line.8 = xxxxxxx\nline 279, 282, 285 : out_line.7 = xxxxxxx\nwich overides the initial values.\n\nIn my environment, INDEXED line is 3, and SHAREOPTION\nline = 4 .... and this little difference makes big\neffects on the define cluster which is generated !\nAfter understanding this, it seems that the procedure\nworks well. I have change the procedure a little bit :\ni keep these two line number in two variables :\nilineindex and ilineshare.  (see line 85 and 87)\n\nAnd later in the code, i have replaced    out_line.7\nby out_line.ilineindex   and out_line.8 by\nout_line.ilineshare\n\nThese line numbers are no more hardcoded in the code !\n!\n\nYou can find the new code in the member VCP.\n\nExcuse my english, i speak english as if i were a\nfrench boy...\n\nThank you very much for your work !\nKindest regards,\nPhilippe\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VC3": {"ttr": 1026, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x04\\x00 \\x01\\x05)\\x7f\\x01\\x051O\\x12\\x00\\x02\\x89\\x02O\\x00\\x00\\xe3\\xc5\\xc4\\xd4\\xc1\\xc3@@@@'", "ispf": {"version": "03.04", "flags": 0, "createdate": "2005-10-24T00:00:00", "modifydate": "2005-11-10T12:00:20", "lines": 649, "newlines": 591, "modlines": 0, "user": "TEDMAC"}, "text": "/*------------------- REXX -----------------------------------*\n *                                                            *\n * This code either displays a VSAM entry or writes the       *\n * IDCAMS control statement needed to define a VSAM file.     *\n * (MUST run under ISPF)                                      *\n *                                                            *\n * From ISPF 3.4, type VC next to a VSAM data set             *\n *                                                            *\n * Originally Written by Jim Connelley.  No copyright.        *\n * Ifyawanna, (If you want to) send your enhancements to      *\n *                                                            *\n * Updated: 2005 -- Ted MacNEIL. Same disclaimer.             *\n *               -- I needed a method to clean up our old     *\n *                  VSAM with the keywords: REPLICATE, IMBED  *\n *                  and KEYRANGE. This was the fastest way.   *\n *                  Those parameters are caught but not       *\n *                  written to control cards.                 *\n *                  I also added a few lines to do a:         *\n *                  DELETE ------ PURGE at the front          *\n *                  (Optional)                                *\n *                                                            *\n * There are bugs, such as handling multi-volume files, but   *\n * that's where YOU come in.                                  *\n * (-- Ted MacNEIL -- I believe I fixed this bug, but I did   *\n *  --             -- not have any multi-volumes to test with)*\n *                                                            *\n * (-- The dependency on STEMVIEW was removed to either write *\n *  -- out to a file or say inside a loop)                    *\n *                                                            *\n * CBTTAPE FILE 493                                           *\n *                                                            *\n *------------------------------------------------------------*\n * %VC3 VSAMDSN pds member DELETE                             *\n *                                                            *\n *   VSAMDSN -- the VSAM FILE you wish to CLONE               *\n *              (if you specify quotes, they are removed)     *\n *                                                            *\n *   pds     -- where to output the control cards (Optional)  *\n *            - default: <userid>.VSAM.CONTROL.CARDS          *\n *                                                            *\n *   member  -- the member name used to output the statements *\n *              (Optional)                                    *\n *                                                            *\n *   DELETE  -- Insert DELETE <entry> PURGE                   *\n *           -- (Optional)                                    *\n *                                                            *\n * NOTE: 1. if PDS does not exist, this outputs to the screen *\n *                                                            *\n *       2. The only entry types supported are:               *\n *          ignored and only the DEFINE ALIAS ... RELATE      *\n *          will be output. There is not enough information in*\n *          the LISTCAT output to rebuild the catalogue       *\n *                                                            *\n *------------------------------------------------------------*\n */\ntrace \"O\"\nparse upper arg data_set_name dsname member delete\n  indent = copies(' ',5)\n  address \"TSO\"\n  call init_variables\n  call execute_listcat\n\n  call produce_delete    /* delete the entry first */\n  call process_listcat\n\n  if state \u00ac= 'USERCATALOG' then call addkey \")\" /* add close paren */\n  out_line.0 = x         /* set total linecount */\n  call output_results\nexit 0\n\n/*\n ************************************\n * All Routines (old & new) follow: *\n * (In alphabetical order)          *\n ************************************\n *\n *\n *------------------------------------------------------------*\n *                                                            *\n * addkey procedure simply adds a passed value to the         *\n * DEFINE statement that we are building.                     *\n *                                                            *\n * Put a check here for keywords such as recordsize(0 0)      *\n *   Return if found, because IDCAMS rejects such values      *\n *     as being 'out of range'.                               *\n *                                                            *\n *------------------------------------------------------------*\n */\naddkey: procedure expose out_line. x indent\n  Parse Arg keyword\n  length_keyword = length(keyword)\n  If length_keyword > 3 Then\n    If substr(keyword,length_keyword-2,3) = '(0)' Then\n      Return\n  If length_keyword > 5 Then\n    If substr(keyword,length_keyword-4,5) = '(0 0)' Then\n      Return\n  out_line.x = out_line.x \"-\"\n  x = x + 1\n  out_line.x = indent keyword\nreturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_alias puts out the define alias kewords                 *\n * there is not enough information in the LISTCAT output to   *\n * redefine the USERCATALOG(ue)                               *\n * Dummy routine                                              *\n *------------------------------------------------------------*\n */\ndo_alias:\nparse upper arg alias\n  x = x + 1\n  start_piece = indent \"DEFINE ALIAS(NAME(\" || alias || \")\"\n  out_line.x = start_piece\n\n  end_piece = \"RELATE(\" || data_set_name || \"))\"\n  if length(start_piece end_piece) > 71 then do\n     out_line.x = out_line.x \"-\"\n     x = x+1\n     out_line.x = indent \"  \" end_piece\n     end\n  else out_line.x = out_line.x end_piece\nreturn\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_allocation processes the keywords and values found      *\n * under the allocation section of the LISTCAT command.       *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_allocation:\n  keyval = getkey('SPACE-TYPE' trap_line.i)\n  If keyval /= '' Then\n    space_type = keyval\n\n  keyval = getkey('SPACE-PRI' trap_line.i)\n  If keyval /= '' Then\n    space_pri = keyval\n\n  keyval = getkey('SPACE-SEC' trap_line.i)\n  If keyval /= '' Then\n    Call addkey space_type || \"(\" || space_pri keyval || \")\"\nReturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes process the non-default data under the       *\n * ATTRIBUTES section of output from the LISTCAT command.     *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_attributes:\n  If big_state = 'DATA' Then\n    Call do_attributes_data\n\n  If big_state = 'INDEX' Then\n    Call do_attributes_index\n\n  keyval = getkey('BUFSPACE' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"BUFFERSPACE(\" || keyval || \")\"\n\n  keyval = getkey('EXCPEXIT' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"EXCEPTIONEXIT(\" || keyval || \")\"\n\n  keyval = getkey('CISIZE' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"CONTROLINTERVALSIZE(\" || keyval || \")\"\n\n  position = pos('SHROPTNS',trap_line.i)\n  /*\n   *********************************************************\n   * This kludge took a while to understand, but since the *\n   * outputted values from LISTCAT puts this in a different*\n   * place than required for IDCAMS, that is what this code*\n   * handles  -- 2005: --tm                                *\n   *********************************************************\n   */\n  If position /= 0 Then Do\n    position = position + length('SHROPTNS(')\n    keyval = substr(trap_line.i,position,3)\n\n    kludge_pos = 4\n    if delete = \"DELETE\" then kludge_pos = 8\n\n    out_line.kludge_pos = indent \"SHAREOPTIONS(\" || keyval || \") -\"\n    End\n\n  Call findkey \"WRITECHECK\"\n  Call findkey \"REUSE\"\n\n  /*\n   *********************************************************\n   * This kludge took a while to understand, but since the *\n   * outputted values from LISTCAT puts this in a different*\n   * place than required for IDCAMS, that is what this code*\n   * handles  -- 2005: --tm                                *\n   *********************************************************\n   */\n  kludge_pos = 3\n  if delete = \"DELETE\" then kludge_pos = 7\n\n  If wordpos(\"NONINDEXED\",trap_line.i) /= 0 then do\n       out_line.kludge_pos = indent \"NONINDEXED -\"\n       end\n  If wordpos(\"NUMBERED\",trap_line.i) /= 0 then do\n       out_line.kludge_pos = indent \"NUMBERED -\"\n       end\n  If wordpos(\"LINEAR\",trap_line.i) /= 0 then do\n       out_line.kludge_pos = indent \"LINEAR -\"\n       end\nReturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes_data processes those keywords that are       *\n * only valid for the data portion of a cluster.        .     *\n * Currently these are KEYS(), RECORDSIZE(), erase and speed. *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_attributes_data:\n  keyval = getkey('KEYLEN' trap_line.i)\n  If keyval /= '' Then\n    keylen = keyval\n\n  keyval = getkey('RKP' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"KEYS(\" || keylen keyval || \")\"\n\n  keyval = getkey('AVGLRECL' trap_line.i)\n  If keyval /= '' Then\n    avglrecl = keyval\n\n  keyval = getkey('MAXLRECL' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"RECORDSIZE(\" || avglrecl keyval || \")\"\n\n  Call findkey \"ERASE\"\nReturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_attributes_index processes those keywords that are      *\n * only valid for the index portion of a cluster.             *\n * Currently these are REPLICATE and IMBED.                   *\n * (DUMMY Routine -- 2005: --tm (Not supported anymore)       *\n *------------------------------------------------------------*\n */\ndo_attributes_index:\n  Return\n  Call findkey \"REPLICATE\"\n  Call findkey \"IMBED\"\n  Return\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_smsdata processes the keywords found under the SMSDATA  *\n * section of output from listcat command.                    *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_smsdata:\n  keyval = getkey('STORAGECLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"STORAGECLASS(\" || keyval || \")\"\n\n  keyval = getkey('MANAGEMENTCLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"MANAGEMENTCLASS(\" || keyval || \")\"\n\n  keyval = getkey('DATACLASS' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"DATACLASS(\" || keyval || \")\"\n\n  keyval = getkey('BWO----' trap_line.i)\n  If keyval /= '' Then\n    Call addkey \"BWO(\" || keyval || \")\"\nReturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * do_volume processes the keywords and values found under    *\n * under the volume section of the LISTCAT command.           *\n * Currently, we are only interested in the VOLUME keyword.   *\n *                                                            *\n *------------------------------------------------------------*\n */\ndo_volume:\n  keyval = getkey('VOLSER' trap_line.i)\n  If keyval /= '' & volstate /= \"VOLUMEDONE\" then do\n    Call addkey \"VOLUMES(\" || keyval || \")\"\n    volstate = \"VOLUMEDONE\"\n    end\nReturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * execute_listcat calls listcat command and handles return.  *\n *                                                            *\n *------------------------------------------------------------*\n */\nexecute_listcat:\ndata_set_name = strip(data_set_name,,\"'\")\ny = outtrap('trap_line.')\n\"listcat entry('\" || data_set_name || \"') all\"\nIf RC /= 0 Then Do\n  say\n  say member || \": '\" || data_set_name || \"' Not found\"\n  say\n  Exit 4\n  End\ny = outtrap('off')\nIf DATATYPE(trap_line.0)  /= 'NUM' Then Do\n  say\n  say member || \": No specification for\" data_set_name\n  say\n  Exit 4\n  End\nReturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * findkey scans for a passed string and if it is found,      *\n * adds the same string to the DEFINE statement.              *\n *                                                            *\n *------------------------------------------------------------*\n */\nfindkey:\n  Parse Arg keyword\n  If wordpos(keyword,trap_line.i) /= 0 Then\n    Call addkey keyword\nReturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * Generate the next member -- VSAM####                       *\n *                                                            *\n *------------------------------------------------------------*\n */\ngencount:\n  dummy = msg(\"OFF\")\n  address \"TSO\" \"DELETE VSAM.MEMBERS\"\n  dummy = msg(\"ON\")\n\n  address \"ISPEXEC\"\n    \"LMINIT   DATAID(ID) DATASET(\" || dsname || \") ENQ(SHR)\"\n    \"LMOPEN DATAID(\" || id || \")\"\n    \"LMMLIST DATAID(\" || id || \") OPTION(SAVE) GROUP(VSAM)\",\n            \"STATS(NO) PATTERN(VSAM*)\"\n    \"LMCLOSE  DATAID(\" || id || \")\"\n    \"LMFREE   DATAID(\" || id || \")\"\n\n    /* Special Case: Empty CONTROL CARDS dataset */\n    dummy = msg(\"OFF\")\n    if sysdsn('VSAM.MEMBERS') \u00ac= \"OK\" then do\n       return VSAM0001\n       end\n    dummy = msg(\"ON\")\n\n    address \"TSO\"\n      drop control.\n       \"ALLOC F(INMEM) DA(VSAM.MEMBERS) SHR\"\n       \"EXECIO * DISKR INMEM (FINIS STEM CONTROL.\"\n       \"FREE F(INMEM)\"\n       dummy = msg(\"OFF\")\n       \"DELETE VSAM.MEMBERS\"\n       dummy = msg(\"ON\")\n       i = control.0\n       lastmem = control.i\n       lastmem = strip(lastmem,,\" \")\n       lastmem = substr(lastmem,5,4)\n       if \u00acdatatype(lastmem,\"NUM\") then num = \"0001\"\n       else                             num = lastmem+1\n       if length(num) = 1 then num = \"000\" || num\n       if length(num) = 2 then num =  \"00\" || num\n       if length(num) = 3 then num =   \"0\" || num\n   return \"VSAM\" || num\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * getkey function scans a passed string for a                *\n * specific keyword.  If the keyword is found, getkey         *\n * returns a value associated with the keyword.               *\n *                                                            *\n * getkey is oriented to that ugly listcat output such as:    *\n *     STORAGECLASS -----SCPRIM                               *\n * example:                                                   *\n *  getkey('STORAGECLASS','STORAGECLASS -----SCPRIM')         *\n *                                                            *\n * getkey will return SCPRIM                                  *\n *                                                            *\n *------------------------------------------------------------*\n */\ngetkey: procedure\n  Parse Arg keyword  str\n  ret_str = ''\n  position = pos(keyword,str)\n  If position /= 0 Then Do\n    len = length(keyword)\n    position = position + len\n    len = 24  - len\n    ret_str = strip(strip(substr(str,position,len)),,'-')\n    If ret_str = '(NULL)' Then ret_str = ''\n    End\nReturn ret_str\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * init_variables is coded promarily so we can add comments   *\n * about the variables used in this REXX.                     *\n *                                                            *\n *------------------------------------------------------------*\n */\ninit_variables:\nif sysvar(\"SYSISPF\")\u00ac=\"ACTIVE\" then call usage\n\ncall parse_parameter    /* What are we to do? */\n\ndrop trap_line.                        /* trapped from listcat */\ndrop out_line.                         /* output array */\ndrop state                             /* currently parsing this */\ndrop object_name                       /* cluster name */\ndrop data_name                         /* data name */\ndrop index_name                        /* index name */\nx = 0                                  /* current output line */\nindent = copies(' ',1)\nreturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * Output any results and then exit this exec.                *\n *                                                            *\n *------------------------------------------------------------*\n */\noutput_results:\nif sysdsn(dsname) = \"OK\" then do\n   if length(member) < 1 then member = gencount()\n   address \"TSO\"\n   dummy = msg(\"OFF\")\n   \"FREE FI(VSAMCNTL)\"\n   dummy = msg(\"ON\")\n   \"ALLOC FI(VSAMCNTL) REUSE OLD DA(\" || dsname || \"(\" || member || \")\"\n   \"EXECIO * DISKW VSAMCNTL (FINIS STEM OUT_LINE.\"\n   \"FREE F(VSAMCNTL)\"\n   end\nelse do\n    do i=start_pos to out_line.0\n        say out_line.i\n        end\n    end\nreturn\n\n\n/*\n *------------------------------------------------------------*\n * PARSE the arguments passed:                                *\n * data_set_name                                              *\n * dsname to put the control cards                            *\n * DELETE specified                                           *\n *------------------------------------------------------------*\n */\nparse_parameter:\n   if length(data_set_name) < 1 then call usage\n\n   if length(dsname) < 1 then dsname = \"VSAM.CONTROL.CARDS\"\n   if length(dsname) > 1 & abbrev(\"DELETE\",dsname) then do\n       dsname = \"VSAM.CONTROL.CARDS\"\n       delete = \"DELETE\"\n       end\n\n   if length(member) > 1 & abbrev(\"DELETE\",member) then do\n       member = \"\"\n       delete = \"DELETE\"\n       end\n\n   if length(delete) > 1 & abbrev(\"DELETE\",delete) then do\n       delete = \"DELETE\"\n       end\n   else delete = \"\"\nreturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * process_listcat drives the processing of the LISTCAT       *\n * output.                                                    *\n *                                                            *\n *------------------------------------------------------------*\n */\nprocess_listcat:\nfield_save = \"\"\ndo i = 1 to trap_line.0\n  parse var trap_line.i field1 the_rest\n\n  /* Dummy Code */\n  if state = 'USERCATALOG' then do       /* only do define alias */\n       the_rest = substr(field1,6)\n       field1 = substr(field1,1,5)\n       if field1 \u00ac= 'ALIAS' then iterate\n\n       the_rest = strip(the_rest,,\"-\")\n       the_rest = strip(the_rest,,\" \")\n       end\n\n  if field_save = \"\" then field_save = field1\n  select\n    When field1 = 'NONVSAM' Then Do\n        say\n        say member || \":\" data_set_name \"NONVSAM (Possibly Migrated)\"\n        say\n        Exit 4\n        end\n    When field1 = 'CLUSTER' Then Do\n      big_state = 'CLUSTER'\n      Parse Var the_rest . object_name\n      out_line.x = indent \"DEFINE CLUSTER (\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || object_name || \")\"\n      indent = copies(' ',10)\n      Call addkey \"INDEXED\"          /* KLUDGE default LINE 7 */\n      Call addkey \"SHAREOPTION(2 1)\" /* KLUDGE default LINE 8 */\n      End\n    When field1 = 'DATA' Then Do\n      big_state = 'DATA'\n      Parse Var the_rest . data_name\n      indent = copies(' ',5)\n      Call addkey \")\"\n      indent = copies(' ',1)\n      Call addkey \"DATA(\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || data_name || \")\"\n      volstate = \"VOLUMENOTDONE\"\n      indent = copies(' ',10)\n      End\n    When field1 = 'INDEX' Then Do\n      big_state = 'INDEX'\n      Parse Var the_rest . index_name\n      indent = copies(' ',5)\n      Call addkey \")\"\n      indent = copies(' ',1)\n      Call addkey \"INDEX(\"\n      indent = copies(' ',5)\n      Call addkey \"NAME(\" || index_name || \")\"\n      volstate = \"VOLUMENOTDONE\"\n      indent = copies(' ',10)\n      End\n    When field1 = 'HISTORY' Then Do\n      state = 'HISTORY'\n      End\n    When field1 = 'SMSDATA' Then Do\n      state = 'SMSDATA'\n      End\n    When field1 = 'RLSDATA' Then Do\n      state = 'RLSDATA'\n      End\n    When field1 = 'ASSOCIATIONS' Then Do\n      state = 'ASSOCIATIONS'\n      End\n    When field1 = 'ATTRIBUTES' Then Do\n      state = 'ATTRIBUTES'\n      End\n    When field1 = 'STATISTICS' Then Do\n      state = 'STATISTICS'\n      End\n    When field1 = 'ALLOCATION' Then Do\n      state = 'ALLOCATION'\n      End\n    When field1 = 'VOLUME' Then Do\n      state = 'VOLUME'\n      End\n    when field1 = 'USERCATALOG' then do\n      call unsupported('USERCATALOG')\n      state = 'USERCATALOG'\n      x = 0                     /* Reset the line so delete is gone */\n      end\n    Otherwise\n      Select\n        When state = 'SMSDATA' Then Do\n          Call do_smsdata\n          End\n        When state = 'ATTRIBUTES' Then Do\n          Call do_attributes\n          End\n        When state = 'ALLOCATION' Then Do\n          Call do_allocation\n          End\n        When state = 'VOLUME' Then Do\n          Call do_volume\n          End\n        When state = 'USERCATALOG' Then Do\n          Call do_alias(the_rest)\n          End\n        Otherwise call unsupported(field_save)\n      End /* Select state */\n  End /* Select field1 */\nEnd\nReturn\n\n\n/*------------------------------------------------------------*\n *                                                            *\n * produce delete creates a \"DELETE <entry> PURGE\" statement  *\n * as the first action for each cluster.                      *\n *------------------------------------------------------------*\n */\nproduce_delete:\n   start_pos = 1               /* If we write to the screen */\n   x = 1                       /* Are we going to put a delet out */\n   if delete = \"\" then return  /* No */\n\n   /* OR: Yes */\n      out_line.1 = indent \"DELETE -\"\n      out_line.2 = indent indent data_set_name \"-\"\n      out_line.3 = indent indent \"PURGE\"\n      out_line.4 = indent \"IF MAXCC < 9 THEN SET MAXCC = 0\"\n      x = 5\n      start_pos = 5               /* If we write to a PDS */\nreturn\n\n\nunsupported: procedure\nparse upper arg entry_type\n   zedsmsg = entry_type \"unsupported.\"\n   zedlmsg = \"Only LINEAR, NUMBERED, KSDS, RRDS are handled by %VC3\"\n   address \"ISPEXEC\" \"SETMSG MSG(ISRZ000)\"\n   exit 8\n\n\nusage: procedure\n   say \"Usage: %VC3 <ENTRY> pds member DELETE\"\n   say \"-pds-, -member-, & DELETE are optional.\"\n   say \"MUST run under ISPF!\"\n   exit 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT726/FILE726.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT726", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}