{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011846000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 470288, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE368.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 470288, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE368.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x08\\x10'", "DS1TRBAL": "b':\\xd6'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xac\\x00\\x04\\x02\\xac\\x00\\x0c\\x00\\t'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x15\\x00\\x00\\x00\\x99\\x13\\x7f\\x00\\x99'\\x9f\\x08W\\x00k\\x00\\x03\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@\"", "ispf": {"version": "01.21", "flags": 0, "createdate": "1999-05-17T00:00:00", "modifydate": "1999-10-06T08:57:00", "lines": 107, "newlines": 3, "modlines": 0, "user": "OPRJAW0"}, "text": "Sam, I will send you some other code when I have time. I thought this\nstuff might be helpful to some. Keep up good work\n\nAll REXX SMF stuff must be RECFM=VB instead of RECFM=VBS as REXX cannot\nhandle spanned records.\n\n//*      $$$DOC   - This member                                     *   FILE 368\n//*                                                                 *   FILE 368\n//*      AL       - Good when you are at 3.4 and need to            *   FILE 368\n//*                 duplicate a dataset                             *   FILE 368\n//*                                                                 *   FILE 368\n//*      COMMAND  - Added support for 4 digit reply id to           *   FILE 368\n//*                 program from File 019 issue 'FIND *JAW*' to     *   FILE 368\n//*                 see my changes.                                 *   FILE 368\n//*                                                                 *   FILE 368\n//*      COPYLNES - Great taking a dataset file and then create     *   FILE 368\n//*                 a record before each.  This is great for        *   FILE 368\n//*                 creating multi-line control cards               *   FILE 368\n//*                                                                 *   FILE 368\n//*      DMPGENER - This simple REXX takes a dataset list and       *   FILE 368\n//*                 generates control cards for DFDSS.  I use       *   FILE 368\n//*                 this same example to create JCL and other       *   FILE 368\n//*                 control card schemes.                           *   FILE 368\n//*                                                                 *   FILE 368\n//*      FTAILSMF - FTAILSMF is BAL program that shows the power    *   FILE 368\n//*                 of ISPF calls. You can easily manage datasets   *   FILE 368\n//*                 using ISPF calls which do the SVC 99 stuff      *   FILE 368\n//*                 under the doors. Also, a REXX version in there. *   FILE 368\n//*                                                                 *   FILE 368\n//*      IEFUJI   - IEFUJI exit to gets info from ACF2.  Probably   *   FILE 368\n//*                 would not take much to get from RACF or Top     *   FILE 368\n//*                 Secret also.  Also creates an SMF record        *   FILE 368\n//*                 (128) processed by SMF128J.                     *   FILE 368\n//*                                                                 *   FILE 368\n//*      JOBID    - Simple REXX to find JOBID                       *   FILE 368\n//*                                                                 *   FILE 368\n//*      MSGCHECK - Little REXX program to check MPF.  IEAVMXIT     *   FILE 368\n//*                 must be active for some AUTOOPS packages.       *   FILE 368\n//*                                                                 *   FILE 368\n//*      RDATE    - REXX date routine. Recently added some Y2K      *   FILE 368\n//*                 updates.  REXX date function has most of this   *   FILE 368\n//*                 support today.  Originally a CLIST from CBT,    *   FILE 368\n//*                 I believe, that I converted to REXX and         *   FILE 368\n//*                 updated.                                        *   FILE 368\n//*                                                                 *   FILE 368\n//*      RXJOBID  - Assembler REXX function sames as JOBID above.   *   FILE 368\n//*                 Shows how simple BAL REXX functions are.        *   FILE 368\n//*                                                                 *   FILE 368\n//*      SEQNUM   - Handy member.  I once had a job with a          *   FILE 368\n//*                 zillion steps all with the same name.  This     *   FILE 368\n//*                 edit macro made each step unique.               *   FILE 368\n//*                                                                 *   FILE 368\n//*      SMF128   - For poor shops without SAS, REXX is a great     *   FILE 368\n//*                 tool for quick SMF data reports for auditors    *   FILE 368\n//*                 or bean counters.                               *   FILE 368\n//*                                                                 *   FILE 368\n//*      SMF128J  - JCL to invoke SMF128 user SMF record from       *   FILE 368\n//*                 IEFUJI.                                         *   FILE 368\n//*                                                                 *   FILE 368\n//*      SMF170   - For poor shops without SAS, REXX is a great     *   FILE 368\n//*                 tool for quick SMF data reports for auditors    *   FILE 368\n//*                 or bean counters. SMF170 records from FILEAID   *   FILE 368\n//*                 require an AUTHSVC.                             *   FILE 368\n//*                                                                 *   FILE 368\n//*      SMF170J  - JCL to invoke SMF170 to report on               *   FILE 368\n//*                 FILEAID edits.                                  *   FILE 368\n//*                                                                 *   FILE 368\n//*      PCOPY    - This edit macro extends the power of the        *   FILE 368\n//*                 COPY command.  PCOPY can copy a PROC member     *   FILE 368\n//*                 without the intervening copy panel.  I need     *   FILE 368\n//*                 to expand this for non-pds's also.              *   FILE 368\n//*                                                                 *   FILE 368\n//*      COBPRT   - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes COBOL II date         *   FILE 368\n//*                 calls.  COBOL for MVS has some examples in      *   FILE 368\n//*                 the IVP.                                        *   FILE 368\n//*                                                                 *   FILE 368\n//*      PLIAVG   - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes PLI date calls at     *   FILE 368\n//*                 the 2.3 level.                                  *   FILE 368\n//*                                                                 *   FILE 368\n//*      STCK     - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes a STCK instruction.   *   FILE 368\n//*                                                                 *   FILE 368\n//*      TIMEPC   - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes a TIME PC call.       *   FILE 368\n//*                                                                 *   FILE 368\n//*      TIMEX    - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes a regular TIME        *   FILE 368\n//*                 call.                                           *   FILE 368\n//*                                                                 *   FILE 368\n//*      TOUPPERC - Xepditer will not handle lower case             *   FILE 368\n//*                 code as of 10-06-1999. Converts all text        *   FILE 368\n//*                 to uppercase prior to assembly.                 *   FILE 368\n//*                                                                 *   FILE 368\n//*      TOUPPERJ - Job to run invoke TOUPPERC against your         *   FILE 368\n//*                 PDS. It uses STARTOOL or PDS85 to invoke.       *   FILE 368\n//*                 Good control card examples.                     *   FILE 368\n//*                                                                 *   FILE 368\n//*      WTOAGL01 - Example of a TSO exit to start all VTAM         *   FILE 368\n//*                 appls at our site.  Would require a IST020I     *   FILE 368\n//*                 entry to start this exit in MPFLST00.  The      *   FILE 368\n//*                 last byte of each of our SMF ids is unique,     *   FILE 368\n//*                 such as SYSA, SYSB, or SYSC.  It grabs the      *   FILE 368\n//*                 character, as we have unique requirements for   *   FILE 368\n//*                 each system.                                    *   FILE 368\n//*                                                                 *   FILE 368\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE368": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99(\\x0f!R\\x00v\\x008\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-10-07T21:52:00", "lines": 118, "newlines": 56, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 368 is from James Williams of Atlanta, Georgia, and       *   FILE 368\n//*           contains a collection of his tools and utilities.     *   FILE 368\n//*                                                                 *   FILE 368\n//*      email:  \"James Williams\" <jwilliam@aglresources.com>       *   FILE 368\n//*                                                                 *   FILE 368\n//*                 James Williams                                  *   FILE 368\n//*                 AGL Resources (Services) Co.                    *   FILE 368\n//*                 1219 Caroline Street                            *   FILE 368\n//*                 Atlanta, GA 30307                               *   FILE 368\n//*                 404-584-4112                                    *   FILE 368\n//*                                                                 *   FILE 368\n//*      Here is a short description of the contents of this        *   FILE 368\n//*      file:                                                      *   FILE 368\n//*                                                                 *   FILE 368\n//*      ALL REXX SMF STUFF MUST BE RECFM=VB INSTEAD OF             *   FILE 368\n//*      RECFM=VBS AS REXX CANNOT HANDLE SPANNED RECORDS.           *   FILE 368\n//*                                                                 *   FILE 368\n//*      $$$DOC   - This member                                     *   FILE 368\n//*                                                                 *   FILE 368\n//*      AL       - Good when you are at 3.4 and need to            *   FILE 368\n//*                 duplicate a dataset                             *   FILE 368\n//*                                                                 *   FILE 368\n//*      COMMAND  - Added support for 4 digit reply id to           *   FILE 368\n//*                 program from File 019 issue 'FIND *JAW*' to     *   FILE 368\n//*                 see my changes.                                 *   FILE 368\n//*                                                                 *   FILE 368\n//*      COPYLNES - Great taking a dataset file and then create     *   FILE 368\n//*                 a record before each.  This is great for        *   FILE 368\n//*                 creating multi-line control cards               *   FILE 368\n//*                                                                 *   FILE 368\n//*      DMPGENER - This simple REXX takes a dataset list and       *   FILE 368\n//*                 generates control cards for DFDSS.  I use       *   FILE 368\n//*                 this same example to create JCL and other       *   FILE 368\n//*                 control card schemes.                           *   FILE 368\n//*                                                                 *   FILE 368\n//*      FTAILSMF - FTAILSMF is BAL program that shows the power    *   FILE 368\n//*                 of ISPF calls. You can easily manage datasets   *   FILE 368\n//*                 using ISPF calls which do the SVC 99 stuff      *   FILE 368\n//*                 under the doors. Also, a REXX version in there. *   FILE 368\n//*                                                                 *   FILE 368\n//*      IEFUJI   - IEFUJI exit to gets info from ACF2.  Probably   *   FILE 368\n//*                 would not take much to get from RACF or Top     *   FILE 368\n//*                 Secret also.  Also creates an SMF record        *   FILE 368\n//*                 (128) processed by SMF128J.                     *   FILE 368\n//*                                                                 *   FILE 368\n//*      JOBID    - Simple REXX to find JOBID                       *   FILE 368\n//*                                                                 *   FILE 368\n//*      MSGCHECK - Little REXX program to check MPF.  IEAVMXIT     *   FILE 368\n//*                 must be active for some AUTOOPS packages.       *   FILE 368\n//*                                                                 *   FILE 368\n//*      RDATE    - REXX date routine. Recently added some Y2K      *   FILE 368\n//*                 updates.  REXX date function has most of this   *   FILE 368\n//*                 support today.  Originally a CLIST from CBT,    *   FILE 368\n//*                 I believe, that I converted to REXX and         *   FILE 368\n//*                 updated.                                        *   FILE 368\n//*                                                                 *   FILE 368\n//*      RXJOBID  - Assembler REXX function same as JOBID above.    *   FILE 368\n//*                 Shows how simple BAL REXX functions are.        *   FILE 368\n//*                                                                 *   FILE 368\n//*      SEQNUM   - Handy member.  I once had a job with a          *   FILE 368\n//*                 zillion steps all with the same name.  This     *   FILE 368\n//*                 edit macro made each step unique.               *   FILE 368\n//*                                                                 *   FILE 368\n//*      SMF128   - For poor shops without SAS, REXX is a great     *   FILE 368\n//*                 tool for quick SMF data reports for auditors    *   FILE 368\n//*                 or bean counters.                               *   FILE 368\n//*                                                                 *   FILE 368\n//*      SMF128J  - JCL to invoke SMF128 user SMF record from       *   FILE 368\n//*                 IEFUJI.                                         *   FILE 368\n//*                                                                 *   FILE 368\n//*      SMF170   - For poor shops without SAS, REXX is a great     *   FILE 368\n//*                 tool for quick SMF data reports for auditors    *   FILE 368\n//*                 or bean counters. SMF170 records from FILEAID   *   FILE 368\n//*                 require an AUTHSVC.                             *   FILE 368\n//*                                                                 *   FILE 368\n//*      SMF170J  - JCL to invoke SMF170 to report on               *   FILE 368\n//*                 FILEAID edits.                                  *   FILE 368\n//*                                                                 *   FILE 368\n//*      PCOPY    - This edit macro extends the power of the        *   FILE 368\n//*                 COPY command.  PCOPY can copy a PROC member     *   FILE 368\n//*                 without the intervening copy panel.  I need     *   FILE 368\n//*                 to expand this for non-pds's also.              *   FILE 368\n//*                                                                 *   FILE 368\n//*      COBPRT   - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes COBOL II date         *   FILE 368\n//*                 calls.  COBOL for MVS has some examples in      *   FILE 368\n//*                 the IVP.                                        *   FILE 368\n//*                                                                 *   FILE 368\n//*      PLIAVG   - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes PLI date calls at     *   FILE 368\n//*                 the 2.3 level.                                  *   FILE 368\n//*                                                                 *   FILE 368\n//*      STCK     - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes a STCK instruction.   *   FILE 368\n//*                                                                 *   FILE 368\n//*      TIMEPC   - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes a TIME PC call.       *   FILE 368\n//*                                                                 *   FILE 368\n//*      TIMEX    - Simple program to test our Y2K date             *   FILE 368\n//*                 simulator.  This executes a regular TIME        *   FILE 368\n//*                 call.                                           *   FILE 368\n//*                                                                 *   FILE 368\n//*      TOUPPERC - Xpediter will not handle lower case             *   FILE 368\n//*                 code as of 10-06-1999. Converts all text        *   FILE 368\n//*                 to uppercase prior to assembly.                 *   FILE 368\n//*                                                                 *   FILE 368\n//*      TOUPPERJ - Job to run invoke TOUPPERC against your         *   FILE 368\n//*                 PDS. It uses STARTOOL or PDS85 to invoke.       *   FILE 368\n//*                 Good control card examples.                     *   FILE 368\n//*                                                                 *   FILE 368\n//*      WTOAGL01 - Example of a TSO exit to start all VTAM         *   FILE 368\n//*                 appls at our site.  Would require a IST020I     *   FILE 368\n//*                 entry to start this exit in MPFLST00.  The      *   FILE 368\n//*                 last byte of each of our SMF ids is unique,     *   FILE 368\n//*                 such as SYSA, SYSB, or SYSC.  It grabs the      *   FILE 368\n//*                 character, as we have unique requirements for   *   FILE 368\n//*                 each system.                                    *   FILE 368\n//*                                                                 *   FILE 368\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AL": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\tB\\x00l\\x00l\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T09:42:00", "lines": 108, "newlines": 108, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/*    Name     - AL                                                   */\n/*    Author   - James A. Williams                                    */\n/*    Date     - 00/00/0000                                           */\n/*    Purpose  - allocate like datset at 3.4                          */\n/*    Invoke   - invoke as ISPF 3.4 line command                      */\n/*                                                                    */\n/**********************************************************************/\n\nAddress ISPEXEC\nArg dsname\nDsname = strip(dsname,b,\"'\")\nUid = sysvar(syspref)\nUid = translate(uid)\nQ = substr(time(),1,2)\nQ1 = substr(time(),4,2)\nQ2 = substr(date(u),7,2)\nMsgs = ls||q||q1||q2\nName =  dsname||.||msgs\n\nAlloc_main:\nX = outtrap('dsnver.')\nAddress tso \"Listc ent('\"dsname\"')\" all\nX = outtrap('off')\n\nDo I=1 to dsnver.0                  /* loop to find the variable  */\n  Tape = index(dsnver.i,'78048081')            /* 3490 */\n  If tape \\= 0 then\n     Do\n      Call Alloc_bad\n      Exit rcode\n     End\n  Tape = index(dsnver.i,'32008003')            /* 3420 */\n  If tape \\= 0  then\n     Do\n      Call Alloc_bad\n      Exit rcode\n     End\nEnd\nStatus = msg(off)\n'Control errors return'\nAddress tso \"allocate da('\"dsname\"') fi(list) shr reus\"\nDummy = Listdsi(list file)\nAddress tso \"free fi(list)\"\nStatus = msg(on)\n\nSelect\nwhen sysreason = 0  then\n    Do\n      Call Alloc_routine    /* nonvsam */\n      Exit rcode\n    End\nWhen sysreason = 12 then\n    Do\n      Call Alloc_routine    /* vsam */\n      Exit rcode\n    End\nOtherwise\n    Do\n      Call Alloc_bad    /* bad dataset*/\n      Rcode = 12\n    End\n\n\nAlloc_routine:\n\nSelect\nWhen sysreason = 0 then\n Do\n  Address tso \"Alloc Da('\"name\"') like('\"dsname\"')\"\n\n  If rc > 0\n   Then\n     Call Alloc_bad    /* member error */\n   Else\n     Call Alloc_cok\n End\n\nWhen sysreason = 12 then\n Do\n  Address tso \"Define Cluster(name('\"name\"') model('\"dsname\"'))\"\n\n  If rc > 0\n   Then\n     Call Alloc_bad    /* member error */\n   Else\n     Call Alloc_cok\n End\nOtherwise\n Nop\nEnd\n\nReturn\n\n\nAlloc_bad:\n    Zedlmsg = \"Encountered error allocating \"name\" from \"dsname\"\"\n    'SETMSG MSG(ISRZ001)'\n    Rcode=12\nReturn\n\nAlloc_cok:\n    Zedlmsg = \"\"name\" created sucessfully from \"dsname\"\"\n    'SETMSG MSG(ISRZ001)'\n    rcode=0\nReturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBPRT": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x18\\x0f\\x00\\x99\\x18\\x0f\\x07\\x18\\x002\\x00p\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-06-29T00:00:00", "modifydate": "1999-06-29T07:18:00", "lines": 50, "newlines": 112, "modlines": 0, "user": "OPRJAW0"}, "text": "//OPRJAW0I JOB (1543TSM),'COBPRT',CLASS=Z,MSGCLASS=R,\n//   NOTIFY=&SYSUID        ALL JOBS NEED ONE\n//*-------------------------------------------------------------------*\n//*    NOTE:  THIS COBOL CLG WAS WRITTEN BY JAMES WILLIAMS TO USE     *\n//*    AS A REPORT PREPROCESSOR.                                      *\n//*-------------------------------------------------------------------*\n//COB     EXEC COB2UCLG,PARM.COB2='OBJECT'\n//COB2.SYSIN DD *\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. HOSS.\n       AUTHOR. JAW.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER. IBM-370.\n       OBJECT-COMPUTER. IBM-370.\n       SPECIAL-NAMES.\n           C01 IS TOP-OF-FORM.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT PRINT-FILE ASSIGN TO S-SYSPRINT.\n       DATA DIVISION.\n       FILE SECTION.\n       FD  PRINT-FILE\n           LABEL RECORDS ARE OMITTED\n           DATA RECORD IS PRINT-RECORD\n           BLOCK CONTAINS 0 RECORDS.\n       01  PRINT-RECORD           PIC X(133).\n       WORKING-STORAGE SECTION.\n       01  DATEG-AREA.\n           02  IN-TIME            PIC X(8) VALUE SPACES.\n           02  IN-DATE            PIC X(6) VALUE SPACES.\n           02  IN-DAYX            PIC X(5) VALUE SPACES.\n       PROCEDURE DIVISION.\n       CONTROL-MODULE.\n           ACCEPT IN-DATE FROM DATE.\n           ACCEPT IN-DAYX FROM DAY.\n           ACCEPT IN-TIME FROM TIME.\n           DISPLAY IN-DAYX.\n           DISPLAY IN-DATE.\n           DISPLAY IN-TIME.\n           PERFORM HOUSEKEEPING.\n           PERFORM WIND-UP.\n           STOP RUN.\n       HOUSEKEEPING.\n           OPEN OUTPUT PRINT-FILE.\n       WIND-UP.\n           CLOSE PRINT-FILE.\n/*\n//GO.SYSPRINT DD SYSOUT=*\n//GO.SYSOUT   DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMMAND": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x99\\x13O\\x00\\x99\\x13\\x7f\\x114\\x04\\x0c\\x04\\x02\\x00\\x12\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf1@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1999-05-14T00:00:00", "modifydate": "1999-05-17T11:34:00", "lines": 1036, "newlines": 1026, "modlines": 18, "user": "OPRJAW1"}, "text": "COMMAND  TITLE 'PROGRAM TO ISSUE O/S COMMANDS FROM A DATASET'\n***********************************************************************\n*                                                                     *\n* STATUS - CHANGE LEVEL 1  JAW  05-17-1999 - PROVIDE SYSPLEX SUPPORT  *\n*                          ISSUE FIND '*JAW*' FOR CHANGES             *\n*                          C O M M A N D                              *\n*                                                                     *\n*        THIS PROGRAM WILL USE THE SVC 34 INTERFACE TO ISSUE O/S OR   *\n*        JES2 COMMANDS.                                               *\n*                                                                     *\n*        CALLERS OF THIS PROGRAM REQUIRE SPECIAL ACCESS               *\n*        AUTHORITY AS FOLLOWS:                                        *\n*                                                                     *\n*           THE USER MUST BE AUTHORIZED THROUGH A SPECIAL             *\n*           SECURITY CALL TO SAF FOR RESOURCE CLASS \"FACILITY\"        *\n*           AND ENTITY NAME \"COMMAND\".                                *\n*                                                                     *\n*                                                                     *\n*        WHAT MAKES THIS PROGRAM DIFFERENT FROM MOST PROGRAMS         *\n*        WHAT ISSUE COMMANDS ARE FOUR SPECIAL COMMANDS:               *\n*                                                                     *\n*        1)  DELAY=NNN - THIS COMMAND MAKES THE PROGRAM DELAY         *\n*            NNN SECONDS PRIOR TO ISSUING THE NEXT COMMAND IN         *\n*            THE LIST.                                                *\n*                                                                     *\n*        2)  REPLY JOBNAME MESSAGEID REPLYTEXT - THIS GIVES           *\n*            THE ABILITY TO REPLY TO OUTSTANDING REPLIES FOR          *\n*            SPECIFIED JOBS WITHOUT HAVING TO KNOW THE REPLY          *\n*            ID.                                                      *\n*                                                                     *\n*        3)  STARTED JOBNAME - THIS GIVES THE ABILITY TO WAIT         *\n*            FOR A SPECIFIC BATCH JOB OR STARTED TASK TO START        *\n*            OR TO INSURE THAT IT IS EXECUTING AT THE PRESENT         *\n*            TIME.                                                    *\n*                                                                     *\n*        4)  STOPPED JOBNAME - THIS GIVES THE ABILITY TO WAIT         *\n*            FOR A SPECIFIC BATCH JOB OR STARTED TASK TO END          *\n*            OR TO INSURE THAT IT IS NOT EXECUTING AT THE             *\n*            PRESENT TIME.                                            *\n*                                                                     *\n*        THE COMMANDS CAN COME FROM TWO INPUT SOURCES.  THE FIRST     *\n*        IS THE PARM VALUE ON THE EXECUTE CARD FOR THE STEP.  THE     *\n*        OTHER IS FROM THE INPUT DATA SET IEFRDER.  IF THE SOURCE     *\n*        IS THE PARM FIELD, MULTIPLE COMMANDS CAN BE ENTERED BY       *\n*        SEPARATING EACH COMMAND WITH A \";\".  IF THE SOURCE IS THE    *\n*        INPUT DATA SET, EACH RECORD WILL CONTAIN A SINGLE COMMAND    *\n*        STARTING IN COLUMN 1 THROUGH COLUMN 72 OF EACH RECORD.       *\n*        IF BOTH THE PARM AND INPUT DATASET ARE USED, THE COMMANDS    *\n*        IN THE PARM ARE EXECUTED FIRST.                              *\n*                                                                     *\n*        ONLY THE FIRST 72 CHARACTERS OF EACH COMMAND WILL BE USED    *\n*        WHEN ACTUALLY ISSUING THE COMMAND.                           *\n*                                                                     *\n*        COMMENTS CAN BE ENTERED WITH THE COMMANDS BY STARTING        *\n*        THE COMMAND WITH A '*'.  THIS CAUSES THE COMMAND TO BE       *\n*        BYPASSED.                                                    *\n*                                                                     *\n*        IF THE COMMAND IS \"DELAY=NNN\", THE PROGRAM WILL ENTER A      *\n*        WAIT FOR THE NUMBER OF SECONDS SPECIFIED BY \"NNN\".  IF       *\n*        MORE THAN A THREE DIGIT DELAY TIME IS SPECIFIED, ONLY        *\n*        THE FIRST THREE DIGITS WILL BE USED.                         *\n*                                                                     *\n*        IF THE COMMAND IS \"REPLY JOBNAME MESSAGEID REPLYTEXT\"        *\n*        THE PROGRAM WILL SEARCH FOR OUTSTANDING REPLIES FOR          *\n*        THE SPECIFIED JOBNAME AND CONTAINING THE OPTIONAL            *\n*        MESSAGE TEXT.                                                *\n*                                                                     *\n*        THE FULL JOBNAME MUST BE SPECIFIED.  THE USE IF THE          *\n*        MESSAGEID FIELD IS OPTIONAL.  IF MULTIPLE REPLIES MAY        *\n*        BE OUTSTANDING FOR THE JOB, THIS PARAMETER CAN BE USED       *\n*        TO SPECIFY A MESSAGEID OR CHARACER STRING CONTAINED IN       *\n*        THE MESSAGE.  IF NO MESSAGEID IS TO BE SPECIFIED, A          *\n*        '*' MUST BE SPECIFIED.  SINGLE QUOTES MAY BE USED IF         *\n*        THE STRING CONTAINS IMBEDDED BLANKS.                         *\n*                                                                     *\n*        THE REPLY TEXT MUST BE SPECIFIED.  SINGLE QUOTES MAY         *\n*        BE USED IF THE STRING CONTAINS IMBEDDED BLANKS.              *\n*                                                                     *\n*        IF THE COMMAND IS \"STOPPED JOBNAME\" THE PROGRAM WILL         *\n*        SEARCH ALL ACTIVE JOBS AND TASKS TO INSURE THAT THE          *\n*        SPECIFIED JOB OR TASK NAME IS NOT EXECUTING.  IF IT          *\n*        IS EXECUTING, A NON-ROLLABLE MESSAGE WILL BE SEND TO         *\n*        THE CONSOLE STATING THAT THE PROGRAM IS WAITING FOR          *\n*        THAT JOB TO STOP.  WHEN THE JOB OR TASK STOPS, THE           *\n*        MESSAGE WILL BE DELETED AND PROCESSING WILL CONTINUE.        *\n*                                                                     *\n*        IF THE COMMAND IS \"STARTED JOBNAME\" THE PROGRAM WILL         *\n*        SEARCH ALL ACTIVE JOBS AND TASKS TO INSURE THAT THE          *\n*        SPECIFIED JOB OR TASK NAME IS EXECUTING.  IF IT IS NOT       *\n*        EXECUTING, A NON-ROLLABLE MESSAGE WILL BE SEND TO THE        *\n*        CONSOLE STATING THAT THE PROGRAM IS WAITING FOR THAT         *\n*        JOB TO START.  WHEN THE JOB OR TASK STARTS, THE              *\n*        MESSAGE WILL BE DELETED AND PROCESSING WILL CONTINUE.        *\n*                                                                     *\n*                                                                     *\n*        BECAUSE THIS PROGRAM ISSUES THE MODESET MACRO AND USES       *\n*        CROSS MEMORY SERVICES, IT MUST BE APF AUTHORIZED TO DO       *\n*        SO.                                                          *\n*                                                                     *\n*        ESA VERSION 4 ALLOWS A REPLYID TO BE UP TO 4 CHARACTERS      *\n*        LONG.  THIS PROGRAM DOES NOT SUPPORT THIS.  IF THAT          *\n*        SUPPORT IS REQUIRED, THE REPLYID CAN BE EXTRACTED FROM       *\n*        THE BINARY REPLY ID IN FIELD WQERPYIB USING THE              *\n*        VERSION OF THE IHAWQE MACRO AND THE LENGTH OF THE            *\n*        REPLY IN THE COMMAND BUFFER CAN BE CHANGED.  SOME            *\n*        OTHER CHANGES WOULD LIKELY BE NEEDED FOR SYSPLEX AS          *\n*        WELL.   THIS CHANGE WAS NOT MADE TO KEEP COMPATIBILITY       *\n*        WITH ESA VERSION 3.                                          *\n*                                                                     *\n*                                                                     *\n*        WRITTEN BY:                                                  *\n*                   JOHN V. HOOPER                                    *\n*                   FOOD LION, INC.                                   *\n*                   2110 EXECUTIVE DRIVE                              *\n*                   SALISBURY, N.C.  28145-1330                       *\n*                                                                     *\n*                                                                     *\n*                           DISCLAIMER                                *\n*                                                                     *\n*      THE AUTHORS INCLUDING FOOD LION, ITS OFFICERS,                 *\n*      DIRECTORS, AND EMPLOYEES MAKE NO REPRESENTATION OR             *\n*      WARRANTY OF ANY KIND WHATSOEVER, INCLUDING, BUT NOT            *\n*      LIMITED TO, REPRESENTATIONS OR WARRANTIES, EXPRESS OR          *\n*      IMPLIED, OR MERCHANTABILITY, FITNESS FOR USE OR PURPOSE,       *\n*      ACCURACY OR COMPLETENESS OF PROCESSES, PROCEDURES,             *\n*      DESIGNS, DEFINITIONS, INSTRUCTIONS, INFORMATION, OR            *\n*      FUNCTIONING OF ANY PROGRAMS, DOCUMENTS, OR RELATED             *\n*      MATERIALS; THE AUTHORS FURTHER EXPRESSLY DISCLAIM ANY          *\n*      KNOWLEDGE OF PURPOSE FOR WHICH THESE PROGRAMS,                 *\n*      DOCUMENTS, OR RELATED MATERIAL MAY BE UTILIZED OR THEIR        *\n*      APPLICABILITY FOR SUCH USE, NOR SHALL THE FACT OF MAKING       *\n*      THEM AVAILABLE CONSTITUTE ANY SUCH REPRESENTATION,             *\n*      WARRANTY, OR KNOWLEDGE; NOR DO THE AUTHORS ASSUME ANY          *\n*      LIABILITY, RESPONSIBILITY, OR OBLIGATION ARISING FROM          *\n*      THE USE OR MALFUNCTIONING OF OF THESE COMPUTER PROGRAMS,       *\n*      DOCUMENTATION, OR RELATED MATERIALS.                           *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*                        SAMPLE JCL                                   *\n*                                                                     *\n*       //JOBNAME ...                                                 *\n*       //COMMAND  EXEC PGM=COMMAND,REGION=4M                         *\n*       //IEFRDER  DD  *                                              *\n*       D R,R                                                         *\n*       DELAY=10                                                      *\n*       STARTED CICS                                                  *\n*       DELAY=10                                                      *\n*       REPLY TESTJOB 'WAITING FOR' 'STOP'                            *\n*       DELAY 10                                                      *\n*       REPLY TESTJOB * YES                                           *\n*       DELAY 10                                                      *\n*       D R,R                                                         *\n*                                                                     *\n*       IN THE ABOVE EXAMPLE, THE DELAY COMMAND IS USED TO            *\n*       PAUSE THE PROGRAM FOR 10 SECONDS BETWEEN COMMANDS TO          *\n*       ALLOW TIME FOR THE PREVIOUS COMMAND TO BE EXECUTED.           *\n*                                                                     *\n*       THE STARTED COMMAND WILL INSURE THAT THE JOB OR TASK          *\n*       CICS IS EXECUTING.                                            *\n*                                                                     *\n*       THE FIRST REPLY COMMAND WILL REPLY 'STOP' TO THE FIRST        *\n*       OUTSTANDING REPLY FOR JOB TESTJOB WHICH CONTAINS              *\n*       THE CHARACTERS 'WAITING FOR'.                                 *\n*                                                                     *\n*       THE SECOND REPLY COMMAND WILL REPLY 'YES' TO THE              *\n*       FIRST OUTSTANDING REPLY FOR JOB TESTJOB NO                    *\n*       MATTER WHAT REPLY MESSAGE IS OUTSTANDING.                     *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*            M A C R O S   U S E D   I N   C O M M A N D              *\n*                                                                     *\n*        01)  ABEND        SYS1.MACLIB                                *\n*        02)  AXSET        SYS1.MACLIB                                *\n*        03)  CALL         SYS1.MACLIB                                *\n*        04)  CLOSE        SYS1.MACLIB                                *\n*        05)  CVT          SYS1.MODGEN                                *\n*        06)  DCB          SYS1.MACLIB                                *\n*        07)  DOM          SYS1.MACLIB                                *\n*        08)  EXTRACT      SYS1.MACLIB                                *\n*        09)  FREEMAIN     SYS1.MACLIB                                *\n*        10)  GET          SYS1.MACLIB                                *\n*        11)  GEMAIN       SYS1.MACLIB                                *\n*        12)  IEECUCM      SYS1.MODGEN                                *\n*        13)  IEFTIOT1     SYS1.MACLIB                                *\n*        14)  IHAASCB      SYS1.MODGEN                                *\n*        15)  IHAASVT      SYS1.MODGEN                                *\n*        16)  IHAORE       SYS1.MODGEN                                *\n*        17)  IHAPSA       SYS1.MACLIB                                *\n*        18)  IHAWQE       SYS1.MODGEN                                *\n*        19)  MGCR         SYS1.MODGEN                                *\n*        20)  MODESET      SYS1.MACLIB                                *\n*        21)  OPEN         SYS1.MACLIB                                *\n*        22)  RETURN       SYS1.MACLIB                                *\n*        23)  SAVE         SYS1.MACLIB                                *\n*        24)  SETLOCK      SYS1.MACLIB                                *\n*        25)  STIMER       SYS1.MACLIB                                *\n*        26)  WTO          SYS1.MACLIB                                *\n*                                                                     *\n*                                                                     *\n*               L I N K A G E    E D I T O R    I N F O               *\n*                                                                     *\n*        SIZE:       3K                                               *\n*        ATTRIBUTES: AUTHORIZED NORENT NOREUS NOREFR                  *\n*                    AMODE24    RMODE24                               *\n*                                                                     *\n***********************************************************************\n         EJECT\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n***********************************************************************\n*                                                                     *\n*        START OF PROGRAM                                             *\n*                                                                     *\n***********************************************************************\nCOMMAND  CSECT\nCOMMAND  AMODE 24\nCOMMAND  RMODE 24\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    R12,R15             SET BASE REGISTER\n         USING COMMAND,R12         SET ADDRESSABILITY\n         LA    R15,SAVEAREA        LOAD ADDRESS OF NEW SAVE\n         ST    R15,8(R13)          STORE NEW SAVE ADDR IN OLD\n         ST    R13,4(R15)          STORE OLD SAVE ADDR IN NEW\n         LR    R13,R15             SET NEW SAVE ADDRESS\n         LR    R2,R1               SAVE INPUT PARM ADDRESS\n         EJECT\n***********************************************************************\n*                                                                     *\n*  CHECK THE AUTHORITY OF THE USER TO SAF CLASS \"FACILITY' FOR        *\n*  ENTITY \"COMMAND\".  NOTE THAT FASTAUTH IS USED.  TO AVOID THE       *\n*  SITUATION WHERE SPECIAL ATTRIBUTES OF THE USER MAY ALLOW THE       *\n*  ACCESS WITH LOGGING, A CHECK IS MADE FOR A NON-ZERO REASON         *\n*  CODE.  THIS CONDITION WILL BE CONSIDERED A FAILURE.                *\n*                                                                     *\n***********************************************************************\nAUTHTST  RACROUTE REQUEST=FASTAUTH,WORKA=RACWORK,WKAREA=FRACWORK,      X\n               ENTITY=RESOURCE,CLASS=FACILITY,ATTR=READ,               X\n               MF=(E,RACROUTE)\n         CH    R15,=H'4'           TEST THE RETURN CODE\n         BE    EXTRACT             NO DECISION POSSIBLE, OK\n         BH    NOTAUTH             GREATER THAN 4, NOT AUTHORIZED\n         CLC   RACROUTE+4(4),=F'0' TEST THE REASON CODE\n         BE    EXTRACT             ZERO, AUTHORIZED\nNOTAUTH  WTO   'CMD913E UNAUTHORIZED USE OF THE COMMAND PROGRAM - JOB AX\n               BORTED',ROUTCDE=(2,11)\n         ABEND X'913',,,SYSTEM,REASON=0  ABEND THE JOB\n***********************************************************************\n*                                                                     *\n*        EXTRACT MY JOB NAME FOR THE WTO MESSAGES                     *\n*                                                                     *\n***********************************************************************\nEXTRACT  EXTRACT TIOTADDR,'S',FIELDS=TIOT EXTRACT THE ADDR OF THE TIOT\n         L     R3,TIOTADDR         LOAD ADDRESS OF THE TIOT\n         USING TIOT,R3             SET ADDRESSABILITY TO THE TIOT\n         MVC   MYNAME,TIOCNJOB     SAVE THE JOBNAME\n         DROP  R3                  DROP ADDRESSABILITY TO THE TIOT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        GET STORAGE FOR AN OUTSTANDING REPLY TABLE                   *\n*                                                                     *\n***********************************************************************\n         GETMAIN R,LV=13801        GET STORAGE FOR TABLE\n         ST    R1,GETADDR          SAVE TABLE ADDRESS\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SEE IF A PARM HAS BEEN ENTERED.  IF SO, PROCESS EACH         *\n*        COMMAND WITHIN THE PARM.                                     *\n*                                                                     *\n***********************************************************************\nCKPARM   LR    R1,R2               RESTORE INPUT PARM ADDRESS\n         LTR   R1,R1               SEE IF INPUT PARM\n         BZ    OPEN                NONE, GO OPEN FILE\n         L     R9,0(R1)            LOAD PARM ADDRESS\n         LTR   R9,R9               TEST PARM ADDRESS\n         BZ    OPEN                ZERO, NO PARM, GO OPEN FILE\n         LH    R8,0(R9)            LOAD PARM LENGTH\n         LTR   R8,R8               TEST PARM LENGTH\n         BZ    OPEN                ZERO, NO PARM, GO OPEN FILE\n         LA    R9,2(R9)            POINT TO ACTUAL PARM\nCKPARM1  LR    R1,R9               SAVE START ADDRESS OF PARM\n         SLR   R15,R15             SET LENGTH OF COMMAND\nCKPARM2  CLI   0(R1),C';'          SEE IF END OF COMMAND\n         BE    CKPARM3             YES, BRANCH\n         LA    R15,1(R15)          ADD 1 TO LENGTH\n         LA    R1,1(R1)            INCREMENT TO NEXT CHAR OF PARM\n         BCT   R8,CKPARM2          LOOP FOR NEXT CHAR OF PARM\nCKPARM3  LTR   R15,R15             TEST FOR ZERO LENGTH\n         BZ    CKPARM5             ZERO, NULL COMMAND, BRANCH\n         CH    R15,=H'72'          SEE IF EXCEEDS MAX LENGTH\n         BNH   CKPARM4             NO, BRANCH\n         LA    R15,72              SET TO MAX LENGTH\nCKPARM4  MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,PARMCMD         MOVE PARM COMMAND TO BUFFER\n         LR    R9,R1               SET NEW START OF CMD POINTER\n         BAL   R10,DOCMD           GO ISSUE THE COMMAND\nCKPARM5  CLI   0(R9),C';'          IS THERE ANOTHER COMMAND\n         BNE   OPEN                NO, GET OUT\n         LA    R9,1(R9)            INCREMENT PAST SEMICOLON\n         BCTR  R8,0                REDUCE REMAINING PARM LENGTH BY 1\n         LTR   R8,R8               TEST REMAINING PARM LENGTH\n         BZ    OPEN                ZERO, FINISHED\n         B     CKPARM1             GO PROCESS THIS COMMAND\nPARMCMD  MVC   COMDATA+4(0),0(R9)  **** EXECUTE ONLY ****\n         EJECT\n***********************************************************************\n*                                                                     *\n*        OPEN THE IEFRDER DATA SET (IF SPECIFIED).                    *\n*                                                                     *\n***********************************************************************\nOPEN     SLR   R15,R15        CLEAR REGISTER FOR ICM\n         L     R14,16         POINT TO CVT\n         L     R14,0(,R14)    POINT TO TCB POINTERS\n         L     R14,4(,R14)    POINT TO CURRENT TCB\n         L     R14,12(,R14)   POINT TO TIOT\n         LA    R14,24(,R14)   POINT TO TIOT DD ENTRIES\nOPEN1    ICM   R15,1,0(R14)   LOAD ENTRY LENGTH\n         BZ    RETURN         END OF TIOT, END OF PROCESSING\n         CLC   4(8,R14),=CL8'IEFRDER' SEE IF DD STATEMENT SPECIFIED\n         BE    OPEN2          YES, GET OUT\n         LA    R14,0(R15,R14) INCREMENT TO NEXT ENTRY\n         B     OPEN1          LOOP\n***********************************************************************\n*                                                                     *\n*        READ INPUT FILE.  PASS THE FIRST 72 CHARACTERS OF EACH       *\n*        RECORD TO O/S AS A COMMAND.                                  *\n*                                                                     *\n***********************************************************************\nOPEN2    OPEN  (IEFRDER,(INPUT))   OPEN INPUT FILE\nREAD     GET   IEFRDER             READ INPUT FILE\n         MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         MVC   COMDATA+4(72),0(R1) MOVE IN JES OR O/S COMMAND\n         BAL   R10,DOCMD           GO ISSUE THE COMMAND\n         B     READ\n         EJECT\n***********************************************************************\n*                                                                     *\n*        END OF THE PROGRAM                                           *\n*                                                                     *\n***********************************************************************\nEOF      CLOSE (IEFRDER)           CLOSE INPUT FILE\nRETURN   L     R1,GETADDR          LOAD ADDRESS OF GETMAINED TABLE\n         FREEMAIN R,LV=13801,A=(1) FREE STORAGE USED BY THE TABLE\n         L     R13,4(,R13)         LOAD ADDRESS OF OLD SAVE AREA\n         RETURN (14,12),RC=0       RETURN TO O/S\n         EJECT\n***********************************************************************\n*                                                                     *\n*        EITHER ISSUE THE COMMAND WHICH HAS BEEN STORED AT            *\n*        COMDATA+4 OR IF IT IS A DELAY COMMAND, WAIT THE SPECIFIED    *\n*        INTERVAL OF TIME BEFORE CONTINUING WITH OTHER COMMANDS.      *\n*                                                                     *\n*        INPUT:  COMMAND AT COMDATA+4                                 *\n*                R10 - RETURN ADDRESS                                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*        SEE IF THE COMMAND IS A DELAY COMMAND TO THE PROGRAM TO      *\n*        WAIT A SPECIFIED INTERVAL OF TIME BEFORE CONTINUING WITH     *\n*        OTHER INPUT COMMANDS.                                        *\n***********************************************************************\nDOCMD    CLI   COMDATA+4,C'*'      SEE IF A COMMENT STATEMENT\n         BER   R10                 YES, BYPASS THIS COMMAND\n         CLC   COMDATA+4(6),=CL6'DELAY=' SEE IF A DELAY COMMAND\n         BNE   DOCMD2              NO, GO SEE IF REPLY COMMAND\nDOCMD1   WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         LA    R2,COMDATA+10       POINT TO START OF \"DELAY=\" VALUE\n         LA    R3,8                SET MAXIMUM LENGTH OF DELAY VALUE\n         SLR   R4,R4               SET LENGTH COUNTER\nDOCMD1A  CLI   0(R2),C' '          END OF DELAY VALUE\n         BE    DOCMD1B             YES, BRANCH\n         LA    R4,1(,R4)           ADD 1 TO LENGTH COUNTER\n         CLI   0(R2),C'0'          SEE IF LT 0\n         BL    DOCMD1C             YES, NOT NUMERIC\n         CLI   0(R2),C'9'          SEE IF GT 9\n         BH    DOCMD1C             YES, NOT NUMERIC\n         LA    R2,1(,R2)           INCREMENT TO NEXT INPUT CHARACTER\n         BCT   R3,DOCMD1A          LOOP UP TO 8 TIMES\n         CLI   0(R2),C' '          END OF DELAY VALUE\n         BNE   DOCMD1C             NO, TOO LONG\nDOCMD1B  LTR   R4,R4               TEST LENGTH\n         BZ    DOCMD1C             ZERO, BLANK\n         BCTR  R4,0                MAKE MACHINE LENGTH\n         EX    R4,PACKTIME         PACK THE DELAY VALUE\n         CVB   R5,DOUBLE           CONVERT DELAY TO BINARY\n         LTR   R5,R5               CHECK VALUE\n         BZ    DOCMD1C             ZERO, INVALID\n         CH    R5,=H'999'          SEE IF EXCEEDS MAXIMUM VALUE\n         BH    DOCMD1C             YES, ERROR\n         MH    R5,=H'100'          MULTIPLY BY 100\n         ST    R5,WAITIME          SAVE WAIT TIME IN HUNDRETHS OF A SEC\n         STIMER WAIT,BINTVL=WAITIME WAIT THE SPECIFIED TIME\n         B     DOCMD6              GO GET ANOTHER COMMAND\nDOCMD1C  WTO   'CMD001E ILLEGAL VALUE SPECIFIED ON THE DELAY CONTROL STX\n               ATEMENT - JOB ABORTED',ROUTCDE=(2,11)\n         ABEND 0001,DUMP           ABEND THE STEP\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS A REPLY COMMAND                                      *\n*                                                                     *\n***********************************************************************\nDOCMD2   CLC   COMDATA+4(6),=CL6'REPLY ' SEE IF A REPLY COMMAND\n         BNE   DOCMD3              NO, GO SEE IF WAIT COMMAND\n***********************************************************************\n*                                                                     *\n*        PARSE THE REPLY COMMAND                                      *\n*                                                                     *\n***********************************************************************\n         MVC   REPLYWK(72),COMDATA+4   SAVE REPLY COMMAND\n         LA    R1,REPLYWK+5        POINT TO START OF REPLY DATA\n         LA    R14,72-5            LOAD LENGTH OF REPLY DATA\n         MVI   DELIM,C' '          SET DELIMETER TO BLANK\n         LA    R2,PARMS            POINT TO PARM TABLE\n         SLR   R15,R15             SET PARM COUNT TO ZERO\nDOCMD2A  CLC   0(1,R1),DELIM       SEE IF START OF PARM\n         BNE   DOCMD2B             NO, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R14,DOCMD2A         LOOP\n         B     DOCMD2F             END OF PARM, BRANCH\nDOCMD2B  CH    R15,=H'3'           SEE IF ALREADY FOUND MAX PARMS\n         BNL   DOCMD2F             YES, IGNORE ANY OTHERS\n         LA    R15,1(,R15)         ADD 1 TO PARM COUNTER\n         CLI   0(R1),C''''         SEE IF QUOTED STRING\n         BNE   DOCMD2C             NO, BRANCH\n         MVC   DELIM,0(R1)         SET DELIMETER\n         LA    R1,1(,R1)           INCREMENT PAST DELIMETER\n         BCTR  R14,0               DECREMENT REMAINING CHARACTER COUNT\n         LTR   R14,R14             TEST REMAINING CHARACTER COUNT\n         BNP   DOCMD2F             DONE, GET OUT\nDOCMD2C  ST    R1,0(R2)            SAVE START ADDRESS OF PARM\nDOCMD2D  CLC   0(1,R1),DELIM       SEE IF END OF PARM\n         BE    DOCMD2E             YES, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R14,DOCMD2D         LOOP\nDOCMD2E  S     R1,0(R2)            SUBTRACT START ADDR FROM ENDING\n         ST    R1,4(R2)            SAVE PARM LENGTH\n         A     R1,0(R2)            RESTORE END ADDRESS\n         LA    R1,1(,R1)           INCREMENT PAST DELIMETER\n         BCTR  R14,0               DECREMENT REMAINING CHARACTER COUNT\n         LTR   R14,R14             TEST REMAINING CHARACTER COUNT\n         BNP   DOCMD2F             DONE, GET OUT\n         MVI   DELIM,C' '          SET DEFAULT DELIMETER\n         LA    R2,8(,R2)           INCREMENT TO NEXT PARM POINTER\n         B     DOCMD2A             GO PROCESS NEXT PARM\nDOCMD2F  CH    R15,=H'3'           SEE IF THREE PARMS\n         BE    DOCMD2G             YES, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR01' SET ERROR FLAG\n         B     DOCMD2P             GO ECHO THE COMMAND\nDOCMD2G  CLC   JOBNL,=F'0'         TEST LENGTH OF THE JOBNAME\n         BNZ   DOCMD2H             NOT ZERO, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR02' SET ERROR FLAG\n         B     DOCMD2P             GO ECHO THE COMMAND\nDOCMD2H  CLC   JOBNL,=F'8'         TEST LENGTH OF THE JOBNAME\n         BNH   DOCMD2I             NOT GREATER THAN 8, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR03' SET ERROR FLAG\n         B     DOCMD2P             GO ECHO THE COMMAND\n***********************************************************************\n*                                                                     *\n*        GO GET A LIST OF OUTSTANDING REPLIES                         *\n*                                                                     *\n***********************************************************************\nDOCMD2I  L     R1,GETADDR          LOAD ADDRESS OF REPLY TABLE\n         CALL  REPLY               CALL THE SUBROUTINE\n***********************************************************************\n*                                                                     *\n*        FIND AN OUTSTANDING REPLY FOR THE SPECIFIED JOBNAME          *\n*                                                                     *\n***********************************************************************\nDOCMD2J  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME\n         L     R14,JOBN            LOAD ADDRESS OF JOBNAME\n         L     R15,JOBNL           LOAD LENGTH OF JOBNAME\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,SETNAME         SET THE FULL JOB NAME\n         L     R3,GETADDR          LOAD ADDRESS OF REPLY TABLE\n         USING MSGENT,R3           SET ADDRESSABILITY TO REPLY TABLE\nDOCMD2K  CLI   0(R3),X'FF'         END OF TABLE, BRANCH\n         BNE   DOCMD2L             NO, BRANCH\n         MVC   COMDATA+4+72(8),=CL8' ERROR04' SET ERROR FLAG\n         B     DOCMD2P             GO ECHO THE COMMAND\nDOCMD2L  CLC   JNAME,JOBNAME       SEE IF MATCH ON JOB NAME\n         BE    DOCMD2N             YES, BRANCH\nDOCMD2M  LA    R3,L'MSGENT(,R3)    INCREMENT TO NEXT REPLY TABLE ENTRY\n         B     DOCMD2K             LOOP\n***********************************************************************\n*                                                                     *\n*        SEE IF THIS REPLY CONTAINS THE SPECIFIED TEXT (IF ANY)       *\n*                                                                     *\n***********************************************************************\nDOCMD2N  LA    R14,MSG             POINT TO MESSAGE TEST\n         LA    R15,128             LOAD MESSAGE LENGTH\n         S     R15,MATCHL          CALCULATE LOOP COUNTER\n         L     R1,MATCHL           LOAD LENGTH OF MATCH TEXT\n         BCTR  R1,0                MAKE MACHINE LENGTH\n         L     R2,MATCH            LOAD ADDRESS OF MATCH TEXT\n         CLC   MATCHL,=F'0'        SEE IF LENGTH OF TEXT = 0\n         BE    DOCMD2P             YES, USE THIS OUTSTANDING REPLY\n         CLC   MATCHL,=F'1'        SEE IF LENGTH OF TEXT = 1\n         BH    DOCMD2O             NO, BRANCH\n         CLI   0(R2),C'*'          SEE IF NULL MATCH TEXT\n         BE    DOCMD2P             YES, USE THIS OUTSTANDING REPLY\nDOCMD2O  EX    R1,COMPTEXT         SEE IF MATCH MESSAGE TEXT\n         BE    DOCMD2P             YES, BRANCH\n         LA    R14,1(,R14)         POINT TO NEXT CHARACTER OF TEXT\n         BCT   R15,DOCMD2O         LOOP\n         B     DOCMD2M             NO MATCH FOR TEXT, FIND ANOTHER MSG\nDOCMD2P  WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         CLC   COMDATA+4+72(8),=CL8' ' SEE IF ERROR HAS OCCURRED\n         BNE   DOCMD6              YES, DROP THIS REPLY COMMAND\n         MVI   COMDATA+4,C' '      BLANK THE ENTIRE\n         MVC   COMDATA+4+1(79),COMDATA+4  COMMAND AREA\n         MVI   COMDATA+4,C'R'      SET REPLY CHARACTER\n         MVC   COMDATA+4+2(4),RID  SET REPLY ID          *JAW*\n         MVI   COMDATA+4+6,C','    SET THE END OF THE REPLY ID *JAW*\n         L     R1,REPLYTX          LOAD ADDRESS OF THE REPLY TEXT\n         ICM   R15,B'1111',REPLYTXL LOAD LENGTH OF REPLY TEXT\n         BZ    DOCMD5              ZERO, GO ISSUE THE NULL REPLY\n         MVI   COMDATA+4+7,C''''   SET START QUOTE FOR REPLY   *JAW*\n         BCTR  R15,0               MAKE MACHINE LENGTH\n         EX    R15,SETREPLY        SET THE REPLY TEXT\n         LA    R15,COMDATA+4+8+1(R15) POINT PAST REPLY         *JAW*\n         MVI   0(R15),C''''        SET ENDING QUOTE FOR REPLY\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         B     DOCMD5              GO ISSUE THE REPLY\nCOMPTEXT CLC   0(0,R14),0(R2)      **** EXECUTE ONLY ****\nSETREPLY MVC   COMDATA+4+8(0),0(R1) *** EXECUTE ONLY ****     *JAW*\n         DROP  R3                  DROP ADDRESSABILITY TO REPLY TABLE\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS A STOPPED COMMAND                                    *\n*                                                                     *\n***********************************************************************\nDOCMD3   CLC   COMDATA+4(8),=CL8'STOPPED' SEE IF A STOPPED COMMAND\n         BNE   DOCMD4              NO, GO SEE IF STARTED COMMAND\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n***********************************************************************\n*                                                                     *\n*        PARSE THE STOPPED COMMAND                                    *\n*                                                                     *\n***********************************************************************\n         MVC   REPLYWK(72),COMDATA+4   SAVE STOPPED COMMAND\n         LA    R1,REPLYWK+8        POINT TO START OF STOPPED DATA\n         LA    R15,72-8            LOAD LENGTH OF STOPPED DATA\n         SLR   R14,R14             SET LENGTH OF JOBNAME TO ZERO\nDOCMD3A  CLC   0(1,R1),C' '        SEE IF START OF JOBNAME\n         BNE   DOCMD3B             NO, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R15,DOCMD3A         LOOP\n         B     DOCMD3Z             END OF PARM, NO JOBNAME, BYPASS\nDOCMD3B  LR    R14,R1              SAVE START ADDRESS OF JOBNAME\nDOCMD3C  CLC   0(1,R1),C' '        SEE IF END OF JOBNAME\n         BE    DOCMD3D             YES, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF JOBNAME\n         BCT   R15,DOCMD3C         LOOP\nDOCMD3D  SR    R1,R14              SUBTRACT START ADDR FROM ENDING\n         CH    R1,=H'8'            TEST LENGTH OF THE JOBNAME\n         BNH   DOCMD3E             NOT GREATER THAN 8, BRANCH\n         LA    R1,8                SET LENGTH TO 8\nDOCMD3E  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME\n         BCTR  R1,0                MAKE MACHINE LENGTH\n         EX    R1,SETNAME          SET THE FULL JOB NAME\n***********************************************************************\n*                                                                     *\n*        SEE IF THE REQUESTED JOB/TASK IS RUNNING                     *\n*                                                                     *\n***********************************************************************\nDOCMD3F  LA    R1,JOBNAME          POINT TO JOBNAME\n         BAL   R14,JOBSRCH         GO SEE IF JOB IS EXECUTING\n         LTR   R15,R15             TEST THE RETURN CODE\n         BNZ   DOCMD3Z             NOT ZER0, NOT EXECUTING, EXIT\n***********************************************************************\n*                                                                     *\n*        ISSUE THE WTO MESSAGE IF NOT ALREADY ISSUED                  *\n*                                                                     *\n***********************************************************************\n         CLC   WTOMSGID,=XL8'00'   SEE IF MESSAGE ALREADY ISSUED\n         BNE   DOCMD3G             YES, GO WAIT A BIT\n         MVC   WAITMSG1+4+08(8),MYNAME  MOVE MY JOBNAME TO MESSAGE\n         MVC   WAITMSG1+4+29(8),JOBNAME MOVE JOBNAME TO MESSAGE\n         WTO   MF=(E,WAITMSG1)     ISSUED THE WTO MESSAGE\n         ST    R1,WTOMSGID         SAVE THE WTO MESSAGE ID FOR DOM\n***********************************************************************\n*                                                                     *\n*        WAIT 15 SECONDS AND TRY AGAIN                                *\n*                                                                     *\n***********************************************************************\nDOCMD3G  STIMER WAIT,BINTVL=SEC15  WAIT 15 SECONDS\n         B     DOCMD3F             GO SEE IF JOB HAS COMPLETED YET\n***********************************************************************\n*                                                                     *\n*        DELETE THE WTO MESSAGE IF IT HAS BEEN ISSUED                 *\n*        AND EXIT                                                     *\n*                                                                     *\n***********************************************************************\nDOCMD3Z  ICM   R1,B'1111',WTOMSGID LOAD WTO MESSAGE ID\n         BZ    DOCMD6              ZERO, NO MESSAGE, GET OUT\n         DOM   MSG=(1)             DELETE OPERATOR MESSAGE\n         XC    WTOMSGID,WTOMSGID   CLEAR THE WTO MESSAGE ID\n         B     DOCMD6              GO GET ANOTHER COMMAND\n         SPACE 3\nWAITMSG1 WTO   'CMD002I ........ WAITING FOR ........ TO COMPLETE',    X\n               ROUTCDE=(2,11),DESC=2,MF=L\n         EJECT\n***********************************************************************\n*                                                                     *\n*        PROCESS A STARTED COMMAND                                    *\n*                                                                     *\n***********************************************************************\nDOCMD4   CLC   COMDATA+4(8),=CL8'STARTED' SEE IF A STARTED COMMAND\n         BNE   DOCMD5              NO, GO ISSUE THE COMMAND\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n***********************************************************************\n*                                                                     *\n*        PARSE THE STARTED COMMAND                                    *\n*                                                                     *\n***********************************************************************\n         MVC   REPLYWK(72),COMDATA+4   SAVE STARTED COMMAND\n         LA    R1,REPLYWK+8        POINT TO START OF STARTED DATA\n         LA    R15,72-8            LOAD LENGTH OF STARTED DATA\n         SLR   R14,R14             SET LENGTH OF JOBNAME TO ZERO\nDOCMD4A  CLC   0(1,R1),C' '        SEE IF START OF JOBNAME\n         BNE   DOCMD4B             NO, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF PARMS\n         BCT   R15,DOCMD4A         LOOP\n         B     DOCMD4Z             END OF PARM, NO JOBNAME, BYPASS\nDOCMD4B  LR    R14,R1              SAVE START ADDRESS OF JOBNAME\nDOCMD4C  CLC   0(1,R1),C' '        SEE IF END OF JOBNAME\n         BE    DOCMD4D             YES, BRANCH\n         LA    R1,1(,R1)           INCREMENT TO NEXT CHAR OF JOBNAME\n         BCT   R15,DOCMD4C         LOOP\nDOCMD4D  SR    R1,R14              SUBTRACT START ADDR FROM ENDING\n         CH    R1,=H'8'            TEST LENGTH OF THE JOBNAME\n         BNH   DOCMD4E             NOT GREATER THAN 8, BRANCH\n         LA    R1,8                SET LENGTH TO 8\nDOCMD4E  MVC   JOBNAME,=CL8' '     BLANK THE JOBNAME\n         BCTR  R1,0                MAKE MACHINE LENGTH\n         EX    R1,SETNAME          SET THE FULL JOB NAME\n***********************************************************************\n*                                                                     *\n*        SEE IF THE REQUESTED JOB/TASK IS RUNNING                     *\n*                                                                     *\n***********************************************************************\nDOCMD4F  LA    R1,JOBNAME          POINT TO JOBNAME\n         BAL   R14,JOBSRCH         GO SEE IF JOB IS EXECUTING\n         LTR   R15,R15             TEST THE RETURN CODE\n         BZ    DOCMD4Z             ZER0, EXECUTING, EXIT\n***********************************************************************\n*                                                                     *\n*        ISSUE THE WTO MESSAGE IF NOT ALREADY ISSUED                  *\n*                                                                     *\n***********************************************************************\n         CLC   WTOMSGID,=XL8'00'   SEE IF MESSAGE ALREADY ISSUED\n         BNE   DOCMD4G             YES, GO WAIT A BIT\n         MVC   WAITMSG2+4+08(8),MYNAME  MOVE MY JOBNAME TO MESSAGE\n         MVC   WAITMSG2+4+29(8),JOBNAME MOVE JOBNAME TO MESSAGE\n         WTO   MF=(E,WAITMSG2)     ISSUED THE WTO MESSAGE\n         ST    R1,WTOMSGID         SAVE THE WTO MESSAGE ID FOR DOM\n***********************************************************************\n*                                                                     *\n*        WAIT 15 SECONDS AND TRY AGAIN                                *\n*                                                                     *\n***********************************************************************\nDOCMD4G  STIMER WAIT,BINTVL=SEC15  WAIT 15 SECONDS\n         B     DOCMD4F             GO SEE IF JOB HAS COMPLETED YET\n***********************************************************************\n*                                                                     *\n*        DELETE THE WTO MESSAGE IF IT HAS BEEN ISSUED                 *\n*        AND EXIT                                                     *\n*                                                                     *\n***********************************************************************\nDOCMD4Z  ICM   R1,B'1111',WTOMSGID LOAD WTO MESSAGE ID\n         BZ    DOCMD6              ZERO, NO MESSAGE, GET OUT\n         DOM   MSG=(1)             DELETE OPERATOR MESSAGE\n         XC    WTOMSGID,WTOMSGID   CLEAR THE WTO MESSAGE ID\n         B     DOCMD6              GO GET ANOTHER COMMAND\n         SPACE 3\nWAITMSG2 WTO   'CMD003I ........ WAITING FOR ........ TO START',       X\n               ROUTCDE=(2,11),DESC=2,MF=L\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ISSUE THE COMMAND                                            *\n*                                                                     *\n***********************************************************************\nDOCMD5   SLR   R0,R0               CLEAR REG ZERO\n         MODESET KEY=ZERO          GET INTO KEY ZERO\n         MGCR  COMDATA             ISSUE THE COMMAND\n         WTO   MF=(E,COMDATA)      ECHO THE COMMAND ON THE CONSOLE\n         MODESET KEY=NZERO         GET OUT OF KEY ZERO\nDOCMD6   BR    R10                 GO GET ANOTHER COMMAND\n         SPACE 1\nPACKTIME PACK  DOUBLE,COMDATA+10(0) *** EXECUTE ONLY ****\nSETNAME  MVC   JOBNAME(0),0(R14)   **** EXECUTE ONLY ****\n         EJECT\n***********************************************************************\n*                                                                     *\n*                          J O B S R C H                              *\n*                                                                     *\n*        SEARCH THE ADDRESS SPACES IN THE SYSTEM TO SEE IF THE        *\n*        JOBNAME OR TASK NAME POINTED TO BY REGISTER 1 UPON           *\n*        ENTRY TO THIS ROUTINE IS EXECUTING.  THE RETURN CODE         *\n*        WILL BE SET AS FOLLOWS:                                      *\n*                                                                     *\n*        R15 = 0  - THE REQUESTED JOB IS EXECUTING                    *\n*        R15 = 4  - THE REQUESTED JOB IS NOT EXECUTING                *\n*                                                                     *\n*        RETURN IS MADE TO THE ADDRESS IN REGISTER 14 UPON ENTRY.     *\n*                                                                     *\n***********************************************************************\nJOBSRCH  STM   R0,R15,SAVESRCH     SAVE REGISTERS\nJOBSRCH1 L     R5,16               LOAD ADDR OF CVT\n         USING CVT,R5              SET ADDRESSABILITY TO CVT\n         L     R5,CVTASVT          POINT TO ADDRESS SPACE VECTOR TABLE.\n         DROP  R5                  DROP ADDRESSABILITY TO CVT\n         USING ASVT,R5             SET ADDRESSABILITY TO ASVT\n         L     R14,ASVTMAXU        LOAD MAX. NUMBER OF ADDRESS SPACES.\n         LA    R5,ASVTENTY         LOAD ADDRESS OF FIRST ASCB POINTER\n         DROP  R5                  DROP ADDRESSABILITY TO ASVT\nJOBSRCH2 ICM   R6,B'1111',0(R5)    POINT TO ASCB\n         BNP   JOBSRCH5            ZERO OR NEGATIVE, BYPASS THIS ONE\n         USING ASCB,R6             SET ADDRESSABILITY TO ASCB\n         ICM   R15,B'1111',ASCBJBNI LOAD ADDRESS OF JOB NAME\n         BZ    JOBSRCH3            ZERO, NOT A BATCH JOB\n         MVC   SRCHNAME,0(R15)     SAVE JOB NAME\n         B     JOBSRCH4            GO SEE IF REQUESTED JOB/TASK NAME\nJOBSRCH3 ICM   R15,B'1111',ASCBJBNS LOAD ADDRESS OF TASK NAME\n         MVC   SRCHNAME,0(R15)     SAVE TASK NAME\nJOBSRCH4 CLC   SRCHNAME,0(R1)      SEE IF REQUESTED JOB/TASK NAME\n         BE    JOBSRCH6            YES, GET OUT\nJOBSRCH5 LA    R5,4(R5)            POINT TO NEXT ASCB POINTER.\n         BCT   R14,JOBSRCH2        LOOP THROUGH ASCBS\n         LA    R15,4               NOT FOUND, SET RETURN CODE TO 4\n         B     JOBSRCH7            GO RETURN TO CALLER\nJOBSRCH6 LA    R15,0               FOUND, SET RETURN CODE TO 0\nJOBSRCH7 LM    R0,R14,SAVESRCH     RESTORE REGISTERS\n         BR    R14                 RETURN TO CALLER\n         DROP  R6                  DROP ADDRESSABILITY TO ASCB\n         EJECT\n***********************************************************************\n*                                                                     *\n*        CONSTANTS AND WORK AREAS.                                    *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         LTORG\n         SPACE 3\nSAVEAREA DS    18F                 REGISTER SAVE AREA\nSAVESRCH DS    16F                 SAVE AREA FOR JOBSRCH ROUTINE\nSEC15    DC    A(15*100)           15 SECOND BINARY WAIT INTERVAL\nTIOTADDR DS    F                   EXTRACT ANSWER AREA\nGETADDR  DS    F                   ADDRESS OF OUTSTANDING REPLY TABLE\nREPLYWK  DC    CL80' '             REPLY COMMAND WORK AREA\nPARMS    DS    0F                  REPLY PARM PARSE LIST\nJOBN     DS    F                   ADDRESS OF JOB NAME\nJOBNL    DS    F                   LENGTH OF JOB NAME\nMATCH    DS    F                   ADDRESS OF REPLY TEXT TO MATCH\nMATCHL   DS    F                   LENGTH OF REPLY TEXT TO MATCH\nREPLYTX  DS    F                   ADDRESS OF ACTUAL REPLY TEXT\nREPLYTXL DS    F                   LENGTH OF ACTUAL REPLY TEXT\nWTOMSGID DC    F'0'                WTO MESSAGE ID FOR DOM PROCESSING\nDELIM    DC    C' '                TEXT SCAN DELIMETER\nMYNAME   DS    CL8                 NAME OF THIS JOB OR TASK\nJOBNAME  DS    CL8                 JOBNAME FOR REPLY SEARCH\nSRCHNAME DS    CL8                 JOB/TASK NAME FROM ASCB\nCOMDATA  DS    0F\n         DC    X'00'\n         DC    AL1(84)\n         DC    X'0000'\n         DC    C'123456789 123456789 123456789 123456789 123456789 1234X\n               56789 123456789 12        '\nDOUBLE   DS    D                   DOUBLE WORK WORK AREA\nWAITIME  DS    F                   DELAY TIME IN 1/100 SECONDS\nFACILITY DC    CL8'FACILITY'       RACROUTE CLASS NAME\nRESOURCE DC    CL44'COMMAND'       RACROUTE RESOURCE NAME\nRACROUTE RACROUTE REQUEST=FASTAUTH,MF=L RACROUTE LIST FORM\nRACWORK  DS    CL512               RACROUTE WORK AREA 1\nFRACWORK DS    16F                 RACROUTE WORK AREA 2\n         PRINT NOGEN\nIEFRDER  DCB   DDNAME=IEFRDER,DSORG=PS,MACRF=GL,EODAD=EOF\n         EJECT\n***********************************************************************\n*                                                                     *\n*                           R E P L Y                                 *\n*                                                                     *\n*        RETURN A LIST OF THE OUTSTANDING REPLIES IN A TABLE          *\n*        POINTED TO BY REGISTER 1 ON ENTRY.  THERE IS ROOM FOR        *\n*        100 OUTSTANDING REPLIES IN THE TABLE.  AN ENTRY WHICH        *\n*        STARTS WITH X'FF' WILL FLAG THE END OF THE REPLIES.          *\n*                                                                     *\n*        BECAUSE SOME OF THE STORAGE AREAS ARE ABOVE THE 16           *\n*        MEG LINE, THE ROUTINE WILL SWITCH TO AMODE31 IN THE          *\n*        BEGINNING AND SWITCH BACK TO AMODE 24 WHEN FINISHED.         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        REGISTERS ON ENTRY                                           *\n*           R1  - ADDRESS OF THE REPLY TABLE                          *\n*           R13 - ADDRESS OF A SAVE AREA                              *\n*           R15 - ENTRY POINT ADDRESS                                 *\n*                                                                     *\n*        REGISTERS ON ENTRY                                           *\n*           SAME AS ON ENTRY                                          *\n*                                                                     *\n***********************************************************************\nREPLY    CSECT\n         SAVE  (14,12)             SAVE REGISTERS\n         LR    R12,R15             INITIALIZE FIRST BASE REGISTER\n         USING REPLY,R12           SET PROGRAM ADDRESSABILITY\n         LR    R15,R13             SAVE CALLING'S SAVE AREA ADDR\n         LA    R13,REPSAVE         LOAD ADDR OF NEW SAVE AREA\n         ST    R13,8(R15)          STORE NEW SAVE ADDR IN OLD\n         ST    R15,4(R13)          STORE OLD SAVE ADDR IN NEW\n         LA    R15,*+10            SET BRANCH ADDRESS\n         O     R15,=X'80000000'    SET AMODE31 BIT ON\n         BASSM R14,R15             GO TO AMODE 31\n***********************************************************************\n*                                                                     *\n*        FLAG END OF REPLY TABLE                                      *\n*                                                                     *\n***********************************************************************\n         MVI   0(R1),X'FF'         SET END OF TABLE INDICATOR\n         ST    R1,TBLADDR          SAVE REPLY TABLE ADDRESS\n***********************************************************************\n*                                                                     *\n*        DETERMINE THE ASID NUMBER OF THE CONSOLE ADDRESS SPACE       *\n*                                                                     *\n***********************************************************************\nREPLY01  L     R4,16               R4 = ADDR OF CVT\n         USING CVT,R4              SET ADDRESSABILITY TO CVT\n         L     R5,CVTASVT          POINT TO ADDRESS SPACE VECTOR TABLE.\n         USING ASVT,R5             SET ADDRESSABILITY TO ASVT\n         L     R4,ASVTMAXU         LOAD MAX. NUMBER OF ADDRESS SPACES.\n         LA    R2,1                SET ADDRESS SPACE NUMBER TO ONE\n         LA    R5,ASVTENTY         LOAD ADDRESS OF FIRST ASCB POINTER\nREPLY02  ICM   R6,B'1111',0(R5)    POINT TO ASCB\n         BNP   REPLY03             ZERO OR NEGATIVE, BYPASS THIS ONE\n         USING ASCB,R6             SET ADDRESSABILITY TO ASCB\n         ICM   R15,B'1111',ASCBJBNS LOAD ADDRESS OF JOBNAME FIELD.\n         BZ    REPLY03             ZERO, BYPASS THIS ONE\n         CLC   0(8,R15),=C'CONSOLE ' IS THIS THE CONSOLE ADDRESS SPACE?\n         BE    REPLY04             YES, EXIT FROM LOOP.\nREPLY03  LA    R2,1(R2)            ADD 1 TO THE ASID\n         LA    R5,4(R5)            POINT TO NEXT ASCB POINTER.\n         BCT   R4,REPLY02          LOOP\n         B     REPLY13             ERROR, GET OUT\nREPLY04  ST    R2,CONSASID         SAVE ASID OF CONSOLE ADDRESS SPACE.\n         DROP  R4                  DROP ADDRESSABILITY TO CVT\n         DROP  R5                  DROP ADDRESSABILITY TO ASVT\n         DROP  R6                  DROP ADDRESSABILITY TO ASCB\n         EJECT\n***********************************************************************\n*                                                                     *\n*        SET UP CROSS MEMORY SERVICES                                 *\n*                                                                     *\n***********************************************************************\nREPLY05  L     R10,TBLADDR         GET START OF REPLY TABLE\n         USING MSGDSECT,R10        SET ADDRESSABILITY TO REPLY ENTRY\n         SLR   R7,R7               SET MESSAGE COUNT TO ZERO\n         MODESET MODE=SUP,KEY=ZERO AUTHORIZE OURSELVES\n         ESAR  R9                  GET SECONDARY ASID\n         ST    R9,SASID            AND SAVE IT\n         AXSET AX=ONE              SET AX TO ALLOW SSAR\n         L     R9,CONSASID         GET 'CONSOLE' ASID\n         SSAR  R9                  SET 'CONSOLE' AS SECONDARY ASID\n***********************************************************************\n*                                                                     *\n*        GET THE CMS LOCK SO THAT THE OUTSTANDING REPLY               *\n*        ELEMENT (ORE) CHAIN WILL NOT BE ALTERED DURING               *\n*        OUR PROCESSING.                                              *\n*                                                                     *\n***********************************************************************\nREPLY06  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE\n         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=SAVE\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n***********************************************************************\n*                                                                     *\n*          GET THE ADDRESS OF THE FIRST OUTSTANDING REPLY             *\n*          ELEMENT (ORE)                                              *\n*                                                                     *\n***********************************************************************\nREPLY07  L     R4,16               R4 = ADDR OF CVT\n         USING CVT,R4              SET ADDRESSABILITY TO CVT\n         L     R4,CVTCUCB          R4 = ADDR OF 'CUCB' (UCM BASE)\n         DROP  R4                  DROP ADDRESSABILITY TO CVT\n         USING UCM,R4              SET ADDRESSABILITY TO UCM BASE\n         L     R2,UCMRPYQ          LOAD ADDRESS OF FIRST ORE\n         LTR   R2,R2               TEST ORE ADDRESS\n         BZ    REPLY12             ZERO, NO OUTSTANDING REPLIES\n         DROP  R4                  DROP ADDRESSABILITY TO UCM BASE\n         USING OREF,R2             SET ADDRESSABILITY TO ORE\n***********************************************************************\n*                                                                     *\n*          COPY THE WTO QUEUE ELEMENT (WQE) FROM THE CONSOLE          *\n*          ADDRESS SPACE FOR THE CURRENT ORE                          *\n*                                                                     *\n***********************************************************************\nREPLY08  L     R8,ORERWQE          R8 = ADDR OF WQE\n         LA    R4,WQECOPY          R4 = ADDR OF COPY OF WQE\n         LA    R5,WQESIZE          R5 = SET LENGTH OF WQE\n         SLR   R15,R15             SET 'FROM' KEY TO ZERO\nREPLY09  MVCP  0(R5,R4),0(R8),R15  MOVE UP TO 256 BYTES\n         BZ    REPLY10             CC=0 - DONE\n         LA    R4,256(,R4)         INCREMENT 'TO' ADDRESS\n         LA    R8,256(,R8)         INCREMENT 'FROM' ADDRESS\n         SH    R5,=H'256'          SUBTRACT LENGTH OF LAST MOVE\n         B     REPLY09             GO GET REST OF AREA\nREPLY10  LA    R4,WQECOPY          RESTORE ADDRESS OF COPY OF WQE\n         USING WQE,R4              SET ADDRESSABILITY TO WQE\n***********************************************************************\n*                                                                     *\n*          SAVE THE REPLY JOBNAME, MSGID, AND ACTUAL MESSAGE          *\n*          FROM THE WQE                                               *\n*                                                                     *\n***********************************************************************\nREPLY11  MVI   MSGENT,C' '         BLANK THE ENTIRE\n         MVC   MSGENT+1(L'MSGENT-1),MSGENT   MESSAGE AREA\n         MVC   JNAME,WQEOJBNM      SAVE JOB NAME\n         ST    R7,SAVEREG          USE R7 TEMP             *JAW*\n         L     R7,WQERPYIB         GET THE SYSPLEX ID      *JAW*\n         CVD   R7,DWORD            CONVERT ID TO DECIMAL   *JAW*\n         UNPK  RID,DWORD           CONVERT ID TO ZONED DEC *JAW*\n         OI    RID+3,X'F0'         GET RID OF SIGN BIT     *JAW*\n         L     R7,SAVEREG          RETURN PREIOUS VALUE    *JAW*\n*        MVC   RID,WQERPYIB        SAVE REPLY ID           *JAW*\n         MVC   MSG,WQETXT          SAVE MESSAGE TEXT\n         LA    R10,L'MSGENT(,R10)  INCREMENT TO NEXT MESSAGE AREA\n         MVI   0(R10),X'FF'        SET END OF TABLE INDICATOR\n         LA    R7,1(,R7)           ADD 1 TO MESSAGE COUNT\n         CH    R7,=H'100'          SEE IF REACHED MAXIMUM\n         BNL   REPLY12             YES, GET OUT\n         L     R2,ORELKP           LOAD ADDRESS OF NEXT ORE\n         LTR   R2,R2               SEE IF ANY MORE ORE'S\n         BNZ   REPLY08             YES, LOOP\n         DROP  R2                  DROP ADDRESSABILITY TO ORE\n         DROP  R4                  DROP ADDRESSABILITY TO WQE\n         DROP  R10                 DROP ADDRESSABILITY TO REPLY TABLE\n***********************************************************************\n*                                                                     *\n*        FREE THE CMS LOCK SO THAT NORMAL CONSOLE MESSAGE             *\n*        PROCESSING CAN CONTINUE                                      *\n*                                                                     *\n***********************************************************************\nREPLY12  AL    R13,=F'12'          CHANGE R13 FOR SETLOCK\n         SETLOCK RELEASE,TYPE=CMS,REGS=SAVE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE\n         SL    R13,=F'12'          PUT R13 BACK TO NORMAL\n***********************************************************************\n*                                                                     *\n*        GET OUT OF CROSS MEMORY MODE                                 *\n*                                                                     *\n***********************************************************************\n         L     R9,SASID            RESTORE PREVIOUS SECONDARY ASID\n         SSAR  R9                  SHOULD BE SAME AS PRIMARY\n         AXSET AX=ZERO             SET AUTHORIZATION INDEX BACK TO ZERO\n         MODESET MODE=PROB,KEY=NZERO UNAUTHORIZE OURSELVES\n***********************************************************************\n*                                                                     *\n*        RETURN TO THE CALLER                                         *\n*                                                                     *\n***********************************************************************\n         SPACE 3\nREPLY13  LA    R15,*+6             SET BRANCH ADDRESS\n         BASSM R14,R15             GO TO AMODE 24\n         L     R13,4(R13)          RESTORE ORIG SAVE AREA ADDRESS\n         RETURN (14,12)            RETURN TO CALLER\n         EJECT\n***********************************************************************\n*                                                                     *\n*                         C O N S T A N T S                           *\n*                                                                     *\n***********************************************************************\n         LTORG\nREPSAVE  DS    18F                 PROGRAM SAVE AREA\nCONSASID DC    F'0'                ASID OF CONSOLE ADDRESS SPACE\nTBLADDR  DS    F                   ADDRESS OF REPLY TABLE\nSASID    DS    F                   SAVE PREVIOUS SECONDARY ASID\nONE      DC    H'1'                TO SET AX 1\nZERO     DC    H'0'                TO SET AX 0\n         DS    0F\nWQECOPY  DS    CL512               LOCAL COPY OF WQE\n         EJECT\nMSGDSECT DSECT\nMSGENT   DS    0CL138\nJNAME    DS    CL8\nRID      DS    CL4\nDWORD    DS    D            *JAW*\nSAVEREG  DS    F            *JAW*\nMSG      DS    CL128\n         EJECT\n         CVT   DSECT=YES\n         EJECT\n         IEECUCM DSECT=YES,FORMAT=NEW,LIST=YES\n         EJECT\n         IHAASVT DSECT=YES\n         EJECT\n         IHAASCB DSECT=YES\n         EJECT\n         IHAORE DSECT=YES\n         EJECT\n         IHAWQE DSECT=YES,FORMAT=OLD\n         EJECT\n         IHAPSA DSECT=YES,LIST=YES\n         EJECT\nTIOT     DSECT\n         IEFTIOT1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COPYLNES": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\t!\\x00(\\x00(\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T09:21:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/*    Name     - COPYLNES                                             */\n/*    Author   - James A. Williams                                    */\n/*    Date     - 01/02/96                                             */\n/*    Purpose  - COPY LINES BEFORE EXISTING LINES                     */\n/*    Invoke   - EDIT MACRO      COPYLNES 'TO BE COPIED'              */\n/*                                                                    */\n/**********************************************************************/\nCOPY_LINE:\nADDRESS ISPEXEC\n'ISREDIT MACRO (WRITE) PROCESS'\n\"ISREDIT (DSN) = DATASET\"\nFIRST  = 0\nSECOND = 0\nIF WRITE = \"\"\n  THEN\n    WRITE = ' XXXXX'\n\"ISREDIT (FIRST) = LINENUM .ZFIRST\"\n\"ISREDIT (LAST) = LINENUM .ZLAST\"\nIF LAST < 1  THEN\n  DO\n    ZEDLMSG = \"MUST HAVE AT LEAST ONE LINE IN FILE\"\n    SIGNAL CLOSE\n  END\n\"ISREDIT LINE_AFTER 0 =  \"WRITE\"\"\nDO (LAST - 1)\n    SECOND = SECOND + 2\n    \"ISREDIT LINE_AFTER \"SECOND\" =  \"WRITE\"\"\n    FIRST = FIRST + 1\nEND\n\nADDRESS ISPEXEC\n\nZEDLMSG = \"\"DSN\" IS UPDATED WITH NEW LINES\"\n\nCLOSE:\n\"SETMSG MSG(ISRZ000)\"\nEXIT\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DMPGENER": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\t&\\x007\\x007\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T09:26:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*       This exec will read a file and create dss copies            **/\n/**********************************************************************/\n/* executil ts  */\nIndsn = oprjaw0.smpeout\nOutdsn = oprjaw0.rsvp\ndsncnt1 = 0                          /* volumes in dss arrary     */\n\nDsnin:\n\"Alloc fi(input) dsname('\"indsn\"') shr reuse\"\n\"Execio * diskr input (stem dssrec. finis\"\n\"Free fi(input)\"\n\n\"Newstack\"                          /* clear stack to use later   */\n\nDss_process:\n   Call Dsstack                     /* write to stack             */\nDo I=1 to dssrec.0                  /* loop to find the variable  */\n   Dssdsn = substr(dssrec.i,1,44)\n   Dssdsn = strip(dssdsn,t)         /* get rid of trailing blanks */\n   Dsnvol = substr(dssrec.i,46,6)\n   Call Dsstack2                    /* write to stack             */\nEnd\n\nCall Dsstack3                    /* write to stack             */\n\nCall Dsswrit     /* write the stack and close out       */\nExit             /* turn out the light the parties over */\n\nDsstack:\nQueue \" DUMP   OUTDDNAME(CART)                    -\"\nQueue \"        DATASET(INCLUDE(                   -\"\nReturn\n\nDsstack2:\nQueue \"                         \"dssdsn\"          -\"\nReturn\n\nDsstack3:\nQueue \"                  ))                       -\"\nQueue \"        TOL(ENQF)                           \"\nReturn\n\nDsswrit:\nDsscnt1 = dssrec.0\n\"Alloc fi(output) dsname('\"outdsn\"') shr reuse\"\nHow_many = queued()\n\"Execio\" how_many  \"diskw output (finis\"\n\"Delstack\"\n\"Free ddname(output)\"\n     Say \"===================================================\"\n     Say \"= Total dfdss control cards created are \"dsscnt1\"        =\"\n     Say \"===================================================\"\nReturn\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FTAILSMF": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01A\\x00\\x00\\x00\\x99%\\x8f\\x00\\x99'\\x9f\\x07X\\x016\\x00\\x8e\\x00\\xf6\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@\"", "ispf": {"version": "01.65", "flags": 0, "createdate": "1999-09-15T00:00:00", "modifydate": "1999-10-06T07:58:00", "lines": 310, "newlines": 142, "modlines": 246, "user": "OPRJAW0"}, "text": "         TITLE 'FTAILSMF - FILE TAILORING FOF ISPF'\n********************************************************\n* NAME: FTAILSMF                                       *\n*                                                      *\n* PURPOSE:  THIS PROGRAM WILL TAKE INPUT FROM A PANEL  *\n*           AND USE THAT TO TAILOR SMF SUBMIT JCL.     *\n*           OF COURSE, THIS PROGRAM IS EASILY DONE     *\n*           FROM REXX WHICH IS INCLUDED TO SHOW        *\n*           THE CONTRAST. I WILL SOON BE ADDING MORE   *\n*           FUNCTION TO IT.                            *\n*                                                      *\n* AUTHOR:   JAMES A. WILLIAMS                          *\n*           TECH SUPPORT                               *\n*                                                      *\n* MACLIBS:  SYS1.AMODGEN AND SYS1.MACLIB               *\n*                                                      *\n* DIRECTIONS: ASSEMBLE PROGRAM AND LINK. COPY THE BELOW*\n* PANEL TO AN ISPPLIB AND THE SKELTON TO AN ISPSLIB    *\n********************************************************\n         AMODE 31\n         RMODE ANY\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n********************************************************\n* STANDARD LINKAGE                                     *\n********************************************************\nFTAILSMF CSECT\n         SAVE (14,12)\n         LR    R12,R15\n         USING FTAILSMF,R12\n         ST    R13,SAVEAREA+4\n         LA    R15,SAVEAREA\n         ST    R15,8(,R13)\n         LR    R13,R15\n********************************************************\n* TEST FOR A VALID ISPF ENVIRONMENT                    *\n********************************************************\nTESTISPF DS    0H\n         CALL  ISPQRY\n         LTR   R15,R15\n         BZ    VDEFINEV\n         TPUT  ERRMSG1,L'ERRMSG1\n         TPUT  ERRMSG2,L'ERRMSG2\n         B     EXIT\n********************************************************\n* DEFINE ALL THE ISPF VARIABLES WHICH WILL BE USED.    *\n********************************************************\nVDEFINEV DS    0H\n         CALL  ISPLINK,(CONTROL,ERRORS,RETURN),VL\n         CALL  ISPLINK,(VDEFINE,XDSNAME1,DSNAME1,CHAR,L44),VL\n         CALL  ISPLINK,(VDEFINE,XDSNAME2,DSNAME2,CHAR,L44),VL\n         CALL  ISPLINK,(VDEFINE,TEMPDSN,ZTEMPF,CHAR,L44),VL\n         CALL  ISPLINK,(VDEFINE,XSMFTY1,SMFTY1,CHAR,L2),VL\n         CALL  ISPLINK,(VDEFINE,XSMFTY2,SMFTY2,CHAR,L2),VL\n         CALL  ISPLINK,(VDEFINE,DATAID,DATA,CHAR,L8),VL\n         CALL  ISPLINK,(VDEFINE,TEMPDDN,ZTEMPN,CHAR,L8),VL\n         CALL  ISPLINK,(VDEFINE,ZUSERX,ZUSER,CHAR,L7),VL\n         CALL  ISPLINK,(VDEFINE,ZACCTNUX,ZACCTNUM,CHAR,L7),VL\n         MVC   MSG,MSG1\n********************************************************\n* DISPLAY PANEL TO OBTAIN INPUT FROM THE USER.         *\n********************************************************\nDISPLAYP DS    0H\n         CALL  ISPLINK,(DISPLAY,SMFPANEL,MSG),VL\n         LTR   R15,R15\n         BZ    FTAILOR\n         C     R15,=F'8'\n         BE    VDELETEV\n********************************************************\n* PERFORM FILE TAILORING IF  PROCESSES                 *\n********************************************************\nFTAILOR  DS    0H\n*\n         CALL  ISPLINK,(VGET,ZUSERX,SHARED),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(VGET,ZACCTNUX,SHARED),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(VGET,ZSTDYEAX,SHARED),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(VGET,ZSYSIDX,SHARED),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(FTOPEN,TEMP),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(FTINCL,SKELETON),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(FTCLOSE),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(VGET,TEMPDDN,SHARED),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(VCOPY,XDSNAME1,L44,TESTX,MOVE),VL\n*\n********************************************************\n* USER LMF SEVICES TO EDIT THE DATASET                 *\n********************************************************\n*\n         CALL  ISPLINK,(LMINIT,DATAID,B,B,B,B,B,B,B,ZTEMPN),VL\n         LTR   R15,R15\n         BNZ   EXIT\n*\n         CALL  ISPLINK,(EDIT,B,B,B,B,B,B,DATA),VL\n         LTR   R15,R15\n         C     R15,=F'4'\n         BH    EXIT\n*\n         CALL  ISPLINK,(LMFREE,DATA),VL\n         LTR   R15,R15\n         BNZ   EXIT\n********************************************************\n* RETURN TO PANEL DISPLAY TO REPEAT PROCESS IF NEEDED  *\n********************************************************\nRDISPLAY DS    0H\n         MVC   MSG,MSG2\n         B     DISPLAYP\n********************************************************\n* CLEANUP TO PREPARE FOR EXIT                          *\n********************************************************\nVDELETEV DS    0H\n         CALL  ISPLINK,(VDELETE,CLEANUP),VL\n         CALL  ISPLINK,(SETMSG,MSGX),VL\n********************************************************\n* CODE TO EXIT FROM FTAILSMF                           *\n********************************************************\nEXIT     DS    0H\n         SR    R15,R15\n         L     R13,4(,R13)             RELOAD --> TO OLD SAVE\n         RETURN (14,12),RC=(15)\n********************************************************\n* DEFINE CONSTANTS, DSECT AND ISPF VARIABLES           *\n********************************************************\nSAVEAREA DS    18F\nZUSER    DS    CL7\nZTEMPF   DS    CL44\nZTEMPN   DS    CL8\nZACCTNUM DS    CL8\nDATA     DS    CL8\n         LTORG\nDISPLAY  DC    CL8'DISPLAY '\nVDEFINE  DC    CL8'VDEFINE '\nVDELETE  DC    CL8'VDELETE '\nVGET     DC    CL8'VGET    '\nVCOPY    DC    CL8'VCOPY   '\nFTOPEN   DC    CL8'FTOPEN  '\nFTINCL   DC    CL8'FTINCL  '\nFTCLOSE  DC    CL8'FTCLOSE '\nLMINIT   DC    CL8'LMINIT  '\nEDIT     DC    CL8'EDIT    '\nLMFREE   DC    CL8'LMFREE  '\nSETMSG   DC    CL8'SETMSG  '\nSHARED   DC    CL8'SHARED  '\nCONTROL  DC    CL8'CONTROL '\nERRORS   DC    CL8'ERRORS  '\nRETURN   DC    CL8'RETURN  '\nMOVE     DC    CL8'        '\nLOCATE   DC    CL8'        '\nCHAR     DC    C'CHAR'\nTEMP     DC    C'TEMP      '\nMSG      DC    CL8' '\nL2       DC    F'2'\nL7       DC    F'7'\nL8       DC    F'8'\nL44      DC    F'44'\n         LTORG\nXSMFTY1  DC    C'(SMFTY1)'\nXDSNAME1 DC    C'(DSNAME1)'\nXSMFTY2  DC    C'(SMFTY2)'\nXDSNAME2 DC    C'(DSNAME2)'\nSMFTY1   DC    CL2' '\nDSNAME1  DC    CL44' '\nSMFTY2   DC    CL2' '\nDSNAME2  DC    CL44' '\nSMFPANEL DC    CL8'FTAILSMF'\nSKELETON DC    CL8'FTAILSMF'\nMSG1     DC    CL8'FTA001A '\nMSG2     DC    CL8'FTA002A '\nMSGX     DC    CL8'FTA003A '\nB        DC    CL1' '\nDATAID   DC    C'DATA    '\nTESTX    DC    CL44' '\nTEMPDDN  DC    C'(ZTEMPN)'\nTEMPDSN  DC    C'(ZTEMPF)'\nZUSERX   DC    C'(ZUSER)'\nZACCTNUX DC    C'(ZACCTNUM)'\nZSTDYEAX DC    C'(ZSTDYEAR)'\nZSYSIDX  DC    C'(ZSYSID)'\nCLEANUP  DC    C'(*)'\nERRMSG1  DC    C'ISPF IS NOT ACTIVE KNUCKLEHEAD'\nERRMSG2  DC    C'PLEASE INVOKE THIS PROGRAM FROM ISPF OPTION 6.'\n*        CVT PREFIX=YES\n         END FTAILSMF\n*\n*\n*   PUT PANEL IN ISPPLIB AS FTAILSMF\n*\n)ATTR\n  ~ TYPE(TEXT) INTENS(HIGH) COLOR(TURQ) HILITE(REVERSE)\n  @ TYPE(TEXT) INTENS(HIGH) COLOR(YELLOW)\n  % TYPE(TEXT) INTENS(HIGH) COLOR(BLUE)\n  + TYPE(TEXT) INTENS(HIGH) COLOR(WHITE)\n)BODY\n+------------------------  SMF JCL Generator   -------------------------\n+OPTION  ===>_ZCMD\n%\n+                                                       ~USERID - &ZUSER\n~\n+ ~SMF input  +%===>+ _dsname1                             +\n+ ~SMF output +%===>+ _dsname2                             +\n+ ~SMFTYPE    +%===>+ _smfty1+   (14,15,30,etc,)\n~\n+\n%\n+-----------------------------------------------------------------------\n%\n%  Enter+END%command to terminate from option line\n)INIT\n  .HELP = ISR00003\n  .CURSOR = DSNAME1\n  &DSNAME1 = ''\n  &DSNAME2 = ''\n  &SMFTY1  = ''\n  &ZHTOP = ISR00003   /* TUTORIAL TABLE OF CONTENTS        */\n  &ZHINDEX = ISR91000 /* TUTORIAL INDEX - 1ST PAGE         */\n  &ZSCLMPRJ = &Z      /* TUTORIAL INDEX - 1ST PAGE     @L1A*/\n  VPUT (ZHTOP,ZHINDEX,ZSCLMPRJ) PROFILE /*             @L1C*/\n\n)PROC\n  VER(&DSNAME1,LEN,NG,44)\n  VER(&DSNAME1,NB,DSNAME)\n  VER(&DSNAME2,LEN,NG,44)\n  VER(&DSNAME2,NB,DSNAME)\n  VER(&SMFTY1,NB,RANGE,1,255)\n)END\n*\n*\n*   PUT SKELETON IN ISPSLIB AS FTAILSMF\n*\n//&ZUSER.A JOB (&ZACCTNUM),'&ZUSER-SMFSTRIP',CLASS=Z,MSGCLASS=R,\n//   NOTIFY=&ZUSER         ALL JOBS NEED ONE\n//SMFSTRIP PROC\n//SMFSTRIP EXEC PGM=IFASMFDP,REGION=32M\n//DUMPIN   DD DSN=&DSNAME1,DISP=SHR,DCB=BUFNO=15\n//DUMPOUT  DD DSN=&DSNAME2,DISP=SHR,DCB=BUFNO=15\n//SYSPRINT DD SYSOUT=*\n// PEND\n//SMFRUN EXEC SMFSTRIP\n//SYSIN  DD *\n INDD(DUMPIN,OPTIONS(DUMP))\n OUTDD(DUMPOUT,TYPE(&SMFTY1))\n DATE(&ZSTDYEAR.001,&ZSTDYEAR.366)\n SID(&ZSYSID)\n*\n*\n*   REXX VERSION OF FTAILSMF\n*\n/*REXX*****************************************************************/\n/*                                                                    */\n/*    NAME     - FTAILSMF                                             */\n/*    Author   - James A. Williams                                    */\n/*    Date     - 09/15/1999                                           */\n/*    Purpose  - PROTOTYPE FOR FTAILSMF                               */\n/*    INVOKE   - TSO %FTAILSMF                                        */\n/*                                                                    */\n/**********************************************************************/\nExecutil TS\nAddress ISPEXEC\n\"Control errors return\"\n\"Display panel(ftailsmf) msg(fta001a)\"\nIf RC > 0 Then Exit 8\n \"Ftopen temp\"\n \"Ftincl FTAILSMF\"\n \"Ftclose\"\n \"Vget (\"ztempf\")\"\nSay \"\"ztempf\"\"\n \"Vget (\"ztempn\")\"\nSay \"\"ztempn\"\"\n \"Lminit dataid(idvar) ddname(\"ZTEMPN\")\"\n \"Edit dataid(\"idvar\")\"\n \"Lmfree dataid(\"idvar\")\"\nExit\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ICEIEXIT": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x18\\x0f\\x07!\\x00\\xdc\\x00\\xdb\\x00\\x02\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-29T07:21:00", "lines": 220, "newlines": 219, "modlines": 2, "user": "OPRJAW0"}, "text": "ICEIEXIT CSECT\n         ICEDIEX\n***********************************************************************\n*                                                                     *\n*  ICEIEXIT - DFSORT INITIALIZATION ROUTINE TO REMOVE HIPERSPACES     *\n*             DURING PEAKTIME AND ALLOW DURING NIGHTLY BATCH AND      *\n*             DURING THE WEEKEND. GAINS CONTROL AT EACH SORT AREA     *\n*             PROVIDED THAT ICEMAC HAS BEEN UPDATED WITH IEXIT=YES    *\n*  OWNER      XXXXXXX XXXXXXXX XXXXXXX                                *\n*  ORIGINAL   IBM                                                     *\n*  CODER      JAMES  WILLIAMS   11-04-93                              *\n*  MOD        JAMES  WILLIAMS   06-09-99  Y2K                         *\n***********************************************************************\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\nICEIEXIT CSECT\n         USING *,R12                   DECLARE BASE REGISTER\n         STM   R14,R12,12(R13)         SAVE CALLERS REGS\n         LR    R12,R15                 LOAD BASE REGISTER\n         GETMAIN R,LV=DSECTLEN         GET MAIN TEMP AREA\n         ST    R13,4(R1)               STORE BACKWARD CHAIN\n         ST    R1,8(R13)               STORE FORWARD CHAIN\n         L     R14,24(R13)             RESTORE PASSED PARM ADDRESS\n         ST    R14,72(R1)              SAVE IN WORK AREA\n         LR    R13,R1                  LOAD SAVE AREA ADDRESS\n         USING SAVEAREA,R13            DECLARE SAVE AREA BASE\n         L     R1,SAVEPARM             RESTORE PARM ADDRESS\n         B     PROCESS                 BRANCH TO CODE\n         DC    CL8'&SYSDATE'\n         DC    CL8'&SYSTIME'\n         DC    CL8'ICEIEXIT'\n         DC    C' SORT INITIALIZATION EXIT'\n         DC    C'TECH SUPPORT'\nPROCESS  DS    0H\n         USING ILMN,R1\n         L     R2,ILMEXA\n         USING ILEXL,R2\n         L     R3,ILMINA\n         USING ILINL,R3\n         DROP  R1\nNOMODULE DS    0H             DEFAULT MODULE NOT FOUND\n         MVC   STORDAY(6),DEFAULTV    SO USE HARD CODED DEFAULTS\n*===============================================================*\n*==  DAYTEST   - UPGRADED THIS AGLORITHM TO SUPPORT           ==*\n*==              Y2K PROCESSING                               ==*\n*===============================================================*\nDAYTEST  TIME  DEC,ZONE=LT            NOT DETERMINE DATE AND TIME\n         ST    R0,HOUR                SAVE HOUR\n         ST    R1,DATE                STORE 0CYYDDDF\n         AP    DATE(4),=P'1900000'    GET YYYYDDDF\n         LH    R5,DATE                GET YEAR\n         SLL   R5,4                   SHIFT\n         LA    R5,15(R5)              ADD SIGN BITS\n         LH    R6,=P'19000'           EPOCH YEAR  1900\n         SLL   R6,4                   SHIFT\n         LA    R6,15(R6)              ADD SIGN BITS\n         XC    WTOWORK,WTOWORK        CLEAR WORK AREA\n         ST    R5,WTOWORK+4           SAVE PACKED DECIMAL CYEAR\n         CVB   R5,WTOWORK             GET IN BINARY\n         XC    WTOWORK,WTOWORK        CLEAR WORK AREA\n         ST    R6,WTOWORK+4           SAVE PACKED DECIMAL 1900\n         CVB   R6,WTOWORK             GET IN BINARY\n         SR    R5,R6                  CURRENT YEAR - 1900\n         ST    R5,SAVEREG             SAVE DIFFERENCE\n         MH    R5,=H'365'             MULTIPLY YEARS SINCE 1900 BY 365\n         ST    R5,SAVEREG+4           SAVE DAYS BEFORE LEAP YEAR ADDED\n         L     R3,SAVEREG             PREPARE FOR LEAPCHK\n         SR    R7,R7                  CLEAR FOR LEAPYEAR TOTAL\n*===============================================================*\n*==  LEAPCHK   - THIS SECTION OF CODE WILL DETERMINE          ==*\n*==              ALL THE LEAPYEARS TO CURRENT                 ==*\n*===============================================================*\nLEAPCHK  DS    0H\n         LR    R5,R6                  1900 ON FIRST RUN + 1 AFTER\n* IF YYYY // 400 = 0 THEN LY = 1\n         SR    R4,R4                  PREPARE REMAINDER AREA\n         D     R4,=F'400'             DIVIDE BY FOUR\n         C     R4,=F'0'               PASS LEAP YEAR TEST1\n         BE    LEAPYR\n* IF YYYY // 4 = 0 THEN LY = 1; ELSE LY = 0\nCHECK1   SR    R4,R4                  PREPARE REMAINDER AREA\n         LR    R5,R6                  1900 ON FIRST RUN + 1 AFTER\n         D     R4,=F'4'             DIVIDE BY FOUR\n         C     R4,=F'0'               PASS LEAP YEAR TEST1\n         BNE   NLEAPYR\n* IF YYYY // 100 = 0 THEN LY = 0\nCHECK2   SR    R4,R4                  PREPARE REMAINDER AREA\n         LR    R5,R6                  1900 ON FIRST RUN + 1 AFTER\n         D     R4,=F'100'             DIVIDE BY FOUR\n         C     R4,=F'0'               PASS LEAP YEAR TEST1\n         BE    NLEAPYR\nLEAPYR   DS    0H\n         AH    R7,=H'1'               ADD 1 BECAUSE A LEAP\nNLEAPYR  DS    0H\n         AH    R6,=H'1'               ADD 1 TO YEAR FOR TEST\n         BCTR  R3,0                   KEEP LOOPING UNTIL LEAPCHK DONE\n         C     R3,=F'0'               CHECK FOR FINISH LOOP\n         BE    LEAPDNE                YES, LEAP CHEAR DONE, TALLY\n         B     LEAPCHK                NO,  CHECK YEAR FOR LEAP\nLEAPDNE  DS    0H\n         L     R5,SAVEREG+4           RELOAD DAYS BEFORE LEAP YEARS\n         AR    R5,R7                  ADD LEAP YEARS TO YEARS*365\n         LH    R4,DATE+2              CURRENT JULIAN\n         XC    WTOWORK,WTOWORK        CLEAR WORK AREA\n         ST    R4,WTOWORK+4           SAVE PACKED DECIMAL\n         CVB   R4,WTOWORK             GET IN BINARY\n         AR    R5,R4                  ADD CURRENT YEAR TO TOTAL\n         XR    R4,R4                  CLEAR FOR WORK\n         D     R4,=F'7'               DAYS IN A WEEK\n         CL    R4,=F'6'               SATURDAY ?\n         BE    OFFDAY                 YES - USE WEEK-END VALUES\n         CL    R4,=F'0'               SUNDAY ?\n         BE    OFFDAY                 YES - USE WEEK-END VALUES\n         CLI   HOUR,X'08'             BEFORE 8AM\n         BL    OFFSHIFT               YES - USE OFFSHIFT VALUES\n         CLI   HOUR,X'17'             AFTER 5PM\n         BNL   OFFSHIFT               YES - USE OFFSHIFT VALUES\n         B     DAYSHIFT               OTHERWISE - USE DAYTIME VALUES\nDAYSHIFT DS    0H                     SET DAY-TIME VALUES\n         MVC   REASON,DAYTIME\n         LH    R1,STORDAY\n         B     HIPRMAX\nOFFDAY   DS    0H                     SET WEEK-END VALUES\n         MVC   REASON,WEEKEND\n         LH    R1,STORWKND\n         B     HIPRMAX\nOFFSHIFT DS    0H                     SET NIGHT-TIME VALUES\n         MVC   REASON,NITETIME\n         LH    R1,STORNITE\n         B     HIPRMAX\nHIPRMAX  DS    0H                     TEST AGAINST INSTALLATION VALUES\n         CH    R1,ILEXHIPR            COMPARE TO DEFAULTS\n         BH    DSPSIZE                BEYOND DEFAULTS\n         STH   R1,ILEXHIPR            ELSE SET NEW LIMIT\nDSPSIZE  DS    0H                     TEST AGAINST INSTALLATION VALUES\n         CH    R1,ILEXDSPZ            COMPARE TO DEFAULTS\n         BH    DEFAULTS               BEYOND DEFAULTS\n         STH   R1,ILEXDSPZ            ELSE SET NEW LIMIT\n         B     RETURN                 RETURN IF DEFAULT IS LOWER\nDEFAULTS DS    0H\n         MVC   REASON,DEFAULT\n         B     RETURN                 RETURN IF DEFAULT IS LOWER\nRETURN   DS    0H\nHSPWTO   MVC   STORMSG(WTOSKELL),WTOSKEL  MOVE TO MESSAGE AREA\n         MVC   STORTYPE,HPRMESS       HIPERSPACE\n         MVC   STORRESN,REASON        MOVE IN REASON\n         LH    R1,ILEXHIPR            GET CURRENT LIMIT\n         CVD   R1,WTOWORK             CONVERT TO DECIMAL\n         MVC   STORMAX,WTOMASK        GET EDIT MASK FOR HIPRMAX\n         ED    STORMAX,WTOWORK+4      FORMAT LIMIT\n         WTO   MF=(E,STORMSG)         WRITE TO PROGRAMMER\nDSPWTO   MVC   STORMSG(WTOSKELL),WTOSKEL  MOVE TO MESSAGE AREA\n         MVC   STORTYPE,DSPMESS       DATASPACE\n         MVC   STORRESN,REASON        MOVE IN REASON\n         LH    R1,ILEXDSPZ            GET CURRENT LIMIT\n         CVD   R1,WTOWORK             CONVERT TO DECIMAL\n         MVC   STORMAX,WTOMASK        GET EDIT MASK FOR DATASPACE\n         ED    STORMAX,WTOWORK+4      FORMAT LIMIT\n         WTO   MF=(E,STORMSG)         WRITE TO PROGRAMMER\n         LR    R1,R13                 ADDRESS WORK AREA\n         L     R13,4(R13)             GET CALLERS SAVE AREA\n         FREEMAIN R,LV=DSECTLEN,A=(1) FREE THE AREA\n         RETURN (14,12),RC=0       EXIT\n         EJECT\nDEFAULTV DC    H'00'                  HIPRMAX=0 AND DSPSIZE=0\n         DC    H'1000'                HIPERMAX=OPTIMAL AND DSPSIZE=MAX\n         DC    H'1000'                HIPERMAX=OPTIMAL AND DSPSIZE=MAX\nDAYTIME  DC    CL10'DAY TIME'\nNITETIME DC    CL10'NON PEAK  '\nWEEKEND  DC    CL10'WEEK-END  '\nDEFAULT  DC    CL10'DEFAULT   '\nHPRMESS  DC    CL7'HIPRMAX'\nDSPMESS  DC    CL7'DSPSIZE'\nWTOMASK  DC    X'4020202020202120'\nWTOSKEL  WTO   'XXXXXXX SET TO ???????? MEGABYTES - REASON =           *\n               ',ROUTCDE=11,MF=L\nWTOSKELE EQU   *\nWTOSKELL EQU   WTOSKELE-WTOSKEL\n         LTORG\nSAVEAREA DSECT\nSAVE     DS    18F\nSAVEPARM DS    F\nVALUADDR DS    F\nHOUR     DS    F\nDATE     DS    D\nDAYS     DS    F\nSAVEREG  DS    4F\nSTORDAY  DS    H\nSTORNITE DS    H\nSTORWKND DS    H\nWTOWORK  DS    D\nREASON   DS    CL10\nTYPE     DS    CL7\nSTORMSG  DS    0C\n         ORG   STORMSG+4\nSTORTYPE DS    CL7\n         ORG   STORMSG+19\nSTORMAX  DS    CL8\n         ORG   STORMSG+49\nSTORRESN DS    CL8\n         ORG   STORMSG+WTOSKELL\n         DS    0D\nDSECTLEN EQU   *-SAVE\n         END   ICEIEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEFUJI": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\x078\\x01Z\\x01Z\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T07:38:00", "lines": 346, "newlines": 346, "modlines": 0, "user": "OPRJAW0"}, "text": "         TITLE 'IEFUJI ACF2 ACCOUNT VERIFICATION'\nIEFUJI   CSECT\n* STATUS - CHANGE LEVEL 9  AGLC 10-21-96\n* STATUS - CHANGE LEVEL 8  AGLC 08-03-95\n* STATUS - CHANGE LEVEL 7  AGLC 06-05-95\n* STATUS - CHANGE LEVEL 6  AGLC 04-28-95\n* STATUS - CHANGE LEVEL 5  AGLC 03-25-93\n* STATUS - CHANGE LEVEL 4  AGLC 09-09-91\n* STATUS - CHANGE LEVEL 3  AGLC 08-26-91\n* STATUS - CHANGE LEVEL 2  AGLC 04-24-91\n* STATUS - CHANGE LEVEL 1  IBM  ?\n* FUNCTION\n*    THIS MODULE CALCULATES THE AMOUNT OF TIME THAT A JOB WAS\n*    ENQUEUED AWAITING INITIATION. THIS TIME AND THE EFFECTIVE JOB\n*    PRIORITY ARE WRITTEN TO THE SMF DATA SET AS RECORD TYPE 128.\n*    MODIFCATION ARE MADE TO THIS PROGRAM TO SUPPORT ACCOUNT\n*    VERIFICATION AT THE JOB LEVEL. ALL NON PRODUCTION USES MUST\n*    GET SUPPORT AT THE JOB LEVEL.\n* ENTRY POINTS -\n*         IEFUJI\n* INPUT\n*    REGISTER 1 POINTS TO A LIST OF 4 BYTE ADDRESSES FOR THE\n*    FOLLOWING FOUR PARAMETERS:\n*    1 - 36 BYTES OF THE FOLLOWING JOB INFORMATION:\n*    JOBNAME (8 BYTES)\n*    TIME STAMP (8 BYTES)\n*    SYSTEM ID (4 BYTES)\n*    USER ID (8 BYTES)\n*    USER COMMUNICATIONS AREA (4 BYTES)\n*    WHEN ENTERED, THIS FIELD CONTAINS THE TIME OF DAY\n*    AT WHICH THE JOB WAS ENQUEUED (SUPPLIED BY THE\n*    IEFUJV ROUTINE). THIS FIELD IS ZEROED BEFORE THE\n*    ROUTINE IS EXITED.\n*    2 - 20 BYTES CONTAINING THE PROGRAMMERS NAME\n*    3 - 1 BYTE INDICATING THE EFFECTIVE JOB PRIORITY\n*    4 - JOB ACCOUNTING FIELDS\n* OUTPUT\n*    A SMF RECORD IS WRITTEN TO THE SMF DATA SET USING THE\n*    SMFWTM MACRO. THE FORMAT OF THIS RECORD IS DESCRIBED BY THE\n*    DSECT FOR THE SMF RECORD.\n*    REGISTER 15 MUST CONTAIN ONE OF THE FOLLOWING RETURN CODES:\n*    0 - CONTINUE PROCESSING\n*    4 - CANCEL\n* EXTERNAL REFERENCES -  NONE\n* EXITS,NORMAL -  RETURN TO CALLER     RC=0\n* EXITS,ERROR - RETURN TO CALLER    RC=4 - CANCEL REQUEST\n* TABLES/WORK AREAS -  DSECT FOR SMF RECORD EMPLOYED\n* ATTRIBUTES - STANDARD\n* CHARACTER CODE DEPENDENCY - NONE\n* NOTES - GETMAIN FREEMAIN SMFWTM AND TIME MACROS WERE USED\n*         ACF2 AND PSA MAPPING MACROS WERE USED\n         EJECT\n         ACFREGS\nD0       EQU   0                       DISP OF 0\nD12      EQU   12                      DISP OF 12\nD16      EQU   16                      DISP OF 16\nD20      EQU   20                      DISP OF 20\nD31      EQU   31                      DISP OF 31\nD32      EQU   32                      DISP OF 32\nD97      EQU   97                      DISP OF 97\nD110     EQU   110                     DISP OF 110\nL1       EQU   1                       LENGTH OF 1\nL4       EQU   4                       LENGTH OF 4\nL6       EQU   6                       LENGTH OF 6\nL7       EQU   7                       LENGTH OF 7\nL8       EQU   8                       LENGTH OF 8\nL16      EQU   16                      LENGTH OF 16\nM2       EQU   2                       MASK OF 2\n*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --*\n         USING *,R15\n         B     HERE                    BRANCH AROUND EYECATCHERS\n         DC    CL8'IEFUJI'             MODULE NAME\n         DC    CL8'&SYSDATE'\n         DC    CL8'&SYSTIME'\nHERE     STM   R14,R12,D12(R13)        SAVE REGS\n         DROP  R15\n         BALR  R11,R0                  SET UP BASE\n         USING *,R11                   REGISTER\n         LM    R2,R4,D0(R1)            GET PARAMETER ADDRESSES\n         L     R7,12(R1)               POINTS AT ACCOUNT FIELD\n         L     R10,16(R1)              POINTS AT SUBSYS FIELD\n         L     R8,0(R1)                POINTS AT JMR\n         USING JMR,R8                  USING THE JMR\n         GETMAIN   R,LV=SMFLEN         GET CORE FOR SMF RECORD   A48478\n         LR    R5,R1\n         USING SMFDSECT,R5             BASE FOR SMF DSECT\n         GETMAIN   R,LV=WORKLEN        GET CORE FOR WTO PROCESS\n         LR    R12,R1\n         USING WTODSECT,R12            WTO DSECT DSECT\nSMFBEGN  DS    0H\n         TIME      BIN\n         ST    R0,TIME                 TIME FOR SMF RECORD\n         ST    R1,DATE                 DATE FOR SMF RECORD\n         MVC   ENQTIME(L4),D32(R2)     GET JOB ENQUEUE TIME\n         XC    D32(L4,R2),D32(R2)      ZERO COMMUNICATIONS WORD\n         C     R0,ENQTIME              CHECK FOR A NEW DAY\n         BC    M2,SAMEDAY              ENQUEUED SAME DAY\n         A     R0,HR24                 ADD 24 HOURS (86400 SECONDS)\nSAMEDAY  DS    0H\n         S     R0,ENQTIME              DETERMINE TIME JOB WAS ON QUEUE\n         ST    R0,ENQTIME              PUT TIME IN SMF RECORD\n         MVC   PRTY(L1),D0(R4)         GET PRIORITY CODE\n         MVC   SYSID(L4),D16(R2)       GET SYSTEM ID\n         MVC   HEADER(L6),SMFRCD       GET HEADER\n         MVC   JOBLOG(L16),D0(R2)      GET JOB LOG\n*        MVC   USERID(L8),D20(R2)      GET USER ID\n         MVC   CLASS(L1),D31(R2)       GET JOBCLASS\n         L     R2,16                   GET CVT POINTER\n         L     R3,0(R2)                GET TCB WORDS\n         L     R4,12(R3)               GET CURRENT ASCB POINTER\n         L     R6,172(R4)              GET POINTER TO JOBNAME\n         LTR   R6,R6                   IS  IT BATCH\n         BZ    RETURN0                 NO, EXIT\n         ACFINCVT R3,NONE=RETURN0      FIND ACF2 CVT\n         USING ACCVT,R3                ADDRESS IT\n         ACFGUCB R4,NONE=RETURN0,      GET ACF2 ACUCB                  X\n               INLINE=YES,SYS=AOS2\n         USING ACUCB,R4                ADDRESS ACUCB\n         L     R6,ACULRECP             POINT AT LOGONID RECORD\n         USING LIDREC,R6               ADDRESS LOGONID\n         MVC   JOBNAME,JMRJOB          MOVE JOBNAME FROM JMR\n         MVC   USERID,LIDLID           POINT TO LOGONID\n         MVC   ACFACCT,LIDACCT         MOVE ACF ACCOUNT NUMBER\n         MVC   JOBACCT,2(R7)           GET JOB ACCOUNT NUMBER\n         MVC   SUBSYS(4),0(R10)        SUBSYSTEM\n         CLC   SUBSYS(4),=C'ASCH'      IS IT AN APPC JOB\n         BE    RETURN0                 YES, EXIT\n         CLC   SUBSYS(4),=C'OMVS'      IS IT AN OMVS JOB\n         BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(4),=C'1111'     RESERVED\n         BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(4),=C'2222'     APPC\n         BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(4),=C'3333'     EMERGENCY BYPASS\n         BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(4),=C'4444'     IS IT RJEJOB\n         BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(4),=C'5555'     IS IT JOBTRAC OR OTHERS\n         BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(7),=C'1550SYS'  IS IT CICS\n         BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(7),=C'9999PCI'  IS IT CICS PRODREG\n         BE    PCICCHK                 YES, VALIDATE\n         CLC   ACFACCT(7),=C'9999TCI'  IS IT CICS TESTREG\n         BE    DCICCHK                 YES, VALIDATE\n*        CLC   ACFACCT(7),=C'1543TSM'  IS IT MVS TECH\n*        BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(7),=C'9999MUS'  IS IT ROSCOE\n         BE    RETURN0                 YES, EXIT\n         CLC   ACFACCT(4),=C'7777'     NON-TSO OR NON-CICS BATCH\n         BE    PSTCCHK                 YES, VALIDATE\n*        CLC   ACFACCT(4),=C'8888'     IS IT TSO BATCH PRODUCTION*TMP*\n*        BE    PTSOCHK                 YES, CHECK FOR TSO        *TMP*\n         CLC   ACFACCT(4),=C'9999'     IS IT CICS BATCH PRODUCTION\n         BE    PCICCHK                 YES, VALIDATE\nAGLJOBN  DS    0H\n         LR    R2,R7                   POINT AT JOB ACCOUNT NUMBER\n         LA    R8,8                    MAXIMUM LENGTH OF LOGONID\n         LA    R9,LIDLID               POINT TO LOGONID\nLIDLOOP  CLI   0(R9),C' '              BLANK YET\n         BE    LIDBLNK                 YES - STOP SCAN\n         LA    R9,1(R9)                POINT TO NEXT CHARACTER\n         BCT   R8,LIDLOOP              AND AROUND AGAIN\nLIDBLNK  LA    R8,LIDLID               POINT TO LOGONID\n         SR    R9,R8                   COMPUTE LENGTH OF LOGONID\n         BCTR  R9,R0                   SUBTRACT ONE FOR EX INST\n         CLC   LIDLID+6(1),=C'1'       CHECK FOR MULTIPLE LIDS\n         BNL   LIDMULT                 HAS A MULTI-LID\nLIDCOMP  EX    R9,COMPLID              COMPARE ON LOGONI\n         BNE   BADNAM\nAGLACCT  DS    0H\n*        CLI   0(R2),X'01'             IS IT MORE THAN 1 ACCT FIELD\n*        BNE   BADDEV                  YES, FAIL IT\n*        CLI   1(R2),X'07'             IS ACCT FIELD SEVEN BYTES\n*        BNE   BADDEV                  YES, FAIL IT\n*        MVC   JOBACCT,2(R2)           GET JOB ACCOUNT NUMBER\n         CLC   ACFACCT(4),=C'8888'     IS IT TSO BATCH PRODUCTION\n         BE    PTSOCHK                 YES, PROD ACCOUNT CHECKS\n         B     DTSOCHK                 NO, I/S ACCOUNT CHECKS\nPSTCCHK  CLC   ACFACCT(4),JOBACCT      CHECK JOBCARD AND ACF2 EQUAL\n         BNE   BADSTC                  YES, CHECK FOR GOOD STC ACCT\n         CLC   CLASS,=C'F'             IS IT STC BTATCH CLASS F\n         BE    RETURN0                 PASS ON THRU\n         B     BADSTC\nPTSOCHK  CLC   ACFACCT(4),JOBACCT      CHECK JOBCARD AND ACF2 EQUAL\n         BNE   BADTSO                  YES, CHECK FOR GOOD TSO ACCT\n         CLC   CLASS,=C'G'             IS IT FAST    CLASS G\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'C'             IS IT SLOW    CLASS C\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'R'             IS IT EMERGENCY\n         BE    RETURN0                 PASS ON THRU\n         B     BADTSO\nPCICCHK  CLC   ACFACCT(4),JOBACCT      CHECK JOBCARD AND ACF2 EQUAL\n         BNE   BADCIC                  YES, CHECK FOR GOOD CICS ACCT\n         CLC   CLASS,=C'Q'             IS IT CICS BATCH CLASS Q\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'5'             IS IT SYS CICS JOBS\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'1'             IS IT SYS CICS JOBS\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'L'             IS IT SYS CICS JOBS  SPECIAL\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'M'             IS IT SYS CICS JOBS  SPECIAL\n         BE    RETURN0                 PASS ON THRU\n         B     BADCIC\nDCICCHK  CLC   ACFACCT(4),JOBACCT      CHECK JOBCARD AND ACF2 EQUAL\n         BNE   BADTIC                  YES, CHECK FOR GOOD CICS ACCT\n         CLC   CLASS,=C'Z'             IS IT TCICS BATCH CLASS Z\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'1'             IS IT TCICS BATCH CLASS  1\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'2'             IS IT TCICS BATCH CLASS  2\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'3'             IS IT TCICS BATCH CLASS  3\n         BE    RETURN0                 PASS ON THRU\n         CLC   CLASS,=C'4'             IS IT TCICS BATCH CLASS  4\n         BE    RETURN0                 PASS ON THRU\n         B     BADTIC\nDTSOCHK  CLC   ACFACCT(7),JOBACCT      CHECK JOBCARD AND ACF2 EQUAL\n         BE    CISACCT                 YES, CHECK FOR GOOD CIS ACCT\n         CLC   ACFACCT+4(3),=C'CIS'    IS IT CIS IN ACF2\n         BE    BADCIS                  YES, FORMAT CIS  AND KILL\n         CLC   ACFACCT+4(3),=C'CIT'    IS IT CIT IN ACF2\n         BE    BADCIS                  YES, FORMAT CIS  AND KILL\n         CLC   ACFACCT+4(3),=C'FIS'    IS IT FIS IN ACF2\n         BE    BADCIS                  YES, FORMAT CIS  AND KILL\n         CLC   ACFACCT+4(3),=C'FIT'    IS IT FIT IN ACF2\n         BE    BADCIS                  YES, FORMAT CIS  AND KILL\n         B     BADDEV                  NO,  FORMAT REGULAR AND KILL\nCISACCT  CLC   ACFACCT+4(3),=C'CIS'    IS IT CIS IN ACF2\n         BE    CHECK2                  YES,GO CHECK SPECIAL CLASS\n         CLC   ACFACCT+4(3),=C'CIT'    IS IT CIT IN ACF2\n         BE    CHECK2                  YES,GO CHECK SPECIAL CLASS\n         CLC   ACFACCT+4(3),=C'FIS'    IS IT FIS IN ACF2\n         BE    CHECK2                  YES,GO CHECK SPECIAL CLASS\n         CLC   ACFACCT+4(3),=C'FIT'    IS IT FIT IN ACF2\n         BE    CHECK2                  YES,GO CHECK SPECIAL CLASS\nCHECKZ   CLC   CLASS,=C'Z'             REGULAR DEVELOPMENT  CLASS\n         BNE   BADDEV                  NO, CANCEL IT\n         B     RETURN0                 YES, GOOD BOY\nCHECK2   CLC   CLASS,=C'2'             IS IT SPECIAL CLASS 2\n         BE    RETURN0                 PASS ON THRU\nCHECK3   CLC   CLASS,=C'3'             IS IT SPECIAL CLASS 3\n         BE    RETURN0                 PASS ON THRU\nCHECK4   CLC   CLASS,=C'4'             IS IT SPECIAL CLASS 4\n         BE    RETURN0                 PASS ON THRU\nBADCIS   MVC   WTODIS(WTOLENC),WTOSKELC\n         B     RETURN4\nBADNAM   DS    0H\n         MVC   WTODIS(WTOLEN),WTOSKEL\n         B     RETURN4\nBADDEV   DS    0H\n         MVC   WTODIS(WTOLEN2),WTOSKEL2\n         B     RETURN4\nBADTSO   DS    0H\n         MVC   WTODIS(WTOLEN3),WTOSKEL3\n         B     RETURN4\nBADSTC   DS    0H\n         MVC   WTODIS(WTOLEN4),WTOSKEL4\n         MVC   WTODIS+33(1),=C'F'\n         B     RETURN4\nBADCIC   DS    0H\n         MVC   WTODIS(WTOLEN4),WTOSKEL4\n         MVC   WTODIS+33(1),=C'Q'\n         B     RETURN4\nBADTIC   DS    0H\n         MVC   WTODIS(WTOLEN4),WTOSKEL4\n         MVC   WTODIS+33(1),=C'Z'\n         B     RETURN4\nCOMPLID  CLC   LIDLID(0),JOBNAME\nLIDMULT  DS    0H\n         BCTR  R9,R0                   SUBTRACT ONE FOR EX INST\n         B     LIDCOMP\nRETURN0  DS    0H\n         LA    R10,0\n         MVC   STATUS,=C'Y'\n         B     EXIT\nRETURN4  DS    0H\n         LA    R10,4                   CAN BE CHANGED\n         MVC   STATUS,=C'N'            NOT A GOOD JOBCARD\n         MVC   WTODIS+18(7),LIDACCT\n         MVC   WTODIS+48(7),LIDLID\n         WTO   MF=(E,WTODIS)\nEXIT     DS    0H\n         LA    R1,SMFOUT               GET SMF BUFFER @\n         SMFWTM    (1)                 WRITE SMF RECORD TYPE 128\n         LR    R1,R5                   RELOAD FREEMAIN\n         FREEMAIN  R,LV=SMFLEN,A=(1)\n         LR    R1,R12                  RELOAD FREEMAIN\n         FREEMAIN  R,LV=WORKLEN,A=(1)\n         LR    R15,R10\n         RETURN (14,12),RC=(15)        RETURN AND CANCEL\n*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --*\n*   DEFINE DATA CONSTANTS                                             *\n*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --*\nHR24     DC    F'8640000'              24 HRS IN SECS\nSMFRCD   DC    X'006C00000280'         SMF RECORD TYPE 128     @YM04803\nWTOSKEL  WTO   'AGL001 - ACCT ????    AND JOBNAME PREFIXED  ??????? IS X\n               NEEDED ',ROUTCDE=(11),MF=L\nWTOLEN   EQU  *-WTOSKEL\nWTOSKEL2 WTO   'AGL002 - ACCT ????   , CLASS Z, AND USERID  ??????? IN X\n               JOBNAME',ROUTCDE=(11),MF=L\nWTOLEN2  EQU  *-WTOSKEL2\nWTOSKEL3 WTO   'AGL003 - ACCT ????   , CLASS G OR C, USERID ??????? IN X\n               JOBNAME',ROUTCDE=(11),MF=L\nWTOLEN3  EQU  *-WTOSKEL3\nWTOSKEL4 WTO   'AGL004 - ACCT ????   , CLASS ? FROM USERID  ??????? IS X\n               NEEDED ',ROUTCDE=(11),MF=L\nWTOLEN4  EQU  *-WTOSKEL4\nWTOSKELC WTO   'AGL00C - ACCT ????   , CLASS 2,3, OR 4 WITH ??????? IN X\n               JOBNAME',ROUTCDE=(11),MF=L\nWTOLENC  EQU  *-WTOSKELC\n         LTORG\n*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --*\n*   DEFINE DSECT FOR JOB INITIATION RECORD (TYPE X'80')               *\n*-- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --*\nWTODSECT DSECT\nWTODIS   DS    CL69\nWORKLEN  EQU  *-WTODSECT\nSMFDSECT DSECT\n         DS    1H                      ALIGN TIME/DATE ON FWD\nSMFOUT   EQU   *\nHEADER   DS    6C                      HEADER\nTIME     DS    1F                      TIME\nDATE     DS    1F                      DATE\nSYSID    DS    1F                      SYSTEM ID\nJOBLOG   DS    4F                      JOB LOG\nUSERID   DS    CL8                     USER ID FROM ACF2\nENQTIME  DS    1F                      ENQUEUE TIME\nPRTY     DS    1C                      PRIORTY\nJOBNAME  DS    CL8                     JOBNAME FROM JES2\nCLASS    DS    CL1                     JOBCLASS ON CARD\nJOBACCT  DS    CL7                     ACCOUNT NUMBER  FROM SMF\nACFACCT  DS    CL40                    ACCOUNT NUMBER  FROM ACF\nSTATUS   DS    CL1                     Y FOR SUCCESS AND N FOR FAILED\nSUBSYS   DS    CL4                     SUBSYSTEM\nSMFLEN   EQU   *-SMFDSECT\n         LIDREC                        LOGONID RECORD\n         ACUCB                         ACF UCB\n         ACFASVT                       ACF SSVT\n         ACCVT                         ACF CVT\n         IHAPSA                        PREFIX SAVE AREA\n         IHAASCB                       ADDRESS SPACE CONTROL BLOCK\n         IEFJMR                        JOB MANAGEMENT RECORD\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOBID": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x99'\\x9f\\x00\\x99'\\x9f\\x08\\x04\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-10-06T00:00:00", "modifydate": "1999-10-06T08:04:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/*    Name     - JOBID                                                */\n/*    Author   - James A. Williams                                    */\n/*    Date     - 09/29/1999                                           */\n/*    Purpose  - OBTAIN JOBID from SSIBJBID                           */\n/*    Invoke   - TSO JOBID                                            */\n/*                                                                    */\n/**********************************************************************/\n/* PURPOSE:  FIND THE CURRENT USERS JOBID FROM THE SSIBJBID           */\n/*=+==================================================================*/\n\nDCL_VARS:\n\nX1   =    X2D(1)\nXB4  =    X2D(B4)\nX13C =    X2D(13C)\nXC   =    X2D(C)\n\nmainline:\n\nExecutil ts\nCVTADR  = C2X(STORAGE(10,4))                    /* CVT L 2,X'10'    */\nCVTTCBP = C2X(STORAGE(D2X(X2D(CVTADR)+X1),3))   /* CTCBP LA 2,0(2)  */\nTCBADDR = C2X(STORAGE(D2X(X2D(CVTTCBP)),4))     /* CTCB L 2,0(R2)   */\nTCBJSCB = C2X(STORAGE(D2X(X2D(TCBADDR)+XB4),4)) /* TCBJ L 2,X'B4'(2)*/\nJSCBSSIB= C2X(STORAGE(D2X(X2D(TCBJSCB)+X13C),4))/* SSIB L 2,X'13C(2)*/\nJOBID   = C2X(STORAGE(D2X(X2D(JSCBSSIB)+XC),8)) /* JOID L R2,X'C'(2)*/\nJOBID   = X2C(JOBID)                            /* CONVERT TO CHAR  */\nSAY JOBID\nRETURN\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MSGCHECK": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x99\\x03_\\x00\\x99\\x03_\\x163\\x00\"\\x00\\x0f\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1999-02-04T00:00:00", "modifydate": "1999-02-04T16:33:00", "lines": 34, "newlines": 15, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/*    NAME     - MSGCHECK                                             */\n/*    AUTHOR   - James A. Williams                                    */\n/*    DATE     - 02/04/1999                                           */\n/*    PURPOSE  - CHECK MPF AND VERIFY MESSAGE                         */\n/*    INVOKE   - VIA TSOBATCH                                         */\n/*                                                                    */\n/**********************************************************************/\n/*    Results                                                         */\n/*    RC = 0    IEAVMXIT ACTIVE                                       */\n/*    RC = 4    IEAVMXIT INACTIVE OR ABENDED                          */\n/**********************************************************************/\nCONSOLE_CHECK:\n\"CONSPROF SOLDISP(NO) SOLNUM(400)\"\n\"CONSOLE ACTIVATE\"\n\"CONSOLE SYSCMD(D MPF)\"\nRC = GETMSG(\"LINE.\",,,,20)\n\"CONSOLE DEACTIVATE\"\nCONSOLE_LOOP:\nRC = 4\nDO I = 1 TO LINE.0\n   MPFCHK = INDEX(LINE.I,\"(IEAVMXIT) ACTIVE\")\n   IF MPFCHK = 0\n     THEN\n       ITERATE\n   ELSE\n      DO\n       RC = 0\n       LEAVE I\n      END\nEND\nSAY RC\nEXIT RC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PCOPY": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x18\\x0f\\x00\\x99\\x18\\x0f\\x08\\x05\\x00e\\x00e\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-29T00:00:00", "modifydate": "1999-06-29T08:05:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*    edit macro to copy to an edited pds from proclib or a pds       */\n/*    example: pcopy temp copies from proclib member temp to current  */\n/*             pds                                                    */\n/*    example: pcopy 'uid.temp(x)' copies member x        to current  */\n/*             pds                                                    */\n/**********************************************************************/\nAddress ISPEXEC\n'ISREDIT MACRO (DATAII) NOPROCESS'\n\"Isredit (dsname) = dataset\"\nRight = \")\"\nLeft = \"(\"\nDataii = translate(dataii)\nAddress tso \"allocate da('\"dsname\"') fi(list) shr reus\"\nDummy = Listdsi(list file)\nAddress tso \"free fi(list)\"\n\nIf sysdsorg \\= PO then\n    Do\n      Zedsmsg = \"Target not a pds\"\n      Zedlmsg = \"Xcopy command only works when used\",\n                \"within a dataset with dsorg po\"\n      \"Setmsg msg(isrz001)\"\n      Exit 12\n    End\n\nIf length(dataii) <= 8 & dataii \\= \"\"  Then\n  Do\n   Proc.1 = cpac.proclib\n   Proc.2 = sys1.proclib\n   Proc.3 = sys4.pp1tec.proclib\n   Proc.4 = sys4.pp1prd.proclib\n   Proc.5 = sys4.pp1cis.proclib\n   Proc.6 = sys4.pp1dev.proclib\n   Proc.7 = sys4.tp1cis.proclib\n    Do I = 1 to 7\n      Pdsn = \"'\"||proc.i||left||dataii||right||\"'\"\n      If sysdsn(pdsn) = 'OK'\n        Then\n          Signal Makedsn\n    End\n      Call baddsn\n      Exit 12\n  End\n\n  If sysdsn(dataii) \\= 'OK' Then\n     Do\n       Call baddsn\n       Exit 12\n     End\n\nMakedsn:\n  If substr(dataii,1,1) \\= \"'\"\n   Then\n    dataii = pdsn\n  Lparn = Index(dataii,left)\n  Dataid = substr(dataii,1,lparn - 1)\n  Datat  = dataid\n  Dataid = dataid||\"'\"\n\nMakemem:\n  Lparn = Index(dataii,left)\n  Rparn = Index(dataii,right)\n  Meml = (rparn - 1) - lparn\n  Mem = substr(dataii,lparn + 1,meml)\n\nFinish:\n \"Lminit dataid(dd01) dataset(\"dataid\") enq(shr)\"\n \"Lminit dataid(dd02) dataset('\"Dsname\"') enq(shr) volume(\"sysvolume\")\"\n \"Lmcopy fromid(\"dd01\") tomem(@@@temp) trunc replace\",\n  \"Todataid(\"dd02\") frommem(\"mem\")\"\n     If rc = 8 Then\n         Do\n            Zedsmsg = \"Member not found\"\n            Zedlmsg = \"\"datat\"(\"mem\")  not found \"\n           \"Setmsg msg(isrz001)\"\n           Exit 12\n         End\n\"Control errors return\"\n\"Isredit process dest\"\n   If rc > 8 then isredit (first) = linenum 0\n Isredit copy @@@temp after .zdest\n   If rc > 0 then\n     Isredit copy @@@temp after .zfirst\n\"Control errors cancel\"\nLmproc:\n \"Lmfree dataid(\"dd01\")\"\n \"Lmfree dataid(\"dd02\")\"\n \"Lminit dataid(pdsid) dataset('\"dsname\"') enq(shrw) org(pdsorg)\"\n \"Lmopen dataid(\"pdsid\") option(output)\"\n \"Lmmdel dataid(\"pdsid\") member(@@@temp)\"\n \"Lmclose dataid(\"pdsid\")\"\n \"Lmfree dataid(\"pdsid\")\"\nExit 0\n\nBaddsn:\n   Zedsmsg = \"Entity not found\"\n   Zedlmsg = \"Check \"dataii\" for valid dataset and member\",\n             \"name (and if they exist)\"\n   \"Setmsg msg(isrz001)\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PLIAVG": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x13\\x7f\\x00\\x99\\x13\\x7f\\x14\\x04\\x00\\x0e\\x00\\x0e\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-05-17T00:00:00", "modifydate": "1999-05-17T14:04:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "OPRJAW0"}, "text": "PLIAVG:PROC OPTIONS(MAIN);\n /*==================================================================*/\n /*==================================================================*/\n         DCL AVERAGE_GRADE FIXED DECIMAL(5);\n         DCL TDTIME CHAR(17);\n         DCL TTIME CHAR(8);\n         DCL TDATE CHAR(6);\n         TTIME = TIME();\n         TDATE = DATE();\n         TDTIME = DATETIME();\n         DISPLAY ('TIME IS ' || TTIME);\n         DISPLAY ('DATE IS ' || TDATE);\n         DISPLAY ('DATETIME IS ' || TDTIME);\n         END PLIAVG;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RDATE": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x933O\\x00\\x99\\x13\\x7f\\x14\\x17\\x00\\xbe\\x00=\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1993-11-30T00:00:00", "modifydate": "1999-05-17T14:17:00", "lines": 190, "newlines": 61, "modlines": 0, "user": "OPRJAW0"}, "text": "/*--REXX-------------------------------------------------------------*/\n/*  Mod   05/11/99 - Corrected Y2K date processing                   */\n/*                   Data window is 2000-2095                        */\n/*                   1996 thru 1999 is only valid in the 1900's      */\n/*  Mod   01/18/95 - adding function to convert gregorian to juian   */\n/*  Mod   01/03/94 - corrected the date processing                   */\n/*  Mod   12/09/94 - streamlined the date processing                 */\n/*  Coded 11/30/93                                                   */\n/*                                                                   */\n/*  James A. Williams                                                */\n/*-------------------------------------------------------------------*/\n/*                                                                   */\n/* The following exec performs these functions:                      */\n/*                                                                   */\n/* Takes any valid gregorian date in this century and                */\n/* calculates the julian date, the day of the week, and              */\n/* a 'shop date' ie- the number of days elapsed between              */\n/* the input date and jan. 1, 1900. Thus if you feed                 */\n/* this exec 2 dates, the difference between the two                 */\n/* shop dates equals the number of elapsed days between              */\n/* the two. also converts julian to gregorian                        */\n/*                                                                   */\n/* the formats of the global variables are as follows:               */\n/* format -date for                                  :               */\n/*         where date equals sysdate or mm/dd/yy                     */\n/*         and for can equal jul day or shop                         */\n/*         the second parm returns in that format                    */\n/* input - Month=MM, Day=DD, Year=YY                                 */\n/*         for example: 01 01 99                                     */\n/*         note - 1 1 99 will not work.                              */\n/*                                                                   */\n/* input - Sysdate   -      sets variables for today's date          */\n/*         MM/DD/YY  -      sets variables for the date specified    */\n/* input - yyddd            sets variables for the date specified    */\n/* input - Sysdate   day    sets variables for today's date          */\n/*         MM/DD/YY  day    sets variables for the date specified    */\n/*                          and returns day of week                  */\n/* jul    - Jul=YYDDD, ie 99365 for 12/31/99                         */\n/* gre    - GRE=MMDDYY ie 12/31/99 for 99365                         */\n/* Shop   - dd..dd, ie, 36523 for the same date                      */\n/* Day - 0 1,2,3,4,5,6                                               */\n/* 0 Monday                                                          */\n/* 1 Tuesday                                                         */\n/* 2 Wednesday                                                       */\n/* 3 Thursday                                                        */\n/* 4 Friday                                                          */\n/* 5 Saturday                                                        */\n/* 6 Sunday                                                          */\n/*                                                                   */\n/* executil ts */\nArg date for\n\nRDATE_c_parm:\nIf  date = \"\"\n Then\n   Exit 4\nIf  for =  \"\"\n Then\n   Exit 4\n\nRDATE_jul_2_gre:\nIf for = gre then\nDo\n Year    = substr(date,1,2)\n Julian  = substr(date,3,3)\n If year >= 00 & year <=95      /* Y2K date window)*/\n   Then\n     LYear =20||year            /* 2000-2095       */\n   Else\n     LYear =19||year            /* 1996-1999       */\n Month.1 = X0003101JANUARY\n Month.2 = X0312802FEBRUARY\n Month.3 = X0593103MARCH\n Month.4 = X0903004APRIL\n Month.5 = X1203105MAY\n Month.6 = X1513006JUNE\n Month.7 = X1813107JULY\n Month.8 = X2123108AUGUST\n Month.9 = X2433009SEPTEMBER\n Month.10 = X2733110OCTOBER\n Month.11 = X3043011NOVEMBER\n Month.12 = X3343112DECEMBER\n  Do I = 1 to 12\n   If substr(month.i,2,3) >= julian | julian > 334  then\n     Do\n      If julian <= 334\n       Then\n        I = I - 1\n       Else\n        I = 12\n       Months = substr(month.i,7,2)\n       If (year//4 = 0 & lyear//4 \\= 100) | lyear//400 = 0 /* Y2K */\n        Then\n         Leap = 'TRUE'\n       If Leap = 'TRUE' & julian >= 60 then\n        Do\n          Month.2 = X0312902FEBRUARY\n          Date = julian  - (substr(month.i,2,3) + 1)\n          Dated = substr(month.i,5,2) - date\n          Date = substr(month.i,5,2) - dated\n          If julian = 60  then\n           Do\n              Months = 02\n              Date = 29\n           End\n        End\n       Else\n        Do\n         Date = julian  - substr(month.i,2,3)\n         Dated = substr(month.i,5,2) - date\n         Date = substr(month.i,5,2) - dated\n        End\n       If date < 10\n        then\n          Date = 0||date\n       Gregor = months||date||year\n       Dates = gregor\n       Leave\n     End\n  End\n  Return dates\nEnd\n\nRDATE_gre_2_jul:\n      If date =  sysdate then\n         Do\n           Sysdate = date(u)\n           Month = substr(sysdate,1,2)\n           Day   = substr(sysdate,4,2)\n           Year  = substr(sysdate,7,2)\n         End\n      Else\n         Do\n           Month = substr(date,1,2)\n           Day   = substr(date,4,2)\n           Year  = substr(date,7,2)\n         End\n\nSignal on syntax\n\nIf year >= 00 & year <=95      /* Y2K date window)*/\n  Then\n    LYear =20||year            /* 2000-2095       */\n  Else\n    LYear =19||year            /* 1996-1999       */\nJulian = substr(000031059090120151181212243273304334,((month*3)-2),3)\nJulian = julian + day\nIf (year//4 = 0 & lyear//4 \\= 100) | lyear//400 = 0 /* Valid Y2K */\n Then\n  Leap = 'TRUE'\nIf Leap = 'TRUE' & month > 2 then julian = julian + 1\nShop = julian  /* save to get day of week */\nL = length(julian)\nJulian = x00||julian\nJulian = year||substr(julian,(l+1),length(julian))\nJulian = strip(Julian,t)\n\nRDATE_Shop:\nB = 1900\nE = LYEAR - B\nDo E\n  If (year//4 = 0 & lyear//4 \\= 100) | lyear//400 = 0 /* Valid Y2K */\n   Then\n    Do\n     Shop = Shop+1\n    End\n  Shop = Shop+365\n  Year = Year+1\n  Lyear = Lyear+1\nEnd\nShop = Shop - 1\nDayn =  Shop//7\nCall format\nReturn dates\n\nFormat:\nSelect\n  When  for = \"JUL\"\n    Then  dates = julian\n  When  for = \"DAY\"\n    Then  dates = dayn\n  When  for = \"SHOP\"\n    Then  dates = shop\n  Otherwise Nop\nEND\nReturn dates\n\nSyntax:\n Say \"Syntax error in RDATE\"\n Exit 4\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REGS": {"ttr": 1552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x97\\x01\\x0f\\x00\\x97\\x01\\x0f\\x13@\\x00*\\x00*\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1997-01-10T00:00:00", "modifydate": "1997-01-10T13:40:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "OPRJAW0"}, "text": "         MACRO\n         REGS\n***********************************************************************\n*                                                                     *\n*        REGISTER EQUATES                                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        FIXED POINT REGISTERS                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nR0       EQU   0        *USED BY O.S.\nR1       EQU   1        *USED BY O.S. // ADDRESS OF PARAMETER LIST\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13       *USED BY O.S. // SAVE-AREA ADDRESS\nR14      EQU   14       *USED BY O.S. // RETURN ADDRESS\nR15      EQU   15       *USED BY O.S. // ENTRY-PT ADDR, RETURN CODE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        FLOATING POINT REGISTERS                                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nF0       EQU   0\nF2       EQU   2\nF4       EQU   4\nF6       EQU   6\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXJOBID": {"ttr": 1554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\r\\x00\\x00\\x00\\x99'\\x1f\\x00\\x99'\\x9f\\x08\\x04\\x00>\\x00D\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@\"", "ispf": {"version": "01.13", "flags": 0, "createdate": "1999-09-28T00:00:00", "modifydate": "1999-10-06T08:04:00", "lines": 62, "newlines": 68, "modlines": 0, "user": "OPRJAW0"}, "text": "RXJOBID  TITLE 'REXX function return current jobid '\nRXJOBID  CSECT\nRXJOBID  AMODE 31\nRXJOBID  RMODE ANY\n*------------------------------------------------------*\n*   Entry                                              *\n*   Program could be useful to return your current     *\n*   to the caller. Program should be RENT              *\n*   INVOKE AS FOLLOWS                                  *\n*   /* REXX */                                         *\n*   X=RXJOBID()                                        *\n*   SAY \"\"X\"\"                                          *\n*------------------------------------------------------*\n         BAKR  R14,0               Save regs, ARs etc\n         LR    R12,R15             Base register\n         USING RXJOBID,R12\n         MODID ,                   Eyecatcher\n         LR    R10,R1              Save parmlist address\n         STORAGE OBTAIN,LENGTH=WORKL\n         LR    R11,R1              Save parmlist address\n         ST    R1,8(,R13)          chain save areas\n         ST    R13,4(,R1)          old into new\n         LR    R13,R1              setup NEW SAVE/WORK AREA\n         USING SAVEAREA,R13        address getmaing using\n*------------------------------------------------------*\n*   Get the Jobid                                      *\n*------------------------------------------------------*\n         L     R2,16                 Get CVT pointer\n         L     R2,0(R2)              Get TCB pointer\n         L     R2,4(R2)              Get TCB address\n         L     R2,X'B4'(,R2)         Get JSCB  TCB+X'B4'\n         L     R2,X'13C'(,R2)        Get JSCBSSIB JSCB+X'13C'\n         LA    R2,X'C'(R2)           Get SSIBJBID SSIB+X'C'\n         MVC   XJOBID(8),0(R2)       Move R2 to JOBID.\n*------------------------------------------------------*\n*   Set up the Evaluation block to return values to the*\n*   caller                                             *\n*------------------------------------------------------*\n         USING EFPL,R10\n         L     R5,EFPLEVAL\n         L     R5,0(,R5)\n         USING EVALBLOCK,R5\n         MVC   EVALBLOCK_EVLEN,=X'00000008' MOVE LEN OF DATA\n         MVC   EVALBLOCK_EVDATA(8),XJOBID   DATA TO EVALBLK\n         SPACE\n*------------------------------------------------------*\n*   Free storage and return                            *\n*------------------------------------------------------*\nRETURN   EQU   *\n         STORAGE RELEASE,ADDR=(11),LENGTH=WORKL\n         SLR   R15,R15                      RC=0\n         PR                                 Return\n         EJECT\nWORK     DSECT\nSAVEAREA DS    18F\nXJOBID   DS    CL8\nWORKL    EQU   *-WORK\n         IEESMCA                            SMC\n         IRXEVALB                           REXX Eval block\n         IRXEFPL                            Extended function parmlst\n         REGS                               Regs\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SEQNUM": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x03?\\x00\\x99\\x07\\x8f\\x15&\\x00\\x1f\\x00\\x1f\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-02-02T00:00:00", "modifydate": "1999-03-19T15:26:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/*    Name     - SEQNUM                                               */\n/*    Author   - James A. Williams                                    */\n/*    Date     - 02/02/1999                                           */\n/*    Purpose  - Added sequence number                                */\n/*    Invoke   - EDIT MACRO  SEQNUM XX 50                             */\n/*                                                                    */\n/**********************************************************************/\nAddress ISPEXEC\n'ISREDIT MACRO (string,total) PROCESS'\n\nIf STRING  = \"\" Then Do\n   ZEDSMSG = 'String to update'\n   ZEDLMSG = 'Change from string to seqnum'\n   'SETMSG MSG(ISRZ001)'\n   Return 0\n   End\n\nIf TOTAL   = \"\" Then Do\n   ZEDSMSG = 'No number of updates'\n   ZEDLMSG = 'Update number of updates'\n   'SETMSG MSG(ISRZ001)'\n   Return 0\nEnd\n\nDo I = 1 to total\n \"ISREDIT change '\"string\"' '\"I\"'\"\nEnd\n\nReturn 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMF128II": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\x10\\x12\\x00\\xf0\\x00\\xf0\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T10:12:00", "lines": 240, "newlines": 240, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/*    Name     - smf128ii                                             */\n/*    Author   - James A. Williams                                    */\n/*    Date     - 03/22/1995                                           */\n/*    Purpose  - read user smf128typ to see who has bad jobcard       */\n/*               as a part of phase ii                                */\n/*    Invoke   - batch or foreground                                  */\n/*                                                                    */\n/**********************************************************************/\nArg infile\n\nCHK_IN_DATASET:\nX = outtrap('var.')\nInfile = \"'\"||infile||\"'\"\nDummy  = listdsi(infile)\nIf dummy \\= 0 then\n  Do\n    Say 'Dataset has problem or does not exits make sure it    '\n    Say 'was created with the ifasmfdp utility parsing smf128ty'\n    Exit 4\n  End\n\nREAD_SMF_IN_ARRAY:\nStatus=msg('off')\n\"Alloc fi(smfin) dsname(\"infile\") shr reuse\"\n\"Execio * diskr smfin (stem smfrec. finis\"\n\"Free fi(smfin)\"\n\"Alloc fi(acffile) dsname('acf10.pn1000.acflids') shr reuse\"\n\"Execio * diskr acffile (stem acfrec. finis\"\n\"Free fi(acffile)\"\nStatus=msg('on')\nAllocrc = rc\n\nSMF_DECLARES:\nSM128PTR = 0                   /*  record pointer    */\nSM128RTY = 0                   /*  record type       */\nSM128TME = 0                   /*  time in binary    */\nSM128DTE = 0                   /*  date in pack      */\nSM128SID = \"\"                  /*  smfid             */\nSM128UID = \"\"                  /*  LID of submitter  */\nSM128JBN = \"\"                  /*  jobname           */\nSM128CLS = \"\"                  /*  class submitted in*/\nSM128JAC = \"\"                  /*  acct on jobcard   */\nSM128AAC = \"\"                  /*  acct in acf2      */\nSM128STA = \"\"                  /*  y or n for start  */\n\nVAR_DECLARES:\nSMF_CTR1 = 0\nSMF_CTR2 = 0\nSMF_CTR3 = 0\nO        = 0\nRPTID    = TECX0002\nTOP      = '1'                                /*  Top of form    */\nSUP      = '+'                                /*  suppress formf */\nSK2      = '0'                                /*  skip 2 lines   */\nSK3      = '-'                                /*  skip 3 lines   */\nPagenum  = 0\nLinenum  = 0\nFirstpass= YES\nTSOfast  = G\nTSOslow  = C\nSTCclass = F\nCICclass = Q\nCICclasp = 5\nCICclast = 1\nSTCacct  = 7777\nTSOacct  = 8888\nCICacct  = 9999\n\nCALL RPT_HEADING\n\nSMF_PROCESS:\nDo I = 1 to smfrec.0\n  SM128RTY = substr(smfrec.i,sm128ptr+2,1)\n  If SM128RTY \\= '80'X\n      Then\n        Iterate\n  SM128TME = substr(smfrec.i,sm128ptr+3,4)\n  SM128DTE = substr(smfrec.i,sm128ptr+7,4)\n  SM128SID = substr(smfrec.i,sm128ptr+11,4)\n  SM128UID = substr(smfrec.i,sm128ptr+31,8)\n  SM128JBN = substr(smfrec.i,sm128ptr+44,8)\n  SM128CLS = substr(smfrec.i,sm128ptr+52,1)\n  SM128JAC = substr(smfrec.i,sm128ptr+53,7)\n  SM128AAC = substr(smfrec.i,sm128ptr+60,7)\n  SM128STA = substr(smfrec.i,sm128ptr+100,1)\n  SM128SUB = substr(smfrec.i,sm128ptr+101,4)\n  If SM128AAC = 5555OPR\n       Then\n         Iterate\n  If SM128UID = SM128JBN\n       Then\n         Iterate\n  Select\n   When STCACCT = SUBSTR(SM128AAC,1,4) then\n    Do\n\n     If SM128CLS = STCCLASS  & SM128JAC = SM128AAC\n         Then\n          Iterate\n    End\n   When TSOACCT = SUBSTR(SM128AAC,1,4) then\n    Do\n     Tmp = strip(SM128UID)\n     L  = LENGTH(tmp)\n     If tmp =  SUBSTR(SM128JBN,1,L)\n         Then\n          Gjob = YES\n         Else\n          Gjob = NO\n     If SM128CLS = TSOFAST  & SM128JAC = SM128AAC\n         Then\n          Do\n           If gjob = YES\n            Then\n             Iterate\n          End\n     If SM128CLS = TSOSLOW  & SM128JAC = SM128AAC\n         Then\n          Do\n           If gjob = YES\n            Then\n             Iterate\n          End\n    End\n   When CICACCT = SUBSTR(SM128AAC,1,4) then\n    Do\n     If SM128CLS = CICCLASS  & SM128JAC = SM128AAC\n         Then\n          Iterate\n     If SM128CLS = CICCLASP  & SM128JAC = SM128AAC\n         Then\n          Iterate\n     If SM128CLS = CICCLAST  & SM128JAC = SM128AAC\n         Then\n          Iterate\n    End\n   When SM128AAC = 1550SYS\n     Then\n      Nop\n   Otherwise\n    Iterate\n  End\nPROCESS:\n  Parse var sm128tme temp\n  TEMP = C2D(temp)\n  HH = TEMP%360000\n  L  = LENGTH(HH)\n  MM = TEMP%6000-60*HH\n  SS = TEMP%100-3600*HH-60*MM\n  JOBTIM = HH*10000+MM*100+SS\n  IF L = 1\n    THEN\n      SM128TME = 0||JOBTIM\n  ELSE\n      SM128TME = JOBTIM\n  SM128TME = SUBSTR(SM128TME,1,2)||'.'||SUBSTR(SM128TME,3,2)\n  Parse var sm128dte temp\n  TEMP = c2X(temp)\n  TEMP = SUBSTR(TEMP,3,5)\n  TEMP = RDATE(TEMP GRE)\n  X    = '/'\n  TEMP = SUBSTR(TEMP,1,2)||X||SUBSTR(TEMP,3,2)||X||SUBSTR(TEMP,5,2)\n  SM128DTE = TEMP\n CALL ACF_NAMES\n CALL BLD_OUTREC\n SMF_CTR1 = SMF_CTR1 + 1\n Linenum = Linenum + 1\n If linenum > 51 then\n     Do\n       LINENUM = 0\n       CALL RPT_HEADING\n     End\nEnd\n\nCall Tally_DATA\nCall WRT_OUTREC\nExit 0\n\nACF_NAMES:\nDo J = 1 TO ACFREC.0             /* CHECK ACF2 ARRAY FOR MATCH  */\nAcfid = substr(acfrec.j,3,7)\nIF SM128UID = ACFID THEN         /* IF NOT IN DBASE MOVE ON     */\n    Do\n      Username = substr(acfrec.j,45,20)\n      Leave J\n    End\nEnd\nReturn\n\nRPT_HEADING:\n/*executil ts */\nPagenum = Pagenum + 1\nO = O + 1\nHeading1 = TOP||LEFT(\"REPORT ID:\",12)||RPTID||,\n       CENTER(XXXXXXX XXX XXXXX XXXXXXX,92,' ')||,\n       LEFT(\"PAGE    : \",11)||PAGENUM\nOUTREC.O = heading1\nO = O + 1\nHeading2 = SK2||CENTER(JOBCARD VIOLATION REPORT,132)\nOUTREC.O = heading2\nO = O + 1\nOUTREC.O = SK3\nO = O + 1\nOUTREC.O = \"     USER'S_____NAME\",\n           \"     USERID       JOBNAME  JOBCLASS   JOBACCNT ACFACCNT \",\n           \"DATE       TIME   SUBSYS\"\nOUTREC.O = CENTER(OUTREC.O,132)\nO = O + 1\nOUTREC.O = \"     ---------------\",\n           \"     -------      -------- --------   -------  -------  \",\n           \"--------   -----  ------\"\nOUTREC.O = CENTER(OUTREC.O,132)\nReturn\n\nBLD_OUTREC:\nO = O + 1\nOUTREC.O = \"    \"USERNAME\"\",\n           \"\"SM128UID\"     \"SM128JBN\"      \"SM128CLS\"     \"SM128JAC\"\",\n             \" \"SM128AAC\"   \"SM128DTE\"   \"SM128TME\"  \"SM128SUB\"\"\nOUTREC.O = center(OUTREC.O,132)\nReturn\n\nWRT_OUTREC:\n/* \"Alloc fi(smfout) dsname('oprjaw0.smfout') shr reuse\"   */\n\"Execio \"o\" diskw smfout (stem outrec. finis\"\n/* \"Free fi(smfout)\"   */\nReturn\n\nTALLY_DATA:\nO = O + 1\nOUTREC.O = SK3\nO = O + 1\nOUTREC.O = TOP||center(\"-\",132,\"-\")\nO = O + 1\nOUTREC.O = \" TOTAL RECORDS READ:               \"SMFREC.0\"\"\nO = O + 1\nOUTREC.O = \" TOTAL JOBS WITH INVALID JOBCARDS: \"SMF_CTR1\"\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMF128J": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\x07D\\x00i\\x00i\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T07:44:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "OPRJAW0"}, "text": "//OPRJAW0J JOB (1543TSM),'SMF128A',CLASS=Z,MSGCLASS=R,\n//   NOTIFY=&SYSUID        ALL JOBS NEED ONE\n//SMFR01NP PROC SMFOUT='DATASET',\n//             MEMBER='CTLCARD',\n//             DISP='OLD'\n//DSMF COMMAND 'D SMF'\n//*==================================================================*\n//* ARCHIVE SMF RECORDS FROM MVSPROD                                 *\n//*==================================================================*\n//SMFARCH  EXEC PGM=IFASMFDP\n//SYSPRINT DD SYSOUT=*\n//DUMPIN1  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN1,\n//            DISP=SHR\n//DUMPIN2  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN2,\n//            DISP=SHR\n//DUMPIN3  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN3,\n//            DISP=SHR\n//DUMPIN4  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN4,\n//            DISP=SHR\n//DUMPIN5  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN5,\n//            DISP=SHR\n//DUMPIN6  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN6,\n//            DISP=SHR\n//DUMPIN7  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN7,\n//            DISP=SHR\n//DUMPIN8  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN8,\n//            DISP=SHR\n//DUMPIN9  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MAN9,\n//            DISP=SHR\n//DUMPINA  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MANA,\n//            DISP=SHR\n//DUMPINB  DD AMP=('BUFND=15'),\n//            DSN=SYS1.MANB,\n//            DISP=SHR\n//DUMPOUT  DD DSN=&SMFOUT,\n//            DISP=&DISP,\n//            DCB=BUFNO=15\n//SYSIN    DD DSN=AGL10.PP1000.CNTLLIB(&MEMBER),\n//            DISP=SHR\n// PEND\n//SMFDUMP  EXEC SMFR01NP,\n//            SMFOUT='OPRJAW0.SMF.DATA'\n//SMFARCH.SYSIN DD *\n INDD(DUMPIN1,OPTIONS(DUMP))\n INDD(DUMPIN2,OPTIONS(DUMP))\n INDD(DUMPIN3,OPTIONS(DUMP))\n INDD(DUMPIN4,OPTIONS(DUMP))\n INDD(DUMPIN5,OPTIONS(DUMP))\n INDD(DUMPIN6,OPTIONS(DUMP))\n INDD(DUMPIN7,OPTIONS(DUMP))\n INDD(DUMPIN8,OPTIONS(DUMP))\n INDD(DUMPIN9,OPTIONS(DUMP))\n INDD(DUMPINA,OPTIONS(DUMP))\n INDD(DUMPINB,OPTIONS(DUMP))\n OUTDD(DUMPOUT,TYPE(128))\n DATE(96001,96366)\n START(0000)\n START(2400)\n/*\n//IEBGENER PROC SOUT='*',\n//             CNTL='DUMMY'\n//IEBGENER EXEC PGM=IEBGENER\n//SYSPRINT DD  SYSOUT=&SOUT\n//SYSUT1   DD  DSN=&DSNI,\n//             DISP=SHR\n//SYSUT2   DD  DSN=&DSNO,\n//             DISP=SHR\n//SYSIN    DD  &CNTL\n// PEND\n//SMFREFM  EXEC IEBGENER,\n//            DSNI='OPRJAW0.SMF.DATA',\n//            DSNO='OPRJAW0.SMF.DATA2'\n//TSOR00NP PROC EXEC=,\n//            REGSIZE='32M',\n//            SOUT='*',\n//            TSIN=DUMMY\n//TSOR00NP EXEC PGM=IKJEFT1A,\n//            DYNAMNBR=50,\n//            REGION=&REGSIZE,\n//            PARM='&EXEC'\n//SYSHELP  DD DSN=SYS1.HELP,\n//            DISP=SHR\n//         DD DSN=SYSP.HELP,\n//            DISP=SHR\n//SYSPROC  DD DSN=AGL10.PP1000.CLIST,\n//            DISP=SHR\n//SYSEXEC  DD DSN=AGL10.PP1000.REXX,\n//            DISP=SHR\n//SYSTSPRT DD SYSOUT=&SOUT\n//SYSTSIN  DD &TSIN\n// PEND\n//SMF128P  EXEC TSOR00NP,\n//            EXEC='SMF128II  OPRJAW0.SMF.DATA2'\n//SMFOUT   DD DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330),\n//            SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMF170": {"ttr": 1803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\x10\\t\\x00\\xad\\x00\\xad\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T10:09:00", "lines": 173, "newlines": 173, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/*    Name     - SMF170                                               */\n/*    Author   - James A. Williams                                    */\n/*    Date     - 02/16/1998                                           */\n/*    Purpose  - read SMF170 to see is editing via FILEAID            */\n/*    Invoke   - batch or foreground                                  */\n/*                                                                    */\n/**********************************************************************/\nArg infile\n\nCHK_IN_DATASET:\nX = outtrap('var.')\nInfile = \"'\"||infile||\"'\"\nDummy  = listdsi(infile)\nIf dummy \\= 0 then\n  Do\n    Say 'Dataset has problem or does not exits make sure it    '\n    Say 'was created with the ifasmfdp utility parsing SM170type'\n    Exit 4\n  End\n\nREAD_SMF_IN_ARRAY:\nStatus=msg('off')\n\"Alloc fi(smfin) dsname(\"infile\") shr reuse\"\n\"Execio * diskr smfin (stem smfrec. finis\"\n\"Free fi(smfin)\"\n\"Alloc fi(acffile) dsname('acf10.pn1000.acflids') shr reuse\"\n\"Execio * diskr acffile (stem acfrec. finis\"\n\"Free fi(acffile)\"\nStatus=msg('on')\nAllocrc = rc\n\nSMF_DECLARES:\nSM170PTR = 0                   /*  record pointer    */\nSM170RTY = 0                   /*  record type       */\nSM170TME = 0                   /*  time in binary    */\nSM170DTE = 0                   /*  date in pack      */\nSM170SID = \"\"                  /*  smfid             */\nSM170DSN = \"\"                  /*  dataset name      */\nSM170MEM = \"\"                  /*  member if PDS     */\nSM170UID = \"\"                  /*  user identifier   */\n\nVAR_DECLARES:\nSMF_CTR1 = 0\nSMF_CTR2 = 0\nSMF_CTR3 = 0\nO        = 0\nRPTID    = AUDR0001\nTOP      = '1'                                /*  Top of form    */\nSUP      = '+'                                /*  suppress formf */\nSK2      = '0'                                /*  skip 2 lines   */\nSK3      = '-'                                /*  skip 3 lines   */\nPagenum  = 0\nLinenum  = 0\nFirstpass= YES\n\nCALL RPT_HEADING\n\nSMF_PROCESS:\nDo I = 1 to smfrec.0\n  SM170RTY = substr(smfrec.i,SM170ptr+2,1)\n  If SM170RTY \\= 'AA'X\n      THEN\n        ITERATE\n  SM170TME = substr(smfrec.i,SM170ptr+3,4)\n  Parse var SM170tme temp\n  TEMP = C2D(temp)\n  HH = TEMP%360000\n  L  = LENGTH(HH)\n  MM = TEMP%6000-60*HH\n  SS = TEMP%100-3600*HH-60*MM\n  JOBTIM = HH*10000+MM*100+SS\n  IF L = 1\n    THEN\n      SM170TME = 0||JOBTIM\n  ELSE\n      SM170TME = JOBTIM\n  SM170TME = SUBSTR(SM170TME,1,2)||'.'||SUBSTR(SM170TME,3,2)\n  SM170DTE = substr(smfrec.i,SM170ptr+7,4)\n  Parse var SM170dte temp\n  TEMP = c2X(temp)\n  TEMP = SUBSTR(TEMP,3,5)\n  TEMP = RDATE(TEMP GRE)\n  X    = '/'\n  TEMP = SUBSTR(TEMP,1,2)||X||SUBSTR(TEMP,3,2)||X||SUBSTR(TEMP,5,2)\n  /* executil ts  */\n  SM170DTE = TEMP\n  SM170SID = substr(smfrec.i,SM170ptr+11,4)\n  SM170UID = substr(smfrec.i,SM170ptr+24,8)\n  SM170DSN = substr(smfrec.i,SM170ptr+32,44)\n  SM170MEM = substr(smfrec.i,SM170ptr+76,8)\n  CALL ACF_NAMES\n  SMF_CTR1 = SMF_CTR1 + 1\nCALL BLD_OUTREC\nLinenum = Linenum + 1\nIf linenum > 51 then\n     DO\n       LINENUM = 0\n       CALL RPT_HEADING\n     END\nEnd\n\nCall Tally_DATA\nCall WRT_OUTREC\nExit 0\n\nACF_NAMES:\nDo J = 1 TO ACFREC.0             /* CHECK ACF2 ARRAY FOR MATCH  */\nAcfid = substr(acfrec.j,3,7)\nIF SM170UID = ACFID THEN         /* IF NOT IN DBASE MOVE ON     */\n    Do\n      Username = substr(acfrec.j,45,20)\n      Leave J\n    End\nEnd\nReturn\n\nRPT_HEADING:\n/*executil ts */\nPagenum = Pagenum + 1\nO = O + 1\nHeading1 = TOP||LEFT(\"REPORT ID:\",12)||RPTID||,\n       CENTER(AGL RESOURCES SERVICE COMPANY,92,' ')||,\n       LEFT(\"PAGE    : \",11)||PAGENUM\nOUTREC.O = heading1\nO = O + 1\nHeading2 = SK2||CENTER(FILEAID MVS PRODUCTION,132)\nOUTREC.O = heading2\nO = O + 1\nOUTREC.O = SK3\nO = O + 1\nOUTREC.O = \" DATE     TIME \",\n        \" DSNAME                                          MEMBER  \",\n        \" USERID    NAME                                          \"\nO = O + 1\nOUTREC.O = \" -------- -----\",\n        \" --------------------------------------------    --------\",\n        \" --------  ---------------------                        \"\nReturn\n\nBLD_OUTREC:\nO = O + 1\nOUTREC.O = \" \"SM170DTE\" \"SM170TME\"\",\n             \" \"SM170DSN\"    \"SM170MEM\"\",\n             \" \"SM170UID\"  \"USERNAME\"  \"\nReturn\n\nWRT_OUTREC:\n/* \"Alloc fi(smfout) dsname('oprjaw0.smfout') shr reuse\"   */\n\"Execio \"o\" diskw smfout (stem outrec. finis\"\n/* \"Free fi(smfout)\"                                       */\nReturn\n\nTALLY_DATA:\nPagenum = Pagenum + 1\nO = O + 1\nOUTREC.O = SK3\nO = O + 1\nHeading1 = TOP||LEFT(\"REPORT ID:\",12)||RPTID||,\n       CENTER(XXX XXXXXXXXX XXXXXXX COMPANY,92,' ')||,\n       LEFT(\"PAGE    : \",11)||PAGENUM\nOUTREC.O = heading1\nO = O + 1\nHeading2 = SK2||CENTER(FILEAID MVS PRODUCTION,132)\nOUTREC.O = heading2\nO = O + 1\nOUTREC.O = SK2||center(\"-\",132,\"-\")\nO = O + 1\nOUTREC.O = \" TOTAL RECORDS READ:                  \"SMFREC.0\"\"\nO = O + 1\nOUTREC.O = \" TOTAL FILEAID DATASETS EDITED INTERVAL:  \"SMF_CTR1\"\"\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMF170J": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\x077\\x001\\x001\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T07:37:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "OPRJAW0"}, "text": "//OPRJAW0J JOB (1543TSM),'SMF170',CLASS=Z,MSGCLASS=R,\n//   NOTIFY=&SYSUID        ALL JOBS NEED ONE\n//IBM0003P PROC CNTLLIB='AGL10.PP1000.CNTLLIB',\n//             MEMBER='MEMBER',\n//             PARMS=,\n//             PROGRAM='SORT',\n//             REGSIZE='32M',\n//             SOUT='*'\n//*******************************************************************\n//*        BATCH UTILITY FOR THE DFSORT PRODUCT                     *\n//*******************************************************************\n//DFSORT   EXEC PGM=&PROGRAM,\n//             PARM='&PARMS',\n//             REGION=&REGSIZE\n//SORTIN   DD  DUMMY\n//SYSOUT   DD  SYSOUT=&SOUT\n//SYSPRINT DD  SYSOUT=&SOUT\n//SYSIN    DD  DISP=SHR,\n//             DSN=&CNTLLIB(&MEMBER)\n//    PEND\n//TSOR00NP PROC EXEC=,\n//            REGSIZE='32M',\n//            SOUT='*',\n//            TSIN=DUMMY\n//TSOR00NP EXEC PGM=IKJEFT1A,\n//            DYNAMNBR=50,\n//            REGION=&REGSIZE,\n//            PARM='&EXEC'\n//SYSHELP  DD DSN=SYS1.HELP,\n//            DISP=SHR\n//         DD DSN=SYSP.HELP,\n//            DISP=SHR\n//SYSPROC  DD DSN=AGL10.PP1000.CLIST,\n//            DISP=SHR\n//SYSEXEC  DD DSN=AGL10.PP1000.REXX,\n//            DISP=SHR\n//SYSTSPRT DD SYSOUT=&SOUT\n//SYSTSIN  DD &TSIN\n// PEND\n//SMFREFM EXEC IBM0003P,\n//            MEMBER=SMFSORT\n//SORTIN   DD  DISP=SHR,\n//             DSN=OPRJAW0.SMF.DATA\n//SORTOUT  DD  DISP=SHR,\n//             DSN=OPRJAW0.SMF.DATA2  /* MUST BE VB AND NOT VBS */\n//SMF128P  EXEC TSOR00NP,\n//            EXEC='SMF170 OPRJAW0.SMF.DATA2'\n//SMFOUT   DD DCB=(RECFM=FBA,LRECL=133,BLKSIZE=1330),\n//            SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STCK": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01*\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01O\\t2\\x00B\\x00\\x0e\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf1@@@'", "ispf": {"version": "01.42", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-14T09:32:00", "lines": 66, "newlines": 14, "modlines": 0, "user": "OPRJAW1"}, "text": "STCK     TITLE 'STCK - INVOKE STORE CLOCK INSTRUCTION TO TEST Y2K'\nR0       EQU   0        *USED BY O.S.\nR1       EQU   1        *USED BY O.S. // ADDRESS OF PARAMETER LIST\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13       *USED BY O.S. // SAVE-AREA ADDRESS\nR14      EQU   14       *USED BY O.S. // RETURN ADDRESS\nR15      EQU   15       *USED BY O.S. // ENTRY-PT ADDR, RETURN CODE\nSTCK     CSECT\n         SAVE  (14,12),,STCK..&SYSDATC\n         BALR  R12,0               INIT BASE\n         USING *,R12               ADDRESS\n         ST    R13,SAVE+4          SAVE OLD SAVE\n         LA    R13,SAVE            COPY IN NEW SAVE\nSTCKPCHK DS    0H\n         LR    R11,R1              PTR PARM ADDR - FIRST COMMAND\n         L     R11,0(R11)          SAVE ADDR OF PARM IN R11\n         LH    R2,0(R11)           LENGTH TO R2\n         C     R2,=F'0'            PARM LENGTH = 0?\n         BE    STORCLOK            YES, ISSUE STCK\n         MVC   TODCLOCK(8),2(R11)  MOVE PARM TO WORK AREA\n         B     STCKCONV\nSTORCLOK STCK TODCLOCK\nSTCKCONV STCKCONV STCKVAL=TODCLOCK,CONVVAL=OUTVAL,TIMETYPE=DEC,        X\n               DATETYPE=MMDDYYYY\nSTCKCON2 DS 0H\n         LM    R2,R3,OUTVAL+8\n         SRDL  R2,28\n         LA    R4,X'0F'        ; SET SIGN BIT\n         OR    R3,R4\n         STM   R2,R3,TODCLOCK\n         UNPK  OUTVAL+8(8),TODCLOCK+3(5)\n         MVC   OUTDATE(8),OUTVAL+8\n         MVC   CONSOL+16(8),OUTDATE     WRITE TO CONSOLE\n         LM    R2,R3,OUTVAL      LOAD TIME IN GMT\n         SRL   R2,12             MOVE DATE OVER\n         LA    R3,X'0F'        ; SET SIGN BIT\n         OR    R2,R3\n         STM   R2,R3,TODCLOCK\n         UNPK  OUTVAL(4),TODCLOCK(4)\n         MVC   OUTTIME(4),OUTVAL\n         MVC   CONSOL+26(4),OUTTIME     WRITE TO CONSOLE\nCONSOL   WTO 'STCKCON XXXXXXXX  XXXX    GMTTIME    ',ROUTCDE=(2,11)\nEXIT     DS 0H\n         L     R13,SAVE+4          RELOAD OLD SAVE\n         RETURN (14,12),RC=0\n         EJECT\n*ODCLOCK DS 2F        TOD CLOCK VALUE\nTODCLOCK DS CL8       TOD CLOCK VALUE\nXODCLOCK DS CL8       TOD CLOCK VALUE\n*ODCLOCK DC X'A0569832F1241000'\nOUTDATE  DS CL8\nOUTTIME  DS CL4\nOUTVAL   DS 4F        CONVERTED VALUE\nSAVE     DS 18F\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TIMEPC": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x98\\x01?\\x00\\x98\\x01?\\tY\\x006\\x00'\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf1@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1998-01-13T00:00:00", "modifydate": "1998-01-13T09:59:00", "lines": 54, "newlines": 39, "modlines": 0, "user": "OPRJAW1"}, "text": "TIMEPC   TITLE 'TIMEPC - INVOKE TIME MACRO'\nR0       EQU   0        *USED BY O.S.\nR1       EQU   1        *USED BY O.S. // ADDRESS OF PARAMETER LIST\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13       *USED BY O.S. // SAVE-AREA ADDRESS\nR14      EQU   14       *USED BY O.S. // RETURN ADDRESS\nR15      EQU   15       *USED BY O.S. // ENTRY-PT ADDR, RETURN CODE\nTIMEPC   CSECT\n         SAVE  (14,12),,TIMEPC..&SYSDATC\n         BALR  R12,0               INIT BASE\n         USING *,R12               ADDRESS\n         ST    R13,SAVE+4          SAVE OLD SAVE\n         LA    R13,SAVE            COPY IN NEW SAVE\nTIMEPCP  DS 0H\n         TIME  DEC,OUTVAL,LINKAGE=SYSTEM,ZONE=LT,DATETYPE=MMDDYYYY\n         LM    R2,R3,OUTVAL+8\n         SRDL  R2,28\n         LA    R4,X'0F'        ; SET SIGN BIT\n         OR    R3,R4\n         STM   R2,R3,TODCLOCK\n         UNPK  OUTVAL+8(8),TODCLOCK+3(5)\n         MVC   OUTDATE(8),OUTVAL+8\n         MVC   CONSOL+18(8),OUTDATE     WRITE TO CONSOLE\n         LM    R2,R3,OUTVAL      LOAD TIME IN GMT\n         SRL   R2,12             MOVE DATE OVER\n         LA    R3,X'0F'        ; SET SIGN BIT\n         OR    R2,R3\n         STM   R2,R3,TODCLOCK\n         UNPK  OUTVAL(4),TODCLOCK(4)\n         MVC   OUTTIME(4),OUTVAL\n         MVC   CONSOL+28(6),OUTTIME     WRITE TO CONSOLE\nCONSOL   WTO 'TIMEPC    XXXXXXXX  XXXX    LOCALTIME  ',ROUTCDE=(2,11)\nEXIT     DS 0H\n         L     R13,SAVE+4          RELOAD OLD SAVE\n         RETURN (14,12),RC=0\n         EJECT\nTODCLOCK DS 2F        TOD CLOCK VALUE\n*ODCLOCK DC X'A0569832F1241000'\nOUTDATE  DS CL8\nOUTTIME  DS CL4\nOUTVAL   DS 4F        CONVERTED VALUE\nSAVE     DS 18F\n         LTORG\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TIMEX": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\n\\x00\\x00\\x00\\x98\\x01?\\x00\\x98\\x01?\\x10\\x05\\x00'\\x00%\\x00\\x07\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf1@@@\"", "ispf": {"version": "01.10", "flags": 0, "createdate": "1998-01-13T00:00:00", "modifydate": "1998-01-13T10:05:00", "lines": 39, "newlines": 37, "modlines": 7, "user": "OPRJAW1"}, "text": "         TITLE 'TIMEX    '\n***********************************************************************\n*        REGISTER USAGE FOLLOWS...                                    *\nR0       EQU   0                   WORK REG                           *\nR1       EQU   1                   PTR TO INPUT PARM                  *\nR2       EQU   2                   WORK REG                           *\nR11      EQU   11                  PTR TO FIRST MESSAGE IF NOZERO PARM*\nR12      EQU   12                  BASE REG                           *\nR13      EQU   13                  PTR TO SAVE                        *\nR14      EQU   14                  LINKAGE REG                        *\nR15      EQU   15                  LINKAGE REG                        *\nML       EQU   2                   MAX  PARM SIZE                     *\n***********************************************************************\nTIMEX    CSECT                         BEGINING OF PROGRAM\n         USING *,R12                SET UP BASE REG\n         SAVE  (14,12),,TIMEX..&SYSDATE       SAVE REGISTERS\n         BALR  R12,0                SET UP ADDRESSABILITY\n         USING *,R12               ADDRESS\n         ST    R13,SAVE+4          SAVE OLD SAVE\n         LA    R13,SAVE            COPY IN NEW SAVE\nTESTCODE DS    0H\n         TIME  DEC,ZONE=LT         NOT DETERMINE DATE AND TIME\n         ST    R0,HHMMSS           SAVE HOUR\n         ST    R1,CYYDDD           SAVE HOUR\n         UNPK  OUTDATE(5),CYYDDD\n         UNPK  OUTTIME(7),HHMMSS\n         MVC   CONSOL+16(8),OUTDATE     WRITE TO CONSOLE\n         MVC   CONSOL+26(7),OUTTIME     WRITE TO CONSOLE\nCONSOL   WTO 'TIMESVC XXXXXXXX  XXXX    LOCAL      ',ROUTCDE=(2,11)\n         LA    R15,0\nEXIT     L     R13,SAVE+4           RESTORE R13\n         RETURN (14,12),RC=0        RETURN TO MVS\nSAVE     DS    18F                  SAVE AREA\nHHMMSS   DS    F\nCYYDDD   DS    F\nOUTDATE  DS    CL8\nOUTTIME  DS    CL8\n         LTORG                      LTORG NEEDED FOR ADDRESSABILITY\n         END   TIMEX                END OF PROGRAM\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TOUPPERC": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x99'\\x9f\\x00\\x99'\\x9f\\x08\\x08\\x00 \\x00 \\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-10-06T00:00:00", "modifydate": "1999-10-06T08:08:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "OPRJAW0"}, "text": "/*REXX*****************************************************************/\n/*                                                                    */\n/*    NAME     - TOUPPERC                                             */\n/*    AUTHOR   - JAMES A. WILLIAMS                                    */\n/*    DATE     - 09/16/1998                                           */\n/*    PURPOSE  - CONVERT TEXT FROM LOWER TO UPPERCASE                 */\n/*    INVOKE   - TOUPPERC FROM BATCH                                  */\n/*                                                                    */\n/**********************************************************************/\nADDRESS ISPEXEC\n\n \"CONTROL ERRORS RETURN\"\n \"ISREDIT MACRO NOPROCESS\"\nTRACE R\n \"ISREDIT CHANGE P'<' P'>' ALL\"\nSRC = RC\nTRACE O\n IF SRC \\= 0\n   THEN\n    DO\n     ZISPFRC=8\n     \"ISPEXEC VPUT (ZISPFRC)\"\n    \"ISREDIT CANCEL\"\n     EXIT 8\n    END\n    DO\n     ZISPFRC=0\n     \"ISPEXEC VPUT (ZISPFRC)\"\n    \"ISREDIT END\"\n     EXIT 0\n    END\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TOUPPERJ": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00\\x00\\x00\\x99'\\x9f\\x00\\x99'\\x9f\\x08G\\x00M\\x001\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-10-06T00:00:00", "modifydate": "1999-10-06T08:47:00", "lines": 77, "newlines": 49, "modlines": 0, "user": "OPRJAW0"}, "text": "//OPRJAW0O JOB (1543TSM),'TOUPPERJ',CLASS=Z,MSGCLASS=R,\n//   NOTIFY=&SYSUID        ALL JOBS NEED ONE\n//TSOR00NP PROC EXEC=,\n//            REGSIZE='32M',\n//            SOUT='*',\n//            TSIN=DUMMY\n//***************************************************\n//* EVEN THOUGH WE HAVE THE VENDOR TOOL STARTOOL    *\n//* I AM SURE MOST OF THE BELOW CAN BE DONE WITH    *\n//* PDS85. THE FIRST  CONTROL CARDS ALLOW US        *\n//* TO RUN THE TOUPPERC EDIT MACRO AGAINST A MACLIB *\n//* THAT USES MIXED CASE. XPEDITER AT THE 6.5 WITH  *\n//* CSS 7.6 LEVEL DOES NOT YET SUPPORT MIXED CASE   *\n//* THE OTHERS ARE GOOD FOR EXAMPLES                *\n//***************************************************\n//TSOR00NP EXEC PGM=IKJEFT1A,\n//            DYNAMNBR=50,\n//            REGION=&REGSIZE,\n//            PARM='&EXEC'\n//SYSHELP  DD DSN=SYS1.HELP,\n//            DISP=SHR\n//         DD DSN=SYSP.HELP,\n//            DISP=SHR\n//SYSPROC  DD DSN=AGL10.PP1000.CLIST,\n//            DISP=SHR\n//SYSEXEC  DD DSN=AGL10.PP1000.REXX,\n//            DISP=SHR\n//SYSTSPRT DD SYSOUT=&SOUT\n//SYSTSIN  DD &TSIN\n// PEND\n//STARTOOL EXEC TSOR00NP\n//SYSTSIN  DD  *\n  STARTOOL 'OPRJAW0.IRX.MACLIB.UC'\n  FIXPDS RESET NOCHECK\n  CHANGE 'OPRJAW0.IRX.MACLIB'\n  SUBLIST :\n  COPY * 'OPRJAW0.IRX.MACLIB.UC' SHR\n  CHANGE 'OPRJAW0.IRX.MACLIB.UC'\n  SUBLIST :\n  EDIT * MACRO(TOUPPERC)\n  CONDEND\n//\n  PDSTOOLS 'OPRJAW0.PGM.LOADLIB'\n  IF : RMODEANY THEN(SUBLIST)\n  COPY * 'OPRJAW0.PDS.TEST2' NEW\n  CONDEND\n//\nPDSTOOLS 'MMA20.PP1000.DB2UTIL'\nSUBLIST :\nREPLACE * /MMAU20/MMAP20/ WRITE\n//\n  PDSTOOLS 'SYSP.LINKLIB'\n  ATTRIB X RESIZE\n  COMPRESS\n  CONDEND\n//\n COPY A* 'OPRJAW0.PDS.TEST2' NEW\n CONDEND\n COPY T* 'OPRJAW0.PDS.TEST3' NEW\n END\n //\n PDSTOOLS 'OPRJAW0.RSVP'\n COPY  'OPRJAW0.PDS(TEMP)' REPLACE\n END\n//\nPDSTOOLS 'OPRJAW0.PGM.LOADLIB'\nSUBLIST :\nIF * CREATED(1999/01/01:1999/06/08) THEN(ATTRIB)\n//\n  PDSTOOLS 'SYS4.PP1PRD.PROCLIB'\n  IF MMA*  THEN(SUBLIST)\n  COPY * 'OPRJAW0.PMM.MEMBERS' NEW\n  CHANGE 'OPRJAW0.PMM.MEMBERS'\n  SUBLIST :\n  FIND * 'LOA.LIB' THEN(SUBLIST)\n  FIND * 'PGM='\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOAGL01": {"ttr": 2062, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99\\x17\\x9f\\x00\\x99\\x17\\x9f\\t3\\x00T\\x00T\\x00\\x00\\xd6\\xd7\\xd9\\xd1\\xc1\\xe6\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-06-28T00:00:00", "modifydate": "1999-06-28T09:33:00", "lines": 84, "newlines": 84, "modlines": 0, "user": "OPRJAW0"}, "text": "WTOAGL01 TITLE 'MESSAGE PROCESSOR TO START VTAM APPL'\n         SPACE 1\n*********************************************************************\n*                                                                   *\n*   WTOAGL01: MPF ROUTINE TO START  AGLSVTMB                        *\n*                                                                   *\n*   EXIT:     NORMAL  -  RC=0                                       *\n*                                                                   *\n*             ERROR   -  RC=4                                       *\n*                                                                   *\n*   MODS:     AUG.  9,1988   -   CHANGED GETMAIN TO SUBPOOL 230  RP *\n*   MODS: AGL OCT.  2,1992   -   MADE CODE CHANGE TO GET IT TO WORK *\n*   MODS: AGL JAN. 16,1993   -   CUSTOMIZED FOR AGLC                *\n*                                                                   *\n*********************************************************************\nWTOAGL01 CSECT ,\nWTOAGL01 AMODE 31\nWTOAGL01 RMODE ANY\n         SPACE 2\nCMDSVC   EQU   34\nK0       EQU   0\nK1       EQU   1\nK2       EQU   2\nK4       EQU   4\nK8       EQU   8\nK12      EQU   12\nK16      EQU   16\n         SPACE 2\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         EJECT\n         SAVE  (14,12),,WTOAGL01_&SYSDATE  SAVE REGISTERS\n         USING WTOAGL01,R12                SET UP BASE\n         USING CVT,R3                      SETUP CVT ADDRESS\n         USING DATA,R13                    SETUP DATE AREA ADDRESS\n         LR    R12,R15                     LOAD BASE REG\n         L     R8,K0(R1)                   SAVE INPUT PARM\n         GETMAIN RU,LV=DATALEN,SP=230,LOC=BELOW GET STORAGE       (RP)\n         ST    R13,K4(R1)                  SAVE CALLERS WORK AREA\n         ST    R1,K8(R13)                  SAVE MY WORK AREA\n         LR    R13,R1                      LOAD SAVE AREA ADDRESS\n         SPACE 1\nSTARTCMD DS    0H\n         SPACE 1\n         L     R3,CVTPTR\n         MVC   CMDL1+17(1),CVTSNAME+3\n         MVC   CMDAREA1(CMDLEN1),CMDL1     MOVE IN START COMMAND\n         SLR   R0,R0                       CLEAR REG 0\n         LA    R1,CMDAREA1                 POINT TO START OF COMMAND\n         SVC   CMDSVC                      ISSUE START COMMAND\n         SPACE 1\nEXIT     DS    0H\n         LR    R1,R13                      LOAD GETMAINED AREA\n         L     R13,K4(R13)                 POINT TO CALLERS SAVE AREA\n         FREEMAIN RU,LV=DATALEN,A=(1),SP=230  FREEMAIN AREA       (RP)\n         LM    14,12,12(13)                RESTORE REGS\n         LA    R15,0                       SET RC=0\n         BSM   0,R14                       GOBACK, IN CALLERS MODE\n         EJECT\nCMDL1    DS    0F\n         DC    AL2(CMDLEN1),AL2(00)        LENGTH OF STRING\n         DC    C'START AGLSVTMX'           COMMAND PLUS BLANK\nCMDLEN1  EQU   *-CMDL1\n         SPACE 2\nDATA     DSECT\nSAVE     DS    18F\nCMDAREA1 DS    0F,XL(CMDLEN1)\nDATALEN  EQU   *-DATA\n         CVT DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT368/FILE368.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT368", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}