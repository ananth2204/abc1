{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012709000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE740.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE740.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x05'", "DS1TRBAL": "b'\\xa8\\xac'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\n\\x00\\x07\\x05\\n\\x00\\x0e\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04G\\x00\\x00\\x01\\x06\\x03\\x9f\\x01\\x06\\x03\\x9f\\t\\x14\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf1@@@'", "ispf": {"version": "04.71", "flags": 0, "createdate": "2006-02-08T00:00:00", "modifydate": "2006-02-08T09:14:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-471"}, "text": "REGULAR CBT TAPE - VERSION 471    FILE:  740\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT471.FILE740\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 17 MEMBERS COUNTED; CUMULATIVE SIZE IS 2,999 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   02/08/06    09:14:55    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x002\\x01\\x06\\x03\\x9f\\x01\\x06\\x03\\x9f\\x08U\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-02-08T00:00:00", "modifydate": "2006-02-08T08:55:32", "lines": 24, "newlines": 24, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:      RE: Your RSQL Package\nFrom:         \"Wynne, Alan A\" <Alan.Wynne@standardbank.co.za>\nDate:         Wed, 8 Feb 2006 11:07:21 +0200\nTo:           \"Sam Golob\" <sbgolob@cbttape.org>\n\nSam\n\nThanks for your effort.  Attached please find a text file\ndescribing the usage of the rexx.  This text is also part of the\napplication.  (It is member RSQLDOC in this file.)\n\nA Short decription of this rexx:\n\nRSQL is a Rexx application to Execute SQL statements.  I have\ntested it extensively on \"Select\", \"Insert\" and \"Update\"\nStatements.  Output can be requested in Columnar, CSV, Flat or\nHTML format.\n\nFeedback on the product will be appreciated, but I cannot promise\nto provide any support.  I will when I can.\n\nRegards\nAlan Wynne\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE740": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04G\\x00\\x00\\x01\\x06\\x03\\x9f\\x01\\x06\\x03\\x9f\\t\\x14\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf1@@@'", "ispf": {"version": "04.71", "flags": 0, "createdate": "2006-02-08T00:00:00", "modifydate": "2006-02-08T09:14:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CBT-471"}, "text": "//***FILE 740 is from Alan Wynne and contains a package of REXX     *   FILE 740\n//*           execs which run SQL statements.                       *   FILE 740\n//*                                                                 *   FILE 740\n//*       RSQL is a Rexx application to Execute SQL statements.     *   FILE 740\n//*       I have tested it extensively on \"Select\", \"Insert\" and    *   FILE 740\n//*       \"Update\" Statements.  Output can be requested in          *   FILE 740\n//*       Columnar, CSV, Flat or HTML format.                       *   FILE 740\n//*                                                                 *   FILE 740\n//*       email:  \"Wynne, Alan A\" <Alan.Wynne@standardbank.co.za>   *   FILE 740\n//*                                                                 *   FILE 740\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DATADICT": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00(\\x01\\x04%\\x8f\\x01\\x06\\x03\\x8f\\x17\\x11\\x00\\x9e\\x00\\x97\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-09-14T00:00:00", "modifydate": "2006-02-07T17:11:28", "lines": 158, "newlines": 151, "modlines": 0, "user": "BSW1"}, "text": "-- -- ==================================================================\n-- -- 1. LIST ALL TABLES\n-- --\n--\n      select\n           name\n          ,creator\n          ,type\n          ,dbname\n          ,tsname\n          ,dbid\n          ,obid\n          ,colcount\n          ,edproc\n          ,valproc\n          ,clustertype\n          ,clusterrid\n          ,card\n          ,npages\n          ,pctpages\n          ,ibmreqd\n          ,remarks\n          ,parents\n          ,children\n          ,keycolumns\n          ,reclength\n          ,status\n          ,keyobid\n          ,label\n          ,checkflag\n          ,checkrid\n          ,auditing\n          ,createdby\n          ,location\n          ,tbcreator\n          ,tbname\n          ,createdts\n          ,alteredts\n          ,datacapture\n          ,pctrowcomp\n          ,statstime\n          ,checks\n          ,cardf\n          ,checkrid5b\n          ,encoding_scheme\n          ,tablestatus\n          ,npagesf\n          ,spacef\n          ,avgrowlen\n          ,relcreated\n        from sysibm.systables\n        where creator =  '????'\n        order by creator, name\n        with ur\n      ;\n-- -- ==================================================================\n-- -- 2. LIST ALL COLUMNS\n-- --\n--\n      select\n           name\n          ,tbname\n          ,tbcreator\n          ,colno\n          ,coltype\n          ,length\n          ,scale\n          ,nulls\n          ,colcard\n          ,updates\n          ,ibmreqd\n          ,remarks\n          ,default\n          ,keyseq\n          ,foreignkey\n          ,fldproc\n          ,label\n          ,statstime\n          ,defaultvalue\n          ,colcardf\n          ,colstatus\n          ,length2\n          ,datatypeid\n          ,sourcetypeid\n          ,typeschema\n          ,typename\n          ,createdts\n        from sysibm.syscolumns\n        where tbcreator =  '????'\n        order by tbname, colno\n        with ur\n      ;\n-- -- ==================================================================\n-- -- 3. List ALL INDEXES\n-- --\n--\n      select\n           name\n          ,creator\n          ,tbname\n          ,tbcreator\n          ,uniquerule\n          ,colcount\n          ,clustering\n          ,clustered\n          ,dbid\n          ,obid\n          ,isobid\n          ,dbname\n          ,indexspace\n          ,firstkeycard\n          ,fullkeycard\n          ,nleaf\n          ,nlevels\n          ,bpool\n          ,pgsize\n          ,eraserule\n          ,dsetpass\n          ,closerule\n          ,space\n          ,ibmreqd\n          ,clusterratio\n          ,createdby\n          ,iofactor\n          ,prefetchfactor\n          ,statstime\n          ,indextype\n          ,firstkeycardf\n          ,fullkeycardf\n          ,createdts\n          ,alteredts\n          ,piecesize\n          ,copy\n          ,case copylrsn\n             when x'000000000000' then ''\n             else copylrsn\n           end as copylrsn\n          ,clusterratiof\n          ,spacef\n          ,remarks\n        from sysibm.sysindexes\n        where tbcreator =  '????'\n        order by tbname, name\n        with ur\n      ;\n-- -- ==================================================================\n-- -- 4. LIST ALL KEYS\n-- --\n--\n      select i.tbname, k.*\n        from sysibm.syskeys as k\n          inner join sysibm.sysindexes as i\n            on k.ixname = i.name\n        where i.creator   =  '????'\n           or i.tbcreator =  '????'\n        order by i.tbname, k.ixname\n        with ur\n      ;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INSTALL": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x08\\x01\\x04%\\x8f\\x01\\x06\\x03\\x8f\\x17A\\x00>\\x00\\x06\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2004-09-14T00:00:00", "modifydate": "2006-02-07T17:41:08", "lines": 62, "newlines": 6, "modlines": 0, "user": "BSW1"}, "text": "Installing RSQL on your system.\n===============================\n\nInstalling RSQL on your system should be very simple. there are two\nsteps to follow.\n\nStep 1: Place members in the a SYSPROC Library.\n-------\n\n  Copy the following members into a dataset in your SYSPROC\n  concatenation.\n\n      RSQL\n      RSQLDFLT\n      RSQLDOC\n      RSQLEXEC\n      RSQLTRIM\n\nStep 2: Setup Defaults.\n-------\n\n  Edit the RSQLDFLT member to set up your instalaion defaults. The\n  member has comments that should help, Some of the defaults are\n  already provided, and I suggest you leave them as they are. The rest\n  that are question marks you will need to determine for your site.\n  The ValidSSID's parameters must list valid SSID in your site.\n\n\nStep 3: Verify that the Programs Work.\n-------\n\n  I have provided a number of jobs to test and demostrate this utility\n  and some of it's parameters.\n\n  IVPJOB0 will show you how to run a simple query and some of the\n  results types that you can get. it provides a simple list of tables\n  in your database.\n\n  IVPJOB1 could help build a data-dictionary for import into a\n  Spread sheet program or other type of Visual Database application.\n  the query instead of just one result set produces four four. It can be\n  used to help build a Data Dictionary of the Database. The job assumes\n  that xmitip is laready installed anmd emails the result sets to an\n  email address you must provide.\n\n  IVPJOB2 and IVPJOB3 are the same as 1 but provide the result sets in\n  different formats.\n\n  Before running these job please first do the following:\n\n    1 : Add a valid jobcard to the jobs.\n    2 : Change all \"YOUR.SITE.SYSPROC\" to the dataset where you\n        installed RSQL.\n    3 : Change all \"RSQL.INSTALL.LIBARY\" to the library name of this\n        uploaded file. (Check that you have a member called DATADICT\n    4 : Change all \"YOUR.SITE.XMITIP.LOAD\" to the load library where\n        the xmitip data has been installed into.\n    5 : Change all \"YOUR.SITE.XMITIP.EXEC\" to the REXX library where\n        the xmitip Rexx'es have been installed into.\n    6 : Update the member DATADICT and change all occurances of ????\n        in it to an appropriate data base creator.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IVPJOB0": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00)\\x01\\x06\\x03\\x7f\\x01\\x06\\x03\\x8f\\x16\\x10\\x00j\\x00x\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2006-02-06T00:00:00", "modifydate": "2006-02-07T16:10:29", "lines": 106, "newlines": 120, "modlines": 0, "user": "BSW1"}, "text": "//         SET SSID=????\n//* ====================================================================\n//IEF01#06 EXEC PGM=IEFBR14,COND=(0,LT)\n//*\n//DD1      DD  DSN=BSW1.RSQLTEST.TXT,\n//             SPACE=(TRK,(60,5)),\n//             DISP=(MOD,DELETE,DELETE)\n//*\n//DD2      DD  DSN=BSW1.RSQLTEST.CSV,\n//             SPACE=(TRK,(60,5)),\n//             DISP=(MOD,DELETE,DELETE)\n//*\n//DD3      DD  DSN=BSW1.RSQLTEST.HTML,\n//             SPACE=(TRK,(60,5)),\n//             DISP=(MOD,DELETE,DELETE)\n//*\n//DD4      DD  DSN=BSW1.RSQLTEST.NH.CSV,\n//             SPACE=(TRK,(60,5)),\n//             DISP=(MOD,DELETE,DELETE)\n//*\n//DD5      DD  DSN=BSW1.RSQLTEST.FLAT,\n//             SPACE=(TRK,(60,5)),\n//             DISP=(MOD,DELETE,DELETE)\n//*\n//* ====================================================================\n//* Run SQL in Batch\n//*\n//IKJ02#06 EXEC PGM=IKJEFT01,\n//         PARM=('%RSQLEXEC BATCH SSID=&SSID')\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.SYSPROC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RSQLIN   DD DISP=SHR,DSN=RSQL.INSTALL.LIBARY(TABLES)\n/*\n//RSQLOUT  DD SYSOUT=*\n//*\n//RS000001 DD DSN=BSW1.RSQLTEST.TXT,\n//            DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,100),RLSE),\n//            DCB=(RECFM=FB,LRECL=4096)\n//* ====================================================================\n//* Run SQL in Batch\n//*\n//IKJ03#06 EXEC PGM=IKJEFT01,\n//         PARM=('%RSQLEXEC BATCH SSID=&SSID CSV')\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.SYSPROC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RSQLIN   DD DISP=SHR,DSN=RSQL.INSTALL.LIBARY(TABLES)\n/*\n//RSQLOUT  DD SYSOUT=*\n//*\n//RS000001 DD DSN=BSW1.RSQLTEST.CSV,\n//            DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,100),RLSE),\n//            DCB=(RECFM=FB,LRECL=4096)\n//* ====================================================================\n//* Run SQL in Batch\n//*\n//IKJ04#06 EXEC PGM=IKJEFT01,\n//         PARM=('%RSQLEXEC BATCH SSID=&SSID HTML')\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.SYSPROC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RSQLIN   DD DISP=SHR,DSN=RSQL.INSTALL.LIBARY(TABLES)\n/*\n//RSQLOUT  DD SYSOUT=*\n//*\n//RS000001 DD DSN=BSW1.RSQLTEST.HTML,\n//            DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,100),RLSE),\n//            DCB=(RECFM=FB,LRECL=4096)\n//* ====================================================================\n//* Run SQL in Batch\n//*\n//IKJ05#06 EXEC PGM=IKJEFT01,\n//         PARM=('%RSQLEXEC BATCH SSID=&SSID CSVNOHEADER')\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.SYSPROC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RSQLIN   DD DISP=SHR,DSN=RSQL.INSTALL.LIBARY(TABLES)\n/*\n//RSQLOUT  DD SYSOUT=*\n//*\n//RS000001 DD DSN=BSW1.RSQLTEST.NH.CSV,\n//            DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,100),RLSE),\n//            DCB=(RECFM=FB,LRECL=4096)\n//*\n//* ====================================================================\n//* Run SQL in Batch\n//*\n//IKJ06#06 EXEC PGM=IKJEFT01,\n//         PARM=('%RSQLEXEC BATCH SSID=&SSID FLAT')\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.SYSPROC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RSQLIN   DD DISP=SHR,DSN=RSQL.INSTALL.LIBARY(TABLES)\n/*\n//RSQLOUT  DD SYSOUT=*\n//*\n//RS000001 DD DSN=BSW1.RSQLTEST.FLAT,\n//            DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,100),RLSE),\n//            DCB=(RECFM=FB,LRECL=4096)\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IVPJOB1": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00F\\x01\\x04%\\x8f\\x01\\x06\\x03\\x8f\\x178\\x00`\\x00\\xfd\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2004-09-14T00:00:00", "modifydate": "2006-02-07T17:38:46", "lines": 96, "newlines": 253, "modlines": 0, "user": "BSW1"}, "text": "//* ====================================================================\n//*\n//IEF01#03 EXEC PGM=IEFBR14,COND=(0,LT)\n//*\n//DD01     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.TABLES.CSV\n//*\n//DD02     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.COLUMNS.CSV\n//*\n//DD03     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.INDEXES.CSV\n//*\n//DD04     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.KEYS.CSV\n//*\n//DD05     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.RSQLOUT1.TXT\n//*\n//* ====================================================================\n//* RUN SQL IN BATCH\n//*\n//IKJ02#03 EXEC PGM=IKJEFT01,\n//         PARM=('RSQLEXEC CSV BATCH COMMIT=NO')\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.SYSPROC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RSQLIN   DD DISP=SHR,DSN=RSQL.INSTALL.LIBARY(DATADICT)\n//RSQLOUT  DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(10,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=80,BLKSIZE=27920),\n//            DSN=&SYSUID..&SSID..DATADICT.RSQLOUT1.TXT\n//*\n//RS000001 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.TABLES.CSV\n//*\n//RS000002 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.COLUMNS.CSV\n//*\n//RS000003 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.INDEXES.CSV\n//*\n//RS000004 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.KEYS.CSV\n//*\n//* ====================================================================\n//IKJ03#03 EXEC PGM=IKJEFT01,DYNAMNBR=200,COND=(4,LT)\n//STEPLIB  DD DISP=SHR,DSN=YOUR.SITE.XMITIP.LOAD\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.XMITIP.EXEC\n//SYSTSPRT DD SYSOUT=*\n//RSQLOUT  DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.RSQLOUT1.TXT\n//*\n//RS000001 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.TABLES.CSV\n//*\n//RS000002 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.COLUMNS.CSV\n//*\n//RS000003 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.INDEXES.CSV\n//*\n//RS000004 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.KEYS.CSV\n//*\n//MSGFILE  DD *\nTo whom it may concern\n\nHere are the System tables data in CSV format for building a\nData Dictionary.\n\n\nRegards\n\n/*\n//ADDRLIST DD *\n  TO your.email@wherever\n/*\n//SYSTSIN  DD *\n  xmitip * addressfiledd addrlist +\n    from your.email@wherever      +\n    subject 'Select against systems tables. &date &time' +\n    msgdd msgfile +\n    filedd (RSQLOUT RS000001 RS000002 RS000003 RS000004 ) +\n    format (txt csv csv csv csv ) +\n    filename (datadict.txt tables.csv columns.csv indexes.csv keys.csv)\n/*\n//* ====================================================================\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IVPJOB2": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x01\\x06\\x03\\x8f\\x01\\x06\\x03\\x8f\\x179\\x00`\\x01\\x1e\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2006-02-07T00:00:00", "modifydate": "2006-02-07T17:39:00", "lines": 96, "newlines": 286, "modlines": 0, "user": "BSW1"}, "text": "//* ====================================================================\n//IEF01#03 EXEC PGM=IEFBR14,COND=(0,LT)\n//*\n//DD01     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.TABLES.TXT\n//*\n//DD02     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.COLUMNS.TXT\n//*\n//DD03     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.INDEXES.TXT\n//*\n//DD04     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.KEYS.TXT\n//*\n//DD05     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.RSQLOUT2.TXT\n//*\n//*\n//* ====================================================================\n//* RUN SQL IN BATCH\n//*\n//IKJ02#03 EXEC PGM=IKJEFT01,\n//         PARM=('RSQLEXEC QUERY BATCH COMMIT=NO')\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.SYSPROC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RSQLIN   DD DISP=SHR,DSN=RSQL.INSTALL.LIBARY(DATADICT)\n//RSQLOUT  DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(10,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=80,BLKSIZE=27920),\n//            DSN=&SYSUID..&SSID..DATADICT.RSQLOUT2.TXT\n//*\n//RS000001 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.TABLES.TXT\n//*\n//RS000002 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.COLUMNS.TXT\n//*\n//RS000003 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.INDEXES.TXT\n//*\n//RS000004 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.KEYS.TXT\n//*\n//* ====================================================================\n//IKJ03#03 EXEC PGM=IKJEFT01,DYNAMNBR=200,COND=(4,LT)\n//STEPLIB  DD DISP=SHR,DSN=YOUR.SITE.XMITIP.LOAD\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.XMITIP.EXEC\n//SYSTSPRT DD SYSOUT=*\n//RSQLOUT  DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.RSQLOUT2.TXT\n//*\n//RS000001 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.TABLES.TXT\n//*\n//RS000002 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.COLUMNS.TXT\n//*\n//RS000003 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.INDEXES.TXT\n//*\n//RS000004 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.KEYS.TXT\n//*\n//MSGFILE  DD *\nTo whom it may concern\n\nHere are the System tables data in query format for building a\nData Dictionary.\n\n\nRegards\n\n/*\n//ADDRLIST DD *\n  TO your.email@wherever\n/*\n//SYSTSIN  DD *\n  xmitip * addressfiledd addrlist +\n    from your.email@wherever      +\n    subject 'Select against systems tables. &date &time' +\n    msgdd msgfile +\n    filedd (RSQLOUT RS000001 RS000002 RS000003 RS000004 ) +\n    format (txt txt txt txt txt ) +\n    filename (datadict.txt tables.txt columns.txt indexes.txt keys.txt)\n/*\n//* ====================================================================\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IVPJOB3": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x13\\x01\\x06\\x03\\x8f\\x01\\x06\\x03\\x8f\\x179\\x00`\\x00`\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-02-07T00:00:00", "modifydate": "2006-02-07T17:39:13", "lines": 96, "newlines": 96, "modlines": 0, "user": "BSW1"}, "text": "//* ====================================================================\n//IEF01#03 EXEC PGM=IEFBR14,COND=(0,LT)\n//*\n//DD01     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.TABLES.HTML\n//*\n//DD02     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.COLUMNS.HTML\n//*\n//DD03     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.INDEXES.HTML\n//*\n//DD04     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.KEYS.HTML\n//*\n//DD05     DD  DISP=(MOD,DELETE,DELETE),\n//             SPACE=(TRK,(60,5)),\n//             DSN=&SYSUID..&SSID..DATADICT.RSQLOUT3.TXT\n./*\n//*\n//* ====================================================================\n//* RUN SQL IN BATCH\n//*\n//IKJ02#03 EXEC PGM=IKJEFT01,\n//         PARM=('RSQLEXEC QUERY BATCH COMMIT=NO')\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.SYSPROC\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//RSQLIN   DD DISP=SHR,DSN=RSQL.INSTALL.LIBARY(DATADICT)\n//RSQLOUT  DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(10,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=80,BLKSIZE=27920),\n//            DSN=&SYSUID..&SSID..DATADICT.RSQLOUT3.TXT\n//*\n//RS000001 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.TABLES.HTML\n//*\n//RS000002 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.COLUMNS.HTML\n//*\n//RS000003 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.INDEXES.HTML\n//*\n//RS000004 DD DISP=(NEW,CATLG,CATLG),\n//            UNIT=SYSDA,SPACE=(TRK,(100,1),RLSE),\n//            DCB=(RECFM=VB,LRECL=4096,BLKSIZE=24576),\n//            DSN=&SYSUID..&SSID..DATADICT.KEYS.HTML\n//*\n//* ====================================================================\n//IKJ03#03 EXEC PGM=IKJEFT01,DYNAMNBR=200,COND=(4,LT)\n//STEPLIB  DD DISP=SHR,DSN=YOUR.SITE.XMITIP.LOAD\n//SYSEXEC  DD DISP=SHR,DSN=YOUR.SITE.XMITIP.EXEC\n//SYSTSPRT DD SYSOUT=*\n//RSQLOUT  DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.RSQLOUT3.TXT\n//*\n//RS000001 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.TABLES.HTML\n//*\n//RS000002 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.COLUMNS.HTML\n//*\n//RS000003 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.INDEXES.HTML\n//*\n//RS000004 DD DISP=SHR,DSN=&SYSUID..&SSID..DATADICT.KEYS.HTML\n//*\n//MSGFILE  DD *\nTo whom it may concern\n\nHere are the System tables data in html format for building a\nData Dictionary.\n\n\nRegards\n\n/*\n//ADDRLIST DD *\n  TO your.email@wherever\n/*\n//SYSTSIN  DD *\n  xmitip * addressfiledd addrlist +\n    from your.email@wherever      +\n    subject 'Select against systems tables. &date &time' +\n    msgdd msgfile +\n    filedd (RSQLOUT RS000001 RS000002 RS000003 RS000004 ) +\n    format (txt txt txt txt txt ) +\n    filename (datadict.txt tables.htm columns.htm indexes.htm keys.htm)\n/*\n//* ====================================================================\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LSTALOC": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x04%/\\x01\\x04%/\\x087\\x00P\\x00P\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2004-09-08T00:00:00", "modifydate": "2004-09-08T08:37:54", "lines": 80, "newlines": 80, "modlines": 0, "user": "BSW1"}, "text": "/* REXX */\n  Ver      = \"1.00\"\n  ReturnCode = 0\n/* ==================================================================\n * Author: Alan Wynne\n *\n * Rexx Exec to List all datasets allocated with their DDname and\n * Disposition.\n *\n * ================================================================== */\n/* TRACE ?R */\n/* ================================================================== */\n/* Recieve arguments                                                  */\n/*                                                                    */\n\n/*no arguments                                                        */\n/*Parse ARG                                                           */\n\n/* ================================================================== */\n/* Test the Alloc commands.                                           */\n/*                                                                    */\n\n  Drop DatasetInfo.\n  DatasetInfo.0 = 0\n\n  BlankString = '                                                     '\n\n  x = OUTTRAP('ListAlc.')\n\n  \"LISTALC STATUS\"\n\n  if ListAlc.0 = 0 Then NOP\n  Else\n    Do i = 1 to listAlc.0\n      Select\n        When SubStr(ListAlc.i,1,2) = '--'    then NOP\n        When SubStr(ListAlc.i,1,2) = '  '    then\n          Do\n            DatasetInfo.j.DD   = Substr(ListAlc.i,3,8)\n            DatasetInfo.j.Disp = Strip(Substr(ListAlc.i,12))\n          End\n        Otherwise\n          Do\n            DatasetInfo.0      = DatasetInfo.0 + 1\n            j                  = DatasetInfo.0\n            DatasetInfo.j.DSN  = Strip(ListAlc.i)\n            DatasetInfo.j.DD   = ''\n            DatasetInfo.j.Disp = ''\n            k =  POS(' ',DatasetInfo.j.DSN,1)\n            If k > 0 then\n              Do\n                DatasetInfo.j.DD   =                                  ,\n                  Strip(Substr(DatasetInfo.j.DSN,k,))\n                DatasetInfo.j.DSN  =                                  ,\n                  Strip(Substr(DatasetInfo.j.DSN,1,k))\n              End\n          End\n      End\n    End\n\n  if DatasetInfo.0 = 0 Then Nop\n  Else\n    Do\n      Say \"List dataset allocated.\"\n      Say \"                                                 \"\n      Say \"The number of Datasets Allocated is:\"DatasetInfo.0\n      Say \"                                                 \"\n      Say \"DDname   DSN                                     \"         ,\n        \"          Disp\"\n      Say \"----+----1----+----2----+----3----+----4----+----5\" ||     ,\n        \"----+----6----+----7----+----\"\n      Do i = 1 to DatasetInfo.0\n        Say SUBSTR(DatasetInfo.i.DD  ||BlankString,1,8),\n            SUBSTR(DatasetInfo.i.DSN ||BlankString,1,50),\n            DatasetInfo.i.Disp\n      End\n    End\n\n  Return\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RSQL": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Y\\x01\\x04#o\\x01\\x06\\x03\\x7f\\x166\\x00\\x18\\x00\\x18\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-23T00:00:00", "modifydate": "2006-02-06T16:36:59", "lines": 24, "newlines": 24, "modlines": 0, "user": "BSW1"}, "text": "/* REXX */\n/* ================================================================   */\n/* Language   : REXX\n * Name       : RSQL\n * Category   : Edit Macro\n * Description: Edit macro to execute SQL that is currently being edited\n * Rexx       : RSQLEXEC\n * Panels     : none\n * Skeltons   : none\n * Messages   : none\n * Procedure  : none\n * Author     : Alan Wynne.\n * Owner      : Alan Wynne.\n * Created    :\n * Modified   :                                                     */\n/* ================================================================ */\n   ARG FILETYPE SSID\n   \"ISREDIT MACRO (Arg1, Arg2, Arg3, Arg4, Arg5) NOPROCESS\"\n   \"ISREDIT (DATASET) = DATASET\"\n   \"ISREDIT (MEMBER) = MEMBER\"\n   IF MEMBER > '' THEN DATASET = DATASET || '(' || MEMBER || ')'\n   \"ALLOC DA('\"DATASET\"') F(RSQLIN) SHR REUSE\"\n   CALL RSQLEXEC Arg1 Arg2 Arg3 Arg4 Arg5 ONLINE\n   RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RSQLDFLT": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00)\\x01\\x04$O\\x01\\x06\\x03\\x7f\\x16D\\x006\\x003\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2004-08-31T00:00:00", "modifydate": "2006-02-06T16:44:29", "lines": 54, "newlines": 51, "modlines": 0, "user": "BSW1"}, "text": "/* REXX */\n/* ================================================================   */\n/* Language   : REXX\n * Name       : RSQLDFLT\n * Category   : Rexx Procedure\n * Description: Rexx procedure to setup DB2 Environment.\n * Rexx       : (Other modules called or NONE)\n * Panels     : (Panels used or NONE)\n * Skeltons   : (Skeletons used or NONE)\n * Messages   : (Message files used or NONE)\n * Procedure  : (Procedures called or NONE)\n * Author     : Alan Wynne.\n * Owner      : Alan Wynne.\n * Created    :\n * Modified   :\n * ================================================================ */\n/* REXX */\n/* ==================================================================\n * Author: Alan Wynne\n *\n * Rexx Exec to determine Default Values for RUNSQL\n *\n * Method of execution is:\n *\n * RUNSQLDF--|                  |---------------\n *           |---MngmntCls------|\n *           |---StorageCls-----|\n *           |---SSID-----------|\n *           |---ResultType-----|\n *           |---RowsPerPage----|\n *           |---ColumnGapSize--|\n *           |---ValidSSIds-----|\n *           |---TextQualifier--|\n *           |---PageTitle------|\n *           |---Commit---------|\n *\n * ================================================================== */\n   Parse Arg Arg1\n\n   if Arg1 = 'MngmntCls'        then Return 'NOMNGMT'\n   if Arg1 = 'StorageCls'       then Return 'GSPACE'\n   if Arg1 = 'SSID'             then Return '????'\n   if Arg1 = 'ResultType'       then Return 'Query'\n   if Arg1 = 'RowsPerPage'      then Return 0\n   if Arg1 = 'ColumnGapSize'    then Return 2\n   if Arg1 = 'ValidSSIds'       then\n     do\n       Return '????,????,????,????,????,????'\n     end\n   if Arg1 = 'TextQualifier'    then Return '\"'\n   if Arg1 = 'PageTitle'        then Return 'Page Generated by RSQL'\n   if Arg1 = 'Commit'           then Return 'No'\n\n   Return 'Invalid Argument suplied'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RSQLDOC": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\t\\x01\\x04#o\\x01\\x06\\x00_\\x14\\x08\\x00\\xc2\\x00\\xc1\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-08-23T00:00:00", "modifydate": "2006-01-05T14:08:09", "lines": 194, "newlines": 193, "modlines": 0, "user": "BSW1"}, "text": "//* Rexx *//\n/*\n\n   RSQLEXEC Documentation.\n\n   Rexx Exec to Read the Sql in a dataset, and execute it.\n\n   Author: Alan Wynne\n\n   Method of execution and parameters are:\n\n   RSQLEXEC--------------------------------------------------------->A\n                |                                       |\n                |--Query--------------------------------|\n                |       |--Rows--|                      |\n                |                                       |\n                |--Flat---------------------------------|\n                |                                       |\n                |--Txt----------------------------------|\n                |                                       |\n                |--CSV----------------------------------|\n                |          |--TQ='?'-------------|      |\n                |          |--TQ=\"?\"-------------|      |\n                |          |--TQ=\"\"--------------|      |\n                |          |--TQ='---------------|      |\n                |          |--TQ=----------------|      |\n                |                                       |\n                |--CSVNoHeader--------------------------|\n                |          |--TQ='?'-------------|      |\n                |          |--TQ=\"?\"-------------|      |\n                |          |--TQ=\"\"--------------|      |\n                |          |--TQ='---------------|      |\n                |          |--TQ=----------------|      |\n                |                                       |\n                |--HTML---------------------------------|\n                          |--PT='Page Title'----|\n\n\n\n    A>-------------------------------------------------------------->B\n                |                        |\n                |--SSID=ssid-------------|\n                |                        |\n                |--S=ssid----------------|\n\n    B>-------------------------------------------------------------->C\n                |                        |\n                |--COMMIT=Yes------------|\n                |                        |\n                |--COMMIT=No-------------|\n\n\n    C>----------------------------------------------------------| End\n                |                        |\n                |--Online----------------|\n                |                        |\n                |--Batch-----------------|\n\n\n   Input Dataset:\n\n   RSQLIN\n\n   Input Dataset will be assigned to Filename RSQLIN. In this dataset\n   the SQL to be executed should be found. Unlike QMF the dataset will\n   accept SQL in free format and it's width is unrestricted. This means\n   that the output of an SQL Statement can be used as the input to\n   another SQL Statement.\n\n   Parameters:\n\n   Query or Q:\n\n   Query or Q means output is to be normal output. Columns will be\n   alligned and Column Headings will be supplied. Columns will be\n   seperated by the nuber specified as the default Column Gap Size.\n   Rows is the number of Rows that will be displayed before each column\n   heading.\n\n   Flat:\n\n   Flat means that columns will be alligned but no space will seperate\n   the columns. No Headings will be displayed either.\n\n   CSV:\n\n   CSV means that a Comma seperated variable file will be created.\n   Comma seperated variables files will not be alligned by columns.\n   Character type Columns will be enclosed in Double Quotes, Numeric\n   type columns will not be enclosed in quotes. Commas will be used to\n   seperate variables. The first row in the output dataset will contain\n   column Headings.\n\n   CSVNoHeader:\n\n   CSVNoHeader is the same as CSV except that the first record in the\n   file will not contain column headings.\n\n   TQ:\n\n   TQ is to define the Text Qualifier character to be used, and is only\n   relevant for CSV and CSV No header file types. The Text qualifier is\n   the character to be used to enclose text fields. The default text\n   Qualifier will be set up in the RSQLDFLT Rexx. The parameter can be\n   to overwite the default Text qualifier character. No text qualifier\n   can also be specified by using the parameter TQ=\"\" or TQ='' or TQ=\n\n   HTML:\n\n   HTML means that an HTML page will be generated with the data in a\n   HTML Table. The Page Title part of the HTML parameters causes The\n   text of Page Title to be the HTML Page Title.\n\n   SSID= or S=:\n\n   SSID=ssid or S=ssid stipulates which DB2 sub system to connect to.\n\n   COMMIT:\n\n   COMMIT parameter determines whether to commit at the end of execution\n   or to Rollback. The default can be setup in RSQLDFLT. I suggest that\n   the defualt be set up as COMMIT=No and that when a COMMIT is required\n   it should be specifically requested.\n\n   Online or Batch:\n\n   Online or Batch are mutualy exclusive  and indicate whether the\n   SQL is being executed in a batch mode or online mode. This is used\n   to detemine the Output dataset. In online mode the Output datasets\n   are detemined by the REXX Program in Batch mode the Output dataset\n   is not determined by the program but by the JCL. When the program is\n   executed by REXX in a Batch Job it may still operate in online mode.\n   The program will default to operate in Online mode unless Batch mode\n   is specifically stipulated.\n\n   Output Dataset:\n\n   There are two types of output dataset. The first type is a dataset\n   that displays the operating results. It is equivalent to the SYSOUT\n   dataset used by other utilities. This dataset is always required and\n   allocated to DD Name RSQLOUT. The second type is only relevant to\n   SQL that produces a result set. A Single execution of RSQLEXEC may\n   desire the execution of more that one SQL Statement. When this occurs\n   then all the processing information of each SQL Statement is shown in\n   the RSQLOUT Dataset, but each possible result set will be output to a\n   DD Name of RSnnnnnn, where nnnnnn is the relative number of the\n   result set; i.e. the first result set will be output to DD name\n   RS000001. SQL Update statments do not result in a result set and so\n   the RSnnnnnn DD name is not required for these types of stements.\n\n   Example JCL:\n\n     //* =================================================================\n     //* Run SQL in Batch\n     //*\n     //IKJ01#01 EXEC PGM=IKJEFT01,COND=(0,LT)\n     //SYSEXEC  DD DISP=SHR,DSN=TRISDXX.REXX\n     //SYSTSPRT DD SYSOUT=*\n     //SYSTSIN  DD *\n       RSQLEXEC CSV SSID=DB2A BATCH COMMIT=YES\n     /*\n     //RSQLIN   DD *\n       select * from TABLEA  where COLUMNA = 'litereal-a' ;\n       update TABLEA set COLUMNA = 'litereal-b'\n         where COLUMNA = 'litereal-a' ;\n       select * from TABLEA  where COLUMNA = 'litereal-a' ;\n       select * from TABLEA  where COLUMNA = 'litereal-b' ;\n     /*\n     //RSQLOUT  DD SYSOUT=*\n     //*\n     //RS000001 DD DSN=&SYSUID..RSQLOUT.RS000001.CSV,\n     //            DISP=(NEW,CATLG,CATLG),\n     //            UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE),\n     //            DCB=(RECFM=FB,LRECL=nnn,BLKSIZE=nnnnn)\n     //RS000002 DD DSN=&SYSUID..RSQLOUT.RS000002.CSV,\n     //            DISP=(NEW,CATLG,CATLG),\n     //            UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE),\n     //            DCB=(RECFM=FB,LRECL=nnn,BLKSIZE=nnnnn)\n     //*\n     //RS000003 DD DSN=&SYSUID..RSQLOUT.RS000003.CSV,\n     //            DISP=(NEW,CATLG,CATLG),\n     //            UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE),\n     //            DCB=(RECFM=FB,LRECL=nnn,BLKSIZE=nnnnn)\n     //*\n     //* =================================================================\n\n   In the above JCL 4 SQL statements are to be executed, 3 select\n   and 1 update statement. The result sets of the select statements are\n   to be output to a CSV (Comma Seperated Variable) files. Since an\n   update is also being performed the COMMIT=YES parameter is required.\n   The DB2 System to be executed in is DB2A.\n\n\n*/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RSQLEXEC": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x01\\x01\\x04%\\x1f\\x01\\x06\\x03\\x7f\\x169\\x06P\\x065\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-09-07T00:00:00", "modifydate": "2006-02-06T16:39:01", "lines": 1616, "newlines": 1589, "modlines": 0, "user": "BSW1"}, "text": "/* REXX */\n/* ================================================================   */\n/* Language   : REXX\n * Name       : RSQLEXEC\n * Category   : Rexx Exec (command line)\n * Description: Rexx Exec to Read the Sql in a dataset, and execute it.\n * Rexx       : RSQLDFLT\n * Panels     : none\n * Skeltons   : none\n * Messages   : none\n * Procedure  : none\n * Author     : Alan Wynne.\n * Owner      : Alan Wynne.\n * Created    : August 2004.\n * Modified   :\n * ================================================================ */\n  Ver      = \"1.00\"\n  ReturnCode = 0\n/* ==================================================================\n * Rexx Exec to Read the Sql in a dataset, and execute it.\n *\n * Method of execution is:\n *\n * RSQLEXEC--------------------------------------------------------->A\n *              |                                       |\n *              |--Query--------------------------------|\n *              |          |--Rows--|                   |\n *              |                                       |\n *              |--Flat---------------------------------|\n *              |                                       |\n *              |--Txt----------------------------------|\n *              |                                       |\n *              |--CSV----------------------------------|\n *              |          |--TQ='?'-------------|      |\n *              |          |--TQ=\"?\"-------------|      |\n *              |          |--TQ=\"\"--------------|      |\n *              |          |--TQ='---------------|      |\n *              |          |--TQ=----------------|      |\n *              |                                       |\n *              |--CSVNoHeader--------------------------|\n *              |          |--TQ='?'-------------|      |\n *              |          |--TQ=\"?\"-------------|      |\n *              |          |--TQ=\"\"--------------|      |\n *              |          |--TQ='---------------|      |\n *              |          |--TQ=----------------|      |\n *              |                                       |\n *              |--HTML---------------------------------|\n *                        |--PT='Page Title'----|\n *\n *\n *\n *  A>-------------------------------------------------------------->B\n *              |                        |\n *              |--SSID=ssid-------------|\n *              |                        |\n *              |--S=ssid----------------|\n *\n *  B>-------------------------------------------------------------->C\n *              |                        |\n *              |--COMMIT----------------|\n *                         |--=Yes-|\n *                         |--=No--|\n *\n *\n *  C>----------------------------------------------------------| End\n *              |                        |\n *              |--Online----------------|\n *              |                        |\n *              |--Batch-----------------|\n *\n *\n * Input Dataset will be assigned to Filename RSQLIN.\n *\n * Query or Q means output is to be normal output. Columns will be\n * alligned and Column Headings will be supplied. Columns will be\n * seperated by the nuber specified as the default Column Gap Size.\n * Rows is the number of Rows that will be displayed before each column\n * heading.\n *\n * Flat means that columns will be alligned but no space will seperate\n * the columns. No Headings will be displayed either.\n *\n * CSV means that a Comma seperated variable file will be created.\n * Comma seperated variables files will not be alligned by columns.\n * Character type Columns will be enclosed in Double Quotes, Numeric\n * type columns will not be enclosed in quotes. Commas will be used to\n * seperate variables. The first row in the output dataset will contain\n * column Headings.\n *\n * CSVNoHeader is the same as CSV except that the first record in the\n * file will not contain column headings.\n *\n * TQ is to define the Text Qualifier character to be used, and is only\n * relevant for CSV and CSV No header file types. The Text qualifier is\n * the character to be used to enclose text fields. The default text\n * Qualifier will be set up in the RSQLDFLT Rexx. The parameter can be\n * used to overwrite the default Text qualifier character. No text\n * qualifier can also be specified by using the parameters TQ=\"\" or\n * TQ='' or TQ=\n *\n * HTML means that an HTML page will be generated with the data in a\n * HTML Table. The Page Title part of the HTML parameters causes The\n * text of Page Title to be the HTML Page Title.\n *\n * SSID=ssid or S=ssid stipulates which DB2 sub system to connect to.\n *\n * COMMIT parameter determines whether to commit at the end of execution\n * or to Rollback. The default can be setup in RSQLDFLT. The commit\n * keyword without the \"=yes\" or \"=No\" results in a commit.\n *\n * Online or Batch are mutualy exclusive  and indicate whether the\n * SQL is being executed in a batch mode or online mode. This is used\n * to detemine the Output dataset. In online mode the Output datasets\n * are detemined by the REXX Program in Batch mode the Output dataset\n * is not determined by the program but by the JCL. When the program is\n * executed by REXX in a Batch Job it may still operate in online mode.\n * The program will default to operate in Online mode unless Batch mode\n * is specifically stipulated.\n *\n * ================================================================== */\n/* TRACE ?R */\n/* ================================================================== */\n/* Recieve arguments                                                  */\n/*                                                                    */\n\n  Parse ARG Args\n/*Parse ARG Arg.1 Arg.2 Arg.3 Arg.4 Arg.5 Arg.6 Arg.7 Arg.8 Arg.9     */\n\n/* ================================================================== */\n/* Initialize Environment                                             */\n/*                                                                    */\n  NoMessage = 0                        /* No of messages              */\n  Drop Message.                        /* Drop message stem           */\n\n  NoSQLDA   = 0                        /* No of Saved SQLDA's         */\n  Drop SavedSQLDAs.                    /* Drop SavedSQLDAs            */\n\n\n  Drop DatasetInfo.                    /* Drop Allocated Dataset info */\n  Call ListAloc                        /* Get Dataset Info            */\n\n  RSQLINDD   = 'RSQLIN'                /* Define DD name input SQL DS */\n  RSQLINDSN  = ''                      /* initialize DSN to blank     */\n  RSQLINDSN  = DSNSearch(RSQLINDD)     /* Find RSQLINDS Name          */\n  RSQLOutDD  = 'RSQLOUT'               /* Define DD name of Output    */\n  RSQLOutDSN = ''                      /* initialize DSN to blank     */\n  RSQLOutDSN = DSNSearch(RSQLOutDD)    /* Find Output DS Name         */\n  RSQLDADD   = 'RSQLDA'                /* Define DD name of SQLDA     */\n  RSQLDADSN  = ''                      /* initialize DSN to blank     */\n  RSQLDADSN  = DSNSearch(RSQLDADD)     /* Find SQLDA DS Namee         */\n\n/* ================================================================== */\n/* Set The Default Environment.                                       */\n/*                                                                    */\n\n  SSID          =  RSQLDFLT('SSID')          /* Default SSID name     */\n  ResultType    =  RSQLDFLT('ResultType')    /* Default Result type   */\n  ColumnGapSize =  RSQLDFLT('ColumnGapSize') /* Default Gap twix cols */\n  RowsPerPage   =  RSQLDFLT('RowsPerPage')   /* Default Rows per page */\n  ValidSSIds    =  RSQLDFLT('ValidSSIds')    /* Valid SSID's          */\n  TextQualifier =  RSQLDFLT('TextQualifier') /* Default Text Qualifier*/\n  PageTitle     =  RSQLDFLT('PageTitle')     /* Default page title    */\n  Commit        =  RSQLDFLT('Commit')        /* Default Commit status */\n\n/* ================================================================== */\n/* Process the Arguments supplied into the Environment                */\n/*                                                                    */\n/* TRACE ?R */\n\n\n  if Pos(' PT=',Args) > 0 then\n    Do\n      PageTitleSP  = Pos(' PT=',Args) + 5\n      PageTitle    = Substr(Args,PageTitleSP)\n      PageTitleLen = Pos(Substr(Args,PageTitleSP-1,1),PageTitle)-1\n      PageTitle    = Substr(PageTitle,1,PageTitleLen)\n      Args         = Substr(Args,1,PageTitleSP-5) ||,\n                     Substr(Args,PageTitleSP+PageTitleLen+2)\n    End\n\n  Drop Arg.\n  Parse VAR Args Arg.1 Arg.2 Arg.3 Arg.4 Arg.5 Arg.6 Arg.7 Arg.8 Arg.9\n\n  Do i = 1 To 6 until Arg.i = ''\n    Select\n      When Arg.i = ''                    Then\n        NOP\n      When Translate(Substr(Arg.i,1,4)) = 'CSVN' Then\n        ResultType = 'CSVNoHeader'\n      When Translate(Substr(Arg.i,1,3)) = 'CSV'  Then\n        ResultType = 'CSV'\n      When Translate(Substr(Arg.i,1,1)) = 'Q'    Then\n        ResultType = 'QUERY'\n      When Translate(Substr(Arg.i,1,1)) = 'F'    Then\n        ResultType = 'FLAT'\n      When Translate(Substr(Arg.i,1,3)) = 'TQ='  Then\n        Do\n          Select\n            When Length(Arg.i) = 6                 Then\n              TextQualifier = Substr(Arg.i,5,1)\n            When Length(Arg.i) = 5                 Then\n              TextQualifier = ''\n            When Length(Arg.i) = 4                 Then\n              TextQualifier = Substr(Arg.i,4,1)\n            When Length(Arg.i) = 3                 Then\n              TextQualifier = ''\n            Otherwise\n              Do\n                NoMessage = NoMessage + 1\n                Message.NoMessage = '  RSQLEXEC: Text Qualifier ',\n                  ||'incorrectly specified. Default text qualifier ',\n                  ||'assumed.'\n              End\n          End\n        End\n      When Translate(Substr(Arg.i,1,1)) = 'T'    Then\n        ResultType = 'TXT'\n      When Translate(Substr(Arg.i,1,1)) = 'H'    Then\n        ResultType = 'HTML'\n      When Translate(Substr(Arg.i,1,2)) = 'S='   Then\n        SSID = Translate(Substr(Arg.i,3))\n      When Translate(Substr(Arg.i,1,5)) = 'SSID=' Then\n        SSID = Translate(Substr(Arg.i,6))\n      When Translate(Substr(Arg.i,1,7)) = 'COMMIT=' Then\n        Commit = Translate(Substr(Arg.i,8))\n      When Translate(Substr(Arg.i,1,6)) = 'COMMIT' Then\n        Commit = 'YES'\n      When Translate(Substr(Arg.i,1,1)) = 'O'    Then\n        Mode = 'ONLINE'\n      When Translate(Substr(Arg.i,1,1)) = 'B'    Then\n        Mode = 'BATCH'\n      Otherwise\n        If DATATYPE(Arg.i, 'N') Then RowsPerPage = Arg.i\n    End\n  End\n\n  If POS(SSID,ValidSSIds,1) = 0 then\n    Do\n      SSID = RSQLDFLT('SSID')\n      NoMessage = NoMessage + 1\n      Message.NoMessage = '  RSQLEXEC: Invalid SSID supplied, ',\n        ||'SSID Defaulted to: ' || SSID\n      If POS(SSID,ValidSSIds,1) = 0 then\n        Do\n          NoMessage = NoMessage + 1\n          Message.NoMessage = '  RSQLEXEC: Default SSID is invalid. ',\n            ||'Unalbe to determine where to connect to.'\n          Say Message.NoMessage\n          Do m  = 1 to NoMessage\n            Say Message.m\n          End\n          Return 12\n        End\n    End\n\n/* ================================================================== */\n/* Parameters have been validated or defaulted.                       */\n/*                                                                    */\n/* TRACE ?R */\n\n/* ================================================================== */\n/* Read Input SQL datasaet.                                           */\n\n  If RSQLINDSN = '' then\n    Do\n      NoMessage = NoMessage + 1\n      Message.NoMessage = '  RSQLEXEC: Input dataset is not',\n        'allocated, nothing to do.'\n      Do m  = 1 to NoMessage\n        Say Message.m\n      End\n      Return 12\n    end\n\n  \"NEWSTACK\"\n  \"ALLOC F(\"RSQLINDD\") SHR REUSE\"\n  \"EXECIO * DISKR RSQLIN (OPEN\"\n  \"EXECIO 0 DISKR RSQLIN (FINIS\"\n\n/* ================================================================== */\n/* Place all Records into the SQLFile Stem                            */\n\n  Drop SQLFile.\n  SQLFile.NoRecs = QUEUED()\n  If SQLFile.NoRecs < 1 then\n    Do\n      NoMessage = NoMessage + 1\n      Message.NoMessage = '  RSQLEXEC: Input dataset is empty or ',\n        'cannot be read, nothing to do.'\n      Do m  = 1 to NoMessage\n        Say Message.m\n      End\n      Return 12\n    end\n\n  Drop SQLFile.Record.\n  Do i = 1 to SQLFile.NoRecs\n    PARSE PULL Line\n    SQLFile.Record.i = Strip(Line)\n  end\n\n  \"Free FILE(RSQLIN)\"\n  \"DELSTACK\"\n\n/* ================================================================== */\n/* Determine the output dataset mask and type.                        */\n/*                                                                    */\n  Select\n    When ResultType = 'QUERY' then\n      FileExtension = 'Q.TXT'\n    When ResultType = 'FLAT' then\n      FileExtension = 'F.TXT'\n    When ResultType = 'CSV' then\n      FileExtension = 'CSV'\n    When ResultType = 'CSVNoHeader' then\n      FileExtension = 'CSV'\n    When ResultType = 'HTML' then\n      FileExtension = 'HTML'\n    Otherwise\n      FileExtension = 'TXT'\n  end\n\n  Call OutputMask SSID RSQLIN OutDSNMask\n\n/* ================================================================== */\n/* Allocate and open the Result output dataset.                       */\n/* Write out operating parameters to Outut dataset.                   */\n/*                                                                    */\n\n  IF RSQLOutDSN = '' Then RSQLOutDSN = OutDSNMask'.RSQLOUT.TXT'\n\n  \"NEWSTACK\"\n\n  PgeCnt       = 0\n  PgeLnCnt     = 0\n  RowCount     = 0\n  RecCount     = 0\n  PageHeadings = ''\n\n  MaxDataLn    = 0\n  NoBytes      = 0\n  drop ColLn.\n\n  Row = Left('-- =',72,'=')\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Row = '-- Summary of processing completed on : ' || DATE('S')\n  Row = Row || ' at ' || TIME('L')\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Row = '-- Parameters Passed to RSQLEXEC: '\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Row = '--   'SSID','ResultType','RSQLIN\n  If ResultYpe = 'Query' Then\n     Row = Row ','RowsPerPage\n  If ResultYpe = 'CSV' | ResultYpe = 'CSVNoHeader' Then\n     Row = Row ','TextQualifier\n  If ResultYpe = 'HTML' Then\n     Row = Row ','PageTitle\n  Row = Row','RSQLIN\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  If Mode = 'ONLINE' Then\n    Do\n\n      MngmntCls  =  RSQLDFLT('MngmntCls')\n      StorageCls =  RSQLDFLT('StorageCls')\n\n      \"DELETE '\"RSQLOutDSN\"' PURGE SCRATCH\"\n      ALLOCOUT = \"DA('\"RSQLOutDSN\"') F(\"RSQLOutDD\")\"\n      ALLOCOUT = ALLOCOUT' NEW MGMTCLAS('MngmntCls')'\n      ALLOCOUT = ALLOCOUT' STORCLAS('StorageCls')'\n      ALLOCOUT = ALLOCOUT' LRECL(4096)'\n      ALLOCOUT = ALLOCOUT' RECFM(V)'\n\n      \"ALLOC \"ALLOCOUT\n\n    end /* do */\n\n  If Mode = 'BATCH' Then\n    Do\n      ALLOCOUT = 'FILE('RSQLOutDD') DA('RSQLOutDSN') MOD '\n      \"ALLOC \"ALLOCOUT\n    end  /* do */\n\n  \"EXECIO \"queued()\" DISKW \"RSQLOutDD\" (OPEN\"\n  \"DELSTACK\"\n\n/* ================================================================== */\n/* Connect to DB2, and process input SQL Statements.                  */\n/*                                                                    */\n\n  SQLStmnt = ''\n  NoStmnt  = 0\n  NoRs     = 0\n  NoExecI  = 0\n  NoExec   = 0\n\n  Address TSO \"SUBCOM DSNREXX \"\n  If RC Then S_RC = RXSUBCOM('ADD','DSNREXX','DSNREXX')\n\n\n  LastAct = 'CONNECT ' || SSID\n  Address DSNREXX \" CONNECT \" SSID\n\n  Do NoRec = 1 to SQLFile.NoRecs\n    i = POS('--',SQLFile.Record.NoRec)\n    If i > 0 then\n      Do\n        i = i - 1\n        Line = SUBSTR(SQLFile.Record.NoRec,1,i)\n      end\n    else\n        Line = SUBSTR(SQLFile.Record.NoRec,1)\n    LineLn = Length(Line)\n    If LineLn > 0 then\n      Do\n        SQLStmnt = SQLStmnt || Line || ' '\n        i = Length(SQLStmnt) - 1\n        If substr(SQLStmnt,i,1) = ';' then\n          Do\n            SQLStmnt = substr(SQLStmnt,1,i-1)\n            SQLStmnt = RSQLTRIM(SQLStmnt)\n            StmntTyp = SubWord(SQLStmnt,1,1)\n            StmntTyp = Translate(StmntTyp)\n            Select\n              When StmntTyp = 'SELECT' Then\n                Call DoCursor\n              When StmntTyp = 'UPDATE' Then\n                Call DoExecImmediate\n              When StmntTyp = 'DELETE' Then\n                Call DoExecImmediate\n              When StmntTyp = 'INSERT' Then\n                Call DoExecImmediate\n              Otherwise\n                Call DoExec\n            end\n            SQLStmnt = ''\n          end\n      end\n  end\n\n  If SQLStmnt \u00ac= '' then\n    Do\n      SQLStmnt = RSQLTRIM(SQLStmnt)\n      StmntTyp = SubWord(SQLStmnt,1,1)\n      StmntTyp = Translate(StmntTyp)\n      Select\n        When StmntTyp = 'SELECT' Then\n          Call DoCursor\n        When StmntTyp = 'UPDATE' Then\n          Call DoExecImmediate\n        When StmntTyp = 'DELETE' Then\n          Call DoExecImmediate\n        When StmntTyp = 'INSERT' Then\n          Call DoExecImmediate\n        Otherwise\n          Call DoExec\n      end\n      SQLStmnt = ''\n    end\n\n  If Commit = 'YES' Then\n    Do\n      LastAct = 'COMMIT'\n      Address DSNREXX \"EXECSQL\" \"COMMIT\"\n      Row = Left('-- =',72,'=')\n      Call QueueOut\n      Row = '-- '\n      Call QueueOut\n      Row = '-- Commit Performed: SQLCODE =' SQLCODE\n      Call QueueOut\n      Row = '-- '\n      Call QueueOut\n      If      SQLCODE \u00ac= 0 Then Call SQLError\n      Row = '-- '\n      Call QueueOut\n      Row = Left('-- =',72,'=')\n      Call QueueOut\n    End\n  Else\n    Do\n      Call RSQLRollback\n    End\n\n  LastAct = 'DISCONNECT'\n  Address DSNREXX \"DISCONNECT\"\n  If SQLCODE \u00ac= 0 &  SQLCODE \u00ac= -924 Then Call SQLError\n\n  Row = '-- End of SQL Input File Reached '\n  Call QueueOut\n  Row = Left('-- =',72,'=')\n  Call QueueOut\n\n  \"EXECIO \"queued()\" DISKW \"RSQLOutDD\" (FINIS\"\n  \"Free FILE(\"RSQLOutDD\")\"\n\n  Call OutputSQLDA\n\n  Return ReturnCode\n\n/* ================================================================== */\n/* DoCursor executes the statement If it is a select statemnt         */\n/*                                                                    */\nDoCursor:\n\n  \"NEWSTACK\"\n\n  PgeCnt    = 0\n  PgeLnCnt  = 0\n  RowCount  = 0\n  RecCount  = 0\n  PageHeadings = ''\n\n  MaxDataLn = 0\n  NoBytes   = 0\n  NoStmnt   = NoStmnt + 1\n\n  drop CurSQLDA.\n  drop ColLn.\n\n  STMTDCLR  = 'Declare  C'NoStmnt' cursor for S'NoStmnt\n  STMTPRPR  = 'Prepare  S'NoStmnt' into :CurSQLDA from :SQLStmnt'\n  STMTDSCR  = 'Describe S'NoStmnt' into :CurSQLDA '\n  STMTOPEN  = 'Open C'NoStmnt\n  STMTFTCH  = 'Fetch C'NoStmnt' using descriptor :CurSQLDA'\n  STMTClose = 'Close C'NoStmnt\n\n  LastAct = STMTDCLR\n  Address DSNREXX \"EXECSQL \" STMTDCLR\n  If SQLCODE \u00ac= 0 Then Call SQLError\n\n  LastAct = STMTPRPR\n  Address DSNREXX \"EXECSQL \" STMTPRPR\n  If SQLCODE \u00ac= 0 Then Call SQLError\n\n/*LastAct = STMTDSCR                                                  */\n/*Address DSNREXX \"EXECSQL \" STMTDSCR                                 */\n/*If SQLCODE \u00ac= 0 Then Call SQLError                                  */\n\n  LastAct = STMTOPEN\n  Address DSNREXX \"EXECSQL \" STMTOPEN\n  If SQLCODE \u00ac= 0 Then Call SQLError\n\n  If RSQLDADSN > '' Then Call SaveSQLDA\n\n  Do until SQLCODE \u00ac= 0\n    LastAct = STMTFTCH\n    Address DSNREXX \"EXECSQL \" STMTFTCH\n\n    If RSQLDADSN > '' Then Call SaveSQLDA\n\n    Select\n      When SQLCODE = 0 Then\n        Do\n          If RowCount = 0 then\n            Do\n              If ResultType = 'HTML' then\n                Do\n                  Row = '<HTML>'\n                  Call QueueOut\n                  Row = '<HEAD>'\n                  Call QueueOut\n                  Row = '  <TITLE>'PageTitle'</TITLE>'\n                  Call QueueOut\n                  Row = '  <META NAME=\"generator\" CONTENT=\"RSQL\">'\n                  Call QueueOut\n                  Row = '  <META NAME=\"author\" CONTENT=\"Alan Wynne\">'\n                  Call QueueOut\n                  Row = '</HEAD>'\n                  Call QueueOut\n                  Row = '<BODY>'\n                  Call QueueOut\n                  Row = '<H1>'PageTitle'</H1><PRE>'\n                  Call QueueOut\n                end\n              Select\n                when ResultType = 'CSV' then\n                  Do i = 1 to CurSQLDA.SQLD\n                    PageHeadings = PageHeadings || TextQualifier\n                    PageHeadings = PageHeadings ||      ,\n                      CurSQLDA.i.SQLNAME\n                    PageHeadings = PageHeadings || TextQualifier\n                    If i < CurSQLDA.SQLD then\n                      PageHeadings = PageHeadings || ','\n                  end\n                when ResultType = 'HTML' then\n                  Do\n                   PageHeadings = PageHeadings || '<TABLE BORDER=1><TR>'\n                   Do i = 1 to CurSQLDA.SQLD\n                     PageHeadings = PageHeadings || '<TD>'\n                     PageHeadings = PageHeadings ||      ,\n                      STRIP(CurSQLDA.i.SQLNAME,T)\n                     PageHeadings = PageHeadings || '</TD>'\n                   end\n                   PageHeadings = PageHeadings || '</TR>'\n                  end\n                when ResultType = 'FLAT' then\n                  Do\n                   Row = ''\n                   Do i = 1 to CurSQLDA.SQLD\n                    Select\n                      when CurSQLDA.i.SQLTYPE = 480 Then\n                        ColLn.i = 20\n                      when CurSQLDA.i.SQLTYPE = 481 Then\n                        ColLn.i = 20\n                      when CurSQLDA.i.SQLTYPE = 484 Then\n                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2\n                      when CurSQLDA.i.SQLTYPE = 485 Then\n                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2\n                      when CurSQLDA.i.SQLTYPE = 496 Then\n                        ColLn.i = 11\n                      when CurSQLDA.i.SQLTYPE = 497 Then\n                        ColLn.i = 11\n                      when CurSQLDA.i.SQLTYPE = 500 Then\n                        ColLn.i = 6\n                      when CurSQLDA.i.SQLTYPE = 501 Then\n                        ColLn.i = 6\n                      when CurSQLDA.i.SQLTYPE = 504 Then\n                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2\n                      when CurSQLDA.i.SQLTYPE = 505 Then\n                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2\n                      otherwise\n                        ColLn.i = CurSQLDA.i.SQLLEN\n                    end\n                   end\n                  end\n                when ResultType = 'CSVNoHeader' then NOP\n                otherwise\n                 Do i = 1 to CurSQLDA.SQLD\n                    Select\n                      when CurSQLDA.i.SQLTYPE = 480 Then\n                        ColLn.i = 20\n                      when CurSQLDA.i.SQLTYPE = 481 Then\n                        ColLn.i = 20\n                      when CurSQLDA.i.SQLTYPE = 484 Then\n                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2\n                      when CurSQLDA.i.SQLTYPE = 485 Then\n                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2\n                      when CurSQLDA.i.SQLTYPE = 496 Then\n                        ColLn.i = 11\n                      when CurSQLDA.i.SQLTYPE = 497 Then\n                        ColLn.i = 11\n                      when CurSQLDA.i.SQLTYPE = 500 Then\n                        ColLn.i = 6\n                      when CurSQLDA.i.SQLTYPE = 501 Then\n                        ColLn.i = 6\n                      when CurSQLDA.i.SQLTYPE = 504 Then\n                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2\n                      when CurSQLDA.i.SQLTYPE = 505 Then\n                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2\n                      otherwise\n                        ColLn.i = CurSQLDA.i.SQLLEN\n                    end\n                  If LENGTH(CurSQLDA.i.SQLNAME) > ColLn.i Then\n                    ColLn.i = LENGTH(CurSQLDA.i.SQLNAME) + ColumnGapSize\n                  else\n                    ColLn.i = ColLn.i + ColumnGapSize\n                  PageHeadings = PageHeadings ||    ,\n                    LEFT(CurSQLDA.i.SQLNAME,ColLn.i,' ')\n                 end\n              end\n              If ResultType \u00ac= 'FLAT' then\n                Do\n                  PgeLnCnt = 0\n                  Row = PageHeadings\n                  Call QueueOut\n                  PgeCnt = PgeCnt + 1\n                end\n            end\n          If ResultType = 'QUERY' then\n            If RowsPer Page > 0 & PgeLnCnt >= RowsPerPage then\n              Do\n                PgeLnCnt = 0\n                Row = PageHeadings\n                Call QueueOut\n                PgeCnt = PgeCnt + 1\n              end\n          If ResultType = 'HTML' then Row = '<TR>'\n          Do i = 1 to CurSQLDA.SQLD\n              If CurSQLDA.i.SQLIND = -1 Then\n                Field = ''\n              else\n                Field = CurSQLDA.i.SQLDATA\n              Select\n              When ResultType = 'CSV' | ResultType = 'CSVNoHeader' then\n                Do\n                  Select\n                    when CurSQLDA.i.SQLTYPE = 480 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 481 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 484 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 485 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 496 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 497 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 500 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 501 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 504 Then\n                      Row = Row || Field\n                    when CurSQLDA.i.SQLTYPE = 505 Then\n                      Row = Row || Field\n                    otherwise\n                      Do\n                        Field = STRIP(Field,T)\n                        If TextQualifier \u00ac= '' then\n                          do\n                            Row = Row || TextQualifier\n                            FieldLn = LENGTH(Field)\n                            j = 1\n                            Do While j < FieldLn + 1\n                              If substr(Field,j,1) = TextQualifier then\n                                Do\n                                  Fieldwrk = Substr(Field,1,j)\n                                  Field = Fieldwrk || Substr(Field,j)\n                                  FieldLn = Length(Field)\n                                  j = j + 1\n                                end\n                              j = j + 1\n                            end\n                            Row = Row || Field\n                            Row = Row || TextQualifier\n                          end\n                        Else\n                          Row = Row || Field\n                      end\n                  end\n                  If i < CurSQLDA.SQLD then\n                    Row = Row || ','\n                  else\n                    Row = Row || ' '\n                end\n              When ResultType = 'HTML' then\n                Do\n                  Row = Row || '<TD>' || STRIP(Field,T)\n                  Row = Row || '</TD>'\n                end\n              When ResultType = 'FLAT' then\n                Do\n                  Field = CurSQLDA.i.SQLDATA\n                  Select\n                    when CurSQLDA.i.SQLTYPE = 480 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 481 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 484 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 485 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 496 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 497 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 500 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 501 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 504 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    when CurSQLDA.i.SQLTYPE = 505 Then\n                      Row = Row || RIGHT(Field,ColLn.i,'0')\n                    otherwise\n                      Row = Row || LEFT(Field,ColLn.i,' ')\n                  end\n                end\n              otherwise\n                Row = Row || LEFT(CurSQLDA.i.SQLDATA,ColLn.i,' ')\n              end\n          end\n          If ResultType = 'HTML' then Row = Row || '</TR>'\n          RowCount = RowCount + 1\n          Call QueueOut\n        end\n      When SQLCODE = +100 Then\n        If RowCount = 0 then\n          Do\n            ReturnCode = 4\n            Select\n              When ResultType = 'CSV' | ResultType = 'CSVNoHeader' then\n                Do\n                  Row = '\"RSQL: No Rows found. Empty Result Set.\"'\n                  Call QueueOut\n                end\n              When ResultType = 'HTML' then\n                Do\n                  Row = '<HTML>'\n                  Call QueueOut\n                  Row = '<HEAD>'\n                  Call QueueOut\n                  Row = '  <TITLE>RSQL Generated Report</TITLE>'\n                  Call QueueOut\n                  Row = '  <META NAME=\"generator\" CONTENT=\"RSQL\">'\n                  Call QueueOut\n                  Row = '  <META NAME=\"author\" CONTENT=\"Alan Wynne\">'\n                  Call QueueOut\n                  Row = '</HEAD>'\n                  Call QueueOut\n                  Row = '<BODY><PRE>'\n                  Call QueueOut\n                  Row = '<H1>RSQL Generated Report</H1>'\n                  Call QueueOut\n                  Row = '<P>No Rows found. Empty Result Set.</P>'\n                  Call QueueOut\n                end\n              otherwise\n                Do\n                  Row = 'RSQL: No Rows found. Empty Result Set.'\n                  Call QueueOut\n                end\n            end\n          end\n      otherwise\n        Call SQLError\n    end\n  end\n\n  If ResultType = 'HTML' then\n    Do\n     Row = '</TABLE>'\n     Call QueueOut\n     Row = '</PRE>'\n     Call QueueOut\n     Row = '</BODY>'\n     Call QueueOut\n     Row = '</HTML>'\n     Call QueueOut\n    end\n\n  LastAct = STMTCLOSE\n  Address DSNREXX \"EXECSQL \" STMTCLOSE\n  If SQLCODE \u00ac= 0 Then Call SQLError\n\n  NoRS = NoRS + 1\n  OutDD = 'RS'        || RIGHT(NoRS,6,'0')\n  OutDSN = OutDSNMask || '.' || OutDD || '.' || FileExtension\n  Disp = 'NEW'\n\n  Call WriteOutput\n\n  \"DELSTACK\"\n  \"NEWSTACK\"\n\n  Row = Left('-- =',72,'=')\n  Call QueueOut\n\n  Row = '-- SQL Statement Executed : 'NoStmnt\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Call SQLFormat\n\n  Row = '  ;'\n  Call QueueOut\n\n  Row = '-- End of Sql Statement'\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Row = '-- Error and Warning Messages : 'NoMessage\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Do i = 1 to NoMessage until i > NoMessage\n    Row = '-- 'Message.i\n    Call QueueOut\n  end\n\n  If NoMessage > 0 Then\n    Do\n      Row = '-- '\n      Call QueueOut\n    end\n\n  Row = '-- Statistics '\n  Call QueueOut\n\n  Row = '-- Headings  Records  Rows    Bytes    Max Lngth  '  ,\n      'Avg Size'\n  Call QueueOut\n\n  NoBytes = NoBytes + 62\n  RecCount = RecCount + 1\n  AvgRecSize = NoBytes/RecCount\n\n  Row = '-- 'Right(PgeCnt,6,'0')'    'Right(RecCount,6,'0'),\n    '  'Right(RowCount,6,'0')'  'Right(NoBytes,6,'0')'  ',\n    Right(MaxDataLn,6,'0')'    'Right(AvgRecSize,6,'0')' '\n  Call QueueOut\n\n  OutDSN = OutDSNMask || '.RSQLOUT.TXT'\n  OutDD = 'RSQLOUT'\n  Disp = 'MOD'\n\n  Call WriteOutput\n\n  \"DELSTACK\"\n\n  Return\n\n/* ================================================================== */\n/* Perform statements that cannot be prepared.                        */\n/*                                                                    */\n\nDoExecImmediate:\n\n  \"NEWSTACK\"\n\n  PgeCnt = 0\n  PgeLnCnt = 0\n  RowCount = 0\n  RecCount = 0\n  PageHeadings = ''\n\n  MaxDataLn = 0\n  NoBytes = 0\n  NoStmnt = NoStmnt + 1\n  drop CurSQLDA.\n  drop ColLn.\n\n  Disp = 'MOD'\n\n  STMTEXEC = 'Execute  Immediate  :SQLStmnt'\n\n  LastAct = STMTEXEC\n  Address DSNREXX \"EXECSQL \" STMTEXEC\n\n  If RSQLDADSN > '' Then Call SaveSQLDA\n\n  Row = Left('-- =',72,'=')\n  Call QueueOut\n\n  Row = '-- SQL Statement Executed : 'NoStmnt\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Call SQLFormat\n\n  Row = '  ;'\n  Call QueueOut\n\n  Row = '-- End of Sql Statement'\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Row = '-- Error and Warning Messages : 'NoMessage\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Do i = 1 to NoMessage until i > NoMessage\n    Row = '-- 'Message.i\n    Call QueueOut\n  end\n\n  If NoMessage \u00ac= 0 Then\n    Do\n      Row = '-- '\n      Call QueueOut\n    end\n\n  If SQLCODE \u00ac= 0 & SQLCODE \u00ac= +100 Then Call SQLError\n\n  If j > MaxDataLn then MaxDataLn = j\n  OutDSN = OutDSNMask || '.RSQLOUT.TXT'\n  OutDD = RSQLOutDD\n\n  Call WriteOutput\n\n  \"DELSTACK\"\n\n  Return\n\n/* ================================================================== */\n/* DoExecute executes non Cursor commands that need to be prepared.   */\n/*                                                                    */\n\nDoExec:\n\n  \"NEWSTACK\"\n\n  PgeCnt = 0\n  PgeLnCnt = 0\n  RowCount = 0\n  RecCount = 0\n  PageHeadings = ''\n\n  MaxDataLn = 0\n  NoBytes = 0\n  NoStmnt = NoStmnt + 1\n  drop CurSQLDA.\n  drop ColLn.\n\n  Disp = 'MOD'\n\n  STMTDCLR = 'Declare  S001 Statement '\n  STMTPRPR = 'Prepare  S001 into  :CurSQLDA from :SQLStmnt'\n  STMTDSCR = 'Describe S001 into  :CurSQLDA '\n  STMTEXEC = 'Execute  S001 using :CurSQLDA '\n\n  LastAct = STMTDCLR\n  Address DSNREXX \"EXECSQL \" STMTDCLR\n  If SQLCODE \u00ac= 0 Then Call SQLError\n\n  LastAct = STMTPRPR\n  Address DSNREXX \"EXECSQL \" STMTPRPR\n  If SQLCODE \u00ac= 0 Then Call SQLError\n\n/*LastAct = STMTDSCR                                                  */\n/*Address DSNREXX \"EXECSQL \" STMTDSCR                                 */\n/*If SQLCODE \u00ac= 0 Then Call SQLError                                  */\n\n  LastAct = STMTEXEC\n  Address DSNREXX \"EXECSQL \" STMTEXEC\n  If SQLCODE \u00ac= 0 Then Call SQLError\n\n  If RSQLDADSN > '' Then Call SaveSQLDA\n\n  Row = Left('-- =',72,'=')\n  Call QueueOut\n\n  Row = '-- SQL Statement Executed : 'NoStmnt\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Call SQLFormat\n\n  Row = '  ;'\n  Call QueueOut\n\n  Row = '-- End of Sql Statement'\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Row = '-- Error and Warning Messages : 'NoMessage\n  Call QueueOut\n\n  Row = '-- '\n  Call QueueOut\n\n  Do i = 1 to NoMessage until i > NoMessage\n    Row = '-- 'Message.i\n    Call QueueOut\n  end\n\n  If NoMessage > 0 Then\n    Do\n      Row = '-- '\n      Call QueueOut\n    end\n\n  If SQLCODE \u00ac= 0 Then Call SQLError\n\n  If j > MaxDataLn then MaxDataLn = j\n  OutDSN = OutDSNMask || '.RSQLOUT.TXT'\n  OutDD = RSQLOutDD\n\n  Call WriteOutput\n\n  \"DELSTACK\"\n\n  Return\n\n/* ================================================================== */\n/* Split SQL Statement string into seperate lines when a certain      */\n/* reseved words occur.                                               */\n/*                                                                    */\n\nSQLFormat:\n\n/* TRACE ?R */\n\n  StmntLen    = Length(SQLStmnt)\n  LineLen     = 68\n  PosLstSpc   = 0\n  PosLstComma = 0\n  StrtPos     = 1\n\n  Do while LineLen > 0\n     StmntLine   = Substr(SQLStmnt,StrtPos)\n     StmntLine   = Strip(StmntLine)\n     LineLen     = Length(StmntLine)\n     if LineLen > 68 Then\n       Do\n         StmntLine   = SubStr(StmntLine,1,68)\n         LineLen     = Length(StmntLine)\n         PosLstSpc   = LASTPOS(' ',StmntLine)\n         PosLstComma = LASTPOS(',',StmntLine)\n         Select\n           When PosLstSpc = 0 & PosLstComma = 0 then\n             Do\n               StmntLine = SubStr(StmntLine,1,70)\n               StrtPos   = StrtPos + 70\n             End\n           When PosLstSpc > 0 & PosLstComma = 0 then\n             Do\n               StmntLine = SubStr(StmntLine,1,PosLstSpc)\n               StrtPos   = StrtPos + PosLstSpc\n             End\n           When PosLstSpc = 0 & PosLstComma > 0 then\n             Do\n               StmntLine = SubStr(StmntLine,1,PosLstSpc)\n               StrtPos   = StrtPos + PosLstComma\n             End\n           Otherwise\n             Do\n               StmntLine = SubStr(StmntLine,1,PosLstSpc)\n               StrtPos   = StrtPos + PosLstSpc\n             End\n         End\n       End\n     Else\n       StrtPos = StrtPos + LineLen\n     Row = '   'StmntLine\n     Call QueueOut\n  end\n\nReturn\n/* ================================================================== */\n/* Create and Write to the Output Dataset.                            */\n/*                                                                    */\n\nWriteOutput:\n\n/* TRACE ?R */\n\n\n  If OutDD = 'RSQLOUT' then\n    \"EXECIO \"queued()\" DISKW \"RSQLOutDD\" \"\n  Else If Mode = 'ONLINE' Then\n    Do\n      If Disp = 'NEW' Then \"DELETE '\"OutDSN\"' PURGE SCRATCH\"\n      MaxDataLn = MaxDataLn + 4\n\n      MngmntCls =  RSQLDFLT('MngmntCls')\n      StorageCls =  RSQLDFLT('StorageCls')\n\n      ALLOCOUT = \"DA('\"OutDSN\"') F(\"OutDD\")\"\n      ALLOCOUT = ALLOCOUT  Disp' MGMTCLAS('MngmntCls')'\n      ALLOCOUT = ALLOCOUT' STORCLAS('StorageCls')'\n      ALLOCOUT = ALLOCOUT' LRECL('MaxDataLn')'\n      ALLOCOUT = ALLOCOUT' RECFM(V)'\n\n      \"ALLOC \"ALLOCOUT\n\n      \"EXECIO \"queued()\" DISKW \"OutDD\" (OPEN\"\n      \"EXECIO \"queued()\" DISKW \"OutDD\" (FINIS\"\n\n      \"Free DA('\"OutDSN\"')\"\n      SAY '  RSQLEXEC: Output written to Dataset : ' OutDSN\n\n    end\n  Else If Mode = 'BATCH' Then\n    Do\n      OutDSN = DSNSearch(OutDD)\n      MaxDataLn = MaxDataLn + 4\n\n      MngmntCls =  RSQLDFLT('MngmntCls')\n      StorageCls =  RSQLDFLT('StorageCls')\n\n      ALLOCOUT = 'F('OutDD') DA('OutDsn')MOD'\n\n      \"ALLOC \"ALLOCOUT\n\n      \"EXECIO \"queued()\" DISKW \"OutDD\" (OPEN\"\n      \"EXECIO \"queued()\" DISKW \"OutDD\" (FINIS\"\n\n      \"Free FILE(\"OutDD\")\"\n      SAY '  RSQLEXEC: Output written to: '\n      SAY '    DD 'OutDD' DSN='OutDSN\n\n    end\n\n\n  Return\n\n/* ================================================================== */\n/* Determine the output dataset mask.                                 */\n/*                                                                    */\nOutputMask:\n\n  OutDSNMask = Userid()   || '.'  || SSID\n  OutDSNMask = OutDSNMask || '.DT' || SUBSTR(DATE('S'),3)\n\n  Member = ''\n\n  i = POS('(',RSQLIN)\n  j = POS(')',RSQLIN)\n  k = Length(RSQLIN)\n  l = LastPOS('.',RSQLIN)\n  If i > 0  then\n    If j > i then\n      Do\n        MemLn = j - i - 1\n        Member = substr(RSQLIN,i+1,MemLn)\n        OutDSNMask = OutDSNMask || '.' || Member\n      end\n    Else\n      If k > 0 and k < l then\n        OutDSNMask = OutDSNMask || substr(RSQLIN,l)\n  Else\n    If k > 0 and k < l then\n      OutDSNMask = OutDSNMask || substr(RSQLIN,l)\n\n  Return\n/* ================================================================== */\n/* Perform Rollback for unexpected errors.                            */\n/*                                                                    */\nRSQLRollback:\n\n      LastAct = 'ROLLBACK'\n      Address DSNREXX \"EXECSQL\" \"ROLLBACK\"\n      Row = Left('-- =',72,'=')\n      Call QueueOut\n      Row = '-- '\n      Call QueueOut\n      Row = '-- Rollback Performed: SQLCODE =' SQLCODE\n      Call QueueOut\n      Row = '-- '\n      Call QueueOut\n      If      SQLCODE \u00ac= 0 Then Call SQLError\n      Row = Left('-- =',72,'=')\n      Call QueueOut\n\n  Return\n/* ================================================================== */\n/* Display SQLError                                                   */\n/*                                                                    */\n\nSQLError:\n\n/* TRACE ?R */\n\n  Commit = 'No'\n  ReturnCode = 12\n\n  Row = Left('-- =',72,'=')\n  Say Row\n  Call QueueOut\n  Row = '-- SQL Error occurred.'\n  Say Row\n  Call QueueOut\n  Row = '-- '\n  Say Row\n  Call QueueOut\n  Row = '-- Last Action : 'LastAct\n  Say Row\n  Call QueueOut\n  Row = '-- Sql Statement :'\n  Say Row\n  Call QueueOut\n  Row = '-- '\n  Say Row\n  Call QueueOut\n\n  Call SQLFormat\n\n  Row = '  ;'\n  Say Row\n  Call QueueOut\n  Row = Left('-- =',72,'=')\n  Say Row\n  Call QueueOut\n  Row = '--'\n  Say Row\n  Call QueueOut\n  Row = '--  SQLDA : '\n  Say Row\n  Call QueueOut\n  Row = '--'\n  Say Row\n  Call QueueOut\n  Row = '-- SQLCODE   =<'SQLCODE'>'\n  Say Row\n  Call QueueOut\n  Row = '-- SQLERRMC  =<'SQLERRMC'>'\n  Say Row\n  Call QueueOut\n  Row = '-- SQLERRP   =<'SQLERRP'>'\n  Say Row\n  Call QueueOut\n  Row = '-- SQLERRD   =<'SQLERRD.1  || '>,<',\n                 || SQLERRD.2  || '>,<',\n                 || SQLERRD.3  || '>,<',\n                 || SQLERRD.4  || '>,<',\n                 || SQLERRD.5  || '>,<',\n                 || SQLERRD.6  || '>'\n  Say Row\n  Call QueueOut\n  Row = '-- SQLWARN   =<'SQLWARN.0  || '>,<',\n                 || SQLWARN.1  || '>,<',\n                 || SQLWARN.2  || '>,<',\n                 || SQLWARN.3  || '>,<',\n                 || SQLWARN.4  || '>,<',\n                 || SQLWARN.5  || '>,<',\n                 || SQLWARN.6  || '>,<',\n                 || SQLWARN.7  || '>,<',\n                 || SQLWARN.8  || '>,<',\n                 || SQLWARN.9  || '>,<',\n                 || SQLWARN.10 || '>'\n  Say Row\n  Call QueueOut\n  Row = '-- SQLSTATE  <'SQLSTATE'>'\n  Say Row\n  Call QueueOut\n\n  Row = Left('-- =',72,'=')\n  Say Row\n  Call QueueOut\n\n  Return\n/* ================================================================== */\n/* Save the SQLDA in an Array.                                        */\n/*                                                                    */\nSaveSQLDA:\n\n  IF RSQLDADSN = '' Then Return\n\n  NoSQLDA   = NoSQLDA + 1\n\n  SavedSQLDAs.NoSQLDA.SQLD = CurSQLDA.SQLD\n\n  If CurSQLDA.SQLD > 0 then\n    Do i = 1 to CurSQLDA.SQLD\n\n      if CurSQLDA.i.SQLTYPE             = 'CURSQLDA.'i'.SQLTYPE'    then\n          SavedSQLDAs.NoSQLDA.i.SQLTYPE = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLTYPE = CurSQLDA.i.SQLTYPE\n\n      if CurSQLDA.i.SQLLEN              = 'CURSQLDA.'i'.SQLLEN'     then\n          SavedSQLDAs.NoSQLDA.i.SQLLEN  = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLLEN  = CurSQLDA.i.SQLLEN\n\n      if CurSQLDA.i.SQLLEN.SQLPRECISION =  ,\n        'CURSQLDA.'i'.SQLLEN.SQLPRECISION'                         then\n          SavedSQLDAs.NoSQLDA.i.SQLLEN.SQLPRECISION = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLLEN.SQLPRECISION = ,\n            CurSQLDA.i.SQLLEN.SQLPRECISION\n\n      if CurSQLDA.i.SQLLEN.SQLSCALE     =  ,\n        'CURSQLDA.'i'.SQLLEN.SQLSCALE'                              then\n          SavedSQLDAs.NoSQLDA.i.SQLLEN.SQLSCALE = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLLEN.SQLSCALE = ,\n            CurSQLDA.i.SQLLEN.SQLSCALE\n\n      if    CurSQLDA.i.SQLCCSID         = 'CURSQLDA.'i'.SQLCCSID'   then\n          SavedSQLDAs.NoSQLDA.i.SQLCCSID = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLCCSID = CurSQLDA.i.SQLCCSID\n\n      if    CurSQLDA.i.SQLLOCATOR       = 'CURSQLDA.'i'.SQLLOCATOR' then\n          SavedSQLDAs.NoSQLDA.i.SQLLOCATOR = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLLOCATOR = CurSQLDA.i.SQLLOCATOR\n\n      if    CurSQLDA.i.SQLDATA          = 'CURSQLDA.'i'.SQLDATA'    then\n          SavedSQLDAs.NoSQLDA.i.SQLDATA = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLDATA = CurSQLDA.i.SQLDATA\n\n      if    CurSQLDA.i.SQLIND           = 'CURSQLDA.'i'.SQLIND'     then\n          SavedSQLDAs.NoSQLDA.i.SQLIND  = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLIND  = CurSQLDA.i.SQLIND\n\n      if    CurSQLDA.i.SQLNAME          = 'CURSQLDA.'i'.SQLNAME'    then\n          SavedSQLDAs.NoSQLDA.i.SQLNAME = ''\n      else\n          SavedSQLDAs.NoSQLDA.i.SQLNAME = CurSQLDA.i.SQLNAME\n\n    End\n\n  Return\n\n/* ================================================================== */\n/* Display the SQLDA's.                                               */\n/*                                                                    */\nOutputSQLDA:\n\n  IF RSQLDADSN = '' Then Return\n\n  \"NEWSTACK\"\n\n  Row = Left('-- =',72,'=')\n  Call QueueOut\n\n  Row = Left('--  ',72,' ')\n  Call QueueOut\n\n  Row = \"--  Number of Saved SQLDA's = \"NoSQLDA\n  Call QueueOut\n\n  Row = Left('--  ',72,' ')\n  Call QueueOut\n\n  Do i = 1 to NoSQLDA\n\n    Row = Left('-- -',72,'-')\n    Call QueueOut\n\n    Row = '--  SQLDA 'i\n    Call QueueOut\n\n    Row = Left('--  ',72,' ')\n    Call QueueOut\n\n    if SavedSQLDAs.i.SQLD                   \u00ac= ''                  then\n      Do\n        Row = '-- SQLDA.SQLD=<'SavedSQLDAs.i.SQLD'>'\n        Call QueueOut\n      End\n\n    If SavedSQLDAs.i.SQLD > 0                                      then\n      Do j = 1 to SavedSQLDAs.i.SQLD\n\n        if SavedSQLDAs.i.j.SQLTYPE          \u00ac= ''                  then\n          Do\n            Row = '<SQLDA.'i'.'j'.SQLTYPE>=<'SavedSQLDAs.i.j.SQLTYPE'>'\n            Call QueueOut\n          End\n\n        if SavedSQLDAs.i.j.SQLLEN           \u00ac= ''                  then\n          Do\n            Row = '<SQLDA.'i'.'j'.SQLLEN>=<'SavedSQLDAs.i.j.SQLLEN'>'\n            Call QueueOut\n          End\n\n        if SavedSQLDAs.i.j.SQLLEN.SQLPRECISION \u00ac= ''               then\n          Do\n            Row = '<SQLDA.'i'.'j'.SQLLEN.SQLPRECISION>=<' || ,\n              SavedSQLDAs.i.j.SQLLEN.SQLPRECISION'>'\n            Call QueueOut\n          End\n\n        if SavedSQLDAs.i.j.SQLLEN.SQLSCALE  \u00ac= ''                  then\n          Do\n            Row = '<SQLDA.'i'.'j'.SQLLEN.SQLSCALE>=<' || ,\n              SavedSQLDAs.i.j.SQLLEN.SQLSCALE'>'\n            Call QueueOut\n          End\n\n        if    SavedSQLDAs.i.j.SQLCCSID      \u00ac= ''                  then\n          Do\n          Row = '<SQLDA.'i'.'j'.SQLCCSID>=<'SavedSQLDAs.i.j.SQLCCSID'>'\n            Call QueueOut\n          End\n\n        if    SavedSQLDAs.i.j.SQLLOCATOR    \u00ac= ''                  then\n          Do\n            Row = '<SQLDA.'i'.'j'.SQLLOCATOR>=<' || ,\n              SavedSQLDAs.i.j.SQLLOCATOR'>'\n            Call QueueOut\n          End\n\n        if    SavedSQLDAs.i.j.SQLDATA       \u00ac= ''                  then\n          Do\n            Row = '<SQLDA.'i'.'j'.SQLDATA>=<'SavedSQLDAs.i.j.SQLDATA'>'\n            Call QueueOut\n          End\n\n        if    SavedSQLDAs.i.j.SQLIND        \u00ac= ''                  then\n          Do\n            Row = '<SQLDA.'i'.'j'.SQLIND>=<'SavedSQLDAs.i.j.SQLIND'>'\n            Call QueueOut\n          End\n\n        if    SavedSQLDAs.i.j.SQLNAME       \u00ac= ''                  then\n          Do\n            Row = '<SQLDA.'i'.'j'.SQLNAME>=<' || ,\n              SavedSQLDAs.i.j.SQLNAME'>'\n            Call QueueOut\n          End\n\n      End\n\n  End\n\n  ALLOCOUT = 'FILE('RSQLDA') DA('RSQLDADSN' MOD '\n  \"ALLOC \"ALLOCOUT\n\n  \"EXECIO \"queued()\" DISKW \"RSQLDADD\" (OPEN\"\n  \"DELSTACK\"\n\n  Return\n/* ================================================================== */\n/* Queue a record for output to the output File                       */\n/*                                                                    */\n\nQueueOut:\n\n/* TRACE ?R */\n\n  RowLn = Length(Row)\n  If MaxDataLn < RowLn then MaxDataLn = RowLn\n  NoBytes = NoBytes     + RowLn\n  RecCount = RecCount + 1\n  PgeLnCnt = PgeLnCnt + 1\n\n  Queue Row\n  Row = ''\n\n  Return\n\n/* ================================================================== */\n/* Queue a record for output to the output File                       */\n/*                                                                    */\n\nListAloc:\n\n/* TRACE ?R */\n\n/* ================================================================== */\n/* Determine which datasets are allocated.                            */\n/*                                                                    */\n\n  Drop DatasetInfo.\n  DatasetInfo.0 = 0\n\n  BlankString = '                                                     '\n\n  x = OUTTRAP('ListAlc.')\n\n  \"LISTALC STATUS\"\n\n  if ListAlc.0 = 0 Then NOP\n  Else\n    Do i = 1 to listAlc.0\n      Select\n        When SubStr(ListAlc.i,1,2) = '--'    then NOP\n        When SubStr(ListAlc.i,1,2) = '  '    then\n          Do\n            DatasetInfo.j.DD   = Substr(ListAlc.i,3,8)\n            DatasetInfo.j.Disp = Strip(Substr(ListAlc.i,12))\n          End /* when */\n        Otherwise\n          Do\n            DatasetInfo.0      = DatasetInfo.0 + 1\n            j                  = DatasetInfo.0\n            DatasetInfo.j.DSN  = Strip(ListAlc.i)\n            DatasetInfo.j.DD   = ''\n            DatasetInfo.j.Disp = ''\n            k =  POS(' ',DatasetInfo.j.DSN,1)\n            If k > 0 then\n              Do\n                DatasetInfo.j.DD   =                                  ,\n                  Strip(Substr(DatasetInfo.j.DSN,k,))\n                DatasetInfo.j.DSN  =                                  ,\n                  Strip(Substr(DatasetInfo.j.DSN,1,k))\n              End /* if */\n          End /* otherwise */\n      End /* select */\n    End /* if */\n\n  Return\n\nDSNSearch:\n\n/* TRACE ?R */\n\n/* ================================================================== */\n/* Find the DSName for the Respective DD name provided.               */\n/*                                                                    */\n\n  Parse Arg DDSearch\n\n  DSNFound    = ''\n\n  if DDSearch = '' Then NOP\n  else\n    Do i = 1 to DatasetInfo.0\n      if DatasetInfo.i.DD = DDSearch then\n        Do\n          DSNFound = DatasetInfo.i.DSN\n          Return DSNFound\n        End\n    End\n\n  Return DSNFound\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RSQLTRIM": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x008\\x01\\x04#o\\x01\\x06\\x03\\x7f\\x169\\x00R\\x00K\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-08-23T00:00:00", "modifydate": "2006-02-06T16:39:38", "lines": 82, "newlines": 75, "modlines": 0, "user": "BSW1"}, "text": "/* REXX */\n/* =====================================================================\n * Language   : REXX\n * Name       : RSQLTRIM\n * Category   : Rexx exec\n * Description: Rexx program to remove unneccessary spaces from a\n *            : string, leaving characters enclosed in Quotes exactly as\n *            : they appear.\n * Rexx       :\n * Panels     :\n * Skeltons   : none\n * Messages   : none\n * Procedure  : none\n * Author     : Alan Wynne.\n * Owner      : Alan Wynne.\n * Created    : August 2004\n * Modified   :\n * ================================================================== */\n  Parse Arg SQLStmnt\n\n  SQLStmnt = STRIP(SQLStmnt, B)\n\n\n  StmntLen = Length(SQLStmnt)\n\n  Do i = 1 until i >= StmntLen\n    FirstChar = SubStr(SQLStmnt,i,1)\n    FirstTwoChar = SubStr(SQLStmnt,i,2)\n    Select\n      When FirstTwoChar         = '\"\"'  Then i = i + 1\n      When FirstTwoChar         = \"''\"  Then i = i + 1\n      When FirstChar            = '\"'   Then\n        Do\n          Literal    = Substr(SQLStmnt,i+1)\n          LiteralLen = Length(Literal)\n          Do j = 1 Until  j >= LiteralLen\n            Select\n              When SubStr(Literal,j,2) = '\"\"'  Then j = j + 1\n              When SubStr(Literal,j,1) = '\"'   Then\n                Do\n                  SQLStmntEnd  = Substr(Literal,j+1)\n                  Literal      = Substr(Literal,1,j)\n                  LiteralLen   = j\n                End\n              Otherwise Nop\n            End\n          End\n          SQLStmnt = SubStr(SQLStmnt,1,i)||Literal||SQLStmntEnd\n          i = i + j\n        End\n      When FirstChar            = \"'\"   Then\n        Do\n          Literal  = Substr(SQLStmnt,i+1)\n          LiteralLen = Length(Literal)\n          Do j = 1 Until  j >= LiteralLen\n            Select\n              When SubStr(Literal,j,2) = \"''\"  Then j = j + 1\n              When SubStr(Literal,j,1) = \"'\"   Then\n                Do\n                  SQLStmntEnd  = Substr(Literal,j+1)\n                  Literal      = Substr(Literal,1,j)\n                  LiteralLen   = j\n               End\n              Otherwise Nop\n            End\n          End\n          SQLStmnt = SubStr(SQLStmnt,1,i)||Literal||SQLStmntEnd\n          i = i + j\n        End\n      When FirstTwoChar         = \"  \" Then\n        Do\n          j = i + 2\n          Do  while (Substr(SQLStmnt,j,1) = \" \" & j < StmntLen)\n            j = j + 1\n          End\n          SQLStmnt = SubStr(SQLStmnt,1,i)||SubStr(SQLStmnt,j)\n          StmntLen = Length(SQLStmnt)\n        End\n      Otherwise Nop\n    End\n  End\n  Return SQLStmnt\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSVARS": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x04%/\\x01\\x06\\x03\\x7f\\x14I\\x00\\xeb\\x01\\xcc\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-09-08T00:00:00", "modifydate": "2006-02-06T14:49:45", "lines": 235, "newlines": 460, "modlines": 0, "user": "BSW1"}, "text": "  /* REXX */\n  PARSE SOURCE P1 P2 P3 P4 P5 P6 P7 P8;\n  SAY \"1 =<\" P1 \">\"\n  SAY \"2 =<\" P2 \">\"\n  SAY \"3 =<\" P3 \">\"\n  SAY \"4 =<\" P4 \">\"\n  SAY \"5 =<\" P5 \">\"\n  SAY \"6 =<\" P6 \">\"\n  SAY \"7 =<\" P7 \">\"\n  SAY \"8 =<\" P8 \">\"\n  ADDRESS ISPEXEC;\n  \"ISPEXEC VGET     (BDSYS) PROFILE \" ; SAY 'BDSYS     = ' BDSYS\n  \"ISPEXEC VGET     (SYSISPF )   \"    ; SAY 'SYSISPF   = ' SYSISPF\n  \"ISPEXEC VGET     (Z       )   \"    ; SAY 'Z         = ' Z\n  \"ISPEXEC VGET     (ZACCTNUM)   \"    ; SAY 'ZACCTNUM  = ' ZACCTNUM\n  \"ISPEXEC VGET     (ZAPLCNT )   \"    ; SAY 'ZAPLCNT   = ' ZAPLCNT\n  \"ISPEXEC VGET     (ZAPPLID )   \"    ; SAY 'ZAPPLID   = ' ZAPPLID\n  \"ISPEXEC VGET     (ZAPPTTL )   \"    ; SAY 'ZAPPTTL   = ' ZAPPTTL\n  \"ISPEXEC VGET     (ZASPECT )   \"    ; SAY 'ZASPECT   = ' ZASPECT\n  \"ISPEXEC VGET     (ZCMD    )   \"    ; SAY 'ZCMD      = ' ZCMD\n  \"ISPEXEC VGET     (ZCONT   )   \"    ; SAY 'ZCONT     = ' ZCONT\n  \"ISPEXEC VGET     (ZCS     )   \"    ; SAY 'ZCS       = ' ZCS\n  \"ISPEXEC VGET     (ZCSDLL  )   \"    ; SAY 'ZCSDLL    = ' ZCSDLL\n  \"ISPEXEC VGET     (ZCUNIT  )   \"    ; SAY 'ZCUNIT    = ' ZCUNIT\n  \"ISPEXEC VGET     (ZCURFLD )   \"    ; SAY 'ZCURFLD   = ' ZCURFLD\n  \"ISPEXEC VGET     (ZCURINX )   \"    ; SAY 'ZCURINX   = ' ZCURINX\n  \"ISPEXEC VGET     (ZCURPOS )   \"    ; SAY 'ZCURPOS   = ' ZCURPOS\n  \"ISPEXEC VGET     (ZCUSIZE )   \"    ; SAY 'ZCUSIZE   = ' ZCUSIZE\n  \"ISPEXEC VGET     (ZDATE   )   \"    ; SAY 'ZDATE     = ' ZDATE\n  \"ISPEXEC VGET     (ZDATEF  )   \"    ; SAY 'ZDATEF    = ' ZDATEF\n  \"ISPEXEC VGET     (ZDATEFD )   \"    ; SAY 'ZDATEFD   = ' ZDATEFD\n  \"ISPEXEC VGET     (ZDATESTD)   \"    ; SAY 'ZDATESTD  = ' ZDATESTD\n  \"ISPEXEC VGET     (ZDAY    )   \"    ; SAY 'ZDAY      = ' ZDAY\n  \"ISPEXEC VGET     (ZDBCS   )   \"    ; SAY 'ZDBCS     = ' ZDBCS\n  \"ISPEXEC VGET     (ZDECS   )   \"    ; SAY 'ZDECS     = ' ZDECS\n  \"ISPEXEC VGET     (ZDEL    )   \"    ; SAY 'ZDEL      = ' ZDEL\n  \"ISPEXEC VGET     (ZDEVNAM )   \"    ; SAY 'ZDEVNAM   = ' ZDEVNAM\n  \"ISPEXEC VGET     (ZDLBLKS )   \"    ; SAY 'ZDLBLKS   = ' ZDLBLKS\n  \"ISPEXEC VGET     (ZDLCDAT )   \"    ; SAY 'ZDLCDAT   = ' ZDLCDAT\n  \"ISPEXEC VGET     (ZDLDEV  )   \"    ; SAY 'ZDLDEV    = ' ZDLDEV\n  \"ISPEXEC VGET     (ZDLDSNT )   \"    ; SAY 'ZDLDSNT   = ' ZDLDSNT\n  \"ISPEXEC VGET     (ZDLDSOR )   \"    ; SAY 'ZDLDSOR   = ' ZDLDSOR\n  \"ISPEXEC VGET     (ZDLEDAT )   \"    ; SAY 'ZDLEDAT   = ' ZDLEDAT\n  \"ISPEXEC VGET     (ZDLEXT  )   \"    ; SAY 'ZDLEXT    = ' ZDLEXT\n  \"ISPEXEC VGET     (ZDLLREC )   \"    ; SAY 'ZDLLREC   = ' ZDLLREC\n  \"ISPEXEC VGET     (ZDLMIGR )   \"    ; SAY 'ZDLMIGR   = ' ZDLMIGR\n  \"ISPEXEC VGET     (ZDLRDAT )   \"    ; SAY 'ZDLRDAT   = ' ZDLRDAT\n  \"ISPEXEC VGET     (ZDLRECF )   \"    ; SAY 'ZDLRECF   = ' ZDLRECF\n  \"ISPEXEC VGET     (ZDLSIZE )   \"    ; SAY 'ZDLSIZE   = ' ZDLSIZE\n  \"ISPEXEC VGET     (ZDLSPAC )   \"    ; SAY 'ZDLSPAC   = ' ZDLSPAC\n  \"ISPEXEC VGET     (ZDLUSED )   \"    ; SAY 'ZDLUSED   = ' ZDLUSED\n  \"ISPEXEC VGET     (ZDLVOL  )   \"    ; SAY 'ZDLVOL    = ' ZDLVOL\n  \"ISPEXEC VGET     (ZDSN    )   \"    ; SAY 'ZDSN      = ' ZDSN\n  \"ISPEXEC VGET     (ZDST    )   \"    ; SAY 'ZDST      = ' ZDST\n  \"ISPEXEC VGET     (ZEDBDSN )   \"    ; SAY 'ZEDBDSN   = ' ZEDBDSN\n  \"ISPEXEC VGET     (ZEDITCM )   \"    ; SAY 'ZEDITCM   = ' ZEDITCM\n  \"ISPEXEC VGET     (ZEDROW  )   \"    ; SAY 'ZEDROW    = ' ZEDROW\n  \"ISPEXEC VGET     (ZEDSAVE )   \"    ; SAY 'ZEDSAVE   = ' ZEDSAVE\n  \"ISPEXEC VGET     (ZEDTDSN )   \"    ; SAY 'ZEDTDSN   = ' ZEDTDSN\n  \"ISPEXEC VGET     (ZEDTMCM )   \"    ; SAY 'ZEDTMCM   = ' ZEDTMCM\n  \"ISPEXEC VGET     (ZEDTMEM )   \"    ; SAY 'ZEDTMEM   = ' ZEDTMEM\n  \"ISPEXEC VGET     (ZEDTRD  )   \"    ; SAY 'ZEDTRD    = ' ZEDTRD\n  \"ISPEXEC VGET     (ZEDUSER )   \"    ; SAY 'ZEDUSER   = ' ZEDUSER\n  \"ISPEXEC VGET     (ZEIBSDN )   \"    ; SAY 'ZEIBSDN   = ' ZEIBSDN\n  \"ISPEXEC VGET     (ZEIROW  )   \"    ; SAY 'ZEIROW    = ' ZEIROW\n  \"ISPEXEC VGET     (ZEITDSN )   \"    ; SAY 'ZEITDSN   = ' ZEITDSN\n  \"ISPEXEC VGET     (ZEIUSER )   \"    ; SAY 'ZEIUSER   = ' ZEIUSER\n  \"ISPEXEC VGET     (ZENTKTXT)   \"    ; SAY 'ZENTKTXT  = ' ZENTKTXT\n  \"ISPEXEC VGET     (ZENVIR  )   \"    ; SAY 'ZENVIR    = ' ZENVIR\n  \"ISPEXEC VGET     (ZERRALR )   \"    ; SAY 'ZERRALR   = ' ZERRALR\n  \"ISPEXEC VGET     (ZERRALRM)   \"    ; SAY 'ZERRALRM  = ' ZERRALRM\n  \"ISPEXEC VGET     (ZERRHM  )   \"    ; SAY 'ZERRHM    = ' ZERRHM\n  \"ISPEXEC VGET     (ZERRLM  )   \"    ; SAY 'ZERRLM    = ' ZERRLM\n  \"ISPEXEC VGET     (ZERRMSG )   \"    ; SAY 'ZERRMSG   = ' ZERRMSG\n  \"ISPEXEC VGET     (ZERRSM  )   \"    ; SAY 'ZERRSM    = ' ZERRSM\n  \"ISPEXEC VGET     (ZERRTYPE)   \"    ; SAY 'ZERRTYPE  = ' ZERRTYPE\n  \"ISPEXEC VGET     (ZERRWIND)   \"    ; SAY 'ZERRWIND  = ' ZERRWIND\n  \"ISPEXEC VGET     (ZEURO   )   \"    ; SAY 'ZEURO     = ' ZEURO\n  \"ISPEXEC VGET     (ZFAMPRT )   \"    ; SAY 'ZFAMPRT   = ' ZFAMPRT\n  \"ISPEXEC VGET     (ZFKA    )   \"    ; SAY 'ZFKA      = ' ZFKA\n  \"ISPEXEC VGET     (ZGE     )   \"    ; SAY 'ZGE       = ' ZGE\n  \"ISPEXEC VGET     (ZGRPLVL )   \"    ; SAY 'ZGRPLVL   = ' ZGRPLVL\n  \"ISPEXEC VGET     (ZGRPNME )   \"    ; SAY 'ZGRPNME   = ' ZGRPNME\n  \"ISPEXEC VGET     (ZGUI    )   \"    ; SAY 'ZGUI      = ' ZGUI\n  \"ISPEXEC VGET     (ZHILITE )   \"    ; SAY 'ZHILITE   = ' ZHILITE\n  \"ISPEXEC VGET     (ZHINDEX )   \"    ; SAY 'ZHINDEX   = ' ZHINDEX\n  \"ISPEXEC VGET     (ZHTOP   )   \"    ; SAY 'ZHTOP     = ' ZHTOP\n  \"ISPEXEC VGET     (ZICFPRT )   \"    ; SAY 'ZICFPRT   = ' ZICFPRT\n  \"ISPEXEC VGET     (ZIND    )   \"    ; SAY 'ZIND      = ' ZIND\n  \"ISPEXEC VGET     (ZISPFOS )   \"    ; SAY 'ZISPFOS   = ' ZISPFOS\n  \"ISPEXEC VGET     (ZISPFRC )   \"    ; SAY 'ZISPFRC   = ' ZISPFRC\n  \"ISPEXEC VGET     (ZJDATE  )   \"    ; SAY 'ZJDATE    = ' ZJDATE\n  \"ISPEXEC VGET     (ZJ4DATE )   \"    ; SAY 'ZJ4DATE   = ' ZJ4DATE\n  \"ISPEXEC VGET     (ZKEYHELP)   \"    ; SAY 'ZKEYHELP  = ' ZKEYHELP\n  \"ISPEXEC VGET     (ZKEYS   )   \"    ; SAY 'ZKEYS     = ' ZKEYS\n  \"ISPEXEC VGET     (ZKLAPPL )   \"    ; SAY 'ZKLAPPL   = ' ZKLAPPL\n  \"ISPEXEC VGET     (ZKLNAME )   \"    ; SAY 'ZKLNAME   = ' ZKLNAME\n  \"ISPEXEC VGET     (ZKLTYPE )   \"    ; SAY 'ZKLTYPE   = ' ZKLTYPE\n  \"ISPEXEC VGET     (ZKLUSE  )   \"    ; SAY 'ZKLUSE    = ' ZKLUSE\n  \"ISPEXEC VGET     (ZLAC    )   \"    ; SAY 'ZLAC      = ' ZLAC\n  \"ISPEXEC VGET     (ZLALIAS )   \"    ; SAY 'ZLALIAS   = ' ZLALIAS\n  \"ISPEXEC VGET     (ZLAMODE )   \"    ; SAY 'ZLAMODE   = ' ZLAMODE\n  \"ISPEXEC VGET     (ZLANG   )   \"    ; SAY 'ZLANG     = ' ZLANG\n  \"ISPEXEC VGET     (ZLATTR  )   \"    ; SAY 'ZLATTR    = ' ZLATTR\n  \"ISPEXEC VGET     (ZLCDATE )   \"    ; SAY 'ZLCDATE   = ' ZLCDATE\n  \"ISPEXEC VGET     (ZLCNORC )   \"    ; SAY 'ZLCNORC   = ' ZLCNORC\n  \"ISPEXEC VGET     (ZLC4DAT )   \"    ; SAY 'ZLC4DAT   = ' ZLC4DAT\n  \"ISPEXEC VGET     (ZLINORC )   \"    ; SAY 'ZLINORC   = ' ZLINORC\n  \"ISPEXEC VGET     (ZLLIB   )   \"    ; SAY 'ZLLIB     = ' ZLLIB\n  \"ISPEXEC VGET     (ZLMDATE )   \"    ; SAY 'ZLMDATE   = ' ZLMDATE\n  \"ISPEXEC VGET     (ZLMEMBE )   \"    ; SAY 'ZLMEMBE   = ' ZLMEMBE\n  \"ISPEXEC VGET     (ZLMNORC )   \"    ; SAY 'ZLMNORC   = ' ZLMNORC\n  \"ISPEXEC VGET     (ZLMOD   )   \"    ; SAY 'ZLMOD     = ' ZLMOD\n  \"ISPEXEC VGET     (ZLMSEC  )   \"    ; SAY 'ZLMSEC    = ' ZLMSEC\n  \"ISPEXEC VGET     (ZLMTIME )   \"    ; SAY 'ZLMTIME   = ' ZLMTIME\n  \"ISPEXEC VGET     (ZLM4DAT )   \"    ; SAY 'ZLM4DAT   = ' ZLM4DAT\n  \"ISPEXEC VGET     (ZLOGNAME)   \"    ; SAY 'ZLOGNAME  = ' ZLOGNAME\n  \"ISPEXEC VGET     (ZLOGO   )   \"    ; SAY 'ZLOGO     = ' ZLOGO\n  \"ISPEXEC VGET     (ZLOGON  )   \"    ; SAY 'ZLOGON    = ' ZLOGON\n  \"ISPEXEC VGET     (ZLPDSUD )   \"    ; SAY 'ZLPDSUD   = ' ZLPDSUD\n  \"ISPEXEC VGET     (ZLRMODE )   \"    ; SAY 'ZLRMODE   = ' ZLRMODE\n  \"ISPEXEC VGET     (ZLSIZE  )   \"    ; SAY 'ZLSIZE    = ' ZLSIZE\n  \"ISPEXEC VGET     (ZLSTLPP )   \"    ; SAY 'ZLSTLPP   = ' ZLSTLPP\n  \"ISPEXEC VGET     (ZLSTNAME)   \"    ; SAY 'ZLSTNAME  = ' ZLSTNAME\n  \"ISPEXEC VGET     (ZLSTNUML)   \"    ; SAY 'ZLSTNUML  = ' ZLSTNUML\n  \"ISPEXEC VGET     (ZLSTTRUN)   \"    ; SAY 'ZLSTTRUN  = ' ZLSTTRUN\n  \"ISPEXEC VGET     (ZLTTR   )   \"    ; SAY 'ZLTTR     = ' ZLTTR\n  \"ISPEXEC VGET     (ZLUSER  )   \"    ; SAY 'ZLUSER    = ' ZLUSER\n  \"ISPEXEC VGET     (ZLVERS  )   \"    ; SAY 'ZLVERS    = ' ZLVERS\n  \"ISPEXEC VGET     (ZMEMCNT )   \"    ; SAY 'ZMEMCNT   = ' ZMEMCNT\n  \"ISPEXEC VGET     (ZMLCOLS )   \"    ; SAY 'ZMLCOLS   = ' ZMLCOLS\n  \"ISPEXEC VGET     (ZMLCR   )   \"    ; SAY 'ZMLCR     = ' ZMLCR\n  \"ISPEXEC VGET     (ZMLTR   )   \"    ; SAY 'ZMLTR     = ' ZMLTR\n  \"ISPEXEC VGET     (ZMONTH  )   \"    ; SAY 'ZMONTH    = ' ZMONTH\n  \"ISPEXEC VGET     (ZOS390RL)   \"    ; SAY 'ZOS390RL  = ' ZOS390RL\n  \"ISPEXEC VGET     (ZPARENT )   \"    ; SAY 'ZPARENT   = ' ZPARENT\n  \"ISPEXEC VGET     (ZPDFREL )   \"    ; SAY 'ZPDFREL   = ' ZPDFREL\n  \"ISPEXEC VGET     (ZPFCTL  )   \"    ; SAY 'ZPFCTL    = ' ZPFCTL\n  \"ISPEXEC VGET     (ZPFFMT  )   \"    ; SAY 'ZPFFMT    = ' ZPFFMT\n  \"ISPEXEC VGET     (ZPFKEY  )   \"    ; SAY 'ZPFKEY    = ' ZPFKEY\n  \"ISPEXEC VGET     (ZPFL01  )   \"    ; SAY 'ZPFL01    = ' ZPFL01\n  \"ISPEXEC VGET     (ZPFL02  )   \"    ; SAY 'ZPFL02    = ' ZPFL02\n  \"ISPEXEC VGET     (ZPFL03  )   \"    ; SAY 'ZPFL03    = ' ZPFL03\n  \"ISPEXEC VGET     (ZPFL04  )   \"    ; SAY 'ZPFL04    = ' ZPFL04\n  \"ISPEXEC VGET     (ZPFL05  )   \"    ; SAY 'ZPFL05    = ' ZPFL05\n  \"ISPEXEC VGET     (ZPFL06  )   \"    ; SAY 'ZPFL06    = ' ZPFL06\n  \"ISPEXEC VGET     (ZPFL07  )   \"    ; SAY 'ZPFL07    = ' ZPFL07\n  \"ISPEXEC VGET     (ZPFL08  )   \"    ; SAY 'ZPFL08    = ' ZPFL08\n  \"ISPEXEC VGET     (ZPFL09  )   \"    ; SAY 'ZPFL09    = ' ZPFL09\n  \"ISPEXEC VGET     (ZPFL10  )   \"    ; SAY 'ZPFL10    = ' ZPFL10\n  \"ISPEXEC VGET     (ZPFL11  )   \"    ; SAY 'ZPFL11    = ' ZPFL11\n  \"ISPEXEC VGET     (ZPFL12  )   \"    ; SAY 'ZPFL12    = ' ZPFL12\n  \"ISPEXEC VGET     (ZPFL13  )   \"    ; SAY 'ZPFL13    = ' ZPFL13\n  \"ISPEXEC VGET     (ZPFL14  )   \"    ; SAY 'ZPFL14    = ' ZPFL14\n  \"ISPEXEC VGET     (ZPFL15  )   \"    ; SAY 'ZPFL15    = ' ZPFL15\n  \"ISPEXEC VGET     (ZPFL16  )   \"    ; SAY 'ZPFL16    = ' ZPFL16\n  \"ISPEXEC VGET     (ZPFL17  )   \"    ; SAY 'ZPFL17    = ' ZPFL17\n  \"ISPEXEC VGET     (ZPFL18  )   \"    ; SAY 'ZPFL18    = ' ZPFL18\n  \"ISPEXEC VGET     (ZPFL19  )   \"    ; SAY 'ZPFL19    = ' ZPFL19\n  \"ISPEXEC VGET     (ZPFL20  )   \"    ; SAY 'ZPFL20    = ' ZPFL20\n  \"ISPEXEC VGET     (ZPFL21  )   \"    ; SAY 'ZPFL21    = ' ZPFL21\n  \"ISPEXEC VGET     (ZPFL22  )   \"    ; SAY 'ZPFL22    = ' ZPFL22\n  \"ISPEXEC VGET     (ZPFL23  )   \"    ; SAY 'ZPFL23    = ' ZPFL23\n  \"ISPEXEC VGET     (ZPFL24  )   \"    ; SAY 'ZPFL24    = ' ZPFL24\n  \"ISPEXEC VGET     (ZPFSET  )   \"    ; SAY 'ZPFSET    = ' ZPFSET\n  \"ISPEXEC VGET     (ZPFSHOW )   \"    ; SAY 'ZPFSHOW   = ' ZPFSHOW\n  \"ISPEXEC VGET     (ZPLACE  )   \"    ; SAY 'ZPLACE    = ' ZPLACE\n  \"ISPEXEC VGET     (ZPREFIX )   \"    ; SAY 'ZPREFIX   = ' ZPREFIX\n  \"ISPEXEC VGET     (ZPRIKEYS)   \"    ; SAY 'ZPRIKEYS  = ' ZPRIKEYS\n  \"ISPEXEC VGET     (ZPRIM   )   \"    ; SAY 'ZPRIM     = ' ZPRIM\n  \"ISPEXEC VGET     (ZPROFAPP)   \"    ; SAY 'ZPROFAPP  = ' ZPROFAPP\n  \"ISPEXEC VGET     (ZSCALIA )   \"    ; SAY 'ZSCALIA   = ' ZSCALIA\n  \"ISPEXEC VGET     (ZSCBR   )   \"    ; SAY 'ZSCBR     = ' ZSCBR\n  \"ISPEXEC VGET     (ZSCED   )   \"    ; SAY 'ZSCED     = ' ZSCED\n  \"ISPEXEC VGET     (ZSCLM   )   \"    ; SAY 'ZSCLM     = ' ZSCLM\n  \"ISPEXEC VGET     (ZSCML   )   \"    ; SAY 'ZSCML     = ' ZSCML\n  \"ISPEXEC VGET     (ZSCMVOL )   \"    ; SAY 'ZSCMVOL   = ' ZSCMVOL\n  \"ISPEXEC VGET     (ZSCRCUR )   \"    ; SAY 'ZSCRCUR   = ' ZSCRCUR\n  \"ISPEXEC VGET     (ZSCREEN )   \"    ; SAY 'ZSCREEN   = ' ZSCREEN\n  \"ISPEXEC VGET     (ZSCREEND)   \"    ; SAY 'ZSCREEND  = ' ZSCREEND\n  \"ISPEXEC VGET     (ZSCREENW)   \"    ; SAY 'ZSCREENW  = ' ZSCREENW\n  \"ISPEXEC VGET     (ZSCRMAX )   \"    ; SAY 'ZSCRMAX   = ' ZSCRMAX\n  \"ISPEXEC VGET     (ZSCRMAXD)   \"    ; SAY 'ZSCRMAXD  = ' ZSCRMAXD\n  \"ISPEXEC VGET     (ZSCRMAXW)   \"    ; SAY 'ZSCRMAXW  = ' ZSCRMAXW\n  \"ISPEXEC VGET     (ZSCRNAME)   \"    ; SAY 'ZSCRNAME  = ' ZSCRNAME\n  \"ISPEXEC VGET     (ZSCROLLA)   \"    ; SAY 'ZSCROLLA  = ' ZSCROLLA\n  \"ISPEXEC VGET     (ZSCROLLD)   \"    ; SAY 'ZSCROLLD  = ' ZSCROLLD\n  \"ISPEXEC VGET     (ZSCROLLN)   \"    ; SAY 'ZSCROLLN  = ' ZSCROLLN\n  \"ISPEXEC VGET     (ZSCTPREF)   \"    ; SAY 'ZSCTPREF  = ' ZSCTPREF\n  \"ISPEXEC VGET     (ZSCTSRCH)   \"    ; SAY 'ZSCTSRCH  = ' ZSCTSRCH\n  \"ISPEXEC VGET     (ZSEL    )   \"    ; SAY 'ZSEL      = ' ZSEL\n  \"ISPEXEC VGET     (ZSESS   )   \"    ; SAY 'ZSESS     = ' ZSESS\n  \"ISPEXEC VGET     (ZSPLIT  )   \"    ; SAY 'ZSPLIT    = ' ZSPLIT\n  \"ISPEXEC VGET     (ZSTDYEAR)   \"    ; SAY 'ZSTDYEAR  = ' ZSTDYEAR\n  \"ISPEXEC VGET     (ZSWIND  )   \"    ; SAY 'ZSWIND    = ' ZSWIND\n  \"ISPEXEC VGET     (ZSYSICON)   \"    ; SAY 'ZSYSICON  = ' ZSYSICON\n  \"ISPEXEC VGET     (ZSYSID  )   \"    ; SAY 'ZSYSID    = ' ZSYSID\n  \"ISPEXEC VGET     (ZSYSNODE)   \"    ; SAY 'ZSYSNODE  = ' ZSYSNODE\n  \"ISPEXEC VGET     (ZSYSPLEX)   \"    ; SAY 'ZSYSPLEX  = ' ZSYSPLEX\n  \"ISPEXEC VGET     (ZTDADD  )   \"    ; SAY 'ZTDADD    = ' ZTDADD\n  \"ISPEXEC VGET     (ZTDAMT  )   \"    ; SAY 'ZTDAMT    = ' ZTDAMT\n  \"ISPEXEC VGET     (ZTDLROWS)   \"    ; SAY 'ZTDLROWS  = ' ZTDLROWS\n  \"ISPEXEC VGET     (ZTDLTOP )   \"    ; SAY 'ZTDLTOP   = ' ZTDLTOP\n  \"ISPEXEC VGET     (ZTDMARK )   \"    ; SAY 'ZTDMARK   = ' ZTDMARK\n  \"ISPEXEC VGET     (ZTDMSG  )   \"    ; SAY 'ZTDMSG    = ' ZTDMSG\n  \"ISPEXEC VGET     (ZTDRET  )   \"    ; SAY 'ZTDRET    = ' ZTDRET\n  \"ISPEXEC VGET     (ZTDROWS )   \"    ; SAY 'ZTDROWS   = ' ZTDROWS\n  \"ISPEXEC VGET     (ZTDSCRP )   \"    ; SAY 'ZTDSCRP   = ' ZTDSCRP\n  \"ISPEXEC VGET     (ZTDSELS )   \"    ; SAY 'ZTDSELS   = ' ZTDSELS\n  \"ISPEXEC VGET     (ZTDSIZE )   \"    ; SAY 'ZTDSIZE   = ' ZTDSIZE\n  \"ISPEXEC VGET     (ZTDSRID )   \"    ; SAY 'ZTDSRID   = ' ZTDSRID\n  \"ISPEXEC VGET     (ZTDTOP  )   \"    ; SAY 'ZTDTOP    = ' ZTDTOP\n  \"ISPEXEC VGET     (ZTEMPF  )   \"    ; SAY 'ZTEMPF    = ' ZTEMPF\n  \"ISPEXEC VGET     (ZTEMPN  )   \"    ; SAY 'ZTEMPN    = ' ZTEMPN\n  \"ISPEXEC VGET     (ZTERM   )   \"    ; SAY 'ZTERM     = ' ZTERM\n  \"ISPEXEC VGET     (ZTERMCID)   \"    ; SAY 'ZTERMCID  = ' ZTERMCID\n  \"ISPEXEC VGET     (ZTERMCP )   \"    ; SAY 'ZTERMCP   = ' ZTERMCP\n  \"ISPEXEC VGET     (ZTERMCS )   \"    ; SAY 'ZTERMCS   = ' ZTERMCS\n  \"ISPEXEC VGET     (ZTHS    )   \"    ; SAY 'ZTHS      = ' ZTHS\n  \"ISPEXEC VGET     (ZTIME   )   \"    ; SAY 'ZTIME     = ' ZTIME\n  \"ISPEXEC VGET     (ZTIMEL  )   \"    ; SAY 'ZTIMEL    = ' ZTIMEL\n  \"ISPEXEC VGET     (ZTS     )   \"    ; SAY 'ZTS       = ' ZTS\n  \"ISPEXEC VGET     (ZTSICMD )   \"    ; SAY 'ZTSICMD   = ' ZTSICMD\n  \"ISPEXEC VGET     (ZTSSCMD )   \"    ; SAY 'ZTSSCMD   = ' ZTSSCMD\n  \"ISPEXEC VGET     (ZUCTPREF)   \"    ; SAY 'ZUCTPREF  = ' ZUCTPREF\n  \"ISPEXEC VGET     (ZUP     )   \"    ; SAY 'ZUP       = ' ZUP\n  \"ISPEXEC VGET     (ZUSER   )   \"    ; SAY 'ZUSER     = ' ZUSER\n  \"ISPEXEC VGET     (ZUSERMA )   \"    ; SAY 'ZUSERMA   = ' ZUSERMA\n  \"ISPEXEC VGET     (ZVERB   )   \"    ; SAY 'ZVERB     = ' ZVERB\n  \"ISPEXEC VGET     (ZWINTTL )   \"    ; SAY 'ZWINTTL   = ' ZWINTTL\n  \"ISPEXEC VGET     (ZWSCDPG )   \"    ; SAY 'ZWSCDPG   = ' ZWSCDPG\n  \"ISPEXEC VGET     (ZWSCON  )   \"    ; SAY 'ZWSCON    = ' ZWSCON\n  \"ISPEXEC VGET     (ZWSOPSYS)   \"    ; SAY 'ZWSOPSYS  = ' ZWSOPSYS\n  \"ISPEXEC VGET     (ZYEAR   )   \"    ; SAY 'ZYEAR     = ' ZYEAR\n  RETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TABLES": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x05\\x01\\x06\\x03\\x7f\\x01\\x06\\x03\\x8f\\x17\\x14\\x006\\x005\\x00\\x00\\xc2\\xe2\\xe6\\xf1@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2006-02-06T00:00:00", "modifydate": "2006-02-07T17:14:05", "lines": 54, "newlines": 53, "modlines": 0, "user": "BSW1"}, "text": "-- -- ==================================================================\n-- -- 1. LIST ALL TABLES\n-- --\n--\n      select\n           name\n          ,creator\n          ,type\n          ,dbname\n          ,tsname\n          ,dbid\n          ,obid\n          ,colcount\n          ,edproc\n          ,valproc\n          ,clustertype\n          ,clusterrid\n          ,card\n          ,npages\n          ,pctpages\n          ,ibmreqd\n          ,remarks\n          ,parents\n          ,children\n          ,keycolumns\n          ,reclength\n          ,status\n          ,keyobid\n          ,label\n          ,checkflag\n          ,checkrid\n          ,auditing\n          ,createdby\n          ,location\n          ,tbcreator\n          ,tbname\n          ,createdts\n          ,alteredts\n          ,datacapture\n          ,pctrowcomp\n          ,statstime\n          ,checks\n          ,cardf\n          ,checkrid5b\n          ,encoding_scheme\n          ,tablestatus\n          ,npagesf\n          ,spacef\n          ,avgrowlen\n          ,relcreated\n        from sysibm.systables\n        order by creator, name\n        with ur\n      ;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT740/FILE740.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT740", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}