/* REXX */
/* ================================================================   */
/* Language   : REXX
 * Name       : RSQLEXEC
 * Category   : Rexx Exec (command line)
 * Description: Rexx Exec to Read the Sql in a dataset, and execute it.
 * Rexx       : RSQLDFLT
 * Panels     : none
 * Skeltons   : none
 * Messages   : none
 * Procedure  : none
 * Author     : Alan Wynne.
 * Owner      : Alan Wynne.
 * Created    : August 2004.
 * Modified   :
 * ================================================================ */
  Ver      = "1.00"
  ReturnCode = 0
/* ==================================================================
 * Rexx Exec to Read the Sql in a dataset, and execute it.
 *
 * Method of execution is:
 *
 * RSQLEXEC--------------------------------------------------------->A
 *              |                                       |
 *              |--Query--------------------------------|
 *              |          |--Rows--|                   |
 *              |                                       |
 *              |--Flat---------------------------------|
 *              |                                       |
 *              |--Txt----------------------------------|
 *              |                                       |
 *              |--CSV----------------------------------|
 *              |          |--TQ='?'-------------|      |
 *              |          |--TQ="?"-------------|      |
 *              |          |--TQ=""--------------|      |
 *              |          |--TQ='---------------|      |
 *              |          |--TQ=----------------|      |
 *              |                                       |
 *              |--CSVNoHeader--------------------------|
 *              |          |--TQ='?'-------------|      |
 *              |          |--TQ="?"-------------|      |
 *              |          |--TQ=""--------------|      |
 *              |          |--TQ='---------------|      |
 *              |          |--TQ=----------------|      |
 *              |                                       |
 *              |--HTML---------------------------------|
 *                        |--PT='Page Title'----|
 *
 *
 *
 *  A>-------------------------------------------------------------->B
 *              |                        |
 *              |--SSID=ssid-------------|
 *              |                        |
 *              |--S=ssid----------------|
 *
 *  B>-------------------------------------------------------------->C
 *              |                        |
 *              |--COMMIT----------------|
 *                         |--=Yes-|
 *                         |--=No--|
 *
 *
 *  C>----------------------------------------------------------| End
 *              |                        |
 *              |--Online----------------|
 *              |                        |
 *              |--Batch-----------------|
 *
 *
 * Input Dataset will be assigned to Filename RSQLIN.
 *
 * Query or Q means output is to be normal output. Columns will be
 * alligned and Column Headings will be supplied. Columns will be
 * seperated by the nuber specified as the default Column Gap Size.
 * Rows is the number of Rows that will be displayed before each column
 * heading.
 *
 * Flat means that columns will be alligned but no space will seperate
 * the columns. No Headings will be displayed either.
 *
 * CSV means that a Comma seperated variable file will be created.
 * Comma seperated variables files will not be alligned by columns.
 * Character type Columns will be enclosed in Double Quotes, Numeric
 * type columns will not be enclosed in quotes. Commas will be used to
 * seperate variables. The first row in the output dataset will contain
 * column Headings.
 *
 * CSVNoHeader is the same as CSV except that the first record in the
 * file will not contain column headings.
 *
 * TQ is to define the Text Qualifier character to be used, and is only
 * relevant for CSV and CSV No header file types. The Text qualifier is
 * the character to be used to enclose text fields. The default text
 * Qualifier will be set up in the RSQLDFLT Rexx. The parameter can be
 * used to overwrite the default Text qualifier character. No text
 * qualifier can also be specified by using the parameters TQ="" or
 * TQ='' or TQ=
 *
 * HTML means that an HTML page will be generated with the data in a
 * HTML Table. The Page Title part of the HTML parameters causes The
 * text of Page Title to be the HTML Page Title.
 *
 * SSID=ssid or S=ssid stipulates which DB2 sub system to connect to.
 *
 * COMMIT parameter determines whether to commit at the end of execution
 * or to Rollback. The default can be setup in RSQLDFLT. The commit
 * keyword without the "=yes" or "=No" results in a commit.
 *
 * Online or Batch are mutualy exclusive  and indicate whether the
 * SQL is being executed in a batch mode or online mode. This is used
 * to detemine the Output dataset. In online mode the Output datasets
 * are detemined by the REXX Program in Batch mode the Output dataset
 * is not determined by the program but by the JCL. When the program is
 * executed by REXX in a Batch Job it may still operate in online mode.
 * The program will default to operate in Online mode unless Batch mode
 * is specifically stipulated.
 *
 * ================================================================== */
/* TRACE ?R */
/* ================================================================== */
/* Recieve arguments                                                  */
/*                                                                    */

  Parse ARG Args
/*Parse ARG Arg.1 Arg.2 Arg.3 Arg.4 Arg.5 Arg.6 Arg.7 Arg.8 Arg.9     */

/* ================================================================== */
/* Initialize Environment                                             */
/*                                                                    */
  NoMessage = 0                        /* No of messages              */
  Drop Message.                        /* Drop message stem           */

  NoSQLDA   = 0                        /* No of Saved SQLDA's         */
  Drop SavedSQLDAs.                    /* Drop SavedSQLDAs            */


  Drop DatasetInfo.                    /* Drop Allocated Dataset info */
  Call ListAloc                        /* Get Dataset Info            */

  RSQLINDD   = 'RSQLIN'                /* Define DD name input SQL DS */
  RSQLINDSN  = ''                      /* initialize DSN to blank     */
  RSQLINDSN  = DSNSearch(RSQLINDD)     /* Find RSQLINDS Name          */
  RSQLOutDD  = 'RSQLOUT'               /* Define DD name of Output    */
  RSQLOutDSN = ''                      /* initialize DSN to blank     */
  RSQLOutDSN = DSNSearch(RSQLOutDD)    /* Find Output DS Name         */
  RSQLDADD   = 'RSQLDA'                /* Define DD name of SQLDA     */
  RSQLDADSN  = ''                      /* initialize DSN to blank     */
  RSQLDADSN  = DSNSearch(RSQLDADD)     /* Find SQLDA DS Namee         */

/* ================================================================== */
/* Set The Default Environment.                                       */
/*                                                                    */

  SSID          =  RSQLDFLT('SSID')          /* Default SSID name     */
  ResultType    =  RSQLDFLT('ResultType')    /* Default Result type   */
  ColumnGapSize =  RSQLDFLT('ColumnGapSize') /* Default Gap twix cols */
  RowsPerPage   =  RSQLDFLT('RowsPerPage')   /* Default Rows per page */
  ValidSSIds    =  RSQLDFLT('ValidSSIds')    /* Valid SSID's          */
  TextQualifier =  RSQLDFLT('TextQualifier') /* Default Text Qualifier*/
  PageTitle     =  RSQLDFLT('PageTitle')     /* Default page title    */
  Commit        =  RSQLDFLT('Commit')        /* Default Commit status */

/* ================================================================== */
/* Process the Arguments supplied into the Environment                */
/*                                                                    */
/* TRACE ?R */


  if Pos(' PT=',Args) > 0 then
    Do
      PageTitleSP  = Pos(' PT=',Args) + 5
      PageTitle    = Substr(Args,PageTitleSP)
      PageTitleLen = Pos(Substr(Args,PageTitleSP-1,1),PageTitle)-1
      PageTitle    = Substr(PageTitle,1,PageTitleLen)
      Args         = Substr(Args,1,PageTitleSP-5) ||,
                     Substr(Args,PageTitleSP+PageTitleLen+2)
    End

  Drop Arg.
  Parse VAR Args Arg.1 Arg.2 Arg.3 Arg.4 Arg.5 Arg.6 Arg.7 Arg.8 Arg.9

  Do i = 1 To 6 until Arg.i = ''
    Select
      When Arg.i = ''                    Then
        NOP
      When Translate(Substr(Arg.i,1,4)) = 'CSVN' Then
        ResultType = 'CSVNoHeader'
      When Translate(Substr(Arg.i,1,3)) = 'CSV'  Then
        ResultType = 'CSV'
      When Translate(Substr(Arg.i,1,1)) = 'Q'    Then
        ResultType = 'QUERY'
      When Translate(Substr(Arg.i,1,1)) = 'F'    Then
        ResultType = 'FLAT'
      When Translate(Substr(Arg.i,1,3)) = 'TQ='  Then
        Do
          Select
            When Length(Arg.i) = 6                 Then
              TextQualifier = Substr(Arg.i,5,1)
            When Length(Arg.i) = 5                 Then
              TextQualifier = ''
            When Length(Arg.i) = 4                 Then
              TextQualifier = Substr(Arg.i,4,1)
            When Length(Arg.i) = 3                 Then
              TextQualifier = ''
            Otherwise
              Do
                NoMessage = NoMessage + 1
                Message.NoMessage = '  RSQLEXEC: Text Qualifier ',
                  ||'incorrectly specified. Default text qualifier ',
                  ||'assumed.'
              End
          End
        End
      When Translate(Substr(Arg.i,1,1)) = 'T'    Then
        ResultType = 'TXT'
      When Translate(Substr(Arg.i,1,1)) = 'H'    Then
        ResultType = 'HTML'
      When Translate(Substr(Arg.i,1,2)) = 'S='   Then
        SSID = Translate(Substr(Arg.i,3))
      When Translate(Substr(Arg.i,1,5)) = 'SSID=' Then
        SSID = Translate(Substr(Arg.i,6))
      When Translate(Substr(Arg.i,1,7)) = 'COMMIT=' Then
        Commit = Translate(Substr(Arg.i,8))
      When Translate(Substr(Arg.i,1,6)) = 'COMMIT' Then
        Commit = 'YES'
      When Translate(Substr(Arg.i,1,1)) = 'O'    Then
        Mode = 'ONLINE'
      When Translate(Substr(Arg.i,1,1)) = 'B'    Then
        Mode = 'BATCH'
      Otherwise
        If DATATYPE(Arg.i, 'N') Then RowsPerPage = Arg.i
    End
  End

  If POS(SSID,ValidSSIds,1) = 0 then
    Do
      SSID = RSQLDFLT('SSID')
      NoMessage = NoMessage + 1
      Message.NoMessage = '  RSQLEXEC: Invalid SSID supplied, ',
        ||'SSID Defaulted to: ' || SSID
      If POS(SSID,ValidSSIds,1) = 0 then
        Do
          NoMessage = NoMessage + 1
          Message.NoMessage = '  RSQLEXEC: Default SSID is invalid. ',
            ||'Unalbe to determine where to connect to.'
          Say Message.NoMessage
          Do m  = 1 to NoMessage
            Say Message.m
          End
          Return 12
        End
    End

/* ================================================================== */
/* Parameters have been validated or defaulted.                       */
/*                                                                    */
/* TRACE ?R */

/* ================================================================== */
/* Read Input SQL datasaet.                                           */

  If RSQLINDSN = '' then
    Do
      NoMessage = NoMessage + 1
      Message.NoMessage = '  RSQLEXEC: Input dataset is not',
        'allocated, nothing to do.'
      Do m  = 1 to NoMessage
        Say Message.m
      End
      Return 12
    end

  "NEWSTACK"
  "ALLOC F("RSQLINDD") SHR REUSE"
  "EXECIO * DISKR RSQLIN (OPEN"
  "EXECIO 0 DISKR RSQLIN (FINIS"

/* ================================================================== */
/* Place all Records into the SQLFile Stem                            */

  Drop SQLFile.
  SQLFile.NoRecs = QUEUED()
  If SQLFile.NoRecs < 1 then
    Do
      NoMessage = NoMessage + 1
      Message.NoMessage = '  RSQLEXEC: Input dataset is empty or ',
        'cannot be read, nothing to do.'
      Do m  = 1 to NoMessage
        Say Message.m
      End
      Return 12
    end

  Drop SQLFile.Record.
  Do i = 1 to SQLFile.NoRecs
    PARSE PULL Line
    SQLFile.Record.i = Strip(Line)
  end

  "Free FILE(RSQLIN)"
  "DELSTACK"

/* ================================================================== */
/* Determine the output dataset mask and type.                        */
/*                                                                    */
  Select
    When ResultType = 'QUERY' then
      FileExtension = 'Q.TXT'
    When ResultType = 'FLAT' then
      FileExtension = 'F.TXT'
    When ResultType = 'CSV' then
      FileExtension = 'CSV'
    When ResultType = 'CSVNoHeader' then
      FileExtension = 'CSV'
    When ResultType = 'HTML' then
      FileExtension = 'HTML'
    Otherwise
      FileExtension = 'TXT'
  end

  Call OutputMask SSID RSQLIN OutDSNMask

/* ================================================================== */
/* Allocate and open the Result output dataset.                       */
/* Write out operating parameters to Outut dataset.                   */
/*                                                                    */

  IF RSQLOutDSN = '' Then RSQLOutDSN = OutDSNMask'.RSQLOUT.TXT'

  "NEWSTACK"

  PgeCnt       = 0
  PgeLnCnt     = 0
  RowCount     = 0
  RecCount     = 0
  PageHeadings = ''

  MaxDataLn    = 0
  NoBytes      = 0
  drop ColLn.

  Row = Left('-- =',72,'=')
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Row = '-- Summary of processing completed on : ' || DATE('S')
  Row = Row || ' at ' || TIME('L')
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Row = '-- Parameters Passed to RSQLEXEC: '
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Row = '--   'SSID','ResultType','RSQLIN
  If ResultYpe = 'Query' Then
     Row = Row ','RowsPerPage
  If ResultYpe = 'CSV' | ResultYpe = 'CSVNoHeader' Then
     Row = Row ','TextQualifier
  If ResultYpe = 'HTML' Then
     Row = Row ','PageTitle
  Row = Row','RSQLIN
  Call QueueOut

  Row = '-- '
  Call QueueOut

  If Mode = 'ONLINE' Then
    Do

      MngmntCls  =  RSQLDFLT('MngmntCls')
      StorageCls =  RSQLDFLT('StorageCls')

      "DELETE '"RSQLOutDSN"' PURGE SCRATCH"
      ALLOCOUT = "DA('"RSQLOutDSN"') F("RSQLOutDD")"
      ALLOCOUT = ALLOCOUT' NEW MGMTCLAS('MngmntCls')'
      ALLOCOUT = ALLOCOUT' STORCLAS('StorageCls')'
      ALLOCOUT = ALLOCOUT' LRECL(4096)'
      ALLOCOUT = ALLOCOUT' RECFM(V)'

      "ALLOC "ALLOCOUT

    end /* do */

  If Mode = 'BATCH' Then
    Do
      ALLOCOUT = 'FILE('RSQLOutDD') DA('RSQLOutDSN') MOD '
      "ALLOC "ALLOCOUT
    end  /* do */

  "EXECIO "queued()" DISKW "RSQLOutDD" (OPEN"
  "DELSTACK"

/* ================================================================== */
/* Connect to DB2, and process input SQL Statements.                  */
/*                                                                    */

  SQLStmnt = ''
  NoStmnt  = 0
  NoRs     = 0
  NoExecI  = 0
  NoExec   = 0

  Address TSO "SUBCOM DSNREXX "
  If RC Then S_RC = RXSUBCOM('ADD','DSNREXX','DSNREXX')


  LastAct = 'CONNECT ' || SSID
  Address DSNREXX " CONNECT " SSID

  Do NoRec = 1 to SQLFile.NoRecs
    i = POS('--',SQLFile.Record.NoRec)
    If i > 0 then
      Do
        i = i - 1
        Line = SUBSTR(SQLFile.Record.NoRec,1,i)
      end
    else
        Line = SUBSTR(SQLFile.Record.NoRec,1)
    LineLn = Length(Line)
    If LineLn > 0 then
      Do
        SQLStmnt = SQLStmnt || Line || ' '
        i = Length(SQLStmnt) - 1
        If substr(SQLStmnt,i,1) = ';' then
          Do
            SQLStmnt = substr(SQLStmnt,1,i-1)
            SQLStmnt = RSQLTRIM(SQLStmnt)
            StmntTyp = SubWord(SQLStmnt,1,1)
            StmntTyp = Translate(StmntTyp)
            Select
              When StmntTyp = 'SELECT' Then
                Call DoCursor
              When StmntTyp = 'UPDATE' Then
                Call DoExecImmediate
              When StmntTyp = 'DELETE' Then
                Call DoExecImmediate
              When StmntTyp = 'INSERT' Then
                Call DoExecImmediate
              Otherwise
                Call DoExec
            end
            SQLStmnt = ''
          end
      end
  end

  If SQLStmnt ¬= '' then
    Do
      SQLStmnt = RSQLTRIM(SQLStmnt)
      StmntTyp = SubWord(SQLStmnt,1,1)
      StmntTyp = Translate(StmntTyp)
      Select
        When StmntTyp = 'SELECT' Then
          Call DoCursor
        When StmntTyp = 'UPDATE' Then
          Call DoExecImmediate
        When StmntTyp = 'DELETE' Then
          Call DoExecImmediate
        When StmntTyp = 'INSERT' Then
          Call DoExecImmediate
        Otherwise
          Call DoExec
      end
      SQLStmnt = ''
    end

  If Commit = 'YES' Then
    Do
      LastAct = 'COMMIT'
      Address DSNREXX "EXECSQL" "COMMIT"
      Row = Left('-- =',72,'=')
      Call QueueOut
      Row = '-- '
      Call QueueOut
      Row = '-- Commit Performed: SQLCODE =' SQLCODE
      Call QueueOut
      Row = '-- '
      Call QueueOut
      If      SQLCODE ¬= 0 Then Call SQLError
      Row = '-- '
      Call QueueOut
      Row = Left('-- =',72,'=')
      Call QueueOut
    End
  Else
    Do
      Call RSQLRollback
    End

  LastAct = 'DISCONNECT'
  Address DSNREXX "DISCONNECT"
  If SQLCODE ¬= 0 &  SQLCODE ¬= -924 Then Call SQLError

  Row = '-- End of SQL Input File Reached '
  Call QueueOut
  Row = Left('-- =',72,'=')
  Call QueueOut

  "EXECIO "queued()" DISKW "RSQLOutDD" (FINIS"
  "Free FILE("RSQLOutDD")"

  Call OutputSQLDA

  Return ReturnCode

/* ================================================================== */
/* DoCursor executes the statement If it is a select statemnt         */
/*                                                                    */
DoCursor:

  "NEWSTACK"

  PgeCnt    = 0
  PgeLnCnt  = 0
  RowCount  = 0
  RecCount  = 0
  PageHeadings = ''

  MaxDataLn = 0
  NoBytes   = 0
  NoStmnt   = NoStmnt + 1

  drop CurSQLDA.
  drop ColLn.

  STMTDCLR  = 'Declare  C'NoStmnt' cursor for S'NoStmnt
  STMTPRPR  = 'Prepare  S'NoStmnt' into :CurSQLDA from :SQLStmnt'
  STMTDSCR  = 'Describe S'NoStmnt' into :CurSQLDA '
  STMTOPEN  = 'Open C'NoStmnt
  STMTFTCH  = 'Fetch C'NoStmnt' using descriptor :CurSQLDA'
  STMTClose = 'Close C'NoStmnt

  LastAct = STMTDCLR
  Address DSNREXX "EXECSQL " STMTDCLR
  If SQLCODE ¬= 0 Then Call SQLError

  LastAct = STMTPRPR
  Address DSNREXX "EXECSQL " STMTPRPR
  If SQLCODE ¬= 0 Then Call SQLError

/*LastAct = STMTDSCR                                                  */
/*Address DSNREXX "EXECSQL " STMTDSCR                                 */
/*If SQLCODE ¬= 0 Then Call SQLError                                  */

  LastAct = STMTOPEN
  Address DSNREXX "EXECSQL " STMTOPEN
  If SQLCODE ¬= 0 Then Call SQLError

  If RSQLDADSN > '' Then Call SaveSQLDA

  Do until SQLCODE ¬= 0
    LastAct = STMTFTCH
    Address DSNREXX "EXECSQL " STMTFTCH

    If RSQLDADSN > '' Then Call SaveSQLDA

    Select
      When SQLCODE = 0 Then
        Do
          If RowCount = 0 then
            Do
              If ResultType = 'HTML' then
                Do
                  Row = '<HTML>'
                  Call QueueOut
                  Row = '<HEAD>'
                  Call QueueOut
                  Row = '  <TITLE>'PageTitle'</TITLE>'
                  Call QueueOut
                  Row = '  <META NAME="generator" CONTENT="RSQL">'
                  Call QueueOut
                  Row = '  <META NAME="author" CONTENT="Alan Wynne">'
                  Call QueueOut
                  Row = '</HEAD>'
                  Call QueueOut
                  Row = '<BODY>'
                  Call QueueOut
                  Row = '<H1>'PageTitle'</H1><PRE>'
                  Call QueueOut
                end
              Select
                when ResultType = 'CSV' then
                  Do i = 1 to CurSQLDA.SQLD
                    PageHeadings = PageHeadings || TextQualifier
                    PageHeadings = PageHeadings ||      ,
                      CurSQLDA.i.SQLNAME
                    PageHeadings = PageHeadings || TextQualifier
                    If i < CurSQLDA.SQLD then
                      PageHeadings = PageHeadings || ','
                  end
                when ResultType = 'HTML' then
                  Do
                   PageHeadings = PageHeadings || '<TABLE BORDER=1><TR>'
                   Do i = 1 to CurSQLDA.SQLD
                     PageHeadings = PageHeadings || '<TD>'
                     PageHeadings = PageHeadings ||      ,
                      STRIP(CurSQLDA.i.SQLNAME,T)
                     PageHeadings = PageHeadings || '</TD>'
                   end
                   PageHeadings = PageHeadings || '</TR>'
                  end
                when ResultType = 'FLAT' then
                  Do
                   Row = ''
                   Do i = 1 to CurSQLDA.SQLD
                    Select
                      when CurSQLDA.i.SQLTYPE = 480 Then
                        ColLn.i = 20
                      when CurSQLDA.i.SQLTYPE = 481 Then
                        ColLn.i = 20
                      when CurSQLDA.i.SQLTYPE = 484 Then
                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2
                      when CurSQLDA.i.SQLTYPE = 485 Then
                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2
                      when CurSQLDA.i.SQLTYPE = 496 Then
                        ColLn.i = 11
                      when CurSQLDA.i.SQLTYPE = 497 Then
                        ColLn.i = 11
                      when CurSQLDA.i.SQLTYPE = 500 Then
                        ColLn.i = 6
                      when CurSQLDA.i.SQLTYPE = 501 Then
                        ColLn.i = 6
                      when CurSQLDA.i.SQLTYPE = 504 Then
                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2
                      when CurSQLDA.i.SQLTYPE = 505 Then
                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2
                      otherwise
                        ColLn.i = CurSQLDA.i.SQLLEN
                    end
                   end
                  end
                when ResultType = 'CSVNoHeader' then NOP
                otherwise
                 Do i = 1 to CurSQLDA.SQLD
                    Select
                      when CurSQLDA.i.SQLTYPE = 480 Then
                        ColLn.i = 20
                      when CurSQLDA.i.SQLTYPE = 481 Then
                        ColLn.i = 20
                      when CurSQLDA.i.SQLTYPE = 484 Then
                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2
                      when CurSQLDA.i.SQLTYPE = 485 Then
                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2
                      when CurSQLDA.i.SQLTYPE = 496 Then
                        ColLn.i = 11
                      when CurSQLDA.i.SQLTYPE = 497 Then
                        ColLn.i = 11
                      when CurSQLDA.i.SQLTYPE = 500 Then
                        ColLn.i = 6
                      when CurSQLDA.i.SQLTYPE = 501 Then
                        ColLn.i = 6
                      when CurSQLDA.i.SQLTYPE = 504 Then
                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2
                      when CurSQLDA.i.SQLTYPE = 505 Then
                        ColLn.i = CurSQLDA.i.SQLLEN.SQLPRECISION + 2
                      otherwise
                        ColLn.i = CurSQLDA.i.SQLLEN
                    end
                  If LENGTH(CurSQLDA.i.SQLNAME) > ColLn.i Then
                    ColLn.i = LENGTH(CurSQLDA.i.SQLNAME) + ColumnGapSize
                  else
                    ColLn.i = ColLn.i + ColumnGapSize
                  PageHeadings = PageHeadings ||    ,
                    LEFT(CurSQLDA.i.SQLNAME,ColLn.i,' ')
                 end
              end
              If ResultType ¬= 'FLAT' then
                Do
                  PgeLnCnt = 0
                  Row = PageHeadings
                  Call QueueOut
                  PgeCnt = PgeCnt + 1
                end
            end
          If ResultType = 'QUERY' then
            If RowsPer Page > 0 & PgeLnCnt >= RowsPerPage then
              Do
                PgeLnCnt = 0
                Row = PageHeadings
                Call QueueOut
                PgeCnt = PgeCnt + 1
              end
          If ResultType = 'HTML' then Row = '<TR>'
          Do i = 1 to CurSQLDA.SQLD
              If CurSQLDA.i.SQLIND = -1 Then
                Field = ''
              else
                Field = CurSQLDA.i.SQLDATA
              Select
              When ResultType = 'CSV' | ResultType = 'CSVNoHeader' then
                Do
                  Select
                    when CurSQLDA.i.SQLTYPE = 480 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 481 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 484 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 485 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 496 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 497 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 500 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 501 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 504 Then
                      Row = Row || Field
                    when CurSQLDA.i.SQLTYPE = 505 Then
                      Row = Row || Field
                    otherwise
                      Do
                        Field = STRIP(Field,T)
                        If TextQualifier ¬= '' then
                          do
                            Row = Row || TextQualifier
                            FieldLn = LENGTH(Field)
                            j = 1
                            Do While j < FieldLn + 1
                              If substr(Field,j,1) = TextQualifier then
                                Do
                                  Fieldwrk = Substr(Field,1,j)
                                  Field = Fieldwrk || Substr(Field,j)
                                  FieldLn = Length(Field)
                                  j = j + 1
                                end
                              j = j + 1
                            end
                            Row = Row || Field
                            Row = Row || TextQualifier
                          end
                        Else
                          Row = Row || Field
                      end
                  end
                  If i < CurSQLDA.SQLD then
                    Row = Row || ','
                  else
                    Row = Row || ' '
                end
              When ResultType = 'HTML' then
                Do
                  Row = Row || '<TD>' || STRIP(Field,T)
                  Row = Row || '</TD>'
                end
              When ResultType = 'FLAT' then
                Do
                  Field = CurSQLDA.i.SQLDATA
                  Select
                    when CurSQLDA.i.SQLTYPE = 480 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 481 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 484 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 485 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 496 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 497 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 500 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 501 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 504 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    when CurSQLDA.i.SQLTYPE = 505 Then
                      Row = Row || RIGHT(Field,ColLn.i,'0')
                    otherwise
                      Row = Row || LEFT(Field,ColLn.i,' ')
                  end
                end
              otherwise
                Row = Row || LEFT(CurSQLDA.i.SQLDATA,ColLn.i,' ')
              end
          end
          If ResultType = 'HTML' then Row = Row || '</TR>'
          RowCount = RowCount + 1
          Call QueueOut
        end
      When SQLCODE = +100 Then
        If RowCount = 0 then
          Do
            ReturnCode = 4
            Select
              When ResultType = 'CSV' | ResultType = 'CSVNoHeader' then
                Do
                  Row = '"RSQL: No Rows found. Empty Result Set."'
                  Call QueueOut
                end
              When ResultType = 'HTML' then
                Do
                  Row = '<HTML>'
                  Call QueueOut
                  Row = '<HEAD>'
                  Call QueueOut
                  Row = '  <TITLE>RSQL Generated Report</TITLE>'
                  Call QueueOut
                  Row = '  <META NAME="generator" CONTENT="RSQL">'
                  Call QueueOut
                  Row = '  <META NAME="author" CONTENT="Alan Wynne">'
                  Call QueueOut
                  Row = '</HEAD>'
                  Call QueueOut
                  Row = '<BODY><PRE>'
                  Call QueueOut
                  Row = '<H1>RSQL Generated Report</H1>'
                  Call QueueOut
                  Row = '<P>No Rows found. Empty Result Set.</P>'
                  Call QueueOut
                end
              otherwise
                Do
                  Row = 'RSQL: No Rows found. Empty Result Set.'
                  Call QueueOut
                end
            end
          end
      otherwise
        Call SQLError
    end
  end

  If ResultType = 'HTML' then
    Do
     Row = '</TABLE>'
     Call QueueOut
     Row = '</PRE>'
     Call QueueOut
     Row = '</BODY>'
     Call QueueOut
     Row = '</HTML>'
     Call QueueOut
    end

  LastAct = STMTCLOSE
  Address DSNREXX "EXECSQL " STMTCLOSE
  If SQLCODE ¬= 0 Then Call SQLError

  NoRS = NoRS + 1
  OutDD = 'RS'        || RIGHT(NoRS,6,'0')
  OutDSN = OutDSNMask || '.' || OutDD || '.' || FileExtension
  Disp = 'NEW'

  Call WriteOutput

  "DELSTACK"
  "NEWSTACK"

  Row = Left('-- =',72,'=')
  Call QueueOut

  Row = '-- SQL Statement Executed : 'NoStmnt
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Call SQLFormat

  Row = '  ;'
  Call QueueOut

  Row = '-- End of Sql Statement'
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Row = '-- Error and Warning Messages : 'NoMessage
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Do i = 1 to NoMessage until i > NoMessage
    Row = '-- 'Message.i
    Call QueueOut
  end

  If NoMessage > 0 Then
    Do
      Row = '-- '
      Call QueueOut
    end

  Row = '-- Statistics '
  Call QueueOut

  Row = '-- Headings  Records  Rows    Bytes    Max Lngth  '  ,
      'Avg Size'
  Call QueueOut

  NoBytes = NoBytes + 62
  RecCount = RecCount + 1
  AvgRecSize = NoBytes/RecCount

  Row = '-- 'Right(PgeCnt,6,'0')'    'Right(RecCount,6,'0'),
    '  'Right(RowCount,6,'0')'  'Right(NoBytes,6,'0')'  ',
    Right(MaxDataLn,6,'0')'    'Right(AvgRecSize,6,'0')' '
  Call QueueOut

  OutDSN = OutDSNMask || '.RSQLOUT.TXT'
  OutDD = 'RSQLOUT'
  Disp = 'MOD'

  Call WriteOutput

  "DELSTACK"

  Return

/* ================================================================== */
/* Perform statements that cannot be prepared.                        */
/*                                                                    */

DoExecImmediate:

  "NEWSTACK"

  PgeCnt = 0
  PgeLnCnt = 0
  RowCount = 0
  RecCount = 0
  PageHeadings = ''

  MaxDataLn = 0
  NoBytes = 0
  NoStmnt = NoStmnt + 1
  drop CurSQLDA.
  drop ColLn.

  Disp = 'MOD'

  STMTEXEC = 'Execute  Immediate  :SQLStmnt'

  LastAct = STMTEXEC
  Address DSNREXX "EXECSQL " STMTEXEC

  If RSQLDADSN > '' Then Call SaveSQLDA

  Row = Left('-- =',72,'=')
  Call QueueOut

  Row = '-- SQL Statement Executed : 'NoStmnt
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Call SQLFormat

  Row = '  ;'
  Call QueueOut

  Row = '-- End of Sql Statement'
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Row = '-- Error and Warning Messages : 'NoMessage
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Do i = 1 to NoMessage until i > NoMessage
    Row = '-- 'Message.i
    Call QueueOut
  end

  If NoMessage ¬= 0 Then
    Do
      Row = '-- '
      Call QueueOut
    end

  If SQLCODE ¬= 0 & SQLCODE ¬= +100 Then Call SQLError

  If j > MaxDataLn then MaxDataLn = j
  OutDSN = OutDSNMask || '.RSQLOUT.TXT'
  OutDD = RSQLOutDD

  Call WriteOutput

  "DELSTACK"

  Return

/* ================================================================== */
/* DoExecute executes non Cursor commands that need to be prepared.   */
/*                                                                    */

DoExec:

  "NEWSTACK"

  PgeCnt = 0
  PgeLnCnt = 0
  RowCount = 0
  RecCount = 0
  PageHeadings = ''

  MaxDataLn = 0
  NoBytes = 0
  NoStmnt = NoStmnt + 1
  drop CurSQLDA.
  drop ColLn.

  Disp = 'MOD'

  STMTDCLR = 'Declare  S001 Statement '
  STMTPRPR = 'Prepare  S001 into  :CurSQLDA from :SQLStmnt'
  STMTDSCR = 'Describe S001 into  :CurSQLDA '
  STMTEXEC = 'Execute  S001 using :CurSQLDA '

  LastAct = STMTDCLR
  Address DSNREXX "EXECSQL " STMTDCLR
  If SQLCODE ¬= 0 Then Call SQLError

  LastAct = STMTPRPR
  Address DSNREXX "EXECSQL " STMTPRPR
  If SQLCODE ¬= 0 Then Call SQLError

/*LastAct = STMTDSCR                                                  */
/*Address DSNREXX "EXECSQL " STMTDSCR                                 */
/*If SQLCODE ¬= 0 Then Call SQLError                                  */

  LastAct = STMTEXEC
  Address DSNREXX "EXECSQL " STMTEXEC
  If SQLCODE ¬= 0 Then Call SQLError

  If RSQLDADSN > '' Then Call SaveSQLDA

  Row = Left('-- =',72,'=')
  Call QueueOut

  Row = '-- SQL Statement Executed : 'NoStmnt
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Call SQLFormat

  Row = '  ;'
  Call QueueOut

  Row = '-- End of Sql Statement'
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Row = '-- Error and Warning Messages : 'NoMessage
  Call QueueOut

  Row = '-- '
  Call QueueOut

  Do i = 1 to NoMessage until i > NoMessage
    Row = '-- 'Message.i
    Call QueueOut
  end

  If NoMessage > 0 Then
    Do
      Row = '-- '
      Call QueueOut
    end

  If SQLCODE ¬= 0 Then Call SQLError

  If j > MaxDataLn then MaxDataLn = j
  OutDSN = OutDSNMask || '.RSQLOUT.TXT'
  OutDD = RSQLOutDD

  Call WriteOutput

  "DELSTACK"

  Return

/* ================================================================== */
/* Split SQL Statement string into seperate lines when a certain      */
/* reseved words occur.                                               */
/*                                                                    */

SQLFormat:

/* TRACE ?R */

  StmntLen    = Length(SQLStmnt)
  LineLen     = 68
  PosLstSpc   = 0
  PosLstComma = 0
  StrtPos     = 1

  Do while LineLen > 0
     StmntLine   = Substr(SQLStmnt,StrtPos)
     StmntLine   = Strip(StmntLine)
     LineLen     = Length(StmntLine)
     if LineLen > 68 Then
       Do
         StmntLine   = SubStr(StmntLine,1,68)
         LineLen     = Length(StmntLine)
         PosLstSpc   = LASTPOS(' ',StmntLine)
         PosLstComma = LASTPOS(',',StmntLine)
         Select
           When PosLstSpc = 0 & PosLstComma = 0 then
             Do
               StmntLine = SubStr(StmntLine,1,70)
               StrtPos   = StrtPos + 70
             End
           When PosLstSpc > 0 & PosLstComma = 0 then
             Do
               StmntLine = SubStr(StmntLine,1,PosLstSpc)
               StrtPos   = StrtPos + PosLstSpc
             End
           When PosLstSpc = 0 & PosLstComma > 0 then
             Do
               StmntLine = SubStr(StmntLine,1,PosLstSpc)
               StrtPos   = StrtPos + PosLstComma
             End
           Otherwise
             Do
               StmntLine = SubStr(StmntLine,1,PosLstSpc)
               StrtPos   = StrtPos + PosLstSpc
             End
         End
       End
     Else
       StrtPos = StrtPos + LineLen
     Row = '   'StmntLine
     Call QueueOut
  end

Return
/* ================================================================== */
/* Create and Write to the Output Dataset.                            */
/*                                                                    */

WriteOutput:

/* TRACE ?R */


  If OutDD = 'RSQLOUT' then
    "EXECIO "queued()" DISKW "RSQLOutDD" "
  Else If Mode = 'ONLINE' Then
    Do
      If Disp = 'NEW' Then "DELETE '"OutDSN"' PURGE SCRATCH"
      MaxDataLn = MaxDataLn + 4

      MngmntCls =  RSQLDFLT('MngmntCls')
      StorageCls =  RSQLDFLT('StorageCls')

      ALLOCOUT = "DA('"OutDSN"') F("OutDD")"
      ALLOCOUT = ALLOCOUT  Disp' MGMTCLAS('MngmntCls')'
      ALLOCOUT = ALLOCOUT' STORCLAS('StorageCls')'
      ALLOCOUT = ALLOCOUT' LRECL('MaxDataLn')'
      ALLOCOUT = ALLOCOUT' RECFM(V)'

      "ALLOC "ALLOCOUT

      "EXECIO "queued()" DISKW "OutDD" (OPEN"
      "EXECIO "queued()" DISKW "OutDD" (FINIS"

      "Free DA('"OutDSN"')"
      SAY '  RSQLEXEC: Output written to Dataset : ' OutDSN

    end
  Else If Mode = 'BATCH' Then
    Do
      OutDSN = DSNSearch(OutDD)
      MaxDataLn = MaxDataLn + 4

      MngmntCls =  RSQLDFLT('MngmntCls')
      StorageCls =  RSQLDFLT('StorageCls')

      ALLOCOUT = 'F('OutDD') DA('OutDsn')MOD'

      "ALLOC "ALLOCOUT

      "EXECIO "queued()" DISKW "OutDD" (OPEN"
      "EXECIO "queued()" DISKW "OutDD" (FINIS"

      "Free FILE("OutDD")"
      SAY '  RSQLEXEC: Output written to: '
      SAY '    DD 'OutDD' DSN='OutDSN

    end


  Return

/* ================================================================== */
/* Determine the output dataset mask.                                 */
/*                                                                    */
OutputMask:

  OutDSNMask = Userid()   || '.'  || SSID
  OutDSNMask = OutDSNMask || '.DT' || SUBSTR(DATE('S'),3)

  Member = ''

  i = POS('(',RSQLIN)
  j = POS(')',RSQLIN)
  k = Length(RSQLIN)
  l = LastPOS('.',RSQLIN)
  If i > 0  then
    If j > i then
      Do
        MemLn = j - i - 1
        Member = substr(RSQLIN,i+1,MemLn)
        OutDSNMask = OutDSNMask || '.' || Member
      end
    Else
      If k > 0 and k < l then
        OutDSNMask = OutDSNMask || substr(RSQLIN,l)
  Else
    If k > 0 and k < l then
      OutDSNMask = OutDSNMask || substr(RSQLIN,l)

  Return
/* ================================================================== */
/* Perform Rollback for unexpected errors.                            */
/*                                                                    */
RSQLRollback:

      LastAct = 'ROLLBACK'
      Address DSNREXX "EXECSQL" "ROLLBACK"
      Row = Left('-- =',72,'=')
      Call QueueOut
      Row = '-- '
      Call QueueOut
      Row = '-- Rollback Performed: SQLCODE =' SQLCODE
      Call QueueOut
      Row = '-- '
      Call QueueOut
      If      SQLCODE ¬= 0 Then Call SQLError
      Row = Left('-- =',72,'=')
      Call QueueOut

  Return
/* ================================================================== */
/* Display SQLError                                                   */
/*                                                                    */

SQLError:

/* TRACE ?R */

  Commit = 'No'
  ReturnCode = 12

  Row = Left('-- =',72,'=')
  Say Row
  Call QueueOut
  Row = '-- SQL Error occurred.'
  Say Row
  Call QueueOut
  Row = '-- '
  Say Row
  Call QueueOut
  Row = '-- Last Action : 'LastAct
  Say Row
  Call QueueOut
  Row = '-- Sql Statement :'
  Say Row
  Call QueueOut
  Row = '-- '
  Say Row
  Call QueueOut

  Call SQLFormat

  Row = '  ;'
  Say Row
  Call QueueOut
  Row = Left('-- =',72,'=')
  Say Row
  Call QueueOut
  Row = '--'
  Say Row
  Call QueueOut
  Row = '--  SQLDA : '
  Say Row
  Call QueueOut
  Row = '--'
  Say Row
  Call QueueOut
  Row = '-- SQLCODE   =<'SQLCODE'>'
  Say Row
  Call QueueOut
  Row = '-- SQLERRMC  =<'SQLERRMC'>'
  Say Row
  Call QueueOut
  Row = '-- SQLERRP   =<'SQLERRP'>'
  Say Row
  Call QueueOut
  Row = '-- SQLERRD   =<'SQLERRD.1  || '>,<',
                 || SQLERRD.2  || '>,<',
                 || SQLERRD.3  || '>,<',
                 || SQLERRD.4  || '>,<',
                 || SQLERRD.5  || '>,<',
                 || SQLERRD.6  || '>'
  Say Row
  Call QueueOut
  Row = '-- SQLWARN   =<'SQLWARN.0  || '>,<',
                 || SQLWARN.1  || '>,<',
                 || SQLWARN.2  || '>,<',
                 || SQLWARN.3  || '>,<',
                 || SQLWARN.4  || '>,<',
                 || SQLWARN.5  || '>,<',
                 || SQLWARN.6  || '>,<',
                 || SQLWARN.7  || '>,<',
                 || SQLWARN.8  || '>,<',
                 || SQLWARN.9  || '>,<',
                 || SQLWARN.10 || '>'
  Say Row
  Call QueueOut
  Row = '-- SQLSTATE  <'SQLSTATE'>'
  Say Row
  Call QueueOut

  Row = Left('-- =',72,'=')
  Say Row
  Call QueueOut

  Return
/* ================================================================== */
/* Save the SQLDA in an Array.                                        */
/*                                                                    */
SaveSQLDA:

  IF RSQLDADSN = '' Then Return

  NoSQLDA   = NoSQLDA + 1

  SavedSQLDAs.NoSQLDA.SQLD = CurSQLDA.SQLD

  If CurSQLDA.SQLD > 0 then
    Do i = 1 to CurSQLDA.SQLD

      if CurSQLDA.i.SQLTYPE             = 'CURSQLDA.'i'.SQLTYPE'    then
          SavedSQLDAs.NoSQLDA.i.SQLTYPE = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLTYPE = CurSQLDA.i.SQLTYPE

      if CurSQLDA.i.SQLLEN              = 'CURSQLDA.'i'.SQLLEN'     then
          SavedSQLDAs.NoSQLDA.i.SQLLEN  = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLLEN  = CurSQLDA.i.SQLLEN

      if CurSQLDA.i.SQLLEN.SQLPRECISION =  ,
        'CURSQLDA.'i'.SQLLEN.SQLPRECISION'                         then
          SavedSQLDAs.NoSQLDA.i.SQLLEN.SQLPRECISION = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLLEN.SQLPRECISION = ,
            CurSQLDA.i.SQLLEN.SQLPRECISION

      if CurSQLDA.i.SQLLEN.SQLSCALE     =  ,
        'CURSQLDA.'i'.SQLLEN.SQLSCALE'                              then
          SavedSQLDAs.NoSQLDA.i.SQLLEN.SQLSCALE = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLLEN.SQLSCALE = ,
            CurSQLDA.i.SQLLEN.SQLSCALE

      if    CurSQLDA.i.SQLCCSID         = 'CURSQLDA.'i'.SQLCCSID'   then
          SavedSQLDAs.NoSQLDA.i.SQLCCSID = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLCCSID = CurSQLDA.i.SQLCCSID

      if    CurSQLDA.i.SQLLOCATOR       = 'CURSQLDA.'i'.SQLLOCATOR' then
          SavedSQLDAs.NoSQLDA.i.SQLLOCATOR = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLLOCATOR = CurSQLDA.i.SQLLOCATOR

      if    CurSQLDA.i.SQLDATA          = 'CURSQLDA.'i'.SQLDATA'    then
          SavedSQLDAs.NoSQLDA.i.SQLDATA = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLDATA = CurSQLDA.i.SQLDATA

      if    CurSQLDA.i.SQLIND           = 'CURSQLDA.'i'.SQLIND'     then
          SavedSQLDAs.NoSQLDA.i.SQLIND  = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLIND  = CurSQLDA.i.SQLIND

      if    CurSQLDA.i.SQLNAME          = 'CURSQLDA.'i'.SQLNAME'    then
          SavedSQLDAs.NoSQLDA.i.SQLNAME = ''
      else
          SavedSQLDAs.NoSQLDA.i.SQLNAME = CurSQLDA.i.SQLNAME

    End

  Return

/* ================================================================== */
/* Display the SQLDA's.                                               */
/*                                                                    */
OutputSQLDA:

  IF RSQLDADSN = '' Then Return

  "NEWSTACK"

  Row = Left('-- =',72,'=')
  Call QueueOut

  Row = Left('--  ',72,' ')
  Call QueueOut

  Row = "--  Number of Saved SQLDA's = "NoSQLDA
  Call QueueOut

  Row = Left('--  ',72,' ')
  Call QueueOut

  Do i = 1 to NoSQLDA

    Row = Left('-- -',72,'-')
    Call QueueOut

    Row = '--  SQLDA 'i
    Call QueueOut

    Row = Left('--  ',72,' ')
    Call QueueOut

    if SavedSQLDAs.i.SQLD                   ¬= ''                  then
      Do
        Row = '-- SQLDA.SQLD=<'SavedSQLDAs.i.SQLD'>'
        Call QueueOut
      End

    If SavedSQLDAs.i.SQLD > 0                                      then
      Do j = 1 to SavedSQLDAs.i.SQLD

        if SavedSQLDAs.i.j.SQLTYPE          ¬= ''                  then
          Do
            Row = '<SQLDA.'i'.'j'.SQLTYPE>=<'SavedSQLDAs.i.j.SQLTYPE'>'
            Call QueueOut
          End

        if SavedSQLDAs.i.j.SQLLEN           ¬= ''                  then
          Do
            Row = '<SQLDA.'i'.'j'.SQLLEN>=<'SavedSQLDAs.i.j.SQLLEN'>'
            Call QueueOut
          End

        if SavedSQLDAs.i.j.SQLLEN.SQLPRECISION ¬= ''               then
          Do
            Row = '<SQLDA.'i'.'j'.SQLLEN.SQLPRECISION>=<' || ,
              SavedSQLDAs.i.j.SQLLEN.SQLPRECISION'>'
            Call QueueOut
          End

        if SavedSQLDAs.i.j.SQLLEN.SQLSCALE  ¬= ''                  then
          Do
            Row = '<SQLDA.'i'.'j'.SQLLEN.SQLSCALE>=<' || ,
              SavedSQLDAs.i.j.SQLLEN.SQLSCALE'>'
            Call QueueOut
          End

        if    SavedSQLDAs.i.j.SQLCCSID      ¬= ''                  then
          Do
          Row = '<SQLDA.'i'.'j'.SQLCCSID>=<'SavedSQLDAs.i.j.SQLCCSID'>'
            Call QueueOut
          End

        if    SavedSQLDAs.i.j.SQLLOCATOR    ¬= ''                  then
          Do
            Row = '<SQLDA.'i'.'j'.SQLLOCATOR>=<' || ,
              SavedSQLDAs.i.j.SQLLOCATOR'>'
            Call QueueOut
          End

        if    SavedSQLDAs.i.j.SQLDATA       ¬= ''                  then
          Do
            Row = '<SQLDA.'i'.'j'.SQLDATA>=<'SavedSQLDAs.i.j.SQLDATA'>'
            Call QueueOut
          End

        if    SavedSQLDAs.i.j.SQLIND        ¬= ''                  then
          Do
            Row = '<SQLDA.'i'.'j'.SQLIND>=<'SavedSQLDAs.i.j.SQLIND'>'
            Call QueueOut
          End

        if    SavedSQLDAs.i.j.SQLNAME       ¬= ''                  then
          Do
            Row = '<SQLDA.'i'.'j'.SQLNAME>=<' || ,
              SavedSQLDAs.i.j.SQLNAME'>'
            Call QueueOut
          End

      End

  End

  ALLOCOUT = 'FILE('RSQLDA') DA('RSQLDADSN' MOD '
  "ALLOC "ALLOCOUT

  "EXECIO "queued()" DISKW "RSQLDADD" (OPEN"
  "DELSTACK"

  Return
/* ================================================================== */
/* Queue a record for output to the output File                       */
/*                                                                    */

QueueOut:

/* TRACE ?R */

  RowLn = Length(Row)
  If MaxDataLn < RowLn then MaxDataLn = RowLn
  NoBytes = NoBytes     + RowLn
  RecCount = RecCount + 1
  PgeLnCnt = PgeLnCnt + 1

  Queue Row
  Row = ''

  Return

/* ================================================================== */
/* Queue a record for output to the output File                       */
/*                                                                    */

ListAloc:

/* TRACE ?R */

/* ================================================================== */
/* Determine which datasets are allocated.                            */
/*                                                                    */

  Drop DatasetInfo.
  DatasetInfo.0 = 0

  BlankString = '                                                     '

  x = OUTTRAP('ListAlc.')

  "LISTALC STATUS"

  if ListAlc.0 = 0 Then NOP
  Else
    Do i = 1 to listAlc.0
      Select
        When SubStr(ListAlc.i,1,2) = '--'    then NOP
        When SubStr(ListAlc.i,1,2) = '  '    then
          Do
            DatasetInfo.j.DD   = Substr(ListAlc.i,3,8)
            DatasetInfo.j.Disp = Strip(Substr(ListAlc.i,12))
          End /* when */
        Otherwise
          Do
            DatasetInfo.0      = DatasetInfo.0 + 1
            j                  = DatasetInfo.0
            DatasetInfo.j.DSN  = Strip(ListAlc.i)
            DatasetInfo.j.DD   = ''
            DatasetInfo.j.Disp = ''
            k =  POS(' ',DatasetInfo.j.DSN,1)
            If k > 0 then
              Do
                DatasetInfo.j.DD   =                                  ,
                  Strip(Substr(DatasetInfo.j.DSN,k,))
                DatasetInfo.j.DSN  =                                  ,
                  Strip(Substr(DatasetInfo.j.DSN,1,k))
              End /* if */
          End /* otherwise */
      End /* select */
    End /* if */

  Return

DSNSearch:

/* TRACE ?R */

/* ================================================================== */
/* Find the DSName for the Respective DD name provided.               */
/*                                                                    */

  Parse Arg DDSearch

  DSNFound    = ''

  if DDSearch = '' Then NOP
  else
    Do i = 1 to DatasetInfo.0
      if DatasetInfo.i.DD = DDSearch then
        Do
          DSNFound = DatasetInfo.i.DSN
          Return DSNFound
        End
    End

  Return DSNFound

