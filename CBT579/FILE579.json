{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012410000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE579.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE579.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\r'", "DS1TRBAL": "b'l`'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04L\\x00\\x03\\x04L\\x00\\x05\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x15o\\x01\\x02\\x15o\\x18#\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-06-05T00:00:00", "modifydate": "2002-06-05T18:23:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 448    FILE:  579\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT448.FILE579\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 4 MEMBERS COUNTED; CUMULATIVE SIZE IS 256 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/05/02    18:23:53    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x02\\x15o\\x01\\x02\\x15o\\x18\\x18\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-06-05T00:00:00", "modifydate": "2002-06-05T18:18:04", "lines": 25, "newlines": 25, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:   CBT tape contribution\nDate:      Wed, 5 Jun 2002 15:23:50 -0500\nFrom:      \"Patriquin, Tim\" <Tim_Patriquin@bmc.com>\nTo:        \"'sbgolob@attglobal.net'\" <sbgolob@attglobal.net>\n\n\nSam,\n\nSince my contribution is small in size and I'm only using it with\nthe Tachyon cross assembler, I decided to send it with the email\nand hope that if you find value you can put it in the correct\nformat for distribution.\n\nThe documentation is in the macro header, but I've extracted it\nhere for you to see.  In a nutshell, the macro adds BREAK and\nCONTINUE support to the structured programming macros included\nwith the HLASM toolkit.  Note that it does not replace IBM's\noffering; the HLASM toolkit must be present for this to work.\n\nPlease let me know if you need any further information.  I can be\ncontacted at work tim_patriquin@bmc.com or home tpatriqu@onr.com.\n\nBest Regards,\nTim Patriquin\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE579": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00$\\x01\\x01\\x02_\\x01\\x02\\x15o\\x18#\\x00\\x0b\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-06-05T18:23:24", "lines": 11, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 579 is from Tim Patriquin and contains a set of macros    *   FILE 579\n//*           which adds BREAK and CONTINUE functionality to the    *   FILE 579\n//*           macros in the HLASM toolkit.                          *   FILE 579\n//*                                                                 *   FILE 579\n//*           You must already be licensed for the IBM HLASM        *   FILE 579\n//*           Toolkit, in order to use this material practically.   *   FILE 579\n//*           This file is an add-on to the HLASM Toolkit.          *   FILE 579\n//*                                                                 *   FILE 579\n//*           emails:  tim_patriquin@bmc.com (work)                 *   FILE 579\n//*                    tpatriqu@onr.com      (home)                 *   FILE 579\n//*                                                                 *   FILE 579\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPMACROS": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x002\\x01\\x02\\x15o\\x01\\x02\\x15o\\x18\\x12\\x00\\xd0\\x00\\xd0\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-06-05T00:00:00", "modifydate": "2002-06-05T18:12:32", "lines": 208, "newlines": 208, "modlines": 0, "user": "SBGOLOB"}, "text": "         PUSH PRINT,noprint\n         PRINT OFF,NOPRINT\n.*                                                                    *\n.* Function:  Implement BREAK and CONTINUE capability for the IBM     *\n.*            structured programming macros included in the HLASM     *\n.*            toolkit.                                                *\n.*                                                                    *\n.* Usage:     Add COPY SPMACROS statement to your program prior to    *\n.*            the first usage of a structured macro.  If you already  *\n.*            have a COPY ASMMSP statement in your source code you    *\n.*            will need to remove it (just gets way to complicated    *\n.*            to do this support any other way!).                     *\n.*                                                                    *\n.* Info:      The structured programming macros in the HLASM toolkit  *\n.*            are normally included via a COPY ASMMSP statement. If   *\n.*            you're including the SPMACROS member then we can assume *\n.*            you want the structured macros so we'll go ahead and    *\n.*            include them first thing in this macro.                 *\n.*                                                                    *\n.*            How it works: First we issue the COPY ASMMSP and        *\n.*            this brings in all of the structured macro definitions. *\n.*            Since we need to \"hook\" the DO and ENDDO macros to      *\n.*            provide the BREAK and CONTINUE functionality, we first  *\n.*            do an OPSYN for DO and ENDDO so we can save their       *\n.*            real contents.  Then we will define our new versions    *\n.*            of DO and ENDDO that wrap the originals' functionality  *\n.*            with some setting of global variables that are used     *\n.*            in the event a BREAK or CONTINUE statement is coded.    *\n.*            The CONTINUE statement needs to branch to a point       *\n.*            prior to the instructions generated for the             *\n.*            corresponding ENDDO.  Any BREAK statement needs to      *\n.*            branch past the ENDDO instructions so we can get        *\n.*            out of the loop.  Then it's just a matter of defining   *\n.*            the BREAK and CONTINUE macros so they branch to the     *\n.*            proper label. (BTW, labels will only be generated when  *\n.*            they are required due to usage of either a BREAK or     *\n.*            CONTINUE within the bounding DO loop).                  *\n.*                                                                    *\n.* Examples:                                                          *\n.*        DO WHILE=(...)                                              *\n.*          ...                                                       *\n.*          IF (CLC,...)                                              *\n.*            MVC RC,=F'8'                                            *\n.*            BREAK             Break out of DO loop                  *\n.*          ENDIF                                                     *\n.*        ENDDO                                                       *\n.*                                                                    *\n.*        DO WHILE=(...)                                              *\n.*          ...                                                       *\n.*          IF (CLC,...)                                              *\n.*            CONTINUE          Continue with next iteration of DO    *\n.*          ENDIF                                                     *\n.*          ...                                                       *\n.*        ENDDO                                                       *\n.*                                                                    *\n.*        You can also break / continue to something other than the   *\n.*        adjacent outer DO by explicitly labeling the DO statement   *\n.*        and then referencing the label on the BREAK or CONTINUE:    *\n.*                                                                    *\n.*  L1    DO WHILE=(...)                                              *\n.*          ...                                                       *\n.*  L2      DO WHILE=(...)                                            *\n.*            ...                                                     *\n.*            IF (CLC,...)                                            *\n.*              MVC RC,=F'8'                                          *\n.*              CONTINUE L1       Continue on with L1's loop          *\n.*            ENDIF                                                   *\n.*          ENDDO                                                     *\n.*        ENDDO                                                       *\n.*                                                                    *\n.* Maintenance History:                                               *\n.*                                                                    *\n.*   Date   Who Prob #  CHID Description                              *\n.* ======== === ======= ==== ======================================== *\n.* 06/03/02 TJP P000000 #000 Macro created\n.* 06/05/02 TJP P000000 #001 Add support for optional labels on the   *\n.*                           DO that can be referenced directly on    *\n.*                           the BREAK or CONTINUE.                   *\n.*                                                                    *\n.* ** End of maintenance history **                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         COPY  ASMMSP                  IBM's structured pgming macros\n##DO     OPSYN DO                      Hide the real \"DO\" macro\n##ENDDO  OPSYN ENDDO                   Hide the real \"ENDDO\" macro\n.*\n.**********************************************************************\n.* Define our replacement DO macro that will set some global          *\n.* variables for branch labels. It will then invoke the original DO   *\n.* macro that has been aliased to ##DO.                               *\n.**********************************************************************\n         MACRO\n&LABEL   DO    &P1,&FROM=,&TO=,&BY=,&UNTIL=,&WHILE=\n         GBLA  &##DOLVL,##DOCNT\n         GBLC  &##DOLOP(100)           Labels for start of loop checks\n         GBLC  &##DOEND(100)           Labels for end of loops\n         GBLC  &##DOLBL(100)           Labels for DO loop Label\n         GBLB  &##DOLOPF(100)          Labels for start of loop needed?\n         GBLB  &##DOENDF(100)          Labels for end of loop needed?\n.*\n&##DOLVL SETA  &##DOLVL+1\n&##DOCNT SETA  &##DOCNT+1\n.*\n&##DOLBL(&##DOLVL) SETC '&LABEL'            Label for DO loop\n&##DOLOP(&##DOLVL) SETC '#@DC'.'&##DOCNT'.'L'.'&##DOLVL'  CONT label\n&##DOEND(&##DOLVL) SETC '#@DB'.'&##DOCNT'.'L'.'&##DOLVL'  BREAK label\n\n.*---- Invoke the real DO macro at this time\n         ##DO  &P1,FROM=&FROM,TO=&TO,BY=&BY,UNTIL=&UNTIL,WHILE=&WHILE\n\n         MEND\n\n.**********************************************************************\n.* Define our replacement ENDDO macro.  Generate labels for           *\n.* BREAK and CONTINUE statements only if they are needed.  Invoke     *\n.* the original ENDDO to generate the branching code.                 *\n.**********************************************************************\n         MACRO\n         ENDDO\n         GBLA  &##DOLVL\n         GBLC  &##DOLOP(100)           Labels for start of loop checks\n         GBLC  &##DOEND(100)           Labels for end of loops\n         GBLC  &##DOLBL(100)           Labels for DO loop Label\n         GBLB  &##DOLOPF(100)          Labels for start of loop needed?\n         GBLB  &##DOENDF(100)          Labels for end of loop needed?\n.*\n         AIF   (NOT &##DOLOPF(&##DOLVL)).BEF   CONTINUE specified??\n&##DOLOP(&##DOLVL) EQU  *              Label for CONTINUE\n.BEF     ANOP\n.*\n.* Invoke the real ENDDO macro at this time\n         ##ENDDO\n.*\n         AIF   (NOT &##DOENDF(&##DOLVL)).END   BREAK specified?\n&##DOEND(&##DOLVL) EQU  *              Label for BREAK\n.END     ANOP\n.*\n&##DOLOPF(&##DOLVL) SETB 0             Turn off CONTINUE label req flag\n&##DOENDF(&##DOLVL) SETB 0             Turn off BREAK label req flag\n&##DOLBL(&##DOLVL)  SETC ''            Reset Label for DO loop\n&##DOLVL SETA  &##DOLVL-1              Decrement the DO level count\n         MEND\n\n.**********************************************************************\n.* Generate the branch to the BREAK statement label.  Set the flag    *\n.* so we know we need to generate the statement when the ENDDO is     *\n.* encountered.                                                       *\n.**********************************************************************\n         MACRO\n         BREAK &LABEL\n         GBLA  &##DOLVL\n         GBLC  &##DOLOP(100)           Labels for start of loop checks\n         GBLC  &##DOEND(100)           Labels for end of loops\n         GBLC  &##DOLBL(100)           Labels for DO loop Label\n         GBLB  &##DOENDF(100)          Labels for end of loop needed?\n         LCLA  &DOLVL                  What level do we break to?\n&DOLVL   SETA  &##DOLVL                Default to current level\n.*       If Label Specified with BREAK search for same\n.*       If found utilize that Label at that level\n         AIF   ('&LABEL' EQ '').DOLVLOK\n.BRLOOPA ANOP  ,\n         AIF   ('&##DOLBL(&DOLVL)' EQ '&LABEL').DOLVLOK\n&DOLVL   SETA  &DOLVL-1\n         AIF   (&DOLVL GT 0).BRLOOPA\n         MNOTE 8,'The target label selected for the BREAK either does n$\n               ot exist or is an inner loop label'\n         MEXIT ,\n.* Label found, so &DOLVL has been adjusted to the proper value\n.DOLVLOK ANOP  ,\n.*\n         B     &##DOEND(&DOLVL)        Break out of current DO loop!\n&##DOENDF(&DOLVL) SETB 1               Turn on BREAK label req\n.*\n         MEND\n\n.**********************************************************************\n.* Generate the branch to the CONTINUE statement label.  Set the flag *\n.* so we know we need to generate the statement when the ENDDO is     *\n.* encountered.                                                       *\n.**********************************************************************\n         MACRO\n         CONTINUE &LABEL\n         GBLA  &##DOLVL\n         GBLC  &##DOLOP(100)           Labels for start of loop checks\n         GBLC  &##DOLBL(100)           Labels for DO loop Label\n         GBLB  &##DOLOPF(100)          Labels for start of loop needed?\n.*\n         LCLA  &DOLVL                  What level do we CONTINUE at?\n&DOLVL   SETA  &##DOLVL                Default to current level\n.*       If Label Specified with CONTINUE search for same\n.*       If found utilize that Label at that level\n         AIF   ('&LABEL' EQ '').DOLVLOK\n.BRLOOPA ANOP  ,\n         AIF   ('&##DOLBL(&DOLVL)' EQ '&LABEL').DOLVLOK\n&DOLVL   SETA  &DOLVL-1\n         AIF   (&DOLVL GT 0).BRLOOPA\n         MNOTE 8,'The target label selected for the CONTINUE either doe$\n               s not exist or is an inner loop label'\n         MEXIT ,\n.* Label found, so &DOLVL has been adjusted to the proper value\n.DOLVLOK ANOP  ,\n.*\n         B     &##DOLOP(&DOLVL)        Continue on in the DO loop!\n&##DOLOPF(&DOLVL) SETB 1               Turn on CONTINUE label req\n.*\n         MEND\n         POP  PRINT,noprint\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT579/FILE579.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT579", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}