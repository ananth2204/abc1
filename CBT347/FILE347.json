{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011816000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE347.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE347.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x0f'", "DS1TRBAL": "b'\\t*'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\x8a\\x00\\x08\\x02\\x8b\\x00\\x00\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00\\x12\\x01\\x16\\x18o\\x01\\x16\\x18o\\x14\"\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-07-04T00:00:00", "modifydate": "2016-07-04T14:22:12", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-491"}, "text": "REGULAR CBT TAPE - VERSION 491    FILE:  347\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT491.FILE347\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 14 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,498 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/04/16    14:22:12    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\x16\\x18o\\x01\\x16\\x18o\\x14\\x15\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-07-04T00:00:00", "modifydate": "2016-07-04T14:15:21", "lines": 23, "newlines": 23, "modlines": 0, "user": "SBGOLOB"}, "text": "Note from Sam Golob....   (04JUL2016)\n\nAs of now, this program will only detect older COBOL versions, and it\nneeds to be fixed to detect later versions of COBOL.  I ran it against\nold ANSI COBOL load modules, and new COBOL modules, and I determied\n(it didn't take much) that this program needs to be modernized.\n\nIt does (accurately) tell you what CSECTs are in each load module.\n\nThere are other programs on the CBT Tape (for example COBANAL on File\n321) which will detect attributes of COBOL load modules.  For now you\nshould use them.\n\nWe'll see what we can do in the future with this one.\n\nSincerely,    Sam Golob\n\nsupport email:  sbgolob@cbttape.org   or\n                sbgolob@attglobal.net\n\nUnfortunately, Rick Fochtman has passed away.  We miss him....!!!\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$README": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x982\\x7f\\x00\\x99\\x03\\x0f#\\x18\\x00#\\x00!\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-11-23T00:00:00", "modifydate": "1999-01-30T23:18:00", "lines": 35, "newlines": 33, "modlines": 0, "user": "CHSY227"}, "text": "\nASSEMBLE THIS USING THE SOURCE LIBRARY AS THE FIRST MEMBER OF THE\nCONCATENATED SYSLIB DATASET.  YOU'LL ALSO NEED SYS1.MACLIB, AND\nPOSSIBLY MODGEN.  USE THE BATCH OPTION; THERE ARE SEVERAL SEPARATE\nSOURCE DECKS STACKED.\n\nDO NOT LINK WITH SPECIAL OPTIONS.  THIS PROGRAM IS NOT REENTRANT,\nREUSABLE OR REFRESHABLE.  ALLOW THE BINDER TO ASSIGN THE RMODE/AMODE\nATTRIBUTES BY DEFAULT, ACCORDING TO THE CSECT FLAGS.\n\nTHE MODLIST PROGRAM WAS DEVELOPED AS A STOP-GAP MEASURE, TO TRY AND\nKEEP A HANDLE ON OUR OS/VS COBOL TO COBOL II CONVERSION PROJECT.\nTHE ONLY KNOWN BUG LEFT IS IN DEALING WITH MODULES THAT MAY LOAD\nABOVE THE 16M LINE.  SOMETIMES THEY WORK OK; SOMETIMES NOT.\n\nTHE OUTPUT FOR EACH LMOD STARTS WITH A LINE OF HYPHENS.  THE FIRST\nLINE BELOW THAT DETAILS THE LMOD INFO, INCLUDING SOME LKED\nATTRIBUTES.  BELOW THAT ARE LINES FOR EACH CSECT IN THE LMOD, MARKED\nBY CS-(NAME) FOR EACH CSECT.  WHERE POSSIBLE, COBOL COMPILER OPTIONS\nTHAT WERE IN EFFECT FOR THE CSECT ARE DETAILED.  THE VARIOUS\nCOMPILERS THAT ARE NOW RECOGNIZED ARE ANS4, OS/VS (LISTED AS VSR1)\nAND COBOL II (LISTED AS C2)\n\nTHE PAN STAMP IS AN IN-HOUSE REQUIREMENT, SO THAT WE CAN MATCH\nSOURCE WITH LMOD CODE.  SINCE SOMEONE ELSE MIGHT BE USING THE SAME\nMECHANISM, I'VE LEFT THAT CODE INTACT.\n\nTHIS IS A REPORT PROGRAM ONLY AND THEREFORE NEEDS ONLY READ ACCESS\nTO ANY LOADLIB IT PROCESSES.\n\nUSE AS YOU SEE FIT; BUT I'D APPRECIATE HAVING ANY MODS SENT BACK TO\nME, TO INCORPORATE IN LATER VERSIONS AS NEEDED.\n\nMY FULL IDENTIFICATION, AND E-MAIL ADDRESS, ARE IN THE COMMENTS AT\nTHE BEGINNING OF THE SOURCE CODE.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DSW": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\t\\x0f\\x00\\x86\\t\\x0f\\x13P\\x007\\x007\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-03-31T00:00:00", "modifydate": "1986-03-31T13:50:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "CHSY227"}, "text": "         MACRO\n&LABEL   $DSW  &B80,&B40,&B20,&B10,&B08,&B04,&B02,&B01,&TYPE=,&INIT=\n.*\n.*       DATA SWITCH GENERATION MACRO\n.*\n         GBLC  &DSWBYTE(80)        DATA SWITCH BYTE NAME ARRAY.\n         GBLC  &DSWBIT(640)        DATA SWITCH BIT NAME ARRAY.\n         LCLA  &X\n         LCLC  &C\n.DSW5    AIF   (&X EQ 80).DSWERR\n&X       SETA  &X+1\n         AIF   ('&DSWBYTE(&X)' NE '').DSW5\n&C       SETC  'DSW&SYSNDX.A'\n         AIF   (K'&LABEL EQ 0).NOLABEL\n&C       SETC  '&LABEL'\n.NOLABEL ANOP\n         AIF   ('&TYPE' EQ 'NODATA').NODATA\n         AIF   (K'&INIT EQ 0).NOINIT\n&C       DC    &INIT               .INITIALIZED SWITCH VARIABLE.\n         AGO   .ENDINIT\n.NOINIT  ANOP\n&C       DS    B                   .SWITCH VARIABLE.\n.ENDINIT ANOP\n.NODATA  ANOP\n&DSWBYTE(&X) SETC '&C'             SAVE SWITCH VARIABLE NAME.\n&X       SETA  (&X-1)*8            GET CORRESPONDING BIT SWITCH GROUP.\n         AIF   ('&B80' EQ '').DSW10\n&B80     EQU   B'10000000'\n&DSWBIT(&X+1) SETC '&B80'\n.DSW10   AIF   ('&B40' EQ '').DSW20\n&B40     EQU   B'01000000'\n&DSWBIT(&X+2) SETC '&B40'\n.DSW20   AIF   ('&B20' EQ '').DSW30\n&B20     EQU   B'00100000'\n&DSWBIT(&X+3) SETC '&B20'\n.DSW30   AIF   ('&B10' EQ '').DSW40\n&B10     EQU   B'00010000'\n&DSWBIT(&X+4) SETC '&B10'\n.DSW40   AIF   ('&B08' EQ '').DSW50\n&B08     EQU   B'00001000'\n&DSWBIT(&X+5) SETC '&B08'\n.DSW50   AIF   ('&B04' EQ '').DSW60\n&B04     EQU   B'00000100'\n&DSWBIT(&X+6) SETC '&B04'\n.DSW60   AIF   ('&B02' EQ '').DSW70\n&B02     EQU   B'00000010'\n&DSWBIT(&X+7) SETC '&B02'\n.DSW70   AIF   ('&B01' EQ '').DSW80\n&B01     EQU   B'00000001'\n&DSWBIT(&X+8) SETC '&B01'\n.DSW80   MEXIT\n.*\n.*\n.DSWERR  MNOTE 0,'** ERROR ** MAX NUMBER OF SWITCHES EXCEEDED'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#SEG": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x89)?\\x00\\x892\\x1f\\x16\\x05\\x005\\x002\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1989-10-20T00:00:00", "modifydate": "1989-11-17T16:05:00", "lines": 53, "newlines": 50, "modlines": 0, "user": "CHSY227"}, "text": "         MACRO\n&L       #SEG  &DEST,&STR,&LEN,&NOFIT=\n.*********************************************************************\n.*\n.*       #SEG\n.*\n.*       STR --DEFINES THE STRING WHICH IS MOVED INTO THE BUFFER.\n.*       LEN --LENGTH OF INPUT STRING.\n.*       DEST--DESTINATION OF STRING.  THIS FIELD IS A VARIABLE\n.*             LENGTH STRING WITH A FULLWORD CONTAINING A HALFWORD\n.*             FOR CURRENT LENGTH AND MAXIMUM LENGTH.\n.*\n.*********************************************************************\n         LCLC  &LBL\n         LCLA  &LN                 LENGTH OF VARIABLE/STRING.\n         LCLC  &LENSYM             SYMBOL FOR LENGTH OF VARIABLE.\n&LBL     SETC  '&L'\n         AIF   ('&LBL' EQ '').NOLBL\n&L       DS    0H\n.NOLBL   ANOP\n         AIF   (T'&STR NE 'O').OKSTR\n         MNOTE 8,'SEG100E STRING NOT SPECIFIED'\n         MEXIT\n.OKSTR   ANOP\n         SR    0,0\n         LA    0,&STR              POINT TO STRING.\n         AIF   (T'&LEN EQ 'O').NOLEN\n         LA    1,&LEN              LOAD LENGTH INTO R1\n         AGO   .DEST\n.NOLEN   ANOP\n         AIF   ('&STR'(1,1) EQ '''').STR\n&LENSYM  SETC  'L'''               SETUP THE LENGTH ATTRIBUTE.\n         LA    1,&LENSYM&STR       USE VARIABLE DEFINED LENGTH.\n         AGO   .DEST\n.STR     ANOP\n&LN      SETA  K'&STR-2            COMPUTE STRING LENGTH.\n         LA    1,&LN               LOAD LENGTH INTO R0.\n.DEST    ANOP\n         SR    14,14\n         LA    14,&DEST            VARIABLE STRING FIELD.\n         LA    15,0                FOR LENGTH COMPUTATIONS\n         LH    15,0(,14)           LOAD CURRENT LENGTH\n         AR    15,1                ADD NEW LENGTH\n         AIF   ('&NOFIT' EQ '').NOCHK\n         CH    15,2(,14)           LONGER THAN MAX LENGTH ??\n         BH    &NOFIT              YES; ERROR EXIT\n.NOCHK   ANOP\n         STH   15,0(,14)\n         SR    15,1\n         LA    14,4(15,14)         POINT TO NEXT BYTE\n         LR    15,1                COPY LENGTH TO MOVE\n         MVCL  14,0                AND INSERT THE STRING\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#XA": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x14?\\x00\\x91\\x14?\\x08\\x13\\x001\\x001\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-05-23T00:00:00", "modifydate": "1991-05-23T08:13:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "CHSY227"}, "text": "         MACRO\n&L       #XA   &OP,&R=R1\n.* XA ADDRESSING MODE UTILITY\n         AIF   (T'&L EQ 'O').NOL\n&L       DS    0H\n.NOL     ANOP\n         AIF   ('&OP' EQ 'SET31').SET31 GO INTO 31 BIT MODE\n         AIF   ('&OP' EQ 'SET24').SET24 GO INTO 24 BIT MODE\n         AIF   ('&OP' EQ 'SETV').SETV   GO INTO MODE PER BIT 0 &R\n         AIF   ('&OP' EQ 'VER31').VER31 ABEND IF NOT IN 31 BIT MODE\n         AIF   ('&OP' EQ 'VER24').VER24 ABEND IF NOT IN 24 BIT MODE\n         AIF   ('&OP' EQ 'MODE').MODE   DETERMINE MODE, SET BIT 0 &R\n         MNOTE 8,'XA MACRO - BAD OP: &OP'\n         MEXIT\n.SET31   ANOP\n         L     &R,XA&SYSNDX\n         BSM   0,&R\nXA&SYSNDX DC   A(*+4+X'80000000')\n         MEXIT\n.SET24   ANOP\n         L     &R,XA&SYSNDX\n         BSM   0,&R\nXA&SYSNDX DC   A(*+4)\n         MEXIT\n.SETV    ANOP\n         N     &R,=X'80000000'\n         O     &R,XA&SYSNDX\n         BSM   0,&R\nXA&SYSNDX DC   A(*+4)\n         MEXIT\n.VER24   ANOP\n         SR    &R,&R               ZERO BITS 1-31\n         BSM   &R,0                SET BIT 0\n         LTR   &R,&R\n         BZ    XA&SYSNDX+2\nXA&SYSNDX DC   H'0'                ABEND - NOT IN EXPECTED MODE\n         MEXIT\n.VER31   ANOP\n         SR    &R,&R               ZERO BITS 1-31\n         BSM   &R,0                SET BIT 0\n         LTR   &R,&R\n         BNZ   XA&SYSNDX+2\nXA&SYSNDX DC   H'0'                ABEND - NOT IN EXPECTED MODE\n         MEXIT\n.MODE    ANOP\nXA&SYSNDX DS   0S(XA&SYSNDX)       FOR XREF\n         SR    &R,&R               ZERO BITS 1-31\n         BSM   &R,0                SET BIT 0\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE347": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04[\\x00\\x05\\x01\\x16\\x18o\\x01\\x16\\x18o\\x14\"\\x00*\\x00*\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf1@@@'", "ispf": {"version": "04.91", "flags": 0, "createdate": "2016-07-04T00:00:00", "modifydate": "2016-07-04T14:22:05", "lines": 42, "newlines": 42, "modlines": 0, "user": "CBT-491"}, "text": "//***FILE 347 IS THE MODLIST PROGRAM FROM RICK FOCHTMAN OF          *   FILE 347\n//*           CHICAGO, ILLINOIS.  THIS PROGRAM LOOKS AT A LOAD      *   FILE 347\n//*           LIBRARY, AND TELLS YOU WHICH COMPILE-LINKEDIT         *   FILE 347\n//*           OPTIONS ANY COBOL MODULES WERE CREATED WITH.          *   FILE 347\n//*                                                                 *   FILE 347\n//*           email:   sbgolob@cbttape.org     or                   *   FILE 347\n//*                    sbgolob@attglobal.net                        *   FILE 347\n//*                                                                 *   FILE 347\n//*     Note:  This program needs fixing.  For now, try using       *   FILE 347\n//*            COBANAL from CBT File 321.   (S.G)                   *   FILE 347\n//*                                                                 *   FILE 347\n//*     THE MODLIST PROGRAM WAS DEVELOPED AS A STOP-GAP MEASURE,    *   FILE 347\n//*     TO TRY AND KEEP A HANDLE ON OUR OS/VS COBOL TO COBOL II     *   FILE 347\n//*     CONVERSION PROJECT.  THE ONLY KNOWN BUG LEFT IS IN          *   FILE 347\n//*     DEALING WITH MODULES THAT MAY LOAD ABOVE THE 16M LINE.      *   FILE 347\n//*     SOMETIMES THEY WORK OK; SOMETIMES NOT.                      *   FILE 347\n//*                                                                 *   FILE 347\n//*     THE OUTPUT FOR EACH LMOD STARTS WITH A LINE OF HYPHENS.     *   FILE 347\n//*     THE FIRST LINE BELOW THAT DETAILS THE LMOD INFO,            *   FILE 347\n//*     INCLUDING SOME LKED ATTRIBUTES.  BELOW THAT ARE LINES       *   FILE 347\n//*     FOR EACH CSECT IN THE LMOD, MARKED BY CS-(NAME) FOR         *   FILE 347\n//*     EACH CSECT.  WHERE POSSIBLE, COBOL COMPILER OPTIONS         *   FILE 347\n//*     THAT WERE IN EFFECT FOR THE CSECT ARE DETAILED.  THE        *   FILE 347\n//*     VARIOUS COMPILERS THAT ARE NOW RECOGNIZED ARE ANS4,         *   FILE 347\n//*     OS/VS (LISTED AS VSR1) AND COBOL II (LISTED AS C2)          *   FILE 347\n//*                                                                 *   FILE 347\n//*     THE PAN STAMP IS AN IN-HOUSE REQUIREMENT, SO THAT WE        *   FILE 347\n//*     CAN MATCH SOURCE WITH LMOD CODE.  SINCE SOMEONE ELSE        *   FILE 347\n//*     MIGHT BE USING THE SAME MECHANISM, I'VE LEFT THAT CODE      *   FILE 347\n//*     INTACT.                                                     *   FILE 347\n//*                                                                 *   FILE 347\n//*     THIS IS A REPORT PROGRAM ONLY AND THEREFORE NEEDS ONLY      *   FILE 347\n//*     READ ACCESS TO ANY LOADLIB IT PROCESSES.                    *   FILE 347\n//*                                                                 *   FILE 347\n//*     USE AS YOU SEE FIT; BUT I'D APPRECIATE HAVING ANY MODS      *   FILE 347\n//*     SENT BACK TO ME, TO INCORPORATE IN LATER VERSIONS AS        *   FILE 347\n//*     NEEDED.                                                     *   FILE 347\n//*                                                                 *   FILE 347\n//*     Please address any requests for help or send any            *   FILE 347\n//*     modifications or suggestions to Sam Golob, email address    *   FILE 347\n//*     above.                                                      *   FILE 347\n//*                                                                 *   FILE 347\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FINDSW": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x843/\\x00\\x843/\\x12I\\x00r\\x00r\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1984-11-27T00:00:00", "modifydate": "1984-11-27T12:49:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "CHSY227"}, "text": "         MACRO\n         FINDSW &A\n.*\n.*INPUT:       &A - SWITCH NAME(S).\n.*\n.*PROCESS:     1) '&ERROR' IS INITIALIZED TO 0 (NORMAL RETURN).\n.*             2) THE SWITCH NAME(S) IS/ARE TRANSFERRED TO THE\n.*                '&BIT' ARRAY ONE BITNAME PER ELEMENT.\n.*             3) BIT SWITCH TABLE '&DSWBIT' IS SCANNED TO LOCATE THE\n.*                BYTENAME '&DSWBYTE' ASSOCIATED WITH EACH BIT.\n.*             4) IF FOUND, THE BYTENAME IS SAVED IN '&RPMSW' AND A\n.*                      BYTE TEST EXPRESSION IS BUILT IN '&RPMSWT'.\n.*                IF NOT FOUND, THE SWITCH NAME IS ASSUMED TO BE THE\n.*                      BYTE NAME ITSELF.\n.*                   A. BYTE SWITCH TABLE '&DSWBYTE' IS SCANNED FOR A\n.*                      MATCH.\n.*                      IF FOUND, THE BYTENAME IS SAVED IN '&RPMSW'\n.*                         AND A BYTE TEST EXPRESSION IS SAVED IN\n.*                         '&RPMSWT'.\n.*                   B. IF NOT FOUND, '&ERROR' IS SET TO 1 (ABNORMAL\n.*                      RETURN) AND AN MNOTE MESSAGE IS PRODUCED.\n.*             5) PROCESSING CONTINUES UNTIL ALL BITNAMES IN '&A' ARE\n.*                PROCESSED.\n.*\n.*OUTPUT:      &ERROR - 0  BIT(S) FOUND.\n.*                    - 1  BIT(S) NOT FOUND (MNOTE ALSO PRODUCED).\n.*             &RPMSW - BYTE NAME.\n.*             &RPMSWT- BYTE TEST EXPRESSION.\n.*\n.*\n.*NOTE - ALL BITNAMES FOR A GIVEN INVOCATION OF 'FINDSW' ARE ASSUMED\n.*       TO REFER TO THE SAME BYTE NAME.\n.*\n.*WRITTEN:     5/1/75 AT RUSH PRES ST. LUKES MEDICAL CENTER.  JMY\n.*             S/370-145 OS/VS1 REL 2.6\n.*----------------------------------------------------------------\n         GBLB  &ERROR              ERROR FLAG.\n         GBLC  &DSWBYTE(30)        DATA SWITCH BYTE NAME ARRAY.\n         GBLC  &DSWBIT(240)        DATA SWITCH BIT NAME ARRAY.\n         GBLC  &RPMSW              SWITCH BYTE NAME.\n         GBLC  &RPMSWT          BYTE TEST EXPRESSION.\n.*\n         LCLA  &X,&N               COUNTERS.\n         LCLC  &BIT(8)             ISOLATED BIT NAMES.\n         LCLC  &C                  CHARACTER ACCUMULATOR.\n.*\n.*\n.*       1) INITIALIZE ERROR SWITCH\n.*\n&ERROR   SETB  0                   INIT RETURN CODE TO NORMAL RETURN.\n.*\n.*       2) ISOLATE AND TRANSFER BIT NAME(S) TO BIT ARRAY\n.*\n&BIT(1)  SETC  '&A'                FIRST BIT NAME.\n&N       SETA  1                   FIRST BIT NAME.\n         AIF   ('&A'(K'&A,1) NE ')').FINDSW0 BR IF ONLY ONE NAME.\n&N       SETA  0                   RE-INIT NUMBER OF BIT NAMES FOUND.\n&X       SETA  1                   INITIALIZE CHAR SCAN INDEX.\n.NEXTBIT ANOP                      PROCESS A BITNAME.\n&N       SETA  &N+1                COUNT NUMBER OF BITNAMES FOUND.\n&BIT(&N) SETC  ''                  INITIALIZE BIT NAME ELEMENT.\n.NXTCHAR ANOP                      PROCESS A BITNAME CHARACTER.\n&X       SETA  &X+1                INCREMENT SCAN INDEX.\n&C       SETC  '&A'(&X,1)\n         AIF   ('&C' EQ ',').NEXTBIT  BR IF BITNAME TERMINATOR FOUND.\n         AIF   ('&C' EQ ')').FINDSW0 BR BITNAME LIST TERMINATOR.\n&BIT(&N) SETC  '&BIT(&N)&C'        ADD A CHARACTER TO BITNAME.\n         AGO   .NXTCHAR\n.*\n.*       3,4) LOCATE/SAVE BYTE NAME AND BUILD BYTE TEST EXPRESSION\n.*\n.FINDSW0 ANOP\n&RPMSWT  SETC  ''                  INITIALIZE BYTE TEST EXPRESSION.\n.NEXTSUB ANOP\n&X       SETA  0\n.FINDSW1 AIF   (&X EQ 240).FINDSW2  BR IF BITNAME UNDEFINED.\n&X       SETA  &X+1\n         AIF   ('&DSWBIT(&X)' NE '&BIT(&N)').FINDSW1\n&RPMSW   SETC  '&DSWBYTE((&X-1)/8+1)'  SAVE BYTENAME.\n&RPMSWT  SETC  '&RPMSWT&BIT(&N)+'   ADD TO BYTE TEST EXPRESSION.\n.NEXT    ANOP\n&N       SETA  &N-1\n         AIF   (&N NE 0).NEXTSUB\n         AIF   ('&RPMSWT' EQ '').EXIT\n&RPMSWT  SETC  '&RPMSWT'(1,K'&RPMSWT-1)\n.EXIT    MEXIT\n.*\n.*       4A) LOCATE/SAVE BYTENAME AND BUILD BYTE TEST EXPRESSION\n.*\n.FINDSW2 ANOP\n&X       SETA  0\n.NXTBYTE AIF   (&X EQ 30).ERROR1\n&X       SETA  &X+1\n         AIF   ('&DSWBYTE(&X)' NE '&BIT(&N)').NXTBYTE\n         AIF   ('&RPMSWT' NE '').ERROR2\n&RPMSW   SETC  '&DSWBYTE(&X)'      SAVE BYTE NAME.\n&RPMSWT  SETC  'X''FF'''           SET BYTE TEST EXPRESSION.\n&N      SETA   &N-1\n         AIF   (&N GT 0).ERROR2    BR IF SYNTAX ERROR.\n         MEXIT\n.*\n.*       4B) SWITCH NAME NOT DEFINED\n.*\n.ERROR1  MNOTE 8,'** ERROR ** SWITCH ''&BIT(&N)'' NOT DEFINED'\n&ERROR   SETB  1                   SET ABNORMAL RETURN.\n         AGO   .NEXT\n.*\n.*\n.ERROR2  MNOTE 8,'** ERROR ** MULTIPLE BYTE SWITCH NAMES NOT ALLOWED,'\n         MNOTE *,'            ''&BIT(&N)'' IGNORED.'\n&N       SETA  &N-1\n         AIF   (&N NE 0).ERROR2\n&ERROR   SETB  1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXCNVT": {"ttr": 533, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x83\\x19\\x9f\\x00\\x910\\x8f\\x08\\x17\\x00\\xb4\\x00\\xb4\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1983-07-18T00:00:00", "modifydate": "1991-11-04T08:17:00", "lines": 180, "newlines": 180, "modlines": 0, "user": "CHSY227"}, "text": "         MACRO\n&NAME    HEXCNVT &OUT,&IN,&LN\n         GBLC  &HEXSECT,&HEXTAB,&HEXWRD\n         LCLA  &A,&B,&C,&D,&E,&F,&G\n         LCLB  &REGSW,&RLNSW,&DFALTSW\n         LCLB  &HEXSW\n         LCLC  &GNAME\n&GNAME   SETC  'HEX'.'&SYSNDX'\n&DFALTSW SETB  (T'&LN EQ 'O')\n         AIF   (&DFALTSW EQ 1).NEXT2\n&RLNSW   SETB  ('&LN'(1,1) EQ '(')\n.NEXT2   AIF   ('&OUT' EQ '' OR '&IN' EQ '').ERROR2\n&REGSW   SETB  ('&OUT'(1,1) EQ '(')\n         AIF   (&DFALTSW EQ 0 AND T'&LN NE 'N').ERROR4\n         AIF   (&DFALTSW EQ 1).NEXT3\n         AIF   (N'&LN NE 1).ERROR5\n.NEXT3   AIF   (&RLNSW EQ 1 AND T'&LN(1) NE 'N').ERROR4\n         AIF   (&DFALTSW EQ 1).NEXT4\n         AIF   (&RLNSW EQ 1 AND (&LN(1) LT 2)).ERROR3\n         AIF   (&RLNSW EQ 0 AND T'&LN(1) NE 'N').ERROR4\n         AIF   (&RLNSW EQ 1).NEXT4\n         AIF   (&LN LT 1 OR &LN GT 112).ERROR6 LN MUST BE FROM 1-112\n.NEXT4   AIF   (&REGSW EQ 0).NEXT9\n         AIF   ('&IN'(1,1) NE '(').ERROR1 &IN MUST ALSO BE A REG\n         AIF   (T'&OUT NE 'N').ERROR4\n         AIF   (N'&OUT GT 1).ERROR3\n         AIF   (&OUT(1) LE 1).ERROR3\n         AIF   (T'&IN NE 'N').ERROR4\n         AIF   (N'&IN GT 1).ERROR3\n         AIF   (&IN(1) LE 1).ERROR3\n         AGO   .NEXT5\n.NEXT9   AIF   ('&IN'(1,1) EQ '(').ERROR1\n         AIF   (T'&OUT EQ 'N' OR T'&IN EQ 'N').ERROR4\n.NEXT5   ANOP\n&HEXSW   SETB  ('&HEXSECT' EQ '&SYSECT')\n         AIF   (&HEXSW EQ 1).NEXT6\n&HEXSECT SETC  '&SYSECT'\n&HEXWRD  SETC  '&GNAME'\n&HEXTAB  SETC  '&GNAME.A'\n.NEXT6   ANOP\n         AIF   (&DFALTSW EQ 1).DFALT\n         AIF   (&RLNSW EQ 1).REGLN\n         AIF   (&LN GT 7).MULTI\n&A       SETA  &LN*2+1             LENGTH FOR R1 OF UNPK\n&B       SETA  &LN+1               LENGTH FOR R2 OF UNPK\n.CONTA   AIF   (&REGSW EQ 1).ISAREG\n&NAME    UNPK  &OUT.(&A),&IN.(&B)  UNPACK HEX DIGITS\n&A       SETA &A-1\n         MVI   &OUT+&A,X'40'       CLEAR SIGN BYTE\n.CONTB   L     1,&GNAME.B          SET ORIGIN OF TABLE\n         S     1,0(1)              BACK 240 BYTES\n         AIF   (&RLNSW EQ 1).CONTG\n         AIF   (&REGSW EQ 1).CONTD\n         TR    &OUT.(&A),0(1)      TRANSLATE FA-FF\n.CONTC   B     &GNAME.H            BR AROUND CONSTANTS\n         AIF   (&HEXSW EQ 1).ENDD  DON'T GENERATE TABLE IF SW ON\n         AGO   .ENDC\n.ISAREG  ANOP\n&NAME    UNPK  0(&A,&OUT(1)),0(&B,&IN(1)) UNPACK HEX DIGITS\n&A       SETA  &A-1\n         MVI   &A.(&OUT(1)),X'40'  CLEAR SIGN BYTE\n         AGO   .CONTB              SET REG 1 FOR TR\n.CONTD   TR    0(&A,&OUT(1)),0(1)  TRANSLATE FA-FF\n         AGO   .CONTC\n.DFALT   ANOP\n&A       SETA  9                   DFAULT TO 4 BYTES\n&B       SETA  5\n         AGO   .CONTA\n.MULTI   ANOP\n&C       SETA  (&LN/4)             TO UNPACK 4 AT A TIME\n&D       SETA  &LN-&C*4            REMAINDER\n&A       SETA  9\n&B       SETA  5\n         AIF   (&REGSW EQ 0).MULTIB\n&E       SETA  &OUT(1)\n&F       SETA  &IN(1)\n&G       SETA  1\n&NAME    LA    &G,&C               SET COUNT\n.MULTIA  ANOP\n&GNAME.E UNPK  0(&A,&E),0(&B,&F)   UNPACK HEX DIGITS\n&A       SETA  &A-1\n         MVI   &A.(&E),X'EF'       CLEAR SIGN BYTE\n         LA    &E,9(&E)            INCREMENT ADDRESSES\n         LA    &F,4(&F)\n         BCT   &G,&GNAME.E         LOOP\n         AIF   (&D EQ 0).CONTH     NO REMAINDER\n&A       SETA  &D*2+1\n&B       SETA  &D+1\n         UNPK  0(&A,&E),0(&B,&F)   UNPACK HEX DIGITS\n&A       SETA  &A-1\n         MVI   &A.(&E),X'40'       CLEAR SIGN BYTE\n.CONTH   ANOP\n&C       SETA  &C+&LN*2\n&G       SETA  &C+&D*2             LENGTH OF FIELD TO BE TRANSLATED\n         LA    1,&C                RE-ESTABLISH BEGINING\n         SR    &E,1                OF FIELD\n         L     1,&GNAME.B          SET ORIGIN OF TABLE\n         S     1,0(1)              BACK 240 BYTES\n         TR    0(&G,&E),0(1)       TRANSLATE FA-FF\n         AGO   .CONTC\n.MULTIB  ANOP\n&NAME    LA    2,&OUT\n         LA    1,&IN\n         LA    3,&C                SET COUNT\n&E       SETA  2\n&F       SETA  1\n&G       SETA  3\n         AGO   .MULTIA\n.REGLN   ANOP\n         AIF   (&REGSW EQ 0).CONTI\n&E       SETA  &OUT(1)\n&F       SETA  &IN(1)\n         AGO   .CONTJ\n.CONTI   ANOP\n&E       SETA  2\n&F       SETA  3\n&NAME    LA    2,&OUT\n         LA    3,&IN\n         LR    1,&LN(1)\n         AGO   .CONTK\n.CONTJ   ANOP\n&NAME    LTR   1,&LN(1)            LOAD LN TO REG 1 AND TEST\n         BZ    &GNAME.H            DO NOTHING IF ZERO\n.CONTK   LA    0,3                 SET UP MASK\n         NR    0,1                 AND SAVE 2 LOW ORDER BITS\n         SRL   1,2                 DIVIDE BY 4\n         LTR   1,1                 LENGTH LESS THAN 4\n         BZ    &GNAME.F            IF YES--BRANCH\n&GNAME.E UNPK  0(9,&E),0(5,&F)     UNPACK HEX DIGITS\n         MVI   8(&E),X'EF'         CLEAR SIGN BYTE\n         LA    &E,9(&E)            INCREMENT REGS\n         LA    &F,4(&F)\n         BCT   1,&GNAME.E          LOOP\n&GNAME.F LTR   0,0\n         BZ    &GNAME.G            BRANCH IF SAVED BITS ARE 0\n         LR    1,0                 ADJUST REG 1\n         AR    1,0                 FOR EXECUTE INSTRUCTION\n         SLL   1,4\n         OR    1,0\n         EX    1,&GNAME.C          EXECUTE UNPK\n         SRL   1,4\n         AR    &E,1\n         MVI   0(&E),X'40'         CLEAR SIGN BYTE\n&GNAME.G LR    1,&LN(1)\n         SRL   1,2                 DIVIDE BY 4\n         AR    &LN(1),&LN(1)       SET UP LENGTH FOR\n         AR    &LN(1),1            TRANSLATE INSTRUCTION\n         SR    &E,&LN(1)           RE-ESTABLISH BEGINING OF FIELD\n         AGO   .CONTB              SET REG 1 FOR TR\n.CONTG   BCTR  &LN(1),0            DECR LN 1 FOR EXECUTE INST\n         EX    &LN(1),&GNAME.D     EXECUTE TR\n         B     &GNAME.H            BRANCH AROUND CONSTANTS\n         AGO   .ENDA\n.ERROR1  MNOTE 12,'INCONSISTANT PARAMETERS'\n         MEXIT\n.ERROR2  MNOTE 12,'PARAMETER MISSING'\n         MEXIT\n.ERROR3  MNOTE 12,'REG PARMS CANNOT BE 0 OR 1 '\n         MEXIT\n.ERROR4  MNOTE 12,'INVALID TYPE ATTRIBUTE SPECIFIED IN PARAMETERS'\n         MEXIT\n.ERROR5  MNOTE 12,'&LN--MULTIPLE PARAMETERS INVALID'\n         MEXIT\n.ERROR6  MNOTE 12,'&LN INVALID--MUST BE FROM 1-112'\n         MEXIT\n.ENDA    ANOP\n&GNAME.C UNPK  0(0,&E),0(0,&F)     UNPACK HEX DIGITS\n&GNAME.D TR    0(0,&E),0(1)        TRANSLATE FA-FF\n         AIF   (&HEXSW EQ 0).ENDC\n.ENDD    ANOP\n&GNAME.B DC    A(&HEXWRD)\n         AGO   .ENDB\n.ENDC    ANOP\n&GNAME.B DC    A(&HEXWRD)\n&GNAME   DC    F'234'\n         DC    C'  '\n&GNAME.A DC    C'0123456789ABCDEF'\n.ENDB    ANOP\n&GNAME.H DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IF": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94)/\\x00\\x94)/\\x10\\t\\x04\\x11\\x04\\x11\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-10-19T00:00:00", "modifydate": "1994-10-19T10:09:00", "lines": 1041, "newlines": 1041, "modlines": 0, "user": "CHSY227"}, "text": "         MACRO\n&NAME    IF    &GOTO=,&NOTGOTO=\n.*\n.*       CONDITIONAL BRANCH MACRO\n.*\n.*       IF    A,OP<,B><,OR/AND>...\n.*             OP - UNARY OR BINARY OPERATOR\n.*\n.*       NOTGOTO= KEYWORD USED BY DOWHILE MACRO\n.*       IT SPECIFIES BRANCH ADRS TO BE TAKEN IF COND. FALSE\n.*       ADRS SPECIFIED BY NOTGOTO CAN ONLY BE INSTRUCTION LABEL\n         GBLB  &ERROR              INNER MACRO ERROR CODE.\n         GBLC  &RPMSW              DATA SWITCH BYTE NAME.\n         GBLC  &RPMSWT          DATA SWITCH BYTE TEST EXPR.\n         GBLC  &DONAME(9)          LABELS FOR DO GROUPS 9 LEVELS DEEP.\n         GBLC  &EIFNAME(9)         ENDIF LABEL.\n         GBLA  &PGMNEST            CURRENT PGM BLOCK NEST LEVEL.\n         GBLC  &PGMBTYP(9)         BLOCK TYPE(IF,CASE,WHILE, OR DO).\n         GBLC  &DOEND(9)           'ENDDO' BRANCH LABEL.\n         GBLA  &DOLVL              DO-BLOCK NEST LEVEL.\n         GBLA  &DONEST             CURRENT DO GROUP NEST LEVEL.\n         GBLA  &VERIFYV\n         GBLA  &NCBQTS,&TPLITRL\n         GBLA  &RPDECTP            EXTERNAL DATA REQUIREMENTS FLAG\n         GBLA  &RPMUSER            EXTERNAL DATA REQUIREMENTS FLAG\n         GBLA  &BLKTAB,&NBLKTAB    EXT. DATA REQ. FLAGS\n         GBLC  &SWQUOTE            USED BY FIXQUOTE INNER MACRO\n         GBLA  &MACLEV,&KEYV\n         GBLC  &CASEND(9)\n         GBLA  &CASELVL\n         GBLA  &WHLNEST            NEST LEVEL FOR DOWHILE MACRO\n         GBLC  &WHLOUT(9)             LABEL FOR BRANCH TO JUST PAST\n.*             ENDWHILE MACRO\n         GBLB  &SDOCASE  1 - IF CALLED BY SECONDARY DOCASE CONDITIONS\n         GBLC  &OLDR14,&OLDDCTP\n         LCLB  &AREG,&CREG         REGISTER FORMAT FLAGS FOR A AND C.\n         LCLC  &AA,&OPCD,&NOPCD,&OPND,&GOR,&AR\n         LCLC  &CC,&CR\n         LCLC  &B\n         LCLC  &GO\n         LCLC  &TA,&TC\n         LCLA  &L\n         LCLA  &CNUMB              0 - &C NOT #\n.*                                 1 - &C |#| < 32768\n.*                                 2 - &C |#| > 32767\n         LCLC  &CLM,&CLMM\n         LCLC  &LABEL\n         LCLA  &K,&I\n         LCLC  &Q\n         LCLA  &CABSNUM\n         LCLC  &TEMPV\n         LCLC  &TEMP\n         LCLA  &LA,&LC\n         LCLC  &TMPOPCD            TEMPOARARY FOR OP CODE SWAP\n         LCLA  &IP                 WHICH POSITIONAL PARM BEING USED\n         LCLA  &NUMARG\n         LCLA  &V\n         LCLB  &AND,&OR\n         LCLC  &LAB,&LABSAVE,&BCD,&BOPND\n         LCLB  &OREVER             SET TO 1 IF OR EVER HIT\n         LCLC  &ORBNCH             ADRS FOR BRANCHING WHEN OR TRUE\n         LCLC  &ANDBNCH            ADRS FOR BRANCHING WHEN AND FALSE IN\n.*                                 LAST AND CHAIN\n         LCLA  &BOLANDC            BEGINNING OF LAST AND CHAIN IF LAST\n         LCLB  &R14FLD,&DCTPFLD,&R14CHG,&DCTPCHG\n         LCLC  &WTAB               NAME OF TRT TABLE\n         SPACE 1\n&MACLEV  SETA  &MACLEV+1\n&GO      SETC  '&GOTO'\n&LABEL   SETC  '&NAME'\n&IP      SETA  1\n&NUMARG  SETA  N'&SYSLIST\n.*       IF 'IF' HAS NOT BE CALLED BY DOCASE FOR SECONDARY CONDITIONS\n.*       THEN SET OLDR14 AND OLDDCTP TO NULL STRINGS.\n.*       THIS WILL FORCE RELOADING OF R14 AND/OR CWADECTP INTIAL\n.*       TIME THRU, IF NECESSARY.\n         AIF   (&SDOCASE).NOVCLR\n&OLDR14  SETC  ''\n&OLDDCTP SETC  ''\n.NOVCLR  ANOP\n&L       SETA  K'&GO\n         AIF   (&L GT 0 OR T'&NOTGOTO NE 'O').PROCGO1\n&TA      SETC  '&SYSLIST(&NUMARG)'\n         AIF   (K'&TA LT 5).NOLEAVE\n         AIF   ('&TA'(1,5) NE 'LEAVE').NOLEAVE\n         AIF   (K'&TA LT 9).BADLFOR\n         AIF   ('&TA'(6,1) EQ '(' AND '&TA'(K'&TA,1) EQ ')').LEAVE\n.BADLFOR MNOTE 8,'** ERROR**, INVALID LEAVE FORMAT.'\n         AGO   .EXIT\n.LEAVE   ANOP\n         AIF   (K'&TA LE 7).BADLFOR\n         AIF   (&PGMNEST GE 1).CHEKBLK\n         MNOTE 8,'** ERROR **, NOT IN BLOCK; LEAVE UNDEFINED.'\n         AGO   .EXIT\n.CHEKBLK ANOP\n&TA      SETC  '&TA'(7,K'&TA-7)\n        MKEYWORD &TA,KEYS=(IF,CASE,WHILE,DO)\n         AIF   (&KEYV GT 0).BTYPOK1\n.BADBLK  MNOTE 8,'** ERROR **, INVALID BLOCK TYPE OF ''&TA'' SPECIFIED *\n               FOR LEAVE OPTION.'\n         AGO   .EXIT\n.BTYPOK1 AIF   ('&TA' EQ '&PGMBTYP(&PGMNEST)').BTYPOK2\n    MNOTE 8,'** ERROR **, ATTEMPT TO LEAVE OTHER THAN CURRENT BLOCK.'\n         AGO   .EXIT\n.BTYPOK2 ANOP\n&NUMARG  SETA  &NUMARG-1        MAKE LEAVE(EFFECTIVELY) NOT BE THERE.\n         AIF   (&KEYV NE 1).NOTIF\n&GO      SETC  '&EIFNAME(&DONEST)'\n         AGO   .PROCGO1\n.NOTIF   AIF   (&KEYV NE 2).NOTCASE\n&GO      SETC  '&CASEND(&CASELVL)'\n         AGO   .PROCGO1\n.NOTCASE AIF   (&KEYV NE 3).NOTWHIL\n&GO      SETC  '&WHLOUT(&WHLNEST)'\n         AGO   .PROCGO1\n.NOTWHIL AIF   (&KEYV NE 4).BADBLK\n&GO      SETC  '&DOEND(&DOLVL)'\n         AGO   .PROCGO1\n.NOLEAVE ANOP\n&DONEST  SETA  &DONEST+1           INCREMENT NESTING LEVEL\n&DONAME(&DONEST) SETC 'RPM&SYSNDX.A' CREATE LABEL FOR FALSE CONDITION\n&EIFNAME(&DONEST) SETC 'RPM&SYSNDX.C' CREATE LABEL FOR ENDIF MACRO.\n         AGO   .RELOCGO\n.PROCGO1 ANOP\n&OPND    SETC  '&GO'\n         AIF   (&L LT 3).RELOCGO\n         AIF   ('&GO'(1,1) NE '(' OR '&GO'(&L,1) NE ')').RELOCGO\n&OPND    SETC  '&GO'(2,&L-2)\n&GOR     SETC  'R'\n.RELOCGO ANOP\n.*       FIRST NULL PARAMETER PASSED IN WILL ALSO EST. NUMARG\n.NUMLOOP ANOP\n&K       SETA  &K+1\n         AIF   (&K GT &NUMARG).NUMEND\n         AIF   (T'&SYSLIST(&K) NE 'O').NUMLOOP\n&NUMARG  SETA  &K-1\n.NUMEND  ANOP\n         AIF   (&NUMARG LE 3).NOLOGIC\n&ORBNCH  SETC  '&OPND'               SET OR BRANCH ADRS\n&ANDBNCH SETC  'ANDF&SYSNDX'       SET AND FALSE BRANCH FOR LAST CHAIN\n         AIF   (&L NE 0).GOSPEC    BRANCH IF GO SPEC.\n&ORBNCH  SETC  'ORTR&SYSNDX'       SET OR TRUE BRANCH ADRS\n         AIF   (T'&NOTGOTO EQ 'O').NOTNOGO\n&ANDBNCH SETC  '&WHLOUT(&WHLNEST)' SET AND FALSE BRANCH FOR LAST CHAIN\n         AGO   .GOSPEC\n.NOTNOGO ANOP\n&ANDBNCH SETC  '&DONAME(&DONEST)' SET AND FALSE BRANCH FOR LAST CHAIN\n.GOSPEC  ANOP\n.*       SCAN FOR BEGINNING OF LAST CHAIN IF IT WAS AN 'AND' CHAIN\n&BOLANDC SETA  10000               SET OBVIOUS IMPOSSIBLE VALUE\n&IP      SETA  1                   SET TO 1ST OPERAND\n&B       SETC  '&SYSLIST(1)'\n         AIF   (NOT ('&B' EQ 'VERIFIED' OR                             *\n               '&B'EQ 'NOTVERIFIED')).NEXTPP\n&IP      SETA  &IP+1               SKIP TO NEXT POS. PARAMETER\n.NEXTPP  ANOP                      BEGIN PROCESSING NEXT ENTRY\n&IP      SETA  &IP+1               POINT TO OPERATOR\n         AIF   (&IP GT &NUMARG).SCANDN BRANCH IF DONE\n&B       SETC  '&SYSLIST(&IP)'     PUT OPERATOR INTO &B\n         MKEYWORD &B,              SEE IF UARY OPERATOR                *\n               KEYS=(ON,OFF,MIXED,NMIXED,ZERO,NZERO,POS,NPOS,NEG,NNEG)\n         AIF   (&KEYV NE 0).OPFND  BRANCH IF UARY OP. FOUND\n         MKEYWORD &B,              SEE IF BINARY OPERATOR              *\n               KEYS=(EQ,NE,LT,GT,GE,LE)\n         AIF   (&KEYV EQ 0).NOFUNC\n&IP      SETA  &IP+1               PT TO 2ND OPERATOR\n.OPFND   ANOP\n&IP      SETA  &IP+1               PT TO LOGICAL OPERATOR\n         AIF   (&IP GT &NUMARG).SCANDN BRANCH IF DONE\n&B       SETC  '&SYSLIST(&IP)'     SAVE LOGICAL OPERATOR\n         AIF   ('&B' NE 'AND').NOAND\n         AIF   (&AND).OPDONE       BRANCH IF PREV. GUY WAS AND\n&AND     SETB  1                   SAY THAT AND HIT\n&BOLANDC SETA  &IP                 SAVE POS. OF LOGICAL OP. HIT\n&OR      SETB  0                   RESET ANY OR HIT IND.\n.OPDONE  ANOP                      LOG. OPER. RECOGNITION DONE\n&IP      SETA  &IP+1               PT TO NEXT POS. PARAM.\n         AGO   .NEXTPP\n.NOAND   ANOP                      LOGICAL OPER. WAS NOT AND\n         AIF   ('&B' NE 'OR').BADLOG ERROR IF NOT OR\n         AIF   (&OR).OPDONE        BRANCH IF PREV. GUY WAS OR\n&OREVER  SETB  1                   SAY THAT AT LEAST 1 OR HIT\n&OR      SETB  1                   SAY THAT OR HIT\n&AND     SETB  0                   RESET ANY POSSIBLE AND HIT FLAG\n&BOLANDC SETA  10000               SET TO IMPOSSIBLE VALUE\n         AGO   .OPDONE\n.SCANDN  ANOP                      RESET FLAGS FOR LATER USE\n&OR      SETB  0\n&AND     SETB  0\n&IP      SETA  1\n.NOLOGIC ANOP\n.*\n.*       PROCESS A OPERAND\n.*\n.COMPROC ANOP                      ENTRY FOR MORE IF PROCESSING\n&AREG    SETB  0\n&TA      SETC  T'&SYSLIST(&IP)\n&K       SETA  K'&SYSLIST(&IP)\n&AA      SETC  '&SYSLIST(&IP)'\n&B       SETC  '&SYSLIST(&IP+1)'\n         AIF   (&K LT 3).RELOCA\n         AIF   ('&AA'(1,1) NE '(' OR '&AA'(&K,1) NE ')').RELOCA\n&TA      SETC  'R'                 REGISTER FORMAT\n&AR      SETC  'R'\n&AREG    SETB  1\n&AA      SETC  '&AA'(2,&K-2)\n         AGO   .MOREA1\n.RELOCA  ANOP\n         AIF   ('&TA' EQ 'U').MOREA1\n         AIF   (NOT ('&TA' EQ 'H' OR '&TA' EQ 'Y')).ANOTH\n.SAH     ANOP\n&TA      SETC  'H'\n         AGO   .MOREA\n.ANOTH   ANOP\n         AIF   (NOT ('&TA' EQ 'F' OR '&TA' EQ 'A' OR                   *\n               '&TA' EQ 'V')).ANOTF\n.SAF     ANOP\n&TA      SETC  'F'\n         AGO   .MOREA\n.ANOTF   ANOP\n         AIF   ('&TA' NE 'D').ANOTD\n&TA      SETC  'P'\n.ANOTD   ANOP\n         AIF   ('&TA' EQ 'X').MOREA\n         AIF   ('&TA' EQ 'P' OR '&TA' EQ 'C' OR                        *\n               '&TA' EQ 'Z').MOREA\n         AIF   ('&TA' NE 'R' AND '&TA' NE 'G').ANOTRG\n&LA      SETA  L'&SYSLIST(&IP)\n         AIF   (&LA EQ 2).SAH\n         AIF   (&LA EQ 4).SAF\n.SETAX   ANOP\n&TA      SETC  'X'\n         AGO   .MOREA\n.ANOTRG  ANOP\n         AIF   ('&TA' EQ 'B').SETAX\n         AIF   (('&B' EQ 'ON') OR ('&B' EQ 'OFF') OR                   *\n               ('&B' EQ 'MIXED') OR ('&B' EQ 'NMIXED')).MOREA1\n         MNOTE 4,'VARIABLE &AA HAS AN INVALID DATA TYPE OF &TA,''U'' AS*\n               SUMED'\n&TA      SETC  'U'\n         AGO   .MOREA1\n.MOREA   ANOP\n&LA      SETA  L'&SYSLIST(&IP)\n.MOREA1  ANOP\n.*\n.*\n.*\n.*       SEE IF UNARY OPERATOR\n.*\n         AIF   ('&B' EQ 'ON').ON\n         AIF   ('&B' EQ 'OFF').OFF\n         AIF   ('&B' EQ 'MIXED').MIXED\n         AIF   ('&B' EQ 'NMIXED').NMIXED\n         AIF   ('&B' EQ 'ZERO').ZERO\n         AIF   ('&B' EQ 'NZERO').NZERO\n         AIF   ('&B' EQ 'POS').POS\n         AIF   ('&B' EQ 'NPOS').NPOS\n         AIF   ('&B' EQ 'NEG').NEG\n         AIF   ('&B' EQ 'NNEG').NNEG\n         AIF   ('&B' EQ 'BLANK').BLANK\n         AIF   ('&B' EQ 'NBLANK').NBLANK\n.*\n.*       SEE IF LEGAL BINARY OPERATOR\n.*\n         AIF   ('&B' EQ 'EQ').EQ\n         AIF   ('&B' EQ 'NE').NE\n         AIF   ('&B' EQ 'GT').GT\n         AIF   ('&B' EQ 'LT').LT\n         AIF   ('&B' EQ 'LE').LE\n         AIF   ('&B' EQ 'GE').GE\n         AIF   ('&B' EQ '' AND &IP EQ 1).NOP\n         AGO   .NOFUNC\n.*\n.*       NO OPERATOR\n.*\n.NOP     ANOP\n&NUMARG  SETA  &NUMARG+1\n&IP      SETA  &IP-1\n         AIF   ('&AA' EQ 'VERIFIED').ZERO      (USED WITH VERIFY MACRO)\n         AIF   ('&AA' EQ 'NOTVERIFIED').NZERO  (USED WITH VERIFY MACRO)\n         AGO   .NOFORM\n.*\n.*       UNARY OPERATOR PROCESSING\n.*\n.*\n.*       ON/OFF/MIXED CHECK\n.*\n.ON      ANOP\n&OPCD    SETC  'O'\n&NOPCD   SETC  'NO'\n         AGO   .CHECK\n.OFF     ANOP\n&OPCD    SETC  'Z'\n&NOPCD   SETC  'NZ'\n         AGO   .CHECK\n.MIXED   ANOP\n&OPCD    SETC  'M'\n&NOPCD   SETC  'NM'\n         AGO   .CHECK\n.NMIXED  ANOP\n&OPCD    SETC  'NM'\n&NOPCD   SETC  'M'\n.CHECK   ANOP\n         FINDSW &SYSLIST(&IP)      SET DATA SWITCH BYTE NAME.\n         AIF   (&ERROR).EXIT\n&LABEL   TM    &RPMSW,&RPMSWT      .SWITCH ON ?\n&NUMARG  SETA  &NUMARG-2\n&IP      SETA  &IP+2\n         AGO   .BRANCH\n.*\n.*       POS/NPOS/ZERO/NZERO/NEG/NNEG/BLANK/NBLANK CHECK\n.*\n.POS     ANOP\n&OPCD    SETC  'P'\n&NOPCD   SETC  'NP'\n         AGO   .CHK2\n.NPOS    ANOP\n&OPCD    SETC  'NP'\n&NOPCD   SETC  'P'\n         AGO   .CHK2\n.ZERO    ANOP\n&OPCD    SETC  'Z'\n&NOPCD   SETC  'NZ'\n         AGO   .CHK2\n.NZERO   ANOP\n&OPCD    SETC  'NZ'\n&NOPCD   SETC  'Z'\n         AGO   .CHK2\n.NEG     ANOP\n&OPCD    SETC  'M'\n&NOPCD   SETC  'NM'\n         AGO   .CHK2\n.NNEG    ANOP\n&OPCD    SETC  'NM'\n&NOPCD   SETC  'M'\n         AGO   .CHK2\n.BLANK   ANOP\n&OPCD    SETC  'Z'\n&NOPCD   SETC  'NZ'\n&BLKTAB  SETA  1\n&WTAB    SETC  'CWABLKTB'\n         AGO   .CHK2\n.NBLANK  ANOP\n&OPCD    SETC  'Z'\n&NOPCD   SETC  'NZ'\n&NBLKTAB SETA  1\n&WTAB    SETC  'CWANOBTB'\n         AGO   .CHK2\n.*\n.CHK2    ANOP\n&NUMARG  SETA  &NUMARG-2\n&IP      SETA  &IP+2\n         AIF   (K'&B EQ 0).BRANCH  BR IF NO TEST TO BE DONE.\n         AIF   ('&B' EQ 'BLANK' OR '&B' EQ 'NBLANK').BLNKCHK\n         AIF   (NOT &AREG).UNOTREG\n&LABEL   LTR   &AA,&AA             .TEST REGISTER STATE.\n         AGO   .BRANCH\n.UNOTREG ANOP\n         AIF   ('&TA' NE 'F').UNOTF\n&R14CHG  SETB  ('&OLDR14' EQ '&AA')\n         AIF   (&R14CHG).UN1\n&LABEL   L     14,&AA\n.UN2     ANOP\n&OLDR14  SETC  '&AA'\n&LABEL   SETC  ''\n.UN1     ANOP\n&LABEL   LTR   14,14\n         AGO   .BRANCH\n.UNOTF   ANOP\n         AIF   ('&TA' NE 'H').UNOTH\n.AHALF   ANOP\n&R14CHG  SETB  ('&OLDR14' EQ '&AA')\n         AIF   (&R14CHG).UN1\n&LABEL   LH    14,&AA\n         AGO   .UN2\n.UNOTH   ANOP\n         AIF   ('&TA' NE 'P').UNOTP\n&LABEL   CP    &AA,=P'0'\n         AGO   .BRANCH\n.UNOTP   ANOP\n         AIF   ('&TA' NE 'Z').UNOTZ\n&RPDECTP SETA  1                   SET DOUBLE REQUIRED\n&DCTPCHG SETB  ('&OLDDCTP' EQ '&AA')\n         AIF   (&DCTPCHG).UN3\n&LABEL   PACK  CWADECTP,&AA\n&OLDDCTP SETC  '&AA'\n&LABEL   SETC  ''\n.UN3     ANOP\n&LABEL   CP    CWADECTP,=P'0'\n         AGO   .BRANCH\n.UNOTZ   ANOP\n         AIF   ('&B' NE 'ZERO' AND '&B' NE 'NZERO').ILLUNI\n         AIF   ('&TA' EQ 'U').ILLUNI\n         AIF   (&LA GT 1).UBIG\n&LABEL   CLI   &AA,0\n         AGO   .BRANCH\n.UBIG    ANOP\n&LABEL   OC    &AA,&AA\n         AGO   .BRANCH\n.BLNKCHK ANOP\n         AIF   (NOT &AREG).IF1\n&LABEL   CLM   &AA,X'F',=CL4'    '\n         AGO   .BRANCH\n.IF1     ANOP\n&LABEL   STM   1,2,12(13)\n         TRT   &AA,&WTAB\n         LM    1,2,12(13)\n         AGO   .BRANCH\n.*\n.*\n.*       BINARY OPERATOR PROCESSING\n.*\n.*       EQ/NE/GT/LT/LE/GE CHECK\n.*\n.*\n.EQ      ANOP\n&OPCD    SETC  'E'\n&NOPCD   SETC  'NE'\n         AGO   .CHK1\n.NE      ANOP\n&OPCD    SETC  'NE'\n&NOPCD   SETC  'E'\n         AGO   .CHK1\n.GT      ANOP\n&OPCD    SETC  'H'\n&NOPCD   SETC  'NH'\n         AGO   .CHK1\n.LT      ANOP\n&OPCD    SETC  'L'\n&NOPCD   SETC  'NL'\n         AGO   .CHK1\n.LE      ANOP\n&OPCD    SETC  'NH'\n&NOPCD   SETC  'H'\n         AGO   .CHK1\n.GE      ANOP\n&OPCD    SETC  'NL'\n&NOPCD   SETC  'L'\n         AGO   .CHK1\n.*\n.CHK1    ANOP\n.*\n.*       PROCESS C OPERAND\n.*\n&CREG    SETB  0\n&TC      SETC  T'&SYSLIST(&IP+2)\n&CC      SETC  '&SYSLIST(&IP+2)'\n&Q       SETC  '&CC'(1,1)\n&K       SETA  K'&CC\n         AIF   (&K LT 3).RELOCC\n         AIF   ('&Q' NE '(' OR '&CC'(&K,1) NE ')').TRYI\n&TC      SETC  'R'                 SET TYPE TO IND. REGISTER\n&CR      SETC  'R'\n&CREG    SETB  1\n&CC      SETC  '&CC'(2,&K-2)\n         AGO   .MOREC1\n.TRYI    ANOP\n         AIF   ('&Q' NE '/' OR '&CC'(&K,1) NE '/').RELOCC\n&TC      SETC  'I'                 SET TYPE TO IND. IMMED.\n&CC      SETC  '&CC'(2,&K-2)\n         AGO   .MOREC1\n.RELOCC  ANOP\n         AIF   ('&TC' EQ 'U' OR '&TC' EQ 'N').CIFLIT\n         AIF   (NOT ('&TC' EQ 'H' OR '&TC' EQ 'Y')).CNOTH\n.SCH     ANOP\n&TC      SETC  'H'\n         AGO   .MOREC\n.CNOTH   ANOP\n         AIF   (NOT ('&TC' EQ 'F' OR '&TC' EQ 'A' OR                   *\n               '&TC' EQ 'V')).CNOTF\n.SCF     ANOP\n&TC      SETC  'F'\n         AGO   .MOREC\n.CNOTF   ANOP\n         AIF   ('&TC' NE 'D').CNOTD\n&TC      SETC  'P'\n.CNOTD   ANOP\n         AIF   ('&TC' EQ 'X').MOREC\n         AIF   ('&TC' EQ 'P' OR '&TC' EQ 'Z' OR                        *\n               '&TC' EQ 'C').MOREC\n         AIF   ('&TC' NE 'R').CNOTR\n&LC      SETA  L'&SYSLIST(&IP+2)\n         AIF   (&LC EQ 2).SCH\n         AIF   (&LC EQ 4).SCF\n.SETCX   ANOP\n&TC      SETC  'X'\n         AGO   .MOREC\n.CNOTR   ANOP\n         AIF   ('&TC' EQ 'B').SETCX\n         MNOTE 4,'VARIABLE &CC HAS AN INVALID DATA TYPE OF &TC,''U'' AS*\n               SUMED'\n&TC      SETC  'U'\n         AGO   .MOREC1\n.*\n.*       SEE IF LITERAL SPECIFIED\n.*\n.CIFLIT  ANOP\n         AIF   ('&CC'(&K,1) NE '''').NOTLIT\n.*       LITERAL WAS SPECIFIED\n         AIF   ('&Q' NE '''').NOA1\n&CC      SETC  'C'.'&CC'\n&K       SETA  &K+1\n         AGO   .QUOTAMP\n.NOA1    ANOP\n         AIF   ('&CC'(2,1) NE '''').NOTLIT\n         AIF   ('&Q' NE 'C').NOA0\n.QUOTAMP ANOP\n&TC      SETC  'C'\n&LC      SETA  &K-3\n&I       SETA  2\n.QLOOP   ANOP\n&I       SETA  &I+1\n         AIF   (&I GE &K).QADONE\n         AIF   ('&CC'(&I,1) NE '''' AND '&CC'(&I,1) NE '&&'(1,1)).QLOOP\n&I       SETA  &I+1                SKIP NEXT CHAR.\n&LC      SETA  &LC-1               ADJUST TO ACTUAL LEN AT XEQ\n         AGO   .QLOOP\n.QADONE  ANOP\n         AGO   .PUTEQ\n.NOA0    ANOP\n         AIF   ('&Q' NE 'X').NOA2\n&TC      SETC  'X'\n&LC      SETA  ((&K-3)+1)/2\n.PUTEQ   ANOP\n&CC      SETC  '='.'&CC'\n         AGO   .MOREC1\n.NOA2    ANOP\n         AIF   ('&Q' NE 'B').NOA3\n&TC      SETC  'X'\n&LC      SETA  ((&K-3)+7)/8\n         AGO   .PUTEQ\n.NOA3    ANOP\n         AIF   ('&Q' NE 'H').NOA4\n&TC      SETC  'H'\n&LC      SETA  2\n         AGO   .PUTEQ\n.NOA4    ANOP\n         AIF   ('&Q' NE 'F').NOA5\n&TC      SETC  'F'\n&LC      SETA  4\n         AGO   .PUTEQ\n.NOA5    ANOP\n         AIF   ('&Q' NE 'P').NOA6\n&TC      SETC  'P'\n&LC      SETA  (&K-1)/2\n         AGO   .PUTEQ\n.NOA6    ANOP\n         AIF   ('&Q' NE 'Z').NOA7\n&TC      SETC  'Z'\n&LC      SETA  &K-3\n         AGO   .PUTEQ\n.NOA7    ANOP\n.NOTLIT  ANOP\n&TEMPV   SETC  '0123456789'\n&TEMP    SETC  '&CC'\n&CNUMB   SETA  0\n         AIF   (NOT ('&Q' EQ '-' OR '&Q' EQ '+')).NOPORM\n&TEMP    SETC  '&CC'(2,&K-1)\n.NOPORM  ANOP\n         MVERIFY &TEMP,&TEMPV\n         AIF   (&VERIFYV NE 0).MOREC1\n&CABSNUM SETA  &TEMP\n&CNUMB   SETA  1\n         AIF   (&CABSNUM LE 32767).MOREC1\n&CNUMB   SETA  2\n         AGO   .MOREC1\n.MOREC   ANOP\n&LC      SETA  L'&SYSLIST(&IP+2)\n.MOREC1  ANOP\n&NUMARG  SETA  &NUMARG-3\n&IP      SETA  &IP+3               POINT TO POSSIBLE LOGICAL OPERATOR\n.*****************************************************\n         AIF   (NOT &AREG).XNOTREG\n.SIDEI   ANOP                      SIDE ENTRY POINT FOR OTHER GUYS\n.*       X WAS A (RX) SPEC.\n         AIF   (NOT &CREG).I1\n.*       Y WAS A (RY)\n&LABEL   CR    &AA,&CC\n         AGO   .BRANCH\n.I1      ANOP\n         AIF   ('&TC' NE 'H').I2\n.I15     ANOP\n&LABEL   CH    &AA,&CC\n         AGO   .BRANCH\n.I2      ANOP\n         AIF   ('&TC' NE 'F').I3\n.I25     ANOP\n&LABEL   C     &AA,&CC\n         AGO   .BRANCH\n.I3      ANOP\n         AIF   ('&TC' NE 'P').I4\n&RPDECTP SETA  1                   SET DOUBLE REQUIRED\n&DCTPCHG SETB  ('&OLDDCTP' EQ '&AA')\n         AIF   (&DCTPCHG).I32\n&LABEL   CVD   &AA,CWADECTP\n&OLDDCTP SETC  '&AA'\n&LABEL   SETC  ''\n.I32     ANOP\n&LABEL   CP    CWADECTP,&CC\n         AGO   .BRANCH\n.I4      ANOP\n         AIF   ('&TC' NE 'Z').I5\n&RPDECTP SETA  1                   SET DOUBLE REQUIRED\n&RPMUSER SETA  1                   SET DOUBLE REQUIRED.\n&DCTPCHG SETB  ('&OLDDCTP' EQ '&AA')\n         AIF   (&DCTPCHG).I34\n&LABEL   CVD   &AA,CWADECTP\n&OLDDCTP SETC  '&AA'\n&LABEL   SETC  ''\n.I34     ANOP\n&LABEL   PACK  TWAUSER,&CC\n         CP    CWADECTP,TWAUSER\n         AGO   .BRANCH\n.I5      ANOP\n         AIF   ('&TC' NE 'I').I55\n&LABEL   C     &AA,=A(&CC)\n         AGO   .BRANCH\n.I55     ANOP\n         AIF   (&CNUMB EQ 0).I6\n         AIF   (&CNUMB GT 1).I7\n&LABEL   CH    &AA,=H'&CC'\n         AGO   .BRANCH\n.I7      ANOP\n&LABEL   C     &AA,=F'&CC'\n         AGO   .BRANCH\n.I6      ANOP\n         AIF   ('&TC' EQ 'U').I8\n&CLM     SETC  'F'\n         AIF   (&LC GT 3).I81\n&CLMM    SETC  '137'\n&CLM     SETC  '&CLMM'(&LC,1)\n.I81     ANOP\n&LABEL   CLM   &AA,X'&CLM',&CC\n         AGO   .BRANCH\n.I8      ANOP\n&LABEL   C     &AA,&CC\n         AGO   .BRANCH\n.XNOTREG ANOP\n         AIF   ('&TA' NE 'P').XNOTPAK\n.*       X IS A PACKED FIELD\n         AIF   ('&TC' NE 'P').II0\n&LABEL   CP    &AA,&CC\n         AGO   .BRANCH\n.II0     ANOP\n         AIF   (NOT &CREG).II1\n&RPDECTP SETA  1                   SET DOUBLE REQUIRED\n&DCTPCHG SETB  ('&OLDDCTP' EQ '&CC')\n         AIF   (&DCTPCHG).II22\n&LABEL   CVD   &CC,CWADECTP\n&OLDDCTP SETC  '&CC'\n&LABEL   SETC  ''\n.II22    ANOP\n&LABEL   CP    &AA,CWADECTP\n         AGO   .BRANCH\n.II1     ANOP\n         AIF   ('&TC' NE 'H').II2\n&R14CHG  SETB  ('&OLDR14' EQ '&CC')\n         AIF   (&R14CHG).II24\n&LABEL   LH    14,&CC\n.AII1    ANOP\n&OLDR14  SETC  '&CC'\n&LABEL   SETC  ''\n.II24    ANOP\n&DCTPCHG SETB  ('&OLDDCTP' EQ '&CC')\n         AIF   (&DCTPCHG).II27\n&LABEL   CVD   14,CWADECTP\n&OLDDCTP SETC  '&CC'\n&LABEL   SETC  ''\n.II27    ANOP\n&LABEL   CP    &AA,CWADECTP\n         AGO   .BRANCH\n.II2     ANOP\n         AIF   ('&TC' NE 'F').II3\n.II25    ANOP\n&R14CHG  SETB  ('&OLDR14' EQ '&CC')\n         AIF   (&R14CHG).II24\n&LABEL   L     14,&CC\n         AGO   .AII1\n.II3     ANOP\n         AIF   ('&TC' NE 'Z').II38\n&RPDECTP SETA  1                   SET DOUBLE REQUIRED\n&DCTPCHG SETB  ('&OLDDCTP' EQ '&CC')\n         AIF   (&DCTPCHG).II42\n&LABEL   PACK  CWADECTP,&CC\n&OLDDCTP SETC  '&CC'\n&LABEL   SETC  ''\n.II42    ANOP\n&LABEL   CP    &AA,CWADECTP\n         AGO   .BRANCH\n.II38    ANOP\n         AIF   ('&TC' NE 'I').II37\n&CC      SETC  '=A(&CC.)'\n         AGO   .II25\n.II37    ANOP\n         AIF   (&CNUMB EQ 0).II5\n&LABEL   CP    &AA,=P'&CC'\n         AGO   .BRANCH\n.II5     ANOP\n         AIF   ('&TC' EQ 'C' OR '&TC' EQ 'X').ABNCOMP\n&LABEL   CP    &AA,&CC\n         AGO   .BRANCH\n.XNOTPAK ANOP\n         AIF   ('&TA' NE 'Z').XNOTZON\n         AIF   (NOT &CREG).III1\n&LABEL   CVD   &CC,TWAUSER\n&LABEL   SETC  ''\n.AIII1   ANOP\n&RPDECTP SETA  1                   SET DOUBLE REQUIRED\n&RPMUSER SETA  1                   SET DOUBLE REQUIRED.\n&DCTPCHG SETB  ('&OLDDCTP' EQ '&AA')\n         AIF   (&DCTPCHG).II44\n&LABEL   PACK  CWADECTP,&AA\n&OLDDCTP SETC  '&AA'\n&LABEL   SETC  ''\n.II44    ANOP\n&LABEL   CP    CWADECTP,TWAUSER\n         AGO   .BRANCH\n.III1    ANOP\n         AIF   ('&TC' NE 'H').III2\n.III15   ANOP\n&R14CHG  SETB  ('&OLDR14' EQ '&CC')\n         AIF   (&R14CHG).III11\n&LABEL   LH    14,&CC\n.III12   ANOP\n&OLDR14  SETC  '&CC'\n&LABEL   SETC  ''\n.III11   ANOP\n&RPMUSER SETA  1\n&LABEL   CVD   14,TWAUSER\n         AGO   .AIII1\n.III2    ANOP\n         AIF   ('&TC' NE 'F').III3\n.III25   ANOP\n&R14CHG  SETB  ('&OLDR14' EQ '&CC')\n         AIF   (&R14CHG).III11\n&LABEL   L     14,&CC\n         AGO   .III12\n.III3    ANOP\n         AIF   ('&TC' NE 'P').III4\n.III35   ANOP\n&RPDECTP SETA  1                   SET DOUBLE REQUIRED\n&DCTPCHG SETB  ('&OLDDCTP' EQ '&AA')\n         AIF   (&DCTPCHG).III31\n&LABEL   PACK  CWADECTP,&AA\n&OLDDCTP SETC  '&AA'\n&LABEL   SETC  ''\n.III31   ANOP\n&LABEL   CP    CWADECTP,&CC\n         AGO   .BRANCH\n.III4    ANOP\n         AIF   ('&TC' NE 'Z').III41\n&LABEL   PACK  TWAUSER,&CC\n&LABEL   SETC  ''\n         AGO   .AIII1\n.III41   ANOP\n         AIF   ('&TC' NE 'I').III42\n&LABEL   CLI   &AA,&CC\n         AGO   .BRANCH\n.III42   ANOP\n         AIF   (&CNUMB EQ 0).III5\n&RPDECTP SETA  1                   SET DOUBLE REQUIRED\n&CC      SETC  '=P''&CC'''\n         AGO   .III35\n.III5    ANOP\n         AIF   ('&TC' EQ 'U').III6\n         AIF   ((('&TC' EQ 'C' OR '&TC' EQ 'X') AND (&LC EQ 1))        *\n               AND ('&CC'(1,1) EQ '=')).ZLIT\n         AIF   ('&AA'(K'&AA,1) EQ ')').III6\n         AIF   (&LA EQ &LC).III6\n&L       SETA  &LC\n         AIF   (&LC LE &LA).III7\n.*       &LC > &LA\n&L       SETA  &LA          SETUP A LENGTH BECAUSE C TOO BIG.\n         FIXQUOTE &CC\n  MNOTE 4,'**WARNING**, ONLY THE FIRST &L CHARS. OF \"&SWQUOTE\" USED IN *\n               COMPARISON'\n.III7    ANOP\n&LABEL   CLC   &AA.(&L),&CC\n         AGO   .BRANCH\n.III6    ANOP\n&LABEL   CLC   &AA,&CC\n         AGO   .BRANCH\n.ZLIT    ANOP\n&CC      SETC  '&CC'(2,K'&CC-1)\n&LABEL   CLI   &AA,&CC\n         AGO   .BRANCH\n.XNOTZON ANOP\n         AIF   ('&TA' NE 'H').XNOTHY\n.*       FIRST OPERAND IS 1/2 WORD\n         AIF   (NOT &CREG).T1\n         AIF   ('&OPCD' EQ 'E').T11\n.*       REVERSE CONDITION\n&TMPOPCD SETC  '&OPCD'\n&OPCD    SETC  '&NOPCD'\n&NOPCD   SETC  '&TMPOPCD'\n.T11     ANOP\n&LABEL   CH    &CC,&AA\n         AGO   .BRANCH\n.T1      ANOP\n         AIF   ('&TC' EQ 'C' OR '&TC' EQ 'X').ABNCOMP\n         AIF   (&CNUMB EQ 2).CERR\n&R14CHG  SETB  ('&OLDR14' EQ '&AA')\n         AIF   (&R14CHG).S1\n&LABEL   LH    14,&AA\n&OLDR14  SETC  '&AA'\n&LABEL   SETC  ''\n.S1      ANOP\n         AIF   ('&TC' NE 'I').S12\n&LABEL   CH    14,=Y(&CC)\n         AGO   .BRANCH\n.S12     ANOP\n         AIF   ('&TC' NE 'U').S13\n&LABEL   CH    14,&CC\n         AGO   .BRANCH\n.S13     ANOP\n&AA      SETC  '14'                PHONY THINGS UP AS IF REG. SPECFIED\n         AGO   .SIDEI\n.XNOTHY  ANOP\n         AIF   ('&TA' NE 'F').XNOTFA\n         AIF   (NOT &CREG).T2\n         AIF   ('&OPCD' EQ 'E').T22\n.*       REVERSE CONDITION\n&TMPOPCD SETC  '&OPCD'\n&OPCD    SETC  '&NOPCD'\n&NOPCD   SETC  '&TMPOPCD'\n.T22     ANOP\n&LABEL   C     &CC,&AA\n         AGO   .BRANCH\n.T2      ANOP\n         AIF   ('&TC' EQ 'C' OR '&TC' EQ 'X').ABNCOMP\n&R14CHG  SETB  ('&OLDR14' EQ '&AA')\n         AIF   (&R14CHG).T13\n&LABEL   L     14,&AA\n&OLDR14  SETC  '&AA'\n&LABEL   SETC  ''\n.T13     ANOP\n         AIF   ('&TC' NE 'I').S13\n&LABEL   C     14,=A(&CC)\n         AGO   .BRANCH\n.XNOTFA  ANOP\n         AIF   (NOT &CREG).NCREG\n         AIF   ('&OPCD' EQ 'E').T33\n.*       REVERSE CONDITION\n&TMPOPCD SETC  '&OPCD'\n&OPCD    SETC  '&NOPCD'\n&NOPCD   SETC  '&TMPOPCD'\n.T33     ANOP\n         AIF   ('&TA' NE 'U').NCREG1\n&LABEL   C     &CC,&AA\n         AGO   .BRANCH\n.NCREG1  ANOP\n&CLM     SETC  'F'\n         AIF   (&LA GT 3).V81\n&CLMM    SETC  '137'\n&CLM     SETC  '&CLMM'(&LA,1)\n.V81     ANOP\n&LABEL   CLM   &CC,X'&CLM',&AA\n         AGO   .BRANCH\n.NCREG   ANOP\n         AIF   ('&TC' NE 'N').CNNUM\n         AIF   ('&TA' EQ 'U').CERR\n         AIF   (&LA NE 1).AN1\n&LABEL   CLI   &AA,&CC\n         AGO   .BRANCH\n.AN1     ANOP\n&LABEL   CLC   &AA,=FL&LA.'&CC'\n         AGO   .BRANCH\n.CNNUM   ANOP\n         AIF   ('&TA' EQ 'U').IV1\n         AIF   ('&TC' EQ 'H' OR '&TC' EQ 'F' OR '&TC' EQ 'P').ABNCOMP\n.IV1     ANOP\n         AIF   ('&TC' NE 'I').NOCLI\n.YESCLI  ANOP\n&LABEL   CLI   &AA,&CC\n         AGO   .BRANCH\n.NOCLI   ANOP\n         AIF   ('&CC'(1,1) NE '=' OR &LC NE 1).NOTCLI1\n&K       SETA  K'&CC\n&CC      SETC  '&CC'(2,&K-1)\n         AGO   .YESCLI\n.ABNCOMP ANOP\n         MNOTE 4,'** WARNING **,INCOMPATIBLE DATA TYPES, STRING COMPARI*\n               SON ASSUMMED'\n.NOTCLI1 ANOP\n         AIF   ('&TA' NE 'U').ANOTU\n         AIF   ('&TC' NE 'P').NP1\n&LABEL   CP    &AA,&CC\n         AGO   .BRANCH\n.NP1     ANOP\n         AIF   ('&TC' NE 'H').NH1\n&R14CHG  SETB  ('&OLDR14' EQ '&AA')\n         AIF   (&R14CHG).T14\n&LABEL   LH    14,&AA\n&OLDR14  SETC  '&AA'\n&LABEL   SETC  ''\n.T14     ANOP\n&LABEL   CH    14,&CC\n         AGO   .BRANCH\n.NH1     ANOP\n         AIF   ('&TC' NE 'F').NF1\n&R14CHG  SETB  ('&OLDR14' EQ '&AA')\n         AIF   (&R14CHG).T15\n&LABEL   L     14,&AA\n&OLDR14  SETC  '&AA'\n&LABEL   SETC  ''\n.T15     ANOP\n&LABEL   C     14,&CC\n         AGO   .BRANCH\n.NF1     ANOP\n         AIF   ('&TA' NE 'U').ANOTU\n.*       IF C IS NOT 'U' AND IF LEN. IS NOT EXPLICITLY SPECIFIED IN A\n.*                                 THEN USE C LEN.\n         AIF   ('&TC' NE 'U').CNOTU1\n.DOIT    ANOP\n&LABEL   CLC   &AA,&CC\n         AGO   .BRANCH\n.CNOTU1  ANOP\n         AIF   ('&AA'(K'&AA,1) EQ ')').DOIT\n&LABEL   CLC   &AA.(&LC),&CC\n         AGO   .BRANCH\n.ANOTU   ANOP\n         AIF   ('&TC' NE 'U').CNOTU2\n         AIF   ('&AA'(K'&AA,1) EQ ')').LS1\n&LABEL   CLC   &AA.(&LA),&CC\n         AGO   .BRANCH\n.LS1     ANOP\n&LABEL   CLC   &AA,&CC\n         AGO   .BRANCH\n.CNOTU2  ANOP\n         AIF   ('&AA'(K'&AA,1) EQ ')' OR &LA EQ &LC).DOIT\n&L       SETA  &LC\n         AIF   (&LC LE &LA).LOK\n.*       &LC > &LA\n&L       SETA  &LA\n         FIXQUOTE &CC\n MNOTE 4,'**WARNING**, ONLY THE FIRST &L CHARS. OF \"&SWQUOTE\" USED IN C*\n               OMPARISON'\n.LOK     ANOP\n&LABEL   CLC   &AA.(&L),&CC\n         AGO   .BRANCH\n.*\n.*       CONSTRUCT 'DO' GROUP OR 'GOTO' LABEL\n.*\n.BRANCH  ANOP\n&LABEL   SETC  ''\n         AIF   (&NUMARG LE 0).DONE1\n.*       MORE OPERANDS FOLLOW\n&B       SETC  '&SYSLIST(&IP)'\n&IP      SETA  &IP+1\n&NUMARG  SETA  &NUMARG-1\n         AIF   ('&B' EQ 'OR').OR\n         AIF   ('&B' EQ 'AND').AND\n         AGO   .BADLOG\n.*\n.OR      ANOP                      OR OPERATOR HIT\n&BCD     SETC  'B&OPCD'\n         AIF   (K'&GO EQ 0).OR1    BRANCH IF GOTO NOT SPECIFIED\n&BCD     SETC  '&BCD&GOR'          ADD IN POSSIBLE 'R' TO OP CODE\n.OR1     ANOP\n         AIF   (&OR).GENBNCH       SKIP AHEAD IF PREV GUY WAS OR\n&BOPND   SETC  '&ORBNCH'           SETUP TRUE BRANCH ADRS\n&OR      SETB  1                   SAY THAT OR HIT\n         AIF   (NOT &AND).GENBNCH   BRANCH IF NO PREV. AND\n.*       OR OPERATOR HIT BUT 'AND' OP. WAS IMMED. PREV. GUY\n.*       WE MUST GENERATE A LABEL\n&AND     SETB  0                   RESET OLD 'AND' IND.\n&LAB     SETC  'AND&V&SYSNDX'      SETUP LABEL\n&V       SETA  &V+1\n&R14FLD  SETB  (&R14FLD OR (NOT &R14CHG))\n         AIF   (NOT &R14FLD).NR14\n&R14FLD  SETB  0\n&OLDR14  SETC  ''\n.NR14    ANOP\n&DCTPFLD SETB  (&DCTPFLD OR (NOT &DCTPCHG))\n         AIF   (NOT &DCTPFLD).GENBNCH\n&DCTPFLD SETB  0\n&OLDDCTP SETC  ''\n         AGO   .GENBNCH\n.*\n.AND     ANOP                      AND OPERATOR HIT\n&BCD     SETC  'B&NOPCD'           SETUP OPCODE\n         AIF   (&AND).PREVAND      BRANCH IF PREV. OP. AND ALSO\n&R14CHG  SETB  1\n&DCTPCHG SETB  1\n&BOPND   SETC  '&ANDBNCH'          SETUP AS IF IN LAST AND CHAIN\n         AIF   (&IP GE &BOLANDC).NIANDC BRANCH IF  IN LAST AND CHAIN\n&BOPND   SETC  'AND&V&SYSNDX'      SETUP BRANCH TO JUST BEFORE NEXT OR\n.NIANDC  ANOP                      NOT IN AND CHAIN\n&AND     SETB  1                   SAY THAT AND ENCOUNTERED\n&OR      SETB  0                   RESET OR HIT IND.\n         AGO   .GENBNCH\n.PREVAND ANOP\n&R14FLD  SETB  (&R14FLD OR (NOT &R14CHG))\n&DCTPFLD SETB  (&DCTPFLD OR (NOT &DCTPCHG))\n.GENBNCH ANOP                      GENERATE BRANCH INSTRUCTION\n         &BCD  &BOPND\n         AIF   (K'&LAB EQ 0).NOLOGIC\n&LABEL   SETC  '&LAB'              GENERATE LABEL FOR PREV. ANDS\n&LAB     SETC  ''\n         AGO   .NOLOGIC\n.DONE1   ANOP\n         AIF   (T'&NOTGOTO NE 'O').NOMNOTE\n         AIF   ('&GO' EQ '').DO    BR IF DO GROUP WANTED.\n&OPCD    SETC  'B&OPCD&GOR    '(1,5)\n         &OPCD &OPND               .BRANCH IF TRUE.\n         AIF   (NOT &AND).EXIT\n&ANDBNCH DS    0H\n.EXIT    ANOP\n&MACLEV  SETA  &MACLEV-1\n         MEXIT\n.DO      ANOP\n         AIF   (&MACLEV GT 1).NOMNOTE\n&PGMNEST SETA  &PGMNEST+1          INCREMENT BLOCK NESTING LEVEL.\n&PGMBTYP(&PGMNEST) SETC 'IF'        SHOW BLOCK TYPE.\n         MNOTE *,'        &PGMNEST'\n.NOMNOTE ANOP\n&OPCD    SETC  'B&NOPCD    '(1,5)\n         AIF   (T'&NOTGOTO EQ 'O').DOS\n&OPND    SETC  '&WHLOUT(&WHLNEST)'\n         AGO   .DOS1\n.DOS     ANOP\n&OPND    SETC  '&DONAME(&DONEST)'\n.DOS1    ANOP\n         &OPCD &OPND               .SKIP 'THEN' CLAUSE IF FALSE.\n         AIF   (NOT &OREVER).EXIT\n&ORBNCH  DS    0H\n         AGO   .EXIT\n.NOFUNC  MNOTE 8,'** ERROR ** MACRO FUNCTION ''&B'' NOT SUPPORTED'\n         AGO   .EXIT\n.NOFORM  MNOTE 8,'** ERROR ** FEATURE NOT SUPPORTED'\n         AGO   .EXIT\n.BADLOG  ANOP\n         MNOTE 8,'** ERROR ** LOGICAL OPERATOR &B IS INVALID'\n         AGO   .EXIT\n.CERR    ANOP\n         FIXQUOTE &CC\n         MNOTE 8,'** ERROR ** OPERAND \"&SWQUOTE\" IS ILLEGAL'\n         AGO   .EXIT\n.ILLUNI  MNOTE 8,'** ERROR ** &B OPERATION IS NOT VALID FOR &AA'\n         AGO   .EXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODLIST": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1c\\x00W\\x00\\x92\\x03\\x0f\\x01\\x16\\x18o\\x14\\x19\\x07 \\x13~\\x07 \\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.28", "flags": 0, "createdate": "1992-01-30T00:00:00", "modifydate": "2016-07-04T14:19:57", "lines": 1824, "newlines": 4990, "modlines": 1824, "user": "SBGOLOB"}, "text": "MODL     TITLE 'LIST LOAD MODULE AND CSECT ATTRIBUTES'\n*---------------------------------------------------------------------*\n*---     THIS PROGRAM LISTS THE LINK-EDIT ATTRIBUTES AND, FOR      ---*\n*---     COBOL PROGRAMS, THE COMPILER VERSION AND SELECTED         ---*\n*---     COMPILER OPTIONS OF AN ENTIRE LIBRARY.                    ---*\n*---                                                               ---*\n*---     INPUT DD STATEMENTS: THE SYSLIB DD STATEMENT DESIGNATES   ---*\n*---     THE LIBRARY TO BE EXAMINED.  CONCATENATED DATASETS ARE    ---*\n*---     NOT ALLOWED.                                              ---*\n*---                                                               ---*\n*---     INPUT PARM FIELD: IF A PARM OF 'NOLIB' IS SUPPLIED, THE   ---*\n*---     VARIOUS 'INVISIBLE' LIBRARY ROUTINES ARE NOT LISTED.      ---*\n*---     THESE ROUTINES ARE ALL THOSE WHOSE NAMES START WITH       ---*\n*---     'ILB', 'IGZ', 'IHO', 'IHC', 'IHN', 'IBM', 'IHE', OR       ---*\n*---     'IHD'.                                                    ---*\n*---                                                               ---*\n*---     OUTPUT CONSISTS OF A LISTING OF ALL THE LOAD MODULE       ---*\n*---     ATTRIBUTES THAT CAN BE DETERMINED AS WELL AS ATTRIBUTE    ---*\n*---     INFORMATION ABOUT EACH CSECT, OTHER THAN THOSE EXCLUDED   ---*\n*---     BY THE NOLIB OPTION.  THE OUTPUT DATASET, SYSPRINT, MUST  ---*\n*---     HAVE ALL DCB ATTRIBUTES SPECIFIED.  LRECL MAY BE          ---*\n*---     ANYWHERE FROM 80 TO 255 BYTES AND THE RECORD FORMAT MUST  ---*\n*---     BE FIXED.  ANSI CARRIAGE CONTROLS ARE USED THROUGHOUT.    ---*\n*---                                                               ---*\n*---     ONE SUGGESTION: YOU SHOULD RUN THIS PROGRAM IN THE        ---*\n*---     LARGEST AVAILABLE REGION BELOW THE 16M LINE.  PART OF     ---*\n*---     THE PROCESSING CONSISTS OF EXECUTING THE LOAD MACRO       ---*\n*---     INSTRUCTION AGAINST EACH LOAD MODULE, SO THAT THE TEXT    ---*\n*---     MAY BE SEARCHED FOR THE COBOL TCT AREA.  THOSE MODULES    ---*\n*---     THAT ARE LINKED WITH THE RMODE=31 ATTRIBUTE ARE LOADED    ---*\n*---     ABOVE THE 16M LINE, WHILE ALL OTHERS ARE LOADED BELOW     ---*\n*---     THE 16M LINE, POSSIBLY REQUIRING A LARGE AMOUNT OF        ---*\n*---     STORAGE.                                                  ---*\n*---                                                               ---*\n*---     ***POSSIBLE BUGS IN \"LOAD\" CODE.                          ---*\n*---                                                               ---*\n*---     RICK FOCHTMAN                                             ---*\n*---     SR. SYSTEMS PROGRAMMING SPECIALIST                        ---*\n*---     BOARD OF TRADE CLEARING CORP.                             ---*\n*---     141 W. JACKSON BLVD, SUITE 1460                           ---*\n*---     CHICAGO, IL  60604                                        ---*\n*---     (312) 786-5772                                            ---*\n*---     PREFERRED E-MAIL: RICKFOCHTMAN@COMPUSERVE.COM             ---*\n*---                                                               ---*\n*---     RICK HAS PASSED AWAY.  PLEASE SEND FIX REQUESTS OR        ---*\n*---     UPDATES TO SAM GOLOB.                                     ---*\n*---                                                               ---*\n*---          EMAIL:  SBGOLOB@CBTTAPE.ORG   OR                     ---*\n*---                  SBGOLOB@ATTGLOBAL.NET                        ---*\n*---                                                               ---*\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\n*---     STANDARD NON-REENTRANT ENTRY LINKAGE STUFF                ---*\n*---------------------------------------------------------------------*\n*---     DEFINE AMODE/RMODE AND VARIOUS SWITCHES                   ---*\n*---------------------------------------------------------------------*\nMODLIST  CSECT\nMODLIST  AMODE 24\nMODLIST  RMODE 24\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\nPDS2ATR1 $DSW  RENT,REUS,OVLY,TEST,LOAD,SCTR,EXEC,SNGLBLK,             X\n               TYPE=NODATA\nPDS2ATR2 $DSW  FLVL,ORG0,EP0,NRLD,EDIT,TSTN,LEF,REFR,TYPE=NODATA\nMISCFLGS $DSW  NOLIB,TYPE=NODATA\n         B     12(,R15)\n         DC    AL1(7),CL7'MODLIST'\n         STM   R14,R12,12(R13)\n         BAS   R2,96(,R15)\n         USING *,R13,R12,R11\n         DS    18F\n         DC    A(4096)\n         LA    R2,0(,R2)           CLEAR HIGH-ORDER BYTE\n         XC    0(72,R2),0(R2)      CLEAR THE NEW SAVE AREA\n         ST    R2,8(,R13)          ADD TO FORWARD CHAIN\n         ST    R13,4(,R2)          UPDATE BACK CHAIN POINTER\n         LR    R13,R2              LOAD FIRST BASE REGISTER\n         LR    R12,R13             COPY TO SECOND BASE\n         AL    R12,72(,R13)        SET SECOND BASE REGISTER\n         LR    R11,R12             COPY TO THIRD BASE REGISTER\n         AL    R11,72(,R13)        SET THIRD BASE REGISTER\n         L     R2,0(R1)            GET THE PARM POINTER\n         LH    R1,0(R2)            GET PARM LENGTH\n         CH    R1,=H'5'            LONG ENOUGH FOR 'NOLIB' ??\n         BL    ALLESD              NOPE ---\n         CLC   2(5,R2),=CL5'NOLIB' SKIP LIBRARY ROUTINES ??\n         BNE   ALLESD              NOPE ---\n         NI    SKIPLIB+1,X'0F'     YES; TURN OFF THE BRANCH\nALLESD   DS    0H\n*---------------------------------------------------------------------*\n*---     ALLOCATE MY ESD AND IDR TABLE SPACE.  I FORCE THEM        ---*\n*---     ABOVE THE 16M LINE BY THE GETMAIN VC AND FREEMAIN VC      ---*\n*---     THAT GRAB ALL THE AVAILABLE STORAGE BELOW THE LINE FIRST. ---*\n*---------------------------------------------------------------------*\n         L     R3,DATALEN\n         GETMAIN RU,LV=(R3),BNDRY=PAGE,SP=40\n         ST    R1,ESDTAB           SAVE AS ESD TABLE ADDRESS\n         ST    R3,0(,R1)           SAVE SIZE IN HEADER\n*---------------------------------------------------------------------*\n*---     OPEN THE VARIOUS FILES NEEDED AND READ IN THE PDS         ---*\n*---     DIRECTORY. ALSO, INITIALIZE THE 'SEG' FIELDS FOR THE      ---*\n*---     REPORT DETAIL LINES.                                      ---*\n*---------------------------------------------------------------------*\n         OPEN  (PDS,INPUT,PRNT,OUTPUT)\n         RDJFCB (PDS)\n         MVC   DSNAME,JFCB\n         LH    R0,PRNT+82          LOAD THE DCB LRECL VALUE\n         STCM  R0,15,LINE1         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE2         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE3         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE4         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE5         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE6         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE7         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE8         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE9         STORE IN 'SEG' CONTROL FIELD\n         STCM  R0,15,LINE10        STORE IN 'SEG' CONTROL FIELD\n         CALL  GETALIAS,(DDN,CHAIN)\n*---------------------------------------------------------------------*\n*---     THE MAJOR PROCESSING LOOP STARTS HERE. START BY READING   ---*\n*---     THE ENTIRE CESD AND IDR INFORMATION FROM THE LOAD MODULE. ---*\n*---------------------------------------------------------------------*\nREREAD   DS    0H\n         NC    CHAIN,CHAIN         ANYTHING RETURNED ??\n         BZ    ENDOFJOB            NOPE; QUIT RIGHT HERE\n         #SEG  LINE1,SEPLINE       MOVE IN A SEPARATOR LINE\n         BAS   R8,PUTR             GO PRINT THAT LINE\n         L     R10,CHAIN           LOAD THE ENTRY POINTER\n         MVC   LIST+4(76),8(R10)   COPY ENTRY TO MY LIST AREA\n         MVC   CHAIN,0(R10)        UNCHAIN THAT LINK\n         L     R2,ESDTAB           LOAD ESD TABLE ADDRESSES\n         CALL  GETCESD,(PDS,LIST+12,(2))\n         L     R2,ESDTAB           LOAD TABLE POINTER\n         L     R3,4(,R2)           LOAD 'BYTES-USED' VALUE\n         AR    R3,R2               POINT TO TABLE END\n         ST    R3,ESDEND           SAVE NEW END POINTER\n         LA    R9,LIST+4           LOAD DIRENTRY POINTER\n         USING PDS2,R9             AND BASE THE DSECT\n*---------------------------------------------------------------------*\n*---     CHECK THE MODULE; IF EXECUTABLE, LOAD IT INTO MAIN        ---*\n*---     STORAGE.  THEN SET THE BOUNDARIES OF THE MODULE FOR       ---*\n*---     LATER USE DURING THE EXAMINATION PHASE.  IF THE MODULE    ---*\n*---     ISN'T EXECUTABLE, WE SKIP THE EXAMINATION PHASE. ALSO,    ---*\n*---     IF WE CAN'T LOAD THE MODULE, WE PUT OUT AN ERROR MESSAGE  ---*\n*---     AND AGAIN SKIP THE EXAMINATION PHASE.                     ---*\n*---------------------------------------------------------------------*\n         LA    R7,PDS2NAME(R4)     POINT TO BLOCK END, FOR LATER\n         #SEG  LINE1,=C'   ',1     SEED IN A LEADING BLANK\n         #SEG  LINE1,LIST+4,8      MEMBER NAME TO LINE\n         #SEG  LINE1,=C'   ',3     PAD WITH BLANKS\n         HEXCNVT DWORK,PDS2TTRP,3  'HEX' THE TTR\n         #SEG  LINE1,DWORK,6\n         #SEG  LINE1,=C'   ',2\n         HEXCNVT DWORK,PDS2STOR,3  'HEX' THE MODULE SIZE\n         #SEG  LINE1,DWORK,6\n         #SEG  LINE1,=C'   ',2\n         L     R6,ESDTAB           LOAD POINTER TO ESD TABLE\n         L     R5,ESDEND           LOAD TABLE-END ADDRESS\n         LA    R4,16               LOAD TABLE ENTRY LENGTH\n         BCTR  R5,R0               GLITCH FOR BXLE\n         AL    R6,=F'8'            ACCOUNT FOR HEADER\nGETEP    DS    0H\n         CLI   8(R6),X'07'         'NULL' SECTION ??\n         BE    SKIPEP              YES; SKIP IT\n         TM    8(R6),X'10'         DELETED SECTION ??\n         BO    SKIPEP              YES; SKIP IT\n         CLC   9(3,R6),PDS2EPA     IS THIS THE EPA NAME\n         BE    GOTEP\nSKIPEP   DS    0H\n         BXLE  R6,R4,GETEP\n         #SEG  LINE1,=CL8' ',8\n         B     NOEP\nGOTEP    DS    0H\n         #SEG  LINE1,0(,R6),8      ADD EP NAME TO LINE\nNOEP     DS    0H\n         #SEG  LINE1,=C'   ',2\n         CALL  RDLKDATE,(PDS,LIST+12)\n         ST    R0,XTTR             SAVE THAT DATE\n         UNPK  DWORK,XTTR          INSERT THE ZONES\n         OI    DWORK+7,X'F0'       FORCE LAST ZONE NUMERIC\n         MVC   DWORK+2(2),DWORK+3  MAKE ROOM FOR PERIOD\n         MVI   DWORK+4,C'.'\n         #SEG  LINE1,DWORK+2,6     ADD TO LINE\n         #SEG  LINE1,=C'   ',2\n         MVC   DWORK,=CL8'*NO SSI*'\n         TM    PDS2FTB1,PDS2SSI    IS SSI DATA PRESENT ??\n         BZ    NOSSI               NOPE ---\n         LR    R3,R7               COPY THE POINTER\n         TM    PDS2FTB1,PDSAPFLG   IS APF DATA VALID ??\n         BZ    NOSCTR              NOPE ---\n         SH    R3,=H'2'            BACK UP PAST IT\nNOSCTR   DS    0H\n         SH    R3,=H'4'            BACK TO SSI START\n         MVC   XTTR(4),0(R3)       COPY TO SCRATCH AREA\n         HEXCNVT DWORK,XTTR,4      MAKE IT READABLE\nNOSSI    DS    0H\n         #SEG  LINE1,DWORK,8\n         #SEG  LINE1,=C'   ',2\n         MVC   DWORK,=CL8' '\n         TM    PDS2FTB1,PDSAPFLG   IS APF DATA VALID ??\n         BZ    NOAPF               NOPE ---\n         SH    R7,=H'2'            BACK UP TO APF FLAG START\n         IC    R0,1(,R7)           INSERT THE VALUE\n         ICM   R0,14,=X'000000'    PAD WITH ZEROS\n         CVD   R0,DWORK            CONVERT TO DECIMAL\n         MVC   XTTR,=X'40202020'   EDIT MASK\n         ED    XTTR,DWORK+6\nNOAPF    DS    0H\n         #SEG  LINE1,XTTR+1,3      INSERT INTO LINE\n         #SEG  LINE1,=C'   ',2\n         TM    PDS2FTB1,PDS2PAGA   PAGE ALIGNMENT REQUIRED ??\n         BZ    NAT0                NOPE ---\n         #SEG  LINE1,=C'PAGE,',5\nNAT0     DS    0H\n         TM    PDS2FTB2,PDSLRMOD   RMODE-31 ??\n         BZ    NATA                NOPE ---\n         #SEG  LINE1,=C'RMODE=ANY ',10 YES ---\n         B     NATB                AND CONTINUE\nNATA     DS    0H\n         #SEG  LINE1,=C'RMODE=24 ',9  YES ---\nNATB     DS    0H\n         IC    R4,PDS2FTB2         INSERT THE FLAG BYTE\n         N     R4,=F'3'            TRIM TO JUST AMODE BITS\n         SLL   R4,2                TIMES 4\n         B     *+4(R4)             BRANCH TO DATA INSERT\n         B     NATW                AMODE=24\n         B     NATW                AMODE=24\n         B     NATX                AMODE=31\n         B     NATY                AMODE=ANY\nNATY     DS    0H\n         #SEG  LINE1,=C'AMODE=ANY ',10\n         B     NATZ                AND GO ---\nNATW     DS    0H\n         #SEG  LINE1,=C'AMODE=24 ',9\n         B     NATZ                AND GO ---\nNATX     DS    0H\n         #SEG  LINE1,=C'AMODE=31 ',9\nNATZ     DS    0H\n         IF    RENT,OFF,GOTO=NAT1  REENTRANT ??\n         #SEG  LINE1,=C'RENT ',5\nNAT1     DS    0H\n         IF    REUS,OFF,GOTO=NAT2\n         #SEG  LINE1,=C'REUS ',5\nNAT2     DS    0H\n         IF    OVLY,OFF,GOTO=NAT3\n         #SEG  LINE1,=C'OVLY ',5\nNAT3     DS    0H\n         IF    TEST,OFF,GOTO=NAT4\n         #SEG  LINE1,=C'TEST ',5\nNAT4     DS    0H\n         IF    LOAD,OFF,GOTO=NAT5\n         #SEG  LINE1,=C'OL ',3\nNAT5     DS    0H\n         IF    SCTR,OFF,GOTO=NAT6\n         #SEG  LINE1,=C'SCTR ',5\nNAT6     DS    0H\n         IF    EXEC,ON,GOTO=NAT7\n         #SEG  LINE1,=C'NOTEXEC ',8\nNAT7     DS    0H\n         IF    SNGLBLK,OFF,GOTO=NAT8\n         #SEG  LINE1,=C'1-BLK ',6\nNAT8     DS    0H\n         IF    FLVL,OFF,GOTO=NAT9\n         #SEG  LINE1,=C'DC ',3\nNAT9     DS    0H\n         IF    ORG0,OFF,GOTO=NAT10\n         #SEG  LINE1,=C'ORIG-ZERO ',10\nNAT10    DS    0H\n         IF    EP0,OFF,GOTO=NAT11\n         #SEG  LINE1,=C'EP-ZERO ',8\nNAT11    DS    0H\n         IF    NRLD,OFF,GOTO=NAT12\n         #SEG  LINE1,=C'NO-RLD ',7\nNAT12    DS    0H\n         IF    EDIT,OFF,GOTO=NAT13\n         #SEG  LINE1,=C'NE ',3\nNAT13    DS    0H\n         IF    TSTN,OFF,GOTO=NAT14\n         #SEG  LINE1,=C'SYMS ',5\nNAT14    DS    0H\n         IF    LEF,OFF,GOTO=NAT15\n         #SEG  LINE1,=C'LKED-F ',7\nNAT15    DS    0H\n         IF    REFR,OFF,GOTO=NAT16\n         #SEG  LINE1,=C'REFR ',5\nNAT16    DS    0H\n         #SEG  LINE2,=C'     ',5\n         BAS   R8,PUTR             OUTPUT THE LINE\n         TM    PDS2ATR1,PDS2EXEC   EXECUTABLE ??\n         BZ    BADLOAD             NOPE; SKIP IT\n         MVC   LIST+4(8),0(R9)     COPY FOR A BLDL\n         BLDL  PDS,LIST            REBUILD THE DIRECTORY ENTRY\n         LOAD  DE=LIST+4,DCB=PDS,LOADPT=MODSTART,ERRET=BADLOAD,        X\n               LSEARCH=NO\n         N     R1,=A(X'FFFFFF')    TRIM R1 TO BARE MODULE LENGTH\n         SLL   R1,3                TIMES 8\n         AL    R1,MODSTART         ADD STARTING ADDRESS\n         ST    R1,MODEND           STORE ENDING ADDRESS\n         DROP  R9\n*---------------------------------------------------------------------*\n*---     START OF EXAMINATION PHASE                                ---*\n*---------------------------------------------------------------------*\n*---     LOOP THROUGH THE ESD TABLE, LOOKING AT EACH CSECT IN      ---*\n*---     THE LOAD MODULE.  USING THE MASKS DEFINED AT AREA         ---*\n*---     'MASKS', SEE IF IT'S A COBOL MODULE, WHAT TYPE OF         ---*\n*---     COBOL AND CALL THE APPROPRIATE FORMATTER TO CHECK OUT     ---*\n*---     THE COMPILE OPTIONS.  ALSO IF IT'S COBOL, LOOK THROUGH    ---*\n*---     THE DATA DIVISION FOR THE PANVALET LEVEL STAMP THAT IS    ---*\n*---     PECULIAR TO BOTCC.  IF FOUND, PRINT THAT DATA AS WELL.    ---*\n*---------------------------------------------------------------------*\n         L     R6,ESDTAB           LOAD POINTER TO ESD TABLE\n         L     R5,ESDEND           LOAD TABLE-END ADDRESS\n         LA    R4,16               LOAD TABLE ENTRY LENGTH\n         BCTR  R5,R0               GLITCH FOR BXLE\n         AL    R6,=F'8'            ACCOUNT FOR HEADER\nESDLP    DS    0H\n         TM    8(R6),X'10'         DELETED OR REPLACED ??\n         BO    NEXTESD             YES; SKIP IT\n         NI    8(R6),X'0F'         TRIM MAP/JUNK BYTES\n         CLI   8(R6),0             SECTION DEFINITION ??\n         BE    ESDFORM             YES ---\n         CLI   8(R6),4             PRIVATE CODE ??\n         BE    ESDFORM             YES ---\n         CLI   8(R6),5             COMMON ??\n         BE    ESDFORM             YES ---\n         B     NEXTESD             NOPE; SKIP IT ---\nESDFORM  DS    0H\nSKIPLIB  B     NOSKIP               TURNED OFF FOR 'NOLIB' PARM\n         CLC   0(3,R6),=CL3'ILB'    IS IT A SUPPRESSED NAME\n         BE    NEXTESD               COBOL V2, V3, V4, VS LIBRARY\n         CLC   0(3,R6),=CL3'IGZ'    IS IT A SUPPRESSED NAME\n         BE    NEXTESD               COBOL II LIBRARY\n         CLC   0(3,R6),=CL3'IHO'    IS IT A SUPPRESSED NAME\n         BE    NEXTESD               FORTRAN MOD II LIBRARY\n         CLC   0(3,R6),=CL3'IHC'    IS IT A SUPPRESSED NAME\n         BE    NEXTESD               FORTRAN FREEBIE LIBRARY\n         CLC   0(3,R6),=CL3'IHN'    IS IT A SUPPRESSED NAME\n         BE    NEXTESD               FORTRAN MOD I LIBRARY\n         CLC   0(3,R6),=CL3'IBM'    IS IT A SUPPRESSED NAME\n         BE    NEXTESD               PL/I OPTIMIZER LIBRARY\n         CLC   0(3,R6),=CL3'IHE'    IS IT A SUPPRESSED NAME\n         BE    NEXTESD               PL/I FREEBIE LIBRARY\n         CLC   0(3,R6),=CL3'IHD'    IS IT A SUPPRESSED NAME\n         BE    NEXTESD               COBOL F LIBRARY (ANCIENT)\nNOSKIP   DS    0H\n         #SEG  LINE1,=C'   CS-',6\n         #SEG  LINE1,0(,R6),8\n         #SEG  LINE1,=C'  ',2\n         SR    R7,R7               CLEAR A REGISTER\n         ICM   R7,7,9(R6)          INSERT CSECT OFFSET\n         A     R7,MODSTART         POINT TO ACTUAL MODULE\n         LA    R10,FORMTAB         POINT TO FORMAT TABLE\n         LA    R9,FORMEND          POINT TO TABLE END\n         LA    R8,16               LOAD TABLE ENTRY LENGTH\n         LA    R3,MODWRK\n         #XA   SET31\nFORMLP1  DS    0H\n         LM    R15,R2,0(R10)       LOAD TABLE ENTRIES\n         CLM   R15,7,13(R6)        LONG ENOUGH ??\n         BH    NOMATCH             NOPE ---\n         BCTR  R15,R0\n         EX    R15,COPY1           COPY A SECTION OF CODE\n         EX    R15,AND1            'AND' WITH THE MASK\n         EX    R15,CLC1            AND COMPARE RESULTS\n         BE    FORMAT              MATCHES; GO FORMAT IT\nNOMATCH  DS    0H\n         BXLE  R10,R8,FORMLP1      CONTINUE SEARCHING/COMPARING\n         #SEG  LINE1,=C'NOT COBOL ',10\n         #XA   SET24\n         BAS   R8,PUTR             OUTPUT THE LINE\n         B     NEXTESD             GO DO THE NEXT CSECT\nCOPY1    MVC   0(1,R3),0(R7)       COPY A CHUNK OF CODE\nAND1     NC    0(1,R3),0(R2)       CLEAR VARIABLE STUFF\nCLC1     CLC   0(1,R3),0(R1)       AND COMPARE WITH 'MASK'\nFORMAT   DS    0H\n         LR    R15,R0              COPY SUBROUTINE ADDRESS\n         LTR   R15,R15             WAS SYMBOL RESOLVED ??\n         BZ    NOCALL              NOPE ---\n         SR    R2,R2               CLEAR PARM REGISTER\n         ICM   R2,7,9(R6)          INSERT CSECT OFFSET\n         AL    R2,MODSTART         POINT TO ACTUAL SECTION\n         LR    R1,R2               COPY ENTRY ADDRESS\n         O     R15,=X'80000000'\n         BASSM R14,R15             CALL THE FORMATTING ROUTINE\nNOCALL   DS    0H\n         #XA   SET24\n         BAS   R8,PUTR             OUTPUT THE LINES WE BUILT\nNEXTESD  DS    0H\n         BXLE  R6,R4,ESDLP\n         DELETE EPLOC=LIST+4\n         B     REREAD\nENDOFJOB DS    0H\n         FREEMAIN R,SP=40\n         CLOSE (PRNT,,PDS)\n         FREEPOOL PRNT\n         L     R13,4(,R13)         LOAD BACK S.A. POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0\n         BR    R14\nBADLOAD  DS    0H\n         #SEG  LINE1,=CL16' ',16\n         #SEG  LINE1,NOLOAD\n         BAS   R8,PUTR             OUTPUT THE ERROR MESSAGE\n         B     REREAD              GO SKIP THE PROCESSING\n         EJECT\n*---------------------------------------------------------------------*\n*---     THIS LITTLE LOCAL SUBROUTINE DOES ALL PRINTING AND        ---*\n*---     PAGINATION FOR THE MODLIST UTILITY.  IT IS CALLED VIA     ---*\n*---     BAS ON R8 AND RESETS ADDRESSING MODE DURING RETURN.       ---*\n*---                                                               ---*\n*---     PARAMETERS:  THERE IS NO PARM LIST. RATHER, THE CONTENTS  ---*\n*---     OF LINE1-LINE10 ARE EXAMINED.  IF NON-EMPTY, THE LINE IS  ---*\n*---     PRINTED AND CLEARED.  PAGE HEADER LINES ARE NOT COUNTED   ---*\n*---     AS PART OF THE PAGE SIZE, SO BEWARE OF CHANGES HERE.      ---*\n*---     ALSO, THE DATA LENGTH OF EACH LINE IS NOT CHECKED.        ---*\n*---------------------------------------------------------------------*\nPUTR     DS    0H\n         STM   R14,R12,PUTSAVE     SAVE ENTRY REGISTERS\n         LA    R6,LINE1            POINT TO LOOP START ADDRESS\n         LA    R4,LINE2            POINT TO SECOND LINE\n         SR    R4,R6               COMPUTE LINE LENGTH\n         LA    R5,LASTLINE         POINT TO LOOP END\nPUT1     DS    0H\n         CLC   0(2,R6),=H'0'       PRINT THIS LINE ??\n         BE    PUT6                NOPE ---\n         CLI   4(R6),C' '          SINGLE SPACE ??\n         BE    PUT4                YES ---\n         CLI   4(R6),C'0'          DOUBLE SPACE ??\n         BE    PUT3                YES ---\n         CLI   4(R6),C'-'          TRIPLE SPACE !!\n         BE    PUT2                YES ---\n         CLI   4(R6),C'+'          SUPPRESS SPACE ??\n         BE    PUT5                YES ---\n         MVI   4(R6),C' '          REPLACE INVALID CC WITH BLANK\n         B     PUT4                TREAT AS SINGLE SPACE\nPUT2     DS    0H\n         AP    LINECNT,=P'1'       ADD ONE TO LINE COUNT\nPUT3     DS    0H\n         AP    LINECNT,=P'1'       ADD ONE TO LINE COUNT\nPUT4     DS    0H\n         AP    LINECNT,=P'1'       ADD ONE TO LINE COUNT\n         CP    LINECNT,PAGESIZE    OFF PAGE END ??\n         BL    PUT5                NOPE; JUST PRINT THE LINE\n         ZAP   LINECNT,=P'1'       RESET THE COUNTER\n         PUT   PRNT,HDR1           OUTPUT THE PAGE HEADER(S)\n         PUT   PRNT,HDR1A          OUTPUT THE PAGE HEADER(S)\n         PUT   PRNT,HDR2           OUTPUT THE PAGE HEADER(S)\n         PUT   PRNT,HDR3           OUTPUT THE PAGE HEADER(S)\n         PUT   PRNT,HDR4           OUTPUT THE PAGE HEADER(S)\n         PUT   PRNT,HDR5           OUTPUT THE PAGE HEADER(S)\nPUT5     DS    0H\n         PUT   PRNT,4(,R6)         OUTPUT THE LINE\n         XC    0(2,R6),0(R6)       RESET 'CURRENT LENGTH'\n         MVI   4(R6),C' '\n         MVC   5(254,R6),4(R6)\nPUT6     DS    0H\n         BXLE  R6,R4,PUT1          LOOP FOR ALL THE LINES\n         LM    R14,R12,PUTSAVE     RESTORE REGISTERS\n         BSM   R0,R8               AND RETURN, RESTORING AMODE\nPUTSAVE  DS    15F\nHDR1     DC    CL255'1 LOAD MODULE/CSECT ATTRIBUTE REPORT'\nHDR1A    DS    0CL255\n         DC    C'    DATASET NAME = '\nDSNAME   DC    CL44' '\n         DC    CL200' '\nHDR2     DC    CL255' '\nHDR3     DC    C'                             '\n         DC    C'ENTRY     LINK'\n         DC    CL255' '\nHDR4     DC    C'  MEMBER      '\n         DC    C'TTR    '\n         DC    C'LENGTH  '\n         DC    C'POINT     '\n         DC    C'DATE   '\n         DC    C'SSI DATA  APF  LKED ATTRIBUTES'\n         DC    CL255' '\nHDR5     DC    CL255' '\nSEPLINE  DS    0CL255\n         DC    255C'-'\nLINECNT  DC    P'99'\nPAGESIZE DC    P'50'\n         EJECT\nDWORK    DS    D\n         DC    F'0'\nXTTR     DS    F\n         DC    F'0'\nNOLOAD   DC    CL35'CANNOT BE LOADED INTO MAIN STORAGE.'\nDATALEN  DC    A(2048*1024)\nMODSTART DC    A(0)                LOAD MODULE START ADDRESS\nMODEND   DC    A(0)                LOAD MODULE END ADDRESS + 1\nMODE31   DC    X'80000000'\nDDN      DC    CL8'SYSLIB'\nLOWSIZE  DC    A(1024)             MINSIZE\n         DC    X'00FFFFFF'         MAXSIZE\nLOWAREA  DC    2F'0'               ADDR. AND LENGTH RETURNED\nCHAIN    DC    F'0'\n         DC    C'ESD TABLE POINTERS ---->'\nESDTAB   DC    F'-1'\nESDEND   DC    F'-1'\nLIST     DC    AL2(1,80)\n         DC    CL8'MISSING '\n         DC    CL80' '\nPDS      DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB,EXLST=JFCBL\nJFCBL    DS    0F\n         DC    X'07',AL3(JFCB)\n         DC    X'80000000'\nJFCB     DS    22D\nPRNT     DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT\n         DC    C' '\nLINE     DC    CL255' '\n         ENTRY LINE1,LINE2,LINE3,LINE4,LINE5\nLINE1    DC    H'0,0'\nLINE1D   DC    CL255' '\nLINE2    DC    H'0,0'\nLINE2D   DC    CL255' '\nLINE3    DC    H'0,0'\nLINE3D   DC    CL255' '\nLINE4    DC    H'0,0'\nLINE4D   DC    CL255' '\nLINE5    DC    H'0,0'\nLINE5D   DC    CL255' '\nLINE6    DC    H'0,0'\nLINE6D   DC    CL255' '\nLINE7    DC    H'0,0'\nLINE7D   DC    CL255' '\nLINE8    DC    H'0,0'\nLINE8D   DC    CL255' '\nLINE9    DC    H'0,0'\nLINE9D   DC    CL255' '\nLASTLINE DS    0H\nLINE10   DC    H'0,0'\nLINE10D  DC    CL255' '\n         LTORG\n*---------------------------------------------------------------------*\n*---     ENTRY POINTS OF THE VARIOUS OPTION-FORMATTING ROUTINES    ---*\n*---                                                               ---*\n*---     THE FORMATTING OF SECONDARY ENTRY DATA IS SIMPLY TO       ---*\n*---     LOCATE THE MAIN ENTRY POINT, USING THE ENTRY DATA,        ---*\n*---     AND BRANCH TO THE MAIN ENTRY-POINT HANDLER.               ---*\n*---------------------------------------------------------------------*\n         WXTRN FRMSMEP       FORMAT VSCOBOL MAIN ENTRY POINT\n         WXTRN FRM2MEP       FORMAT VSCOBOL II MAIN ENTRY POINT\n         WXTRN FRM4MEP       FORMAT ANS4 COBOL MAIN ENTRY POINT\nFORMTAB  DC    A(44,FRM4MEP,ANS4MEP,ANS4MEPM)\n         DC    A(44,FRMSMEP,CBVSMEP,CBVSMEPM)\nFORMEND  DC    A(126,FRM2MEP,CBL2MEP,CBL2MEPM)\nMODWRK   DC    256X'00'\n*---------------------------------------------------------------------*\n*---     THE SOLE PURPOSE OF THESE CONSTANTS IS TO DETERMINE IF    ---*\n*---     THE ENTRY POINT IS IN A MODULE CREATED BY THE ANS4        ---*\n*---     COBOL COMPILER, THE VS COBOL 2.4 COMPILER OR THE VS       ---*\n*---     COBOL II COMPILER.  TO USE THESE MASKS, COPY THE DATA     ---*\n*---     FROM THE ENTRY POINT ADDRESS FOR THE LENGTH OF THE        ---*\n*---     MASK TO A WORK AREA.   THEN 'AND' THE XXXXXXXM MASK       ---*\n*---     WITH THAT WORD AREA AND COMPARE TO THE XXXXXXX MASK.      ---*\n*---     IF EQUAL, YOU'VE GOT A MATCH FOR THE COMPILER TYPE.       ---*\n*---------------------------------------------------------------------*\n*---     ANS4 COBOL COMPILED MAIN ENTRY POINT                      ---*\n*---------------------------------------------------------------------*\nANS4MEP  DC    XL8'90ECD00C185D05F0'\n         DC    XL8'4580F01000000000'\n         DC    XL8'00000000C1D5E2F4'\n         DC    XL8'0700989FF02407FF'\n         DC    XL8'9602103407FE41F0'\n         DC    XL4'000107FE'\nANS4MEPM DC    XL8'FFFFFFFFFFFFFFFF'\n         DC    XL8'FFFFFFFF00000000'\n         DC    XL8'00000000FFFFFFFF'\n         DC    XL8'FFFFFFFFFFFFFFFF'\n         DC    XL8'FFFFFFFFFFFFFFFF'\n         DC    XL4'FFFFFFFF'\n*---------------------------------------------------------------------*\n*---     VS COBOL 2.4 COMPILED MAIN ENTRY POINT                    ---*\n*---------------------------------------------------------------------*\nCBVSMEP  DC    X'90ECD00C185D05F0'\n         DC    X'4580F01040404040'\n         DC    X'40404040E5E2D9F1'\n         DC    X'0700989FF02407FF'\n         DC    X'9602103407FE41F0'\n         DC    X'000107FE'\nCBVSMEPM DC    X'FFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFF40404040'\n         DC    X'40404040FFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFFFFFFFFFF'\n         DC    X'FFFFFFFF'\n*---------------------------------------------------------------------*\n*---     VS COBOL II COMPILED MAIN ENTRY POINT                     ---*\n*---------------------------------------------------------------------*\nCBL2MEP  DC    X'47F0F07023404040404040404040C3F2' +00\n         DC    X'40F04BF04BF040F0F061F0F061F0F040' +10\n         DC    X'F0F04BF0F04BF0F00000000000000000' +20\n         DC    X'00000000000000000000000000000000' +30\n         DC    X'00000000000000000000000000000000' +40\n         DC    X'00000000000000000000000000000000' +50\n         DC    X'00000000000000000000000000000000' +60\n         DC    X'90ECD00C5810F02898EFF06807FF'     +70\nCBL2MEPM DC    X'FFFFFFFFFF4040404040404040FFFFFF' +00\n         DC    X'FFF0FFF0FFF0FFF0F0FFF0F0FFF0F040' +10\n         DC    X'F0F0FFF0F0FFF0F00000000000000000' +20\n         DC    X'00000000000000000000000000000000' +30\n         DC    X'00000000000000000000000000000000' +40\n         DC    X'00000000000000000000000000000000' +50\n         DC    X'00000000000000000000000000000000' +60\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFF'     +70\n*---------------------------------------------------------------------*\n*---     ESD RECORD WITHIN A LOAD MODULE                           ---*\n*---                                                               ---*\n*---     CREATED BY: LINKAGE EDITOR                                ---*\n*---                                                               ---*\n*---     ADDRESS: N/A                                              ---*\n*---                                                               ---*\n*---     LENGTH: 24-248 BYTES                                      ---*\n*---------------------------------------------------------------------*\nESDREC   DSECT\nESDRID   DS    XL1      RECORD ID (X'20')\nESDRFLG  DS    XL1      SPECIAL FLAG FIELD\n*        0... ....  BYTE 12 OF ESD DATA ITEM\n*                   CONTAINS SEGMENT NUMBERS\n*        1... ....  BYTE 12 OF ESD DATA ITEM\n*                   CONTAINS RSECT/RMODE/AMODE FLAGS\n         DS    XL2      UNUSED BYTES\nESDFID   DS    H        ESDID OF FIRST ESD DATA ITEM\nESDRCNT  DS    H        BYTE COUNT OF ESD DATA\nESDDATA  DS    CL240    UP TO 240 BYTES OF ESD DATA\n*---------------------------------------------------------------------*\n*---     ESD DATA ITEM WITHIN THE ESD RECORD                       ---*\n*---                                                               ---*\n*---     CREATED BY: LINKAGE EDITOR                                ---*\n*---                                                               ---*\n*---     ADDRESS: N/A                                              ---*\n*---                                                               ---*\n*---     LENGTH: 16 BYTES                                          ---*\n*---------------------------------------------------------------------*\nESDMAP   DSECT\nESDNAME  DS    CL8      SYMBOL NAME\nESDTYPE  DS    BL1      ESD TYPE\n*        .... 0000  SECTION DEFINITION (SD)\n*        .... 0011  LABEL REFERENCE (LR)\n*        .... 0100  PRIVATE CODE (PC)\n*        .... 0101  COMMON (CM)\n*        .... 0110  PESUDO REGISTER (PR)\n*        .... 0111  NULL\n*        .... 0010  EXTERNAL REFERENCE (ER)\n*        .... 1010  WEAK EXTERNAL REFERENCE (WX)\n*        ...1 .100  PRIVATE CODE MARKED DELETE\n*                   ($SEGTAB / $ENTAB SECTIONS)\n*        ...1 ....  DELETE FLAG\n*        ...1 ....  ALSO REPLACE FLAG\n*        ..1. ....  INSERT FLAG\n*        .1.. ....  CHAIN FLAG\n*        1... ....  MAP FLAG\nESDADDR  DS    AL3      LINKAGE-EDITOR ASSIGNED ADDRESS\n*        ZERO IF TYPE = ER,WX OR NULL\nESDFLG1  DS    BL1      MISC. FLAGS\n*        ZERO FOR ER, WX OR NULL\n*        SEGMENT NUMBER, IF BYTE 1, BIT 0 IS 0\n*        AMODE/RMODE/RSECT FLAGS, IF BYTE 1, BIT 0 IS 1\n*        XXXX ....  NOT USED\n*        .... 1...  READ-ONLY SECTION\n*        .... 0...  NOT READ-ONLY SECTION\n*        .... .0..  RMODE = 24\n*        .... .1..  RMODE = ANY\n*        .... ..00  AMODE = 24\n*        .... ..01  AMODE = 24\n*        .... ..10  AMODE = 31\n*        .... ..11  AMODE = ANY\n*        ALIGNMENT FACTOR, IF TYPE = PR\n*        0000 0111  DOUBLEWORD ALIGNMENT\n*        0000 0011  FULLWORD ALIGNMENT\n*        0000 0001  HALFWORD ALIGNMENT\n*        0000 0000  BYTE ALIGNMENT\nESDIDF   DS    AL3      ANOTHER MULTI-USE FIELD\n*        LENGTH, IF TYPE IS SD,PD,CM OR PR\n*        ESDID, IF TYPE = LR\n*        ZERO, IF TYPE IS WX,NULL OR ER (X'06' INDICATES NEVERCALL)\n         IHAPDS PDSBLDL=NO\n         END\nFRMSMEP  CSECT\nFRMSMEP  AMODE 31\nFRMSMEP  RMODE 24\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         B     12(,R15)\n         DC    AL1(7),CL7'FRMSMEP' CSECT IDENTIFIER\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         BAS   R2,92(,R15)\n         USING *,R13\n         DS    18F\n         XC    0(72,R2),0(R2)\n         ST    R2,8(,R13)\n         ST    R13,4(,R2)\n         LR    R13,R2\n         LR    R12,R1              COPY INPUT POINTER\n         USING COBINIT,R12         AND BASE ITS DSECT\n*\n*        FIRST LOOK FOR IDENTIFIER WITHIN THE INITIALIZATION CODE\n*\nMAINLINE DS    0H\n         LA    R10,LINETAB         POINT TO OUTPUT LINE TABLE\n         L     R11,0(,R10)         POINT TO FIRST OUTPUT LINE\n         #SEG  0(,R11),CBESIGID\n         #SEG  0(,R11),BLANKS,2\n         #SEG  0(,R11),CBECOMP     COMPILER ID\n         #SEG  0(,R11),BLANKS,8\n         #SEG  0(,R11),CBECDATE     COMPILE DATE\n         #SEG  0(,R11),BLANKS,2\n         #SEG  0(,R11),CBECTIME     COMPILE TIME\n         #SEG  0(,R11),BLANKS,2\n         L     R5,CBETGT           GET TASK GLOBAL TABLE POINTER\n         CLC   KSYSOUT,X'1BC'(R5)  CHECK FOR GOOD TGT\n         BNE   NOTTGT              GOT PROBLEMS UNDERSTANDING\n         TM    72(R5),X'10'        MAIN PGM ??\n         BNO   NB1                 NOPE ---\n         #SEG  0(,R11),KMAIN,NOFIT=NEWLINE\nNB1      DS    0H\n         TM    72(R5),X'08'        SYMDUMP ??\n         BNO   NB2                 NOPE ---\n         #SEG  0(,R11),KSYMD,NOFIT=NEWLINE\nNB2      DS    0H\n         TM    72(R5),X'04'        FLOW ??\n         BNO   NB3                 NOPE ---\n         #SEG  0(,R11),KFLOW,NOFIT=NEWLINE\nNB3      DS    0H\n         TM    72(R5),X'02'        STATE ??\n         BNO   NB4                 NOPE ---\n         #SEG  0(,R11),KSTATE,NOFIT=NEWLINE\nNB4      DS    0H\n         TM    72(R5),X'01'        OPTIMIZE ??\n         BNO   NB5                 NOPE ---\n         #SEG  0(,R11),KOPT,NOFIT=NEWLINE\nNB5      DS    0H\n         TM    73(R5),X'10'        TEST ??\n         BNO   NB6                 NOPE ---\n         #SEG  0(,R11),KTEST,NOFIT=NEWLINE\nNB6      DS    0H\n         TM    74(R5),X'80'        RES ??\n         BO    NB8                 NOPE ---\n         #SEG  0(,R11),KRES,NOFIT=NEWLINE\nNB8      DS    0H\n         TM    74(R5),X'40'        ENDJOB ??\n         BNO   NB9                 NOPE ---\n         #SEG  0(,R11),KENDJOB,NOFIT=NEWLINE\nNB9      DS    0H\n         TM    74(R5),X'20'        OBJ370 ??\n         BNO   NB10                NOPE ---\n         #SEG  0(,R11),KOBJ370,NOFIT=NEWLINE\nNB10     DS    0H\n         TM    74(R5),X'08'        COUNT ??\n         BNO   NB11                NOPE ---\n         #SEG  0(,R11),KCOUNT,NOFIT=NEWLINE\nNB11     DS    0H\n         TM    74(R5),X'04'        TRACE VERB PRESENT ??\n         BNO   NB12                NOPE ---\n         #SEG  0(,R11),KTRACE,NOFIT=NEWLINE\nNB12     DS    0H\n         LA    R10,4(,R10)\n         L     R11,0(,R10)         POINT TO NEXT PRINT LINE\n         #SEG  0(,R11),BLANKS\n         #SEG  0(,R11),KPAN\n         LH    R8,0(,R11)          LOAD LINE HEADER\n         LA    R8,4(R8,R11)        POINT TO, OUTPUT AREA\n          CALL  GETSTAMP,((12),(5),(8)) GO LOCATE THE TIME STAMP\n         LTR   R15,R15             WAS IT FOUND ??\n         BZ    DONEFMT             YES ---\n         #SEG  0(,R11),KNOPAN\nDONEFMT  DS    0H\n         L     R13,4(,R13)         LOAD BACK POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ZERO RETURN CODE\n         BSM   R0,R14              RETURN TO CALLER\nNEWLINE  DS    0H\n         LA    R10,4(,R10)         POINT TO NEXT LINE ENTRY\n         L     R11,0(,R10)         POINT TI LINE AREA\n         XC    0(2,R11),0(R11)     'CLEAR' IT OUT\n         #SEG  0(,R11),BLANKS      LEADING BLANK STUFF\n         BR    R9                  AND RETURN TO RE-SEG\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DC    H'0'\n         #SEG  0(,R11),KNOTGT\n         B     DONEFMT\nKSYSOUT  DC    CL8'SYSOUT'\nKMAIN    DC    CL5'MAIN '\nKSYMD    DC    CL8'SYMDUMP '\nKFLOW    DC    CL5'FLOW '\nKSTATE   DC    CL6'STATE '\nKOPT     DC    CL9'OPTIMIZE '\nKTEST    DC    CL5'TEST '\nKRES     DC    CL4'RES '\nKENDJOB  DC    CL7'ENDJOB '\nKOBJ370  DC    CL7'OBJ370 '\nKCOUNT   DC    CL6'COUNT '\nKTRACE   DC    CL19'TRACE-VERB-PRESENT '\nKPAN     DC    CL11'PAN STAMP:'\nKNOPAN   DC    CL26'NO PANVALET STAMP FOUND.'\nKNOTGT   DC    CL16'NO TGT FOUND.'\nLINETAB  DC    V(LINE1)\n         DC    V(LINE2)\n         DC    V(LINE3)\n         DC    V(LINE4)\n         DC    V(LINE5)\nBLANKS   DC    CL16' '\n         LTORG\n*---------------------------------------------------------------------*\n*---     THIS DSECT DESCRIBES THE PARTS OF THE INITIALIZATION CODE ---*\n*---     THAT WE ARE MOST INTERESTED IN.                           ---*\n*---------------------------------------------------------------------*\nCOBINIT  DSECT\nCBES     DS    3F      THREE WORDS OF CODE\nCBESIGID DS    CL8     PROGRAM NAME\nCBECOMP  DS    CL4     COMPILER IDENTIFIER\n         ORG   COBINIT+X'3C'\nCBETGT   DS    A       TGT ADDRESS\n         ORG   COBINIT+X'88'\nCBECTIME DS    CL8     COMPILE TIME\nCBECDATE DS    CL12    COMPILE DATE\n         ORG\nVSTGT    DSECT\n         ORG   VSTGT+X'48'\nVSTGTOPT DS    XL4     COMPILER OPTIONS BYTES\n         ORG   VSTGT+X'1BC'\nVSTGTDD  DS    CL8    'SYSOUT  ' CONSTANT\n         ORG   VSTGT+X'1C8'\nVSTGTWS  DS    A      ADDRESS OF WORKING STORAGE\n         ORG\n         END\nFRM2MEP  CSECT\nFRM2MEP  AMODE 31\nFRM2MEP  RMODE 24\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         PRINT ON,NOGEN\nCBLINF1  $DSW  ADV,APOST,DATA31,DECK,DUMP,DYNAM,FASTSRT,FDUMP,         X\n               TYPE=NODATA\nCBLINF2  $DSW  LIB,LIST,MAP,NUM,OBJ,OFFSET,OPTIMIZE,DDNAME,            X\n               TYPE=NODATA\nCBLINF3  $DSW  PFDSGN,RENT,RES,SEQUENCE,SIZEMAX,SOURCE,SSRANGE,        X\n               TERM,TYPE=NODATA\nCBLINF4  $DSW  TEST,TRUNC,URSVWD,VBREF,XREF,ZWB,NAME,CMPR2,            X\n               TYPE=NODATA\nCBLINF5  $DSW  NUMPROCM,NUMCLASS,DBCS,AWO,TRUNCBIN,TYPE=NODATA\n         PRINT ON,GEN,NODATA\n         B     12(,R15)\n         DC    AL1(7),CL7'FRM2MEP' CSECT IDENTIFIER\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         BAS   R2,92(,R15)\n         USING *,R13\n         DS    18F\n         XC    0(72,R2),0(R2)\n         ST    R2,8(,R13)\n         ST    R13,4(,R2)\n         LR    R13,R2\n         LR    R12,R1              COPY INPUT POINTER\n         USING COBINIT,R12         AND BASE ITS DSECT\n*\n*        FIRST LOOK FOR IDENTIFIER WITHIN THE INITIALIZATION CODE\n*\nMAINLINE DS    0H\n         LA    R10,LINETAB         POINT TO OUTPUT LINE TABLE\n         L     R11,0(,R10)         POINT TO FIRST OUTPUT LINE\n         #SEG  0(,R11),CBLSIGID\n         #SEG  0(,R11),BLANKS,2\n         #SEG  0(,R11),CBLCOMP      COMPILER ID\n         #SEG  0(,R11),BLANKS,2\n         #SEG  0(,R11),CBLVRM       COMPILER VERSION/RELEASE/MOD\n         #SEG  0(,R11),BLANKS,2\n         #SEG  0(,R11),CBLDATE      COMPILE DATE\n         #SEG  0(,R11),BLANKS,3\n         #SEG  0(,R11),CBLTIME      COMPILE TIME\n         #SEG  0(,R11),BLANKS,2\n         IF    ADV,OFF,GOTO=OPT1\n         #SEG  0(,R11),KADV,NOFIT=NEWLINE\nOPT1     DS    0H\n         IF    DATA31,OFF,GOTO=OPT2A\n         #SEG  0(,R11),KDATA31,NOFIT=NEWLINE\n         B     OPT2B\nOPT2A    DS    0H\n         #SEG  0(,R11),KDATA24,NOFIT=NEWLINE\nOPT2B    DS    0H\n         IF    DYNAM,OFF,GOTO=OPT6A\n         #SEG  0(,R11),KDYNAM,NOFIT=NEWLINE\nOPT6A    DS    0H\n         IF    FASTSRT,OFF,GOTO=OPT7A\n         #SEG  0(,R11),KFASTSRT,NOFIT=NEWLINE\nOPT7A    DS    0H\n         IF    FDUMP,OFF,GOTO=OPT8A\n         #SEG  0(,R11),KFDUMP,NOFIT=NEWLINE\nOPT8A    DS    0H\n         IF    OPTIMIZE,OFF,GOTO=OPT15A\n         #SEG  0(,R11),KOPT,NOFIT=NEWLINE\nOPT15A   DS    0H\n         IF    DDNAME,OFF,GOTO=OPT16A\n         #SEG  0(,R11),KDDNAME,NOFIT=NEWLINE\nOPT16A   DS    0H\n         IF    PFDSGN,OFF,GOTO=OPT17A\n         #SEG  0(,R11),KPFDSGN,NOFIT=NEWLINE\nOPT17A   DS    0H\n         IF    RENT,OFF,GOTO=OPT18A\n         #SEG  0(,R11),KRENT,NOFIT=NEWLINE\nOPT18A   DS    0H\n         IF    RES,OFF,GOTO=OPT19A\n         #SEG  0(,R11),KRES,NOFIT=NEWLINE\nOPT19A   DS    0H\n         IF    SSRANGE,OFF,GOTO=OPT23A\n         #SEG  0(,R11),KSSRANGE,NOFIT=NEWLINE\nOPT23A   DS    0H\n         IF    TEST,OFF,GOTO=OPT25A\n         #SEG  0(,R11),KTEST,NOFIT=NEWLINE\nOPT25A   DS    0H\n         IF    TRUNC,OFF,GOTO=OPT26A\n         #SEG  0(,R11),KTRUNC,NOFIT=NEWLINE\nOPT26A   DS    0H\n         IF    ZWB,OFF,GOTO=OPT30A\n         #SEG  0(,R11),KZWB,NOFIT=NEWLINE\nOPT30A   DS    0H\n         IF    CMPR2,OFF,GOTO=OPT32A\n         #SEG  0(,R11),KCMPR2,NOFIT=NEWLINE\nOPT32A   DS    0H\n         IF    NUMPROCM,OFF,GOTO=OPT33A\n         #SEG  0(,R11),KNUMPR,NOFIT=NEWLINE\nOPT33A   DS    0H\n         IF    NUMCLASS,OFF,GOTO=OPT34A\n         #SEG  0(,R11),KNUMC,NOFIT=NEWLINE\nOPT34A   DS    0H\n         IF    DBCS,OFF,GOTO=OPT35A\n         #SEG  0(,R11),KDBCS,NOFIT=NEWLINE\nOPT35A   DS    0H\n         IF    AWO,OFF,GOTO=OPT36A\n         #SEG  0(,R11),KAWO,NOFIT=NEWLINE\nOPT36A   DS    0H\n         IF    TRUNCBIN,OFF,GOTO=OPT37A\n         #SEG  0(,R11),KTRUNCB,NOFIT=NEWLINE\nOPT37A   DS    0H\n         LA    R10,4(,R10)\n         L     R11,0(,R10)         POINT TO NEXT PRINT LINE\n         #SEG  0(,R11),BLANKS\n         #SEG  0(,R11),KSTAMP\n         LH    R8,0(,R11)          LOAD LINE HEADER\n         LA    R8,4(R8,R11)        POINT TO, OUTPUT AREA\n         L     R2,X'05C'(,R12)     LOAD TGT ADDRESS\n          CALL  GETSTAMP,((12),(2),(8)) GO LOCATE THE TIME STAMP\n         LTR   R15,R15             WAS IT FOUND ??\n         BZ    DONEFMT             YES ---\n         #SEG  0(,R11),KNOPAN\nDONEFMT  DS    0H\n         L     R13,4(,R13)         LOAD BACK POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ZERO RETURN CODE\n         BSM   R0,R14              RETURN TO CALLER\nNEWLINE  DS    0H\n         LA    R10,4(,R10)         POINT TO NEXT LINE ENTRY\n         L     R11,0(,R10)         POINT TI LINE AREA\n         XC    0(2,R11),0(R11)     'CLEAR' IT OUT\n         #SEG  0(,R11),BLANKS      LEADING BLANK STUFF\n         BR    R9                  AND RETURN TO RE-SEG\nKADV     DC    CL4'ADV'\nKAWO     DC    CL4'AWO' ?????????\nKRES     DC    CL4'RES'\nKZWB     DC    CL4'ZWB'\nKDBCS    DC    CL5'DBCS'\nKRENT    DC    CL5'RENT'\nKTEST    DC    CL5'TEST'\nKCMPR2   DC    CL6'CMPR2'\nKDYNAM   DC    CL6'DYNAM'\nKFDUMP   DC    CL6'FDUMP'\nKTRUNC   DC    CL6'TRUNC'\nKDDNAME  DC    CL7'DDNAME'  ?????????\nKPFDSGN  DC    CL7'PFDSGN'\nKFASTSRT DC    CL8'FASTSRT'\nKSSRANGE DC    CL8'SSRANGE'\nKDATA24  DC    CL9'DATA(24)'\nKDATA31  DC    CL9'DATA(31)'\nKNUMC    DC    CL9'NUMCLASS' ????????\nKOPT     DC    CL9'OPTIMIZE'\nKSTAMP   DC    CL11'PAN STAMP:'\nKTRUNCB  DC    CL11'TRUNC(BIN)'\nKNUMPR   DC    CL13'NUMPROC(MIG)'  ????????\nKNOPAN   DC    CL24'NO PANVALET STAMP FOUND.'\nLINETAB  DC    V(LINE1)\n         DC    V(LINE2)\n         DC    V(LINE3)\n         DC    V(LINE4)\n         DC    V(LINE5)\nBLANKS   DC    CL16' '\n         LTORG\n*---------------------------------------------------------------------*\n*---     THIS DSECT DESCRIBES THE PARTS OF THE INITIALIZATION CODE ---*\n*---     THAT WE ARE MOST INTERESTED IN.                           ---*\n*---------------------------------------------------------------------*\nCOBINIT  DSECT\nCBLS     DS    F       '47XXXXXX' INSTRUCTION\nCBLSIGLN DS    FL1     SIGNATURE LENGTH\nCBLSIGID DS    CL8     PROGRAM NAME\nCBLCOMP  DS    CL4     COMPILER IDENTIFIER\nCBLVRM   DS    CL6     VERSION/RELEASE/MOD\nCBLDATE  DS    CL9     DATE COMPILED\nCBLTIME  DS    CL8     TIME COMPILED\nCBLPRMS  DS    A       INIT. RTN PARMS\nCBLINF1  DS    XL1     INFO BYTES\nCBLINF2  DS    XL1     INFO BYTES\nCBLINF3  DS    XL1     INFO BYTES\nCBLINF4  DS    XL1     INFO BYTES\nCBLINF5  DS    XL1     INFO BYTES\nCBLINF6  DS    XL1     INFO BYTES\nCBLINF7  DS    XL1     INFO BYTES\nCBLINF8  DS    XL1     INFO BYTES\nCBLINF9  DS    XL1     INFO BYTES\nCBLINF10 DS    XL1     INFO BYTES\nCBLINF11 DS    XL1     INFO BYTES\nCBLINF12 DS    XL1     INFO BYTES\nCBLINF13 DS    XL1     INFO BYTES\nCBLINF14 DS    XL1     INFO BYTES\nCBLINF15 DS    XL1     INFO BYTES\nCBLINF16 DS    XL1     INFO BYTES\nCBLINF17 DS    XL1     INFO BYTES\nCBLINF18 DS    XL1     INFO BYTES\nCBLINF19 DS    XL1     INFO BYTES\nCBLINF20 DS    XL1     INFO BYTES\nCBLINF21 DS    XL1     INFO BYTES\nCBLINF22 DS    XL1     INFO BYTES\nCBLINF23 DS    XL1     INFO BYTES\nCBLRS1   DS    XL1     RESERVED BYTE\nCBL#DATA DS    F       # OF DATA DIV. STATEMENTS\nCBL#PROC DS    F       # OF PROC. DIV. STATEMENTS\nCBLINF24 DS    XL1     INFO BYTES\nCBLINF25 DS    XL1     INFO BYTES\nCBLRS2   DS    XL2     RESERVED\nCBLLINFO DS    CL4     USER LEVEL INFO (LVINFO)\nCBLEPA   DS    A       MAIN ENTRY POINT ADDRESS\nCBLPGT   DS    A       PGT ADDRESS\nCBLTGT   DS    A       TGT ADDRESS\nCBLEPNAM DS    A       ADDRESS OF EP NAME\nCBLEPCUR DS    A       CURRENT EP ADDRESS\nCBLSTRT  DS    A       ADDRESS OF PROCEDURE CODE\nCBLINIT  DS    A       ADDRESS OF INIT ROUTINE\nCBLSTM   DC    XL14'90ECD00C5810F02898EFF06807FF'\n         END\nFRM4MEP  CSECT\nFRM4MEP  AMODE 31\nFRM4MEP  RMODE 24\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         B     12(,R15)\n         DC    AL1(7),CL7'FRM4MEP' CSECT IDENTIFIER\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         BAS   R2,92(,R15)\n         USING *,R13\n         DS    18F\n         XC    0(72,R2),0(R2)\n         ST    R2,8(,R13)\n         ST    R13,4(,R2)\n         LR    R13,R2\n         LR    R12,R1              COPY INPUT POINTER\n         USING COBINIT,R12            AND BASE ITS DSECT\n*\n*        FIRST LOOK FOR IDENTIFIER WITHIN THE INITIALIZATION CODE\n*\nMAINLINE DS    0H\n         LA    R10,LINETAB         POINT TO OUTPUT LINE TABLE\n         L     R11,0(,R10)         POINT TO FIRST OUTPUT LINE\n         #SEG  0(,R11),CBESIGID\n         #SEG  0(,R11),BLANKS,2\n         #SEG  0(,R11),CBECOMP     COMPILER ID\n         #SEG  0(,R11),BLANKS,8\n         #SEG  0(,R11),BLANKS,12    COMPILE DATE\n         #SEG  0(,R11),BLANKS,2\n         #SEG  0(,R11),BLANKS,8     COMPILE TIME\n         #SEG  0(,R11),BLANKS,2\n         L     R5,CBETGT           GET TASK GLOBAL TABLE POINTER\n         CLC   KSYSOUT,X'1BC'(R5)  CHECK FOR GOOD TGT\n         BNE   NOTTGT              GOT PROBLEMS UNDERSTANDING\n         TM    72(R5),X'10'        MAIN PGM ??\n         BNO   NB1                 NOPE ---\n         #SEG  0(,R11),KMAIN,NOFIT=NEWLINE\nNB1      DS    0H\n         TM    72(R5),X'08'        SYMDUMP ??\n         BNO   NB2                 NOPE ---\n         #SEG  0(,R11),KSYMD,NOFIT=NEWLINE\nNB2      DS    0H\n         TM    72(R5),X'04'        FLOW ??\n         BNO   NB3                 NOPE ---\n         #SEG  0(,R11),KFLOW,NOFIT=NEWLINE\nNB3      DS    0H\n         TM    72(R5),X'02'        STATE ??\n         BNO   NB4                 NOPE ---\n         #SEG  0(,R11),KSTATE,NOFIT=NEWLINE\nNB4      DS    0H\n         TM    72(R5),X'01'        OPTIMIZE ??\n         BNO   NB5                 NOPE ---\n         #SEG  0(,R11),KOPT,NOFIT=NEWLINE\nNB5      DS    0H\n         TM    73(R5),X'10'        TEST ??\n         BNO   NB6                 NOPE ---\n         #SEG  0(,R11),KTEST,NOFIT=NEWLINE\nNB6      DS    0H\n         TM    74(R5),X'80'        RES ??\n         BO    NB8                 NOPE ---\n         #SEG  0(,R11),KRES,NOFIT=NEWLINE\nNB8      DS    0H\n         TM    74(R5),X'40'        ENDJOB ??\n         BNO   NB9                 NOPE ---\n         #SEG  0(,R11),KENDJOB,NOFIT=NEWLINE\nNB9      DS    0H\n         TM    74(R5),X'20'        OBJ370 ??\n         BNO   NB10                NOPE ---\n         #SEG  0(,R11),KOBJ370,NOFIT=NEWLINE\nNB10     DS    0H\n         TM    74(R5),X'08'        COUNT ??\n         BNO   NB11                NOPE ---\n         #SEG  0(,R11),KCOUNT,NOFIT=NEWLINE\nNB11     DS    0H\n         TM    74(R5),X'04'        TRACE VERB PRESENT ??\n         BNO   NB12                NOPE ---\n         #SEG  0(,R11),KTRACE,NOFIT=NEWLINE\nNB12     DS    0H\n*         BYTE 1  BIT 0 MASK X'80'  USED BY ON SIZE ERROR\n*         BYTE 1  BIT 1 MASK X'40'  USED BY READY TRACE VERB\n*         BYTE 1  BIT 2 MASK X'20'  INITIALIZATION FLAG\n*         BYTE 1  BIT 3 MASK X'10'  MAIN PROGRAM FLAG\n*         BYTE 1  BIT 4 MASK X'08'  SYMDUMP FLAG\n*         BYTE 1  BIT 5 MASK X'04'  FLOW FLAG\n*         BYTE 1  BIT 6 MASK X'02'  STATE FLAG / REUSED AT RUN TIME\n*         BYTE 1  BIT 7 MASK X'01'  OPTIMIZATION FLAG\n*         BYTE 2  BIT 0 MASK X'80'  RESERVED\n*         BYTE 2  BIT 1 MASK X'40'  USED BY CALL AND CANCEL\n*         BYTE 2  BIT 2 MASK X'20'  EXEC TIME STATE FLAG\n*         BYTE 2  BIT 3 MASK X'10'  TEST ATTRIBUTE FLAG\n*         BYTE 2  BIT 4 MASK X'08'  QUOTE IS APOST FLAG\n*         BYTE 2  BIT 5 MASK X'04'  SPECIAL SYMDUMP USAGE\n*         BYTE 2  BIT 6 MASK X'02'  LONG TGT FLAG, ALWAYS 1 FOR V4 / VS\n*         BYTE 2  BIT 7 MASK X'01'  Q-ROUTINE USAGE\n*         BYTE 3  BIT 0 MASK X'80'  NORES FLAG, SET TO 0 FOR RES OPTION\n*         BYTE 3  BIT 1 MASK X'40'  ENDJOB WAS SPECIFIED\n*         BYTE 3  BIT 2 MASK X'20'  OBJECT COMPUTER 370 SPECIFIED\n*         BYTE 3  BIT 3 MASK X'10'  Q-ROUTINE FLAG\n*         BYTE 3  BIT 4 MASK X'08'  COUNT OPTION - VS\n*         BYTE 3  BIT 5 MASK X'04'  TRACE VERB IS PRESENT\n*         BYTE 3  BIT 6 MASK X'02'  SYNADAF USAGE\n*         BYTE 3  BIT 7 MASK X'01'  UNUSED BIT\n*         BYTE 4  DEC POINT IS COMMA BYTE\n*                 C',' IF SPECIFIED, ELSE C'.'\n         LA    R10,4(,R10)\n         L     R11,0(,R10)         POINT TO NEXT PRINT LINE\n         #SEG  0(,R11),BLANKS\n         #SEG  0(,R11),KSTAMP\n         LH    R8,0(,R11)          LOAD LINE HEADER\n         LA    R8,4(R8,R11)        POINT TO, OUTPUT AREA\n         L     R3,X'1C8'(,R2)      LOAD WORKING STORAGE ADDRESS\n          CALL  GETSTAMP,((12),(5),(8)) GO LOCATE THE TIME STAMP\n         LTR   R15,R15             WAS IT FOUND ??\n         BZ    DONEFMT             YES ---\n         #SEG  0(,R11),KNOPAN\nDONEFMT  DS    0H\n         L     R13,4(,R13)         LOAD BACK POINTER\n         LM    R14,R12,12(R13)     RESTORE REGISTERS\n         LA    R15,0               ZERO RETURN CODE\n         BSM   R0,R14              RETURN TO CALLER\nNEWLINE  DS    0H\n         LA    R10,4(,R10)         POINT TO NEXT LINE ENTRY\n         L     R11,0(,R10)         POINT TO LINE AREA\n         XC    0(2,R11),0(R11)     'CLEAR' IT OUT\n         #SEG  0(,R11),BLANKS      LEADING BLANK STUFF\n         BR    R9                  AND RETURN TO RE-SEG\n*\n*        UNABLE TO FIND THE TASK GLOBAL TABLE  -\n*\nNOTTGT   DC    H'0'\n         #SEG  0(,R11),KNOTGT\n         B     DONEFMT\nKSYSOUT  DC    CL8'SYSOUT'\nKMAIN    DC    CL5'MAIN'\nKSYMD    DC    CL8'SYMDUMP'\nKFLOW    DC    CL5'FLOW'\nKSTATE   DC    CL6'STATE'\nKOPT     DC    CL9'OPTIMIZE'\nKTEST    DC    CL5'TEST'\nKRES     DC    CL4'RES'\nKENDJOB  DC    CL7'ENDJOB'\nKOBJ370  DC    CL7'OBJ370'\nKCOUNT   DC    CL6'COUNT'\nKTRACE   DC    CL19'TRACE-VERB-PRESENT'\nKSTAMP   DC    CL11'PAN STAMP:'\nKNOPAN   DC    CL24'NO PANVALET STAMP FOUND.'\nKNOTGT   DC    CL16'NO TGT     '\nLINETAB  DC    V(LINE1)\n         DC    V(LINE2)\n         DC    V(LINE3)\n         DC    V(LINE4)\n         DC    V(LINE5)\nBLANKS   DC    CL16' '\n         LTORG\n*---------------------------------------------------------------------*\n*---     THIS DSECT DESCRIBES THE PARTS OF THE INITIALIZATION CODE ---*\n*---     THAT WE ARE MOST INTERESTED IN.                           ---*\n*---------------------------------------------------------------------*\nCOBINIT  DSECT\nCBES     DS    3F      THREE WORDS OF CODE\nCBESIGID DS    CL8     PROGRAM NAME\nCBECOMP  DS    CL4     COMPILER IDENTIFIER\n         ORG   CBES+X'3C'\nCBETGT   DS    A       TGT ADDRESS\n         ORG\nVSTGT    DSECT\n         ORG   VSTGT+X'48'\nVSTGTOPT DS    XL4     COMPILER OPTIONS BYTES\n         ORG   VSTGT+X'1BC'\nVSTGTDD  DS    CL8    'SYSOUT  ' CONSTANT\n         ORG   VSTGT+X'1C8'\nVSTGTWS  DS    A      ADDRESS OF WORKING STORAGE\n         ORG\n         END\n         TITLE 'GETALIAS --- READ PDS DIRECTORY INTO STORAGE'\n*---------------------------------------------------------------------*\n*---     GETALIAS --- READ A COMPLETE PDS DIRECTORY AND BUILD A    ---*\n*---           LIST OF NAMES AND ALIASES                           ---*\n*---                                                               ---*\n*---     PARAMETERS:                                               ---*\n*---           1. DDNAME OF THE DD STATEMENT THAT DESIGNATES THE   ---*\n*---              PDS TO BE EXAMINED.                              ---*\n*---                                                               ---*\n*---           2. A SINGLE WORD THAT WILL CONTAIN THE ADDRESS OF   ---*\n*---              START OF THE NAME-ALIAS CHAIN. STORAGE FOR THE   ---*\n*---              CHAIN IS OBTAINED FROM SUBPOOL 84 AND MAY BE     ---*\n*---              RELEASE BY A SUBPOOL-LEVEL FREEMAIN.             ---*\n*---                                                               ---*\n*---     CHAIN FORMAT:                                             ---*\n*---           DS  A  ADDRESS OF NEXT CHAIN LINK, OR ZERO.         ---*\n*---           DS  A  ADDRESS OF FIRST ALIAS, OR ZERO              ---*\n*---           DS  CL80 COMPLETE DIRECTORY ENTRY, MINUS BLDL       ---*\n*---                    BYTES.                                     ---*\n*---                                                               ---*\n*---     ALL ALIASES ARE CHAINED IN EXACTLY THE SAME FASHION,      ---*\n*---           INCLUDING THE COMPLETE DIRECTORY ENTRY.             ---*\n*---                                                               ---*\n*---     ALIAS CHAIN FORMAT:                                       ---*\n*---           DS  A  ADDRESS OF NON-ALIAS MEMBER NAME ENTRY       ---*\n*---           DS  A  ADDRESS OF NEXT ALIAS, OR ZERO               ---*\n*---           DS  CL80 COMPLETE DIRECTORY ENTRY, MINUS BLDL       ---*\n*---                    BYTES.                                     ---*\n*---                                                               ---*\n*---     ORPHAN ALIASES WILL BE NOTED BY THE FIRST WORD OF THE     ---*\n*---     ALIAS CHAIN LINK SET TO ZERO, TO DENOTE THAT NO NON-      ---*\n*---     ALIAS MEMBER EXISTS FOR THIS ALIAS.                       ---*\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\n*---      STANDARD OPERATING SYSTEM ENTRY LINKAGE CRAP             ---*\n*---------------------------------------------------------------------*\nGETALIAS CSECT\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n*---------------------------------------------------------------------*\n*---     STANDARD NON-REENTRANT ENTRY LINKAGE.                     ---*\n*---------------------------------------------------------------------*\n         B     12(,R15)            BRANCH AROUND\n         DC    X'07',CL7'GETALIAS' CSECT IDENTIFIER\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         BAS   R2,92(,R15)         'BAL' AROUND\n         USING *,R13\n         DS    18F                 NEW SAVE AREA\n         XC    0(72,R2),0(R2)      CLEAR NEW SAVE AREA\n         ST    R13,4(,R2)          STORE BACKWARD AND\n         ST    R2,8(,R13)          FORWARD POINTERS\n         LR    R13,R2              LOAD PGM BASE REGISTER\n*---------------------------------------------------------------------*\n*---     LOAD THE PARM LIST                                        ---*\n*---------------------------------------------------------------------*\n         LM    R2,R3,0(R1)         LOAD PARM LIST POINTER\n*---------------------------------------------------------------------*\n*---     R2 --> 8-BYTE DDNAME                                      ---*\n*---     R3 --> 4-BYTE ROOT ADDRESS                                ---*\n*---------------------------------------------------------------------*\n         XC    0(4,R3),0(R3)       START WITH EMPTY CHAIN\n         LA    R1,GETA20           LOAD DCB POINTER\n         USING IHADCB,R1           AND BASE THE DCB DSECT\n         MVC   DCBDDNAM,0(R2)      MOVE DDNAME INTO THE DCB\n         OPEN  GETA20              OPEN THE DCB\n         LA    R1,GETA20           RELOAD DCB POINTER\n         TM    DCBOFLGS,X'10'      IS DCB OPEN ??\n         BZ    GETA18              NOPE; 8 RETURN CODE AND QUIT\n         DROP  R1\n*---------------------------------------------------------------------*\n*---     LOOP THROUGH THE DIRECTORY, PICKING OUT THE NON-ALIAS     ---*\n*---     MEMBER NAMES AND CHAINING THEM.                           ---*\n*---------------------------------------------------------------------*\nGETA1    DS    0H\n         GET   GETA20              READ A DIRECTORY BLOCK\n         LA    R4,2(,R1)           POINT TO DATA START\n         LH    R5,0(,R1)           LOAD BYTES-USED VALUE\n         BCTR  R5,R0               DECREMENT BY ONE\n         LA    R5,0(R5,R1)         POINT TO LAST VALID BYTE\n         USING PDS2,R4             BASE THE DIRECTORY ENTRY DSECT\nGETA2    DS    0H\n         CLC   PDS2NAME,GETA19     END-OF-DIRECTORY MARKER ??\n         BE    GETA7               YES; DO THE ALIASES NOW\n         IC    R6,PDS2INDC         INSERT ALIAS/LENGTH BITS\n         N     R6,=A(PDS2LUSR)     ISOLATE LENGTH\n         LA    R6,12(R6,R6)        COMPUTE FULL ENTRY LENGTH\n         TM    PDS2INDC,PDS2ALIS   IS THIS AN ALIAS ??\n         BO    GETA5               YES; SKIP IT THIS TIME\n         GETMAIN R,LV=88,SP=84     GRAB SOME STORAGE\n         XC    0(88,R1),0(R1)      CLEAR IT OUT\n         EX    R6,GETA6            COPY IN THE DIRECTORY DATA\n         LR    R7,R3               COPY THE CHAIN START POINTER\nGETA3    DS    0H\n         NC    0(4,R7),0(R7)       NULL POINTER ??\n         BZ    GETA4               YES; STORE NEW LINK POINTER\n         L     R7,0(,R7)           BUMP DOWN THE CHAIN\n         B     GETA3               CONTINUE LOOPING AND SEARCHING\nGETA4    DS    0H\n         ST    R1,0(,R7)           STORE NEW LINK POINTER\nGETA5    DS    0H\n         LA    R4,0(R6,R4)         POINT DOWN THE BLOCK\n         CR    R4,R5               PAST END OF BLOCK\n         BL    GETA2               NOPE; JUST CONTINUE DEBLOCKING\n         B     GETA1               YES; GET A FRESH BLOCK\nGETA6    MVC   8(1,R1),PDS2NAME    COPY OF DIRECTORY ENTRY\n*---------------------------------------------------------------------*\n*---     RE-READ THE DIRECTORY, LOOKING FOR ALIASES.               ---*\n*---------------------------------------------------------------------*\nGETA7    DS    0H\n         CLOSE (GETA20,REREAD)     CLOSE DIRECTORY FOR RE-READ\n         LA    R1,GETA20\n         USING IHADCB,R1\n         MVC   DCBEODA,=AL3(GETA16)\n         DROP  R1\n         OPEN  GETA20              AND RE-OPEN\nGETA8    DS    0H\n         GET   GETA20              READ A DIRECTORY BLOCK\n         LA    R4,2(,R1)           POINT TO DATA START\n         LH    R5,0(,R1)           LOAD BYTES-USED VALUE\n         BCTR  R5,R0               DECREMENT BY ONE\n         LA    R5,0(R5,R1)         POINT TO LAST VALID BYTE\n         USING PDS2,R4             BASE THE DIRECTORY ENTRY DSECT\nGETA9    CLC   PDS2NAME,GETA19     END-OF-DIRECTORY MARKER ??\n         BE    GETA16              YES; DO THE ALIASES NOW\n         IC    R6,PDS2INDC         INSERT ALIAS/LENGTH BITS\n         N     R6,=A(PDS2LUSR)     ISOLATE LENGTH\n         LA    R6,12(R6,R6)        COMPUTE FULL ENTRY LENGTH\n         TM    PDS2INDC,PDS2ALIS   IS THIS AN ALIAS ??\n         BZ    GETA15              NOPE; SKIP IT THIS TIME\n         GETMAIN R,LV=88,SP=84     GRAB SOME STORAGE\n         XC    0(88,R1),0(R1)      CLEAR IT OUT\n         EX    R6,GETA6            COPY IN THE DIRECTORY DATA\n         LR    R7,R3               COPY THE CHAIN START POINTER\nGETA10   NC    0(4,R7),0(R7)       NULL POINTER ??\n         BZ    GETA11              YES; STORE NEW LINK POINTER\n         CLC   GETA21(3,R1),GETA21(R7) DO TTR'S MATCH ??\n         BE    GETA12              YES; INSERT KNOWN ALIAS\n         L     R7,0(,R7)           BUMP DOWN THE CHAIN\n         B     GETA10              CONTINUE LOOPING AND SEARCHING\nGETA11   DS    0H\n         ST    R1,0(,R7)           STORE NEW LINK POINTER\n         B     GETA15              AND GO DEBLOCK SOME MORE\nGETA12   DS    0H\n         ST    R7,0(,R1)           STORE POINTER TO NON-ALIAS NAME\nGETA13   DS    0H\n         NC    4(4,R7),4(R7)       ALIAS CHAIN EMPTY ??\n         BZ    GETA14              YES; INSERT NEW ALIAS\n         L     R7,4(,R7)           BUMP DOWN THE CHAIN\n         B     GETA13              AND KEEP SEARCHING\nGETA14   DS    0H\n         ST    R1,4(,R7)\nGETA15   DS    0H\n         LA    R4,0(R6,R4)         POINT DOWN THE BLOCK\n         CR    R4,R5               PAST END OF BLOCK\n         BL    GETA9               NOPE; JUST CONTINUE DEBLOCKING\n         B     GETA8               YES; GET A FRESH BLOCK\n*---------------------------------------------------------------------*\n*---     ALL DONE; CLOSE DCB, FREE THE BUFFER POOL AND RETURN      ---*\n*---------------------------------------------------------------------*\nGETA16   DS    0H\n         L     R1,4(,R13)          LOAD BACK S.A. POINTER\n         MVC   16(4,R1),=F'0'      SET THE RETURN CODE\n         CLOSE GETA20\n         FREEPOOL GETA20\nGETA17   DS    0H\n         L     R13,4(,R13)\n         LM    R14,R12,12(R13)\n         MVI   12(R13),255\n         BR    R14\nGETA18   DS    0H\n         L     R1,4(,R13)          LOAD BACK S.A. POINTER\n         MVC   16(4,R1),=F'4'      SET THE RETURN CODE\n         B     GETA17              AND RETURN\n         EJECT\n*---------------------------------------------------------------------*\n*---     MISC CONSTANTS AND DATA AREAS                             ---*\n*---------------------------------------------------------------------*\nGETA19   DC    8X'FF'\nGETA20   DCB   DSORG=PS,MACRF=GL,DDNAME=DD00,RECFM=U,BLKSIZE=256,      X\n               EODAD=GETA7\n         DCBD  DSORG=PS\n         IHAPDS PDSBLDL=NO\nGETA21   EQU   (PDS2TTRP-PDS2)+8\n         END\n         TITLE 'GETCESD --- LOAD ESD/IDR FROM LMOD INTO STORAGE'\n*---------------------------------------------------------------------*\n*---     GETCESD --- READ LOAD-MODULE ESD DATA INTO THE            ---*\n*---           USER-SUPPLIED AREA OF MAIN STORAGE.                 ---*\n*---                                                               ---*\n*---     PARAMETERS:                                               ---*\n*---           R1 --> A(PDSDCB)                                    ---*\n*---                  A(MEMBER TTR)                                ---*\n*---                  A(CESD DATA AREA)                            ---*\n*---                                                               ---*\n*---     THE CESD AREA IS FORMATTED THUSLY:                        ---*\n*---                                                               ---*\n*---           OFFSET 0, LENGTH 4 --- TOTAL AREA LENGTH,           ---*\n*---              INCLUDING THESE CONTROL WORDS.                   ---*\n*---                                                               ---*\n*---           OFFSET 4, LENGTH 4 --- TOTAL AREA USED, AGAIN       ---*\n*---              INCLUDING THESE CONTROL WORDS.                   ---*\n*---                                                               ---*\n*---           OFFSET 8, LENGTH ?? --- ACTUAL ESD DATA READ FROM   ---*\n*---              THE LOAD MODULE.                                 ---*\n*---                                                               ---*\n*---     THE CALLER IS RESPONSIBLE FOR SETTING THE VALUE IN THE    ---*\n*---     FIRST WORD. THE VALUE IN THE SECOND WORD WILL BE SET      ---*\n*---     BY THIS SUBROUTINE AND ANY PREVIOUS VALUE WILL BE         ---*\n*---     IGNORED.                                                  ---*\n*---                                                               ---*\n*---     RETURN CODE IS 4 IF ANY AREA PROVIDED BY THE CALLER IS    ---*\n*---           TOO SMALL; OTHERWISE RETURN CODE IS ZERO            ---*\n*---                                                               ---*\n*---     ATTRIBUTES: REENTRANT, REUSABLE                           ---*\n*---------------------------------------------------------------------*\nGETCESD  CSECT\nGETCESD  AMODE 24\nGETCESD  RMODE 24\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n*---------------------------------------------------------------------*\n*---     STANDARD REENTRANT ENTRY LINKAGE.                         ---*\n*---------------------------------------------------------------------*\n         B     12(,R15)            BRANCH AROUND\n         DC    X'07',CL7'GETCESD'  CSECT IDENTIFIER\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         LR    R12,R15             COPY E.P. ADDRESS\n         LA    R12,0(,R12)         CLEAR HIGH-ORDER BYTE\n         USING GETCESD,R12         AND DECLARE THE BASE\n         LR    R2,R1               COPY PARM LIST POINTER\n         L     R5,GETC5            LOAD MY AREA LENGTH\n         GETMAIN RU,LV=(5),LOC=BELOW GRAB SOME STORAGE\n         LA    R4,0(,R1)           COPY ITS ADDRESS\n         LA    R14,0\n         LA    R15,0\n         MVCL  R4,R14              CLEAR THE AREA\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LR    R13,R1\n         USING WAREA,R13           BASE WORK-AREA DSECT\n         MVC   PARMS,0(R2)         COPY PARMS TO MY AREA\n*---------------------------------------------------------------------*\n*---     SET UP WORD2 OF EACH CALLER-SUPPLIED DATA AREA            ---*\n*---------------------------------------------------------------------*\n         L     R1,CESDAA           LOAD ESD AREA POINTER\n         MVC   4(4,R1),=F'8'       START WITH 8 BYTES USED\n*---------------------------------------------------------------------*\n*---     SET-UP BUFFERS, TTR POINTER                               ---*\n*---------------------------------------------------------------------*\n         L     R11,PDSDCBA         LOAD BPAM DCB ADDRESS\n         USING IHADCB,R11          BASE THE DCB DSECT\n         MVC   DCBEODA(3),=AL3(GETC4) SET THE EOF ADDRESS\n         L     R2,TTRA             POINT TO INPUT TTR\n         MVC   TTR(3),0(R2)        COPY TTR POINTER\n         POINT (11),TTR            POINT TO MEMBER START\n*---------------------------------------------------------------------*\n*---     LOOP, READING ALL CESD DATA INTO SUPPLIED AREA            ---*\n*---------------------------------------------------------------------*\nGETC1    DS    0H\n         READ  PDSDECB,SF,(11),BUFFER,'S',MF=E READ A CESD RECORD\n         CHECK PDSDECB\n         CLI   BUFFER,X'80'        WAS THIS AN IDR RECORD ??\n         BE    GETC4               YES; ALL DONE ---\n         CLI   BUFFER,X'20'        WAS THIS AN ESD RECORD ??\n         BE    GETC2               YES; COPY AND CONTINUE ---\n         B     GETC1               JUST CONTINUE ---\n*---------------------------------------------------------------------*\n*---     SET UP REGS FOR ESDDATA MOVE                              ---*\n*---------------------------------------------------------------------*\nGETC2    DS    0H\n         LH    R14,BUFFER+6        GET ESD RECORD LENGTH\n         L     R10,CESDAA          POINT TO THE RIGHT AREA\n         L     R0,0(,R10)          LOAD TOTAL AREA LENGTH\n         S     R0,4(,R10)          COMPUTE BYTES LEFT\n         CR    R14,R0              ENOUGH ROOM ??\n         BNH   GETC3               YES ---\n         LR    R14,R0              NOPE; JUST MOVE WHAT WE CAN\n         L     R15,4(,R13)         LOAD S.A. BACK POINTER\n         MVC   16(4,R15),=F'4'     SET THE RETURN CODE\nGETC3    DS    0H\n         L     R2,4(,R10)          LOAD BYTES USED\n         AR    R2,R10              POINT INTO THE AREA\n         LR    R3,R14              AND SET THE LENGTH\n         LA    R6,BUFFER+8         POINT TO INPUT BUFFER\n         LR    R7,R14              AND SET THE LENGTH\n         MVCL  R2,R6               MOVE DATA TO BUFFER\n         A     R14,4(,R10)         SUM: USED PLUS ADDED\n         ST    R14,4(,R10)         SAVE UPDATED VALUE\n         B     GETC1               YES; CONTINUE\n         EJECT\n*---------------------------------------------------------------------*\n*---     ALL FUNCTIONS COMPLETE. TERMINATE QUIETLY                 ---*\n*---------------------------------------------------------------------*\nGETC4    DS    0H\n         LR    R1,R13\n         L     R13,4(,R13)\n         L     R0,GETC5            LOAD AREA SIZE\n         FREEMAIN R,LV=(0),A=(1)   RELEASE MY WORK AREA\n         LM    R14,R12,12(R13)\n         LA    R15,0\n         BR    R14\n         EJECT\n*---------------------------------------------------------------------*\n*---     MISC CONSTANTS AND DATA AREAS                             ---*\n*---------------------------------------------------------------------*\n         LTORG\nGETC5    DC    A(WALEN)\n         DCBD  DSORG=PS\nWAREA    DSECT\nNSAVE    DS    18F           NEW SAVE AREA\nPARMS    DS    0CL12\nPDSDCBA  DS    A             PDS DCB POINTER\nTTRA     DS    A             ADDRESS OF MEMBER TTR\nCESDAA   DS    A             POINTER TO CESD AREA\nTTR      DS    A             ACTUAL TTR OF MEMBER START\n         READ  PDSDECB,SF,MF=L\nBUFFER   DS    4000D         PDS I/O BUFFER\nWALEN    EQU   *-WAREA\n         END\n*---------------------------------------------------------------------*\n*---     GETSTAMP - SEARCH WORKING STORAGE FOR COBOL/PANVALET      ---*\n*---           LEVEL STAMP INFORMATION.                            ---*\n*---                                                               ---*\n*---     PARAMETERS: A THREE-WORD PARAMETER LIST                   ---*\n*---           WORD1: POINTER TO WORKING STORAGE START             ---*\n*---           WORD2: POINTER TO THE TGT                           ---*\n*---           WORD3: AREA TO COPY THE STAMP INTO                  ---*\n*---                                                               ---*\n*---     RETURN CODES: 0 IF THE STAMP IS FOUND AND COPIED          ---*\n*---                   4 IF NO STAMP IS FOUND                      ---*\n*---                                                               ---*\n*---     CSECT ATTRIBUTES: REENTRANT, REUSABLE,REFRESHABLE,        ---*\n*---           AMODE(ANY), RMODE(ANY)                              ---*\n*---                                                               ---*\n*---     MACROS: GETMAIN, FREEMAIN                                 ---*\n*---                                                               ---*\n*---     METHOD: THE WORKING STORAGE IS SEARCHED USING A           ---*\n*---           'MASKING' ALGORITHM BASED ON THE STAMP FORMAT.      ---*\n*---           THE WORKING STORAGE IS SEARCHED FOR A ZONED         ---*\n*---           DECIMAL DIGIT.  EACH TIME THIS IS FOUND, THE BYTES  ---*\n*---           FOLLOWING ARE COPIED TO A PRIVATE WORK AREA AND     ---*\n*---           CHECKED USING THE MASK.  WHAT I DO IS THIS: FIRST,  ---*\n*---           REDUCE THE CHARACTERS TO BLANKS, DIGITS AND         ---*\n*---           SPECIAL CHARACTERS, VIA THE 'NC' INSTRUCTION, THE   ---*\n*---           RESULT IS COMPARED TO A SECOND STRING FOR AN EXACT  ---*\n*---           MATCH.  IF FOUND, I ASSUME THAT THIS IS THE STAMP   ---*\n*---           AND RETURN IT TO MY CALLER.                         ---*\n*---------------------------------------------------------------------*\nGETSTAMP CSECT\nGETSTAMP AMODE 31\nGETSTAMP RMODE 24\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n         B     12(,R15)\n         DC    AL1(7),CL7'GETSTAMP'\n         STM   R14,R12,12(R13)     SAVE ENTRY REGISTERS\n         LR    R12,R15             COPY E.P. ADDRESS\n         USING GETSTAMP,R12\n         LR    R2,R1               COPY PARM LIST POINTER\n         L     R5,WALEN            LOAD WORK-AREA LENGTH\n         GETMAIN RU,LV=(5)         GRAB STORAGE FOR WORK AREA\n         LR    R4,R1               COPY ITS ADDRESS\n         SR    R14,R14             CLEAR TWO OTHER\n         SR    R15,R15               REGISTERS\n         MVCL  R4,R14              CLEAR MY WORK AREA\n         ST    R1,8(,R13)          FORWARD CHAIN\n         ST    R13,4(,R1)          BACK CHAIN\n         LR    R13,R1              BUMP POINTER DOWN THE CHAIN\n         USING WAREA,R13           AND BASE THE DSECT\n         MVC   PARMS,0(R2)         COPY PARM POINTERS\n         L     R5,END              LOAD TGT POINTER\n         L     R6,START            POINT TO WORKING STORAGE\n         LA    R4,1                LOAD LOOP INCREMENT\nSRCLOOP  DS    0H\n         CLI   0(R6),240           NUMERIC DIGIT ??\n         BL    NOTHERE             NOPE ---\n         CLI   0(R6),249           TOO HIGH FOR NUMERIC ??\n         BH    NOTHERE             YES; SKIP IT\n         MVC   STMPTST,0(R6)       COPY SOME FOR STAMP TEST\n         NC    STMPTST,MASK1       REDUCE TO BASIC FORMAT\n         CLC   STMPTST,MASK2       COMPARE TO EXPECTED RESULT\n         BE    MOVEIT              GOT IT; MOVE THE DATA\nNOTHERE  DS    0H\n         BXLE  R6,R4,SRCLOOP       KEEP SEARCHING\n         LA    R9,4                LOAD MY 'NOT FOUND' CODE\nRETURN   DS    0H\n         LR    R1,R13              COPY MY WORK-AREA ADDRESS\n         L     R13,4(,R13)         LOAD BACK SAVE-AREA POINTER\n         L     R0,WALEN            LOAD AREA LENGTH\n         FREEMAIN RU,LV=(0),A=(1)  RELEASE MY STORAGE\n         LR    R15,R9              SET THE RETURN CODE\n         L     R14,12(,R13)        LOAD RETURN ADDRESS\n         LM    R0,R12,20(R13)      RESTORE REGISTERS\n         BR    R14                 AND RETURN TO CALLER\nMOVEIT   DS    0H\n         L     R2,OUTPUT           LOAD OUTPUT AREA POINTER\n         MVC   0(STMPLEN,R2),0(R6) COPY THE STAMP DATA\n         LA    R9,0                SET ZERO RETURN CODE\n         B     RETURN              AND GO RETURN TO CALLER\nMASK1    DC    X'F0F0F0004040404040404040404000F0'\n         DC    X'F0FFF0F0FFF0F000F0F0FFF0F0FFF0F0'\nSTMPLEN  EQU   *-MASK1\nMASK2    DC    X'F0F0F0004040404040404040404000F0'\n         DC    X'F061F0F061F0F000F0F07AF0F07AF0F0'\nWALEN    DC    A(ENDWK-WAREA)\nWAREA    DSECT\nSAVEAREA DS    18F\nPARMS    DS    0CL12\nSTART    DS    A\nEND      DS    A\nOUTPUT   DS    A\nSTMPTST  DS    CL32\nENDWK    DS    0D\n         END\n*---------------------------------------------------------------------*\n*---     RDLKDATE --- LOCATE LINKEDIT DATE IN A LOAD MODULE.       ---*\n*---                                                               ---*\n*---     PARAMETERS: R1 --> A(PDSDCB)                              ---*\n*---                        A(MEMBER TTR)                          ---*\n*---                                                               ---*\n*---     THE LKED DATE, IF FOUND, IS RETURNED IN R0 AS A PACKED    ---*\n*---     DECIMAL NUMBER IN THE FORMAT '00YYDDDF'. IF NO DATE IS    ---*\n*---     FOUND, THE REGISTER IS SET TO ZEROS.                      ---*\n*---                                                               ---*\n*---     ATTRIBUTES: NON-REENTRANT, REUSABLE                       ---*\n*---                                                               ---*\n*---     STANDARD OPERATING SYSTEM ENTRY LINKAGE CRAP              ---*\n*---------------------------------------------------------------------*\nRDLKDATE CSECT\nRDLKDATE RMODE 24\nRDLKDATE AMODE 24\nR0       EQU   0                   R\nR1       EQU   1                    E\nR2       EQU   2                     G\nR3       EQU   3                      I\nR4       EQU   4                       S\nR5       EQU   5                        T\nR6       EQU   6                         E\nR7       EQU   7                          R\nR8       EQU   8\nR9       EQU   9                   E\nR10      EQU   10                   Q\nR11      EQU   11                    U\nR12      EQU   12                     A\nR13      EQU   13                      T\nR14      EQU   14                       E\nR15      EQU   15                        S\n*---------------------------------------------------------------------*\n*---     STANDARD NON-REENTRANT ENTRY LINKAGE. USE ONE BASE REG.   ---*\n*---------------------------------------------------------------------*\n         B     12(,R15)            BRANCH AROUND\n         DC    X'07',CL7'RDLKDATE' CSECT IDENTIFIER\n         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS\n         BAS   R2,92(,R15)         'BAL' AROUND\n         USING *,R13\n         DS    18F                 NEW SAVE AREA\n         XC    0(72,R2),0(R2)      CLEAR NEW SAVE AREA\n         ST    R13,4(,R2)          STORE BACKWARD AND\n         ST    R2,8(,R13)          FORWARD POINTERS\n         LR    R13,R2              LOAD PGM BASE REGISTER\n         L     R2,4(,R2)           POINT TO BACK SAVE AREA\n         XC    20(4,R2),20(R2)     DEFAULT RETURN VALUE\n*---------------------------------------------------------------------*\n*---     SET-UP BUFFER, TTR POINTER                                ---*\n*---------------------------------------------------------------------*\n         LM    R2,R3,0(R1)         LOAD PARM POINTERS\n         USING IHADCB,R2           BASE THE DCB DSECT\n         MVC   DCBEODA(3),=AL3(ENDOFJOB) SET THE EOF ADDRESS\n         LH    R7,DCBBLKSI         LOAD ITS BLKSIZE\n         GETMAIN R,LV=(7)          GRAB AN I/O BUFFER\n         LR    R12,R1              SAVE ITS ADDRESS\n         MVC   TTR(3),0(R3)        COPY TTR POINTER\n         LA    R5,0(,R7)           LOAD OUTPUT AREA LENGTH\n*---------------------------------------------------------------------*\n*---     LOOP, READING LINKAGE EDITOR DATA INTO AREA               ---*\n*---------------------------------------------------------------------*\n         POINT (2),TTR             POINT TO MEMBER START\nIDRLOOP1 DS    0H\n         READ  PDS,SF,(2),(12),'S' READ A IDR RECORD\n         CHECK PDS\n         CLI   0(R12),X'80'        WAS THIS AN IDR RECORD ??\n         BNE   IDRLOOP1            NOPE ---\n         TM    2(R12),X'02'        LKED IDR DATA ??\n         BO    IDRMOVE             YES; PROCESS AND QUIT\n         TM    2(R12),X'80'        LAST IDR ??\n         BO    ENDOFJOB            YES; JUST QUIT\n         B     IDRLOOP1            NOPE; KEEP SEARCHING\nIDRMOVE  DS    0H\n         SR    R0,R0               CLEAR A WORK REGISTER\n         ICM   R0,7,15(R12)        INSERT THE LINK DATE\n         L     R2,4(,R13)          POINT TO BACK SAVE AREA\n         ST    R0,20(,R2)          SET THE RETURN VALUE\n         EJECT\n*---------------------------------------------------------------------*\n*---     ALL FUNCTIONS COMPLETE. TERMINATE QUIETLY                 ---*\n*---------------------------------------------------------------------*\nENDOFJOB DS    0H\n         FREEMAIN R,LV=(7),A=(12) RELEASE MY BUFFER\n         L     R13,4(,R13)\n         LM    R14,R12,12(R13)\n         SR    R15,R15             ALWAYS ZERO RETURN CODE\n         MVI   12(R13),255\n         BR    R14\n         EJECT\n*---------------------------------------------------------------------*\n*---     MISC CONSTANTS AND DATA AREAS                             ---*\n*---------------------------------------------------------------------*\n         LTORG\nTTR      DC    F'0'\n         DCBD  DSORG=PS\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODLIST$": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00W\\x01\\x01\\x05\\x1f\\x01\\x16\\x18o\\x13S\\x00\\x1c\\x00\\x1f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-02-20T00:00:00", "modifydate": "2016-07-04T13:53:57", "lines": 28, "newlines": 31, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,FLAG(5))\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//         DD DISP=SHR,DSN=SBGOLOB.CBT491.FILE347\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(MODLIST)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=HEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//OBJECT   DD  DISP=(OLD,DELETE),DSN=&&TEMP\n//SYSLIN   DD  *\n INCLUDE OBJECT\n SETSSI  CB491347\n SETCODE AC(0)\n NAME    MODLIST(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MODLIS01": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x16\\x18o\\x01\\x16\\x18o\\x14\\x05\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-07-04T00:00:00", "modifydate": "2016-07-04T14:05:47", "lines": 22, "newlines": 22, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBM JOB ,'SAM GOLOB',CLASS=B,\n//    MSGCLASS=X,NOTIFY=&SYSUID\n//*\n//*\n//LIST1    EXEC  PGM=MODLIST,REGION=0M PARM=NOLIB\n//*\n//* A PARM VALUE OF NOLIB WILL SUPPRESS ANY OF THE COMMON\n//* LIBRARY ROUTINES FROM THE LISTING.\n//*\n//*\n//STEPLIB  DD DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//*\n//SYSPRINT  DD   SYSOUT=*,HOLD=YES,\n//          RECFM=FBA,LRECL=121,BLKSIZE=121\n//*\n//* DCB ATTRIBUTES ARE REQUIRED FOR THE SYSPRINT DATASET.  THE\n//* LRECL MAY VARY FROM XXX TO YYY; THE PROGRAM WILL ADJUST THE\n//* LINESIZE WITHIN THOSE VALUES.  STANDARD QSAM I/O IS USED,\n//* SO DIRECTING SYSPRINT TO A DISK DATASET IS NO PROBLEM.\n//*\n//SYSLIB   DD    DISP=SHR,DSN=SBGOLOB.N.LOAD\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAMPJCL": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x982\\x7f\\x00\\x982\\x7f\\x105\\x00\\x14\\x00\\x14\\x00\\x00\\xc3\\xc8\\xe2\\xe8\\xf2\\xf2\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-11-23T00:00:00", "modifydate": "1998-11-23T10:35:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "CHSY227"}, "text": "//*\n//LIST1    EXEC  PGM=MODLIST,REGION=????,PARM=NOLIB\n//*\n//* A PARM VALUE OF NOLIB WILL SUPPRESS ANY OF THE COMMON\n//* LIBRARY ROUTINES FROM THE LISTING.\n//*\n//*\n//STEPLIB  DD    (........AS NEEDED.........)\n//*\n//SYSPRINT  DD   SYSOUT=C,HOLD=YES,\n//          RECFM=FBA,LRECL=121,BLKSIZE=121\n//*\n//* DCB ATTRIBUTES ARE REQUIRED FOR THE SYSPRINT DATASET.  THE\n//* LRECL MAY VARY FROM XXX TO YYY; THE PROGRAM WILL ADJUST THE\n//* LINESIZE WITHIN THOSE VALUES.  STANDARD QSAM I/O IS USED,\n//* SO DIRECTING SYSPRINT TO A DISK DATASET IS NO PROBLEM.\n//*\n//SYSLIB   DD    DISP=SHR,DSN=LOADLIB.TO.BE.CHECKED\n//*\nTHIS SHOULD BE SELF-EXPLANATORY.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT347/FILE347.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT347", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}