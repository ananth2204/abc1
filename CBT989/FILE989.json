{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013713000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1410864, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 19, "INMDSNAM": "CBT.V500.FILE989.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1410864, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1410864, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE989.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x18\\x06'", "DS1TRBAL": "b'v\\xde'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xd0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xd0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\n\\x7f\\x00\\x0c\\n\\x81\\x00\\x06\\x00\\x19'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00\\x01\\x01\\x19\\x16\\x8f\\x01\\x19\\x16\\x8f\\x11$\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-06-17T00:00:00", "modifydate": "2019-06-17T11:24:01", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-498"}, "text": "REGULAR CBT TAPE - VERSION 498    FILE:  989\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT498.FILE989\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 80 MEMBERS COUNTED; CUMULATIVE SIZE IS 12,923 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   06/17/19    11:24:01    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00R\\x01\\x19\\x06_\\x01\\x19\\x08/\\x18\\x07\\x00\\x01\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-03-23T18:07:52", "lines": 1, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "See member WFMDOC....\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE989": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04b\\x00U\\x01\\x19\\x16\\x8f\\x01\\x19\\x16\\x8f\\x11#\\x00,\\x00,\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf8@@@'", "ispf": {"version": "04.98", "flags": 0, "createdate": "2019-06-17T00:00:00", "modifydate": "2019-06-17T11:23:55", "lines": 44, "newlines": 44, "modlines": 0, "user": "CBT-498"}, "text": "//***FILE 989 is from Willy Jensen, and contains a fantastic        *   FILE 989\n//*           package called FINDMEM that can take a member name    *   FILE 989\n//*           (or masked name) and tell you all the datasets in     *   FILE 989\n//*           the entire system, which contain that name, or        *   FILE 989\n//*           masked name, as a pds member.  I've never seen a      *   FILE 989\n//*           package like this, at least for free.                 *   FILE 989\n//*                                                                 *   FILE 989\n//*           Note that this package is dated 2019-06-15, which     *   FILE 989\n//*           contains a fix for missing some datasets in SMF.      *   FILE 989\n//*                                                                 *   FILE 989\n//*           email:  willy.h.jensen@outlook.com                    *   FILE 989\n//*                                                                 *   FILE 989\n//*       This package contains a user manual in PDF format,        *   FILE 989\n//*       member FINDMEMP.  See member WFMDOC for setup             *   FILE 989\n//*       instructions.                                             *   FILE 989\n//*                                                                 *   FILE 989\n//*  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *   FILE 989\n//*                                                                 *   FILE 989\n//*       Description of a Sample Panel:                            *   FILE 989\n//*                                                                 *   FILE 989\n//*                     Find Member (WFM4)            Row 1 from 6  *   FILE 989\n//*  Cmd =>                                                   PAGE  *   FILE 989\n//*                                                                 *   FILE 989\n//*  Membername ICKDSF    name or name* or mask (mask chars % and   *   FILE 989\n//*             --------  *) if mask in pos 1 then expect search    *   FILE 989\n//*                       to take a while                           *   FILE 989\n//*                                                                 *   FILE 989\n//*  Linecmds: Info Browse Edit BrowseDataset EditDataset Pdsmain   *   FILE 989\n//*            View ViewDataset                                     *   FILE 989\n//*                                                                 *   FILE 989\n//*     Member   Dataset               Volume User     Date     Cat *   FILE 989\n//*     ICKDSF   SBGOLOB.LIB.CNTL      MVSR01 SBGOLOB  20161001 Y   *   FILE 989\n//*     ICKDSF   IBMUSER.B.CNTL        MVSR01 SBGOLOB  20070905 Y   *   FILE 989\n//*     ICKDSF   IBMUSER.B.TEST        MVSR03 SBGOLOB  20070905 Y   *   FILE 989\n//*     ICKDSF   SYS1.LINKLIB          MVSRES          20181226 Y   *   FILE 989\n//*     ICKDSF   WJENSEN.RPF.CNTL      MVSR02 WJENSEN  20190103 Y   *   FILE 989\n//*                                                                 *   FILE 989\n//*  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  *   FILE 989\n//*                                                                 *   FILE 989\n//*   The display shows all occurrences of the member name on the   *   FILE 989\n//*   entire system, as a member of a pds.  And you have a choice   *   FILE 989\n//*   to do any of the commands mentioned as \"linecmds\" to operate  *   FILE 989\n//*   on the dataset, or the member itself.                         *   FILE 989\n//*                                                                 *   FILE 989\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDMEMP": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x19\\x16\\x7f\\x01\\x19\\x16\\x7f\\x16(\\x0e\\xf6\\x0e\\xf6\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-06-16T00:00:00", "modifydate": "2019-06-16T16:28:47", "lines": 3830, "newlines": 3830, "modlines": 0, "user": "DVL"}, "mimetype": "application/pdf", "datatype": "binary", "extension": ".pdf"}, "JOBDBCR": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\\x19\\x01\\x19\\x06_\\x01\\x19\\x16\\x7f\\x16(\\x00+\\x00\\x15\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-06-16T16:28:19", "lines": 43, "newlines": 21, "modlines": 0, "user": "DVL"}, "text": "//WFM4DBCR  JOB (1),'DBINIT',CLASS=A,\n//          MSGCLASS=T,COND=(0,LT),REGION=64M\n//*\n//* DB create\n//*\n//   SET     WFMLIB=WFM.WFM4.LIB\n//   JCLLIB  ORDER=&WFMLIB\n//   INCLUDE MEMBER=WFMSET\n//*\n//DEFDB    EXEC WFMRUN,P='IDCAMS EDIT(SYSIN)'\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n PARM GRAPHICS(CHAIN(SN))\n /*                          */\n DELETE   &DBPFX..DSN    CLUSTER\n DELETE   &DBPFX..MBR    CLUSTER\n SET MAXCC = 0\n /* Dataset database         */\n DEFINE CLUSTER( -\n          NAME(&DBPFX..DSN)     -\n          CYLINDER(2 2) -\n          KEYS(12 0)  -\n          RECORDSIZE(50 100) -\n          SHR(3,3) -\n          VOL(&DBVOL) -\n         ) -\n         INDEX(CISZ(4096))\n REPRO INFILE(DSNI) OUTDATASET(&DBPFX..DSN)\n /* Member database         */\n DEFINE CLUSTER( -\n          NAME(&DBPFX..MBR)     -\n          CYLINDER(50 50) -\n          KEYS(20 0)  -\n          RECORDSIZE(50 100) -\n          SHR(3,3) -\n          VOL(&DBVOL) -\n         ) -\n         INDEX(CISZ(4096))\n REPRO INFILE(MBRI) OUTDATASET(&DBPFX..MBR)\n//DSNI     DD *\n000000000000 AAAAAA AAAAAAA.AAAAAAAA.AAAAAAAA.AAAAAAAA.AAAAAAAA\n//MBRI     DD *\n++++++++000000000000WFM4INI;;;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBDBMN1": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x014\\x00R\\x01\\x19\\x06_\\x01\\x19\\x16\\x7f\\x16(\\x00\\x10\\x00\\x0f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.52", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-06-16T16:28:52", "lines": 16, "newlines": 15, "modlines": 0, "user": "DVL"}, "text": "//WFM4DMN1  JOB (1),'WFM-DB-MAINT-1',\n//*  RESTART=WFMDBX.WFMDBXS1,\n//          CLASS=A,COND=(5,LT),REGION=64M\n//*\n//* Delete duplicate dsn records and orphaned mbr records\n//*\n//         SET WFMLIB=WFM.WFM4.LIB\n//         JCLLIB ORDER=&WFMLIB\n//         INCLUDE MEMBER=WFMSET\n//*\n//DBM      EXEC WFMDBM,TEST='ALL'\n//         EXEC WFMDWD           Delete work dataset(s)\n//         EXEC WFMAWD           Create work dataset(s)\n//         EXEC WFMDBD           DB delete\n//         EXEC WFMDBA           DB add\n//         EXEC WFMDWD           Delete work datasets\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBDBMN2": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00)\\x01\\x19\\x10o\\x01\\x19\\x16\\x7f\\x16(\\x00\\x17\\x00\\x16\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2019-04-16T00:00:00", "modifydate": "2019-06-16T16:28:29", "lines": 23, "newlines": 22, "modlines": 0, "user": "DVL"}, "text": "//WFM4DMN2  JOB (1),'WFM-DB-MAINT-2',\n//*  RESTART=WFMDBX.WFMDBXS1,\n//          CLASS=A,COND=(5,LT),REGION=64M\n//*\n//* Compare database- to VTOC lists, generate DB del and DB add\n//*\n//         SET WFMLIB=WFM.WFM4.LIB\n//         JCLLIB ORDER=&WFMLIB\n//         INCLUDE MEMBER=WFMSET\n//*\n//         EXEC WFMDWD           Delete work dataset(s)\n//         EXEC WFMAWD           Create work dataset(s)\n//         EXEC WFMGNR           Create CNTL dataset\n//SYSUT1   DD *\n vol( all    )\n//SYSUT2   DD DISP=(,PASS),DSN=&&CNTL,LRECL=80,RECFM=FB,BLKSIZE=0,\n//            UNIT=SYSDA,SPACE=(TRK,(5,5))\n//         EXEC WFMVTC,CNTL=&&CNTL Extract VTOC data\n//         EXEC WFMDBX,CNTL=&&CNTL Extract data from dsn db\n//         EXEC WFMMDV           Merge dsn DB and VTOC data\n//         EXEC WFMDBD           DB delete\n//         EXEC WFMDBA           DB add\n//         EXEC WFMDWD           Delete work datasets\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBDBMN3": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x04\\x01\\x19\\x11\\x1f\\x01\\x19\\x16\\x7f\\x16(\\x003\\x00\\x17\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-04-21T00:00:00", "modifydate": "2019-06-16T16:28:04", "lines": 51, "newlines": 23, "modlines": 0, "user": "DVL"}, "text": "//WFM4DMN3  JOB (1),'WFM-DB-MAINT-2',\n//*  RESTART=WFMDBX.WFMDBXS1,\n//          CLASS=A,COND=(5,LT),REGION=64M\n//*\n//         SET WFMLIB=WFM.WFM4.LIB\n//         JCLLIB ORDER=&WFMLIB\n//         INCLUDE MEMBER=WFMSET\n//*\n//* Delete database records based on dsname, membername,\n//* volser or key.\n//*\n//* Control data in libref CNTL DD.\n//*  ACT(DEL) MBR(MEMBER-LIST)\n//*  ACT(DEL) DSN(DATASET-LIST)\n//*  ACT(DEL) VOL(VOLUME-LIST)\n//*  ACT(DEL) KEY(KEY-LIST)\n//*\n//* Control data may be continued over several lines\n//*\n//       SET     WFMLIB=WFM.WFM4.LIB\n//       JCLLIB  ORDER=&WFMLIB\n//       INCLUDE MEMBER=WFMSET\n//*\n//U      EXEC WFMDBU,MSGLVL=2\n//CNTL   DD   *\n ACT(DEL)\n MBR(\n   $$DOC\n   $$DSN\n   $$ENTRY\n )\n//\n ACT(DEL)\n VOL(\n  SYSXU3\n )\n//\n ACT(DEL)\n KEY(\n  702917454995\n )\n//\n ACT(DEL)\n DSN(\n  SYSX.JOL.LINKLIB\n )\n//\n DSN(\n  WJ.ZB.FILE.D190227.T1825241\n  SYSX.CBT.CNTL.TO.DELETE\n )\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBDBREO": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x14\\x01\\x19\\x08\\x9f\\x01\\x19\\x16\\x7f\\x16(\\x00>\\x00>\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-03-30T00:00:00", "modifydate": "2019-06-16T16:28:14", "lines": 62, "newlines": 62, "modlines": 0, "user": "DVL"}, "text": "//WFM4DBRO  JOB (1),'DB-reorg',CLASS=A,COND=(0,LT),REGION=64M\n//*\n//* DB reorg sample\n//*\n//   SET     WFMLIB=WFM.WFM4.LIB\n//   JCLLIB  ORDER=&WFMLIB\n//   INCLUDE MEMBER=WFMSET\n//*\n//* DB unload\n//*\n//DBULX    EXEC PGM=IEFBR14\n//DSNDS    DD DISP=(MOD,DELETE),DSN=&DSPFX..DSN.UNLOAD,\n//            UNIT=SYSDA,SPACE=(TRK,1),RECFM=VB,LRECL=100\n//MBRDS    DD DISP=(MOD,DELETE),DSN=&DSPFX..MBR.UNLOAD,\n//            UNIT=SYSDA,SPACE=(TRK,1),RECFM=VB,LRECL=100\n//*\n//DBUL     EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//DSNDB    DD DISP=SHR,DSN=&DBPFX..DSN\n//DSNDS    DD DISP=(,CATLG),DSN=&DSPFX..DSN.UNLOAD,\n//            UNIT=SYSDA,SPACE=(TRK,(15,75),RLSE),\n//            RECFM=VB,LRECL=100\n//MBRDB    DD DISP=SHR,DSN=&DBPFX..MBR\n//MBRDS    DD DISP=(,CATLG),DSN=&DSPFX..MBR.UNLOAD,\n//            UNIT=SYSDA,SPACE=(CYL,(5,50),RLSE),\n//            RECFM=VB,LRECL=100\n REPRO INFILE(DSNDB) OUTFILE(DSNDS)\n REPRO INFILE(MBRDB) OUTFILE(MBRDS)\n//*\n//* DB create + load\n//*\n//DEFDB    EXEC WFMRUN,P='IDCAMS EDIT(SYSIN)'\n//SYSPRINT DD SYSOUT=*\n//DSNI     DD DISP=SHR,DSN=&DSPFX..DSN.UNLOAD\n//MBRI     DD DISP=SHR,DSN=&DSPFX..MBR.UNLOAD\n//SYSIN    DD *\n PARM GRAPHICS(CHAIN(SN))\n /*                          */\n DELETE   &DBPFX..DSN    CLUSTER\n DELETE   &DBPFX..MBR    CLUSTER\n SET MAXCC = 0\n /* Dataset database         */\n DEFINE CLUSTER( -\n          NAME(&DBPFX..DSN)     -\n          CYLINDER(2 2) -\n          KEYS(12 0)  -\n          RECORDSIZE(50 100) -\n          SHR(3,3) -\n          VOL(&DBVOL) -\n         ) -\n         INDEX(CISZ(4096))\n /* Member database         */\n DEFINE CLUSTER( -\n          NAME(&DBPFX..MBR)     -\n          CYLINDER(20 20) -\n          KEYS(20 0)  -\n          RECORDSIZE(50 100) -\n          SHR(3,3) -\n          VOL(&DBVOL) -\n         ) -\n         INDEX(CISZ(4096))\n REPRO INFILE(MBRI) OUTDATASET(&DBPFX..MBR)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBDBRLD": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00U\\x01\\x19\\x08?\\x01\\x19\\x08_\\x14D\\x00\\x0c\\x00\\x12\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-03-26T14:44:55", "lines": 12, "newlines": 18, "modlines": 0, "user": "DVL"}, "text": "//WFM4DBRL  JOB (1),'DB-reload',CLASS=A,COND=(0,LT),REGION=64M\n//*\n//* DB reload sample\n//*\n//DBRL     EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//DSNDS    DD DISP=SHR,DSN=Z.WFM4.DSN.UNLOAD\n//DSNDB    DD DISP=OLD,DSN=Z.WFM4.DSN\n//MBRDS    DD DISP=SHR,DSN=Z.WFM4.MBR.UNLOAD\n//MBRDB    DD DISP=OLD,DSN=Z.WFM4.MBR\n REPRO INFILE(DSNDS) OUTFILE(DSNDB)\n REPRO INFILE(MBRDS) OUTFILE(MBRDB)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBDBUNL": {"ttr": 2065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x008\\x01\\x19\\x08?\\x01\\x19\\x16\\x7f\\x16(\\x00\\x1a\\x00\\x08\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-06-16T16:28:38", "lines": 26, "newlines": 8, "modlines": 0, "user": "DVL"}, "text": "//WFM4DBUL  JOB (1),'DB-unload',CLASS=A,COND=(0,LT),REGION=64M\n//*\n//* DB unload sample\n//*\n//   SET WFMLIB=WFM.WFM4.LIB\n//   JCLLIB ORDER=&WFMLIB\n//   INCLUDE MEMBER=WFMSET\n//*\n//DBULX    EXEC PGM=IEFBR14\n//DSNDS    DD DISP=(MOD,DELETE),DSN=&DSPFX..DSN.UNLOAD,\n//            UNIT=SYSDA,SPACE=(TRK,1),RECFM=VB,LRECL=100\n//MBRDS    DD DISP=(MOD,DELETE),DSN=&DSPFX..MBR.UNLOAD,\n//            UNIT=SYSDA,SPACE=(TRK,1),RECFM=VB,LRECL=100\n//*\n//DBUL     EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//DSNDB    DD DISP=SHR,DSN=&DBPFX..DSN\n//DSNDS    DD DISP=(,CATLG),DSN=&DBPFX..DSN.UNLOAD,\n//            UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),\n//            RECFM=VB,LRECL=100\n//MBRDB    DD DISP=SHR,DSN=&DBPFX..MBR\n//MBRDS    DD DISP=(,CATLG),DSN=&DBPFX..MBR.UNLOAD,\n//            UNIT=SYSDA,SPACE=(CYL,(50,50),RLSE),\n//            RECFM=VB,LRECL=100\n REPRO INFILE(DSNDB) OUTFILE(DSNDS)\n REPRO INFILE(MBRDB) OUTFILE(MBRDS)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBDBUPD": {"ttr": 2067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00Q\\x01\\x19\\x08O\\x01\\x19\\x16\\x7f\\x16(\\x003\\x00\\n\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2019-03-25T00:00:00", "modifydate": "2019-06-16T16:28:51", "lines": 51, "newlines": 10, "modlines": 0, "user": "DVL"}, "text": "//WFM4DBU  JOB (1),'WFM4UPD-set-catinf',CLASS=A,\n//  COND=(0,LT),REGION=64M\n//*\n//* Ad-hoc update DSN db\n//* -  set blksize\n//* -  set catalog indicator\n//*\n//   SET     WFMLIB=WFM.WFM4.LIB\n//   JCLLIB  ORDER=&WFMLIB\n//   INCLUDE MEMBER=WFMSET\n//*\n//   EXEC RXINSTRM\n//DSNDB   DD DISP=OLD,DSN=Z.WFM4.DSN    <<-- dsn db\n//REXX    DD *\n\n call xmsg 'Update dsn db started'\n cc=RxVsamBa('get dd(dsndb) stem(dsn.)')\n if cc<>0 then exit xmsg('read db rc' cc,8)\n call xmsg dsn.0 +0 'records read'\n\n updn=0\n Do dsnn=1 to dsn.0\n /*if words(dsn.dsnn)<>6 then iterate */\n   parse var dsn.dsnn key vol dsn dso recfm lrecl cat .\n   dsn.dsnn=key vol dsn dso recfm lrecl GetBlkSz(dsn,vol),\n            CatInd(dsn,vol)\n   say left(dsnn,6) dsn.dsnn\n   updn=updn+1\n End\n call xmsg updn 'records updated'\n\n cc=RxVsamBa('put dd(dsndb) stem(dsn.)')\n if cc<>0 then exit xmsg('write db rc' cc,8)\n exit xmsg('db updated')\n\nXMsg: if arg(1)<>'' then say time() arg(1);return word(arg(2) 0,1)\n /* cataloged info */\nCatInd: Procedure\n iscat='N'\n cc=XTSO(\"listc ent('\"arg(1)\"') volume\")\n if cc=0 then do\n   n=$.0\n   cvol = right(word($.n,1),6)\n   if cvol=arg(2) then iscat='Y'\n end\n return iscat\nGetBlkSz: procedure\n if listdsi(\"'\"arg(1)\"' volume(\"arg(2)\")\")=0 then return sysblksize\n return '??'\nXTso: trace off; zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');xtsorc=rc;return rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBMAINT": {"ttr": 2069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01-\\x005\\x01\\x19\\x06_\\x01\\x19\\x10_\\x17X\\x00\\x16\\x00\\x0f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.45", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-04-15T17:58:35", "lines": 22, "newlines": 15, "modlines": 0, "user": "DVL"}, "text": "//WFM4DBM$  JOB (1),'WFM-DB-MAINT',\n//*  RESTART=WFMDBX.WFMDBXS1,\n//          CLASS=A,COND=(0,LT),REGION=64M\n//*\n//         SET WFMLIB=Z.WFM4.LIB\n//         JCLLIB ORDER=&WFMLIB\n//         INCLUDE MEMBER=WFMSET\n//*\n//* Delete duplicate dsn records and orphaned mbr records\n//*\n//DBM      EXEC WFMDBM,TEST='ALL'\n//*\n//* Merge database and VTOC lists, generate DB del and DB add\n//*\n//         EXEC WFMDWD           Delete work dataset(s)\n//         EXEC WFMAWD           Create work dataset(s)\n//         EXEC WFMVTC           VTOC extract\n//         EXEC WFMDBX           Extract data from dsn db\n//         EXEC WFMMDV           Merge dsn DB and VTOC data\n//         EXEC WFMDBD           DB delete\n//         EXEC WFMDBA           DB add\n//         EXEC WFMDWD           Delete work datasets\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBMIGR": {"ttr": 2071, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x16\\x01\\x19\\x08?\\x01\\x19\\x16\\x7f\\x16%\\x00\\x16\\x00\\x01\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-06-16T16:25:16", "lines": 22, "newlines": 1, "modlines": 0, "user": "DVL"}, "text": "//WFM4MIGR  JOB (1),'DB-MIGR',CLASS=A,COND=(0,LT),REGION=64M\n//*\n//* Migeate database from v3 to v4 (sample)\n//*\n//*\n//* Copy dsndb\n//*\n//CPDSN    EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//V3DSNDB  DD DISP=SHR,DSN=Z.WFM3.DSN\n//V4DSNDB  DD DISP=SHR,DSN=Z.WFM4.DSN\n REPRO INFILE(V3DSNDB) OUTFILE(V4DSNDB)\n//*\n//* Copy mbrdb, reformat records\n//*\n//CPMBR    EXEC PGM=SORT\n//SYSOUT   DD SYSOUT=*\n//SORTIN   DD DISP=SHR,DSN=Z.WFM3.MBR\n//SORTOUT  DD DISP=SHR,DSN=Z.WFM4.MBR\n SORT FIELDS=COPY\n OUTREC BUILD=(1,4,5,20,33)\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBPRMCR": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00G\\x01\\x19\\x08/\\x01\\x19\\x16\\x7f\\x16(\\x00%\\x00\\x15\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2019-03-23T00:00:00", "modifydate": "2019-06-16T16:28:47", "lines": 37, "newlines": 21, "modlines": 0, "user": "DVL"}, "text": "//WFM4PMCR JOB (1),'ALLOCDS',CLASS=A,COND=(0,LT),REGION=64M\n//*\n//         SET WFMLIB=WFM.WFM4.LIB\n//         JCLLIB ORDER=&WFMLIB\n//         INCLUDE MEMBER=WFMSET\n//*\n//* NOTE - IF YOU CHANGE THE DSNTYPE TO AN ORDINARY LIBRARY THEN\n//*        YOU MUST ALSO DO REGULAR COMPRESS.\n//*\n//         EXEC RXINSTRM\n//LASTDATE DD UNIT=SYSDA,DISP=(,PASS),DSN=&&LASTDATE,\n//            RECFM=FB,LRECL=80,BLKSIZE=4080,\n//            SPACE=(TRK,(5,5))\n//REXX     DD *\n /* generate yesterday like  2019-04-17 */\n ld = date('b')-1\n ld = date('s',ld,'b')\n ld.1 = Insert('-',Insert('-',ld,6),4)\n \"execio 1 diskw lastdate (stem ld. finis)\"\n//*\n//U1       EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(,CATLG),DSN=&PARMDS,DSNTYPE=LIBRARY,\n//            UNIT=SYSDA,VOL=SER=&DSVOL,\n//            RECFM=FB,LRECL=80,SPACE=(TRK,(2,1,1))\n//SYSIN    DD *\n./ ADD NAME=DISKLIST\nVOL(\n  ALL\n)\n./ ADD NAME=VOLSEL\nINCLUDE(\n)\nEXCLUDE(\n)\n./ ADD NAME=LASTDATE\n//         DD DISP=OLD,DSN=&&LASTDATE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBUPDDL": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00$\\x01\\x19\\x07\\x0f\\x01\\x19\\x16\\x7f\\x16(\\x00\\x1d\\x000\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-06-16T16:28:24", "lines": 29, "newlines": 48, "modlines": 0, "user": "DVL"}, "text": "//WFM4UPDL JOB (1),'WFM4UPD-dslist',CLASS=A,\n//  MSGCLASS=T,COND=(0,LT),REGION=64M\n//*\n//* Update database by specific vol/dsn list\n//*\n//   SET     WFMLIB=WFM.WFM4.LIB\n//   JCLLIB  ORDER=&WFMLIB\n//   INCLUDE MEMBER=WFMSET\n//*\n//* Prep\n//*\n//DWD      EXEC WFMDWD\n//AWD      EXEC WFMAWD\n//*\n//* Make dataset update list\n//*\n//UDL      EXEC WFMUDL\n//SYSIN    DD *\n* Datasetlist - dsname volser, or just dsname\n* Input is not case sensitive\n* Blank lines are ignored\n* Asterix in col1 means comment\nADCD.Z113.LINKLIB\ntcpip.aezadbr1  zddis6\n//*\n//* Update DBs\n//*\n//DEL      EXEC WFMDBD\n//ADD      EXEC WFMDBA\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBUPDSH": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x15\\x01\\x19\\x06\\x8f\\x01\\x19\\x16\\x7f\\x16(\\x00\\x1f\\x00\\x1b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2019-03-09T00:00:00", "modifydate": "2019-06-16T16:28:15", "lines": 31, "newlines": 27, "modlines": 0, "user": "DVL"}, "text": "//WFM4UPSH JOB (1),'WFM4UPD-SMF-hist',CLASS=A,\n//* RESTART=WFMDBDS1,\n//  COND=(0,LT),REGION=64M\n//*\n//* WFM update DBs using SMF history dataset\n//*\n//   SET WFMLIB=WFM.WFM4.LIB\n//   JCLLIB ORDER=&WFMLIB\n//   INCLUDE MEMBER=WFMSET\n//*\n//* Prepare\n//*\n//   EXEC WFMDWD           delete work datasets\n//*\n//* Make control records, default date is in parm(lastdate) mbr\n//*\n//   EXEC WFMCTL  ,DATE='2019-03-27,2019-03-27'\n//*\n//* Extract data\n//*\n//   EXEC WFMSMH           SMF extract from history dataset\n//*\n//* Update databases\n//*\n//*  EXEC WFMVSL           filter volser\n//   EXEC WFMDBD           DB delete\n//   EXEC WFMDBA           DB add\n//*\n//* Cleanup\n//*\n//   EXEC WFMDWD           delete work datasets\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBUPDSL": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00 \\x01\\x19\\x06\\x8f\\x01\\x19\\x16\\x7f\\x16(\\x00\\x1f\\x00\\x1b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "2019-03-09T00:00:00", "modifydate": "2019-06-16T16:28:20", "lines": 31, "newlines": 27, "modlines": 0, "user": "DVL"}, "text": "//WFM4UPSL JOB (1),'WFM4UPD-SMF-log',CLASS=A,\n//* RESTART=WFMDBDS1,\n//  MSGCLASS=T,COND=(0,LT),REGION=64M\n//*\n//* WFM update DBs using SMF log data\n//*\n//   SET WFMLIB=WFM.WFM4.LIB\n//   JCLLIB ORDER=&WFMLIB\n//   INCLUDE MEMBER=WFMSET\n//*\n//* Prepare\n//*\n//   EXEC WFMDWD           delete work datasets\n//*\n//* Make control records, default date is in parm(lastdate) mbr\n//*\n//   EXEC WFMCTL  ,DATE='2019-03-27,2019-03-27'\n//*\n//* Extract data\n//*\n//   EXEC WFMSML           SMF extract from logstream\n//*\n//* Update databases\n//*\n//*  EXEC WFMVSL           filter volser\n//   EXEC WFMDBD           DB delete\n//   EXEC WFMDBA           DB add\n//*\n//* Cleanup\n//*\n//   EXEC WFMDWD           delete work datasets\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JOBUPDVT": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00I\\x01\\x19\\x08\\x0f\\x01\\x19\\x16\\x7f\\x16(\\x00\\x1e\\x00\\x1c\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2019-03-21T00:00:00", "modifydate": "2019-06-16T16:28:49", "lines": 30, "newlines": 28, "modlines": 0, "user": "DVL"}, "text": "//WFM4UPVT JOB (1),'WFM4UPD-VTOC',CLASS=A,\n//* RESTART=DBVTS1,\n//         MSGCLASS=T,COND=(0,LT),REGION=64M\n//*\n//* List VTOC, add all po/pe to DB\n//*\n//         SET     WFMLIB=WFM.WFM4.LIB\n//         JCLLIB  ORDER=&WFMLIB\n//         INCLUDE MEMBER=WFMSET\n//*\n//* Prepare\n//*\n//         EXEC WFMDWD           Delete work datasets\n//*\n//* Extract\n//*\n//         EXEC WFMVTC,LISTDS=&DSPFX..UPD\n//DISKLIST DD *\n* VOL(one or more volser or volser prefix in one or more lines)\n vol(\n  sysxs1\n )\n//*\n//* Add\n//*\n//         EXEC WFMDBA\n//*\n//* Cleanup\n//*\n//         EXEC WFMDWD           Delete work datasets\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PDSMAIN": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x19\\x16\\x7f\\x01\\x19\\x16\\x7f\\x16(\\x12\\x9b\\x12\\x9b\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-06-16T00:00:00", "modifydate": "2019-06-16T16:28:47", "lines": 4763, "newlines": 4763, "modlines": 0, "user": "DVL"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "RXINSTRM": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00'\\x01\\x19\\x16o\\x01\\x19\\x16o\\x19E\\x00\\n\\x00\\n\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-06-15T00:00:00", "modifydate": "2019-06-15T19:45:27", "lines": 10, "newlines": 10, "modlines": 0, "user": "DVL"}, "text": "//RXINSTRM PROC EXEC1=&WFMLIB,EXEC2=&WFMLIB,\n//             REXXDD='REXX',P='',DNBR=500,PGMN=IKJEFT1B\n//R        EXEC PGM=&PGMN,\n//         PARM='RXINSTRX REXXDD=&REXXDD &P',DYNAMNBR=&DNBR\n//SYSEXEC  DD DISP=SHR,DSN=&EXEC1\n//         DD DISP=SHR,DSN=&EXEC2\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//REXX     DD DDNAME=SYSIN\n//         PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RXINSTRX": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00!\\x01\\x05\\x14\\x1f\\x01\\x19\\x00O\\x16\\x02\\x00A\\x00N\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2005-05-21T00:00:00", "modifydate": "2019-01-04T16:02:21", "lines": 65, "newlines": 78, "modlines": 0, "user": "DVL"}, "text": "/* ------------------------------------------------------------ REXX\n\n name  : RXINSTRX\n desc  : Allow a REXX program to be supplied instream, instead of\n         having to be a pds member.\n parms :\n input : Libref REXX contains the REXX program.\n sample JCL\n  //GO       EXEC PGM=IKJEFT1B,PARM=RXINSTRX\n  //SYSEXEC  DD  DISP=SHR,DSN=your.exec.lib\n  //         DD  DISP=SHR,DSN=rxinstrm.exec.lib\n  //SYSTSPRT DD  SYSOUT=*\n  //SYSTSIN  DD  DUMMY\n  //REXX     DD  *\n    say 'hello world'\n\n history:\n 2019-01-04  rename to RXINSTRM->RXINSTRX so it can be shipped in the\n             same lib as the procedure RXINSTRM.\n 2016-10-16  add parm REXDD=ddname\n 2014-03-30  major rewrite\n\n ------------------------------------------------------------------ */\n\n parse arg prm\n rxdd='REXX'\n if left(translate(prm),7)='REXXDD=' then do\n   parse var prm . '=' rxdd prm\n end\n Address TSO\n\n /*-------------------------------------------------------------------\n                            allocate temp pds\n --------------------------------------------------------------------*/\n tempname='zzz'right(time('s'),5,0)\n cc=bpxwdyn('alloc new rtddn(rxinddn) rtdsn(rxindsn)',\n             'da(&&rxinstrm('rxinname')',\n             'lrecl(80) recfm(f,b) blksize(0)',\n             'tracks space(8,8) dir(8) dsorg(po) unit(vio)')\n if cc<>0 then call close 8  \"Alloc temppds failed\" cc\n\n /*-------------------------------------------------------------------\n                write inline REXX to temp pds and run it\n --------------------------------------------------------------------*/\n \"Execio * diskr\" rxdd \"(stem data. finis)\"\n if rc<>0 then call close 8  \"Read data failed\" rc\n if pos('REXX',translate(data.1))=0 then,      /* add REXX if not     */\n   data.1=left(strip(data.1,'t'),72)'/*rexx*/' /* already there       */\n parse value 1+data.0 1+data.0 ' Exit 0' with n data.0 data.n\n \"execio\" data.0 \"diskw\" rxinddn \"(stem data. finis)\"   /* save */\n if rc<>0 then call close 8  \"write temp failed\" rc\n\n \"ex '\"rxindsn\"(\"rxinname\")' '\"prm\"'\"\n if datatype(rc)='NUM' then if rc<>0 then call close rc\n call close 0\n\n /*-------------------------------------------------------------------\n                                terminate\n --------------------------------------------------------------------*/\nClose:\n cc=BpxWdyn(\"free dd(\"rxinddn\")\")\n parse arg _rc _msg\n if _msg<>'' then say _msg\n _rc=word(_rc 0,1)\n Exit _rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXVSAMBA": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x19\\x16\\x7f\\x01\\x19\\x16\\x7f\\x16(\\x01w\\x01w\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-06-16T00:00:00", "modifydate": "2019-06-16T16:28:47", "lines": 375, "newlines": 375, "modlines": 0, "user": "DVL"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "VTOC": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x19\\x16\\x7f\\x01\\x19\\x16\\x7f\\x16(\\x01\\n\\x01\\n\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-06-16T00:00:00", "modifydate": "2019-06-16T16:28:47", "lines": 266, "newlines": 266, "modlines": 0, "user": "DVL"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "WFMAWD": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00Q\\x01\\x19\\x08\\x0f\\x01\\x19\\x10o\\x18Y\\x00\\x08\\x00\\x08\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-21T00:00:00", "modifydate": "2019-04-16T18:59:51", "lines": 8, "newlines": 8, "modlines": 0, "user": "DVL"}, "text": "//WFMAWD   PROC\n//*\n//* Allocate some work datasets\n//*\n//WFMAWDS1 EXEC PGM=IEFBR14\n//DD1      DD DISP=(MOD,CATLG),DSN=&DSPFX..UPD,LRECL=51,RECFM=FB,\n//            UNIT=SYSDA,SPACE=(51,(2,2)),AVGREC=K,VOL=SER=&DSVOL\n//WFMAWD   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMCNTL": {"ttr": 4614, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x03\\x01\\x19\\x10o\\x01\\x19\\x10\\x7f\\x15U\\x00A\\x00\\x0e\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2019-04-16T00:00:00", "modifydate": "2019-04-17T15:55:03", "lines": 65, "newlines": 14, "modlines": 0, "user": "DVL"}, "text": " /*                                                                      rexx\n  Subroutine - read CNTL file, make parsable\n  Parameters:\n    DD(ddname)            libref for data file\n    ALIAS(alias-list)     keyword alias list\n    VAL(valid-list)       list of valid keywords\n    REQ(reqd-list)        list of required keywords\n */\n arg p\n parse var p . 'DD('dd')' .    0 . 'ALIAS('alias')' .,\n           0 . 'VAL('vall')' . 0 . 'REQ('reql')' .\n dd=word(dd 'CNTL',1)\n\n \"execio * diskr\" dd \"(stem ctl. finis)\"\n if rc<>0 then exit 'ERR('rc')'\n\n ctl=''\n do n=1 to ctl.0\n   if left(ctl.n,1)='*' then iterate\n   ctl=ctl space(ctl.n)\n end\n\n /* drop blanks before '(' and ')' i.e. VOL ( list )  -> VOL(list) */\n ctl=translate(space(ctl))\n do while pos(' (',ctl)>0\n   ctl=delstr(ctl,pos(' (',ctl),1)\n end\n do while pos('( ',ctl)>0\n   ctl=delstr(ctl,pos('( ',ctl)+1,1)\n end\n do while pos(' )',ctl)>0\n   ctl=delstr(ctl,pos(' )',ctl),1)\n end\n\n /* handle cmd alias, i.e.\n   alias='EXC EXCLUDE INC INCLUDE'\n   ctl='EXC(lst)' -> ctl='EXCLUDE(lst)'\n */\n do an=1 to words(alias) by 2\n   p=pos(word(alias,an)'(',translate(ctl))+1\n   if p=1 then iterate\n   parse value ' 'ctl with s1 =(p) . '(' s2\n   ctl=space(s1 word(alias,an+1)'('s2)\n end\n\n /* test valid */\n if vall<>'' then do\n   s=ctl\n   do while s<>''\n     parse value strip(s) with k'(' . ')' s\n     if wordpos(k,vall)=0 then exit 'ERR('k 'not valid)'\n   end\n end\n\n /* test required */\n if reql<>'' then do\n   s=ctl\n   do while s<>''\n     parse value strip(s) with k'(' . ')' s\n     if wordpos(k,reql)>0 then reql=delword(reql,wordpos(k,reql),1)\n   end\n   if reql<>'' then exit 'ERR(Missing verbs(s)' reql')'\n end\n\n exit ctl\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMCTL": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00A\\x01\\x19\\x06_\\x01\\x19\\x10\\x8f\"\\'\\x00\\x15\\x00\\n\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-04-18T22:27:41", "lines": 21, "newlines": 10, "modlines": 0, "user": "DVL"}, "text": "//WFMCTL   PROC DATE=,DISK=\n//*\n//* Generate control data for other steps\n//* Allocate some general datasets\n//*\n//WFMCTLS1 EXEC PGM=IKJEFT1B,\n//            PARM='%WFMCTLX1 DATE(&DATE) DISK(&DISK)'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//LASTDATE DD DISP=SHR,DSN=&PARMDS(LASTDATE)\n//SMFLDATE DD DISP=SHR,DSN=&PARMDS(SMFLDATE)\n//SMFHDATE DD DISP=SHR,DSN=&PARMDS(SMFHDATE)\n//SMFDISK  DD DISP=SHR,DSN=&PARMDS(SMFDISK)\n//DDBDISK  DD DISP=SHR,DSN=&PARMDS(DDBDISK)\n//VTOCDISK DD DISP=SHR,DSN=&PARMDS(VTOCDISK)\n//VTOCDATE DD DISP=SHR,DSN=&PARMDS(VTOCDATE)\n//UPD      DD DISP=(MOD,CATLG),DSN=&DSPFX..UPD,LRECL=51,RECFM=FB,\n//            UNIT=SYSDA,SPACE=(51,(2,2),RLSE),AVGREC=K\n//WFMCTL   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMCTLX1": {"ttr": 4618, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x06\\x01\\x19\\x06_\\x01\\x19\\t?\\x07\\x05\\x00l\\x00\\x13\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-04-03T07:05:06", "lines": 108, "newlines": 19, "modlines": 0, "user": "DVL"}, "text": "/*                                                              rexx\n\n  Generate control data for other steps\n\n*/\n\n parse value '' with date1 date2\n arg p\n\n say 'WFM control data generator started at' todayd() '('date('j')')' time()\n if p<>'' then call Listp 'Parameters',p\n else say 'No parameters'\n parse var p . 'DATE('$date')' ,\n           0 . 'DISK('$disk')' ,\n           .\n\n /* get date(s) from parm or dataset */\n if $date<>'' then do      /* date from parm    */\n   say 'Using date from parm'\n   parse var $date date1','date2\n   date2 = word(date2 date1,1)\n end\n else do                   /* date from dataset */\n   \"execio 1 diskr lastdate (stem r. finis)\"\n   if rc=0 then do\n     Call Listp  'Old lastdate record',r.1\n     olddate = word(r.1,1)\n     date1 = ud2bd(olddate)+1\n     if date1>ysday() then exit xmsg('Update already run',4)\n     date1 = bd2sd(date1)\n   end\n   else say 'Read lastdate rc' rc', will use default'\n end\n if date1<>'' then date1 = ud2bd(date1)\n else date1 = ToDay()-2\n if date2<>'' then date2 = ud2bd(date2)\n else date2 = ToDay()-1\n call listp 'Date range',bd2dd(date1)','bd2dd(date2)\n if date1>date2 then exit xmsg('Invalid daterange',8)\n\n /* update lastdate in dataset */\n if $date='' then do /* rewrite if read from file */\n   r.1=bd2dd(date2) '    was:' olddate 'latest run:' todayd() time()\n   Call Listp  'New lastdate record',r.1\n   \"execio 1 diskw lastdate (stem r. finis)\"\n end\n\n /* SMF dump date               */\n r.1 = ' DATE('bd2ljd(date1)','bd2ljd(date2)')'\n Call Listp  'SMF dump date',r.1\n \"execio 1 diskw smfldate (stem r. finis)\"\n\n /* SMF history ds date (sort)  */\n r.1 = \"            OR,11,4,BI,LT,X'\"bd2smf(date1)\"',\",\n    ||             \"OR,11,4,BI,GT,X'\"bd2smf(date2)\"',\"\n Call Listp  'SMF history date',r.1\n \"execio 1 diskw smfhdate (stem r. finis)\"\n\n /* disk record for dsn db      */\n if $disk='' then r.1 = '* all disks'\n else r.1 = ' INCLUDE COND=(18,'length($disk)',CH,EQ,C'''$DISK''')'\n Call Listp  'Dsn DB daterec',r.1\n \"execio 1 diskw ddbdisk (stem r. finis)\"\n\n /* disk record for sorts  */\n if $disk='' then r.1 = '* all disks'\n else r.1 = ' INCLUDE COND=(1,'length($disk)',CH,EQ,C'''$DISK''')'\n \"execio 1 diskw smfdisk (stem r. finis)\"\n Call Listp  'SORT disk record',r.1\n\n /* disk record for VTOC  */\n if $disk='' then r.1 = '  ALL -'\n else r.1 = '   '$disk '-'\n Call Listp  'VTOC disk record',r.1\n \"execio 1 diskw vtocdisk (stem r. finis)\"\n\n /* date records for VTOC  */\n r.1= '   AND1(REFDT,GE,'bd2jd(date1)') AND2(REFDT,LE,'bd2jd(date2)') +'\n Call Listp  'VTOC date record',r.1\n \"execio 1 diskw vtocdate (stem r. finis)\"\n\n say 'WFM control data generator ended at' date('s') time()\n exit 0\n\nListp: trace off; say left(arg(1),20) strip(arg(2));return 0\nXMsg:  trace off; if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n/* date conversions */\nsd2bd:  return date('b',arg(1),'s')\ndd2bd:  return date('b',space(translate(arg(1),' ','-'),0),'s')\njd2bd:  return date('b','20'left(arg(1),2)'0101','s')-1+substr(arg(1),3)\nljd2bd: return date('b',    left(arg(1),4)'0101','s')-1+substr(arg(1),5)\nbd2jd:  return substr(Date('S',arg(1),'B'),3,2)Right(Date('d',arg(1),'B'),3,0)\nbd2ljd: return Left(bd2sd(arg(1)),2)bd2jd(arg(1))\nbd2sd:  return date('s',arg(1),'b')\nbd2dd:  return Insert('-',Insert('-',bd2sd(arg(1)),6),4)\nbd2y2:  return substr(Date('S',arg(1),'B'),3,2)\nbd2y4:  return left(Date('S',arg(1),'B'),4)\nud2bd:  trace off\n if arg(1)='' then return date('b')\n if pos('-',arg(1))>0 then return dd2bd(arg(1))     /* dashed                */\n if length(arg(1))=8  then return sd2bd(arg(1))     /* standard              */\n if length(arg(1))=5  then return jd2bd(arg(1))     /* julian                */\n if length(arg(1))=7  then return ljd2bd(arg(1))    /* long julian           */\n return    arg(1)                                   /* assume base           */\ntoday:  return date('b')\nysday:  return date('b')-1\nbd2smf: return '01'bd2jd(arg(1))'F'                 /* century 20xx forced   */\ntodayd: return bd2dd(date('b'))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDBA": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00\\x16\\x01\\x19\\x06_\\x01\\x19\\x11\\x1f\\x150\\x00\\x16\\x00\\xb2\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-04-21T15:30:16", "lines": 22, "newlines": 178, "modlines": 0, "user": "DVL"}, "text": "//WFMDBA   PROC MSGLVL=1,UPDLIST=&DSPFX..UPD,TYPRUN=RUN\n//*\n//* Add records to the databases\n//* Typrun(SIM | RUN)\n//*\n//WFMDBAS1 EXEC PGM=IKJEFT1B,\n// PARM=('WFMDBAX1 MSGLVL(&MSGLVL) SORTU(&SORTU) TYPRUN(&TYPRUN)',\n//       'PDSMAIN(&PDSMAIN)')\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//DSNDB    DD DISP=SHR,DSN=&DBPFX..DSN\n//MBRDB    DD DISP=SHR,DSN=&DBPFX..MBR\n//UPDLIST  DD DISP=SHR,DSN=&UPDLIST\n//DSNDBIN  DD UNIT=SYSDA,RECFM=VB,LRECL=120,SPACE=(CYL,(1,5))\n//MBRDBIN  DD UNIT=SYSDA,RECFM=VB,LRECL=120,SPACE=(CYL,(5,50))\n//SYSOUT   DD UNIT=VIO,SPACE=(TRK,(5,5))\n//SYSIN    DD UNIT=VIO,RECFM=FB,LRECL=80,SPACE=(TRK,(1,1))\n//DFSPARM  DD UNIT=VIO,RECFM=FB,LRECL=80,SPACE=(TRK,(1,1))\n//*\n//WFMDBA   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMDBAX1": {"ttr": 4623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01W\\x00Y\\x01\\x19\\x06_\\x01\\x19\\x11\\x1f\\x150\\x01\\x0e\\x00\\xa7\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.87", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-04-21T15:30:59", "lines": 270, "newlines": 167, "modlines": 0, "user": "DVL"}, "text": "/*                                                                   REXX\n  WFM4ADD - Add records to dsn and mbr dbs based on datasetname list\n*/\n call xmsg 'Add database records, parm:' arg(1)\n\n call xtso \"profile\"\n $nomsgid=(wordpos('NOMSGID',$.1)>0)\n if $nomsgid then do\n   call xtso \"profile msgid\"\n   say 'Profile MSGID set temporarily'\n end\n\n $et = time('e')\n parse value copies('0 ',20) with $rc $msglvl .\n $indent = '       '\n arg p\n p=space(translate(p,' ',','))\n parse var p . 'MSGLVL('$msglvl')' . 0 . 'SORTU('$sortu')' .,\n           0 . 'TYPRUN('$typrun')' . 0 . 'PDSMAIN('$pdsmain')' .\n $msglvl =word($msglvl 0,1)\n $pdsmain=word($pdsmain 'PDSMAIN',1)\n $sortu =word($sortu 'N',1)\n if wordpos($sortu,'N Y')=0 then exit xmsg('Invalid sortu',8)\n if wordpos($typrun,'SIM RUN')=0 then exit xmsg('Invalid typrun',8)\n say 'Msglvl:' $msglvl\n say 'Sortu: ' $sortu\n say 'Typrun:' $typrun\n\n /* read and filter dsn list */\n call xmsg 'Read and format dsn list'\n \"execio * diskr updlist (stem updl. finis)\"\n if rc<>0 then call quit 8,'Read updlist rc' rc\n call xmsg updl.0 'records read from list'\n /* drop 'delete' records */\n nn=0\n do n=1 to updl.0\n   if left(updl.n,1)='*' ,\n    | substr(updl.n,51,1)='D' then iterate\n   parse value nn+1 strip(left(updl.n,50)) with nn dsnl.nn\n end\n dsnl.0=nn\n call xmsg dsnl.0 'dataset records after dropping deletes'\n drop updl.\n if dsnl.0=0 then call quit 4,'Empty list'\n if $sortu='Y' then do\n   call bpxwunix 'sort -u', 'DSNL.', 'DSNL.', 'STDERR.'\n   call xmsg  dsnl.0 'dataset records after sort-unique'\n end\n if $msglvl>1 then do\n   call xmsg  'Dataset list'\n   do n=1 to dsnl.0\n     say $indent dsnl.n\n   end\n end\n say ''\n\n /* make update lists */\n call xmsg 'Building dataset and member update records'\n mbran=0          /* count all members so far         */\n mbrwn=0          /* count members in write buffer    */\n mbrwmax=1000     /* max count before write to buffer */\n dsaln=0          /* count datasets so far            */\n do dsnln=1 to dsnl.0\n   mbrln=0        /* count members in library         */\n   Call PdsData dsnl.dsnln dsnln\n   if mbrwn<mbrwmax then iterate\n   call xmsg '-write member list for' mbrwn 'at' mbran\n   mbrl.0=mbrwn\n   \"execio\" mbrwn \"diskw mbrdbin (stem mbrl.)\"\n   if rc<>0 then do\n     call xmsg 'Write mbrdbin rc' rc\n     do n=1 to mbrwn\n       say '\"'mbrl.n'\"'\n     end\n     call quit 8,'write mbrdbin rc' rc\n   end\n   mbrwn=0        /* count members in write buffer */\n end\n \"execio\" mbrwn \"diskw mbrdbin (stem mbrl. finis)\"\n drop dsnl.\n dsal.0=dsaln\n call xmsg 'Datasets' dsaln', members' mbran\n say ''\n\n if $typrun='RUN' then do\n\n   /* update dsn db */\n   call xmsg 'Update dsndb with' dsaln 'records'\n   \"execio\" dsaln \"diskw dsndbin (stem dsal. finis)\"\n   if rc >1 then call quit 8,'write dsnlist rc' rc\n   cc=XSort('SORTIN=DSNDBIN,SORTOUT=DSNDB','FIELDS(5,12,CH,A)')\n   if cc<>0 then call quit 12,'Sort rc' cc\n   call xmsg 'Update ok'\n   say ''\n\n   /* update mbr db */\n   if mbran=0 then call quit 4,'No member updates'\n   call xmsg 'Update mbrdb with' mbran 'records'\n   cc=XSort('SORTIN=MBRDBIN,SORTOUT=MBRDB','FIELDS(5,20,CH,A)')\n   if cc<>0 then call quit 8,'Sort rc' cc\n   call xmsg 'Update ok'\n   say ''\n\n end\n else call xmsg 'Add bypassed due to typrun' $typrun\n\n /* process ended */\n call xmsg 'Add ended, elapsed time:' time('e') - $et\n call quit $rc\n\nQuit:\n if $nomsgid then call xtso \"profile nomsgid\"\n if arg(2)<>'' then say time() arg(2)\n exit word(arg(1) 0,1)\n\n /*--------------------------------------------------------------------\n                      Load dataset info\n add dsnlist DSAL.DSAN with key vol dsn type dsorg recfm lrecl cat\n add mbrlist MBRL.MBRN with name||key,\n               id;created;updated;vermod;mod;size;init;,\n               ssi;attr;aliasof\n --------------------------------------------------------------------*/\nPdsData:\n arg p\n parse var p dvol +6 ddsn dnum .\n dkey = date('c'), /* 4 bytes */\n     || left(space(translate(time('l'),' ',':.'),0),8) /* 8 bytes */\n\n Call xmsg 'Dataset' ddsn 'on' dvol '('dnum 'of' dsnl.0')'\n cc=Listdsi(\"'\"ddsn\"' volume(\"dvol\")\")\n if cc=16 & sysreason=24   then return  Xmsg('Not found')\n if cc<>0                  then return  Xmsg('Listdsi rc' cc ,\n                           'reason('sysreason')' listdsic(sysreason))\n if left(sysdsorg,2)<>'PO' then return  Xmsg('Not partitioned')\n if sysdssms='PDSE' then sysdsorg='PE'\n sysrecfm=left(space(translate(sysrecfm,' ',','),0),2)\n dsaln=dsaln+1\n /* cataloged info */\n dscat='N'\n cc=XTSO(\"listc ent('\"ddsn\"') volume\")\n if cc=0 then do\n   n=$.0\n   cvol = right(word($.n,1),6)\n   if cvol=sysvolume then dscat='Y'\n end\n\n dsal.dsaln = dkey dvol space(ddsn sysdsorg sysrecfm syslrecl sysblksize dscat)\n\n cc=outtrap('pl.')\n \"\"$PdsMain \"'\"ddsn\"' vol(\"dvol\") attr : short\"\n pcc=rc\n cc=outtrap('off')\n if pcc<>0 then return xmsg('PDSMAIN error' pcc,8)\n\n parse value '0 0 PO' with mln pp dsorg name vermod created id,\n      updated attr size init ssi mod aliasof dsinfo lastname\n\n Do pp=1 to pl.0\n   parse var pl.pp w1 w2 w3 .\n   Select\n     when w1='PDS230I' & w3='VER.MOD' then iterate\n     when w1='PDS232I' & w3='ALIASOF' then iterate\n     when w1='PDS230I' | w1='PDS232I' then do\n       parse value '' with name vermod created id,\n          updated attr size init ssi mod aliasof\n       if w1='PDS230I' then do  /*  srclib */\n         if w3='SSI:' then parse var pl.pp . =10 name +8 . ssi .\n         else,\n           parse var pl.pp . =10 name +8 . =21 vermod =29 created +8 .,\n           =39 updated =54 size =60 init =66 mod =73 id\n       end\n       else ,                   /*  pgmlib */\n         parse var pl.pp . =9 name =18 aliasof,\n           =27 created =36 size =42 ssi =51 attr\n       if pos('.',name)>0 then do\n         call xmsg name 'invalid member name, ignored'\n         iterate\n       end\n       if name=lastname then do\n         call xmsg name 'duplicate member name, ignored'\n         iterate\n       end\n       lastname=name\n       mbrln=mbrln+1\n       mbrwn=mbrwn+1   /* update # members in write buffer */\n       mbrl.mbrwn=left(strip(name),8,'\\')dkey,\n       || space(id';'created';'updated';'vermod';'mod';'size';'init';',\n              ssi';'attr';'aliasof,0)\n     end\n     when w1='PDS400W' then return xmsg('Empty library',1)\n     when w1='PDS530W' then return xmsg('Not a library',2)\n  /* when w1='PDS531W' then dsal.dsaln=overlay('PE',dsal.dsaln,66)   pdse*/\n     otherwise nop\n   end\n end\n mbran=mbran+mbrln     /* update # members so far          */\n call xmsg 'Member records:' mbrln 'totals so far:' mbran\n return 0\nl8: return left(strip(arg(1)),8)\n/*\nDataset info\n----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\nPDS200I DISP UNIT     RECFM LRECL BLKSIZE   ALLOCTRK FREETRK SECONDARY FREEDIR\nPDS200I SHR  3390     FB       80    5600   1X     7       0     3 TRK       5\n\nSrclib member info\nPDS230I MEMBER      VER.MOD  CREATED   LAST MODIFIED  SIZE  INIT   MOD   ID\nPDS230I  $$$#DATE    01.00  02/09/29  02/09/29 22:29    12    12     0  SHIPDAT\n\nPgmlib member info\nPDS232I NAME     ALIASOF   CREATED  SIZE SSI      ATTRIBUTES\nPDS232I MSGXRBL           17/01/20  5800          R24, A31\n*/\nXMsg: if arg(1)<>'' then say time() arg(1);return word(arg(2) 0,1)\nXTso: trace off; zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');xtsorc=rc;return rc\n\nXSort:\n r.1 = ' OPTION' translate(arg(1))\n \"execio 1 diskw dfsparm (stem r. finis)\"\n r.1 = ' SORT' translate(arg(2))\n \"execio 1 diskw sysin  (stem r. finis)\"\n \"Call *(SORT)\"\n src=rc\n if src<>0 then do\n   \"execio * diskr sysout (stem sout. finis)\"\n   do n=1 to sout.0\n     say sout.n\n   end\n   return xmsg('SORT rc' src,8)\n end\n Return 0\n\nListDsiC: Procedure\n t.0 ='Normal completion.'\n t.1 ='Error parsing the function.'\n t.2 ='Dynamic allocation processing error.'\n t.3 ='The data set is a type that cannot be processed.'\n t.4 ='Error determining UNIT name.'\n t.5 ='Data set not cataloged.'\n t.6 ='Error obtaining the data set name.'\n t.7 ='Error finding device type.'\n t.8 ='The data set does not reside on DASD.'\n t.9 ='DFHSM migrated the data set,',\n      'NORECALL prevents retrieval.'\n t.11='Directory information was requested, but you lack',\n      'authority to access the data set.'\n t.12='VSAM data sets are not supported.'\n t.13='The data set could not be opened.'\n t.14='Device type not found in UCB tables.'\n t.17='System or user abend occurred.'\n t.18='Partial data set information was obtained.'\n t.19='Data set resides on multiple volumes.'\n t.20='Device type not found in eligible device table.'\n t.21='Catalog error trying to locate the data set.'\n t.22='Volume not mounted.'\n t.23='Permanent I/O error on volume.'\n t.24='Data set not found.'\n t.25='Data set migrated to non-DASD device.'\n t.27='No volume serial is allocated to the data set.'\n t.28='The ddname must be one to eight characters.'\n t.29='Data set name or ddname must be specified.'\n t.30='Data set is not SMS-managed.'\n t.31='ISITMGD macro returned with bad return code and reason code.',\n      'Return code and reason code can be found in message',\n      'IKJ58431I, which is returned in variable &SYSMSGLVL2.'\n t.32='Unable to retrieve SMS information.',\n      'DFSMS/MVS has incorrect level.'\n n=arg(1)+0\n return t.n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDBD": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x10\\x01\\x19\\x06_\\x01\\x19\\x08\\x7f\\x19\\x07\\x00\\x0f\\x00@\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-03-28T19:07:10", "lines": 15, "newlines": 64, "modlines": 0, "user": "DVL"}, "text": "//WFMDBD   PROC MSGLVL=1,UPDLIST=&DSPFX..UPD,TYPRUN=UPDATE\n//*\n//* Delete records from the databases\n//*\n//WFMDBDS1 EXEC PGM=IKJEFT1B,\n//       PARM='WFMDBDX1 MSGLVL(&MSGLVL) SORTU(&SORTU) TYPRUN(&TYPRUN)'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//DSNDB    DD DISP=SHR,DSN=&DBPFX..DSN\n//MBRDB    DD DISP=SHR,DSN=&DBPFX..MBR\n//UPDLIST  DD DISP=SHR,DSN=&UPDLIST\n//*\n//WFMDBD   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMDBDX1": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00Q\\x01\\x19\\x06_\\x01\\x19\\x16\\x1f\\x10S\\x00Y\\x004\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-06-10T10:53:51", "lines": 89, "newlines": 52, "modlines": 0, "user": "DVL"}, "text": "/*                                                                   REXX\n  WFM4DEL - Delete records in dsn and mbr dbs based on datasetname\n\n  msglvl 0  list statistics\n         1  list datasets and members actually deleted\n         2  list datasets and members potentially and actually deleted\n*/\n call xmsg 'Delete database records, parm:' arg(1)\n $et = time('e')\n $rc = 0\n arg p\n parse var p . 'MSGLVL('$msglvl')' . 0 . 'SORTU('$sortu')' .,\n         . 0 . 'TYPRUN('$typrun')' .\n $msglvl = word($msglvl  0,1)\n $sortu  = word($sortu  'N',1)\n if wordpos($sortu,'N Y')=0 then exit xmsg('Invalid sortu',8)\n $typrun = word($typrun 'UPDATE',1)\n if $typrun='RUN' then $typrun='UPDATE'\n if $typrun='SIM' then $typrun='DRY'\n if wordpos($typrun,'DRY UPDATE')=0 then exit xmsg('Invalid typrun',8)\n say 'msglvl:' $msglvl\n say 'sortu: ' $sortu\n say 'typrun:' $typrun\n\n /* read and filter dsn list */\n call xmsg 'Read and format dsn list'\n \"execio * diskr updlist (stem updi. finis)\"\n call xmsg updi.0 'records read'\n\n /* reformat list */\n ln=0\n do n=1 to updi.0\n   if left(updi.n,1)='*' then iterate\n   r=strip(updi.n)\n   if pos(' ',r)<10 then r=space(subword(r,1,2),0)  /* vol dsn */\n   ln=ln+1\n   updl.ln=strip(left(r,50))    /* drop action char if any */\n end\n updl.0=ln\n call xmsg ln 'records in update list'\n drop updi.\n if $sortu='Y' then do\n   call bpxwunix 'sort -u', 'updl.', 'updl.', 'STDERR.'\n   call xmsg updl.0 'records after sort'\n end\n if $msglvl>1 then say 'Deleting..'\n do n=1 to updl.0\n   updl.n=strip(insert(' ',updl.n,6))\n   if $msglvl>1 then say '    'updl.n\n end\n say ''\n\n /* delete records from dsndb - save keys         */\n if $typrun='UPDATE' then do\n   call xmsg 'Delete dsn db records'\n   cc=RxVsamBa('del dd(dsndb) textstem(updl.) POS(14) ENDPOS('14+6+1+44')',\n               'list(dkey.)')\n   call xmsg 'Delete dsndb rc:' cc+0', records deleted:' rxvbdele+0,\n         ||  ', records remaining in db:' rxvbread-rxvbdele\n   if $msglvl>0 then do n=1 to dkey.0\n     say '   'dkey.n\n   end\n end\n else call xmsg 'Delete dsn records bypassed due to typrun' $typrun\n say ''\n\n /* delete records from mbrdb - sequential access */\n if $typrun='UPDATE' then do\n   call xmsg 'Delete mbr db records'\n   do n=1 to dkey.0\n     dkey.n=left(dkey.n,12)\n     if $msglvl>1 then say dkey.n\n   end\n   cc=RxVsamBa('del dd(mbrdb) textstem(dkey.) POS(9) ENDPOS(20)' ,\n               'list(mdel.)')\n   call xmsg 'Delete mbrdb rc:' cc+0', records deleted:' rxvbdele+0 ,\n         ||  ', records remaining in db:' rxvbread-rxvbdele\n   if $msglvl>1 then do n=1 to mdel.0\n     say '   'mdel.n\n   end\n end\n else call xmsg 'Delete mbr records bypassed due to typrun' $typrun\n say ''\n\n /* process ended */\n call xmsg 'Delete ended, elapsed time=' time('e') - $et\n exit $rc\n\nXMsg: if arg(1)<>'' then say time() arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDBM": {"ttr": 4872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x12\\x01\\x19\\x08\\x7f\\x01\\x19\\x08\\x8f\\x14#\\x00\\r\\x00\\x0c\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-03-28T00:00:00", "modifydate": "2019-03-29T14:23:12", "lines": 13, "newlines": 12, "modlines": 0, "user": "DVL"}, "text": "//WFMDBM   PROC TEST=,MSGLVL=0,TYPRUN=UPDATE\n//* db maintenance, remove duplicate dsns and orphaned mbrs\n//WFMDBMS1 EXEC PGM=IKJEFT1B,\n//         PARM='WFMDBMX1 TEST(&TEST) TYPRUN(&TYPRUN) MSGLVL(&MSGLVL)'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//DSNDB    DD DISP=SHR,DSN=&DBPFX..DSN\n//MBRDB    DD DISP=SHR,DSN=&DBPFX..MBR\n//UPDLIST  DD UNIT=VIO,RECFM=FB,LRECL=80\n//UNLOAD   DD UNIT=SYSDA,SPACE=(CYL,(1,50)),RECFM=VB,LRECL=100\n//         PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMDBMX1": {"ttr": 4874, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00!\\x01\\x19\\x08\\x7f\\x01\\x19\\x08\\x7f\\x190\\x00\\xef\\x00\\xd9\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2019-03-28T00:00:00", "modifydate": "2019-03-28T19:30:21", "lines": 239, "newlines": 217, "modlines": 0, "user": "DVL"}, "text": "/*                                                                    rexx\n   WFM DB Maintenance\n    - drop duplicate dataset records\n    - drop orphaned member records\n\n   Parm\n     TEST(test options)   DUPDS and/or MBR, or ALL\n     MSGLVL(n)            1 shows more messages\n     TYPRUN(t)            DRY ot UPDATE\n*/\n\n vtoc.=''\n vtocn=0\n pdsn.=''\n arg p\n parse var p . 'MSGLVL('$msglvl')' . 0 . 'TYPRUN('$typrun')' .,\n           0 . 'TEST('$test')' .\n $msglvl  = word($msglvl 0,1)\n $typrun  = word($typrun 'UPDATE',1)\n if $test = 'ALL' then $test='DUPDS MBR'   /* ORPH */\n\n if p<>'' then p='parm' p\n call xmsg 'Dsn db maintenance started' p\n say '  Testing ' $test\n say '  Type run' $typrun\n say '  Msglvl  ' $msglvl\n if wordpos($typrun,'UPDATE DRY')=0 then exit xmsg('Invalid typrun',8)\n if $test='' then exit xmsg('Missing test def',8)\n do n=1 to words($test)\n   if wordpos(word($test,n),'DUPDS MBR')=0    /* ORPH */\n     then exit xmsg('Invalid test' word($test,n),8)\n end\n\n if wordpos('DUPDS',$test)>0 then cc=TestDupDs()\n drop dbl. dup.\n\n if wordpos('ORPH',$test)>0 then cc=TestOrphDsn()\n drop dbl. del.\n\n if wordpos('MBR',$test)>0 then cc=TestOrphMbr()\n drop dbl. del.\n\n say ''\n exit xmsg('Maintenance done')\n\nXMsg: if arg(1)<>'' then say time() arg(1);return word(arg(2) 0,1)\nXTso: trace off; zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');xtsorc=rc;return rc\n\n/*\n      test for duplicate dsn entries\n*/\nTestDupDs:\n say ''\n call xmsg 'Testing for duplicate dataset entries'\n\n /* db record sample:\n  1       10        20        30        40        50\n  K---+----+-K--+----+----+----+----+----+----+----+\n  701018190145 ZDDIS1 CDS.ACDSHFS PO VB 255 27998 Y\n */\n /* reformat as vol dsn key */\n call LoadDsnDb\n do n=1 to dbl.0\n   dbl.n = subword(dbl.n,2,2) word(dbl.n,1)\n end\n call bpxwunix 'sort', 'dbl.', 'dbl.', 'STDERR.'\n\n /* check for duplicates */\n call xmsg 'Check for duplicates..'\n dupn=0\n do n=2 to dbl.0\n   m=n-1\n   if subword(dbl.n,1,2)<>subword(dbl.m,1,2) then iterate\n   dupn=dupn+1\n   say '       ' word(dbl.m,3) subword(dbl.m,1,2)\n   say ' dup of' word(dbl.n,3) subword(dbl.n,1,2)\n   dup.dupn=word(dbl.m,3)      /* drop the older dup by key */\n end\n call xmsg 'Duplicates found: 'dupn\n if dupn=0 then return 0\n dup.0=dupn\n\n /* dry run */\n if $typrun='DRY' | $msglvl>0 then do\n   call xmsg 'Update records generated..'\n   do n=1 to dup.0\n     say '  'dup.n\n   end\n   if $typrun='DRY' then return 0\n end\n\n /* Delete from dsndb */\n ddel.0=0\n call xmsg 'Delete from dsndb'\n cc=RxVsamBa('del dd(dsndb) keystem(dup.) list(dell.)')\n if cc<>0 then exit xmsg('Delete failed rc' cc rxvberrm,8)\n call xmsg 'Records deleted:' rxvbdele+0,\n       ||  ', records remaining in db:' rxvbread-rxvbdele\n if $msglvl>1 then do n=1 to ddel.0\n   say '   'ddel.n\n end\n\n /* Delete from mbrdb */\n ddel.0=0\n call xmsg 'Delete from mbrdb'\n cc=RxVsamBa('del dd(mbrdb) textstem(dup.) POS(9) ENDPOS(20) list(ddel.)')\n if cc<>0 then exit xmsg('Delete failed rc' cc rxvberrm,8)\n call xmsg 'Records deleted:' rxvbdele+0,\n       ||  ', records remaining in db:' rxvbread-rxvbdele\n if $msglvl>1 then do n=1 to ddel.0\n   say '   'ddel.n\n end\n return 0\n\n/*\n      test for missing physical datasets\n*/\nTestOrphDsn:\n say ''\n call xmsg 'Testing for orphaned dataset entries'\n\n /* db record sample:\n  1       10        20        30        40        50\n  K---+----+-K--+----+----+----+----+----+----+----+\n  701018190145 ZDDIS1 CDS.ACDSHFS PO VB 255 27998 Y\n */\n call LoadDsnDb\n\n /* do over list  */\n deln=0\n do dbn=1 to dbl.0\n   parse var dbl.dbn key vol dsn .\n   if vtoc.vol='' then Call VTOClist\n   if pdsn.vol.dsn='X' then iterate\n   deln=deln+1\n   del.deln=vol''dsn\n   say '  orphan:' dsn 'on' vol\n end\n call xmsg dbn-1 'datasets tested on' vtocn' disks, orphans:' deln\n\n /* dry run */\n if $typrun='DRY' then do\n   call xmsg 'Delete records generated..'\n   do n=1 to deln\n     say '  'del.n\n   end\n   return 0\n end\n\n /* Do delete  */\n \"execio\" deln \"diskw updlist (stem del. finis)\"\n cc=WfmDbdX1()\n if cc<>0 then exit xmsg('Delete failed rc' cc,8)\n return 0\n\n/*\n      test for orphaned member records\n*/\nTestOrphMbr:\n say ''\n call xmsg 'Testing for orphaned member entries'\n call xmsg 'Offloading data'\n cc=XTSO('repro infile(mbrdb) outfile(unload)')\n if cc<>0 then exit xmsg('Offload mbrdb rc' cc $.1,8)\n call xmsg 'records offloaded:' word($.1,7)\n\n /* make dsndb key list */\n call LoadDsnDb\n keyl.=0\n do n=1 to dbl.0\n   parse var dbl.n k .\n   keyl.k=1\n end\n\n /* read mbr offload, check keys */\n call xmsg 'Processing offloaded member records'\n deln=0\n inpn=0\n do forever\n   \"Execio 10000 diskr unload (stem ul.)\"\n   if ul.0=0 then leave\n   inpn=inpn+ul.0\n   if $msglvl>1 then,\n     call xmsg 'read' inpn 'records so far, orphans so far:' deln\n   do uln=1 to ul.0\n     k=substr(ul.uln,9,12)\n     if keyl.k then iterate /* already used */\n     deln=deln+1\n     say '  orphaned mbr:' ul.uln\n     del.deln=left(ul.uln,20)\n   end\n end\n \"Execio 0 diskr unload (finis)\"\n del.0=deln\n call xmsg  'Orphaned member records found:' del.0\n if del.0=0 then return 0\n\n /* dry run */\n if $typrun='DRY' | $msglvl>0 then do\n   call xmsg 'Update records generated..'\n   do n=1 to del.0\n     say '  'del.n\n   end\n   if $typrun='DRY' then return 0\n end\n\n /* Do delete  */\n rxvberrm=''\n cc=RxVsamBa('del dd(mbrdb) keystem(del.)')\n if cc<>0 then exit xmsg('Delete failed rc' cc rxvberrm,8)\n call xmsg 'Records deleted:' rxvbdele+0\n return 0\n\n /* subroutine - build vtoc list */\nVTOClist:\ntrace off\n if $msglvl>0 then,\n   call xmsg 'Build disk info for' vol\n cc=XTSO(\"VTOC\" vol \"LIMIT(DSO EQ PO) OR1(DSO EQ PE)\",\n         \"NOHEADING PRINT(NEW (DSNAME VOLUME))\")\n if rc<>0 then exit xmsg('VTOC' vol 'rc' rc,8)\n if $msglvl>0 then,\n   say '         Libraries found' $.0 -1\n vtoc.vol='X'         /* remember done */\n vtocn=vtocn+1\n do n=1 to $.0 -1\n   parse var $.n vdsn vvol .\n   pdsn.vvol.vdsn='X'  /* exists */\n end\n return 0\n\nLoadDsnDb:\n cc=RxVsamBa('get dd(dsndb) stem(dbl.)')\n if cc<>0 then exit xmsg('Read dsn db rc' cc,8)\n call xmsg 'Records read from dsndb:' 0+dbl.0\n return 0\n\nLowCase: return translate(arg(1),xrange('a','z'),xrange('A','Z'))\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDBU": {"ttr": 4879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x01\\x19\\x11\\x0f\\x01\\x19\\x11\\x0f\\x162\\x00\\x11\\x001\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-04-20T00:00:00", "modifydate": "2019-04-20T16:32:00", "lines": 17, "newlines": 49, "modlines": 0, "user": "DVL"}, "text": "//WFMDBU   PROC MSGLVL=1,TYPRUN=SIM\n//*\n//* Update databases\n//*\n//WFMDBUS1 EXEC PGM=IKJEFT1B,\n// PARM='WFMDBUX1 MSGLVL(&MSGLVL) TYPRUN(&TYPRUN)'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//DSNDB    DD DISP=SHR,DSN=&DBPFX..DSN\n//MBRDB    DD DISP=SHR,DSN=&DBPFX..MBR\n//SYSOUT   DD UNIT=VIO,SPACE=(TRK,(5,5))\n//SYSIN    DD UNIT=VIO,RECFM=FB,LRECL=80,SPACE=(TRK,(1,1))\n//DFSPARM  DD UNIT=VIO,RECFM=FB,LRECL=80,SPACE=(TRK,(1,1))\n//*\n//WFMDBU   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMDBUX1": {"ttr": 4881, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00!\\x01\\x19\\x11\\x0f\\x01\\x19\\x11\\x1f\\x01\\x01\\x00\\xa1\\x00^\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2019-04-20T00:00:00", "modifydate": "2019-04-21T01:01:21", "lines": 161, "newlines": 94, "modlines": 0, "user": "DVL"}, "text": "/*                                                                    rexx\n   WFM DB Update\n    - delete records by either dsn, vol, mbr or key\n\n   Parm\n     MSGLVL(n)            1 shows more messages i.e. dsn db updates\n                          2 also show mbr db updates\n     TYPRUN(t)            SIM or RUN\n*/\n\n $rc=0\n arg p\n parse var p . 'MSGLVL('$msglvl')' . 0 . 'TYPRUN('$typrun')' .\n $msglvl  = word($msglvl 0,1)\n $typrun  = word($typrun 'RUN',1)\n\n if p<>'' then p='parm' p\n call xmsg 'Dsn db maintenance started' p\n say '  Type run' $typrun\n say '  Msglvl  ' $msglvl\n if wordpos($typrun,'SIM RUN')=0 then exit xmsg('Invalid typrun',8)\n\n Parse value wfmcntl('valid(ACT DSN VOL MBR KEY) REQ(ACT)'),\n     with . 'ERR('err')'  . 0 . 'ACT('pact')' .,\n       0  . 'DSN('pdsn')' . 0 . 'MBR('pmbr')' .,\n       0  . 'VOL('pvol')' . 0 . 'KEY('pkey')' .\n if err<>'' then exit xmsg(err,8)\n\n Select\n   when wordpos(pact,'DEL DELETE')>0 then $rc=Delete()\n   otherwise exit xmsg('Invalid ACT',8)\n End\n say ''\n exit xmsg('Update done rc' $rc,$rc)\n\nXMsg: if arg(1)<>'' then say time() arg(1);return word(arg(2) 0,1)\nXTso: trace off; zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');xtsorc=rc;return rc\nLowCase: return translate(arg(1),xrange('a','z'),xrange('A','Z'))\nStr2Stem:\n parse arg str,stem,pfx,sfx\n do n=1 to words(str)\n   zz=Value(stem''n,pfx''word(str,n)''sfx)\n end\n zz=Value(stem''0,n-1)\n return 0\n\n/*\n      Delete db entries\n*/\nDelete:\n say ''\n if pdsn pmbr pkey pvol='' then return xmsg('Missing data list',8)\n call xmsg 'Deleting db entries begin'\n\n if pdsn<>'' then call DelDsn\n if pmbr<>'' then call DelMbr\n if pvol<>'' then call DelVol\n if pkey<>'' then call DelKey\n Return 0\n\n /* delete records by dsn, load the dsn db to get keys */\nDelDsn:\n zz=Str2Stem(pdsn,'DSNS.',,' ')\n call xmsg  'Deleting dataset records..'\n do n=1 to dsns.0\n   say '  'dsns.n\n end\n cc=RxVsamBa('get dd(dsndb) textstem(dsns.) pos(21) stem(dbl.)')\n if dbl.0=0 then exit xmsg('No ds db records found')\n /* make key list */\n call xmsg 'Ds db records found'\n do n=1 to dbl.0\n   say '  'dbl.n\n   key.n = word(dbl.n,1)\n end\n key.0=dbl.0\n Return DelKeyX()\n\n call bpxwunix 'sort', 'key.', 'key.', 'STDERR.'\n /* delete dataset records */\n cc=RxVsamBa('del dd(dsndb) keystem(key.) list(ddel.)')\n if cc<>0 then exit xmsg('Delete dsn db rc' cc,8)\n call xmsg 'Records deleted:' rxvbdele+0\n /* delete member records */\n call xmsg  'Deleting member records..'\n cc=RxVsamBa('del dd(mbrdb) textstem(key.) POS(9) ENDPOS(20) list(mdel.)')\n if cc<>0 then exit xmsg('Delete mbr db rc' cc,8)\n call xmsg 'Records deleted:' rxvbdele+0\n if $msglvl>0 then do n=1 to mdel.0\n   say '  ' mdel.n\n end\n return 0\n\n /* delete records by vol, load the dsn db to get keys */\nDelVol:\n call xmsg  'Deleting volser records..'\n zz=Str2Stem(pvol,'VOLS.')\n do n=1 to vols.0\n   say '  'vols.n\n end\n cc=RxVsamBa('get dd(dsndb) textstem(vols.) pos(14) stem(dbl.)')\n if dbl.0=0 then exit xmsg('No ds db records found')\n /* make key list */\n call xmsg dbl.0 'Ds db records found'\n if $msglvl>0 then,\n do n=1 to dbl.0\n   say '  'dbl.n\n   key.n = word(dbl.n,1)\n end\n key.0=dbl.0\n Return DelKeyX()\n\n /* delete records by member */\nDelMbr:\n zz=Str2Stem(pmbr,'MBRS.')\n call xmsg  'Deleting member records..'\n do n=1 to mbrs.0\n   say '  'mbrs.n\n   mbr.n=left(mbr.n,8,'\\')\n end\n cc=RxVsamBa('get dd(mbrdb) keystem(mbrs.) stem(dbl.)')\n if dbl.0=0 then exit xmsg('No mbr db records found')\n /* make key list */\n call xmsg 'Mbr db records found'\n do n=1 to dbl.0\n   say '  'dbl.n\n   key.n = substr(dbl.n,9,12)\n end\n key.0=dbl.0\n Return DelKeyX()\n\n /* delete records by keys */\nDelKey:\n call xmsg  'Deleting records by key..'\n zz=Str2Stem(pkey,'KEY.')\n do n=1 to key.0\n   say '  'key.n\n end\n Return DelKeyX()\n\n /* run delete records by keylist */\nDelKeyX:\n call bpxwunix 'sort', 'key.', 'key.', 'STDERR.'\n /* delete dataset records */\n call xmsg 'Delete dsn db records'\n cc=RxVsamBa('del dd(dsndb) keystem(key.) list(ddel.)')\n if cc<>0 then exit xmsg('Delete dsn db rc' cc,8)\n call xmsg 'Records deleted:' rxvbdele+0\n if $msglvl>0 then do n=1 to ddel.0\n   say '  ' ddel.n\n end\n /* delete member records */\n call xmsg 'Delete mbr db records'\n cc=RxVsamBa('del dd(mbrdb) textstem(key.) POS(9) ENDPOS(20) list(mdel.)')\n if cc<>0 then exit xmsg('Delete mbr db rc' cc,8)\n call xmsg 'Records deleted:' rxvbdele+0\n if $msglvl>1 then do n=1 to mdel.0\n   say '  ' mdel.n\n end\n return 0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMDBX": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x16\\x01\\x19\\x06_\\x01\\x19\\x10\\x8f\"0\\x00\\x0f\\x00\\x18\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-04-18T22:30:16", "lines": 15, "newlines": 24, "modlines": 0, "user": "DVL"}, "text": "//WFMDBX   PROC CNTL=&PARMDS(DISKLIST)\n//*\n//* Extract volser and datasetname list from dsn db\n//*\n//WFMDBXS1 EXEC PGM=IKJEFT1B,PARM='%WFMDBXX1'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//DSNDB    DD DISP=SHR,DSN=&DBPFX..DSN\n//DBDSNS   DD DISP=(,CATLG),DSN=&DSPFX..DSDBEXTR,\n//            UNIT=SYSDA,SPACE=(TRK,(5,30),RLSE),\n//            LRECL=51,RECFM=FB,BLKSIZE=0\n//CNTL     DD DISP=SHR,DSN=&CNTL\n//WFMDBX   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMDBXX1": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00S\\x01\\x19\\x06_\\x01\\x19\\x10o\\x169\\x00E\\x00\\x05\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-04-16T16:39:53", "lines": 69, "newlines": 5, "modlines": 0, "user": "DVL"}, "text": "/*                                                               REXX\n\n  Extract and format data from dsn db\n  Filter list by values in CNTL DD as follows (may span lines):\n\n    DSN( dsn1 dsn2 .. dsnn )\n    DSNVOL( dsn1 vol1 dsn2 vol2 .. dsnn voln )\n    VOL( vol1 vol2 .. voln )\n\n  Lists are ORed when checked.\n\n*/\n voli.=0\n dsni.=0\n dsvi.=0\n\n Call xmsg 'Extract and format data from dsn db'\n cc=RxVsamBa('get dd(dsndb) stack')\n if cc<>0 then exit xmsg('Read dsn db rc' cc rxvberrm,8)\n call xmsg queued() 'records read from dsndb'\n\n /* get filter list */\n parse value WFMCNTL() with . 'ERR('err')' .,\n       0 . 'VOL('vol')' . 0 . 'DSN('dsn')' . 0 . 'DSNVOL('dsv')' .\n if err<>'' then exit 'Read cntl error' err\n pvol=(vol<>'')\n pdsn=(dsn<>'')\n pdsv=(dsv<>'')\n\n /* volume list as checkval */\n say 'Selecting disks' vol 'from db'\n if vol='ALL' then voli.=1\n else do m=1 to words(vol)\n   v=word(vol,m)\n   voli.v=1\n end\n\n /* dataset list as checkval */\n if dsn='' then dsni.=1\n else do m=1 to words(dsn)\n   d=word(dsn,m)\n   dsni.d=1\n end\n\n /* dataset+volume list as checkval */\n if dsv='' then dsvi.=1\n else do m=1 to words(dsnvol) by 2\n   d=word(dsnvol,m+1)word(dsnvol,m)   /* vol || dsn */\n   dsvi.d=1\n end\n\n /* reformat as vol(6) || dsn(44) || 'B' */\n qn=queued()\n do qn\n   pull key vol dsn rest\n   if pvol then if \\voli.vol then iterate\n   if pdsn then if \\dsni.dsn then iterate\n   vd = vol||dsn\n   if pdsv then if \\dsvi.vd  then iterate\n   queue left(vol,6)left(dsn,44)'B'\n end\n qn=queued()\n say qn 'records passed filtering'\n \"execio\" queued() \"diskw dbdsns (finis)\"\n if rc<>0 then exit xmsg('Write extract dataset rc' rc,8)\n\n exit xmsg('Extract and reformat done')\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDIAGO": {"ttr": 5128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x005\\x01\\x19\\x07\\x0f\\x01\\x19\\x16\\x7f\\x16(\\x00&\\x00&\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-06-16T16:28:35", "lines": 38, "newlines": 38, "modlines": 0, "user": "DVL"}, "text": "/*- ?? Run the Find-Member application     ?x? -------------------rexx\n\n   WFMXISPX  - drive the WFM4 ISPF dialog\n\n --------------------------------------------------------------------*/\n\n build = '2019-06-15'\n dbdsp = 'WFM.WFM4'       /* database prefix         */\n dlib  = 'WFM.WFM4.LIB'   /* product dataset prefix  */\n\n Address IspExec\n \"Control errors return\"\n \"libdef ispplib dataset id('\"dlib\"') stack\"\n if rc<>0 then call close 'Libdef ISPPLIB' dlib 'rc' rc zerrlm\n address tso \"altlib act appl(exec) da('\"dlib\"')\"\n if rc<>0 then call close 'ALTLIB' dlib 'rc' rc\n\n cc=Bpxwdyn('alloc dd(wfmdsn) da('dbdsp'.dsn) shr reuse')\n if cc<>0 then call close 'Alloc DSNDB' dbdsp'.DSN rc' cc\n cc=Bpxwdyn('alloc dd(wfmmbr) da('dbdsp'.mbr) shr reuse')\n if cc<>0 then call close 'Alloc MBRDB' dbdsp'.MBR rc' cc\n\n \"select cmd(%WFMDIAX1\",\n   \"NAME(\"arg(1)\") mbrdd(wfmmbr) dsndd(wfmdsn) test(n))\"\n if rc<>0 then say  'Dialog rc' rc\n\n address tso \"altlib deact appl(exec)\"\n \"libdef ispplib\"\n cc=Bpxwdyn('free dd(wfmdsn)')\n cc=Bpxwdyn('free dd(wfmmbr)')\n\n Call Close\n\nClose:\n Address TSO \"delstack\"\n parse arg _msg,_rc\n if _msg<>'' then say _msg\n Exit word(_rc 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDIAPH": {"ttr": 5130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00X\\x01\\x19\\x07\\x9f\\x01\\x19\\x11/\\x191\\x006\\x00\"\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-04-22T19:31:58", "lines": 54, "newlines": 34, "modlines": 0, "user": "DVL"}, "text": ")ATTR DEFAULT($+_)\n + type(text) color(green) skip(on)\n \" type(text) color(turq ) skip(on)\n \u20ac type(text) color(white) skip(on)\n # type(input ) color(turq  ) hilite(uscore) caps(on)\n @ type(input ) color(turq  ) hilite(uscore) caps(off)\n | area(scrl) extend(on)\n)Body expand(\\\\)\n\u20ac\\ \\WFM4 Help\\ \\+\n\u20acCmd =>_zcmd \\ \\\n+\n|SAREA1 \\ \\|\n)AREA SAREA1\n\u20acMember selection in the list panel\n+\n A full member name, without any wildcards.\n A mask using wildcards '%' for one char and '*' for any mumber of characters\n including none. Note that the search will take longer if the first character\n of the name is a wildcard, as the entire database has to be scanned.\n+\n\u20acInformation in the list panel\n+\n\"Member       +Member name\n\"Dataset      +Dataset name - this is the real name on disk.\n\"Volume       +Volume where the dataset is found\n\"Ds           +Dataset org - PO for old-time PDS, PE for PDS/E\n\"User         +Id of last updater if known (source lib only)\n\"Date         +Last modification date\n\"Cat          +Y if dataset is cataloged to the volume.\n+\n\u20acLine commands in the list panel\n+\n\"B            +Browse the member\n\"BD           +Browse the dataset\n\"E            +Edit the member\n\"ED           +Edit the dataset\n\"I            +Info, show all available information for the member\n\"P            +Start PDSMAIN (PDS86) for the dataset\n\"V            +View the member\n\"VD           +View the dataset\n\"X            +Exclude line from display\n\n\u20acPrimary commands in the list panel\n\n\"ALL          +Show all lines.\n\"EXClude text +Do not show lines with 'text'.\n\"Find text    +Find next line with 'text'.\n\"Only text    +text Show only lines with 'text'.\n\"RESet        +Show all lines.\n\"SORT         +Sort member + dataset\n\"SORT names   +Sort by names shown in screen - presently only ascending sort.\n\"X text       +Do not show lines with 'text'.\n)Proc\n)End\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDIAPI": {"ttr": 5132, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x000\\x01\\x19\\x07\\x0f\\x01\\x19\\x16\\x7f\\x13\\x02\\x00#\\x00%\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-06-16T13:02:30", "lines": 35, "newlines": 37, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n +  type(text) color(green)\n %  type(text) color(white)\n \"  type(text  ) color(turq  )\n !  type(input ) color(turq  ) hilite(uscore) caps(on)\n #  type(output) color(turq  )\n @  type(output) color(yellow)\n)BODY EXPAND(\\\\)\n\"\\ \\Find Member Info (WFM4.002)\\ \\+\n%Cmd =>_zcmd \\ \\+    +\n+\n+\n%Member info\n+  Name     #mbrname +\n+  User     #mbruser +\n+  Create   #mbrcredt         +\n+  Update   #mbrupddt         +\n+  Size     #mbrsize +\n+  Init     #mbrisize+\n+  Aliasof  #mbraliof+\n+  SSI      #mbrssi  +\n+\n%Dataset info\n+  Name     #dsnname\n+  Volume   #dsnvol+\n+  Cataloged#dsncat+\n+  Type     #dsntype+\n+  Dsorg    #dsndsorg+\n+  Recfm    #dsnrecfm+\n+  Lrecl    #dsnlrecl+\n+  Blksz    #dsnblksz+\n+\n)INIT\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDIAPL": {"ttr": 5134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00\\x00\\x01\\x19\\x07\\x0f\\x01\\x19\\x16\\x7f\\x13\\x02\\x000\\x00\"\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-06-16T13:02:00", "lines": 48, "newlines": 34, "modlines": 0, "user": "DVL"}, "text": ")ATTR DEFAULT(\"+_)\n +  type(text) color(green)\n /  type(text) color(turq )\n \"  type(text  ) color(white)\n ?  type(text  ) color(blue)\n !  type(input ) color(turq  ) hilite(uscore) caps(on)\n #  type(output) color(turq  )\n @  type(output) color(yellow)\n \u00dd  AREA(DYNAMIC)\n {  TYPE(CHAR)  COLOR(white)\n)BODY EXPAND(\\\\)\n/\\ \\Find Member (WFM4.002)\\ \\+\n\"Cmd =>_zcmd \\ \\_scrl+\n+\n\"Membername!fmmember? name or name* or mask (mask chars % and *)\n+                   ? if mask in pos 1 then expect search to take a while\n+\n+Linecmds: \u00ddlc1txt,lc1clr                                                    \u00dd\n+          \u00ddlc2txt,lc2clr                                                    \u00dd\n+\n\"   Member   Dataset                                Volume User     Date     Cat\n)MODEL ROWS(SCAN)\n!z #mbrname #dsnname                               #dsnvol#mbruser #mbrupddt#z\n)INIT\n &lc1txt   = 'Info Browse Edit BrowseDataset EditDataset Pdsmain'\n &lc1clr   = '{    {      {    {     {       {   {       {      '\n &lc2txt   = 'View ViewDataset'\n &lc2clr   = '{    {   {      '\n .zvars='(zsel dsncat)'\n .help = WFMDIAPH\n &zzmember = &fmmember\n)PROC\n if (&fmmember NE &zzmember)\n   &zcmd = 'NEWMEM &fmmember'\n*REXX(*,ZCMD)\n if word(zcmd,1)='SORT' & words(zcmd)>1 then do\n   c=''\n   do cn=2 to words(zcmd)\n     n=wordpos(word(zcmd,cn),'MEMBER DATASET VOLUME USER DATE CAT')\n     if n>0 then c=c word('MBRNAME DSNNAME DSNVOL MBRUSER MBRUPDDT DSNCAT',n)\n     else c=c word(zcmd,cn)\n   end\n   zcmd='SORT' c\n end\n*ENDREXX\n\n)END\n Ver (&zsel,list,B,BD,E,ED,V,VD,I,P,S,X)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDIAPM": {"ttr": 5136, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00'\\x01\\x19\\x07\\x0f\\x01\\x19\\x07\\x0f#0\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-03-11T23:30:27", "lines": 15, "newlines": 15, "modlines": 0, "user": "DVL"}, "text": ")ATTR\n +  type(text) color(green)\n %  type(text) color(yellow)\n \"  type(text  ) color(yellow)\n !  type(input ) color(turq  ) hilite(uscore) caps(on)\n @  type(output) color(green ) caps(off)\n)BODY EXPAND(\\\\)\n%\n+\n+\n   @lmwarn1 \\ \\+\n   @lmwarn2 \\ \\+\n)INIT\n)PROC\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDIAX1": {"ttr": 5138, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00C\\x01\\x19\\x10_\\x01\\x19\\x16o\\x171\\x00\\xf8\\x00\\xda\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2019-04-15T00:00:00", "modifydate": "2019-06-15T17:31:43", "lines": 248, "newlines": 218, "modlines": 0, "user": "DVL"}, "text": " /*                                                                rexx\n   Locate member dialog\n */\n parse value '1000 0 0 0' with $maxmatch _maxrc _istso _isispf dsninfo.\n parse source . . $me .\n\n Address IspExec\n \"Control errors return\"\n\n /* determine if called as command handler */\n arg p1,pid,pcmd,ptable,ptext\n if p1 pcmd='XISPTBL CMD' then Exit PCmdX()\n if p1 pcmd='XISPTBL SEL' then Exit LCmdX()\n\n arg p\n parse value ' 'p  with p1 'DSNDD('dsndd')' p2\n parse value p1 p2 with p1 'MBRDD('mbrdd')' p2\n parse value p1 p2 with p1 'NAME('fmmember')' p2\n parse value p1 p2 with p1 'TEST('test')' p2\n if p1 p2<>'' then exit xmsg('Invalid parm:' space(p1 p2))\n if test='Y' & fmmember='' then exit xmsg('Name is required for test',8)\n if test='Y' then say 'Looking for' fmmember\n\n dsndd=word(dsndd 'WFMDSN',1)\n mbrdd=word(mbrdd 'WFMMBR',1)\n $table='T'right(space(translate(time('l'),' ',':.'),0),7,0)\n\n /* display if testing */\n if test='Y' then do\n   Call MakeList\n   \"tbquery\" $table \"rownum(rown)\"\n   \"tbtop\"   $table\n   do rown\n     \"tbskip\"  $table\n     say mbrname fmtext dsname dsnvol\n   end\n   Call Close 0\n end\n\n /* dialog */\n if fmmember<>'' then Call MakeList\n else Call CreateTbl\n Do forever\n   \"vput fmmember\" shared\n   cc=XISPTBL('table('$table') panel(wfmdiapl) width(80)',\n             'proc('$me') id('$pid') sel(b bd e ed v vd se sed i p)',\n             'sort(mbrname dsnname dsnvol) icmd(sort)',\n             'retcmd(newmem)')\n   if cc>8 then call close 8 'Display rc' rc\n   if cc=8 then call close 0\n   if cc=0 then call close 0\n   if cc = '' then iterate\n   if cc ='EXIT' then call close 0\n   parse var cc cverb ctext\n   if cverb ='NEWMEM' then do\n     fmmember = ctext\n     if fmmember<>'' then call MakeList\n   end\n   else say 'Invalid command:' pcmd\n end\n Call Close 0\n\n /*- Line command handlers -*/\nLCmdX:\n \"tbget\" ptable\n err=''\n if zsel='S' & dsnrecfm<>'U' then zsel='E'\n $sel=dsndsorg''zsel\n Select\n   when zsel =''    then nop\n   when zsel ='B'   then call Accds 'Browse',dsnname,dsnvol,mbrname\n   when zsel ='BD'  then call Accds 'Browse',dsnname,dsnvol\n   when zsel ='E'   then call Accds 'Edit',dsnname,dsnvol,mbrname\n   when zsel ='ED'  then call Accds 'Edit',dsnname,dsnvol\n   when zsel ='V'   then call Accds 'View',dsnname,dsnvol,mbrname\n   when zsel ='VD'  then call Accds 'View',dsnname,dsnvol\n   when $sel ='SE'  then call Accds 'Edit',dsnname,dsnvol,mbrname\n   when $sel ='SED' then call Accds 'Edit',dsnname,dsnvol\n   when zsel ='I'   then Call ShowInfo\n   when zsel ='P'   then Address TSO \"PdsX '\"dsnname\"' vol(\"dsnvol\") ml :\"\n   otherwise do\n     call Ispmsg 'Invalid selection:' zsel\n     zsel='?'zsel\n   end\n end\n if left(zsel,1)<>'?' then zsel=''\n \"tbput\" ptable\n exit 0\n\n /*- Primary command handlers -*/\nPCmdX:\n say 'Invalid command:' ptext\n exit 0\n\nClose:\n trace off\n parse arg _rc _msg\n zz=outtrap('zz.')\n \"tbend\" $table\n Address TSO \"delstack\"\n cc=Bpxwdyn('free dd(mbrdb)')  /* just in case */\n zz=outtrap('off')\n if _msg<>'' then say _msg\n Exit word(_rc 0,1)\n\n /*--------------------------------------------------------------------\n                          Build memberlist\n --------------------------------------------------------------------*/\nCreateTbl:\n trace off\n \"tbend\" $table\n \"tbcreate\" $table \"names(mbrname mbruser mbrcredt mbrupddt mbrsize\",\n                   \"mbrisize mbraliof mbrssi\",\n                   \"dsnname dsnvol dsntype dsndsorg dsnrecfm dsnlrecl\",\n                   \"dsnblksz dsncat zsel)\"\n if rc<>0 then call close 8 'Could not create results table rc' rc\n added=0\n drop mbrl.\n return 0\n\nMakeList:\n trace off\n Call CreateTbl\n\n if pos('*',fmmember)>0 & length(fmmember)<4 then,\n     return ispmsg('*member must be at least 3 wide plus *')\n\n/* mbr db entry sample\n1       10        20        30        40        50        60\nK---+----+----+----K----+----+----+----+----+----+----+----+--\n$$$$READ163124691489 SYSXU1 CBT422;99/11/18;99/11/1816:27;01.00;0;10;10;;;\n*/\n\n/* dsn db entry sample\n1       10        20        30        40        50        60        70        80\nK---+----+-K--+----+----+----+----+----+----+----+----+----+----+----+----+----+\n163124686601 SYSXB1 WJ.ZB.FILE.D140331.T1921465 PE FB 80 0 1631 Y\n*/\n Select\n   when left(fmmember,1)='*' & verify(substr(fmmember,2),'*%','m')=0 then,\n     p='text('strip(strip(fmmember),'l','*')') pos(1) endpos(8)'\n   when right(fmmember,1)='*' & verify(fmmember,'*%','m')=length(fmmember),\n     then p='key('strip(fmmember,'t','*')')'\n   when verify(fmmember,'*%','m')>1 then do\n     n=verify(fmmember,'*%','m')\n     m=fmmember\n   /*if right(m,1)<>'*' then,\n       if length(m)<8 then m=m'\\*'*/\n     p='key('left(fmmember,n-1)') mask('m') pos(1) endpos(8)'\n   end\n   when verify(fmmember,'*%','m')>0 then,\n     p='mask('fmmember') pos(1) endpos(8)'\n   when right(fmmember,1)='*' then p='key('strip(fmmember,'t','*')')'\n   otherwise                       p='key('left(fmmember,8,'\\')')'\n End\n cc=RxVsamBa('get dd('mbrdd') stem(mbrl.)' p)\n if cc>0 | mbrl.0=0 then do\n   if cc<>0 then call ispmsg 'Member(s) not found'\n /*if cc>4 then say 'get member' val 'by' act 'cc' cc rxvsbaem */\n   drop mbrl. dsnl.\n   return 0\n end\n\n /* get dataset info */\n drop did. dsl.\n n=0\n do mbrli=1 to mbrl.0\n   dk=substr(mbrl.mbrli,9,12)\n   if dsninfo.dk='' then parse value n+1 dk with n did.n\n end\n\n /* new datasetlist is used for just one pass through the dsndb */\n if n>0 then do\n   did.0=n\n   cc=RxVsamBa('get dd('dsndd') keystem(did.) stem(dsl.)')\n   if datatype(dsl.0)<>'NUM' then dsl.0=0\n   do i=1 to dsl.0\n     parse var dsl.i key vol dsn dsorg recfm\n     dsninfo.key=space(subword(dsl.i,2))\n   end\n end\n drop did. dsl.\n\n /* table record layouts\n dsn  key vol dsn type dsorg recfm lrecl cat\n mbr  name||key||user;created;updated;vermod;mod;size;init;,\n               ssi;attr;aliasof\n */\n zsel=''\n do mbrli=1 to mbrl.0\n   parse var mbrl.mbrli mbrname +8 key +12 mbruser,\n             ';'mbrcredt';'mbrupddt';'.';'.';'mbrsize';'mbrisize,\n             ';'mbrssi';'mbrattr';'mbraliof\n   parse var dsninfo.key dsnvol dsnname dsndsorg dsnrecfm,\n             dsnlrecl dsnblksz dsncat .\n   mbrupddt=word(mbrupddt mbrcredt,1)\n   if mbrupddt<>'' then do\n     parse var mbrcredt y'/'m'/'d\n     if y<50 then mbrcredt='20'y''m''d\n     else         mbrcredt='19'y''m''d\n     parse var mbrupddt d +8 t\n     parse var d y'/'m'/'d\n     if y<50 then mbrupddt='20'y''m''d t\n     else         mbrupddt='19'y''m''d t\n   end\n   mbrname=translate(mbrname,' ','\\')\n   address ispexec \"tbadd\" $table\n   added=added+1\n end\n return 0\n\n /*--------------------------------------------------------------------\n                      show member info screen\n --------------------------------------------------------------------*/\nShowInfo:\n do forever\n   \"display panel(WFMDIAPI)\"\n   cc=rc\n   if cc=8 then leave\n   if cc>0 then call close 8 'Info display rc' cc\n end\n return 0\n\nWarning:\n fmwarn1=arg(1)\n fmwarn2=arg(2)\n fmwarn3=arg(3)\n fmwarn4=arg(4)\n \"display panel(WFMDIAPM)\"\n return rc\n\nXTSO: zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');return rc\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n\nISPMSG:\n parse arg zedlmsg\n address ispexec\"setmsg msg(isrz000)\"\n return 0\n\nAccDs: procedure /* what,dsn,vol,mbr */\n arg what .,dsn .,vol .,mbr .\n if mbr<>'' then dsn=dsn'('mbr')'         /* member */\n call ispmsg what \"dataset('\"dsn\"') volume(\"vol\")\"\n address ispexec \"vput zedlmsg\"\n \"\"what \"dataset('\"dsn\"') volume(\"vol\")\"\n return rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDIAX9": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x007\\x01\\x19\\x07\\x0f\\x01\\x19\\x10_\\x17X\\x00\\xda\\x00\\xe7\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-04-15T17:58:37", "lines": 218, "newlines": 231, "modlines": 0, "user": "DVL"}, "text": " /*                                                                rexx\n   Locate member dialog\n */\n parse value '1000 0 0 0' with $maxmatch _maxrc _istso _isispf dsninfo.\n\n Address IspExec\n \"Control errors return\"\n\n arg p\n parse value ' 'p with,\n     . 'DSNDD('dsndd')' . 0 . 'MBRDD('mbrdd')' . 0 . 'NAME('fmmember')' .,\n   0 . 'TEST('test')' .\n if test='Y' & fmmember='' then exit xmsg('Name is required for test',8)\n if test='Y' then say 'Looking for' fmmember\n\n dsndd=word(dsndd 'WFM3DSN',1)\n mbrdd=word(mbrdd 'WFM3MBR',1)\n\n /* display */\n $toprow=0\n $lmmbr=''\n $table='T'right(space(translate(time('l'),' ',':.'),0),7,0)\n\n /* display if testing */\n if test='Y' then do\n   Call MakeList\n   \"tbquery\" $table \"rownum(rown)\"\n   \"tbtop\"   $table\n   do rown\n     \"tbskip\"  $table\n     say mbrname fmtext dsname dsnvol\n   end\n   Call Close 0\n end\n\n /* dialog */\n Call CreateTbl\n do forever\n   zz=fmmember\n   if fmmember<>$lmmbr & fmmember<>'' then do\n     Call MakeList\n     $lmmbr=fmmember\n     $toprow=0\n   end\n   \"tbtop\"   $table\n   \"tbskip\"  $table  \"number(\"$toprow\")\"\n   \"tbdispl\" $table  \"panel(WFMDIAPL)\"\n   $toprow=ztdtop\n   if rc>8 then call close 8 'Display rc' rc\n   if rc=8 then call close 0\n   if zsel='S' & dsnrecfm<>'U' then zsel='E'\n   $sel=dsndsorg''zsel\n   Select\n     when zsel =''    then nop\n     when zsel ='B'   then call Accds 'Browse',dsnname,dsnvol,mbrname\n     when zsel ='BD'  then call Accds 'Browse',dsnname,dsnvol\n     when zsel ='E'   then call Accds 'Edit',dsnname,dsnvol,mbrname\n     when zsel ='ED'  then call Accds 'Edit',dsnname,dsnvol\n     when zsel ='V'   then call Accds 'View',dsnname,dsnvol,mbrname\n     when zsel ='VD'  then call Accds 'View',dsnname,dsnvol\n     when $sel ='SE'  then call Accds 'Edit',dsnname,dsnvol,mbrname\n     when $sel ='SED' then call Accds 'Edit',dsnname,dsnvol\n     when zsel ='I'   then Call ShowInfo\n     when zsel ='P'   then Address TSO \"PdsX '\"dsnname\"' vol(\"dsnvol\") ml :\"\n     otherwise             call Ispmsg 'Invalid selection:' zsel\n   end\n end\n\n Call Close 0\n\nClose:\n parse arg _rc _msg\n zz=outtrap('zz.')\n \"tbend\" $table\n Address TSO \"delstack\"\n cc=Bpxwdyn('free dd(mbrdb)')  /* just in case */\n zz=outtrap('off')\n if _msg<>'' then say _msg\n Exit word(_rc 0,1)\n\n /*--------------------------------------------------------------------\n                          Build memberlist\n --------------------------------------------------------------------*/\nCreateTbl:\n \"tbend\" $table\n \"tbcreate\" $table \"names(mbrname mbruser mbrcredt mbrupddt mbrsize\",\n                   \"mbrisize mbraliof mbrssi\",\n                   \"dsnname dsnvol dsntype dsndsorg dsnrecfm dsnlrecl\",\n                   \"dsnblksz dsncat)\"\n if rc<>0 then call close 8 'Could not create results table rc' rc\n added=0\n drop mbrl.\n return 0\n\nMakeList:\n Call CreateTbl\n\n if pos('*',fmmember)>0 & length(fmmember)<4 then,\n     return ispmsg('*member must be at least 3 wide plus *')\n\n/* mbr db entry sample\n1       10        20        30        40        50        60\nK---+----+----+----K----+----+----+----+----+----+----+----+--\n$$$$READ163124691489 SYSXU1 CBT422;99/11/18;99/11/1816:27;01.00;0;10;10;;;\n*/\n\n/* dsn db entry sample\n1       10        20        30        40        50        60        70        80\nK---+----+-K--+----+----+----+----+----+----+----+----+----+----+----+----+----+\n163124686601 SYSXB1 Z.ZB.FILE.D140331.T1921465  PE FB 80 0 1631 Y\n*/\n Select\n   when left(fmmember,1)='*' & verify(substr(fmmember,2),'*%','m')=0 then,\n     p='text('strip(strip(fmmember),'l','*')') pos(1) endpos(8)'\n   when right(fmmember,1)='*' & verify(fmmember,'*%','m')=length(fmmember),\n     then p='key('strip(fmmember,'t','*')')'\n   when verify(fmmember,'*%','m')>1 then do\n     n=verify(fmmember,'*%','m')\n     m=fmmember\n   /*if right(m,1)<>'*' then,\n       if length(m)<8 then m=m'\\*'*/\n     p='key('left(fmmember,n-1)') mask('m') pos(1) endpos(8)'\n   end\n   when verify(fmmember,'*%','m')>0 then,\n     p='mask('fmmember') pos(1) endpos(8)'\n   when right(fmmember,1)='*' then p='key('strip(fmmember,'t','*')')'\n   otherwise                       p='key('left(fmmember,8,'\\')')'\n End\n cc=RxVsamBa('get dd('mbrdd') stem(mbrl.)' p)\n if cc>0 | mbrl.0=0 then do\n   if cc<>0 then call ispmsg 'Member(s) not found'\n /*if cc>4 then say 'get member' val 'by' act 'cc' cc rxvsbaem */\n   drop mbrl. dsnl.\n   return 0\n end\n\n /* get dataset info */\n drop did. dsl.\n n=0\n do mbrli=1 to mbrl.0\n   dk=substr(mbrl.mbrli,9,12)\n   if dsninfo.dk='' then parse value n+1 dk with n did.n\n end\n\n /* new datasetlist is used for just one pass through the dsndb */\n if n>0 then do\n   did.0=n\n   cc=RxVsamBa('get dd('dsndd') keystem(did.) stem(dsl.)')\n   if datatype(dsl.0)<>'NUM' then dsl.0=0\n   do i=1 to dsl.0\n     parse var dsl.i key vol dsn dsorg recfm\n     dsninfo.key=space(subword(dsl.i,2))\n   end\n end\n drop did. dsl.\n\n /* table record layouts\n dsn  key vol dsn type dsorg recfm lrecl cat\n mbr  name||key||user;created;updated;vermod;mod;size;init;,\n               ssi;attr;aliasof\n */\n do mbrli=1 to mbrl.0\n   parse var mbrl.mbrli mbrname +8 key +12 mbruser,\n             ';'mbrcredt';'mbrupddt';'.';'.';'mbrsize';'mbrisize,\n             ';'mbrssi';'mbrattr';'mbraliof\n   parse var dsninfo.key dsnvol dsnname dsndsorg dsnrecfm,\n             dsnlrecl dsnblksz dsncat .\n   mbrupddt=word(mbrupddt mbrcredt,1)\n   parse var mbrcredt y'/'m'/'d\n   if y<50 then mbrcredt='20'y''m''d\n   else         mbrcredt='19'y''m''d\n   parse var mbrupddt d +8 t\n   parse var d y'/'m'/'d\n   if y<50 then mbrupddt='20'y''m''d t\n   else         mbrupddt='19'y''m''d t\n   mbrname=translate(mbrname,' ','\\')\n   address ispexec \"tbadd\" $table\n   added=added+1\n end\n return 0\n\n /*--------------------------------------------------------------------\n                      show member info screen\n --------------------------------------------------------------------*/\nShowInfo:\n do forever\n   \"display panel(WFMDIAPI)\"\n   cc=rc\n   if cc=8 then leave\n   if cc>0 then call close 8 'Info display rc' cc\n end\n return 0\n\nWarning:\n fmwarn1=arg(1)\n fmwarn2=arg(2)\n fmwarn3=arg(3)\n fmwarn4=arg(4)\n \"display panel(WFMDIAPM)\"\n return rc\n\nXTSO: zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');return rc\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n\nISPMSG:\n parse arg zedlmsg\n address ispexec\"setmsg msg(isrz000)\"\n return 0\n\nAccDs: procedure /* what,dsn,vol,mbr */\n arg what .,dsn .,vol .,mbr .\n if mbr<>'' then dsn=dsn'('mbr')'         /* member */\n call ispmsg what \"dataset('\"dsn\"') volume(\"vol\")\"\n address ispexec \"vput zedlmsg\"\n \"\"what \"dataset('\"dsn\"') volume(\"vol\")\"\n return rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMDOC": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\'\\x00\\x13\\x01\\x19\\x08/\\x01\\x19\\x16\\x7f\\x16\"\\x00\\xe5\\x00+\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.39", "flags": 0, "createdate": "2019-03-23T00:00:00", "modifydate": "2019-06-16T16:22:13", "lines": 229, "newlines": 43, "modlines": 0, "user": "DVL"}, "text": "Willow Find Member (WFM) application ver 4 build 002\n\n By Willy Jensen\n   email willy@harders-jensen.com\n   web   http://harders-jensen.com/wjtech/index.html\n\n See the 'Change history' section at the end for changes in this build.\n Download the 'FINDMEMP' as FINDMEMP.PDF and open it with a PDF viewer\n to see a perhaps better documentation.\n\n There are no changes to the database definitions, so a working product\n can be replaced by this build.\n\n\nIntroduction\n\n The WFM application is an ISPF application which allows you to find\n PDS/PDSE member(s) which existed at the latest WFM update run.\n\n The basis  for member info  load is  disk, so uncataloged  datasets are\n processed too.  This means that the  real name of a  dataset is stored,\n not any symbolic datasetname.\n\n Member(s) can be located by full name, name prefix or using\n Wildcards.\n\n The generated member list allows browse, edit and view of the member\n and the dataset where the member is found\n\n WFM is build using REXX + freeware programs, so is not as resource\n lean as a purpose built application probably would be. On the other\n hand a lot of thoughts have gone into making it perform reasonably. See\n the section 'Performance considerarions' later for hints.\n\n\nPrinciples of operation\n\n The WFM infrastructure consists of 2 VSAM databases, one containing\n dataset names and one containing member names. The member database\n refers to the dataset database during member lookup.\n\n The databases are initially loaded using VTOC listings.\n\n The databases are updated by a daily run which scans SMF data for\n dataset update, scratch and rename. Both old-fashioned SMF history\n datasets and SMF logstreams are supported. Use either job JOBUPDSL or\n JOBUPDSH as reference.\n\n You can use the application while the update is running.\n\n The application is built using some freeware programs PDSMAIN (PDS86),\n RXVSAMBA and VTOC from www.cbttape.org file 192, 112 and 669\n respectively. A copy of those programs is provided as part of the WFM\n package.\n An alternate to PDSMAIN can be used by modifying the PDSMAIN=\n operand in the WFMSET member. SERENAs STARTOOL program has the same\n functionality and syntax as PDSMAIN as I recall.\n\n Several of the jobs use IBM DFSORT and ICETOOL. If you do not have\n those installed, I hope that you have useful equvivalents. Otherwise\n drop me a note and I shall see what I can do.\n\n Members with invalid names like 'B+......' are dropped durning load.\n\n\nGetting started\n\n Unload the LIB dataset (you probably have done that already if you are\n Reading this).\n\n If you do not have either of the freeware programs PDSMAIN (PDS86),\n RXVSAMBA or VTOC installed, then un-xmit the program from the package\n lib to a loadlib. Update the JOBLIB parameter and statement in the\n WFMSET member accordingly.\n\n Edit the WFMSET member.\n\n Edit the WFMSTEPL member.\n\n Edit and run the JOBPRMCR and JOBDBCR jobs.\n\n Edit and run the JOBUPDVT member. If the VTOC and PDSMAIN programs are\n not available through LINKLIST/LPALIST then you must un-comment the\n STEPLIB statement. You might want to run the job several times with\n disk subsets. This will also allow you to monitor the size of the\n databases as you go along. Note that a lot of SMF type 14 will be\n generated, one per dataset scanned.\n\n Edit the WFMDIAGO member and tryout the dialog. Note that the RXVSAMBA\n program must be available.\n\n Continue with the section 'Daily update'\n\n\nThe ISPF dialog\n\n Execute the WFMDIAGO member.\n\n Enter HELP to see available primary- and line commands\n\n\nDaily update\n\n Determine which job to use, depending on whether a SMF logstream is\n avaiable or not. Sample job JOBUPDSL reads from a logstream, JOBUPDSH\n reads from a history dataset.\n\n Edit the latest run info in the PARM dataset member LASTDATE. Enter\n the date when you started to add data to the databases.\n\n Edit and run the JOBUPDSH or JOBUPDSL member.\n The DATE= parameter is only used if you want to extract from a specific\n date range. The default is to read the parm member LASTDATE.\n\n Run the dialog to verify the updates.\n\n You can use the WFMSMX to pull SMF types 15, 17 and 18 as part of a\n SMF Dump process. This will make a much smaller dataset for WFMSMH.\n\n\nResync update\n\n This should be run at regular intervals. All disks are read so you may\n want to do this only once per week or even once per month.\n\n Edit and run the JOBUPDVT member.\n\n\nAd-hoc update\n\n Run this to update specific datasets.\n\n Edit and run the JOBUPDDL member.\n\n\nSpecial considerations\n\n You can filter the disk volser list just before the update steps by\n using the WFMVSL proc. This can be usefull if you are not quite sure\n what VTOC ALL or the SMF extractor steps will pull in. See JOBUPDSH for\n a sample.\n\n\nDatasets\n\n xxxx.LIB contains JCL, REXX programs and control data.\n\n  Sample jobs\n   JOBDBCR   Create the databases.\n   JOBDBREO  DB reorg\n   JOBDBMN1  Delete duplicate dsn records and orphaned mbr records\n   JOBDBMN2  Sync database and VTOCs\n   JOBPRMCR  Create the PARM dataset\n   JOBDBRLD  Reload DB from unload dataset\n   JOBDBUNL  Unload DB to dataset\n   JOBUPDDL  Update db using a ad-hoc dataset list\n   JOBUPDSH  Update db from SMF history dataset\n   JOBUPDSL  Update db from SMF logstream\n   JOBUPDVT  Update db using VTOC list\n\n  Procedures and input\n   WFMAWD    Allocate work datasets\n   WFMCTL*   Make control data\n   WFMDBA*   Add data to databases\n   WFMDBD*   Delete data from databases\n   WFMDBM*   Maintenance databaes\n   WFMDBU*   Update DBs, delete records by either dsn, vol, mbr or key\n   WFMDBX*   Extract data from databases\n   WFMDIA*   Dialog\n   WFMDWD*   Delete work datasets\n   WFMSET    JCL SET statements\n   WFMLST    List dataset.\n   WFMMDV*   Merge database and SMF Data\n   WFMRUN*   Run program after edit of control data\n   WFMSMH*   Extract from SMF history dataset\n   WFMSML*   Extract from SMF logstream\n   WFMUDL*   Make datasetlist for update\n   WFMVPG*   Make VIO pgmlib\n   WFMVSL*   Filter the update list\n   WFMVTC*   Get po/pe datalist from VTOC\n\n  Other\n   PDSMAIN   XMITed PDS86 (PDSMAIN) program\n   RXVSAMBA  XMITed RXVSAMBA program\n   VTOC      XMITed VTOC program\n   XISPTBL   general ISPF table display driver\n\n xxxx.PARM contains verious selections generated by the WFMCTL proc.\n\n xxxx.UPD contains updates for the WFMDBA and WFMDBD procs.\n\n xxxx.DSN dataset database\n\n xxxx.MBR member database\n\n\nPerformance considerations\n\n The PDSMAIN (PDS86) program should be in  LPALIB as it is used a lot by\n the load and update jobs. The RXVSAMBA and VTOC programs are used a lot\n less, but may also be copied to LPALIB.\n\n If you cannot add the programs to  LPA, then you could at least execute\n them from VIO as follows:\n\n   Edit the  JOBUPDxx member you  want to  run, add the  following after\n   EXEC WFMCTL:\n\n   //          EXEC WFMVPG,LOADLIB='loadlib.with.programs'\n\n   Update the WFMSTEPL member:\n\n   //STEPLIB DD DISP=SHR,DSN=&&VIOLIB\n\n\nSecurity considerations\n\n The databases are read directly by the dialog, so must have universal\n access READ.\n The userid for the update job must be able to read all PDS(E) datasets\n and update the databases, so it is recommended that the userid has\n OPERATIONS attribute.\n\n\nChange history\n\n Build 002 (current)\n  The SMF filters have been modified, so at the very least you must\n  replace the members WFMSMHI2 WFMSMLI3 and WFMSMXI1.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMDWD": {"ttr": 5390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x19\\x08/\\x01\\x19\\x08\\x8f\\x14#\\x00\\n\\x00\\t\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-23T00:00:00", "modifydate": "2019-03-29T14:23:31", "lines": 10, "newlines": 9, "modlines": 0, "user": "DVL"}, "text": "//WFMDWD   PROC\n//*\n//* Delete work datasets\n//*\n//WFMDWDS1 EXEC PGM=IKJEFT1B,PARM='%WFMDWDX1 &DSPFX'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//WFMDWD   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMDWDX1": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00(\\x01\\x19\\x06_\\x01\\x19\\x07\\x9f\\x18 \\x00\\x1a\\x00\\t\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-03-20T18:20:28", "lines": 26, "newlines": 9, "modlines": 0, "user": "DVL"}, "text": "/*                                                                     rexx\n  Delete work datasets\n*/\n arg dspfx\n dslist= ,\n         'DBVTUPD',\n         'DSDBEXTR',\n         'SMFEXTR',\n         'SMFTEMP',\n         'SMVTUPD',\n         'VTOCEXTR',\n         'UPD',\n         ''\n\n Do dsln=1 to words(dslist)\n   ds = dspfx\".\"word(dslist,dsln)\n   dsq= \"'\"ds\"'\"\n   if sysdsn(dsq)<>'OK' then iterate\n   if Silent(\"delete\" dsq)<>0 then say 'Delete' ds 'rc' cc\n   say ds 'deleted'\n End\n\n Exit 0\n\nSilent: trace off; zz=outtrap(word(arg(2) '$.',1))\n        address tso arg(1);zz=outtrap('off');xtsorc=rc;return rc\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMGNR": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00C\\x01\\x19\\x10o\\x01\\x19\\x10o\\x15X\\x00\\x08\\x00\\x08\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-16T00:00:00", "modifydate": "2019-04-16T15:58:43", "lines": 8, "newlines": 8, "modlines": 0, "user": "DVL"}, "text": "//WFMGNR   PROC\n//*\n//* Do IEBGENER\n//*\n//WFMGNR   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//WFMGNR   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMLST": {"ttr": 5637, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x01\\x19\\x08/\\x01\\x19\\x08/\\x15Y\\x00\\x07\\x00\\x07\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-23T00:00:00", "modifydate": "2019-03-23T15:59:13", "lines": 7, "newlines": 7, "modlines": 0, "user": "DVL"}, "text": "//WFMLST   PROC DS=\n//WFMLSTS1 EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT1   DD DISP=SHR,DSN=&DS\n//SYSUT2   DD SYSOUT=*\n//         PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMMDV": {"ttr": 5639, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x19\\x01\\x19\\x06_\\x01\\x19\\x08/\\x17\\x01\\x00\\x17\\x00!\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-03-23T17:01:19", "lines": 23, "newlines": 33, "modlines": 0, "user": "DVL"}, "text": "//WFMMDV   PROC S2SYSIN=WFMMDVI2\n//*\n//* Merge db and vtoc extracts to get pds updates\n//*\n//WFMMDVS1 EXEC PGM=SORT\n//SYSOUT   DD SYSOUT=*\n//JNF1JMSG DD SYSOUT=*\n//JNF2JMSG DD SYSOUT=*\n//DBEXTR   DD DISP=SHR,DSN=&DSPFX..DSDBEXTR\n//VTEXTR   DD DISP=SHR,DSN=&DSPFX..VTOCEXTR\n//SORTOUT  DD DISP=(,PASS),DSN=&&MDVOUT,DSORG=PS,\n//            UNIT=SYSDA,SPACE=(TRK,(15,15),RLSE),LRECL=51,RECFM=FB\n//SYSIN    DD DISP=SHR,DSN=&WFMLIB(WFMMDVI1)\n//*\n//* Format\n//*\n//WFMMDVS2 EXEC PGM=SORT\n//SYSOUT   DD SYSOUT=*\n//SORTIN   DD DISP=(OLD,DELETE),DSN=&&MDVOUT\n//SORTOUT  DD DISP=MOD,DSN=&DSPFX..UPD\n//SYSIN    DD DISP=SHR,DSN=&WFMLIB(&S2SYSIN)\n//*\n//WFMMDV   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMMDVI1": {"ttr": 5641, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x12\\x01\\x19\\x06_\\x01\\x19\\x08\\x7f\\x18D\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-03-28T18:44:12", "lines": 15, "newlines": 15, "modlines": 0, "user": "DVL"}, "text": "* output is fixed\n*  db not vtoc -> del (upd)\n*  vtoc not db -> add\n*\n JOINKEYS F1=DBEXTR,FIELDS=(1,50,A)\n JOINKEYS F2=VTEXTR,FIELDS=(1,50,A),SORTED\n JOIN UNPAIRED,F1,F2\n REFORMAT FIELDS=(?,F1:1,51,F2:1,51)\n OPTION COPY      Copy joined records\n OUTFILE IFTHEN=(WHEN=(1,1,CH,EQ,C'1'),\n          BUILD=(2,50,C'D')),\n         IFTHEN=(WHEN=(1,1,CH,EQ,C'2'),\n          BUILD=(53,50,C'A')),\n         IFTHEN=(WHEN=NONE,\n          BUILD=(C'-',2,50))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMMDVI2": {"ttr": 5643, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x004\\x01\\x19\\x06_\\x01\\x19\\x07\\x0f\\x157\\x00\\x02\\x00\\x02\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-03-11T15:37:34", "lines": 2, "newlines": 2, "modlines": 0, "user": "DVL"}, "text": " INCLUDE COND=(1,1,CH,NE,C'-')\n SORT FIELDS=(1,50,CH,A)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMMDVI3": {"ttr": 5645, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00F\\x01\\x19\\x07\\x1f\\x01\\x19\\x07\\x1f\\x11\\x12\\x00\\x02\\x00\\x02\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-12T00:00:00", "modifydate": "2019-03-12T11:12:46", "lines": 2, "newlines": 2, "modlines": 0, "user": "DVL"}, "text": " INCLUDE COND=(51,1,CH,EQ,C'V')\n SORT FIELDS=(1,50,CH,A)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMRUN": {"ttr": 5647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x008\\x01\\x19\\x08_\\x01\\x19\\x08\\x8f\\x14#\\x00\\x08\\x00\\x14\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-03-26T00:00:00", "modifydate": "2019-03-29T14:23:38", "lines": 8, "newlines": 20, "modlines": 0, "user": "DVL"}, "text": "//WFMRUN   PROC P=\n//WFMRUNS1 EXEC PGM=IKJEFT1B,PARM='%WFMRUNX1 &P'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//WFMSET   DD DISP=SHR,DSN=&WFMLIB.(WFMSET)\n//WFMRUN   PEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMRUNX1": {"ttr": 5649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x002\\x01\\x19\\x08_\\x01\\x19\\x08_\\x147\\x007\\x00\"\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2019-03-26T00:00:00", "modifydate": "2019-03-26T14:37:32", "lines": 55, "newlines": 34, "modlines": 0, "user": "DVL"}, "text": "/*                                                                  rexx\n  Use the WFMSET data to update input file(s), then run named program\n  Parm: programname dd1 .. ddn\n*/\n var.=''\n\n arg pgm rest\n parse var rest . 'EDIT('edlist')' . 0 . 'PARM('prm')' .\n if pgm='' then exit xmsg('Pgm parm missing',8)\n if edlist='' then exit xmsg('EDIT parm missing',8)\n\n /* parse WFMSET, make var-list */\n \"execio * diskr wfmset (finis)\"\n do queued()\n   pull r\n   if left(r,3)<>'// ' | pos(' SET ',r)=0 then iterate\n   parse var r . . name'='val .\n   if val=\"''\" then iterate\n   zz=value('var.'name,val)\n end\n\n /* read and modify input files, one after the other */\n do ddn=1 to words(edlist)\n   dd=word(edlist,ddn)\n   \"execio * diskr\" dd \"(stem file. finis)\"\n   /* reallocate libref to temp */\n   cc=bpxwdyn('free dd('dd')')\n   cc=bpxwdyn('alloc dd('dd') new delete unit(vio) space(1,1) tracks',\n      'recfm(f,b) lrecl(80)')\n   if cc<>0 then exit xmsg('Alloc dd' dd 'rc' cc,8)\n   do fn=1 to file.0\n   /*say left(dd,8) 'I' file.fn */\n     do while pos('&',file.fn)>0\n       parse var file.fn front '&' rest\n       p=Verify(rest,xrange('A','Z')'0123456789','n')\n       parse var rest v =(p) rest\n       if left(rest,1)='.' then rest=substr(rest,2)\n       file.fn=front || var.v || rest\n     end\n   /*say left(dd,8) 'O' file.fn  */\n   end\n   \"execio\" file.0 \"diskw\" dd \"(stem file. finis)\"\n end\n\n /* finally run program */\n address AttchMvs pgm prm\n cc=rc\n\n /* release resources (not really neccessary) */\n do ddn=1 to words(edlist)\n   cc=bpxwdyn('free dd('word(edlist,ddn)')')\n end\n exit xmsg(pgm 'run rc' cc,cc)\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMSET": {"ttr": 5651, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00R\\x01\\x19\\x07\\x9f\\x01\\x19\\x16\\x7f\\x16(\\x00\\x10\\x00\\x04\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-06-16T16:28:52", "lines": 16, "newlines": 4, "modlines": 0, "user": "DVL"}, "text": "//*  Parameter dataset\n//   SET PARMDS=WFM.WFM4.PARM\n//*  Dataset prefix for service datasets, i.e. sort extracts\n//   SET DSPFX=WFM.WFM4\n//*  Volser for service datasets if not SMS managed\n//   SET DSVOL=''\n//*  Database datset prefix\n//   SET DBPFX=WFM.WFM4\n//*  Volser for databases. leave xxxxxx if SMS managed\n//   SET DBVOL=XXXXXX\n//*  SMF history dataset used as input if not logstream\n//   SET SMFHIST=WFM.SMF.EXTRACT\n//*  Sort-unique in db-del and db-add steps\n//   SET SORTU=N\n//*  Alternate name for PDSMAIN/PDS86, i.e. STARTOOL\n//   SET PDSMAIN=PDSMAIN\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMSMH": {"ttr": 5653, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00G\\x01\\x19\\x06\\x7f\\x01\\x19\\x10\\x8f\"0\\x00\\x11\\x00?\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2019-03-08T00:00:00", "modifydate": "2019-04-18T22:30:47", "lines": 17, "newlines": 63, "modlines": 0, "user": "DVL"}, "text": "//WFMSMH   PROC\n//*\n//* Copy SMF type 15, 17 and 18 for a given period from SMFhist\n//* Get last record per dataset, reformat\n//*\n//WFMSMHS2 EXEC PGM=ICETOOL\n//TOOLMSG  DD SYSOUT=*\n//DFSMSG   DD SYSOUT=*\n//IN       DD DISP=SHR,DSN=&SMFHIST\n//OUT      DD DISP=MOD,DSN=&DSPFX..UPD\n//TEMP     DD UNIT=SYSDA,SPACE=(TRK,(2,2)),LRECL=55,RECFM=VB\n//TOOLIN   DD DISP=SHR,DSN=&WFMLIB(WFMSMHI1)\n//CTL1CNTL DD DISP=SHR,DSN=&WFMLIB(WFMSMHI2)\n//         DD DISP=SHR,DSN=&PARMDS(SMFHDATE)\n//         DD DISP=SHR,DSN=&WFMLIB(WFMSMHI3)\n//CTL2CNTL DD DISP=SHR,DSN=&WFMLIB(WFMSMHI4)\n//WFMSMH   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMSMHI1": {"ttr": 5655, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x19\\x08/\\x01\\x19\\x08/\\x11H\\x00\\x02\\x00\\x02\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-23T00:00:00", "modifydate": "2019-03-23T11:48:57", "lines": 2, "newlines": 2, "modlines": 0, "user": "DVL"}, "text": " COPY   FROM(IN) TO(TEMP) USING(CTL1)\n SELECT FROM(TEMP) TO(OUT) ON(1,50,CH) FIRST USING(CTL2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMSMHI2": {"ttr": 5657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00S\\x01\\x19\\x08/\\x01\\x19\\x16O\\x13\\x11\\x00\\x08\\x00\\x12\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-03-23T00:00:00", "modifydate": "2019-06-13T13:11:53", "lines": 8, "newlines": 18, "modlines": 0, "user": "DVL"}, "text": " OPTION EQUALS,VLSHRT,VLSCMP\n* 43,1,BI,NE,X'20' was 43,2,BI,NE,X'2084'\n OMIT    COND=((6,1,BI,EQ,X'0F',        type 15 : update\n               AND,43,1,BI,NE,X'20'),   perm pds\n            OR,(6,1,BI,EQ,X'11',        type 17 : scratch\n               AND,45,3,CH,EQ,C'SYS',   sysdsn\n               AND,48,5,ZD,EQ,NUM,\n               AND,50,2,CH,EQ,C'.T'),\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMSMHI3": {"ttr": 5659, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00G\\x01\\x19\\x08/\\x01\\x19\\x08/\\x11R\\x00\\x0b\\x00\\x12\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-23T00:00:00", "modifydate": "2019-03-23T11:52:47", "lines": 11, "newlines": 18, "modlines": 0, "user": "DVL"}, "text": "            OR,6,1,BI,LT,X'0F')\n OUTFIL IFTHEN=(WHEN=(6,1,BI,EQ,X'0F'),\n         BUILD=(1,4,187,6,69,44,C'U')),\n        IFTHEN=(WHEN=(6,1,BI,EQ,X'11'),\n         BUILD=(1,4,95,6,45,44,C'D')),\n        IFTHEN=(WHEN=(6,1,BI,EQ,X'12'),\n         BUILD=(1,4,139,6,45,44,C'D',\n                /,\n                1,4,139,6,89,44,C'U')),\n        IFTHEN=(WHEN=NONE,\n         BUILD=(1,4,C'?'))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMSMHI4": {"ttr": 5661, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00R\\x01\\x19\\x08/\\x01\\x19\\x08/\\x11I\\x00\\x03\\x00\\x03\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-03-23T00:00:00", "modifydate": "2019-03-23T11:49:52", "lines": 3, "newlines": 3, "modlines": 0, "user": "DVL"}, "text": " OPTION  EQUALS,VLSHRT,VLSCMP\n SORT    FIELDS=(5,50,CH,A)\n OUTFIL  BUILD=(5,51),VTOF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMSML": {"ttr": 5663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00)\\x01\\x19\\x06\\x7f\\x01\\x19\\x10\\x8f\"0\\x00\\x17\\x00?\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2019-03-08T00:00:00", "modifydate": "2019-04-18T22:30:29", "lines": 23, "newlines": 63, "modlines": 0, "user": "DVL"}, "text": "//WFMSML   PROC\n//*\n//* Copy SMF type 15, 17 and 18 for a given period from logger\n//*\n//WFMSMLS1 EXEC PGM=IFASMFDL\n//OUTDD1   DD DISP=(,PASS),DSN=&&SMFDATA,RECFM=VBS,BLKSIZE=0,\n//            UNIT=SYSDA,SPACE=(CYL,(15,15),RLSE)\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DISP=SHR,DSN=&WFMLIB(WFMSMLI1)\n//         DD DISP=SHR,DSN=&PARMDS(SMFLDATE)\n//*\n//* Get last record per dataset, reformat\n//*\n//WFMSMLS2 EXEC PGM=ICETOOL\n//TOOLMSG  DD SYSOUT=*\n//DFSMSG   DD SYSOUT=*\n//IN       DD DISP=(OLD,DELETE),DSN=&&SMFDATA\n//OUT      DD DISP=MOD,DSN=&DSPFX..UPD\n//TEMP     DD UNIT=SYSDA,SPACE=(TRK,(2,2)),LRECL=55,RECFM=VB\n//TOOLIN   DD DISP=SHR,DSN=&WFMLIB(WFMSMLI2)\n//CTL1CNTL DD DISP=SHR,DSN=&WFMLIB(WFMSMLI3)\n//CTL2CNTL DD DISP=SHR,DSN=&WFMLIB(WFMSMLI4)\n//WFMSML   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMSMLI1": {"ttr": 5665, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x16\\x01\\x19\\x06\\x8f\\x01\\x19\\x08\\x1f\\x16\\x06\\x00\\x02\\x00\\x04\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-09T00:00:00", "modifydate": "2019-03-22T16:06:16", "lines": 2, "newlines": 4, "modlines": 0, "user": "DVL"}, "text": " LSNAME(IFASMF.DEFAULT,OPTIONS(DUMP))\n OUTDD(OUTDD1,TYPE(15,17,18))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMSMLI2": {"ttr": 5667, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00&\\x01\\x19\\x07\\x0f\\x01\\x19\\x07\\x0f\\x16#\\x00\\x02\\x00\\x02\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-03-11T16:23:26", "lines": 2, "newlines": 2, "modlines": 0, "user": "DVL"}, "text": " COPY   FROM(IN) TO(TEMP) USING(CTL1)\n SELECT FROM(TEMP) TO(OUT) ON(1,50,CH) FIRST USING(CTL2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMSMLI3": {"ttr": 5669, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00C\\x01\\x19\\x07\\x0f\\x01\\x19\\x16O\\x14\\x14\\x00\\x12\\x00\\x12\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-06-13T14:14:43", "lines": 18, "newlines": 18, "modlines": 0, "user": "DVL"}, "text": " OPTION EQUALS,VLSHRT,VLSCMP\n OMIT    COND=((6,1,BI,EQ,X'0F',        type 15 : update\n               AND,43,1,BI,NE,X'20'),   perm pds\n            OR,(6,1,BI,EQ,X'11',        type 17 : scratch\n               AND,45,3,CH,EQ,C'SYS',   sysdsn\n               AND,48,5,ZD,EQ,NUM,\n               AND,50,2,CH,EQ,C'.T'),\n            OR,6,1,BI,LT,X'0F')\n OUTFIL IFTHEN=(WHEN=(6,1,BI,EQ,X'0F'),\n         BUILD=(1,4,187,6,69,44,C'U')),\n        IFTHEN=(WHEN=(6,1,BI,EQ,X'11'),\n         BUILD=(1,4,95,6,45,44,C'D')),\n        IFTHEN=(WHEN=(6,1,BI,EQ,X'12'),\n         BUILD=(1,4,139,6,45,44,C'D',\n                /,\n                1,4,139,6,89,44,C'U')),\n        IFTHEN=(WHEN=NONE,\n         BUILD=(1,4,C'?'))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMSMLI4": {"ttr": 5671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\t\\x01\\x19\\x07\\x0f\\x01\\x19\\x07\\x0f\\x16%\\x00\\x03\\x00\\x03\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2019-03-11T00:00:00", "modifydate": "2019-03-11T16:25:09", "lines": 3, "newlines": 3, "modlines": 0, "user": "DVL"}, "text": " OPTION  EQUALS,VLSHRT,VLSCMP\n SORT    FIELDS=(5,50,CH,A)\n OUTFIL  BUILD=(5,51),VTOF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMSMX": {"ttr": 5673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x02\\x01\\x19\\x10\\x8f\\x01\\x19\\x10\\x8f\\x16%\\x00\\x08\\x00\\x08\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-04-18T00:00:00", "modifydate": "2019-04-18T16:25:02", "lines": 8, "newlines": 8, "modlines": 0, "user": "DVL"}, "text": "//WFMSMX   PROC\n//*\n//* Copy SMF type 15, 17 and 18 from SMF hist dataset(s)\n//*\n//WFMSMXS1 EXEC PGM=SORT\n//SYSOUT   DD SYSOUT=*\n//SYSIN    DD DISP=SHR,DSN=&WFMLIB(WFMSMXI1)\n//WFMSMX   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMSMXI1": {"ttr": 5675, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00)\\x01\\x19\\x10\\x8f\\x01\\x19\\x16O\\x13\\x10\\x00\\x0f\\x00\\x0e\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-04-18T00:00:00", "modifydate": "2019-06-13T13:10:29", "lines": 15, "newlines": 14, "modlines": 0, "user": "DVL"}, "text": "* Copy SMF\n*   type 15 if po/pe\n*   type 17 if permanent\n*   type 18 if permanent\n SORT FIELDS=COPY\n OPTION EQUALS,VLSHRT,VLSCMP\n OMIT    COND=((6,1,BI,EQ,X'0F',        type 15 : update\n               AND,43,1,BI,NE,X'20'),   perm pds (ref SMF14RIN)\n            OR,(6,1,BI,EQ,X'11',        type 17 : scratch\n               AND,45,3,CH,EQ,C'SYS',   if perm dataset\n               AND,48,5,ZD,EQ,NUM,\n               AND,50,2,CH,EQ,C'.T'),\n            OR,6,1,BI,LT,X'0F',         drop if lt 15\n            OR,6,1,BI,GT,X'12')         drop if gt 18\n*  43,1,BI,NE,X'20' was 43,2,BI,NE,X'2084'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMSTEPL": {"ttr": 5677, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00)\\x01\\x19\\x08_\\x01\\x19\\x08_#\\x02\\x00\\x01\\x00\\x01\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2019-03-26T00:00:00", "modifydate": "2019-03-26T23:02:29", "lines": 1, "newlines": 1, "modlines": 0, "user": "DVL"}, "text": "//*STEPLIB DD DISP=SHR,DSN=&DSPFX..LOADLIB  &&VIOLIB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMUDL": {"ttr": 5679, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00F\\x01\\x19\\x08?\\x01\\x19\\x08\\x8f\\x14#\\x00\\x0c\\x00\\t\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-03-29T14:23:46", "lines": 12, "newlines": 9, "modlines": 0, "user": "DVL"}, "text": "//WFMUDL   PROC\n//*\n//* Make update dataset list\n//*\n//WFMUDLS1 EXEC PGM=IKJEFT1B,PARM='%WFMUDLX1'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//DSNLIST  DD DDNAME=SYSIN\n//UPDLIST  DD DISP=MOD,DSN=&DSPFX..UPD\n//WFMUDL   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMUDLX1": {"ttr": 5889, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x006\\x01\\x19\\x08?\\x01\\x19\\x08?\\x126\\x00#\\x00#\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-24T00:00:00", "modifydate": "2019-03-24T12:36:36", "lines": 35, "newlines": 35, "modlines": 0, "user": "DVL"}, "text": "/*                                                                   REXX\n  WFMMDL  - Make datasetlist for update\n\n  msglvl 0  list statistics\n         1  list datasets and members actually deleted\n         2  list datasets and members potentially and actually deleted\n*/\n call xmsg 'Make dataset list'\n\n /* read and filter dsn list */\n \"execio * diskr dsnlist (stem idl. finis)\"\n call xmsg idl.0 'records read from list'\n odn=0\n do n=1 to idl.0\n   if idl.n='' | left(idl.n,1)='*' then iterate\n   parse upper var idl.n dsn vol .\n   if vol='' then do   /* use catalog */\n     cc=Listdsi(\"'\"dsn\"'\")\n     if cc<>0 then do\n       call xmsg 'Cannot locate' dsn\n       iterate\n     end\n     vol=sysvolume\n   end\n   odn=odn+1\n   odl.odn=vol''dsn\n   call xmsg '  'left(dsn,44) vol\n end\n drop idl.\n if odn=0 then exit xmsg('No datasets in list',8)\n call xmsg odn 'datasetnames in list'\n \"execio\" odn \"diskw updlist (stem odl. finis)\"\n\n exit xmsg('All done')\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMVPG": {"ttr": 5891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x10\\x01\\x19\\x08_\\x01\\x19\\x08_\\x166\\x00\\t\\x00\\n\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2019-03-26T00:00:00", "modifydate": "2019-03-26T16:36:10", "lines": 9, "newlines": 10, "modlines": 0, "user": "DVL"}, "text": "//WFMVPG   PROC LOADLIB=\n//* copy programs to VIO for quicker access\n//WFMVPGS1 EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//PGMLIB   DD DISP=SHR,DSN=&LOADLIB\n//VIOLIB   DD DISP=(,PASS),DSN=&&VIOLIB,\n//            UNIT=VIO,SPACE=(TRK,(15,15,2)),DCB=(&LOADLIB)\n//SYSIN    DD DISP=SHR,DSN=&WFMLIB.(WFMVPGI1)\n//         PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMVPGI1": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00E\\x01\\x19\\x08_\\x01\\x19\\x08_\\x109\\x00\\x04\\x00\\x02\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2019-03-26T00:00:00", "modifydate": "2019-03-26T10:39:45", "lines": 4, "newlines": 2, "modlines": 0, "user": "DVL"}, "text": " C I=PGMLIB,O=VIOLIB\n  S M=PDSMAIN\n  S M=RXVSAMBA\n  S M=VTOC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMVSL": {"ttr": 5895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x13\\x01\\x19\\x07\\x9f\\x01\\x19\\x10\\x8f\"0\\x00\\r\\x00\\n\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-04-18T22:30:13", "lines": 13, "newlines": 10, "modlines": 0, "user": "DVL"}, "text": "//WFMVSL   PROC DS=&DSPFX..UPD,MSGLVL=0,CNTL=&PARMDS(VOLSEL)\n//*\n//* Include/Exclude disks in update list\n//*\n//WFMVSLS1 EXEC PGM=IKJEFT1B,PARM='%WFMVSLX1 MSGLVL(&MSGLVL)'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//LISTIN   DD DISP=OLD,DSN=&DS\n//LISTOUT  DD DISP=OLD,DSN=&DS\n//CNTL     DD DISP=SHR,DSN=&CNTL\n//WFMVSL   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMVSLX1": {"ttr": 5897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x14\\x01\\x19\\x07\\x9f\\x01\\x19\\x10\\x7f\\x00\\x00\\x00J\\x00\\x1a\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2019-03-20T00:00:00", "modifydate": "2019-04-17T00:00:14", "lines": 74, "newlines": 26, "modlines": 0, "user": "DVL"}, "text": "/*                                                                        rexx\n VSEL - Include / Exclude disks in list\n Input dataset LISTIN layout:\n  1-6  volser\n  7-*  rest\n*/\n\n arg p\n parse var p . 'MSGLVL('$msglvl')' .\n $msglvl=word($msglvl 0,1)\n\n parse value '0 0 0' with pass incl. excl. ctl list\n\n /* read control list, pull include and exclude lists */\n parse upper value WFMCNTL('alias(inc include exc exclude)'),\n   with . 'INCLUDE(' incp ')' . 0 . 'EXCLUDE(' excp ')' .\n if $msglvl>0 then say 'Incl:' incp\n if $msglvl>0 then say 'Excl:' excp\n\n hasincl=(length(incp)>0)\n do n=1 to words(incp)\n   v=word(incp,n)\n   incl.v=1\n end\n\n hasexcl=(length(excp)>0)\n do n=1 to words(excp)\n   v=word(excp,n)\n   excl.v=1\n end\n drop incp excp\n\n /* read volume list, do filter */\n \"Execio * diskr listin (stem lst. finis)\"\n say 'List records read:' lst.0\n\n /* filter list */\n do n=1 to lst.0\n   parse value left(lst.n,6) with vl6 +6 . 1 vl5 +5 . 1 vl4 +4 . 1 vl3 +3 .,\n             1 vl2 +2 . 1 vl1 +1 .\n   ok=1\n   if hasexcl then Select\n     when excl.vl6 then ok=0\n     when excl.vl5 then ok=0\n     when excl.vl4 then ok=0\n     when excl.vl3 then ok=0\n     when excl.vl2 then ok=0\n     when excl.vl1 then ok=0\n     otherwise nop /* say 'passed excl test' */\n   End\n   if hasincl then Select\n     when incl.vl6 then nop\n     when incl.vl5 then nop\n     when incl.vl4 then nop\n     when incl.vl3 then nop\n     when incl.vl2 then nop\n     when incl.vl1 then nop\n     otherwise ok=0\n   End\n   if ok then do\n     pass=pass+1\n     out.pass=lst.n\n     p='passed'\n   end\n   else p='dropped'\n   if $msglvl>0 then say vl6 p\n end\n say 'List records passed:' pass\n\n /* update */\n \"Execio\" pass \"diskw listout (stem out. finis)\"\n exit xmsg('All done')\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WFMVTC": {"ttr": 5900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00Y\\x01\\x19\\x06_\\x01\\x19\\x10\\x8f\"0\\x00\\x16\\x00\\x1d\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-04-18T22:30:59", "lines": 22, "newlines": 29, "modlines": 0, "user": "DVL"}, "text": "//WFMVTC   PROC LISTDS=&DSPFX..VTOCEXTR,CNTL=&PARMDS(DISKLIST)\n//*\n//* Get po/pe datalist from vtoc\n//*\n//WFMVTCS1 EXEC PGM=IKJEFT1B,PARM='%WFMVTCX1'\n//STEPLIB  INCLUDE MEMBER=WFMSTEPL\n//SYSEXEC  DD DISP=SHR,DSN=&WFMLIB\n//SYSTSPRT DD SYSOUT=*\n//VTOCEXTR DD UNIT=SYSDA,DISP=(MOD,PASS),DSN=&&VTOCEXTR,\n//            RECFM=VB,LRECL=256,BLKSIZE=27998,SPACE=(TRK,(75,75))\n//SYSTSIN  DD DUMMY\n//CNTL     DD DISP=SHR,DSN=&CNTL\n//*\n//* Format\n//*\n//WFMVTCS2 EXEC PGM=SORT\n//SYSOUT   DD SYSOUT=*\n//SORTIN   DD DISP=(OLD,DELETE),DSN=&&VTOCEXTR\n//VTOCDSNS DD UNIT=SYSDA,DISP=(,CATLG),DSN=&LISTDS,VOL=SER=&DSVOL,\n//            RECFM=FB,LRECL=51,BLKSIZE=0,SPACE=(TRK,(15,15),RLSE)\n//SYSIN    DD DISP=SHR,DSN=&WFMLIB(WFMVTCI1)\n//WFMVTC   PEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "WFMVTCI1": {"ttr": 5902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x14\\x01\\x19\\x06_\\x01\\x19\\x07\\x0f\\x15@\\x00\\x08\\x00\\x08\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-03-06T00:00:00", "modifydate": "2019-03-11T15:40:14", "lines": 8, "newlines": 8, "modlines": 0, "user": "DVL"}, "text": " OPTION EQUALS,VLSHRT,VLSCMP\n OMIT    COND=(5,9,SS,NE,C'.',           SYSDSN\n           OR,(5,3,CH,EQ,C'SYS',\n               AND,8,5,ZD,EQ,NUM,\n               AND,13,2,CH,EQ,C'.T'))\n INREC BUILD=(1,4,50,6,5,44,57,13)\n SORT FIELDS=(5,50,CH,A)\n OUTFILE FNAMES=VTOCDSNS,BUILD=(5,50,C'V'),VTOF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WFMVTCX1": {"ttr": 5904, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00(\\x01\\x19\\x08\\x0f\\x01\\x19\\x16o\\x16X\\x00$\\x00\\x18\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2019-03-21T00:00:00", "modifydate": "2019-06-15T16:58:28", "lines": 36, "newlines": 24, "modlines": 0, "user": "DVL"}, "text": "/*                                                                rexx\n\n WFM - read data from one or more VTOCs\n Output goes to SYSTSPRT\n CNTL Syntax (may span lines):\n  VOL( volume-list )\n\n*/\n\n say 'VTOC extract started at' time()\n\n /* get filter list */\n ctl = WFMCNTL('dd(disklist)')\n parse var ctl . 'ERR('err')' . 0 . 'VOL('vol')' .\n if err<>'' then exit xmsg('Read cntl error' err,8)\n if vol='' then exit xmsg('Missing VOL parm',8)\n\n /* run VTOC for each volser */\n vc=0\n do vn=1 to words(vol)\n   say \"VTOC\" word(vol,vn) 'started' time()\n   zz=outtrap('lst.')\n   \"VTOC\" word(vol,vn),\n   \"LIMIT(DSO EQ PO) OR1(DSO EQ PE)\",\n   \"NOHEADING PRINT(NEW (DSNAME VOLUME DSO RFM LRECL))\"\n   zz=outtrap('off')\n   if rc<>0 then exit xmsg('VTOC' word(vol,vn) 'rc' rc,8)\n   \"execio\" lst.0 \"diskw vtocextr (stem lst.)\"\n   vc=vc+1\n end\n \"execio 0 diskw vtocextr (finis)\"\n\n if vol='ALL' then vc='ALL'\n Exit xmsg(vc 'VTOCs processed by' time())\n\nXMsg: if arg(1)<>'' then say arg(1);return word(arg(2) 0,1)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XISPTBL": {"ttr": 5906, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x00\\x01\\x174\\x0f\\x01\\x19\\x11/\\x194\\x02@\\x01\\xbc\\x00\\x00\\xc4\\xe5\\xd3@@@@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2017-12-06T00:00:00", "modifydate": "2019-04-22T19:34:00", "lines": 576, "newlines": 444, "modlines": 0, "user": "DVL"}, "text": " /*                                                                   REXX\n\n  XISPTBL: General ISPF Table Handler - list and manage ISPF table contents\n           Subroutine to be called from other program\n\n  parms: see below\n\n  Return codes\n   00       ok, data may have be changed if CRC parameter is not used.\n   crcval   data changed (value set by the CRC parameter)\n   08   User cancelled process\n  >08   Something very bad happened\n\n  2017-12-11  Opt RETCMD added\n  2017-12-14  point-and-shoot selection added\n  2017-12-21  make work table if original does not have ZSEL var\n  2017-12-23  fix update detection problem\n  2018-01-08  fix problems with details display and with internal copy.\n  2018-01-15  fix problem with change detection\n  2018-01-16  change remaining EXITs to RETURNs\n              change all labels so that XISPTBL can be included in other\n  2018-05-18  add display refresh after TSOX\n  2018-07-17  add ERROR and SYNTAX OFF in a couple of places\n  2018-09-26  add parm WIDTH. add test for valid ISEL values, center header\n  2018-10-18  add parm PASSTEXT - pass text to called pgm.\n  2019-01-22  fix RETCMD problem\n  2019-04-15  fix RETCMD problem - will test 1st word, not entire string\n              fix problem EXCLUDE primary command not recoqnized.\n  2019-04-22  add SORT-by-name. names are table names. sort is ascending.\n\n  Lables and variables are mostly prefixed by 'ath' - A Table Handler.\n\n  Written by Willy Jensen, email willy.h.jensen@outlook.com\n\n */\n parse value '' with athdosort athwtbl athotbl\n vkl='ID TABLE PANEL DPANEL WIDTH PROC SEL ISEL SPROC ICMD CPROC DPROC',\n     'SORT HDR SELVAR SEARCHVAR POPUP CRC RETCMD ASEL', /* valid keywords */\n     'PASSTEXT'\n do n=1 to words(vkl)\n   zz=Value('ATH'word(vkl,n),'')\n end\n cc=AthParser(arg(1),vkl,'ATH')\n if word(cc,1)<>0 then return xmsg(cc)\n upper athsel athisel athselvar\n if athisel='ALL' then athisel='D E I L R S'\n do n=1 to words(athisel)    /* check values */\n   if wordpos(word(athisel,n),'D E I L R S')=0 ,\n         then return AthTblErr('Invalid ISEL value' word(athisel,n),90)\n end\n if athtable  ='' then return AthTblErr('Missing table name',90)\n if athpanel  ='' then return AthTblErr('Missing panel name',90)\n if athproc<>'' then,\n   parse value athproc athproc athproc with athcproc athsproc athdproc\n athuid=right(left(space(translate(time('l'),' ','.:'),0),10),7)\n athasel=translate(word(athasel 'S',1))   /* auto selection char */\n\n /*--------------------------------------------------------------------\n                     Table handler main routine\n --------------------------------------------------------------------*/\n Address ispexec\n parse value copies('0 ',20) with athrc athtdtop athcrp .\n parse value '' with athsell athfind athonly\n \"vget zscrmaxw\"\n Select\n   when datatype(athwidth)='NUM' then nop\n   when athwidth='MAX' then athwidth=zscrmax\n   otherwise athwidth=80\n End\n if athhdr<>'' then athhdr=center(athhdr,athwidth-2)\n athme = 'XISPTBL'\n \"vput (athsel athisel)\"\n\n /* get table info */\n athotbl=athtable\n \"tbquery\" athtable \"names(athonl) keys(athokl) rownum(rows)\"\n if rc<>0 then return AthIspMsg('TBQUERY' zerrlm,8)\n parse value UnPar(athonl','athokl) with athonl','athokl\n athvarl =space(athokl athonl)\n athovarl=athvarl   /* keep original list */\n athvarlnz=athvarl\n n=wordpos('ZSEL',athvarlnz)\n if n>0 then athvarlnz=delword(athvarlnz,n,1)\n\n /* make change base */\n \"tbtop\" athotbl                                /* re-position      */\n interpret,\n   'do n=1 to' rows';\"tbskip\"' athotbl';dbase.n='athvarlnz';end'\n dbase.0=rows\n\n /* make copy table if original does not contain ZSEL var */\n if wordpos('ZSEL',athvarl)=0 then do  /* make copy */\n   athtable='W'athuid\n   If AthIspCmd(\"tbcreate\" athtable \"keys(\"athokl\") names(zsel \"athonl\")\",0),\n     then return 12\n   Call AthTblCopy athotbl athtable\n   \"tbquery\" athtable \"names(n) keys(k) rownum(r)\"\n end\n\n /* setup sort opts */\n if athsearchvar='' then athsearchvar = athvarlnz\n if athsort='=' then athsort=athvarlnz\n if athsort<>'' then do\n   s=''\n   do n=1 to words(athsort)\n     if word(athsort,n)<>'ZSEL' then s=s','word(athsort,n)',C,A'\n   end\n   athsort=substr(s,2)\n end\n\n if athicmd<>'' then do    /* initial command */\n   cc=AthTblCmd(athicmd)\n   if cc>=8 then return cc\n end\n\n /* main handler */\n Do athmain$=1 to 999999                          /* forever          */\n   if athdosort='Y' & athsort<>'' then Call AthTblSort\n   athdosort='N'                                  /* sort before show?*/\n   \"tbtop\" athtable                               /* re-position      */\n   if athtdtop<>0 then \"tbskip\" athtable \"number(\"athtdtop\") NOREAD\"\n   zerrlm=''\n   \"tbvclear\" athtable\n   zsel='X'\n   \"tbsarg\"   athtable \"namecond(zsel ne)\"\n   athcsrrw=''\n   if athpopup='Y' then \"addpop\"\n   \"tbquery\"  athtable \"rownum(athrown)\"\n   \"tbdispl\"  athtable \"panel(\"athpanel\")\",        /* stack selection 1*/\n            \"rowid(athrowid) position(athcrp)\"    /* return csr and id*/\n   drc=rc\n   if athpopup='Y' then \"rempop\"\n   /* athrowid   - will contain a number that uniquely identifies the\n                   row being accessed\n      athcrp     - will contain the row number pointed to by the crp\n   */\n   if drc>8 then,\n     return AthTblErr('Table display' athpanel 'rc' drc)+AthEpilog(drc)\n   if drc=8 then return AthEpilog()                /* END / RETURN     */\n\n   athtdtop=ztdtop                                /* save 1st displayd*/\n\n   /* handle primary commands */\n   if zcmd<>'' then do\n     if AthAbrList(word(zcmd,1),athretcmd) then,\n       return abbrlistv subword(zcmd,2)\n     cc=AthTblCmd(zcmd)\n     if cc>=8 then Return AthEpilog(cc)\n     iterate athmain$\n   end\n\n   /* save row selections */\n   zselsave=''\n   If athcsrrw<>'' & ztdsels=0 & athcsrrw<>0 then do  /* sel by cursor */\n     \"tbtop\"  athtable\n     \"tbskip\" athtable \"number(\"athcsrrw\") rowid(athsell)\"\n     parse value athasel athasel with zsel zselsave\n     \"tbput\" athtable   /* rewrite data */\n   End\n   Else do athseln=1 to ztdsels\n     if athseln>1 then \"tbdispl\" athtable \"rowid(athrowid) position(athcrp)\"\n     if zsel='=' then zsel=zselsave\n     else if zsel<>'' then zselsave=zsel\n     \"tbput\" athtable   /* rewrite data */\n     if zsel<>'' & wordpos(athrowid+0,athsell)=0 then,\n       athsell=athsell athrowid+0\n   End\n\n   /* process row selections */\n   Do while athsell<>''\n     athrowid=word(athsell,1)\n     \"tbskip\" athtable \"row(\"athrowid\")\"\n     parse value '' with athpnlhi\n     athzsel=zsel\n     Select\n       when zsel='' then nop\n       when left(zsel,1)='?' then iterate athmain$\n       when zsel='X' then NOP\n       when wordpos(zsel,athselvar)>0 then do\n         if value(word(athselvar,wordpos(zsel,athselvar)+1))<>'' then,\n            zz=AthRunCmd(value(word(athselvar,wordpos(zsel,athselvar)+1))),\n              +AthTblSetSel('')\n       end\n       when wordpos(zsel,athsel)>0 & athsproc<>'' then do\n         Interpret,\n           \"cc=\"athsproc\"('\"athme\"','\"athid\"','SEL','\"athtable\"','\"zsel\"'\",\n             || \",'\"athpasstext\"')\"\n         if cc=0 & queued()>0 then return AthEpilog(0)\n         if cc>4 then return AthEpilog(cc)\n       end\n       when wordpos(zsel,athisel)>0 then Interpret \"cc=AthTblEdit\"zsel\"()\"\n       otherwise do\n         call AthIspMsg zsel 'is not a valid line command'\n         call AthTblSetSel('?'zsel)\n         iterate athmain$\n       end\n     End\n     athsell=subword(athsell,2)\n   End\n end\n Return AthEpilog(athrc)\n\n/* processing done at final return */\nAthEpilog: /* parm: rc */\n $ischg=AthChkChg()\n if athotbl<>athtable then do   /* rewrite original tale if needed */\n   if $ischg then do  /* change detected */\n     \"tbquery\" athotbl \"rownum($rows)\"\n     \"tbbottom\" athotbl\n     do $rows /* clear table */\n       \"tbdelete\" athotbl\n     end\n     Call AthTblCopy athtable athotbl\n   end\n   \"tbend\" athtable\n end\n if arg(1)>=8 then return arg(1)\n if $ischg & athcrc<>'' then return athcrc  /* change detected */\n return word(arg(1) 0,1)\n\n /* set changed rc  */\nAthChkChg:\n \"tbquery\" athtable \"rownum(ccrows)\"\n if ccrows<>dbase.0 then return 1\n \"tbtop\" athotbl\n Interpret,\n 'do n=1 to' ccrows';',\n   '\"tbskip\"' athtable';',\n   'if dbase.n<>'athvarlnz 'then return 1;',\n 'end'\n return 0\n\n/* handle primary commands */\nAthTblCmd:\n arg athpcmd\n parse var athpcmd athpcverb athpcdata\n Select\n   when Abbrev('CANCEL',athpcmd,3)   then return 8\n   when Abbrev('RESET', athpcmd,3)   then call AthTblReset\n   when Abbrev('FIND',  athpcverb,1) then call AthTblFind athpcdata\n   when Abbrev('ONLY',  athpcverb,1) then call AthTblOnly athpcdata\n   when athpcverb = 'ALL'            then call AthTblReset\n   when athpcverb = 'SORT' & athpcdata<>'' then call AthTblSortN\n   when athpcverb = 'SORT' & athsort<>'' then call AthTblSort\n   when athpcverb = 'EDIT' then \"Edit dataset(\"requote(athpcdata)\")\"\n   when athpcverb='X' | Abbrev('EXCLUDE',athpcverb,3) then,\n        call AthTblExcl athpcdata\n   when athpcverb = 'NEW' & wordpos('I',athisel)>0 then Call AthTblInsertRow\n   when athcproc<>'' then do\n     Signal on error  name AthTblCmdErr\n     Signal on syntax name AthTblCmdSyn\n     Interpret,\n       \"cc=\"athcproc\"('\"athme\"','\"athid\"','CMD','\"athtable\"'\",\n       ||  \",'\"strip(translate(zcmd,\" \",\"'\"))\"','\"athpasstext\"')\"\n     Signal off error\n     Signal off syntax\n     Select\n       when cc='ALL'          then call AthTblAll\n       when word(cc,1)='ONLY' then zz=AthTblAll()+AthTblOnly(subword(cc,2))\n       when word(cc,1)='EXCL' then zz=AthTblAll()+AthTblExcl(subword(cc,2))\n       when cc>4 then return cc\n       when cc=1 then athtdtop=0    /* view from top */\n       otherwise return 0\n     end\n   end\n   otherwise call AthIspMsg 'Invalid command:' athpcmd\n End\n return 0\nAthTblCmdErr:\n Signal off error\n Signal off syntax\n say 'XISPTBL error' rc 'in line' sigl\n return 0\nAthTblCmdSyn:\n Signal off error\n Signal off syntax\n say 'XISPTBL syntax' rc 'in line' sigl':' \"ERRORTEXT\"(rc)\n return 0\n\nAthTblErr:\n if arg(1)<>'' then say arg(1) zerrlm\n if arg(2)<>'' then athrc=arg(2)\n Return word(arg(2) 0,1)\n\nAthTblSetSel:\n zsel=arg(1)\n \"tbput\" word(arg(2) athtable,1)\n return rc\n\n /*-------------------------------------------------------------------\n                           table functions\n --------------------------------------------------------------------*/\nAthTblAll:\nAthTblReset:\n \"tbtop\"    athtable\n do forever\n   zsel=''\n   \"tbscan\" athtable \"arglist(zsel) condlist(NE)\"\n   if rc<>0 then leave\n   zsel=''\n   \"tbput\"  athtable\n end\n parse value 0 with athtdtop athsell\n Return 0\n\nAthTblFind: /* copy row with text */\n if arg(1)<>'' then arg athfind\n if athfind='' then return AthIspMsg('No find arg set')\n \"tbskip\" athtable \"row(\"athtdtop\") noread\" /* position   */\n Do forever\n   \"tbskip\" athtable \"rowid(#)\"\n   if rc<>0 then return AthIspMsg('No match for' athfind)\n   if zsel='X' then iterate\n   Interpret \"n=pos(athfind,translate(\"athsearchvar\"))\"\n   if n>0 then leave\n End\n athtdtop=#\n Return 0\n\nAthTblOnly: /* show only lines with text */\n arg athonly\n if athonly='' then return AthIspMsg('No ONLY arg set')\n /*Call AthTblReset */\n athonlyn=0\n \"tbtop\"  athtable\n do forever\n   \"tbskip\" athtable\n   if rc<>0 then leave\n   if zsel='X' then iterate\n   Interpret \"n=pos(athonly,translate(\"athsearchvar\"))\"\n   if n=0 then do\n     zsel='X'\n     \"tbput\"  athtable\n   end\n   else athonlyn=athonlyn+1\n End\n athtdtop=0\n call AthIspMsg athonlyn 'records with match'\n Return 0\n\nAthTblExcl: /* suppress lines with text */\n arg athexcl\n if athexcl='' then return AthIspMsg('No excl arg set')\n athexcln=0\n \"tbtop\"  athtable\n do forever\n   \"tbskip\" athtable\n   if rc<>0 then leave\n   if zsel='X' then iterate\n   Interpret \"n=pos(athexcl,translate(\"athsearchvar\"))\"\n   if n>0 then do\n     zsel='X'\n     \"tbput\"  athtable\n     athexcln=athexcln+1\n   end\n End\n athtdtop=0\n call AthIspMsg athexcln 'records excluded'\n Return 0\n\nAthTblSort: /* sort */\n zerrlm=''\n \"tbsort\" athtable \"fields(\"athsort\")\"\n if rc<>0 then return AthIspMsg('SORT error rc' rc zerrlm)\n athtdtop=0\n return 0\nAthTblSortN: /* sort named */\n parse value '' with zerrlm p\n do n=1 to words(athpcdata)\n   p=p','word(athpcdata,n)',C,A'\n end\n \"TBSORT\" athtable \"FIELDS(\"substr(p,2)\")\"\n if rc<>0 then return AthIspMsg('SORT error rc' rc zerrlm)\n athtdtop=0\n return 0\n\n /*--------------------------------------------------------------------\n                        Table edit functions\n --------------------------------------------------------------------*/\nAthTblListRow:\nAthTblShowRow:\nAthTblEditL:  /* list table row (detail list) */\nAthTblEditS:  /* show table row (detail list) */\ntrace off\n Call AthTblSetSel      /* clear zsel */\n if athdpanel<>'' then do\n   athpnlac ='OUTPUT'\n   athpnltx =''\n   zcmd=''\n   \"display panel(\"athdpanel\")\"\n   if rc >8 then Return AthIspMsg('Panel' athdpanel 'display error rc' rc)\n end\n Return 0\n\nAthTblDeleteRow:\nAthTblEditD:  /* delete table row */\ntrace off\n Call AthTblSetSel      /* clear zsel */\n if athdpanel<>'' then do\n   athpnlac ='OUTPUT'\n   athpnltx ='Hit ENTER to delete record, enter CANcel to abort'\n   zcmd=''\n   \"display panel(\"athdpanel\")\"\n   if rc >8 then Return AthIspMsg('Panel' athdpanel 'display error rc' rc)\n   if rc<>0 then Return AthIspMsg('Row delete aborted')\n end\n Return AthIspCmd(\"tbdelete\" athtable,,,'Delete failed')\n\nAthTblEditRow:\nAthTblEditE:  /* edit table row   */\ntrace off\n if athdpanel='' then return AthIspMsg('DPANEL is required for EDIT')\n Call AthTblSetSel      /* clear zsel */\n athwtbl='W'athuid\n parse value 'INPUT USCORE' with athpnlac athpnlhi\n athpnltx = word(arg(1) 'Edit',1) 'record, enter CANcel to discard changes'\n do forever\n   zcmd=''\n   \"display panel(\"athdpanel\")\"\n   if rc>8 then Return AthIspMsg('Panel' athdpanel 'rc' rc zerrlm)\n   if abbrev('CANCEL',zcmd,3) then Return AthIspMsg('Updates aborted',4)\n   if rc=8 then Return AthIspCmd(\"tbput\" athtable)\n   if zcmd<>'' then do\n     /* run command with copy of table row*/\n     if athdproc<>'' then do\n       \"tbcreate\" athwtbl \"names(\"athvarl\") nowrite share\"\n       \"tbadd\" athwtbl\n       Interpret,\n         \"cc=\"athdproc\"('\"athme\"','\"athid\"','DTL','\"athwtbl\"','\"zcmd\"')\"\n       if cc=0 then do\n         \"tbget\" athwtbl\n         \"tbput\" athtable\n       end\n       \"tbend\" athwtbl\n     end\n     else zz=AthIspMsg('Invalid command' zcmd)\n   end\n end\n Return 0\n\nAthTblInsertRow:\nAthTblEditI:  /* insert table row */\n Call AthTblSetSel      /* clear zsel */\n \"tbvclear\" athtable\n \"tbadd\" athtable\n if athdpanel='' then return 0\n if AthTblEditRow('Insert')<>0 then return AthIspCmd(\"tbdelete\" athtable)\n /* drop row if all fields are null\n \"tbquery\" athtable \"names(n) keys(k)\"\n n=space(translate(n k,' ','()'))\n p=wordpos('ZSEL',n)\n if p>0 then n =delword(n,p,1)\n interpret 'if' n '=\"\" then return AthIspCmd(\"tbdelete\"' athtable')' */\n athdosort='Y'\n Return 0\n\nAthTblRepeatRow:\nAthTblEditR:  /* repeat table row */\n Call AthTblSetSel      /* clear zsel */\n \"tbadd\" athtable\n if athdpanel<>'' then do\n   if AthTblEditRow('Repeat')=0 then athdosort='Y'\n   else \"tbdelete\" athtable\n end\n Return 0\n\n /*--------------------------------------------------------------------\n                               other\n --------------------------------------------------------------------*/\nRequote: if arg(1)='' then return '';else return \"'\"Unquote(arg(1))\"'\"\nUnquote: return space(translate(arg(1),\" \",\"'\"),0)\nXMsg: say 'XISPTBL' arg(1); return word(arg(2) 0,1)\nUnPar: return space(translate(arg(1),' ','()'))\n\nAthIspCmd: /* command,rc,msg-ok-prefix,msg-nok-prefix */\n zerrlm=''\n address ispexec arg(1);\n AthIspCmdrc=rc\n AthIspCmdmsg='rc' rc zerrlm\n if rc<>0 & arg(4)<>'' then return AthIspMsg(arg(3) AthIspCmdmsg,rc)\n if rc<>0 then return rc\n if rc= 0 & arg(3)<>'' then return AthIspMsg(arg(3) 'ok')\n return max(word(arg(2) 0,1),AthIspCmdrc)\n\nAthIspMsg:\n trace off\n zedlmsg='XISPTBL' arg(1)\n address ispexec\"setmsg msg(isrz000)\"\n return word(arg(2) 0,1)\n\nAthRunCmd:\ntrace off\n parse value '0 0' with rc result zerrlm\n Select\n   when word(translate(arg(1)),1)='ISPX' then,\n     address ispexec subword(arg(1),2)\n   when wordpos(translate(arg(1)),'EDITROW REPEATROW DELETEROW',\n     'INSERTROW')>0 then Interpret \"Call Table\"arg(1)\n   otherwise do\n     signal on error  name AthRunCmdErr\n     signal on syntax name AthRunCmdErr\n     Select\n       when left(arg(1),1)='%' then address tso arg(1)\n       when word(translate(arg(1)),1)='TSOX' then do\n         address tso subword(arg(1),2)\n         address ispexec 'CONTROL DISPLAY REFRESH'\n       end\n       otherwise Interpret arg(1)\n     End\n     signal off error\n     signal off syntax\n   end\n end\n rc= max(rc,result)\nAthRunCmdErr:\n if rc>8 | rc<0 then say 'Execution error' arg(1) 'RC' rc zerrlm\n signal off error\n signal off syntax\n return 0\n\nAthParser:\ntrace off\n parse arg zpstring,zpvalids,zppfx\n upper zpvalids\n do while zpstring<>''\n   zpstring=strip(zpstring,'b')\n   if zpstring='' then return 0\n   zn=Min(pos('(',zpstring'('),pos(' ',zpstring' '))\n   parse var zpstring zpverb =(zn) zpstring\n   if zpvalids<>'' & wordpos(translate(zpverb),zpvalids)=0 ,\n     then return 1 'Invalid verb' zpverb\n   if left(zpstring' ',1)=' ' then zn=Value(zppfx''zpverb,'Y')\n   else do\n     parse value 1 0 substr(zpstring,2) with zn zp zpstring\n     if left(zpstring,1)=')' then zpstring=' 'zpstring /* null */\n     do until zn<=0\n       zp=Verify(zpstring')','()','M',zp+1)\n       if zp=0 then return 2 'Missing end at' zpstring\n       if substr(zpstring,zp,1)=')' then zn=zn-1\n       else zn=zn+1\n     end\n     parse var zpstring zpdata =(zp) zpstring\n     zn=Value(zppfx''zpverb,strip(zpdata))\n     if left(zpstring,1)=')' then zpstring=substr(zpstring,2)\n   end\n end\n return 0\n\n/* test value against a list of verbs/abbreviations\n   value,list - returns 1: true or 0: false\n   list must include the length of the abbreviation, i.e. NAME(1)\n*/\nAthAbrList: Procedure expose abbrlistv\n arg val,lst\n if wordpos(val,translate(lst,' ','()'))>0 then do\n   abbrlistv=val\n   return 1\n end\n do while lst<>''\n   parse value space(lst) with abbrlistv'('lstl')' lst\n   if lstl<>'' then,\n     if abbrev(abbrlistv,val,lstl) then return 1\n end\n return 0   /* false */\n\nAthTblCopy: Procedure\n arg $ctn1 $ctn2            /* name1,name2 */\n zsel=''\n address ispexec\n \"tbtop\" $ctn1\n \"tbquery\" $ctn1 \"rownum($rows)\"\n do $rows\n   \"tbskip\" $ctn1\n   \"tbadd\"  $ctn2\n end\n return 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT989/FILE989.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT989", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}