{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011259000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 823004, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE125.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE125.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0f\\n'", "DS1TRBAL": "b'SF'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x00\\xc9\\x00\\r\\x00\\xca\\x00\\r\\x00\\x10'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$README": {"ttr": 516, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "****DISCLAIMER****\nTHE SOFTWARE DESCRIBED IN THIS DOCUMENT IS SUPPLIED FREE\nAND MAY BE USED OR COPIED AS NEEDED. IT IS INTENDED FOR\nTECHNICAL PERSONNEL AND ALTHOUGH EVERY EFFORT HAS BEEN MADE\nTO INSURE THAT THE PROGRAMS AND TECHNIQUES ARE CORRECT THERE\nIS NO GUARANTEE THAT THEY ARE. PEOPLE USING THE PROGRAMS AND\nINFORMATION CONTAINED HERE DO SO AT THERE OWN RISK.\n**************************************************************\n\nREAD MEMBER $SASDOC FOR MORE INFORMATION AND DIRECTIONS.\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$FILE1": {"ttr": 518, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "THE INSTALLATION TAPE IS A STANDARD LABELED CARTRIDGE THAT\nCONTAINS TWO FILES.\n\nFILE1 IS THE INSTALLTION INSTRUCTIONS AND JCL. (YOU ARE NOW READING\nFILE1.) THIS FILE ALSO APPEARS AS MEMBER $FILE1 IN THE PDS DESCRIBED\nBELOW.\n\nFILE2 IS A PARTITIONED DATASET THAT CONTAINS VARIOUS SAS PROGRAMS\nAND OTHER RELATED JOBS.\n\n\nTO UNLOAD THIS FILE1 FROM TAPE (OPTIONAL) USE THE FOLLOWING\nIEBGENER PROGRAM:\n\n//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//FILE1    EXEC PGM=IEBGENER\n//*  **********************************************************\n//*  *        UNLOAD1 FILE1                                   *\n//*  *        DOCUMENTATION AND INSTRUCTIONS                  *\n//*  **********************************************************\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  UNIT=CART,\n//             DISP=(OLD,KEEP),DSN=FILE1,\n//             VOL=(,RETAIN,SER=TC0001),\n//             LABEL=(1,SL,EXPDT=98000)\n//SYSUT2   DD  DISP=(NEW,KEEP),\n//             DSN=A.XY.FILE1.DATASET,               <==== CHECK\n//             VOL=SER=TECH81,UNIT=DISK,             <==== CHECK\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=4240),\n//             SPACE=(TRK,(1))\n//\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nTO UNLOAD FILE2 FROM TAPE (SOURCE PDS) USE THE FOLLOWING IEBCOPY JCL:\n\n//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//   EXEC PGM=IEBCOPY\n//*  **********************************************************\n//*  *        UNLOAD  FILE2                                   *\n//*  *        SOURCE PDS                                      *\n//*  **********************************************************\n//SYSPRINT DD SYSOUT=*\n//INDD1    DD UNIT=CART,\n//            DISP=(OLD,KEEP),DSN=FILE2,\n//            VOL=(,RETAIN,SER=TC0001),\n//            LABEL=(2,SL,EXPDT=98000),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=4240)\n//OUTDD1 DD UNIT=DISK,\n//   DSN=A.XY.TEST.SASCPU,                           <====CHECK\n//   DISP=(NEW,KEEP),\n//   VOL=SER=TECH81,                                 <====CHECK\n//   SPACE=(CYL,(5,,50)),    <=WILL ACTUALLY FIT ON 1 CYL\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=4240)\n//SYSIN    DD *\n    COPY OUTDD=OUTDD1,INDD=INDD1\n//\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n***********************************************************************\n**  THE FOLLOWING DIRECTIONS COME FROM THE TAIL-END OF $SASDOC       **\n***********************************************************************\n\nONCE THE SOURCE PDS HAS BEEN UNLOADED FROM FILE 2 THEN RUN THE\nFOLLOWING JOBS FROM THE PDS:\n 1) ALLOCATE SAS DATASET. USE MEMBER ALLOCSAS. SPACE REQUIREMENTS\n    DEPEND ON HOW MUCH DATA YOU INTEND TO STORE IN THIS DATASET.\n 2) PULL OFF RMF RECS FOR A CERTAIN TIME PERIOD (MONTH, WEEK, DAY, ETC.)\n    AND STORE ON DISK TEMPORARILY.\n    COULD USE PROGRAM XY9910.\n 3) SORT RMF RECORDS. SEE SORTRMF MEMBER. (NOTE: THIS IS THE\n    SAME SORT THAT MUST BE USED IF RMF RECORDS SRE TO USED\n    BY THE RMF POST PROCESSOR.)\n 4) MODIFY THE OUTPUT AND SYSTEM ID'S IN RMF70, RMF71, AND, RMF72.\n 5) RUN RMF70J, RMF71J, AND RMF72J TO RETREIVE, AND SUMMARIZE\n    RMF DATA BY RMF INTERVAL AND THEN STORE IT IN A SAS DATASET.\n    YOU MIGHT WANT TO CHECK TO SYSPRINT OUTPUT OF THESE JOBS\n    AGAINST YOUR RMF REPORTS TO MAKE SURE IT IS CORRECT.\n 6) MODIFY THE MEMBER SASCLIST FOR YOUR INSTALLATION. THESE DIRECTIONS\n    ASSUME YOU ARE USING THE DISPLAY MANAGER OPTION OF SAS. BUT\n    THEY ARE BASICALLY HOLD TRUE FOR THE OTHER OPTION AS WELL (I.E.\n    THE VERSION THAT USES A LINE EDITOR.)\n---------\n 7) TO PRODUCE SAS GRAPHS USING THE RETREIVED INFORMATION:\n      ENTER: EX 'A.XY.SASCPU(SASCLIST)'  FROM OPTION 6 IN TSO.\n\n      WHEN SAS PRESENTS ITSELF ON YOUR SCREEN ENTER:\n      INCLUDE DD1(SASMEMBER) ON THE COMMAND LINE, WHERE SASMEMBER\n      IS THE NAME OF MEMBER IN A.XY.SASCPU THAT PRODUCES A GRAPH.\n\n      FOR EXAMPLE,   INCLUDE DD1(D2CPU)\n      WILL PULL IN THE CODE TO PRODUCE A GRAPH OF CPU UTILIZATION.\n\n      NOTE THAT MOST OF THE \"PROC PRINT ... \" STATEMENTS HAVE BEEN\n      COMMENTED OUT. JUST REMOVE THE ASTERISK FROM COLUMN 1 ON THESE\n      STATEMENTS WHEN YOU WISH TO VIEW THE PRINT. ONCE THE DATA IS\n      VERIFIED AND/OR YOU NO LONGER WISH TO SEE THE PRINT JUST\n      REPLACE THE ASTERISK BACK IN COLUMN 1.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$MEMINFO": {"ttr": 521, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "$$README  IMPORTANT INFORMATION. READ THIS BEFORE USING.\n$FILE1    INSTRUCTIONS AND JCL TO UNLOAD TAPE\n$MEMINFO  THIS MEMBER\n$SASDOC   SHORT DECRIPTION OF SYSTEM\nALLOCPDS  JCL TO ALLOCATE SOURCE PDS\nALLOCSAS  JCL TO ALLOCATE SAS DATASET\nCOPYDT    IEBGENER TO COPY SMF/RMF DATA FROM DISK TO TAPE\nCPTOT     SAS PROGRAM TO READ SUMMARIZED RMF RECORDS PRODUCED BY CPUT.\nCPTOTJ    JCL TO RUN CPTOT IN BATCH.\nCPUT      SAS PROGRAM TO READ RMF RECORDS. USED TO FIND TOTAL UTIL.\n          OF A PHYSICAL PROCESSOR COMPLEX.\nCPUTJ     JCL TO RUN CPUT IN BATCH\nDOC1      LONG DESRIPTION OF SYSTEM\nLOADTP    JCL TO LOAD TAPE WITH INSTRUCTIONS AND PDS\nRMF70     SAS PROGRAM TO READ RMF TYPE 70 RECS\nRMF70J    JCL TO RUN RMF70 IN BATCH\nRMF70W    SAME AS RMF70 EXCEPT OUTPUT STATEMENTS ARE DIFFERENT\nRMF70WJ   JCL TO RUN RMF70W IN BATCH\nRMF71     SAS PROGRAM TO READ RMF TYPE 71 RECS\nRMF71J    JCL TO RUN RMF71 IN BATCH\nRMF71W    SAME AS RMF71 EXCEPT OUTPUT STATEMENTS ARE DIFFERENT\nRMF71WJ   JCL TO RUN RMF71W IN BATCH\nRMF72     SAS PROGRAM TO READ RMF TYPE 72 RECS\nRMF72J    JCL TO RUN RMF72 IN BATCH\nRMF72W    SAME AS RMF72 EXCEPT OUTPUT STATEMENTS ARE DIFFERENT\nRMF72WJ   JCL TO RUN RMF72W IN BATCH\nSORTWEEK  JCL TO SORT RMF RECORDS\nUNLOAD    JCL TO UNLOAD INSTRUCTIONS AND SOURCE PDS FROM TAPE\nXY9910    ASM PROGRAM TO PULL OFF RMF 70-79 RECORDS FROM TAPE\nXY9910AS  JCL TO ASSEMBLE/LINK XY9910\nXY9910J   JCL TO RUN PROGRAM XY9910\n\n\nTHE MEMBERS BELOW ARE SAS PROGRAMS THAT GRAPH SOME OF THE DATA\nSAVED IN THE SAS DATASET BY RMF70, RMF71, RMF72 AND OTHER DATA\nREDUCTION PROGRAMS.\n\n        |\nMEMBER  |DESCRIPTION\n--------+---------------------------------------------------------------\n        |\nBATCH   | JCL TO PRINT GRAPHS TO A LOCAL PRINTER(S) WITHOUT HAVING TO\n        | USE TSO.\n        |\nCPUCPW  |2-DIM GRAPH OF AVERAGE CPU UTILIZATION BY MACHINE. PLOTTED\n        |BY DAY, FOR ONE WEEK.\n        |\nCPUNDL  |3-DIM GRAPH OF AVERAGE CPU UTILIZATION BY MACHINE (SCATTER\n        |DIAGRAM). EACH RMF INTERVAL IS SHOWN AND GROUPED BY LOW, MED.,\n        |OR HIGH CPU UTILIZATION. BEST WHEN PRINTED IN COLOR.\n        |\nCPUUT   |2-DIM GRAPH OF AVERAGE CPU UTILIZATION BY MACHINE. PLOTTED\n        |BY DAY.\n        |\nD2BAV   |2-DIM GRAPH OF AVERAGE BATCH USERS AND ASIDS OUT/READY. PLOTTED\n        |BY DAY.\n        |\nD2BMM   |2-DIM GRAPH OF AVERAGE MAX BATCH USERS.\n        |\n        |\nD2CPU   |2-DIM GRAPH OF AVERAGE CPU UTILIZATION.\n        |PLOTTED BY DAY.\n        |\nD2PPS   |2-DIM GRAPH OF PAGES PER SECOND.\n        |PLOTTED BY DAY.\n        |\nD2PPS2  |2-DIM GRAPH OF PAGES PER SECOND FOR SYSTEM 2.\n        |PLOTTED BY DAY.\n        |\nD2PPS3  |2-DIM GRAPH OF PAGES PER SECOND FOR SYSTEM 3.\n        |PLOTTED BY DAY.\n        |\nD2RT2   |2-DIM GRAPH OF AVERAGE TSO RESPONSE TIME FOR ALL PERIODS AND\n        |ALSO THE AVERAGE. PLOTTED BY DAY.\n        |\nD2RT2P1 |2-DIM GRAPH OF AVERAGE TSO RESPONSE FOR PERFORMANCE GROUP 2,\n        |PERIOD 1 (TRIVIAL). CAN BE USED FOR ANY PERFORMANCE GROUP BY\n        |CHANGING THE INPUT. PLOTTED BY DAY.\n        |\nD2RT2H  |2-DIM GRAPH OF AVERAGE TSO RESPONSE TIME FOR FIRST PERIOD.\n        |X-AXIS IS 1/2 HOUR INTERVALS STRUNG OUT BY DAY.\n        |(I.E 9-4 DAY 1, 9-4 DAY 2, ETC.)\n        |\nD2TMM   |2-DIM GRAPH OF AVERAGE OF MAX TSO USERS LOGGED ON. PLOTTED BY\n        |DAY.\n        |\nM1HH    |SHOWS CPU UTILIZATION (BY MACHINE) SUMMERIZED BY HOURS. GIVES\n        |MAX UTIL FOR 1 HOUR, HIGHEST HOURLY AVERAGE, AND MONTHLY\n        |AVERAGE OF ALL THE HOURS.\n        |\nPGSECC  |3-DIM COUNTOUR GRAPH OF PAGES/SEC BY HOUR BY DAY.\n        |NOT THE GREATEST.\n        |\nPPS3D   |3-DIM GRAPH OF PAGES/SEC BY HOUR BY DAY.\n        |\nPPS3DS  |3-DIM SCATTER DIAGRAM OF PAGES/SEC BY HOUR BY DAY.\n        |\nREGCPU  |REGRESSION ANALYSIS OF CPU UTILIZATION.\n        |BY DAY.\n        |\nRM1CPMAX|REGRESSION ANALYSIS OF MAXIMUM CPU UTILIZATION FOR ONE MACHINE.\n        |BY DAY.\n        |\nRM1CPU  |REGRESSION ANALYSIS OF TOTAL CPU UTILIZATION FOR ONE MACHINE.\n        |BY DAY.\n        |\nREGPPS1 |REGRESSION ANALYSIS OF PAGES PER SECOND.\n        |BY DAY.\n        |\nRT213D  |3-DIM GRAPH OF AVERAGE TSO FIRST PERIOD RESPONSE TIME.\n        |BY 1/2 HOUR BY DAY.\n        |\n        |\n        |\n        |\n        |\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$SASDOC": {"ttr": 524, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "        SMF/RMF RECORDS\n              |\n              |     Retreive RMF records from SMF tape and store onto\n              |     a disk dataset. (Could use program xy9910 for this.)\n              |\n              V\n         RMF RECORDS\n              |\n              |     Read RMF records with SAS programs and store the\n              |     results on a SAS dataset. (Use SAS programs\n              |     RMF70, RMF71, and RMF72 for this.) One member is\n              |     created for each RMF record type. Contained in this\n              |     member are observations. There is one observation\n              |     for each RMF interval. Additionally, the\n              |     data is kept seperate by system. Therefore, a week's\n              |     worth of data for 1 system that had RMF intervals\n              |     of 1/2 hour would then have 3 SAS members\n              |     (1 for RMF record 70 + 1 for RMF record 71 + 1 for\n              |     RMF record 72 = 3). Each member would contain 336\n              |     observations (48 per day * 7 days in a week = 336).\n              |     Unless, of course, RMF was not up all the time, or\n              |     the system was down.\n              |\n              |     A couple of new programs have been added in an\n              |     attempt to keep track of CPU utilization by\n              |     physical machine (also known as \"physical processor\n              |     complex\" - for example, one 3090-400S). This will\n              |     allow us to keep track of total CPU utilization\n              |     for a machine irregardless of wether it is\n              |     physically or logically partitioned and how many\n              |     logical CPU's it is using.\n              |\n              |     Basically, there is a program CPUT which summerizes\n              |     RMF data and stores it on a SAS dataset under the\n              |     name  'ssCPyymm'. Where ss = some sort of system\n              |     identifier,  yy = last 2 digits of the year, and\n              |     mm = month. Some examples are:\n              |      P0CP8903 for the month of March 1989 for system P0.\n              |      P1CP8903 for the month of March 1989 for system P1.\n              |      S1CP8904 for the month of April 1989 for system S1.\n              |\n              |     Then there is program CPTOT which attempts to\n              |     combine this data to show utilization for the whole\n              |     machine. This program creates SAS member UTM1yymm.\n              |     (E.g. UTM18903 = March 1989 util. for machine #1.)\n              |     Input for CPTOT is only those system CPU\n              |     utilizations that ran on that phycical machine.\n              |\n              |     Sample flow chart of programs CPUT and CPTOT\n              |\n              |                   RMF data\n              |                      |\n              |                      |\n              |                      V\n              |                 **********\n              |                 *  CPUT  *\n              |                 **********\n              |                      |\n              |                      |\n              |                      \\------> P0CP8903\n              |                               P1CP8903\n              |                                  |\n              |                                  |\n              |                                  |\n              |                                  V\n              |                             ***********\n              |                             *  CPTOT  *\n              |                             ***********\n              |                                  |\n              |                                  |\n              |                                  |\n              |                                  V\n              |                               UTM18903\n              |     .\n              |     .\n              |\n              |\n              |\n              |\n              |\n              |\n              |\n              |\n              V\n         SAS database\n              |\n              |     Run SAS programs to print, sumarize, plot, etc.\n              |     the data contained in the SAS dataset.\n              |\n              V\n         SAS Reports\n\n  Any comments or questions you can reach me at :\n    Thomas Confrey\n    Data Center\n    340 Capitol Ave.\n    4-th Floor - Technical Support\n    Hartford, CT  06106\n\n  or by phone: (203) 566-4362\n\n\n\n **********************************************************************\n **    When changes are made below, copy it to the last half of      **\n **    member $file1.                                                **\n **********************************************************************\n\n ONCE THE SOURCE PDS HAS BEEN UNLOADED FROM FILE 2 THEN RUN THE\n FOLLOWING JOBS FROM THE PDS:\n 1) ALLOCATE SAS DATASET. USE MEMBER ALLOCSAS. SPACE REQUIREMENTS\n    DEPEND ON HOW MUCH DATA YOU INTEND TO STORE IN THIS DATASET.\n 2) PULL OFF RMF RECS FOR A CERTAIN TIME PERIOD (MONTH, WEEK, DAY, ETC.)\n    AND STORE ON DISK TEMPORARILY.\n    COULD USE PROGRAM XY9910.\n 3) SORT RMF RECORDS. SEE SORTRMF MEMBER. (NOTE: THIS IS THE\n    SAME SORT THAT MUST BE USED IF RMF RECORDS SRE TO USED\n    BY THE RMF POST PROCESSOR.)\n 4) MODIFY THE OUTPUT AND SYSTEM ID'S IN RMF70, RMF71, AND, RMF72.\n 5) RUN RMF70J, RMF71J, AND RMF72J TO RETREIVE, AND SUMMARIZE\n    RMF DATA BY RMF INTERVAL AND THEN STORE IT IN A SAS DATASET.\n    YOU MIGHT WANT TO CHECK TO SYSPRINT OUTPUT OF THESE JOBS\n    AGAINST YOUR RMF REPORTS TO MAKE SURE IT IS CORRECT.\n 6) MODIFY THE MEMBER SASCLIST FOR YOUR INSTALLATION. THESE DIRECTIONS\n    ASSUME YOU ARE USING THE DISPLAY MANAGER OPTION OF SAS. BUT\n    THEY ARE BASICALLY HOLD TRUE FOR THE OTHER OPTION AS WELL (I.E.\n    THE VERSION THAT USES A LINE EDITOR.)\n --------\n 7) TO PRODUCE SAS GRAPHS USING THE RETREIVED INFORMATION:\n      ENTER: EX 'A.XY.SASCPU(SASCLIST)'  FROM OPTION 6 IN TSO.\n\n      WHEN SAS PRESENTS ITSELF ON YOUR SCREEN ENTER:\n      INCLUDE DD1(SASMEMBER) ON THE COMMAND LINE, WHERE SASMEMBER\n      IS THE NAME OF MEMBER IN A.XY.SASCPU THAT PRODUCES A GRAPH.\n\n      FOR EXAMPLE,   INCLUDE DD1(D2CPU)\n      WILL PULL IN THE CODE TO PRODUCE A GRAPH OF CPU UTILIZATION.\n\n      NOTE THAT MOST OF THE \"PROC PRINT ... \" STATEMENTS HAVE BEEN\n      COMMENTED OUT. JUST REMOVE THE ASTERISK FROM COLUMN 1 ON THESE\n      STATEMENTS WHEN YOU WISH TO VIEW THE PRINT. ONCE THE DATA IS\n      VERIFIED AND/OR YOU NO LONGER WISH TO SEE THE PRINT JUST\n      REPLACE THE ASTERISK BACK IN COLUMN 1.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALLOCPDS": {"ttr": 528, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,20,20,10),'IEFBR14      +TC',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//* ALLOCATE SOURCE PDS.\n//* CHANGE THE VOL=SER=\n//*\n//   EXEC PGM=IEFBR14\n//DD1      DD DSN=XY.TC.A.SASCPU,\n//   VOL=SER=XXXXXX,DISP=(NEW,CATLG),UNIT=DISK,\n//   SPACE=(CYL,(05,,100)),\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOCSAS": {"ttr": 530, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,20,20,10),'IEFBR14      +TC',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//* ALLOCATE SAS DATASET. NUMBER OF CYLINDERS DEPENDS\n//* ON HOW MUCH DATA YOU INTEND TO PUT OUT THERE.\n//* CHANGE THE VOL=SER=\n//*\n//   EXEC PGM=IEFBR14\n//DD2      DD DSN=XY.TC.A.SASDB.CPU,\n//   VOL=SER=XXXXXX,DISP=(NEW,CATLG),UNIT=DISK,\n//   SPACE=(CYL,(20))\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BADREC": {"ttr": 532, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "   IF SMF70BDN = 0 THEN GO TO NEXT_P /*BECAUSE NO. OF LOG. PROCESSORS*/;\n*                                  FOR THIS PARTITION IS ZERO. ELSE,   ;\n**                                 POINT TO LPDS FOR THIS PARTITION.***;\n**  POINTER = OFFSET PLUS LENGTH TIMES NUM. OF SECTIONS TO SKIP     ***;\n    NUMCPU = S70BNP      /*RESET TO NO. PROCESSORS ASSIGNED TO PR/SM*/;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BATCH": {"ttr": 534, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//XYT6970A JOB (XY,R412,20,20,10),'WEEKLY IB GRAPHS',MSGLEVEL=(1,1),\n//  CLASS=O,MSGCLASS=R\n//*\n//*\n//*           PRODUCES GRAPHS FROM A SAS DATA BASE.\n//*\n//STEP1    EXEC SAS,RGN=6000K\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//*AS.ADMDEFS  DD DISP=SHR,DSN=XY.GDDM.GDDMDEF\n//*AS.ADMDEFS  DD DISP=SHR,DSN=P.GDDM.GDDMDEFF\n//SASDB  DD DSN=XY.TC.SASDB.CPU,            <==INPUT  (SAS DATASET)\n//          DISP=SHR\n//DD1    DD DISP=SHR,DSN=XY.TC.PROD.SASCPU  <==NEEDED FOR EXCLUDE DATES\n//*                                            AND SOURCE PROGRAMS\n//SYSIN  DD *\nGOPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEV=GDDMFAM2 GDDMTOKEN=L68;\nGOPTIONS  NOTEXT82;\n%INCLUDE DD1(CPUCPW);\n%INCLUDE DD1(D2PPS2);\n%INCLUDE DD1(D2PPS3);\n%INCLUDE DD1(RM1CPMAX);\n%INCLUDE DD1(RM1CPU);\n%INCLUDE DD1(M1HH);\nGOPTIONS DEVADDR=(ADMPRINT,.,L03M16) DEV=GDDM87;\n%INCLUDE DD1(CPUNDL);\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONTENTS": {"ttr": 536, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PROC CONTENTS WILL PRINT INFORMATION AND/OR MEMBERS OF A SAS\n//*  DATA SET. BELOW ARE SOME COMMONLY USED OPTIONS:\n//*\n//* PROC CONTENTS DATA = SASDB._ALL_ NODS; <-- DIRECTORY ONLY\n//* PROC CONTENTS DATA = SASDB.XXX  ;      <-- PRINT MEMBER XXX\n//* PROC CONTENTS DATA = SASDB._ALL_ ;     <-- PRINT DESC OF ALL SAS\n//*                                            DATA SETS (AND DIR)\n//* PROC CONTENTS DATA = SASDB._ALL_ SHORT;<-- PRINT ONLY VARIABLE NAMES\n//*\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,\n//   DISP=OLD\n//SYSIN DD *\nPROC CONTENTS DATA = SASDB._ALL_ NODS;\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPYDT": {"ttr": 538, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*   TAKES THE MONTHLY RMF DISK FILE AND COPIES TO TAPE\n//*    USING IEBGENER\n//*\n//   EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=R\n//SYSIN    DD DUMMY\n//SYSUT1 DD DSN=XY.RMFMONTH,\n//          DISP=(OLD,KEEP,KEEP)\n//SYSUT2 DD DSN=A.DC.MONTHLY.RMF88(+1),\n//          DISP=(NEW,CATLG,DELETE),UNIT=CART,\n//          LABEL=EXPDT=99000,\n//          DCB=(A.GDGDUMMY,RECFM=VBS,LRECL=32759,BLKSIZE=6000)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPTOT": {"ttr": 769, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n|   CPTOT                                                           |\n|                                                                   |\n|   THIS PROGRAM READS INPUT FROM 2 SYSTEMS. (THE INPUT IS CREATED  |\n|   BY \"CPUT\") IF MACHINES ARE = AND THIS IS NOT PR/SM THEN ADD     |\n|   THE 2 UTILIZATIONS TOGETHER AND DIVIDE BY THE APPROPRIATE       |\n|   NUMBER.                                                         |\n|   IF THIS IS PR/SM AND THE PARTITIONS ARE DEDICATED THEN DO THE   |\n|   SAME THING. HOWEVER, IF THE LPARS HAVE SHARED CPU'S THEN        |\n|   USE THE INFORMATION FROM ONE SYSTEM ONLY SINCE ALL THE INFO     |\n|   IS THERE.                                                       |\n|   .                                                               |\n|   IF PHYSICALLY PARTITIONED AND BOTH SIDES ARE NOT UP, THIS       |\n|   PROGRAM WILL SKIP RECORDS BECAUSE IT IS LOOKING FOR A MATCH.    |\n|                                                                   |\n|   THE VARIABLES THAT ARE SAVED ARE:                               |\n|                                                                   |\n|   S70INT........ LENGTH OF (RMF) INTERVAL                         |\n|   WAIT_PER...... PER OF WAIT TIME (NON PR/SM AND TIME SLICING)    |\n|   S70MOD........ CPU MODEL NUMBER (E.G. 3090)                     |\n|   S70VER........ CPU VERSION NUMBER (E.G. 41)                     |\n|   S70SER........ CPU SERIAL NUMBER                                |\n|   S70SID........ SYSTEM'S SMF ID -THE SYSTEM THAT PRODUCED THE    |\n|                  RMF RECORDS.                                     |\n|   S70DAT........ INTERVAL DATE                                    |\n|   S70IST........ INTERVAL START TIME                              |\n|   NUMLP......... NUMBER OF LOGICAL PROCESSORS (PR/SM)             |\n|   NUMPART....... NUMBER OF PARTITIONS RUNNING UNDER PR/SM         |\n|   TOT_UT........ TOTAL UTILIZATION (ALL CPU'S IN PARTITION)       |\n|   CPU_UT........ AVG. PERCENT BUSY (1 - WAIT_PER FOR NON PR/SM) OR|\n|                  FROM SMF70PDT FOR PR/SM MACHINES - CALCULATED    |\n|                  BY: (TOT_UT/NUM_CP)  <===CHECK THIS.             |\n|   NUMCPU........ NUMBER OF LOGICAL PROCESSORS ASSIGNED TO A       |\n|                  PARTITION OR IS THE NUMBER AVAILABLE <=====???   |\n|   MODE.......... BLANK = BASIC MODE. \"D\" = LPAR HAS DEDICATED     |\n|                  CPU'S. \"E\" = LPAR'S HAVE SHARED CPU'S WITH       |\n|                  WAIT COMPLETION ENABLED. \"P\" = LPAR'S HAVE ALL   |\n|                  SHARED CPU'S.                                    |\n|   FLAG.......... INDICATES DATA MIGHT NOT BE COMPLETELY CORRECT   |\n|                  FOR THIS PARTICULAR RMF INTERVAL.                |\n|                                                                   |\n|   OUTPUT FILE NAME = TOTAL UTILIZATION                            |\n|                      FOR MACHINE #1                               |\n|                       \u00a6                                           |\n|                       \u00a6             YEAR...MONTH                  |\n|                       \u00a6              \u00a6       \u00a6                    |\n|                       \u00a6              \u00a6       \u00a6                    |\n|    E.G.   UTM18811 = UTM1...........88  ... 11                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.UTM18811 TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|          C UTM18809 UTM18810 ALL                                  |\n|                                                                   |\n|   UPDATES:                                                        |\n*-------------------------------------------------------------------*\n;\n   DATA\n SASDB.UTM18904 (KEEP=S70INT S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                TOT_UT CPU_UT NUMCPU  MODE FLAG )\n        ;\n  REC0SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\nREADP1:\n   SET SASDB.P1CP8904;\n   IF S70IST LT 090000\n      THEN GO TO READP1            /*THROW OUT ANYTHING BEFORE 9:00  */;\n   IF S70INT LT 0500000\n      THEN GO TO READP1            /*INTERVAL IS TOO SMALL           */;\n  REC1SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\n  IF MODE = 'P' OR\n     MODE = 'E' THEN GO TO PR_SM   /*THIS IS A PR/SM MACHINE         */;\n* ***                                                                  ;\n* ***OTHERWISE WE HAVE PR/SM WITH DEDICATED CPU'S OR BASIC MODE.       ;\n* ***IN THIS CASE WE WILL COMBINE THE CPU UTILIZATIONS FROM 2          ;\n* ***OPERATING SYSTEMS.                                                ;\n* ***                                                                  ;\n   S70INT1 = S70INT;\n   S70MOD1 = S70MOD;\n   S70VER1 = S70VER;\n   S70SER1 = S70SER;\n   S70SID1 = S70SID;\n   S70DAT1 = S70DAT;\n   S70IST1 = S70IST;\n   TOT_UT1 = TOT_UT;\n   CPU_UT1 = CPU_UT;\n   NUMCPU1 = NUMCPU;\n   MODE1   = MODE;\n   FLAG1   = FLAG;\n   ISTHH1  = FLOOR(S70IST/10000)   /*HOUR THAT INTERVAL STARTED      */;\n   ISTHM1  = FLOOR(S70IST1/100)    /*HH MM THAT INTERVAL STARTED     */;\n   NXIST1  = S70IST+(S70INT1/1000) /*TIME NEXT INTERVAL SHOULD START */;\n  IF REC0SW = 'Y' THEN GO TO EREADP0 /*ALREADY HAVE A REC, SKIP READ */;\nREADP0:\n   SET SASDB.P0CP8904;\n  IF S70IST LT 090000\n      THEN GO TO READP0            /*THROW OUT ANYTHING BEFORE 9:00  */;\n  IF S70INT LT 0500000\n      THEN GO TO READP0            /*INTERVAL IS TOO SMALL           */;\n  REC0SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\n   S70INT0 = S70INT;\n   S70MOD0 = S70MOD;\n   S70VER0 = S70VER;\n   S70SER0 = S70SER;\n   S70SID0 = S70SID;\n   S70DAT0 = S70DAT;\n   S70IST0 = S70IST;\n   TOT_UT0 = TOT_UT;\n   CPU_UT0 = CPU_UT;\n   NUMCPU0 = NUMCPU;\n   MODE0   = MODE;\n   FLAG0   = FLAG;\n   ISTHH0  = FLOOR(S70IST0/10000)  /*HOUR  THAT INTERVAL STARTED     */;\n   ISTHM0  = FLOOR(S70IST0/100)    /*HH MM THAT INTERVAL STARTED     */;\n   NXIST0  = S70IST0+(S70INT0/1000)  /*START OF NEXT INTERVAL        */;\nEREADP0:\n  IF S70DAT0 LT S70DAT1 THEN\n     GO TO READP0                  /*NON PR/SM-WE WILL JUST SYNCH    */;\n  IF S70DAT0 GT S70DAT1 THEN DO;\n     PUT 'INPUT FOR P0 SOMEHOW GOT AHEAD OF P1.';\n     PUT 'FOR P0 DATE=' S70DAT0 'TIME=' S70IST0 ;\n     PUT 'FOR P1 DATE=' S70DAT1 'TIME=' S70IST1 ;\n     PUT 'WILL GO TRY TO CATCH UP BY READING P1.';\n     REC0SW = 'Y'                  /*HOLD THIS SYSTEMS RECORD        */;\n     GO TO READP1;\n     END;\n***********************************************************************;\n***** DATES ARE NOW EQUAL.  HOWEVER, WE DO NOT ACCOUNT FOR IST'S THAT  ;\n***** ARE CLOSE BUT START MORE THAN A MINUTE APART.                    ;\n*                                                             *********;\n  IF ISTHM0 NE ISTHM1 THEN GO TO ISTNEQ ;\n***********************************************************************;\n***** NOW ALL WE HAVE IS INTERVAL START TIMES ARE EQUAL                ;\n***********************************************************************;\n  INTDIFF = ABS(S70INT0 - S70INT1)/100000 /*DIFF IN MINUTES          */;\n  INTDIFF = FLOOR(INTDIFF)                /*INTEGER ONLY             */;\n  IF ISTHM0 = ISTHM1 AND\n     INTDIFF LT 4 THEN             /*IS DURATIONS WITHIN 4 MINUTES   */\n     GO TO INTEQ                   /*YES, ADD EM UP AND WRITE EM OUT */;\n     GO TO STEQ                    /*INT DURATION DIFF IS GT 4 MINS  */;\nOTHERT:\n   PUT 'AT OTHERT SHOULD NOT BE HERE';\n     PUT 'FOR P0 DATE=' S70DAT0 'TIME=' S70IST0 ;\n     PUT 'FOR P1 DATE=' S70DAT1 'TIME=' S70IST1 ;\n   RETURN;\nINTEQ:\n   TOT_UT  = TOT_UT0 + TOT_UT1     /*SIDE 1 + SIDE 2                 */;\n   NUMCPU  = NUMCPU0 + NUMCPU1     /*TOTAL ALL CPU'S                 */;\n   CPU_UT  = TOT_UT/NUMCPU         /*UTILIZATION OF ALL PHYSICAL CP'S*/;\n   S70INT  = S70INT1;\n   S70MOD  = S70MOD1;\n   S70VER  = S70VER1;\n   S70SER  = S70SER1;\n   S70SID  = S70SID1;\n   S70DAT  = S70DAT1;\n   S70IST  = S70IST1;\n   MODE    = MODE1;\n   FLAG    = FLAG1;\n  OUTPUT SASDB.UTM18904            /*WRITE INFORMATION OUT           */;\n  RETURN;\nPR_SM:\n  OUTPUT SASDB.UTM18904            /*WRITE INFORMATION OUT           */;\n  RETURN;\nSTEQ:\n PUT 'AT STEQ:  INTDIFF=' INTDIFF;\n PUT 'P0 DATE=' S70DAT0 'TIME=' S70IST0 'DUR=' S70INT0;\n PUT 'P1 DATE=' S70DAT1 'TIME=' S70IST1 'DUR=' S70INT1;\n   RETURN;\nISTNEQ:\n PUT 'AT ISTNEQ:  INTDIFF=' INTDIFF;\n PUT 'P0 DATE=' S70DAT0 'TIME=' S70IST0 'DUR=' S70INT0;\n PUT 'P1 DATE=' S70DAT1 'TIME=' S70IST1 'DUR=' S70INT1;\n  IF ISTHM0 LT ISTHM1 THEN DO;\n     REC1SW = 'Y'                  /*HOLD THIS RECORD AND            */;\n     GO TO READP0                  /*GO TRY AND CATCH UP.            */;\n     END                           /*OTHERWISE*/;\n     REC0SW = 'Y'                  /*HOLD THIS RECORD AND            */;\n     GO TO READP1                  /*GO TRY AND CATCH UP.            */;\nRETURN;\n   PROC PRINT DATA=SASDB.UTM18904 ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPTOTJ": {"ttr": 773, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'CPU UT BY MACHINE',MSGLEVEL=(1,1),\n//  CLASS=O,MSGCLASS=A,TIME=(4,10)\n//*\n//*  CALCULATE CPU UTILIZATION BY MACHINE (NOT SYSTEM) FOR THOSE\n//*  MACHINES UNDER THE CONTROL OF PR/SM.\n//*  THIS WILL ALSO WORK FOR NON PR/SM MACHINES.\n//*  INFORMATION IS CONTAINED IN RMF 70 RECORDS.\n//*\n//STEP1  EXEC SAS,WORK='40,10',RGN=4096K\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(CPTOT)\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,           <==INPUT  (SAS DATASET)\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPTOTW": {"ttr": 775, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n|   CPTOTW - SIMILAR TO CPTOT EXCEPT DATA IS FOR ONE WEEK.          |\n|                                                                   |\n|   THIS PROGRAM READS INPUT FROM 2 SYSTEMS. (THE INPUT IS CREATED  |\n|   BY \"CPUT\") IF MACHINES ARE = AND THIS IS NOT PR/SM THEN ADD     |\n|   THE 2 UTILIZATIONS TOGETHER AND DIVIDE BY THE APPROPRIATE       |\n|   NUMBER.                                                         |\n|   IF THIS IS PR/SM AND THE PARTITIONS ARE DEDICATED THEN DO THE   |\n|   SAME THING. HOWEVER, IF THE LPARS HAVE SHARED CPU'S THEN        |\n|   USE THE INFORMATION FROM ONE SYSTEM ONLY SINCE ALL THE INFO     |\n|   IS THERE.                                                       |\n|   .                                                               |\n|   IF PHYSICALLY PARTITIONED AND BOTH SIDES ARE NOT UP, THIS       |\n|   PROGRAM WILL SKIP RECORDS BECAUSE IT IS LOOKING FOR A MATCH.    |\n|                                                                   |\n|   THE VARIABLES THAT ARE SAVED ARE:                               |\n|                                                                   |\n|   S70INT........ LENGTH OF (RMF) INTERVAL                         |\n|   WAIT_PER...... PER OF WAIT TIME (NON PR/SM AND TIME SLICING)    |\n|   S70MOD........ CPU MODEL NUMBER (E.G. 3090)                     |\n|   S70VER........ CPU VERSION NUMBER (E.G. 41)                     |\n|   S70SER........ CPU SERIAL NUMBER                                |\n|   S70SID........ SYSTEM'S SMF ID -THE SYSTEM THAT PRODUCED THE    |\n|                  RMF RECORDS.                                     |\n|   S70DAT........ INTERVAL DATE                                    |\n|   S70IST........ INTERVAL START TIME                              |\n|   NUMLP......... NUMBER OF LOGICAL PROCESSORS (PR/SM)             |\n|   NUMPART....... NUMBER OF PARTITIONS RUNNING UNDER PR/SM         |\n|   TOT_UT........ TOTAL UTILIZATION (ALL CPU'S IN PARTITION)       |\n|   CPU_UT........ AVG. PERCENT BUSY (1 - WAIT_PER FOR NON PR/SM) OR|\n|                  FROM SMF70PDT FOR PR/SM MACHINES - CALCULATED    |\n|                  BY: (TOT_UT/NUM_CP)  <===CHECK THIS.             |\n|   NUMCPU........ NUMBER OF LOGICAL PROCESSORS ASSIGNED TO A       |\n|                  PARTITION OR IS THE NUMBER AVAILABLE <=====???   |\n|   MODE.......... BLANK = BASIC MODE. \"D\" = LPAR HAS DEDICATED     |\n|                  CPU'S. \"E\" = LPAR'S HAVE SHARED CPU'S WITH       |\n|                  WAIT COMPLETION ENABLED. \"P\" = LPAR'S HAVE ALL   |\n|                  SHARED CPU'S.                                    |\n|   FLAG.......... INDICATES DATA MIGHT NOT BE COMPLETELY CORRECT   |\n|                  FOR THIS PARTICULAR RMF INTERVAL.                |\n|                                                                   |\n|   OUTPUT FILE NAME = TOTAL UTILIZATION                            |\n|                      FOR MACHINE #1                               |\n|                       \u00a6                                           |\n|                       \u00a6             WEEK...WEEK NUMBER            |\n|                       \u00a6              \u00a6       \u00a6                    |\n|                       \u00a6              \u00a6       \u00a6                    |\n|    E.G.   UTM18811 = UTM1...........WK  ... 0X                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.UTM1WK0X TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|          C UTM18809 UTM18810 ALL                                  |\n|                                                                   |\n|   UPDATES:                                                        |\n*-------------------------------------------------------------------*\n;\n   DATA\n SASDB.UTM1WK04 (KEEP=S70INT S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                TOT_UT CPU_UT NUMCPU  MODE FLAG )\n        ;\n  REC0SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\nREADP1:\n   SET SASDB.P1CPWK04;\n   IF S70IST LT 090000\n      THEN GO TO READP1            /*THROW OUT ANYTHING BEFORE 9:00  */;\n   IF S70INT LT 0500000\n      THEN GO TO READP1            /*INTERVAL IS TOO SMALL           */;\n  REC1SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\n  IF MODE = 'P' OR\n     MODE = 'E' THEN GO TO PR_SM   /*THIS IS A PR/SM MACHINE         */;\n* ***                                                                  ;\n* ***OTHERWISE WE HAVE PR/SM WITH DEDICATED CPU'S OR BASIC MODE.       ;\n* ***IN THIS CASE WE WILL COMBINE THE CPU UTILIZATIONS FROM 2          ;\n* ***OPERATING SYSTEMS.                                                ;\n* ***                                                                  ;\n   S70INT1 = S70INT;\n   S70MOD1 = S70MOD;\n   S70VER1 = S70VER;\n   S70SER1 = S70SER;\n   S70SID1 = S70SID;\n   S70DAT1 = S70DAT;\n   S70IST1 = S70IST;\n   TOT_UT1 = TOT_UT;\n   CPU_UT1 = CPU_UT;\n   NUMCPU1 = NUMCPU;\n   MODE1   = MODE;\n   FLAG1   = FLAG;\n   ISTHH1  = FLOOR(S70IST/10000)   /*HOUR THAT INTERVAL STARTED      */;\n   ISTHM1  = FLOOR(S70IST1/100)    /*HH MM THAT INTERVAL STARTED     */;\n   NXIST1  = S70IST+(S70INT1/1000) /*TIME NEXT INTERVAL SHOULD START */;\n  IF REC0SW = 'Y' THEN GO TO EREADP0 /*ALREADY HAVE A REC, SKIP READ */;\nREADP0:\n   SET SASDB.P0CPWK04;\n  IF S70IST LT 090000\n      THEN GO TO READP0            /*THROW OUT ANYTHING BEFORE 9:00  */;\n  IF S70INT LT 0500000\n      THEN GO TO READP0            /*INTERVAL IS TOO SMALL           */;\n  REC0SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\n   S70INT0 = S70INT;\n   S70MOD0 = S70MOD;\n   S70VER0 = S70VER;\n   S70SER0 = S70SER;\n   S70SID0 = S70SID;\n   S70DAT0 = S70DAT;\n   S70IST0 = S70IST;\n   TOT_UT0 = TOT_UT;\n   CPU_UT0 = CPU_UT;\n   NUMCPU0 = NUMCPU;\n   MODE0   = MODE;\n   FLAG0   = FLAG;\n   ISTHH0  = FLOOR(S70IST0/10000)  /*HOUR  THAT INTERVAL STARTED     */;\n   ISTHM0  = FLOOR(S70IST0/100)    /*HH MM THAT INTERVAL STARTED     */;\n   NXIST0  = S70IST0+(S70INT0/1000)  /*START OF NEXT INTERVAL        */;\nEREADP0:\n  IF S70DAT0 LT S70DAT1 THEN\n     GO TO READP0                  /*NON PR/SM-WE WILL JUST SYNCH    */;\n  IF S70DAT0 GT S70DAT1 THEN DO;\n     PUT 'INPUT FOR P0 SOMEHOW GOT AHEAD OF P1.';\n     PUT 'FOR P0 DATE=' S70DAT0 'TIME=' S70IST0 ;\n     PUT 'FOR P1 DATE=' S70DAT1 'TIME=' S70IST1 ;\n     PUT 'WILL GO TRY TO CATCH UP BY READING P1.';\n     REC0SW = 'Y'                  /*HOLD THIS SYSTEMS RECORD        */;\n     GO TO READP1;\n     END;\n***********************************************************************;\n***** DATES ARE NOW EQUAL.  HOWEVER, WE DO NOT ACCOUNT FOR IST'S THAT  ;\n***** ARE CLOSE BUT START MORE THAN A MINUTE APART.                    ;\n*                                                             *********;\n  IF ISTHM0 NE ISTHM1 THEN GO TO ISTNEQ ;\n***********************************************************************;\n***** NOW ALL WE HAVE IS INTERVAL START TIMES ARE EQUAL                ;\n***********************************************************************;\n  INTDIFF = ABS(S70INT0 - S70INT1)/100000 /*DIFF IN MINUTES          */;\n  INTDIFF = FLOOR(INTDIFF)                /*INTEGER ONLY             */;\n  IF ISTHM0 = ISTHM1 AND\n     INTDIFF LT 4 THEN             /*IS DURATIONS WITHIN 4 MINUTES   */\n     GO TO INTEQ                   /*YES, ADD EM UP AND WRITE EM OUT */;\n     GO TO STEQ                    /*INT DURATION DIFF IS GT 4 MINS  */;\nOTHERT:\n   PUT 'AT OTHERT SHOULD NOT BE HERE';\n     PUT 'FOR P0 DATE=' S70DAT0 'TIME=' S70IST0 ;\n     PUT 'FOR P1 DATE=' S70DAT1 'TIME=' S70IST1 ;\n   RETURN;\nINTEQ:\n   TOT_UT  = TOT_UT0 + TOT_UT1     /*SIDE 1 + SIDE 2                 */;\n   NUMCPU  = NUMCPU0 + NUMCPU1     /*TOTAL ALL CPU'S                 */;\n   CPU_UT  = TOT_UT/NUMCPU         /*UTILIZATION OF ALL PHYSICAL CP'S*/;\n   S70INT  = S70INT1;\n   S70MOD  = S70MOD1;\n   S70VER  = S70VER1;\n   S70SER  = S70SER1;\n   S70SID  = S70SID1;\n   S70DAT  = S70DAT1;\n   S70IST  = S70IST1;\n   MODE    = MODE1;\n   FLAG    = FLAG1;\n  OUTPUT SASDB.UTM1WK04            /*WRITE INFORMATION OUT           */;\n  RETURN;\nPR_SM:\n  OUTPUT SASDB.UTM1WK04            /*WRITE INFORMATION OUT           */;\n  RETURN;\nSTEQ:\n PUT 'AT STEQ:  INTDIFF=' INTDIFF;\n PUT 'P0 DATE=' S70DAT0 'TIME=' S70IST0 'DUR=' S70INT0;\n PUT 'P1 DATE=' S70DAT1 'TIME=' S70IST1 'DUR=' S70INT1;\n   RETURN;\nISTNEQ:\n PUT 'AT ISTNEQ:  INTDIFF=' INTDIFF;\n PUT 'P0 DATE=' S70DAT0 'TIME=' S70IST0 'DUR=' S70INT0;\n PUT 'P1 DATE=' S70DAT1 'TIME=' S70IST1 'DUR=' S70INT1;\n  IF ISTHM0 LT ISTHM1 THEN DO;\n     REC1SW = 'Y'                  /*HOLD THIS RECORD AND            */;\n     GO TO READP0                  /*GO TRY AND CATCH UP.            */;\n     END                           /*OTHERWISE*/;\n     REC0SW = 'Y'                  /*HOLD THIS RECORD AND            */;\n     GO TO READP1                  /*GO TRY AND CATCH UP.            */;\nRETURN;\n   PROC PRINT DATA=SASDB.UTM1WK04 ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPTOTWJ": {"ttr": 779, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'CPU UT BY MACHINE',MSGLEVEL=(1,1),\n//  CLASS=O,MSGCLASS=A,TIME=(4,10)\n//*\n//*  CALCULATE CPU UTILIZATION BY MACHINE (NOT SYSTEM) FOR THOSE\n//*  MACHINES UNDER THE CONTROL OF PR/SM.\n//*  THIS WILL ALSO WORK FOR NON PR/SM MACHINES.\n//*  INFORMATION IS CONTAINED IN RMF 70 RECORDS.\n//*\n//STEP1  EXEC SAS,WORK='40,10',RGN=4096K\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(CPTOTW)\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,           <==INPUT  (SAS DATASET)\n//   DISP=OLD                                  AND OUTPUT\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPTOT1": {"ttr": 781, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n|   CPTOT1                                                          |\n|                                                                   |\n|   THIS PROGRAM READS INPUT FROM 2 SYSTEMS. (THE INPUT IS CREATED  |\n|   BY \"CPUT\") IF MACHINES ARE = AND THIS IS NOT PR/SM THEN ADD     |\n|   THE 2 UTILIZATIONS TOGETHER AND DIVIDE BY THE APPROPRIATE       |\n|   NUMBER.                                                         |\n|   IF THIS IS PR/SM AND THE PARTITIONS ARE DEDICATED THEN DO THE   |\n|   SAME THING. HOWEVER, IF THE LPARS HAVE SHARED CPU'S THEN        |\n|   USE THE INFORMATION FROM ONE SYSTEM ONLY SINCE ALL THE INFO     |\n|   IS THERE.                                                       |\n|   .                                                               |\n|   IF PHYSICALLY PARTITIONED AND BOTH SIDES ARE NOT UP, THIS       |\n|   PROGRAM WILL SKIP RECORDS BECAUSE IT IS LOOKING FOR A MATCH.    |\n|                                                                   |\n|   THE VARIABLES THAT ARE SAVED ARE:                               |\n|                                                                   |\n|   S70INT........ LENGTH OF (RMF) INTERVAL                         |\n|   WAIT_PER...... PER OF WAIT TIME (NON PR/SM AND TIME SLICING)    |\n|   S70MOD........ CPU MODEL NUMBER (E.G. 3090)                     |\n|   S70VER........ CPU VERSION NUMBER (E.G. 41)                     |\n|   S70SER........ CPU SERIAL NUMBER                                |\n|   S70SID........ SYSTEM'S SMF ID -THE SYSTEM THAT PRODUCED THE    |\n|                  RMF RECORDS.                                     |\n|   S70DAT........ INTERVAL DATE                                    |\n|   S70IST........ INTERVAL START TIME                              |\n|   NUMLP......... NUMBER OF LOGICAL PROCESSORS (PR/SM)             |\n|   NUMPART....... NUMBER OF PARTITIONS RUNNING UNDER PR/SM         |\n|   TOT_UT........ TOTAL UTILIZATION (ALL CPU'S IN PARTITION)       |\n|   CPU_UT........ AVG. PERCENT BUSY (1 - WAIT_PER FOR NON PR/SM) OR|\n|                  FROM SMF70PDT FOR PR/SM MACHINES - CALCULATED    |\n|                  BY: (TOT_UT/NUM_CP)  <===CHECK THIS.             |\n|   NUMCPU........ NUMBER OF LOGICAL PROCESSORS ASSIGNED TO A       |\n|                  PARTITION OR IS THE NUMBER AVAILABLE <=====???   |\n|   MODE.......... BLANK = BASIC MODE. \"D\" = LPAR HAS DEDICATED     |\n|                  CPU'S. \"E\" = LPAR'S HAVE SHARED CPU'S WITH       |\n|                  WAIT COMPLETION ENABLED. \"P\" = LPAR'S HAVE ALL   |\n|                  SHARED CPU'S.                                    |\n|   FLAG.......... INDICATES DATA MIGHT NOT BE COMPLETELY CORRECT   |\n|                  FOR THIS PARTICULAR RMF INTERVAL.                |\n|                                                                   |\n|   OUTPUT FILE NAME = TOTAL UTILIZATION                            |\n|                      FOR MACHINE #1                               |\n|                       \u00a6                                           |\n|                       \u00a6             YEAR...MONTH                  |\n|                       \u00a6              \u00a6       \u00a6                    |\n|                       \u00a6              \u00a6       \u00a6                    |\n|    E.G.   UTM18811 = UTM1...........88  ... 11                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.UTM18811 TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|          C UTM18809 UTM18810 ALL                                  |\n|                                                                   |\n|   UPDATES:                                                        |\n*-------------------------------------------------------------------*\n;\n   DATA\n SASDB.UTM18904 (KEEP=S70INT S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                TOT_UT CPU_UT NUMCPU  MODE FLAG )\n        ;\n  REC0SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\nREADP1:\n   SET SASDB.P1CP8904;\n   IF S70IST LT 090000\n      THEN GO TO READP1            /*THROW OUT ANYTHING BEFORE 9:00  */;\n   IF S70INT LT 0500000\n      THEN GO TO READP1            /*INTERVAL IS TOO SMALL           */;\n  REC1SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\n  IF MODE = 'P' OR\n     MODE = 'E' THEN GO TO PR_SM   /*THIS IS A PR/SM MACHINE         */;\n* ***                                                                  ;\n* ***OTHERWISE WE HAVE PR/SM WITH DEDICATED CPU'S OR BASIC MODE.       ;\n* ***IN THIS CASE WE WILL COMBINE THE CPU UTILIZATIONS FROM 2          ;\n* ***OPERATING SYSTEMS.                                                ;\n* ***                                                                  ;\n   S70INT1 = S70INT;\n   S70MOD1 = S70MOD;\n   S70VER1 = S70VER;\n   S70SER1 = S70SER;\n   S70SID1 = S70SID;\n   S70DAT1 = S70DAT;\n   S70IST1 = S70IST;\n   TOT_UT1 = TOT_UT;\n   CPU_UT1 = CPU_UT;\n   NUMCPU1 = NUMCPU;\n   MODE1   = MODE;\n   FLAG1   = FLAG;\n   ISTHH1  = FLOOR(S70IST/10000)   /*HOUR THAT INTERVAL STARTED      */;\n   ISTHM1  = FLOOR(S70IST1/100)    /*HH MM THAT INTERVAL STARTED     */;\n   NXIST1  = S70IST+(S70INT1/1000) /*TIME NEXT INTERVAL SHOULD START */;\n  IF REC0SW = 'Y' THEN GO TO EREADP0 /*ALREADY HAVE A REC, SKIP READ */;\nREADP0:\n   SET SASDB.P0CP8904;\n  IF S70IST LT 090000\n      THEN GO TO READP0            /*THROW OUT ANYTHING BEFORE 9:00  */;\n  IF S70INT LT 0500000\n      THEN GO TO READP0            /*INTERVAL IS TOO SMALL           */;\n  REC0SW = 'N'                     /*CLEAR RECORD WAITING SWITCH     */;\n   S70INT0 = S70INT;\n   S70MOD0 = S70MOD;\n   S70VER0 = S70VER;\n   S70SER0 = S70SER;\n   S70SID0 = S70SID;\n   S70DAT0 = S70DAT;\n   S70IST0 = S70IST;\n   TOT_UT0 = TOT_UT;\n   CPU_UT0 = CPU_UT;\n   NUMCPU0 = NUMCPU;\n   MODE0   = MODE;\n   FLAG0   = FLAG;\n   ISTHH0  = FLOOR(S70IST0/10000)  /*HOUR  THAT INTERVAL STARTED     */;\n   ISTHM0  = FLOOR(S70IST0/100)    /*HH MM THAT INTERVAL STARTED     */;\n   NXIST0  = S70IST0+(S70INT0/1000)  /*START OF NEXT INTERVAL        */;\nEREADP0:\n  IF S70DAT0 LT S70DAT1 THEN\n     GO TO READP0                  /*NON PR/SM-WE WILL JUST SYNCH    */;\n  IF S70DAT0 GT S70DAT1 THEN DO;\n     PUT 'INPUT FOR P0 SOMEHOW GOT AHEAD OF P1.';\n     PUT 'FOR P0 DATE=' S70DAT0 'TIME=' S70IST0 ;\n     PUT 'FOR P1 DATE=' S70DAT1 'TIME=' S70IST1 ;\n     PUT 'WILL GO TRY TO CATCH UP BY READING P1.';\n     REC0SW = 'Y'                  /*HOLD THIS SYSTEMS RECORD        */;\n     GO TO READP1;\n     END;\n***********************************************************************;\n***** DATES ARE NOW EQUAL.  HOWEVER, WE DO NOT ACCOUNT FOR IST'S THAT  ;\n***** ARE CLOSE BUT START MORE THAN A MINUTE APART.                    ;\n*                                                             *********;\n  IF ISTHM0 NE ISTHM1 THEN GO TO ISTNEQ ;\n***********************************************************************;\n***** NOW ALL WE HAVE IS INTERVAL START TIMES ARE EQUAL                ;\n***********************************************************************;\n  INTDIFF = ABS(S70INT0 - S70INT1)/100000 /*DIFF IN MINUTES          */;\n  INTDIFF = FLOOR(INTDIFF)                /*INTEGER ONLY             */;\n  IF ISTHM0 = ISTHM1 AND\n     INTDIFF LT 4 THEN             /*IS DURATIONS WITHIN 4 MINUTES   */\n     GO TO INTEQ                   /*YES, ADD EM UP AND WRITE EM OUT */;\n     GO TO STEQ                    /*INT DURATION DIFF IS GT 4 MINS  */;\nOTHERT:\n   PUT 'AT OTHERT SHOULD NOT BE HERE';\n     PUT 'FOR P0 DATE=' S70DAT0 'TIME=' S70IST0 ;\n     PUT 'FOR P1 DATE=' S70DAT1 'TIME=' S70IST1 ;\n   RETURN;\nINTEQ:\n   TOT_UT  = TOT_UT0 + TOT_UT1     /*SIDE 1 + SIDE 2                 */;\n   NUMCPU  = NUMCPU0 + NUMCPU1     /*TOTAL ALL CPU'S                 */;\n   CPU_UT  = TOT_UT/NUMCPU         /*UTILIZATION OF ALL PHYSICAL CP'S*/;\n   S70INT  = S70INT1;\n   S70MOD  = S70MOD1;\n   S70VER  = S70VER1;\n   S70SER  = S70SER1;\n   S70SID  = S70SID1;\n   S70DAT  = S70DAT1;\n   S70IST  = S70IST1;\n   MODE    = MODE1;\n   FLAG    = FLAG1;\n  OUTPUT SASDB.UTM18904            /*WRITE INFORMATION OUT           */;\n  RETURN;\nPR_SM:\n  OUTPUT SASDB.UTM18904            /*WRITE INFORMATION OUT           */;\n  RETURN;\nSTEQ:\n PUT 'AT STEQ:  INTDIFF=' INTDIFF;\n PUT 'P0 DATE=' S70DAT0 'TIME=' S70IST0 'DUR=' S70INT0;\n PUT 'P1 DATE=' S70DAT1 'TIME=' S70IST1 'DUR=' S70INT1;\n   RETURN;\nISTNEQ:\n PUT 'AT ISTNEQ:  INTDIFF=' INTDIFF;\n PUT 'P0 DATE=' S70DAT0 'TIME=' S70IST0 'DUR=' S70INT0;\n PUT 'P1 DATE=' S70DAT1 'TIME=' S70IST1 'DUR=' S70INT1;\n  IF ISTHM0 LT ISTHM1 THEN DO;\n     REC1SW = 'Y'                  /*HOLD THIS RECORD AND            */;\n     GO TO READP0                  /*GO TRY AND CATCH UP.            */;\n     END                           /*OTHERWISE*/;\n     REC0SW = 'Y'                  /*HOLD THIS RECORD AND            */;\n     GO TO READP1                  /*GO TRY AND CATCH UP.            */;\nRETURN;\n   PROC PRINT DATA=SASDB.UTM18904 ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPUCP": {"ttr": 1025, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\nGOPTIONS HSIZE=8 VSIZE=7;\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY CPUTOT.\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH DAY FOR\n*       ONE PHYSICAL PROCESSOR COMPLEX.\n*       THE NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.2\n*\n;\n*\n;\n  DATA TEST1;\n  SET SASDB.UTM18904;\n* -APR 1989 EXCLUSION DATES (ALL EXCEPT T/W/TH NON-HOLIDAYS) *;\n%INCLUDE DD1(EX8904);\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n*  IF S70IST GE 120000 AND\n      S70IST LT 130000 THEN DELETE;\n   IF S70INT LT 0500000 THEN DELETE /*     THROW OUT SMALL INTERVAL  */;\n   HHOLD  = FLOOR(S70IST/10000);\nKEEP HHOLD  CPU_UT;\nPROC SORT DATA=TEST1 OUT=TEST2;\n BY  HHOLD;\nPROC PRINT DATA=TEST2;\nPROC SUMMARY;\n VAR CPU_UT;\n BY HHOLD;\n OUTPUT OUT=SUMIT MEAN(CPU_UT)=CPUAVG\n MAX(CPU_UT)=CPUMAX\n MIN(CPU_UT)=CPUMIN;\n PROC PRINT DATA=SUMIT;\nTITLE1 J=C H=1 F=XSWISSE C=WHITE 'CPU UTILIZATION BY HOUR ';\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE 'APRIL 1989 MON-FRI';               ;\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=WHITE 'CPUCP: TECHNICAL SUPPORT';\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED '3090-400E' C=WHITE ' SOURCE RMF';\nFOOTNOTE3 J=R H=1 F=SIMPLEX C=GREEN 'MINIMUM' C=CYAN ' AVGERAGE '\n      C=RED 'MAXIMUM';\nSYMBOL1 W=1 C=GREEN V=DIAMOND I=JOIN;\nSYMBOL2 W=1 C=CYAN V=STAR I=JOIN;\nSYMBOL3 W=1 C=RED V=SQUARE I=JOIN;\n   PROC GPLOT DATA = SUMIT        /* GOUT=MYCAT.GRAPHS */;\n AXIS1 LABEL=(F=XSWISS H=1 'UTILIZATION')\n       VALUE=(F=XSWISS H=1 C=GREEN)\n       ORDER=0 TO 100 BY 20;\n AXIS2 LABEL=(F=XSWISS H=1 'HOUR')\n       VALUE=(F=XSWISS H=1 C=GREEN);\n        PLOT CPUMIN*HHOLD=1\n             CPUAVG*HHOLD=2\n             CPUMAX*HHOLD=3 / OVERLAY\n             NAME='CPUCP' DES='3090   UTIL'\n             FRAME VAXIS = AXIS1 HAXIS = AXIS2;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPUCPW": {"ttr": 1028, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nOPTIONS DQUOTE  ;\n*OPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*OPTIONS HSIZE=8 VSIZE=7;\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY CPUTOT.\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH DAY FOR\n*       ONE PHYSICAL PROCESSOR COMPLEX.\n*       THE NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.2\n*\n;\n*\n;\n  DATA TEST1;\n  SET SASDB.UTM1WK04;\n*  EXCLUSION DATES **;\n%INCLUDE DD1(EX8905);\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n*  IF S70IST GE 120000 AND\n      S70IST LT 130000 THEN DELETE;\n   IF S70INT LT 0500000 THEN DELETE /*     THROW OUT SMALL INTERVAL  */;\n   HHOLD  = FLOOR(S70IST/10000);\nKEEP HHOLD  CPU_UT;\n%LET XSER = S70SER;\nPROC SORT DATA=TEST1 OUT=TEST2;\n BY  HHOLD;\nPROC PRINT DATA=TEST2;\nPROC SUMMARY;\n VAR CPU_UT;\n BY HHOLD;\n OUTPUT OUT=SUMIT MEAN(CPU_UT)=CPUAVG\n MAX(CPU_UT)=CPUMAX\n MIN(CPU_UT)=CPUMIN;\n PROC PRINT DATA=SUMIT;\nTITLE1 J=C H=2 F=SIMPLEX C=WHITE\n    'WEEKLY CPU UTILIZATION BY HOUR FOR 3090-400E';\nTITLE2    J=C H=1.5 F=SIMPLEX C=WHITE 'WEEK OF MAY 21, 1989';           ;\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE '    CPUCPW: TECHNICAL SUPPORT';\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED \"    3090-400E: SER # &XSER\";\nFOOTNOTE3 J=R H=1 F=SIMPLEX C=GREEN '    MINIMUM' C=CYAN ' AVGERAGE '\n      C=RED 'MAXIMUM';\nSYMBOL1 W=1 C=GREEN V=DIAMOND I=JOIN;\nSYMBOL2 W=1 C=CYAN V=STAR I=JOIN;\nSYMBOL3 W=1 C=RED V=SQUARE I=JOIN;\n   PROC GPLOT DATA = SUMIT        /* GOUT=MYCAT.GRAPHS */;\n AXIS1 LABEL=(F=SIMPLEX H=1 'UTILIZATION')\n       VALUE=(F=SIMPLEX H=1 C=GREEN)\n       ORDER=0 TO 100 BY 20;\n AXIS2 LABEL=(F=SIMPLEX H=1 'HOUR')\n       VALUE=(F=SIMPLEX H=1 C=GREEN);\n        PLOT CPUMIN*HHOLD=1\n             CPUAVG*HHOLD=2\n             CPUMAX*HHOLD=3 / OVERLAY\n        VREF  = 75\n        CVREF = RED\n        LVREF = 2\n             NAME='CPUCPW' DES='3090-400E UTIL'\n             VAXIS = AXIS1 HAXIS = AXIS2;\n   ;\nRUN;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPUCPWX": {"ttr": 1031, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nOPTIONS DQUOTE  ;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\nGOPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\nGOPTIONS HSIZE=8 VSIZE=7;\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY CPUTOT.\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH DAY FOR\n*       ONE PHYSICAL PROCESSOR COMPLEX.\n*       THE NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.2\n*\n;\n*\n;\n  DATA TEST1;\n  SET SASDB.UTM1WK02;\n*  EXCLUSION DATES **;\n%INCLUDE DD1(EX8905);\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n*  IF S70IST GE 120000 AND\n      S70IST LT 130000 THEN DELETE;\n   IF S70INT LT 0500000 THEN DELETE /*     THROW OUT SMALL INTERVAL  */;\n   HHOLD  = FLOOR(S70IST/10000);\nKEEP HHOLD  CPU_UT;\nCALL SYMPUT (XSER,S70SER) ;\nPROC SORT DATA=TEST1 OUT=TEST2;\n BY  HHOLD;\nPROC PRINT DATA=TEST2;\nPROC SUMMARY;\n VAR CPU_UT;\n BY HHOLD;\n OUTPUT OUT=SUMIT MEAN(CPU_UT)=CPUAVG\n MAX(CPU_UT)=CPUMAX\n MIN(CPU_UT)=CPUMIN;\n PROC PRINT DATA=SUMIT;\nTITLE1 J=C H=1 F=XSWISSE C=WHITE 'WEEKLY CPU UTILIZATION BY HOUR ';\nTITLE2    J=C H=1 F=SIMPLEX C=WHITE 'WEEK OF MAY 8, 1989';              ;\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE 'CPUCPW: TECHNICAL SUPPORT';\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED \"3090-400E: SER # &XSER\";\nFOOTNOTE3 J=R H=1 F=SIMPLEX C=GREEN 'MINIMUM' C=CYAN ' AVGERAGE '\n      C=RED 'MAXIMUM';\nSYMBOL1 W=1 C=GREEN V=DIAMOND I=JOIN;\nSYMBOL2 W=1 C=CYAN V=STAR I=JOIN;\nSYMBOL3 W=1 C=RED V=SQUARE I=JOIN;\n   PROC GPLOT DATA = SUMIT        /* GOUT=MYCAT.GRAPHS */;\n AXIS1 LABEL=(F=XSWISS H=1 'UTILIZATION')\n       VALUE=(F=XSWISS H=1 C=GREEN)\n       ORDER=0 TO 100 BY 20;\n AXIS2 LABEL=(F=XSWISS H=1 'HOUR')\n       VALUE=(F=XSWISS H=1 C=GREEN);\n        PLOT CPUMIN*HHOLD=1\n             CPUAVG*HHOLD=2\n             CPUMAX*HHOLD=3 / OVERLAY\n             NAME='CPUCPW' DES='3090-400E UTIL'\n             FRAME VAXIS = AXIS1 HAXIS = AXIS2;\nRUN;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPUNDL": {"ttr": 1034, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\n*OPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L03M16) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*OPTIONS HSIZE=8 VSIZE=7;\n  DATA TEST1;\n  SET SASDB.UTM18901\n      SASDB.UTM18902\n      SASDB.UTM18903\n      SASDB.UTM18904\n      SASDB.UTM1WK01\n      SASDB.UTM1WK02\n      SASDB.UTM1WK03\n      SASDB.UTM1WK04\n         ;\n%INCLUDE DD1(EX8901);\n%INCLUDE DD1(EX8902);\n%INCLUDE DD1(EX8903);\n%INCLUDE DD1(EX8904);\n%INCLUDE DD1(EX8905);\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n   IF S70INT LT 0500000 THEN DELETE /*     THROW OUT SMALL INTERVAL  */;\n   HHOLD  = FLOOR(S70IST/10000);\nKEEP HHOLD  CPU_UT S70DAT;\nPROC SORT DATA=TEST1 OUT=TEST2;\n BY  HHOLD;\n*PROC PRINT DATA=TEST2;\nDATA TEST3;\nSET TEST2;\nLENGTH COLORVAR SHAPVAR $ 8;\nIF CPU_UT GE 70.0 THEN\nDO;\n   COLORVAR='RED';\nSHAPEVAR='PYRAMID';\nEND;\nIF CPU_UT GE 45.0 AND  CPU_UT < 70.0 THEN\nDO;\n    COLORVAR='BLUE';\n    SHAPEVAR='CUBE';\nEND;\nIF CPU_UT < 45.0 THEN\nDO;\n    COLORVAR='GREEN';\n    SHAPEVAR='DIAMOND';\nEND;\nTITLE1 J=C H=1.5 F=SIMPLEX C=WHITE 'CPU UTILIZATION FOR 3090-400E';\nTITLE2 J=C H=1 F=SIMPLEX C=WHITE 'SUMMARIZED BY RMF INTERVALS';\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE\n   '    JANUARY 1989 THROUGH MAY 26TH';\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED C=WHITE\n   '    CPUNDL: TECHNICAL SUPPORT';\nFOOTNOTE3 J=L H=1 F=SIMPLEX C=RED   '    RED   GT 75% ';\nFOOTNOTE4 J=L H=1 F=SIMPLEX C=BLUE  '    BLUE  GT 45 LT 75% ';\nFOOTNOTE5 J=L H=1 F=SIMPLEX C=GREEN '    GREEN LT 45 % ';\n   PROC G3D  DATA = TEST3; /* GOUT=MYCAT.GRAPHS;*/\n SCATTER S70DAT*HHOLD=CPU_UT / NONEEDLE TILT=80 90 45 ROTATE=60 90 20\n ZMIN=10.0 ZMAX=100.0 ZTICKNUM=10\n  XTICKNUM=7\nCOLOR=COLORVAR SHAPE=SHAPEVAR GRID;\nLABEL S70DAT = 'DATE (YYDDD)';\nLABEL CPU_UT = '% UTIL';\nLABEL HHOLD = 'TIME';\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPUNDL3": {"ttr": 1036, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*OPTIONS HSIZE=8 VSIZE=7;\n  DATA TEST1;\n  SET SASDB.UTM18901\n      SASDB.UTM18902\n      SASDB.UTM18903\n      SASDB.UTM18904\n      SASDB.UTM1WK01\n      SASDB.UTM1WK02;\n%INCLUDE DD1(EX8901);\n%INCLUDE DD1(EX8902);\n%INCLUDE DD1(EX8903);\n%INCLUDE DD1(EX8904);\n%INCLUDE DD1(EX8905);\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n   IF S70INT LT 0500000 THEN DELETE /*     THROW OUT SMALL INTERVAL  */;\n   HHOLD  = FLOOR(S70IST/10000);\nKEEP HHOLD  CPU_UT S70DAT;\nPROC SORT DATA=TEST1 OUT=TEST2;\n BY  HHOLD;\n*PROC PRINT DATA=TEST2;\nDATA TEST3;\nSET TEST2;\nLENGTH COLORVAR SHAPVAR $ 8;\nIF CPU_UT GE 70.0 THEN\nDO;\n   COLORVAR='RED';\nSHAPEVAR='PYRAMID';\nEND;\nIF CPU_UT GE 45.0 AND  CPU_UT < 70.0 THEN\nDO;\n    COLORVAR='BLUE';\n    SHAPEVAR='CUBE';\nEND;\nIF CPU_UT < 45.0 THEN\nDO;\n    COLORVAR='GREEN';\n    SHAPEVAR='DIAMOND';\nEND;\nTITLE1 J=C H=1.5 F=XSWISSE C=WHITE 'CPU UTILIZATION FOR 3090-400E';\nTITLE2 J=C H=1 F=XSWISSE C=WHITE 'SUMMARIZED BY RMF INTERVALS';\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE 'FIRST 2 WEEKS OF MAY';             ;\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED 'CPUNEED:'\n   C=WHITE ' TECHNICAL SUPPORT';\nFOOTNOTE3 J=L H=1 F=SIMPLEX C=RED 'PRIME TIME ';\n   PROC G3D  DATA = TEST3; /* GOUT=MYCAT.GRAPHS;*/\n SCATTER S70DAT*HHOLD=CPU_UT / NONEEDLE TILT=80 90 45 ROTATE=60 90 20\n ZMIN=10.0 ZMAX=100.0 ZTICKNUM=10\n  XTICKNUM=7\nCOLOR=COLORVAR SHAPE=SHAPEVAR GRID;\nLABEL S70DAT = 'YEAR & DAY';\nLABEL CPU_UT = 'UTIL.';\nLABEL HHOLD = 'PRIME TIME';\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPUT": {"ttr": 1038, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n|   CPUT                                                            |\n|   ONLY LOOKING AT SMF TYPE 70 RECORDS. FOR MVS/XA SYSTEMS         |\n|   WITH OR WITHOUT PR/SM                                           |\n|   DATA MUST BE SORTED BEFORE BEING USED BY                        |\n|         SMF70SID,SMF70DAT,SMF70IST                                |\n|         (JUST USE THE SORT MEMBER)                                |\n|                                                                   |\n|   THIS PROGRAM IS THE FIRST STEP IN ATTEMPTING TO SUMMURIZE       |\n|   CPU UTILIZATION BY PHYSICAL PROCESSOR COMPLEX (E.G. ONE         |\n|   3090-400S). THE FOLLOWING ARE SOME THINGS TO REMEMBER.          |\n|                                                                   |\n|   A) A PHYSICAL PROCESSOR COMPLEX RUNNING IN BASIC MODE. IN THIS  |\n|      CASE IT WILL HAVE ONE OPERATING SYSTEM OR TWO OPERATING      |\n|      SYSTEMS IF THE MACHINE IS PHYSICALLY PARTITIONED.            |\n|     -THIS IS PRETTY STRAIGHT FORWARD AND ALL ONE HAS TO DO IS     |\n|      USE THE AVERAGE CPU UTILIZATION NUMBER PROVIDED BY RMF       |\n|      FOR A SINGLE OPERATING SYSTEM. IN THE CASE OF A PHYSICALLY   |\n|      PARTITIONED MACHINE THEN ONE HAS TO ADD THE TWO UTILIZATION  |\n|      NUMBERS FOR EACH OF THE OPERATING SYSTEMS AND DIVIDE BY 2.   |\n|                                                                   |\n|                                                                   |\n|   B) SIMILAR TO THE PHYSICALLY PARTITIONED MACHINE IS THE CASE    |\n|      OF THE LOGICALLY PARTITIONED PROCESSOR COMLEX (LPAR MODE)    |\n|      WHERE ALL THE PARTITIONS HAVE DEDICATED CPU'S. HERE WE HAVE  |\n|      TO ADD UP ALL THE CPU TIMES OF THE PARTITIONS AND DIVIDE BY  |\n|      THE NUMBER OF CPU'S. NOTE THAT THE CPU UTILIZATION (ACTUALLY |\n|      WAIT TIME) FOR DEDICATED CPU'S ARE ONLY CONTAINED IN THE     |\n|      RMF RECORDS OF THE SYSTEM WHICH PRODUCED THE RECORDS. THAT   |\n|      IS, YOU MUST READ RMF RECORDS FROM EACH SYSTEM TO PICK UP THE|\n|      DEDICATED CPU TIMES.                                         |\n|                                                                   |\n|   C) NEXT, PROBABLY THE SIMPLEST, IS THE CASE OF LPAR MODE IN     |\n|      WHICH ALL THE CPU'S ARE SHARED. IN THIS CASE ONE CAN PICK    |\n|      UP THE CPU UTILIZATION OF ALL PARTITIONS FROM ONE SYSTEM'S   |\n|      RMF RECORDS.                                                 |\n|                                                                   |\n|   D) OF COURSE, THERE ARE OTHER SITUATIONS IN WHICH SOME          |\n|      LPARS HAVE DEDICATED CPU'S AND SOME HAVE SHARED. AND OF      |\n|      COURSE, DON'T FORGET A MACHINE THAT IS PHYSICALLY PARTITIONED|\n|      AND ONE SIDE USES PR/SM IN VARIOUS CONFIGUARTIONS AND        |\n|      THE OTHER SIDE DOESN'T ...                                   |\n|                                                                   |\n| ----                       -----                            ----  |\n|   SINCE THE DATA IS SAVED BY SYSTEM ID (SMF ID) THEN THE ONLY     |\n|   THING THAT MAKES THESE PROGRAMS INSTALLATION DEPENDANT ARE      |\n|   1) THE LITERALS FOR CHECKING THE SYSTEM ID                      |\n|       -LOCATED AT THE END OF THE PROGRAM                          |\n|   2) THE MEMBER NAME THAT IS GIVEN TO THE SAS DATASET (ONE FOR    |\n|      EACH SYSTEM)                                                 |\n|       -LOCATED IN THE BEGINING (DATA STATEMENT)                   |\n|        AND AT THE END, FOLLOWING THE \"OUTPUT\" STATEMENTS          |\n|                                                                   |\n|   IN ADDITION, SINCE THE DATA IS NORMALLY STORED BY MONTH         |\n|   THEN THE MEMBER NAMES REFERENCED IN NUMBER 2 ABOVE              |\n|   IS CHANGED SLIGHTLY EACH MONTH TO REFLECT THE MONTH AND YEAR.   |\n| ----                       -----                            ----  |\n|                                                                   |\n|   THIS SAS FILE THEN CAN BE USED AS INPUT TO CREATE A GRAPH       |\n|   EITHER ON THE TERMINAL OR TO A PRINTER USING GDDM.              |\n|                                                                   |\n|   SMF70RTY...... RECORD TYPE.                                     |\n|   SMF70SID...... SID.                                             |\n|   SMF70IST...... TIME RMF MEASUREMENT INTERVAL STARTED IN FORM    |\n|                  0HHMMSSF WHERE F IS THE SIGN.                    |\n|   SMF70DAT...... DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED    |\n|                  (F IS THE SIGN).                                 |\n|   SMF70INT...... DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|   SMF70TMN...... TSO USERS MINIMUM OVER INTERVAL.                 |\n|   SMF70TMM...... TSO USERS MAXIMUM OVER INTERVAL.\n|   SMF70TTT...... TSO USERS TOTAL VALUE OVER INTERVAL.             |\n|                                                                   |\n|                                                                   |\n|   THE VARIABLES THAT ARE SAVE ARE:                                |\n|                                                                   |\n|   S70IST........ INTERVAL START TIME                              |\n|   S70DAT........ INTERVAL DATE                                    |\n|   S70INT........ LENGTH OF (RMF) INTERVAL                         |\n|   S70MOD........ PROCESSOR MODEL (SMF70MOD)                       |\n|   S70VER........ VERSION (SMF70VER)                               |\n|   S70SER........ SERIAL NUMBER (SMF70SER)                         |\n|   S70SID........ SYSTEM'S SMF ID                                  |\n|   NUMLP......... NUMBER OF LOGICAL PROCESSORS                     |\n|   NUMPART....... NUMBER OF PARTITIONS                             |\n|   CPU_UT........ AVG. PERCENT BUSY (1 - WAIT_PER FOR NON PR/SM) OR|\n|                  FROM SMF70PDT FOR PR/SM MACHINES                 |\n|   TOT_UT........ TOTAL UTILIZATION (ALL CPU'S IN PARTITION)       |\n|   NUMCPU........ NUMBER OF LOGICAL PROCESSORS ASSIGNED TO A       |\n|                  PARTITION. OR NUMBER OF DEDICATED CPU'S IN       |\n|                  THIS SYSTEM'S PARTITION.                         |\n|   MODE.......... MODE. BLANK=BASIC. D=LPAR WITH DEDICATED CPU'S   |\n|                        E=WAIT COMPLETION ENABLED (SHARED CPU'S).  |\n|                        P=PR/SM SHARED CPU'S.                      |\n|   FLAG.......... SOMETHING OCCURED IN THIS INTERVAL OUT OF THE    |\n|                  ORDINARY. DETAILED MESSAGE IS PRINTED.           |\n|                                                                   |\n|                                                                   |\n|   OUTPUT FILE NAME = SID...CONSTANT.YEAR...MONTH                  |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|    E.G.   S1CP8811 = S1 ...  CP  ...88  ... 11                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.S1CP8811 TO S1CP8811 FOR TEMPORARY DATASET  |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|          C CP8809 CP8810 ALL                                      |\n|                                                                   |\n|   UPDATES:                                                        |\n|    ADDED S70BMM TO THE DATA STATEMETS. THIS WILL SAVE MAXIMUM     |\n|    BATCH JOBS.                                                    |\n|                                                                   |\n|   UPDATES:                                                        |\n|     3/20/89 - ADDED NEW FIELD LABELED \"MODE\" TO INDICATED WHAT    |\n|      MODE THE MACHINE WAS OPERATING IN. P=PR/SM. BLANK FOR ALL    |\n|      OTHERS.                                                      |\n|     3/22/89 - ADDED \"MISSOVER\" TO INFILE STATEMENT TO KEEP SAS    |\n|      FROM LOOKING AHEAD WHEN IT CAN'T FIND ALL THE VARIABLES.     |\n|     3/27/89 - FIX TO HANDLE NO LPDS FOR A PARTITION. AND TO       |\n|      RECORD CORRECT NUMBER OF PHYSICAL CPU'S                      |\n|     4/25/89 - ADDED CODE TO HANDLE DEDICATED CPU'S UNDER PR/SM.   |\n|      CPU WAIT TIME IS ONLY RECORDED FOR THE SYSTEM THAT PRODUCED  |\n|      THE RMF RECORDS. NOT SURE (YET) ABOUT DEDICATED AND SHARED   |\n|      CPU'S.                                                       |\n|      ALSO ADDED A NEW \"MODE\" OF \"D\" TO INDICATED UNDER PR/SM      |\n|      BUT WITH DEDICATED CPU'S                                     |\n|     4/27/89 - CORRECTED CODE TO HANDLE SHARED CPU(S) WITH WAIT    |\n|      COMPLETION ENABLED. ADDED \"MODE\" OF \"E\" TO INDICATE SUCH.    |\n|--                                                                 |\n|    NOTE: FOR NOW WE ARE JUST USING THE 1ST FOUR BYTES OF SMF70LPM |\n|          (THE PARTITION NAME)                                     |\n*-------------------------------------------------------------------*\n;\n   MACRO INPUTIT\n   DATA\n SASDB.P1CP8903 (KEEP=S70INT WAIT_PER S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                NUMLP NUMPART TOT_UT CPU_UT NUMCPU  MODE FLAG )\n SASDB.P0CP8903 (KEEP=S70INT WAIT_PER S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                NUMLP NUMPART TOT_UT CPU_UT NUMCPU  MODE FLAG )\n SASDB.S1CP8903 (KEEP=S70INT WAIT_PER S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                NUMLP NUMPART TOT_UT CPU_UT NUMCPU  MODE FLAG )\n        ;\n   INFILE SMF LENGTH=L MISSOVER;\n*  INFORMAT S70IST RMFDUR4. S70INT PDTIME4. ;\n   INPUT @2 ID PIB1. @;\n   IF ID = 70  THEN LINK X5;\n   RETURN;\nX5:\nPOINTER = 1;\nM = -3;\nINPUT @ POINTER\n                SMF70FLG  PIB1.\n             +9 SMF70SID  $CHAR4.\n            +10 SMF70PRS  PIB4.\n                SMF70PRL  PIB2.\n                SMF70PRN  PIB2.\n                SMF70CCS  PIB4.\n                SMF70CCL  PIB2.\n                SMF70CCN  PIB2.\n                SMF70CPS  PIB4.\n                SMF70CPL  PIB2.\n                SMF70CPN  PIB2.\n                SMF70ASS  PIB4.\n                SMF70ASL  PIB2.\n                SMF70ASN  PIB2.\n                SMF70BCS  PIB4.\n                SMF70BCL  PIB2.\n                SMF70BCN  PIB2.\n                SMF70BVS  PIB4.\n                SMF70BVL  PIB2.\n                SMF70BVN  PIB2.\n                 @;\n*  ***---------------RMF PRODUCT SECTION--------------***;\nPOINTER = SMF70PRS +M;\nINPUT @ POINTER\n           +10  SMF70IST  PD4.\n                SMF70DAT  PD4.\n                SMF70INT  PD4.\n            +2  SMF70SAM  PIB4.\n                 @;\n*  ***---------------CPU CONTROL SECTION--------------***;\nPOINTER = SMF70CCS +M;\n  INPUT @ POINTER\n                SMF70MOD  PK2.\n                SMF70VER  PK1.\n                SMF70BNP  PIB1.\n                SMF70INB  PIB1.\n                   @;\n*  ***---------------CPU DATA SECTION-----------------***;\nPOINTER = SMF70CPS +M;\n  INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n*  ***---------------ASID DATA AREA SECTION-----------***;\nPOINTER = SMF70ASS +M;\nINPUT @ POINTER\n          +128  SMF70OMN  PIB2.\n                SMF70OMM  PIB2.\n                SMF70OTT  PIB4.\n          +104  SMF70BMN  PIB2.\n                SMF70BMM  PIB2.\n                SMF70BTT  PIB4.\n          +104  SMF70TMN  PIB2.\n                SMF70TMM  PIB2.\n                SMF70TTT  PIB4.\n                 @;\n*  ***---------------PR/SM PARTITION DATA SECTION-----***;\nPOINTER = SMF70BCS + M;\n  INPUT @ POINTER\n                SMF70LPM  $CHAR4.\n                LPM2HALF  $CHAR4.\n                SMF70LPN  PIB1.\n                SMF70PFG  PIB1.\n                SMF70BDN  PIB2.\n                SMF70BDS  PIB4.\n                   @;\n*  ***--LETS START DOING SOME CALCULATIONS--***;\n***IF SMF70DAT NE 89030 THEN DELETE          /*<===TESTING ONLY==*/;\n  S70IST = SMF70IST;\n  S70DAT = SMF70DAT;\n  S70INT = SMF70INT;\n  S70SID = SMF70SID;\n  S70MOD = SMF70MOD;\n  S70VER = SMF70VER;\n  S70SER = SMF70SER;\n  S70BNP = SMF70BNP;\n  S70CPN = SMF70CPN;\n**IF SMF70SAM = 0 THEN S70TAV = 0;\n   IF SMF70INT LT 0100000 THEN DELETE;\n* ******************************************************************;\n* ******************************************************************;\n   IF SMF70INB = '1... ....'B THEN DO      /* PR/SM INDICATOR BITS*/;\n      FLAG = '*';\n      PUT 'SMF70INB INDICATES DIAGNOSE X''204'' FAILURE.'           ;\n      PUT ' INTERVAL=' S70IST ' ON DATE=' S70DAT 'SYSTEM=' SMF70SID ;\n      END;\n   IF SMF70INB = '.1.. ....'B THEN DO;\n      FLAG = '*';\n      PUT 'SMF70INB INDICATES NO. OF PHYSICAL PROCESSORS HAS CHANGED.';\n      PUT ' INTERVAL=' S70IST ' ON DATE=' S70DAT 'SYSTEM=' SMF70SID ;\n      END;\n   IF SMF70INB = '..1. ....'B THEN DO;\n      FLAG = '*';\n      PUT 'SMF70INB INDICATES DGLOBAL TIME SLICE VALUE HAS CHANGED.';\n      PUT ' INTERVAL=' S70IST ' ON DATE=' S70DAT 'SYSTEM=' SMF70SID ;\n      END;\n* ******************************************************************;\n* ******************************************************************;\n  MIN = FLOOR(SMF70INT/100000)  /*PICK UP THE MINUTES ONLY MMSSTTT*/;\n  SEC = FLOOR((SMF70INT - MIN*100000)/1000)                         ;\n  INTSEC = (MIN*60) + SEC               /* NO. OF SECS IN INTERVAL*/;\n* ******************************************************************;\n* ******************************************************************;\n* *************************BEG. OF CPU WAIT TIME ROUTINE************;\n  IF SMF70FLG = '.... ...1'B THEN\n      GO TO PRSM_UT                 /*BIT INDICATES PR/SM MACHINE */;\n* **************ELSE USE WAIT TIME TO CALC CPU UTILIZATION**********;\n  TOT_UT  = 0                       /*INITIALIZE TOTAL UTILIZATION*/;\n  MODE    = '40'X                   /*INDICATE NON PR/SM MACHINE  */;\n  WAIT    = 0;\n  CPU_CTR = 1;\n  POINTER = SMF70CPS +M             /*LOCATE SMF70WAT             */;\nCPU_LOOP:\n   IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE        */;\n      FLAG = '*';\n      PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n          'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n      END;\n   WAIT = WAIT + SMF70WAT;\n   IF SMF70CPN = CPU_CTR THEN\n      GO TO CONT;\n   CPU_CTR = CPU_CTR + 1            /*    WE HAVE ANOTHER CPU */ ;\n   POINTER = POINTER + SMF70CPL     /* POINT TO ITS WAIT TIME */ ;\n  INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n   GO TO CPU_LOOP;\nCONT:\n WAIT = WAIT/CPU_CTR ;\n WAITMICS = WAIT/4096       /* CONVERT WAIT TIME TO MICRO SECS */;\n WAITSEC  = WAITMICS/1000000        /*      CONVERT TO SECONDS */;\n**                         END OF CPU WAIT TIME ROUTINE;\n   IF INTSEC = 0 THEN WAIT_PER = 0;\n   ELSE WAIT_PER = WAITSEC/INTSEC  /* PERCENTAGE OF WAIT TIME  */;\n   WAIT_PER = WAIT_PER*100               /* MAKE IT AN INTERGER*/;\n   CPU_UT   = 100 - WAIT_PER             /* AVG CPU UTILIZATION*/;\n   CPU_UT   = ROUND(CPU_UT,.1)           /* AVG CPU UTILIZATION*/;\n   TOT_UT   = CPU_UT * CPU_CTR       /*TOTL CPU UTL FOR PARTITN*/;\n   TOT_UT   = ROUND(TOT_UT,.1)       /*TOTL CPU UTL FOR PARTITN*/;\n   NUMCPU   = CPU_CTR              /* TOTAL CPU'S THIS  PARTITN*/;\n   GO TO SAVEIT                    /* ALL DONE                 */;\n* ******************************************************************;\n* ******************************************************************;\n* ********BEG. OF CPU UTILIZATION ROUTINE FOR PR/SM MACHINES********;\nPRSM_UT:\n    MODE     = 'P'                 /*INDICATE PR/SM MACHINE    */;\n    CUR_PDS  = SMF70BCS + M        /*FIRST PARTITION DATA SECT.*/;\n    PART_CTR = 0                   /*PARTITION COUNTER         */;\n    TCPU_CTR = 0                   /*PROCESSOR COUNTER         */;\n    TOT_UT   = 0                   /*TOTAL UTILIZATION         */;\nPART_LP:\n    PART_CTR = PART_CTR + 1        /*KEEP TRACK OF PARTITIONS  */;\n   IF SMF70PFG = '1... ....'B THEN DO  /*HAS PARTITION CHANGED */;\n      FLAG = '*';\n      PUT 'SMF70PFG INDICATES PARTITION HAS CHANGED. INTERVAL=' S70IST\n          'ON DATE=' S70DAT 'PARTITION=' SMF70LPN;\n      END;\n   IF SMF70PFG = '.1.. ....'B THEN DO  /*HAS PROCESSOR CHANGED */;\n      FLAG = '*';\n      PUT 'SMF70PFG INDICATES LOG. PROCESSOR HAS CHANGED. INTERVAL='\n          S70IST 'ON DATE=' S70DAT 'PARTITION=' SMF70LPN;\n      END;\n    CP_UT   = 0                    /*PHYSICAL CPU UTILIZATION      */;\n    CPU_CTR = 0             /*CPU NO. WITHIN A PARTICULAR PARTITION*/;\n   IF SMF70BDN = 0 THEN GO TO NEXT_P /*BECAUSE NO. OF LOG. PROCESSORS*/;\n**                                 FOR THIS PARTITION IS ZERO. ELSE,   ;\n**                                 POINT TO LPDS FOR THIS PARTITION.***;\n**  POINTER = OFFSET PLUS LENGTH TIMES NUM. OF SECTIONS TO SKIP     ***;\n****POINTER = OFFSET PLUS LENGTH TIMES NUM. OF SECTIONS TO SKIP**;\n    POINTER = SMF70BVS + M + (SMF70BDS*SMF70BVL);\n*  ***---------------PR/SM LOGICAL PROCESSOR DATA SECTION--***;\n  INPUT @ POINTER\n                SMF70PDT  PIB8.\n                SMF70VPA  PIB2.\n                SMF70BPS  PIB2.\n                SMF70VPF  PIB1.\n                   @;\n    NUMCPU = SMF70BDN       /*NUMBER OF LPDS FOR THIS PARTITION. THIS*/;\n**                            VARIABLE USED TEMPORARILY TO CONTROL THE ;\n**                            NUMBER OF TIMES TO LOOP. WILL BE RESET.  ;\n* ******************************************************************;\n*UT 'END OF PART_LP: ROUTINE AND WE HAVE THE FOLLOWING:  ';\n*UT 'PART_CTR=' PART_CTR '  S70SID=' S70SID '   SMF70LPM=' SMF70LPM   ;\n*UT 'TOT_UT=' TOT_UT 'CPU_CTR=' CPU_CTR;\n*UT 'POINTER=' POINTER '  = ' SMF70BVS '+' M'+'SMF70BDS'*'SMF70BVL;\n*UT 'LPDS=' SMF70PDT SMF70VPA SMF70BPS SMF70VPF ;\n* ******************************************************************;\nLPDS_LP1:\n    CPU_CTR =  CPU_CTR + 1        /*     LOGICAL PROCESSOR NUMBER */;\n    TCPU_CTR= TCPU_CTR + 1        /*TOTAL LOGICAL PROCESSORS      */;\n**********                                            **************;\n***IS PROCESSOR NOT DEDICATED AND IS WAIT COMPLETION DISABLED*******;\n***NOTE: 65535 = HEX'FFFF'                                   *******;\n**********                                            **************;\n    IF SMF70BPS NE 65535   AND\n       SMF70VPF EQ '0... ....'B THEN DO;\n        TOT_UT = TOT_UT +\n        ((SMF70PDT/1000000)/INTSEC)*100     /*TOTAL CPU UTIL */;\n       END;\n***                                                              ***;\n***IS PROCESSOR DEDICATED AND DO WE STILL HAVE                   ***;\n***CPU'S LEFT IN THE CPU DATA SECTION TO ANALYZE                 ***;\n***IF NOT FORGET IT BECAUSE WE DID ALL THE DEDICATED CPU'S       ***;\n***ALSO, WE ONLY UP ONE PARTITIONS DEDICATED CPU'S (THE ONE THAT ***;\n***MATCHES THE SMF SID.                                          ***;\n***NOTE: 65535 = HEX'FFFF'                                       ***;\n***                                                              ***;\n    IF SMF70BPS EQ 65535     AND\n       S70SID   EQ SMF70LPM  AND\n       CPU_CTR  LE S70CPN THEN DO;\n* ******************************************************************;\n*PUT 'DEDICATED CPU ROUTINE   AND WE HAVE THE FOLLOWING:  ';\n*PUT 'DATE=' S70DAT '  TIME=' S70IST;\n*PUT 'S70SID=' S70SID ' SMF70LPM=' SMF70LPM   ;\n*PUT 'TOT_UT=' TOT_UT 'CPU_CTR=' CPU_CTR ' S70CPN=' S70CPN;\n*PUT 'LPDS=' SMF70PDT SMF70VPA SMF70BPS SMF70VPF ;\n* ******************************************************************;\n       MODE     = 'D'           /*INDICATE PR/SM W/DEDICATED CPU  */;\n       POINTHLD = POINTER;\n       POINTER = SMF70CPS +M +((CPU_CTR - 1) * SMF70CPL);\n       INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n        WAITMICS = SMF70WAT/4096  /* CONVERT WAIT TIME TO MICRO SECS */;\n        CP_WAIT = ((WAITMICS/1000000)/INTSEC)*100     /*THEN TO SECS*/;\n        CP_UT   = 100 - CP_WAIT;\n        TOT_UT = TOT_UT + CP_UT;\n*PUT 'NEAR END OF CPU ROUTINE AND WE HAVE THE FOLLOWING:  ';\n*PUT 'TOT_UT=' TOT_UT 'CPU_CTR=' CPU_CTR ' S70CPN=' S70CPN;\n*PUT '*---   ';\n        IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE   */;\n        FLAG = '*';\n        PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n            'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n          END;\n        POINTER = POINTHLD;\n        GO TO LPDS_C1;\n       END;\n***                                                          ***;\n***IS PROCESSOR NOT DEDICATED AND IS WAIT COMPLETION ENABLED ***;\n***NOTE: 65535 = HEX'FFFF'                                   ***;\n***                                                          ***;\n    IF SMF70BPS NE 65535 AND\n       SMF70VPF EQ '1... ....'B THEN DO;\n*PUT '===>I AM AT RT FOR PROC NOT DEDICATED AND WAIT COMP. ENABLED';\n*PUT 'DATE=' S70DAT '  TIME=' S70IST;\n*PUT 'S70SID=' S70SID ' SMF70LPM=' SMF70LPM   ;\n*PUT '*---';\n       MODE     = 'E'     /*INDICATE LPAR, SHARED CPU, WAIT COMP. ON*/;\n       POINTHLD = POINTER;\n       POINTER = SMF70CPS +M +((CPU_CTR - 1) * SMF70CPL);\n       INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n        WAITMICS = SMF70WAT/4096  /* CONVERT WAIT TIME TO MICRO SECS */;\n        CP_UT = (((SMF70PDT-WAITMICS)/1000000)/INTSEC)*100;\n        TOT_UT = TOT_UT + CP_UT;\n        IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE   */;\n        FLAG = '*';\n        PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n            'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n          END;\n        POINTER = POINTHLD;\n        GO TO LPDS_C1;\n       END;\nLPDS_C1:\n    IF NUMCPU = CPU_CTR THEN\n       GO TO NEXT_P               /*DONE WITH THIS PART      */;\n    POINTER = POINTER + SMF70BVL  /*POINT TO NEXT PROCESSOR  */;\n*  ***---------------PR/SM LOGICAL PROCESSOR DATA SECTION--***;\n  INPUT @ POINTER\n                SMF70PDT  PIB8.\n                SMF70VPA  PIB2.\n                SMF70BPS  PIB2.\n                SMF70VPF  PIB1.\n                   @;\n    GO TO LPDS_LP1           /*GO DO NEXT PROCESSOR          */;\nNEXT_P:\n*  ASSUMES WE ONLY ACCUMULATE CPU TIME FOR DEDICATED MODE DIFFERENTLY;\n*  THAN IN SHARED MODE. IN SHARED WE CAN PICK UP CPU TIME FOR THE    ;\n*  ENTIRE MACHINE. IN DEDICATED MODE WE ARE LIMITED TO THE SYSTEM    ;\n*  WHOSE RMF RECORDS WE ARE ANALYZING. HAVE YET TO ACCOUNT FOR       ;\n*  MACHINES THAT ARE BOTH DEDICATED AND SHARED. (WE WILL PICK UP     ;\n*  EXTRA CPU TIME (FOR THE SHARED CPU'S) BUT THE CPU COUNTER WILL    ;\n*  BE OFF.)                                                          ;\n   IF PART_CTR GE SMF70BCN THEN DO;\n    IF MODE = 'D' THEN NUMCPU = S70CPN  /*THE DEDICATED CPU'S      */;\n       ELSE NUMCPU = S70BNP   /*OTHERWISE ALL THE CPU'S UNDER PR/SM*/;\n    CPU_UT = TOT_UT/NUMCPU          /*  AVERAGE CPU UTL FOR MACHINE*/;\n    CPU_UT   = ROUND(CPU_UT,.1)     /*  ROUND IT                   */;\n    TOT_UT   = ROUND(TOT_UT,.1)     /*  TOTAL CPU UTIL FOR MACHINE */;\n    NUMLP    = TCPU_CTR             /*  TOTAL NO. OF LOGICAL CPU'S */;\n    NUMPART  = PART_CTR             /*  NUMBER OF PART. FOR MACHINE*/;\n    GO TO SAVEIT;\n       END;\n    CUR_PDS = CUR_PDS + SMF70BCL /*SAVE NEXT PARTITION D.S.  */;\n    POINTER = CUR_PDS            /*POINT TO NEXT PART. D.S.  */;\n*  ***---------------PR/SM PARTITION DATA SECTION-----***;\n  INPUT @ POINTER\n                SMF70LPM  $CHAR4.\n                LPM2HALF  $CHAR4.\n                SMF70LPN  PIB1.\n                SMF70PFG  PIB1.\n                SMF70BDN  PIB2.\n                SMF70BDS  PIB4.\n                   @;\n    GO TO PART_LP            /*LETS LOOK AT THIS PARTITION   */;\nSAVEIT:\n**                                                     ;\n**  OUTPUT DATA FOR EACH SYSTEM THAT YOU WANT TO SAVE.         ;\n**                                                             ;\n**               SMF-ID                   P1CP8811             ;\n**                 |                      P1.........SYSTEM    ;\n**                 |                        CP.......CONSTANT  ;\n**                 |                          88.....YEAR      ;\n**                 |                            11...MONTH     ;\n**                 V                                           ;\n   IF SMF70SID = 'P1S2' THEN OUTPUT SASDB.P1CP8903 ;\n   IF SMF70SID = 'P0S3' THEN OUTPUT SASDB.P0CP8903 ;\n   IF SMF70SID = 'S1S1' THEN OUTPUT SASDB.S1CP8903 ;\nRETURN;\n   %\n   INPUTIT;\n   PROC PRINT DATA=SASDB.P1CP8903 ;\n       VAR S70INT WAIT_PER S70MOD S70VER S70SER\n           S70SID S70DAT S70IST\n           NUMLP NUMPART TOT_UT CPU_UT NUMCPU MODE FLAG ;\n   PROC PRINT DATA=SASDB.P0CP8903 ;\n       VAR S70INT WAIT_PER S70MOD S70VER S70SER\n           S70SID S70DAT S70IST\n           NUMLP NUMPART TOT_UT CPU_UT NUMCPU MODE FLAG ;\n   PROC PRINT DATA=SASDB.S1CP8903 ;\n       VAR S70INT WAIT_PER S70MOD S70VER S70SER\n           S70SID S70DAT S70IST\n           NUMLP NUMPART TOT_UT CPU_UT NUMCPU MODE FLAG ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPUTJ": {"ttr": 1288, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//XYT6970A JOB (XY,R412,30,20,05),'CPU UT BY MACHINE',MSGLEVEL=(1,1),\n//  CLASS=O,MSGCLASS=R,TIME=(4,10)\n//*\n//*  CALCULATE CPU UTILIZATION BY MACHINE (NOT SYSTEM) FOR THOSE\n//*  MACHINES UNDER THE CONTROL OF PR/SM.\n//*  THIS WILL ALSO WORK FOR NON PR/SM MACHINES.\n//*  INFORMATION IS CONTAINED IN RMF 70 RECORDS.\n//*\n//STEP1  EXEC SAS,WORK='40,10',RGN=4096K\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(CPUT)\n//SMF   DD DISP=SHR,DSN=XY.RMFMONTH         <==RMF INPUT\n//SASDB DD DSN=XY.TC.SASDB.CPU,           <==OUTPUT (SAS DATASET)\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPUTW": {"ttr": 1290, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n|   CPUTW - SIMILAR TO CPUT EXCEPT IT STORES DATA BY WEEK.          |\n|   ONLY LOOKING AT SMF TYPE 70 RECORDS. FOR MVS/XA SYSTEMS         |\n|   WITH OR WITHOUT PR/SM                                           |\n|   DATA MUST BE SORTED BEFORE BEING USED BY                        |\n|         SMF70SID,SMF70DAT,SMF70IST                                |\n|         (JUST USE THE SORT MEMBER)                                |\n|                                                                   |\n|   THIS PROGRAM IS THE FIRST STEP IN ATTEMPTING TO SUMMURIZE       |\n|   CPU UTILIZATION BY PHYSICAL PROCESSOR COMPLEX (E.G. ONE         |\n|   3090-400S). THE FOLLOWING ARE SOME THINGS TO REMEMBER.          |\n|                                                                   |\n|   A) A PHYSICAL PROCESSOR COMPLEX RUNNING IN BASIC MODE. IN THIS  |\n|      CASE IT WILL HAVE ONE OPERATING SYSTEM OR TWO OPERATING      |\n|      SYSTEMS IF THE MACHINE IS PHYSICALLY PARTITIONED.            |\n|     -THIS IS PRETTY STRAIGHT FORWARD AND ALL ONE HAS TO DO IS     |\n|      USE THE AVERAGE CPU UTILIZATION NUMBER PROVIDED BY RMF       |\n|      FOR A SINGLE OPERATING SYSTEM. IN THE CASE OF A PHYSICALLY   |\n|      PARTITIONED MACHINE THEN ONE HAS TO ADD THE TWO UTILIZATION  |\n|      NUMBERS FOR EACH OF THE OPERATING SYSTEMS AND DIVIDE BY 2.   |\n|                                                                   |\n|                                                                   |\n|   B) SIMILAR TO THE PHYSICALLY PARTITIONED MACHINE IS THE CASE    |\n|      OF THE LOGICALLY PARTITIONED PROCESSOR COMLEX (LPAR MODE)    |\n|      WHERE ALL THE PARTITIONS HAVE DEDICATED CPU'S. HERE WE HAVE  |\n|      TO ADD UP ALL THE CPU TIMES OF THE PARTITIONS AND DIVIDE BY  |\n|      THE NUMBER OF CPU'S. NOTE THAT THE CPU UTILIZATION (ACTUALLY |\n|      WAIT TIME) FOR DEDICATED CPU'S ARE ONLY CONTAINED IN THE     |\n|      RMF RECORDS OF THE SYSTEM WHICH PRODUCED THE RECORDS. THAT   |\n|      IS, YOU MUST READ RMF RECORDS FROM EACH SYSTEM TO PICK UP THE|\n|      DEDICATED CPU TIMES.                                         |\n|                                                                   |\n|   C) NEXT, PROBABLY THE SIMPLEST, IS THE CASE OF LPAR MODE IN     |\n|      WHICH ALL THE CPU'S ARE SHARED. IN THIS CASE ONE CAN PICK    |\n|      UP THE CPU UTILIZATION OF ALL PARTITIONS FROM ONE SYSTEM'S   |\n|      RMF RECORDS.                                                 |\n|                                                                   |\n|   D) OF COURSE, THERE ARE OTHER SITUATIONS IN WHICH SOME          |\n|      LPARS HAVE DEDICATED CPU'S AND SOME HAVE SHARED. AND OF      |\n|      COURSE, DON'T FORGET A MACHINE THAT IS PHYSICALLY PARTITIONED|\n|      AND ONE SIDE USES PR/SM IN VARIOUS CONFIGUARTIONS AND        |\n|      THE OTHER SIDE DOESN'T ...                                   |\n|                                                                   |\n| ----                       -----                            ----  |\n|   SINCE THE DATA IS SAVED BY SYSTEM ID (SMF ID) THEN THE ONLY     |\n|   THING THAT MAKES THESE PROGRAMS INSTALLATION DEPENDANT ARE      |\n|   1) THE LITERALS FOR CHECKING THE SYSTEM ID                      |\n|       -LOCATED AT THE END OF THE PROGRAM                          |\n|   2) THE MEMBER NAME THAT IS GIVEN TO THE SAS DATASET (ONE FOR    |\n|      EACH SYSTEM)                                                 |\n|       -LOCATED IN THE BEGINING (DATA STATEMENT)                   |\n|        AND AT THE END, FOLLOWING THE \"OUTPUT\" STATEMENTS          |\n|                                                                   |\n|   IN ADDITION, SINCE THE DATA IS NORMALLY STORED BY MONTH         |\n|   THEN THE MEMBER NAMES REFERENCED IN NUMBER 2 ABOVE              |\n|   IS CHANGED SLIGHTLY EACH MONTH TO REFLECT THE MONTH AND YEAR.   |\n| ----                       -----                            ----  |\n|                                                                   |\n|   THIS SAS FILE THEN CAN BE USED AS INPUT TO CREATE A GRAPH       |\n|   EITHER ON THE TERMINAL OR TO A PRINTER USING GDDM.              |\n|                                                                   |\n|   SMF70RTY...... RECORD TYPE.                                     |\n|   SMF70SID...... SID.                                             |\n|   SMF70IST...... TIME RMF MEASUREMENT INTERVAL STARTED IN FORM    |\n|                  0HHMMSSF WHERE F IS THE SIGN.                    |\n|   SMF70DAT...... DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED    |\n|                  (F IS THE SIGN).                                 |\n|   SMF70INT...... DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|   SMF70TMN...... TSO USERS MINIMUM OVER INTERVAL.                 |\n|   SMF70TMM...... TSO USERS MAXIMUM OVER INTERVAL.\n|   SMF70TTT...... TSO USERS TOTAL VALUE OVER INTERVAL.             |\n|                                                                   |\n|                                                                   |\n|   THE VARIABLES THAT ARE SAVE ARE:                                |\n|                                                                   |\n|   S70IST........ INTERVAL START TIME                              |\n|   S70DAT........ INTERVAL DATE                                    |\n|   S70INT........ LENGTH OF (RMF) INTERVAL                         |\n|   S70MOD........ PROCESSOR MODEL (SMF70MOD)                       |\n|   S70VER........ VERSION (SMF70VER)                               |\n|   S70SER........ SERIAL NUMBER (SMF70SER)                         |\n|   S70SID........ SYSTEM'S SMF ID                                  |\n|   NUMLP......... NUMBER OF LOGICAL PROCESSORS                     |\n|   NUMPART....... NUMBER OF PARTITIONS                             |\n|   CPU_UT........ AVG. PERCENT BUSY (1 - WAIT_PER FOR NON PR/SM) OR|\n|                  FROM SMF70PDT FOR PR/SM MACHINES                 |\n|   TOT_UT........ TOTAL UTILIZATION (ALL CPU'S IN PARTITION)       |\n|   NUMCPU........ NUMBER OF LOGICAL PROCESSORS ASSIGNED TO A       |\n|                  PARTITION. OR NUMBER OF DEDICATED CPU'S IN       |\n|                  THIS SYSTEM'S PARTITION.                         |\n|   MODE.......... MODE. BLANK=BASIC. D=LPAR WITH DEDICATED CPU'S   |\n|                        E=WAIT COMPLETION ENABLED (SHARED CPU'S).  |\n|                        P=PR/SM SHARED CPU'S.                      |\n|   FLAG.......... SOMETHING OCCURED IN THIS INTERVAL OUT OF THE    |\n|                  ORDINARY. DETAILED MESSAGE IS PRINTED.           |\n|                                                                   |\n|                                                                   |\n|   OUTPUT FILE NAME = SID...CONSTANTS.......WEEK NUMBER            |\n|                       \u00a6       \u00a6   \u00a6__.       \u00a6                    |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|    E.G.   S1CPWK0X = S1 ...  CP  ...WK  ... 0X                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.S1CPWKXX TO S1CPWKXX FOR TEMPORARY DATASET  |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST WEEK  STORED WAS WEEK \"X\"       |\n|          AND YOU WANT TO SAVE WEEK \"Y\" DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|          C CPWK0X CPWK0Y ALL                                      |\n|                                                                   |\n|   UPDATES:                                                        |\n|    ADDED S70BMM TO THE DATA STATEMETS. THIS WILL SAVE MAXIMUM     |\n|    BATCH JOBS.                                                    |\n|                                                                   |\n|   UPDATES:                                                        |\n|     3/20/89 - ADDED NEW FIELD LABELED \"MODE\" TO INDICATED WHAT    |\n|      MODE THE MACHINE WAS OPERATING IN. P=PR/SM. BLANK FOR ALL    |\n|      OTHERS.                                                      |\n|     3/22/89 - ADDED \"MISSOVER\" TO INFILE STATEMENT TO KEEP SAS    |\n|      FROM LOOKING AHEAD WHEN IT CAN'T FIND ALL THE VARIABLES.     |\n|     3/27/89 - FIX TO HANDLE NO LPDS FOR A PARTITION. AND TO       |\n|      RECORD CORRECT NUMBER OF PHYSICAL CPU'S                      |\n|     4/25/89 - ADDED CODE TO HANDLE DEDICATED CPU'S UNDER PR/SM.   |\n|      CPU WAIT TIME IS ONLY RECORDED FOR THE SYSTEM THAT PRODUCED  |\n|      THE RMF RECORDS. NOT SURE (YET) ABOUT DEDICATED AND SHARED   |\n|      CPU'S.                                                       |\n|      ALSO ADDED A NEW \"MODE\" OF \"D\" TO INDICATED UNDER PR/SM      |\n|      BUT WITH DEDICATED CPU'S                                     |\n|     4/27/89 - CORRECTED CODE TO HANDLE SHARED CPU(S) WITH WAIT    |\n|      COMPLETION ENABLED. ADDED \"MODE\" OF \"E\" TO INDICATE SUCH.    |\n|--                                                                 |\n|    NOTE: FOR NOW WE ARE JUST USING THE 1ST FOUR BYTES OF SMF70LPM |\n|          (THE PARTITION NAME)                                     |\n*-------------------------------------------------------------------*\n;\n   MACRO INPUTIT\n   DATA\n SASDB.P1CPWK04 (KEEP=S70INT WAIT_PER S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                NUMLP NUMPART TOT_UT CPU_UT NUMCPU  MODE FLAG )\n SASDB.P0CPWK04 (KEEP=S70INT WAIT_PER S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                NUMLP NUMPART TOT_UT CPU_UT NUMCPU  MODE FLAG )\n SASDB.S1CPWK04 (KEEP=S70INT WAIT_PER S70MOD S70VER S70SER\n                S70SID S70DAT S70IST\n                NUMLP NUMPART TOT_UT CPU_UT NUMCPU  MODE FLAG )\n        ;\n   INFILE SMF LENGTH=L MISSOVER;\n*  INFORMAT S70IST RMFDUR4. S70INT PDTIME4. ;\n   INPUT @2 ID PIB1. @;\n   IF ID = 70  THEN LINK X5;\n   RETURN;\nX5:\nPOINTER = 1;\nM = -3;\nINPUT @ POINTER\n                SMF70FLG  PIB1.\n             +9 SMF70SID  $CHAR4.\n            +10 SMF70PRS  PIB4.\n                SMF70PRL  PIB2.\n                SMF70PRN  PIB2.\n                SMF70CCS  PIB4.\n                SMF70CCL  PIB2.\n                SMF70CCN  PIB2.\n                SMF70CPS  PIB4.\n                SMF70CPL  PIB2.\n                SMF70CPN  PIB2.\n                SMF70ASS  PIB4.\n                SMF70ASL  PIB2.\n                SMF70ASN  PIB2.\n                SMF70BCS  PIB4.\n                SMF70BCL  PIB2.\n                SMF70BCN  PIB2.\n                SMF70BVS  PIB4.\n                SMF70BVL  PIB2.\n                SMF70BVN  PIB2.\n                 @;\n*  ***---------------RMF PRODUCT SECTION--------------***;\nPOINTER = SMF70PRS +M;\nINPUT @ POINTER\n           +10  SMF70IST  PD4.\n                SMF70DAT  PD4.\n                SMF70INT  PD4.\n            +2  SMF70SAM  PIB4.\n                 @;\n*  ***---------------CPU CONTROL SECTION--------------***;\nPOINTER = SMF70CCS +M;\n  INPUT @ POINTER\n                SMF70MOD  PK2.\n                SMF70VER  PK1.\n                SMF70BNP  PIB1.\n                SMF70INB  PIB1.\n                   @;\n*  ***---------------CPU DATA SECTION-----------------***;\nPOINTER = SMF70CPS +M;\n  INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n*  ***---------------ASID DATA AREA SECTION-----------***;\nPOINTER = SMF70ASS +M;\nINPUT @ POINTER\n          +128  SMF70OMN  PIB2.\n                SMF70OMM  PIB2.\n                SMF70OTT  PIB4.\n          +104  SMF70BMN  PIB2.\n                SMF70BMM  PIB2.\n                SMF70BTT  PIB4.\n          +104  SMF70TMN  PIB2.\n                SMF70TMM  PIB2.\n                SMF70TTT  PIB4.\n                 @;\n*  ***---------------PR/SM PARTITION DATA SECTION-----***;\nPOINTER = SMF70BCS + M;\n  INPUT @ POINTER\n                SMF70LPM  $CHAR4.\n                LPM2HALF  $CHAR4.\n                SMF70LPN  PIB1.\n                SMF70PFG  PIB1.\n                SMF70BDN  PIB2.\n                SMF70BDS  PIB4.\n                   @;\n*  ***--LETS START DOING SOME CALCULATIONS--***;\n***IF SMF70DAT NE 89030 THEN DELETE          /*<===TESTING ONLY==*/;\n  S70IST = SMF70IST;\n  S70DAT = SMF70DAT;\n  S70INT = SMF70INT;\n  S70SID = SMF70SID;\n  S70MOD = SMF70MOD;\n  S70VER = SMF70VER;\n  S70SER = SMF70SER;\n  S70BNP = SMF70BNP;\n  S70CPN = SMF70CPN;\n**IF SMF70SAM = 0 THEN S70TAV = 0;\n   IF SMF70INT LT 0100000 THEN DELETE;\n* ******************************************************************;\n* ******************************************************************;\n   IF SMF70INB = '1... ....'B THEN DO      /* PR/SM INDICATOR BITS*/;\n      FLAG = '*';\n      PUT 'SMF70INB INDICATES DIAGNOSE X''204'' FAILURE.'           ;\n      PUT ' INTERVAL=' S70IST ' ON DATE=' S70DAT 'SYSTEM=' SMF70SID ;\n      END;\n   IF SMF70INB = '.1.. ....'B THEN DO;\n      FLAG = '*';\n      PUT 'SMF70INB INDICATES NO. OF PHYSICAL PROCESSORS HAS CHANGED.';\n      PUT ' INTERVAL=' S70IST ' ON DATE=' S70DAT 'SYSTEM=' SMF70SID ;\n      END;\n   IF SMF70INB = '..1. ....'B THEN DO;\n      FLAG = '*';\n      PUT 'SMF70INB INDICATES DGLOBAL TIME SLICE VALUE HAS CHANGED.';\n      PUT ' INTERVAL=' S70IST ' ON DATE=' S70DAT 'SYSTEM=' SMF70SID ;\n      END;\n* ******************************************************************;\n* ******************************************************************;\n  MIN = FLOOR(SMF70INT/100000)  /*PICK UP THE MINUTES ONLY MMSSTTT*/;\n  SEC = FLOOR((SMF70INT - MIN*100000)/1000)                         ;\n  INTSEC = (MIN*60) + SEC               /* NO. OF SECS IN INTERVAL*/;\n* ******************************************************************;\n* ******************************************************************;\n* *************************BEG. OF CPU WAIT TIME ROUTINE************;\n  IF SMF70FLG = '.... ...1'B THEN\n      GO TO PRSM_UT                 /*BIT INDICATES PR/SM MACHINE */;\n* **************ELSE USE WAIT TIME TO CALC CPU UTILIZATION**********;\n  TOT_UT  = 0                       /*INITIALIZE TOTAL UTILIZATION*/;\n  MODE    = '40'X                   /*INDICATE NON PR/SM MACHINE  */;\n  WAIT    = 0;\n  CPU_CTR = 1;\n  POINTER = SMF70CPS +M             /*LOCATE SMF70WAT             */;\nCPU_LOOP:\n   IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE        */;\n      FLAG = '*';\n      PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n          'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n      END;\n   WAIT = WAIT + SMF70WAT;\n   IF SMF70CPN = CPU_CTR THEN\n      GO TO CONT;\n   CPU_CTR = CPU_CTR + 1            /*    WE HAVE ANOTHER CPU */ ;\n   POINTER = POINTER + SMF70CPL     /* POINT TO ITS WAIT TIME */ ;\n  INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n   GO TO CPU_LOOP;\nCONT:\n WAIT = WAIT/CPU_CTR ;\n WAITMICS = WAIT/4096       /* CONVERT WAIT TIME TO MICRO SECS */;\n WAITSEC  = WAITMICS/1000000        /*      CONVERT TO SECONDS */;\n**                         END OF CPU WAIT TIME ROUTINE;\n   IF INTSEC = 0 THEN WAIT_PER = 0;\n   ELSE WAIT_PER = WAITSEC/INTSEC  /* PERCENTAGE OF WAIT TIME  */;\n   WAIT_PER = WAIT_PER*100               /* MAKE IT AN INTERGER*/;\n   CPU_UT   = 100 - WAIT_PER             /* AVG CPU UTILIZATION*/;\n   CPU_UT   = ROUND(CPU_UT,.1)           /* AVG CPU UTILIZATION*/;\n   TOT_UT   = CPU_UT * CPU_CTR       /*TOTL CPU UTL FOR PARTITN*/;\n   TOT_UT   = ROUND(TOT_UT,.1)       /*TOTL CPU UTL FOR PARTITN*/;\n   NUMCPU   = CPU_CTR              /* TOTAL CPU'S THIS  PARTITN*/;\n   GO TO SAVEIT                    /* ALL DONE                 */;\n* ******************************************************************;\n* ******************************************************************;\n* ********BEG. OF CPU UTILIZATION ROUTINE FOR PR/SM MACHINES********;\nPRSM_UT:\n    MODE     = 'P'                 /*INDICATE PR/SM MACHINE    */;\n    CUR_PDS  = SMF70BCS + M        /*FIRST PARTITION DATA SECT.*/;\n    PART_CTR = 0                   /*PARTITION COUNTER         */;\n    TCPU_CTR = 0                   /*PROCESSOR COUNTER         */;\n    TOT_UT   = 0                   /*TOTAL UTILIZATION         */;\nPART_LP:\n    PART_CTR = PART_CTR + 1        /*KEEP TRACK OF PARTITIONS  */;\n   IF SMF70PFG = '1... ....'B THEN DO  /*HAS PARTITION CHANGED */;\n      FLAG = '*';\n      PUT 'SMF70PFG INDICATES PARTITION HAS CHANGED. INTERVAL=' S70IST\n          'ON DATE=' S70DAT 'PARTITION=' SMF70LPN;\n      END;\n   IF SMF70PFG = '.1.. ....'B THEN DO  /*HAS PROCESSOR CHANGED */;\n      FLAG = '*';\n      PUT 'SMF70PFG INDICATES LOG. PROCESSOR HAS CHANGED. INTERVAL='\n          S70IST 'ON DATE=' S70DAT 'PARTITION=' SMF70LPN;\n      END;\n    CP_UT   = 0                    /*PHYSICAL CPU UTILIZATION      */;\n    CPU_CTR = 0             /*CPU NO. WITHIN A PARTICULAR PARTITION*/;\n   IF SMF70BDN = 0 THEN GO TO NEXT_P /*BECAUSE NO. OF LOG. PROCESSORS*/;\n**                                 FOR THIS PARTITION IS ZERO. ELSE,   ;\n**                                 POINT TO LPDS FOR THIS PARTITION.***;\n**  POINTER = OFFSET PLUS LENGTH TIMES NUM. OF SECTIONS TO SKIP     ***;\n****POINTER = OFFSET PLUS LENGTH TIMES NUM. OF SECTIONS TO SKIP**;\n    POINTER = SMF70BVS + M + (SMF70BDS*SMF70BVL);\n*  ***---------------PR/SM LOGICAL PROCESSOR DATA SECTION--***;\n  INPUT @ POINTER\n                SMF70PDT  PIB8.\n                SMF70VPA  PIB2.\n                SMF70BPS  PIB2.\n                SMF70VPF  PIB1.\n                   @;\n    NUMCPU = SMF70BDN       /*NUMBER OF LPDS FOR THIS PARTITION. THIS*/;\n**                            VARIABLE USED TEMPORARILY TO CONTROL THE ;\n**                            NUMBER OF TIMES TO LOOP. WILL BE RESET.  ;\n* ******************************************************************;\n*UT 'END OF PART_LP: ROUTINE AND WE HAVE THE FOLLOWING:  ';\n*UT 'PART_CTR=' PART_CTR '  S70SID=' S70SID '   SMF70LPM=' SMF70LPM   ;\n*UT 'TOT_UT=' TOT_UT 'CPU_CTR=' CPU_CTR;\n*UT 'POINTER=' POINTER '  = ' SMF70BVS '+' M'+'SMF70BDS'*'SMF70BVL;\n*UT 'LPDS=' SMF70PDT SMF70VPA SMF70BPS SMF70VPF ;\n* ******************************************************************;\nLPDS_LP1:\n    CPU_CTR =  CPU_CTR + 1        /*     LOGICAL PROCESSOR NUMBER */;\n    TCPU_CTR= TCPU_CTR + 1        /*TOTAL LOGICAL PROCESSORS      */;\n**********                                            **************;\n***IS PROCESSOR NOT DEDICATED AND IS WAIT COMPLETION DISABLED*******;\n***NOTE: 65535 = HEX'FFFF'                                   *******;\n**********                                            **************;\n    IF SMF70BPS NE 65535   AND\n       SMF70VPF EQ '0... ....'B THEN DO;\n        TOT_UT = TOT_UT +\n        ((SMF70PDT/1000000)/INTSEC)*100     /*TOTAL CPU UTIL */;\n       END;\n***                                                              ***;\n***IS PROCESSOR DEDICATED AND DO WE STILL HAVE                   ***;\n***CPU'S LEFT IN THE CPU DATA SECTION TO ANALYZE                 ***;\n***IF NOT FORGET IT BECAUSE WE DID ALL THE DEDICATED CPU'S       ***;\n***ALSO, WE ONLY UP ONE PARTITIONS DEDICATED CPU'S (THE ONE THAT ***;\n***MATCHES THE SMF SID.                                          ***;\n***NOTE: 65535 = HEX'FFFF'                                       ***;\n***                                                              ***;\n    IF SMF70BPS EQ 65535     AND\n       S70SID   EQ SMF70LPM  AND\n       CPU_CTR  LE S70CPN THEN DO;\n* ******************************************************************;\n*PUT 'DEDICATED CPU ROUTINE   AND WE HAVE THE FOLLOWING:  ';\n*PUT 'DATE=' S70DAT '  TIME=' S70IST;\n*PUT 'S70SID=' S70SID ' SMF70LPM=' SMF70LPM   ;\n*PUT 'TOT_UT=' TOT_UT 'CPU_CTR=' CPU_CTR ' S70CPN=' S70CPN;\n*PUT 'LPDS=' SMF70PDT SMF70VPA SMF70BPS SMF70VPF ;\n* ******************************************************************;\n       MODE     = 'D'           /*INDICATE PR/SM W/DEDICATED CPU  */;\n       POINTHLD = POINTER;\n       POINTER = SMF70CPS +M +((CPU_CTR - 1) * SMF70CPL);\n       INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n        WAITMICS = SMF70WAT/4096  /* CONVERT WAIT TIME TO MICRO SECS */;\n        CP_WAIT = ((WAITMICS/1000000)/INTSEC)*100     /*THEN TO SECS*/;\n        CP_UT   = 100 - CP_WAIT;\n        TOT_UT = TOT_UT + CP_UT;\n*PUT 'NEAR END OF CPU ROUTINE AND WE HAVE THE FOLLOWING:  ';\n*PUT 'TOT_UT=' TOT_UT 'CPU_CTR=' CPU_CTR ' S70CPN=' S70CPN;\n*PUT '*---   ';\n        IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE   */;\n        FLAG = '*';\n        PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n            'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n          END;\n        POINTER = POINTHLD;\n        GO TO LPDS_C1;\n       END;\n***                                                          ***;\n***IS PROCESSOR NOT DEDICATED AND IS WAIT COMPLETION ENABLED ***;\n***NOTE: 65535 = HEX'FFFF'                                   ***;\n***                                                          ***;\n    IF SMF70BPS NE 65535 AND\n       SMF70VPF EQ '1... ....'B THEN DO;\n*PUT '===>I AM AT RT FOR PROC NOT DEDICATED AND WAIT COMP. ENABLED';\n*PUT 'DATE=' S70DAT '  TIME=' S70IST;\n*PUT 'S70SID=' S70SID ' SMF70LPM=' SMF70LPM   ;\n*PUT '*---';\n       MODE     = 'E'     /*INDICATE LPAR, SHARED CPU, WAIT COMP. ON*/;\n       POINTHLD = POINTER;\n       POINTER = SMF70CPS +M +((CPU_CTR - 1) * SMF70CPL);\n       INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n        WAITMICS = SMF70WAT/4096  /* CONVERT WAIT TIME TO MICRO SECS */;\n        CP_UT = (((SMF70PDT-WAITMICS)/1000000)/INTSEC)*100;\n        TOT_UT = TOT_UT + CP_UT;\n        IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE   */;\n        FLAG = '*';\n        PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n            'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n          END;\n        POINTER = POINTHLD;\n        GO TO LPDS_C1;\n       END;\nLPDS_C1:\n    IF NUMCPU = CPU_CTR THEN\n       GO TO NEXT_P               /*DONE WITH THIS PART      */;\n    POINTER = POINTER + SMF70BVL  /*POINT TO NEXT PROCESSOR  */;\n*  ***---------------PR/SM LOGICAL PROCESSOR DATA SECTION--***;\n  INPUT @ POINTER\n                SMF70PDT  PIB8.\n                SMF70VPA  PIB2.\n                SMF70BPS  PIB2.\n                SMF70VPF  PIB1.\n                   @;\n    GO TO LPDS_LP1           /*GO DO NEXT PROCESSOR          */;\nNEXT_P:\n*  ASSUMES WE ONLY ACCUMULATE CPU TIME FOR DEDICATED MODE DIFFERENTLY;\n*  THAN IN SHARED MODE. IN SHARED WE CAN PICK UP CPU TIME FOR THE    ;\n*  ENTIRE MACHINE. IN DEDICATED MODE WE ARE LIMITED TO THE SYSTEM    ;\n*  WHOSE RMF RECORDS WE ARE ANALYZING. HAVE YET TO ACCOUNT FOR       ;\n*  MACHINES THAT ARE BOTH DEDICATED AND SHARED. (WE WILL PICK UP     ;\n*  EXTRA CPU TIME (FOR THE SHARED CPU'S) BUT THE CPU COUNTER WILL    ;\n*  BE OFF.)                                                          ;\n   IF PART_CTR GE SMF70BCN THEN DO;\n    IF MODE = 'D' THEN NUMCPU = S70CPN  /*THE DEDICATED CPU'S      */;\n       ELSE NUMCPU = S70BNP   /*OTHERWISE ALL THE CPU'S UNDER PR/SM*/;\n    CPU_UT = TOT_UT/NUMCPU          /*  AVERAGE CPU UTL FOR MACHINE*/;\n    CPU_UT   = ROUND(CPU_UT,.1)     /*  ROUND IT                   */;\n    TOT_UT   = ROUND(TOT_UT,.1)     /*  TOTAL CPU UTIL FOR MACHINE */;\n    NUMLP    = TCPU_CTR             /*  TOTAL NO. OF LOGICAL CPU'S */;\n    NUMPART  = PART_CTR             /*  NUMBER OF PART. FOR MACHINE*/;\n    GO TO SAVEIT;\n       END;\n    CUR_PDS = CUR_PDS + SMF70BCL /*SAVE NEXT PARTITION D.S.  */;\n    POINTER = CUR_PDS            /*POINT TO NEXT PART. D.S.  */;\n*  ***---------------PR/SM PARTITION DATA SECTION-----***;\n  INPUT @ POINTER\n                SMF70LPM  $CHAR4.\n                LPM2HALF  $CHAR4.\n                SMF70LPN  PIB1.\n                SMF70PFG  PIB1.\n                SMF70BDN  PIB2.\n                SMF70BDS  PIB4.\n                   @;\n    GO TO PART_LP            /*LETS LOOK AT THIS PARTITION   */;\nSAVEIT:\n**                                                     ;\n**  OUTPUT DATA FOR EACH SYSTEM THAT YOU WANT TO SAVE.         ;\n**                                                             ;\n**               SMF-ID                   P1CP8811             ;\n**                 |                      P1.........SYSTEM    ;\n**                 |                        CP.......CONSTANT  ;\n**                 |                          88.....YEAR      ;\n**                 |                            11...MONTH     ;\n**                 V                                           ;\n   IF SMF70SID = 'P1S2' THEN OUTPUT SASDB.P1CPWK04 ;\n   IF SMF70SID = 'P0S3' THEN OUTPUT SASDB.P0CPWK04 ;\n   IF SMF70SID = 'S1S1' THEN OUTPUT SASDB.S1CPWK04 ;\nRETURN;\n   %\n   INPUTIT;\n   PROC PRINT DATA=SASDB.P1CPWK04 ;\n       VAR S70INT WAIT_PER S70MOD S70VER S70SER\n           S70SID S70DAT S70IST\n           NUMLP NUMPART TOT_UT CPU_UT NUMCPU MODE FLAG ;\n   PROC PRINT DATA=SASDB.P0CPWK04 ;\n       VAR S70INT WAIT_PER S70MOD S70VER S70SER\n           S70SID S70DAT S70IST\n           NUMLP NUMPART TOT_UT CPU_UT NUMCPU MODE FLAG ;\n   PROC PRINT DATA=SASDB.S1CPWK04 ;\n       VAR S70INT WAIT_PER S70MOD S70VER S70SER\n           S70SID S70DAT S70IST\n           NUMLP NUMPART TOT_UT CPU_UT NUMCPU MODE FLAG ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPUTWJ": {"ttr": 1543, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'CPU UT BY MACHINE',MSGLEVEL=(1,1),\n//  CLASS=O,MSGCLASS=R,TIME=(4,30)\n//*\n//*  CALCULATE CPU UTILIZATION BY MACHINE (NOT SYSTEM) FOR THOSE\n//*  MACHINES UNDER THE CONTROL OF PR/SM.\n//*  THIS WILL ALSO WORK FOR NON PR/SM MACHINES.\n//*  INFORMATION IS CONTAINED IN RMF 70 RECORDS.\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(CPUTW)\n//SMF   DD DISP=SHR,DSN=XY.RMFWEEK          <==RMF INPUT\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,           <==OUTPUT (SAS DATASET)\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2BAV": {"ttr": 1545, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=cyan\n     'DEC 1988 AVG BATCH USERS AND ASIDS OUT/READY'\n ;\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'D2BAV   SOURCE: RMF DATA - SYSTEM 1';\nFOOTNOTE3 J=L H=1 F=NONE C=GREEN\n       'AVG BATCH USERS IN GREEN ';\nFOOTNOTE4 J=L H=1 F=NONE C=RED\n       'AVG ASIDS SWAPPED OUT AND READY IS IN RED';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0708810\n*              SASDB.P0708811\n*              SASDB.P0708812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=XDAT XHH  XBAV XOAV);\n  SET SASDB.P0708812\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n%INCLUDE DD1(EX8811) ;\n%INCLUDE DD1(EX8812) ;\n HH = FLOOR(S70IST/10000);\nXBAV = S70BAV                  /* AVG BATCH JOBS */ ;\nXOAV = S70OAV                  /* AVG ASIDS OUT AND WAITING */ ;\nXHH  = HH ;\nXDAT = S70DAT ;\n OUTPUT TEST0 ;\nRETAIN;\nRETURN;\n*  PROC PRINT ;\n  PROC SORT OUT=TEST1;\n    BY XDAT ;\n  PROC SUMMARY ;\n    VAR XBAV XOAV ;\n    BY XDAT ;\n        OUTPUT OUT=TEST2  MEAN(XBAV)=GBAV   MEAN(XOAV)= GOAV\n;\n  DATA TEST3\n       (KEEP=GDAT GBAV GOAV GNUM );\n  SET TEST2         /*READ IN DAILY AVERAGES                */;\n  GNUM = _N_        /*NUMBER EACH RECORD SO WE CAN GRAPH IT */;\n  GDAT = XDAT       /*JUST THE DATE MAY USE IT LATER        */;\n  GBAV = CEIL(GBAV) /*ROUND IT UP                           */;\n  GOAV = CEIL(GOAV) /*ROUND IT UP                           */;\n  OUTPUT TEST3;\n*PROC PRINT DATA=TEST3;\nSYMBOL1 W=1 C=GREEN I=JOIN V=DIAMOND ;\nSYMBOL2 W=1 C=RED   I=JOIN V=STAR ;\n   PROC GPLOT      DATA = TEST3;\n        PLOT GBAV  *GNUM= 1\n             GOAV  *GNUM= 2 / OVERLAY\n        VAXIS= 0 TO 16  BY 2\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "D2BMM": {"ttr": 1548, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS NOCHACTERS;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n          ' DEC 1988 AVG HOURLY MAX BATCH USERS/DAY '\n ;\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'D2BMM  AVG OF MAX BATCH USERS';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0708810\n*              SASDB.P0708811\n*              SASDB.P0708812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GBMM GNUM GBAV GOAV);\n  SET SASDB.P0708812\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8812) ;\n HH = FLOOR(S70IST/10000);\nGBMM = S70BMM                  /* MAX BATCH JOBS */ ;\nGBAV = S70BAV                  /* AVG BATCH JOBS */ ;\nGOAV = S70OAV                  /* AVG ASIDS OUT AND WAITING */ ;\nGHH  = HH ;\nGDAT = S70DAT ;\n OUTPUT TEST0 ;\nRETAIN;\nRETURN;\n   PROC PRINT ;\n PROC MEANS;\n  VAR GBMM;\n  BY GDAT;\n  OUTPUT OUT=TEST2 MEAN=AVGBMM;\n PROC PRINT DATA=TEST2;\nSYMBOL1 W=1 C=GREEN I=JOIN V=DIAMOND ;\nSYMBOL2 W=1 C=RED   I=JOIN V=STAR ;\n   PROC GPLOT      DATA = TEST2     /*GOUT=MYCAT.GRAPH*/;\n        PLOT AVGBMM*GDAT    /\n        VAXIS= 0 TO 50  BY 5\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2CPU": {"ttr": 1550, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n  'AVGERAGE CPU UTILIZATION BY DAY';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN\n  'DEC 1988 AVGERAGE CPU UTILIZATION ';\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN\n  'D2CPU  SOURCE:RMF DATA. SYSTEM 3';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0708810\n*              SASDB.P0708811\n*              SASDB.P0708812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.P0708812\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8812) ;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT;\nGHH  = HH;\nGDAT = S70DAT;\n OUTPUT TEST0    ;\nRETAIN;\nRETURN;\n*PROC PRINT;\n PROC MEANS   NOPRINT;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGCPU;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=RED   I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=GREEN I=JOIN V=DIAMOND ;\n*ATTERN V=S R=99 ;\n*PROC PRINT;\n   PROC GPLOT      DATA = TEST2       /*GOUT=MYCAT.GRAPH*/ ;\n       AXIS1 LABEL=('AVG CPU' )\n             ORDER= 0 TO 100 BY 20 ;\n       AXIS2 LABEL=('DAYS' )\n             ORDER= 0 TO 40  BY 1  ;\n     PLOT AVGCPU*GNUM    /\n        VAXIS= AXIS1\n        HAXIS= AXIS2\n        NAME='D2CPU'   DES='AVG CPU UTIL BY DAY'\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2M1CPU": {"ttr": 1793, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n  'AVGERAGE CPU UTILIZATION BY DAY 3090-400E';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN\n  'JAN - APR 1989 AVGERAGE CPU UTILIZATION ';\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN\n  'D2M1CPU  SOURCE:RMF DATA. SER NO. NN1596';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.UTM18901\n      SASDB.UTM18902\n      SASDB.UTM18903\n      SASDB.UTM18904\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8901) ;\n%INCLUDE DD1(EX8902) ;\n%INCLUDE DD1(EX8903) ;\n%INCLUDE DD1(EX8904) ;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT;\nGHH  = HH;\nGDAT = S70DAT;\n OUTPUT TEST0    ;\nRETAIN;\nRETURN;\n*PROC PRINT;\n PROC MEANS   NOPRINT;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGCPU;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=RED   I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=GREEN I=JOIN V=DIAMOND ;\n*ATTERN V=S R=99 ;\n*PROC PRINT;\n   PROC GPLOT      DATA = TEST2       /*GOUT=MYCAT.GRAPH*/ ;\n       AXIS1 LABEL=('AVG CPU' )\n             ORDER= 0 TO 100 BY 20 ;\n       AXIS2 LABEL=('DAYS' )\n             ORDER= 0 TO 40  BY 1  ;\n     PLOT AVGCPU*GNUM    /\n        VAXIS= AXIS1\n        HAXIS= AXIS2\n        NAME='D2CPU'   DES='AVG CPU UTIL BY DAY'\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2M1TEST": {"ttr": 1796, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\nGOPTIONS NOCHARACTERS;\nGOPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n  'AVGERAGE CPU UTILIZATION BY DAY 3090-400E';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN\n  'JAN - FEB 1989 AVGERAGE CPU UTILIZATION ';\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN\n  'D2M1CPU  SOURCE:RMF DATA. SER NO. NN1596';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.UTM18901\n      SASDB.UTM18902\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8901) ;\n%INCLUDE DD1(EX8902) ;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT;\nGHH  = HH;\nGDAT = S70DAT;\n OUTPUT TEST0    ;\nRETAIN;\nRETURN;\n PROC PRINT;\n PROC MEANS   NOPRINT;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGCPU;\n PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=RED   I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=GREEN I=JOIN V=DIAMOND ;\n*ATTERN V=S R=99 ;\n PROC PRINT;\n   PROC GPLOT      DATA = TEST2       /*GOUT=MYCAT.GRAPH*/ ;\n       AXIS1 LABEL=('AVG CPU' )\n             ORDER= 0 TO 100 BY 20 ;\n       AXIS2 LABEL=('DAYS' )\n             ORDER= 0 TO 40  BY 1  ;\n     PLOT AVGCPU*GNUM    /\n        VAXIS= AXIS1\n        HAXIS= AXIS2\n        NAME='D2CPU'   DES='AVG CPU UTIL BY DAY'\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2PPS": {"ttr": 1799, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=C H=1 F=NONE C=CYAN  ' PAGES/SECOND SYSTEM 3 (TSO/BATCH) ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n   ' JAN -MAY 12, 1989   AVERAGE PAGES/SECOND ';\nFOOTNOTE1 J=L H=1 F=NONE C=BLACK 'D2PPS   SOURCE:RMF DATA. SYSTEM 3';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'TECHNICAL SUPPORT  '\n          J=R H=1 F=NONE C=CYAN 'NOON HOUR EXCLUDED ';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 71'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0718810\n*              SASDB.P0718811\n*              SASDB.P0718812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GPGSEC);\n  SET SASDB.P0718901\n      SASDB.P0718902\n      SASDB.P0718903\n      SASDB.P0718904\n      SASDB.P071WK01\n      SASDB.P071WK02\n;\n* EXCLUDE 2ND AND 3RD SHIFTS                    *;\n   IF S71IST LT 090000 THEN DELETE ;\n   IF S71IST GT 155000 THEN DELETE ;\n* EXCLUDE LUNCH TIME                            *;\nIF S71IST GE 120000 AND S71IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX718901) ;\n%INCLUDE DD1(EX718902) ;\n%INCLUDE DD1(EX718903) ;\n%INCLUDE DD1(EX718904) ;\n%INCLUDE DD1(EX718905) ;\n HH = FLOOR(S71IST/10000);\nGPGSEC = PGSEC;\nGHH  = HH    ;\nGDAT = S71DAT ;\n OUTPUT TEST0;\nRETAIN;\nRETURN;\n PROC MEANS;\n  VAR GPGSEC;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGPSEC;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGPSEC);\n  SET TEST1  ;\n GNUM = _N_ ;\nOUTPUT TEST2 ;\n RETURN ;\n*PROC PRINT DATA=TEST1;\n   PROC GPLOT      DATA = TEST2      /*GOUT=MYCAT.GRAPH*/;\n    SYMBOL1 W=1 C=RED   I=JOIN V=DIAMOND ;\n    SYMBOL2 W=1 C=CYAN  I=JOIN V=SQUARE  ;\n   PLOT AVGPSEC*GNUM      /\n                            VAXIS= 0 TO 400 BY 50\n  ;\nRUN;\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2PPS2": {"ttr": 1802, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\n*OPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\n*OPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=C H=1 F=NONE C=CYAN  ' PAGES/SECOND SYSTEM 2 (CICS) ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n   ' JAN -MAY 26, 1989   AVERAGE PAGES/SECOND ';\nFOOTNOTE1 J=L H=1 F=NONE C=BLACK 'D2PPS2: RMF DATA. SYSTEM 2';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'TECHNICAL SUPPORT  '\n          J=R H=1 F=NONE C=CYAN 'NOON HOUR EXCLUDED ';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 71'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P1718810\n*              SASDB.P1718811\n*              SASDB.P1718812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GPGSEC);\n  SET SASDB.P1718901\n      SASDB.P1718902\n      SASDB.P1718903\n      SASDB.P1718904\n      SASDB.P171WK01\n      SASDB.P171WK02\n      SASDB.P171WK03\n      SASDB.P171WK04\n;\n* EXCLUDE 2ND AND 3RD SHIFTS                    *;\n   IF S71IST LT 090000 THEN DELETE ;\n   IF S71IST GT 155000 THEN DELETE ;\n* EXCLUDE LUNCH TIME                            *;\nIF S71IST GE 120000 AND S71IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX718901) ;\n%INCLUDE DD1(EX718902) ;\n%INCLUDE DD1(EX718903) ;\n%INCLUDE DD1(EX718904) ;\n%INCLUDE DD1(EX718905) ;\n HH = FLOOR(S71IST/10000);\nGPGSEC = PGSEC;\nGHH  = HH    ;\nGDAT = S71DAT ;\n OUTPUT TEST0;\nRETAIN;\nRETURN;\n PROC MEANS;\n  VAR GPGSEC;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGPSEC;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGPSEC);\n  SET TEST1  ;\n GNUM = _N_ ;\nOUTPUT TEST2 ;\n RETURN ;\n*PROC PRINT DATA=TEST1;\n   PROC GPLOT      DATA = TEST2      /*GOUT=MYCAT.GRAPH*/;\n    SYMBOL1 W=1 C=RED   I=JOIN V=DIAMOND ;\n    SYMBOL2 W=1 C=CYAN  I=JOIN V=SQUARE  ;\n   PLOT AVGPSEC*GNUM      /\n                            VAXIS= 0 TO 400 BY 50\n  ;\nRUN;\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2PPS3": {"ttr": 1805, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*OPTIONS NOTEXT82;\n*OPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\n*OPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=C H=1 F=NONE C=CYAN  ' PAGES/SECOND SYSTEM 3 (TSO/BATCH) ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n   ' JAN -MAY 26, 1989   AVERAGE PAGES/SECOND ';\nFOOTNOTE1 J=L H=1 F=NONE C=BLACK 'D2PPS3: RMF DATA. SYSTEM 3';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'TECHNICAL SUPPORT  '\n          J=R H=1 F=NONE C=CYAN 'NOON HOUR EXCLUDED ';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 71'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0718810\n*              SASDB.P0718811\n*              SASDB.P0718812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GPGSEC);\n  SET SASDB.P0718901\n      SASDB.P0718902\n      SASDB.P0718903\n      SASDB.P0718904\n      SASDB.P071WK01\n      SASDB.P071WK02\n      SASDB.P071WK03\n      SASDB.P071WK04\n;\n* EXCLUDE 2ND AND 3RD SHIFTS                    *;\n   IF S71IST LT 090000 THEN DELETE ;\n   IF S71IST GT 155000 THEN DELETE ;\n* EXCLUDE LUNCH TIME                            *;\nIF S71IST GE 120000 AND S71IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX718901) ;\n%INCLUDE DD1(EX718902) ;\n%INCLUDE DD1(EX718903) ;\n%INCLUDE DD1(EX718904) ;\n%INCLUDE DD1(EX718905) ;\n HH = FLOOR(S71IST/10000);\nGPGSEC = PGSEC;\nGHH  = HH    ;\nGDAT = S71DAT ;\n OUTPUT TEST0;\nRETAIN;\nRETURN;\n PROC MEANS;\n  VAR GPGSEC;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGPSEC;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGPSEC);\n  SET TEST1  ;\n GNUM = _N_ ;\nOUTPUT TEST2 ;\n RETURN ;\n*PROC PRINT DATA=TEST1;\n   PROC GPLOT      DATA = TEST2      /*GOUT=MYCAT.GRAPH*/;\n    SYMBOL1 W=1 C=RED   I=JOIN V=DIAMOND ;\n    SYMBOL2 W=1 C=CYAN  I=JOIN V=SQUARE  ;\n   PLOT AVGPSEC*GNUM      /\n                            VAXIS= 0 TO 400 BY 50\n  ;\nRUN;\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2RT2": {"ttr": 1808, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n  'DEC 1988 TSO RESPONSE TIME BY PERIOD';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'RED LINE IS AVERAGE RESPONSE TIME';\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN 'D2RT2  SOURCE:RMF DATA SYSTEM 1';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 72'S\n*       PRODUCES A GRAPH\n*\n*    USE   SET SASDB.P0P2YYMM FOR PERFORMANCE GROUP 2, AND\n*     USE  SET SASDB.P0P3YYMM FOR PERFORMANCE GROUP 3.\n*     WHERE YY IS THE YEAR (E.G. 88) AND MM IS THE MONTH (E.G. 10).\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0P28810\n*              SASDB.P0P28811\n*              SASDB.P0P28812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GRTP1 GRTP2 GRTP3 GRTTOT) ;\n  SET SASDB.P0P28807\n      SASDB.P0P28808\n      SASDB.P0P28809\n      SASDB.P0P28810\n      SASDB.P0P28811\n      SASDB.P0P28812\n  ;\n   IF S72IST LT 090000 THEN DELETE ;\n   IF S72IST GT 155000 THEN DELETE ;\n%INCLUDE DD1(EX728807) ;\n%INCLUDE DD1(EX728808) ;\n%INCLUDE DD1(EX728809) ;\n%INCLUDE DD1(EX728810) ;\n%INCLUDE DD1(EX728811) ;\n%INCLUDE DD1(EX728812) ;\n HH = FLOOR(S72IST/10000);\nGRTP1 = RTP1;\nGRTP2 = RTP2;\nGRTP3 = RTP3;\nGRTTOT= RTTOT;\nGHH  = HH ;\nGDAT = S72DAT;\n OUTPUT TEST0;\nRETAIN;\nRETURN;\n PROC PRINT DATA=TEST0;\n PROC MEANS;\n  VAR GRTP1 GRTP2 GRTP3 GRTTOT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=ARTP1 ARTP2 ARTP3 ARTTOT;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM ARTP1 ARTP2 ARTP3 ARTTOT);\n  SET TEST1\n  ;\nGNUM = _N_ ;\nRETURN ;\n*PROC PRINT ;\nSYMBOL1 W=1 C=YELLOW I=JOIN V=DIAMOND ;\nSYMBOL2 W=1 C=CYAN   I=JOIN V=SQUARE  ;\nSYMBOL3 W=1 C=GREEN  I=JOIN V=STAR    ;\nSYMBOL4 W=1 C=RED    I=JOIN V=CARTOG  ;\n*ATTERN V=S R=99 ;\n   PROC GPLOT      DATA = TEST2 /*GOUT=MYCAT.GRAPH*/ ;\n        PLOT ARTP1*GNUM = 1\n             ARTP2*GNUM = 2\n             ARTP3*GNUM = 3\n             ARTTOT*GNUM= 4  / OVERLAY\n  ;\nRUN;\n\n*       VAXIS= 0 TO 4.0 BY .15;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2RT2P1": {"ttr": 2049, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n  'DEC 1988 TSO RESPONSE TIME 1ST PERIOD';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN\n  'GREEN=MAX RED=AVG BLUE=MIN';\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN 'D2RT2  SOURCE:RMF DATA SYSTEM 3';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 72'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0728810\n*              SASDB.P0728811\n*              SASDB.P0728812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GRTP1 GRTP2 GRTP3 GRTTOT) ;\n  SET SASDB.P0P28812\n;\n   IF S72IST LT 090000 THEN DELETE ;\n   IF S72IST GT 155000 THEN DELETE ;\n* -EXCLUDE LUNCH TIME                           *;\nIF S72IST GE 120000 AND S72IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8812)  ;\n HH = FLOOR(S72IST/10000);\nGRTP1 = RTP1;\nGRTP2 = RTP2;\nGRTP3 = RTP3;\nGRTTOT= RTTOT;\nGHH  = HH ;\nGDAT = S72DAT;\n OUTPUT TEST0;\nRETAIN;\nRETURN;\n PROC MEANS   NOPRINT    ;\n  VAR GRTP1 GRTP2 GRTP3 GRTTOT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGP1 AVGP2 AVGP3 AVGTOT\n                   MIN =MINP1 MINP2 MINP3 MINTOT\n                   MAX =MAXP1 MAXP2 MAXP3 MAXTOT\n     ;\n PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGP1 AVGP2 AVGP3 AVGTOT\n                       MINP1 MINP2 MINP3 MINTOT\n                       MAXP1 MAXP2 MAXP3 MAXTOT\n    );\n  SET TEST1\n  ;\nGNUM = _N_ ;\nRETURN ;\nSYMBOL1 W=1 C=RED   I=JOIN V=DIAMOND ;\nSYMBOL2 W=1 C=CYAN  I=JOIN V=SQUARE  ;\nSYMBOL3 W=1 C=GREEN I=JOIN V=STAR    ;\nSYMBOL4 W=1 C=RED   I=JOIN V=CARTOG  ;\n*ATTERN V=S R=99 ;\n   PROC GPLOT      DATA = TEST2  /*GOUT=MYCAT.GRAPH*/ ;\n        PLOT AVGP1*GNUM = 1\n             MINP1*GNUM = 2\n             MAXP1*GNUM = 3   /OVERLAY\n        VAXIS= 0 TO 2.0 BY  .2\n  ;\nRUN;\n\n*       VAXIS= 0 TO 4.0 BY .15;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2RT3": {"ttr": 2052, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n  'JUL - DEC 1988 TSO RESPONSE TIME BY PERIOD/PG3';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'RED LINE IS AVERAGE RESPONSE TIME';\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN 'D2RT3  SOURCE:RMF DATA SYSTEM 1';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 72'S\n*       PRODUCES A GRAPH\n*\n*    USE   SET SASDB.P0P2YYMM FOR PERFORMANCE GROUP 2, AND\n*     USE  SET SASDB.P0P3YYMM FOR PERFORMANCE GROUP 3.\n*     WHERE YY IS THE YEAR (E.G. 88) AND MM IS THE MONTH (E.G. 10).\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0P28810\n*              SASDB.P0P28811\n*              SASDB.P0P28812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GRTP1 GRTP2 GRTP3 GRTTOT) ;\n  SET SASDB.P0P38807\n      SASDB.P0P38808\n      SASDB.P0P38809\n      SASDB.P0P38810\n      SASDB.P0P38811\n      SASDB.P0P38812\n  ;\n   IF S72IST LT 090000 THEN DELETE ;\n   IF S72IST GT 155000 THEN DELETE ;\n%INCLUDE DD1(EX728807) ;\n%INCLUDE DD1(EX728808) ;\n%INCLUDE DD1(EX728809) ;\n%INCLUDE DD1(EX728810) ;\n%INCLUDE DD1(EX728811) ;\n%INCLUDE DD1(EX728812) ;\n HH = FLOOR(S72IST/10000);\nGRTP1 = RTP1;\nGRTP2 = RTP2;\nGRTP3 = RTP3;\nGRTTOT= RTTOT;\nGHH  = HH ;\nGDAT = S72DAT;\n OUTPUT TEST0;\nRETAIN;\nRETURN;\n PROC PRINT ;\n PROC MEANS;\n  VAR GRTP1 GRTP2 GRTP3 GRTTOT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=ARTP1 ARTP2 ARTP3 ARTTOT;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM ARTP1 ARTP2 ARTP3 ARTTOT);\n  SET TEST1\n  ;\nGNUM = _N_ ;\nRETURN ;\n*PROC PRINT ;\nSYMBOL1 W=1 C=YELLOW I=JOIN V=DIAMOND ;\nSYMBOL2 W=1 C=CYAN   I=JOIN V=SQUARE  ;\nSYMBOL3 W=1 C=GREEN  I=JOIN V=STAR    ;\nSYMBOL4 W=1 C=RED    I=JOIN V=CARTOG  ;\n*ATTERN V=S R=99 ;\n   PROC GPLOT      DATA = TEST2 /*GOUT=MYCAT.GRAPH*/ ;\n        PLOT ARTP1*GNUM = 1\n             ARTP2*GNUM = 2\n             ARTP3*GNUM = 3\n             ARTTOT*GNUM= 4  / OVERLAY\n  ;\nRUN;\n\n*       VAXIS= 0 TO 4.0 BY .15;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2TMM": {"ttr": 2055, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n          'DEC 1988 AVG MAX TSO USERS/DAY     '\n ;\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'D2TMM  AVG OF MAX TSO USERS';\n*\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0708810\n*              SASDB.P0708811\n*              SASDB.P0708812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TMM8701\n       (KEEP=GDAT GHH GTMM GNUM);\n  SET SASDB.P0708812\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 150000 THEN DELETE ;\n* -LUNCH TIME                                   *;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8812) ;\n HH = FLOOR(S70IST/10000);\nGTMM = S70TMM ;\nGHH  = HH ;\nGDAT = S70DAT ;\n OUTPUT TMM8701;\nRETAIN;\nRETURN;\n   PROC PRINT ;\n PROC MEANS NOPRINT;\n  VAR GTMM;\n  BY GDAT;\n  OUTPUT OUT=TEST2 MEAN=AVGTMM;\n PROC PRINT DATA=TEST2;\nSYMBOL1 W=1 C=GREEN I=JOIN V=DIAMOND ;\nSYMBOL2 W=1 C=RED   I=JOIN V=STAR ;\n   PROC GPLOT      DATA = TEST2     /*GOUT=MYCAT.GRAPH*/;\n        PLOT AVGTMM*GDAT    /\n        VAXIS= 0 TO 200 BY 20\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2TMMR": {"ttr": 2057, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\n*PTIONS GDEST=U1 GCLASS=S  /* NEEDED FOR VPS*/ ;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*VPS  */ ;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n          'JUL-DEC 1988 AVG MAX TSO USERS/DAY     '\n ;\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'D2TMM  AVG OF MAX TSO USERS';\n*\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0708810\n*              SASDB.P0708811\n*              SASDB.P0708812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TMM8701\n       (KEEP=GDAT GHH GTMM GNUM);\n  SET SASDB.P0708807\n      SASDB.P0708808\n      SASDB.P0708809\n      SASDB.P0708810\n      SASDB.P0708811\n      SASDB.P0708812\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 150000 THEN DELETE ;\n* -LUNCH TIME                                   *;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8807) ;\n%INCLUDE DD1(EX8808) ;\n%INCLUDE DD1(EX8809) ;\n%INCLUDE DD1(EX8810) ;\n%INCLUDE DD1(EX8811) ;\n%INCLUDE DD1(EX8812) ;\n HH = FLOOR(S70IST/10000);\nGTMM = S70TMM ;\nGHH  = HH ;\nGDAT = S70DAT ;\n OUTPUT TMM8701;\nRETAIN;\nRETURN;\n   PROC PRINT ;\n PROC MEANS NOPRINT;\n  VAR GTMM;\n  BY GDAT;\n  OUTPUT OUT=TEST2 MEAN=AVGTMM;\n PROC PRINT DATA=TEST2;\nSYMBOL1 W=1 C=GREEN I=JOIN V=DIAMOND ;\nSYMBOL2 W=1 C=RED   I=JOIN V=STAR ;\n   PROC GPLOT      DATA = TEST2     /*GOUT=MYCAT.GRAPH*/;\n        PLOT AVGTMM*GDAT    /\n        VAXIS= 0 TO 200 BY 20\n  ;\n  DATA TESTR\n       (KEEP=GDAT GNUM AVGTMM);\nSET TEST2;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=GREEN I=JOIN V=DIAMOND L=4;\nSYMBOL2 W=1 C=RED   I=JOIN V=STAR    ;\n  PROC GLM ;\n  MODEL AVGTMM= GNUM/P;\n  OUTPUT  PREDICTED = PAVGTMM\n          RESIDUAL = RESID;\nPROC PRINT;\n  PROC GPLOT;\n   PLOT AVGTMM*GNUM   PAVGTMM*GNUM   / OVERLAY\n        VAXIS= 0 TO 200 BY 20;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "D2TMMX": {"ttr": 2060, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n          'JUL-DEC 1988 AVG MAX TSO USERS/DAY     '\n ;\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN 'D2TMM  AVG OF MAX TSO USERS';\n*\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0708810\n*              SASDB.P0708811\n*              SASDB.P0708812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TMM8701\n       (KEEP=GDAT GHH GTMM GNUM);\n  SET SASDB.P0708807\n      SASDB.P0708808\n      SASDB.P0708809\n      SASDB.P0708810\n      SASDB.P0708811\n      SASDB.P0708812\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 150000 THEN DELETE ;\n* -LUNCH TIME                                   *;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8807) ;\n%INCLUDE DD1(EX8808) ;\n%INCLUDE DD1(EX8809) ;\n%INCLUDE DD1(EX8810) ;\n%INCLUDE DD1(EX8811) ;\n%INCLUDE DD1(EX8812) ;\n HH = FLOOR(S70IST/10000);\nGTMM = S70TMM ;\nGHH  = HH ;\nGDAT = S70DAT ;\n OUTPUT TMM8701;\nRETAIN;\nRETURN;\n   PROC PRINT ;\n PROC MEANS NOPRINT;\n  VAR GTMM;\n  BY GDAT;\n  OUTPUT OUT=TEST2 MEAN=AVGTMM;\n PROC PRINT DATA=TEST2;\nSYMBOL1 W=1 C=GREEN I=JOIN V=DIAMOND ;\nSYMBOL2 W=1 C=RED   I=JOIN V=STAR ;\n   PROC GPLOT      DATA = TEST2     /*GOUT=MYCAT.GRAPH*/;\n        PLOT AVGTMM*GDAT    /\n        VAXIS= 0 TO 200 BY 20\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX718901": {"ttr": 2063, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -JAN 1989 EXCLUSION DATES (SAT. SUN AND HOLIDAYS) *;\n   IF S71DAT = 0089001 THEN DELETE ;\n   IF S71DAT = 0089002 THEN DELETE ;\n   IF S71DAT = 0089007 THEN DELETE ;\n   IF S71DAT = 0089008 THEN DELETE ;\n   IF S71DAT = 0089014 THEN DELETE ;\n   IF S71DAT = 0089015 THEN DELETE ;\n   IF S71DAT = 0089016 THEN DELETE ;\n   IF S71DAT = 0089021 THEN DELETE ;\n   IF S71DAT = 0089022 THEN DELETE ;\n   IF S71DAT = 0089028 THEN DELETE ;\n   IF S71DAT = 0089029 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX718902": {"ttr": 2065, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -FEB 1989 EXCLUSION DATES (SAT. SUN AND HOLIDAYS) *;\n   IF S71DAT = 0089035 THEN DELETE ;\n   IF S71DAT = 0089036 THEN DELETE ;\n   IF S71DAT = 0089042 THEN DELETE ;\n   IF S71DAT = 0089043 THEN DELETE ;\n   IF S71DAT = 0089044 THEN DELETE ;\n   IF S71DAT = 0089049 THEN DELETE ;\n   IF S71DAT = 0089050 THEN DELETE ;\n   IF S71DAT = 0089051 THEN DELETE ;\n   IF S71DAT = 0089056 THEN DELETE ;\n   IF S71DAT = 0089057 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX718903": {"ttr": 2067, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -MAR 1989 EXCLUSION DATES (SAT SUN HOLIDAYS) *;\n   IF S71DAT = 0089063 THEN DELETE ;\n   IF S71DAT = 0089064 THEN DELETE ;\n   IF S71DAT = 0089070 THEN DELETE ;\n   IF S71DAT = 0089071 THEN DELETE ;\n   IF S71DAT = 0089077 THEN DELETE ;\n   IF S71DAT = 0089078 THEN DELETE ;\n   IF S71DAT = 0089083 THEN DELETE ;\n   IF S71DAT = 0089084 THEN DELETE ;\n   IF S71DAT = 0089085 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX718904": {"ttr": 2069, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -APR 1989 EXCLUSION DATES (SAT SUN AND HOLIDAYS) *;\n   IF S71DAT = 0089091 THEN DELETE ;\n   IF S71DAT = 0089092 THEN DELETE ;\n   IF S71DAT = 0089098 THEN DELETE ;\n   IF S71DAT = 0089099 THEN DELETE ;\n   IF S71DAT = 0089105 THEN DELETE ;\n   IF S71DAT = 0089106 THEN DELETE ;\n   IF S71DAT = 0089112 THEN DELETE ;\n   IF S71DAT = 0089113 THEN DELETE ;\n   IF S71DAT = 0089119 THEN DELETE ;\n   IF S71DAT = 0089120 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX718905": {"ttr": 2071, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -MAY 1989 EXCLUSION DATES (SAT, SUN, AND HOLIDAYS) *;\n   IF S71DAT = 0089126 THEN DELETE ;\n   IF S71DAT = 0089127 THEN DELETE ;\n   IF S71DAT = 0089133 THEN DELETE ;\n   IF S71DAT = 0089134 THEN DELETE ;\n   IF S71DAT = 0089140 THEN DELETE ;\n   IF S71DAT = 0089141 THEN DELETE ;\n   IF S71DAT = 0089147 THEN DELETE ;\n   IF S71DAT = 0089148 THEN DELETE ;\n   IF S71DAT = 0089149 THEN DELETE /*MEMORIAL DAY*/;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX728811": {"ttr": 2073, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -NOV 1988 EXCLUSION DATES (ALL EXCEPT T/W/TH NON-HOLIDAYS) *;\n   IF S72DAT = 0088309 THEN DELETE ;\n   IF S72DAT = 0088310 THEN DELETE ;\n   IF S72DAT = 0088311 THEN DELETE ;\n   IF S72DAT = 0088312 THEN DELETE ;\n   IF S72DAT = 0088316 THEN DELETE ;\n   IF S72DAT = 0088317 THEN DELETE ;\n   IF S72DAT = 0088318 THEN DELETE ;\n   IF S72DAT = 0088319 THEN DELETE ;\n   IF S72DAT = 0088323 THEN DELETE ;\n   IF S72DAT = 0088324 THEN DELETE ;\n   IF S72DAT = 0088325 THEN DELETE ;\n   IF S72DAT = 0088326 THEN DELETE ;\n   IF S72DAT = 0088329 THEN DELETE ;\n   IF S72DAT = 0088330 THEN DELETE ;\n   IF S72DAT = 0088331 THEN DELETE ;\n   IF S72DAT = 0088332 THEN DELETE ;\n   IF S72DAT = 0088333 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX728812": {"ttr": 2305, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -DEC 1988 EXCLUSION DATES (ALL EXCEPT T/W/TH NON-HOLIDAYS) *;\n   IF S72DAT = 0088337 THEN DELETE ;\n   IF S72DAT = 0088338 THEN DELETE ;\n   IF S72DAT = 0088339 THEN DELETE ;\n   IF S72DAT = 0088340 THEN DELETE ;\n   IF S72DAT = 0088344 THEN DELETE ;\n   IF S72DAT = 0088345 THEN DELETE ;\n   IF S72DAT = 0088346 THEN DELETE ;\n   IF S72DAT = 0088347 THEN DELETE ;\n   IF S72DAT = 0088351 THEN DELETE ;\n   IF S72DAT = 0088352 THEN DELETE ;\n   IF S72DAT = 0088353 THEN DELETE ;\n   IF S72DAT = 0088354 THEN DELETE ;\n   IF S72DAT = 0088358 THEN DELETE ;\n   IF S72DAT = 0088359 THEN DELETE ;\n   IF S72DAT = 0088360 THEN DELETE ;\n   IF S72DAT = 0088361 THEN DELETE ;\n   IF S72DAT = 0088365 THEN DELETE ;\n   IF S72DAT = 0088366 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX728901": {"ttr": 2307, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -JAN 1989 EXCLUSION DATES (ALL EXCEPT T/W/TH NON-HOLIDAYS) *;\n   IF S71DAT = 0089001 THEN DELETE ;\n   IF S71DAT = 0089002 THEN DELETE ;\n   IF S71DAT = 0089007 THEN DELETE ;\n   IF S71DAT = 0089008 THEN DELETE ;\n   IF S71DAT = 0089014 THEN DELETE ;\n   IF S71DAT = 0089015 THEN DELETE ;\n   IF S71DAT = 0089016 THEN DELETE ;\n   IF S71DAT = 0089020 THEN DELETE ;\n   IF S71DAT = 0089022 THEN DELETE ;\n   IF S71DAT = 0089028 THEN DELETE ;\n   IF S71DAT = 0089029 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX728902": {"ttr": 2309, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -MAR 1989 EXCLUSION DATES (ALL EXCEPT M-FRI  NON-HOLIDAYS) *;\n   IF S71DAT = 0089063 THEN DELETE ;\n   IF S71DAT = 0089064 THEN DELETE ;\n   IF S71DAT = 0089070 THEN DELETE ;\n   IF S71DAT = 0089071 THEN DELETE ;\n   IF S71DAT = 0089077 THEN DELETE ;\n   IF S71DAT = 0089078 THEN DELETE ;\n   IF S71DAT = 0089083 THEN DELETE ;\n   IF S71DAT = 0089084 THEN DELETE ;\n   IF S71DAT = 0089085 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX8811": {"ttr": 2311, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -NOV 1988 EXCLUSION DATES (ALL EXCEPT T/W/TH NON-HOLIDAYS) *;\n   IF S70DAT = 0088309 THEN DELETE ;\n   IF S70DAT = 0088310 THEN DELETE ;\n   IF S70DAT = 0088311 THEN DELETE ;\n   IF S70DAT = 0088312 THEN DELETE ;\n   IF S70DAT = 0088316 THEN DELETE ;\n   IF S70DAT = 0088317 THEN DELETE ;\n   IF S70DAT = 0088318 THEN DELETE ;\n   IF S70DAT = 0088319 THEN DELETE ;\n   IF S70DAT = 0088323 THEN DELETE ;\n   IF S70DAT = 0088324 THEN DELETE ;\n   IF S70DAT = 0088325 THEN DELETE ;\n   IF S70DAT = 0088326 THEN DELETE ;\n   IF S70DAT = 0088329 THEN DELETE ;\n   IF S70DAT = 0088330 THEN DELETE ;\n   IF S70DAT = 0088331 THEN DELETE ;\n   IF S70DAT = 0088332 THEN DELETE ;\n   IF S70DAT = 0088333 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX8812": {"ttr": 2313, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -DEC 1988 EXCLUSION DATES (ALL EXCEPT T/W/TH NON-HOLIDAYS) *;\n   IF S70DAT = 0088337 THEN DELETE ;\n   IF S70DAT = 0088338 THEN DELETE ;\n   IF S70DAT = 0088339 THEN DELETE ;\n   IF S70DAT = 0088340 THEN DELETE ;\n   IF S70DAT = 0088344 THEN DELETE ;\n   IF S70DAT = 0088345 THEN DELETE ;\n   IF S70DAT = 0088346 THEN DELETE ;\n   IF S70DAT = 0088347 THEN DELETE ;\n   IF S70DAT = 0088351 THEN DELETE ;\n   IF S70DAT = 0088352 THEN DELETE ;\n   IF S70DAT = 0088353 THEN DELETE ;\n   IF S70DAT = 0088354 THEN DELETE ;\n   IF S70DAT = 0088358 THEN DELETE ;\n   IF S70DAT = 0088359 THEN DELETE ;\n   IF S70DAT = 0088360 THEN DELETE ;\n   IF S70DAT = 0088361 THEN DELETE ;\n   IF S70DAT = 0088365 THEN DELETE ;\n   IF S70DAT = 0088366 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX8901": {"ttr": 2315, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -JAN 1989 EXCLUSION DATES (SAT. SUN AND HOLIDAYS) *;\n   IF S70DAT = 0089001 THEN DELETE ;\n   IF S70DAT = 0089002 THEN DELETE ;\n   IF S70DAT = 0089007 THEN DELETE ;\n   IF S70DAT = 0089008 THEN DELETE ;\n   IF S70DAT = 0089014 THEN DELETE ;\n   IF S70DAT = 0089015 THEN DELETE ;\n   IF S70DAT = 0089016 THEN DELETE ;\n   IF S70DAT = 0089021 THEN DELETE ;\n   IF S70DAT = 0089022 THEN DELETE ;\n   IF S70DAT = 0089028 THEN DELETE ;\n   IF S70DAT = 0089029 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX8902": {"ttr": 2317, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -FEB 1989 EXCLUSION DATES (SAT. SUN AND HOLIDAYS) *;\n   IF S70DAT = 0089035 THEN DELETE ;\n   IF S70DAT = 0089036 THEN DELETE ;\n   IF S70DAT = 0089042 THEN DELETE ;\n   IF S70DAT = 0089043 THEN DELETE ;\n   IF S70DAT = 0089044 THEN DELETE ;\n   IF S70DAT = 0089049 THEN DELETE ;\n   IF S70DAT = 0089050 THEN DELETE ;\n   IF S70DAT = 0089051 THEN DELETE ;\n   IF S70DAT = 0089056 THEN DELETE ;\n   IF S70DAT = 0089057 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX8903": {"ttr": 2319, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -MAR 1989 EXCLUSION DATES (SAT SUN HOLIDAYS) *;\n   IF S70DAT = 0089063 THEN DELETE ;\n   IF S70DAT = 0089064 THEN DELETE ;\n   IF S70DAT = 0089070 THEN DELETE ;\n   IF S70DAT = 0089071 THEN DELETE ;\n   IF S70DAT = 0089077 THEN DELETE ;\n   IF S70DAT = 0089078 THEN DELETE ;\n   IF S70DAT = 0089083 THEN DELETE ;\n   IF S70DAT = 0089084 THEN DELETE ;\n   IF S70DAT = 0089085 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX8904": {"ttr": 2321, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -APR 1989 EXCLUSION DATES (SAT SUN AND HOLIDAYS) *;\n   IF S70DAT = 0089091 THEN DELETE ;\n   IF S70DAT = 0089092 THEN DELETE ;\n   IF S70DAT = 0089098 THEN DELETE ;\n   IF S70DAT = 0089099 THEN DELETE ;\n   IF S70DAT = 0089105 THEN DELETE ;\n   IF S70DAT = 0089106 THEN DELETE ;\n   IF S70DAT = 0089112 THEN DELETE ;\n   IF S70DAT = 0089113 THEN DELETE ;\n   IF S70DAT = 0089119 THEN DELETE ;\n   IF S70DAT = 0089120 THEN DELETE ;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EX8905": {"ttr": 2323, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* -MAY 1989 EXCLUSION DATES (SAT, SUN, AND HOLIDAYS) *;\n   IF S70DAT = 0089126 THEN DELETE ;\n   IF S70DAT = 0089127 THEN DELETE ;\n   IF S70DAT = 0089133 THEN DELETE ;\n   IF S70DAT = 0089134 THEN DELETE ;\n   IF S70DAT = 0089140 THEN DELETE ;\n   IF S70DAT = 0089141 THEN DELETE ;\n   IF S70DAT = 0089147 THEN DELETE ;\n   IF S70DAT = 0089148 THEN DELETE ;\n   IF S70DAT = 0089149 THEN DELETE /*MEMORIAL DAY*/;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GOPTIONS": {"ttr": 2325, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\nGOPTIONS HSIZE=8 VSIZE=7;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HHWEEKER": {"ttr": 2327, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n| HHWEEKM - HIGH HOURLY WEEK FOR 1 PHYSICAL PROCESSOR COMLEX        |\n|                                                                   |\n*-------------------------------------------------------------------*\n*\n*    THIS SAS JOB TAKES THE FILE CREATED IN MEMBER RMF70W OR CPTOTW\n*       AND PRODUCES A LISTING OF AVGCPU AND MAXCPU BY DATE\n*       NOON HOUR EXCLUDED.\n*\n*    INPUT EITHER UTM1WK02 OR P0..WK01\n*\n;\n  DATA       TEST3\n       (KEEP=GDAT GHH GCPU_UT);\n* FORMAT GDAT DATE7.;\n  SET SASDB.UTM1WK02 ;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n   IF S70IST GE 120000 AND\n      S70IST LT 130000 THEN DELETE;\n   IF S70INT LT 0500000 THEN DELETE /* THROW OUT SMALL INTERVAL */;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT  ;\nGHH  = HH    ;\nGDAT = S70DAT ;\n OUTPUT       TEST3  ;\nRETAIN;\nRETURN;\n PROC MEANS        ;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST5 MEAN=AVGCPU MAX=MAXCPU;\n PROC PRINT DATA=TEST5;\n*ITLE1 'WEEKLY CPU UTILIZATION SYS P0S3';\nTITLE1 'WEEKLY CPU UTILIZATION FOR 3090-400E';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED IN MEMBER RMF70W\n*       AND PRODUCES A LISTING OF AVGCPU AND MAXCPU BY DATE\n*\n*\n*\n;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HHWEEKM": {"ttr": 2329, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n| HHWEEKM - HIGH HOURLY WEEK FOR 1 PHYSICAL PROCESSOR COMLEX        |\n|                                                                   |\n*-------------------------------------------------------------------*\n*\n*    THIS SAS JOB TAKES THE FILE CREATED IN MEMBER RMF70W OR CPTOTW\n*       AND PRODUCES A LISTING OF AVGCPU AND MAXCPU BY DATE\n*       NOON HOUR EXCLUDED.\n*\n*    INPUT EITHER UTM1WK02 OR P0..WK01\n*\n;\n  DATA       TEST3\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.UTM1WK02 ;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n   IF S70IST GE 120000 AND\n      S70IST LT 130000 THEN DELETE;\n   IF S70INT LT 0500000 THEN DELETE /* THROW OUT SMALL INTERVAL */;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT  ;\nGHH  = HH    ;\nGDAT = S70DAT ;\n OUTPUT       TEST3  ;\nRETAIN;\nRETURN;\n PROC MEANS        ;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST5 MEAN=AVGCPU MAX=MAXCPU;\n PROC PRINT DATA=TEST5;\n*ITLE1 'WEEKLY CPU UTILIZATION SYS P0S3';\nTITLE1 'WEEKLY CPU UTILIZATION FOR 3090-400E';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED IN MEMBER RMF70W\n*       AND PRODUCES A LISTING OF AVGCPU AND MAXCPU BY DATE\n*\n*\n*\n;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HHWEEKMJ": {"ttr": 2331, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAMEA JOB (XX,R412,30,20,05),'HIGH HOURLY CPU  ',MSGLEVEL=(1,1),\n//  CLASS=O,MSGCLASS=A,TIME=(4,10)\n/*ROUTE PRINT RMT20\n//*\n//*  CALCULATE THE HIGH HOURLY CPU UTILIZATION FOR A PROCESSOR\n//*  COMPLEX.\n//*\n//STEP1  EXEC SAS,WORK='40,10',RGN=4096K\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(HHWEEKM)\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,           <==INPUT  (SAS DATASET)\n//   DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JOBCARD": {"ttr": 2333, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOADTP": {"ttr": 2335, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//FILE1    EXEC PGM=IEBGENER\n//*  **********************************************************\n//*  *        LOAD FILE1                                      *\n//*  *        DOCUMENTATION AND INSTRUCTIONS                  *\n//*  **********************************************************\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  DISP=SHR,\n//             DSN=XY.TC.A.SASCPU($FILE1)\n//SYSUT2   DD  UNIT=CART,\n//             DISP=(NEW,KEEP),DSN=FILE1,\n//             VOL=(,RETAIN,SER=TC0001),\n//             LABEL=(1,SL,EXPDT=98000),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=4240)\n//FILE2    EXEC PGM=IEBCOPY\n//*  **********************************************************\n//*  *        LOAD FILE2                                      *\n//*  *        SOURCE PDS                                      *\n//*  **********************************************************\n//SYSPRINT DD  SYSOUT=*\n//OUTDD1   DD  UNIT=CART,\n//             DISP=(NEW,KEEP),DSN=FILE2,\n//             VOL=SER=TC0001,\n//             LABEL=(2,SL,EXPDT=98000),\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=4240)\n//INDD1    DD  DISP=(SHR,KEEP),\n//   DSN=XY.TC.A.SASCPU\n//SYSIN    DD *\n    COPY OUTDD=OUTDD1,INDD=INDD1\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "M1HH": {"ttr": 2337, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\n*OPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*OPTIONS HSIZE=8 VSIZE=7;\nTITLE1 J=C H=1.5 F=SIMPLEX C=WHITE\n  'ANALYSIS OF THE MONTHLY HOURLY AVERAGES';\nTITLE2    J=C H=1 F=SIMPLEX C=WHITE\n  'JANUARY 1989 THROUGH APRIL 1989 : 3090-400E SERIAL # &S70SER';\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE\n  '    M1HH: TECHNICAL SUPPORT-NOTE: NOON HOUR EXCLUDED FROM AVERAGE';\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED\n  '    BREAKDOWN OF UTILIZATION BY HOUR FOR EACH MONTH';\nFOOTNOTE3 J=L H=1 F=SIMPLEX C=RED\n                  '    THE MAXIMUM UTILIZATION FOR 1 HOUR';\nFOOTNOTE4 J=L H=1 F=SIMPLEX C=GREEN\n                  '    THE HIGHEST HOURLY AVERAGE';\nFOOTNOTE5 J=L H=1 F=SIMPLEX C=CYAN\n                  '    MONTHLY AVERAGE OF ALL THE HOURS';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY HHMNTHM.\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH HOUR FOR\n*       ONE PHYSICAL PROCESSOR COMPLEX.\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.2\n*\n;\n  DATA TEST0\n       (KEEP=HMAXCPU MAVGCPU MMAXCPU MDATE);\n  SET SASDB.M1JAN89\n      SASDB.M1FEB89\n      SASDB.M1MAR89\n      SASDB.M1APR89\n;\n*PROC PRINT DATA=TEST0;\nSYMBOL1 W=1 C=RED   I=JOIN V=STAR    ;\nSYMBOL2 W=1 C=CYAN  I=JOIN V=DIAMOND    ;\nSYMBOL3 W=1 C=GREEN I=JOIN V=BOX     ;\n  PROC GPLOT;\n   PLOT HMAXCPU*MDATE=3 MAVGCPU*MDATE=2 MMAXCPU*MDATE=1   / OVERLAY\n   VAXIS = 40 TO 100 BY 10\n   HAXIS = 'JAN89'  'FEB89'  'MAR89'  'APR89'\n   VREF  = 75\n   CVREF = RED\n   LVREF = 2\n   ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PGSECC": {"ttr": 2339, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n   'DEC 1988 PAGES/SECOND  BY HOUR. SYSTEM 3 ';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=GREEN\n          'PGSECC  COUNTOUR GRAPH ';\nFOOTNOTE3 J=L H=1 F=NONE C=GREEN\n          'SOURCE: RMF DATA ';\n*\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 71'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0718810\n*              SASDB.P0718811\n*              SASDB.P0718812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*\n;\n  DATA TEST1\n       (KEEP=GDAT GHH GPGSEC);\n  SET SASDB.P0718812\n;\n   IF S71IST LT 090000 THEN DELETE ;\n   IF S71IST GT 150000 THEN DELETE ;\n* -LUNCH TIME                                   *;\nIF S71IST GE 120000 AND S71IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8812) ;\n   IF DATHOLD = . THEN DO ;\n     DATHOLD = S71DAT ;\n     ISTHOLD = S71IST ;\n     PPSHOLD = PGSEC;\n     HHHOLD  = FLOOR(S71IST/10000);\nEND ;\n HH = FLOOR(S71IST/10000);\n IF S71DAT = DATHOLD AND HH = HHHOLD THEN GOTO SAME;\nGPGSEC = PPSHOLD;\nGHH  = HHHOLD;\nGDAT = DATHOLD;\n OUTPUT TEST1;\nPPSHOLD = PGSEC;\nISTHOLD = S71IST;\nDATHOLD = S71DAT;\nHHHOLD  = HH;\nRETAIN;\nRETURN;\nSAME:\n IF PGSEC GT PPSHOLD THEN PPSHOLD = PGSEC;\n RETURN;\n PROC MEANS NOPRINT;\n  VAR GPGSEC;\n  BY GDAT;\n  OUTPUT OUT=TEST2 MEAN=AVGPSEC;\n PROC PRINT DATA=TEST2;\n*ATTERN V=S R=99 ;\n   PROC GCONTOUR   DATA = TEST1      /*GOUT=MYCAT.GRAPH*/;\n        PLOT GDAT*GHH=GPGSEC / PATTERN JOIN\n            COUTLINE = RED\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PPS3D": {"ttr": 2562, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n   'DEC 1988 PAGING RATE ';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=GREEN\n    'PPS3DS  RATE IS BY DAY AND BY HOUR';\nFOOTNOTE3 J=L H=1 F=NONE C=GREEN\n          'SOURCE: RMF DATA. SYSTEM 1';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY RMF71 AND\n*       GRAPHS PAGING RATES.\n*       THIS IS A 3D GRAPH BY HOUR BY DAY. THE NUMBER OF DAYS\n*       DEPENDS ON THE INPUT.\n*\n*       THIS WAS A SCATTER DIAGRAM BUT WAS CHANGED BY MISTAKE\n*  --------------------------------------------------------------\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 71'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0718810\n*              SASDB.P0718811\n*              SASDB.P0718812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST1\n       (KEEP=GDAT GHH GPGSEC);\n  SET SASDB.P0718812\n      ;\n   IF S71IST LT 090000 THEN DELETE ;\n   IF S71IST GT 150000 THEN DELETE ;\n%INCLUDE DD1(EX8812)      ;\n   IF DATHOLD = . THEN DO ;\n     DATHOLD = S71DAT ;\n     ISTHOLD = S71IST ;\n     PPSHOLD = PGSEC;\n     HHHOLD  = FLOOR(S71IST/10000);\nEND ;\n HH = FLOOR(S71IST/10000);\n IF S71DAT = DATHOLD AND HH = HHHOLD THEN GOTO SAME;\nGPGSEC = PPSHOLD;\nGHH  = HHHOLD;\nGDAT = DATHOLD;\n OUTPUT TEST1;\nPPSHOLD = PGSEC;\nISTHOLD = S71IST;\nDATHOLD = S71DAT;\nHHHOLD  = HH;\nRETAIN;\nRETURN;\nSAME:\n IF PGSEC GT PPSHOLD THEN PPSHOLD = PGSEC;\n RETURN;\n PROC PRINT DATA=TEST1  ;\n   PROC G3D   DATA = TEST1        /*GOUT = MYCAT.GRAPH*/  ;\n        PLOT GDAT*GHH=GPGSEC / CAXIS = CYAN\n            CTEXT = CYAN  CTOP = RED    CBOTTOM = CYAN\n            XTICKNUM=7\n            YTICKNUM=5\n            ZTICKNUM=05 ZMIN=0 ZMAX=550\n            GRID\n            TILT=060 ROTATE = 065;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PPS3DS": {"ttr": 2565, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\n*OPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n   'DEC 1988 PAGES/SECOND  BY HOUR. ';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=GREEN\n          'PGSECC  SCATTER GRAPH ';\nFOOTNOTE3 J=L H=1 F=NONE C=GREEN\n          'SOURCE: RMF DATA  SYSTEM 3';\n*\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY RMF71 AND\n*       GRAPHS PAGING RATES.\n*       THIS IS A 3D GRAPH BY HOUR BY DAY. THE NUMBER OF DAYS\n*       DEPENDS ON THE INPUT.\n*\n*       THIS WAS A SCATTER DIAGRAM BUT WAS CHANGED BY MISTAKE\n*  --------------------------------------------------------------\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 71'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0718810\n*              SASDB.P0718811\n*              SASDB.P0718812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n;\n  DATA TEST1\n       (KEEP=GDAT GHH GPGSEC);\n  SET SASDB.P0718812\n      ;\n   IF S71IST LT 090000 THEN DELETE ;\n   IF S71IST GT 150000 THEN DELETE ;\n%INCLUDE DD1(EX8812)  ;\n   IF DATHOLD = . THEN DO ;\n     DATHOLD = S71DAT ;\n     ISTHOLD = S71IST ;\n     PPSHOLD = PGSEC;\n     HHHOLD  = FLOOR(S71IST/10000);\nEND ;\n HH = FLOOR(S71IST/10000);\n IF S71DAT = DATHOLD AND HH = HHHOLD THEN GOTO SAME;\nGPGSEC = PPSHOLD;\nGHH  = HHHOLD;\nGDAT = DATHOLD;\n OUTPUT TEST1;\nPPSHOLD = PGSEC;\nISTHOLD = S71IST;\nDATHOLD = S71DAT;\nHHHOLD  = HH;\nRETAIN;\nRETURN;\nSAME:\n IF PGSEC GT PPSHOLD THEN PPSHOLD = PGSEC;\n RETURN;\n*PROC PRINT DATA=TEST1;\n   PROC G3D   DATA = TEST1;\n     SCATTER GDAT*GHH=GPGSEC /\n            SHAPE = 'PYRAMID'\n            XTICKNUM=7\n            YTICKNUM=3\n            ZTICKNUM=05 ZMIN=0 ZMAX=550\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINT": {"ttr": 2568, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PULL OFF RMF RECORD 72 INFORMATION.  THIS INCLUDES TSO USERS\n//*  CPU TIME BATCH USERS ETC. STORE INFO ON SAS DATA BASE.\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,\n//   DISP=OLD\n//SYSIN DD *\nPROC PRINT DATA = SASDB.S370WK01;\n VAR S70DAT S70INT S70IST CPU_UT S70TMM S70SID;\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINTMEM": {"ttr": 2570, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PRINT OUT A MEMBER\n//*\n//STEP1  EXEC PGM=IEBGENER\n//SYSPRINT DD SYSOUT=A\n//SYSIN    DD DUMMY\n//SYSUT2 DD SYSOUT=A\n//SYSUT1 DD DSN=XY.TC.A.SASCPU(CPUT),\n//   DISP=SHR\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGCPU": {"ttr": 2572, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n 'REGRESSION ANALYSIS OF AVGERAGE CPU UTILIZATION BY DAY JUL-DEC 1988';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=RED\n  'RED LINE IS REGRESSION LINE - NOON HOUR EXCLUDED FROM AVERAGE.';\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN\n  'REGCPU  SOURCE:RMF DATA. SYSTEM 3';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY RMF70\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH DAY.\n*       THE NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n*       DOES A REGRESSION ANALYSIS ON THE ABOVE MENTIONED DATA.\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0708810\n*              SASDB.P0708811\n*              SASDB.P0708812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.1.2  (AKA XA 2.1.2)\n*       WORKS FOR MVS/SP 2.2\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.P0708807\n      SASDB.P0708808\n      SASDB.P0708809\n      SASDB.P0708810\n      SASDB.P0708811\n      SASDB.P0708812\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n* LUNCH TIME                 ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8807) ;\n%INCLUDE DD1(EX8808) ;\n%INCLUDE DD1(EX8809) ;\n%INCLUDE DD1(EX8810) ;\n%INCLUDE DD1(EX8811) ;\n%INCLUDE DD1(EX8812) ;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT;\nGHH  = HH;\nGDAT = S70DAT;\n OUTPUT TEST0    ;\nRETAIN;\nRETURN;\n PROC MEANS   NOPRINT;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGCPU;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=GREEN I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=RED   I=JOIN V=DIAMOND ;\n  PROC GLM ;\n  MODEL AVGCPU= GNUM/P;\n  OUTPUT  PREDICTED = PAVGCPU\n          RESIDUAL = RESID;\nPROC PRINT;\n  PROC GPLOT;\n   PLOT AVGCPU*GNUM   PAVGCPU*GNUM   / OVERLAY;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGM1CPU": {"ttr": 2575, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n 'REGRESSION ANALYSIS OF AVGERAGE CPU UTILIZATION BY DAY JAN-APR 1989';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=RED\n  'RED LINE IS REGRESSION LINE - NOON HOUR EXCLUDED FROM AVERAGE.';\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN\n  'REGM1CPU  SOURCE:RMF DATA. 3090-400E';\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY CPUTOT.\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH DAY FOR\n*       ONE PHYSICAL PROCESSOR COMPLEX.\n*       THE NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n*       DOES A REGRESSION ANALYSIS ON THE ABOVE MENTIONED DATA.\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.2\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.UTM18901\n      SASDB.UTM18902\n      SASDB.UTM18903\n      SASDB.UTM18904\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n* LUNCH TIME                 ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8901) ;\n%INCLUDE DD1(EX8902) ;\n%INCLUDE DD1(EX8903) ;\n%INCLUDE DD1(EX8904) ;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT;\nGHH  = HH;\nGDAT = S70DAT;\n OUTPUT TEST0    ;\nRETAIN;\nRETURN;\n PROC MEANS   NOPRINT;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGCPU;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=GREEN I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=RED   I=JOIN V=DIAMOND ;\n  PROC GLM ;\n  MODEL AVGCPU= GNUM/P;\n  OUTPUT  PREDICTED = PAVGCPU\n          RESIDUAL = RESID;\nPROC PRINT;\n  PROC GPLOT;\n   PLOT AVGCPU*GNUM   PAVGCPU*GNUM   / OVERLAY;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGPPS1": {"ttr": 2578, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\nGOPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=L H=1 F=NONE C=CYAN\n   'REGRESSION ANALYSIS OF AVG PAGES/SEC BY DAY';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=RED\n    'DEC 1988. AVERAGE PAGES PER SEC - RED LINE IS REGRESSION LINE' ;\nFOOTNOTE3 J=L H=1 F=NONE C=CYAN\n    'D2PPS   SOURCE RMF DATA. SYSTEM 3';\n*\n*\n*\n*       DOES A REGRESSION ANALYSIS OF PAGES/ SEC.\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 71'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0718810\n*              SASDB.P0718811\n*              SASDB.P0718812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.1.2  (AKA XA 2.1.2)\n*       WORKS FOR MVS/SP 2.2\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GPGSEC);\n  SET SASDB.P0718812\n;\n   IF S71IST LT 090000 THEN DELETE ;\n   IF S71IST GT 155000 THEN DELETE ;\n* LUNCH TIME   ;\nIF S71IST GE 120000 AND S71IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8812) ;\n HH = FLOOR(S71IST/10000);\nGPGSEC = PGSEC;\nGHH  = HH    ;\nGDAT = S71DAT ;\n OUTPUT TEST0;\nRETAIN;\nRETURN;\n PROC MEANS  NOPRINT;\n  VAR GPGSEC;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGPSEC;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGPSEC);\n  SET TEST1  ;\n GNUM = _N_ ;\nOUTPUT TEST2 ;\n RETURN ;\n*PROC PRINT DATA=TEST1;\n    SYMBOL1 W=1 C=GREEN  I=JOIN V=STAR    ;\n    SYMBOL2 W=1 C=RED   I=JOIN V=DIAMOND ;\n  PROC GLM ;\n  MODEL AVGPSEC = GNUM / P;\n  OUTPUT  OUT=TEST3 PREDICTED = PAVGPSEC\n          RESIDUAL = RESID;\nPROC PRINT;\n* *PROC GPLOT      DATA = TEST2 GOUT=MYCAT.GRAPH;\n  PROC GPLOT ;\n  PLOT AVGPSEC*GNUM   PAVGPSEC*GNUM   / OVERLAY\n                            VAXIS= 0 TO 300 BY 40\n  ;\n* *******                   VAXIS= 0 TO 400 BY 10;\nRUN;\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REGPROC": {"ttr": 2581, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "  DATA TEST2\n       (KEEP=GDAT GNUM AVGCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=GREEN I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=RED   I=JOIN V=DIAMOND ;\n  PROC GLM ;\n  MODEL AVGCPU= GNUM/P;\n  OUTPUT  PREDICTED = PAVGCPU\n          RESIDUAL = RESID;\nPROC PRINT;\n  PROC GPLOT;\n   PLOT AVGCPU*GNUM   PAVGCPU*GNUM   / OVERLAY;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RMF70": {"ttr": 2817, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n|   ONLY LOOKING AT SMF TYPE 70 RECORDS. FOR MVS/XA SYSTEMS         |\n|   DATA MUST BE SORTED BEFORE BEING USED BY                        |\n|         SMF70SID,SMF70DAT,SMF70IST                                |\n|         (JUST USE THE SORT MEMBER)                                |\n|                                                                   |\n|   SMF DATA FOR -TSO  ACTIVITY                                     |\n|                -AVERAGE NUMBER OF BATCH JOBS RUNNING              |\n|                -AVERAGE NUMBER OF OUT AND READY ASIDS             |\n|                -PICKS UP WAIT TIME AND CALCULATES CPU UTILIZATION |\n|                                                                   |\n| ----                       -----                            ----  |\n|   SINCE THE DATA IS SAVED BY SYSTEM ID (SMF ID) THEN THE ONLY     |\n|   THING THAT MAKES THESE PROGRAMS INSTALLATION DEPENDANT ARE      |\n|   1) THE LITERALS FOR CHECKING THE SYSTEM ID                      |\n|       -LOCATED AT THE END OF THE PROGRAM                          |\n|   2) THE MEMBER NAME THAT IS GIVEN TO THE SAS DATASET (ONE FOR    |\n|      EACH SYSTEM)                                                 |\n|       -LOCATED IN THE BEGINING (DATA STATEMENT)                   |\n|        AND AT THE END, FOLLOWING THE \"OUTPUT\" STATEMENTS          |\n|                                                                   |\n|   IN ADDITION, SINCE THE DATA IS NORMALLY STORED BY MONTH         |\n|   THEN THE MEMBER NAMES REFERENCED IN NUMBER 2 ABOVE              |\n|   IS CHANGED SLIGHTLY EACH MONTH TO REFLECT THE MONTH AND YEAR.   |\n| ----                       -----                            ----  |\n|                                                                   |\n|   THIS SAS FILE THEN CAN BE USED AS INPUT TO CREATE A GRAPH       |\n|   EITHER ON THE TERMINAL OR TO A PRINTER USING GDDM.              |\n|                                                                   |\n|   SMF70RTY...... RECORD TYPE.                                     |\n|   SMF70SID...... SID.                                             |\n|   SMF70IST...... TIME RMF MEASUREMENT INTERVAL STARTED IN FORM    |\n|                  0HHMMSSF WHERE F IS THE SIGN.                    |\n|   SMF70DAT...... DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED    |\n|                  (F IS THE SIGN).                                 |\n|   SMF70INT...... DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|   SMF70TMN...... TSO USERS MINIMUM OVER INTERVAL.                 |\n|   SMF70TMM...... TSO USERS MAXIMUM OVER INTERVAL.\n|   SMF70TTT...... TSO USERS TOTAL VALUE OVER INTERVAL.             |\n|                                                                   |\n|                                                                   |\n|   THE VARIABLES THAT ARE SAVE ARE:                                |\n|                                                                   |\n|   S70TMN........ MINIMUM TSO USERS                                |\n|   S70TMM........ MAXIMUM TSO USERS                                |\n|   S70TAV........ AVERAGE TSO USERS                                |\n|   S70TMM........ MAXIMUM TSO USERS                                |\n|   S70BMM........ MAXIMUM BATCH USERS                              |\n|   S70OAV........ AVERAGE NUMBER OF ASIDS OUT AND READY            |\n|   S70IST........ INTERVAL START TIME                              |\n|   S70DAT........ INTERVAL DATE                                    |\n|   S70INT........ LENGTH OF (RMF) INTERVAL                         |\n| | WAIT_PER...... PERCENT OF TIME CPU WAITING -NO LONGER SAVED     |\n| | CPU_UT........ AVG. PERCENT BUSY (1 - WAIT_PER FOR NON PR/SM) OR|\n| |                FROM SMF70PDT FOR PR/SM MACHINES                 |\n| | TOT_UT........ TOTAL UTILIZATION (ALL CPU'S IN PARTITION)       |\n| | NUMCPU........ NUMBER OF LOGICAL PROCESSORS ASSIGNED TO A       |\n| |                PARTITION                                        |\n|   S70SID........ SYSTEM'S SMF ID                                  |\n|                                                                   |\n|   OUTPUT FILE NAME = SID...REC NO...YEAR...MONTH                  |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|    E.G.   S1708811 = S1 ...  70  ...88  ... 11                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.S1708811 TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|          C 708809 708810 ALL                                      |\n|                                                                   |\n|   UPDATES:                                                        |\n|    ADDED S70BMM TO THE DATA STATEMETS. THIS WILL SAVE MAXIMUM     |\n|    BATCH JOBS.                                                    |\n|                                                                   |\n|   UPDATES:  2/23/89                                               |\n|    ADDED ROUTINE TO CALCULATE CPU UTILIZATION FOR PR/SM LOGICAL   |\n|    AND DEDICATED PROCESSORS. NEW VARIABLES ARE:                   |\n|    TOT_UT (TOTAL UTILIZATION                                      |\n|    AND NUMCPU (NUMBER OF PROCESSORS IN THE PARTITION((SMS70BDN)). |\n|    NOTE: FOR NOW WE ARE JUST USING THE 1ST FOUR BYTES OF SMF70LPM |\n|          (THE PARTITION NAME)                                     |\n*-------------------------------------------------------------------*\n;\n   MACRO INPUTIT\n   DATA\n SASDB.P1708902 (KEEP=S70TMN S70TMM S70TAV S70BAV S70OAV S70IST S70DAT\n             S70BMM\n             S70INT WAIT_PER CPU_UT TOT_UT NUMCPU S70SID FLAG )\n SASDB.P0708902 (KEEP=S70TMN S70TMM S70TAV S70BAV S70OAV S70IST S70DAT\n             S70BMM\n             S70INT WAIT_PER CPU_UT TOT_UT NUMCPU S70SID FLAG )\n SASDB.S3708902 (KEEP=S70TMN S70TMM S70TAV S70BAV S70OAV S70IST S70DAT\n             S70BMM\n             S70INT WAIT_PER CPU_UT TOT_UT NUMCPU S70SID FLAG )\n SASDB.S2708902 (KEEP=S70TMN S70TMM S70TAV S70BAV S70OAV S70IST S70DAT\n             S70BMM\n             S70INT WAIT_PER CPU_UT TOT_UT NUMCPU S70SID FLAG )\n SASDB.S1708902 (KEEP=S70TMN S70TMM S70TAV S70BAV S70OAV S70IST S70DAT\n             S70BMM\n             S70INT WAIT_PER CPU_UT TOT_UT NUMCPU S70SID FLAG )\n        ;\n   INFILE SMF LENGTH=L ;\n*  INFORMAT S70IST RMFDUR4. S70INT PDTIME4. ;\n   INPUT @2 ID PIB1. @;\n   IF ID = 70  THEN LINK X5;\n   RETURN;\nX5:\nPOINTER = 1;\nM = -3;\nINPUT @ POINTER\n                SMF70FLG  PIB1.\n             +9 SMF70SID  $CHAR4.\n            +10 SMF70PRS  PIB4.\n            +12 SMF70CPS  PIB4.\n                SMF70CPL  PIB2.\n                SMF70CPN  PIB2.\n                SMF70ASS  PIB4.\n                SMF70ASL  PIB2.\n                SMF70ASN  PIB2.\n                SMF70BCS  PIB4.\n                SMF70BCL  PIB2.\n                SMF70BCN  PIB2.\n                SMF70BVS  PIB4.\n                SMF70BVL  PIB2.\n                SMF70BVN  PIB2.\n                 @;\n*  ***---------------RMF PRODUCT SECTION--------------***;\nPOINTER = SMF70PRS +M;\nINPUT @ POINTER\n           +10  SMF70IST  PD4.\n                SMF70DAT  PD4.\n                SMF70INT  PD4.\n            +2  SMF70SAM  PIB4.\n                 @;\n*  ***---------------CPU DATA SECTION-----------------***;\nPOINTER = SMF70CPS +M;\n  INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n*  ***---------------ASID DATA AREA SECTION-----------***;\nPOINTER = SMF70ASS +M;\nINPUT @ POINTER\n          +128  SMF70OMN  PIB2.\n                SMF70OMM  PIB2.\n                SMF70OTT  PIB4.\n          +104  SMF70BMN  PIB2.\n                SMF70BMM  PIB2.\n                SMF70BTT  PIB4.\n          +104  SMF70TMN  PIB2.\n                SMF70TMM  PIB2.\n                SMF70TTT  PIB4.\n                 @;\n*  ***---------------PR/SM PARTITION DATA SECTION-----***;\nPOINTER = SMF70BCS + M;\n  INPUT @ POINTER\n                SMF70LPM  $CHAR4.\n                LPM2HALF  $CHAR4.\n                SMF70LPN  PIB1.\n                SMF70PFG  PIB1.\n                SMF70BDN  PIB2.\n                SMF70BDS  PIB4.\n                   @;\n*  ***--LETS START DOING SOME CALCULATIONS--***;\n  S70IST = SMF70IST;\n  S70DAT = SMF70DAT;\n  S70INT = SMF70INT;\n  S70TMN = SMF70TMN;\n  S70TMM = SMF70TMM;\n  IF SMF70SAM = 0 THEN S70TAV = 0;\n      ELSE S70TAV = SMF70TTT / SMF70SAM;\n  S70OMN = SMF70OMN              /* MIN USERS OUT AND READY */;\n  S70OMM = SMF70OMM              /* MAX USERS OUT AND READY */;\n  IF SMF70SAM = 0 THEN S70OAV = 0;\n     ELSE S70OAV = SMF70OTT / SMF70SAM /* AVG USERS OUT AND READY */;\n  S70BMN = SMF70BMN              /* MIN BATCH OUT AND READY */;\n  S70BMM = SMF70BMM              /* MAX BATCH OUT AND READY */;\n  IF SMF70SAM = 0 THEN S70BAV = 0;\n     ELSE S70BAV = SMF70BTT / SMF70SAM /* AVG BATCH OUT AND READY */;\n  S70SID = SMF70SID;\n   IF SMF70INT LT 0100000 THEN DELETE;\n   IF SMF70SID EQ 'P1S2'    AND\n      IF SMF70DAT EQ  89032 AND\n      IF SMF70IST EQ  63000 THEN DELETE /*BAD RECORD CHECK IT OUT<==*/;\n* ******************************************************;\n MIN  = FLOOR(SMF70INT/100000)  /*PICK UP THE MINUTES ONLY MMSSTTT*/;\n SEC  = FLOOR((SMF70INT - MIN*100000)/1000)                         ;\n INTSEC = (MIN*60) + SEC                /* NO. OF SECS IN INTERVAL*/;\n* *************************BEG. OF CPU WAIT TIME ROUTINE************;\n  IF SMF70FLG = '.... ...1'B THEN\n      GO TO PRSM_UT                 /*BIT INDICATES PR/SM MACHINE */;\n* **************ELSE USE WAIT TIME TO CALC CPU UTILIZATION**********;\n  WAIT    = 0;\n  CPU_CTR = 1;\n  POINTER = SMF70CPS +M             /*LOCATE SMF70WAT             */;\nCPU_LOOP:\n   IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE        */;\n      FLAG = '*';\n      PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n          'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n      END;\n   WAIT = WAIT + SMF70WAT;\n   IF SMF70CPN = CPU_CTR THEN\n      GO TO CONT;\n   CPU_CTR = CPU_CTR + 1            /*    WE HAVE ANOTHER CPU */ ;\n   POINTER = POINTER + SMF70CPL     /* POINT TO ITS WAIT TIME */ ;\n  INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n   GO TO CPU_LOOP;\nCONT:\n WAIT = WAIT/CPU_CTR ;\n WAITMICS = WAIT/4096       /* CONVERT WAIT TIME TO MICRO SECS */;\n WAITSEC  = WAITMICS/1000000        /*      CONVERT TO SECONDS */;\n**                         END OF CPU WAIT TIME ROUTINE;\n   IF INTSEC = 0 THEN WAIT_PER = 0;\n   ELSE WAIT_PER = WAITSEC/INTSEC  /* PERCENTAGE OF WAIT TIME  */;\n   WAIT_PER = WAIT_PER*100               /* MAKE IT AN INTERGER*/;\n   CPU_UT   = 100 - WAIT_PER             /* AVG CPU UTILIZATION*/;\n   CPU_UT   = ROUND(CPU_UT,.1)           /* AVG CPU UTILIZATION*/;\n   TOT_UT   = CPU_UT * CPU_CTR       /*TOTL CPU UTL FOR PARTITN*/;\n   TOT_UT   = ROUND(TOT_UT,.1)       /*TOTL CPU UTL FOR PARTITN*/;\n   NUMCPU   = CPU_CTR              /* TOTAL CPU'S THIS  PARTITN*/;\n   GO TO SAVEIT                    /* ALL DONE                 */;\nPRSM_UT:\n    CUR_PDS  = SMF70BCS + M        /*FIRST PARTITION DATA SECT.*/;\n    PART_CTR = 0                   /*PARTITION COUNTER         */;\nPART_LP:\n    PART_CTR = PART_CTR + 1        /*KEEP TRACK OF PARTITIONS  */;\n    IF S70SID NE SMF70LPM\n       THEN GO TO NEXT_P         /*ONLY WANT THIS SID PARTITION*/;\n   IF SMF70PFG = '1... ....'B THEN DO  /*HAS PARTITION CHANGED */;\n      FLAG = '*';\n      PUT 'SMF70PFG INDICATES PARTITION HAS CHANGED. INTERVAL=' S70IST\n          'ON DATE=' S70DAT 'PARTITION=' SMF70LPN;\n      END;\n   IF SMF70PFG = '.1.. ....'B THEN DO  /*HAS PROCESSOR CHANGED */;\n      FLAG = '*';\n      PUT 'SMF70PFG INDICATES LOG. PROCESSOR HAS CHANGED. INTERVAL='\n          S70IST 'ON DATE=' S70DAT 'PARTITION=' SMF70LPN;\n      END;\n    TOT_UT  = 0                    /*TOTAL UTILIZATION         */;\n    CP_UT   = 0                    /*PHYSICAL CPU UTILIZATION  */;\n    CPU_CTR = 0;\n****POINTER = OFFSET PLUS LENGTH TIMES NUM. OF SECTIONS TO SKIP**;\n    POINTER = SMF70BVS + M + (SMF70BDS*SMF70BVL);\n*  ***---------------PR/SM LOGICAL PROCESSOR DATA SECTION--***;\n  INPUT @ POINTER\n                SMF70PDT  PIB8.\n                SMF70VPA  PIB2.\n                SMF70BPS  PIB2.\n                SMF70VPF  PIB1.\n                   @;\n    NUMCPU = SMF70BDN        /*NO. OF LPDS FOR THIS PARTITION*/;\n*UT 'END OF PART_LP: ROUTINE AND WE HAVE THE FOLLOWING:  ';\n*UT 'PART_CTR=' PART_CTR '  S70SID=' S70SID '   SMF70LPM=' SMF70LPM   ;\n*UT 'TOT_UT=' TOT_UT 'CPU_CTR=' CPU_CTR;\n*UT 'POINTER=' POINTER '  = ' SMF70BVS '+' M'+'SMF70BDS'*'SMF70BVL;\n*UT 'LPDS=' SMF70PDT SMF70VPA SMF70BPS SMF70VPF ;\nLPDS_LP1:\n    CPU_CTR= CPU_CTR + 1          /*LOGICAL PROCESSOR NUMBER */;\n***                                                          ***;\n***IS PROCESSOR NOT DEDICATED AND IS WAIT COMPLETION DISABLED***;\n***NOTE: 65535 = HEX'FFFF'                                   ***;\n***                                                          ***;\n    IF SMF70BPS NE 65535   AND\n       SMF70VPF EQ '0... ....'B THEN DO;\n        TOT_UT = TOT_UT +\n        ((SMF70PDT/1000000)/INTSEC)*100     /*TOTAL CPU UTIL */;\n       END;\n***                                                          ***;\n***IS PROCESSOR DEDICATED                                    ***;\n***NOTE: 65535 = HEX'FFFF'                                   ***;\n***                                                          ***;\n    IF SMF70BPS EQ 65535 THEN DO;\n       POINTHLD = POINTER;\n       POINTER = SMF70CPS +M +((CPU_CTR - 1) * SMF70CPL);\n       INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n        WAITMICS = SMF70WAT/4096  /* CONVERT WAIT TIME TO MICRO SECS */;\n        CP_WAIT = ((WAITMICS/1000000)/INTSEC)*100     /*THEN TO SECS*/;\n        CP_UT   = 100 - CP_WAIT;\n        TOT_UT = TOT_UT + CP_UT;\n        IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE   */;\n        FLAG = '*';\n        PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n            'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n          END;\n        POINTER = POINTHLD;\n        GO TO LPDS_C1;\n       END;\n***                                                          ***;\n***IS PROCESSOR NOT DIDICATED AND IS WAIT COMPLETION ENABLED ***;\n***NOTE: 65535 = HEX'FFFF'                                   ***;\n***                                                          ***;\n    IF SMF70BPS EQ 65535 AND\n       SMF70VPF EQ '1... ....'B THEN DO;\n       POINTHLD = POINTER;\n       POINTER = SMF70CPS +M +((CPU_CTR - 1) * SMF70CPL);\n       INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n        WAITMICS = SMF70WAT/4096  /* CONVERT WAIT TIME TO MICRO SECS */;\n        CP_UT = (((SMF70PDT-WAITMICS)/1000000)/INTSEC)*100;\n        TOT_UT = TOT_UT + CP_UT;\n        IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE   */;\n        FLAG = '*';\n        PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n            'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n          END;\n        POINTER = POINTHLD;\n        GO TO LPDS_C1;\n       END;\nLPDS_C1:\n    IF NUMCPU = CPU_CTR THEN\n       GO TO LP_CONT1             /*DONE WITH THIS PART      */;\n    POINTER = POINTER + SMF70BVL  /*POINT TO NEXT PROCESSOR  */;\n*  ***---------------PR/SM LOGICAL PROCESSOR DATA SECTION--***;\n  INPUT @ POINTER\n                SMF70PDT  PIB8.\n                SMF70VPA  PIB2.\n                SMF70BPS  PIB2.\n                SMF70VPF  PIB1.\n                   @;\n    GO TO LPDS_LP1           /*GO DO NEXT PROCESSOR          */;\nLP_CONT1:\n    CPU_UT = TOT_UT/NUMCPU   /*AVERAGE CPU UTL FOR PARTITION */;\n   CPU_UT   = ROUND(CPU_UT,.1)           /* AVG CPU UTILIZATION*/;\n   TOT_UT   = ROUND(TOT_UT,.1)       /*TOTL CPU UTL FOR PARTITN*/;\n    GO TO SAVEIT;\nNEXT_P:\n    IF PART_CTR GE SMF70BCN THEN DO;\n       PUT 'COULDNT FIND PARTN. SID=' S70SID 'PART=' SMF70LPM ;\n       PUT 'SMF70BCN=' SMF70BCN 'PART_CTR=' PART_CTR;\n       PUT 'AT LABEL  NEXT_P:';\n       ABORT RETURN 99       /*COULDNT FIND CORRECT PARTITION*/;\n       END;\n    CUR_PDS = CUR_PDS + SMF70BCL /*SAVE NEXT PARTITION D.S.  */;\n    POINTER = CUR_PDS            /*POINT TO NEXT PART. D.S.  */;\n*  ***---------------PR/SM PARTITION DATA SECTION-----***;\n  INPUT @ POINTER\n                SMF70LPM  $CHAR4.\n                LPM2HALF  $CHAR4.\n                SMF70LPN  PIB1.\n                SMF70PFG  PIB1.\n                SMF70BDN  PIB2.\n                SMF70BDS  PIB4.\n                   @;\n    GO TO PART_LP            /*LETS LOOK AT THIS PARTITION   */;\nSAVEIT:\n**                                                     ;\n**  OUTPUT DATA FOR EACH SYSTEM THAT YOU WANT TO SAVE.         ;\n**                                                             ;\n**               SMF-ID                   P1708811             ;\n**                 |                      P1.........SYSTEM    ;\n**                 |                        70.......REC NUMBER;\n**                 |                          88.....YEAR      ;\n**                 |                            11...MONTH     ;\n**                 V                                           ;\n   IF SMF70SID = 'P1S2' THEN OUTPUT SASDB.P1708902 ;\n   IF SMF70SID = 'P0S3' THEN OUTPUT SASDB.P0708902 ;\n   IF SMF70SID = 'S3S3' THEN OUTPUT SASDB.S3708902 ;\n   IF SMF70SID = 'S2S2' THEN OUTPUT SASDB.S2708902 ;\n   IF SMF70SID = 'S1S1' THEN OUTPUT SASDB.S1708902 ;\nRETURN;\n   %\n   INPUTIT;\n   PROC PRINT DATA=SASDB.P1708902 ;\n        VAR S70TMN S70TMM S70TAV S70BMM S70BAV S70OAV S70IST\n            S70DAT CPU_UT TOT_UT NUMCPU S70SID FLAG ;\n   PROC PRINT DATA=SASDB.P0708902 ;\n        VAR S70TMN S70TMM S70TAV S70BMM S70BAV S70OAV S70IST\n            S70DAT CPU_UT TOT_UT NUMCPU S70SID FLAG ;\n   PROC PRINT DATA=SASDB.S3708902 ;\n        VAR S70TMN S70TMM S70TAV S70BMM S70BAV S70OAV S70IST\n            S70DAT CPU_UT TOT_UT NUMCPU S70SID FLAG ;\n   PROC PRINT DATA=SASDB.S2708902 ;\n        VAR S70TMN S70TMM S70TAV S70BMM S70BAV S70OAV S70IST\n            S70DAT CPU_UT TOT_UT NUMCPU S70SID FLAG ;\n   PROC PRINT DATA=SASDB.S1708902 ;\n        VAR S70TMN S70TMM S70TAV S70BMM S70BAV S70OAV S70IST\n            S70DAT CPU_UT TOT_UT NUMCPU S70SID FLAG ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMF70J": {"ttr": 2824, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PULL OFF RMF RECORD 70 INFORMATION.  THIS INCLUDES TSO USERS\n//*  CPU TIME BATCH USERS ETC. STORE INFO ON SAS DATA BASE.\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(RMF70)\n//SMF   DD DISP=SHR,DSN=XY.RMFJAN           <==RMF INPUT\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,           <==OUTPUT (SAS DATASET)\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RMF70W": {"ttr": 2826, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n| **THIS PROGRAM IS THE SAME AS RMF70 EXCEPT IT STORES DATA   **    |\n| **BY WEEK RATHER THAN BY MONTH. IT DOES THIS BY SAVEING     **    |\n| **THE DATA WITH A DIFFERENT NAME (CONTAINS THE CHARACTERS   **    |\n| **\"WK\" IN THE SAS NAME). COMPARE THE DATA STATEMENTS TO SEE **    |\n| **THE DIFFERENCE.                                           **    |\n| **CREATED FROM RMF70 ON 3/16/89 <====                       **    |\n|                                                                   |\n+-------------------------------------------------------------------+\n|   ONLY LOOKING AT SMF TYPE 70 RECORDS. FOR MVS/XA SYSTEMS         |\n|   DATA MUST BE SORTED BEFORE BEING USED BY                        |\n|         SMF70SID,SMF70DAT,SMF70IST                                |\n|         (JUST USE THE SORT MEMBER)                                |\n|                                                                   |\n|   SMF DATA FOR -TSO  ACTIVITY                                     |\n|                -AVERAGE NUMBER OF BATCH JOBS RUNNING              |\n|                -AVERAGE NUMBER OF OUT AND READY ASIDS             |\n|                -PICKS UP WAIT TIME AND CALCULATES CPU UTILIZATION |\n|                                                                   |\n| ----                       -----                            ----  |\n|   SINCE THE DATA IS SAVED BY SYSTEM ID (SMF ID) THEN THE ONLY     |\n|   THING THAT MAKES THESE PROGRAMS INSTALLATION DEPENDANT ARE      |\n|   1) THE LITERALS FOR CHECKING THE SYSTEM ID                      |\n|       -LOCATED AT THE END OF THE PROGRAM                          |\n|   2) THE MEMBER NAME THAT IS GIVEN TO THE SAS DATASET (ONE FOR    |\n|      EACH SYSTEM)                                                 |\n|       -LOCATED IN THE BEGINING (DATA STATEMENT)                   |\n|        AND AT THE END, FOLLOWING THE \"OUTPUT\" STATEMENTS          |\n|                                                                   |\n|   IN ADDITION, SINCE THE DATA IS NORMALLY STORED BY MONTH         |\n|   THEN THE MEMBER NAMES REFERENCED IN NUMBER 2 ABOVE              |\n|   IS CHANGED SLIGHTLY EACH MONTH TO REFLECT THE MONTH AND YEAR.   |\n| ----                       -----                            ----  |\n|                                                                   |\n|   THIS SAS FILE THEN CAN BE USED AS INPUT TO CREATE A GRAPH       |\n|   EITHER ON THE TERMINAL OR TO A PRINTER USING GDDM.              |\n|                                                                   |\n|   SMF70RTY...... RECORD TYPE.                                     |\n|   SMF70SID...... SID.                                             |\n|   SMF70IST...... TIME RMF MEASUREMENT INTERVAL STARTED IN FORM    |\n|                  0HHMMSSF WHERE F IS THE SIGN.                    |\n|   SMF70DAT...... DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED    |\n|                  (F IS THE SIGN).                                 |\n|   SMF70INT...... DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|   SMF70TMN...... TSO USERS MINIMUM OVER INTERVAL.                 |\n|   SMF70TMM...... TSO USERS MAXIMUM OVER INTERVAL.\n|   SMF70TTT...... TSO USERS TOTAL VALUE OVER INTERVAL.             |\n|                                                                   |\n|                                                                   |\n|   THE VARIABLES THAT ARE SAVE ARE:                                |\n|                                                                   |\n|   S70TMN........ MINIMUM TSO USERS                                |\n|   S70TMM........ MAXIMUM TSO USERS                                |\n|   S70TAV........ AVERAGE TSO USERS                                |\n|   S70TMM........ MAXIMUM TSO USERS                                |\n|   S70BMM........ MAXIMUM BATCH USERS                              |\n|   S70OAV........ AVERAGE NUMBER OF ASIDS OUT AND READY            |\n|   S70IST........ INTERVAL START TIME                              |\n|   S70DAT........ INTERVAL DATE                                    |\n|   S70INT........ LENGTH OF (RMF) INTERVAL                         |\n| | WAIT_PER...... PERCENT OF TIME CPU WAITING -NO LONGER SAVED     |\n| | CPU_UT........ AVG. PERCENT BUSY (1 - WAIT_PER FOR NON PR/SM) OR|\n| |                FROM SMF70PDT FOR PR/SM MACHINES                 |\n| | TOT_UT........ TOTAL UTILIZATION (ALL CPU'S IN PARTITION)       |\n| | NUMCPU........ NUMBER OF LOGICAL PROCESSORS ASSIGNED TO A       |\n| |                PARTITION                                        |\n|   S70SID........ SYSTEM'S SMF ID                                  |\n|                                                                   |\n|   OUTPUT FILE NAME = SID...REC NO...WK.....WEEK NUMBER...         |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|    E.G.   S1708811 = S1 ...  70  ...88  ... 09                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.S1708811 TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|          C 70WK09 70WK10 ALL                                      |\n|                                                                   |\n|   UPDATES:                                                        |\n|    ADDED S70BMM TO THE DATA STATEMETS. THIS WILL SAVE MAXIMUM     |\n|    BATCH JOBS.                                                    |\n|                                                                   |\n|   UPDATES:  2/23/89                                               |\n|    ADDED ROUTINE TO CALCULATE CPU UTILIZATION FOR PR/SM LOGICAL   |\n|    AND DEDICATED PROCESSORS. NEW VARIABLES ARE:                   |\n|    TOT_UT (TOTAL UTILIZATION                                      |\n|    AND NUMCPU (NUMBER OF PROCESSORS IN THE PARTITION((SMS70BDN)). |\n|    NOTE: FOR NOW WE ARE JUST USING THE 1ST FOUR BYTES OF SMF70LPM |\n|          (THE PARTITION NAME)                                     |\n*-------------------------------------------------------------------*\n;\n   MACRO INPUTIT\n   DATA\n SASDB.P170WK02 (KEEP=S70TMN S70TMM S70TAV S70BAV S70OAV S70IST S70DAT\n             S70BMM\n             S70INT WAIT_PER CPU_UT TOT_UT NUMCPU S70SID FLAG )\n SASDB.P070WK02 (KEEP=S70TMN S70TMM S70TAV S70BAV S70OAV S70IST S70DAT\n             S70BMM\n             S70INT WAIT_PER CPU_UT TOT_UT NUMCPU S70SID FLAG )\n SASDB.S170WK02 (KEEP=S70TMN S70TMM S70TAV S70BAV S70OAV S70IST S70DAT\n             S70BMM\n             S70INT WAIT_PER CPU_UT TOT_UT NUMCPU S70SID FLAG )\n        ;\n   INFILE SMF LENGTH=L ;\n*  INFORMAT S70IST RMFDUR4. S70INT PDTIME4. ;\n   INPUT @2 ID PIB1. @;\n   IF ID = 70  THEN LINK X5;\n   RETURN;\nX5:\nPOINTER = 1;\nM = -3;\nINPUT @ POINTER\n                SMF70FLG  PIB1.\n             +9 SMF70SID  $CHAR4.\n            +10 SMF70PRS  PIB4.\n            +12 SMF70CPS  PIB4.\n                SMF70CPL  PIB2.\n                SMF70CPN  PIB2.\n                SMF70ASS  PIB4.\n                SMF70ASL  PIB2.\n                SMF70ASN  PIB2.\n                SMF70BCS  PIB4.\n                SMF70BCL  PIB2.\n                SMF70BCN  PIB2.\n                SMF70BVS  PIB4.\n                SMF70BVL  PIB2.\n                SMF70BVN  PIB2.\n                 @;\n*  ***---------------RMF PRODUCT SECTION--------------***;\nPOINTER = SMF70PRS +M;\nINPUT @ POINTER\n           +10  SMF70IST  PD4.\n                SMF70DAT  PD4.\n                SMF70INT  PD4.\n            +2  SMF70SAM  PIB4.\n                 @;\n*  ***---------------CPU DATA SECTION-----------------***;\nPOINTER = SMF70CPS +M;\n  INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n*  ***---------------ASID DATA AREA SECTION-----------***;\nPOINTER = SMF70ASS +M;\nINPUT @ POINTER\n          +128  SMF70OMN  PIB2.\n                SMF70OMM  PIB2.\n                SMF70OTT  PIB4.\n          +104  SMF70BMN  PIB2.\n                SMF70BMM  PIB2.\n                SMF70BTT  PIB4.\n          +104  SMF70TMN  PIB2.\n                SMF70TMM  PIB2.\n                SMF70TTT  PIB4.\n                 @;\n*  ***---------------PR/SM PARTITION DATA SECTION-----***;\nPOINTER = SMF70BCS + M;\n  INPUT @ POINTER\n                SMF70LPM  $CHAR4.\n                LPM2HALF  $CHAR4.\n                SMF70LPN  PIB1.\n                SMF70PFG  PIB1.\n                SMF70BDN  PIB2.\n                SMF70BDS  PIB4.\n                   @;\n*  ***--LETS START DOING SOME CALCULATIONS--***;\n  S70IST = SMF70IST;\n  S70DAT = SMF70DAT;\n  S70INT = SMF70INT;\n  S70TMN = SMF70TMN;\n  S70TMM = SMF70TMM;\n  IF SMF70SAM = 0 THEN S70TAV = 0;\n      ELSE S70TAV = SMF70TTT / SMF70SAM;\n  S70OMN = SMF70OMN              /* MIN USERS OUT AND READY */;\n  S70OMM = SMF70OMM              /* MAX USERS OUT AND READY */;\n  IF SMF70SAM = 0 THEN S70OAV = 0;\n     ELSE S70OAV = SMF70OTT / SMF70SAM /* AVG USERS OUT AND READY */;\n  S70BMN = SMF70BMN              /* MIN BATCH OUT AND READY */;\n  S70BMM = SMF70BMM              /* MAX BATCH OUT AND READY */;\n  IF SMF70SAM = 0 THEN S70BAV = 0;\n     ELSE S70BAV = SMF70BTT / SMF70SAM /* AVG BATCH OUT AND READY */;\n  S70SID = SMF70SID;\n   IF SMF70INT LT 0100000 THEN DELETE;\n* ******************************************************;\n MIN  = FLOOR(SMF70INT/100000)  /*PICK UP THE MINUTES ONLY MMSSTTT*/;\n SEC  = FLOOR((SMF70INT - MIN*100000)/1000)                         ;\n INTSEC = (MIN*60) + SEC                /* NO. OF SECS IN INTERVAL*/;\n* *************************BEG. OF CPU WAIT TIME ROUTINE************;\n  IF SMF70FLG = '.... ...1'B THEN\n      GO TO PRSM_UT                 /*BIT INDICATES PR/SM MACHINE */;\n* **************ELSE USE WAIT TIME TO CALC CPU UTILIZATION**********;\n  WAIT    = 0;\n  CPU_CTR = 1;\n  POINTER = SMF70CPS +M             /*LOCATE SMF70WAT             */;\nCPU_LOOP:\n   IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE        */;\n      FLAG = '*';\n      PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n          'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n      END;\n   WAIT = WAIT + SMF70WAT;\n   IF SMF70CPN = CPU_CTR THEN\n      GO TO CONT;\n   CPU_CTR = CPU_CTR + 1            /*    WE HAVE ANOTHER CPU */ ;\n   POINTER = POINTER + SMF70CPL     /* POINT TO ITS WAIT TIME */ ;\n  INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n   GO TO CPU_LOOP;\nCONT:\n WAIT = WAIT/CPU_CTR ;\n WAITMICS = WAIT/4096       /* CONVERT WAIT TIME TO MICRO SECS */;\n WAITSEC  = WAITMICS/1000000        /*      CONVERT TO SECONDS */;\n**                         END OF CPU WAIT TIME ROUTINE;\n   IF INTSEC = 0 THEN WAIT_PER = 0;\n   ELSE WAIT_PER = WAITSEC/INTSEC  /* PERCENTAGE OF WAIT TIME  */;\n   WAIT_PER = WAIT_PER*100               /* MAKE IT AN INTERGER*/;\n   CPU_UT   = 100 - WAIT_PER             /* AVG CPU UTILIZATION*/;\n   CPU_UT   = ROUND(CPU_UT,.1)           /* AVG CPU UTILIZATION*/;\n   TOT_UT   = CPU_UT * CPU_CTR       /*TOTL CPU UTL FOR PARTITN*/;\n   TOT_UT   = ROUND(TOT_UT,.1)       /*TOTL CPU UTL FOR PARTITN*/;\n   NUMCPU   = CPU_CTR              /* TOTAL CPU'S THIS  PARTITN*/;\n   GO TO SAVEIT                    /* ALL DONE                 */;\nPRSM_UT:\n    CUR_PDS  = SMF70BCS + M        /*FIRST PARTITION DATA SECT.*/;\n    PART_CTR = 0                   /*PARTITION COUNTER         */;\nPART_LP:\n    PART_CTR = PART_CTR + 1        /*KEEP TRACK OF PARTITIONS  */;\n    IF S70SID NE SMF70LPM\n       THEN GO TO NEXT_P         /*ONLY WANT THIS SID PARTITION*/;\n   IF SMF70PFG = '1... ....'B THEN DO  /*HAS PARTITION CHANGED */;\n      FLAG = '*';\n      PUT 'SMF70PFG INDICATES PARTITION HAS CHANGED. INTERVAL=' S70IST\n          'ON DATE=' S70DAT 'PARTITION=' SMF70LPN;\n      END;\n   IF SMF70PFG = '.1.. ....'B THEN DO  /*HAS PROCESSOR CHANGED */;\n      FLAG = '*';\n      PUT 'SMF70PFG INDICATES LOG. PROCESSOR HAS CHANGED. INTERVAL='\n          S70IST 'ON DATE=' S70DAT 'PARTITION=' SMF70LPN;\n      END;\n    TOT_UT  = 0                    /*TOTAL UTILIZATION         */;\n    CP_UT   = 0                    /*PHYSICAL CPU UTILIZATION  */;\n    CPU_CTR = 0;\n****POINTER = OFFSET PLUS LENGTH TIMES NUM. OF SECTIONS TO SKIP**;\n    POINTER = SMF70BVS + M + (SMF70BDS*SMF70BVL);\n*  ***---------------PR/SM LOGICAL PROCESSOR DATA SECTION--***;\n  INPUT @ POINTER\n                SMF70PDT  PIB8.\n                SMF70VPA  PIB2.\n                SMF70BPS  PIB2.\n                SMF70VPF  PIB1.\n                   @;\n    NUMCPU = SMF70BDN        /*NO. OF LPDS FOR THIS PARTITION*/;\n*UT 'END OF PART_LP: ROUTINE AND WE HAVE THE FOLLOWING:  ';\n*UT 'PART_CTR=' PART_CTR '  S70SID=' S70SID '   SMF70LPM=' SMF70LPM   ;\n*UT 'TOT_UT=' TOT_UT 'CPU_CTR=' CPU_CTR;\n*UT 'POINTER=' POINTER '  = ' SMF70BVS '+' M'+'SMF70BDS'*'SMF70BVL;\n*UT 'LPDS=' SMF70PDT SMF70VPA SMF70BPS SMF70VPF ;\nLPDS_LP1:\n    CPU_CTR= CPU_CTR + 1          /*LOGICAL PROCESSOR NUMBER */;\n***                                                          ***;\n***IS PROCESSOR NOT DEDICATED AND IS WAIT COMPLETION DISABLED***;\n***NOTE: 65535 = HEX'FFFF'                                   ***;\n***                                                          ***;\n    IF SMF70BPS NE 65535   AND\n       SMF70VPF EQ '0... ....'B THEN DO;\n        TOT_UT = TOT_UT +\n        ((SMF70PDT/1000000)/INTSEC)*100     /*TOTAL CPU UTIL */;\n       END;\n***                                                          ***;\n***IS PROCESSOR DEDICATED                                    ***;\n***NOTE: 65535 = HEX'FFFF'                                   ***;\n***                                                          ***;\n    IF SMF70BPS EQ 65535 THEN DO;\n       POINTHLD = POINTER;\n       POINTER = SMF70CPS +M +((CPU_CTR - 1) * SMF70CPL);\n       INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n        WAITMICS = SMF70WAT/4096  /* CONVERT WAIT TIME TO MICRO SECS */;\n        CP_WAIT = ((WAITMICS/1000000)/INTSEC)*100     /*THEN TO SECS*/;\n        CP_UT   = 100 - CP_WAIT;\n        TOT_UT = TOT_UT + CP_UT;\n        IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE   */;\n        FLAG = '*';\n        PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n            'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n          END;\n        POINTER = POINTHLD;\n        GO TO LPDS_C1;\n       END;\n***                                                          ***;\n***IS PROCESSOR NOT DIDICATED AND IS WAIT COMPLETION ENABLED ***;\n***NOTE: 65535 = HEX'FFFF'                                   ***;\n***                                                          ***;\n    IF SMF70BPS EQ 65535 AND\n       SMF70VPF EQ '1... ....'B THEN DO;\n       POINTHLD = POINTER;\n       POINTER = SMF70CPS +M +((CPU_CTR - 1) * SMF70CPL);\n       INPUT @ POINTER\n                SMF70WAT  PIB8.\n                SMF70CID  PIB2.\n                SMF70CNF  PIB1.\n                SMF70RV3  PIB1.\n                SMF70SER  PK3.\n                   @;\n        WAITMICS = SMF70WAT/4096  /* CONVERT WAIT TIME TO MICRO SECS */;\n        CP_UT = (((SMF70PDT-WAITMICS)/1000000)/INTSEC)*100;\n        TOT_UT = TOT_UT + CP_UT;\n        IF SMF70CNF = '.... ..1.'B THEN DO  /*DID CONFIG CHANGE   */;\n        FLAG = '*';\n        PUT 'SMF70CNF INDICATES CPU RECONFIGED DURING INTERVAL=' S70IST\n            'ON DATE=' S70DAT 'CPU=' CPU_CTR;\n          END;\n        POINTER = POINTHLD;\n        GO TO LPDS_C1;\n       END;\nLPDS_C1:\n    IF NUMCPU = CPU_CTR THEN\n       GO TO LP_CONT1             /*DONE WITH THIS PART      */;\n    POINTER = POINTER + SMF70BVL  /*POINT TO NEXT PROCESSOR  */;\n*  ***---------------PR/SM LOGICAL PROCESSOR DATA SECTION--***;\n  INPUT @ POINTER\n                SMF70PDT  PIB8.\n                SMF70VPA  PIB2.\n                SMF70BPS  PIB2.\n                SMF70VPF  PIB1.\n                   @;\n    GO TO LPDS_LP1           /*GO DO NEXT PROCESSOR          */;\nLP_CONT1:\n    CPU_UT = TOT_UT/NUMCPU   /*AVERAGE CPU UTL FOR PARTITION */;\n   CPU_UT   = ROUND(CPU_UT,.1)           /* AVG CPU UTILIZATION*/;\n   TOT_UT   = ROUND(TOT_UT,.1)       /*TOTL CPU UTL FOR PARTITN*/;\n    GO TO SAVEIT;\nNEXT_P:\n    IF PART_CTR GE SMF70BCN THEN DO;\n       PUT 'COULDNT FIND PARTN. SID=' S70SID 'PART=' SMF70LPM ;\n       PUT 'SMF70BCN=' SMF70BCN 'PART_CTR=' PART_CTR;\n       PUT 'AT LABEL  NEXT_P:';\n       ABORT RETURN 99       /*COULDNT FIND CORRECT PARTITION*/;\n       END;\n    CUR_PDS = CUR_PDS + SMF70BCL /*SAVE NEXT PARTITION D.S.  */;\n    POINTER = CUR_PDS            /*POINT TO NEXT PART. D.S.  */;\n*  ***---------------PR/SM PARTITION DATA SECTION-----***;\n  INPUT @ POINTER\n                SMF70LPM  $CHAR4.\n                LPM2HALF  $CHAR4.\n                SMF70LPN  PIB1.\n                SMF70PFG  PIB1.\n                SMF70BDN  PIB2.\n                SMF70BDS  PIB4.\n                   @;\n    GO TO PART_LP            /*LETS LOOK AT THIS PARTITION   */;\nSAVEIT:\n**                                                     ;\n**  OUTPUT DATA FOR EACH SYSTEM THAT YOU WANT TO SAVE.         ;\n**                                                             ;\n**               SMF-ID                   P1708811             ;\n**                 |                      P1.........SYSTEM    ;\n**                 |                        70.......REC NUMBER;\n**                 |                          88.....YEAR      ;\n**                 |                            11...MONTH     ;\n**                 V                                           ;\n   IF SMF70SID = 'P1S2' THEN OUTPUT SASDB.P170WK02 ;\n   IF SMF70SID = 'P0S3' THEN OUTPUT SASDB.P070WK02 ;\n   IF SMF70SID = 'S1S1' THEN OUTPUT SASDB.S170WK02 ;\nRETURN;\n   %\n   INPUTIT;\n   PROC PRINT DATA=SASDB.P170WK02 ;\n        VAR S70TMN S70TMM S70TAV S70BMM S70BAV S70OAV S70IST\n            S70DAT CPU_UT TOT_UT NUMCPU S70SID FLAG ;\n   PROC PRINT DATA=SASDB.P070WK02 ;\n        VAR S70TMN S70TMM S70TAV S70BMM S70BAV S70OAV S70IST\n            S70DAT CPU_UT TOT_UT NUMCPU S70SID FLAG ;\n   PROC PRINT DATA=SASDB.S170WK02 ;\n        VAR S70TMN S70TMM S70TAV S70BMM S70BAV S70OAV S70IST\n            S70DAT CPU_UT TOT_UT NUMCPU S70SID FLAG ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMF70WJ": {"ttr": 3078, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PULL OFF RMF RECORD 70 INFORMATION.  THIS INCLUDES TSO USERS\n//*  CPU TIME BATCH USERS ETC. STORE INFO ON SAS DATA BASE BY WEEK.\n//*  BUT USE RMF70W INSTEAD OF RMF70.\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(RMF70W)\n//SMF   DD DISP=SHR,DSN=XY.RMFWEEK\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RMF71": {"ttr": 3080, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n|   SMF DATA FOR PAGING ACTIVITY                                    |\n|   ONLY LOOKING AT SMF TYPE 71 RECORDS. FOR MVS/XA SYSTEMS         |\n|                                                                   |\n|   DATA MUST BE SORTED BEFORE BEING USED BY                        |\n|         SMF71SID,SMF71DAT,SMF71IST                                |\n|         (JUST USE THE SORT MEMBER)                                |\n|                                                                   |\n| ----                       -----                            ----  |\n|   SINCE THE DATA IS SAVED BY SYSTEM ID (SMF ID) THEN THE ONLY     |\n|   THING THAT MAKES THESE PROGRAMS INSTALLATION DEPENDANT ARE      |\n|   1) THE LITERALS FOR CHECKING THE SYSTEM ID                      |\n|       -LOCATED AT THE END OF THE PROGRAM                          |\n|   2) THE MEMBER NAME THAT IS GIVEN TO THE SAS DATASET (ONE FOR    |\n|      EACH SYSTEM)                                                 |\n|       -LOCATED IN THE BEGINING (DATA STATEMENT)                   |\n|        AND AT THE END, FOLLOWING THE \"OUTPUT\" STATEMENTS          |\n|                                                                   |\n|   IN ADDITION, SINCE THE DATA IS NORMALLY STORED BY MONTH         |\n|   THEN THE MEMBER NAMES REFERENCED IN NUMBER 2 ABOVE              |\n|   IS CHANGED SLIGHTLY EACH MONTH TO REFLECT THE MONTH AND YEAR.   |\n| ----                       -----                            ----  |\n|                                                                   |\n|                                                                   |\n|   THIS JOB RECREATES THE RMF 71 RECORD WITH INFORMATION           |\n|   ABOUT PAGES PER SECOND. IT THROWS OUT INTERVALS OF 1 MIN OR     |\n|   LESS. IT SAVES IT IN A SAS FILE BY SYSTEM ID AND ALSO GIVES     |\n|   GIVES A PRINTOUT OF THIS INFORMATION.                           |\n|   THIS SAS FILE THEN CAN BE USED AS INPUT TO CREATE A GRAPH       |\n|   EITHER ON THE TERMINAL OR TO A PRINTER USING GDDM.              |\n|                                                                   |\n|   SMF71RTY...... RECORD TYPE.                                     |\n|   SMF71SID...... SID.                                             |\n|   SMF71IST...... TIME RMF MEASUREMENT INTERVAL STARTED IN FORM    |\n|   SMF71DAT...... DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED    |\n|   SMF71INT...... DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|   SMF71PIN...... NUMBER OF NON-VIO NON-SWAP PAGES IN.             |\n|   SMF71POT...... NUMBER OF NON-VIO NON-SWAP PAGES OUT.            |\n|   SMF71SIN...... NUMBER OF PAGES SWAPPED IN.                      |\n|   SMF71SOT...... NUMBER OF PAGES SWAPPED OUT.                     |\n|   SMF71VIN...... NUMBER OF VIO PAGES IN.                          |\n|   SMF71VOT...... NUMBER OF VIO PAGES OUT.                         |\n|   ENDHR......... END OF MEASURED INTERVAL IS THE SUM OF SMF71IST  |\n|                  AND SMF71INT. (IN SECS).                         |\n|   TOTPAGES...... TOTAL NUMBER OF PAGES.                           |\n|   PGSEC......... TOTAL NUMBER OF PAGES PER SEC.                   |\n|   INTSEC........ DURATION IN SECS.                                |\n|   ISTSEC........ INTERVAL START TIME IN SECS.                     |\n|   S71INT........ DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|                                                                   |\n|                                                                   |\n|   OUTPUT FILE NAME = SID...REC NO...YEAR...MONTH                  |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|    E.G.   S1718811 = S1 ...  71  ...88  ... 11                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.S1718810 TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|           C 718809 718810                                         |\n|          FOR EACH OCCURRENCE (A CHANGE ALL WILL WORK BUT IT       |\n|          ALSO CHANGES THE DIRECTIONS).                            |\n|                                                                   |\n|   UPDATE: ADDED S71INT TO THE SAVED VARIABLES.                    |\n|                                                                   |\n|                                                                   |\n*-------------------------------------------------------------------*\n;\n   MACRO INPUTIT\n   DATA\n     SASDB.P1718903 (KEEP=S71SID S71DAT S71IST S71INT PAGES SECS PGSEC )\n     SASDB.P0718903 (KEEP=S71SID S71DAT S71IST S71INT PAGES SECS PGSEC )\n     SASDB.S1718903 (KEEP=S71SID S71DAT S71IST S71INT PAGES SECS PGSEC )\n        ;\n   INFILE SMF LENGTH=L;\n   INPUT @2 ID PIB1. @;\n   IF ID = 71  THEN LINK X5;\n   RETURN;\nX5:\nPOINTER = 11;\nM = -3;\nINPUT @ POINTER\n                SMF71SID  $CHAR4.\n            +10 SMF71PRS  PIB4.\n             +4 SMF71PDS  PIB4.\n                 @;\nPOINTER = SMF71PRS +M;\nINPUT @ POINTER\n           +10  SMF71IST  PD4.\n                SMF71DAT  PD4.\n                SMF71INT  PD4.\n                 @;\nPOINTER = SMF71PDS +M;\nINPUT @ POINTER\n                SMF71PIN  PIB4.\n                SMF71POT  PIB4.\n             +8 SMF71SIN  PIB4.\n                SMF71SOT  PIB4.\n                SMF71VIN  PIB4.\n                SMF71VOT  PIB4.\n                 @;\n   IF SMF71INT LT 0100000 THEN DELETE;\n*              *********              ***;\n*                *****                ***;\n   S71SID = SMF71SID ;\n   S71DAT = SMF71DAT ;\n   S71IST = SMF71IST ;\n   S71INT = SMF71INT ;\n   MIN = FLOOR(SMF71INT / 100000) ;\n   SEC = FLOOR((SMF71INT - MIN * 100000) / 1000) ;\n   INTSEC = (MIN * 60) + SEC ;\n**** THE DURATION OF THE INTERVAL IS NOW IN SECONDS ;\n   HH = FLOOR(SMF71IST / 10000) ;\n   MM = FLOOR((SMF71IST - HH * 10000) / 100) ;\n   SS = SMF71IST - ((HH * 10000) + (MM * 100)) ;\n   ISTSEC = (HH * 3600) + (MM * 60) + SS ;\n**** THIS IS TO PUT THE STARTING INTERVAL TIME IN SECS ;\n   ENDSEC = ISTSEC + INTSEC ;\n   ENDHR = FLOOR(ENDSEC / 3600) ;\n   PAGES = SMF71SIN + SMF71SOT + SMF71PIN +SMF71POT +\n       SMF71VIN + SMF71VOT ;\n   SECS  = INTSEC;\n   PGSEC = PAGES / SECS;\n**                                                     ;\n**  OUTPUT DATA FOR EACH SYSTEM THAT YOU WANT TO SAVE.         ;\n**                                                             ;\n**               SMF-ID                   P1718811             ;\n**                 |                      P1.........SYSTEM    ;\n**                 |                        71.......REC NUMBER;\n**                 |                          88.....YEAR      ;\n**                 |                            11...MONTH     ;\n**                 V                                           ;\n   IF SMF71SID = 'P1S2' THEN OUTPUT SASDB.P1718903 ;\n   IF SMF71SID = 'P0S3' THEN OUTPUT SASDB.P0718903 ;\n   IF SMF71SID = 'S1S1' THEN OUTPUT SASDB.S1718903 ;\nRETURN;\n    %\nINPUTIT;\n   PROC PRINT DATA=SASDB.P1718903;\n   PROC PRINT DATA=SASDB.P0718903;\n   PROC PRINT DATA=SASDB.S1718903;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMF71J": {"ttr": 3084, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PULL OFF PAGING INFO (71 REC) AND SAVE IT IN THE SAS DATA BASE\n//*  TO BE USED LATER.\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(RMF71)\n//SMF   DD DISP=SHR,DSN=XY.RMFWEEK          <==RMF INPUT\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,           <==OUTPUT (SAS DATASET)\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RMF71W": {"ttr": 3086, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n| **THIS PROGRAM IS THE SAME AS RMF71 EXCEPT IT STORES DATA   **    |\n| **BY WEEK RATHER THAN BY MONTH. IT DOES THIS BY SAVEING     **    |\n| **THE DATA WITH A DIFFERENT NAME (CONTAINS THE CHARACTERS   **    |\n| **\"WK\" IN THE SAS NAME). COMPARE THE DATA STATEMENTS TO SEE **    |\n| **THE DIFFERENCE.                                           **    |\n| **CREATED FROM RMF71 ON 3/16/89                             **    |\n|                                                                   |\n+-------------------------------------------------------------------+\n|   SMF DATA FOR PAGING ACTIVITY                                    |\n|   ONLY LOOKING AT SMF TYPE 71 RECORDS. FOR MVS/XA SYSTEMS         |\n|                                                                   |\n|   DATA MUST BE SORTED BEFORE BEING USED BY                        |\n|         SMF71SID,SMF71DAT,SMF71IST                                |\n|         (JUST USE THE SORT MEMBER)                                |\n|                                                                   |\n| ----                       -----                            ----  |\n|   SINCE THE DATA IS SAVED BY SYSTEM ID (SMF ID) THEN THE ONLY     |\n|   THING THAT MAKES THESE PROGRAMS INSTALLATION DEPENDANT ARE      |\n|   1) THE LITERALS FOR CHECKING THE SYSTEM ID                      |\n|       -LOCATED AT THE END OF THE PROGRAM                          |\n|   2) THE MEMBER NAME THAT IS GIVEN TO THE SAS DATASET (ONE FOR    |\n|      EACH SYSTEM)                                                 |\n|       -LOCATED IN THE BEGINING (DATA STATEMENT)                   |\n|        AND AT THE END, FOLLOWING THE \"OUTPUT\" STATEMENTS          |\n|                                                                   |\n|   IN ADDITION, SINCE THE DATA IS NORMALLY STORED BY MONTH         |\n|   THEN THE MEMBER NAMES REFERENCED IN NUMBER 2 ABOVE              |\n|   IS CHANGED SLIGHTLY EACH MONTH TO REFLECT THE MONTH AND YEAR.   |\n| ----                       -----                            ----  |\n|                                                                   |\n|                                                                   |\n|   THIS JOB RECREATES THE RMF 71 RECORD WITH INFORMATION           |\n|   ABOUT PAGES PER SECOND. IT THROWS OUT INTERVALS OF 1 MIN OR     |\n|   LESS. IT SAVES IT IN A SAS FILE BY SYSTEM ID AND ALSO GIVES     |\n|   GIVES A PRINTOUT OF THIS INFORMATION.                           |\n|   THIS SAS FILE THEN CAN BE USED AS INPUT TO CREATE A GRAPH       |\n|   EITHER ON THE TERMINAL OR TO A PRINTER USING GDDM.              |\n|                                                                   |\n|   SMF71RTY...... RECORD TYPE.                                     |\n|   SMF71SID...... SID.                                             |\n|   SMF71IST...... TIME RMF MEASUREMENT INTERVAL STARTED IN FORM    |\n|   SMF71DAT...... DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED    |\n|   SMF71INT...... DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|   SMF71PIN...... NUMBER OF NON-VIO NON-SWAP PAGES IN.             |\n|   SMF71POT...... NUMBER OF NON-VIO NON-SWAP PAGES OUT.            |\n|   SMF71SIN...... NUMBER OF PAGES SWAPPED IN.                      |\n|   SMF71SOT...... NUMBER OF PAGES SWAPPED OUT.                     |\n|   SMF71VIN...... NUMBER OF VIO PAGES IN.                          |\n|   SMF71VOT...... NUMBER OF VIO PAGES OUT.                         |\n|   ENDHR......... END OF MEASURED INTERVAL IS THE SUM OF SMF71IST  |\n|                  AND SMF71INT. (IN SECS).                         |\n|   TOTPAGES...... TOTAL NUMBER OF PAGES.                           |\n|   PGSEC......... TOTAL NUMBER OF PAGES PER SEC.                   |\n|   INTSEC........ DURATION IN SECS.                                |\n|   ISTSEC........ INTERVAL START TIME IN SECS.                     |\n|   S71INT........ DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|                                                                   |\n|                                                                   |\n|   OUTPUT FILE NAME = SID...REC NO...WK.....WEEK NUMBER...         |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|    E.G.   S1718811 = S1 ...  71  ...WK  ... 09                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.S171WKXX TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|           C 71WK09 71WK10                                         |\n|          FOR EACH OCCURRENCE (A CHANGE ALL WILL WORK BUT IT       |\n|          ALSO CHANGES THE DIRECTIONS).                            |\n|                                                                   |\n|   UPDATE: ADDED S71INT TO THE SAVED VARIABLES.                    |\n|                                                                   |\n|                                                                   |\n*-------------------------------------------------------------------*\n;\n   MACRO INPUTIT\n   DATA\n     SASDB.P171WK02 (KEEP=S71INT PAGES SECS S71SID S71DAT S71IST PGSEC )\n     SASDB.P071WK02 (KEEP=S71INT PAGES SECS S71SID S71DAT S71IST PGSEC )\n     SASDB.S171WK02 (KEEP=S71INT PAGES SECS S71SID S71DAT S71IST PGSEC )\n        ;\n   INFILE SMF LENGTH=L;\n   INPUT @2 ID PIB1. @;\n   IF ID = 71  THEN LINK X5;\n   RETURN;\nX5:\nPOINTER = 11;\nM = -3;\nINPUT @ POINTER\n                SMF71SID  $CHAR4.\n            +10 SMF71PRS  PIB4.\n             +4 SMF71PDS  PIB4.\n                 @;\nPOINTER = SMF71PRS +M;\nINPUT @ POINTER\n           +10  SMF71IST  PD4.\n                SMF71DAT  PD4.\n                SMF71INT  PD4.\n                 @;\nPOINTER = SMF71PDS +M;\nINPUT @ POINTER\n                SMF71PIN  PIB4.\n                SMF71POT  PIB4.\n             +8 SMF71SIN  PIB4.\n                SMF71SOT  PIB4.\n                SMF71VIN  PIB4.\n                SMF71VOT  PIB4.\n                 @;\n   IF SMF71INT LT 0100000 THEN DELETE;\n*              *********              ***;\n*                *****                ***;\n   S71SID = SMF71SID ;\n   S71DAT = SMF71DAT ;\n   S71IST = SMF71IST ;\n   S71INT = SMF71INT ;\n   MIN = FLOOR(SMF71INT / 100000) ;\n   SEC = FLOOR((SMF71INT - MIN * 100000) / 1000) ;\n   INTSEC = (MIN * 60) + SEC ;\n**** THE DURATION OF THE INTERVAL IS NOW IN SECONDS ;\n   HH = FLOOR(SMF71IST / 10000) ;\n   MM = FLOOR((SMF71IST - HH * 10000) / 100) ;\n   SS = SMF71IST - ((HH * 10000) + (MM * 100)) ;\n   ISTSEC = (HH * 3600) + (MM * 60) + SS ;\n**** THIS IS TO PUT THE STARTING INTERVAL TIME IN SECS ;\n   ENDSEC = ISTSEC + INTSEC ;\n   ENDHR = FLOOR(ENDSEC / 3600) ;\n   PAGES = SMF71SIN + SMF71SOT + SMF71PIN +SMF71POT +\n       SMF71VIN + SMF71VOT ;\n   SECS  = INTSEC;\n   PGSEC = PAGES / SECS;\n**                                                     ;\n**  OUTPUT DATA FOR EACH SYSTEM THAT YOU WANT TO SAVE.         ;\n**                                                             ;\n**               SMF-ID                   P1718811             ;\n**                 |                      P1.........SYSTEM    ;\n**                 |                        71.......REC NUMBER;\n**                 |                          WK.....CONSTANT  ;\n**                 |                            09...WK NUMBER ;\n**                 V                                           ;\n   IF SMF71SID = 'P1S2' THEN OUTPUT SASDB.P171WK02 ;\n   IF SMF71SID = 'P0S3' THEN OUTPUT SASDB.P071WK02 ;\n   IF SMF71SID = 'S1S1' THEN OUTPUT SASDB.S171WK02 ;\nRETURN;\n    %\nINPUTIT;\n   PROC PRINT DATA=SASDB.P171WK02;\n   PROC PRINT DATA=SASDB.P071WK02;\n   PROC PRINT DATA=SASDB.S171WK02;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMF71WJ": {"ttr": 3330, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PULL OFF RMF RECORD 71 INFORMATION.  PAGING ACTIVITY FOR\n//*  ONE WEEK.\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(RMF71W)\n//SMF   DD DISP=SHR,DSN=XY.RMFWEEK\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RMF72": {"ttr": 3332, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n|   SMF DATA FOR TSO RESPONSE TIME                                  |\n|   ONLY LOOKING AT SMF TYPE 72 RECORDS. FOR MVS/XA SYSTEMS         |\n|                                                                   |\n|   DATA MUST BE SORTED BEFORE BEING USED BY                        |\n|         SMF72SID,SMF72DAT,SMF72IST                                |\n|         (JUST USE THE SORT MEMBER)                                |\n|                                                                   |\n| ----                       -----                            ----  |\n|   SINCE THE DATA IS SAVED BY SYSTEM ID (SMF ID) THEN THE ONLY     |\n|   THING THAT MAKES THESE PROGRAMS INSTALLATION DEPENDANT ARE      |\n|   1) THE LITERALS FOR CHECKING THE SYSTEM ID                      |\n|       -LOCATED AT THE END OF THE PROGRAM                          |\n|   2) THE MEMBER NAME THAT IS GIVEN TO THE SAS DATASET (ONE FOR    |\n|      EACH SYSTEM)                                                 |\n|       -LOCATED IN THE BEGINING (DATA STATEMENT)                   |\n|        AND AT THE END, FOLLOWING THE \"OUTPUT\" STATEMENTS          |\n|                                                                   |\n|   IN ADDITION, SINCE THE DATA IS NORMALLY STORED BY MONTH         |\n|   THEN THE MEMBER NAMES REFERENCED IN NUMBER 2 ABOVE              |\n|   IS CHANGED SLIGHTLY EACH MONTH TO REFLECT THE MONTH AND YEAR.   |\n| ----                       -----                            ----  |\n|                                                                   |\n|    THIS JOB PICKS UP TRANSACTIONS IN CERTAIN PERFORMANCE          |\n|   GROUPS (PG) (CURRENTLY PG NUMBERS 2 AND 3)                      |\n|   AND CALCULATES RESPONSE TIME BY PG AND BY                       |\n|   EACH PERIOD WITHIN THAT PERFORMANCE GROUP.                      |\n|                                                                   |\n|   NOTE: THIS PROGRAM ASSUMES THAT EACH TSO PERFORMANCE            |\n|         GROUP HAS FOUR PERIODS. YOU MAY ONLY NEED TRIVIAL         |\n|         AND AVERAGE.                                              |\n|                                                                   |\n|    THIS SAS FILE THEN CAN BE USED AS INPUT TO CREATE A GRAPH      |\n|   EITHER ON THE TERMINAL OR TO A PRINTER USING GDDM.              |\n|                                                                   |\n|   SMF72RTY...... RECORD TYPE.                                     |\n|   SMF72SID...... SID.                                             |\n|   SMF72IST...... TIME RMF MEASUREMENT INTERVAL STARTED IN FORM    |\n|                  0HHMMSSF WHERE F IS THE SIGN.                    |\n|   SMF72DAT...... DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED    |\n|                  (F IS THE SIGN).                                 |\n|   SMF72INT...... DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|   SMF72TTM...... ELAPSED TIME IN 1024 MICRO SECONDS.              |\n|   SMF72TTX...... NUMBER OF ENDED TRANSACTIONS.                    |\n|                                                                   |\n|   RTTOT......... TOTAT RESPONSE TIME                              |\n|   TTXTOT........ TOTAL NUMBER OF ENDED TRANSACTIONS               |\n|   RTP1.......... RESPONSE TIME PERIOD 1                           |\n|   RTP2.......... RESPONSE TIME PERIOD 2                           |\n|   RTP3.......... RESPONSE TIME PERIOD 3                           |\n|   RTP4.......... RESPONSE TIME PERIOD 4                           |\n|   S72SUB........ PERFORMANCE GROUP NUMBER                         |\n|   S72IST........ TIME RMF MEASUREMENT INTERVAL STARTED.           |\n|   S72DAT......   DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED.   |\n|   S72INT......   DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|                                                                   |\n|                                                                   |\n|   OUTPUT FILE NAME = SID...REC NO...YEAR...MONTH                  |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|    E.G.   S1728901 = S1 ...  72  ...88  ... 11                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.S1728901 TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|           C   8809   8810                                         |\n|          FOR EACH OCCURRENCE (A CHANGE ALL WILL WORK BUT IT       |\n|          ALSO CHANGES THE DIRECTIONS).                            |\n|                                                                   |\n|   UPDATE: ADDED 2 MORE PERIODS TO PG3 TO REFLECT ACTUAL CASE.     |\n|                                                                   |\n|                                                                   |\n|                                                                   |\n*-------------------------------------------------------------------*\n;\n   MACRO INPUTIT\n   DATA\n  SASDB.P1P28901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.P0P28901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.S3P28901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.S2P28901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.S1P28901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.P1P38901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.P0P38901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.S3P38901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.S2P38901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n  SASDB.S1P38901 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                          S72DAT S72IST S72INT S72SID S72SUB)\n        ;\n   INFILE SMF LENGTH=L ;\n   INPUT @2 ID PIB1. @;\n   IF ID = 72  THEN LINK X5;\n   RETURN;\nX5:\nPOINTER = 11;\nM = -3;\nINPUT @ POINTER\n                SMF72SID  $CHAR4.\n            +10 SMF72PRS  PIB4.\n            + 4 SMF72WLS  PIB4.\n            + 4 SMF72PGS  PIB4.\n                SMF72PGL  PIB2.\n                SMF72PGN  PIB2.\n                 @;\nPOINTER = SMF72PRS +M;\nINPUT @ POINTER\n           +10  SMF72IST  PD4.\n                SMF72DAT  PD4.\n                SMF72INT  PD4.\n            +2  SMF72SAM  PIB4.\n                 @;\nPOINTER = SMF72WLS +M;\n  INPUT @ POINTER\n            + 2 SMF72SUB  PIB2.\n                   @;\nPOINTER = SMF72PGS +M;\nINPUT @ POINTER\n                SMF72TTX  PIB4.\n            + 8 SMF72TTM  PIB4.\n            +20 SMF72SPP  PIB4.\n            + 8 SMF72ET1  PIB4.\n                SMF72ET2  PIB4.\n                 @;\nIF SMF72SUB =  2 OR SMF72SUB = 3 THEN GO TO PROC_IT;\n   ELSE RETURN                /* CAN ONLY HANDLE PG 2 OR 3   */;\nPROC_IT:\n   IF SMF72INT LT 0100000 THEN DELETE;\n*              *********              ***;\n  S72IST = SMF72IST;\n  S72DAT = SMF72DAT;\n  S72INT = SMF72INT;\n  S72SID = SMF72SID;\n  S72SUB = SMF72SUB        /* SAVE PERFORMANCE GROUP NUMBER       */;\n  ETTOT   = 0              /* ELAPSED TIME TOTAL IN MICRO SECONDS */;\n  TTXTOT  = 0              /* ENDED TRANSACTIONS TOTAL            */;\n  PGP_CTR = 1              /* PERFORMANCE GROUP PERIOD            */;\n  POINTER = SMF72PGS +M    /* INSURE POINTER IS IN CORRECT SPOT   */;\nIF SMF72SUB =  2 THEN GO TO PG2P_LP    /* PERF GROUP 2 ROUTINE    */;\nIF SMF72SUB =  3 THEN GO TO PG3P_LP    /* PERF GROUP 3 ROUTINE    */;\nRETURN                     /* PERFORM GROU\u00a2 SLIPPED THROUGH       */;\nPG2P_LP:\n  ETTOT  = ETTOT  + SMF72TTM     /* ELPSED TIME IN 1024 MICRO SEC  */;\n  TTXTOT = TTXTOT + SMF72TTX     /* NUMBER OF ENDED TRANSACTIONS   */;\n  ETSECP = (SMF72TTM * 1024)/1000000  /* CONVERT TO SECONDS        */;\n  IF SMF72TTX = 0 THEN RTP = 0 ;\n  ELSE RTP = ETSECP/SMF72TTX        /* RESPONSE TIME FOR PG PERIOD */;\n  IF PGP_CTR = 01 THEN RTP1 = RTP /* RESPONSE TIME FOR PERIOD 1    */;\n  IF PGP_CTR = 02 THEN RTP2 = RTP /* RESPONSE TIME FOR PERIOD 2    */;\n  IF PGP_CTR = 03 THEN RTP3 = RTP /* RESPONSE TIME FOR PERIOD 3    */;\n  IF PGP_CTR = 04 THEN RTP4 = RTP /* RESPONSE TIME FOR PERIOD 4    */;\n  IF SMF72PGN = PGP_CTR\n     THEN GO TO PG2P_END         /* NO MORE PERIODS   */;\n  PGP_CTR = PGP_CTR + 1         /* NEXT PERIOD IN PG              */;\n  POINTER = POINTER + SMF72PGL   /* POINT TO NEXT PERIOD           */;\nINPUT @ POINTER\n                SMF72TTX  PIB4.\n            + 8 SMF72TTM  PIB4.\n            +20 SMF72SPP  PIB4.\n            + 8 SMF72ET1  PIB4.\n                SMF72ET2  PIB4.\n                 @;\n  GO TO PG2P_LP;\nPG2P_END:\n  GO TO CNT_CALC                    /* ALL DONE WITH PERIODS       */;\nPG3P_LP:\n  ETTOT  = ETTOT  + SMF72TTM     /* ELPSED TIME IN 1024 MICRO SEC  */;\n  TTXTOT = TTXTOT + SMF72TTX     /* NUMBER OF ENDED TRANSACTIONS   */;\n  ETSECP = (SMF72TTM * 1024)/1000000  /* CONVERT TO SECONDS        */;\n  IF SMF72TTX = 0 THEN RTP = 0 ;\n  ELSE RTP = ETSECP/SMF72TTX        /* RESPONSE TIME FOR PG PERIOD */;\n  IF PGP_CTR = 01 THEN RTP1 = RTP /* RESPONSE TIME FOR PERIOD 1    */;\n  IF PGP_CTR = 02 THEN RTP2 = RTP /* RESPONSE TIME FOR PERIOD 2    */;\n  IF PGP_CTR = 03 THEN RTP3 = RTP /* RESPONSE TIME FOR PERIOD 3    */;\n  IF PGP_CTR = 04 THEN RTP4 = RTP /* RESPONSE TIME FOR PERIOD 4    */;\n  IF SMF72PGN = PGP_CTR\n     THEN GO TO PG3P_END         /* NO MORE PERIODS   */;\n  PGP_CTR = PGP_CTR + 1         /* NEXT PERIOD IN PG              */;\n  POINTER = POINTER + SMF72PGL   /* POINT TO NEXT PERIOD           */;\nINPUT @ POINTER\n                SMF72TTX  PIB4.\n            + 8 SMF72TTM  PIB4.\n            +20 SMF72SPP  PIB4.\n            + 8 SMF72ET1  PIB4.\n                SMF72ET2  PIB4.\n                 @;\n  GO TO PG3P_LP;\nPG3P_END:\n  GO TO CNT_CALC                    /* ALL DONE WITH PERIODS       */;\nCNT_CALC:\n  ETSECS = (ETTOT * 1024) / 1000000 /* CONVERT TO TOTAL SECONDS    */;\n IF TTXTOT = 0 OR TTXTOT = . THEN DO  ;\n  TTXTOT = 0                   /* NO TRANSACTIONS FOR THIS PERIOD */;\n  RTTOT  = 0                   /* TOTAL RESPONSE TIME             */;\n  GO TO SAVE_IT;\n END;\n  ELSE RTTOT  = ETSECS / TTXTOT   /* TOTAL RESPONSE TIME FOR PG   */;\nSAVE_IT:\n**                                                     ;\n**  OUTPUT DATA FOR EACH SYSTEM THAT YOU WANT TO SAVE.         ;\n**                                                             ;\n**               SMF-ID                   P1718901             ;\n**                 |                      P1.........SYSTEM    ;\n**                 |                        71.......REC NUMBER;\n**                 |                          88.....YEAR      ;\n**                 |                            11...MONTH     ;\n**                 V                                           ;\n   IF S72SID = 'P1S2' AND S72SUB = 2 THEN\n      OUTPUT  SASDB.P1P28901;\n   IF S72SID = 'P1S2' AND S72SUB = 3 THEN\n      OUTPUT  SASDB.P1P38901;\n   IF S72SID = 'P0S3' AND S72SUB = 2 THEN\n      OUTPUT  SASDB.P0P28901;\n   IF S72SID = 'P0S3' AND S72SUB = 3 THEN\n      OUTPUT  SASDB.P0P38901;\n   IF S72SID = 'S3S3' AND S72SUB = 2 THEN\n      OUTPUT  SASDB.S3P28901;\n   IF S72SID = 'S3S3' AND S72SUB = 3 THEN\n      OUTPUT  SASDB.S3P38901;\n   IF S72SID = 'S2S2' AND S72SUB = 2 THEN\n      OUTPUT  SASDB.S2P28901;\n   IF S72SID = 'S2S2' AND S72SUB = 3 THEN\n      OUTPUT  SASDB.S2P38901;\n   IF S72SID = 'S1S1' AND S72SUB = 2 THEN\n      OUTPUT  SASDB.S1P28901;\n   IF S72SID = 'S1S1' AND S72SUB = 3 THEN\n      OUTPUT  SASDB.S1P38901;\nRETURN;\n   %\n   INPUTIT;\n   PROC PRINT DATA= SASDB.P1P28901 ;\n   PROC PRINT DATA= SASDB.P1P38901 ;\n   PROC PRINT DATA= SASDB.P0P28901 ;\n   PROC PRINT DATA= SASDB.P0P38901 ;\n   PROC PRINT DATA= SASDB.S3P28901 ;\n   PROC PRINT DATA= SASDB.S3P38901 ;\n   PROC PRINT DATA= SASDB.S2P28901 ;\n   PROC PRINT DATA= SASDB.S2P38901 ;\n   PROC PRINT DATA= SASDB.S1P28901 ;\n   PROC PRINT DATA= SASDB.S1P38901 ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMF72J": {"ttr": 3337, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PULL OFF RMF RECORD 72 INFORMATION.  THIS INCLUDES TSO USERS\n//*  CPU TIME BATCH USERS ETC. STORE INFO ON SAS DATA BASE.\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(RMF72)\n//SMF   DD DISP=SHR,DSN=XY.RMFWEEK          <==RMF INPUT\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,           <==OUTPUT (SAS DATASET)\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RMF72W": {"ttr": 3339, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*-------------------------------------------------------------------*\n| **THIS PROGRAM IS THE SAME AS RMF72 EXCEPT IT STORES DATA   **    |\n| **BY WEEK RATHER THAN BY MONTH. IT DOES THIS BY SAVEING     **    |\n| **THE DATA WITH A DIFFERENT NAME (CONTAINS THE CHARACTERS   **    |\n| **\"WK\" IN THE SAS NAME). COMPARE THE DATA STATEMENTS TO SEE **    |\n| **THE DIFFERENCE.                                           **    |\n| **CREATED FROM RMF72 ON 3/16/89                             **    |\n|                                                                   |\n+-------------------------------------------------------------------+\n|   SMF DATA FOR TSO RESPONSE TIME                                  |\n|   ONLY LOOKING AT SMF TYPE 72 RECORDS. FOR MVS/XA SYSTEMS         |\n|                                                                   |\n|   DATA MUST BE SORTED BEFORE BEING USED BY                        |\n|         SMF72SID,SMF72DAT,SMF72IST                                |\n|         (JUST USE THE SORT MEMBER)                                |\n|                                                                   |\n| ----                       -----                            ----  |\n|   SINCE THE DATA IS SAVED BY SYSTEM ID (SMF ID) THEN THE ONLY     |\n|   THING THAT MAKES THESE PROGRAMS INSTALLATION DEPENDANT ARE      |\n|   1) THE LITERALS FOR CHECKING THE SYSTEM ID                      |\n|       -LOCATED AT THE END OF THE PROGRAM                          |\n|   2) THE MEMBER NAME THAT IS GIVEN TO THE SAS DATASET (ONE FOR    |\n|      EACH SYSTEM)                                                 |\n|       -LOCATED IN THE BEGINING (DATA STATEMENT)                   |\n|        AND AT THE END, FOLLOWING THE \"OUTPUT\" STATEMENTS          |\n|                                                                   |\n|   IN ADDITION, SINCE THE DATA IS NORMALLY STORED BY MONTH         |\n|   THEN THE MEMBER NAMES REFERENCED IN NUMBER 2 ABOVE              |\n|   IS CHANGED SLIGHTLY EACH MONTH TO REFLECT THE MONTH AND YEAR.   |\n| ----                       -----                            ----  |\n|                                                                   |\n|    THIS JOB PICKS UP TRANSACTIONS IN CERTAIN PERFORMANCE          |\n|   GROUPS (PG) (CURRENTLY PG NUMBERS 2 AND 3)                      |\n|   AND CALCULATES RESPONSE TIME BY PG AND BY                       |\n|   EACH PERIOD WITHIN THAT PERFORMANCE GROUP.                      |\n|                                                                   |\n|   NOTE: THIS PROGRAM ASSUMES THAT EACH TSO PERFORMANCE            |\n|         GROUP HAS FOUR PERIODS. YOU MAY ONLY NEED TRIVIAL         |\n|         AND AVERAGE.                                              |\n|                                                                   |\n|    THIS SAS FILE THEN CAN BE USED AS INPUT TO CREATE A GRAPH      |\n|   EITHER ON THE TERMINAL OR TO A PRINTER USING GDDM.              |\n|                                                                   |\n|   SMF72RTY...... RECORD TYPE.                                     |\n|   SMF72SID...... SID.                                             |\n|   SMF72IST...... TIME RMF MEASUREMENT INTERVAL STARTED IN FORM    |\n|                  0HHMMSSF WHERE F IS THE SIGN.                    |\n|   SMF72DAT...... DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED    |\n|                  (F IS THE SIGN).                                 |\n|   SMF72INT...... DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|   SMF72TTM...... ELAPSED TIME IN 1024 MICRO SECONDS.              |\n|   SMF72TTX...... NUMBER OF ENDED TRANSACTIONS.                    |\n|                                                                   |\n|   RTTOT......... TOTAT RESPONSE TIME                              |\n|   TTXTOT........ TOTAL NUMBER OF ENDED TRANSACTIONS               |\n|   RTP1.......... RESPONSE TIME PERIOD 1                           |\n|   RTP2.......... RESPONSE TIME PERIOD 2                           |\n|   RTP3.......... RESPONSE TIME PERIOD 3                           |\n|   RTP4.......... RESPONSE TIME PERIOD 4                           |\n|   S72SUB........ PERFORMANCE GROUP NUMBER                         |\n|   S72IST........ TIME RMF MEASUREMENT INTERVAL STARTED.           |\n|   S72DAT......   DATE AS 00YYDDDF MEASUREMENT INTERVAL STARTED.   |\n|   S72INT......   DURATION OF RMF MEASUREMENT INTERVAL IN FORM     |\n|                  MMSSTTTF WHERE F IS THE SIGN.                    |\n|                                                                   |\n|                                                                   |\n|   OUTPUT FILE NAME = SID...REC NO...WK.....WEEK NUMBER...         |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|                       \u00a6       \u00a6      \u00a6       \u00a6                    |\n|    E.G.   S1728901 = S1 ...  72  ...WK  ... 09                    |\n|                                                                   |\n|                                                                   |\n|   NOTE1: CHANGE SASDB.S172WKXX TO TEST0 FOR TEMPORARY DATASET     |\n|                                                                   |\n|   NOTE2: MONTHLY USE. IF THE LAST MONTH STORED WAS SEP 1988       |\n|          AND YOU WANT TO SAVE OCT 1988 DATA THEN ENTER THE        |\n|          FOLLOWING CHANGE COMMANDS:                               |\n|           C   WK09   WK10 ALL                                     |\n|          FOR EACH OCCURRENCE.                                     |\n|                                                                   |\n|   UPDATE: ADDED 2 MORE PERIODS TO PG3 TO REFLECT ACTUAL CASE.     |\n|                                                                   |\n|                                                                   |\n|                                                                   |\n*-------------------------------------------------------------------*\n;\n   MACRO INPUTIT\n   DATA\n  SASDB.P1P2WK02 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                  S72INT S72SID S72DAT S72IST S72SUB)\n  SASDB.P0P2WK02 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                  S72INT S72SID S72DAT S72IST S72SUB)\n  SASDB.S1P2WK02 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                  S72INT S72SID S72DAT S72IST S72SUB)\n  SASDB.P1P3WK02 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                  S72INT S72SID S72DAT S72IST S72SUB)\n  SASDB.P0P3WK02 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                  S72INT S72SID S72DAT S72IST S72SUB)\n  SASDB.S1P3WK02 (KEEP=RTTOT TTXTOT RTP1 RTP2 RTP3 RTP4\n                  S72INT S72SID S72DAT S72IST S72SUB)\n        ;\n   INFILE SMF LENGTH=L ;\n   INPUT @2 ID PIB1. @;\n   IF ID = 72  THEN LINK X5;\n   RETURN;\nX5:\nPOINTER = 11;\nM = -3;\nINPUT @ POINTER\n                SMF72SID  $CHAR4.\n            +10 SMF72PRS  PIB4.\n            + 4 SMF72WLS  PIB4.\n            + 4 SMF72PGS  PIB4.\n                SMF72PGL  PIB2.\n                SMF72PGN  PIB2.\n                 @;\nPOINTER = SMF72PRS +M;\nINPUT @ POINTER\n           +10  SMF72IST  PD4.\n                SMF72DAT  PD4.\n                SMF72INT  PD4.\n            +2  SMF72SAM  PIB4.\n                 @;\nPOINTER = SMF72WLS +M;\n  INPUT @ POINTER\n            + 2 SMF72SUB  PIB2.\n                   @;\nPOINTER = SMF72PGS +M;\nINPUT @ POINTER\n                SMF72TTX  PIB4.\n            + 8 SMF72TTM  PIB4.\n            +20 SMF72SPP  PIB4.\n            + 8 SMF72ET1  PIB4.\n                SMF72ET2  PIB4.\n                 @;\nIF SMF72SUB =  2 OR SMF72SUB = 3 THEN GO TO PROC_IT;\n   ELSE RETURN                /* CAN ONLY HANDLE PG 2 OR 3   */;\nPROC_IT:\n   IF SMF72INT LT 0100000 THEN DELETE;\n*              *********              ***;\n  S72IST = SMF72IST;\n  S72DAT = SMF72DAT;\n  S72INT = SMF72INT;\n  S72SID = SMF72SID;\n  S72SUB = SMF72SUB        /* SAVE PERFORMANCE GROUP NUMBER       */;\n  ETTOT   = 0              /* ELAPSED TIME TOTAL IN MICRO SECONDS */;\n  TTXTOT  = 0              /* ENDED TRANSACTIONS TOTAL            */;\n  PGP_CTR = 1              /* PERFORMANCE GROUP PERIOD            */;\n  POINTER = SMF72PGS +M    /* INSURE POINTER IS IN CORRECT SPOT   */;\nIF SMF72SUB =  2 THEN GO TO PG2P_LP    /* PERF GROUP 2 ROUTINE    */;\nIF SMF72SUB =  3 THEN GO TO PG3P_LP    /* PERF GROUP 3 ROUTINE    */;\nRETURN                     /* PERFORM GROU\u00a2 SLIPPED THROUGH       */;\nPG2P_LP:\n  ETTOT  = ETTOT  + SMF72TTM     /* ELPSED TIME IN 1024 MICRO SEC  */;\n  TTXTOT = TTXTOT + SMF72TTX     /* NUMBER OF ENDED TRANSACTIONS   */;\n  ETSECP = (SMF72TTM * 1024)/1000000  /* CONVERT TO SECONDS        */;\n  IF SMF72TTX = 0 THEN RTP = 0 ;\n  ELSE RTP = ETSECP/SMF72TTX        /* RESPONSE TIME FOR PG PERIOD */;\n  IF PGP_CTR = 01 THEN RTP1 = RTP /* RESPONSE TIME FOR PERIOD 1    */;\n  IF PGP_CTR = 02 THEN RTP2 = RTP /* RESPONSE TIME FOR PERIOD 2    */;\n  IF PGP_CTR = 03 THEN RTP3 = RTP /* RESPONSE TIME FOR PERIOD 3    */;\n  IF PGP_CTR = 04 THEN RTP4 = RTP /* RESPONSE TIME FOR PERIOD 4    */;\n  IF SMF72PGN = PGP_CTR\n     THEN GO TO PG2P_END         /* NO MORE PERIODS   */;\n  PGP_CTR = PGP_CTR + 1         /* NEXT PERIOD IN PG              */;\n  POINTER = POINTER + SMF72PGL   /* POINT TO NEXT PERIOD           */;\nINPUT @ POINTER\n                SMF72TTX  PIB4.\n            + 8 SMF72TTM  PIB4.\n            +20 SMF72SPP  PIB4.\n            + 8 SMF72ET1  PIB4.\n                SMF72ET2  PIB4.\n                 @;\n  GO TO PG2P_LP;\nPG2P_END:\n  GO TO CNT_CALC                    /* ALL DONE WITH PERIODS       */;\nPG3P_LP:\n  ETTOT  = ETTOT  + SMF72TTM     /* ELPSED TIME IN 1024 MICRO SEC  */;\n  TTXTOT = TTXTOT + SMF72TTX     /* NUMBER OF ENDED TRANSACTIONS   */;\n  ETSECP = (SMF72TTM * 1024)/1000000  /* CONVERT TO SECONDS        */;\n  IF SMF72TTX = 0 THEN RTP = 0 ;\n  ELSE RTP = ETSECP/SMF72TTX        /* RESPONSE TIME FOR PG PERIOD */;\n  IF PGP_CTR = 01 THEN RTP1 = RTP /* RESPONSE TIME FOR PERIOD 1    */;\n  IF PGP_CTR = 02 THEN RTP2 = RTP /* RESPONSE TIME FOR PERIOD 2    */;\n  IF PGP_CTR = 03 THEN RTP3 = RTP /* RESPONSE TIME FOR PERIOD 3    */;\n  IF PGP_CTR = 04 THEN RTP4 = RTP /* RESPONSE TIME FOR PERIOD 4    */;\n  IF SMF72PGN = PGP_CTR\n     THEN GO TO PG3P_END         /* NO MORE PERIODS   */;\n  PGP_CTR = PGP_CTR + 1         /* NEXT PERIOD IN PG              */;\n  POINTER = POINTER + SMF72PGL   /* POINT TO NEXT PERIOD           */;\nINPUT @ POINTER\n                SMF72TTX  PIB4.\n            + 8 SMF72TTM  PIB4.\n            +20 SMF72SPP  PIB4.\n            + 8 SMF72ET1  PIB4.\n                SMF72ET2  PIB4.\n                 @;\n  GO TO PG3P_LP;\nPG3P_END:\n  GO TO CNT_CALC                    /* ALL DONE WITH PERIODS       */;\nCNT_CALC:\n  ETSECS = (ETTOT * 1024) / 1000000 /* CONVERT TO TOTAL SECONDS    */;\n IF TTXTOT = 0 OR TTXTOT = . THEN DO  ;\n  TTXTOT = 0                   /* NO TRANSACTIONS FOR THIS PERIOD */;\n  RTTOT  = 0                   /* TOTAL RESPONSE TIME             */;\n  GO TO SAVE_IT;\n END;\n  ELSE RTTOT  = ETSECS / TTXTOT   /* TOTAL RESPONSE TIME FOR PG   */;\nSAVE_IT:\n**                                                     ;\n**  OUTPUT DATA FOR EACH SYSTEM THAT YOU WANT TO SAVE.         ;\n**                                                                  ;\n**               SMF-ID                   P171WK09                  ;\n**                 |                      PX.........PG NUMBER      ;\n**                 |                                 E.G. P2 = PG 2 ;\n**                 |                        71.......REC NUMBER     ;\n**                 |                          WK.....CONSTANT       ;\n**                 |                            09...WEEK NUMBER    ;\n**                 V                                                ;\n   IF S72SID = 'P1S2' AND S72SUB = 2 THEN\n      OUTPUT  SASDB.P1P2WK02;\n   IF S72SID = 'P1S2' AND S72SUB = 3 THEN\n      OUTPUT  SASDB.P1P3WK02;\n   IF S72SID = 'P0S3' AND S72SUB = 2 THEN\n      OUTPUT  SASDB.P0P2WK02;\n   IF S72SID = 'P0S3' AND S72SUB = 3 THEN\n      OUTPUT  SASDB.P0P3WK02;\n   IF S72SID = 'S1S1' AND S72SUB = 2 THEN\n      OUTPUT  SASDB.S1P2WK02;\n   IF S72SID = 'S1S1' AND S72SUB = 3 THEN\n      OUTPUT  SASDB.S1P3WK02;\nRETURN;\n   %\n   INPUTIT;\n   PROC PRINT DATA= SASDB.P1P2WK02 ;\n   PROC PRINT DATA= SASDB.P1P3WK02 ;\n   PROC PRINT DATA= SASDB.P0P2WK02 ;\n   PROC PRINT DATA= SASDB.P0P3WK02 ;\n   PROC PRINT DATA= SASDB.S1P2WK02 ;\n   PROC PRINT DATA= SASDB.S1P3WK02 ;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMF72WJ": {"ttr": 3344, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*  PULL OFF RMF RECORD 72 INFORMATION.  THIS INCLUDES TSO USERS\n//*  CPU TIME BATCH USERS ETC. STORE INFO ON SAS DATA BASE.\n//*\n//STEP1  EXEC SAS\n//SAS.FT11F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SAS.FT12F001 DD SYSOUT=*,DCB=(BLKSIZE=141,LRECL=137,RECFM=VBA)\n//SYSIN DD DISP=SHR,DSN=XY.TC.A.SASCPU(RMF72W)\n//SMF   DD DISP=SHR,DSN=XY.RMFWEEK          <==RMF INPUT\n//SASDB DD DSN=XY.TC.A.SASDB.CPU,           <==OUTPUT (SAS DATASET)\n//   DISP=OLD\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RM1CPMAX": {"ttr": 3585, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\n*OPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\n*OPTIONS HSIZE=8 VSIZE=7;\nTITLE1 J=C H=2 F=SIMPLEX C=WHITE\n  'REGRESSION ANALYSIS OF MAXIMUM CPU UTILIZATION BY DAY';\nTITLE2    J=C H=1.5 F=SIMPLEX C=WHITE\n  'JAN THROUGH MAY 26, 1989 : 3090-400E SERIAL # &S70SER';\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE '    RM1CPMAX: TECHNICAL SUPPORT';\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED\n  '    RED LINE IS REGRESSION LINE ';\nFOOTNOTE3 J=R H=1 F=SIMPLEX C=WHITE\n  '    NOTE: NOON HOUR EXCLUDED FROM AVERAGE';\nSYMBOL1 W=1 C=GREEN V=DIAMOND I=JOIN;\nSYMBOL2 W=1 C=CYAN V=STAR I=JOIN;\nSYMBOL3 W=1 C=RED V=SQUARE I=JOIN;\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY CPUTOT.\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH DAY FOR\n*       ONE PHYSICAL PROCESSOR COMPLEX.\n*       THE NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n*       DOES A REGRESSION ANALYSIS ON THE ABOVE MENTIONED DATA.\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.2\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.UTM18901\n      SASDB.UTM18902\n      SASDB.UTM18903\n      SASDB.UTM18904\n      SASDB.UTM1WK01\n      SASDB.UTM1WK02\n      SASDB.UTM1WK03\n      SASDB.UTM1WK04\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n* LUNCH TIME                 ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8901) ;\n%INCLUDE DD1(EX8902) ;\n%INCLUDE DD1(EX8903) ;\n%INCLUDE DD1(EX8904) ;\n%INCLUDE DD1(EX8905) ;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT;\nGHH  = HH;\nGDAT = S70DAT;\n OUTPUT TEST0    ;\nRETAIN;\nRETURN;\n PROC MEANS   NOPRINT;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MAX=MAXCPU;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM MAXCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=GREEN I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=RED   I=JOIN V=DIAMOND ;\n  PROC GLM ;\n  MODEL MAXCPU= GNUM/P;\n  OUTPUT  PREDICTED = PMAXCPU\n          RESIDUAL = RESID;\nPROC PRINT;\n  PROC GPLOT;\n   PLOT MAXCPU*GNUM=1   PMAXCPU*GNUM=2   / OVERLAY\n  VAXIS = 0 TO 100 BY 10\n   VREF = 75\n   CVREF = RED\n   LVREF = 2\n   ;\nRUN;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RM1CPU": {"ttr": 3588, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\n*OPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\n*OPTIONS HSIZE=8 VSIZE=7;\nTITLE1 J=C H=2 F=SIMPLEX C=WHITE\n  'REGRESSION ANALYSIS OF AVERAGE CPU UTILIZATION BY DAY';\nTITLE2    J=C H=1.5 F=SIMPLEX C=WHITE\n  'JANUARY 1989 THROUGH MAY 26, 1989 : 3090-400E SERIAL # &S70SER';\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE '    RM1CPU: TECHNICAL SUPPORT';\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED\n  '    RED LINE IS REGRESSION LINE ';\nFOOTNOTE3 J=R H=1 F=SIMPLEX C=WHITE\n  '    NOTE: Noon hour excluded from average';\nSYMBOL1 W=1 C=GREEN V=DIAMOND I=JOIN;\nSYMBOL2 W=1 C=CYAN V=STAR I=JOIN;\nSYMBOL3 W=1 C=RED V=SQUARE I=JOIN;\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY CPUTOT.\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH DAY FOR\n*       ONE PHYSICAL PROCESSOR COMPLEX.\n*       THE NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n*       DOES A REGRESSION ANALYSIS ON THE ABOVE MENTIONED DATA.\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.2\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.UTM18901\n      SASDB.UTM18902\n      SASDB.UTM18903\n      SASDB.UTM18904\n      SASDB.UTM1WK01\n      SASDB.UTM1WK02\n      SASDB.UTM1WK03\n      SASDB.UTM1WK04\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n* LUNCH TIME                 ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8901) ;\n%INCLUDE DD1(EX8902) ;\n%INCLUDE DD1(EX8903) ;\n%INCLUDE DD1(EX8904) ;\n%INCLUDE DD1(EX8905) ;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT;\nGHH  = HH;\nGDAT = S70DAT;\n OUTPUT TEST0    ;\nRETAIN;\nRETURN;\n PROC MEANS   NOPRINT;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGCPU;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=GREEN I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=RED   I=JOIN V=DIAMOND ;\n  PROC GLM ;\n  MODEL AVGCPU= GNUM/P;\n  OUTPUT  PREDICTED = PAVGCPU\n          RESIDUAL = RESID;\nPROC PRINT;\n  PROC GPLOT;\n   PLOT AVGCPU*GNUM   PAVGCPU*GNUM   / OVERLAY\n   VAXIS = 0 TO 100 BY 10\n    VREF = 75\n   CVREF = RED\n   LVREF = 2\n  ;\nRUN;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RM1CPUW": {"ttr": 3591, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS NOCHARACTERS;\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\n*OPTIONS HSIZE=8 VSIZE=7;\nTITLE1 J=C H=1 F=XSWISSE C=WHITE\n  'REGRESSION ANALYSIS OF AVERAGE CPU UTILIZATION BY DAY';\nTITLE2    J=C H=1 F=SIMPLEX C=WHITE\n  'WEEK OF MAY 8, 1989 : 3090-400E SERIAL # &S70SER';\nFOOTNOTE1 J=L H=1 F=SIMPLEX C=WHITE 'RM1CPUW: TECHNICAL SUPPORT';\nFOOTNOTE2 J=L H=1 F=SIMPLEX C=RED\n  'RED LINE IS REGRESSION LINE ';\nFOOTNOTE3 J=R H=1 F=SIMPLEX C=WHITE\n  'NOTE: Noon hour excluded from average':\nSYMBOL1 W=1 C=GREEN V=DIAMOND I=JOIN;\nSYMBOL2 W=1 C=CYAN V=STAR I=JOIN;\nSYMBOL3 W=1 C=RED V=SQUARE I=JOIN;\n*\n*    THIS SAS JOB TAKES THE FILE CREATED BY CPUTOT.\n*       CALCULATES AVERAGE CPU UTILIZATION FOR EACH DAY FOR\n*       ONE PHYSICAL PROCESSOR COMPLEX.\n*       THE NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n*       DOES A REGRESSION ANALYSIS ON THE ABOVE MENTIONED DATA.\n*   ---------------------------------------------------------------\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.UTM18810\n*              SASDB.UTM18811\n*              SASDB.UTM18812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*    UPDATE INFORMATION:\n*       WORKS FOR MVS/SP 2.2\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GCPU_UT);\n  SET SASDB.UTM1WK02\n;\n   IF S70IST LT 090000 THEN DELETE ;\n   IF S70IST GT 155000 THEN DELETE ;\n* LUNCH TIME                 ;\nIF S70IST GE 120000 AND S70IST LT 130000\n   THEN DELETE;\n%INCLUDE DD1(EX8905) ;\n%INCLUDE DD1(EX8904) ;\n HH = FLOOR(S70IST/10000);\nGCPU_UT = CPU_UT;\nGHH  = HH;\nGDAT = S70DAT;\n OUTPUT TEST0    ;\nRETAIN;\nRETURN;\n PROC MEANS   NOPRINT;\n  VAR GCPU_UT;\n  BY GDAT;\n  OUTPUT OUT=TEST1 MEAN=AVGCPU;\n*PROC PRINT DATA=TEST1;\n  DATA TEST2\n       (KEEP=GDAT GNUM AVGCPU);\n  SET TEST1  ;\nGNUM = _N_ ;\nRETURN;\nSYMBOL1 W=1 C=GREEN I=JOIN V=STAR    L=4;\nSYMBOL2 W=1 C=RED   I=JOIN V=DIAMOND ;\n  PROC GLM ;\n  MODEL AVGCPU= GNUM/P;\n  OUTPUT  PREDICTED = PAVGCPU\n          RESIDUAL = RESID;\nPROC PRINT;\n  PROC GPLOT;\n   PLOT AVGCPU*GNUM   PAVGCPU*GNUM   / OVERLAY;\nRUN;\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RT213D": {"ttr": 3594, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "GOPTIONS NOTEXT82;\nGOPTIONS DEVICE=GDDMPCGX;\nGOPTIONS CBACK=CYAN ;\nGOPTIONS COLORS=(WHITE CYAN PINK BLUE GREEN YELLOW RED);\n*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87;\n*OPTIONS HSIZE=8 VSIZE=7;\nTITLE1    J=L H=1 F=NONE C=CYAN  '  ';\nTITLE2    J=C H=1 F=NONE C=CYAN\n  'TSO AVERAGE RESPONSE TIME FOR PERIOD 1 BY 1/2 HOUR INTERVALS';\nFOOTNOTE1 J=L H=1 F=NONE C=CYAN '  ';\nFOOTNOTE2 J=L H=1 F=NONE C=CYAN\n 'D2RT2  DEC 88 SOURCE:RMF DATA - SYSTEM 1';\n*\n*\n*    THIS SAS JOB TAKES THE FILE CREATED FROM RMF RECORD 70'S\n*       PRODUCES A GRAPH\n*\n*     TO READ IN MORE THAN ONE MONTH'S WORTH OF DATA\n*     CONCATENATE THE DATA AS FOLLOWS:\n*          SET SASDB.P0708810\n*              SASDB.P0708811\n*              SASDB.P0708812\n*\n*     AND THEN USE MULTIPLE %INCLUDES TO EXCLUDE CERTAIN\n*     DATES. FOR EXAMPLE,\n*           %INCLUDE DD1(EX8810)\n*           %INCLUDE DD1(EX8811)\n*           %INCLUDE DD1(EX8812)\n*\n*     YOU COULD, OF COURSE, COPY THE EXCLUDE INSTRUCTIONS\n*     INTO THE SAS PROGRAM BY ISSUING THE\n*     INCLUDE COMMAND ON THE COMMAND LINE AND THEN MOVING\n*     THOSE LINES OF CODE TO THE APPROPRIATE LOCATION.\n*\n*\n*       NUMBER OF DAYS DEPENDS ON THE INPUT.\n*\n;\n  DATA TEST0\n       (KEEP=GDAT GHH GRTP1 GRTP2 GRTP3 GRTTOT) ;\n  SET SASDB.P0P28812\n  ;\n   IF S72IST LT 090000 THEN DELETE ;\n   IF S72IST GT 155000 THEN DELETE ;\n%INCLUDE DD1(EX8812)        ;\n HH = FLOOR(S72IST/100);\nGRTP1 = RTP1;\nGRTP2 = RTP2;\nGRTP3 = RTP3;\nGRTTOT= RTTOT;\nGHH  = HH ;\nGDAT = S72DAT;\n OUTPUT TEST0;\nRETAIN;\nRETURN;\n*PROC PRINT DATA=TEST0;\n  DATA TEST1\n       (KEEP=GDAT GNUM GHH GRTP1 GRTP2 GRTP3 GRTTOT);\n  SET TEST0\n  ;\nGNUM = _N_ ;\nIF GHH = 1249 THEN GHH = 1230;\nRETURN ;\n*PROC PRINT DATA=TEST1;\n   PROC G3D   DATA = TEST1    /*GOUT=TCCAT.GRAPH*/  ;\n        PLOT GDAT*GHH=GRTP1/ CAXIS = CYAN\n            CTEXT = CYAN  CTOP = RED    CBOTTOM = BLUE\n            XTICKNUM=14\n            YTICKNUM=0\n            ZTICKNUM=10 ZMIN=0 ZMAX=1.8\n            GRID\n            TILT=60 90  ROTATE = 60 90\n          NAME='XRT213D'\n          DES='TSO P1 RT 3D DEC 87'\n  ;\nRUN;\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SASCLIST": {"ttr": 3597, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "        PROC 0\n        CONTROL MSG PROMPT\n        FREE FI(SASDB)\n        FREE FI(DD1)\n        ALLOC FI(SASDB) DA('XY.TC.A.SASDB.CPU')\n        ALLOC FI(DD1)     DA('XY.TC.A.SASCPU') SHR\n        %SAS\n        FREE FI(SASDB)\n        FREE FI(DD1)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SASTC": {"ttr": 3599, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "        PROC 0\n        CONTROL MSG PROMPT\n        FREE FI(SASDB)\n        FREE FI(DD1)\n        ALLOC FI(SASDB) DA('XY.TC.SASDB.CPU')\n        ALLOC FI(DD1)     DA('XY.TC.A.SASCPU') SHR\n        %SAS\n        FREE FI(SASDB)\n        FREE FI(DD1)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SORTRMF": {"ttr": 3601, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//* THIS JOB SORTS RMF RECORDS SO THEY CAN BE PROCESSED\n//* BY THE RMF POST PROCESSOR AND SAS PROGRAMS.\n//*\n//STEP1   EXEC PGM=SORT,PARM='SIZE=750K'\n//SORTLIB DD DSN=SYS1.SORTLIB,DISP=SHR\n//SORTIN   DD DSN=XY.RMFWEEK,            <=RMF INPUT\n//   DISP=SHR\n//SORTOUT  DD DSN=XY.RMFWEEK,            <=RMF OUTPUT. THIS JOB SORTS IT\n//  DISP=SHR                               TO ITSELF. YOU MAY WANT TO\n//*                                        SORT IT TO ANOTHER DATASET.\n//SORTWK01 DD UNIT=DISK,SPACE=(CYL,(15,5))\n//SORTWK02 DD UNIT=DISK,SPACE=(CYL,(15,5))\n//SORTWK03 DD UNIT=DISK,SPACE=(CYL,(15,5))\n//SORTWK04 DD UNIT=DISK,SPACE=(CYL,(15,5))\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//EXITLIB  DD DSN=SYS1.LINKLIB,DISP=SHR\n//SYSIN    DD *\n OPTION EQUALS\n SORT FIELDS=(11,4,CH,A,7,4,CH,A)\n MODS E15=(ERBPPSRT,500,EXITLIB,N),E35=(ERBPPSRT,500,EXITLIB,N)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TCCLIST": {"ttr": 3603, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "        PROC 0\n        CONTROL MSG PROMPT\n        FREE FI(SASDB)\n        FREE FI(DD1)\n        ALLOC FI(SASDB) DA('XY.TC.SASDB.CPU')\n        ALLOC FI(DD1)     DA('XY.TC.A.SASCPU') SHR\n        %SAS\n        FREE FI(SASDB)\n        FREE FI(DD1)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UNLOAD": {"ttr": 3605, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//FILE1    EXEC PGM=IEBGENER\n//*  **********************************************************\n//*  *        UNLOAD1 FILE1                                   *\n//*  *        DOCUMENTATION AND INSTRUCTIONS                  *\n//*  **********************************************************\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n//SYSUT1   DD  UNIT=CART,\n//             DISP=(OLD,KEEP),DSN=FILE1,\n//             VOL=(,RETAIN,SER=TC0001),\n//             LABEL=(1,SL,EXPDT=98000)\n//SYSUT2   DD  DISP=(NEW,KEEP),\n//             DSN=XY.TC.A.FILE1.DATASET,\n//             VOL=SER=TECH81,UNIT=DISK,\n//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=4240),\n//             SPACE=(TRK,(1))\n//   EXEC PGM=IEBCOPY\n//*  **********************************************************\n//*  *        UNLOAD1 FILE2                                   *\n//*  *        SOURCE PDS                                      *\n//*  **********************************************************\n//SYSPRINT DD SYSOUT=*\n//INDD1    DD UNIT=CART,\n//            DISP=(OLD,KEEP),DSN=FILE2,\n//            VOL=(,RETAIN,SER=TC0001),           <=======VOL SER\n//            LABEL=(2,SL,EXPDT=98000),\n//            DCB=(RECFM=FB,LRECL=80,BLKSIZE=4240)\n//OUTDD1 DD UNIT=DISK,\n//   DSN=XY.TC.A.TEST.SASCPU,                     <==========CHANGE\n//   DISP=(NEW,KEEP),\n//   VOL=SER=TECH81,\n//   SPACE=(CYL,(5,,50)),\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=4240)\n//SYSIN    DD *\n    COPY OUTDD=OUTDD1,INDD=INDD1\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VPSOPT": {"ttr": 3607, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "*OPTIONS DEVADDR=(ADMPRINT,.,L02MCE) DEVICE=GDDM87 /*USE FOR ADMPRINT*/;\n*PTIONS GDEST=U1 GCLASS=S                          /*USE FOR VPS     */;\n*OPTIONS DEVADDR=(SASWTR,.,L02MCE)   DEVICE=IBM3287D /*      VPS  */;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XY9910": {"ttr": 3841, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "XY9910   CSECT\n         SPACE 3\n***    .\n***    .    START OF CODE. BASE       REGS 12 9\n***    .    WORK AREA                 REG 11\n***    .    SYSIN RECORD AREA         REG 2\n***    .    SMF RECORD AREA           REG 2\n***    .    RETURN FROM BRANCH        REG 7\n***    .\n***    .    CONTROL CARDS THAT ARE VALID ARE:\n***    .      SDATE=YYDDD YEAR AND DAY. THE SIGNIFICANT DIGITS ARE\n***    .                  FROM LEFT TO RIGHT. E.G. YOU CAN CODE\n***    .                  SDATE=85 FOR 1985 AND TAKE THE DEFAULT DAY\n***    .                  DEFAULT IS 00000\n***    .      EDATE=YYDDD  SAME AS ABOVE. DEFAULT IS 99366.\n***    .      STIME=HHMMSS SIGNIFICANT DIGITS ARE LEFT TO RIGHT. IF\n***    .                   YOU DONT TAKE THE DEFAULT THE YOU MUST\n***    .                   SUPPLY AT LEAST 2 DIGITS FOR THE HOUR.\n***    .                  DEFAULT IS 00000\n***    .\n         STM   14,12,12(13)\n         LR    12,15           1ST BASE REG\n         USING XY9910,12,9\n         LA    R9,4095(R12)\n         LA    R9,1(R9)        2ND BASE REG\n         ST    R13,SAVERET+4   MUST SAVE REG13\n         LA    R13,SAVERET     POINT TO SAVE AREA\n         B     BEGIN           BRANCH AROUND ID\n         DC    C'XY9910        JULY 6, 1987'\n         DS    0H\nBEGIN    EQU   *\n         L     R4,0(1)            GET ADDR OF PARMS\n         L     R0,SIZE\n         GETMAIN R,LV=(0)\n         LR    R11,R1             REG 11 POINTS TO WORK AREA\n         USING WORK,R11\n         LA    R0,WORKSTRT          POINT TO START OF CLEAR\n         LA    R1,WORKEND-WORKSTRT  AND SET THE LENGTH\n         SR    R15,R15            SET REG WITH PADDING CHAR\n         MVCL  R0,R14             CLEAR THE AREA\n         LR    R10,R11            LOAD SAVE AREA ADDR\n         ST    R4,PARMAREA        NOW SAVE ADDR OF PARMS\nSETTBLS  EQU   *                  GET STORAGE FOR TABLES\n         L     R0,SIZETAB         SIZE AND SUBPOOL OF SMF REC\n         GETMAIN R,LV=(0)\n         ST    R1,@TYPETAB        SAVE ADDR OF SMF RECORD AREA\n         MVC   0(1,R1),EFFS\n         L     R0,SIZESMF         SIZE AND SUBPOOL OF SMF REC\n         GETMAIN R,LV=(0)\n         ST    R1,@SMFIN          SAVE ADDR OF SMF RECORD AREA\nOPENPRT  EQU   *\n         OPEN  (PRINT1,OUTPUT)    OPEN SYSPRINT DD\n         OPEN  (SYSIN,INPUT)\nGETAREC  EQU   *                  GET PARMS FROM SYSIN\n         GET   SYSIN,INAREA\n         LA    R2,INAREA          POINT TO INPUT AREA\n         LA    R3,79              LIMIT-1 OF CARD AREA\nCHKDEL   EQU   *                  PROCESS PARMS FROM SYSIN\n         CLI   0(R2),X'40'        CHECK FOR DELIMETER OF BLANK\n         BE    ECHKDEL\n         CLI   0(R2),C','         CHECK FOR DELIMITER OF COMMA\n         BE    ECHKDEL\n         CLC   0(6,R2),=C'SDATE=' STARTING DATE KEYWORD\n         BE    SDATERT            YES, GO TO ROUTINE\n         CLC   0(6,R2),=C'EDATE=' ENDING DATE KEYWORD\n         BE    EDATERT            YES, GO TO ROUTINE\n         CLC   0(6,R2),=C'STIME=' STARTING TIME KEYWORD\n         BE    STIMERT            YES, GO TO ROUTINE\n         CLC   0(6,R2),=C'ETIME=' ENDING TIME KEYWORD\n         BE    ETIMERT            YES, GO TO ROUTINE\n         OI    ERRORSW,CNTLCARD   INDICATE CONTROL CARD ERROR\n         B     ERROR1             NO, INVALID CONTROL CARD\nSDATERT  EQU   *\n         PACK  SDATE(4),6(5,R2)   PACK INPUT STARTING DATE YYDDD\n         OI    SDATE+3,X'0F'      FORCE SIGN IN CASE OF BLANKS\n         B     GETAREC\nEDATERT  EQU   *\n         PACK  EDATE(4),6(5,R2)   PACK INPUT ENDING DATE\n         OI    EDATE+3,X'0F'      FORCE SIGN IN CASE OF BLANKS\n         B     GETAREC\nSTIMERT  EQU   *\n         PACK  STIME(4),6(6,R2)   PACK INPUT STARTING TIME-HHMMSS\n         OI    STIME+3,X'0F'      FORCE SIGN IN CASE OF BLANKS\n*                                 ALLOWS HH INSTEAD OF HH0000\n*                                 MUST SUPPLY AT LEAST HH\n         B     GETAREC\nETIMERT  EQU   *\n         PACK  ETIME(4),6(6,R2)   PACK INPUT ENDING TIME\n         OI    ETIME+3,X'0F'      FORCE SIGN IN CASE OF BLANKS\n         B     GETAREC\nECHKDEL  EQU   *\n         LA    R2,1(R2)           NEXT POSTION\n         BCT   R3,CHKDEL          KEEP CHECKING SAME RECORD\n         B     GETAREC            GET NEXT RECORD\nENDIN    EQU   *\n         CLOSE (SYSIN)            CLOSE IT HERE FOR NOW\n*        ALL DONE WITH REG 2 AND 3\nOPENSMF  EQU   *\n         UNPK  L4STIME(6),STIME(4) MOVE TO TITLE LINE\n         UNPK  L4ETIME(6),ETIME(4)\n         UNPK  L4SDATE(5),SDATE(4)\n         UNPK  L4EDATE(5),EDATE(4)\n         PUT   PRINT1,PLINEA\n         PUT   PRINT1,PLINEB\n         PUT   PRINT1,PLINEC\n         PUT   PRINT1,PLINED\n         PUT   PRINT1,PLINEE\n         PUT   PRINT1,PLINEF\n         PUT   PRINT1,PLINE4\n         OPEN  (SMFOUT,OUTPUT)    OPEN THE OUTPUT FILE\n         OPEN  (SMFIN,INPUT)      OPEN THE SMF FILE\n         MVC   TOTALRMF,ZEDS      ZERO OUT TOTAL FIELD\n**       SHOULD BE ALL DONE WITH REG 2\n         USING SMF74HDR,R2\nREADSMF  EQU   *\n         L     R2,@SMFIN          RE-ESTABLISH ADDR OF SMF REC AREA\n         GET   SMFIN,SMF74HDR     GET A SMF REC\nCHECKSMF EQU   *\n         CLC   SMF74RTY,=X'46'    IS THIS A 70 REC\n         BL    READSMF            IF LESS THAN GET ANOTHER REC\n         CLC   SMF74RTY,=X'4F'    IS THIS A 79 REC\n         BH    READSMF            IF GREATER THAN GET ANOTHER REC\n         MVC   S74PRS,SMF74PRS    SAVE OFFSET TO PROD SECTION\n         MVC   S74TYPE,SMF74RTY\n         DROP  R2\n         A     R2,S74PRS\n         USING SMF74PRO,R2\n         CLC   SMF74DAT,SDATE     INTERVAL DATE\n         BL    READSMF            SMF74DAT LT SDATE, GET A REC\n         CLC   SMF74DAT,EDATE     INTERVAL DATE\n         BH    READSMF            SMF74DAT GT EDATE, GET A REC\n         CLC   SMF74IST,STIME     INTERVAL START TIME\n         BL    READSMF            SMF74IST LT STIME, GET A REC\n         CLC   SMF74IST,ETIME     INTERVAL START TIME\n*                                  DOESNOT ACCOUNT FOR DURATION\n         BH    READSMF            SMF74IST GT ETIME, GET A REC\nPROCREC  EQU   *                  NOW HAVE A GOOD SMF REC\n         L     R2,@SMFIN\n         USING SMF74HDR,R2\n         PUT   SMFOUT,SMF74HDR    WRITE OUTPUT REC\nDDSLOOP  EQU   *                  NOW HAVE A GOOD SMF REC\n         L     R5,@TYPETAB        ADDR OF TYPE TABLE\n         USING TYPETAB,R5\n         LA    R6,10              MAX AMOUNT OF ENTRIES IN TABLE -1\nTTABLOOP EQU   *                  NOW HAVE A GOOD SMF REC\n         CLC   TYPEREC(1),EFFS    START OF TABLE\n         BE    ADDTAB             NO, KEEP LOOKING FOR REC TYPE\n         CLC   TYPEREC,S74TYPE    IS THIS THE REC TYPE\n         BE    TYPEHIT            YES,\n         LA    R5,5(R5)           NO, POINT TO NEXT ENTRY\n         BCT   R6,TTABLOOP\nADDTAB   EQU   *\n         MVC   TYPEREC,S74TYPE    MOVE IN NEW TYPE REC\n         MVC   NUMRECS,ZEDS       MOVE ZEROS TO NUMRECS\n         MVC   5(1,R5),EFFS       MARK END OF TABLE\nTYPEHIT  EQU   *\n         AP    1(4,R5),=P'1'      ADD 1 TO REC COUNTER IN TABLE\n         AP    TOTALRMF,=P'1'     ADD 1 TO TOTAL REC COUNTER\n         B     READSMF            READ ANOTHER REC\nENDSMF   EQU   *\n         PUT   PRINT1,PLINE3\nPRTRECS  EQU   *\n         DROP  R5\n         L     R3,@TYPETAB         ADDR OF TYPETAB\nPRTTABR  EQU   *                   PRINT INFO IN TABLES\n         USING TYPETAB,R3\n         CLC   0(1,R3),EFFS        END OF TABLE\n         BE    PTOTAL              YES, ALL DONE\n         SR    6,6\n         IC    6,TYPEREC\n         CVD   6,DOUBLEWK\n         UNPK  L2RECTYP,DOUBLEWK\n         OI    L2RECTYP+1,X'F0'\n         MVC   L2NUMREC,MASK1\n         ED    L2NUMREC,NUMRECS\n         PUT   PRINT1,PLINE2       PRINT A LINE\n         LA    R3,5(R3)           NEXT ENTRY\n         B     PRTTABR             PRINT NEXT ENTRY\nPTOTAL   EQU   *\n         MVC   L5TOTREC,MASK1\n         ED    L5TOTREC,TOTALRMF\n         PUT   PRINT1,PLINE5       PRINT A LINE\nRETURN   EQU   *\n         CLOSE (PRINT1)\n         CLOSE (SMFOUT)\n         CLOSE (SMFIN)\n         L     R0,SIZESMF                        .FREE SMF REC AREA\n         L     R1,@SMFIN                   ADDR OF SMFIN\n         FREEMAIN R,LV=(0),A=(1)           SAVE AREA\n         L     R0,SIZE                           .FREE THIS WORK AREA\n         LR    R1,R11                      ADDR OF WORK AREA..\n         FREEMAIN R,LV=(0),A=(1)           SAVE AREA\n         L     R13,SAVERET+4\n         LM    14,12,12(13)\n         SR    15,15           COND CODE\n         BR    14\nERROR1   EQU   *                       RTN TO CONVERT ERROR FLAG1\n         EJECT\n*                             WORK DSECT LATER AS DS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         LTORG\n         DS    0F\nSIZE     DC    AL1(000),AL3(WORKEND-WORKSTRT)  SIZE OF GET MAIN\nSIZESMF  DC    AL1(000),AL3(32767)    SIZE OF INPUT AREA FOR SMF\nSIZETAB  DC    AL1(000),AL3(5*10)     SIZE OF TYPE TABLE\nSAVERET  DS    18F\nSDATE    DC    X'0000000F'     00YYDDDF   DEFAULTS\nEDATE    DC    X'0099366F'     00YYDDDF   DEFAULTS\nSTIME    DC    X'0000000F'     0HHMMSSF   DEFAULTS\nETIME    DC    X'0250000F'     0HHMMSSF   DEFAULTS\nDOUBLEWK DC    D'0'            CVB/CVD WORK AREA\nMASK1    DC    X'40206B2020206B202120' D=7 L=11  EDIT MASK\nEFFS     DC    X'FF'         HEX EFFS\nZEDS     DC    X'0000000F'  PACKED ZERO\nPLINE5   DS    0CL133\n         DC    X'F0'           CAR. CONTROL F0=DOUBLE\n         DC    CL2' '\n         DC    C'TOTAL RECORDS'\n         DC    CL2' '\nL5TOTREC DS    CL11\n         DC    CL104' '\nPLINE4   DS    0CL133          PRINTLINE\nL4CC     DC    X'F1'           CAR. CONTROL F1=TOP        1\n         DC    C'SUMMARY OF SMF RECORDS             '    35\n         DC    4C' '                                '     4\n         DC    C' FROM '                                  6\nL4STIME  DS    CL6     HHMMSS                             6\n         DC    C' ON '                                    4   56\nL4SDATE  DS    CL5     YYDDD                              5\n         DC    C' UNTIL '                                 7\nL4ETIME  DS    CL6     HHMMSS                             6\n         DC    C' ON '                                    4\nL4EDATE  DS    CL5     YYDDD                              5   83\n         DC    CL50' '                                   50  133\nPLINE2   DS    0CL133          PRINTLINE\nL2CC     DC    X'40'           CAR. CONTROL 40=SINGLE\n         DC    CL8' '\nL2RECTYP DS    CL2\n         DC    CL7' '\nL2NUMREC DS    CL11\n         DC    CL104' '\nPLINE3   DS    0CL133          PRINTLINE\nL3CC     DC    X'F0'           CAR. CONTROL F0=DOUBLE     1\n         DC    CL3' '\n         DC    C'RECORD TYPE'\n         DC    CL5' '\n         DC    C'NUMBER OF RECORDS'\n         DC    CL96' '\nPLINEA   DS    0CL133\nLACC     DC    X'F1'\n         DC    CL30' '\n         DC    C'THIS PROGRAM PULLS OFF SMF RECORDS 70-79'\n         DC    CL62' '\nPLINEB   DS    0CL133\nLBCC     DC    X'F0'\n         DC    CL30' '\n         DC    C'THESE ARE THE VALID CONTROL CARDS       '\n         DC    CL62' '\nPLINEC   DS    0CL133\nLCCC     DC    X'40'\n         DC    CL30' '\n         DC    C'SDATE=YYDDD   DEFAULT IS 00000          '\n         DC    CL62' '\nPLINED   DS    0CL133\nLDCC     DC    X'40'\n         DC    CL30' '\n         DC    C'EDATE=YYDDD   DEFAULT IS 99366          '\n         DC    CL62' '\nPLINEE   DS    0CL133\nLECE     DC    X'40'\n         DC    CL30' '\n         DC    C'STIME=HHMMSS  DEFAULT IS 000000         '\n         DC    CL62' '\nPLINEF   DS    0CL133\nLFCE     DC    X'40'\n         DC    CL30' '\n         DC    C'ETIME=HHMMSS  DEFAULT IS 250000         '\n         DC    CL62' '\nSMFOUT   DCB   DDNAME=SMFOUT,DSORG=PS,MACRF=(PM),                      X\n               LRECL=32767,RECFM=VBS\nPRINT1   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),                    X\n               BLKSIZE=133,LRECL=133,RECFM=FBA\nSYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(GM),EODAD=ENDIN,           X\n               BLKSIZE=80,LRECL=80,RECFM=FB\nSMFIN    DCB   DDNAME=SMFIN,DSORG=PS,MACRF=(GM),EODAD=ENDSMF,          X\n               LRECL=32767,RECFM=VBS\n****           BLKSIZE=4096,LRECL=32767,RECFM=VBS\n         EJECT\nWORK     DSECT\nWORKSTRT DS    0D\n         DS    F\n         DS    F\nPARMAREA DS    F               ADDR OF PARM AREA\n@SMFIN   DS    F               ADDR OF SMFREC AFTER READ\n@TYPETAB DS    F               ADDR OF TYPETAB\nS74PRS   DS    F\nS74TYPE  DS    CL1\nINAREA   DS    CL80            CNTL CARD INPUT AREA\nERRORSW  DS    X               SYSIN\nCNTLCARD EQU   X'01'           ERROR ON CONTROL CARD\nTOTALRMF DS    PL4\nWORKEND  DS    0D\n         EJECT\n         ERBSMF74\n         EJECT\nTYPETAB  DSECT\nTTENTRY  DS    0CL5\nTYPEREC  DS    BL1\nNUMRECS  DS    PL4\n         EJECT\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XY9910AS": {"ttr": 3847, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//*\n//*    THIS JOB ASSEMBLES AND LINKS  PGM XY9910 (THE PROGRAM THAT\n//*    PULLS OF SMF RECORDS 70 THRU 79). IT IS FAIRLY QUICK.\n//*\n//*\n//*\n//*\n//X1   EXEC  PROC=ASMFCL,\n//   PARM.ASM='NODECK,LOAD'\n//ASM.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//           DD DSN=SYS1.RMFMAC01,DISP=SHR\n//ASM.SYSPRINT DD SYSOUT=*\n//ASM.SYSIN DD DISP=SHR,DSN=A.XY.SASCPU(XY9910)\n//LKED.SYSLMOD DD DISP=SHR,DSN=YOUR.LINKLIB      <====CHANGE THIS\n//LKED.SYSPRINT DD SYSOUT=*\n//LKED.SYSIN DD *\n  NAME XY9910(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XY9910J": {"ttr": 3849, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//JOBNAME  JOB (XX,R412,30,20,05),'PROGRAMMER NAME ',MSGLEVEL=(1,1),\n//  CLASS=A,MSGCLASS=A\n//****************************************************************\n//****                                                        ****\n//**** USE CONTROL CARDS TO PULL OFF SPECIFIC DATE AND TIME   ****\n//**** VALID CONTROL CARDS FOR \"SYSIN\" ARE:                   ****\n//****                                                        ****\n//**** SDATE=YYDDD                                            ****\n//**** EDATE=YYDDD                                            ****\n//**** STIME=HHMMSS                                           ****\n//**** ETIME=HHMMSS                                           ****\n//****                                                        ****\n//**** IF CONTROL CARDS ARE NOT USED THEN THE PROGRAM WILL    ****\n//**** PULL OFF WHATEVER IS ON THE TAPE.                      ****\n//****************************************************************\n//S1  EXEC PGM=XY9910\n//STEPLIB  DD  DISP=SHR,DSN=YOUR.LINKLIB <===CHANGE OR DELETE\n//SMFIN    DD DISP=(OLD,KEEP),DSN=A.DC.BKUP1.SMFMVS(+0),  <=== INPUT\n//    UNIT=CART,DCB=BUFNO=8\n//SMFOUT   DD DSN=A.RMF.DATA,                            <=== OUTPUT\n//   DISP=(NEW,PASS),UNIT=DISK,\n//   DCB=(LRECL=32759,BLKSIZE=4096,RECFM=VBS),\n//   SPACE=(CYL,(60,1))\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD SYSOUT=A\n//SYSIN    DD DUMMY\n/*\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT125/FILE125.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT125", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}