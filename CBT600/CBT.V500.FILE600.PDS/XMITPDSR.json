{"INMR01": {"INMLRECL": 80, "INMFNODE": "SAOTEST", "INMFUID": "AWCPAW", "INMTNODE": "SAOTEST", "INMTUID": "AWCPAW", "INMFTIME": "20050606130319000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "AWCPAW.CBT.FILE600.REXX.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"AWCPAW.CBT.FILE600.REXX.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 160, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 10017, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "050157", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\x06'", "DS1LSTAR": "b'\\x00\\x04\\x08'", "DS1TRBAL": "b'-\\xb0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b0\\xb8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b0\\xb8'", "b'X\\xf1\\x86\\xe8\\x00\\x00\\x00L\\x00\\r\\x00M\\x00\\x02\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$README": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x01\\x020?\\x01\\x04\\x04/\\x151\\x00\\x04\\x00\\x04\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-10-30T00:00:00", "modifydate": "2004-02-11T15:31:12", "lines": 4, "newlines": 4, "modlines": 0, "user": "AWCPAW"}, "text": "\nPlease see the README in the installation PDS -\n      (userid).CBTxxx.FILE600.PDS\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CONTACT": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x005\\x01\\x02'_\\x01\\x05\\x15o\\x12X\\x00:\\x00$\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-10-02T00:00:00", "modifydate": "2005-06-05T12:58:35", "lines": 58, "newlines": 36, "modlines": 0, "user": "AWCPAW"}, "text": "\nAuthor contact details as follows.\n\nName      : Paul Wells\n\nAddress   : Saudi Aramco Box 12959\n            Dhahran 31311\n            Saudi Arabia\n\nTelephone : +966 3 873 3155 (Work - direct line)\n\nFax       : +966 3 873 8958 (Work)\n\nEmail     : Paul.Wells@aramco.com\n\n\nAnyone who thinks they remember me from places where I have worked\nin the past, and wish to renew acquaintances, please do.\nMy brief history as an MVS sysprog (since 1987) is as follows.\n\n2000-present : Saudi Aramco, Dhahran, Saudi Arabia.\n               OS/390 2.5/2.9, z/OS 1.2, z/OS 1.4\n\n1998-2000    : Ladbroke Racing, Rayners Lane, London, UK.\n               MVS 4.2/5.1, OS/390 2.5\n\n1996-1998    : Cap Gemini, Wandsworth Road, London, UK.\n               MVS 4.3, MVS 5.2.2, OS/390 2.4\n\n1994-1996    : ECSoft Synapse, Berkhamsted, UK.\n               Customer sites:-\n\n             : TNT Worldwide, Atherstone, UK.\n               MVS 4.3, OS/390 1.1\n\n             : Polygram, Romford, UK.\n               MVS 4.3/5.2.2\n\n             : Whitbread, Luton, UK.\n               MVS 4.3\n\n             : NPI, Tunbridge Wells, UK.\n               MVS 4.3\n\n1987-1994    : Tesco Stores, Cheshunt, UK.\n               MVS 2.1.7/2.2/3.1.3/4.3\n\n1985-1986    : Whitbread, Reading, UK.\n\n\nFootnote\n--------\nMy employer's mainframe is due to be decommissioned at the end of 2006.\nAfter this time, I will most likely be unable to maintain the\nsubmissions for CBT tape file 600. It will be with sadness and regret\nthat I bid farewell to the venerable mainframe which has been my\nbread and butter for nearly 20 years!\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INDEX": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x003\\x01\\x02(\\x9f\\x01\\x03\\t\\x1f\\x16\\x02\\x00\\x12\\x00)\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2002-10-16T00:00:00", "modifydate": "2003-04-01T16:02:33", "lines": 18, "newlines": 41, "modlines": 0, "user": "AWCPAW"}, "text": "INDEX OF MEMBERS IN AWCPAW.CBT.FILE600.REXX.PDS\n-----------------------------------------------\n\n$CONTACT - Contact details for the author\n$INDEX   - This member\nRXMAILD1 - Sample input data for RXMAILER (plain text).\nRXMAILD2 - Sample input data for RXMAILER (HTML).\nRXMAILER - A bulk emailer which opens a\n           socket connection to an SMTP server and transmits\n           SMTP format input data. This is similar in many\n           ways to UDSMTP, but RXMAILER has some interesting\n           features. It can simulate the sending of emails\n           to stress test an SMTP server and it can generate\n           parts of the SMTP commands, SMTP header and mail\n           data at run-time from symbolics (including\n           interpreted REXX) in the input file.\nRXMAILJ  - Sample JCL to run RXMAILER.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXMAILD1": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x1d\\x00D\\x01\\x03\\t\\x0f\\x01\\x03\\t\\x8f\\x15'\\x00&\\x00\\x0c\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.29", "flags": 0, "createdate": "2003-03-31T00:00:00", "modifydate": "2003-04-08T15:27:44", "lines": 38, "newlines": 12, "modlines": 0, "user": "AWCPAW"}, "text": "Helo &HOST&\nMail from:<&EXECNAME&@&HOST&.&DOMAIN&>\nNoop\nNoop  *****************************************************\nNoop   An example of using RXMAILER symbolics to build\nNoop   the SMTP commands and mail contents.\nNoop   Symbolics within the mail text are only substituted\nNoop   if the SYMDATA keyword is used with RXMAILER.\nNoop  *****************************************************\nNoop\nRcpt to:<&USERID&@&HOST&.&DOMAIN&>\nData\nImportance: high\nX-Mailer: &EXECNAME& &VERSION& on &SYSNAME& running &SYSOPSYS&\nFrom: Job &JOBNAME&(&JOBNUM&) on &SYSNAME& <&JOBNAME&@&HOST&.&DOMAIN&>\nReply-to: &USERID&@&HOST&.&DOMAIN&\nTo: Recipient <&USERID&@&HOST&.&DOMAIN&>\nSubject: Hello from &EXECNAME& &VERSION&\nDate: &!left(date(\"W\"),3)\",\" date() time() \"LCL\"!&\n\n\nThe sun has got his hat on, hip hip hip hooray.\nThe sun has got his hat on, and he's coming out today.\n\nSent by &JOBNAME&(&JOBNUM&) from &HOST&.&DOMAIN&(&HOSTID&) at\n&!time()!& on &!date()!& using mail server &PEERNAME&(&PEERID&)\n\nUser &USERID& is &USERNAME&\n\n&!TSO LISTC LVL('&USERID&')!&\n\n&!OE ls -al!&\n\n&!HFS /etc/rc!&\n\n&!DSN &USERID&.CBT.FILE600.REXX.PDS($CONTACT)!&\n\n.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXMAILER": {"ttr": 265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x08\\x05\\x00\\x14\\x01\\x01\\x17_\\x01\\x04\\x18\\x7f\\x10!\\x08 \\x00\\xa5\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "08.05", "flags": 0, "createdate": "2001-06-24T00:00:00", "modifydate": "2004-07-05T10:21:14", "lines": 2080, "newlines": 165, "modlines": 0, "user": "AWCPAW"}, "text": "/******************************* REXX *********************************/\n/*                                                                    */\n/* RXMAILER a REXX batch mailer                                       */\n/*                                                                    */\n/*  Written June 2001 by                                              */\n/*                                                                    */\n/*  Paul Wells                                                        */\n/*  Mainframe Systems Group                                           */\n/*  Computer Operating System Division                                */\n/*  Computer and Communication Systems Department                     */\n/*  Saudi Aramco                                                      */\n/*  Dhahran                                                           */\n/*  Saudi Arabia                                                      */\n/*                                                                    */\n/*  +966-3-873-9505                                                   */\n/*  wellspa@aramco.com.sa                                             */\n/*                                                                    */\n/**********************************************************************/\n/* Modification History                                               */\n/* --------------------                                               */\n/*                                                                    */\n/* Note: When amending, please change the version in the ver REXX     */\n/*       variable.                                                    */\n/*                                                                    */\n/* Userid    Date         Comment                                     */\n/* -------   ---------    --------------------------------------------*/\n/* AWCPAW    2004/07/05 - Aramco domain names changed to aramco.com   */\n/* AWCPAW    2003/04/22 - Mail data lines are split by CRLF before    */\n/*                        being send to the server so as to avoid     */\n/*                        exceeding the RFC defined limit for line    */\n/*                        length.                                     */\n/* AWCPAW    2003/04/14 - Four options for symbolic substitution -    */\n/*                        SYMDATA, SYMSMTP, SYMALL, NOSYM.            */\n/*                        SYMSMTP is the default option.              */\n/*                      - CPU utilisation improvements in symbolic    */\n/*                        substitution routines.                      */\n/* AWCPAW    2003/04/05 - Added symbolic substitution which can       */\n/*                        be performed in either the SMTP commands,   */\n/*                        email SMTP header and the email body text.  */\n/*                        For performance reasons the latter will     */\n/*                        only be invoked when the SYMDATA parameter  */\n/*                        is passed.                                  */\n/*                      - Additional counters in termination messages */\n/*                        indicating effect of symbolic substitution  */\n/*                        (if any).                                   */\n/*                      - Remove restriction on embeded blanks in     */\n/*                        the parm string. This allows the RXMAILER   */\n/*                        command to be split over multiple lines     */\n/*                        in a batch job. Subparameters must still be */\n/*                        separated by commas.                        */\n/*                      - Enforced an RC=12 when an invalid           */\n/*                        parameter is detected.                      */\n/*                      - Rewrote socket read logic to just be a      */\n/*                        single routine and to always read all       */\n/*                        available data from the socket.             */\n/* AWCPAW    2003/03/31 - New option SERVER= to specify the SMTP      */\n/*                        server as an alternative to hardcoding      */\n/*                        a list in the exec.                         */\n/*                      - A special SMTP server name of *LOCAL*       */\n/*                        can be used for the local system's SMTP     */\n/*                        server.                                     */\n/*                      - Improvements to retry and SMTP server list  */\n/*                        processing.                                 */\n/*                      - Close any open file left behind by the      */\n/*                        retry logic.                                */\n/*                      - New parameter HELO which allows the HELO    */\n/*                        commands to be procesed if desired. However */\n/*                        the timing of the server connects and HELOs */\n/*                        is controlled by the exec and not input     */\n/*                        file.                                       */\n/* AWCPAW    2003/01/27 - Strip quotes from DSN= parameter to enable  */\n/*                        use from ISPF 3.4.                          */\n/* AWCPAW    2002/11/24 - If the 'From:' email address does not       */\n/*                        contain an '@' then a valid email           */\n/*                        address is generated and appended.          */\n/* AWCPAW    2002/07/29 - Send end of data message after EOF if not   */\n/*                        already sent to prevent hang.               */\n/*                      - Jobname obtained via MVSVAR service not     */\n/*                        via control blocks.                         */\n/*                      - KB/MB/GB are multiples of 1000 not 1024     */\n/* AWCPAW    2001/12/03 - Minor improvement to status message.        */\n/* AWCPAW    2001/11/07 - CRLF to each command for NT Exchange server */\n/* AWCP#W    2001/09/16 - DD parameter added.                         */\n/* AWCP#W    2001/09/09 - Automatic internal restart from current     */\n/*                        file position upon socket error up to limit */\n/*                        of maxrty variable (suppressed for file     */\n/*                        errors).                                    */\n/*                      - Slight code tidy-up.                        */\n/*                      - Save RC before clean-up processing.         */\n/*                      - Correct check for TSO environment.          */\n/* AWCP#W    2001/09/08 - Return code (retval) checking after most    */\n/*                        socket calls.                               */\n/* AWCP#W    2001/07/30 - Primary and alternate SMTP servers.         */\n/*                      - GetHostByAddr call added to reverse resolve */\n/*                        SMTP server address.                        */\n/* AWCP#W    2001/07/29 - Minor improvements to statistics.           */\n/*                      - Truncate ignored line echo.                 */\n/*                      - SIMULATE or NOMAIL parameter to simulate    */\n/*                        sending mails but not actually send them.   */\n/* AWCP#W    2001/07/28 - Check for space delimited parameters (they  */\n/*                        should be comma delimited).                 */\n/*                      - Single line EXECIOs to limit storage use.   */\n/* AWCP#W    2001/07/04 - Process QUIT commands.                      */\n/*                      - Process RSET/NOOP correctly.                */\n/* AWCP#W    2001/07/02 - Tidy up some debug messages.                */\n/*                      - Ignore HELOs in the input file and send     */\n/*                        our own.                                    */\n/*                      - Allow SMTP commands in lower case.          */\n/* AWCP#W    2001/07/01 - Status messages to track progress when      */\n/*                        MSGLEVEL=1 is being used.                   */\n/* AWCP#W    2001/06/30 - Suppress duplicate HELO commands if         */\n/*                        still connected to prevent '503 bad         */\n/*                        sequence' warning message.                  */\n/*                      - Issue 'Exiting RC=' unconditionally.        */\n/*                      - Echo smtpserver and maxmailbytes values at  */\n/*                        start-up.                                   */\n/*                      - Renumbered MSGLEVELs to add MSGLEVEL=1,     */\n/*                        so old 1 becomes 2, 2 becomes 3 etc.        */\n/* AWCP#W    2001/06/27 - Added MSGLEVEL parameter to control volume  */\n/*                        of logging messages.                        */\n/*                      - Echo parameters and MSGLEVEL at start-up.   */\n/*                      - Added RESTART= parameter for restart        */\n/*                        capability.                                 */\n/*                      - Added statistics messages at termination.   */\n/*                      - Comments relating to performance.           */\n/* AWCP#W    2001/06/26 - Original version.                           */\n/*                                                                    */\n/**********************************************************************/\n/* Program Description                                                */\n/* -------------------                                                */\n/* A REXX exec to forward emails from an input file direct to an      */\n/* SMTP server on the network. The input file should already be in    */\n/* SMTP format. This bypasses the SMTP server supplied with OS/390.   */\n/* Unlike the OS/390 SMTP server this EXEC has no known data volume   */\n/* limitations.                                                       */\n/*                                                                    */\n/* Customisation                                                      */\n/* -------------                                                      */\n/* 1) Specify the list of SMTP servers in the smtpserver.x            */\n/*    rexx variables. (or use the SERVER= parameter)                  */\n/* 2) Optional:                                                       */\n/*    Specify the connection transmission limit in the maxmailbytes   */\n/*    rexx variable. This threshold allows a disconnect/reconnect     */\n/*    sequence to be issued when the specified number of bytes has    */\n/*    been transmitted.                                               */\n/* 3) Other optional customisation variables are the SMTP port,       */\n/*    default message level, status statistics thereshold and error   */\n/*    retries.                                                        */\n/*                                                                    */\n/* Input file format                                                  */\n/* -----------------                                                  */\n/* DSORG=PS RECFM=FB/VB any sensible LRECL (80-200 say)               */\n/*                                                                    */\n/* The input dataset can be passed as a DSN= parameter or             */\n/* preallocated as the MAILDATA DD.                                   */\n/*                                                                    */\n/* It should contain any of the following SMTP commands:-             */\n/* EHLO HELO RCPT RSET NOOP VRFY MAIL DATA                            */\n/*                                                                    */\n/* The input file can contain any number of emails.                   */\n/*                                                                    */\n/* An example input file looks like this:-                            */\n/*                                                                    */\n/* HELO SAOTOWER                                                      */\n/* MAIL FROM:<WELLSPA@EXCHANGE.ARAMCO.COM.SA>                         */\n/* RCPT TO:<WELLSPA@EXCHANGE.ARAMCO.COM.SA>                           */\n/* DATA                                                               */\n/* SENDER:  TROON                                                     */\n/* IMPORTANCE: HIGH                                                   */\n/* FROM:     DO NOT REPLY                                             */\n/* TO:       WELLSPA@EXCHANGE.ARAMCO.COM.SA                           */\n/* SUBJECT:  TROONIGAN TROONER                                        */\n/* RUN DATE : 06/23/2001                                              */\n/*                                                                    */\n/* This is a test email.                                              */\n/* .                                                                  */\n/*                                                                    */\n/* (The single period above indicates the end of the email data)      */\n/*                                                                    */\n/* Symbolic Substitution                                              */\n/* ---------------------                                              */\n/* Dynamic data, substituted at run-time and initiated by the use     */\n/* of symbolics can be placed and will be substituted in any          */\n/* of the following 3 places.                                         */\n/*   1) SMTP commands e.g. MAIL, RCPT etc.                            */\n/*   2) SMTP mail data header e.g. Sender: From: To: Subject:         */\n/*   3) SMTP mail email data (only if the SYMDATA parameter is used   */\n/*      os as to limit performance impact on jobs that don't need it) */\n/* Symbloics available:-                                              */\n/*   &HOST&     - host name                                           */\n/*   &DOMAIN    - domain name                                         */\n/*   &HOSTID&   - host IP address                                     */\n/*   &JOBNAME&  - job name                                            */\n/*   &USERID&   - security userid                                     */\n/*   &USERNAME& - security name                                       */\n/*   &JOBNUM&   - JES job number                                      */\n/*   &PEERID&   - SMTP server IP address                              */\n/*   &PEERNAME& - SMTP server name                                    */\n/*   &SYSNODE&  - JES node                                            */\n/*   &EXECNAME& - name of this exec                                   */\n/*   &VERSION&  - version of this exec                                */\n/*   &SYSNAME&  - system name                                         */\n/*   &SYSSMFID& - SMF id                                              */\n/*   &SYSOPSYS& - Operating system version                            */\n/*   &SYSPLEX&  - SYSPLEX name                                        */\n/*   &!tsocmd!& - Output of any TSO command (lines serarated by CRLFs)*/\n/*   &!oecmd!&  - Output of any OMVS cmd (lines serarated by CRLFs)   */\n/*   &!dsn!&    - Contents of any sequential dataset (CRLFs used)     */\n/*   &!hfs!&    - Contents of any HFS dataset (CRLFs used)            */\n/* Example:-                                                          */\n/*   Helo &HOST&                                                      */\n/*   Mail from:<&EXECNAME&@&HOST&.&DOMAIN&>                           */\n/*   Rcpt to:<wellspa@aramco.com.sa>                                  */\n/*   Data                                                             */\n/*   Importance: high                                                 */\n/*   X-Mailer: &EXECNAME& &VERSION& on &SYSNAME& running &SYSOPSYS&   */\n/*   From: Job &JOBNAME&(&JOBNUM&) <&JOBNAME&@&HOST&.&DOMAIN&>        */\n/*   Reply-to: &USERID&@&HOST&.&DOMAIN&                               */\n/*   To: Recipient <&USERID&@&HOST&.&DOMAIN&>                         */\n/*   Subject: Hello from &EXECNAME& &VERSION&                         */\n/*   Date: &!left(date(\"W\"),3)\",\" date() time() \"LCL\"!&               */\n/*                                                                    */\n/*   The sun has got his hat on, hip hip hip hooray.                  */\n/*   The sun has got his hat on, and he's coming out today.           */\n/*   Sent by &JOBNAME&(&JOBNUM&) from &HOST&.&DOMAIN&(&HOSTID&) at    */\n/*   &!time()!& on &!date()!& using mail server &PEERNAME&(&PEERID&)  */\n/*   User &USERID& is &USERNAME&                                      */\n/*   &!TSO LISTC LVL('&USERID&')!&                                    */\n/*   &!OE ls -al!&                                                    */\n/*   &!HFS /etc/rc!&                                                  */\n/*   &!DSN &USERID&.CBT.FILE600.REXX.PDS($CONTACT)!&                  */\n/*   .                                                                */\n/*                                                                    */\n/* Execution                                                          */\n/* ---------                                                          */\n/* In TSO enter %RXMAILER DSN=dataset name                            */\n/*                                                                    */\n/* In batch use JCL like the following:-                              */\n/*                                                                    */\n/* //EMAIL    EXEC PGM=IKJEFT1B,PARM='%RXMAILER'                      */\n/* //SYSEXEC  DD  DISP=SHR,DSN=CSD.CMDPROC                            */\n/* //SYSTSPRT DD  SYSOUT=*                                            */\n/* //SYSTSIN  DD  DUMMY                                               */\n/* //MAILDATA DD  DISP=SHR,DSN=AWCP#W.TEST.MAIL                       */\n/*                                                                    */\n/* The return code will be 0 for success and non-zero to indicate     */\n/* an error. A message in the SYSTSPRT will describe the error.       */\n/*                                                                    */\n/* Parameters                                                         */\n/* ----------                                                         */\n/* DSN=        - Specifies the input dataset if a preallocated        */\n/*               MAILDATA is not to be used.                          */\n/* DD=         - Specifies the input DD to be used if                 */\n/*               MAILDATA is not to be used.                          */\n/* MSGLEVEL=   - Specifies the level of messages to be output to      */\n/*               SYSTSPRT. 1 is stats only, 2 is most transmissions,  */\n/*               3 is more, 4 is full debug                           */\n/* DEBUG       - Equivalent to MSGLEVEL=4 for comprehensive DEBUG     */\n/*               messages in SYSTSPRT.                                */\n/* RESTART=    - A line number from which to begin processing the     */\n/*               input file.                                          */\n/* SIMULATE    - Read input, connect to server, send HELO/MAIL/RCPT   */\n/*               commands, but send RSET to cancel before             */\n/*               sending mail. Allows testing of high volume input    */\n/*               without actually sending the mails.                  */\n/* NOMAIL      - Alias of SIMULATE.                                   */\n/* SERVER=     - SMTP server name. Can be specified as an alternative */\n/*               to those hardcoded in the exec.                      */\n/* HELO        - Do not suppress HELO/EHLOs in the input file         */\n/* SYMDATA     - Process symbolics in the mail data                   */\n/* SYMSMTP     - Process symbolics in the SMTP commands and SMTP mail */\n/*               header (default).                                    */\n/* SYMALL      - Both SYMDATA and SYMSMTP.                            */\n/* NOSYM       - Neither SYMDATA nor SYMSMTP.                         */\n/*                                                                    */\n/* When specifying multiple parameters, separate them by commas. e.g. */\n/*                                                                    */\n/*   MSGLEVEL=2,RESTART=100                                           */\n/*                                                                    */\n/* Messages                                                           */\n/* --------                                                           */\n/* Messages are logged in SYSTSPRT to indicate connection and         */\n/* transmissions to server. e.g. with MSGLEVEL=3                      */\n/*                                                                    */\n/* RXMAILER: Entered as a TSO COMMAND at 14:41:45 on 26 Jun 2001, usin*/\n/* g system TEST, by job AWCP#WEM (userid AWCP#W) and loaded from DD:S*/\n/* YSEXEC.                                                            */\n/*                                                                    */\n/* RXMAILER: Connected to simsmail.aramco.com.sa -- Server ESMTP (Sun */\n/* Internet Mail Server sims.4.0.1999.10.29.10.36.p4)                 */\n/*                                                                    */\n/* RXMAILER: Sent HELO SAOTOWER from line 1 of DD:MAILDATA            */\n/* RXMAILER: Recv 250 simsmail.aramco.com.sa OK, tso03.dha.aramco.com.*/\n/* RXMAILER: Sent MAIL FROM:<WELLSPA@EXCHANGE.ARAMCO.COM.SA>          */\n/* RXMAILER: Recv 250 2.5.0 Address Ok.                               */\n/* RXMAILER: Sent RCPT TO:<WELLSPA@EXCHANGE.ARAMCO.COM.SA>            */\n/* RXMAILER: Recv 250 2.1.5 WELLSPA@EXCHANGE.ARAMCO.COM.SA OK.        */\n/* RXMAILER: Sent DATA from line 4 of DD:MAILDATA                     */\n/* RXMAILER: Recv 354 Enter mail, end with a single \".\".              */\n/* RXMAILER: Sent end of message for mail 1. 40 data lines (3512 bytes*/\n/* RXMAILER: Recv 250 2.5.0 Ok.                                       */\n/*                                                                    */\n/*                                                                    */\n/* Error messages usually contain a socket call description and a     */\n/* return code. e.g.                                                  */\n/*                                                                    */\n/* RXMAILER: Connect RC=2016 EHOSTNOTFOUND Host not found in SITEINFO */\n/* file                                                               */\n/*                                                                    */\n/* Socket errors can be diagnosed with the help of the                */\n/* OS/390 SecureWay CS IP API Guide                                   */\n/*                                                                    */\n/* If these messages aren't enough for you, you can trace all the     */\n/* socket calls using the DEBUG parameter to the EXEC. e.g.           */\n/*                                                                    */\n/* %RXMAILER DSN=dataset,DEBUG                                        */\n/*                                                                    */\n/* With DEBUG you will receive messages of the form :-                */\n/*                                                                    */\n/* RXMAILER DEBUG: Performing socket Fcntl BLOCKING                   */\n/* RXMAILER DEBUG: Fcntl BLOCKING RC=0                                */\n/* RXMAILER DEBUG: Performing socket Read                             */\n/* RXMAILER DEBUG: Read RC=0 46 250 2.1.5 WELLSPA@EXCHANGE.ARAMCO.COM.*/\n/*                                                                    */\n/* Performance                                                        */\n/* -----------                                                        */\n/* This EXEC should perform considerably better than the OS/390 SMTP  */\n/* server. 4-5 mails per second should be achievable. For             */\n/* even better performance, put the REXX socket API in MLPA. This     */\n/* eliminates the program load from the linklist of the 'socket'      */\n/* module which occurs for every socket call. e.g.                    */\n/*                                                                    */\n/* SYS1.PARMLIB(IEALPA00) could additionally contain:-                */\n/*                                                                    */\n/*  /* TCPIP REXX socket API and aliases */                           */\n/*  INCLUDE LIBRARY(SYS1.TCPIP.SEZALINK)                              */\n/*          MODULES(EZBRXSOC,RXSOCKET,SOCKET,TCPERROR)                */\n/*                                                                    */\n/* or add dynamically by operator command:-                           */\n/*                                                                    */\n/*  SETPROG LPA,ADD,DSN=SYS1.TCPIP.SEZALINK,                          */\n/*          MOD=(EZBRXSOC,RXSOCKET,SOCKET,TCPERROR)                   */\n/*                                                                    */\n/**********************************************************************/\n\n /* EXEC version - please change this when amending code */\n ver = \"Version-05Jul04\"\n\n /* smtpserver.x defines the network SMTP servers. */\n /* The SERVER= parameter can be used as an alternative. */\n smtpserver.1 = \"exchange.aramco.com\"\n smtpserver.2 = \"mail.aramco.com\"\n smtpserver.3 = \"tso01.aramco.com\"\n smtpserver.4 = \"tso02.aramco.com\"\n smtpserver.5 = \"*LOCAL*\"       /* Special value for local SMTP */\n\n /* standard smtp port - amend if neccessary */\n smtpport = 25\n\n /* maxmailbytes defines the threshold of transmitted bytes\n    which triggers a disconnect/reconnect to the SMTP server.\n    If the connection is to an OS390 or MVS SMTP server, the\n    maxOS390mailbytes will be used. We prefer to use\n    other faster servers higher up the smtpserver.x list. */\n maxmailbytes = 4*1024*1024\n maxOS390mailbytes = 524288 - 4096 /* default MAXMAILBYTES on OS/390 */\n\n /* default message level\n    1 - Socket sends, selected socket receives, status messages\n    2 - Socket sends, all socket receives, status messages\n    3 - Socket sends, all socket receives, status messages,\n        non-error return codes, diagnostic traces. Equivalent\n        to DEBUG option                                        */\n dftmsglevel = 2\n\n /* Status message frequency. Issue progress message after defined\n    number of mails */\n statthresh = 100\n\n /* DD name to use for dynamically allocated input */\n dynddn = \"MA$LDA$A\"\n\n /* Maximum retry count after error */\n maxrty = 5\n\n/*--------------------------------------------------------------------*/\n\n parse arg parmsin\n\n parms = \"\"\n do mli1 = 1 to words(parmsin)   /* drop embedded spaces from parms */\n   parms = parms||word(parmsin,mli1)\n end\n retval = 0\n savretval = 0\n\n parse source s1 s2 s3 s4 s5 s6 s7 s8 s9\n if \u00ac(abbrev(s8,\"TSO\")) & \u00ac(abbrev(s8,\"ISPF\")) then do\n   say s3\": Error - not running in TSO environment.\"\n   say s3\": Error - source string is \"s1 s2 s3 s4 s5 s6 s7 s8 s9\".\"\n   retval = 20\n   signal theend\n end\n\n call ginit             /* general initialisation */\n if retval \u00ac= 0 then signal theend    /* quit if bad RC */\n\n call wmsg              /* call welcome message routine */\n\n call gpar              /* call parse parms routine */\n if retval \u00ac= 0 then signal theend    /* quit if bad RC */\n\n call adsn              /* call alloc DSN routine */\n if retval \u00ac= 0 then signal theend    /* quit if bad RC */\n\n call pmsg              /* call parm echo routine */\n\n call init              /* call init socket API routine */\n if retval \u00ac= 0 & reas \u00ac= \"ESUBTASKALREADYACTIVE\" then ,\n  signal theend         /* quit if bad RC */\n\n call gdmn               /* call get domainname routine */\n\n do rcnt = 1 to maxrty + 1 /* Loop up to maxrty times to attempt\n                              to send all of the data to SMTP server */\n   if rcnt \u00ac= 1 then do /* first loop is not a restart */\n     call snapstat      /* echo statistics so far */\n     if conn then do\n       call quit\n       call shut\n       call clos\n     end\n     /* don't check retval here in case socket already closed */\n     conn = 0\n     connbytectr = 0\n     rstline = maillineno  /* set restart to start of current mail */\n     intrst = 1            /* set internal restart flag */\n     tmplinectr = plinectr - rstline + 1 + ignctr + orstline - 1\n     plinectr = plinectr - tmplinectr /* no part processed mails */\n     say\n     say s3\": Automatic restart from line \"maillineno\" generated.\"\n   end\n\n   call sdat                   /* call send data routine */\n\n   if openf then do                  /* cleanup a possible open file */\n     \"EXECIO 0 DISKR \"ddn\" (FINIS)\"   /* close file */\n     openf = 0\n   end\n\n   if retval = 0 | nointrst then ,\n    leave                      /* RC 0 means no need for restart,\n                                  or no restart flag is set */\n end\n\n if retval \u00ac= 0 then do /* RC not zero and retries finished, */\n   call crst            /* so determine restart point */\n   savretval = retval   /* save RC for exit */\n end\n\n if conn then do        /* still connected ? */\n   call quit            /* call send QUIT routine */\n   call shut            /* call socket shut routine */\n   call clos            /* call socket close routine */\n end\n\n call term              /* call terminate socket API routine */\n\n call tmsg              /* call terminating message routine */\n\n if ddn = dynddn then do\n   if dbf then ,\n    say s3||flag\" Freeing input dataset DD:\"ddn\n   \"FREE FI(\"ddn\")\"\n end\n\ntheend:\n\n if savretval \u00ac= 0 then retval = savretval\n if retval > 4 then errtxt = \"ERROR \"\n else errtxt = \"\"\n say\n say s3\": Exiting \"errtxt\"RC=\"retval\" at \"time()\" on \"date()\".\"\n say\n\nreturn retval\n\n\n/* General initialisation */\nginit:\n\n sdate = date(\"B\")\n stime = time(\"L\")\n dbf = 0         /* debug flag */\n flag = \":\"\n nointrst = 0    /* suppress internal restart flag */\n intrst = 0      /* internal restart flag */\n maillineno = 1  /* restart line number */\n conn = 0        /* connected to server flag */\n openf = 0       /* file open flag */\n retval = 0      /* return code */\n crlf = \"0d25\"x\n call syscalls \"ON\" /* Initialise OMVS variables */\n\n /* jobname from PSA(PSATOLD)->TCB(TCBTIO)->TIOT(TIOCNJOB) */\n /*jobn = ,\n  strip(storage(c2x(storage(d2x(c2d(storage(21c,4))+12),4)),8))*/\n jobn = strip(mvsvar(\"SYMDEF\",\"JOBNAME\"))\n tcb = c2d(storage(21c,4))\n jstcb = c2d(storage(d2x(tcb+124),4))\n jscb = c2d(storage(d2x(jstcb+180),4))\n ssib = c2d(storage(d2x(jscb+316),4))\n jobnum = strip(storage(d2x(ssib+12),8))\n tcb = c2d(storage(21c,4))\n acee = c2d(storage(d2x(tcb+340),4))\n if acee = 0 then do\n  ascb = c2d(storage(224,4))\n  asxb = c2d(storage(d2x(ascb+108),4))\n  acee = c2d(storage(d2x(asxb+200),4))\n end\n user = strip(storage(d2x(acee+21),8))\n if user = \"\" | left(user,1) = d2c(0) then ,\n  user = strip(sysvar(\"SYSUID\"))\n username = \"\"\n aceeunam = c2d(storage(d2x(acee+100),4))\n if aceeunam \u00ac= 0 then do\n   aceeusrl = c2d(storage(d2x(aceeunam),1))\n   if aceeusrl > 0 then ,\n    username = strip(storage(d2x(aceeunam+1),aceeusrl-1))\n end\n\n address TSO\n \"PROFILE MSGID WTPMSG\" /* set msgid on to get TSO message ids */\n\n /* count SMTP servers */\n gi1 = 1\n if \u00ac(datatype(smtpserver.0,\"W\")) then do\n   smtpserver.0 = 0\n   do while smtpserver.gi1 \u00ac= \"SMTPSERVER.\"gi1\n     smtpserver.0 = gi1\n     gi1 = gi1 + 1\n   end\n end\n if smtpserver.0 = 0 then do\n   say s3\": Error - No SMTP servers defined in \"s3\" exec\",\n    \"and SERVER= parameter not used.\"\n   retval = 12\n   return\n end\n\nreturn\n\n\n/* Welcome message routine */\nwmsg:\n\n wmsg1 = s3\":\" ver\" entered as a \"s1 s2\" at\",\n  time()\" on \"date()\".\"\n wmsg2 = s3\": Using system \"mvsvar(\"SYSNAME\")\",\"\n if jobn = user then ,\n  wmsg3 = s3\": Executing userid is \"jobn\".\"\n else ,\n  wmsg3 = s3\": Executing job is \"jobn\" (userid \"user\").\"\n if s5 = \"?\" then ,\n  wmsg4 = \"EXEC loaded from DD:\"s4\".\"\n else ,\n  wmsg4 = \"EXEC loaded from DD:\"s4\" DSN:\"s5\".\"\n\n say\n say wmsg1\n say wmsg3\n say wmsg2 wmsg4    /* issue welcome message */\n\nreturn\n\n\npmsg:\n\n if parmstr = \"\" then parmstr = \"(none)\"\n say s3\": Parameters - \"parmstr\".\" /* show parameters */\n if pos(\"MSGLEVEL\",parmstr) = 0 & msglevel = dftmsglevel then ,\n  say s3\": MSGLEVEL defaults to \"dftmsglevel\".\" /* show MSGLEVEL */\n\n say s3\": Input data from \"inp\".\"     /* show input dataset */\n\n say s3\": Primary SMTP server is \"smtpserver.1\".\"\n say s3\": Status message issued every \"statthresh\" mails.\"\n\n if simflag then do\n   say\n   say s3\": Simulation only, no mails will be sent.\"\n   say s3\": Simulation only, no mails will be sent.\"\n end\n\nreturn\n\n\n/* Parse input parameters routine */\ngpar:\n\n retval = 0      /* return code */\n parmstr = \"\"\n msglevel = dftmsglevel\n orstline = 1\n rstline = 1\n pctr = 1\n simflag = 0\n ddn = \"\"\n dsn = \"\"\n helosupp = 1\n helocmd = \"\"\n symdata = 0\n symsmtp = 1\n\n do while parms \u00ac= \"\"\n\n   parse value parms with parm.pctr \",\" parms\n   parm.pctr = strip(parm.pctr)\n   parse upper value parm.pctr with parmu\n\n   select\n\n     when abbrev(parmu,\"DSN=\") then do\n       if ddn \u00ac= \"\" then do\n         say s3\": Error - DSN parameter incompatible with DD.\"\n         retval = 12\n         return\n       end\n       dsn = strip(substr(parmu,5))\n       dsn = strip(dsn,,\"'\")\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when abbrev(parmu,\"DD=\") then do\n       if dsn \u00ac= \"\" then do\n         say s3\": Error - DD parameter incompatible with DSN.\"\n         retval = 12\n         return\n       end\n       ddn = strip(substr(parmu,4))\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when abbrev(parmu,\"MSGLEVEL=\") then do\n       if pos(\"DEBUG\",parmstr) > 0 then do\n         say s3\": Error - DEBUG parameter incompatible with MSGLEVEL.\"\n         retval = 12\n         return\n       end\n       msglevel = substr(parmu,10)\n       if \u00ac(datatype(msglevel,\"W\")) then do\n         say s3\": Warning - non-integer \"parm.pctr\" ignored.\"\n         msglevel = dftmsglevel\n       end\n       else if msglevel < 1 then do\n         say s3\": Warning - invalid \"parm.pctr\" assumed to be 1.\"\n         msglevel = 1\n       end\n       else if msglevel > 4 then do\n         say s3\": Warning - invalid \"parm.pctr\" assumed to be 4.\"\n         msglevel = 4\n       end\n       parmstr = parmstr\"MSGLEVEL=\"msglevel\",\"\n     end\n\n     when abbrev(parmu,\"RESTART=\") then do\n       rstline = substr(parmu,9)\n       if \u00ac(datatype(rstline,\"W\")) then do\n         say s3\": Error - non-integer \"parm.pctr\".\"\n         retval = 16\n         return\n       end\n       else if rstline < 1 then do\n         say s3\": Error - invalid \"parm.pctr\".\"\n         retval = 16\n         return\n       end\n       parmstr = parmstr\"RESTART=\"rstline\",\"\n       orstline = rstline\n     end\n\n     /*when abbrev(parmu,\"DEBUG\") then do*/\n     when parmu = \"DEBUG\" then do\n       if pos(\"MSGLEVEL\",parmstr) > 0 then do\n         say s3\": Error - DEBUG parameter incompatible with MSGLEVEL.\"\n         retval = 12\n         return\n       end\n       dbf = 1\n       msglevel = 4\n       flag = \" DEBUG:\"\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when parmu = \"SIMULATE\" | parmu =  \"NOMAIL\" then do\n       simflag = 1\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when parmu = \"HELO\" then do\n       helosupp = 0\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when parmu = \"SYMDATA\" then do\n       symdata = 1\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when parmu = \"SYMSMTP\" then do\n       symsmtp = 1\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when parmu = \"NOSYM\" then do\n       symsmtp = 0\n       symdata = 0\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when parmu = \"SYMALL\" then do\n       symsmtp = 1\n       symdata = 1\n       parmstr = parmstr||parmu\",\"\n     end\n\n     when abbrev(parmu,\"SERVER=\") then do\n       smtpserver.1 = substr(parmu,8)\n       smtpserver.0 = 1\n       parmstr = parmstr||parmu\",\"\n     end\n\n     otherwise do\n       say s3\": Error - unknown parameter '\"parm.pctr\"'.\"\n       retval = 12\n     end\n   end\n\n   pctr = pctr + 1\n\n end\n\n parmstr = strip(parmstr,\"T\",\",\")\n if msglevel = 4 then dbf = 1\n\nreturn\n\n\n/* Alloc input dataset routine */\nadsn:\n\n retval = 0      /* return code */\n\n if dsn \u00ac= \"\" then do        /* DSN passed ? */\n\n   inp = \"DSN:\"dsn\n   if dbf then ,\n    say s3||flag\" Performing Alloc \"inp\n\n   ddn = dynddn\n   msgstatus = MSG(\"OFF\")\n   \"FREE FI(\"ddn\")\"\n   null = MSG(msgstatus)\n\n   \"ALLOC FI(\"ddn\") DA('\"dsn\"') SHR\"\n   retval = RC\n   if dbf | retval \u00ac= 0 then ,\n    say s3||flag \"ALLOC DD:\"ddn inp\" RC=\"retval\n\n end\n else if ddn \u00ac= \"\" then do\n   inp = \"DD:\"ddn\n end\n else do\n\n   /* no DSN/DD passed, assume MAILDATA DD */\n   inp = \"DD:MAILDATA\"\n   ddn = \"MAILDATA\"\n\n end\n\nreturn\n\n\n/* Send data routine */\nsdat:\n\n retval = 0      /* return code */\n indata = 0      /* got DATA command flag */\n indatahdr = 0   /* in DATA header command flag */\n gotmail = 0     /* mail flag */\n connbytectr = 0 /* connection bytes transmitted */\n maildatactr = 0 /* data lines in mail */\n mailbytectr = 0 /* data bytes in mail */\n if \u00ac(intrst) then do /* don't reset counters on internal restart */\n   plinectr = 0    /* total processed lines */\n   bytectr = 0     /* total bytes processed */\n   readctr = 0     /* lines read */\n   mailctr = 0     /* total mail counter */\n   ignctr = 0      /* ignored lines counter */\n   symbytectr = 0  /* net change in byte count after symbolics */\n   symlinectr = 0  /* net change in line count after symbolics */\n   rsymbctr = 0    /* set to zero in case symbolics not used */\n   rsymlctr = 0    /* set to zero in case symbolics not used */\n end\n flctr = rstline - 1  /* current file line number */\n\n if rstline \u00ac= 1 then ,\n  say s3\": Restarting from line \"rstline\".\"\n\n \"EXECIO 0 DISKR \"ddn rstline \"(OPEN)\"    /* open input file */\n retval = RC\n\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag \"EXECIO open \"inp\" RC=\"retval\n if retval \u00ac= 0 then do\n   nointrst = 1     /* suppress internal restart for open error */\n   return\n end\n\n openf = 1\n\n /* Loop for every line in the dataset */\n do forever   /* do until eof */\n\n   \"EXECIO 1 DISKR \"ddn\" (LIFO)\"  /* read 1 line from file */\n   retval = RC\n\n   if dbf | retval > 2 then ,\n    say s3||flag \"EXECIO read \"inp\" RC=\"retval\n\n   if retval > 2 then do\n     nointrst = 1     /* suppress internal restart for file error */\n     return\n   end\n   else if retval = 2 then do\n\n     if dbf then ,\n      say s3||flag \"EOF reached, closing \"inp\n     \"EXECIO 0 DISKR \"ddn\" (FINIS)\"   /* close file */\n     openf = 0\n     if rstline > 1 & readctr = 0 then do\n       say s3\": RESTART=\"rstline\" invalid because input file does\",\n        \"not have that many lines.\"\n       nointrst = 1     /* suppress internal restart for file error */\n       retval = 16\n       return\n     end\n     else do\n       retval = 0      /* EOF is normal so propagate a zero */\n     end\n\n     if indata then do /* must send end of data if data not ended */\n       sv2retval = retval\n       line = crlf||\".\"\n       edverb = \"Generated\"\n       call enddata\n       retval = sv2retval\n     end\n\n     leave           /* eof reached - leave the forever loop */\n\n   end\n\n   parse pull line                      /* get data line from stack */\n   flctr = flctr + 1                    /* increment curr line ctr */\n   readctr = readctr + 1                /* increment read counter */\n   line = strip(line,\"T\")               /* strip trailing blanks */\n   len = length(line)\n   parse upper value word(line,1) with cmd\n\n   /* Select on the input data line */\n   select\n\n     /* End of data received. We expect a response so a blocking\n        read is used. The indata flag is reset. */\n     when (indata & line = \".\") then do             /* must be 1st */\n       edverb = \"Sent\"\n       call enddata\n     end\n\n     /* For data lines we do not expect a response */\n     when indata then do                            /* must be 2nd */\n       if indatahdr & line = \"\" then indatahdr = 0\n\n       /* Resolve symbolics for the data header */\n       rsymlctr = 0 /* reset cos call to symbolics is conditional */\n       rsymbctr = 0\n       if indatahdr & symsmtp then line = resolve_symbolics(line)\n       if \u00ac(indatahdr) & symdata then line = resolve_symbolics(line)\n\n       /* Append a valid email address to the from name\n          in case the SMTP server validates it */\n       if indatahdr & abbrev(translate(line),\"FROM:\") &,\n        pos(\"@\",line) = 0 then do\n         line = line\" <\"strip(jobn)\"@\"strip(hdmn)\">\"\n       end\n\n       if \u00ac(simflag) then do\n         linespl = line\n         do until linespl = \"\"\n           parse var linespl linedat (crlf) linespl\n           call wdat linedat     /* call write data routine */\n           if retval \u00ac= 0 then return\n         end\n       end\n       bytectr = bytectr + len        /* file byte counter increment\n                                         before recompute line length */\n       len = length(line)        /* recompute line length */\n       symbytectr = symbytectr + rsymbctr\n       symlinectr = symlinectr + rsymlctr\n       maildatactr = maildatactr + 1 + rsymlctr\n       mailbytectr = mailbytectr + len\n       plinectr = plinectr + 1\n       connbytectr = connbytectr + len     /* add to conn byte count */\n     end\n\n    /* MAIL command - we expect a definite response,\n       but we also do a non-blocking read just in case there are\n       extra response lines. */\n     when cmd = \"MAIL\" then do                      /* must be 3rd */\n\n       maillineno = flctr  /* restart line number */\n       gotmail = 1\n       if symsmtp then line = resolve_symbolics(line)\n\n       /* Disconnect if maxmailbytes is exceeded to try to\n          avoid any errors due to thresholds set in the server */\n       if (connbytectr > currmaxmailbytes) & conn then do\n         say s3\": Transmitted bytes exceeds threshold (\"||,\n          currmaxmailbytes\") - disconnecting temporarily.\"\n         call snapstat \"discon\"     /* echo statistics so far */\n         call quit\n         call shut\n         call clos\n         /* don't check retval here in case socket already closed */\n         conn = 0\n         connbytectr = 0\n       end\n\n       /* Connect to server if not already connected. */\n       if \u00ac(conn) then do\n         call connr          /* call connect routine */\n         if retval \u00ac= 0 then return /* return if no connect */\n         conn = 1\n         call shlo           /* call send HELO routine */\n         if retval \u00ac= 0 then return\n       end\n\n       call wdat line        /* call write data routine */\n       if retval \u00ac= 0 then return\n       if msglevel > 1 then do\n         say\n         say s3\": Sent \"line\" from line \"flctr\" of \"inp\".\"\n       end\n       call readmchknum \"250\"\n       if retval \u00ac= 0 then return\n       symbytectr = symbytectr + rsymbctr\n       symlinectr = symlinectr + rsymlctr\n       plinectr = plinectr + 1\n       connbytectr = connbytectr + len     /* add to conn byte count */\n       bytectr = bytectr + len             /* add to proc byte count */\n\n     end\n\n     when cmd = \"HELO\" | cmd = \"EHLO\" then do       /* must be 4th */\n\n       if symsmtp then line = resolve_symbolics(line)\n       if helosupp then do\n         ignctr = ignctr + 1\n         if msglevel > 2 then ,\n          say s3\": Command '\"line\"' at line \"flctr\" not needed,\",\n           \"so ignored.\"\n       end\n       else do\n         helocmd = line\n       end\n\n     end\n\n     when cmd = \"QUIT\" then do                     /* must be 5th */\n\n       if conn then do\n         call quit\n         call shut\n         call clos\n         conn = 0\n         connbytectr = 0\n         plinectr = plinectr + 1\n       end\n       else do\n         ignctr = ignctr + 1\n         if msglevel > 2 then ,\n          say s3\": Command '\"line\"' at line \"flctr\" ignored\",\n           \"(already quit).\"\n       end\n\n     end\n\n     /* No MAIL command received so we ignore lines in the file\n        until we get one */\n     when \u00ac(gotmail) then do                        /* must be 6th */\n\n       say s3\": Warning - ignored line starting '\"substr(line,1,20)||,\n        \"' at line \"flctr,\n        \"as no MAIL command received.\"\n       ignctr = ignctr + 1\n\n     end\n\n     when cmd = \"RSET\" |,                          /* must be 7th */\n      cmd = \"NOOP\" then do\n\n       if symsmtp then line = resolve_symbolics(line)\n       if cmd = \"NOOP\" then line = cmd  /* skip operands for noop */\n       call wdat line        /* call write data routine */\n       if retval \u00ac= 0 then return\n       if msglevel > 1 then ,\n        say s3\": Sent \"line\n       call readmchknum \"250\"\n       if retval \u00ac= 0 then return\n       symbytectr = symbytectr + rsymbctr\n       symlinectr = symlinectr + rsymlctr\n       plinectr = plinectr + 1\n       connbytectr = connbytectr + len     /* add to conn byte count */\n       bytectr = bytectr + len             /* add to proc byte count */\n\n     end\n\n    /* DATA command - we expect a definite response,\n       but we also do a non-blocking read all just in case there are\n       extra response lines. The indata flag is set as following\n       data lines will not get a response */\n     when cmd = \"DATA\" then do\n\n       indata = 1\n       indatahdr = 1\n       maildatactr = 0 /* data lines in mail */\n       mailbytectr = 0 /* bytes in mail */\n       if \u00ac(simflag) then do\n         call wdat line        /* call write data routine */\n         if retval \u00ac= 0 then return\n         if msglevel > 1 then ,\n          say s3\": Sent \"line\n         call readmchknum \"354\"\n         if retval \u00ac= 0 then return\n       end\n       plinectr = plinectr + 1\n       connbytectr = connbytectr + len     /* add to conn byte count */\n       bytectr = bytectr + len             /* add to proc byte count */\n\n     end\n\n    /* various commands - we expect a definite response,\n       but we also do a non-blocking read just in case there are\n       extra response lines. */\n     when cmd = \"RCPT\" |,\n      cmd = \"VRFY\" then do\n\n       if symsmtp then line = resolve_symbolics(line)\n       call wdat line        /* call write data routine */\n       if retval \u00ac= 0 then return\n       if msglevel > 1 then ,\n        say s3\": Sent \"line\n       call readmchknum \"250 251 252\"\n       if retval \u00ac= 0 then return\n       symbytectr = symbytectr + rsymbctr\n       symlinectr = symlinectr + rsymlctr\n       plinectr = plinectr + 1\n       connbytectr = connbytectr + len     /* add to conn byte count */\n       bytectr = bytectr + len             /* add to proc byte count */\n\n     end\n\n    /* other commands - we do a non-blocking read because we don't\n       know if we will get a response */\n     otherwise do\n\n       call wdat line        /* call write data routine */\n       if retval \u00ac= 0 then return\n       say s3\": Sent \"line\n       call readmsgs \"NON-BLOCKING\"\n       if retval \u00ac= 0 then return\n       if rddata \u00ac= \"\" & msglevel > 2 then ,\n        say s3\": Recv \"rddata\n       plinectr = plinectr + 1\n       connbytectr = connbytectr + len     /* add to conn byte count */\n       bytectr = bytectr + len             /* add to proc byte count */\n\n     end\n\n   end\n\n end\n\nreturn\n\n\n/* init socket API routine */\ninit:\n\n if dbf then do\n   say\n   say s3||flag\" Performing socket Initialize\"\n end\n rtvl = socket(\"Initialize\",s3)\n parse var rtvl retval reas .\n if dbf | (retval \u00ac= 0 & reas \u00ac= \"ESUBTASKALREADYACTIVE\") then ,\n  say s3||flag\" Initialize RC=\"rtvl\n\nreturn\n\n\n/* socket init routine */\nsock:\n\n if dbf then ,\n  say s3||flag\" Performing Socket\"\n rtvl = socket(\"Socket\",2,\"STREAM\",0)\n parse var rtvl retval reas .\n if retval = 0 then sockid = reas\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Socket RC=\"rtvl\n\nreturn\n\n\n/* socket set ASCII routine */\nasci:\n\n if dbf then ,\n  say s3||flag\" Performing socket Setsockopt So_ASCII\"\n rtvl = socket(\"Setsockopt\",sockid,\"Sol_Socket\",\"So_ASCII\",\"On\")\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Setsockopt So_ASCII RC=\"rtvl\n\nreturn\n\n\n/* socket set block/non-block routine. A socket\n   with the block option causes read socket calls to wait\n   indefinitely for a response. */\nblck:\n\n parse arg blopt\n\n if dbf then ,\n  say s3||flag\" Performing socket Fcntl \"blopt\n rtvl = socket(\"Fcntl\",sockid,\"F_SETFL\",blopt)\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Fcntl \"blopt\" RC=\"rtvl\n\nreturn\n\n\n/* socket connect retry wrapper routine. */\nconnr:\n\n sctr = 1\n\n do until (retval = 0 | sctr > smtpserver.0)\n\n   if smtpserver.sctr = \"*LOCAL*\" then ,\n    smtpserver.sctr = host\".\"domain\n   call conns smtpserver.sctr\n   if retval \u00ac= 0 then do\n     sretval = retval\n     call clos\n     if sctr = smtpserver.0 then do\n      cnrstr1 = \"Error\"\n      cnrstr2 = \"No more SMTP servers available to try.\"\n     end\n     else do\n      cnrstr1 = \"Warning\"\n      cnrstr2 = \"Retrying with next one.\"\n     end\n     say s3\": \"cnrstr1\" - Connect failed to SMTP server #\"||,\n      sctr smtpserver.sctr\".\" cnrstr2\n     retval = sretval\n   end\n   sctr = sctr + 1\n\n end\n\n if retval \u00ac= 0 then return\n\n if wordpos(\"MVS\",sav220) > 0 |,\n  wordpos(\"OS390\",sav220) > 0 |,\n  wordpos(\"OS/390\",sav220) > 0 |,\n  wordpos(\"Z/OS\",sav220) > 0 |,\n  wordpos(\"z/OS\",sav220) > 0 then do\n   currmaxmailbytes = maxOS390mailbytes\n   if msglevel > 1 then ,\n    say s3||flag\" OS/390 system detected, maximum bytes\",\n     \"per connection set to \"currmaxmailbytes\" bytes.\"\n end\n else do\n   currmaxmailbytes = maxmailbytes\n   if msglevel > 1 then ,\n    say s3||flag\" Maximum bytes\",\n     \"per connection set to \"currmaxmailbytes\" bytes.\"\n end\n\nreturn\n\n\n/* End of data routine. */\nenddata:\n\n indata = 0\n indatahdr = 0\n gotmail = 0     /* mail flag */\n\n /* if simulation, then cancel existing transaction with\n    RSET SMTP server command */\n if simflag then do\n   call rset\n   if retval \u00ac= 0 then return\n end\n else do\n   call wdat line        /* call write data routine */\n   if retval \u00ac= 0 then return\n   if msglevel > 1 then ,\n    say s3\": \"edverb\" end of message for mail \"mailctr+1\".\",\n     maildatactr\" data lines (\"mailbytectr\" data bytes).\"\n   call readmchknum \"250\"\n   if retval \u00ac= 0 then return\n end\n\n mailctr = mailctr + 1\n plinectr = plinectr + 1\n connbytectr = connbytectr + len     /* add to conn byte count */\n bytectr = bytectr + len             /* add to proc byte count */\n\n if datatype(mailctr/statthresh,\"W\") then do\n   call snapstat       /* snap statistics if threshold reached */\n end\n\nreturn\n\n\n/* socket connect routine. */\nconns:\n\n parse arg cssrv\n sav220 = \"\"\n\n call sock                   /* call socket init routine */\n if retval \u00ac= 0 then return  /* quit if bad RC */\n\n call asci                   /* call socket set ASCII routine */\n if retval \u00ac= 0 then return  /* quit if bad RC */\n\n call gsoc                   /* call get socket info routine */\n call gcli                   /* call get client info routine */\n\n if dbf then ,\n  say s3||flag\" Performing socket Connect \"cssrv\n rtvl = socket(\"Connect\",sockid,\"AF_INET \"smtpport cssrv)\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Connect \"cssrv\" RC=\"rtvl\n if retval \u00ac= 0 then return\n\n /* definite response with 220 message expected from server */\n call readmchknum \"220\"\n if retval \u00ac= 0 then return\n say;say s3\": Connected to \"strip(subword(sav220,2))\".\"\n\n call gpee                   /* call get peer (server) info routine */\n if retval = 0 then ,        /* call gethostbyaddr info routine */\n  call ghba\n\nreturn\n\n\n/* blocking read routine i.e. an indefinite wait for a reply from\n   the server for 1st message then non-blocking reads subsequently */\nreadmsgs:\n\n parse arg rmsgp\n rddata = \"\"\n srvrc = \"\"\n\n if rmsgp \u00ac= \"NON-BLOCKING\" then do\n\n   call blck \"BLOCKING\"\n   if retval \u00ac= 0 then return\n\n   if dbf then ,\n    say s3||flag\" Performing socket Read (blocking)\"\n\n   rtvl = socket(\"Read\",sockid)\n   parse var rtvl retval reas .\n   if dbf | retval \u00ac= 0 then ,\n    say s3||flag\" Read RC=\"rtvl\n\n   /* Data starts at 3rd word of response */\n   if retval = 0 then do\n     rddata = trns(subword(rtvl,3))\n     srvrc = word(rddata,1)\n   end\n   else return\n\n end\n\n call blck \"NON-BLOCKING\"\n if retval \u00ac= 0 then return\n\n do forever          /* Loop until no more data */\n\n   if dbf then ,\n    say s3||flag\" Performing socket Read (non-blocking)\"\n   rtvl = socket(\"Read\",sockid)\n   parse var rtvl retval reas .\n   if dbf | (retval \u00ac= 0 & reas \u00ac= \"EWOULDBLOCK\" ) then ,\n    say s3||flag\" Read RC=\"rtvl\n   if retval = 0 then do\n     if reas = 0 then leave        /* exit for zero length data */\n     rddata = rddata||trns(subword(rtvl,3))\n   end\n   else do\n     if reas = \"EWOULDBLOCK\" then retval = 0\n     leave\n   end\n\n end\n\nreturn\n\n\n/* Send RSET to server routine */\nrset:\n\n call wdat \"RSET\"            /* call write data routine */\n if retval \u00ac= 0 then return\n if msglevel > 2 then ,\n  say s3\": Sent RSET\"\n call readmchknum \"250\"\n\nreturn\n\n\n/* Send QUIT to server routine */\nquit:\n\n call wdat \"QUIT\"            /* call write data routine */\n if retval \u00ac= 0 then return\n if msglevel > 1 then do\n  say\n  say s3\": Sent QUIT\"\n end\n call readmsgs\n if retval \u00ac= 0 then return\n if (msglevel > 2 | srvrc \u00ac= \"221\") & rddata \u00ac= \"\" then ,\n  say s3\": Recv \"rddata\n\nreturn\n\n\n/* Send HELO to server routine */\nshlo:\n\n if helocmd = \"\" then helocmd = \"HELO \"hdmn\n call wdat helocmd                  /* call write data routine */\n if retval \u00ac= 0 then return\n if msglevel > 1 then ,\n  say s3\": Sent \"helocmd\n call readmchknum \"250\"\n\nreturn\n\n\n/* socket write routine */\nwdat:\n\n parse arg wddata\n if dbf then ,\n  say s3||flag\" Write\" wddata\n rtvl = socket(\"Write\",sockid,wddata||crlf)\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Write RC=\"rtvl\n\nreturn\n\n\n/* socket shut routine */\nshut:\n\n if dbf then ,\n  say s3||flag\" Performing socket Shutdown\"\n rtvl = socket(\"Shutdown\",sockid,\"BOTH\")\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Shutdown RC=\"rtvl\n\nreturn\n\n\n/* socket close routine */\nclos:\n\n if dbf then ,\n  say s3||flag\" Performing socket Close\"\n rtvl = socket(\"Close\",sockid)\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Close RC=\"rtvl\n if retval = 0 & peer \u00ac= \"PEER\" then do\n   if ghbaname \u00ac= \"\" then extstr = \" (\"ghbaname\")\"\n   else extstr = \"\"\n   say s3\": Closed socket to \"peer||extstr\".\"\n end\n\nreturn\n\n\n/* socket API terminate routine */\nterm:\n\n if dbf then ,\n  say s3||flag\" Performing socket Terminate\"\n rtvl = socket(\"Terminate\")\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Terminate RC=\"rtvl\n\nreturn\n\n\n/* socket get peer info routine */\ngpee:\n\n if dbf then ,\n  say s3||flag\" Performing socket Getpeername\"\n rtvl = socket(\"Getpeername\",sockid)\n parse var rtvl retval reas .\n if retval = 0 then peer = word(rtvl,4)\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Getpeername RC=\"rtvl\n\nreturn\n\n\n/* socket get socket name info routine */\ngsoc:\n\n if dbf then ,\n  say s3||flag\" Performing socket Getsockname\"\n rtvl = socket(\"Getsockname\",sockid)\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Getsockname RC=\"rtvl\n\nreturn\n\n\n/* socket get client info routine */\ngcli:\n\n if dbf then ,\n  say s3||flag\" Performing socket Getclientid\"\n rtvl = socket(\"Getclientid\")\n parse var rtvl retval reas .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Getclientid RC=\"rtvl\n\nreturn\n\n\n/* socket get domainname info routine */\ngdmn:\n\n call ghst\n call ghid\n\n if dbf then ,\n  say s3||flag\" Performing socket Getdomainname\"\n rtvl = socket(\"Getdomainname\")\n parse var rtvl retval domain .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Getdomainname RC=\"rtvl\n if retval \u00ac= 0 then do\n   domain = \"\"\n   hdmn = sysvar(\"SYSNODE\")\n   retval = 0\n end\n else do\n  if host = \"\" then hdmn = domain\n  else hdmn = host\".\"domain\n end\n\nreturn\n\n\n/* socket get hostname info routine */\nghst:\n\n if dbf then ,\n  say s3||flag\" Performing socket Gethostname\"\n rtvl = socket(\"Gethostname\")\n parse var rtvl retval host .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Gethostname RC=\"rtvl\n if retval \u00ac= 0 then do\n   host = \"\"\n   retval = 0\n end\n\nreturn\n\n\n/* socket get hostid info routine */\nghid:\n\n if dbf then ,\n  say s3||flag\" Performing socket Gethostid\"\n rtvl = socket(\"Gethostid\")\n parse var rtvl retval hostid .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" Gethostid RC=\"rtvl\n if retval \u00ac= 0 then do\n   hostid = \"0.0.0.0\"\n   retval = 0\n end\n\nreturn\n\n\n/* socket get hostbyaddr info routine */\nghba:\n\n if pos(\".\",peer) = 0 then do\n   ghbaname = \"\"\n   if dbf then ,\n    say s3||flag peer\" not a valid IP address, GetHostByAddr skipped.\"\n   retval = 0\n   return\n end\n if dbf then ,\n  say s3||flag\" Performing socket GetHostByAddr \"peer\n rtvl = socket(\"GetHostByAddr\",peer)\n parse var rtvl retval ghbaname .\n if dbf | retval \u00ac= 0 then ,\n  say s3||flag\" GetHostByAddr RC=\"rtvl\n if retval \u00ac= 0 then do\n   ghbaname = \"\"\n   retval = 0\n end\n\nreturn\n\n\n/* terminating message routine */\ntmsg:\n\n retval = 0\n\n lsecs = getlsecs()\n\n lhrs = lsecs % (60*60)\n if lhrs > 0 then do\n   rsecs = lsecs // (60*60)\n   lmins = rsecs % 60\n   rsecs = rsecs // 60\n   if lhrs = 1 then hrstr = \"\"\n   else hrstr = \"s\"\n   if lmins = 1 then minstr = \"\"\n   else minstr = \"s\"\n   lstr = lhrs\" hour\"hrstr\" \"lmins\" minute\"minstr,\n    format(rsecs,,1)||\" seconds.\"\n end\n else do\n   lmins = lsecs % 60\n   if lmins > 0 then do\n     rsecs = lsecs // 60\n     if lmins = 1 then minstr = \"\"\n     else minstr = \"s\"\n     lstr = lmins\" minute\"minstr,\n      format(rsecs,,1)||\" seconds.\"\n   end\n   else do\n     lstr = format(lsecs,,1)||\" seconds.\"\n   end\n end\n\n mailrate = format(mailctr/lsecs,,1)\n byterate = (bytectr+symbytectr)/lsecs\n if byterate > 1000*1000 then ,\n   brstr = format(byterate/(1000*1000),,2)||\" total Mbytes/sec.\"\n else if byterate > 1000 then ,\n   brstr = format(byterate/1000,,1)||\" total Kbytes/sec.\"\n else ,\n   brstr = format(byterate,,0)||\" total bytes/sec.\"\n\n if ignctr > 0 & orstline = 1 then ,\n  igndata = \" (plus \"ignctr\" ignored)\"\n else if ignctr > 0 & orstline > 1 then ,\n  igndata = \" (plus \"ignctr\" ignored, \"orstline-1\" skipped)\"\n else if ignctr = 0 & orstline > 1 then ,\n  igndata = \" (plus \"orstline-1\" skipped)\"\n else ,\n  igndata = \"\"\n\n say\n if simflag then do\n   simstr = \"Simulated \"\n   simstr1 = \"Simulated elapsed\"\n   simstr2 = \"Simulated performance\"\n   say s3\": Simulation only, no mails sent, following statistics\",\n    \"reflect simulated performce only.\"\n   say s3\": Simulation only, no mails sent, following statistics\",\n    \"reflect simulated performce only.\"\n   say\n end\n else do\n   simstr = \"\"\n   simstr1 = \"Elapsed\"\n   simstr2 = \"Performance\"\n end\n\n\n bcstr = fmtbyte(bytectr,\"file \")\n\n if mailctr = 1 then mcp = \"\"\n else mcp = \"s\"\n say s3\": \"simstr||mailctr\" mail\"mcp||,\n  \", \"plinectr\" file lines\"igndata\",\",\n  bcstr\" processed.\"\n if symbytectr \u00ac= 0 then do\n   if symbytectr < 0 then symbytestr = \"removed\"\n   else symbytestr = \"added\"\n   say s3\": Symbolic substitution\",\n    symbytestr fmtbyte(symbytectr)\".\"\n end\n\n if mailctr = 0 then retval = 4\n else do\n   say s3\": \"simstr1\" time \"lstr\n   say s3\": \"simstr2\" \"mailrate,\n    \"mails/sec, \"brstr\n end\n\nreturn\n\n\nfmtbyte:\n\n parse arg fmtbyte,fmtext\n\n if fmtbyte > 1000*1000*1000 then ,\n   fbstr = format(fmtbyte/(1000*1000*1000),,3) fmtext\"Gbytes\"\n else if fmtbyte > 1000*1000 then ,\n   fbstr = format(fmtbyte/(1000*1000),,2) fmtext\"Mbytes\"\n else if fmtbyte > 1000 then ,\n   fbstr = format(fmtbyte/1000,,1) fmtext\"Kbytes\"\n else ,\n   fbstr = format(fmtbyte,,0) fmtext\"bytes\"\n\nreturn fbstr\n\n\n/* resolve symbolics in commands, data header and data */\nresolve_symbolics:\n\n parse arg rsyml\n\n if pos(\"&\",rsyml) = 0 then return rsyml /* extra check saves CPU */\n rssav = rsyml\n\n rsymnm.1  = \"&HOST&\"    ; rsymvl.1  = host\n rsymnm.2  = \"&DOMAIN&\"  ; rsymvl.2  = domain\n rsymnm.3  = \"&HOSTID&\"  ; rsymvl.3  = hostid\n rsymnm.4  = \"&JOBNAME&\" ; rsymvl.4  = jobn\n rsymnm.5  = \"&USERID&\"  ; rsymvl.5  = user\n rsymnm.6  = \"&USERNAME&\"; rsymvl.6  = username\n rsymnm.7  = \"&JOBNUM&\"  ; rsymvl.7  = jobnum\n rsymnm.8  = \"&PEERID&\"  ; rsymvl.8  = peer\n rsymnm.9  = \"&PEERNAME&\"; rsymvl.9  = ghbaname\n rsymnm.10 = \"&SYSNODE&\" ; rsymvl.10 = sysvar(\"SYSNODE\")\n rsymnm.11 = \"&EXECNAME&\"; rsymvl.11 = s3\n rsymnm.12 = \"&VERSION&\" ; rsymvl.12 = ver\n rsymnm.13 = \"&SYSNAME&\" ; rsymvl.13 = mvsvar(\"SYSNAME\")\n rsymnm.14 = \"&SYSSMFID&\"; rsymvl.14 = mvsvar(\"SYSSMFID\")\n rsymnm.15 = \"&SYSOPSYS&\"; rsymvl.15 = mvsvar(\"SYSOPSYS\")\n rsymnm.16 = \"&SYSPLEX&\" ; rsymvl.16 = mvsvar(\"SYSPLEX\")\n\n rsyml = rsym2(rsyml)\n\n /* process REXX and TSO commands after substitution of variables */\n signal on syntax name resolve_symbolics_err\n rsyml = rsym3(rsyml)\n signal off syntax\n signal resolve_symbolics_cont\n\nresolve_symbolics_err:\n say s3\": REXX error \"RC\" in line \"SIGL\" : \"errortext(RC)\n say s3\": \"strip(sourceline(SIGL),\"T\")\n say s3\": Warning, substitution of &!CMDS& in line \"flctr \"caused a\",\n  \"REXX error: \"rsyml\n\nresolve_symbolics_cont:\n  if dbf & rssav \u00ac= rsyml then do\n    say s3||flag\" Line \"flctr\" before substitution: \"rssav\n    say s3||flag\" Line \"flctr\" after substitution:  \"rsyml\n  end\n\n  rsymlctr = 0\n  rsymbctr = length(rsyml)\n  do rsymi1 = 1 to rsymbctr          /* count the CRLFs */\n    if abbrev(substr(rsyml,rsymi1),crlf) then ,\n     rsymlctr = rsymlctr + 1\n  end\n  rsymbctr = rsymbctr - length(rssav) /* compute net increase in bytes*/\n  retval = 0\n\nreturn rsyml\n\n\n/* substitute static symbolics */\nrsym2:\n\n parse arg r2in\n\n r2rt = \"\"\n do r2i1 = 1 to length(r2in)\n   r2remstr = substr(r2in,r2i1)\n   if abbrev(r2remstr,\"&\") then do    /* this extra check saves CPU */\n     r2i2 = 1\n     do until rsymnm.r2i2 = \"RSYMNM.\"r2i2\n       r2fr = rsymnm.r2i2\n       r2to = rsymvl.r2i2\n       if abbrev(r2remstr,r2fr) then do\n         r2rt = r2rt||r2to\n         r2i1 = r2i1 + length(r2fr) - 1\n         iterate r2i1\n       end\n       r2i2 = r2i2 + 1\n     end\n   end\n   /*r2rt = r2rt||substr(r2in,r2i1,1)*/\n   r2rt = r2rt||substr(r2remstr,1,1)\n end\n\nreturn r2rt\n\n\n/* substitute command and REXX symbolics */\nrsym3:\n\n parse arg r3in\n\n if pos(\"&!\",r3in) = 0 then return r3in /* this extra check saves CPU */\n r3rt = \"\"\n do r3i1 = 1 to length(r3in)\n   r3remstr = substr(r3in,r3i1)\n   if abbrev(r3remstr,\"&!\") then do\n     r3ecpos = pos(\"!&\",substr(r3remstr,2))\n     if r3ecpos > 0 then do\n       r3exc = substr(r3remstr,3,r3ecpos-2)\n       if abbrev(r3remstr,\"&!TSO \") then do\n         r3exc = substr(r3exc,5)\n         r3cmdout = rsymtso(r3exc)\n       end\n       else if abbrev(r3remstr,\"&!DSN \") then do\n         r3exc = substr(r3exc,5)\n         r3cmdout = rsymdsn(r3exc)\n       end\n       else if abbrev(r3remstr,\"&!OE \") then do\n         r3exc = substr(r3exc,4)\n         r3cmdout = rsymoe(r3exc)\n       end\n       else if abbrev(r3remstr,\"&!HFS \") then do\n         r3exc = substr(r3exc,5)\n         r3cmdout = rsymhfs(r3exc)\n       end\n       else ,\n        interpret \"r3cmdout = \"r3exc\n       r3rt = r3rt||r3cmdout\n       r3i1 = r3i1 + r3ecpos + 1\n       iterate\n     end\n   end\n   r3rt = r3rt||substr(r3remstr,1,1)\n end\n\nreturn r3rt\n\n\n/* TSO command substitution */\nrsymtso:\n\n parse arg rstc\n\n rstret = rstc||crlf\n rstmsg = msg(\"ON\")\n drop rstout.\n rsdum = outtrap(\"rstout.\")\n address TSO rstc\n do rsti1 = 1 to rstout.0\n   rstret = rstret||rstout.rsti1||crlf\n end\n rsdum = outtrap(\"OFF\")\n x = msg(rstmsg)\n\nreturn rstret\n\n\n/* DSN substitution */\nrsymdsn:\n\n parse arg rsdsc\n\n rsdsc = strip(rsdsc,,\"'\")\n rsdsret = rsdsc||crlf\n rsdsdd = \"R$X\"right(random(99999),5,\"0\")\n rsdsmsg = msg(\"ON\")\n drop rsdscmdout.\n rsdum = outtrap(\"rsdscmdout.\")\n address TSO\n\n \"ALLOC FI(\"rsdsdd\") DA('\"rsdsc\"') SHR\"\n if RC \u00ac = 0 then do\n   rsdsret = rsdsret\"ALLOC for \"rsdsc\" failed RC=\"RC||crlf\n   do rsdsi1 = 1 to rsdscmdout.0\n     rsdsret = rsdsret||rsdscmdout.rsdsi1||crlf\n   end\n   signal rsymdsnret\n end\n\n drop rsdsout.\n \"EXECIO * DISKR \"rsdsdd\" (STEM rsdsout. FINIS)\"\n if RC \u00ac = 0 then do\n   rsdsret = rsdsret\"EXECIO read of \"rsdsc\" failed RC=\"RC||crlf\n   do rsdsi1 = 1 to rsdscmdout.0\n     rsdsret = rsdsret||rsdscmdout.rsdsi1||crlf\n   end\n   signal rsymdsnret\n end\n\n do rsdsi1 = 1 to rsdsout.0\n   rsdsret = rsdsret||rsdsout.rsdsi1||crlf\n end\n\nrsymdsnret:\n rsdum = outtrap(\"OFF\")\n x = msg(\"OFF\")\n \"FREE FI(\"rsdsdd\")\"\n x = msg(rsdsmsg)\n\nreturn rsdsret\n\n\n/* OE command substitution */\nrsymoe:\n\n parse arg rsoec\n\n rsoec.1 = \"/bin/sh\"\n rsoec.2 = \"-Lc\"\n rsoec.3 = rsoec\n rsoec.0 = 3\n\n rsoepw. = \"\"\n address syscall \"getpwnam \"user\" rsoepw.\"\n if RC < 0 | (RC >= 0 & retval = -1) then do\n   rsoeret = rsoeret||rsymoeerr(\"syscall getpwnam \"user)\n   signal rsymoeret\n end\n if \u00ac(abbrev(rsoepw.pw_dir,\"/\")) then rsoepw.pw_dir = \"/tmp\"\n\n rsoeev.1 = \"_BPX_SHAREAS=YES\"\n rsoeev.2 = \"HOME=\"rsoepw.pw_dir\n rsoeev.3 = \"LOGNAME=\"user\n rsoeev.0 = 3\n\n rsoeret = rsoec||crlf\n rsoeshout = \"/tmp/\"user\".\"time(\"L\")\".\"s3\".\"random(99999)\n\n address syscall \"open /dev/null \"O_RDONLY 000\n if RC < 0 | (RC >= 0 & retval = -1) then do\n   rsoeret = rsoeret||rsymoeerr(\"syscall open /dev/null\")\n   signal rsymoeret\n end\n rsoefd.0 = retval\n\n address syscall \"creat (rsoeshout) 700\"\n if RC < 0 | (RC >= 0 & retval = -1) then do\n   rsoeret = rsoeret||rsymoeerr(\"syscall creat \"rsoeshout)\n   signal rsymoeret\n end\n rsoefd.1 = retval\n rsoefd.2 = retval\n\n address syscall \"spawnp (rsoec.1) 3 rsoefd. rsoec. rsoeev.\"\n if RC < 0 | (RC >= 0 & retval = -1) then do\n   rsoeret = rsoeret||rsymoeerr(\"syscall spawnp \"rsoec.1)\n   signal rsymoeret\n end\n\n rsoepid = retval\n\n address syscall \"waitpid (rsoepid) rsoest. 0\"\n if RC < 0 | (RC >= 0 & retval = -1) then do\n   rsoeret = rsoeret||rsymoeerr(\"syscall waitpid \"rsoepid)\n   signal rsymoeret\n end\n\n address syscall \"fstat (rsoefd.1) rsoestat.\"\n if RC < 0 | (RC >= 0 & retval = -1) then do\n   rsoeret = rsoeret||rsymoeerr(\"syscall fstat \"rsoefd.1)\n   signal rsymoeret\n end\n address syscall \"close \"rsoefd.1\n rsoefd.1 = \"\"             /* prevent double close */\n\n if rsoestat.st_size > 0 then do\n   address syscall \"readfile (rsoeshout) rsoeout.\"\n   if RC < 0 | (RC >= 0 & retval = -1) then do\n     rsoeret = rsoeret||rsymoeerr(\"syscall readfile \"rsoeshout)\n     signal rsymoeret\n   end\n   do rsoei1 = 1 to rsoeout.0\n     rsoeret = rsoeret||rsoeout.rsoei1||crlf\n   end\n end\n\nrsymoeret:\n if datatype(rsoefd.0,\"W\") then do\n   address syscall \"close \"rsoefd.0\n end\n if datatype(rsoefd.1,\"W\") then do\n   address syscall \"close \"rsoefd.1\n end\n if datatype(rsoefd.2,\"W\") then do\n   address syscall \"unlink (rsoeshout)\"\n end\n\nreturn rsoeret\n\n\n/* HFS substitution */\nrsymhfs:\n\n parse arg rshfc\n\n rshfret = rshfc||crlf\n address syscall \"readfile (rshfc) rshfout.\"\n if RC < 0 | (RC >= 0 & retval = -1) then do\n   rshfret = rshfret||rsymoeerr(\"syscall readfile \"rshfc)\n   signal rsymhfsret\n end\n do rshfi1 = 1 to rshfout.0\n   rshfret = rshfret||rshfout.rshfi1||crlf\n end\n\nrsymhfsret:\n\nreturn rshfret\n\n\nrsymoeerr:\n\n parse arg rsoeet\n\n rsoeet = rsoeet||\" error RC=\"RC\n if retval = -1 then do\n  rsoeet = rsoeet||\" Errno=\"errno \"Errnojr=\"right(errnojr,8,\"0\")||crlf\n  address syscall \"strerror \"errno errnojr\" rsoeerr.\"\n  do rsoeei1 = 1 to rsoeerr.0\n    rsoeet = rsoeet||rsoeerr.rsoeei1||crlf\n  end\n end\n\nreturn rsoeet\n\n\n/* echo status statistics */\nsnapstat:\n\n parse arg ssentry\n\n if ssentry = \"discon\" then ssmrstr = ,\n  \" (\"format(mailctr/getlsecs(),,1)\" per sec)\"\n else ,\n  ssmrstr = \"\"\n\n if mailctr = 1 then mcp = \"\"\n else mcp = \"s\"\n\n bcstr = fmtbyte(bytectr+symbytectr,\"total \")\n say s3\": Status - \"mailctr\" mail\"mcp||ssmrstr\", \"plinectr,\n  \"file lines, \"bcstr\" processed.\"\n\nreturn\n\n\n/* read multiple messages and check numeric reply code from server */\nreadmchknum:\n\n parse arg chknum\n retval = 0\n\n call readmsgs\n\n if retval \u00ac= 0 then return\n if srvrc = \"220\" then ,\n  sav220 = rddata\n if msglevel > 2 | wordpos(srvrc,chknum) = 0 then ,\n   say s3\": Recv \"rddata\n if wordpos(srvrc,chknum) = 0 then do\n   say s3\": Error unexpected response \"srvrc\" from server, expecting\",\n    chknum\n   if datatype(srvrc,\"W\") then ,\n    retval = srvrc\n   else ,\n    retval = 999\n   return\n end\n\nreturn\n\n\n/* check recommended restart line and echo it */\ncrst:\n\n say\n say s3\": An error has occurred and the maximum retry count of \"maxrty,\n  \"has been exceeded, or retry is not allowed.\"\n say s3\": See prior messages for diagnosis.\"\n if mailctr = 0 then do\n   if rstline = 1 then ,      /* message only if no restart */\n    say s3\": Restart using entire input dataset.\",\n     \"i.e. do not specify RESTART= parameter to \"s3\".\"\n end\n else do\n   if mailctr = 1 then mcp = \"\"\n   else mcp = \"s\"\n   say s3\": \"mailctr\" mail\"mcp\" (\"maillineno-1,\n    \"lines) already processed.\"\n   say s3\": To avoid duplicate sends, specify\",\n    \"parameter RESTART=\"maillineno\" to \"s3\" on this\",\n    \"step for re-run.\"\n end\n\nreturn\n\n\ngetlsecs:\n\n ssecs = (substr(stime,1,2)*60*60) + ,\n  (substr(stime,4,2)*60) + substr(stime,7)\n edate = date(\"B\")\n etime = time(\"L\")\n esecs = (substr(etime,1,2)*60*60) + ,\n  (substr(etime,4,2)*60) + substr(etime,7)\n\n if edate = sdate then do\n   lsecs = esecs - ssecs\n end\n else do\n   extsecs = (edate - sdate - 1) * 60*60*24\n   lsecs = extsecs + ((60*60*24)-ssecs) + esecs\n end\n\nreturn lsecs\n\n\n/* Translate CRLF to spaces and square brackets to normal\n   brackets to make them printable. */\ntrns:\n\n parse arg trnsarg\n trnsretval = translate(trnsarg,\"  ()\",\"0d25adbd\"x)\n\nreturn trnsretval\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RXMAILJ": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x03\\x01\\x03\\t\\x0f\\x01\\x03\\x10O\\x18\\x16\\x00\\x1f\\x00%\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-03-31T00:00:00", "modifydate": "2003-04-14T18:16:03", "lines": 31, "newlines": 37, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWEM JOB (AWC),TOSD-MSG,CLASS=M,MSGCLASS=X,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.REXX.PDS(RXMAILJ)\n//* JCL TO DEMONSTRATE RXMAILER (BATCH SMTP EMAILER)\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CUSTOMISE THE RXMAILER EXEC AS PER THE INSTRUCTIONS IN\n//*      THE EXEC.\n//*   3) AMEND MAILDATA DD AS REQUIRED\n//*   4) AMEND SERVER= PARAMETER AS REQUIRED\n//*\n//*\n//* EMAIL01 - RXMAILER WITH SERVER= DSN= MSGLEVEL=\n//*\n//EMAIL01  EXEC PGM=IKJEFT1B\n//SYSEXEC  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.REXX.PDS\n//SYSTSPRT DD  SYSOUT=*\n//SYSTSIN  DD  *\n %RXMAILER SERVER=*LOCAL*,DSN=AWCPAW.CBT.FILE600.REXX.PDS(RXMAILD1), -\n  MSGLEVEL=3,SYMDATA\n//*\n//* EMAIL02 - RXMAILER WITH SIMULATE (NO EMAILS) AND DEBUG (MSGLEVEL=4)\n//*\n//EMAIL02  EXEC PGM=IKJEFT1B,\n//          PARM='%RXMAILER SERVER=*LOCAL*,SIMULATE,DEBUG,SYMDATA'\n//SYSEXEC  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.REXX.PDS\n//SYSTSPRT DD  SYSOUT=*\n//MAILDATA DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.REXX.PDS(RXMAILD1)\n//SYSTSIN  DD  DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT600/CBT.V500.FILE600.PDS/XMITPDSR.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT600/CBT.V500.FILE600.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}