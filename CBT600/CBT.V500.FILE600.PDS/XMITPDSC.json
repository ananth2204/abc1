{"INMR01": {"INMLRECL": 80, "INMFNODE": "SAOTEST", "INMFUID": "AWCPAW", "INMTNODE": "SAOTEST", "INMTUID": "AWCPAW", "INMFTIME": "20050606130318000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 293930, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 255, "INMBLKSZ": 27998, "INMRECFM": "VB", "INMDIR": 11, "INMDSNAM": "AWCPAW.CBT.FILE600.C.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 293930, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"AWCPAW.CBT.FILE600.C.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27998, "DS1LRECL": 255, "DS1RECFM": "VB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 128, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 10017, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "050157", "DS1SCEXT": "b'\\x80m^'", "DS1SCALO": "b'P\\x00\\x00\\x03'", "DS1LSTAR": "b'\\x00\\x05\\x04'", "DS1TRBAL": "b'\\xcf0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b0\\xb8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03@\\x00\\x04\\x9b0\\xb8'", "b'X\\xf1\\x87\\x80\\x00\\x00\\x00g\\x00\\x01\\x00g\\x00\\x06\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$README": {"ttr": 263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00Q\\x01\\x020?\\x01\\x020?\\t'\\x00\\x04\\x00\\x04\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-30T00:00:00", "modifydate": "2002-10-30T09:27:51", "lines": 4, "newlines": 4, "modlines": 0, "user": "AWCPAW"}, "text": "\nPlease see the README in the installation PDS -\n      (userid).CBTxxx.FILE600.PDS\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CONTACT": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00B\\x01\\x02'_\\x01\\x05\\x15o\\x10\\x17\\x009\\x00$\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-10-02T00:00:00", "modifydate": "2005-06-05T10:17:42", "lines": 57, "newlines": 36, "modlines": 0, "user": "AWCPAW"}, "text": "\nAuthor contact details as follows.\n\nName      : Paul Wells\n\nAddress   : Saudi Aramco Box 12959\n            Dhahran 31311\n            Saudi Arabia\n\nTelephone : +966 3 873 3155 (Work - direct line)\n\nFax       : +966 3 873 8958 (Work)\n\nEmail     : Paul.Wells@aramco.com\n\n\nAnyone who thinks they remember me from places where I have worked\nin the past, and wish to renew acquaintances, please do.\nMy brief history as an MVS sysprog (since 1987) is as follows.\n\n2000-present : Saudi Aramco, Dhahran, Saudi Arabia.\n               OS/390 2.5/2.9, z/OS 1.2, z/OS 1.4\n\n1998-2000    : Ladbroke Racing, Rayners Lane, London, UK.\n               MVS 4.2/5.1, OS/390 2.5\n\n1996-1998    : Cap Gemini, Wandsworth Road, London, UK.\n               MVS 4.3, MVS 5.2.2, OS/390 2.4\n\n1994-1996    : ECSoft Synapse, Berkhamsted, UK.\n               Customer sites:-\n\n             : TNT Worldwide, Atherstone, UK.\n               MVS 4.3, OS/390 1.1\n\n             : Polygram, Romford, UK.\n               MVS 4.3/5.2.2\n\n             : Whitbread, Luton, UK.\n               MVS 4.3\n\n             : NPI, Tunbridge Wells, UK.\n               MVS 4.3\n\n1987-1994    : Tesco Stores, Cheshunt, UK.\n               MVS 2.1.7/2.2/3.1.3/4.3\n\n1985-1986    : Whitbread, Reading, UK.\n\n\nFootnote\n--------\nMy employer's mainframe is due to be decommissioned at the end of 2006.\nAfter this time, I will most likely be unable the submissions\nfor CBT tape file 600. It will be with sadness and regret that I\nbid farewell to the venerable mainframe which has been my bread and\nbutter for nearly 20 years!\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INDEX": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0f\\x00T\\x01\\x02'/\\x01\\x04\\x06/\\tX\\x005\\x00+\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.15", "flags": 0, "createdate": "2002-09-29T00:00:00", "modifydate": "2004-03-02T09:58:54", "lines": 53, "newlines": 43, "modlines": 0, "user": "AWCPAW"}, "text": "Index of members in AWCPAW.CBT.FILE600.C.PDS\n--------------------------------------------\n\n$CONTACT - Contact details for the author\n$INDEX   - This member\nCCOMP    - Generalised C compile and save object\nCOPYLINK - JCL to copy load modules to linklist library\nCPRLKLKD - Generalised C object link edit to a load library\nCPRLKLKH - Generalised C object link edit to an HFS\nCSQ      - Edit macro to switch between the different forms of\n           square brackets used in C code.\nDIV@BSD  - NetBSD div() function used in the SMF exits\n           so as to avoid using the C library div() function.\n           Sourced from:-\n           http://cvsweb.netbsd.org/bsdweb.cgi/basesrc/lib/libc/stdlib/div.c\nDS118R10 - C header for SMF type 118 FTP records on OS/390 2.10\n           and above.\nDS118R9  - C header for SMF type 118 FTP records on OS/390 2.9\n           and below.\nDS119R12 - C header for SMF type 119 FTP records on z/OS 1.2 and\n           above.\nEDCDS118 - JCL to run C DSECT utility and create the SMF type\n           118 C header.\nEDCDS119 - JCL to run C DSECT utility and create the SMF type\n           119 C header.\nFTPC118  - C program source for SMF type 118 (FTP)\n           batch print and SMF exit WTO program.\nFTPC118C - Compile JCL to save object modules for FTPC118.\nFTPC118L - Link-edit JCL to create load modules for FTPC118/FTPT118\n           from object.\nFTPC119  - C program source for SMF type 119 (FTP)\n           batch print and SMF exit WTO program.\nFTPC119C - Compile JCL to save object modules for FTPC119.\nFTPC119L - Link-edit JCL to create load modules for FTPC119/FTPT119\n           from object.\nFTPT118J - JCL to run print form of program FTPC118 (FTPT118).\nFTPT119J - JCL to run print form of program FTPC119 (FTPT119).\nNICKNC   - C program source for NICKNC - an English nicknames\n           generating program. Use it to name your pets, mythical\n           creatures in stories or even your kids!\nNICKNCJ  - JCL to run NICKNC.\nSMFX118J - JCL to extract SMF type 118 FTP records to a dataset.\nSMFX119J - JCL to extract SMF type 119 FTP records to a dataset.\nSPRNTLLC - Compile/link/run JCL for the sprntll function test program\n           (SPRNTLLT).\nSPRNTLLT - C program source which tests and demonstrates the function\n           of the sprntll assembler function.\nTITLE    - C title copy member.\nTITLEJ   - JCL title copy member.\nWTOT     - C program source which tests and demonstrates the function\n           of the mlwto assembler function.\nWTOTC    - Compile/link/run JCL for the mlwto function test program\n           (WTOT).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CCOMP": {"ttr": 515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00S\\x01\\x020\\x9f\\x01\\x04\\x06\\x1f\\x14\\x05\\x00\\x18\\x00\\x17\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-11-05T00:00:00", "modifydate": "2004-03-01T14:05:53", "lines": 24, "newlines": 23, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWC  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(CCOMP)\n//* JCL TO FOR GENERALISED C COMPILE AND SAVE OBJECT\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*   3) IF YOU HAVE THE LE DEBUGGER, INCLUDE THE TEST OPTION IN\n//*      THE COMPILE OPTIONS\n//*\n//*       JCLLIB ORDER=(SYS1.CBC.SCBCPRC)     OS/390 R10 COMPILER\n//        JCLLIB ORDER=(SYS1.CBC.SCCNPRC)     Z/OS 1.2 COMPILER\n//*\n//* COMP1 - COMPILE NICKNC (NICKNAMES)\n//COMP1    EXEC  EDCC,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          CPARM='SO,LIS,OF,EXP,TEST',\n//          SYSLBLK=,\n//          INFILE='AWCPAW.CBT.FILE600.C.PDS(NICKNC)',\n//          OUTFILE='AWCPAW.CBT.FILE600.OBJ.PDS(NICKNC),DISP=SHR'\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPYLINK": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x08\\x01\\x04\\x06/\\x01\\x04\\x17O\\x153\\x00\\x17\\x00\\x17\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2004-03-02T00:00:00", "modifydate": "2004-06-22T15:33:08", "lines": 23, "newlines": 23, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWCP JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(COPYLINK)\n//* JCL TO COPY FTP SMF EXIT RELATED PROGRAMS TO A LINKLIST LIBRARY\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE SYS1.ARA.LINKLIB TO YOUR LINKLIST LIBRARY\n//*\n//*\n//LINKCOPY EXEC PGM=IEBCOPY\n//I1        DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.LOAD\n//O1        DD  DISP=SHR,DSN=SYS1.ARA.LINKLIB\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  *\n COPYMOD I=((I1,R)),O=O1\n S M=FTPCTST\n S M=FTPC118\n S M=FTPC119\n S M=FTPSMFEX\n S M=FTPT118\n S M=FTPT119\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPRELKDS": {"ttr": 287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00)\\x01\\x020\\x9f\\x01\\x03\\x08\\x9f\\x14\\t\\x00\\x14\\x00/\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-11-05T00:00:00", "modifydate": "2003-03-30T14:09:29", "lines": 20, "newlines": 47, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWL  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(CPRELKDS)\n//* JCL FOR GENERALISED PRE-LINK/LINK OF C OBJECT TO A LOAD LIBRARY\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*\n//*\n//        JCLLIB ORDER=(SYS1.CEE.SCEEPROC)\n//*\n//* LINK1 - LINK NICKNC (NICKNAMES)\n//LINK1    EXEC  EDCPL,\n//          LIBPRFX='SYS1.CEE',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP',\n//          INFILE='AWCPAW.CBT.FILE600.OBJ.PDS(NICKNC)',\n//          OUTFILE='AWCPAW.CBT.FILE600.LOAD(NICKNC),DISP=SHR'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPRELKHF": {"ttr": 289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x005\\x01\\x020\\x9f\\x01\\x03\\x08\\x9f\\x14\\t\\x00\\x16\\x00/\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2002-11-05T00:00:00", "modifydate": "2003-03-30T14:09:35", "lines": 22, "newlines": 47, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWL  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(CPRELKHF)\n//* JCL FOR GENERALISED PRE-LINK/LINK OF C OBJECT TO HFS\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*\n//*\n//        JCLLIB ORDER=(SYS1.CEE.SCEEPROC)\n//*\n//* LINK1 - LINK NICKNC (NICKNAMES)\n//LINK1    EXEC  EDCPL,\n//          LIBPRFX='SYS1.CEE',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP',\n//          INFILE='AWCPAW.CBT.FILE600.OBJ.PDS(NICKNC)',\n//          OUTFILE=\n//LKED.SYSLMOD DD PATH='/u/awcpaw/nicknc',PATHOPTS=(OWRONLY,OCREAT),\n//          PATHMODE=(SIRWXU,SIRWXG,SIXOTH)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CSQ": {"ttr": 283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00B\\x01\\x020\\x9f\\x01\\x020\\x9f\\t@\\x00Q\\x00B\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-11-05T00:00:00", "modifydate": "2002-11-05T09:40:42", "lines": 81, "newlines": 66, "modlines": 0, "user": "AWCPAW"}, "text": "/*\n/* An edit macro to switch between the different forms of\n/* square brackets used in C code.\n/*\n/* Invocation - Type CSQ on command line in edit of C source code\n/*\n/* The 3 types of square brackets are as follows:-\n/*\n/* x'AD' and x'BD' - Accepted by default in C compiler\n/* ??( and ??)     - Accepted by default in C compiler\n/*                   (known as trigraphs)\n/* x'BA' and x'BB' - Some PC emulators map these characters to the\n/*                   square bracket keys but they are not recognised\n/*                   by the C compiler\n/*\n/* IBM sample CCNGMV2 improved by Paul Wells\n/*\n\nPROC 0\nISREDIT MACRO\n\nSET RP = &STR())\n /* Symbolic values for 6 C language symbols.\n /* 1. left  bracket, ebcdic hex value\n /* 2. right bracket, ebcdic hex value\n /* 3. left  bracket, trigraph\n /* 4. right bracket, trigraph\n /* 5. left  bracket, square\n /* 6. right bracket, square\nSET LBRACKET_HEX = X'AD'\nSET RBRACKET_HEX = X'BD'\nSET LBRACKET_TRI = &STR(??(\nSET RBRACKET_TRI = &STR(??&RP)\nSET LBRACKET_SQR = X'BA'       /* LBRACKET_SQR = HEX BA */\nSET RBRACKET_SQR = X'BB'       /* RBRACKET_SQR = HEX BB */\n\nISREDIT FIND &LBRACKET_SQR ALL NX\nISREDIT (N1) = FIND_COUNTS\nISREDIT FIND &RBRACKET_SQR ALL NX\nISREDIT (N2) = FIND_COUNTS\n/*IF (&N1 \u00ac= &N2) THEN WRITE ........UNBALANCED SQUARE BRACKETS*/\nIF (&N1 > 0) THEN DO\n   ISREDIT CHANGE &LBRACKET_SQR &LBRACKET_HEX ALL NX\n   ISREDIT CHANGE &RBRACKET_SQR &RBRACKET_HEX ALL NX\n   SET ZMSG000S = &STR(xAD/BD set)\n   SET ZMSG000L = &STR(xAD/BD set)\n   ISPEXEC VPUT (ZMSG000S,ZMSG000L)\n   ISPEXEC SETMSG MSG(ISPZ000)\n   EXIT\nEND\n\nISREDIT FIND &LBRACKET_HEX ALL NX\nISREDIT (N1) = FIND_COUNTS\nISREDIT FIND &RBRACKET_HEX ALL NX\nISREDIT (N2) = FIND_COUNTS\n/*IF (&N1 \u00ac= &N2) THEN WRITE ........UNBALANCED HEX BRACKETS*/\nIF (&N1 > 0) THEN DO\n   ISREDIT CHANGE &LBRACKET_HEX &LBRACKET_TRI ALL NX\n   ISREDIT CHANGE &RBRACKET_HEX &RBRACKET_TRI ALL NX\n   SET ZMSG000S = &STR(Trigraphs ?? set)\n   SET ZMSG000L = &STR(Trigraphs ?? set)\n   ISPEXEC VPUT (ZMSG000S,ZMSG000L)\n   ISPEXEC SETMSG MSG(ISPZ000)\n   EXIT\nEND\n\nISREDIT FIND &LBRACKET_TRI ALL NX\nISREDIT (N1) = FIND_COUNTS\nISREDIT FIND &RBRACKET_TRI ALL NX\nISREDIT (N2) = FIND_COUNTS\n/*IF (&N1 \u00ac= &N2) THEN WRITE ........UNBALANCED TRIGRAPH*/\nIF (&N1 > 0) THEN DO\n   ISREDIT CHANGE &LBRACKET_TRI &LBRACKET_SQR ALL NX\n   ISREDIT CHANGE &RBRACKET_TRI &RBRACKET_SQR ALL NX\n   SET ZMSG000S = &STR(xBA/BB set)\n   SET ZMSG000L = &STR(xBA/BB set)\n   ISPEXEC VPUT (ZMSG000S,ZMSG000L)\n   ISPEXEC SETMSG MSG(ISPZ000)\n   EXIT\nEND\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DIV@BSD": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00'\\x01\\x02'/\\x01\\x02'/\\x147\\x00O\\x00W\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-09-29T00:00:00", "modifydate": "2002-09-29T14:37:27", "lines": 79, "newlines": 87, "modlines": 0, "user": "AWCPAW"}, "text": "\n/* http://cvsweb.netbsd.org/bsdweb.cgi/basesrc/lib/libc/stdlib/div.c */\n\n/* $NetBSD: div.c,v 1.6 1998/01/30 23:37:52 perry Exp $ */\n\n/*\n * Copyright (c) 1990, 1993\n * The Regents of the University of California.  All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * Chris Torek.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n * This product includes software developed by the University of\n * California, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\ndiv_t\ndiv(num, denom)\n int num, denom;\n{\n div_t r;\n\n r.quot = num / denom;\n r.rem = num % denom;\n /*\n  * The ANSI standard says that |r.quot| <= |n/d|, where\n  * n/d is to be computed in infinite precision.  In other\n  * words, we should always truncate the quotient towards\n  * 0, never -infinity.\n  *\n  * Machine division and remainer may work either way when\n  * one or both of n or d is negative.  If only one is\n  * negative and r.quot has been truncated towards -inf,\n  * r.rem will have the same sign as denom and the opposite\n  * sign of num; if both are negative and r.quot has been\n  * truncated towards -inf, r.rem will be positive (will\n  * have the opposite sign of num).  These are considered\n  * `wrong'.\n  *\n  * If both are num and denom are positive, r will always\n  * be positive.\n  *\n  * This all boils down to:\n  * if num >= 0, but r.rem < 0, we got the wrong answer.\n  * In that case, to get the right answer, add 1 to r.quot and\n  * subtract denom from r.rem.\n  */\n if (num >= 0 && r.rem < 0) {\n  r.quot++;\n  r.rem -= denom;\n }\n return (r);\n}\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DS118R10": {"ttr": 13, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x03\\x01\\x02%O\\x01\\x02%O\\x08C\\x00\\xc4\\x00\\xc4\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-11T00:00:00", "modifydate": "2002-09-11T08:43:03", "lines": 196, "newlines": 196, "modlines": 0, "user": "AWCPAW"}, "text": "#pragma pack(packed)\n\nstruct smfftp76 {\n unsigned char  smfftphd\u00dd24\u00a8; /* Standard SMF header with subtypes    */\n unsigned char  smfftpcm\u00dd4\u00a8;  /* FTP Subcommand                       */\n unsigned char  smfftpty\u00dd4\u00a8;  /* FTP Server=file type (SEQ, JES, SQL) */\n int            smfftpsa;     /* FTP Server remote IP address   OR    */\n int            smfftpsl;     /* FTP Server local   IP address  OR    */\n unsigned char  smfftpcp\u00dd2\u00a8;  /* FTP Client local   port              */\n unsigned char  smfftpcf\u00dd2\u00a8;  /* FTP Client foreign port              */\n unsigned char  smfftpr2\u00dd4\u00a8;  /* FTP Client reserved                  */\n unsigned char  smfftpsu\u00dd8\u00a8;  /* FTP Server local  user ID      OR    */\n unsigned char  smfftpfm;     /* FTP data format                      */\n unsigned char  smfftpmo;     /* FTP mode                             */\n unsigned char  smfftpst;     /* FTP structure                        */\n unsigned char  smfftpdt;     /* FTP data set type                    */\n int            smffttrs;     /* FTP start time of transmission       */\n int            smffttre;     /* FTP end   time of transmission       */\n int            smffttbc;     /* FTP byte count of transmission       */\n unsigned char  smfftpxd;     /* FTP ID                               */\n unsigned char  smfftslr\u00dd3\u00a8;  /* FTP Server - last reply to client    */\n unsigned char  smfftdsn\u00dd44\u00a8; /* FTP Data Set Name                    */\n unsigned char  smfftmem\u00dd8\u00a8;  /* FTP member name for PDS              */\n unsigned char  smfftrs2\u00dd8\u00a8;  /* FTP reserved for abnormal end info.  */\n unsigned char  smfftds2\u00dd44\u00a8; /* FTP Second Data Set Name (if needed) */\n unsigned char  smfftmm2\u00dd8\u00a8;  /* FTP Second member name for PDS       */\n unsigned char  smfftstc\u00dd8\u00a8;  /* FTP Server started task qualifier OR */\n unsigned char  smffthst\u00dd8\u00a8;  /* FTP TCP/IP Host Name                 */\n unsigned char  smfftsrp\u00dd2\u00a8;  /* FTP Server Remote port number        */\n unsigned char  smfftslp\u00dd2\u00a8;  /* FTP Server Local  port number        */\n short int      smfftof1;     /* Offset to the first HFS file field   */\n short int      smfftof2;     /* Offset to the second HFS file field  */\n unsigned char  smfftbyf\u00dd8\u00a8;  /* Bytes transferred counter in double  */\n void          *smfftgig;     /* 4-Gigabyte counter for bytexfer      */\n unsigned char  smfftvar;     /* Var-length fields                    */\n };\n\n/* Values for field \"smfftpfm\" */\n#define smfftpfa 'A'  /* A = ASCII          */\n#define smfftpfe 'E'  /* E = EBCDIC         */\n#define smfftpfi 'I'  /* I = Image          */\n\n/* Values for field \"smfftpmo\" */\n#define smfftpmb 'B'  /* B = block          */\n#define smfftpmc 'C'  /* C = compressed     */\n#define smfftpms 'S'  /* S = stream         */\n\n/* Values for field \"smfftpst\" */\n#define smfftpsf 'F'  /* F = file           */\n\n/* Values for field \"smfftpdt\" */\n#define smfftpdb ' '  /* blank = sequential */\n#define smfftpdp 'P'  /* P     = PDS        */\n\n/* Values for field \"smfftpxd\" */\n#define smfftpxc 'C'  /* C = client         */\n#define smfftpxs 'S'  /* S = server         */\n\nstruct smfheadr {\n short int      smfhdlen;    /* Length of record                */\n short int      smfhdseg;    /* Segment Descriptor              */\n unsigned char  smfhdflg;    /* System Indicator                */\n char           smfhdtyp;    /* Record type number              */\n int            smfhdtme;    /* TOD, Using format from TIME     */\n unsigned char  smfhddte\u00dd4\u00a8; /* DATE Record written (CCYYDDDS)  */\n unsigned char  smfhdsid\u00dd4\u00a8; /* SYSTEM Id from Installation     */\n unsigned char  smfhdssi\u00dd4\u00a8; /* Subsystem identification        */\n short int      smfhdsub;    /* SMF sub type field              */\n unsigned char  smfhdovy;    /* Start of subtype record overlay */\n };\n\n/* Values for field \"smfhdflg\" */\n#define smfhdsty 0x40 /* Subtypes are valid.        */\n#define smfhdsp4 0x10 /* MVS/SP Version 4 and above */\n#define smfhdsp3 0x08 /* MVS/SP Version 3 and above */\n#define smfhdsp2 0x04 /* MVS/SP Version 2 and above */\n#define smfhdvs2 0x02 /* MVS/VS2                    */\n\n/* Values for field \"smfhdtyp\" */\n#define smfhdtcp 118  /* Record type number -       */\n\nstruct smftriple {\n int            smf3off; /* Offset of section  */\n short int      smf3len; /* Length of section  */\n short int      smf3num; /* Number of sections */\n };\n\n/* Values for field \"smf3num\" */\n#define lsmftriple 0x08 /* Length of SMF Triple */\n\nstruct smfsubsys {\n unsigned char  smfsubproc\u00dd8\u00a8; /* MVSMIBStruct.TcpIpProcName */\n int            smfsubasid;    /* MVSMIBStruct.TcpIpAsid     */\n unsigned char  smfsubtime\u00dd8\u00a8; /* MVSMIBStruct.IplTod        */\n unsigned char  smfsubflag;    /* Reason for writing record  */\n unsigned char  _filler1\u00dd3\u00a8;   /* Reserved                   */\n };\n\n/* Values for field \"smfsubflag\" */\n#define smfrsnstrt 0x80 /* Write first SMF record            */\n#define smfrsnintv 0x40 /* Write interval SMF record         */\n#define smfrsnend  0x20 /* Write last SMF record             */\n#define smfrsnshut 0x10 /* Write SMF record at shutdown      */\n\n/* Values for field \"_filler1\" */\n#define lsmfsubsys 0x18 /* Length of SMF subsystem structure */\n\nstruct smfsubip {\n int            imirecv;  /* Total Received Datagrams       */\n int            imihdrer; /* Total Discarded Datagrams      */\n int            imiadrer; /* Total Discarded Addr Errs      */\n int            imifwddg; /* Total Attempt to Fwd Datagrams */\n int            imiunprt; /* Total Discarded Unknown Prot   */\n int            imidisc;  /* Total Discarded Other          */\n int            imidelvr; /* Total Delivered Datagrams      */\n int            imoreqst; /* Total Sent Datagrams           */\n int            imodisc;  /* Total Sent Discarded Other     */\n int            imonorte; /* Total Send Discarded No Route  */\n int            imrsmtos; /* Total Reassembly Timeouts      */\n int            imrsmreq; /* Total Received Reassem. Req'ed */\n int            imrsmok;  /* Total Datagrams Reassembled    */\n int            imrsmfld; /* Total Reassembly Failed        */\n int            imfragok; /* Total Datagrams Fragmented     */\n int            imfrgfld; /* Total Discarded Frag. Failed   */\n int            imfrgcre; /* Total Fragments Generated      */\n int            imrtdisc; /* Total Routing Discards         */\n int            imrsmmax; /* Max active RSMCBs              */\n int            imrsmact; /* Num active RSMCBs              */\n int            imrsmful; /* Reassembly flags               */\n };\n\n/* Values for field \"imrsmful\" */\n#define lsmfsubip 0x54 /* Length of SMF IP structure */\n\nstruct smfsubtc {\n int            tcp_rtoalgorithm; /* Retransmit algorithm */\n int            tcp_rtomin;       /* Min Retran time (ms) */\n int            tcp_rtomax;       /* Max Retran time (ms) */\n int            tcp_maxconn;      /* Max connections      */\n int            tcp_activeopens;  /* Active opens         */\n int            tcp_passiveopens; /* Passive opens        */\n int            tcp_attemptfails; /* Open failures        */\n int            tcp_estabresets;  /* Number of resets     */\n int            tcp_currestab;    /* Currently Estabs     */\n int            tcp_insegs;       /* Input segments       */\n int            tcp_outsegs;      /* Output segments      */\n int            tcp_retranssegs;  /* Retransmitted segs   */\n int            tcp_inerrs;       /* Input errors         */\n int            tcp_outrsts;      /* Number of resets     */\n };\n\n/* Values for field \"tcp_outrsts\" */\n#define lsmfsubtc 0x38 /* Length of SMF TCP structure */\n\nstruct smfsubud {\n int            usindgrm; /* received datagrams          */\n int            usnoprts; /* dgrms rcvd with no port def */\n int            usinerrs; /* other dgrms not rcvd        */\n int            usotdgrm; /* sent datagrams              */\n };\n\n/* Values for field \"usotdgrm\" */\n#define lsmfsubud 0x10 /* Length of SMF UDP structure */\n\nstruct tcpstatentry {\n short int      smf1184len;    /* Record length                   */\n short int      smf1184seg;    /* SMF Seg set to zero/nospan      */\n unsigned char  smf1184flg;    /* Smf flag bit 1 set on           */\n unsigned char  smf1184rty;    /* Smf record type 118             */\n unsigned char  smf1184tim\u00dd4\u00a8; /* time  set by MVS                */\n unsigned char  smf1184dat\u00dd4\u00a8; /* date  set by MVS                */\n unsigned char  smf1184sid\u00dd4\u00a8; /* system id  set by MVS           */\n unsigned char  smf1184ssi\u00dd4\u00a8; /* subsystem id  set by MVS        */\n short int      smf1184sty;    /* subtype                         */\n short int      _filler1;      /* reserved                        */\n short int      smf1184sdl;    /* length of self defining section */\n unsigned char  smf1184ss\u00dd8\u00a8;  /* subsystem section               */\n unsigned char  smf1184ip\u00dd8\u00a8;  /* IP        section               */\n unsigned char  smf1184ic\u00dd8\u00a8;  /* ICMP      section               */\n unsigned char  smf1184tc\u00dd8\u00a8;  /* TCP       section               */\n unsigned char  smf1184ud\u00dd8\u00a8;  /* UDP       section               */\n };\n\n/* Values for field \"smf1184flg\" */\n#define smf1184flg_subtype 0x40 /* SMF1184Flg                      */\n\n/* Values for field \"smf1184rty\" */\n#define smf1184rty_type    0x76 /* SMF1184Rty                      */\n\n/* Values for field \"smf1184sty\" */\n#define smf1184sty_type    5    /* SMF1184Sty                      */\n\n/* Values for field \"smf1184ud\" */\n#define lsmf1184sds        0x28 /* length of self defining section */\n\n#pragma pack(reset)\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DS118R9": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x17\\x01\\x02'/\\x01\\x02'/\\x10T\\x00\\xbf\\x00\\xbe\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-09-29T00:00:00", "modifydate": "2002-09-29T10:54:17", "lines": 191, "newlines": 190, "modlines": 0, "user": "AWCPAW"}, "text": "#pragma pack(packed)\n\nstruct smfftp76 {\n unsigned char  smfftphd\u00dd24\u00a8; /* Standard SMF header with subtypes    */\n unsigned char  smfftpcm\u00dd4\u00a8;  /* FTP Subcommand                       */\n unsigned char  smfftpty\u00dd4\u00a8;  /* FTP Server=file type (SEQ, JES, SQL) */\n int            smfftpsa;     /* FTP Server remote IP address   OR    */\n int            smfftpsl;     /* FTP Server local   IP address  OR    */\n unsigned char  smfftpcp\u00dd2\u00a8;  /* FTP Client local   port              */\n unsigned char  smfftpcf\u00dd2\u00a8;  /* FTP Client foreign port              */\n unsigned char  smfftpr2\u00dd4\u00a8;  /* FTP Client reserved                  */\n unsigned char  smfftpsu\u00dd8\u00a8;  /* FTP Server local  user ID      OR    */\n unsigned char  smfftpfm;     /* FTP data format                      */\n unsigned char  smfftpmo;     /* FTP mode                             */\n unsigned char  smfftpst;     /* FTP structure                        */\n unsigned char  smfftpdt;     /* FTP data set type                    */\n int            smffttrs;     /* FTP start time of transmission       */\n int            smffttre;     /* FTP end   time of transmission       */\n int            smffttbc;     /* FTP byte count of transmission       */\n unsigned char  smfftpxd;     /* FTP ID                               */\n unsigned char  smfftslr\u00dd3\u00a8;  /* FTP Server - last reply to client    */\n unsigned char  smfftdsn\u00dd44\u00a8; /* FTP Data Set Name                    */\n unsigned char  smfftmem\u00dd8\u00a8;  /* FTP member name for PDS              */\n unsigned char  smfftrs2\u00dd8\u00a8;  /* FTP reserved for abnormal end info.  */\n unsigned char  smfftds2\u00dd44\u00a8; /* FTP Second Data Set Name (if needed) */\n unsigned char  smfftmm2\u00dd8\u00a8;  /* FTP Second member name for PDS       */\n unsigned char  smfftstc\u00dd8\u00a8;  /* FTP Server started task qualifier OR */\n unsigned char  smffthst\u00dd8\u00a8;  /* FTP TCP/IP Host Name                 */\n unsigned char  smfftsrp\u00dd2\u00a8;  /* FTP Server Remote port number        */\n unsigned char  smfftslp\u00dd2\u00a8;  /* FTP Server Local  port number        */\n };\n\n/* Values for field \"smfftpfm\" */\n#define smfftpfa 'A'  /* A = ASCII          */\n#define smfftpfe 'E'  /* E = EBCDIC         */\n#define smfftpfi 'I'  /* I = Image          */\n\n/* Values for field \"smfftpmo\" */\n#define smfftpmb 'B'  /* B = block          */\n#define smfftpmc 'C'  /* C = compressed     */\n#define smfftpms 'S'  /* S = stream         */\n\n/* Values for field \"smfftpst\" */\n#define smfftpsf 'F'  /* F = file           */\n\n/* Values for field \"smfftpdt\" */\n#define smfftpdb ' '  /* blank = sequential */\n#define smfftpdp 'P'  /* P     = PDS        */\n\n/* Values for field \"smfftpxd\" */\n#define smfftpxc 'C'  /* C = client         */\n#define smfftpxs 'S'  /* S = server         */\n\nstruct smfheadr {\n short int      smfhdlen;    /* Length of record               */\n short int      smfhdseg;    /* Segment Descriptor             */\n unsigned char  smfhdflg;    /* System Indicator               */\n char           smfhdtyp;    /* Record type number             */\n int            smfhdtme;    /* TOD, Using format from TIME    */\n unsigned char  smfhddte\u00dd4\u00a8; /* DATE Record written (CCYYDDDS) */\n unsigned char  smfhdsid\u00dd4\u00a8; /* SYSTEM Id from Installation    */\n unsigned char  smfhdssi\u00dd4\u00a8; /* Subsystem identification       */\n short int      smfhdsub;    /* SMF sub type field             */\n unsigned char  smfhdovy;    /* Start of subtype record overlay */\n };\n\n/* Values for field \"smfhdflg\" */\n#define smfhdsty 0x40 /* Subtypes are valid.        */\n#define smfhdsp4 0x10 /* MVS/SP Version 4 and above */\n#define smfhdsp3 0x08 /* MVS/SP Version 3 and above */\n#define smfhdsp2 0x04 /* MVS/SP Version 2 and above */\n#define smfhdvs2 0x02 /* MVS/VS2                    */\n\n/* Values for field \"smfhdtyp\" */\n#define smfhdtcp 118  /* Record type number -       */\n\nstruct smftriple {\n int            smf3off; /* Offset of section  */\n short int      smf3len; /* Length of section  */\n short int      smf3num; /* Number of sections */\n };\n\n/* Values for field \"smf3num\" */\n#define lsmftriple 0x08 /* Length of SMF Triple */\n\nstruct smfsubsys {\n unsigned char  smfsubproc\u00dd8\u00a8; /* MVSMIBStruct.TcpIpProcName */\n int            smfsubasid;    /* MVSMIBStruct.TcpIpAsid     */\n unsigned char  smfsubtime\u00dd8\u00a8; /* MVSMIBStruct.IplTod        */\n unsigned char  smfsubflag;    /* Reason for writing record  */\n unsigned char  _filler1\u00dd3\u00a8;   /* Reserved                   */\n };\n\n/* Values for field \"smfsubflag\" */\n#define smfrsnstrt 0x80 /* Write first SMF record            */\n#define smfrsnintv 0x40 /* Write interval SMF record         */\n#define smfrsnend  0x20 /* Write last SMF record             */\n#define smfrsnshut 0x10 /* Write SMF record at shutdown      */\n\n/* Values for field \"_filler1\" */\n#define lsmfsubsys 0x18 /* Length of SMF subsystem structure */\n\nstruct smfsubip {\n int            imirecv;  /* Total Received Datagrams       */\n int            imihdrer; /* Total Discarded Datagrams      */\n int            imiadrer; /* Total Discarded Addr Errs      */\n int            imifwddg; /* Total Attempt to Fwd Datagrams */\n int            imiunprt; /* Total Discarded Unknown Prot   */\n int            imidisc;  /* Total Discarded Other          */\n int            imidelvr; /* Total Delivered Datagrams      */\n int            imoreqst; /* Total Sent Datagrams           */\n int            imodisc;  /* Total Sent Discarded Other     */\n int            imonorte; /* Total Send Discarded No Route  */\n int            imrsmtos; /* Total Reassembly Timeouts      */\n int            imrsmreq; /* Total Received Reassem. Req'ed */\n int            imrsmok;  /* Total Datagrams Reassembled    */\n int            imrsmfld; /* Total Reassembly Failed        */\n int            imfragok; /* Total Datagrams Fragmented     */\n int            imfrgfld; /* Total Discarded Frag. Failed   */\n int            imfrgcre; /* Total Fragments Generated      */\n int            imrtdisc; /* Total Routing Discards         */\n int            imrsmmax; /* Max active RSMCBs              */\n int            imrsmact; /* Num active RSMCBs              */\n int            imrsmful; /* Reassembly flags               */\n };\n\n/* Values for field \"imrsmful\" */\n#define lsmfsubip 0x54 /* Length of SMF IP structure */\n\nstruct smfsubtc {\n int            tcp_rtoalgorithm; /* Retransmit algorithm */\n int            tcp_rtomin;       /* Min Retran time (ms) */\n int            tcp_rtomax;       /* Max Retran time (ms) */\n int            tcp_maxconn;      /* Max connections      */\n int            tcp_activeopens;  /* Active opens         */\n int            tcp_passiveopens; /* Passive opens        */\n int            tcp_attemptfails; /* Open failures        */\n int            tcp_estabresets;  /* Number of resets     */\n int            tcp_currestab;    /* Currently Estabs     */\n int            tcp_insegs;       /* Input segments       */\n int            tcp_outsegs;      /* Output segments      */\n int            tcp_retranssegs;  /* Retransmitted segs   */\n int            tcp_inerrs;       /* Input errors         */\n int            tcp_outrsts;      /* Number of resets     */\n };\n\n/* Values for field \"tcp_outrsts\" */\n#define lsmfsubtc 0x38 /* Length of SMF TCP structure */\n\nstruct smfsubud {\n int            usindgrm; /* received datagrams          */\n int            usnoprts; /* dgrms rcvd with no port def */\n int            usinerrs; /* other dgrms not rcvd        */\n int            usotdgrm; /* sent datagrams              */\n };\n\n/* Values for field \"usotdgrm\" */\n#define lsmfsubud 0x10 /* Length of SMF UDP structure */\n\nstruct tcpstatentry {\n short int      smf1184len;    /* Record length                   */\n short int      smf1184seg;    /* SMF Seg set to zero/nospan      */\n unsigned char  smf1184flg;    /* Smf flag bit 1 set on           */\n unsigned char  smf1184rty;    /* Smf record type 118             */\n unsigned char  smf1184tim\u00dd4\u00a8; /* time  set by MVS                */\n unsigned char  smf1184dat\u00dd4\u00a8; /* date  set by MVS                */\n unsigned char  smf1184sid\u00dd4\u00a8; /* system id  set by MVS           */\n unsigned char  smf1184ssi\u00dd4\u00a8; /* subsystem id  set by MVS        */\n short int      smf1184sty;    /* subtype                         */\n short int      _filler1;      /* reserved                        */\n short int      smf1184sdl;    /* length of self defining section */\n unsigned char  smf1184ss\u00dd8\u00a8;  /* subsystem section               */\n unsigned char  smf1184ip\u00dd8\u00a8;  /* IP        section               */\n unsigned char  smf1184ic\u00dd8\u00a8;  /* ICMP      section               */\n unsigned char  smf1184tc\u00dd8\u00a8;  /* TCP       section               */\n unsigned char  smf1184ud\u00dd8\u00a8;  /* UDP       section               */\n };\n\n/* Values for field \"smf1184flg\" */\n#define smf1184flg_subtype 0x40 /* SMF1184Flg                      */\n\n/* Values for field \"smf1184rty\" */\n#define smf1184rty_type    0x76 /* SMF1184Rty                      */\n\n/* Values for field \"smf1184sty\" */\n#define smf1184sty_type    5    /* SMF1184Sty                      */\n\n/* Values for field \"smf1184ud\" */\n#define lsmf1184sds        0x28 /* length of self defining section */\n\n#pragma pack(reset)\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "DS119R12": {"ttr": 15, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01\\x02$?\\x01\\x02$?\\x15D\\x01\\xd5\\x01\\xe1\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-08-31T00:00:00", "modifydate": "2002-08-31T15:44:57", "lines": 469, "newlines": 481, "modlines": 0, "user": "AWCPAW"}, "text": "#pragma pack(packed)\n\nstruct smf119header {\n unsigned char  smf119hdlength\u00dd2\u00a8;  /* Record length                       */\n unsigned char  smf119hdsegdesc\u00dd2\u00a8; /* Segment descriptor                  */\n unsigned char  smf119hdflags;      /* Header flags                        */\n unsigned char  smf119hdtype;       /* Record type (119, x'77')            */\n unsigned char  smf119hdtime\u00dd4\u00a8;    /* Time record was moved to SMF buffer */\n unsigned char  smf119hddate\u00dd4\u00a8;    /* Date record was moved to SMF buffer */\n unsigned char  smf119hdsid\u00dd4\u00a8;     /* System ID                           */\n unsigned char  smf119hdssi\u00dd4\u00a8;     /* Subsystem ID                        */\n unsigned char  smf119hdsubtype\u00dd2\u00a8; /* Record subtype                      */\n };\n\n/* Values for field \"smf119hdflags\" */\n#define smf119hdsub          0x40 /* Subtypes are valid         */\n#define smf119hdsp4          0x10 /* MVS/SP Version 4 and above */\n#define smf119hdsp3          0x08 /* MVS/SP Version 3 and above */\n#define smf119hdsp2          0x04 /* MVS/SP Version 2 and above */\n#define smf119hdvs2          0x02 /* MVS/VS2                    */\n\n/* Values for field \"smf119hdsubtype\" */\n#define smf119hdst_tcpinit   0x01\n#define smf119hdst_tcpterm   0x02\n#define smf119hdst_ftpclient 0x03\n#define smf119hdst_tcpstats  0x05\n#define smf119hdst_ifstats   0x06\n#define smf119hdst_portstats 0x07\n#define smf119hdst_stackss   0x08\n#define smf119hdst_udpclose  0x0A\n#define smf119hdst_tnsvrinit 0x14\n#define smf119hdst_tnsvrterm 0x15\n#define smf119hdst_tsocinit  0x16\n#define smf119hdst_tsocterm  0x17\n#define smf119hdst_ftpserver 0x46\n#define smf119hdst_ftplogonf 0x48\n#define smf119hdln           0x18\n\nstruct smf119sdefsect {\n unsigned char  smf119sd_trn\u00dd2\u00a8; /* Number of triplets                     */\n unsigned char  smf119sdrsvd\u00dd2\u00a8; /* reserved                               */\n unsigned char  smf119idoff\u00dd4\u00a8;  /* Offset to TCP/IP Ident section    @L3C */\n unsigned char  smf119idlen\u00dd2\u00a8;  /* Length of TCP/IP Ident section    @L3C */\n unsigned char  smf119idnum\u00dd2\u00a8;  /* Number of TCP/IP Ident section    @L3C */\n unsigned char  smf119s1off\u00dd4\u00a8;  /* Offset to first record section    @L3C */\n unsigned char  smf119s1len\u00dd2\u00a8;  /* Length of first record section    @L3C */\n unsigned char  smf119s1num\u00dd2\u00a8;  /* Number of section instances       @L3C */\n };\n\n/* Values for field \"smf119s1num\" */\n#define smf119sdln 0x14\n\nstruct smf119sd3triples {\n unsigned char  smf119s2off\u00dd4\u00a8; /* Offset to 2nd record section      @L3C */\n unsigned char  smf119s2len\u00dd2\u00a8; /* Length of 2nd record section      @L3C */\n unsigned char  smf119s2num\u00dd2\u00a8; /* Number of section instances       @L3C */\n };\n\n/* Values for field \"smf119s2num\" */\n#define smf119s3ln 0x08\n\nstruct smf119sd4triples {\n unsigned char  smf119s3off\u00dd4\u00a8; /* Offset to 3rd record section      @L3C */\n unsigned char  smf119s3len\u00dd2\u00a8; /* Length of 3rd record section      @L3C */\n unsigned char  smf119s3num\u00dd2\u00a8; /* Number of section instances       @L3C */\n };\n\n/* Values for field \"smf119s3num\" */\n#define smf119s4ln 0x08\n\nstruct smf119sd5triples {\n unsigned char  smf119s4off\u00dd4\u00a8; /* Offset to 4th record section      @L3C */\n unsigned char  smf119s4len\u00dd2\u00a8; /* Length of 4th record section      @L3C */\n unsigned char  smf119s4num\u00dd2\u00a8; /* Number of section instances       @L3C */\n };\n\n/* Values for field \"smf119s4num\" */\n#define smf119s5ln 0x08\n\nstruct smf119ident {\n unsigned char  smf119ti_sysname\u00dd8\u00a8;     /* System name                  */\n unsigned char  smf119ti_sysplexname\u00dd8\u00a8; /* Sysplex name                 */\n unsigned char  smf119ti_stack\u00dd8\u00a8;       /* Stack name                   */\n unsigned char  smf119ti_releaseid\u00dd8\u00a8;   /* CS/390 release identifier    */\n unsigned char  smf119ti_comp\u00dd8\u00a8;        /* TCP/IP subcomponent          */\n unsigned char  smf119ti_asname\u00dd8\u00a8;      /* Address space name of writer */\n unsigned char  smf119ti_userid\u00dd8\u00a8;      /* User ID of security context  */\n union {\n  unsigned char  _smf119ti_asid\u00dd4\u00a8; /* ASID of writer */\n  struct {\n   unsigned char  _smf119ti_fill2\u00dd2\u00a8; /* High order bytes not used    */\n   unsigned char  _smf119ti_asid2\u00dd2\u00a8; /* Low order bytes contain ASID */\n   } _smf119ident_struct1;\n  } _smf119ident_union1;\n unsigned char  smf119ti_reason;         /* Reason for writing record    */\n unsigned char  smf119ti_rsvd\u00dd3\u00a8;        /* Reserved                     */\n };\n\n#define smf119ti_asid  _smf119ident_union1._smf119ti_asid\n#define smf119ti_fill2 _smf119ident_union1._smf119ident_struct1._smf119ti_fill2\n#define smf119ti_asid2 _smf119ident_union1._smf119ident_struct1._smf119ti_asid2\n\n/* Values for field \"smf119ti_reason\" */\n#define smf119ti_reasonintinc  0xC0 /* - Interval record, incomplete        */\n#define smf119ti_reasonint     0x80 /* - Interval record                    */\n#define smf119ti_reasoniendinc 0x60 /* - Interval ending stats, incomplete  */\n#define smf119ti_reasoniend    0x20 /* - Interval ending stats              */\n#define smf119ti_reasonishtinc 0x50 /* - Interval shutdown stats,incomplete */\n#define smf119ti_reasonisht    0x10 /* - Interval shutdown stats            */\n#define smf119ti_reasonevt     0x08 /* - Event record                       */\n\n/* Values for field \"smf119ti_rsvd\" */\n#define smf119tiln             0x40\n\nstruct smf119ti_identdefs {\n unsigned char  smf119ti_comptcp\u00dd8\u00a8;     /* @L3C */\n unsigned char  smf119ti_compudp\u00dd8\u00a8;     /* @L3C */\n unsigned char  smf119ti_compip\u00dd8\u00a8;      /* @L3C */\n unsigned char  smf119ti_compstack\u00dd8\u00a8;   /* @L3C */\n unsigned char  smf119ti_comptn3270s\u00dd8\u00a8; /* @L3C */\n unsigned char  smf119ti_comptn3270c\u00dd8\u00a8; /* @L3C */\n unsigned char  smf119ti_compftps\u00dd8\u00a8;    /* @L3C */\n unsigned char  smf119ti_compftpc\u00dd8\u00a8;    /* @L3C */\n };\n\nstruct smf119ft_fs {\n unsigned char  smf119ft_fsoper;          /* FTP Operation                         */\n unsigned char  smf119ft_fsrsvd\u00dd3\u00a8;       /* Reserved                              */\n unsigned char  smf119ft_fscmd\u00dd4\u00a8;        /* FTP command (cf. RFC959)              */\n unsigned char  smf119ft_fsftype\u00dd4\u00a8;      /* File type (SEQ, JES, or SQL)          */\n union {\n  unsigned char  _smf119ft_fsdrip\u00dd16\u00a8; /* Data conn remote IP address (IPv6) */\n  struct {\n   unsigned char  _smf119ft_fsdriprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler1\u00dd4\u00a8;\n   } _smf119ft_fs_struct1;\n  struct {\n   unsigned char  _smf119ft_fsdriprsvd10\u00dd10\u00a8; /* @L8A                                 */\n   unsigned char  _smf119ft_fsdripfmt\u00dd2\u00a8;     /* IPv4 address flagging           @L8A */\n   unsigned char  _smf119ft_fsdrip_ipv4\u00dd4\u00a8;   /* Remote IP address, IPv4 format       */\n   } _smf119ft_fs_struct2;\n  } _smf119ft_fs_union1;\n union {\n  unsigned char  _smf119ft_fsdlip\u00dd16\u00a8; /* Data conn local IP address (IPv6) */\n  struct {\n   unsigned char  _smf119ft_fsdliprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler2\u00dd4\u00a8;\n   } _smf119ft_fs_struct3;\n  struct {\n   unsigned char  _smf119ft_fsdliprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_fsdlipfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_fsdlip_ipv4\u00dd4\u00a8;   /* Local IP address, IPv4 format       */\n   } _smf119ft_fs_struct4;\n  } _smf119ft_fs_union2;\n unsigned char  smf119ft_fsdrport\u00dd2\u00a8;     /* Data conn remote port                 */\n unsigned char  smf119ft_fsdlport\u00dd2\u00a8;     /* Data conn local port                  */\n union {\n  unsigned char  _smf119ft_fscrip\u00dd16\u00a8; /* Control conn remote IP (IPv6) */\n  struct {\n   unsigned char  _smf119ft_fscriprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler3\u00dd4\u00a8;\n   } _smf119ft_fs_struct5;\n  struct {\n   unsigned char  _smf119ft_fscriprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_fscripfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_fscrip_ipv4\u00dd4\u00a8;   /* Remote IP address, IPv4 format      */\n   } _smf119ft_fs_struct6;\n  } _smf119ft_fs_union3;\n union {\n  unsigned char  _smf119ft_fsclip\u00dd16\u00a8; /* Control conn local IP (IPv6) */\n  struct {\n   unsigned char  _smf119ft_fscliprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler4\u00dd4\u00a8;\n   } _smf119ft_fs_struct7;\n  struct {\n   unsigned char  _smf119ft_fscliprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_fsclipfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_fsclip_ipv4\u00dd4\u00a8;   /* Local IP address, IPv4 format       */\n   } _smf119ft_fs_struct8;\n  } _smf119ft_fs_union4;\n unsigned char  smf119ft_fscrport\u00dd2\u00a8;     /* Control conn remote port              */\n unsigned char  smf119ft_fsclport\u00dd2\u00a8;     /* Control conn local port               */\n unsigned char  smf119ft_fssuser\u00dd8\u00a8;      /* Client User ID on server              */\n unsigned char  smf119ft_fstype;          /* Data type                             */\n unsigned char  smf119ft_fsmode;          /* Transmission mode                     */\n unsigned char  smf119ft_fsstruct;        /* Data structure                        */\n unsigned char  smf119ft_fsdsttype;       /* DATA SET TYPE                         */\n unsigned char  smf119ft_fsstime\u00dd4\u00a8;      /* Start time of transmission (UTC)      */\n unsigned char  smf119ft_fssdate\u00dd4\u00a8;      /* Start date of transmission            */\n unsigned char  smf119ft_fsetime\u00dd4\u00a8;      /* End time of transmission (UTC)        */\n unsigned char  smf119ft_fsedate\u00dd4\u00a8;      /* End date of transmission              */\n unsigned char  smf119ft_fsdur\u00dd4\u00a8;        /* Duration of transmission (1/100 s)    */\n unsigned char  smf119ft_fsbytes\u00dd8\u00a8;      /* Bytes transmitted (64-bit)            */\n unsigned char  smf119ft_fslreply\u00dd4\u00a8;     /* Last replycode to client (cf. RFC959) */\n unsigned char  smf119ft_fsm1\u00dd8\u00a8;         /* PDS member name                       */\n unsigned char  smf119ft_fsrs\u00dd8\u00a8;         /* Abnormal end information              */\n unsigned char  smf119ft_fsm2\u00dd8\u00a8;         /* Second PDS member (if REName)         */\n unsigned char  smf119ft_fsbytesfloat\u00dd8\u00a8; /* Bytes transmitted (64-bit float)      */\n };\n\n#define smf119ft_fsdrip       _smf119ft_fs_union1._smf119ft_fsdrip\n#define smf119ft_fsdriprsvd   _smf119ft_fs_union1._smf119ft_fs_struct1._smf119ft_fsdriprsvd\n#define smf119ft_fsdriprsvd10 _smf119ft_fs_union1._smf119ft_fs_struct2._smf119ft_fsdriprsvd10\n#define smf119ft_fsdripfmt    _smf119ft_fs_union1._smf119ft_fs_struct2._smf119ft_fsdripfmt\n#define smf119ft_fsdrip_ipv4  _smf119ft_fs_union1._smf119ft_fs_struct2._smf119ft_fsdrip_ipv4\n#define smf119ft_fsdlip       _smf119ft_fs_union2._smf119ft_fsdlip\n#define smf119ft_fsdliprsvd   _smf119ft_fs_union2._smf119ft_fs_struct3._smf119ft_fsdliprsvd\n#define smf119ft_fsdliprsvd10 _smf119ft_fs_union2._smf119ft_fs_struct4._smf119ft_fsdliprsvd10\n#define smf119ft_fsdlipfmt    _smf119ft_fs_union2._smf119ft_fs_struct4._smf119ft_fsdlipfmt\n#define smf119ft_fsdlip_ipv4  _smf119ft_fs_union2._smf119ft_fs_struct4._smf119ft_fsdlip_ipv4\n#define smf119ft_fscrip       _smf119ft_fs_union3._smf119ft_fscrip\n#define smf119ft_fscriprsvd   _smf119ft_fs_union3._smf119ft_fs_struct5._smf119ft_fscriprsvd\n#define smf119ft_fscriprsvd10 _smf119ft_fs_union3._smf119ft_fs_struct6._smf119ft_fscriprsvd10\n#define smf119ft_fscripfmt    _smf119ft_fs_union3._smf119ft_fs_struct6._smf119ft_fscripfmt\n#define smf119ft_fscrip_ipv4  _smf119ft_fs_union3._smf119ft_fs_struct6._smf119ft_fscrip_ipv4\n#define smf119ft_fsclip       _smf119ft_fs_union4._smf119ft_fsclip\n#define smf119ft_fscliprsvd   _smf119ft_fs_union4._smf119ft_fs_struct7._smf119ft_fscliprsvd\n#define smf119ft_fscliprsvd10 _smf119ft_fs_union4._smf119ft_fs_struct8._smf119ft_fscliprsvd10\n#define smf119ft_fsclipfmt    _smf119ft_fs_union4._smf119ft_fs_struct8._smf119ft_fsclipfmt\n#define smf119ft_fsclip_ipv4  _smf119ft_fs_union4._smf119ft_fs_struct8._smf119ft_fsclip_ipv4\n\n/* Values for field \"smf119ft_fsoper\" */\n#define smf119ft_fsoperappe    0x01 /* - APPEND       */\n#define smf119ft_fsoperdele    0x02 /* - DELETE       */\n#define smf119ft_fsoperrenm    0x03 /* - RENAME       */\n#define smf119ft_fsoperretr    0x04 /* - RETRIEVE     */\n#define smf119ft_fsoperstor    0x05 /* - STORE        */\n#define smf119ft_fsoperstou    0x06 /* - STORE UNIQUE */\n\n/* Values for field \"smf119ft_fstype\" */\n#define smf119ft_fstypeascii   'A'  /* - ASCII        */\n#define smf119ft_fstypeebcdic  'E'  /* - EBCDIC       */\n#define smf119ft_fstypeimage   'I'  /* - Image        */\n#define smf119ft_fstypedbyte   'B'  /* - Double-Byte  */\n#define smf119ft_fstypeucs2    'U'  /* - UCS-2        */\n\n/* Values for field \"smf119ft_fsmode\" */\n#define smf119ft_fsmodeblock   'B'  /* - Block        */\n#define smf119ft_fsmodecmpress 'C'  /* - Compressed   */\n#define smf119ft_fsmodestream  'S'  /* - Stream       */\n\n/* Values for field \"smf119ft_fsstruct\" */\n#define smf119ft_fsstructfile  'F'  /* - File         */\n#define smf119ft_fsstructrec   'R'  /* - Record       */\n\n/* Values for field \"smf119ft_fsdsttype\" */\n#define smf119ft_fsdstypeseq   'S'  /* - Sequential   */\n#define smf119ft_fsdstypepds   'P'  /* - PDS          */\n#define smf119ft_fsdstypehfs   'H'  /* - HFS          */\n\n/* Values for field \"smf119ft_fsbytesfloat\" */\n#define smf119ftfsln           0xA0\n\nstruct smf119ft_fsdefs {\n unsigned char  smf119ft_fsftypejes\u00dd4\u00a8; /* - JES */\n unsigned char  smf119ft_fsftypeseq\u00dd4\u00a8; /* - SEQ */\n unsigned char  smf119ft_fsftypesql\u00dd4\u00a8; /* - SQL */\n };\n\nstruct smf119ft_ff {\n union {\n  unsigned char  _smf119ft_ffrip\u00dd16\u00a8; /* Remote IP address (IPv6) */\n  struct {\n   unsigned char  _smf119ft_ffriprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler1\u00dd4\u00a8;\n   } _smf119ft_ff_struct1;\n  struct {\n   unsigned char  _smf119ft_ffriprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_ffripfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_ffrip_ipv4\u00dd4\u00a8;   /* Remote IP address, IPv4 format      */\n   } _smf119ft_ff_struct2;\n  } _smf119ft_ff_union1;\n union {\n  unsigned char  _smf119ft_fflip\u00dd16\u00a8; /* Local IP address (IPv6) */\n  struct {\n   unsigned char  _smf119ft_ffliprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler2\u00dd4\u00a8;\n   } _smf119ft_ff_struct3;\n  struct {\n   unsigned char  _smf119ft_ffliprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_fflipfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_fflip_ipv4\u00dd4\u00a8;   /* Local IP address, IPv4 format       */\n   } _smf119ft_ff_struct4;\n  } _smf119ft_ff_union2;\n unsigned char  smf119ft_ffrport\u00dd2\u00a8;  /* Remote port                      */\n unsigned char  smf119ft_fflport\u00dd2\u00a8;  /* Local port                       */\n unsigned char  smf119ft_ffuserid\u00dd8\u00a8; /* Client userid received by server */\n unsigned char  smf119ft_ffreason;    /* Logon failure reason             */\n unsigned char  smf119ft_ffrsvd2\u00dd3\u00a8;  /* Reserved                         */\n };\n\n#define smf119ft_ffrip       _smf119ft_ff_union1._smf119ft_ffrip\n#define smf119ft_ffriprsvd   _smf119ft_ff_union1._smf119ft_ff_struct1._smf119ft_ffriprsvd\n#define smf119ft_ffriprsvd10 _smf119ft_ff_union1._smf119ft_ff_struct2._smf119ft_ffriprsvd10\n#define smf119ft_ffripfmt    _smf119ft_ff_union1._smf119ft_ff_struct2._smf119ft_ffripfmt\n#define smf119ft_ffrip_ipv4  _smf119ft_ff_union1._smf119ft_ff_struct2._smf119ft_ffrip_ipv4\n#define smf119ft_fflip       _smf119ft_ff_union2._smf119ft_fflip\n#define smf119ft_ffliprsvd   _smf119ft_ff_union2._smf119ft_ff_struct3._smf119ft_ffliprsvd\n#define smf119ft_ffliprsvd10 _smf119ft_ff_union2._smf119ft_ff_struct4._smf119ft_ffliprsvd10\n#define smf119ft_fflipfmt    _smf119ft_ff_union2._smf119ft_ff_struct4._smf119ft_fflipfmt\n#define smf119ft_fflip_ipv4  _smf119ft_ff_union2._smf119ft_ff_struct4._smf119ft_fflip_ipv4\n\n/* Values for field \"smf119ft_ffreason\" */\n#define smf119ft_ffreasoninvalid  0x01 /* - Password is not valid            */\n#define smf119ft_ffreasonexpired  0x02 /* - Password has expired             */\n#define smf119ft_ffreasonrevoked  0x03 /* - User ID has been revoked         */\n#define smf119ft_ffreasonnoaccess 0x04 /* - User does not have server access */\n#define smf119ft_ffreasonexit     0x05 /* - FTCHKPWD User exit reject login  */\n#define smf119ft_ffreasonexcess   0x06 /* - Excessive bad passwords          */\n#define smf119ft_ffreasongroupid  0x07 /* - Group ID process failed          */\n#define smf119ft_ffreasonunknown  0x08 /* - User ID is unknown               */\n\n/* Values for field \"smf119ft_ffrsvd2\" */\n#define smf119ftffln              0x30\n\nstruct smf119ft_fc {\n unsigned char  smf119ft_fccmd\u00dd4\u00a8;        /* FTP command (cf. RFC 959)          */\n unsigned char  smf119ft_fcftype\u00dd4\u00a8;      /* Local file type (SEQ, JES, or SQL) */\n union {\n  unsigned char  _smf119ft_fcdrip\u00dd16\u00a8; /* Data conn remote IP address (IPv6) */\n  struct {\n   unsigned char  _smf119ft_fcdriprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler1\u00dd4\u00a8;\n   } _smf119ft_fc_struct1;\n  struct {\n   unsigned char  _smf119ft_fcdriprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_fcdripfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_fcdrip_ipv4\u00dd4\u00a8;   /* Remote IP address, IPv4 format      */\n   } _smf119ft_fc_struct2;\n  } _smf119ft_fc_union1;\n union {\n  unsigned char  _smf119ft_fcdlip\u00dd16\u00a8; /* Data conn local IP address (IPv6) */\n  struct {\n   unsigned char  _smf119ft_fcdliprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler2\u00dd4\u00a8;\n   } _smf119ft_fc_struct3;\n  struct {\n   unsigned char  _smf119ft_fcdliprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_fcdlipfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_fcdlip_ipv4\u00dd4\u00a8;   /* Local IP address, IPv4 format       */\n   } _smf119ft_fc_struct4;\n  } _smf119ft_fc_union2;\n unsigned char  smf119ft_fcdrport\u00dd2\u00a8;     /* Data conn remote port              */\n unsigned char  smf119ft_fcdlport\u00dd2\u00a8;     /* Data conn local port               */\n union {\n  unsigned char  _smf119ft_fccrip\u00dd16\u00a8; /* Control conn remote IP address (IPv6) */\n  struct {\n   unsigned char  _smf119ft_fccriprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler3\u00dd4\u00a8;\n   } _smf119ft_fc_struct5;\n  struct {\n   unsigned char  _smf119ft_fccriprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_fccripfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_fccrip_ipv4\u00dd4\u00a8;   /* Remote IP address, IPv4 format      */\n   } _smf119ft_fc_struct6;\n  } _smf119ft_fc_union3;\n union {\n  unsigned char  _smf119ft_fcclip\u00dd16\u00a8; /* Control conn local IP address (IPv6) */\n  struct {\n   unsigned char  _smf119ft_fccliprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler4\u00dd4\u00a8;\n   } _smf119ft_fc_struct7;\n  struct {\n   unsigned char  _smf119ft_fccliprsvd10\u00dd10\u00a8; /* @L8A                                */\n   unsigned char  _smf119ft_fcclipfmt\u00dd2\u00a8;     /* IPv4 address flagging          @L8A */\n   unsigned char  _smf119ft_fcclip_ipv4\u00dd4\u00a8;   /* Local IP address, IPv4 format       */\n   } _smf119ft_fc_struct8;\n  } _smf119ft_fc_union4;\n unsigned char  smf119ft_fccrport\u00dd2\u00a8;     /* Control conn remote port           */\n unsigned char  smf119ft_fcclport\u00dd2\u00a8;     /* Control conn local port            */\n unsigned char  smf119ft_fcruser\u00dd8\u00a8;      /* User ID (login name) on server     */\n unsigned char  smf119ft_fcluser\u00dd8\u00a8;      /* Local User ID                      */\n unsigned char  smf119ft_fctype;          /* Data format                        */\n unsigned char  smf119ft_fcmode;          /* Transmission mode                  */\n unsigned char  smf119ft_fcstruct;        /* Data structure                     */\n unsigned char  smf119ft_fcdstype;        /* Dataset type                       */\n unsigned char  smf119ft_fcstime\u00dd4\u00a8;      /* Start time of transmission (UTC)   */\n unsigned char  smf119ft_fcsdate\u00dd4\u00a8;      /* Start date of transmission         */\n unsigned char  smf119ft_fcetime\u00dd4\u00a8;      /* End time of transmission (UTC)     */\n unsigned char  smf119ft_fcedate\u00dd4\u00a8;      /* End date of transmission           */\n unsigned char  smf119ft_fcdur\u00dd4\u00a8;        /* Duration of transmission (1/100 s) */\n unsigned char  smf119ft_fcbytes\u00dd8\u00a8;      /* Bytes transmitted (64-bit)         */\n unsigned char  smf119ft_fclreply\u00dd4\u00a8;     /* Last server reply (cf. RFC 959)    */\n unsigned char  smf119ft_fcm1\u00dd8\u00a8;         /* PDS member name                    */\n unsigned char  smf119ft_fchostname\u00dd8\u00a8;   /* Host name                          */\n unsigned char  smf119ft_fcrs\u00dd8\u00a8;         /* Abnormal end info                  */\n unsigned char  smf119ft_fcbytesfloat\u00dd8\u00a8; /* Bytes transmitted (64-bit float)   */\n };\n\n#define smf119ft_fcdrip       _smf119ft_fc_union1._smf119ft_fcdrip\n#define smf119ft_fcdriprsvd   _smf119ft_fc_union1._smf119ft_fc_struct1._smf119ft_fcdriprsvd\n#define smf119ft_fcdriprsvd10 _smf119ft_fc_union1._smf119ft_fc_struct2._smf119ft_fcdriprsvd10\n#define smf119ft_fcdripfmt    _smf119ft_fc_union1._smf119ft_fc_struct2._smf119ft_fcdripfmt\n#define smf119ft_fcdrip_ipv4  _smf119ft_fc_union1._smf119ft_fc_struct2._smf119ft_fcdrip_ipv4\n#define smf119ft_fcdlip       _smf119ft_fc_union2._smf119ft_fcdlip\n#define smf119ft_fcdliprsvd   _smf119ft_fc_union2._smf119ft_fc_struct3._smf119ft_fcdliprsvd\n#define smf119ft_fcdliprsvd10 _smf119ft_fc_union2._smf119ft_fc_struct4._smf119ft_fcdliprsvd10\n#define smf119ft_fcdlipfmt    _smf119ft_fc_union2._smf119ft_fc_struct4._smf119ft_fcdlipfmt\n#define smf119ft_fcdlip_ipv4  _smf119ft_fc_union2._smf119ft_fc_struct4._smf119ft_fcdlip_ipv4\n#define smf119ft_fccrip       _smf119ft_fc_union3._smf119ft_fccrip\n#define smf119ft_fccriprsvd   _smf119ft_fc_union3._smf119ft_fc_struct5._smf119ft_fccriprsvd\n#define smf119ft_fccriprsvd10 _smf119ft_fc_union3._smf119ft_fc_struct6._smf119ft_fccriprsvd10\n#define smf119ft_fccripfmt    _smf119ft_fc_union3._smf119ft_fc_struct6._smf119ft_fccripfmt\n#define smf119ft_fccrip_ipv4  _smf119ft_fc_union3._smf119ft_fc_struct6._smf119ft_fccrip_ipv4\n#define smf119ft_fcclip       _smf119ft_fc_union4._smf119ft_fcclip\n#define smf119ft_fccliprsvd   _smf119ft_fc_union4._smf119ft_fc_struct7._smf119ft_fccliprsvd\n#define smf119ft_fccliprsvd10 _smf119ft_fc_union4._smf119ft_fc_struct8._smf119ft_fccliprsvd10\n#define smf119ft_fcclipfmt    _smf119ft_fc_union4._smf119ft_fc_struct8._smf119ft_fcclipfmt\n#define smf119ft_fcclip_ipv4  _smf119ft_fc_union4._smf119ft_fc_struct8._smf119ft_fcclip_ipv4\n\n/* Values for field \"smf119ft_fctype\" */\n#define smf119ft_fctypeascii   'A'  /* - ASCII       */\n#define smf119ft_fctypeebcdic  'E'  /* - EBCDIC      */\n#define smf119ft_fctypeimage   'I'  /* - Image       */\n#define smf119ft_fctypedbyte   'B'  /* - Double-Byte */\n#define smf119ft_fctypeucs2    'U'  /* - UCS-2       */\n\n/* Values for field \"smf119ft_fcmode\" */\n#define smf119ft_fcmodeblock   'B'  /* - Block       */\n#define smf119ft_fcmodecmpress 'C'  /* - Compressed  */\n#define smf119ft_fcmodestream  'S'  /* - Stream      */\n\n/* Values for field \"smf119ft_fcstruct\" */\n#define smf119ft_fcstructfile  'F'  /* - File        */\n#define smf119ft_fcstructrec   'R'  /* - Record      */\n\n/* Values for field \"smf119ft_fcdstype\" */\n#define smf119ft_fcdstypeseq   'S'  /* - Sequential  */\n#define smf119ft_fcdstypepds   'P'  /* - PDS         */\n#define smf119ft_fcdstypehfs   'H'  /* - HFS         */\n\n/* Values for field \"smf119ft_fcbytesfloat\" */\n#define smf119ftfcln           0xA4\n\nstruct smf119ft_fcso {\n union {\n  unsigned char  _smf119ft_fccip\u00dd16\u00a8; /* SOCKS Server IPv6 address, control */\n  struct {\n   unsigned char  _smf119ft_fcciprsvd\u00dd12\u00a8; /* unused if IPv4 address supplied */\n   unsigned char  _filler1\u00dd4\u00a8;\n   } _smf119ft_fcso_struct1;\n  struct {\n   unsigned char  _smf119ft_fcciprsvd10\u00dd10\u00a8; /* @L8A                                 */\n   unsigned char  _smf119ft_fccipfmt\u00dd2\u00a8;     /* IPv4 address flagging           @L8A */\n   unsigned char  _smf119ft_fccip_ipv4\u00dd4\u00a8;   /* Server IP address, IPv4 format       */\n   } _smf119ft_fcso_struct2;\n  } _smf119ft_fcso_union1;\n unsigned char  smf119ft_fccport\u00dd2\u00a8; /* SOCKS Server Port, control      */\n unsigned char  smf119ft_fccprot;    /* SOCKS protocol version, control */\n };\n\n#define smf119ft_fccip       _smf119ft_fcso_union1._smf119ft_fccip\n#define smf119ft_fcciprsvd   _smf119ft_fcso_union1._smf119ft_fcso_struct1._smf119ft_fcciprsvd\n#define smf119ft_fcciprsvd10 _smf119ft_fcso_union1._smf119ft_fcso_struct2._smf119ft_fcciprsvd10\n#define smf119ft_fccipfmt    _smf119ft_fcso_union1._smf119ft_fcso_struct2._smf119ft_fccipfmt\n#define smf119ft_fccip_ipv4  _smf119ft_fcso_union1._smf119ft_fcso_struct2._smf119ft_fccip_ipv4\n\n/* Values for field \"smf119ft_fccprot\" */\n#define smf119ft_fccprotv4 0x01 /* - Version 4 */\n#define smf119ft_fccprotv5 0x02 /* - Version 5 */\n#define smf119ftfcsoln     0x13\n\nstruct smf119ft_fcdefs {\n unsigned char  smf119ft_fcftypejes\u00dd4\u00a8; /* - JES */\n unsigned char  smf119ft_fcftypeseq\u00dd4\u00a8; /* - SEQ */\n unsigned char  smf119ft_fcftypesql\u00dd4\u00a8; /* - SQL */\n };\n\n#pragma pack(reset)\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "EDCDS118": {"ttr": 265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x11\\x00I\\x01\\x02'/\\x01\\x020\\x7f\\x109\\x00\\x1d\\x00_\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.17", "flags": 0, "createdate": "2002-09-29T00:00:00", "modifydate": "2002-11-03T10:39:49", "lines": 29, "newlines": 95, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWDS JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(EDCDS118)\n//* GENERATE SMF TYPE 118 C HEADER FROM ASSEMBLER DSECT\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*\n//        JCLLIB ORDER=(SYS1.CBC.SCBCPRC)\n//*\n//* DSECT\n//* - ASSEMBLE ASSEMBLER DSECT\n//* - CONVERT SYSADATA FILE TO C HEADER FORMAT\n//*\n//DSECT    EXEC     EDCDSECT,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          DPARM='BITF0XL,EQUATE(DEF),INDENT(1),NOSEQ'\n//ASSEMBLE.SYSLIB DD  DISP=SHR,\n//*         VOL=SER=SYXRES,UNIT=3390,\n//          DSN=SYS1.TCPIP.SEZACMAC\n//ASSEMBLE.SYSIN  DD  *\n         EZASMF76 FTP=YES,STAT=YES\n         END\n//DSECT.SYSADATA  DD  DISP=(OLD,DELETE)\n//DSECT.EDCDSECT  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.C.PDS(DS118)\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDCDS119": {"ttr": 267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00T\\x01\\x02'/\\x01\\x020\\x7f\\x109\\x00\\x1c\\x00_\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-09-29T00:00:00", "modifydate": "2002-11-03T10:39:54", "lines": 28, "newlines": 95, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWDS JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(EDCDS119)\n//* GENERATE SMF TYPE 119 C HEADER FROM ASSEMBLER DSECT\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*\n//        JCLLIB ORDER=(SYS1.CBC.SCBCPRC)\n//*\n//* DSECT\n//* - ASSEMBLE ASSEMBLER DSECT\n//* - CONVERT SYSADATA FILE TO C HEADER FORMAT. AN RC4 IS NORMAL\n//*   DUE TO EDC5515 MESSAGES.\n//*\n//DSECT    EXEC     EDCDSECT,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          DPARM='BITF0XL,EQUATE(DEF),INDENT(1),NOSEQ'\n//ASSEMBLE.SYSLIB DD  DISP=SHR,DSN=SYS1.TCPIP.SEZACMAC\n//ASSEMBLE.SYSIN  DD  *\n         EZASMF77 FTP=YES,TELNET=NO,HEADER=YES,API=NO,STAT=NO\n         END\n//DSECT.SYSADATA  DD  DISP=(OLD,DELETE)\n//DSECT.EDCDSECT  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.C.PDS(DS119)\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FTPC118": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00H\\x01\\x00%_\\x01\\x04\\x17O\\x138\\x03\\xd9\\x02*\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2000-09-11T00:00:00", "modifydate": "2004-06-22T13:38:48", "lines": 985, "newlines": 554, "modlines": 0, "user": "AWCPAW"}, "text": "#pragma title(\"FTPC118 - SMF type 118 (FTP) print/WTO\")\n#pragma comment(copyright,\"FTPC118 - \u00a9Paul Wells (Saudi Aramco) 2002\")\n\n/**********************************************************************\n*\n*  Name: FTPC118 (C language source)\n*\n*\n*  Abstract:\n*\n*     A C language program which processes SMF type 118 FTP records.\n*\n*     The program has 2 modes of operation, selected by compile\n*     and link edit options: EXITMODE and TESTMODE.\n*\n*     In EXITMODE, FTPC118 uses Systems Programming C facilities to run\n*     as an SMF IEFU83/84 exit to format and WTO the SMF FTP records.\n*     FTPC118 can also be installed as a FTP server SMF exit (FTPSMFEX),\n*     but this mode does not allow it to process FTP client SMF\n*     records.\n*\n*     In TESTMODE, FTPC118 (load module FTPT118) runs as a standard\n*     C main program in batch to print the SMF FTP records to\n*     standard output.\n*\n*\n*  Operation:\n*\n*     EXITMODE\n*     --------\n*     On entry R1 points to the address of the SMF record being\n*     written by the system. The chkrec() function is called to\n*     verify that it is a valid type 118 FTP record. Type 118\n*     subtypes 3 and 70-75 are processed. All other records\n*     are ignored and control returns to the system with RC=0\n*     to allow the SMF record to be written.\n*\n*     For a valid FTP record an output area is allocated and\n*     dartn() is called to format the SMF data to be suitable\n*     for WTO. The data fields processed in the FTP Client (C),\n*     FTP Server (S) and FTP Server logon failure (L) records\n*     is as follows.\n*\n*      WTO    C/S/L Description          SMF 118 Name Example\n*      ---    ----- -----------          ------------ -------\n*      cm=    C/S/L Subcommand (RFC959)  SMFFTPCM     cm=STOR\n*      ty=    S     File type            SMFFTPTY     ty=SEQ\n*      lr=    C/S/L Last reply to client C: SMFFTPTY  lr=250\n*                                        S: SMFFTSLR\n*                                        L: SMFFTSLR\n*      cp=    C     Local port           SMFFTPCP     cp=1064\n*      cf=    C     Foreign port         SMFFTPCF     cf=21\n*      rp=    S/L   Remote port          SMFFTSRP     rp=4608\n*      lp=    S/L   Local port           SMFFTSLP     lp=21\n*      sa=    C/S/L C: Local IP address  SMFFTPSA     sa=10.13.80.11\n*                   S: Remote IP address\n*                   L: Remote IP address\n*      sl=    C/S/L C: Remote IP address SMFFTPSL     sl=10.1.160.220\n*                   S: Local IP address\n*                   L: Local IP address\n*      su=    C/S/L C: Remote userid     SMFFTPSU     su=AWCPAW\n*                   S: Local userid\n*                   L: Local userid\n*             C/S   Data format          SMFFTPFM     ASCII\n*             C/S   Mode                 SMFFTPMO     Stream\n*             C/S   Structure            SMFFTPST     File\n*             C/S   Dataset type         SMFFTPDT     Seq\n*      trs=   C/S/L Start time           SMFFTTRS     trs=08:09:08.87\n*      dur=   C/S   Duration             (derived)    dur=00:00:00.02\n*      tbc=   C/S   Byte count           SMFFTTBC     tbc=5924\n*                                        SMFFTBYF\n*      rt=    C/S   Rate                 (derived)    rt=296.20kb/sec\n*      hst=   C/S/L Host name            SMFFTHST     hst=tso03\n*      stc=   C     Local userid         SMFFTSTC     stc=AWCPAW\n*      dsn=   C/S   1st Dataset name     SMFFTDSN     dsn=AWCPAW.TEMP\n*                                        SMFFTMEM\n*                                        SMFFTVAR\n*      ds2=   S     2nd Dataset name     SMFFTDS2     ds2=AWCPAW.TEMP2\n*                                        SMFFTMM2\n*                                        SMFFTVAR\n*\n*     Once formatted, the data is passed to an external assembler\n*     subroutine to issue the WTO to the operating system. The\n*     format of the output in the syslog will be similar\n*     to the following.\n*\n*  FTPC118-02I FTP Client cm=STOR lr=226 cp=1096 cf=21 sa=10.1.160.220\n*  sl=10.13.80.11 su=troon ASCII Stream File Seq trs=07:52:04.65\n*  dur=00:00:00.02 tbc=5924 rt=296.20kb/sec hst=tso03 stc=AWCPAW\n*  dsn=AWCPAW.TEMP.TXT\n*\n*     Once the WTO is issued the program frees storage for the\n*     output area and returns to the operating system with RC=0\n*     to allow the SMF record to be written.\n*\n*     TESTMODE\n*     --------\n*     In TESTMODE a 32K buffer is allocated for processing the\n*     SMF records. The SMFDD DD is opened as an input file\n*     and an SMF record is read from it. The chkrec() function is\n*     called to verify that it is a valid type 118 FTP record. Type\n*     118 subtypes 3 and 70-75 are processed. All other records\n*     are ignored and control returns to the system. Rejected\n*     records are reported to STDERR output.\n*\n*     For a valid FTP record an output area is allocated and\n*     dartn() is called to format the SMF data to be suitable\n*     for output. The data fields are identical to those described\n*     above for EXITMODE.\n*\n*     Once formatted, the data is output to STDOUT via the printf\n*     function. The formatting is almost identical to that described\n*     above for EXITMODE. The difference being that the data is\n*     prefixed by the system and date/time from the SMF record.\n*\n*     Control then returns back, another SMF record is read\n*     and processed and so on until end of file. At EOF the SMFDD\n*     is closed, storage is freed and control returns to the operating\n*     system.\n*\n*\n*  Environment:\n*\n*     IBM compatible mainframe\n*\n*     IBM OS/390, z/OS or subsequent operating system with C compiler\n*\n*     A minimum level of OS/390 R5 (HTCP340 TCPIP fmid) is required\n*     for the SMF formats supported by this program.\n*\n*     The program has been tested on OS/390 R9 and z/OS 1.2 systems. On\n*     z/OS 1.2 a new TCPIP SMF record 119 was introduced. Type 119\n*     records are much better strucutured than 118 records and provide\n*     IPv6 support and will be the basis for further enhancements by\n*     IBM. Type 118 records can be produced in parallel with the 119\n*     records for the time being at least.\n*\n*\n*  Compilation:\n*\n*     EXITMODE & TESTMODE\n*     -------------------\n*     If the C compiler is available, sample JCL\n*     AWCPAW.CBT.FILE600.C.PDS(FTPC118C) can be used to compile the\n*     program. 2 object modules are output: FTPC118 for EXITMODE\n*     and FTPT118 for TESTMODE.\n*\n*     The FTPC118 compile is for SPC (Systems Programming C)\n*     and must specify the NOSTART option. It must not specify\n*     RENT, since RENT is not supported in SPC. The code is naturally\n*     re-entrant in any case.\n*\n*     The FTPT118 compile is a standard C main program compile\n*     and can specify TEST for use with the LE debugger.\n*\n*\n*  Installation:\n*\n*     EXITMODE & TESTMODE\n*     -------------------\n*     To ensure that SMF 118 FTP records are being created the\n*     following tasks must be completed.\n*\n*      1) For client FTP records ensure that SYS1.TCPPARMS(PROFILE)\n*         or equivalent includes this statement.\n*\n*         SMFCONFIG FTPCLIENT\n*\n*      2) For all types of server records ensure that\n*         SYS1.TCPPARMS(FTPSDATA) or equivalent contains the\n*         statements as follows. (SMFJES and SMFSQL are optional)\n*\n*         SMF           STD       ; SMF records use standard subtypes\n*         SMFJES                  ; SMF recording when filetype=jes\n*         SMFSQL                  ; SMF recording when filetype=sql\n*\n*     EXITMODE\n*     --------\n*     To install the SMF exits for EXITMODE, complete the following.\n*\n*      1) Ensure type 118 records are being written (above).\n*\n*      2) Link edit FTPC118 into a linklist library and refresh\n*         LLA if necessary. Sample JCL is in\n*         AWCPAW.CBT.FILE600.C.PDS(FTPC118L). The FTPC118 load module\n*         is used in EXITMODE.\n*\n*         The FPTC118 link edit must specify CEE.SCEESPC\n*         first in its SYSLIB concatenation for SPC support. Object\n*         module EDCXSPRT must be explicitly included for the\n*         SPC version of the sprintf function. Assembler object modules\n*         MLWTO and EDCXFGS should also be included for the mlwto()\n*         and malloc()/free() functions respectively.\n*\n*      3) Optionally install the SMF exit test program FTPCTST\n*         which is contained in AWCPAW.CBT.FILE600.ASM.PDS. This\n*         program can be used to test the WTO functions of the\n*         program before it is installed as an SMF exit.\n*\n*      4) Ensure that exits IEFU83 and IEFU84 are being called\n*         for all address spaces by coding these exits in\n*         all SYS or SUBSYS statements in SYS1.PARMLIB(SMFPRMxx) e.g.\n*\n*         SYS(NOTYPE(..,..,..,..),\n*             EXITS(IEFU83,IEFU84,.....,......,),..........,........)\n*         SUBSYS(STC,NOTYPE(..,..,..,..),\n*             EXITS(IEFU83,IEFU84,.....,......,),..........,........)\n*\n*         Including the exits in SUBSYS(STC) is required and ommiting\n*         it is a likely reason for the exits not being invoked.\n*\n*         Note that IEFU83 is required for FTP server records\n*         whereas IEFU84 is required for client records.\n*         It is recommended to install both.\n*\n*      5) Update SYS1.PARMLIB(PROGxx) to load the exits\n*         via the dynamic exit facility, e.g.\n*\n*         EXIT ADD EXITNAME(SYS.IEFU83) MODNAME(FTPC118)\n*         EXIT ADD EXITNAME(SYS.IEFU84) MODNAME(FTPC118)\n*\n*      6) Dynamically install via the SETPROG operator\n*         command e.g.\n*\n*         SETPROG EXIT,ADD,EXITNAME=SYS.IEFU83,MODNAME=FTPC118\n*         SETPROG EXIT,ADD,EXITNAME=SYS.IEFU84,MODNAME=FTPC118\n*\n*         Or alternatively IPL to activate the exits via PROGxx.\n*\n*     TESTMODE\n*     --------\n*     FTPC118 should be link edited into any load library. Sample\n*     JCL is in AWCPAW.CBT.FILE600.C.PDS(FTPC118L). The FTPT118 load\n*     module is used in TESTMODE.\n*\n*\n*  Invocation:\n*\n*     EXITMODE\n*     --------\n*     When installed (as recommended) as both an IEFU83 and IEFU84\n*     system SMF exit, the program will be entered for every SMF record\n*     written, except those written in cross memory mode that\n*     would be processed by IEFU85. (There is no point installing\n*     the program as an IEFU85 exit as there are no FTP records\n*     written in this mode.)\n*\n*     In IEFU83/84 the linkage conventions are as follows.\n*     (From z/OS MVS Installation Exits SA22-7593-01)\n*\n*      The contents of the registers on entry to IEFU83/84 are:\n*\n*      Register  Contents\n*      0/2-12    Not applicable\n*      1         Address of the parameter list\n*      13        Register save area\n*      14        Return address\n*      15        Entry point address of IEFU84\n*\n*      Register 1 points to the following address:\n*\n*      Word 1    The address of the record that SMF is to write. The\n*                first four bytes of this record are the\n*                record descriptor word.\n*\n*      Upon return from IEFU83/84 processing, the register contents\n*      must be:\n*\n*      Register  Contents\n*      0-14      Same as at entry\n*      15        One of the following return codes:\n*\n*      Value of 4 SMF is not to write the record to the SMF data set.\n*      Other than 4 SMF is to write the record to the SMF data set.\n*\n*     When installed as an FTPSMFEX, which is an alternate\n*     entry point, the parameters are slightly different.\n*\n*      (From z/OS Communications Server IP Configuration Reference\n*      SC31-8776-02)\n*      On entry to FTPSMFEX, register 1 contains a pointer to the\n*      following 2-word parameter list:\n*\n*      Offset  Value\n*      0       Pointer to the return code\n*      4       Pointer to the type 118 SMF record\n*\n*      Prior to calling the SMF user exit, the return code is set to 0.\n*      A return code of 0 specifies that the SMF record will be written.\n*      To suppress writing the SMF record to the SYS1.MANx data set,\n*      the user exit must change the return code to a nonzero value.\n*\n*\n*     The EXITMODE function can be tested by program FTPCTST without\n*     installing FTPC118 as an SMF exit. FTPCTST is contained in\n*     AWCPAW.CBT.FILE600.ASM.PDS and can be invoked by the JCL\n*     in AWCPAW.CBT.FILE600.ASM.PDS(FTPCTSTJ). This JCL requires\n*     an SMF input file of type 118 SMF records.\n*\n*\n*     TESTMODE\n*     --------\n*     In TESTMODE FTPC118 (load module FTPT118) is invoked via\n*     batch JCL. Sample JCL can be found in\n*     AWCPAW.CBT.FILE600.C.PDS(FTPT118J).\n*\n*     An extract of SMF type 118 can then be run. Sample JCL is in\n*     AWCPAW.CBT.FILE600.C.PDS(SMFX118J).\n*\n*     The program can then run against the SMF file. Sample JCL is in\n*     AWCPAW.CBT.FILE600.C.PDS(FTPT118J).\n*\n*\n*  Notes:\n*\n*     Writeable static variables cannot be used in SPC mode because it\n*     violates reentrancy. This type of variable is statically linked\n*     into the program and if modified in SPC mode, an abend0c4 will\n*     result.\n*\n*     In SPC mode, the program runs with #pragma (FTPC118,nolib)\n*     which means that the program cannot use any C library functions.\n*     This is essential because invocation of library functions may\n*     involve external module loads or other SVCs which cannot be\n*     tolerated in an SMF exit.\n*\n*     The record length of this source is greater than 80. The source\n*     is best stored in a VB255 PDS.\n*\n*\n*  Author: Paul Wells\n*          Saudi Aramco Box 12959\n*          Dhahran 31311\n*          Saudi Arabia\n*\n*  Email:  paul.wells@aramco.com\n*\n*  History:\n*\n*     PW 22/Jun/2004 - IBM changed SMFFTPTY from binary to EBCDIC with\n*                      APAR PQ83055. The code was changed to allow\n*                      for both data formats.\n*     PW 02/Mar/2004 - Minor fix to dsnrtn and hfsrtn to suppress a\n*                      harmless extra space at the end of the dataset\n*                      name.\n*     PW 30/Mar/2003 - Comments updated\n*     PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************/\n\n/* Include standard C header files */\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <limits.h>\n\n#ifndef TESTMODE                       /* Not compiled for TESTMODE? */\n\n #define EXITMODE                      /* Default compile is EXITMODE (for SMF exit) */\n #pragma runopts(\"TRAP(OFF),HEAP(8K,32K,ANY),STACK(8K,32K,ANY)\")\n                                       /* TRAP(OFF) sets ESTAE/ESPIE off for SMF exit\n                                          8K for Heap is sufficient in exit mode\n                                          8K for Stack is sufficient in exit mode */\n #pragma environment(FTPC118,nolib)    /* Define entry point for\n                                          SMF exit. The C library is\n                                          not available. */\n #pragma environment(FTPSMFEX,nolib)   /* Define entry point for /\n                                          FTP exit. The C library is\n                                           not available. */\n #include <spc.h>                      /* SPC headers */\n\n#else\n\n #include <stdio.h>                    /* File functions used in TESTMODE */\n #include <decimal.h>                  /* Packed decimals used in TESTMODE */\n\n#endif\n\n\n#if __LIBREL__ < 0x220A0000            /* Pre OS/390 2.10 ? */\n #include \"ds118r9.h\"                  /* V2.9 TCPIP SMF 118 record */\n#else\n #define V2R10                         /* Set 2.10 or above SMF record format */\n #include \"ds118r10.h\"                 /* V2.10 TCPIP SMF 118 record */\n#endif\n\ntypedef union {\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n struct {                              /* 1st union is a mapping for a 32K record buffer in TESTMODE */\n  unsigned short int lrecl;            /* Record length */\n  unsigned short int seg;\n  char iobuffer\u00dd32764\u00a8;                /* Record buffer */\n } rec;\n#endif\n struct smfheadr hd;                   /* 2nd union in TESTMODE (1st in EXITMODE) is the standard SMF header */\n struct smfftp76 ftp;                  /* 3rd union in TESTMODE (2nd in EXITMODE) is SMF type 118 body */\n} SMFREC;\n\ntypedef struct {                       /* Output data buffer for WTO or printf */\n  unsigned short int len;              /* Length of output */\n  char line\u00dd3072\u00a8;                     /* Output data */\n} WTOLINE;\n\ntypedef struct {                       /* Structure to map HFS dataset name sections in SMF records */\n unsigned short int hfslen;            /* Length of HFS dataset name */\n char hfsds\u00dd1024\u00a8;                     /* HFS dataset name */\n} HFSDS;\n\n/* Prototype global functions */\nchar *mnb(char *,const char *,unsigned int);\nchar *timrtn(char *,unsigned int);\nint ftpc118a(SMFREC *);\n\n\n/* The following functions are defined in SMF exit mode only.*/\n#ifdef EXITMODE                        /* Compiled for SMF exit mode? */\n\nvoid mlwto(WTOLINE *);                 /* Multi-line WTO assembler function */\n\n #include \"div@bsd.h\"                  /* Non-library version of div() for EXITMODE.\n                                          Required because we cannot call C library functions in an SMF exit.*/\n#endif\n\n\n/* main()/FTPC118()\n   Main program entry points */\n#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/\nint main() {                           /* Standard C entry point for TESTMODE */\n#else                                  /* Else SMF exit mode */\nint FTPC118() {                        /* FTPC118 entry point for SMF exit mode ? */\n#endif\n\n SMFREC *smfptr;                       /* Pointer to SMF data */\n int rc=0;\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/\n smfptr=malloc(sizeof(SMFREC));        /* Alloc storage for SMF record */\n if(!smfptr) {                         /* Storage OK ? */\n  fprintf(stderr,\"FTPC118 - malloc for smfptr %u bytes failed\",sizeof(SMFREC));\n  return(-1);                          /* Error if sotrage alloc failure */\n }\n rc=ftpc118a(smfptr);                  /* Call SMF record processing routine */\n free(smfptr);                         /* Free the storage */\n#else                                  /* Else SMF exit mode */\n smfptr=*(SMFREC **)__xregs(1);        /* In SMF exit SMF record address is pointed to by Reg 1 */\n ftpc118a(smfptr);                     /* Call SMF record processing routine */\n#endif\n\n return(rc);                           /* Return rc (rc only meaningful in TESTMODE) */\n}\n\n\n/* FTPSMFEX()\n   Alternate entry point for FTP exit FTPSMFEX */\n#ifdef EXITMODE                        /* Compiled for SMF exit mode? */\nint FTPSMFEX() {                       /* Alternate entry point for FTP exit FTPSMFEX */\n\n SMFREC *smfptr;                       /* Pointer to SMF data */\n\n smfptr=*(((SMFREC **)__xregs(1))+1);  /* In FTPSMFEX SMF record is the 2nd address pointed to by R1 */\n ftpc118a(smfptr);                     /* Call SMF record processing routine */\n\n return(0);                            /* Always return 0 */\n}\n#endif\n\n\n/* ftpc118a()\n   Main SMF record processing routine */\nint ftpc118a(SMFREC *smfptr) {\n\n WTOLINE *datline;                     /* Pointer to output data */\n int chkrec(SMFREC *,unsigned int);    /* Prototype function */\n void dartn(SMFREC *,WTOLINE *);       /* Prototype function */\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/\n unsigned short int lrecl;             /* SMF record length */\n unsigned int recctr=0;                /* Record counter */\n char recflag=0;                       /* FTP record found flag */\n FILE *fp;                             /* File pointer */\n#endif\n\n datline=malloc(sizeof(WTOLINE));      /* GETMAIN output area */\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/\n fp=fopen(\"dd:SMFDD\",\"rb,type=record\"); /* Open file */\n if(!fp) {\n  fprintf(stderr,\"FTPC118 - dd:SMFDD open failed\\n\");\n  return(-1);                          /* Error if open not OK */\n }\n\n do {\n  lrecl=fread(smfptr->rec.iobuffer,1,sizeof(smfptr->rec.iobuffer),fp); /* Read SMF input file */\n  if(!lrecl) continue;                 /* If no record continue do loop */\n  else recctr++;                       /* Increment record count */\n  smfptr->rec.lrecl=lrecl+4;           /* Set real record length */\n  if(chkrec(smfptr,recctr)) continue;  /* If not valid FTP SMF record, continue do loop */\n  else recflag=1;                      /* Set record found flag */\n  dartn(smfptr,datline);               /* Format data in the record */\n } while(!feof(fp));                   /* Exit loop at EOF */\n\n if(!recflag) {                        /* Any calid records found? */\n  fprintf(stderr,\"FTPC118 - no valid FTP SMF records in dd:SMFDD\\n\");\n  return(4);                           /* Set RC4 if no records */\n }\n\n fclose(fp);                           /* Close input file */\n#endif\n\n#ifdef EXITMODE                        /* Compiled for SMF exit mode? */\n if(chkrec(smfptr,0)) return(0);       /* If not a valid record exit program */\n dartn(smfptr,datline);                /* Format data in the record */\n mlwto(datline);                       /* Call multi-line WTO routine */\n#endif\n\n free(datline);                        /* Free output area */\n\n return(0);                            /* Normal return RC0 */\n}\n\n\n/* chkrec()\n   Check that the SMF record is a valid FTP type 118 record */\nint chkrec(SMFREC *sr,unsigned int recctr) {\n\n int chkreclen1,chkreclen2;\n\n if(sr->hd.smfhdtyp!=smfhdtcp) {       /* Type 118 record ? */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n  fprintf(stderr,\"FTPC118 - dd:SMFDD record #%u SMF type %u %s\",\n   recctr,sr->hd.smfhdtyp,\"ignored\\n\");\n#endif\n  return(1);                           /* Return RC1 (skip) */\n }\n\n switch(sr->hd.smfhdsub) {             /* Check for FTP subtype */\n  case 3: case 70: case 71: case 72: case 73: case 74: case 75:\n   break;\n  default:                             /* Default not an FTP subtype */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n   fprintf(stderr,\"SMFDD record #%u SMF type %u subtype %u %s\",\n    recctr,sr->hd.smfhdtyp,sr->hd.smfhdsub,\"ignored\\n\");\n#endif\n   return(1);                          /* Return RC1 (skip) */\n }\n\n chkreclen1=(&sr->ftp.smfftpxd)-(sr->ftp.smfftphd);\n if(!(sr->hd.smfhdlen>chkreclen1)) {   /* Check the record length to ignore short records */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n  fprintf(stderr,\"SMFDD record #%u of length %u %s %u%s\",\n   recctr,sr->hd.smfhdlen,\n   \"too short (should be >\",chkreclen1,\")\\n\");\n#endif\n  return(1);                           /* Return RC1 (skip) */\n }\n\n#ifdef V2R10                           /* OS/390 2.10 or above ? */\n sr->ftp.smfftpxd==smfftpxs ?\n  (chkreclen2=((char *)(&sr->ftp.smfftgig))-(sr->ftp.smfftphd)+\n   sizeof(sr->ftp.smfftgig)) :\n  (chkreclen2=(sr->ftp.smfftbyf)-(sr->ftp.smfftphd)+\n   sizeof(sr->ftp.smfftbyf));\n#else                                  /* End record fields are different before V2R10 */\n sr->ftp.smfftpxd==smfftpxs ?\n  (chkreclen2=(sr->ftp.smfftslp)-(sr->ftp.smfftphd)+2+2+\n   sizeof(sr->ftp.smfftslp)) :\n  (chkreclen2=(sr->ftp.smfftslp)-(sr->ftp.smfftphd)+\n   sizeof(sr->ftp.smfftslp));\n#endif\n\n if(sr->hd.smfhdlen<chkreclen2) {      /* Check the record length to ignore short records */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n  fprintf(stderr,\"SMFDD record #%u of length %u %s %u%s\",\n   recctr,sr->hd.smfhdlen,\n   \"too short (should be >=\",chkreclen2,\")\\n\");\n#endif\n  return(1);                           /* Return RC1 (skip) */\n }\n\n return(0);                            /* Return RC0 (process) */\n}\n\n\n/* dartn()\n   Format the SMF record for WTO/printf */\nvoid dartn(SMFREC *sr,WTOLINE *dl) {\n\n char *dsnrtn(char *,char *,char *,int,char *,int); /* Prototype function */\n char *hfsrtn(char *,char *,HFSDS *);  /* Prototype function */\n char *testhdr(SMFREC *,char *);       /* Prototype function */\n\n int linelen;\n double dur,rate,tbc;\n div_t x1;\n unsigned short int len,hfsoff1,hfsoff2;\n HFSDS *hfs1,*hfs2;\n char ch1\u00dd80\u00a8,ch2\u00dd80\u00a8,ch3\u00dd80\u00a8,ch4\u00dd80\u00a8,ch5\u00dd80\u00a8,tbcstr\u00dd25\u00a8,\n  outfm\u00dd7\u00a8,outmo\u00dd11\u00a8,outst\u00dd5\u00a8,outdt\u00dd11\u00a8,outratestr\u00dd25\u00a8;\n char *outrate=\"kb/sec\",*dsntag=\"dsn=\",*ds2tag=\" ds2=\",\n  databuf\u00dd4096\u00a8,*currbuf=databuf,*ptr1,tbcflag='\\0';\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */\n  \"%s \",testhdr(sr,ch1));\n currbuf+=len;                         /* Bump output buffer */\n#endif\n\n if(sr->ftp.smfftpxd==smfftpxs) {      /* FTP server record ? */\n  len=sprintf(currbuf,                 /* Format command */\n   \"%s %s%s \",\n   \"FTPC118-01I FTP Server\",\n   \"cm=\",mnb(ch1,sr->ftp.smfftpcm,sizeof(sr->ftp.smfftpcm)));\n  currbuf+=len;                        /* Bump output buffer */\n\n  if(memcmp(sr->ftp.smfftpcm,\"LOGN\",4)) { /* Not logon failure ? */\n   len=sprintf(currbuf,                 /* Format dataset type */\n    \"%s%s \",\n    \"ty=\",mnb(ch2,sr->ftp.smfftpty,sizeof(sr->ftp.smfftpty)));\n   currbuf+=len;                       /* Bump output buffer */\n  }\n\n  len=sprintf(currbuf,                 /* Format last reply, ports */\n   \"%s%s %s%u %s%u \",\n   \"lr=\",mnb(ch3,sr->ftp.smfftslr,sizeof(sr->ftp.smfftslr)),\n   \"rp=\",*((unsigned short int *)sr->ftp.smfftsrp),\n   \"lp=\",*((unsigned short int *)sr->ftp.smfftslp));\n  currbuf+=len;                        /* Bump output buffer */\n\n#ifdef V2R10                           /* OS/390 2.10 or above ? */\n  hfsoff1=sr->ftp.smfftof1;\n  hfsoff2=sr->ftp.smfftof2;\n#else                                  /* End record fields are different before V2R10 */\n  hfsoff1=*(((unsigned short int *)(&sr->ftp.smfftslp))+1);\n  hfsoff2=*(((unsigned short int *)(&sr->ftp.smfftslp))+2);\n#endif\n }\n else {                                /* Else FTP client record */\n  len=sprintf(currbuf,                 /* Format command, last reply, ports */\n   \"%s %s%s \",\n   \"FTPC118-02I FTP Client\",\n   \"cm=\",mnb(ch1,sr->ftp.smfftpcm,sizeof(sr->ftp.smfftpcm)));\n  currbuf+=len;                        /* Bump output buffer */\n\n  /* APAR PQ83055 code */\n  if(*((unsigned int *)sr->ftp.smfftpty) > 4026531839) {\n   len=sprintf(currbuf,                  /* Format last reply */\n    \"%s%s \",\n    \"lr=\",mnb(ch1,sr->ftp.smfftpty,sizeof(sr->ftp.smfftpty)))            ;\n   currbuf+=len;                         /* Bump output buffer */\n  }\n  else {\n   len=sprintf(currbuf,                  /* Format last reply */\n    \"%s%u \",\n    \"lr=\",*((unsigned int *)sr->ftp.smfftpty));\n   currbuf+=len;                         /* Bump output buffer */\n  }\n\n  len=sprintf(currbuf,                 /* Format command, last reply, ports */\n   \"%s%u %s%u \",\n   \"cp=\",*((unsigned short int *)sr->ftp.smfftpcp),\n   \"cf=\",*((unsigned short int *)sr->ftp.smfftpcf));\n  currbuf+=len;                        /* Bump output buffer */\n\n  hfsoff1=*((unsigned short int *)sr->ftp.smfftsrp); /* Cleint HFS offsets are different yet again! */\n  hfsoff2=*((unsigned short int *)sr->ftp.smfftslp);\n }\n\n hfsoff1 ?\n  (hfs1=(HFSDS *)(((char *)(sr))+hfsoff1)) : /* If there is an HFS, set pointer to it */\n  (hfs1=NULL);\n hfsoff2 ?\n  (hfs2=(HFSDS *)(((char *)(sr))+hfsoff2)) : /* If there is an HFS, set pointer to it */\n  (hfs2=NULL);\n\n#ifdef V2R10                           /* OS/390 2.10 or above ? */\n if(sr->ftp.smfftpxd==smfftpxs) {      /* FTP server record ? */\n  if((unsigned int)sr->ftp.smfftgig) { /* TBC > 4Gb ? */\n   tbc=*(double *)sr->ftp.smfftbyf;    /* Get TBC from FP value */\n   tbcflag=1;                          /* Set > 4Gb flag */\n  }\n }\n else {                                /* Else FTP client record */\n  if(*((unsigned int *)sr->ftp.smfftbyf+1)) { /* TBC > 4Gb ? */\n   tbc=*((double *)&sr->ftp.smfftof1); /* Get TBC from FP value */\n   tbcflag=1;                          /* Set > 4Gb flag */\n  }\n }\n if(!tbcflag) tbc=(unsigned int)sr->ftp.smffttbc; /* if < 4Gb, use integer value for TBC */\n#else\n tbc=(unsigned int)sr->ftp.smffttbc;   /* Always use integer value when not V2R10 */\n#endif\n\n sr->ftp.smffttrs>sr->ftp.smffttre ?   /* Start time > end time ? */\n  (dur=sr->ftp.smffttre+(24*60*60*100)-sr->ftp.smffttrs) : /* Yes, assume add a day */\n  (dur=sr->ftp.smffttre-sr->ftp.smffttrs); /* No, get duration directly */\n\n if(dur>0) {                           /* duration > 0 ? */\n  rate=(tbc/(dur/100))/1000;           /* Set rate in kb/sec */\n  if(rate>=1000) {                     /* Rate > 1000 kb/sec */\n   rate/=1000;                         /* Yes, set rate in mb/sec */\n   outrate=\"mb/sec\";\n  }\n }\n else rate=0;                          /* Else set rate unknown */\n\n/* Different code for EXITMODE and TESTMODE because\n   sprintf type FP cannot be used in SPC mode without\n   the library. APAR PQ45794 */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n if(rate>0) sprintf(outratestr,\"%s%.2f%s\",\"rt=\",rate,outrate); /* Format rate */\n else strcpy(outratestr,\"rt=n/a\");\n#else\n if(!(rate>0)||((rate*100)>UINT_MAX)) strcpy(outratestr,\"rt=n/a\"); /* rate*100 exceeds unsigned max ? */\n else {\n  x1=div(((unsigned int)(rate*100+.5)),100); /* Determine rate in SMF exit mode */\n  sprintf(outratestr,\"%s%u.%02u%s\",\"rt=\",x1.quot,x1.rem,outrate); /* Format rate */\n }\n#endif\n\n if(memcmp(sr->ftp.smfftpcm,\"REN\",3)&&\n  memcmp(sr->ftp.smfftpcm,\"LOGN\",4)&&\n  memcmp(sr->ftp.smfftpcm,\"DELE\",4)) { /* Not rename/delete/logon ? */\n   switch(sr->ftp.smfftpfm) {          /* Format data format */\n    case smfftpfa: strcpy(outfm,\" ASCII\"); break;\n    case smfftpfe: strcpy(outfm,\" EBCDIC\"); break;\n    case smfftpfi: strcpy(outfm,\" Bin\"); break;\n    case 'B': strcpy(outfm,\" DBCS\"); break;\n    case 'U': strcpy(outfm,\" UCS-2\"); break;\n    default: sprintf(outfm,\" fm=%c\\0\",sr->ftp.smfftpfm);\n   }\n   switch(sr->ftp.smfftpmo) {          /* Format mode */\n    case smfftpmb: strcpy(outmo,\" Block\"); break;\n    case smfftpmc: strcpy(outmo,\" Cmprs\"); break;\n    case smfftpms: strcpy(outmo,\" Stream\"); break;\n    default: sprintf(outmo,\" mo=%c\\0\",sr->ftp.smfftpmo);\n   }\n   switch(sr->ftp.smfftpst) {          /* Format structure */\n    case smfftpsf: strcpy(outst,\" File\"); break;\n    default: sprintf(outst,\" st=%c\\0\",sr->ftp.smfftpst);\n   }\n   switch(sr->ftp.smfftpdt) {          /* Format file type */\n    case smfftpdb: strcpy(outdt,\" Seq\"); break;\n    case smfftpdp: strcpy(outdt,\" PDS\"); break;\n    case 'H': strcpy(outdt,\" HFS\"); break;\n    default: sprintf(outdt,\" dt=%c\\0\",sr->ftp.smfftpdt);\n   }\n }\n else {                                /* Else set nulls */\n  *outfm='\\0';\n  *outmo='\\0';\n  *outst='\\0';\n  *outdt='\\0';\n }\n\n len=sprintf(currbuf,                  /* Format IP addrs, userid, file type flags, start time */\n  \"%s%u.%u.%u.%u %s%u.%u.%u.%u %s%s%s%s\"\n  \"%s%s %s%s \",\n  \"sa=\",*((char *)(&sr->ftp.smfftpsa)),\n  *(((char *)(&sr->ftp.smfftpsa))+1),\n  *(((char *)(&sr->ftp.smfftpsa))+2),\n  *(((char *)(&sr->ftp.smfftpsa))+3),\n  \"sl=\",*((char *)(&sr->ftp.smfftpsl)),\n  *(((char *)(&sr->ftp.smfftpsl))+1),\n  *(((char *)(&sr->ftp.smfftpsl))+2),\n  *(((char *)(&sr->ftp.smfftpsl))+3),\n  \"su=\",mnb(ch1,sr->ftp.smfftpsu,sizeof(sr->ftp.smfftpsu)),\n  outfm,outmo,outst,outdt,\n  \"trs=\",timrtn(ch2,sr->ftp.smffttrs));\n currbuf+=len;                         /* Bump output buffer */\n\n if(memcmp(sr->ftp.smfftpcm,\"REN\",3)&&\n  memcmp(sr->ftp.smfftpcm,\"LOGN\",4)&&\n  memcmp(sr->ftp.smfftpcm,\"DELE\",4)) { /* Not rename/delete/logon ? */\n   len=sprintf(currbuf,\n    \"%s%s \",\n    \"dur=\",timrtn(ch3,(unsigned int)dur)); /* Format duration */\n   currbuf+=len;                       /* Bump output buffer */\n\n/* In V2R10 we can receive byte counts > 4Gb */\n#ifdef V2R10                           /* OS/390 2.10 or above ? */\n   if(tbcflag) {                       /* TBC > 4Gb ? */\n/* Different code for EXITMODE and TESTMODE because\n   sprintf type FP cannot be used in SPC mode without\n   the library. APAR PQ45794 */\n #ifdef TESTMODE                       /* Compiled for TESTMODE? */\n    len=sprintf(currbuf,               /* Format byte count */\n     \"%s%.2e %s \",\n     \"tbc=\",tbc,\n     outratestr);\n #else                                 /* Else SMF exit mode */\n    tbc=tbc/(1000*1000*1000);          /* Convert to Gbyte */\n    if((tbc*100)>UINT_MAX) strcpy(tbcstr,\"tbc=(>4gb)\"); /* If exceeds unsigned max, give up */\n    else {\n     x1=div(((unsigned int)(tbc*100+.5)),100); /* Determine rate in SMF exit mode */\n     sprintf(tbcstr,\"%s%u.%02u%s\",\"tbc=\",x1.quot,x1.rem,\"gb\"); /* Format rate in Gb */\n     len=sprintf(currbuf,              /* Format byte count */\n      \"%s %s \",\n      tbcstr,\n      outratestr);\n    }\n /* End special bypass floating point SPC code */\n #endif\n    currbuf+=len;                      /* Bump output buffer */\n   }\n   else {                              /* Else, not TBC > 4Gb */\n    len=sprintf(currbuf,               /* Format byte count */\n     \"%s%u %s \",\n     \"tbc=\",sr->ftp.smffttbc,\n    outratestr);\n    currbuf+=len;                      /* Bump output buffer */\n   }\n#else                                  /* Else V2R9 or lower */\n   len=sprintf(currbuf,                /* Format byte count */\n    \"%s%u %s \",\n    \"tbc=\",sr->ftp.smffttbc,\n    outratestr);\n   currbuf+=len;                       /* Bump output buffer */\n#endif\n }\n\n mnb(ch1,sr->ftp.smffthst,sizeof(sr->ftp.smffthst));\n if(ptr1=strchr(ch1,'.')) *ptr1='\\0'; /* smffthst may be truncated, so we take 1st qualifier only */\n\n len=sprintf(currbuf,                  /* Format host name */\n  \"%s%s \",\n  \"hst=\",ch1);\n currbuf+=len;                         /* Bump output buffer */\n\n if(sr->ftp.smfftpxd==smfftpxc) {      /* FTP client record ? */\n  len=sprintf(currbuf,                 /* Format userid */\n   \"%s%s \",\n   \"stc=\",mnb(ch1,sr->ftp.smfftstc,sizeof(sr->ftp.smfftstc)));\n  currbuf+=len;                        /* Bump output buffer */\n }\n\n if(memcmp(sr->ftp.smfftpcm,\"LOGN\",4)) { /* Not logon failure ? */\n  if(hfs1&&hfs1->hfslen) {             /* Any HFS 1 ? */\n   currbuf+=strlen(hfsrtn(currbuf,dsntag,hfs1)); /* Get HFS 1 */\n   if(hfs2&&hfs2->hfslen)              /* Any HFS 2 ? */\n    currbuf+=strlen(hfsrtn(currbuf,ds2tag,hfs2)); /* Get HFS 2 */\n  }\n  else {\n   if(*sr->ftp.smfftdsn!=' ') {        /* Any DSN 1 ? */\n    currbuf+=strlen(dsnrtn(currbuf,dsntag, /* Get DSN 1 */\n     sr->ftp.smfftdsn,sizeof(sr->ftp.smfftdsn),\n     sr->ftp.smfftmem,sizeof(sr->ftp.smfftmem)));\n    if(*sr->ftp.smfftds2!=' ')          /* Any DSN 2 ? */\n     currbuf+=strlen(dsnrtn(currbuf,ds2tag, /* Get DSN 2 */\n      sr->ftp.smfftds2,sizeof(sr->ftp.smfftds2),\n      sr->ftp.smfftmm2,sizeof(sr->ftp.smfftmm2)));\n   }\n  }\n }\n\n *currbuf='\\0';                        /* Set end of data */\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n printf(\"%s\\n\",databuf);               /* Output the data */\n#endif\n\n strcpy(dl->line,databuf);             /* Copy data to output buffer */\n dl->len=strlen(dl->line);             /* Set length of data */\n\nreturn;\n}\n\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n/* testhdr()\n   Add the system id and date/time to message for TESTMODE */\nchar *testhdr(SMFREC *sr,char *out) {\n\n char *currbuf=out,ch1\u00dd80\u00a8;\n unsigned short int len;\n div_t x1;\n struct tm tim;\n struct tm *datconv(int,int,struct tm *);\n\n x1=div(*((decimal(7,0) *)sr->hd.smfhddte),1000); /* Get Juilan date stored in packed decimal format */\n datconv(x1.quot,x1.rem,&tim);         /* Convert date to C tm structure format */\n\n memcpy(currbuf,sr->hd.smfhdsid,sizeof(sr->hd.smfhdsid)); /* Copy system id */\n currbuf+=sizeof(sr->hd.smfhdsid);     /* Bump output buffer */\n\n len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */\n  \" %u/%02u/%02u %s\",\n  tim.tm_year+1900,tim.tm_mon+1,tim.tm_mday,\n  timrtn(ch1,sr->hd.smfhdtme));\n currbuf+=len;                         /* Bump output buffer */\n\n return out;\n}\n\n\n/* datconv()\n   Convert a date from Julan format into C tm structure format */\nstruct tm *datconv(int yr,int jd,struct tm *tim) {\n\n char montab\u00dd12\u00a8={31,28,31,30,31,30,31,31,30,31,30,31};\n char monctr=0;\n int jdctr=1,dyctr=1;\n\n memset((char *)tim,'\\0',sizeof(tim)); /* Initialise tm structure */\n tim->tm_yday=jd-1;\n tim->tm_year=yr;\n yr+=1900;\n if(!(yr%4)&&!(!(yr%100)&&(yr%400))) montab\u00dd1\u00a8=29; /* Set Feb to 29 days on leap years */\n\n for(;jdctr<=jd;dyctr++,jdctr++) {\n  tim->tm_mon=monctr;\n  tim->tm_mday=dyctr;\n  if(montab\u00ddmonctr\u00a8==dyctr) {\n   dyctr=0;\n   monctr++;\n  }\n }\n\n return tim;\n}\n#endif\n\n\n/* mnb()\n   Copy a space delimited string up to a max length */\nchar *mnb(char *out,const char *in,unsigned int len) {\n\n char *ptr1=out;\n\n for(;*in!=' '&&*in&&len;ptr1++,in++,len--) *ptr1=*in;\n *ptr1='\\0';\n\n return out;\n}\n\n\n/* dsnrtn()\n   Format a dataset and member name */\nchar *dsnrtn(char *out,char *dsntag,char *in1,int in1l,\n char *in2,int in2l) {\n\n char *ptr1=out+strlen(dsntag),*ch1;\n\n ch1=malloc(in2l+1);\n strcpy(out,dsntag);\n ptr1+=strlen(mnb(ptr1,in1,in1l));\n if(*in2!=' '&&*in2)\n  sprintf(ptr1,\"(%s)\\0\",mnb(ch1,in2,in2l));\n else *ptr1='\\0';\n free(ch1);\n\n return out;\n}\n\n\n/* hfsrtn()\n   Format a HFS dataset name */\nchar *hfsrtn(char *currbuf,char *dsntag,HFSDS *hfs) {\n\n char *ptr=currbuf+strlen(dsntag);\n\n strcpy(currbuf,dsntag);\n memcpy(ptr,hfs->hfsds,hfs->hfslen);\n ptr+=hfs->hfslen;\n\n return currbuf;\n}\n\n\n/* timrtn()\n   Format a binary time in HH:MM:SS.TH format */\nchar *timrtn(char *tim_out,unsigned int tim_in) {\n\n div_t x1,x2,x3;\n\n x1=div(tim_in,60*60*100);\n x2=div(x1.rem,60*100);\n x3=div(x2.rem,100);\n sprintf(tim_out,\"%02u:%02u:%02u.%02u\\0\",\n  x1.quot,x2.quot,x3.quot,x3.rem);\n\n return tim_out;\n}\n\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FTPC118C": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x00\\x05\\x01\\x02'\\x1f\\x01\\x04\\x06?\\x16\\x18\\x007\\x00/\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "2002-09-28T00:00:00", "modifydate": "2004-03-03T16:18:05", "lines": 55, "newlines": 47, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWC  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(FTPC118C)\n//* JCL TO COMPILE FTPT118/FTPC118 (FTP SMF 118 WTO/PRINT)\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*   3) IF YOU HAVE THE LE DEBUGGER, INCLUDE THE TEST OPTION IN\n//*      THE COMP1 STEP\n//*   4) ON Z/OS 1.2 AND ABOVE, CHECK THE VERSION OF THE C COMPILER\n//*      YOU WISH TO USE. IN THIS JCL, SWITCHING BETWEEN THE\n//*      OS/390 R10 COMPILER AND THE Z/OS 1.2 COMPILER IS MERELY\n//*      A MATTER OF CHANGING THE JCLLIB STATEMENT.\n//*   5) REFER TO DOC MEMBER $DOCFTPC OF (USERID).CBTXXX.FILE600.PDS\n//*      FOR INSTALLATION INSTRUCTIONS\n//*\n//*\n//        JCLLIB ORDER=(SYS1.CBC.SCBCPRC)     OS/390 R10 COMPILER\n//*       JCLLIB ORDER=(SYS1.CBC.SCCNPRC)     Z/OS 1.2 COMPILER\n//*\n//* COMP1 (NORMAL C COMPILE FOR FTPT118 - TESTING OR PRINTING SMF RECS)\n//* - COMPILE THE PROGRAM WITH OPTIONS FOR BATCH\n//* - IF USING THE LE DEBUGGER, INCLUDE THE TEST COMPILE OPTION\n//* - THE TESTMODE SYMBOL IS PASSED TO THE COMPILER. THIS WILL\n//*   GENERATE PRINTF FUNCTIONS FOR TESTING AND SUPPRESS THE\n//*   SPC-TYPE LINKAGE AND FUNCTIONS.\n//* - THE OUTPUT OBJECT MODULE IS SAVED\n//*\n//COMP1    EXEC  EDCC,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          CPARM='SO,LIS,OF,EXP', ,TEST',\n//          CPARM2='DEF(TESTMODE),FLOAT(HEX)',\n//          SYSLBLK=,\n//          INFILE='AWCPAW.CBT.FILE600.C.PDS(FTPC118)',\n//          OUTFILE='AWCPAW.CBT.FILE600.OBJ.PDS(FTPT118),DISP=SHR'\n//COMPILE.USERLIB DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.C.PDS\n//*\n//* COMP2 (SYSTEMS PROGRAMMING C COMPILE FOR FTPC118 - SMF EXIT)\n//* - COMPILE THE PROGRAM WITH SPC OPTIONS (NOSTART).\n//* - THE TESTMODE SYMBOL IS NOT PASSED TO THE COMPILER. THIS WILL\n//*   GENERATE SPC-TYPE LINKAGE AND FUNCTIONS.\n//* - THE OUTPUT OBJECT MODULE IS SAVED\n//*\n//COMP2    EXEC  EDCC,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          CPARM='SO,LIS,OF,EXP,NOSTA',\n//          CPARM2='FLOAT(HEX)',\n//          SYSLBLK=,\n//          INFILE='AWCPAW.CBT.FILE600.C.PDS(FTPC118)',\n//          OUTFILE='AWCPAW.CBT.FILE600.OBJ.PDS(FTPC118),DISP=SHR'\n//COMPILE.USERLIB DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.C.PDS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FTPC118L": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0c\\x00W\\x01\\x02'\\x1f\\x01\\x04\\x17O\\x139\\x002\\x002\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.12", "flags": 0, "createdate": "2002-09-28T00:00:00", "modifydate": "2004-06-22T13:39:57", "lines": 50, "newlines": 50, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWL  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(FTPC118L)\n//* JCL TO PRELINK/LINK FTPT118/FTPC118 (FTP SMF 118 WTO/PRINT)\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*   3) CHANGE ALL AWCPAW.CBT.FILE600.LOAD TO YOUR LINKLIB LIBRARY\n//*   4) REFER TO DOC MEMBER $DOCFTPC OF (USERID).CBTXXX.FILE600.PDS\n//*      FOR INSTALLATION INSTRUCTIONS\n//*\n//*\n//        JCLLIB ORDER=(SYS1.CEE.SCEEPROC)\n//*\n//* LINK1 (NORMAL C LINK FOR FTPT118 - TESTING OR PRINTING SMF RECORDS)\n//* - THE PROGRAM IS ASSUMED TO BE NATURALLY REENTRANT\n//* - THE OUTPUT LOAD MODULE IS SAVED IN A LINKLIST LIBRARY\n//*\n//LINK1    EXEC  EDCPL,\n//          LIBPRFX='SYS1.CEE',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP,RENT',\n//          INFILE='AWCPAW.CBT.FILE600.OBJ.PDS(FTPT118)',\n//          OUTFILE='AWCPAW.CBT.FILE600.LOAD(FTPT118),DISP=SHR'\n//*\n//* LINK2 (SYSTEMS PROGRAMMING C LINK FOR FTPC118 - SMF EXIT)\n//* - THE PROGRAM IS ASSUMED TO BE NATURALLY REENTRANT\n//* - FOR SPC THE LINK EDIT SYSLIB MUST SPECIFY THE SCEESPC LIBRARY\n//*   AND THE EDCXSPRT AND EDCXMEM MUST BE EXPLICITLY INCLUDED.\n//* - THE OUTPUT LOAD MODULE IS SAVED IN A LINKLIST LIBRARY\n//*\n//LINK2    EXEC  EDCPL,\n//          LIBPRFX='SYS1.CEE',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP,RENT',\n//          INFILE='AWCPAW.CBT.FILE600.OBJ.PDS(FTPC118)',\n//          OUTFILE='AWCPAW.CBT.FILE600.LOAD,DISP=SHR'\n//LKED.SYSLIB DD DISP=SHR,DSN=SYS1.CEE.SCEESPC\n//            DD DISP=SHR,DSN=SYS1.CEE.SCEELKED\n//LKED.SYSIN DD *\n INCLUDE SYSLIB(EDCXSPRT)\n INCLUDE OBJECT\n ENTRY FTPSMFEX\n ALIAS FTPSMFEX\n ENTRY FTPC118\n NAME FTPC118(R)\n//LKED.OBJECT DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.OBJ.PDS(MLWTO)\n//            DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.OBJ.PDS(EDCXFGS)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FTPC119": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\t\\x01\\x00%_\\x01\\x05\\x15o\\tS\\x05\\x1e\\x02*\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2000-09-11T00:00:00", "modifydate": "2005-06-05T09:53:09", "lines": 1310, "newlines": 554, "modlines": 0, "user": "AWCPAW"}, "text": "#pragma title(\"FTPC119 - SMF type 119 (FTP) print/WTO\")\n#pragma comment(copyright,\"FTPC119 - \u00a9Paul Wells (Saudi Aramco) 2002\")\n\n/**********************************************************************\n*\n*  Name: FTPC119 (C language source)\n*\n*\n*  Abstract:\n*\n*     A C language program which processes SMF type 119 FTP records.\n*\n*     The program has 2 modes of operation, selected by compile\n*     and link edit options: EXITMODE and TESTMODE.\n*\n*     In EXITMODE, FTPC119 uses Systems Programming C facilities to run\n*     as an SMF IEFU83/84 exit to format and WTO the SMF FTP records.\n*\n*     In TESTMODE, FTPC119 (load module FTPT119) runs as a standard\n*     C main program in batch to print the SMF FTP records to\n*     standard output.\n*\n*\n*  Operation:\n*\n*     EXITMODE\n*     --------\n*     On entry R1 points to the address of the SMF record being\n*     written by the system. The chkrec() function is called to\n*     verify that it is a valid type 119 FTP record. Type 119\n*     subtypes 3/70/72 are processed. All other records\n*     are ignored and control returns to the system with RC=0\n*     to allow the SMF record to be written.\n*\n*     For a valid FTP record an output area is allocated, dartn()\n*     then a subtype-specific function is called to format\n*     the SMF data to be suitable for WTO. The data fields processed\n*     in the FTP Client (C), FTP Server (S) and FTP Server logon\n*     failure (L) records is as follows.\n*\n*      WTO    C/S/L Description          SMF 119 Name  Example\n*      ---    ----- -----------          ------------  -------\n*      cm=    C/S/L Subcommand (RFC959)  C: fccmd      cm=STOR\n*                                        S: fscmd\n*                                        L: (derived)\n*      ty=    S     File type            fsftype       ty=SEQ\n*      lr=    C/S   Last reply to client C: fclreply   lr=250\n*                                        S: fslreply\n*      cp=    C     Local port           fcclport      cp=1064\n*      cf=    C     Foreign port         fccrport      cf=21\n*      rp=    S/L   Remote port          S: fscrport   rp=4608\n*                                        L: ffrport\n*      lp=    S/L   Local port           S: fsclport   lp=21\n*                                        L: fflport\n*      sa=    C/S/L C: Local IP address  C: fcclip     sa=10.13.80.11\n*                   S: Remote IP address S: fsclip\n*                   L: Remote IP address L: ffrip\n*      sl=    C/S/L C: Remote IP address C: fccrip     sl=10.1.160.220\n*                   S: Local IP address  S: fscrip\n*                   L: Local IP address  L: fflip\n*      su=    C/S/L C: Remote userid     C: fcruser    su=AWCPAW\n*                   S: Local userid      S: fssuser\n*                   L: Local userid      L: ffuserid\n*             C/S   Data format          C: fctype     ASCII\n*                                        S: fstype\n*             C/S   Mode                 C: fcmode     Stream\n*                                        S: fsmode\n*             C/S   Structure            C: fcstruct   File\n*                                        S: fsstruct\n*             C/S   Dataset type         C: fcdstype   Seq\n*                                        S: fsdsttype\n*      trs=   C/S   Start time           C: fcstime    trs=08:09:08.87\n*                                        S: fsstime\n*      dur=   C/S   Duration             C: fcdur      dur=00:00:00.02\n*                                        S: fsdur\n*      tbc=   C/S   Byte count           C: fcbytes    tbc=5924\n*                                        S: fsbytes\n*      rt=    C/S   Rate                 (derived)     rt=296.20kb/sec\n*      hst=   C/S   Host name            C: fchostname hst=tso03\n*                                        S: fshostname\n*      stc=   C     Local userid         fcluser       stc=AWCPAW\n*      asn=   C     Address space        asname        asn=AWCPAWFT\n*      dsn=   C/S   1st Dataset name     C: fcfilename dsn=AWCPAW.TEMP\n*                                        S: fsfilename1\n*      ds2=   S     2nd Dataset name     fsfilename2   ds2=AWCPAW.TEMP2\n*      reas=  L     Logon failure reason ffreason      reas=1(password\n*                                                      not valid)\n*\n*     Once formatted, the data is passed to an external assembler\n*     subroutine to issue the WTO to the operating system. The\n*     format of the output in the syslog will be similar\n*     to the following.\n*\n*  FTPC119-02I FTP Client cm=RETR lr=226 cp=1146 cf=21 sa=10.1.160.220\n*  sl=10.1.43.57 su=anonymou ASCII Stream File Seq trs=08:33:52.04\n*  dur=00:00:04.09 tbc=160638 rt=39.28kb/sec hst=tso03 stc=AWCPAW\n*  asn=AWCHOLDD dsn=SYSM.OS390.HOLDDATA(MONTH)\n*\n*     Once the WTO is issued the program frees storage for the\n*     output area and returns to the operating system with RC=0\n*     to allow the SMF record to be written.\n*\n*     TESTMODE\n*     --------\n*     In TESTMODE a 32K buffer is allocated for processing the\n*     SMF records. The SMFDD DD is opened as an input file\n*     and an SMF record is read from it. The chkrec() function is called\n*     to verify that it is a valid type 119 FTP record. Type 119\n*     subtypes 3/70/72 are processed. All other records\n*     are ignored and control returns to the system. Rejected\n*     records are reported to STDERR output.\n*\n*     For a valid FTP record an output area is allocated, dartn()\n*     then a subtype-specific function is called to format\n*     the SMF data to be suitable for output. The data fields are\n*     identical to those described above for EXITMODE.\n*\n*     Once formatted, the data is output to STDOUT via the printf\n*     function. The formating is almost identical to that described\n*     above for EXITMODE. The difference being that the data is\n*     prefixed by the system and date/time from the SMF record.\n*\n*     Control then returns back, another SMF record is read\n*     and processed and so on until end of file. At EOF the SMFDD\n*     is closed, storage is freed and control returns to the operating\n*     system.\n*\n*\n*  Environment:\n*\n*     IBM compatible mainframe\n*\n*     IBM OS/390, z/OS or subsequent operating system with C compiler\n*\n*     A minimum level of z/OS 1.2 (HIP6120 TCPIP fmid) is required\n*     for the SMF type 119 formats supported by this program.\n*\n*     The program has been tested on a z/OS 1.2 system. On\n*     z/OS 1.2 type 119 is the new TCPIP SMF record. Type 119\n*     records are much better strucutured than 118 records and provide\n*     IPv6 support and will be the basis for further enhancements by\n*     IBM. Type 119 records can be produced in parallel with the 118\n*     records for the time being at least.\n*\n*\n*  Compilation:\n*\n*     EXITMODE & TESTMODE\n*     -------------------\n*     If the C compiler is available, sample JCL\n*     AWCPAW.CBT.FILE600.C.PDS(FTPC119C) can be used to compile the\n*     program. 2 object modules are output: FTPC119 for EXITMODE\n*     and FTPT119 for TESTMODE.\n*\n*     The FTPC119 compile is for SPC (Systems Programming C)\n*     and must specify the NOSTART option. It must not specify\n*     RENT, since RENT is not supported in SPC. The code is naturally\n*     re-entrant in any case.\n*\n*     The FTPT119 compile is a standard C main program compile\n*     and can specify TEST for use with the LE debugger.\n*\n*\n*  Installation:\n*\n*     EXITMODE & TESTMODE\n*     -------------------\n*     To ensure that SMF 119 FTP records are being created the\n*     following tasks must be completed.\n*\n*      1) For client FTP records ensure that SYS1.TCPPARMS(PROFILE)\n*         or equivalent includes this statement.\n*\n*         SMFCONFIG TYPE119 FTPCLIENT\n*\n*         This statement can be present in addition to\n*         SMFCONFIG FTPCLIENT (for type 118 records) if required.\n*\n*      2) For all types of server records ensure that\n*         SYS1.TCPPARMS(FTPSDATA) or equivalent contains the\n*         statements as follows. (SMFJES and SMFSQL are optional)\n*\n*         SMF           TYPE119         ; SMF records (new type 119)\n*         SMFJES        TYPE119         ; SMF filetype=jes (type 119)\n*         SMFSQL        TYPE119         ; SMF filetype=sql (type 119)\n*\n*         These statements can be present in addition to those\n*         for type 118 records, if required.\n*\n*     EXITMODE\n*     --------\n*     To install the SMF exits for EXITMODE, complete the following.\n*\n*      1) Ensure type 119 records are being written (above).\n*\n*      2) Link edit FTPC119 into a linklist library and refresh\n*         LLA if necessary. Sample JCL is in\n*         AWCPAW.CBT.FILE600.C.PDS(FTPC119L). The FTPC119 load module\n*         is used in EXITMODE.\n*\n*         The FPTC119 link edit must specify CEE.SCEESPC\n*         first in its SYSLIB concatenation for SPC support. Object\n*         module EDCXSPRT must be explicitly included for the\n*         SPC version of the sprintf function. Assembler object modules\n*         MLWTO, SPRNTLL and EDCXFGS should also be included for the\n*         mlwto(),sprntll() and malloc()/free() functions respectively.\n*\n*      3) Optionally install the SMF exit test program FTPCTST\n*         which is contained in AWCPAW.CBT.FILE600.ASM.PDS. This\n*         program can be used to test the WTO functions of the\n*         program before it is installed as an SMF exit.\n*\n*      4) Ensure that exits IEFU83 and IEFU84 are being called\n*         for all address spaces by coding these exits in\n*         all SYS or SUBSYS statements in SYS1.PARMLIB(SMFPRMxx) e.g.\n*\n*         SYS(NOTYPE(..,..,..,..),\n*             EXITS(IEFU83,IEFU84,.....,......,),..........,........)\n*         SUBSYS(STC,NOTYPE(..,..,..,..),\n*             EXITS(IEFU83,IEFU84,.....,......,),..........,........)\n*\n*         Including the exits in SUBSYS(STC) is required and ommitting\n*         it is a likely reason for the exits not being invoked.\n*\n*         Note that IEFU83 is required for FTP server records\n*         whereas IEFU84 is required for client records.\n*         It is recommended to install both.\n*\n*      5) Update SYS1.PARMLIB(PROGxx) to load the exits\n*         via the dynamic exit facility, e.g.\n*\n*         EXIT ADD EXITNAME(SYS.IEFU83) MODNAME(FTPC119)\n*         EXIT ADD EXITNAME(SYS.IEFU84) MODNAME(FTPC119)\n*\n*      6) Dynamically install via the SETPROG operator\n*         command e.g.\n*\n*         SETPROG EXIT,ADD,EXITNAME=SYS.IEFU83,MODNAME=FTPC119\n*         SETPROG EXIT,ADD,EXITNAME=SYS.IEFU84,MODNAME=FTPC119\n*\n*         Or alternatively IPL to activate the exits via PROGxx.\n*\n*     TESTMODE\n*     --------\n*     FTPC119 should be link edited into any load library. Sample\n*     JCL is in AWCPAW.CBT.FILE600.C.PDS(FTPC119L). The FTPT119 load\n*     module is used in TESTMODE.\n*\n*\n*  Invocation:\n*\n*     EXITMODE\n*     --------\n*     When installed (as recommended) as both an IEFU83 and IEFU84\n*     system SMF exit, the program will be entered for every SMF record\n*     written, except those written in cross memory mode that\n*     would be processed by IEFU85. (There is no point installing\n*     the program as an IEFU85 exit as there are no FTP records\n*     written in this mode.)\n*\n*     In IEFU83/84 the linkage conventions are as follows.\n*     (From z/OS MVS Installation Exits SA22-7593-01)\n*\n*      The contents of the registers on entry to IEFU83/84 are:\n*\n*      Register  Contents\n*      0/2-12    Not applicable\n*      1         Address of the parameter list\n*      13        Register save area\n*      14        Return address\n*      15        Entry point address of IEFU84\n*\n*      Register 1 points to the following address:\n*\n*      Word 1    The address of the record that SMF is to write. The\n*                first four bytes of this record are the\n*                record descriptor word.\n*\n*      Upon return from IEFU83/84 processing, the register contents\n*      must be:\n*\n*      Register  Contents\n*      0-14      Same as at entry\n*      15        One of the following return codes:\n*\n*      Value of 4 SMF is not to write the record to the SMF data set.\n*      Other than 4 SMF is to write the record to the SMF data set.\n*\n*\n*     The EXITMODE function can be tested by program FTPCTST without\n*     installing FTPC119 as an SMF exit. FTPCTST is contained in\n*     AWCPAW.CBT.FILE600.ASM.PDS and can be invoked by the JCL\n*     in AWCPAW.CBT.FILE600.ASM.PDS(FTPCTSTJ). This JCL requires\n*     an SMF input file of type 119 SMF records.\n*\n*\n*     TESTMODE\n*     --------\n*     In TESTMODE FTPC119 (load module FTPT119) is invoked via\n*     batch JCL and runs against an SMF input dataset.\n*     Sample JCL can be found in\n*     AWCPAW.CBT.FILE600.C.PDS(FTPT119J).\n*     In TESTMODE FTPC119 (load module FTPT119) has 2 switches:\n*       -r to resolve IP addresses via a nameserver\n*       -e to echo the switch options to stdout\n*\n*     Sample JCL for an SMF type 119 extract is in\n*     AWCPAW.CBT.FILE600.C.PDS(SMFX119J).\n*\n*\n*  Notes:\n*\n*     Writeable static variables cannot be used in SPC mode because it\n*     violates reentrancy. This type of variable is statically linked\n*     into the program and if modified in SPC mode, an abend0c4 will\n*     result.\n*\n*     In SPC mode, the program runs with #pragma (FTPC119,nolib)\n*     which means that the program cannot use any C library functions.\n*     This is essential because invocation of library functions may\n*     involve external module loads or other SVCs which cannot be\n*     tolerated in an SMF exit.\n*\n*     The record length of this source is greater than 80. The source\n*     is best stored in a VB255 PDS.\n*\n*\n*  Author: Paul Wells\n*          Saudi Aramco Box 12959\n*          Dhahran 31311\n*          Saudi Arabia\n*\n*  Email:  paul.wells@aramco.com\n*\n*  History:\n*\n*     PW 06/Jun/2005 - Update for APAR PK01634 which added\n*                      blank filling for the PDS member fields.\n*     PW 22/Mar/2004 - smf119ft_fsdur and smf119ft_fcdur can be\n*                      invalid if the ftp spans midnight.\n*                      The fix for APAR PQ87028 is required to\n*                      rectify this. The fmtrate routine was amended\n*                      to attempt to trap invalid durations and report\n*                      them as n/a.\n*     PW 15/Mar/2004 - For subtype 72 (FTP server logon failure) the\n*                      local IP address (sl=) and remote IP address\n*                      (sa=) output fields were transposed. The\n*                      ftff.smf119ft_ffrip and ftff.smf119ft_fflip\n*                      SMF fields were swapped to be consistent\n*                      with the documentation and the old SMF type 118\n*                      subtype 72 output.\n*     PW 07/Mar/2004 - Included comment to state that the RENT compile\n*                      option is required in TESTMODE.\n*     PW 01/Mar/2004 - In TESTMODE for SMF type 119 a program switch\n*                      (-r) is added which causes IP addresses to\n*                      be resolved to a domain name. The display will\n*                      show the domain name (if found) followed by\n*                      the IP address in brackets. A -e switch is also\n*                      added to echo the switch options to stdout\n*                      if required.\n*     PW 11/Feb/2004 - IBM changed ftfc.smf119ft_fclreply from\n*                      binary to EBCDIC with APAR PQ80090. The code\n*                      was changed to allow for both data formats.\n*     PW 30/Mar/2003 - Comments updated\n*     PW 30/Oct/2002 - Changed fmtdsn function to use unsigned short\n*                      int type rather than size_t.\n*     PW 18/Sep/2002 - Original\n*\n***********************************************************************/\n\n/* Include standard C header files */\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <limits.h>\n\n#ifndef TESTMODE                       /* Not compiled for TESTMODE? */\n\n #define EXITMODE                      /* Default compile is EXITMODE (for SMF exit) */\n #pragma runopts(\"TRAP(OFF),HEAP(8K,32K,ANY),STACK(8K,32K,ANY)\")\n                                       /* TRAP(OFF) sets ESTAE/ESPIE off for SMF exit\n                                          8K for Heap is sufficient in exit mode\n                                          8K for Stack is sufficient in exit mode */\n #pragma environment(FTPC119,nolib)    /* Define entry point for\n                                          SMF exit. The C library is\n                                          not available. */\n #include <spc.h>                      /* SPC headers */\n\n#else\n\n #define _OE_SOCKETS                   /* BSD-like socket interface */\n #include <unistd.h>                   /* Some standard Unix functions */\n #include <netdb.h>                    /* Network database operations */\n #include <sys/socket.h>               /* Sockets definitions */\n #include <decimal.h>                  /* Packed decimals used in TESTMODE */\n #include <stdio.h>                    /* File functions used in TESTMODE */\n\n#endif\n\n#include \"ds119r12.h\"                  /* z/OS 1.2 TCPIP SMF 119 record */\n\n/* DSECTs from SMF record 119 not converted by C DSECT utility\n   due to DSECTS having length 0 i.e.\nEDC5515 00 HDRSKIP option value greater than length for section SMF119FT_FSHN\nEDC5515 00 HDRSKIP option value greater than length for section SMF119FT_FSA1\nEDC5515 00 HDRSKIP option value greater than length for section SMF119FT_FSA2\nEDC5515 00 HDRSKIP option value greater than length for section SMF119FT_FCAN\n */\nstruct smf119ft_fshn {                 /* FTP Server Transfer Completion Hostname */\n unsigned char smf119ft_fshostname\u00dd255\u00a8;\n};\nstruct smf119ft_fsa1 {                 /* FTP Server Transfer Completion 1st Associated Dataset File Name */\n unsigned char smf119ft_fsfilename1\u00dd1024\u00a8;\n};\nstruct smf119ft_fsa2 {                 /* FTP Server Transfer Completion 2nd Associated Dataset File Name */\n unsigned char smf119ft_fsfilename2\u00dd1024\u00a8;\n};\nstruct smf119ft_fcan {                 /* FTP Client Transfer Completion Associated Dataset File Name */\n unsigned char smf119ft_fcfilename\u00dd1024\u00a8;\n};\n\n\ntypedef union {\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n struct {                              /* 1st union is a mapping for a 32K record buffer in TESTMODE */\n  unsigned short int lrecl;            /* Record length */\n  unsigned short int seg;\n  char iobuffer\u00dd32764\u00a8;                /* Record buffer */\n } rec;\n#endif\n struct {                              /* 2nd union in TESTMODE (1st in EXITMODE) is the whole SMF record */\n  struct smf119header ft1;             /* SMF header */\n  struct smf119sdefsect ft2;           /* SMF self defining section */\n  struct smf119sd3triples ft3;         /* SMF section for record with at least 3 triples */\n  struct smf119sd4triples ft4;         /* SMF section for record with at least 4 triples */\n  struct smf119sd5triples ft5;         /* SMF section for record with 5 triples */\n } fts;\n} SMFREC;\n\n#define fth1 sr->fts.ft1               /* Shortcut for header */\n#define fth2 sr->fts.ft2               /* Shortcut for self defining section */\n#define fth3 sr->fts.ft3               /* Shortcut for self defining section 2 */\n#define fth4 sr->fts.ft4               /* Shortcut for self defining section 3 */\n#define fth5 sr->fts.ft5               /* Shortcut for self defining section 4 */\n\ntypedef struct {\n struct smf119ident ftsid;             /* TCPIP SMF record identification section */\n} FTIDENT;\n#define ftid srid->ftsid               /* Shortcut for ID section */\n\ntypedef struct {                       /* Output data buffer for WTO or printf */\n  unsigned short int len;              /* Length of output */\n  char line\u00dd3072\u00a8;                     /* Output data */\n} WTOLINE;\n\n/* Prototype global functions */\nchar *mnb(char *,const char *,unsigned int);\nchar *timrtn(char *,unsigned int);\nchar *fmtipv6(char *,unsigned short int,const char *);\nchar *fmtrate(char *,unsigned long long,unsigned int);\nchar *testhdr(SMFREC *,char *);\nunsigned short int fmtdsn(char *,const char *,const char *,const char *,unsigned short int,unsigned short int);\nvoid sprntll(char *,long long);       /* External format 64 bit integer function */\nint ftpc119a(SMFREC *);\n#define __isleap(year)    \\\n ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))\n\n\n/* The following is defined in SMF exit mode only.*/\n#ifdef EXITMODE                        /* Compiled for SMF exit mode? */\n\nvoid mlwto(WTOLINE *);                 /* Multi-line WTO assembler function */\n\n #include \"div@bsd.h\"                  /* Non-library version of div() for EXITMODE.\n                                          Required because we cannot call C library functions in an SMF exit.*/\n#else\nint ftpt119a(int,char **);             /* TESTMODE entry function */\nchar runflag=0;                        /* run flags (Switches) in writable static area (requires RENT compile option) */\n #define rf_error 0x01                 /* switch error switch */\n #define rf_resolve 0x02               /* resolve switch */\n #define rf_ques 0x20                  /* -? */\n #define rf_echo 0x40                  /* echo some messages to stdout */\n#endif\n\n\n/* main()/FTPC119()\n   Main program entry points */\n#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/\nint main(int argc,char *argv\u00dd\u00a8) {      /* Standard C entry point for TESTMODE */\n#else                                  /* Else SMF exit mode */\nint FTPC119() {                        /* FTPC119 entry point for SMF exit mode ? */\n#endif\n\n SMFREC *smfptr;                       /* Pointer to SMF data */\n int rc=0;\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/\n char ch1\u00dd255\u00a8;\n\n if(ftpt119a(argc,argv)) {             /* Call TESTMODE entry */\n  if(runflag&rf_error) return -1;      /* return -1 if error */\n  else return 0;\n }\n if((runflag&rf_resolve)&&gethostname(ch1,sizeof(ch1))) {\n  runflag&=(255-rf_resolve);\n  fprintf(stderr,\"FTPC119 - resolve suppressed due to failure of gethostname call\\n\");\n }\n\n smfptr=malloc(sizeof(SMFREC));        /* Alloc storage for SMF record */\n if(!smfptr) {                         /* Storage OK ? */\n  fprintf(stderr,\"FTPC119 - malloc for smfptr %u bytes failed\\n\",sizeof(SMFREC));\n  return(-1);                          /* Error if sotrage alloc failure */\n }\n rc=ftpc119a(smfptr);                  /* Call SMF record processing routine */\n free(smfptr);                         /* Free the storage */\n#else                                  /* Else SMF exit mode */\n smfptr=*(SMFREC **)__xregs(1);        /* In SMF exit SMF record address is pointed to by Reg 1 */\n ftpc119a(smfptr);                     /* Call SMF record processing routine */\n#endif\n\n return(rc);                           /* Return rc (rc only meaningful in TESTMODE) */\n}\n\n\n/* ftpc119a()\n   Main SMF record processing routine */\nint ftpc119a(SMFREC *smfptr) {\n\n WTOLINE *datline;                     /* Pointer to output data */\n int chkrec(SMFREC *,unsigned int);    /* Prototype function */\n void dartn(SMFREC *,WTOLINE *);       /* Prototype function */\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/\n unsigned short int lrecl;             /* SMF record length */\n unsigned int recctr=0;                /* Record counter */\n char recflag=0;                       /* FTP record found flag */\n FILE *fp;                             /* File pointer */\n#endif\n\n datline=malloc(sizeof(WTOLINE));      /* GETMAIN output area */\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE ?*/\n fp=fopen(\"dd:SMFDD\",\"rb,type=record\"); /* Open file */\n if(!fp) {\n  fprintf(stderr,\"FTPC119 - dd:SMFDD open failed\\n\");\n  return(-1);                          /* Error if open not OK */\n }\n\n do {\n  lrecl=fread(smfptr->rec.iobuffer,1,sizeof(smfptr->rec.iobuffer),fp); /* Read SMF input file */\n  if(!lrecl) continue;                 /* If no record continue do loop */\n  else recctr++;                       /* Increment record count */\n  smfptr->rec.lrecl=lrecl+4;           /* Set real record length */\n  if(chkrec(smfptr,recctr)) continue;  /* If not valid FTP SMF record, continue do loop */\n  else recflag=1;                      /* Set record found flag */\n  dartn(smfptr,datline);               /* Format data in the record */\n } while(!feof(fp));                   /* Exit loop at EOF */\n\n if(!recflag) {                        /* Any calid records found? */\n  fprintf(stderr,\"FTPC119 - no valid FTP SMF records in dd:SMFDD\\n\");\n  return(4);                           /* Set RC4 if no records */\n }\n\n fclose(fp);                           /* Close input file */\n#endif\n\n#ifdef EXITMODE                        /* Compiled for SMF exit mode? */\n if(chkrec(smfptr,0)) return(0);       /* If not a valid record exit program */\n dartn(smfptr,datline);                /* Format data in the record */\n mlwto(datline);                       /* Call multi-line WTO routine */\n#endif\n\n free(datline);                        /* Free output area */\n\n return(0);                            /* Normal return RC0 */\n}\n\n\n/* chkrec()\n   Check that the SMF record is a valid FTP type 119 record */\nint chkrec(SMFREC *sr,unsigned int recctr) {\n\n unsigned short int subtype;\n\n if(fth1.smf119hdtype!=119) {          /* Type 119 record ? */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n  fprintf(stderr,\"FTPC119 - SMFDD record #%u SMF type %u %s\",\n   recctr,fth1.smf119hdtype,\"ignored - not TCPIP type 119\\n\");\n#endif\n  return(1);                           /* Return RC1 (skip) */\n }\n\n subtype=*((unsigned short int *)fth1.smf119hdsubtype); /*  Get SMF record subtype */\n\n switch(subtype) {                     /* Check for FTP subtype */\n  case 3: case 70: case 72:\n   break;\n  default:                             /* Default not an FTP subtype */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n   fprintf(stderr,\"FTPC119 - SMFDD record #%u SMF type %u subtype %u %s\",\n    recctr,fth1.smf119hdtype,subtype,\n    \"ignored - not an FTP subtype\\n\");\n#endif\n   return(1);                          /* Return RC1 (skip) */\n }\n\n return(0);                            /* Return RC0 (process) */\n}\n\n\n/* dartn()\n   Call function to format the SMF record for WTO/printf */\nvoid dartn(SMFREC *sr,WTOLINE *dl) {\n\n int st03rtn(SMFREC *,char *);         /* Prototype function */\n int st70rtn(SMFREC *,char *);         /* Prototype function */\n int st72rtn(SMFREC *,char *);         /* Prototype function */\n unsigned short int len,subtype;\n char databuf\u00dd4096\u00a8;\n\n subtype=*((unsigned short int *)fth1.smf119hdsubtype); /*  Get SMF record subtype */\n\n if(subtype==smf119hdst_ftpclient) {   /* FTP client record ? */\n  st03rtn(sr,databuf);                 /* Yes, call subtype 3 function */\n }\n else if(subtype==smf119hdst_ftpserver) { /* FTP server record ? */\n  st70rtn(sr,databuf);                 /* Yes, call subtype 70 function */\n }\n else if(subtype==smf119hdst_ftplogonf) { /* FTP logon record  ? */\n  st72rtn(sr,databuf);                 /* Yes, call subtype 72 function */\n }\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n printf(\"%s\\n\",databuf);               /* Output the data */\n#endif\n\n strcpy(dl->line,databuf);             /* Copy data to output buffer */\n dl->len=strlen(dl->line);             /* Set length of data */\n\nreturn;\n}\n\n\n/* st03rtn()\n   Format SMF type 119 subtype 3 (FTP client) */\nint st03rtn(SMFREC *sr,char *currbuf) {\n\n FTIDENT *srid=0;                      /* TCPIP SMF record identification section */\n typedef struct {                      /* FTP Client Transfer Completion */\n  struct smf119ft_fc ftsfc;\n } FT_FC;\n FT_FC *srd1=0;\n#define ftfc srd1->ftsfc               /* Shortcut */\n\n typedef struct {                      /* FTP Client Transfer Completion Associated Dataset File Name */\n  struct smf119ft_fcan ftsfcan;\n } FT_FCAN;\n FT_FCAN *srd2=0;\n#define ftfcan srd2->ftsfcan           /* Shortcut */\n\n typedef struct {                      /* FTP Client Transfer Completion SOCKS section */\n  struct smf119ft_fcso ftsfcso;\n } FT_FCSO;\n FT_FCSO *srd3=0;\n#define ftfcso srd3->ftsfcso           /* Shortcut */\n\n unsigned short int len,tripleft;\n char ch1\u00dd255\u00a8,ch2\u00dd255\u00a8,ch3\u00dd80\u00a8,ch4\u00dd80\u00a8,\n  outfm\u00dd7\u00a8,outmo\u00dd11\u00a8,outst\u00dd5\u00a8,outdt\u00dd11\u00a8;\n\n tripleft=*((unsigned short int *)fth2.smf119sd_trn); /* Get no. of triples */\n\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth2.smf119idlen)) /* If length > 0 then set pointer to this triple */\n   srid=(FTIDENT *)((char *)sr+*((unsigned int *)fth2.smf119idoff));\n  tripleft-=1;                         /* Decrement triple count */\n }\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth2.smf119s1len)) /* If length > 0 then set pointer to this triple */\n   srd1=(FT_FC *)((char *)sr+*((unsigned int *)fth2.smf119s1off));\n  tripleft-=1;                         /* Decrement triple count */\n }\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth3.smf119s2len)) /* If length > 0 then set pointer to this triple */\n   srd2=(FT_FCAN *)((char *)sr+*((unsigned int *)fth3.smf119s2off));\n  tripleft-=1;                         /* Decrement triple count */\n }\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth4.smf119s3len)) /* If length > 0 then set pointer to this triple */\n   srd3=(FT_FCSO *)((char *)sr+*((unsigned int *)fth4.smf119s3off));\n  tripleft-=1;                         /* Decrement triple count */\n }\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */\n  \"%s \",testhdr(sr,ch1));\n currbuf+=len;                         /* Bump output buffer */\n#endif\n\n len=sprintf(currbuf,                  /* Format command */\n  \"%s %s%s \",\n  \"FTPC119-02I FTP Client\",\n  \"cm=\",mnb(ch1,ftfc.smf119ft_fccmd,sizeof(ftfc.smf119ft_fccmd)));\n currbuf+=len;                         /* Bump output buffer */\n\n /* APAR PQ80090 code */\n if(*((unsigned int *)ftfc.smf119ft_fclreply) > 4026531839) {\n  len=sprintf(currbuf,                  /* Format last reply */\n   \"%s%s \",\n   \"lr=\",mnb(ch1,ftfc.smf119ft_fclreply,sizeof(ftfc.smf119ft_fclreply)));\n  currbuf+=len;                         /* Bump output buffer */\n }\n else {\n  len=sprintf(currbuf,                  /* Format last reply */\n   \"%s%u \",\n   \"lr=\",*((unsigned int *)ftfc.smf119ft_fclreply));\n  currbuf+=len;                         /* Bump output buffer */\n }\n\n len=sprintf(currbuf,                  /* Format ports */\n  \"%s%u %s%u \",\n  \"cp=\",*((unsigned short int *)ftfc.smf119ft_fcclport),\n  \"cf=\",*((unsigned short int *)ftfc.smf119ft_fccrport));\n currbuf+=len;                         /* Bump output buffer */\n\n switch(ftfc.smf119ft_fctype) {        /* Format data format */\n  case smf119ft_fctypeascii: strcpy(outfm,\" ASCII\"); break;\n  case smf119ft_fctypeebcdic: strcpy(outfm,\" EBCDIC\"); break;\n  case smf119ft_fctypeimage: strcpy(outfm,\" Bin\"); break;\n  case smf119ft_fctypedbyte: strcpy(outfm,\" DBCS\"); break;\n  case smf119ft_fctypeucs2: strcpy(outfm,\" UCS-2\"); break;\n  default: sprintf(outfm,\" fm=%c\\0\",ftfc.smf119ft_fctype);\n }\n switch(ftfc.smf119ft_fcmode) {        /* Format mode */\n  case smf119ft_fcmodeblock: strcpy(outmo,\" Block\"); break;\n  case smf119ft_fcmodecmpress: strcpy(outmo,\" Cmprs\"); break;\n  case smf119ft_fcmodestream: strcpy(outmo,\" Stream\"); break;\n  default: sprintf(outmo,\" mo=%c\\0\",ftfc.smf119ft_fcmode);\n }\n switch(ftfc.smf119ft_fcstruct) {      /* Format structure */\n  case smf119ft_fcstructfile: strcpy(outst,\" File\"); break;\n  case smf119ft_fcstructrec: strcpy(outst,\" Rec\"); break;\n  default: sprintf(outst,\" st=%c\\0\",ftfc.smf119ft_fcstruct);\n }\n switch(ftfc.smf119ft_fcdstype) {      /* Format file type */\n  case smf119ft_fcdstypeseq: strcpy(outdt,\" Seq\"); break;\n  case smf119ft_fcdstypepds: strcpy(outdt,\" PDS\"); break;\n  case smf119ft_fcdstypehfs: strcpy(outdt,\" HFS\"); break;\n  default: sprintf(outdt,\" dt=%c\\0\",ftfc.smf119ft_fcdstype);\n }\n\n\n len=sprintf(currbuf,                  /* Format IP addrs, userid, file type flags, start time */\n  \"%s%s %s%s %s%s%s%s%s%s %s%s \",\n  \"sa=\",fmtipv6(ch1,sizeof(ch1),ftfc.smf119ft_fcclip),\n  \"sl=\",fmtipv6(ch2,sizeof(ch2),ftfc.smf119ft_fccrip),\n  \"su=\",\n  mnb(ch3,ftfc.smf119ft_fcruser,sizeof(ftfc.smf119ft_fcruser)),\n  outfm,outmo,outst,outdt,\n  \"trs=\",timrtn(ch4,*((unsigned int *)ftfc.smf119ft_fcstime)));\n currbuf+=len;                         /* Bump output buffer */\n\n len=sprintf(currbuf,                  /* Format rate, host name, userid, jobname */\n  \"%s %s%s %s%s %s%s\",\n  fmtrate(ch1,\n   *((unsigned long long *)ftfc.smf119ft_fcbytes),\n   *((unsigned int *)ftfc.smf119ft_fcdur)),\n  \"hst=\",mnb(ch4,ftfc.smf119ft_fchostname,sizeof(ftfc.smf119ft_fchostname)),\n  \"stc=\",mnb(ch2,ftfc.smf119ft_fcluser,sizeof(ftfc.smf119ft_fcluser)),\n  \"asn=\",mnb(ch3,ftid.smf119ti_asname,sizeof(ftid.smf119ti_asname)));\n currbuf+=len;                         /* Bump output buffer */\n\n if(srd3) {                            /* SOCKS triple present ? */\n  len=sprintf(currbuf,                 /* Format SOCKS information */\n   \" %s%s %s%s %s%u\",\n   \"sip=\",fmtipv6(ch1,sizeof(ch1),ftfcso.smf119ft_fccip),\n   \"spt=\",*((unsigned short int *)ftfcso.smf119ft_fccport),\n   \"spr=\",ftfcso.smf119ft_fccprot);\n  currbuf+=len;                        /* Bump output buffer */\n }\n\n if(srd2) {                            /* DSN triple present ? */\n  len=fmtdsn(currbuf,\" dsn=\",ftfcan.smf119ft_fcfilename,ftfc.smf119ft_fcm1,*((unsigned short int *)fth3.smf119s2len),sizeof(ftfc.smf119ft_fcm1)); /* Copy dataset name */\n  currbuf+=len;                        /* Bump output buffer */\n }\n\nreturn(0);\n}\n\n\n/* st70rtn()\n   Format SMF type 119 subtype 70 (FTP server) */\nint st70rtn(SMFREC *sr,char *currbuf) {\n\n FTIDENT *srid=0;                      /* TCPIP SMF record identification section */\n typedef struct {                      /* FTP Server Transfer Completion */\n  struct smf119ft_fs ftsfs;\n } FT_FS;\n FT_FS *srd1=0;\n#define ftfs srd1->ftsfs               /* Shortcut */\n\n typedef struct {                      /* FTP Server Transfer Completion Hostname */\n  struct smf119ft_fshn ftsfshn;\n } FT_FSHN;\n FT_FSHN *srd2=0;\n#define ftfshn srd2->ftsfshn           /* Shortcut */\n\n typedef struct {                      /* FTP Server Transfer Completion First Associated Dataset File Name */\n  struct smf119ft_fsa1 ftsfsa1;\n } FT_FSA1;\n FT_FSA1 *srd3=0;\n#define ftfsa1 srd3->ftsfsa1           /* Shortcut */\n\n typedef struct {\n  struct smf119ft_fsa2 ftsfsa2;        /* FTP Server Transfer Completion Second Associated Dataset File Name */\n } FT_FSA2;\n FT_FSA2 *srd4=0;\n#define ftfsa2 srd4->ftsfsa2           /* Shortcut */\n\n unsigned short int len,tripleft;\n char ch1\u00dd255\u00a8,ch2\u00dd255\u00a8,ch3\u00dd80\u00a8,ch4\u00dd80\u00a8,\n  outfm\u00dd7\u00a8,outmo\u00dd11\u00a8,outst\u00dd5\u00a8,outdt\u00dd11\u00a8;\n\n tripleft=*((unsigned short int *)fth2.smf119sd_trn); /* Get no. of triples */\n\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth2.smf119idlen)) /* If length > 0 then set pointer to this triple */\n   srid=(FTIDENT *)((char *)sr+*((unsigned int *)fth2.smf119idoff));\n  tripleft-=1;                         /* Decrement triple count */\n }\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth2.smf119s1len)) /* If length > 0 then set pointer to this triple */\n   srd1=(FT_FS *)((char *)sr+*((unsigned int *)fth2.smf119s1off));\n  tripleft-=1;                         /* Decrement triple count */\n }\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth3.smf119s2len)) /* If length > 0 then set pointer to this triple */\n   srd2=(FT_FSHN *)((char *)sr+*((unsigned int *)fth3.smf119s2off));\n  tripleft-=1;                         /* Decrement triple count */\n }\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth4.smf119s3len)) /* If length > 0 then set pointer to this triple */\n   srd3=(FT_FSA1 *)((char *)sr+*((unsigned int *)fth4.smf119s3off));\n  tripleft-=1;                         /* Decrement triple count */\n }\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth5.smf119s4len)) /* If length > 0 then set pointer to this triple */\n   srd4=(FT_FSA2 *)((char *)sr+*((unsigned int *)fth5.smf119s4off));\n  tripleft-=1;                         /* Decrement triple count */\n }\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */\n  \"%s \",testhdr(sr,ch1));\n currbuf+=len;                         /* Bump output buffer */\n#endif\n\n len=sprintf(currbuf,                  /* Format command, file type,last reply, ports */\n  \"%s %s%s %s%s %s%s %s%u %s%u \",\n  \"FTPC119-01I FTP Server\",\n  \"cm=\",mnb(ch1,ftfs.smf119ft_fscmd,sizeof(ftfs.smf119ft_fscmd)),\n  \"ty=\",mnb(ch2,ftfs.smf119ft_fsftype,sizeof(ftfs.smf119ft_fsftype)),\n  \"lr=\",mnb(ch3,ftfs.smf119ft_fslreply,sizeof(ftfs.smf119ft_fslreply)),\n  \"rp=\",*((unsigned short int *)ftfs.smf119ft_fscrport),\n  \"lp=\",*((unsigned short int *)ftfs.smf119ft_fsclport));\n currbuf+=len;                         /* Bump output buffer */\n\n if(memcmp(ftfs.smf119ft_fscmd,\"REN\",3)&&\n  memcmp(ftfs.smf119ft_fscmd,\"DELE\",4)) { /* Not rename/delete ? */\n  switch(ftfs.smf119ft_fstype) {       /* Format data format */\n   case smf119ft_fstypeascii: strcpy(outfm,\" ASCII\"); break;\n   case smf119ft_fstypeebcdic: strcpy(outfm,\" EBCDIC\"); break;\n   case smf119ft_fstypeimage: strcpy(outfm,\" Bin\"); break;\n   case smf119ft_fstypedbyte: strcpy(outfm,\" DBCS\"); break;\n   case smf119ft_fstypeucs2: strcpy(outfm,\" UCS-2\"); break;\n   default: sprintf(outfm,\" fm=%c\\0\",ftfs.smf119ft_fstype);\n  }\n  switch(ftfs.smf119ft_fsmode) {       /* Format mode */\n   case smf119ft_fsmodeblock: strcpy(outmo,\" Block\"); break;\n   case smf119ft_fsmodecmpress: strcpy(outmo,\" Cmprs\"); break;\n   case smf119ft_fsmodestream: strcpy(outmo,\" Stream\"); break;\n   default: sprintf(outmo,\" mo=%c\\0\",ftfs.smf119ft_fsmode);\n  }\n  switch(ftfs.smf119ft_fsstruct) {     /* Format structure */\n   case smf119ft_fsstructfile: strcpy(outst,\" File\"); break;\n   case smf119ft_fsstructrec: strcpy(outst,\" Rec\"); break;\n   default: sprintf(outst,\" st=%c\\0\",ftfs.smf119ft_fsstruct);\n  }\n  switch(ftfs.smf119ft_fsdsttype) {    /* Format file type */\n   case smf119ft_fsdstypeseq: strcpy(outdt,\" Seq\"); break;\n   case smf119ft_fsdstypepds: strcpy(outdt,\" PDS\"); break;\n   case smf119ft_fsdstypehfs: strcpy(outdt,\" HFS\"); break;\n   default: sprintf(outdt,\" dt=%c\\0\",ftfs.smf119ft_fsdsttype);\n  }\n }\n else {                                /* Else set nulls */\n  *outfm='\\0';\n  *outmo='\\0';\n  *outst='\\0';\n  *outdt='\\0';\n }\n\n len=sprintf(currbuf,                  /* Format IP addrs, userid, file type flags, start time */\n  \"%s%s %s%s %s%s%s%s%s%s %s%s\",\n  \"sa=\",fmtipv6(ch1,sizeof(ch1),ftfs.smf119ft_fsclip),\n  \"sl=\",fmtipv6(ch2,sizeof(ch2),ftfs.smf119ft_fscrip),\n  \"su=\",\n  mnb(ch3,ftfs.smf119ft_fssuser,sizeof(ftfs.smf119ft_fssuser)),\n  outfm,outmo,outst,outdt,\n  \"trs=\",timrtn(ch4,*((unsigned int *)ftfs.smf119ft_fsstime)));\n currbuf+=len;                         /* Bump output buffer */\n\n if(memcmp(ftfs.smf119ft_fscmd,\"REN\",3)&&\n  memcmp(ftfs.smf119ft_fscmd,\"DELE\",4)) { /* Not rename/delete ? */\n  len=sprintf(currbuf,                  /* Format rate */\n   \" %s\",\n   fmtrate(ch1,\n    *((unsigned long long *)ftfs.smf119ft_fsbytes),\n    *((unsigned int *)ftfs.smf119ft_fsdur)));\n  currbuf+=len;                        /* Bump output buffer */\n }\n\n if(srd2) {                            /* Hostname triple present ? */\n  len=sprintf(currbuf,\" hst=\");\n  currbuf+=len;                        /* Bump output buffer */\n  strncpy(currbuf,ftfshn.smf119ft_fshostname,*((unsigned short int *)fth3.smf119s2len)); /* Copy host name */\n  currbuf+=*((unsigned short int *)fth3.smf119s2len);\n  *currbuf=0;\n }\n\n if(srd3) {                            /* 1st DSN triple present ? */\n  len=fmtdsn(currbuf,\" dsn=\",ftfsa1.smf119ft_fsfilename1,ftfs.smf119ft_fsm1,*((unsigned short int *)fth4.smf119s3len),sizeof(ftfs.smf119ft_fsm1)); /* Copy 1st DSN */\n  currbuf+=len;                        /* Bump output buffer */\n  if(srd4) {                           /* 2nd DSN triple present ? */\n   len=fmtdsn(currbuf,\" ds2=\",ftfsa2.smf119ft_fsfilename2,ftfs.smf119ft_fsm2,*((unsigned short int *)fth5.smf119s4len),sizeof(ftfs.smf119ft_fsm2)); /* Copy 2nd DSN */\n   currbuf+=len;                       /* Bump output buffer */\n  }\n }\n\nreturn(0);\n}\n\n\n/* st72rtn()\n   Format SMF type 119 subtype 72 (FTP server logon failure) */\nint st72rtn(SMFREC *sr,char *currbuf) {\n\n FTIDENT *srid=0;                      /* TCPIP SMF record identification section */\n typedef struct {                      /* FTP Server Logon Failure */\n  struct smf119ft_ff ftsff;\n } FT_FF;\n FT_FF *srd1=0;\n #define ftff srd1->ftsff              /* Shortcut */\n\n unsigned short int len,tripleft;\n char ch1\u00dd255\u00a8,ch2\u00dd255\u00a8,ch3\u00dd80\u00a8;\n\n tripleft=*((unsigned short int *)fth2.smf119sd_trn); /* Get no. of triples */\n\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth2.smf119idlen)) /* If length > 0 then set pointer to this triple */\n   srid=(FTIDENT *)((char *)sr+*((unsigned int *)fth2.smf119idoff));\n  tripleft-=1;                         /* Decrement triple count */\n }\n if(tripleft) {                        /* Any more triples ? */\n  if(*((unsigned short int *)fth2.smf119s1len)) /* If length > 0 then set pointer to this triple */\n   srd1=(FT_FF *)((char *)sr+*((unsigned int *)fth2.smf119s1off));\n  tripleft-=1;                         /* Decrement triple count */\n }\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */\n  \"%s \",testhdr(sr,ch1));\n currbuf+=len;                         /* Bump output buffer */\n#endif\n\n len=sprintf(currbuf,                  /* Format ports */\n  \"%s %s%u %s%u \",\n  \"FTPC119-03I FTP Server cm=LOGN\",\n  \"lp=\",*((unsigned short int *)ftff.smf119ft_fflport),\n  \"rp=\",*((unsigned short int *)ftff.smf119ft_ffrport));\n currbuf+=len;                         /* Bump output buffer */\n\n len=sprintf(currbuf,                  /* Format IP addrs, userid failure reason */\n  \"%s%s %s%s %s%s %s%u\",\n  \"sa=\",fmtipv6(ch1,sizeof(ch1),ftff.smf119ft_ffrip),\n  \"sl=\",fmtipv6(ch2,sizeof(ch2),ftff.smf119ft_fflip),\n  \"su=\",\n  mnb(ch3,ftff.smf119ft_ffuserid,sizeof(ftff.smf119ft_ffuserid)),\n  \"reas=\",ftff.smf119ft_ffreason);\n currbuf+=len;                         /* Bump output buffer */\n\n switch(ftff.smf119ft_ffreason) {      /* Format failure reason text */\n  case smf119ft_ffreasoninvalid: strcpy(currbuf,\"(password not valid)\"); break;\n  case smf119ft_ffreasonexpired: strcpy(currbuf,\"(password expired)\"); break;\n  case smf119ft_ffreasonrevoked: strcpy(currbuf,\"(userid revoked)\"); break;\n  case smf119ft_ffreasonnoaccess: strcpy(currbuf,\"(no server access)\"); break;\n  case smf119ft_ffreasonexit: strcpy(currbuf,\"(FTCHKPWD rejected logon)\"); break;\n  case smf119ft_ffreasonexcess: strcpy(currbuf,\"(excessive bad passwords)\"); break;\n  case smf119ft_ffreasongroupid: strcpy(currbuf,\"(groupid process failed)\"); break;\n  case smf119ft_ffreasonunknown: strcpy(currbuf,\"(userid is unknown)\"); break;\n  default: ;\n }\n\nreturn(0);\n}\n\n\n/* fmtipv6()\n   Format an IP address in (either V4 or V6) */\nchar *fmtipv6(char *out,unsigned short int ilen,const char *in) {\n\n unsigned long long ipw1w2=*(unsigned long long *)in;\n unsigned int ipw3=*(((unsigned int *)in)+2);\n unsigned short int remlen=ilen,tlen;\n char *outpos=out;\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n struct hostent *hp=0;\n#endif\n\n if((!ipw1w2)&&(ipw3=65535)) {              /* IPv4 address ? */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n  if(runflag&rf_resolve)\n   hp=gethostbyaddr(((unsigned char *)in)+12,4,AF_INET);\n  if(hp) {\n   tlen=strlen(hp->h_name);\n   if(remlen>(tlen+1)) {\n    outpos+=sprintf(outpos,\"%s(\",hp->h_name);\n    remlen-=(tlen+1);\n   }\n  }\n  if(remlen>17) {\n#endif\n   outpos+=sprintf(outpos,                  /* Format IPv4 address */\n    \"%u.%u.%u.%u\",\n    *(((unsigned char *)in)+12),\n    *(((unsigned char *)in)+13),\n    *(((unsigned char *)in)+14),\n    *(((unsigned char *)in)+15));\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n   if(hp) outpos+=sprintf(outpos,\"%s\",\")\");\n  }\n#endif\n }\n else {                                     /* Else IPv6 address */\n  sprintf(outpos,\n   \"%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X\", /* Format IPv6 address */\n   *((unsigned short int *)in),\n   *(((unsigned short int *)in)+1),\n   *(((unsigned short int *)in)+2),\n   *(((unsigned short int *)in)+3),\n   *(((unsigned short int *)in)+4),\n   *(((unsigned short int *)in)+5),\n   *(((unsigned short int *)in)+6),\n   *(((unsigned short int *)in)+7));\n }\n\n return out;\n}\n\n\n/* fmtrate()\n   Format the duration and data transmission rate */\nchar *fmtrate(char *out,\n unsigned long long inbytes,\n unsigned int indur) {\n\n double dur=indur,bytes=inbytes,rate=0;\n char *outrate=\"kb/sec\",ch1\u00dd80\u00a8,*outpos=out;\n unsigned short int len;\n div_t x1;\n\n /* Maximum duration accepted is about 31 days to intercept\n    invalid durations prior to the fix for APAR PQ87028 */\n if(dur>0x0FFFFFFF) {                   /* > 31:01:39:14.55 ? */\n  dur=0;\n  len=sprintf(outpos,                   /* Format duration */\n   \"%s \",\n   \"dur=n/a\");\n }\n else {\n  len=sprintf(outpos,                   /* Format duration */\n   \"%s%s \",\n   \"dur=\",timrtn(ch1,(unsigned int)dur));\n }\n outpos+=len;                          /* Bump output area */\n\n if(dur) {                             /* duration > 0 ? */\n  rate=(bytes/(dur/100))/1000;         /* Set rate in kb/sec */\n  if(rate>=1000) {                     /* Rate > 1000 kb/sec */\n   rate/=1000;                         /* Yes, set rate in mb/sec */\n   outrate=\"mb/sec\";\n  }\n }\n\n sprntll(ch1,inbytes);                 /* Format 64 bit byte count */\n\n if(*ch1) {                            /* Running on z/Arch and returned value ? */\n  len=sprintf(outpos,\"%s%s \",\"tbc=\",ch1); /* On z/OS values up to 9223372036854775807 formatted correctly */\n }\n else {                                /* Else, not running on z/Arch so use old method */\n  if(*((unsigned int *)&inbytes)) {    /* Bytes > 4294967295 ? */\n/* Different code for EXITMODE and TESTMODE because\n   sprintf type FP cannot be used in SPC mode without\n   the library. APAR PQ45794 */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n   len=sprintf(outpos,\"%s%.2e \",\"tbc=\",bytes); /* > 4294967295 so in TESTMODE we can use sprintf FP formatting */\n#else\n   len=sprintf(outpos,\"tbc=(>4gb)\");   /* > 4294967295 but in EXITMODE we just cop out */\n#endif\n  }\n  else len=sprintf(outpos,\"%s%u \",\"tbc=\",*((unsigned int *)&inbytes+1)); /* < 4294967295 so format right half of 64 bit int */\n }\n outpos+=len;                          /* Bump output area */\n\n/* Different code for EXITMODE and TESTMODE because\n   sprintf type FP cannot be used in SPC mode without\n   the library. APAR PQ45794 */\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n if(rate>0) sprintf(outpos,\"%s%.2f%s\",\"rt=\",rate,outrate); /* Format rate */\n else strcpy(outpos,\"rt=n/a\");\n#else\n if(!(rate>0)||((rate*100)>UINT_MAX)) strcpy(outpos,\"rt=n/a\"); /* Rate*100 exceeds unsigned max ? */\n else {\n  x1=div(((unsigned int)(rate*100+.5)),100); /* Determine rate in SMF exit mode */\n  sprintf(outpos,\"%s%u.%02u%s\",\"rt=\",x1.quot,x1.rem,outrate); /* Format rate */\n }\n#endif\n\n return out;                           /* Return output string */\n}\n\n\n/* fmtdsn()\n   Format a dataset name and member */\nunsigned short int fmtdsn(char *out,const char *dsntag,const char *indsn,const char *inmem,unsigned short int dsnlen,unsigned short int memlen) {\n\n char *outpos=out,ch1\u00dd80\u00a8;\n unsigned short int len,len2=0;\n\n len=sprintf(outpos,dsntag);\n outpos+=len; len2+=len;\n\n strncpy(outpos,indsn,dsnlen);\n outpos+=dsnlen; len2+=dsnlen;\n\n/* 2005/06/06 Update for APAR PK01634 which added\n   blank filling */\n if(*inmem&&!(*inmem==' ')) {\n  len=sprintf(outpos,\n   \"%c%s%c\",\n   '(',mnb(ch1,inmem,memlen),')');\n  outpos+=len; len2+=len;\n }\n else *outpos=0;\n\n return len2;\n}\n\n\n#ifdef TESTMODE                        /* Compiled for TESTMODE? */\n/* ftpt119a()\n   TESTMODE entry function */\nint ftpt119a(int argc,char *argv\u00dd\u00a8) {\n\n int x=argc-1,retval=0;\n char *ptr;\n\n if(!x) return retval;                   /* return 0 if no switches */\n\n for(x=1;x<argc;x++) {                   /* loop through switches */\n  if((*argv\u00ddx\u00a8=='-')) {                  /* valid switch ? */\n   for(ptr=argv\u00ddx\u00a8+1;*ptr;ptr++) {       /* loop through each switch */\n    switch(*ptr) {                       /* select switches */\n     case '?':                           /* -? switch?*/\n      runflag|=rf_ques;                  /* set ques flag */\n      retval=-1;                         /* set err flag */\n      break;                             /* skip */\n     case 'r':                           /* resolve switch?*/\n      runflag|=rf_resolve;               /* set resolve flag */\n      break;                             /* skip */\n     case 'R':                           /* resolve switch?*/\n      runflag|=rf_resolve;               /* set resolve flag */\n      break;                             /* skip */\n     case 'e':                           /* echo switch?*/\n      runflag|=rf_echo;                  /* set echo flag */\n      break;                             /* skip */\n     case 'E':                           /* echo switch?*/\n      runflag|=rf_echo;                  /* set echo flag */\n      break;                             /* skip */\n     default:                            /* all else is error */\n      fprintf(stderr,\"FTPC119 - Invalid switch %s\\n\",ptr);\n      runflag|=rf_error;                 /* set err flag */\n      retval=-1;                         /* set err flag */\n    }\n    if(retval) break;             /* skip rest of switch if error */\n   }\n   if(retval) break;              /* skip remaining switches if error */\n  }\n  else {                                  /* not valid switch */\n   fprintf(stderr,\"FTPC119 - Invalid switch %s\\n\",argv\u00ddx\u00a8);\n   runflag|=rf_error;                 /* set err flag */\n   retval=-1;                         /* set err flag */\n   break;                        /* skip remaining switches if error */\n  }\n }                                       /* end loop through switches */\n\n if(retval) {                            /* switches OK ? */\n  if(!(runflag&rf_ques)) {               /* -? on ? */\n   fprintf(stderr,\"FTPC119 - Error in switches\\n\");\n  }\n  fprintf(stderr,\"FTPC119 - Switches: -re\\n\");\n }\n else {\n  if(runflag&rf_echo) {\n   printf(\"FTPC119 - SMF type 119 FTP batch print program\\n\");\n   if(runflag&rf_resolve)\n    printf(\"FTPC119 - resolve IP address switch is on\\n\");\n   else\n    printf(\"FTPC119 - resolve IP address switch is off\\n\");\n  }\n }\n\n return retval;\n}\n\n\n/* testhdr()\n   Add the system id and date/time to message for TESTMODE */\nchar *testhdr(SMFREC *sr,char *out) {\n\n char *currbuf=out,ch1\u00dd80\u00a8;\n unsigned short int len;\n div_t x1;\n struct tm tim;\n struct tm *datconv(int,int,struct tm *);\n\n x1=div(*((decimal(7,0) *)fth1.smf119hddate),1000); /* Get Juilan date stored in packed decimal format */\n datconv(x1.quot,x1.rem,&tim);         /* Convert date to C tm structure format */\n\n memcpy(currbuf,fth1.smf119hdsid,sizeof(fth1.smf119hdsid)); /* Copy system id */\n currbuf+=sizeof(fth1.smf119hdsid);    /* Bump output buffer */\n\n len=sprintf(currbuf,                  /* Format system id, date/time for TESTMODE */\n  \" %u/%02u/%02u %s\",\n  tim.tm_year+1900,tim.tm_mon+1,tim.tm_mday,\n  timrtn(ch1,*((unsigned int *)fth1.smf119hdtime)));\n currbuf+=len;                         /* Bump output buffer */\n\n return out;\n}\n\n\n/* datconv()\n   Convert a date from Julan format into C tm structure format */\nstruct tm *datconv(int yr,int jd,struct tm *tim) {\n\n char montab\u00dd12\u00a8={31,28,31,30,31,30,31,31,30,31,30,31};\n char monctr=0;\n int jdctr=1,dyctr=1;\n\n memset((char *)tim,'\\0',sizeof(tim)); /* Initialise tm structure */\n tim->tm_yday=jd-1;\n tim->tm_year=yr;\n yr+=1900;\n montab\u00dd1\u00a8+=__isleap(yr);        /* Set Feb to 29 days on leap years */\n\n for(;jdctr<=jd;dyctr++,jdctr++) {\n  tim->tm_mon=monctr;\n  tim->tm_mday=dyctr;\n  if(montab\u00ddmonctr\u00a8==dyctr) {\n   dyctr=0;\n   monctr++;\n  }\n }\n\n return tim;\n}\n#endif\n\n\n/* mnb()\n   Copy a space delimited string up to a max length */\nchar *mnb(char *out,const char *in,unsigned int len) {\n\n char *ptr1=out;\n\n for(;*in!=' '&&*in&&len;ptr1++,in++,len--) *ptr1=*in;\n *ptr1='\\0';\n\n return out;\n}\n\n\n/* timrtn()\n   Format a binary time in HH:MM:SS.TH format */\nchar *timrtn(char *tim_out,unsigned int tim_in) {\n\n div_t x1,x2,x3;\n\n x1=div(tim_in,60*60*100);\n x2=div(x1.rem,60*100);\n x3=div(x2.rem,100);\n sprintf(tim_out,\"%02u:%02u:%02u.%02u\\0\",\n  x1.quot,x2.quot,x3.quot,x3.rem);\n\n return tim_out;\n}\n\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "FTPC119C": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x1b\\x00\\x19\\x01\\x02'\\x1f\\x01\\x04\\x06\\x7f\\x13G\\x00;\\x003\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.27", "flags": 0, "createdate": "2002-09-28T00:00:00", "modifydate": "2004-03-07T13:47:19", "lines": 59, "newlines": 51, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWC  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(FTPC119C)\n//* JCL TO COMPILE FTPT119/FTPC119 (FTP SMF 119 WTO/PRINT)\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*   3) IF YOU HAVE THE LE DEBUGGER, INCLUDE THE TEST OPTION IN\n//*      THE COMP1 STEP\n//*   4) ON Z/OS 1.2 AND ABOVE, CHECK THE VERSION OF THE C COMPILER\n//*      YOU WISH TO USE. IN THIS JCL, SWITCHING BETWEEN THE\n//*      OS/390 R10 COMPILER AND THE Z/OS 1.2 COMPILER IS MERELY\n//*      A MATTER OF CHANGING THE JCLLIB STATEMENT.\n//*      AS OF FEBRUARY 2004 THIS IS THE DEFAULT COMPILER FOR THIS\n//*      MEMBER.\n//*   5) REFER TO DOC MEMBER $DOCFTPC OF (USERID).CBTXXX.FILE600.PDS\n//*      FOR INSTALLATION INSTRUCTIONS\n//*\n//*\n//*       JCLLIB ORDER=(SYS1.CBC.SCBCPRC)     OS/390 R10 COMPILER\n//        JCLLIB ORDER=(SYS1.CBC.SCCNPRC)     Z/OS 1.2 COMPILER\n//*\n//* COMP1 (NORMAL C COMPILE FOR FTPT119 - TESTING OR PRINTING SMF RECS)\n//* - COMPILE THE PROGRAM WITH OPTIONS FOR TESTING (SOURCE,TEST)\n//* - IF USING THE LE DEBUGGER, INCLUDE THE TEST COMPILE OPTION\n//* - THE TESTMODE SYMBOL IS PASSED TO THE COMPILER. THIS WILL\n//*   GENERATE PRINTF FUNCTIONS FOR TESTING AND SUPPRESS THE\n//*   SPC-TYPE LINKAGE AND FUNCTIONS.\n//* - THE RENT COMPILE OPTION IS USED TO ENABLE CONSTRUCTED\n//*   REENTRANCY FOR WRITABLE STATIC STORAGE.\n//* - THE OUTPUT OBJECT MODULE IS SAVED\n//*\n//COMP1    EXEC  EDCC,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          CPARM='SO,LIS,OF,EXP,RENT', ,TEST',\n//          CPARM2='DEF(TESTMODE),FLOAT(HEX)',\n//          SYSLBLK=,\n//          INFILE='AWCPAW.CBT.FILE600.C.PDS(FTPC119)',\n//          OUTFILE='AWCPAW.CBT.FILE600.OBJ.PDS(FTPT119),DISP=SHR'\n//COMPILE.USERLIB DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.C.PDS\n//*\n//* COMP2 (SYSTEMS PROGRAMMING C COMPILE FOR FTPC119 - SMF EXIT)\n//* - COMPILE THE PROGRAM WITH SPC OPTIONS (NOSTART).\n//* - THE TESTMODE SYMBOL IS NOT PASSED TO THE COMPILER. THIS WILL\n//*   GENERATE SPC-TYPE LINKAGE AND FUNCTIONS.\n//* - THE OUTPUT OBJECT MODULE IS SAVED\n//*\n//COMP2    EXEC  EDCC,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          CPARM='SO,LIS,OF,EXP,NOSTA',\n//          CPARM2='FLOAT(HEX)',\n//          SYSLBLK=,\n//          INFILE='AWCPAW.CBT.FILE600.C.PDS(FTPC119)',\n//          OUTFILE='AWCPAW.CBT.FILE600.OBJ.PDS(FTPC119),DISP=SHR'\n//COMPILE.USERLIB DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.C.PDS\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FTPC119L": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\r\\x00D\\x01\\x02'\\x1f\\x01\\x04\\x17O\\x139\\x002\\x00E\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.13", "flags": 0, "createdate": "2002-09-28T00:00:00", "modifydate": "2004-06-22T13:39:44", "lines": 50, "newlines": 69, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWL  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(FTPC119L)\n//* JCL TO PRELINK/LINK FTPT119/FTPC119 (FTP SMF 119 WTO/PRINT)\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*   3) REFER TO DOC MEMBER $DOCFTPC OF (USERID).CBTXXX.FILE600.PDS\n//*      FOR INSTALLATION INSTRUCTIONS\n//*\n//*\n//        JCLLIB ORDER=(SYS1.CEE.SCEEPROC)\n//*\n//* LINK1 (NORMAL C LINK FOR FTPT119 - TESTING OR PRINTING SMF RECORDS)\n//* - THE PROGRAM IS ASSUMED TO BE NATURALLY REENTRANT\n//* - THE OUTPUT LOAD MODULE IS SAVED IN A LINKLIST LIBRARY\n//*\n//LINK1    EXEC  EDCPL,\n//          LIBPRFX='SYS1.CEE',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP,RENT',\n//          INFILE='AWCPAW.CBT.FILE600.OBJ.PDS(FTPT119)',\n//          OUTFILE='AWCPAW.CBT.FILE600.LOAD(FTPT119),DISP=SHR'\n//LKED.SYSLIN DD\n//            DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.OBJ.PDS(SPRNTLL)\n//*\n//* LINK2 (SYSTEMS PROGRAMMING C LINK FOR FTPC119 - SMF EXIT)\n//* - THE PROGRAM IS ASSUMED TO BE NATURALLY REENTRANT\n//* - FOR SPC THE LINK EDIT SYSLIB MUST SPECIFY THE SCEESPC LIBRARY\n//*   AND THE EDCXSPRT AND EDCXMEM MUST BE EXPLICITLY INCLUDED.\n//* - THE OUTPUT LOAD MODULE IS SAVED IN A LINKLIST LIBRARY\n//*\n//LINK2    EXEC  EDCPL,\n//          LIBPRFX='SYS1.CEE',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP,RENT',\n//          INFILE='AWCPAW.CBT.FILE600.OBJ.PDS(FTPC119)',\n//          OUTFILE='AWCPAW.CBT.FILE600.LOAD,DISP=SHR'\n//LKED.SYSLIB DD DISP=SHR,DSN=SYS1.CEE.SCEESPC\n//            DD DISP=SHR,DSN=SYS1.CEE.SCEELKED\n//LKED.SYSIN DD *\n INCLUDE SYSLIB(EDCXSPRT)\n INCLUDE OBJECT\n ENTRY FTPC119\n NAME FTPC119(R)\n//LKED.OBJECT DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.OBJ.PDS(SPRNTLL)\n//            DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.OBJ.PDS(MLWTO)\n//            DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.OBJ.PDS(EDCXFGS)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FTPT118J": {"ttr": 269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x19\\x01\\x02&\\x7f\\x01\\x020\\x7f\\x10A\\x00\\x18\\x00\\x14\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-09-24T00:00:00", "modifydate": "2002-11-03T10:41:19", "lines": 24, "newlines": 20, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWTT JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(FTPT118J)\n//* JCL TO RUN SMF 118 FTP PROGRAM IN TESTMODE\n//* THIS JOB WILL PRINT THE SMF TYPE 118 FTP RECORDS TO THE SYSPRINT DD\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE STEPLIB AS NECESSARY OR COMMENT OUT FOR LINKLIB USE\n//*   3) CHANGE SMFDD DSN TO YOUR DSN OF SMF TYPE 118 RECORDS\n//*   4) DUMMY OUT THE SYSOUT DD STATEMENT IF RUNNING AGAINST\n//*      AN SMF TAPE RATHER THAN A SMF 118 EXTRACT. THIS PREVENTS\n//*      UNWANTED OUTPUT FOR EACH NON-FTP RECORD REJECTED.\n//*\n//*\n//FTPT118  EXEC PGM=FTPT118\n//STEPLIB  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.LOAD\n//SMFDD    DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.SMF118\n//SYSUDUMP DD  SYSOUT=*\n//CEEDUMP  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*,LRECL=512,RECFM=VB\n//SYSOUT   DD  SYSOUT=*\n//*SYSOUT   DD  DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FTPT119J": {"ttr": 517, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00Q\\x01\\x02&\\x7f\\x01\\x04\\x06\\x1f\\x14\\t\\x00\\x1e\\x00\\n\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "2002-09-24T00:00:00", "modifydate": "2004-03-01T14:09:51", "lines": 30, "newlines": 10, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWTT JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(FTPT119J)\n//* JCL TO RUN SMF 119 FTP PROGRAM IN TESTMODE\n//* THIS JOB WILL PRINT THE SMF TYPE 119 FTP RECORDS TO THE SYSPRINT DD\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE STEPLIB AS NECESSARY OR COMMENT OUT FOR LINKLIB USE\n//*   3) CHANGE SMFDD DSN TO YOUR DSN OF SMF TYPE 119 RECORDS\n//*   4) DUMMY OUT THE SYSOUT DD STATEMENT IF RUNNING AGAINST\n//*      AN SMF TAPE RATHER THAN A SMF 119 EXTRACT. THIS PREVENTS\n//*      UNWANTED OUTPUT FOR EACH NON-FTP RECORD REJECTED.\n//*   5) SET PROGRAM SWITCHES AS REQUIRED (SEE BELOW)\n//*\n//* PROGRAM SWITCHES (PARMS)\n//*   -R PERFORM HOST NAME RESOLUTION ON ALL IP ADDRESSES\n//*   -E ECHO SWITCH STATUS TO STDOUT\n//*\n//*\n//FTPT119  EXEC PGM=FTPT119,\n//          PARM='/-R'\n//STEPLIB  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.LOAD\n//SMFDD    DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.SMF119\n//SYSUDUMP DD  SYSOUT=*\n//CEEDUMP  DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*,LRECL=512,RECFM=VB\n//SYSOUT   DD  SYSOUT=*\n//*SYSOUT   DD  DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NICKNC": {"ttr": 513, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01+\\x00H\\x01\\x020\\x9f\\x01\\x04\\x06\\x1f\\x079\\x01\\xdd\\x01m\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.43", "flags": 0, "createdate": "2002-11-05T00:00:00", "modifydate": "2004-03-01T07:39:48", "lines": 477, "newlines": 365, "modlines": 0, "user": "AWCPAW"}, "text": "/**********************************************************************\n*\n*  Name: NICKNC  (C language source)\n*\n*\n*  Abstract:\n*\n*     A C language program to generate English nicknames. Use it to\n*     name your pets, mythical creatures in stories or even your kids!\n*\n*\n*  Operation:\n*\n*     Run the program in TSO, batch or USS.\n*\n*\n*  Environment:\n*\n*     IBM compatible mainframe\n*\n*     IBM OS/390, z/OS or subsequent operating system with C compiler\n*\n*     May well work on other platforms, but never tried\n*\n*\n*  Compilation:\n*\n*     Compile with the CCOMP compile member in\n*     userid.CBT.FILE600.C.PDS\n*\n*\n*  Installation:\n*\n*     Link edit with CPRELKDS (load library) or CPRELKHF (HFS) in\n*     userid.CBT.FILE600.C.PDS\n*\n*\n*  Invocation:\n*\n*     Usage: nicknc [-qnw -c nnnn -e nnnn\u00a8\n*            -q     quiet mode to suppress titles\n*            -n     no nicknames output (useful when debugging\n*                   rejected nicknames)\n*            -c     count of nicknames output\n*            -e     count of rejected nicknames output and overrides -c\n*\n*\n*  Notes:\n*\n*     This program was the first C program the author ever wrote\n*     and was created prior to the birth of my second daughter. She\n*     is named Saskia and nicknamed Sassy which was inspired by this\n*     very program.\n*\n*     The program is just a bit of fun and is not being maintained.\n*\n*\n*  Author: Paul Wells\n*          Saudi Aramco Box 12959\n*          Dhahran 31311\n*          Saudi Arabia\n*\n*  Email:  paul.wells@aramco.com\n*\n*\n*  History:\n*\n*     PW Aug/2000 - Original\n*\n*\n*\n**********************************************************************/\n#pragma title(\"NICKNC - Kids names/nicknames\")\n#pragma comment(copyright,\"NICKNC - \u00a9Paul Wells (Saudi Aramco) 2002\")\n\n#define CTR 100                          /* default no. of names */\n\n/* include header files for functions used */\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n\nchar l1ran\u00dd5\u00a8,                           /* 1st-5th sound(s) */\n l2ran\u00dd5\u00a8,l3ran\u00dd5\u00a8,l4ran\u00dd5\u00a8,l5ran\u00dd5\u00a8;\nchar *progname=\"nicknc\";\nchar runflag=0;                          /* run flags (Switches) */\n#define rf_namesoff 0x02                 /* no names switch */\n#define rf_quiet 0x04                    /* no header switch */\n#define rf_ctr 0x08                      /* count parameter passed */\n#define rf_ectr 0x10                     /* errcount parameter passed */\n#define rf_wrap 0x20                     /* wrap parameter passed */\n#define rf_ques 0x40                     /* -? passed */\nint count=CTR,errcount=0,errs;           /* counters */\n\n\n/* main program */\nint main(int argc,char *argv\u00dd\u00a8) {\n\n int setnames(void);                     /* get names function */\n int parseparms(int,char **);            /* parse switches function */\n time_t tim;                             /* seed for random() */\n int x;\n\n /*progname=argv\u00dd0\u00a8;*/                       /* save program name */\n\n if(parseparms(argc,argv)) {             /* switches OK ? */\n  if(!(runflag&rf_ques))                 /* -? on ? */\n   fprintf(stderr,\"%s Error in parameters\\n\",progname);\n  fprintf(stderr,\"Usage: %s \u00dd-qnw -c nnnn -e nnnn\u00a8\\n\",progname);\n  return -1;                             /* error RC if switches bad */\n }\n\n if(!(runflag&rf_quiet)) {               /* headers on ? */\n  printf(\"%s Nicknames by Paul Wells\\n\",progname);\n  if(errcount) {                         /* error count specified? */\n   if(!(runflag&rf_namesoff))            /* names also included? */\n    printf(\"%s %s\",progname,\"names to follow\\n\");\n   printf(\"%s %u errors are listed\\n\",progname,errcount);\n  }\n  else if(!(runflag&rf_namesoff))            /* names on ? */\n   printf(\"%s %u%s\",progname,count,\" names to follow\\n\");\n  printf(\"\\n\");\n }\n\n srandom(time(&tim));                   /* seed for random() */\n\n for(x=0; x!=count;) {                 /* main loop for count names */\n  if(errcount&&!(errs<errcount)) break;  /* error count reached ? */\n  if(!setnames()) x++;                   /* if name OK, inc ctr */\n }                                     /* end loop for count names */\n\n return(0);                              /* finished OK */\n\n}\n\n\n/* parse parameters function */\nint parseparms(int argc,char *argv\u00dd\u00a8) {\n\n int x=argc-1,retval=0;\n char *ptr;\n\n if(!x) return retval;                   /* return 0 if no switches */\n\n for(x=1;x<argc;x++) {                   /* loop through switches */\n  if((*argv\u00ddx\u00a8=='-')) {                  /* valid switch ? */\n   for(ptr=argv\u00ddx\u00a8+1;*ptr;ptr++) {       /* loop through each switch */\n    if(!strcmp(ptr,\"c\")) {               /* c switch on its own? */\n     if(runflag&rf_ectr) {\n      retval=1;                          /* set error */\n      fprintf(stderr,\"%s -e cannot coexist with -c \\n\",progname);\n      break;\n     }\n     if(runflag&rf_namesoff) {\n      retval=1;                          /* set error */\n      fprintf(stderr,\"%s -n cannot coexist with -c \\n\",progname);\n      break;\n     }\n     x++;                                /* inc switch count */\n     if(x<argc) {                     /* enough switches for count? */\n      count=strtoul(argv\u00ddx\u00a8,NULL,10); /* convert count */\n      if(!count) {                       /* any count ?*/\n       retval=1;                         /* err if no count */\n       fprintf(stderr,\"%s Invalid count %s \\n\",progname,argv\u00ddx\u00a8);\n      }\n      else {\n       runflag|=rf_ctr;                  /* set counter specified */\n      }\n     }\n     else {                              /* no count */\n      retval=1;                          /* set error */\n      fprintf(stderr,\"%s No count found for -c \\n\",progname);\n     }\n     break;                              /* skip rest of this switch */\n    }                                    /* end c switch */\n    else if(!strcmp(ptr,\"e\")) {        /* e switch on its own? */\n     x++;                                /* inc switch count */\n     if(runflag&rf_ctr) {\n      retval=1;                          /* set error */\n      fprintf(stderr,\"%s -c cannot coexist with -e \\n\",progname);\n      break;\n     }\n     if(x<argc) {                     /* enough switches for count? */\n      errcount=strtoul(argv\u00ddx\u00a8,NULL,10); /* convert err count */\n      count=4294967295;                  /* set max names count */\n      if(!errcount) {                    /* any count? */\n       retval=1;                         /* err if no count */\n       fprintf(stderr,\"%s Invalid err count %s \\n\",progname,argv\u00ddx\u00a8);\n      }\n      else {\n       runflag|=rf_ectr;                 /* set errcounter specified */\n      }\n     }\n     else {\n      retval=1;\n      fprintf(stderr,\"%s No err count found for -e \\n\",progname);\n     }\n     break;                              /* skip rest of this switch */\n    }                                    /* end e switch */\n    switch(*ptr) {                       /* select switches */\n     case '?':                           /* -? switch?*/\n      runflag|=rf_ques;                  /* set ques flag */\n      retval=1;                          /* set quit */\n      break;                             /* skip */\n     case 'w':                           /* wrap switch?*/\n      runflag|=rf_wrap;                  /* set wrap flag */\n      break;                             /* skip */\n     case 'n':                           /* no names switch?*/\n      runflag|=rf_namesoff;              /* set no names flag */\n      break;                             /* skip */\n     case 'q':                           /* quiet switch? */\n      runflag|=rf_quiet;                 /* set quiet flag */\n      break;                             /* skip */\n     default:                            /* all else is error */\n      fprintf(stderr,\"%s Invalid parameter %s \\n\",progname,ptr);\n      retval=1;\n    }\n    if(retval) break;                 /* skip rest of switch if error */\n   }\n   if(retval) break;             /* skip remaining switches if error */\n  }\n  else {                                  /* not valid switch */\n   fprintf(stderr,\"%s Invalid parameter %s \\n\",progname,argv\u00ddx\u00a8);\n   retval=1;                              /* set error flag */\n   break;                        /* skip remaining switches if error */\n  }\n }                                       /* end loop through switches */\n\n return retval;\n\n}\n\n\n/* generate names function */\nint setnames(void) {\n\n const char *randlet(const char **);      /* random letter function */\n int exceptions(void);                    /* weed out exceptions func */\n int retval,x;\n char nameout\u00dd14\u00a8,ptr;\n\n /* first consonant (optional) */\n const char *l1\u00dd\u00a8={\n  \"b\",\"bl\",\"br\",\"c\",\"ch\",\"cl\",\"cr\",\n  \"d\",\"dr\",\"f\",\"fl\",\"fr\",\n  \"g\",\"gr\",\"h\",\"j\",\"l\",\"m\",\"n\",\n  \"p\",\"pl\",\"pr\",\"qu\",\"r\",\"s\",\"sc\",\n  \"sh\",\"sl\",\"sp\",\"st\",\"sw\",\n  \"t\",\"tr\",\"v\",\"w\",\"y\",\"z\",\"\",\"\",\"\",\"\",\"\",\n  \"\\n\"\n };\n\n /* first vowel */\n const char *l2\u00dd\u00a8={\n  \"a\",\"e\",\"e\",\"ee\",\"i\",\"i\",\"o\",\"o\",\"oo\",\"u\",\n  \"\\n\"\n };\n\n /* second consonant (* denotes non-ender, @ is no \"e\" ender) */\n const char *l3\u00dd\u00a8={\n  \"b\",\"bb*@\",\"bl*\",\"br*@\",\"bs@\",\n  \"ch@\",\"cl*\",\"cr*@\",\"ck@\",\"cks@\",\n  \"d\",\"ds@\",\"dd*@\",\"dr*@\",\"f\",\"ff@\",\n  \"fl*\",\"fr*@\",\"g\",\"gl*\",\"gm*@\",\"gg*@\",\"gr*@\",\"gs@\",\n  \"j\",\"l\",\"lf@\",\"lg\",\"lk@\",\"ll@\",\"lls@\",\"lm@\",\n  \"lp@\",\"lt@\",\"m\",\"mm*@\",\"ms@\",\n  \"n\",\"nd@\",\"ng\",\"nk@\",\"nn*@\",\"ns@\",\"nt@\",\"p\",\n  \"pp*@\",\"ps@\",\"pl*\",\"pr*@\",\n  \"pt@\",\"qu*\",\"r\",\"rb@\",\"rd@\",\"rdg*@\",\"rf@\",\n  \"rg\",\"rk@\",\"rl@\",\"rm@\",\"rn@\",\"rp@\",\"rr*@\",\n  \"rs\",\"rt@\",\"rv\",\"s\",\"sc*@\",\"sh@\",\"sk@\",\"sl*\",\n  \"sp@\",\"ss@\",\"st@\",\"sw*@\",\"t\",\"tr*@\",\"tt*@\",\n  \"ts@\",\"v\",\"vv*@\",\"vl*\",\"vr*@\",\"w\",\"y\",\"z\",\"zz*@\",\n  \"\\n\"\n };\n\n /* second vowel (optional) */\n const char *l4\u00dd\u00a8={\n  \"a\",\"e\",\"e\",\"y\",\"y\",\"o\",\"oo\",\"\",\"\",\n  \"\\n\"\n };\n\n /* third consonant (optional - 1/4) */\n const char *l5\u00dd\u00a8={\n  \"b\",\"\",\"\",\"\",\"bs\",\"\",\"\",\"\",\"be\",\"\",\"\",\"\",\"ch\",\"\",\"\",\"\",\n  \"ck\",\"\",\"\",\"\",\"cks\",\"\",\"\",\"\",\n  \"d\",\"\",\"\",\"\",\"de\",\"\",\"\",\"\",\"ds\",\"\",\"\",\"\",\n  \"f\",\"\",\"\",\"\",\"g\",\"\",\"\",\"\",\"ge\",\"\",\"\",\"\",\"gs\",\"\",\"\",\"\",\n  \"dge\",\"\",\"\",\"\",\"l\",\"\",\"\",\"\",\"le\",\"\",\"\",\"\",\"ll\",\"\",\"\",\"\",\n  \"lls\",\"\",\"\",\"\",\"m\",\"\",\"\",\"\",\"me\",\"\",\"\",\"\",\"ms\",\"\",\"\",\"\",\n  \"n\",\"\",\"\",\"\",\"p\",\"\",\"\",\"\",\"pe\",\"\",\"\",\"\",\"ps\",\"\",\"\",\"\",\n  \"pt\",\"\",\"\",\"\",\"r\",\"\",\"\",\"\",\"re\",\"\",\"\",\"\",\"rk\",\"\",\"\",\"\",\"rs\",\"\",\"\",\"\",\n  \"s\",\"\",\"\",\"\",\"\",\"se\",\"\",\"\",\"\",\"sh\",\"\",\"\",\"\",\"sp\",\"\",\"\",\"\",\n  \"ss\",\"\",\"\",\"\",\"st\",\"\",\"\",\"\",\"t\",\"\",\"\",\"\",\"te\",\"\",\"\",\"\",\n  \"ts\",\"\",\"\",\"\",\"ve\",\"\",\"\",\"\",\"ves\",\"\",\"\",\"\",\"w\",\"\",\"\",\"\",\n  \"y\",\"\",\"\",\"\",\"z\",\"\",\"\",\"\",\"ze\",\"\",\"\",\"\",\n  \"\\n\"\n };\n\n strcpy(l1ran,randlet(l1));              /* get 1st sound */\n strcpy(l2ran,randlet(l2));              /* get 2nd sound */\n strcpy(l3ran,randlet(l3));              /* get 3rd sound */\n strcpy(l4ran,randlet(l4));              /* get 4th sound */\n\n /* if 4th is blank, 5th must be blank, else get a 5th sound */\n if (!strcmp(l4ran,\"\")) strcpy(l5ran,\"\");  /* - - - \"\" \"\" */\n else strcpy(l5ran,randlet(l5));\n\n /* uncomment these to fix letters for tests */\n /*strcpy(l1ran,\"\");\n strcpy(l2ran,\"ee\");\n strcpy(l3ran,\"gg*\");*/\n\n retval=exceptions();                    /* evaluate exceptions */\n\n if(retval) {                            /* word not OK ? */\n  if(errcount) {                         /* are we doing errors? */\n   fprintf(stderr,\"Error%u:%s%s%s%s%s \",\n    retval,l1ran,l2ran,l3ran,l4ran,l5ran);\n   errs++;                               /* inc err count */\n  }\n }\n else if(!(runflag&rf_namesoff)) {       /* are we doing names ? */\n  x=sprintf(nameout,\"%s%s%s%s%s\",l1ran,l2ran,l3ran,l4ran,l5ran);\n  if(!(runflag&rf_wrap)) printf(\"%s\\n\",nameout);\n  else {\n   for(;x<sizeof(nameout)-1;nameout\u00ddx\u00a8=' ',x++); /* pad with spaces */\n   nameout\u00ddx\u00a8='\\0';\n   printf(\"%s\",nameout);\n  }\n }\n\n return retval;                          /* return RC */\n\n}\n\n\n/* random sound function */\nconst char *randlet(const char **rlptr) {\n\n int element_count(const char **);       /* array element ctr func */\n int rand_mid(int,int);                  /* random no. generator */\n int ran;\n\n /* get random number in range of array */\n ran = rand_mid(1,element_count(rlptr)),ran--;\n\n return rlptr\u00ddran\u00a8;                      /* return ptr to sound */\n\n}\n\n\n/* weed out bad word forms, and strip special chars */\nint exceptions(void) {\n\n int strsame(char *);                 /* double letter finder func */\n char *strrmchr(char *,char);         /* remove char func */\n char *cptr;\n char flag=0;                            /* special chars flag */\n #define fl_3aster 0x01               /* non-ender spec char flag */\n #define fl_3at 0x02                  /* non \"e\" ender spec char flag */\n\n /* strip * and set flag */\n if (strchr(l3ran,'*')&&strrmchr(l3ran,'*')) flag|=fl_3aster;\n /* strip @ and set flag */\n if (strchr(l3ran,'@')&&strrmchr(l3ran,'@')) flag|=fl_3at;\n\n /* - - non-ender - \"\" */\n if ((flag&fl_3aster)&&!strcmp(l4ran,\"\")) return 1;\n\n /* - - w/y y - */\n if ((!strcmp(l3ran,\"y\")||!strcmp(l3ran,\"w\"))&&\n  !strcmp(l4ran,\"y\")) return 2;\n\n /* qu u - - - */\n if (!strcmp(l1ran,\"qu\")&&!strcmp(l2ran,\"u\")) return 3;\n\n /* - i/u w/y - - */\n if ((!strcmp(l3ran,\"y\")||!strcmp(l3ran,\"w\"))&&\n  (!strcmp(l2ran,\"i\")||!strcmp(l2ran,\"u\"))) return 4;\n\n /* - double-vowel double-consonant - - */\n if (strsame(l2ran)&&strsame(l3ran)) return 5;\n\n /* - - - double-vowel w/y */\n if ((strsame(l4ran))&&\n  (!strcmp(l5ran,\"y\")||!strcmp(l5ran,\"w\"))) return 6;\n\n /* - not-a/o w/y - \"\" */\n if ((!(!strcmp(l2ran,\"a\")||!strcmp(l2ran,\"o\")))&&\n  (!strcmp(l3ran,\"y\")||!strcmp(l3ran,\"w\"))&&\n  !strcmp(l5ran,\"\")) return 7;\n\n/* - - - y y/w */\n  if (!strcmp(l4ran,\"y\")&&\n  (!strcmp(l5ran,\"y\")||!strcmp(l5ran,\"w\"))) return 8;\n\n/* - - double e \"\" */\n if ((flag&fl_3at)&&\n  !strcmp(l4ran,\"e\")&&!strcmp(l5ran,\"\")) return 9;\n\n /* - double-vowel w/y - - */\n if ((strsame(l2ran))&&\n  (!strcmp(l3ran,\"y\")||!strcmp(l3ran,\"w\"))) return 10;\n\n/* - - - y non-blank */\n  if (!strcmp(l4ran,\"y\")&&strcmp(l5ran,\"\"))\n   strcpy(l4ran,\"i\");\n\n/* - - j \"\" \"\" */\n  if (!strcmp(l3ran,\"j\")&&!strcmp(l4ran,\"\"))\n   strcpy(l3ran,\"dge\");\n\n/* - - j not-\"\" - */\n  if (!strcmp(l3ran,\"j\")&&strcmp(l4ran,\"\"))\n   strcpy(l3ran,\"dg\");\n\n/* - double-vowel ck(s) - - */\n if (strsame(l2ran)&&!memcmp(l3ran,\"ck\",2))\n  strcpy(l3ran,l3ran+1);\n\n/* - - - double-vowel ck(s) */\n if (strsame(l4ran)&&!memcmp(l5ran,\"ck\",2))\n  strcpy(l3ran,l3ran+1);\n\n /* if first sound blank, point to second sound for case change */\n (*l1ran) ? (cptr=l1ran) : (cptr=l2ran);\n ('A'==0xC1) ? (*cptr|=0x40) : (*cptr-=32); /*upper EBCDIC/ASCII*/\n\n return 0;                               /* return OK */\n\n}\n\n/* array element counter */\nint element_count(const char **arptr) {\n\n int i=0;\n for(; strcmp(arptr\u00ddi\u00a8,\"\\n\"); i++);\n return i;\n\n}\n\n\n/* double letter detector */\nint strsame(char *srptr) {\n\n int sr=1;\n char *ptr=srptr+1;\n for(; sr&&(*srptr)&&(*ptr); ptr++) sr=(*ptr!=*srptr);\n return !sr;\n\n}\n\n\n/* random number in range generator */\nint rand_mid(int low,int high) {\n\n return low+random()%(high-low+1);\n\n}\n\n\n/* remove a character from string */\nchar *strrmchr(char *string,char target) {\n\n char *ptr,*str_begin=string;\n\n for(ptr=string; *string; string++)\n  if(*string!=target) *ptr++=*string;\n *ptr='\\0';\n\n return str_begin;\n\n}\n\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "NICKNCJ": {"ttr": 285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00F\\x01\\x020\\x9f\\x01\\x020\\x9f\\x104\\x00\\x17\\x00\\x14\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-11-05T00:00:00", "modifydate": "2002-11-05T10:34:46", "lines": 23, "newlines": 20, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWG  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,                   JOB62512\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(NICKNCJ)\n//* PRELINK/LINK/RUN NICKNC - KIDS NAMES PROGRAM\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*\n//*\n//        JCLLIB ORDER=(SYS1.CBC.SCBCPRC)\n//*\n//LINK     EXEC  EDCPL,\n//          LIBPRFX='SYS1.CEE',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP',\n//          INFILE='AWCPAW.CBT.FILE600.OBJ.PDS(NICKNC)'\n//*\n//NICKNC   EXEC PGM=*.LINK.LKED.SYSLMOD,COND=(0,NE)\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n//CEEDUMP  DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMFX118J": {"ttr": 271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00&\\x01\\x02'_\\x01\\x020\\x7f\\x10A\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-10-02T00:00:00", "modifydate": "2002-11-03T10:41:26", "lines": 27, "newlines": 27, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWSR JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(SMFX118J)\n//* EXTRACTS SMF TYPE 118 FTP SUBTYPES TO A DATASET\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL ZAZUO.DISK.ZUTA2 TO YOUR SMF TAPE DATASET NAME\n//*\n//SORTSMF  EXEC PGM=SORT\n//SYSOUT   DD  SYSOUT=*\n//SORTIN   DD  DISP=SHR,DSN=ZAZUO.DISK.ZUTA2\n//SORTOUT  DD  DISP=(MOD,CATLG),UNIT=SYSALLDA,\n//          SPACE=(TRK,(100,100),RLSE),\n//          RECFM=VB,LRECL=27994,DSORG=PS,\n//          DSN=AWCPAW.CBT.FILE600.SMF118\n//SYSIN    DD  *\n INCLUDE COND=((6,1,CH,EQ,X'76'),&,\n               ((24,1,CH,EQ,X'03'),|,\n                (24,1,CH,EQ,X'46'),|,\n                (24,1,CH,EQ,X'47'),|,\n                (24,1,CH,EQ,X'48'),|,\n                (24,1,CH,EQ,X'49'),|,\n                (24,1,CH,EQ,X'4A'),|,\n                (24,1,CH,EQ,X'4B')))\n OPTION COPY,VLSHRT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMFX119J": {"ttr": 273, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00(\\x01\\x02'_\\x01\\x020\\x7f\\x10A\\x00\\x17\\x00\\x1b\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-10-02T00:00:00", "modifydate": "2002-11-03T10:41:28", "lines": 23, "newlines": 27, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWSR JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(SMFX119J)\n//* EXTRACTS SMF TYPE 119 FTP SUBTYPES TO A DATASET\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL ZAZUO.DISK.ZUTA2 TO YOUR SMF TAPE DATASET NAME\n//*\n//SORTSMF  EXEC PGM=SORT\n//SYSOUT   DD  SYSOUT=*\n//SORTIN   DD  DISP=SHR,DSN=ZAZUO.DISK.ZUTA2\n//SORTOUT  DD  DISP=(MOD,CATLG),UNIT=SYSALLDA,\n//          SPACE=(TRK,(100,100),RLSE),\n//          RECFM=VB,LRECL=27994,DSORG=PS,\n//          DSN=AWCPAW.CBT.FILE600.SMF119\n//SYSIN    DD  *\n INCLUDE COND=((6,1,CH,EQ,X'77'),&,\n               ((24,1,CH,EQ,X'03'),|,\n                (24,1,CH,EQ,X'46'),|,\n                (24,1,CH,EQ,X'48')))\n OPTION COPY,VLSHRT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPRNTLLC": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00A\\x01\\x02&o\\x01\\x04\\tO\\x08)\\x00\\x1e\\x00\\x1d\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2002-09-23T00:00:00", "modifydate": "2004-04-03T08:29:41", "lines": 30, "newlines": 29, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWC  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(SPRNTLLC)\n//* JCL TO COMPILE/RUN SPRNTLLT (C SPRNTLL FUNCTION TEST PROGRAM)\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*\n//*\n//*       JCLLIB ORDER=(SYS1.CBC.SCBCPRC)     OS/390 R10 COMPILER\n//        JCLLIB ORDER=(SYS1.CBC.SCCNPRC)     Z/OS 1.2 COMPILER\n//*\n//* COMP1\n//* - COMPILE THE PROGRAM WITH OPTIONS FOR TESTING (SOURCE,TEST)\n//* - THE PROGRAM IS ASSUMED TO BE NATURALLY REENTRANT\n//* - THE OUTPUT LOAD MODULE IS NOT SAVED\n//* - THE PROGRAM IS RUN IN THE GO STEP\n//*\n//COMP1    EXEC  EDCCPLG,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          CPARM='SOURCE,LIST,OF,EXPMAC,TEST',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP,RENT',\n//          INFILE='AWCPAW.CBT.FILE600.C.PDS(SPRNTLLT)',\n//          PARM.GO='RPTSTG(ON)/'\n//LKED.SYSLIN DD\n//            DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.OBJ.PDS(SPRNTLL)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPRNTLLT": {"ttr": 275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00B\\x01\\x02&o\\x01\\x020\\x7f\\x10A\\x00H\\x00\\x19\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2002-09-23T00:00:00", "modifydate": "2002-11-03T10:41:42", "lines": 72, "newlines": 25, "modlines": 0, "user": "AWCPAW"}, "text": "#pragma title(\"SPRNTLLT - sprntll() function test program\")\n#pragma comment(copyright,\"SPRNTLLT - \u00a9Paul Wells (Saudi Aramco) 2002\")\n\n/**********************************************************************\n*\n*  Name: SPRNTLLT (C langauage source)\n*\n*  Abstract:\n*\n*     A simple program to test/demonstrate the sprntll() assembler\n*     function.\n*\n*  Operation:\n*\n*     There are no parameters. The program runs and calls sprntll()\n*     to format the max and min 64 bit signed integers. It then\n*     printf's the results.\n*\n*\n*  Environment:\n*\n*     IBM compatible mainframe\n*\n*     IBM OS/390, z/OS or subsequent operating system with C compiler\n*\n*  Invocation:\n*\n*     Use sample JCL AWCPAW.CBT.FILE600.C.PDS(SPRNTLLC) to compile and\n*     run the program. Object module SPRNTLL is included at link-edit.\n*\n*\n*  Author: Paul Wells\n*          Saudi Aramco Box 12959\n*          Dhahran 31311\n*          Saudi Arabia\n*\n*  Email:  paul.wells@aramco.com\n*\n*  History:\n*\n*     PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************/\n\n\n#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\nvoid sprntll(char *out,long long lli);\n\nint main() {\n\n long long lli1=LONGLONG_MAX;\n long long lli2=LONGLONG_MIN;\n long long lli3=0;\n char ch1\u00dd21\u00a8,ch2\u00dd21\u00a8,ch3\u00dd21\u00a8;\n\n sprntll(ch1,lli1);\n sprntll(ch2,lli2);\n sprntll(ch3,lli3);\n\n printf(\"%s%s\\n%s%s\\n%s%s\",\n  \"SPRNTLL - Max 64 bit signed integer=\",ch1,\n  \"SPRNTLL - Min 64 bit signed integer=\",ch2,\n  \"SPRNTLL - Zero=\",ch3);\n\nreturn(0);\n}\n\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TITLE": {"ttr": 261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00!\\x01\\x02'?\\x01\\x02(\\x1f\\x13 \\x000\\x004\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-09-30T00:00:00", "modifydate": "2002-10-08T13:20:21", "lines": 48, "newlines": 52, "modlines": 0, "user": "AWCPAW"}, "text": "#pragma title(\"xxxxxxx - xxxxxxxxxxxxxxxxxxxxxxxxxxxx\")\n#pragma comment(copyright,\"xxxxxxx - \u00a9Saudi Aramco 2002\")\n\n/**********************************************************************\n*\n*  Name: xxxxxxxxxxxxx\n*\n*  Abstract:\n*\n*     xxxxxxxxxxxx\n*\n*  Operation:\n*\n*     xxxxxxxxxxxxx\n*\n*  Environment:\n*\n*     IBM compatible mainframe\n*\n*     IBM OS/390, z/OS or subsequent operating system with C compiler\n*\n*  Invocation:\n*\n*     xxxxxxxxxxxxxxxxx\n*\n*\n*  Notes:\n*\n*     Writeable static variables cannot be used in SPC mode because it\n*     violates reentrancy. This type of variable is statically linked\n*     into the program and if modified in SPC mode, an abend0c4 will\n*     result.\n*\n*\n*  Author: Paul Wells\n*          Saudi Aramco Box 12959\n*          Dhahran 31311\n*          Saudi Arabia\n*\n*  Email:  paul.wells@aramco.com\n*\n*  History:\n*\n*     PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************/\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "TITLEJ": {"ttr": 277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00G\\x01\\x02&\\x7f\\x01\\x020\\x7f\\x10A\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-09-24T00:00:00", "modifydate": "2002-11-03T10:41:47", "lines": 11, "newlines": 11, "modlines": 0, "user": "AWCPAW"}, "text": "//*\n//* AWCPAW.CBT.FILE600.C.PDS(XXXXXXXX)\n//* XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE ALL SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*   3) XXXXXXXXXXXXX\n//*   4) XXXXXXXXXXXXX\n//*\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WTOT": {"ttr": 279, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00T\\x01\\x02&\\x1f\\x01\\x020\\x7f\\x10A\\x00N\\x00\\x16\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2002-09-18T00:00:00", "modifydate": "2002-11-03T10:41:54", "lines": 78, "newlines": 22, "modlines": 0, "user": "AWCPAW"}, "text": "#pragma title(\"WTOT - mlwto() function test program\")\n#pragma comment(copyright,\"WTOT - \u00a9Paul Wells (Saudi Aramco) 2002\")\n\n/**********************************************************************\n*\n*  Name: WTOT (C langauage source)\n*\n*  Abstract:\n*\n*     A simple program to test/demonstrate the mlwto() assembler\n*     function.\n*\n*  Operation:\n*\n*     There are no parameters. The program runs and calls mwlto()\n*     to demonstrate both single and multi line WTOs.\n*\n*\n*  Environment:\n*\n*     IBM compatible mainframe\n*\n*     IBM OS/390, z/OS or subsequent operating system with C compiler\n*\n*  Invocation:\n*\n*     Use sample JCL AWCPAW.CBT.FILE600.C.PDS(WTOTC) to compile and\n*     run the program. Object module MLWTO is included at link-edit.\n*\n*\n*  Author: Paul Wells\n*          Saudi Aramco Box 12959\n*          Dhahran 31311\n*          Saudi Arabia\n*\n*  Email:  paul.wells@aramco.com\n*\n*  History:\n*\n*     PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************/\n\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n unsigned short int len;\n char line\u00dd200\u00a8;\n} WTOLINE;\n\nvoid mlwto(WTOLINE *dl);               /* External mlwto() function */\n\nint main() {\n\n WTOLINE *dl;\n const char str1\u00dd\u00a8=\"MLWTO - This is a single line WTO \";\n const char str2\u00dd\u00a8=\"MLWTO - This is a multi line WTO \";\n\n dl=malloc(sizeof(WTOLINE));           /* Getmain storage for WTOs */\n\n strcpy(dl->line,str1);                /* Copy SLWTO string */\n dl->len=strlen(dl->line);             /* Set length */\n mlwto(dl);                            /* Call WTO function */\n\n for(strcpy(dl->line,str2);\n  sizeof(dl->line)-strlen(dl->line)>sizeof(str2);\n  strcat(dl->line,str2));              /* Build MLWTO string */\n dl->len=strlen(dl->line);             /* Set length */\n mlwto(dl);                            /* Call WTO function */\n\n free(dl);                             /* Free storage for WTO */\n\nreturn(0);                             /* finished OK */\n}\n\n\n", "mimetype": "text/x-c", "datatype": "ebcdic", "extension": ".x-c"}, "WTOTC": {"ttr": 281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00X\\x01\\x02&o\\x01\\x020\\x7f\\x10A\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2002-09-23T00:00:00", "modifydate": "2002-11-03T10:41:58", "lines": 29, "newlines": 29, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWC  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.C.PDS(WTOTC)\n//* JCL TO COMPILE/RUN WTOT (C MLWTO FUNCTION TEST PROGRAM)\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*\n//*\n//        JCLLIB ORDER=(SYS1.CBC.SCBCPRC)\n//*\n//* COMP1\n//* - COMPILE THE PROGRAM WITH OPTIONS FOR TESTING (SOURCE,TEST)\n//* - THE PROGRAM IS ASSUMED TO BE NATURALLY REENTRANT\n//* - THE OUTPUT LOAD MODULE IS NOT SAVED\n//* - THE PROGRAM IS RUN IN THE GO STEP\n//*\n//COMP1    EXEC  EDCCPLG,\n//          LIBPRFX='SYS1.CEE',\n//          LNGPRFX='SYS1.CBC',\n//          CPARM='SOURCE,LIST,OF,EXPMAC,TEST',\n//          PPARM='NOER',\n//          LPARM='AMODE=31,MAP,RENT',\n//          INFILE='AWCPAW.CBT.FILE600.C.PDS(WTOT)',\n//          PARM.GO='RPTSTG(ON)/'\n//LKED.SYSLIN DD\n//            DD DISP=SHR,DSN=AWCPAW.CBT.FILE600.OBJ.PDS(MLWTO)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT600/CBT.V500.FILE600.PDS/XMITPDSC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT600/CBT.V500.FILE600.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}