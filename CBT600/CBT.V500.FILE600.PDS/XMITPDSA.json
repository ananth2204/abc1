{"INMR01": {"INMLRECL": 80, "INMFNODE": "NODENAME", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20060221145123000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 352716, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "SBGOLOB.PWELLS.FILE600.ASM", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 352716, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SBGOLOB.PWELLS.FILE600.ASM": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12304, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 1113, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "060052", "DS1SCEXT": "b'\\x80m\\x10'", "DS1SCALO": "b'P\\x00\\x00\\x04'", "DS1LSTAR": "b'\\x00\\x07\\x06'", "DS1TRBAL": "b'\\x0b\\x8e'"}, "COPYR2": {"deb": "b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f[p\\x00\\x04\\x88\\xfd`'", "extents": ["b'\\x02\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f[p\\x00\\x04\\x88\\xfd`'", "b'X\\xf36\\xe0\\x00\\x00\\x00,\\x00\\t\\x00-\\x00\\x00\\x00\\x07'", "b'X\\xf36\\xe0\\x00\\x00\\x00-\\x00\\x01\\x00-\\x00\\x02\\x00\\x02'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$NOTE1": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00T\\x01\\x06\\x05/\\x01\\x06\\x05/\\tG\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-02-21T00:00:00", "modifydate": "2006-02-21T09:47:54", "lines": 16, "newlines": 16, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:     HPNSTST Fix\nFrom:        mjt6@daimlerchrysler.com\nDate:        Mon, 20 Feb 2006 11:35:09 -0500\nTo:          sbgolob@cbttape.org\n\nHi Sam,\n\nIt was a pleasure speaking with you.\n\nThe below attachments contain the assembler source and the SUPERC\noutput list for the HPNSTST program from Paul Wells.  I didn't\nadd any comments to the prolog in the source regarding the\nchange.\n\nWarmest Regards, Mike\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$README": {"ttr": 10, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x08\\x01\\x020?\\x01\\x020?\\t(\\x00\\x04\\x00\\x04\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-30T00:00:00", "modifydate": "2002-10-30T09:28:08", "lines": 4, "newlines": 4, "modlines": 0, "user": "AWCPAW"}, "text": "\nPlease see the README in the installation PDS -\n      (userid).CBTxxx.FILE600.PDS\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$CONTACT": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x005\\x01\\x02'_\\x01\\x05\\x15o\\x12X\\x00:\\x00$\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-10-02T00:00:00", "modifydate": "2005-06-05T12:58:35", "lines": 58, "newlines": 36, "modlines": 0, "user": "AWCPAW"}, "text": "\nAuthor contact details as follows.\n\nName      : Paul Wells\n\nAddress   : Saudi Aramco Box 12959\n            Dhahran 31311\n            Saudi Arabia\n\nTelephone : +966 3 873 3155 (Work - direct line)\n\nFax       : +966 3 873 8958 (Work)\n\nEmail     : Paul.Wells@aramco.com\n\n\nAnyone who thinks they remember me from places where I have worked\nin the past, and wish to renew acquaintances, please do.\nMy brief history as an MVS sysprog (since 1987) is as follows.\n\n2000-present : Saudi Aramco, Dhahran, Saudi Arabia.\n               OS/390 2.5/2.9, z/OS 1.2, z/OS 1.4\n\n1998-2000    : Ladbroke Racing, Rayners Lane, London, UK.\n               MVS 4.2/5.1, OS/390 2.5\n\n1996-1998    : Cap Gemini, Wandsworth Road, London, UK.\n               MVS 4.3, MVS 5.2.2, OS/390 2.4\n\n1994-1996    : ECSoft Synapse, Berkhamsted, UK.\n               Customer sites:-\n\n             : TNT Worldwide, Atherstone, UK.\n               MVS 4.3, OS/390 1.1\n\n             : Polygram, Romford, UK.\n               MVS 4.3/5.2.2\n\n             : Whitbread, Luton, UK.\n               MVS 4.3\n\n             : NPI, Tunbridge Wells, UK.\n               MVS 4.3\n\n1987-1994    : Tesco Stores, Cheshunt, UK.\n               MVS 2.1.7/2.2/3.1.3/4.3\n\n1985-1986    : Whitbread, Reading, UK.\n\n\nFootnote\n--------\nMy employer's mainframe is due to be decommissioned at the end of 2006.\nAfter this time, I will most likely be unable to maintain the\nsubmissions for CBT tape file 600. It will be with sadness and regret\nthat I bid farewell to the venerable mainframe which has been my\nbread and butter for nearly 20 years!\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INDEX": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x03\\x01\\x02(\\x9f\\x01\\x03\\t\\x0f\\x140\\x00\\x17\\x00)\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "2002-10-16T00:00:00", "modifydate": "2003-03-31T14:30:03", "lines": 23, "newlines": 41, "modlines": 0, "user": "AWCPAW"}, "text": "INDEX OF MEMBERS IN AWCPAW.CBT.FILE600.ASM.PDS\n----------------------------------------------\n\n$CONTACT - Contact details for the author\n$INDEX   - This member\nANFUXMSG - Improved WTO message exit for IBM Infoprint server.\nASMOBJ   - JCL to assemble and save object for assembler programs.\nASMLKED  - JCL to assemble/link assembler programs.\nEDCXFGS  - Assembler source for storage allocation routines in SPC.\nFTPCTST  - Assembler source for FTPCTST - an assembler program to invoke\n           FTPC118/FTPC119 directly to simulate the SMF exit mode\n           of operation for these programs.\nFTPCTSTJ - JCL to run FTPCTST using SMF input.\nHPNSTST  - Assembler source for HPNSTST - A program to 'IVP' the\n           TCPIP HPNS API.\nHPNSTSTJ - JCL to run HPNSTST.\nMLWTO    - Assembler source for MLWTO - a C function to issue WTOs\n           (single or multi-line).\nSPRNTLL  - Assembler source for SPRNTLL - a C function to format\n           a 64 bit signed integer.\nTITLE    - ASM title copy member.\nTITLEJ   - JCL title copy member.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ANFUXMSG": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00Y\\x01\\x020\\x8f\\x01\\x04\\x06/\\x14\\x04\\x01Z\\x01O\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2002-11-04T00:00:00", "modifydate": "2004-03-02T14:04:59", "lines": 346, "newlines": 335, "modlines": 0, "user": "AWCPAW"}, "text": "         TITLE 'ANFUXMSG - Infoprint Server Message Exit'\n***********************************************************************\n*\n* Name: ANFUXMSG\n*\n* Abstract:\n*\n*    Message exit for the IBM Infoprint Server product.\n*    IBM's sample performs a similar function but it makes no\n*    effort to format the messages according to their length and\n*    content.\n*\n* Operation:\n*\n*    Receives log message from product and allows it to\n*    be written to the product's dataset log and also\n*    WTOs the message out to the console.\n*\n*    The format of the WTO depends on the length of the message.\n*    A message of 126 chars or less will generate a standard WTO,\n*    whereas a longer message will generate an MLWTO split\n*    into lines of 71 chars. Processing ensures that words\n*    of the message are not split over 2 lines.\n*\n*    Messages can also be suppressed via this exit. (see\n*    SUPMSGE)\n*\n* Environment:\n*\n*    IBM compatible mainframe (branch relative/immediate instructions\n*    must be supported)\n*\n*    IBM OS/390, z/OS or subsequent operating system\n*\n*    IBM Infoprint Server product\n*\n* Assembly:\n*\n*    Use (userid).CBTxxx.FILE600.ASM.PDS(ASMLKED) or similar to\n*    assemble and link this program.\n*\n* Invocation:\n*\n*    Place the module in the linklist and Infoprint Server will find\n*    it.\n*\n* Notes:\n*\n*    The assembler code does not use a base register, so the\n*    relative/immediate forms of branch instructions must be used.\n*\n*\n* Author: Paul Wells\n*         Saudi Aramco Box 12959\n*         Dhahran\n*         Saudi Arabia\n*\n* Email:  paul.wells@aramco.com\n*\n* History:\n*\n*    PW 22/Feb/2002 - Original\n*    PW 02/Mar/2004 - Fixed bug in GETLEN routine which caused\n*                     line length to sometimes be out by 1\n*\n*\n***********************************************************************\n*\n         MACRO\n.* Set CSECT eyecatcher\n&NAME    @ID   &@IDN\n&NAME    J     @LAB&SYSNDX\n         DC    AL1(@LAB&SYSNDX-*)\n         AIF   (T'&@IDN EQ 'O').@IDL1\n         DC    C'&@IDN '\n         AGO   .@IDL2\n.@IDL1   ANOP\n         DC    C'&SYSECT '\n.@IDL2   ANOP\n         DC    C'&SYSDATC &SYSTIME &SYSJOB '\n         DC    C'&SYSIN_DSN',C'(',C'&SYSIN_MEMBER',C') '\n         DC    C'&SYSTEM_ID ',X'B4',C'Paul Wells (Saudi Aramco) 2002 '\n@LAB&SYSNDX DS 0H\n         MEND\n*\n         MACRO\n.* Execute the next instruction so as not to break the sequence\n.* of instructions, in order to preserve readability. We hate it\n.* when people execute instructions half a mile away in the code!\n&NAME    @EXNEXT &@EXNEXTL\n&NAME    LR    15,&@EXNEXTL\n         BCTR  15,0\n         BASR  14,0\n         AHI   14,@EXN&SYSNDX-*\n         EX    15,0(,14)\n         J     *+10\n@EXN&SYSNDX EQU *\n         MEND\n*\n         MACRO\n.* Internal subroutine call\n&NAME    @BAS  &@BASLOC\n         CNOP  2,4\n&NAME    BASR  15,0\n         AHI   15,@BAS1&SYSNDX-*\n         J     @BAS2&SYSNDX\n@BAS1&SYSNDX DC A(&@BASLOC)\n@BAS2&SYSNDX EQU *\n         L     15,0(,15)\n         BASR  14,15\n         MEND\n*\nANFUXMSG CSECT ,                   Establish the csect\nANFUXMSG AMODE 31                  It addresses all storage\nANFUXMSG RMODE ANY                 It can reside anywhere\n         @ID   ,\n         STM   R14,R12,12(R13)     Save callers registers\n         L     R11,0(,R1)          Get address of parm area\n         USING ANFUEXTP,R11        R11 is base for parm area\n         ST    R13,XTPSAVE+4       chain save areas\n         LA    R15,XTPSAVE         get my save area\n         ST    R15,8(,R13)         point callers save area to it\n         LR    R13,R15             point R13 to my save area\n         BASR  R14,0\n         USING *,R14\n         STORAGE OBTAIN,LENGTH=WORKL\n         DROP  R14\n         LR    R9,R1\n         USING WORKA,R9\n         BASR  R12,0               get current location\n         AHI   R12,STATIC-*        add offset to static area\n         USING STATIC,R12          map static area with R12\n         LA    R14,MACROMASKS\n         LA    R15,MACROMASKS_LENGTH\n         LA    R0,MACROEXECS\n         LR    R1,R15\n         MVCL  R0,R14\n*\n         L     R8,XTPMSGP          get pointer to message text\n         LA    R3,SUPMSGE\n         LA    R4,L'SUPMSGE\n         LA    R5,SUPMSGE+SUPMSGL-L'SUPMSGE+1 Point to last entry\n         BASR  R6,0\n* Instruction following BASR is start of loop\n         CLC   0(L'SUPMSGE,R3),0(R8) Suppressed MSG ?\n         JE    GETOUT              Skip if yes\n         BXLE  R3,R4,0(R6)         Loop through SUPMSGE table\n* End of loop\n         OI    XTPMSGFL,XTPM2MDS   Set log to dataset\n         CLC   XTPMSGLN,=AL2(LINELENS) Fit on single line WTO ?\n         JH    MLWTO               Skip if no\n         MVC   WTOLINES(2),XTPMSGLN Get length of data\n         IC    R3,XTPMSGLN+1       Put len in reg\n         @EXNEXT R3                Move data to WTO line\n         MVC   WTOLINES+2(0),0(R8) *EXECUTED*\n         LA    R3,WTOLINES         Point to WTO line\n         SR    R0,R0               Clear R0\n         WTO   TEXT=(R3),MF=(E,WTOE1) Issue WTO (single line)\n         J     GETOUT              Skip MLWTO\nMLWTO    DS    0H\n         @BAS  FLINE               Invoke first line processing\n         LM    R4,R7,0(R1)         Get saved Regs passed back\n         @BAS  RMLINE              Invoke processing for rest of lines\n         SR    R0,R0               Clear R0\n         WTO   MF=(E,WTOE2)        Issue MLWTO\nGETOUT   DS    0H\n         PUSH  USING               Save USINGs\n         DROP  ,                   Drop all USINGs\n         BASR  R14,0               Kilroy woz ere\n         USING *,R14               Map 'ere'\n         STORAGE RELEASE,LENGTH=WORKL,ADDR=(R9) Free work area\n         DROP  R14                 Drop 'ere'\n         POP   USING               Get back USINGs\n         L     R13,XTPSAVE+4      Get address of caller's save area\n         RETURN (14,12)           Restore caller's registers and return\n*\n* Format the first line of the MLWTO\n*\nFLINE    DS    0H\n         BAKR  R14,0               Stack regs\n* Internal Register usage\n*  r4 remaining data len\n*  r5 pointer to data\n*  r2 current line len\n*  r6 pointer to next WTO line address pointer (on exit)\n*  r7 pointer to next WTO line text location (on exit)\n         L     R5,XTPMSGP          get pointer to message text\n         SR    R4,R4               clear\n         ICM   R4,3,XTPMSGLN       get pointer to message len\n         SR    R6,R6               Clear\n         IC    R6,WTOE2+8+(WPXLNGTH-WPX) Get len of WPL\n         LA    R6,WTOE2+8(R6)      Point to end of WPL\n         CL    R4,=A(FLINELEN)     More than a lines worth ?\n         JH    FLINE10             Skip if yes\n         LR    R2,R4               Set line len to data len\n         MVI   0(R6),WPLLTFC+WPLLTFD Set type 'data end' line\n         J     FLINE20\nFLINE10  DS    0H\n         MVI   0(R6),WPLLTFC       Set type 'data' line\n         @BAS  GETLEN\n         LR    R2,R1               Get Assigned length\nFLINE20  DS    0H\n         LA    R6,WPLLINES-WPLLTF(,R6) Point to line count in WPL\n         MVI   0(R6),1             Set no. of lines so far\n         ST    R6,LINESADDR        Save line counter pointer\n         LA    R7,WTOLINES         Point to 1st WTO line\n         ST    R7,WTOE2+(WPLADTXT-WPL) Save addr in WPL\n         STCM  R2,3,0(R7)          Set len of line for WTO\n         @EXNEXT R2                Move data into WTO line\n         MVC   2(0,R7),0(R5)       *EXECUTED*\n         LA    R7,2(R2,R7)         point to next WTO line\n         LA    R6,WTOADDRS         point to next WTO line address\n         LA    R5,0(R2,R5)         Point past current line in data\n         SR    R4,R2               Subtract the line length\nFLINEX   DS    0H\n         STM   R4,R7,FLINEREG\n         LA    R1,FLINEREG\n         PR\n*\n* RMLINE\n* Format the second and subsequent lines of the MLWTO\n*\nRMLINE   DS    0H\n         BAKR  R14,0               Stack regs\n* Internal Register usage\n*  r4 remaining data len\n*  r5 pointer to current data\n*  r2 current line len\n*  r3 number of WTO lines remaining before max reached\n*  r6 pointer to WTO line address pointer\n*  r7 pointer to WTO line text location\n         LTR   R4,R4               any data left ?\n         JNP   RMLINEX             Skip if no\n         LA    R3,NUMLINES         Get max no. of lines\n         BCTR  R3,0                Decrement for 1st line\nRMLINE10 DS    0H\n         CL    R4,=A(LINELEN)      More than a lines worth left ?\n         JH    RMLINE20            Skip if yes\n         LR    R2,R4               Set line len to data len\n         J     RMLINE30            Skip\nRMLINE20 DS    0H\n         @BAS  GETLEN              Get preferred len of this line\n         LR    R2,R1               Get assigned length\nRMLINE30 DS    0H\n         @EXNEXT R2                Move data into WTO line\n         MVC   2(0,R7),0(R5)       *EXECUTED*\n         STCM  R2,3,0(R7)          Set len of line for WTO\n         XC    0(8,R6),0(R6)       Clear current WTO address pointer\n         MVI   1(R6),8             Set len of ptr to 8\n         LTR   R3,R3               last line ?\n         JZ    RMLINE40            Skip if yes\n         CL    R4,=A(LINELEN)      Last bit of data ?\n         JH    RMLINE50            Skip if no\nRMLINE40 DS    0H\n         OI    2(R6),WPLLTFC+WPLLTFD Set type 'data end' line\n         J     RMLINE60            Skip\nRMLINE50 DS    0H\n         OI    2(R6),WPLLTFC       Set type 'data' line\nRMLINE60 DS    0H\n         STCM  R7,15,4(R6)         Save addr of current WTO line\n         L     R1,LINESADDR        Get pointer to no. of lines\n         IC    R15,0(,R1)          Get no. of lines\n         LA    R15,1(,R15)         Increment\n         STC   R15,0(,R1)          Save no. of lines\n         S     R3,=F'1'            Decrement used lines counter\n         JM    RMLINEX             Skip if negative\n         LA    R7,2(R2,R7)         Point to next WTO line\n         LA    R6,8(,R6)           Point to next WTO line address\n         LA    R5,0(R2,R5)         Point past current line in data\n         SR    R4,R2               Subtract the line length\n         JP    RMLINE10            Loop if some data left\nRMLINEX  DS    0H\n         PR\n*\n* GETLEN\n* Sets length of line up to and including last space/LF/CR.\n* The idea is to not split long strings (dataset names) over multiple\n* lines.\n*\nGETLEN   DS    0H\n         BAKR  R14,0               Stack regs\n* Internal Register usage\n*  r5 pointer to current data (must be set on entry)\n*  r2 work\n*  r1 position of delimiter (TRT) and length of line (on exit)\n         LA    R1,LINELEN          Get length of data\n         LA    R2,0(R1,R5)         Point past end of data\n         BCTR  R2,0                Point to last byte of data\n         MVCIN REVLINE,0(R2)       Reverse data\n         TRT   REVLINE,TRTAB       Find first (last) delim\n         JZ    GETLENX             Skip if no delim found\n         LA    R2,REVLINE          Point to reversed data\n         SLR   R1,R2               Get offset into data for delim\n         LA    R2,LINELEN          Get length of data\n         SLR   R2,R1               Get length of data after delim\n         LR    R1,R2               Return length in R1\nGETLENX  DS    0H\n         PR\n*\nSTATIC   DS    0H\nMACROMASKS DS  0D\n         WTO   TEXT=,LINKAGE=,                                         *\n               ROUTCDE=(2,11),DESC=(6),MF=L\n         WTO   TEXT=((,D)),LINKAGE=,                                   *\n               ROUTCDE=(2,11),DESC=(6),MF=L\nMACROMASKS_LENGTH EQU *-MACROMASKS\nSUPMSGE  DC    CL9'ANFM602I'\n         DC    CL9'ANFM604I'\nSUPMSGL  EQU   *-SUPMSGE\nFLINELEN EQU   71                  MLWTO first line length (auth)\nLINELEN  EQU   71                  MLWTO subsequent line length\nNUMLINES EQU   255                 MLWTO max lines (auth)\nLINELENS EQU   126                 SLWTO line length (authorised)\nTRTAB    DC    XL256'00'\n         ORG   TRTAB+X'0A'\n         DC    X'FF'\n         ORG   TRTAB+X'15'\n         DC    X'FF'\n         ORG   TRTAB+C' '\n         DC    X'FF'\n         ORG\n         LTORG\n*\nWORKA    DSECT\nMACROEXECS DS  0D\nWTOE1    WTO   TEXT=,LINKAGE=,                                         *\n               ROUTCDE=(2,11),DESC=(6),MF=L\nWTOE2    WTO   TEXT=((,D)),LINKAGE=,                                   *\n               ROUTCDE=(2,11),DESC=(6),MF=L\nWTOADDRS DS    0F,254AL2,254XL2,254AL4     Contiguous from WTOE2\n*\nPARMADDR DS    F\nLINESADDR DS   F\nFLINEREG DS    4F\nREVLINE  DS    CL(LINELEN)\nWTOLINES DS    AL2,CL(FLINELEN),254AL2,255CL(LINELEN)\n*\nWORKL    EQU   *-WORKA\n*\n         DROP  R12,R11,R9\n*\n         ANFUEXTP                  Infoprint Server DSECT\n         IEZWPL ,                  WTO parm list\n         YREGS ,                   Register equates\n*\n         END   ,                   End of ANFUXMSG module\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMLKED": {"ttr": 12, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00D\\x01\\x020\\x1f\\x01\\x03\\x07\\x0f\\x14\\x12\\x00%\\x00%\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-10-28T00:00:00", "modifydate": "2003-03-11T14:12:44", "lines": 37, "newlines": 37, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWA  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.ASM.PDS(ASMLKED)\n//* JCL TO ASSEMBLE/LINK ASSEMBLER PROGRAMS\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*   3) COMMENT IN/OUT MODULES WHICH YOU WISH TO ASSEMBLE\n//*\n//*\n//ASMLKED  PROC SRC='AWCPAW.CBT.FILE600.ASM.PDS',M=,\n//          LOAD='AWCPAW.CBT.FILE600.LOAD'\n//C        EXEC PGM=ASMA90,PARM='OBJECT,RENT,NODECK,LIST'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=SYS1.TCPIP.SEZACMAC\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(15,15))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DISP=(,PASS),UNIT=SYSALLDA,SPACE=(TRK,(15,15))\n//SYSPUNCH DD  DUMMY\n//SYSIN    DD  DISP=SHR,DSN=&SRC(&M)\n//L        EXEC PGM=HEWL,PARM='MAP,XREF,LET,LIST,RENT',COND=(0,NE,C)\n//SYSLIN   DD  DISP=(OLD,DELETE),DSN=*.C.SYSLIN\n//SYSLMOD  DD  DISP=SHR,DSN=&LOAD(&M)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(15,15))\n//SYSPRINT DD  SYSOUT=*\n//         PEND\n//*\n//* ASM1 - ASSEMBLE/LINK FTPCTST PROGRAM\n//ASM1    EXEC ASMLKED,M=FTPCTST\n//* ASM2 - ASSEMBLE/LINK HPNSTST PROGRAM\n//ASM2    EXEC ASMLKED,M=HPNSTST\n//* ASM3 - ASSEMBLE/LINK ANFUXMSG PROGRAM\n//ASM3    EXEC ASMLKED,M=ANFUXMSG\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASMOBJ": {"ttr": 14, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00F\\x01\\x020\\x1f\\x01\\x03\\x07\\x0f\\x14\\x12\\x00 \\x00$\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-10-28T00:00:00", "modifydate": "2003-03-11T14:12:46", "lines": 32, "newlines": 36, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWA  JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.ASM.PDS(ASMOBJ)\n//* JCL TO ASSEMBLE AND SAVE OBJECT FOR ASSEMBLER PROGRAMS\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) CHANGE SYS1 PREFIX OF IBM TARGET LIBRARIES TO YOUR OWN\n//*   3) COMMENT IN/OUT MODULES WHICH YOU WISH TO ASSEMBLE\n//*\n//*\n//ASMOBJ   PROC SRC='AWCPAW.CBT.FILE600.ASM.PDS',M=,\n//          OBJ='AWCPAW.CBT.FILE600.OBJ.PDS'\n//C        EXEC PGM=ASMA90,PARM='OBJECT,RENT,NODECK,LIST'\n//SYSLIB   DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//         DD  DISP=SHR,DSN=SYS1.CEE.SCEEMAC\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(TRK,(15,15))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DISP=SHR,DSN=&OBJ(&M)\n//SYSPUNCH DD  DUMMY\n//SYSIN    DD  DISP=SHR,DSN=&SRC(&M)\n//         PEND\n//*\n//* ASM1 - ASSEMBLE EDCXFGS (C STORAGE FUNCTIONS)\n//ASM1    EXEC ASMOBJ,M=EDCXFGS\n//* ASM2 - ASSEMBLE MLWTO PROGRAM\n//ASM2    EXEC ASMOBJ,M=MLWTO\n//* ASM3 - ASSEMBLE SPRNTLL PROGRAM\n//ASM3    EXEC ASMOBJ,M=SPRNTLL\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDCXFGS": {"ttr": 16, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00H\\x01\\x02%\\x9f\\x01\\x03\\x07\\x0f\\x14\\x12\\x01\\x0b\\x00a\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "2002-09-16T00:00:00", "modifydate": "2003-03-11T14:12:48", "lines": 267, "newlines": 97, "modlines": 0, "user": "AWCPAW"}, "text": "         TITLE 'EDCXFGS - non-SVC SPC storage malloc/free routines'\n***********************************************************************\n*\n* Name: @@XGET (Entry point), EDCXGET (CSECT)\n*\n* Abstract:\n*\n*    Virtual storage allocation subroutine for Systems Programming\n*    C using the STORAGE macro. The default (brainless) @@XGET uses\n*    SVC 120 which limits SPC use in system exits where SVCs are not\n*    allowed.\n*\n* Operation:\n*\n*    Input:  R0 - length of storage to obtain (high bit on for storage\n*            above the line).\n*            R14 - Return address\n*\n*    Output: R0 - length of storage obtained\n*            R1 - address of memory obtained\n*\n*    The program does rudimentary checks to see whether it is running\n*    authorised so it can use the preferred high private subpool\n*    230, where possible.\n*\n* Environment:\n*\n*    IBM compatible mainframe (branch relative/immediate instructions\n*    must be supported)\n*    IBM OS/390, z/OS or subsequent operating system\n*\n* Invocation:\n*\n*    Via malloc function of Systems Programming C.\n*\n*    Must be explicitly included via link-edit. For an example see\n*    AWCPAW.CBT.FILE600.C.PDS(FTPC119C).\n*\n* Notes:\n*\n*    IBM samples state that only R0-2/4/14/15 may be modified by this\n*    routine and a save area is not provided. We get around this by\n*    using the linkage stack to save and restore registers.\n*\n*    The assembler code does not use a base register, so the\n*    relative/immediate forms of branch instructions must be used.\n*\n*    To avoid USING conflicts when we have to temporarily provide\n*    a base register for some system macros, a literal pool\n*    is not available. Static literals must be placed by name in\n*    the 'STATIC' section and referenced via a labeled dependent\n*    USING by specifying an ST prefix.\n*\n*\n* Author: Paul Wells\n*         Saudi Aramco Box 12959\n*         Dhahran\n*         Saudi Arabia\n*\n* Email:  paul.wells@aramco.com\n*\n* History:\n*\n*    PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************\n*\n         MACRO\n.* Set CSECT eyecatcher\n&NAME    @ID   &@IDN\n&NAME    J     @LAB&SYSNDX\n         DC    AL1(@LAB&SYSNDX-*)\n         AIF   (T'&@IDN EQ 'O').@IDL1\n         DC    C'&@IDN '\n         AGO   .@IDL2\n.@IDL1   ANOP\n         DC    C'&SYSECT '\n.@IDL2   ANOP\n         DC    C'&SYSDATC &SYSTIME &SYSJOB '\n         DC    C'&SYSIN_DSN',C'(',C'&SYSIN_MEMBER',C') '\n         DC    C'&SYSTEM_ID ',X'B4',C'Paul Wells (Saudi Aramco) 2002 '\n@LAB&SYSNDX DS 0H\n         MEND\n*\nEDCXGET  AMODE ANY\nEDCXGET  RMODE ANY\nEDCXGET  CSECT\n@@XGET   @ID   __xget\n         ENTRY @@XGET\n         BAKR  R14,0               SAVE REGS ON STACK\n         BASR  R12,0               Get current location\n         AHI   R12,GSTATIC-*       Add offset to static area\nST       USING GSTATIC,R12         Map static area with R12\n         LR    R5,R0               Save R0\n         SR    R6,R6               Set subpool zero for later\n         ICM   R8,15,PSATOLD-PSA(0) SRB mode ?\n         JZ    GET10               Assume auth if yes\n         TM    X'A3'(0),X'01'      z/architecture present ?\n*        TM    FLCARCH-PSA(0),PSAZARCH z/architecture present ?\n         JNO   GET20               Skip if no\n*        EPSW  R1,0                Get left half of PSW\n         DC    0H,X'B98D0010'      EPSW  R1,0\n         CLM   R1,B'0100',ST.GKEY8 KEY < 8 ?\n         JNL   GET30               Skip if no\n         N     R1,ST.GPROBSTATE    Problem state ?\n         JNZ   GET30               Skip if yes\nGET10    DS    0H\n         LA    R6,230              Set subpool 230 for auth callers\n         J     GET30\nGET20    DS    0H\n         L     R8,TCBRBP-TCB(,R8)  Get our RB\n         SH    R8,ST.GLENRBPRE     Point at RB prefix\n         CLI   RBSTAB1-RBPRFX(R8),RBFTPRB In a PRB ?\n         JNE   GET10               Assume auth subpool if no\nGET30    DS    0H\n         LTR   R5,R5               Memory above or below?\n         JNL   GET40               Skip if below\n         BASR  R14,0\n         USING *,R14               Temp base reg for macro\n         LTR   R14,R14             Are we running above the line?\n         JNL   GET40               If below line, skip to below\n         LA    R5,0(,R5)           Clear high bit\n         STORAGE OBTAIN,LENGTH=(5),COND=YES,                           *\n               LOC=ANY,SP=(6)\n         DROP  R14\n         LTR   R15,R15             Was it successful?\n         JZ    GETOUT              Yes...\n         SR    R1,R1               No, indicate failure\n         J     GETOUT\nGET40    DS    0H                  Get memory below the line\n         BASR  R14,0\n         USING *,R14               Temp base reg for macro\n         STORAGE OBTAIN,LENGTH=(5),COND=YES,                           *\n               LOC=BELOW,SP=(6)\n         DROP  R14\n         LTR   R15,R15             Was it successful?\n         JZ    GETOUT              Yes...\n         SR    R1,R1               No, indicate failure in R1\nGETOUT   DS    0H\n         PR\n*\nGSTATIC  DS    0D\nGPROBSTATE DC  0F,XL4'00010000'\nGLENRBPRE DC   0H,AL2(RBBASIC-RBPRFX)\nGKEY8    DC    X'80'\n*\n         DROP  ST\n*\n***********************************************************************\n*\n* Name: Entry point @@XFREE, CSECT EDCXFREE\n*\n* Abstract:\n*\n*    Virtual storage free subroutine for Systems Programming\n*    C using the STORAGE macro. The default (brainless) @@XFREE uses\n*    SVC 120 which limits SPC use in system exits where SVCs are not\n*    allowed.\n*\n* Operation:\n*\n*    Input:  R0 - length of storage to free\n*            R1 - address of storage to free\n*            R14 - Return address\n*\n*    The program does rudimentary checks to see whether it is running\n*    authorised so it can detect use of the preferred high private\n*    subpool 230.\n*\n* Environment:\n*\n*    IBM compatible mainframe (branch relative/immediate instructions\n*    must be supported)\n*    IBM OS/390, z/OS or subsequent operating system\n*\n* Invocation:\n*\n*    Via free function of Systems Programming C.\n*\n*    Must be explicitly included via link-edit. For an example see\n*    AWCPAW.CBT.FILE600.C.PDS(FTPC119C).\n*\n* Notes:\n*\n*    IBM samples state that only R0-2/4/14/15 may be modified by this\n*    routine and a save area is not provided. We get around this by\n*    using the linkage stack to save and restore registers.\n*\n*    The assembler code does not use a base register, so the\n*    relative/immediate forms of branch instructions must be used.\n*\n*    To avoid USING conflicts when we have to temporarily provide\n*    a base register for some system macros, a literal pool\n*    is not available. Static literals must be placed by name in\n*    the 'STATIC' section and referenced via a labeled dependent\n*    USING by specifying an ST prefix.\n*\n*\n* Author: Paul Wells\n*         Enterprise Servers Division\n*         Saudi Aramco\n*         Dhahran\n*         Saudi Arabia\n*\n* Email:  paul.wells@aramco.com\n*\n* History:\n*\n*    PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************\n*\nEDCXFREE AMODE ANY\nEDCXFREE RMODE ANY\nEDCXFREE CSECT\n@@XFREE  @ID   __xfree\n         ENTRY @@XFREE\n         BAKR  R14,0               SAVE REGS ON STACK\n         BASR  R12,0               Get current location\n         AHI   R12,FSTATIC-*       Add offset to static area\nST       USING FSTATIC,R12         Map static area with R12\n         LR    R5,R0               Save R0\n         LR    R4,R1               Save R1\n         SR    R6,R6               Set subpool zero for later\n         ICM   R8,15,PSATOLD-PSA(0) SRB mode ?\n         JZ    FREE10              Assume auth if yes\n         TM    X'A3'(0),X'01'      z/architecture present ?\n*        TM    FLCARCH-PSA(0),PSAZARCH z/architecture present ?\n         JNO   FREE20              Skip if no\n*        EPSW  R1,0                Get left half of PSW\n         DC    0H,X'B98D0010'      EPSW  R1,0\n         CLM   R1,B'0100',ST.FKEY8 KEY < 8 ?\n         JNL   FREE30              Skip if no\n         N     R1,ST.FPROBSTATE    Problem state ?\n         JNZ   FREE30              Skip if yes\nFREE10   DS    0H\n         LA    R6,230              Set subpool 230 for auth\n         J     FREE30\nFREE20   DS    0H\n         L     R8,TCBRBP-TCB(,R8)  Get our RB\n         SH    R8,ST.FLENRBPRE     Point at RB prefix\n         CLI   RBSTAB1-RBPRFX(R8),RBFTPRB In a PRB ?\n         JNE   FREE10              Assume auth subpool if no\nFREE30   DS    0H\n         LA    R5,0(,R5)           Clear high bit\n         BASR  R14,0\n         USING *,R14               Temp base reg for macro\n         STORAGE RELEASE,LENGTH=(5),ADDR=(4),COND=YES,SP=(6)\n         DROP  R14\n         PR\n*\nFSTATIC  DS    0D\nFPROBSTATE DC  0F,XL4'00010000'\nFLENRBPRE DC   0H,AL2(RBBASIC-RBPRFX)\nFKEY8    DC    X'80'\n*\n         DROP  ST\n*\n         YREGS ,\n         IHAPSA ,\n         IHAASCB ,\n         IHARB ,\n         IKJTCB ,\n*\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FTPCTST": {"ttr": 257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00Q\\x01\\x02&\\x7f\\x01\\x03\\x07\\x0f\\x14\\x12\\x00\\xf1\\x00\\xed\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-09-24T00:00:00", "modifydate": "2003-03-11T14:12:51", "lines": 241, "newlines": 237, "modlines": 0, "user": "AWCPAW"}, "text": "         TITLE 'FTPCTST - Test MLWTO functions of FTPC118/119'\n***********************************************************************\n*\n* Name: FTPCTST\n*\n* Abstract:\n*\n*    Test the MLWTO functions of the C SMF exits FTPC118/119. This\n*    allows the SMF exit functions of these programs to be tested\n*    without installing them as SMF exits.\n*\n* Operation:\n*\n*    Passed a single parameter indicating which SMF exit program\n*    to call. This will be either FTPC119 (default), FTPC118,\n*    FTPSMFEX, or possibly something else.\n*\n*    For each record in the SMFDD input file, the indicated SMF\n*    exit program is directly branched to, passing the SMF record which\n*    has been read as a parameter.\n*\n*    The MLWTO functions of the FTP SMF exits will be invoked and the\n*    MLWTOs should appear in the joblog of the job running this\n*    program. The output will be in the same format as if\n*    the SMF exits been installed.\n*\n* Environment:\n*\n*    IBM compatible mainframe (branch relative/immediate instructions\n*    must be supported)\n*\n*    IBM OS/390, z/OS or subsequent operating system\n*\n* Assembly:\n*\n*    Use (userid).CBTxxx.FILE600.ASM.PDS(ASMLKED) or similar to\n*    assemble and link this program.\n*\n* Invocation:\n*\n*    Usually via batch JCL e.g.\n*\n*     //FTPCTST  EXEC PGM=FTPCTST,PARM=FTPC119\n*     //*FTPCTST  EXEC PGM=FTPCTST,PARM=FTPC118\n*     //*FTPCTST  EXEC PGM=FTPCTST,PARM=FTPSMFEX\n*     //STEPLIB  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.LOAD\n*     //SMFDD    DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.SMF119\n*     //SYSUDUMP DD  SYSOUT=*\n*     //SYSPRINT DD  SYSOUT=*\n*     //SYSOUT   DD  SYSOUT=*\n*\n* Notes:\n*\n*    This program can run either APF authed or not (the program will\n*    check). It is better to run it from an APF authed library\n*    as this will test the full length authorised MLWTO functions\n*    and the authorised STORAGE subpool used in the SMF exits. if\n*    run unauthed the MLWTOs will be 1 character shorter than\n*    they would be in an SMF exit.\n*\n*    The assembler code does not use a base register, so the\n*    relative/immediate forms of branch instructions must be used.\n*\n*    To avoid USING conflicts when we have to temporarily provide\n*    a base register for some system macros, a literal pool\n*    is not available. Static literals must be placed by name in\n*    the 'STATIC' section and referenced via a labeled dependent\n*    USING by specifying an ST prefix.\n*\n*\n* Author: Paul Wells\n*         Saudi Aramco Box 12959\n*         Dhahran\n*         Saudi Arabia\n*\n* Email:  paul.wells@aramco.com\n*\n* History:\n*\n*    PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************\n*\n         MACRO\n.* Set CSECT eyecatcher\n&NAME    @ID   &@IDN\n&NAME    J     @LAB&SYSNDX\n         DC    AL1(@LAB&SYSNDX-*)\n         AIF   (T'&@IDN EQ 'O').@IDL1\n         DC    C'&@IDN '\n         AGO   .@IDL2\n.@IDL1   ANOP\n         DC    C'&SYSECT '\n.@IDL2   ANOP\n         DC    C'&SYSDATC &SYSTIME &SYSJOB '\n         DC    C'&SYSIN_DSN',C'(',C'&SYSIN_MEMBER',C') '\n         DC    C'&SYSTEM_ID ',X'B4',C'Paul Wells (Saudi Aramco) 2002 '\n@LAB&SYSNDX DS 0H\n         MEND\n*\n         MACRO\n.* Execute the next instruction so as not to break the sequence\n.* of instructions, in order to preserve readability. We hate it\n.* when people execute instructions half a mile away in the code!\n&NAME    @EXNEXT &@EXNEXTL\n&NAME    LR    15,&@EXNEXTL\n         BCTR  15,0\n         BASR  14,0\n         AHI   14,@EXN&SYSNDX-*\n         EX    15,0(,14)\n         J     *+10\n@EXN&SYSNDX EQU *\n         MEND\n*\n         PUNCH ' SETCODE AC(1)'    Auth me guv'nor\nFTPCTST  AMODE 31\nFTPCTST  RMODE ANY\nFTPCTST  CSECT\n         @ID   ,\n         STM   R14,R12,12(R13)     Save callers registers\n         L     R8,0(,R1)           Get address of parm area\n         BASR  R14,0\n         USING *,R14               Temp base reg for macro\n         STORAGE OBTAIN,LENGTH=WORKL,LOC=BELOW   Getmain work area\n         DROP  R14\n         ST    R13,4(,R1)          Chain save areas\n         ST    R1,8(,R13)\n         LR    R13,R1\n         USING WORKA,R13           Map work area\n         BASR  R12,0               Get current location\n         AHI   R12,STATIC-*        Add offset to static area\nST       USING STATIC,R12          Map static area\n         LA    R14,ST.MACROMASKS\n         LA    R15,MACROMASKS_LENGTH\n         LA    R0,MACROEXECS\n         LR    R1,R15\n         MVCL  R0,R14              Init macro list forms\n         MVI   FLAG,0              Clear flag byte\n         MVI   PGM,C' '\n         MVC   PGM+1(L'PGM-1),PGM  Blank the called PGM\n         ICM   R2,3,0(R8)          Did he pass a PGM ?\n         JNZ   GETPARM1            Skip if yes\n         MVC   PGM,ST.FTPC119      Set default PGM\n         J     GETPARM2\nGETPARM1 DS    0H\n         @EXNEXT R2                Set PGM to call from parm\n         MVC   PGM(0),2(R8)        *EXECUTED*\nGETPARM2 DS    0H\n         LA    R2,DCBE\n         ST    R2,SMFDD(DCBDCBE-IHADCB) Save DCBE address in DCB\n         OPEN  (SMFDD,(INPUT)),                                        *\n               MODE=31,MF=(E,OPENL) Open SMF input file\n         TM    SMFDD+(DCBOFLGS-IHADCB),DCBOFOPN Open OK ?\n         JO    OPENOK\n         WTO   MF=(E,ST.WTOOPERR)  Issue error message\n         ABEND 999                 Abend if bad open\nOPENOK   DS    0H\n         TESTAUTH FCTN=1\n         LTR   R15,R15             APF auth ?\n         JNZ   NOAUTH              Skip if no\n         OI    FLAG,FLAGAPF        Set APF flag\nNOAUTH   DS    0H\n         LA    R0,PGM              Set PGM to call\n         LOAD  EPLOC=(0)           Load PGM in storage\n         ST    R0,EP               Save entry point\nGETREC1  DS    0H\n         GET   SMFDD               Get an SMF record\n         SR    R15,R15             Clear offset into PARM\n         CLC   ST.FTPSMFEX,PGM     Is it FTPSMFEX ?\n         JNE   GETREC2             Skip if no\n         LA    R15,4(,R15)         Record is 2nd parm if FTPSMFEX\nGETREC2  DS    0H\n         ST    R1,PARMS(R15)       Save record address\n         TM    FLAG,FLAGAPF        APF ?\n         JNO   SKIPMOD1            Skip if no\n         BASR  R14,0\n         USING *,R14               Temp base reg for macro\n         MODESET KEY=ZERO,MODE=SUP Turn on KEY0/SUPV to test auth funcs\n         DROP  R14\nSKIPMOD1 DS    0H\n         L     R15,EP              Get entry point\n         LA    R1,PARMS            Get record address\n         BALR  R14,R15             Branch to PGM\n         TM    FLAG,FLAGAPF        APF ?\n         JNO   SKIPMOD2\n         BASR  R14,0\n         USING *,R14               Temp base reg for macro\n         MODESET KEY=NZERO,MODE=PROB Turn off KEY0/SUPV\n         DROP  R14\nSKIPMOD2 DS    0H\n         J     GETREC1             Loop for next record\nCLOSEX   DS    0H\n         LA    R0,PGM              Get PGM\n         DELETE EPLOC=(0)          Delete from storage\n         CLOSE (SMFDD),MODE=31,MF=(E,CLOSEL) Close SMF input\nEXIT     DS    0H\n         L     R2,4(,R13)          Get address of caller's save area\n         BASR  R14,0\n         USING *,R14               Temp base reg for macro\n         STORAGE RELEASE,LENGTH=WORKL,ADDR=(R13) Free work area\n         DROP  R14\n         LR    R13,R2\n         RETURN (14,12),RC=0      Restore caller's registers and return\n*\n*\nSTATIC   DS    0D\nMACROMASKS DS  0D\n         DCB   DDNAME=SMFDD,MACRF=(GL),BUFNO=5,DCBE=0,DSORG=PS\n         OPEN  (,),MODE=31,MF=L\n         CLOSE (,),MODE=31,MF=L\n         DCBE  RMODE31=BUFF,EODAD=CLOSEX\nMACROMASKS_LENGTH EQU *-MACROMASKS\nWTOOPERR WTO  'FTPCTST-01E Error SMFDD DD failed to open',             X\n               ROUTCDE=(2,11),DESC=(4,6),MF=L\nFTPC119  DC    CL8'FTPC119'\nFTPSMFEX DC    CL8'FTPSMFEX'\n*\n*\nWORKA    DSECT\nSAVEA    DS    18F\nMACROEXECS DS  0D\nSMFDD    DCB   DDNAME=SMFDD,MACRF=(GL),BUFNO=5,DCBE=0,DSORG=PS\nOPENL    OPEN  (,),MODE=31,MF=L\nCLOSEL   CLOSE (,),MODE=31,MF=L\nDCBE     DCBE  RMODE31=BUFF,EODAD=CLOSEX\n*\nPGM      DS    CL8\nEP       DS    F\nPARMS    DS    2F\nFLAG     DS    X\nFLAGAPF  EQU   1\n*\nWORKL    EQU   *-WORKA\n*\n*\n         YREGS ,\n         DCBD  DSORG=PS,DEVD=DA\n*\n         DROP  R13,ST\n         END   FTPCTST\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FTPCTSTJ": {"ttr": 259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00V\\x01\\x02&\\x7f\\x01\\x03\\x07\\x0f\\x14\\x12\\x00 \\x00\\x1c\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2002-09-24T00:00:00", "modifydate": "2003-03-11T14:12:56", "lines": 32, "newlines": 28, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWTT JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.ASM.PDS(FTPCTSTJ)\n//* JCL TO RUN FTPCTST (FTP SMF EXIT TEST PROGRAM)\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) AMEND STEPLIB AS REQUIRED\n//*   3) AMEND SMFDD AS REQUIRED TO A DATASET CONTAINING SMF TYPE\n//*      118 AND/OR 119 RECORDS\n//*   4) AMEND PARM TO REFLECT WHICH EXIT IS BEING TESTED\n//*      (FTPC118/FTPC119/FTPSMFEX)\n//*\n//*  NOTE\n//*   BE CAREFUL IF YOU HAVE AUTOMATION UTILISING THE WTOS FROM THE\n//*   FTP SMF EXITS. THIS JOB WILL DRIVE THE SMF EXITS AND PRODUCE\n//*   THE WTOS WHICH MAY CAUSE YOUR AUTOMATION TO BE DRIVEN IN A\n//*   WAY NOT INTENDED.\n//*\n//* FTPCTST\n//* - RUN FTPCTST PROGRAM AGAINST SMF 118/119 DATA\n//*\n//FTPCTST  EXEC PGM=FTPCTST,PARM=FTPC119\n//*FTPCTST  EXEC PGM=FTPCTST,PARM=FTPC118\n//*FTPCTST  EXEC PGM=FTPCTST,PARM=FTPSMFEX\n//STEPLIB  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.LOAD\n//SMFDD    DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.SMF119\n//*SMFDD    DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.SMF118\n//SYSUDUMP DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSOUT   DD  SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HPNSTST": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x01\\x06\\x05/\\x01\\x06\\x05/\\tE\\x05!\\x05!\\x00\\x00\\xe3\\xd6\\xd4\\xd2\\xc9\\xd5\\xe2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2006-02-21T00:00:00", "modifydate": "2006-02-21T09:45:00", "lines": 1313, "newlines": 1313, "modlines": 0, "user": "TOMKINS"}, "text": "         TITLE 'HPNSTST - HPNS API IVP'\n***********************************************************************\n*\n* Name: HPNSTST\n*\n* Abstract:\n*\n*    A program which runs in batch to 'IVP' TCPIP using the\n*    HPNS API. This can be useful to test the TCPIP network setup.\n*\n* Operation:\n*\n*    - Accepts an optional port number parameter (default 47319)\n*    - Starts a TCPIP HPNS API session.\n*    - Shows available TCPIP stacks and status.\n*    - Obtains IP address via GETHOSTID.\n*    - Obtains short host name via GETHOSTNAME.\n*    - Obtains all IP addresses for this host using GETHOSTBYNAME.\n*    - Obtains host names for all IP addresses returned in previous\n*      GETHOSTBYNAME using GETHOSTBYADDR.\n*    - Opens a socket and binds to INADDR_ANY (0.0.0.0).\n*    - Opens sockets and binds to all specific IP addresses returned in\n*      previous GETHOSTBYNAME.\n*    - Ends TCPIP HPNS API session.\n*\n* Environment:\n*\n*    IBM compatible mainframe (branch relative/immediate instructions\n*    must be supported)\n*\n*    IBM OS/390, z/OS or subsequent operating system\n*\n* Assembly:\n*\n*    Use (userid).CBTxxx.FILE600.ASM.PDS(ASMLKED) or similar to\n*    assemble and link this program.\n*\n* Invocation:\n*\n*    Usually via batch JCL e.g.\n*\n*     //HPNSTEST EXEC PGM=HPNSTST\n*     //STEPLIB  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.LOAD\n*     //SYSPRINT DD  SYSOUT=*\n*     //SYSUDUMP DD  SYSOUT=*\n*     //*$NOWTO   DD  DUMMY      Include to suppress WTO output\n*\n*\n* Sample output:\n*\n*    Output is via WTO and optionally via the SYSPRINT DD. Messages\n*    are prefixed by a message id of the form HPNSTxxI. WTO output\n*    can be suppressed via inclusion of $NOWTO DD in JCL.\n*\n*    e.g.\n*\n* HPNSTST HPNS test program at 04 Nov 2002 06:54:03 on system TEST\n* GETIBMOPT RC=0\n* GETIBMOPT returns IP stack 001 named TCPIP at version x'0612' status\n*  x'8200' (active)\n* INITAPI RC=0\n* GETCLIENTID RC=0 returns Task=x'000003BB7F638D58' Name=AWCIP\n* GETHOSTID RC=x'0A01A0DC' returns IPA=x.x.x.x\n* GETHOSTNAME RC=0 returns Shortname=xxxx\n* GETHOSTBYADDR RC=0 using IPA=x.x.x.x returns Hostname=x.x.x.x.x\n* GETHOSTBYNAME RC=0 using Host=xxxx\n* GETHOSTBYNAME using Host=xxxx returns IPA001=x.x.x.x\n* GETHOSTBYNAME using Host=xxxx returns IPA002=x.x.x.x\n* GETHOSTBYNAME using Host=xxxx returns IPA003=x.x.x.x\n* GETHOSTBYNAME using Host=xxxx returns IPA004=x.x.x.x\n* GETHOSTBYNAME using Host=xxxx returns IPA005=x.x.x.x\n* GETHOSTBYNAME using Host=xxxx returns IPA006=x.x.x.x\n* GETHOSTBYADDR RC=0 using IPA=x.x.x.x returns Hostname=x.x.x.x.x\n* GETHOSTBYADDR RC=0 using IPA=x.x.x.x returns Hostname=x.x.x.x.x\n* GETHOSTBYADDR RC=0 using IPA=x.x.x.x returns Hostname=x.x.x.x.x\n* GETHOSTBYADDR RC=0 using IPA=x.x.x.x returns Hostname=x.x.x.x.x\n* GETHOSTBYADDR RC=0 using IPA=x.x.x.x returns Hostname=x.x.x.x.x\n* GETHOSTBYADDR RC=0 using IPA=x.x.x.x returns Hostname=x.x.x.x.x\n* SOCKET RC=0\n* BIND RC=0 to Port=47319 IPA=0.0.0.0\n* GETSOCKNAME RC=0 returns Port=47319 IPA=0.0.0.0\n* CLOSE RC=0\n* SOCKET RC=0\n* BIND RC=0 to Port=47319 IPA=x.x.x.x\n* GETSOCKNAME RC=0 returns Port=47319 IPA=x.x.x.x\n* CLOSE RC=0\n* SOCKET RC=0\n* BIND RC=0 to Port=47319 IPA=x.x.x.x\n* GETSOCKNAME RC=0 returns Port=47319 IPA=x.x.x.x\n* CLOSE RC=0\n* SOCKET RC=0\n* BIND RC=0 to Port=47319 IPA=x.x.x.x\n* GETSOCKNAME RC=0 returns Port=47319 IPA=x.x.x.x\n* CLOSE RC=0\n* SOCKET RC=0\n* BIND RC=0 to Port=47319 IPA=x.x.x.x\n* GETSOCKNAME RC=0 returns Port=47319 IPA=x.x.x.x\n* CLOSE RC=0\n* SOCKET RC=0\n* BIND RC=0 to Port=47319 IPA=x.x.x.x\n* GETSOCKNAME RC=0 returns Port=47319 IPA=x.x.x.x\n* CLOSE RC=0\n* SOCKET RC=0\n* BIND RC=0 to Port=47319 IPA=x.x.x.x\n* GETSOCKNAME RC=0 returns Port=47319 IPA=x.x.x.x\n* CLOSE RC=0\n* TERMAPI RC=(none)\n* HPNS API test successful\n*\n*\n* Notes:\n*\n*    The assembler code does not use a base register, so the\n*    relative/immediate forms of branch instructions must be used.\n*\n*    To avoid USING conflicts when we have to temporarily provide\n*    a base register for some system macros, a literal pool\n*    is not available. Static literals must be placed by name in\n*    the 'STATIC' section and referenced via a labeled dependent\n*    USING by specifying an ST prefix.\n*\n*\n* Author: Paul Wells\n*         Saudi Aramco Box 12959\n*         Dhahran\n*         Saudi Arabia\n*\n* Email:  paul.wells@aramco.com\n*\n* History:\n*\n*    PW 10/Jul/2002 - Original\n*\n***********************************************************************\n*\n         MACRO\n.* Set CSECT eyecatcher\n&NAME    @ID   &@IDN\n&NAME    J     @LAB&SYSNDX\n         DC    AL1(@LAB&SYSNDX-*)\n         AIF   (T'&@IDN EQ 'O').@IDL1\n         DC    C'&@IDN '\n         AGO   .@IDL2\n.@IDL1   ANOP\n         DC    C'&SYSECT '\n.@IDL2   ANOP\n         DC    C'&SYSDATC &SYSTIME &SYSJOB '\n         DC    C'&SYSIN_DSN',C'(',C'&SYSIN_MEMBER',C') '\n         DC    C'&SYSTEM_ID ',X'B4',C'Paul Wells (Saudi Aramco) 2002 '\n@LAB&SYSNDX DS 0H\n         MEND\n*\n         MACRO\n.* Execute the next instruction so as not to break the sequence\n.* of instructions, in order to preserve readability. We hate it\n.* when people execute instructions half a mile away in the code!\n&NAME    @EXNEXT &@EXNEXTL\n&NAME    LR    15,&@EXNEXTL\n         BCTR  15,0\n         BASR  14,0\n         AHI   14,@EXN&SYSNDX-*\n         EX    15,0(,14)\n         J     *+10\n@EXN&SYSNDX EQU *\n         MEND\n*\n         MACRO\n.* Internal subroutine call\n&NAME    @BAS  &@BASLOC\n         CNOP  2,4\n&NAME    BASR  15,0\n         AHI   15,@BAS1&SYSNDX-*\n         J     @BAS2&SYSNDX\n@BAS1&SYSNDX DC A(&@BASLOC)\n@BAS2&SYSNDX EQU *\n         L     15,0(,15)\n         BASR  14,15\n         MEND\n*\n         MACRO\n.* Init a field (max length 257 chars)\n&NAME    @CLEAR &@CLR1,&@CLR2\n         AIF   (T'&@CLR2 EQ 'O').@CLR2\n&@CLR3   SETC  '&@CLR2'\n         AGO   .@CLR3\n.@CLR2   ANOP\n&@CLR3   SETC  'C'' '''\n.@CLR3   ANOP\n&NAME    MVI   &@CLR1,&@CLR3\n         MVC   &@CLR1+1(L'&@CLR1-1),&@CLR1\n         MEND\n*\n         MACRO\n.* Format the RC messages\n&NAME    @FMTRC &WRCLIT,&@NONE\n&NAME    MVC   RCCALL(L'&WRCLIT),&WRCLIT\n         LA    15,L'&WRCLIT\n         STC   15,RCCLEN\n         AIF   ('&@NONE' EQ 'NOERRNO').@FMTRC10\n         MVI   RCEN,0\n         AGO   .@FMTRC40\n.@FMTRC10 ANOP\n         MVI   RCEN,1\n.@FMTRC40 ANOP\n         @BAS  FMTRC\n         MEND\n*\n         MACRO\n.* WTO and PUT out the RC messages\n&NAME    @SAYMSG &@SAYM2\n&NAME    NOP   0\n         AIF   (T'&@SAYM2 EQ 'O').@SAYM2\n         MVI   TXTW,0\n         LA    15,L'&@SAYM2\n         STC   15,TXTW+1\n         @EXNEXT 15                Move in call name\n         MVC   TXTW+2(0),&@SAYM2   *executed*\n.@SAYM2  ANOP\n         TM    FLAG,FLAGNWTO       $NOWTO set ?\n         JO    @SAY1&SYSNDX        Skip if yes\n         WTO   TEXT=TXTW,MF=(E,WTO1) Issue message\n@SAY1&SYSNDX DS 0H\n         TM    FLAG,FLAGNOF        No SYSPRINT DD ?\n         JO    @SAY2&SYSNDX        Skip if yes\n         ICM   15,3,TXTW           Get WTO length\n         LA    15,4(,15)           Add 4 for RDW\n         LA    14,TXTW             Point to start of message\n         BCTR  14,0                Decrement\n         BCTR  14,0                Decrement\n         STCM  15,3,0(14)          Save length in RDW\n         XC    2(2,14),2(14)       Clear span indicator in RDW\n         LR    0,14                Set record address\n         PUT   SYSPRINT,(0)        Put it out\n@SAY2&SYSNDX DS 0H\n         MEND\n*\n         MACRO\n.* Convert a hex value to printable EBCDIC\n&NAME    @HEXCONV &@HXOUT,&@HXIN\n&NAME    UNPK  UNPKWORK((L'&@HXIN*2)+1),&@HXIN.(L'&@HXIN+1)\n         TR    UNPKWORK(L'&@HXIN*2),ST.HEXTAB-C'0'\n         MVC   &@HXOUT.(L'&@HXIN*2),UNPKWORK\n         MEND\n*\n         MACRO\n.* Convert an IP address to printable EBCDIC\n&NAME    @IPACONV &@IPABIN,&@IPACHR,&@IPALEN\n&NAME    LA    R14,&@IPABIN        Set address of input bin IP\n         LA    R15,&@IPACHR        Set address of output printable IP\n         LA    R0,&@IPALEN         Set address of output length\n         STM   R14,R0,IPAPARMS     Save parms\n         LA    R1,IPAPARMS         Point to parms\n         @BAS  IPACONV             Call IPA convert subroutine\n         MEND\n*\n*\n* Start of main CSECT\n*\nHPNSTST  CSECT ,                   Establish the csect\nHPNSTST  AMODE 31                  It addresses all storage\nHPNSTST  RMODE ANY                 It can reside anywhere\n         @ID   ,                   CSECT eyecatacher\n         BAKR  R14,0               Save callers registers\n         L     R9,0(,R1)           Get address of parm area\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         STORAGE OBTAIN,LOC=BELOW,LENGTH=WORKL Getmain work area\n         DROP  R11                 Drop temp base reg\n         LR    R13,R1              Set work area reg\n         USING WORKA,R13           Map work area\n         BASR  R12,0               Get current location\n         AHI   R12,STATIC-*        Add offset to static area\nST       USING STATIC,R12          Map static area with R12\n         MVC   4(L'F1SA,R13),ST.F1SA Indicate linkage stack\n         @BAS  INIT                Initialise subroutine\n         @BAS  IPIBMO              GETIBMOPT subroutine\n         @BAS  IPINIT              INITAPI subroutine\n         @BAS  IPGCLI              GETCLIENTID subroutine\n         @BAS  IPGHI               GETHOSTID subroutine\n         @BAS  IPGHN               GETHOSTNAME subroutine\n         MVC   IPBINGHBA,IPBIN     Switch IP addresses\n         @BAS  IPGHBA              GETHOSTBYADDR subroutine\n         @BAS  IPGHBN              GETHOSTBYNAME subroutine\n         @BAS  IPSOCK              SOCKET subroutine\n         XC    SOCKIPA,SOCKIPA     Set bind to INADDR_ANY 0.0.0.0\n         @BAS  IPBIND              BIND subroutine\n         @BAS  IPGSKN              GETSOCKNAME subroutine\n         @BAS  IPCLOS              CLOSE subroutine\n*\n* Bind to each IP address returned by GETHOSTBYNAME\n*\n         LA    R5,MAXIPA           Get max IPs allowed\n         LA    R4,GHBNIPAS         Point to start of IPs returned\nMAIN10   DS    0H\n         ICM   R8,15,0(R4)         Get IP\n         JZ    MAIN20              Skip if last\n         @BAS  IPSOCK              SOCKET subroutine\n         STCM  R8,15,SOCKIPA       Bind to specific IP address\n         @BAS  IPBIND              BIND subroutine\n         @BAS  IPGSKN              GETSOCKNAME subroutine\n         @BAS  IPCLOS              CLOSE subroutine\n         LA    R4,4(,R4)           Increment IP table\n         JCT   R5,MAIN10           Loop until MAXIPA reached\nMAIN20   DS    0H\n         @BAS  IPTERM              TERMAPI subroutine\n         TM    FLAG,FLAGFAIL       Any failures indicated ?\n         JNO   MAIN30              Skip if no\n         @SAYMSG ST.MTOTXT09       Output bad message\n         LA    R15,12              Set RC 12\n         ST    R15,EXITRC          Save exit RC\n         J     MAIN40\nMAIN30   DS    0H\n         @SAYMSG ST.MTOTXT10       Output good message\nMAIN40   DS    0H\n         TM    FLAG,FLAGNOF        Any SYSPRINT present ?\n         JO    MAIN50              Skip close if no\n         CLOSE (SYSPRINT),MODE=31,MF=(E,CLOSEL)\nMAIN50   DS    0H\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         STORAGE RELEASE,LENGTH=WORKL,ADDR=(R13) Free work area\n         DROP  R11                 Drop temp base reg\n         L     R15,EXITRC          Get back RC\n         PR    ,                   Restore R2-R14 and return\n*\n* Initialise work area and generate start message\n*\nINIT     DS    0H\n         BAKR  R14,0               Save regs on stack\n         LA    R14,ST.MACROMASKS\n         LA    R15,MACROMASKS_LENGTH\n         LA    R0,MACROEXECS\n         LR    R1,R15\n         MVCL  R0,R14              Initialise macro masks\n         XC    HNAM2L(L'HNAM2L+1),HNAM2L Clear host name\n         MVI   FLAG,0              Clear flag\n         XC    EXITRC,EXITRC       Clear exit RC\n         LTR   R9,R9               Any port number parm ?\n         JZ    INIT10              Skip if no\n         SR    R1,R1\n         ICM   R1,1,1(R9)          Get length of parm\n         JZ    INIT10              Skip if zero\n         LA    R5,5\n         CLR   R1,R5               Parm longer than 5 ?\n         JH    INIT10              Skip if yes\n         @EXNEXT R1                Convert parm to packed decimal\n         PACK  DWORD,2(0,R9)       *executed*\n         CVB   R15,DWORD           Convert to binary\n         STCM  R15,3,PORT          Save requested port number\n         J     INIT20\nINIT10   DS    0H\n         MVC   PORT,ST.PORTD       Use default port\nINIT20   DS    0H\n         DEVTYPE ST.DD$NOWTO,DWORD Check for $NOWTO DD\n         LTR   R15,R15             $NOWTO DD present ?\n         JNZ   INIT30              Skip if no\n         OI    FLAG,FLAGNWTO       Set flag to suppress WTOs\nINIT30   DS    0H\n         DEVTYPE ST.DDSYSPRT,DWORD Check for message DD\n         LTR   R15,R15             Message DD present ?\n         JNZ   INIT40              Skip if no\n         MVC   SYSPRINT+(DCBDDNAM-IHADCB)(L'DDSYSPRT),ST.DDSYSPRT\n         OPEN  (SYSPRINT,(OUTPUT)),                                    *\n               MODE=31,MF=(E,OPENL)\n         TM    SYSPRINT+(DCBOFLGS-IHADCB),DCBOFOPN Open OK ?\n         JO    INIT50              Skip if yes\nINIT40   DS    0H\n         OI    FLAG,FLAGNOF        Set flag for no message DD\nINIT50   DS    0H\n         @CLEAR TXTW               Clear message text\n         MVI   TXTW,0              Set unused 1st byte to zero\n         LA    R6,TXTW+2           Get message start\n         MVC   0(L'MTOID02,R6),ST.MTOID02 Move in start of message\n         LA    R6,L'MTOID02+1(,R6)   Bump length\n         ICM   R7,15,PSATOLD-PSA   Get current TCB\n         JZ    INIT80              Skip if none\n         ICM   R7,15,TCBRBP-TCB(R7) Get current RB\n         JZ    INIT80              Skip if none\n         LA    R8,RBBASIC-RBPRFX   Length of RB prefix\n         SLR   R7,R8               Back up to RB prefix\n         ICM   R7,15,RBCDE-RBPRFX(R7) Get current CDE\n         JZ    INIT80              Skip if none\n         LA    R2,L'CDNAME         Max length of program name\n         LA    R7,CDNAME-CDENTRY(,R7) Point to program name\nINIT60   DS    0H\n         CLI   0(R7),C' '          Found a space ?\n         JE    INIT70              If yes, then its end of prog name\n         MVC   0(1,R6),0(R7)       Save the character into message\n         LA    R7,1(,R7)           Bump source position\n         LA    R6,1(,R6)           Bump target\n         JCT   R2,INIT60           Loop until end of program name\nINIT70   DS    0H\n         LA    R6,1(,R6)           Bump length\nINIT80   DS    0H\n         MVC   0(L'SIGLIT,R6),ST.SIGLIT Move in literal\n         LA    R6,L'SIGLIT(,R6)    Bump length\n         TIME  DEC,USECSTOD,ZONE=LT,LINKAGE=SYSTEM,DATETYPE=DDMMYYYY,  *\n               MF=(E,TIMEL)\n         LTR   R15,R15             Bad RC ?\n         JNZ   INIT90              Skip if yes\n         SR    R8,R8               Clear\n         SR    R9,R9               Clear\n         ICM   R8,15,USECSTOD+8    Get DDMMYYYY\n         SRDL  R8,4                Shift right 4 nibbles\n         STM   R8,R9,PDATE         Store\n         OI    PDATE+4,X'0C'       Make packed\n         MVC   DATEOUT,ST.DATEMASK Set ED mask\n         ED    DATEOUT,PDATE       Convert to printable\n         MVC   1(3,R6),DATEOUT+1   Move in DD/\n         MVC   7(5,R6),DATEOUT+6   Move in /YYYY\n         SR    R9,R9               Clear\n         ICM   R9,1,USECSTOD+9     Get month\n         BCTR  R9,0                Decrement\n         MH    R9,ST.HWTHREE       x3\n         LA    R8,ST.MONTAB(R9)    Offset into month table\n         MVC   4(3,R6),0(R8)       Move in month\n         LA    R6,12(,R6)          Bump length\n         SR    R8,R8               Clear\n         ICM   R8,7,USECSTOD       Get HHMMSS\n         SLL   R8,4                Shift left 4 nibbles\n         ST    R8,PTIME            Store\n         OI    PTIME+3,X'0C'       Make packed\n         MVC   0(L'TIMEMASK,R6),ST.TIMEMASK Set ED mask\n         ED    0(L'TIMEMASK,R6),PTIME Convert to printable\n         MVI   0(R6),C' '          Fix space\n         LA    R6,L'TIMEMASK(,R6)  Bump target\nINIT90   DS    0H\n         LA    R6,1(,R6)           Bump target\n         MVC   0(L'SYSLIT,R6),ST.SYSLIT Move in literal\n         LA    R6,L'SYSLIT(,R6)    Bump length\n         L     R7,CVTPTR           Point to CVT\n         MVC   0(L'CVTSNAME,R6),CVTSNAME-CVT(R7) Get system name\n         LA    R6,L'CVTSNAME(,R6)  Bump length\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nINITX    DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* GETIBMOPT subroutine\n*\nIPIBMO   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=GETIBMOPT,                                        *\n               COMMAND=1,                                              *\n               BUF=IBMOBUF,                                            *\n               ERRNO=ERRNO,                                            *\n               RETCODE=RETCODE\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.GETIBMOPT       Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPIBMO10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPIBMO10 DS    0H\n         @SAYMSG ,                 Output message to SYSPRINT and cons\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JE    IPIBMOX             Skip if yes\n         ICM   R4,15,IBMOBUF       Any info returned ?\n         JZ    IPIBMOX             Skip if no\n         SR    R2,R2\n         LA    R3,IBMOBUF+4\nIPIBMO20 DS    0H\n         LA    R2,1(,R2)\n         @CLEAR TXTW               Clear message text\n         MVI   TXTW,0              Set unused 1st byte to zero\n         LA    R6,TXTW+2           Get message start\n         MVC   0(L'MTOID01,R6),ST.MTOID01 Move in start of message\n         LA    R6,L'MTOID01(,R6)   Bump length\n         CVD   R2,DWORD            Convert to packed decimal\n         UNPK  0(3,R6),DWORD+7(1)  Convert to zoned decimal\n         OI    2(R6),X'F0'         Fix sign\n         LA    R6,4(,R6)           Bump length\n         MVC   0(L'NAMLIT,R6),ST.NAMLIT Move in literal\n         LA    R6,L'NAMLIT(,R6)    Bump length\n         LA    R9,8                Max length of IP stack name\n         LA    R1,4(,R3)           Point to start of IP stack name\nIPIBMO25 DS    0H\n         CLI   0(R1),C' '          Found a space ?\n         JE    IPIBMO30            If yes, then its end of stack name\n         MVC   0(1,R6),0(R1)       Save the character into message\n         LA    R1,1(,R1)           Bump source position\n         LA    R6,1(,R6)           Bump target\n         JCT   R9,IPIBMO25         Loop until end of stack name\nIPIBMO30 DS    0H\n         LA    R6,1(,R6)           Bump length\n         MVC   0(L'VERLIT,R6),ST.VERLIT Move in literal\n         LA    R6,L'VERLIT(,R6)    Bump length\n         MVC   IBMOTM2,2(R3)       Save version of stack\n         @HEXCONV IBMOTM1,IBMOTM2  Convert to printable EBCDIC\n         MVC   0(L'IBMOTM1,R6),IBMOTM1 Put in message\n         LA    R6,L'IBMOTM1(,R6)   Bump length\n         MVI   0(R6),C''''\n         LA    R6,2(,R6)           Bump length\n         MVC   0(L'STALIT,R6),ST.STALIT Move in literal\n         LA    R6,L'STALIT(,R6)    Bump length\n         MVC   IBMOTM2,0(R3)       Save status of stack\n         @HEXCONV IBMOTM1,IBMOTM2  Convert to printable EBCDIC\n         MVC   0(L'IBMOTM1,R6),IBMOTM1 Put in message\n         LA    R6,L'IBMOTM1(,R6)   Bump length\n         MVI   0(R6),C''''\n         LA    R6,2(,R6)           Bump length\n         SR    R7,R7               Clear\n         IC    R7,0(,R3)           Get 1st byte of status\n         SRL   R7,4                Lose 2nd nibble\n         LA    R8,8\n         CLR   R7,R8               Exceeds our branch table ?\n         JH    IPIBMO40            Skip if yes\n         SLL   R7,2                x4\n         BASR  R9,0                Kilroy woz ere\n         AHI   R9,IPIBMOBT-*       Set base of branch table\n         B     0(R7,R9)            Branch according to status\nIPIBMOBT DS    0H                  Branch table for status code\n         J     IPIBMOCU            Status x'0xxx'\n         J     IPIBMOC1            Status x'1xxx'\n         J     IPIBMOC2            Status x'2xxx'\n         J     IPIBMOC3            Status x'3xxx'\n         J     IPIBMOC4            Status x'4xxx'\n         J     IPIBMOCU            Status x'5xxx'\n         J     IPIBMOCU            Status x'6xxx'\n         J     IPIBMOCU            Status x'7xxx'\n         J     IPIBMOC8            Status x'8xxx'\nIPIBMOCU DS    0H\n         MVC   0(L'IBMOUNKN,R6),ST.IBMOUNKN Set unknown status\n         LA    R6,L'IBMOUNKN(,R6)  Bump length\n         J     IPIBMO40\nIPIBMOC1 DS    0H\n         MVC   0(L'IBMOSTOP,R6),ST.IBMOSTOP Set stopped status\n         LA    R6,L'IBMOSTOP(,R6)  Bump length\n         J     IPIBMO40\nIPIBMOC2 DS    0H\n         MVC   0(L'IBMODOWN,R6),ST.IBMODOWN Set down status\n         LA    R6,L'IBMODOWN(,R6)  Bump length\n         J     IPIBMO40\nIPIBMOC3 DS    0H\n         MVC   0(L'IBMOABND,R6),ST.IBMOABND Set abend status\n         LA    R6,L'IBMOABND(,R6)  Bump length\n         J     IPIBMO40\nIPIBMOC4 DS    0H\n         MVC   0(L'IBMOTERM,R6),ST.IBMOTERM Set terminating status\n         LA    R6,L'IBMOTERM(,R6)  Bump length\n         J     IPIBMO40\nIPIBMOC8 DS    0H\n         MVC   0(L'IBMOACT,R6),ST.IBMOACT Set active status\n         LA    R6,L'IBMOACT(,R6)   Bump length\n*\nIPIBMO40 DS    0H\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\n         @SAYMSG ,                 Output message to SYSPRINT and cons\n         LA    R3,12(,R3)          Point to info for next stack\n         JCT   R4,IPIBMO20         Loop for all stacks found\nIPIBMOX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* INITAPI subroutine\n*\nIPINIT   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=INITAPI,                                          *\n               MAXSOC=50,                                              *\n               MAXSNO=MAXSNO,                                          *\n               ERRNO=ERRNO,                                            *\n               RETCODE=RETCODE,                                        *\n               APITYPE=2,                                              *\n               ASYNC='NO'\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.INITAPI         Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPINIT10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPINIT10 DS    0H\n         @SAYMSG ,                 Output message to SYSPRINT and cons\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JE    ABENDFAIL           Skip if yes\nIPINITX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* TERMAPI subroutine\n*\nIPTERM   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=TERMAPI\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.TERMAPI,NOERRNO Format the RC\n         MVC   TXTW+22(L'NONELIT),ST.NONELIT No RC so we say (none)\n         IC    R5,TXTW+1\n         LA    R5,L'NONELIT-1(,R5) Fix length of WTO\n         STC   R5,TXTW+1           Save length of WTO\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nIPTERMX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* SOCKET subroutine\n*\nIPSOCK   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=SOCKET,                                           *\n               AF='INET',                                              *\n               ERRNO=ERRNO,                                            *\n               RETCODE=RETCODE,                                        *\n               SOCTYPE='STREAM'\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.SOCKET          Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPSOCK10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPSOCK10 DS    0H\n         @SAYMSG ,                 Output message to SYSPRINT and cons\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JE    ABENDFAIL           Skip if yes\n         MVC   SOCKDES,RETCODE+2\nIPSOCKX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* GETSOCKNAME subroutine\n*\nIPGSKN   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=GETSOCKNAME,                                      *\n               S=SOCKDES,                                              *\n               ERRNO=ERRNO,                                            *\n               RETCODE=RETCODE,                                        *\n               NAME=SOCKNAME\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.GETSOCKNAME     Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPGSKN10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPGSKN10 DS    0H\n         SR    R5,R5               Clear R5\n         IC    R5,TXTW+1           Get length of message so far\n         LA    R6,TXTW+2+1(R5)     Point to end of message (+ 1 space)\n         MVC   0(L'RETLIT,R6),ST.RETLIT Move in literal\n         LA    R6,L'RETLIT(,R6)    Bump length\n         MVC   0(L'PORTLIT,R6),ST.PORTLIT Move in literal\n         LA    R6,L'PORTLIT(,R6)   Bump length\n         SR    R9,R9\n         ICM   R9,3,SOCKPORT\n         CVD   R9,DWORD            Convert to packed decimal\n         UNPK  0(5,R6),DWORD+5(3)  Convert to zoned decimal\n         OI    4(R6),X'F0'         Fix sign\n         LA    R6,6(,R6)           Bump length\n         MVC   0(L'IPALIT,R6),ST.IPALIT Move in literal\n         LA    R6,L'IPALIT(,R6)    Bump length\n         @IPACONV SOCKIPA,0(,R6),IPAGSKNL Convert IP to printable\n         SR    R3,R3\n         IC    R3,IPAGSKNL\n         LA    R6,0(R3,R6)         Bump length\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nIPGSKNX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* GETCLIENTID subroutine\n*\nIPGCLI   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=GETCLIENTID,                                      *\n               ERRNO=ERRNO,                                            *\n               RETCODE=RETCODE,                                        *\n               CLIENT=CLISTR\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.GETCLIENTID     Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPGCLI10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPGCLI10 DS    0H\n         SR    R5,R5               Clear R5\n         IC    R5,TXTW+1           Get length of message so far\n         LA    R6,TXTW+2+1(R5)     Point to end of message (+ 1 space)\n         MVC   0(L'RETLIT,R6),ST.RETLIT Move in literal\n         LA    R6,L'RETLIT(,R6)    Bump length\n         MVC   0(L'TASKLIT,R6),ST.TASKLIT Move in literal\n         LA    R6,L'TASKLIT(,R6)   Bump length\n         @HEXCONV GCLIWORK,CLITASK1 Convert to printable EBCDIC\n         MVC   0(L'GCLIWORK,R6),GCLIWORK\n         LA    R6,L'GCLIWORK(,R6)  Bump length\n         @HEXCONV GCLIWORK,CLITASK2 Convert to printable EBCDIC\n         MVC   0(L'GCLIWORK,R6),GCLIWORK\n         MVI   L'GCLIWORK(R6),C''''\n         LA    R6,L'GCLIWORK+2(,R6) Bump length\n         MVC   0(L'NAMELIT,R6),ST.NAMELIT Move in literal\n         LA    R6,L'NAMELIT(,R6)   Bump length\n         MVC   0(L'CLINAME,R6),CLINAME\n         LA    R6,L'CLINAME(,R6)   Bump length\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nIPGCLIX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* BIND subroutine\n*\nIPBIND   DS    0H\n         BAKR  R14,0               Save regs on stack\n         LA    R15,2\n         STC   R15,SOCKFAM+1\n         MVC   SOCKPORT,PORT\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=BIND,                                             *\n               S=SOCKDES,                                              *\n               ERRNO=ERRNO,                                            *\n               RETCODE=RETCODE,                                        *\n               NAME=SOCKNAME\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.BIND            Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPBIND10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPBIND10 DS    0H\n         SR    R5,R5               Clear R5\n         IC    R5,TXTW+1           Get length of message so far\n         LA    R6,TXTW+2+1(R5)     Point to end of message (+ 1 space)\n         MVC   0(L'TOLIT,R6),ST.TOLIT Move in literal\n         LA    R6,L'TOLIT(,R6)     Bump length\n         MVC   0(L'PORTLIT,R6),ST.PORTLIT Move in literal\n         LA    R6,L'PORTLIT(,R6)   Bump length\n         SR    R9,R9\n         ICM   R9,3,SOCKPORT\n         CVD   R9,DWORD            Convert to packed decimal\n         UNPK  0(5,R6),DWORD+5(3)  Convert to zoned decimal\n         OI    4(R6),X'F0'         Fix sign\n         LA    R6,6(,R6)           Bump length\n         MVC   0(L'IPALIT,R6),ST.IPALIT Move in literal\n         LA    R6,L'IPALIT(,R6)    Bump length\n         @IPACONV SOCKIPA,0(,R6),IPABINDL Convert IP to printable\n         SR    R3,R3\n         IC    R3,IPABINDL\n         LA    R6,0(R3,R6)         Bump length\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nIPBINDX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* CLOSE subroutine\n*\nIPCLOS   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=CLOSE,                                            *\n               ERRNO=ERRNO,                                            *\n               RETCODE=RETCODE,                                        *\n               S=SOCKDES\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.CLOSE           Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPCLOS10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPCLOS10 DS    0H\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nIPCLOSX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* GETHOSTID subroutine\n*\nIPGHI    DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=GETHOSTID,                                        *\n               RETCODE=RETCODE\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.GETHOSTID,NOERRNO Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPGHI10             Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\n         J     IPGHI20\nIPGHI10  DS    0H\n         MVC   IPBIN,RETCODE       Save IP\n         @IPACONV IPBIN,IPA,IPAL   Convert IP to printable\n         SR    R5,R5               Clear R5\n         IC    R5,TXTW+1           Get length of message so far\n         LA    R6,TXTW+2+1(R5)     Point to end of message (+ 1 space)\n         MVC   0(L'RETLIT,R6),ST.RETLIT Move in literal\n         LA    R6,L'RETLIT(,R6)    Bump length\n         MVC   0(L'IPALIT,R6),ST.IPALIT Move in literal\n         LA    R6,L'IPALIT(,R6)    Bump length\n         SR    R7,R7\n         IC    R7,IPAL             Get IP length\n         @EXNEXT R7                Move in IP\n         MVC   0(0,R6),IPA         *executed*\n         LA    R6,0(R7,R6)         Bump length\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\nIPGHI20  DS    0H\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nIPGHIX   DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* GETHOSTNAME subroutine\n*\nIPGHN    DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         XC    FWORD,FWORD\n         LA    R6,L'HNAM2\n         STC   R6,FWORD+3\n         EZASMI TYPE=GETHOSTNAME,                                      *\n               NAMELEN=FWORD,                                          *\n               NAME=HNAM2,                                             *\n               ERRNO=ERRNO,                                            *\n               RETCODE=RETCODE\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.GETHOSTNAME     Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPGHN10             Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\n         J     IPGHN30\nIPGHN10  DS    0H\n         SR    R5,R5               Clear R5\n         IC    R5,TXTW+1           Get length of message so far\n         LA    R6,TXTW+2+1(R5)     Point to end of message (+ 1 space)\n         MVC   0(L'RETLIT,R6),ST.RETLIT Move in literal\n         LA    R6,L'RETLIT(,R6)    Bump length\n         MVC   0(L'HNLIT,R6),ST.HNLIT Move in literal\n         LA    R6,L'HNLIT(,R6)     Bump length\n         SR    R0,R0               Set search for x'00'\n         LA    R8,HNAM2            Start of search\nIPGHN20  DS    0H\n         SRST  R0,R8               Search for character\n         JO    IPGHN20             Loop until end of search\n         LA    R8,HNAM2\n         SR    R0,R8               Length of hostname in R0\n         STC   R0,HNAM2L           Set hostname length\n         LR    R7,R0\n         @EXNEXT R7                Move in hostname\n         MVC   0(0,R6),HNAM2       *executed*\n         LA    R6,0(R7,R6)         Bump length\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\nIPGHN30  DS    0H\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nIPGHNX   DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* GETHOSTBYADDR subroutine\n*\nIPGHBA   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         EZASMI TYPE=GETHOSTBYADDR,                                    *\n               HOSTADR=IPBINGHBA,                                      *\n               RETCODE=RETCODE,                                        *\n               HOSTENT=HOSTENT\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.GETHOSTBYADDR,NOERRNO Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPGHBA10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPGHBA10 DS    0H\n         SR    R5,R5               Clear R5\n         IC    R5,TXTW+1           Get length of message so far\n         LA    R6,TXTW+2+1(R5)     Point to end of message (+ 1 space)\n         MVC   0(L'USELIT,R6),ST.USELIT Move in literal\n         LA    R6,L'USELIT(,R6)    Bump length\n         MVC   0(L'IPALIT,R6),ST.IPALIT Move in literal\n         LA    R6,L'IPALIT(,R6)    Bump length\n         @IPACONV IPBINGHBA,0(,R6),IPAGHBAL Convert IP to printable\n         SR    R4,R4\n         IC    R4,IPAGHBAL\n         LA    R6,0(R4,R6)         Increment position\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JE    IPGHBA50            Skip if yes\n         L     R7,HOSTENT\n         ICM   R8,15,0(R7)         Get address of hostname\n         JZ    IPGHBA50            Skip if not found\n         MVC   1(L'RETLIT,R6),ST.RETLIT Move in literal\n         LA    R6,L'RETLIT+1(,R6)  Bump length\n         MVC   0(L'HNLLIT,R6),ST.HNLLIT Move in literal\n         LA    R6,L'HNLLIT(,R6)    Bump length\n         SR    R0,R0               Set search for x'00'\nIPGHBA20 DS    0H\n         SRST  R0,R8               Search for character\n         JO    IPGHBA20            Loop until end of search\n         LR    R9,R0\n         L     R8,0(,R7)           Get back hostname addr\n         SR    R0,R8               Length of hostname in R0\n         LR    R5,R6               Get current position in message\n         LA    R2,TXTW+2           Get start of message\n         SR    R5,R2               Get used length\n         LA    R1,MAXWTOL-1\n         SR    R1,R5               R1 contains what's left in WTO\n         JNP   IPGHBA50\n         CLR   R0,R1               Compare hostname len\n         JH    IPGHBA30            Skip if not enough\n         LR    R7,R0               Set length to hostname length\n         J     IPGHBA40\nIPGHBA30 DS    0H\n         LR    R7,R1               Set length to what's left\nIPGHBA40 DS    0H\n         @EXNEXT R7                Move in hostname\n         MVC   0(0,R6),0(R8)       *executed*\n         LA    R6,0(R7,R6)         Bump length\nIPGHBA50 DS    0H\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\n         @SAYMSG ,                 Output message to SYSPRINT and cons\nIPGHBAX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* GETHOSTBYNAME subroutine\n*\nIPGHBN   DS    0H\n         BAKR  R14,0               Save regs on stack\n         BASR  R11,0               Kilroy woz ere\n         USING *,R11               Set temp base reg for macro\n         XC    FWORD,FWORD\n         SR    R7,R7\n         IC    R7,HNAM2L           Get hostname length\n         STC   R7,FWORD+3\n         EZASMI TYPE=GETHOSTBYNAME,                                    *\n               NAMELEN=FWORD,                                          *\n               NAME=HNAM2,                                             *\n               RETCODE=RETCODE,                                        *\n               HOSTENT=HOSTENT\n         DROP  R11                 Drop temp base reg\n         @FMTRC ST.GETHOSTBYNAME,NOERRNO Format the RC\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JNE   IPGHBN10            Skip if no\n         MVI   TXTW+9,C'E'         Set error indicator in message\n         OI    FLAG,FLAGFAIL       Flag error for later\nIPGHBN10 DS    0H\n         SR    R5,R5               Clear R5\n         IC    R5,TXTW+1           Get length of message so far\n         LA    R6,TXTW+2+1(R5)     Point to end of message (+ 1 space)\n         MVC   0(L'USELIT,R6),ST.USELIT Move in literal\n         LA    R6,L'USELIT(,R6)    Bump length\n         MVC   0(L'HOSTLIT,R6),ST.HOSTLIT Move in literal\n         LA    R6,L'HOSTLIT(,R6)   Bump length\n         @EXNEXT R7                Move in hostname\n         MVC   0(0,R6),HNAM2       *executed*\n         LA    R6,0(R7,R6)         Bump length\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\n         @SAYMSG ,                 Output message to SYSPRINT and cons\n         CLC   RETCODE,ST.MINUSONE Call failed ?\n         JE    IPGHBNX             Skip if yes\n         L     R7,HOSTENT          Point to structure returned by TCPIP\n         L     R7,16(,R7)          Point to list of addresses of IPAs\n         SR    R9,R9               Zero IPs found counter\n         LA    R4,GHBNIPAS         Point to start of IPs returned\nIPGHBN20 DS    0H\n         XC    0(4,R4),0(R4)       Clear saved IP address\n         ICM   R8,15,0(R7)\n         JZ    IPGHBN30\n         LA    R9,1(,R9)           Increment IPs found counter\n         @CLEAR TXTW               Clear message text\n         MVI   TXTW,0              Set unused 1st byte to zero\n         LA    R6,TXTW+2           Get message start\n         MVC   0(L'MTOID05,R6),ST.MTOID05 Move in start of message\n         LA    R6,L'MTOID05(,R6)   Bump length\n         SR    R3,R3\n         IC    R3,HNAM2L           Get hostname length\n         @EXNEXT R3                Move in hostname\n         MVC   0(0,R6),HNAM2       *executed*\n         LA    R6,0(R3,R6)         Bump length\n         MVC   1(L'RETLIT,R6),ST.RETLIT Move in literal\n         LA    R6,L'RETLIT+1(,R6)  Bump length\n         MVC   0(L'IPALIT2,R6),ST.IPALIT2 Move in literal\n         LA    R6,L'IPALIT2(,R6)   Bump length\n         CVD   R9,DWORD            Convert to packed decimal\n         UNPK  0(3,R6),DWORD+7(1)  Convert to zoned decimal\n         OI    2(R6),X'F0'         Fix sign\n         MVI   3(R6),C'='\n         LA    R6,4(,R6)           Bump length\n         @IPACONV 0(,R8),0(,R6),IPAGHBNL Convert IP to printable\n         IC    R3,IPAGHBNL\n         LA    R6,0(R3,R6)         Bump length\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\n         @SAYMSG ,                 Output message to SYSPRINT and cons\n         MVC   0(4,R4),0(R8)       Save IP\n         LA    R7,4(,R7)           Bump source IPs\n         LA    R4,4(,R4)           Bump saved IPs\n         J     IPGHBN20            Loop\nIPGHBN30 DS    0H\n         LA    R5,MAXIPA           Get max IPs allowed\n         LA    R4,GHBNIPAS         Point to start of IPs returned\nIPGHBN40 DS    0H\n         ICM   R8,15,0(R4)         Get IP\n         JZ    IPGHBNX             Skip if last\n         STCM  R8,15,IPBINGHBA     Save IP for GETHOSTBYADDR\n         @BAS  IPGHBA              Call GETHOSTBYADDR subroutine\n         LA    R4,4(,R4)           Increment IP table\n         JCT   R5,IPGHBN40         Loop until MAXIPA reached\nIPGHBNX  DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* Format IP API RC & Errno subroutine\n*\nFMTRC    DS    0H\n         BAKR  R14,0               Save regs on stack\n         @CLEAR TXTW               Clear message text\n         MVI   TXTW,0              Set unused 1st byte to zero\n         LA    R6,TXTW+2           Get message start\n         MVC   0(L'MTOID00,R6),ST.MTOID00 Move in start of message\n         LA    R6,L'MTOID00+1(,R6) Bump length\n         SR    R10,R10\n         IC    R10,RCCLEN\n         @EXNEXT R10               Move in call\n         MVC   0(0,R6),RCCALL      *executed\n         LA    R6,1(R10,R6)        Bump length\n         MVC   0(L'RCLIT,R6),ST.RCLIT Move in literal\n         LA    R6,L'RCLIT(,R6)     Bump length\n         ICM   R10,15,RETCODE\n         JZ    FMTRC10\n         MVC   0(L'RCLIT2,R6),ST.RCLIT2 Move in literal\n         LA    R6,L'RCLIT2(,R6)    Bump length\n         @HEXCONV RCTXT,RETCODE    Convert to printable EBCDIC\n         MVC   0(L'RCTXT,R6),RCTXT\n         LA    R6,L'RCTXT(,R6)\n         MVI   0(R6),C''''\n         LA    R6,1(,R6)           Bump length\n         J     FMTRC20\nFMTRC10  DS    0H\n         MVI   0(R6),C'0'          Set RC=0\n         LA    R6,1(,R6)           Bump length\n         J     FMTRC40             If RC 0 then errno is not relevant\nFMTRC20  DS    0H\n         ICM   R10,1,RCEN          Errno requested ?\n         JNZ   FMTRC40             Skip if no\n         MVC   0(L'ENLIT,R6),ST.ENLIT Move in literal\n         LA    R6,L'ENLIT(,R6)     Bump length\n         ICM   R10,15,ERRNO\n         JZ    FMTRC30\n         CVD   R10,DWORD           Convert to packed decimal\n         UNPK  0(6,R6),DWORD+4(4)  Convert to zoned decimal\n         OI    5(R6),X'F0'         Fix sign\n         LA    R6,6(,R6)           Bump length\n         J     FMTRC40\nFMTRC30  DS    0H\n         MVI   0(R6),C'0'\n         LA    R6,1(,R6)           Bump length\nFMTRC40  DS    0H\n         LA    R5,TXTW+2           Get message start\n         SR    R6,R5               Subtract start from curr position\n         STC   R6,TXTW+1           Save new length\nFMTRCX   DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* Convert a binary IP address to printable EBCDIC\n*\nIPACONV  DS    0H\n         BAKR  R14,0               Save regs on stack\n         LR    R2,R1               Save parm address\n         L     R8,0(,R2)           Get inpit IP binary\n         @CLEAR IPW17              Clear work area\n         LA    R9,IPW17            Point to work area\n         SR    R4,R4               Zero ip zone length\n         LA    R3,4                Set digits in ip addr\n         LA    R5,1(,R9)           Point to ip zoned\nIPCON10  DS    0H\n         SR    R15,R15\n         IC    R15,0(,R8)          Get this digit\n         CVD   R15,DWORD           Convert to packed decimal\n         UNPK  IPWORK,DWORD+6(2)   Convert to zoned decimal\n         OI    IPWORK+L'IPWORK-1,X'F0' Fix sign\n         LA    R7,2                Set counter\n         LA    R6,IPWORK           Point to 1st char\nIPCON20  DS    0H\n         CLI   0(R6),C'0'          Zero ?\n         JNE   IPCON30             Skip if no\n         LA    R6,1(,R6)           Set next digit\n         JCT   R7,IPCON20          Loop\nIPCON30  DS    0H\n         LA    R7,1(,R7)           Ensure 1 significant digit\n         @EXNEXT R7                Save this part of addrress\n         MVC   0(0,R5),0(R6)       *executed*\n         LA    R5,0(R7,R5)         Set next in IPZONED\n         LA    R4,0(R7,R4)         Add to ipzone length\n         CL    R3,ST.ONE           Last loop ?\n         JE    IPCON40             Skip if yes\n         MVI   0(R5),C'.'          Set period\n         LA    R5,1(,R5)           Increment for period\n         LA    R4,1(,R4)           Increment for period\nIPCON40  DS    0H\n         LA    R8,1(,R8)           Set next digit\n         JCT   R3,IPCON10          Loop\n         STC   R4,0(,R9)           Store this character\n         L     R3,4(,R2)           Point to output\n         MVC   0(15,R3),1(R9)      Move IP to output (max length 15)\n         LA    R0,C' '             Set search for space\nIPCON50  DS    0H\n         SRST  R0,R3               Search for character\n         JO    IPCON50             Loop until end of search\n         L     R3,4(,R2)           Point to start of output\n         SR    R0,R3               Length of IPA in R0\n         L     R3,8(,R2)           Point to output length\n         STC   R0,0(,R3)           Return output length\nIPCONX   DS    0H\n         PR    ,                   Restore R2-R14 and return\n*\n* Abend routine\n*\nABENDFAIL DS   0H\n         @SAYMSG ST.MTOTXT08       Output bad message\n         ABEND 999,DUMP\n*\n* Static area for RX-type constants\n* Mapped by R12\n*\nSTATIC   DS    0H\n*\nMACROMASKS DS  0D\n         WTO   TEXT=0,ROUTCDE=(2),DESC=(6),MF=L\n         DCB   MACRF=(PM),BUFNO=5,DSORG=PS,                            *\n               RECFM=VB,LRECL=MAXWTOL+4\n         OPEN  (,),MODE=31,MF=L\n         CLOSE (,),MODE=31,MF=L\nMACROMASKS_LENGTH EQU *-MACROMASKS\nONE      DC    F'1'\nMINUSONE DC    F'-1'\nHWTHREE  DC    H'3'\nPORTD    DC    AL2(DFLTPORT)       Default port\nGETIBMOPT DC   C'GETIBMOPT'\nGETHOSTID DC   C'GETHOSTID'\nGETHOSTNAME DC C'GETHOSTNAME'\nGETSOCKNAME DC C'GETSOCKNAME'\nGETCLIENTID DC C'GETCLIENTID'\nINITAPI  DC    C'INITAPI'\nGETHOSTBYADDR DC C'GETHOSTBYADDR'\nGETHOSTBYNAME DC C'GETHOSTBYNAME'\nSOCKET   DC    C'SOCKET'\nBIND     DC    C'BIND'\nCLOSE    DC    C'CLOSE'\nTERMAPI  DC    C'TERMAPI'\n*\n* Static forms of messages issued\n*\nMTOID00  DC    C'HPNST00I'\nRCLIT    DC    C'RC='\nRCLIT2   DC    C'x'''\nENLIT    DC    C' Errno='\n*\nMTOID01  DC    C'HPNST01I GETIBMOPT returns IP stack '\nNAMLIT   DC    C'named '\nVERLIT   DC    C'at version x'''\nSTALIT   DC    C'status x'''\n*\nMTOID02  DC    C'HPNST02I'\nSIGLIT   DC    C'HPNS test program at'\nSYSLIT   DC    C'on system '\n*\nMTOID05  DC    C'HPNST05I GETHOSTBYNAME using Host='\n*\nMTOTXT08 DC    C'HPNST08E HPNS API critical error - immediate abend'\n*\nMTOTXT09 DC    C'HPNST09E HPNS API test failed - check prior messages f*\n               or reason'\n*\nMTOTXT10 DC    C'HPNST10I HPNS API test successful'\n*\n*\nF1SA     DC    C'F1SA'\nNONELIT  DC    C'(none)'\nIPALIT   DC    C'IPA='\nIPALIT2  DC    C'IPA'\nHNLIT    DC    C'Shortname='\nHNLLIT   DC    C'Hostname='\nHOSTLIT  DC    C'Host='\nPORTLIT  DC    C'Port='\nNAMELIT  DC    C'Name='\nUSELIT   DC    C'using '\nRETLIT   DC    C'returns '\nTOLIT    DC    C'to '\nTASKLIT  DC    C'Task=x'''\nHEXTAB   DC    C'0123456789ABCDEF'\nIBMOACT  DC    C'(active)'\nIBMOTERM DC    C'(terminating)'\nIBMODOWN DC    C'(down)'\nIBMOSTOP DC    C'(stopped)'\nIBMOABND DC    C'(abended)'\nIBMOUNKN DC    C'(unknown)'\nMONTAB   DC    C'JanFebMarAprMayJunJulAugSepaaabbbcccdddeeefffOctNovDec*\n               '\nTIMEMASK DC    X'2120207A20207A2020'\nDATEMASK DC    X'2120204020204020202020'\n*\n* Program defaults\n*\nMAXWTOL  EQU   125                 Max length of message\nMAXIPA   EQU   32                  Max local IP addresses\nDDSYSPRT DC    CL8'SYSPRINT'       Message ddname (if present)\nDD$NOWTO DC    CL8'$NOWTO'         Suppress WTO ddname (if present)\nDFLTPORT EQU   47319               Default port D1800 47319 xos KY\n*\n* Dynamic getmained work area\n*\nWORKA    DSECT\n         DS    18F\nMACROEXECS DS  0D\nWTO1     WTO   TEXT=0,ROUTCDE=(2),DESC=(6),MF=L\nSYSPRINT DCB   MACRF=(PM),BUFNO=5,DSORG=PS,                            *\n               RECFM=VB,LRECL=MAXWTOL+4\nOPENL    OPEN  (,),MODE=31,MF=L\nCLOSEL   CLOSE (,),MODE=31,MF=L\n*\nDWORD    DS    D\nFWORD    DS    F\nERRNO    DS    F\nRETCODE  DS    F\nEXITRC   DS    F\nHOSTENT  DS    F\nIPBIN    DS    F\nIPBINGHBA DS   F\nMAXSNO   DS    F\nIPAPARMS DS    3F\nPTIME    DS    0F,PL4              0HHMMSSF\nPDATE    DS    0F,PL5,XL3          0DDMMYYYYF\n         EZASMI TYPE=TASK,STORAGE=CSECT\nTIMEL    TIME  LINKAGE=SYSTEM,MF=L\nSOCKDES  DS    H\nPORT     DS    AL2\nIPWORK   DS    CL3\nRCTXT    DS    CL8\nRCCALL   DS    CL13\nRCCLEN   DS    XL1\nRCEN     DS    XL1\nERRNOTXT DS    CL6\nFLAG     DS    X\nFLAGFAIL EQU   1\nFLAGNOF  EQU   2\nFLAGNWTO EQU   4\nUNPKWORK DS    XL17\nIPW17    DS    CL17\nIPAGSKNL DS    X\nIPAGHBAL DS    X\nIPAGHBNL DS    X\nIPABINDL DS    X\nIPAL     DS    X\nIPA      DS    CL15\nHNAM2L   DS    X\nHNAM2    DS    CL24,X\n*\nSOCKNAME DS    0CL16             SOCKET NAME STRUCTURE\nSOCKFAM  DS    AL2               FAMILY\nSOCKPORT DS    AL2\nSOCKIPA  DS    AL4\n         DS    XL8\n*\nCLISTR   DS    0CL40             Client STRUCTURE\nCLIDOM   DS    AL4               FAMILY\nCLINAME  DS    CL8\nCLITASK1 DS    CL4\nCLITASK2 DS    CL4\n         DS    XL20\n*\nIBMOTM2  DS    XL2\nIBMOTM1  DS    XL4\nIBMOBUF  DS    CL100\nGCLIWORK DS    CL8\nUSECSTOD DS    CL16\nDATEOUT  DS    CL11\n*\nTEXTREC  DS    0CL258\n         DS    CL2\nTXTW     DS    CL256\n*\n* Last entry in work area\nGHBNIPAS DS    (MAXIPA)F           Saved IPs from GETHOSTBYNAME\n*\n*\nWORKL    EQU   *-WORKA\n*\n         DROP  R13,ST              Drop remaining regs\n*\n         YREGS ,                   Register equates\n         DCBD  DSORG=PS,DEVD=DA\n         IKJTCB LIST=NO\n         IHARB LIST=NO\n         IHACDE ,\n         IHAPSA LIST=NO\n         CVT   DSECT=YES\n*\n         END   ,                   End of HPNSTST module\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HPNSTSTJ": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x05\\x01\\x020\\x8f\\x01\\x03\\x07\\x0f\\x14\\x13\\x00\\x12\\x00\\x12\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-11-04T00:00:00", "modifydate": "2003-03-11T14:13:05", "lines": 18, "newlines": 18, "modlines": 0, "user": "AWCPAW"}, "text": "//AWCPAWTT JOB (AWC),PW,CLASS=M,MSGCLASS=X,REGION=7M,\n//         NOTIFY=&SYSUID\n//*\n//* AWCPAW.CBT.FILE600.ASM.PDS(HPNSTSTJ)\n//* JCL TO RUN HPNSTST (TCPIP HPNS API 'IVP')\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) AMEND STEPLIB AS REQUIRED\n//*\n//* HPNSTST\n//* - RUN HPNSTST PROGRAM TO 'IVP' TCIP VIA HPNS\n//*\n//HPNSTST  EXEC PGM=HPNSTST\n//STEPLIB  DD  DISP=SHR,DSN=AWCPAW.CBT.FILE600.LOAD\n//SYSUDUMP DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*        REMOVE TO SUPPRESS SYSPRINT MESSAGES\n//*$NOWTO   DD  DUMMY           INCLUDE TO SUPPRESS WTO MESSAGES\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MLWTO": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01H\\x008\\x01\\x02%\\x7f\\x01\\x04\\x06/\\x14\\x04\\x01\\xe8\\x01[\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.72", "flags": 0, "createdate": "2002-09-14T00:00:00", "modifydate": "2004-03-02T14:04:38", "lines": 488, "newlines": 347, "modlines": 0, "user": "AWCPAW"}, "text": "         TITLE 'MLWTO - LE-Compliant WTO function'\n***********************************************************************\n*\n* Name: MLWTO\n*\n* Abstract:\n*\n*    An LE compliant assembler function to issue a WTO from\n*    IBM C. The WTO will either be a single-line or multi-line\n*    WTO depending on the length of the input.\n*\n*    The program could be adapted for non-LE usage by changing\n*    the prologue and epilogue to use MVS-standard, rather than\n*    LE-specific linkage.\n*\n* Operation:\n*\n*    Receives a single parameter whose address is passed in R1. The\n*    first 2 bytes of the parameter indicate the length of the WTO\n*    text. The remaining bytes of the parameter are the variable\n*    length WTO text itself.\n*\n*    MLWTO attempts to determine whether it is running authorised. This\n*    is important for 2 reasons.\n*\n*      1) We have to determine whether we are allowed to issue\n*         branch-entry rather than SVC-entry WTO. In certain\n*         environments, e.g. some system exits, we are forbidden\n*         from issuing SVCs of any kind.\n*\n*      2) If we are 'authorised' then the length of a WTO is increased\n*         by 1. This means that single-line WTOs are 127 chars long\n*         when authorised and 126 chars when not. MLWTO lines are 71\n*         chars long when authorised and 70 chars when not. This is\n*         important when determining whether to issue an SLWTO or\n*         MLWTO and when splitting the lines of an MLWTO.\n*\n*     A single line WTO is issued if the input is 126 (127 auth)\n*     characters or less.\n*\n*     If the input is longer, then multiple (up to 255) lines of an\n*     MLWTO with line length 70 (71 auth) are built. In building the\n*     MLWTO, consideration is given to not splitting 'words' of the\n*     input over 2 lines.\n*\n* Environment:\n*\n*    IBM compatible mainframe (branch relative/immediate instructions\n*    must be supported)\n*\n*    IBM OS/390, z/OS or subsequent operating system\n*\n*    Tested with OS/390 2.9 on G5 and z/900 processors and with\n*    z/OS 1.2 on a z/900.\n*\n* Invocation:\n*\n*    From C code, see the example in AWCPAW.CBT.FILE600.C.PDS(WTOT)\n*\n*    As a C function, SPRNTLL is usually included in object form\n*    via a link edit. For an example see\n*    AWCPAW.CBT.FILE600.C.PDS(WTOTC)\n*\n*    MLWTO could also work with LE-compliant programs in other\n*    languages, but this has not been tested.\n*\n* Notes:\n*\n*    If link edited as a standalone module, MLWTO should\n*    be link edited RENT, AMODE 31, RMODE ANY and best placed\n*    in an authorised linklist or LPA library.\n*\n*    The assembler code does not use a base register, so the\n*    relative/immediate forms of branch instructions must be used.\n*\n*    To avoid USING conflicts when we have to temporarily provide\n*    a base register for some system macros, a literal pool\n*    is not available. Static literals must be placed by name in\n*    the 'STATIC' section and referenced via a labeled dependent\n*    USING by specifying an ST prefix.\n*\n*\n* Author: Paul Wells\n*         Saudi Aramco Box 12959\n*         Dhahran\n*         Saudi Arabia\n*\n* Email:  paul.wells@aramco.com\n*\n* History:\n*\n*    PW 18/Sep/2002 - Original\n*    PW 02/Mar/2004 - Fixed bug in GETLEN routine which caused\n*                     line length to sometimes be out by 1\n*\n***********************************************************************\n*\n         MACRO\n.* Execute the next instruction so as not to break the sequence\n.* of instructions, in order to preserve readability. We hate it\n.* when people execute instructions half a mile away in the code!\n&NAME    @EXNEXT &@EXNEXTL\n&NAME    LR    15,&@EXNEXTL\n         BCTR  15,0\n         BASR  14,0\n         AHI   14,@EXN&SYSNDX-*\n         EX    15,0(,14)\n         J     *+10\n@EXN&SYSNDX EQU *\n         MEND\n*\n         MACRO\n.* Internal subroutine call\n&NAME    @BAS  &@BASLOC\n         CNOP  2,4\n&NAME    BASR  15,0\n         AHI   15,@BAS1&SYSNDX-*\n         J     @BAS2&SYSNDX\n@BAS1&SYSNDX DC A(&@BASLOC)\n@BAS2&SYSNDX EQU *\n         L     15,0(,15)\n         BASR  14,15\n         MEND\n*\n*\nMLWTO    CSECT ,                   Establish the csect\nMLWTO    AMODE 31                  It addresses all storage\nMLWTO    RMODE ANY                 It can reside anywhere\n         EDCPRLG BASEREG=NONE,USRDSAL=WORKL LE compliant prologue\n         USING WORKA,R13           Map LE DSA\n         L     R11,0(,R1)          Get address of parm area\n         BASR  R12,0               Get current location\n         AHI   R12,STATIC-*        Add offset to static area\nST       USING STATIC,R12          Map static area\n         @BAS  INIT                Invoke Initialisation\n         LA    R8,2(,R11)          Get pointer to message text\n         CLC   0(2,R11),LINELENS   Fit on single line WTO ?\n         JH    MLWTOBLD            Skip if no\n         MVC   WTOLINES(2),0(R11)  Get length of data\n         IC    R3,1(,R11)          Put len in reg\n         @EXNEXT R3                Move data to WTO line\n         MVC   WTOLINES+2(0),0(R8) *EXECUTED*\n         LA    R3,WTOLINES         Point to WTO line\n         SR    R0,R0               Clear R0\n         TM    FLAG,FLBRWTO        Auth for BR-entry WTO ?\n         JO    SLWTOA              Skip if yes\n         WTO   TEXT=(R3),MF=(E,WTOE1) Issue WTO (single line)\n         J     GETOUT              Skip MLWTO\nSLWTOA   DS    0H\n         WTO   TEXT=(R3),LINKAGE=BRANCH,MF=(E,WTOE1) WTO (single line)\n         J     GETOUT              Skip MLWTO\nMLWTOBLD DS    0H\n         @BAS  FLINE               Invoke first line processing\n         LM    R4,R7,0(R1)         Get saved Regs passed back\n         @BAS  RMLINE              Invoke processing for rest of lines\n         SR    R0,R0               Clear R0\n         TM    FLAG,FLBRWTO        Auth for BR-entry WTO ?\n         JO    MLWTOA              Skip if yes\n         WTO   MF=(E,WTOE2)        Issue MLWTO\n         J     GETOUT              Skip\nMLWTOA   DS    0H\n         LA    R1,WTOE2\n         WTO   LINKAGE=BRANCH,MF=(E,WTOE2) Issue MLWTO\nGETOUT   DS    0H\n         EDCEPIL ,                 LE compliant epilogue\n*\n* INIT\n*\nINIT     DS    0H\n         BAKR  R14,0               Stack regs\n         LA    R14,ST.MACROMASKS\n         LA    R15,MACROMASKS_LENGTH\n         LA    R0,MACROEXECS\n         LR    R1,R15\n         MVCL  R0,R14              Initialise macros\n         MVI   FLAG,0              Reset flag byte\n         MVC   LINELENS,ST.ALINELENSU Default unauth 126 char SLWTO\n         MVC   LINELENM,ST.ALINELENMU Default unauth 70 char MLWTO\n         TM    X'A3'(0),X'01'      z/architecture present ?\n*        TM    FLCARCH-PSA(0),PSAZARCH z/architecture present ?\n         JNO   INIT10              Skip if no\n         @BAS  AUTHZCHK            Authorisation check (z/Arch)\n         J     INITX\nINIT10   DS    0H\n         @BAS  AUTHECHK            Authorisation check (not z/Arch)\nINITX    DS    0H\n         PR\n*\n* AUTHZCHK (z/Arch and above)\n* 2 levels of authorisation are checked by this routine\n*   1) Authorised to write 127 line WTOs and 71 line MLWTOs.\n*      (non-authorised programs write 126 line WTOs and 70 line MLWTOs)\n*      127 line WTOs and 71 line MLWTOs are authorised by any\n*      one of APF, KEY0-7 or supervisor state.\n*   2) Authorised to use branch entry WTO. This requires KEY0-7 and\n*      supervisor state.\n* The EPSW instruction is used. This was first available on z/Arch\n* but was supposedly retrofitted to ESA/390. Since we don't know how\n* to check for it's availability in ESA/390, we only use it only on\n* z/Arch and above.\n*\nAUTHZCHK DS    0H\n         BAKR  R14,0               Stack regs\n         ICM   R15,15,PSATOLD-PSA(0) SRB mode ?\n         JZ    AUTHZC40            Skip if yes\n         L     R15,TCBJSCB-TCB(,R15) Get JSCB\n         USING IEZJSCB,R15         Map JSCB\n         TM    JSCBOPTS,JSCBAUTH   APF auth ?\n         JNO   AUTHZC10            Skip if no\n         DROP  R15\n         OI    FLAG,FLAPF          Set APF flag\nAUTHZC10 DS    0H\n*        EPSW  R1,0                Get left half of PSW\n         DC    0H,X'B98D0010'      EPSW  R1,0\n         CLM   R1,B'0100',ST.KEY8  KEY < 8 ?\n         JNL   AUTHZC20            Skip if no\n         OI    FLAG,FLKEY0_7       Set KEY0-7 flag\nAUTHZC20 DS    0H\n         N     R1,ST.PROBSTATE     Problem state ?\n         JNZ   AUTHZC30            Skip if yes\n         OI    FLAG,FLSUPV         Set supervisor state flag\nAUTHZC30 DS    0H\n         TM    FLAG,FLAPF+FLKEY0_7+FLSUPV Any of APF/KEY0-7/SUPV ?\n         JZ    AUTHZCHKX           Skip if no\n         TM    FLAG,FLKEY0_7+FLSUPV KEY0-7+SUPV ?\n         JNO   AUTHZC50            Skip if no\nAUTHZC40 DS    0H\n         OI    FLAG,FLBRWTO        Set BRWTO flag\nAUTHZC50 DS    0H\n         OI    FLAG,FLPLUS1\n         MVC   LINELENS,ST.ALINELENSA Auth 127 char SLWTO\n         MVC   LINELENM,ST.ALINELENMA Auth 71 char MLWTO\nAUTHZCHKX DS   0H\n         PR\n*\n* AUTHECHK (not z/Arch)\n* 2 levels of authorisation are checked by this routine\n*   1) Authorised to write 127 line WTOs and 71 line MLWTOs.\n*      (non-authorised programs write 126 line WTOs and 70 line MLWTOs)\n*      127 line WTOs and 71 line MLWTOs are authorised by any\n*      one of APF, KEY0-7 or supervisor state.\n*   2) Authorised to use branch entry WTO. This requires KEY0-7 and\n*      supervisor state.\n* The TESTAUTH SVC is used.\n*\nAUTHECHK DS    0H\n         BAKR  R14,0               Stack regs\n         ICM   R15,15,PSATOLD-PSA  SRB mode ?\n         JZ    AUTHEC10            Assume auth if yes\n         L     R2,TCBRBP-TCB(,R15)\n         SH    R2,ST.LENRBPRE\n         CLI   RBSTAB1-RBPRFX(R2),RBFTPRB In a PRB ?\n         JNE   AUTHEC10            Assume auth if not in PRB\n         BASR  R14,0               Kilroy woz ere\n         USING *,R14               Map 'ere'\n         TESTAUTH FCTN=1,STATE=YES,KEY=YES,RBLEVEL=1 APF/KEY0/SUPV ?\n         DROP  R14\n         LTR   R15,R15             APF/KEY0/SUPV ?\n         JNZ   AUTHECHKX           Skip if not any of APF/KEY0/SUPV\n         MVC   LINELENS,ST.ALINELENSA Auth 127 char SLWTO\n         MVC   LINELENM,ST.ALINELENMA Auth 71 char MLWTO\n         BASR  R14,0               Kilroy woz ere\n         USING *,R14               Map 'ere'\n         TESTAUTH FCTN=0,STATE=YES,KEY=NO,RBLEVEL=1 SUPV ?\n         DROP  R14\n         LTR   R15,R15\n         JNZ   AUTHECHKX           Skip if not SUPV\n         BASR  R14,0               Kilroy woz ere\n         USING *,R14               Map 'ere'\n         TESTAUTH FCTN=0,STATE=NO,KEY=YES,RBLEVEL=1 KEY 0 ?\n         DROP  R14\n         LTR   R15,R15\n         JNZ   AUTHECHKX           Skip if not KEY0\nAUTHEC10 DS    0H\n         OI    FLAG,FLBRWTO\n         MVC   LINELENS,ST.ALINELENSA Auth 127 char SLWTO\n         MVC   LINELENM,ST.ALINELENMA Auth 71 char MLWTO\nAUTHECHKX DS   0H\n         PR\n*\n* Format the first line of the MLWTO\n*\nFLINE    DS    0H\n         BAKR  R14,0               Stack regs\n* Internal Register usage\n*  r4 remaining data len\n*  r5 pointer to data\n*  r2 current line len\n*  r6 pointer to next WTO line address pointer (on exit)\n*  r7 pointer to next WTO line text location (on exit)\n         LA    R5,2(,R11)          Get pointer to message text\n         SR    R4,R4               Clear\n         ICM   R4,3,0(R11)         Get pointer to message len\n         SR    R6,R6               Clear\n         IC    R6,WTOE2+8+(WPXLNGTH-WPX) Get len of WPL\n         LA    R6,WTOE2+8(R6)      Point to end of WPL\n         CH    R4,LINELENM         More than a lines worth ?\n         JH    FLINE10             Skip if yes\n         LR    R2,R4               Set line len to data len\n         MVI   0(R6),WPLLTFC+WPLLTFD Set type 'data end' line\n         J     FLINE20\nFLINE10  DS    0H\n         MVI   0(R6),WPLLTFC       Set type 'data' line\n         @BAS  GETLEN\n         LR    R2,R1               Get Assigned length\nFLINE20  DS    0H\n         LA    R6,WPLLINES-WPLLTF(,R6) Point to line count in WPL\n         MVI   0(R6),1             Set no. of lines so far\n         ST    R6,LINESADDR        Save line counter pointer\n         LA    R7,WTOLINES         Point to 1st WTO line\n         ST    R7,WTOE2+(WPLADTXT-WPL) Save addr in WPL\n         STCM  R2,3,0(R7)          Set len of line for WTO\n         @EXNEXT R2                Move data into WTO line\n         MVC   2(0,R7),0(R5)       *EXECUTED*\n*\n* Debugging code to test authorisation check\n*\n         TM    FLAG,FLBRWTO\n         JNO   FLINE30\n*        MVI   5(R7),C'$'          Branch entry WTO indicator\n         J     FLINE40\nFLINE30  DS    0H\n         TM    FLAG,FLPLUS1\n         JNO   FLINE40\n*        MVI   5(R7),C'#'          71/127 length indicator\nFLINE40  DS    0H\n*\n* End debugging code to test authorisation check\n*\n         LA    R7,2(R2,R7)         point to next WTO line\n         LA    R6,WTOADDRS         point to next WTO line address\n         LA    R5,0(R2,R5)         Point past current line in data\n         SR    R4,R2               Subtract the line length\nFLINEX   DS    0H\n         STM   R4,R7,FLINEREG\n         LA    R1,FLINEREG\n         PR\n*\n* RMLINE\n* Format the second and subsequent lines of the MLWTO\n*\nRMLINE   DS    0H\n         BAKR  R14,0               Stack regs\n* Internal Register usage\n*  r4 remaining data len\n*  r5 pointer to current data\n*  r2 current line len\n*  r3 number of WTO lines remaining before max reached\n*  r6 pointer to WTO line address pointer\n*  r7 pointer to WTO line text location\n         LTR   R4,R4               Any data left ?\n         JNP   RMLINEX             Skip if no\n         LA    R3,NUMLINES         Get max no. of lines\n         BCTR  R3,0                Decrement for 1st line\nRMLINE10 DS    0H\n         CH    R4,LINELENM         More than a lines worth left ?\n         JH    RMLINE20            Skip if yes\n         LR    R2,R4               Set line len to data len\n         J     RMLINE30            Skip\nRMLINE20 DS    0H\n         @BAS  GETLEN              Get preferred len of this line\n         LR    R2,R1               Get assigned length\nRMLINE30 DS    0H\n         @EXNEXT R2                Move data into WTO line\n         MVC   2(0,R7),0(R5)       *EXECUTED*\n         STCM  R2,3,0(R7)          Set len of line for WTO\n         XC    0(8,R6),0(R6)       Clear current WTO address pointer\n         MVI   1(R6),8             Set len of ptr to 8\n         LTR   R3,R3               Last line ?\n         JZ    RMLINE40            Skip if yes\n         CH    R4,LINELENM         Last bit of data ?\n         JH    RMLINE50            Skip if no\nRMLINE40 DS    0H\n         OI    2(R6),WPLLTFC+WPLLTFD Set type 'data end' line\n         J     RMLINE60            Skip\nRMLINE50 DS    0H\n         OI    2(R6),WPLLTFC       Set type 'data' line\nRMLINE60 DS    0H\n         STCM  R7,15,4(R6)         Save addr of current WTO line\n         L     R1,LINESADDR        Get pointer to no. of lines\n         IC    R15,0(,R1)          Get no. of lines\n         LA    R15,1(,R15)         Increment\n         STC   R15,0(,R1)          Save no. of lines\n         S     R3,ST.ONE           Decrement used lines counter\n         JM    RMLINEX             Skip if negative\nRMLINE70 DS    0H\n         LA    R7,2(R2,R7)         Point to next WTO line\n         LA    R6,8(,R6)           Point to next WTO line address\n         LA    R5,0(R2,R5)         Point past current line in data\n         SR    R4,R2               Subtract the line length\n         JP    RMLINE10            Loop if some data left\nRMLINEX  DS    0H\n         PR\n*\n* GETLEN\n* Sets length of line up to and including last space/tab/LF/CR.\n* The idea is to not split long strings (dataset names) over multiple\n* lines.\n*\nGETLEN   DS    0H\n         BAKR  R14,0               Stack regs\n* Internal Register usage\n*  r5 pointer to current data (must be set on entry)\n*  r2 work\n*  r1 position of delimiter (TRT) and length of line (on exit)\n         SLR   R1,R1\n         ICM   R1,3,LINELENM       Get max length of data\n         LA    R2,0(R1,R5)         Point past end of data\n         BCTR  R2,0                Point to last byte of data\n         MVCIN REVLINE,0(R2)       Reverse data\n         TRT   REVLINE,ST.TRTAB    Find first (last) delim\n         JZ    GETLENX             Skip if no delim found\n         LA    R2,REVLINE          Point to reversed data\n         SLR   R1,R2               Get offset into data for delim\n         SLR   R2,R2\n         ICM   R2,3,LINELENM       Get length of data\n         SLR   R2,R1               Get length of data after delim\n         LR    R1,R2               Return length in R1\nGETLENX  DS    0H\n         PR\n*\nSTATIC   DS    0D\nMACROMASKS DS  0D\n         WTO   TEXT=,LINKAGE=,                                         *\n               ROUTCDE=(2),DESC=(6,7),MF=L\n         WTO   TEXT=((,D)),LINKAGE=,                                   *\n               ROUTCDE=(2),DESC=(6,7),MF=L\nMACROMASKS_LENGTH EQU *-MACROMASKS\nNUMLINES EQU   255                 MLWTO max lines (auth)\nLINELENSA EQU  127                 SLWTO auth line len\nLINELENSU EQU  126                 SLWTO unauth line len\nLINELENMA EQU  71                  MLWTO auth line len\nLINELENMU EQU  70                  MLWTO unauth line len\nALINELENSA DC  AL2(LINELENSA)      SLWTO auth line len\nALINELENSU DC  AL2(LINELENSU)      SLWTO unauth line len\nALINELENMA DC  AL2(LINELENMA)      MLWTO auth line len\nALINELENMU DC  AL2(LINELENMU)      MLWTO unauth line len\nTRTAB    DC    XL256'00'\n         ORG   TRTAB+X'05'         Tab\n         DC    X'FF'\n         ORG   TRTAB+X'0A'         CR\n         DC    X'FF'\n         ORG   TRTAB+X'15'         LF\n         DC    X'FF'\n         ORG   TRTAB+C' '          Space\n         DC    X'FF'\n         ORG\nONE      DC    F'1'\nPROBSTATE DC   0F,XL4'00010000'\nLENRBPRE DC    AL2(RBBASIC-RBPRFX)\nKEY8     DC    X'80'\n*\nWORKA    DSECT\n         DS    CL(CEEDSASZ)       LE area\nUSERDSA  EQU   *\nMACROEXECS DS  0D\nWTOE1    WTO   TEXT=,LINKAGE=,                                         *\n               ROUTCDE=(2),DESC=(6,7),MF=L\nWTOE2    WTO   TEXT=((,D)),LINKAGE=,                                   *\n               ROUTCDE=(2),DESC=(6,7),MF=L\nWTOADDRS DS    0F,254AL2,254XL2,254AL4     Contiguous from WTOE2\n*\nFLAG     DS    X\nFLBRWTO  EQU   B'00000001'         Branch entry WTO flag\nFLKEY0_7 EQU   B'00000010'         KEY0-7 flag\nFLSUPV   EQU   B'00000100'         Supervisor state flag\nFLAPF    EQU   B'00001000'         APF auth flag\nFLPLUS1  EQU   B'00010000'         71/127 length indicator\nLINESADDR DS   F\nLINELENM DS    AL2\nLINELENS DS    AL2\nFLINEREG DS    4F\nREVLINE  DS    CL(LINELENMA)\nWTOLINES DS    AL2,CL(LINELENMA),254AL2,255CL(LINELENMA)\n*\nWORKL    EQU   *-USERDSA\n*\n         DROP  R13,ST\n*\n         IEZWPL ,                  WTO parm list\n         YREGS ,                   Register equates\n         IHAPSA ,\n         IHARB  ,\n         IKJTCB ,\n         IEZJSCB ,\n         CEEDSA ,                 LE Dynamic Storage Area\n*\n         END   ,                   End of MLWTO module\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPRNTLL": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01C\\x00\\x14\\x01\\x02$o\\x01\\x03\\x07\\x0f\\x14\\x13\\x00\\x9e\\x00\\x92\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.67", "flags": 0, "createdate": "2002-09-03T00:00:00", "modifydate": "2003-03-11T14:13:14", "lines": 158, "newlines": 146, "modlines": 0, "user": "AWCPAW"}, "text": "         TITLE 'SPRNTLL - LE-Compliant Long Long Integer Print'\n***********************************************************************\n*\n* Name: SPRNTLL\n*\n* Abstract:\n*\n*    A function to convert a 64 bit signed integer (Long Long in C) to\n*    printable EBCDIC. This is required because Systems\n*    Programming C does not support the Long Long type in the\n*    sprintf function. (APAR PQ42591)\n*\n*    Note that this function only works on z/Architecture\n*    (or above) processors. On processors without z/Arch a null\n*    string will be returned.\n*\n* Operation:\n*\n*    2 parameters are passed. The first is the address of the output\n*    area for the printable 64 bit integer (min length 21 chars).\n*    The second is the 64 bit integer itself (Long Long data type\n*    in C). The range of a 64 bit signed integer is\n*    -9223372036854775808 to 9223372036854775807. For unsigned\n*    integers, only values up to 9223372036854775807\n*    (0x7FFFFFFFFFFFFFFF or 63 bits) will be formatted correctly.\n*\n*    The presence of z/Arch is checked. If not present a null string\n*    is returned.\n*\n*    The 64 bit CVDG instruction is used to convert the integer\n*    to decimal, then it is split into 2 portions, unpacked and\n*    moved to the output area. Leading zeroes are suppressed.\n*\n* Invocation:\n*\n*    From C code, see the example in AWCPAW.CBT.FILE600.C.PDS(SPRNTLLT)\n*\n*    As a C function, SPRNTLL is usually included in object form\n*    via a link edit. For an example see\n*    AWCPAW.CBT.FILE600.C.PDS(SPRNTLLC)\n*\n* Environment:\n*\n*    IBM compatible mainframe (branch relative/immediate instructions\n*    must be supported)\n*\n*    IBM OS/390, z/OS or subsequent operating system\n*\n*    Usage of the CVDG/LG/LTGR instructions means that this program\n*    requires a minimum of HLASM R4.0 (OS/390 R10) to assemble.\n*\n* Notes:\n*\n*    This function does not 'return' the output string, it simply\n*    updates the string passed as the first parameter. This means\n*    that the returned value cannot be used directly, but instead\n*    it must be assigned to a variable. i.e.\n*\n*        sprntll(ch1,lli1);\n*        printf(\"%s%s\\n\",\"64 bit signed integer=\",ch1);\n*\n*    The reason for this is that I couldn't work out how\n*    to get an assembler function to return any sort of value, even\n*    after trying various return registers.\n*\n*    The assembler code does not use a base register, so the\n*    relative/immediate forms of branch instructions must be used.\n*\n*    To avoid USING conflicts when we have to temporarily provide\n*    a base register for some system macros, a literal pool\n*    is not available. Static literals must be placed by name in\n*    the 'STATIC' section and referenced via a labeled dependent\n*    USING by specifying an ST prefix.\n*\n*\n* Author: Paul Wells\n*         Saudi Aramco Box 12959\n*         Dhahran\n*         Saudi Arabia\n*\n* Email:  paul.wells@aramco.com\n*\n* History:\n*\n*    PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************\n*\nSPRNTLL  CSECT ,                  Establish the csect\nSPRNTLL  AMODE 31                 It addresses all 31 bit storage\nSPRNTLL  RMODE ANY                It can reside anywhere\n         EDCPRLG BASEREG=NONE,USRDSAL=WORKL\n         LR    R11,R1             Get address of parm area\n         USING WORKA,R13          Map work area\n         L     R6,0(,R11)         Get output area\n         TM    X'A3'(0),X'01'     z/architecture present ?\n*        TM    FLCARCH-PSA(0),PSAZARCH z/architecture present ?\n         JNO   GETOUT             leave the scene if no\nMAIN10   DS    0H\n         TM    4(R11),X'80'       Is passed integer negative ?\n         JNO   MAIN20             Skip if no\n         MVI   0(R6),C'-'         Set minus sign\n         LA    R6,1(,R6)          Increment output area\nMAIN20   DS    0H\n         LG    R7,4(,R11)         Get 64 bit integer passed\n         LTGR  R7,R7              Zero ?\n         JNZ   MAIN30             Skip if no\n         MVI   0(R6),C'0'         Set zero in output area\n         LA    R6,1(,R6)          Increment output area\n         J     GETOUT             Skip\nMAIN30   DS    0H\n         CVDG  R7,CVDGWK          Convert to decimal (64 bit signed)\n         ICM   R5,15,CVDGWK+4     Get first significant digits\n         SLL   R5,4               Shift left to accomodate sign\n         LA    R5,X'C'(,R5)       Give first part a sign\n         STCM  R5,15,CVDGWK       Store in unused part of CVDG area\n         UNPK  UNPKWK,CVDGWK(4)   Unpack first bit of 64 bit integer\n         OI    UNPKWK+L'UNPKWK-1,X'F0' Fix sign\n         MVC   ZDWK(L'UNPKWK),UNPKWK\n         UNPK  UNPKWK,CVDGWK+8(8) Unpack rest of 64 bit integer\n         OI    UNPKWK+L'UNPKWK-1,X'F0' Fix sign\n         MVC   ZDWK+L'UNPKWK(L'UNPKWK-1),UNPKWK+1\n         LA    R5,L'ZDWK          Set length of ZDWK\n         LA    R4,ZDWK            Point to ZDWK\n         SR    R3,R3              Clear significant digit flag\nMAIN40   DS    0H\n         LTR   R3,R3              Significant digit found ?\n         JNZ   MAIN50             Skip if yes\n         CLI   0(R4),C'0'         Leading zero ?\n         JE    MAIN60             Skip if yes\nMAIN50   DS    0H\n         LA    R3,1               Set flag for significant digit\n         MVC   0(1,R6),0(R4)      Move to output area\n         LA    R6,1(,R6)          Increment output area\nMAIN60   DS    0H\n         LA    R4,1(,R4)          Increment ZDWK ptr\n         JCT   R5,MAIN40          Loop thru ZDWK\nGETOUT   DS    0H\n         MVI   0(R6),0            Set null end of string for C\n         EDCEPIL\n*\n*\nWORKA    DSECT\n         DS    CL(CEEDSASZ)       LE area\nUSERDSA  EQU   *\nCVDGWK   DS    0D,CL16            Work area for CVDG\nUNPKWK   DS    CL16               Work area for UNPK\nZDWK     DS    CL31               Work area for zoned decimal\n*\nWORKL    EQU   *-USERDSA\n*\n         DROP  R13\n*\n         YREGS ,                  Register equates\n         CEEDSA ,                 LE Dynamic Storage Area\n         IHAPSA ,                 Prefixed Save Area (absolute 0)\n         END   ,                  End of SPRNTLL module\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TITLE": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x17\\x01\\x02&o\\x01\\x03\\x07\\x0f\\x14\\x13\\x008\\x00\\x1d\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "2002-09-23T00:00:00", "modifydate": "2003-03-11T14:13:17", "lines": 56, "newlines": 29, "modlines": 0, "user": "AWCPAW"}, "text": "         TITLE 'Goes here'\n***********************************************************************\n*\n* Name: xxxxxxxxxxxxx\n*\n* Abstract:\n*\n*    xxxxxxxxxxxx\n*\n* Operation:\n*\n*    xxxxxxxxxxxxx\n*\n* Environment:\n*\n*    IBM compatible mainframe (branch relative/immediate instructions\n*    must be supported)\n*\n*    IBM OS/390, z/OS or subsequent operating system\n*\n* Assembly:\n*\n*    Use (userid).CBTxxx.FILE600.ASM.PDS(ASMLKED) or similar to\n*    assemble and link this program.\n*\n* Invocation:\n*\n*    xxxxxxxxxxxxxxxxx\n*\n*\n* Notes:\n*\n*    The assembler code does not use a base register, so the\n*    relative/immediate forms of branch instructions must be used.\n*\n*    To avoid USING conflicts when we have to temporarily provide\n*    a base register for some system macros, a literal pool\n*    is not available. Static literals must be placed by name in\n*    the 'STATIC' section and referenced via a labeled dependent\n*    USING by specifying an ST prefix.\n*\n*\n* Author: Paul Wells\n*         Saudi Aramco Box 12959\n*         Dhahran\n*         Saudi Arabia\n*\n* Email:  paul.wells@aramco.com\n*\n* History:\n*\n*    PW 18/Sep/2002 - Original\n*\n*\n***********************************************************************\n*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "TITLEJ": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x19\\x01\\x02&\\x7f\\x01\\x03\\x07\\x0f\\x14\\x13\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc1\\xe6\\xc3\\xd7\\xc1\\xe6@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-09-24T00:00:00", "modifydate": "2003-03-11T14:13:19", "lines": 11, "newlines": 11, "modlines": 0, "user": "AWCPAW"}, "text": "//*\n//* AWCPAW.CBT.FILE600.ASM.PDS(XXXXXXXX)\n//* XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n//*\n//* CUSTOMISATION\n//*   1) CHANGE ALL AWCPAW TO YOUR HLQ\n//*   2) XXXXXXXXXXXXX\n//*   3) XXXXXXXXXXXXX\n//*   4) XXXXXXXXXXXXX\n//*\n//*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT600/CBT.V500.FILE600.PDS/XMITPDSA.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT600/CBT.V500.FILE600.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}