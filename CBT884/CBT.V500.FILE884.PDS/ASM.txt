./ ADD NAME=BXABR14  0100-20110-20110-2315-00004-00004-00000-BXAASM  15
BXABR14  RSECT
         XR       15,15
         BR       14
         END
./ ADD NAME=BXACOPY  0100-20110-20110-2315-00634-00634-00000-BXAASM  15
*PROCESS FLAG(SUBSTR)
*PROCESS RENT
***********************************************************************
*
* BIXXAMS - Bixoft Cross Access Method Services
* Licensed material - Property of B.V. Bixoft
*
* This program can be licensed or used on an as-is basis.
* No warranty, neither implicit nor explicit, is given.
* It remains your own responsibility to ensure the correct
* working of this program in your installation.
*
* Suggestions for improvement are always welcome at
* http://www.bixoft.com  or mail to  bixoft@bixoft.nl
*
* (C) Copyright B.V. Bixoft, 1999-2001
***********************************************************************
*
* This program will copy a member from a PDS concatenation
*                     or a physical sequential dataset concatenation
*
***********************************************************************
*
* Input:  parameter specifying 'MEMBER=memname'
*                           or 'DATSET=PS'
*         INPUT  dd-statement giving the input dataset(s)
* OUTPUT: OUTPUT dd-statement specifying the dataset to create
*
* For MEMBER=memname the INPUT concatenation of PDS'es will
*     be searched for the specified member, which will then
*     be copied to OUTPUT.
* For DATSET=PS the INPUT concatenation of physical sequential files
*     will be copied to OUTPUT.
*
* IEBCOPY does more, but needs control cards for its input,
*         which cannot be substituted from JCL variables.
* IEHLIST will also copy datasets, but it also lists all
*         records, filling up the spool.
*
***********************************************************************
         PGM   VERSION=V00R00M00,      * Version number                *
               HDRTXT='Bixxams copy utility',                          *
               WORKAREA=COPY,          * Dynamic area                  *
               SAVES=4,                * Internal save-areas           *
               ABND=4090,              * Abend code                    *
               MAPS=($COPY,            * Private mapping macros        *
               DCB,DCBE,DECB,IOB,SDWA)
*
* Assign some global registers
R_RCD    EQUREG ,                      * Assign retcode register
         USE   R_RCD,SCOPE=CALLED      * Set register in use
R_TMP    EQU   R_RCD                   * retcode reg also temp reg
R_LEN    EQUREG ,                      * Assign length register
         USE   R_LEN,SCOPE=CALLED      * Set length reg in use
R_RSN    EQU   R_LEN                   * length reg also reson reg
*
* Assign registers for input parm parsing
R_PTR1   EQUREG ,                      * Ptr to first operand
         USE   R_PTR1                  * Set register in use
R_PTR2   EQUREG ,                      * Ptr to second operand
         USE   R_PTR2                  * Set register in use
R_LEN1   EQUREG ,                      * Length of first operand
         USE   R_LEN1                  * Set register in use
R_LEN2   EQUREG ,                      * Length of second operand
         USE   R_LEN2                  * Set register in use
*
* Retrieve JCL parameter - if specified - and save in R_PTR1
         IF    R1,Z                    * Pointer to parmlist valid?
          ABND ,                       * No: issue error
         ENDIF ,                       *
         L     R_PTR1,0(,R1)           * Retrieve ptr to JCL parm
         CLEAR (R_PTR1,*ADDR)          * Wipe hi-order bit
         IF    R_PTR1,Z                * If it is invalid
          ABND ,                       * issue error
         ENDIF ,                       *
         LH    R_LEN1,0(R_PTR1)        * First halfword is length
         INC   R_PTR1,2                * Point start of text of parm
         IF    R_LEN1,GT,256           * If it is too long
          ABND ,                       * Issue error
         ENDIF ,                       *
         IF    R_LEN1,Z                * If no parm was specified
          ABND ,                       * Issue error
         ENDIF ,                       *
*
* Find equal sign in input string
         L     R_TMP,=A(TRTAB1)        * Point table to be used
         EXTRT 0(R_LEN1,R_PTR1),0(R_TMP) * Search first equal sign
         ABND  Z                       * Abend if not found
*
* Determine length of operand 1 and remainder of string
         LA    R_PTR2,1(,R1)           * Point after equal sign
         CPY   R_LEN2,R_LEN1           * Copy string length
         CPY   R_TMP,R1                * Delimiter location
         SR    R_TMP,R_PTR1            * Nr of chars in first operand
         ABND  Z                       * Empty operand is error
         CPY   R_LEN1,R_TMP            * Set length of operand 1
         SR    R_LEN2,R_LEN1           * Remaining string length
         DEC   R_LEN2                  *    after delimiter
         IF    R_LEN2,LE,0             * Something left?
          ABND ,                       * No: error
         ENDIF ,                       *
*
* Operand 1 must be a valid keyword
         CASE  R_LEN1,EQ,6             * Length must be 6
          CASE E,CLC,=CL6'MEMBER',0(R_PTR1),NEST=YES * MEMBER copy?
           SETON COPYMEM               * Yes: indicate member copy
          CASE E,CLC,=CL6'DATSET',0(R_PTR1) * Dataset copy?
           SETON COPYDS                * Yes: indicate dataset copy
          ELSE ,                       *
           ABND ,                      * Invalid keyword
          ENDCASE ,                    *
         ELSE  ,                       * Other keyword lengths
          ABND ,                       * Invalid keyword length
         ENDCASE ,                     *
*
* Test operand 2 for validity
         CASE  COPYMEM                 * Copy member requested?
          IF   R_LEN2,GT,8             * Length max is 8
           ABND ,                      * Member name too long
          ENDIF ,                      *
          CLEAR COPYMBNM               * Wipe member name
          EXMVC COPYMBNM(R_LEN2),0(R_PTR2) * Copy member name
         CASE  COPYDS                  * Copy dataset requested?
          IF   R_LEN2,NE,2             * Length must be 2
           ABND ,                      * Wrong organisation
          ENDIF ,                      *
          IF   E,CLC,=CL2'PS',0(R_PTR2) * Physical Sequential?
           SETON COPYPS                * Indicate PS copy request
          ENDIF ,                      *
         ENDCASE ,                     *
*
* Input string processing complete: drop used registers
         DROP  R_PTR1                  *
         DROP  R_PTR2                  *
         DROP  R_LEN1                  *
         DROP  R_LEN2                  *
*
* Set up recovery environment
         MVPL  COPYESTAE,CPY_ESTAE     * Copy ESTAE parmlist
         ESTAE RECOVER,CT,             * Create new ESTAE-environment  *
               PARAM=(R13),            * Pass COPY as parameter field  *
               MF=(E,COPYESTAE)        *
         ABND  TSTRC,RCD=(R_RCD,R_RSN) * Abend on error

*
* Perform requested function
         CASE  COPYMEM                 * Member copy?
          EXSR CPYMEM                  * Ok: copy a member
         CASE  COPYPS                  * PS copy?
          EXSR CPYPS                   * Ok: copy a PS dataset
         ENDCASE ,
*
* Remove ESTAE environment
         MVPL  COPYESTAE,CPY_ESTAE     * Copy ESTAE parmlist
         ESTAE 0,                      * Remove our ESTAE-environment  *
               MF=(E,COPYESTAE)        *
         ABND  TSTRC,RCD=(R_RCD,R_RSN) * Abend on error
*
* And exit program
         RETRN RC=0                    * Quit this program
***********************************************************************
*
* Routine to copy a PDS member
*
***********************************************************************
CPYMEM   BEGSR ,
*
* Allocate input DCB and DCBE in the workarea
         MVPL  COPYDCBP,CPY_DCBP       * Copy input DCB
         MVPL  COPYDCBE,CPY_DCBE       * Copy DCBE to be used
IN       USE   DCB,COPYDCBP            * Set DCB fields addressable
         USE   DCBE,COPYDCBE           * Set DCBE fields addressable
         SET   IN.DCBDCBE,COPYDCBE     * Point from DCB to DCBE
         SET   DCBEEODA,EODADRTN       * Point to EODAD routine
*
* Open the input PDS (concatenation)
         MVPL  COPYOPEN,CPY_OPEN       * Copy open parmlist
         OPEN  (COPYDCBP,INPUT),       * Open the input dataset(s)     *
               MF=(E,COPYOPEN)         *
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Allocate and open the output DCB in the workarea
         MVPL  COPYDCBO,CPY_DCBO       * Copy output DCB
OUT      USE   DCB,COPYDCBO            * Set DCB fields addressable
CPYMEM_OPEN LABEL ,                    *
         MVPL  COPYOPEN,CPY_OPEN       * Copy open parmlist
         OPEN  (COPYDCBO,OUTPUT),      * Open the output dataset       *
               MF=(E,COPYOPEN)         *
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Locate the required input member
         FIND  COPYDCBP,COPYMBNM,D     * Locate required member
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Allocate 1 buffer for the BPAM input dataset
R_BUFP   EQUREG ,                      * Assign buffer ptr
         USE   R_BUFP                  * Set ptr in use
         CPY   R_LEN,IN.DCBBLKSI       * Obtain input block size
         STORAGE OBTAIN,LOC=ANY,       * Get storage above the line    *
               LENGTH=(R_LEN)          *   for a single block
         CPY   R_BUFP,R1               * Set ptr to buffer
         CPY   COPYBUFI,R_BUFP         * And save buffer address
*
* Allocate 1 buffer for an output record
R_BUFO   EQUREG ,                      * Assign buffer ptr
         USE   R_BUFO                  * Set ptr in use
         CPY   R_LEN,OUT.DCBLRECL      * Obtain (max) output lrecl
         STORAGE OBTAIN,LOC=ANY,       * Get storage above the line    *
               LENGTH=(R_LEN)          *   for a single block
         CPY   R_BUFO,R1               * Set ptr to buffer
         CPY   COPYBUFO,R_BUFO         * And save buffer address
*
* Loop to read all blocks in the member
         DO    UNTIL,COPYEOF           * Until EOF detected
          MVPL COPYDECB,CPY_DECB       * Set up initial DECB
          USE  DECB,COPYDECB           * Set DECB fields addressable
          CPY  R_TMP,R_BUFP            * Set ptr to BPAM buffer
          READ COPYDECB,SF,            * Read forward                  *
               COPYDCBP,(R_TMP),'S',   *  1 block from input dataset   *
               MF=E                    *
          CHECK COPYDECB               * Wait for READ to complete
          IF   NOT,COPYEOF             * Valid block was read?
* For Fixed records: use IOB to determine end-of-buffer
* For Variable records: use BDW to determine end-of-buffer
           IF  IN.DCBRECF              * Fixed or FB input records?
            CPY R_LEN,IN.DCBBLKSI      * Load input block length
R_IOB       EQUREG ,                   * Assign IOB ptr
            USE IOBSTDRD,R_IOB         * Set IOB addressable
            CPY R_IOB,DECIOBPT         * And point to IOB
            CPY R_TMP,IOBRESCT         * Load residual count
            DROP R_IOB                 * IOB no longer needed
            SR R_LEN,R_TMP             * Nr of bytes in input buffer
            AR R_LEN,R_BUFP            * Point past end of data
            ST R_LEN,COPYBUFE          * Save end-of-block ptr
            ST R_BUFP,COPYREC          * Set ptr to current record
           ELSE  ,                     * Must be variable or VB records
R_BDW       EQUREG ,                   * Assign buffer ptr
            USE BDW,R_BDW              * Address block descriptor word
            CPY R_BDW,R_BUFP           * Point to filled buffer
            CPY R_LEN,BDWBLKLN         * Retrieve length of block
            AR  R_LEN,R_BUFP           * Point past end of data
            ST  R_LEN,COPYBUFE         * Set ptr to end of buffer
            LA  R_TMP,BDW_LEN(,R_BUFP) * Point to first RDW in buffer
            CPY COPYREC,R_TMP          * Set ptr to current record
            DROP R_BDW                 * Buffer ptr no longer needed
           ENDIF ,                     *
           EXSR CPYBLK                 * Go copy a block to output
          ENDIF ,                      *
         ENDDO ,                       *
*
* Free the output record buffer
         CPY   R_LEN,OUT.DCBLRECL      * Obtain output record length
         STORAGE RELEASE,ADDR=(R_BUFO), * Free storage allocated       *
               LENGTH=(R_LEN)          *   for a single record
         DROP  R_BUFO                  * Buffer ptr no longer valid
         CLEAR COPYBUFO                * And wipe ptr in storage too
*
* Free the input buffer
         CPY   R_LEN,IN.DCBBLKSI       * Obtain input block size
         STORAGE RELEASE,ADDR=(R_BUFP), * Free storage allocated       *
               LENGTH=(R_LEN)          *   for a single block
         DROP  R_BUFP                  * Buffer ptr no longer valid
         CLEAR COPYBUFI                * And wipe ptr in storage too
*
* Close the input PDS (concatenation)
         MVPL  COPYCLOS,CPY_CLOS       * Copy close parmlist
         CLOSE (COPYDCBP),MF=(E,COPYCLOS) * Close the input dataset(s)
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Close the output dataset
         MVPL  COPYCLOS,CPY_CLOS       * Copy close parmlist
         CLOSE (COPYDCBO),MF=(E,COPYCLOS) * Close the input dataset(s)
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Release registers
         DROP  R_RCD                   *
         DROP  R_LEN                   *
*
         ENDSR ,
***********************************************************************
*
* Routine to copy a sequential dataset (or concatenation)
*
***********************************************************************
CPYPS    BEGSR ,
*
* Allocate input DCB and DCBE in the workarea
         MVPL  COPYDCBS,CPY_DCBS       * Copy input DCB
         MVPL  COPYDCBE,CPY_DCBE       * Copy DCBE to be used
IN       USE   DCB,COPYDCBS            * Set DCB fields addressable
         USE   DCBE,COPYDCBE           * Set DCBE fields addressable
         SET   IN.DCBDCBE,COPYDCBE     * Point from DCB to DCBE
         SET   DCBEEODA,EODADRTN       * Point to EODAD routine
*
* Open the input dataset or concatenation
         MVPL  COPYOPEN,CPY_OPEN       * Copy open parmlist
         OPEN  (COPYDCBS,INPUT),       * Open the input dataset(s)     *
               MF=(E,COPYOPEN)         *
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Allocate and open the output DCB in the workarea
         MVPL  COPYDCBO,CPY_DCBO       * Copy output DCB
OUT      USE   DCB,COPYDCBO            * Set DCB fields addressable
CPYPS_OPEN LABEL ,                     *
         MVPL  COPYOPEN,CPY_OPEN       * Copy open parmlist
         OPEN  (COPYDCBO,OUTPUT),      * Open the output dataset       *
               MF=(E,COPYOPEN)         *
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Allocate 1 buffer for the input BSAM dataset
R_BUFS   EQUREG ,                      * Assign buffer ptr
         USE   R_BUFS                  * Set ptr in use
         CPY   R_LEN,IN.DCBBLKSI       * Obtain input block size
         STORAGE OBTAIN,LOC=ANY,       * Get storage above the line    *
               LENGTH=(R_LEN)          *   for a single block
         CPY   R_BUFS,R1               * Set ptr to buffer
         CPY   COPYBUFI,R_BUFS         * And save buffer address
*
* Allocate 1 buffer for an output record
* R_BUFO EQUREG ,                      * Assigned in CPYMEM routine!
         USE   R_BUFO                  * Set ptr in use
         CPY   R_LEN,OUT.DCBLRECL      * Obtain (max) output lrecl
         STORAGE OBTAIN,LOC=ANY,       * Get storage above the line    *
               LENGTH=(R_LEN)          *   for a single block
         CPY   R_BUFO,R1               * Set ptr to buffer
         CPY   COPYBUFO,R_BUFO         * And save buffer address
*
* Loop to read all blocks in the dataset
         DO    UNTIL,COPYEOF           * Until EOF detected
          MVPL COPYDECB,CPY_DECB       * Set up initial DECB
          USE  DECB,COPYDECB           * Set DECB fields addressable
          CPY  R_TMP,R_BUFS            * Set ptr to BSAM buffer
          READ COPYDECB,SF,            * Read forward                  *
               COPYDCBS,(R_TMP),'S',   *  1 block from input dataset   *
               MF=E                    *
          CHECK COPYDECB               * Wait for READ to complete
          IF   NOT,COPYEOF             * Valid block was read?
* For Fixed records: use IOB to determine end-of-buffer
* For Variable records: use BDW to determine end-of-buffer
           IF  IN.DCBRECF              * Fixed or FB input records?
            CPY R_LEN,IN.DCBBLKSI      * Load input block length
            USE IOBSTDRD,R_IOB         * Set IOB addressable
            CPY R_IOB,DECIOBPT         * And point to IOB
            CPY R_TMP,IOBRESCT         * Load residual count
            DROP R_IOB                 * IOB no longer needed
            SR R_LEN,R_TMP             * Nr of bytes in input buffer
            AR R_LEN,R_BUFS            * Point past end of data
            ST R_LEN,COPYBUFE          * Save end-of-block ptr
            ST R_BUFS,COPYREC          * Set ptr to current record
           ELSE  ,                     * Must be variable or VB records
            USE BDW,R_BDW              * Address block descriptor word
            CPY R_BDW,R_BUFS           * Point to filled buffer
            CPY R_LEN,BDWBLKLN         * Retrieve length of block
            AR  R_LEN,R_BUFS           * Point past end of data
            ST  R_LEN,COPYBUFE         * Set ptr to end of buffer
            LA  R_TMP,BDW_LEN(,R_BUFS) * Point to first RDW in buffer
            CPY COPYREC,R_TMP          * Set ptr to current record
            DROP R_BDW                 * Buffer ptr no longer needed
           ENDIF ,                     *
           EXSR CPYBLK                 * Go copy a block to output
          ENDIF ,                      *
         ENDDO ,                       *
*
* Free the output record buffer
         CPY   R_LEN,OUT.DCBLRECL      * Obtain output record length
         STORAGE RELEASE,ADDR=(R_BUFO), * Free storage allocated       *
               LENGTH=(R_LEN)          *   for a single record
         DROP  R_BUFO                  * Buffer ptr no longer valid
         CLEAR COPYBUFO                * And wipe ptr in storage too
*
* Free the BSAM input buffer
         CPY   R_LEN,IN.DCBBLKSI       * Obtain input block size
         STORAGE RELEASE,ADDR=(R_BUFS), * Free storage allocated       *
               LENGTH=(R_LEN)          *   for a single block
         DROP  R_BUFS                  * Buffer ptr no longer valid
         CLEAR COPYBUFI                * And wipe ptr in storage too
*
* Close the input dataset (or concatenation)
         MVPL  COPYCLOS,CPY_CLOS       * Copy close parmlist
         CLOSE (COPYDCBS),MF=(E,COPYCLOS) * Close the input dataset(s)
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Close the output dataset
         MVPL  COPYCLOS,CPY_CLOS       * Copy close parmlist
         CLOSE (COPYDCBO),MF=(E,COPYCLOS) * Close the input dataset(s)
         ABND  TSTRC,RCD=R_RCD         * Abend on failure
*
* Release registers
         DROP  R_RCD                   *
         DROP  R_LEN                   *
*
         ENDSR ,
***********************************************************************
*
* Routine to write an entire block
*
* At entry: COPYREC  points to first record in buffer
*           COPYBUFE points to end-of-buffer
*           COPYBUFO points to output record buffer
*
***********************************************************************
CPYBLK   BEGSR ,
*
* Set up to loop thru the block
         CPY   R_BUFO,COPYBUFO         * Point to output record area
         USE   R_BUFO                  * and set register in use
*
R_REC    EQUREG ,                      * Assign record ptr
RDWIN    USE   RDW,R_REC               * Assume RECFM=V or VB
*
* No distinction is made between COPYDCBP (BPAM) and COPYDCBS (BSAM)
IN       USE   DCB,COPYDCBP            * Set DCB fields addressable
OUT      USE   DCB,COPYDCBO            * Set DCB fields addressable
*
* For each record in the buffer:
* - determine length, advance current record pointer
* - copy record, truncate if too long, pad if too short
* - write record to output dataset
*
         DO    WHILE,COPYREC,LT,COPYBUFE * For each record in buffer
*         Determine length, advance current record pointer
          CPY  R_REC,COPYREC           * Copy ptr to current record
          IF   IN.DCBRECF              * Fixed record length:
           CPY R_LEN,IN.DCBLRECL       * Retrieve rec length from DCB
           CPY R_TMP,R_REC             * Copy current record ptr
           INC R_TMP,(R_LEN)           * Point to next record
           CPY COPYREC,R_TMP           * Update current record ptr
          ELSE ,                       * Variable records:
           CPY R_LEN,RDWIN.RDWRECLN    * Retrieve length of record
           CPY R_TMP,R_REC             * Copy current record pointer
           INC R_TMP,(R_LEN)           * Point next record in buffer
           CPY COPYREC,R_TMP           * Update current record pointer
           INC R_REC,RDW_LEN           * Point to start of record data
           DEC R_LEN,RDW_LEN           * And adjust data length
          ENDIF ,                      *
*         R_REC now points data, R_LEN holds data length
*         Copy record, truncate if too long, pad if too short
          IF   OUT.DCBRECF             * Fixed record length:
           IF  R_LEN,GT,OUT.DCBLRECL   * Record is too long?
            CPY R_LEN,OUT.DCBLRECL     * Yes: truncate
           ENDIF ,                     *
           IF  R_LEN,LE,256            * Length is legal?
            EXMVC 0(R_LEN,R_BUFO),0(R_REC) * Copy the data
           ELSE ,                      * Length too large
            ABND ,                     *
           ENDIF ,                     *
           IF  R_LEN,LT,OUT.DCBLRECL   * Wipe remainder of buffer?
            LA R_TMP,0(R_BUFO,R_LEN)   * Yes: point to remainder start
            SH R_LEN,OUT.DCBLRECL      *      and set remainder size
            IF R_LEN,LE,256            * Length is legal?
             EXXC 0(R_LEN,R_TMP),0(R_TMP) * Wipe remainder
            ELSE ,                     * Length too large
             ABND ,                    *
            ENDIF ,                    *
           ENDIF ,                     * End of wipe for short records
          ELSE  ,                      * Must be V or VB records
           DROP R_BUFO                 * Drop to swap using status
RDWOUT     USE RDW,R_BUFO              * Record starts with a RDW
           INC R_LEN,RDW_LEN           * Add size of RDW to lrecl
           IF  R_LEN,GT,OUT.DCBLRECL   * Record is too long?
            CPY R_LEN,OUT.DCBLRECL     * Yes: truncate
           ENDIF ,                     *
           CPY RDWOUT.RDWRECLN,R_LEN   * Set length in RDW
           CLEAR RDWOUT.RDWT00         * Wipe trailing zeroes
           DEC R_LEN,RDW_LEN           * Reduce to data length
           IF  R_LEN,LE,256            * Length is legal?
            EXMVC RDW_LEN(R_LEN,R_BUFO),0(R_REC) * Copy the data
           ELSE ,                      * Length too large
            ABND ,                     *
           ENDIF ,                     *
          ENDIF ,                      * Output buffer now ready
*         Output buffer now complete: write record to output
          PUT  COPYDCBO,(R_BUFO)       * Write record to output dataset
         ENDDO ,                       *
*
         ENDSR ,                       *
***********************************************************************
*
* Retry routine after System 013 abend
*
***********************************************************************
RETRY013 BEGSR TYPE=RETRY              *
*
IN       USE   DCB,COPYDCBS            * Set DCB fields addressable
OUT      USE   DCB,COPYDCBO            * Set DCB fields addressable
*
* Setup fresh output DCB
         MVPL  COPYDCBO,CPY_DCBO       * Copy output DCB
*
* Copy LRECL, BLKSIZE, and record format from input DCB
         CPY   OUT.DCBBLKSI,IN.DCBBLKSI * Copy block size
         CPY   OUT.DCBLRECL,IN.DCBLRECL * Copy record length
         CPY   OUT.DCBRECFM,IN.DCBRECFM * Copy record format
*
* Retry the open
         GOTO  CPYMEM_OPEN,COPYMEM     * Retry for member copy
         GOTO  CPYPS_OPEN,COPYPS       * Retry for PS dataset copy
         ABND  ,                       * Error!
*
         DROP  IN                      * DCB fields no longer
         DROP  OUT                     *     needed
*
         ENDSR ,                       *
***********************************************************************
*
* Constants etc.
*
***********************************************************************
         LTORG ,                       *
***********************************************************************
*
* Out-of-line routinse
*
***********************************************************************
EODADRTN LABEL H                       * Ensure alignment
         SETON COPYEOF                 * Indicate EOF reached
         BR    R14                     * Return
***********************************************************************
*
* Recovery routine
*
***********************************************************************
RECOVER  BEGSR TYPE=ESTAE,             * Estae recovery routine        *
               LVL=1                   * For normal code
*
* Do we have an SDWA?
         GOTO  RECPERC,R0,EQ,12        * No SDWA: percolate
*
* SDWA found
R_SDWA   EQUREG ,                      *
         LR    R_SDWA,R1               * Copy SDWA pointer
         USE   SDWA,R_SDWA             * And set SDWA addressable
*
* If registers at time of error unavailable: do not retry
         GOTO  SETRP0,SDWARPIV         * Regs not available: percolate
*
* This is a recoverable abend?
         CASE  SDWACMPC,EQ,=X'013000'  * System 013 is recoverable
          GOTO SYS013                  * Retry if original SVC abended
         ELSE  ,                       * All other abends
          GOTO SETRP0                  * Percolate
         ENDCASE ,                     *
         GOTO  SETRP0                  * Always percolate
*
* We encountered a S013 abend, meaning that open could not complete
* successfully. If reasoncode is 34 some DCB parameters are missing
* and must be copied from the input DCB before retrying the open.
SYS013   LABEL ,                       *
R_PTRS   EQUREG ,                      * Assign ptr to pointers block
         USE   SDWAPTRS,R_PTRS         * And set it addressable
         L     R_PTRS,SDWAXPAD         * Point to pointers block
R_RC1    EQUREG ,                      * Assign ptr service extension 1
         USE   SDWARC1,R_RC1           * And set it addressable
         L     R_RC1,SDWASRVP          * Point to service extension 1
         GOTO  SETRP0,NOT,SDWARCF      * Reasoncode must be available
         GOTO  SETRP0,SDWAHRC,NE,52    * Reasoncode must be 34 hex
*
* Open failed due to incomplete DCB
IN       USE   DCB,COPYDCBS            * Set DCB fields addressable
OUT      USE   DCB,COPYDCBO            * Set DCB fields addressable
*
* Make sure input DCB is open and output DCB is not
         GOTO  SETRP0,NOT,IN.DCBOFOPN  * No retry: input not open
         GOTO  SETRP0,OUT.DCBOFOPN     * No retry: output is open
*
* Make sure we don't retry more than once
         GOTO  SETRP0,COPYRTRY         * No retry: retried before
         SETON COPYRTRY                * Indicate retry performed
*
* Setup for retry
         L     R0,=AL4(RETRY013)       * Retrieve address of retry-rout
         B     SETRP4                  * And go retry
*
         DROP  R_RC1                   * SDWARC1 not needed anymore
         DROP  R_PTRS                  * SDWAPTRS no longer needed
         DROP  R_SDWA                  * SDWA no longer needed
*
* Percolate
SETRP0   LABEL ,                       * SETRP RC=0: percolate
         SETRP RC=0,                   * Retcode 0 to percolate        *
               WKAREA=(R_SDWA)         * Point to SDWA
         B     RECEXIT                 *
*
* Tell system to retry
SETRP4   LABEL ,                       * SETRP RC=4: retry
         SETRP RC=4,                   * Retcode 0 to percolate        *
               WKAREA=(R_SDWA),        * Points to SDWA                *
               DUMP=NO,                * Suppress dump                 *
               RETADDR=(R0),           * Retry address in R0           *
               RETREGS=YES,            * Restore registers from SDWA   *
               FRESDWA=YES,            * Free SDWA before retry        *
               RECORD=NO               * Do not record in LOGREC
         B     RECEXIT                 *
*
* Percolate: no SDWA
RECPERC  LABEL ,                       *
         CLEAR R15                     * RC=0 to percolate
*
RECEXIT  LABEL ,                       *
         ENDSR RC=*,                   * When RC=4 (retry)             *
               KEEPREG=R0              *   R0 contains retry address
***********************************************************************
*
* Indirectly addressable Plists and constants
*
***********************************************************************
TRTAB1   TRTAB ,                       * Select no characters          *
               CHARS=(C'=')            * Except equal sign
*
CPY_ESTAE ESTAE 0,                     * Establish ESTAE routine       *
               MF=L                    *
*
CPY_DCBP DCB   DDNAME=INPUT,           * Model input DCB for BPAM      *
               DSORG=PO,               * Partitioned organization      *
               DCBE=CPY_DCBE,          * For use in 31-bit environment *
               MACRF=R                 * And read-only
*
CPY_DCBS DCB   DDNAME=INPUT,           * Model input DCB for BSAM      *
               DSORG=PS,               * Physical sequential           *
               DCBE=CPY_DCBE,          * For use in 31-bit environment *
               MACRF=R                 * And read-only
*
CPY_DCBE DCBE  EODAD=EODADRTN          * DCB-extension prototype
*
         READ  CPY_DECB,SF,MF=L        * DECB prototype
*
CPY_DCBO DCB   DDNAME=OUTPUT,          * Model output DCB              *
               DSORG=PS,               * Sequential file               *
               MACRF=PM                * Use Put-Move
*
CPY_OPEN OPEN  (0,INPUT),MF=L          *
CPY_CLOS CLOSE (0),MF=L                *
*
         END
./ ADD NAME=BXAIO    0100-20110-20110-2315-00392-00392-00000-BXAASM  15
BXAIO    TITLE 'Static stub for dynamic I/O routine BXAIO00'
***********************************************************************
* Start create : 20-03-1989
* 1st delivery : 15-08-1989
* Designer     : AF Kornelis
* Programmer   : AF Kornelis
* Reason       : Untie logical record lay-outs from physical file
*                structure
***********************************************************************
* Change 01    : 21-06-1990
* Programmer   : JB
* Reason       : Added 2 logical record lay-outs: PDD and CSC
***********************************************************************
* Change 02    : 31-10-1991
* Programmer   : JB
* Reason       : Added 1 logical record lay-out: CCX
***********************************************************************
* Change 03    : 31-05-1992
* Programmer   : JB
* Reason       : Added 1 logical record lay-out: ACD
***********************************************************************
* Change 04    : 31-05-1996
* Programmer   : JB
* Reason       : Added 1 logical record lay-out: SVD
***********************************************************************
* Change 05    : Summer 2001
* Programmer   : Abe F. Kornelis
* Reason       : Replace register numbers with names
*                Improve comments
***********************************************************************
         EJECT ,                       *
         PRINT GEN                     *
         ENTRY BXAIOCCD                * Customer Contract Data
         ENTRY BXAIOCPD                * Customer Personal Data
         ENTRY BXAIOCCX                * Customer Contract eXtension
         ENTRY BXAIOPDD                * Product Definition Data
         ENTRY BXAIOCSC                * Capitalized Savings/Contract
         ENTRY BXAIOACD                * ACcounting Data
         ENTRY BXAIOSVD                * SaVings Details
***********************************************************************
* Change implemented on 9-7-2001: use DSECT for entry parm lay-out
HDRDATA  DSECT ,                       * HeaDeR DATA
         B     0                       * Skip header: dummy instruction
         DS    AL1,CL24                * Entry Point descriptor
MOVEIN   DS    A                       * Setup routine for parameter 2
MOVEOUT  DS    A                       * Output conversion routine
* End of change d.d. 9-7-2001
***********************************************************************
* Change implemented on 9-7-2001: use register equates
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
* End of change d.d. 9-7-2001
***********************************************************************
BXAIO    START 0                       *
BXAIO    AMODE ANY
BXAIO    RMODE ANY
***********************************************************************
* Change implemented on 10-7-2001: add error message and abend
         USING BXAIO,R15               * Establish addressability
         B     BXAIO_GO                * Skip header data
         DC    AL1(24),CL24'BXAIO    &SYSDATE &SYSTIME'
         DC    A(0)                    * Setup routine for parameter 2
         DC    A(0)                    * Output conversion routine
BXAIO_GO EQU   *
         LR    R12,R15                 * Copy base address
         DROP  R15                     * No longer needed
         USING BXAIO,R12               * Re-establish addressability
         WTO   'BXAIO - Illegal entry point into mudule',              *
               ROUTCDE=11,DESC=7
         DC    X'0000'                 * Force a S0C1 abend
         CNOP  0,8                     * Re-align on doubleword
         DROP  R12                     * End of error logic
* End of change d.d. 9-7-2001
***********************************************************************
         SPACE 2
         USING BXAIOCCD,R15            * Establish addressability (CCD)
BXAIOCCD B     IOCCD_GO                * Skip header data
         DC    AL1(24),CL24'BXAIOCCD &SYSDATE &SYSTIME'
         DC    A(CCDIN)                * Setup routine for parameter 2
         DC    A(CCDOUT)               * Output conversion routine
*
IOCCD_GO EQU   *
         STM   R14,R12,12(R13)         * Save caller's registers
         LA    R3,BXAIOGO              * Set base register
         BR    R3                      * and execute main line
         CNOP  0,8                     * Re-align on doubleword
         DROP  R15                     * End of entry logic for CCD
*
         SPACE 2
         USING BXAIOCPD,R15            * Establish addressability (CPD)
BXAIOCPD B     IOCPD_GO                * Skip header data
         DC    AL1(24),CL24'BXAIOCPD &SYSDATE &SYSTIME'
         DC    A(CPDIN)                * Setup routine for parameter 2
         DC    A(CPDOUT)               * Output conversion routine
*
IOCPD_GO EQU   *
         STM   R14,R12,12(R13)         * Save caller's registers
         LA    R3,BXAIOGO              * Set base register
         BR    R3                      * and execute main line
         CNOP  0,8                     * Re-align on doubleword
         DROP  R15                     * End of entry logic for CPD
*
         SPACE 2
         USING BXAIOCCX,R15            * Establish addressability (CCX)
BXAIOCCX B     IOCCX_GO                * Skip header data
         DC    AL1(24),CL24'BXAIOCCX &SYSDATE &SYSTIME'
         DC    A(CCXIN)                * Setup routine for parameter 2
         DC    A(CCXOUT)               * Output conversion routine
*
IOCCX_GO EQU   *
         STM   R14,R12,12(R13)         * Save caller's registers
         LA    R3,BXAIOGO              * Set base register
         BR    R3                      * and execute main line
         CNOP  0,8                     * Re-align on doubleword
         DROP  R15                     * End of entry logic for CCX
*
         SPACE 2
         USING BXAIOPDD,R15            * Establish addressability (PDD)
BXAIOPDD B     IOPDD_GO                * Skip header data
         DC    AL1(24),CL24'BXAIOPDD &SYSDATE &SYSTIME'
         DC    A(PDDIN)                * Setup routine for parameter 2
         DC    A(PDDOUT)               * Output conversion routine
*
IOPDD_GO EQU   *
         STM   R14,R12,12(R13)         * Save caller's registers
         LA    R3,BXAIOGO              * Set base register
         BR    R3                      * and execute main line
         CNOP  0,8                     * Re-align on doubleword
         DROP  R15                     * End of entry logic for PDD
*
         SPACE 2
         USING BXAIOCSC,R15            * Establish addressability (CSC)
BXAIOCSC B     IOCSC_GO                * Skip header data
         DC    AL1(24),CL24'BXAIOCSC &SYSDATE &SYSTIME'
         DC    A(CSCIN)                * Setup routine for parameter 2
         DC    A(CSCOUT)               * Output conversion routine
*
IOCSC_GO EQU   *
         STM   R14,R12,12(R13)         * Save caller's registers
         LA    R3,BXAIOGO              * Set base register
         BR    R3                      * and execute main line
         CNOP  0,8                     * Re-align on doubleword
         DROP  R15                     * End of entry logic for CSC
*
         SPACE 2
         USING BXAIOACD,R15            * Establish addressability (ACD)
BXAIOACD B     IOACD_GO                * Skip header data
         DC    AL1(24),CL24'BXAIOACD &SYSDATE &SYSTIME'
         DC    A(ACDIN)                * Setup routine for parameter 2
         DC    A(ACDOUT)               * Output conversion routine
*
IOACD_GO EQU   *
         STM   R14,R12,12(R13)         * Save caller's registers
         LA    R3,BXAIOGO              * Set base register
         BR    R3                      * and execute main line
         CNOP  0,8                     * Re-align on doubleword
         DROP  R15                     * End of entry logic for ACD
*
         SPACE 2
         USING BXAIOSVD,R15            * Establish addressability (SVD)
BXAIOSVD B     IOSVD_GO                * Skip header data
         DC    AL1(24),CL24'BXAIOSVD &SYSDATE &SYSTIME'
         DC    A(SVDIN)                * Setup routine for parameter 2
         DC    A(SVDOUT)               * Output conversion routine
*
IOSVD_GO EQU   *
         STM   R14,R12,12(R13)         * Save caller's registers
         LA    R3,BXAIOGO              * Set base register
         BR    R3                      * and execute main line
         CNOP  0,8                     * Re-align on doubleword
         DROP  R15                     * End of entry logic for SVD
*
         EJECT
         USING BXAIOGO,R3              * Declare base register
BXAIOGO  EQU   *
         LA    R14,SAVEAREA            * Retrieve address of save-area
         ST    R13,4(R14)              * Set backward pointer
         XR    R0,R0                   * Set to zero for compare
         C     R0,0(R13)               * Old save-area is PL/I ??
         BNE   *+8                     * Yes: no forward pointer !!
         ST    R14,8(R13)              * Set forward pointer
         LR    R13,R14                 * and switch to new save-area
*
         SPACE 3
         LR    R4,R15                  * Set base reg to entry point
         USING HDRDATA,R4              * Inserted 7-9-2001
*
         OI    PLIST+4,X'80'           * Set end-of-plist
         LTR   R1,R1                   * Plist ??
         BZ    NOPARM                  * No: no conversion
*  Sometimes end-of-plist marker is missing.
**       TM    0(1),X'80'              * End-of-plist correct ??
**       BNO   NOPARM                  * No: no conversion
         L     R1,0(R1)                * Get address of parameter
         LA    R1,0(R1)                * Strip end-of-plist bit
         LTR   R1,R1                   * Address is valid ??
         BZ    NOPARM                  * No: no conversion
         ST    R1,PLIST                * Store address of input-parm
*
         L     R15,MOVEIN              * Get addr of move-input routine
         BASR  R14,R15                 * and execute it
*
LOAD     ICM   R15,B'1111',ENTRY       * First time: load BXAIO00
         BNZ   BXAIO00                 * thereafter: execute immediate
*
         SPACE 3
         LOAD  EP=BXAIO00,ERRET=ERROR  * Load dynamic I/O routine
         B     LOADOK                  * I/O routine correctly loaded
*
ERROR    WTO   'BXAIO - 68 - Cannot load dynamic module BXAIO00',      *
               ROUTCDE=11,DESC=7
         LA    R10,68                  * Load reasoncode
         L     R1,PLIST                * Get address of parameter
         LTR   R1,R1                   * Valid ??
         BZ    EXITERR                 * No: quit
         MVI   2(R1),C'5'              * Set retcode in caller's parm
         B     EXITERR
*
LOADOK   ST    R0,ENTRY                * Save address of load module
         XC    LNSUAPTR,LNSUAPTR       * Set user-area pointer to zeros
         LR    R15,R0                  * Copy entry point address
*
         SPACE 3
BXAIO00  EQU   *
         LA    R1,PLIST                * Get addr of plist for BXAIO00
         BASSM R14,R15                 * and execute BXAIO00
*
         LTR   R10,R15                 * BXAIO00 was ok ??
         BZ    CONTINUE                * Yes: fill caller's parameter
         L     R1,PLIST                * Retrieve address of parm
         LTR   R1,R1                   * Is it valid ??
         BZ    CONTINUE                * No: cannot process the error
*
         CLI   2(R1),C'1'              * EOF / record not found ??
         BE    CONTINUE                * Yes: use exit after error
*
         CH    R10,=H'025'             * If userarea could not be freed
         BNE   NOWIPEUA                * then LNSUAPTR may be invalid
         XC    LNSUAPTR,LNSUAPTR       * and is therefore to be cleared
NOWIPEUA EQU   *
         CLI   2(R1),C'2'              * Error is just a warning ??
         BE    CONTINUE                * Yes: return output to caller
         CLI   2(R1),C'0'              * Errorcode set ??
         BNE   EXITERR                 * Yes: use exit-after-error
*                                      * Returncode not set: set it
         CH    R10,=H'025'             * Userarea freeing error ??
         BNE   NOTERR25                * No: skip setting code 2
         MVI   2(R1),C'2'              * Set error level to two
         B     CONTINUE                * and carry on accordingly
NOTERR25 EQU   *
*
         CH    R10,=H'026'             * No parameter-error ??
         BNE   NOTERR26                * No: skip setting code 3
         MVI   2(R1),C'3'              * Set error level to three
         B     EXITERR                 * And use exit-after-error
NOTERR26 EQU   *
*
         MVI   2(R1),C'5'              * Other error: set RCODE to 5
         B     EXITERR                 * and use exit-after-error
*
         EJECT
CONTINUE EQU   *                       * Statements disabled:no moveout
*
**!!     L     R1,PLIST                * Get address of parm in caller
**!!     L     R15,MOVEOUT             * Get addr of move-output routin
**!!     BASR  R14,R15                 * and execute it
*
         CLC   LNSUAPTR,=F'0'          * USERAREA de-allocated ??
         BNE   EXITERR                 * No: leave BXAIO00 in storage
         DELETE EP=BXAIO00             * Remove dynamic mod from memory
         LTR   R15,R15                 * Delete was ok ??
         BNE   DELETERR                * No: issue delete error
         XC    ENTRY,ENTRY             * Next call: reload dynamic mod
*
EXITERR  EQU   *
         LR    R15,R10                 * Restore saved reasoncode
*
EXIT     EQU   *
         L     R13,4(R13)              * Retrieve addr of old save-area
         L     R14,12(R13)             * Restore return address
         LM    R0,R12,20(R13)          * Restore all other registers
         BR    R14                     * and return with retcode
*
DELETERR WTO   'BXAIO - 74 - Cannot remove dymanic module BXAIO00',    *
               ROUTCDE=11,DESC=7
         LA    R10,74                  * Load reasoncode
         L     R1,PLIST                * Get address of parameter
         LTR   R1,R1                   * Valid ??
         BZ    EXITERR                 * No: quit
         MVI   2(R1),C'5'              * Set retcode in caller's parm
         B     EXITERR
*
         SPACE 3
* Reset end-of-plist bit to cause error - to be issued by BXAIO00
NOPARM   EQU   *                       * No parameter given by applic.
         NI    PLIST+4,X'7F'           * Reset end-of-plist bit
         B     LOAD                    * And go call to issue error
         DROP  4                       * Inserted 7-9-2001
*
         EJECT
CCDIN    EQU   *                       * Movein of BXAIOCCD
         MVC   LNSVERSI,=C'01'         * Set parameter version to 01
         MVC   LNSFILES,=C'10000000'   * Select all files for CCD-parm
         BR    R14                     * Return to mainline
*
CCDOUT   EQU   *                       * Moveout of BXAIOCCD
         BR    R14                     * Return to mainline
*
         SPACE 2
CPDIN    EQU   *                       * Movein of BXAIOCPD
         MVC   LNSVERSI,=C'02'         * Set parameter version to 02
         MVC   LNSFILES,=C'01000000'   * Select all files for CPD-parm
         BR    R14                     * Return to mainline
*
CPDOUT   EQU   *                       * Moveout of BXAIOCPD
         BR    R14                     * Return to mainline
*
         SPACE 2
CCXIN    EQU   *                       * Movein of BXAIOCCX
         MVC   LNSVERSI,=C'03'         * Set parameter version to 03
         MVC   LNSFILES,=C'00100000'   * Select all files for CCX-parm
         BR    R14                     * Return to mainline
*
CCXOUT   EQU   *                       * Moveout of BXAIOCCX
         BR    R14                     * Return to mainline
*
         SPACE 2
PDDIN    EQU   *                       * Movein of BXAIOPDD
         MVC   LNSVERSI,=C'04'         * Set parameter version to 04
         MVC   LNSFILES,=C'00010000'   * Select all files for PDD-parm
         BR    R14                     * Return to mainline
*
PDDOUT   EQU   *                       * Moveout of BXAIOPDD
         BR    R14                     * Return to mainline
*
         SPACE 2
CSCIN    EQU   *                       * Movein of BXAIOCSC
         MVC   LNSVERSI,=C'05'         * Set parameter version to 05
         MVC   LNSFILES,=C'00001000'   * Select all files for CSC-parm
         BR    R14                     * Return to mainline
*
CSCOUT   EQU   *                       * Moveout of BXAIOCSC
         BR    R14                     * Return to mainline
*
         SPACE 2
ACDIN    EQU   *                       * Movein of BXAIOACD
         MVC   LNSVERSI,=C'06'         * Set parameter version to 06
         MVC   LNSFILES,=C'00000100'   * Select all files for ACD-parm
         BR    R14                     * Return to mainline
*
ACDOUT   EQU   *                       * Moveout of BXAIOACD
         BR    R14                     * Return to mainline
*
         SPACE 2
SVDIN    EQU   *                       * Movein of BXAIOSVD
         MVC   LNSVERSI,=C'07'         * Set parameter version to 07
         MVC   LNSFILES,=C'00000010'   * Select all files for SVD-parm
         BR    R14                     * Return to mainline
*
SVDOUT   EQU   *                       * Moveout of BXAIOSVD
         BR    R14                     * Return to mainline
*
         EJECT
SAVEAREA DS    9D                      * Save-area for all entry points
ENTRY    DS    F                       * Entry point of dynamic module
PLIST    DC    A(0)                    * Parameter in application
         DC    A(LNSPRM2)              * Extra parameter
*
         DS    0D
LNSPRM2  DS    0CL16
LNSUAPTR DS    A                       * Address of user-area
LNSVERSI DS    CL2                     * Parameter version number
LNSFILES DS    CL8                     * Logical files to be used
         DS    CL2                     * Reserved
*
         LTORG
*
         END
./ ADD NAME=BXAIO00  0100-20110-20110-2315-05004-05004-00000-BXAASM  15
BXAIO00  TITLE 'Dynamic module for VSAM I/O handling'
***********************************************************************
* Start create : 20-03-1989
* 1st delivery : 15-08-1989
* Designer     : AF Kornelis
* Programmer   : AF Kornelis
* Reason       : Untie logical record lay-outs from physical file
*                structure
***********************************************************************
* Change 01    : 22-06-1990
* Programmer   : JB
* Reason       : Add 2 logical record lay-outs: PDD and CSC
*              : Add supporting physical files: PDD and CSC
***********************************************************************
* Change 02    : 31-10-1991
* Programmer   : JB
* Reason       : Add 1 logical record lay-out: CCX
*              : Add supporting physical file: CCX
***********************************************************************
* Change 03    : 31-05-1992
* Programmer   : JB
* Reason       : Add 1 logical record lay-out: ACD
*              : Add supporting physical file: ACD
***********************************************************************
* Change 04    : 31-05-1996
* Programmer   : JB
* Reason       : Add 1 logical record lay-out: SVD
*              : Add supporting physical file: SVD
*              : These changes were never implemented
***********************************************************************
* Change 05    : Summer 2001
* Programmer   : Abe F. Kornelis
* Reason       : Remove warning errors from assembly
*                Improve comments
***********************************************************************
         EJECT
***********************************************************************
*
* When maintaining this program, please mind the following:
* - Never change any data or coding in the program at run-time. For
*   storing data, always use getmained areas. Otherwise reenterability
*   will be lost.
* - When suballocating storage areas (whether getmained or not)
*   always allocate on a doubleword boundary.
* - Remember never to use r12, since it contains information that the
*   PL/I estae/espie-routines need for error/exception handling.
* - Do not try to call this module recursively: it won't work.
* - Allocate all variable storage areas from subpool &sp (17). Since
*   applications get their storage from subpool 0, the chances of
*   destructive interference between BXAIO00 and application is
*   minimal. By taking all storage from the same subpool, the
*   chances of page-faults are minimized.
* - Debugging is controlled by the &DBG global variable: if it
*   contains the value 1 then debugging code will be generated,
*   otherwise debugging code will be skipped.
* - Optimization (speed and size of load) is controlled by &OPT
* - The program is reenterable. If it is to become refreshable, remove
*   the crashmem area and have the uaerr error-exit dump in stead of
*   using the crashmem area.
*
*******
*
* The following subjects still need to be taken care of:
* - IMS/LST conflicts
* - Check RPL-status before issuing any vsam-request
* - temporary modifications are marked by **!!
*
***********************************************************************
         EJECT
***********************************************************************
*
* The structure of control blocks used in this program is as follows:
*   ________
*  |        |
*  | Caller |
*  | BXAIOxxx     ________
*  |--------|    |        |
*  |LNSUAPTR|--->|USERAREA|     ________
*  |________|    |--------|    |        |
*                |UAFDBPTR|--->|  FDB   |
*                |________|    |--------|
*                              |FDBNEXT |---> next FDB --> next FDB etc
*                              |--------|
*                              | FDBACB |---> ACB ---> DDNAME ---> FILE
* LNSUAPTR is a pointer to     |--------|
*    the USERAREA, where all   | FDBRPL |---> RPL ---> ACB        ____
*    caller-dependent data     |--------|     _______            | ME |
*    are to be found.          | FDBMAP |--->|  MME  |---------->|----|
*                              |________|    |-------|    ____   | ME |
* UAFDBPTR is the entry to                   |  MME  |-->| ME |  |----|
*    the chain of FDBs. Each FDB             |-------|   |----|  | .  |
*    contains information pertaining         |   .   |   | ME |  | .  |
*    to one physical dataset.                |   .   |   |----|  | .  |
*                                            |   .   |   | .  |  |____|
* FDBMAP is a pointer to a list of           |_______|   | .  |
*    Map-Master-Elements. Each MME                       | .  |
*    corresponds with one parameter version.             |____|
*    Thus, for each dataset there is one and only one
*    MME-list, which is the same for all callers.
*
* The MME in turn contains a pointer to a list of Map-Elements.
*    Each Map-Element specifies one block of data that may be
*    moved in one piece between the parameter (BXAIOPRM) and a
*    physical record.
*
***********************************************************************
         EJECT
***********************************************************************
*
* The program has been split up into the following sections:
*              each section has its own addressability.
*
* - PHASE1   - housekeeping
*            - general check of parameter
* - PHASE2   - evaluation of the requested function code
*            - setup of FDBs to reflect the request
*            - phase2 includes the checkxx routines
* - PHASE3   - execution of the requests
*            - phase3 includes the rxx routines
* - PHASE4   - waiting for completion of asynchronous i/o
*            - post-processing
*            - cleanup of resources no longer needed
*            - return to caller
* - RCHECK   - second level routine that waits for vsam-i/o-completion
* - ERROR    - error handling routine
*            - error includes the error exits (for example: vserr)
* - RSETBASE - lowest-level subroutine, used for returning to a caller
*              which may or may not use a different base address for
*              its addressability.
* - RSNAP    - debugging help routine, linked as a separate subprogram.
*            - rsnap dumps control blocks that are both defined by this
*              program and currently in use.
*
***********************************************************************
         EJECT
*
* The assembler program accepts as a JCL-parameter a specification
* for the variable SYSPARM. The value entered in the JCL will be
* passed to a global set symbol named &SYSPARM. The value specified
* in the JCL is passed as a single string. This macro decomposes the
* string into separate parameters. Then the parameters are checked
* and handled. 4 different keywords are allowed:
* - DEBUG   : generate debugging code (rsnap routine, etc.)
* - NODEBUG : do not generate debugging code
* - OPT     : generate a fully optimized program
* - NOOPT   : generate a program with complete error checking
*
         MACRO
         CHECKPRM
*
         GBLB  &DBG,&OPT
&DBG     SETB  0                       * Default: no debug coding
&OPT     SETB  1                       * Default: full optimization
         AIF   ('.&SYSPARM' EQ '.').EXIT
*
* First the SYSPARM string is to be split into substrings
*
         LCLC  &P(5)                   * Array to contain parms
         LCLA  &I,&N,&X
&I       SETA  0                       * Character indec for &SYSPARM
&N       SETA  1                       * Next position to extract
&X       SETA  1                       * Parameter counter (array &P)
.LOOP1   ANOP
&I       SETA  &I+1                    * Increment character index
         AIF   (&I GT K'&SYSPARM).LOOP1X       * End-of-string ??
         AIF   ('&SYSPARM'(&I,1) NE ',').LOOP1 * End-of-substring ??
&P(&X)   SETC  '&SYSPARM'(&N,&I-&N)            * Extract substring
&N       SETA  &I+1                    * Set ptr to start of substring
&X       SETA  &X+1                    * Increment substring counter
         AGO   .LOOP1                  * and go check next character
*
.LOOP1X  ANOP
&P(&X)   SETC  '&SYSPARM'(&N,&I-1)     * Extract last substring
*
* Now check that keywords are valid
*                                      * &X now is count of parms
&I       SETA  0                       * Index into array P
.LOOP2   ANOP
&I       SETA  &I+1                    * Increment parm index
         AIF   (&I GT &X).LOOP2X       * All parms checked ??
         AIF   ('.&P(&I)' EQ '.').LOOP2 * Skip empty parm
         AIF   ('.&P(&I)' EQ '.OPT').OPT
         AIF   ('.&P(&I)' EQ '.NOOPT').NOOPT
         AIF   ('.&P(&I)' EQ '.DEBUG').DEBUG
         AIF   ('.&P(&I)' EQ '.NODEBUG').NODEBUG
         MNOTE 4,'Invalid SYSPARM operand: &P(&I)'
         AGO   .LOOP2                  * and go try next parm
*
.OPT     ANOP
&OPT     SETB  1
         MNOTE 0,'Optimized coding will be generated'
         AGO   .LOOP2
*
.NOOPT   ANOP
&OPT     SETB  0
         MNOTE 0,'Fault tolerant coding will be generated'
         AGO   .LOOP2
*
.DEBUG   ANOP
&DBG     SETB  1
         MNOTE 0,'Debugging code will be included'
         AGO   .LOOP2
*
.NODEBUG ANOP
&DBG     SETB  0
         MNOTE 0,'Debugging code will be excluded'
         AGO   .LOOP2
*
.LOOP2X  ANOP
.EXIT    ANOP
*
         MEND
*
         EJECT
*
* The RSNAP-routine, which is available in debug mode only, may return
* an error code. If an error code is received, then the error handler
* should be invoked before continuing. Thus the error will be issued
* as it should.
* In order not to have to code the whole protocol for each call to
* the snap routine an extended snap macro (ESNAP) has been provided.
* This macro will generate a call to the RSNAP-routine with full
* error handling.
*
         MACRO
         ESNAP
*
         GBLB  &DBG,&ERR
         AIF   (NOT &DBG).ESNAP
*
         L     R15,=AL4(RSNAP)         * Retrieve entry-point of RSNAP
         BASR  R14,R15                 * Call the RSNAP-routine
         LTR   R15,R15                 * Error in RSNAP ??
         AIF   (&ERR).ESNAPER
         BE    *+14                    * No: skip error handling
         OI    UASTAT,UASNAPER         * Indicate snap is in error
         L     R3,=AL4(ERROR)          * Load address of error handler
         BASR  R14,R3                  * Issue error, then return here
*
         MEXIT ,                       * Macro complete
*
.ESNAPER ANOP  ,                       * Snap error in error-handler
         BE    *+16                    * No: skip error handling
         OI    UASTAT,UASNAPER         * Indicate snap is in error
         L     R14,UAERRSAV            * Reload original return address
         B     ERROR                   * Restart error handler
*
.ESNAP   ANOP
         MEND
*
         EJECT
         PRINT NOGEN
*
* Register equates
*
R0       EQU   0                       * Work register
R1       EQU   1                       * Work register
R2       EQU   2                       * Work register
R3       EQU   3                       * Base register
R4       EQU   4                       * Pointer to parameter area
R5       EQU   5                       * Pointer to current FDB
R6       EQU   6                       *
R7       EQU   7                       *
R8       EQU   8                       *
R9       EQU   9                       *
R10      EQU   10                      *
R11      EQU   11                      * Data-area ptr (constants etc.)
R12      EQU   12                      * Reserved for pli-environment
R13      EQU   13                      * USERAREA pointer (see note)
R14      EQU   14                      * Return address
R15      EQU   15                      * Entry point addr / return code
*
* Note: Since the save-area is placed first in the user-data area
*       R13 is a pointer to both of these areas.
*
         SPACE 3
*
* The global &DBG controls debug/nodebug assembling options
* - when &dbg = 1 then debugging is active.
* The global &opt controls optimization.
* - when &opt = 1 then full optimization takes place.
* - when &opt = 0 then full fault tolerance will be generated.
*
         GBLB  &DBG,&OPT
* Check &SYSPARM to set &DBG and &OPT
         CHECKPRM
*
         GBLB  &ERR
&ERR     SETB  0                       * Not assembling error-routine
*
         SPACE 3
*
         GBLA  &NOOFFDB,&AANTFIL,&MAXKEY,&SP
&NOOFFDB SETA  8                       * Nr of fdbs to be allocated
&AANTFIL SETA  6                       * Max. nr of files
&MAXKEY  SETA  15                      * Length of longest key
&SP      SETA  17                      * Subpoolnr for storage requests
* The number 17 was chosen arbitrarily.
* Any number between 1 and 127 will do.
*
         SPACE 3
*
* To keep the code reentrant, it is required that we have a workarea
* where code (to be modified) can be copied, before it is changed.
* Here we set up a global variable that contains the length we need.
* Whenever anything is moved into the workarea (uaworkar) make sure
* that it does not extend beyond the allocated area. If more room is
* needed for a workarea, increase the &WORKLV variable. If the &WORKLV
* is changed, always change it to a multiple of 8. Thus correct
* alignment is ensured for the data fields following the workarea.
*
         GBLA  &WORKLV                 * Var to contain required length
&WORKLV  SETA  160                     * Greatest length we expect
*
         SPACE 3
*
         GBLC  &PRT                    * Controls print option
&PRT     SETC  'NOGEN'                 * Nogen is default
         AIF   (NOT &DBG).NOGEN        * When debugging then
&PRT     SETC  'GEN'                   *   generate full listing
.NOGEN   ANOP
         PRINT &PRT                    * Set print option
*
         EJECT
*
* Setup save area, and establish addressability. For a save-area
* storage must be obtained from the system. The address of this
* private save-area is saved for subsequent calls.
*
BXAIO00  CSECT
BXAIO00  AMODE 31                      * 31-bit addressing
BXAIO00  RMODE 24                      * Residency below 16m
*
PHASE1   EQU   *
         USING BXAIO00,R15             * R15 assumed base
         B     BXAIO000                * Branch around text
         DC    AL1(23),CL23'BXAIO00 &SYSDATE &SYSTIME'
CONSTADR DC    AL4(CONST)              * Address of data-area
BXAIO000 STM   R14,R12,SAVEDR14(R13)   * Save regs of calling module
         LR    R3,R15                  * Pick up base register
         DROP  R15                     * Switch from temporary
         USING PHASE1,R3               * to permanent base register
*
         L     R11,CONSTADR            * Get address of data-area
         USING CONST,R11               * and establish addressability
*
         XR    R6,R6                   * Provide for hex-zeroes
*
* Obtain address of parameter from caller. If invalid, issue error.
*
         AIF   (&OPT).GOTPARM
         LTR   R1,R1                   * Is a plist given ??
         BNE   GOTPARM                 * Yes, skip error
NOPARM   LA    R15,026                 * Indicate error number
         L     R14,=AL4(EXIT)          * Let error return to exit
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, then exit
*
GOTPARM  TM    4(R1),X'80'             * Is the 2nd word the last one ?
         BNO   NOPARM                  * No: argument(s) invalid
.GOTPARM L     R4,0(R1)                * Get 1st plist element
         AIF   (&OPT).GOTPRM2
         LA    R4,0(R4)                * Nullify leading bits
         LTR   R4,R4                   * Is it valid ??
         BZ    NOPARM                  * No: go issue error
.GOTPRM2 ANOP
         USING DS83PARM,R4             * Use R4 to address parm area
         USING DSFDB,R5                * Use R5 to address current FDB
*
         L     R2,4(R1)                * Load address of second parm
         LA    R2,0(R2)                * Remove end-of-plist marker
         AIF   (&OPT).FASE110
         LTR   R2,R2                   * Is it valid ??
         BZ    NOPARM                  * No: go issue error
*
.FASE110 USING DS83PRM2,R2             * Use R2 to address parm 2
         L     R1,LNSUAPTR             * Get address of USERAREA
         LTR   R1,R1                   * Is address valid ??
         BNZ   GOTM                    * If not allocated: get storage
*
         SPACE 3
*
* Since the private save-area-pointer is invalid, this must be the
* first call. Therefore storage is to be obtained for the USERAREA
* (including the new save-area). Storage for run-time FDBs is
* obtained at the same time.
*
GETM     GETMAIN RC,                   * Conditional request (register)*
               SP=&SP,                 *  from our private subpool     *
               LV=L'USERAREA           *  for allocating the USERAREA
         LTR   R15,R15                 * Storage allocated ??
         BZ    GETMOK                  * Yes: skip error
         LA    R15,069                 * Load error code
         L     R14,=AL4(EXIT)          * Let error return to EXIT
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, then goto exit
*
GETMOK   EQU   *
         ST    R1,LNSUAPTR             * Save area address
*
         SPACE 3
*
* R1 now points to our private save-area.
*
GOTM     EQU   *
         ST    R13,SAVEPREV(R1)        * Set backward pointer
         C     R6,SAVEPLI(R13)         * PLI uses 1st word of savearea
         BNE   ENVIRPLI                * For PLI env.: no forward ptr
         ST    R1,SAVENEXT(R13)        * Set forward ptr (non-PLI env.)
ENVIRPLI LR    R13,R1                  * Point to new savearea
         USING DSUSERAR,R13            * Address USERAREA & savearea
*
* In the UAERR routine R11 is used to determine whether R13 points to
* our own USERAREA or somewhere different. Therefore R11 is to be saved
* in its proper place. Thus this USERAREA will be recognizable.
*
         ST    R11,SAVEDR11(R13)       * Mark this save-area as our own
*
* Copy data we will need from parm 2 to the USERAREA
*
         LCLC  &LM                     * Length modifier
&LM      SETC  'L''UASELECT'           * Default: full length
         AIF   (NOT &OPT).FASE120      * When optimizing:
&LM      SETC  '&AANTFIL'              *  copy only the needed bytes
.FASE120 MVC   UASELECT(&LM),LNSFILES  * Logical data-group selectors
         MVC   UAVERSI,LNSVERSI        * Parameter 1 version nr
         DROP  R2                      * End addressability to ds83prm2
*
         SPACE 3
*
* Increment call-count and initialize return- and reasoncode to zero
*
         AIF   (&OPT AND (NOT &DBG)).FASE130
         L     R1,UACALLNR             * Retrieve call-count
         LA    R1,1(R1)                * Increment call-count by one
         ST    R1,UACALLNR             * Store call-count in USERAREA
.FASE130 MVI   UARETCD,C'0'            * Set returncode
         STH   R6,UAREASN              * Set reasoncode to H'0'
         MVC   UAKEY,LNSKEY            * Copy key from parm
*
         SPACE 3
*
* Check select/deselect codes for each logical file section
*
         AIF   (&OPT).FASE140
         LA    R7,UASELECT             * First byte to be checked
         LA    R8,1                    * Increment value for loop
         LA    R9,UASELECT+L'UASELECT-1 * Last byte to be checked
LOOP0    CLI   0(R7),C'0'              * Valid deselect code ??
         BE    LOOP0NX                 * Yes: check next selector
         CLI   0(R7),C'1'              * Valid select code ??
         BE    LOOP0NX                 * Yes: check next selector
         LA    R15,003                 * Load error message nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then continue
         MVI   0(R7),C'0'              * Default to deselect section
LOOP0NX  BXLE  R7,R8,LOOP0             * Loop to try next selector
*
.FASE140 ANOP
*
* First we must map the individual requests for logical file sections
* (UASELECT) onto physical file requests (UAFILES).
* Mapping is now 1 to 1, but this may be changed in future.
* The bytes of UAFILES must always correspond 1 to 1 with the
* FDBNR field of each FDB in the FDB-chain. If two files are always
* to be treated identically then they should be given the same value
* for their FDBNR-fields.
*
         AIF   (NOT &OPT).MAPPIN0
         MVC   UAFILES(&LM),UASCCDI    * Copy options (XLATE = 1 to 1)
         AGO   .MAPPINX
*
.MAPPIN0 ANOP
MAPPING0 MVC   UAFILES(&LM),=&NOOFFDB.C'0' * Prefill with zeroes
         CLI   UASCCDI,C'1'            * 1st logical section requested?
         BNE   MAPPING1                * No
         MVI   UAFILES+0,C'1'          * Map section 1 to FDBNR 0
*
MAPPING1 CLI   UASCPDI,C'1'            * 2nd logical section requested?
         BNE   MAPPING2                * No
         MVI   UAFILES+1,C'1'          * Map section 2 to FDBNR 1
*
MAPPING2 CLI   UASCCXI,C'1'            * 3rd logical section requested?
         BNE   MAPPING3                * No
         MVI   UAFILES+2,C'1'          * Map section 3 to FDBNR 2
*
MAPPING3 CLI   UASPDDI,C'1'            * 4th logical section requested?
         BNE   MAPPING4                * No
         MVI   UAFILES+3,C'1'          * Map section 4 to FDBNR 3
*
MAPPING4 CLI   UASCSCI,C'1'            * 5th logical section requested?
         BNE   MAPPING5                * No
         MVI   UAFILES+4,C'1'          * Map section 5 to FDBNR 4
*
MAPPING5 CLI   UASACDI,C'1'            * 6th logical section requested?
         BNE   MAPPING9                * No
         MVI   UAFILES+5,C'1'          * Map section 6 to FDBNR 5
*
MAPPING9 EQU   *
         AIF   (&OPT).MAPPINX
         CLC   UAFILES,=&NOOFFDB.C'0'  * Still all zeroes ??
         BNE   MAPPINGX                * No: carry on
         LA    R15,004                 * Load error number
         L     R14,=AL4(EXIT)          * Get return address for error
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, then goto exit
*
.MAPPINX ANOP
*
MAPPINGX EQU   *
*
         SPACE 3
*
* Phase 1 of the program is now done. Change base register for phase 2
*
         L     R3,=AL4(PHASE2)         * Load address of next phase
         AIF   (&OPT).FASE1ND
         BR    R3                      * And go execute it
*
.FASE1ND DROP  R3                      * End of phase 1
FASE1END EQU   *
*
         EJECT
         USING PHASE2,R3
PHASE2   EQU   *
*
* Now the mapping from logical data groups in the parameter onto
* physical VSAM files has taken place, the function code in the
* parameter is to be translated into request bits in the FDBREQ field
* of each file concerned. This is done by checking the function code
* against a table of supported function codes. The table also contains
* for each supported function code the address of a checking routine.
*
* Now run-time FDBs have been set up. Before we can set them according
* to the current request we must look up the requested function code in
* the table of supported opcodes.
*
         L     R7,=AL4(OPCODES)        * Starting address of table
         LA    R8,L'OPC                * Length of each element
         L     R9,=AL4(OPCODEND)       * Ending address of table
         USING DSOPC,R7                * Address table by DSECT
LOOP1    CLC   LNSFCODE,OPCFCOD        * Is it this element ??
         BE    LOOP1EX                 * Yes: terminate inner loop
         BXLE  R7,R8,LOOP1             * Try next element
*                                      * No valid function-code found
         B     LOOP250                 * Skip to exit handling for err
LOOP1EX  EQU   *                       * Seek opcode is now done
         ST    R7,UAOPCADR             * Save address in userarea
*
         AIF   (&OPT).LOOPA
*
* FDBs are to be generated on first call
*
         CLC   UAFDBPTR,=F'0'          * FDBs allocated ??
         BE    LOOPA                   * No: go force allocation
.LOOPA   ANOP
*
         TM    OPCMASK,FDBOPEN         * Is this an open-request ??
         BNO   LOOP2INI                * No: go initiate loop 2
*
* An open request is to be processed. Allocate run-time FDBs
* from the defaults chain when necessary.
*
LOOPA    LA    R5,=AL4(CCDFDB)         * Point to root of default FDBs
LOOPA1   L     R5,FDBNEXT              * Get next default FDB
         LTR   R5,R5                   * Is it valid ??
         BZ    LOOP2INI                * No: we're done
         AIF   (NOT &OPT).LOOPA1
*
* Optimized version is to check whether the FDB is to be opened.
* If not, then it should not be allocated. In test version
* however, all FDBs are to be allocated, or no errors will be
* generated for calls against unopened files.
*
         XR    R1,R1                   * Clear register
         IC    R1,FDBNR                * to contain FDB-group-number
         LA    R6,UAFILES(R1)          * Get addr of file group switch
         CLI   0(R6),C'1'              * Switch is on ??
         BNE   LOOPA1                  * No: try next default FDB
.LOOPA1  ANOP
*
* This FDB is to be activated. If no runtime-fdb exists, then a
* new one will have to be allocated.
*
         AIF   (&OPT).LOOPA2
         L     R10,=AL4(SEEKSPC)       * Get address of seekspace table
         LA    R6,FDBDDNAM             * Point DDNAME in default FDB
         TRT   FDBDDNAM,0(R10)         * Find addr of first blank
         BNZ   LOOPA105                * If no spaces, use full length
         LA    R1,L'FDBDDNAM(R6)       * Point beyond DDNAME
LOOPA105 SR    R1,R6                   * Used length of DDNAME
         BCTR  R1,R0                   * Decrement count by one for CLC
*
.LOOPA2  LA    R9,UAFDBPTR             * Point to root of FDBs
LOOPA2   L     R10,0(R9) =FDBNEXT      * Point to next FDB
         LTR   R10,R10                 * Is it valid ??
         BZ    LOOPA2EX                * No: exit
         LR    R9,R10                  * Copy address of next FDB
         AIF   (&OPT).LOOPA21
         EX    R1,LOOPACLC             * Compare DDNAMEs
         AGO   .LOOPA22
*
.LOOPA21 CLC   FDBDDLOC(3,R9),FDBDDNAM * DDNAME base is three chars
.LOOPA22 BNE   LOOPA2                  * Not =: try next default FDB
         B     LOOPA1                  * Equal: dont allocate a new FDB
*
LOOPA2EX EQU   *                       * Allocate new FDB
         GETMAIN RC,                   * Conditional storage request   *
               SP=&SP,                 *    from our own subpool       *
               LV=L'FDB                *    for allocating an FDB
         LTR   R15,R15                 * Storage allocated ??
         BZ    LOOPA120                * Yes: add it to the chain
         LA    R15,069                 * Set error code
         L     R14,=AL4(EXIT)          * Get return addr for error rout
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * And execute it
*
LOOPA120 MVC   0(L'FDB,R1),FDB         * Copy default FDB to new area
         MVC   0(4,R1),0(R9) = FDBNEXT * Copy next-ptr from prev FDB
         ST    R1,0(R9)      = FDBNEXT * Let prev FDB point to new one
         AIF   (&OPT).LOOP2IN
         B     LOOPA1                  * Check remaining default FDBs
*
LOOPACLC CLC   FDBDDLOC(0,R9),FDBDDNAM * Compare DDNAME with default
*
         SPACE 3
.LOOP2IN ANOP
*
* Now that we have the opcode-element to be used we must loop
* through all run-time FDBs. Use their FDBNR-value as an index
* in UAFILES to determine whether this file is to be processed for
* the current request. If it is to be processed, set the FDBREQ-bits
* to indicate the actions phase 3 is to take.
*
LOOP2INI LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOP2    L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * Does it point to nowhere ??
         BZ    LOOP2EX                 * If no next FDB, then exit loop
         MVI   FDBREQ,FDBNOREQ         * Reset all request bits
         MVI   FDBRETCD,X'00'          * Reset returncode to zero
         XR    R1,R1                   * Clear register
         STH   R1,FDBREASN             * Reset reasoncode for this FDB
         IC    R1,FDBNR                * Load relative file nr to use
         LA    R6,UAFILES(R1)          * Point to file switch
         CLI   0(R6),C'1'              * Indicator in parm = 1 ??
         BNE   LOOP2                   * No: go try next one
*
* Set the request bits associated with this opcode. If a checking
* routine is specified for the opcode, execute it.
*
         OC    FDBREQ,OPCMASK          * Set request bits
LOOP250  L     R8,OPCROUT              * Get exit routine address
         AIF   (&OPT).LOOP210
         LTR   R8,R8                   * Check on zero
         BZ    LOOP2                   * If zero, skip execution
.LOOP210 BASR  R14,R8                  * Go execute exit routine
         L     R7,UAOPCADR             * Reload opcode-element address
         B     LOOP2                   * And go try next FDB
*
LOOP2EX  EQU   *
*
         SPACE 3
*
* Phase 2 is now done. Go proceed to phase 3.
*
         L     R3,=AL4(PHASE3)         * Get entry point of next phase
         BR    R3                      * And go execute it
*
         EJECT
*
* Checking routines to evalute the validity of the request
* first are listed the check-routines that combine requests
* explicitly. These execute the elementary checks that are listed
* thereafter. The elementary requests may in turn invoke other
* elementary request checking routines for implicit open requests.
*
         SPACE 3
*
* CHECKSN: request to skip, then to read sequential. The request may
* imply open input as well. The open request will be forced by the
* execution of the checksk routine.
*
CHECKSN  EQU   *
         ST    R14,UALV1SAV            * Save return address
         BAS   R14,CHECKSK             * Execute check-rout for skip
         L     R14,UALV1SAV            * Retrieve return address
         B     CHECKRS                 * Execute check-rout for read
*                                      *         which returns to R14
*
         SPACE 3
         AIF   (NOT &DBG).CHECKWN      * Allow WN in test mode only
*
* CHECKWN: request to write, then to read either sequential or random.
* Depending on the random/sequential status different elementary
* check-routines will be executed. If the file is not open, it does not
* matter which write-checker is executed: both will generate an abend.
*
CHECKWN  EQU   *                       * Temporarily not supported
         ST    R14,UALV1SAV            * Save return address
         TM    FDBSTAT,FDBACRND        * Access is currently random ??
         BO    CHECKWNR                * Yes: use random check-routines
         BAS   R14,CHECKWS             * Execute check-rout for skip
         L     R14,UALV1SAV            * Retrieve return address
         B     CHECKRS                 * Execute check-rout for read
*                                      *         which returns to R14
*
* For a random WN-operation we must juggle the key values, otherwise
* either the write will detect a key mismatch or the read will read
* the record just written.
*
CHECKWNR EQU   *
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain key length
         LA    R8,LNSKEY(R7)           * Load address of data area
         BCTR  R7,R0                   * Decrement length by 1 for MVCs
         EX    R7,CHECKMV1             * Save key for read operation
         EX    R7,CHECKMV2             * Copy key of current record
         BAS   R14,CHECKWR             * Execute check-rout for write
*
* Reset key in parameter to reflect the value to be used for reading
*
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain key length
         BCTR  R7,R0                   * Decrement length by 1 for MVC
         EX    R7,CHECKMV3             * Reset key for read operation
         BAS   R14,CHECKRR             * Execute check-rout for read
*
* Before exiting the key of the parm must be set to match the one in
* the record because the write will be executed first.
*
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain key length
         LA    R8,LNSKEY(R7)           * Load address of data area
         BCTR  R7,R0                   * Decrement length by 1 for MVC
         EX    R7,CHECKMV2             * Copy key of current record
         L     R14,UALV1SAV            * Retrieve return address
         BR    R14                     * Return to mainline of phase2
*
.CHECKWN ANOP
*
         SPACE 3
         AIF   (NOT &DBG).CHECKDN      * Allow DN in test mode only
*
* CHECKDN: request to delete, then to read either sequential or random.
* Depending on the random/sequential status different elementary
* check-routines will be executed. If the file is not open, the
* delete-checker will generate an abend.
*
CHECKDN  EQU   *                       * Temporarily not supported
         ST    R14,UALV1SAV            * Save return address
         TM    FDBSTAT,FDBACRND        * Access is currently random ??
         BO    CHECKDNR                * Yes: use random check-routines
         BAS   R14,CHECKDR             * Execute check-rout for delete
         L     R14,UALV1SAV            * Retrieve return address
         B     CHECKRS                 * Execute check-rout for read
*                                      *         which returns to R14
*
* For a random DN-operation we must juggle the key values, otherwise
* either the delete will detect a key mismatch or the read will find
* a deleted record.
*
CHECKDNR EQU   *
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain key length
         LA    R8,LNSKEY(R7)           * Load address of data area
         BCTR  R7,R0                   * Decrement length by 1 for MVCs
         EX    R7,CHECKMV1             * Save key for read operation
         EX    R7,CHECKMV2             * Copy key of current record
         BAS   R14,CHECKDR             * Execute check-rout for delete
*
* Reset key in parameter to reflect the value to be used for reading
*
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain key length
         BCTR  R7,R0                   * Decrement length by 1 for MVC
         EX    R7,CHECKMV3             * Reset key for read operation
         BAS   R14,CHECKRR             * Execute check-rout for read
*
* Before exiting the key of the parm must be set to match the one in
* the record because the delete will be executed first.
*
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain key length
         LA    R8,LNSKEY(R7)           * Load address of data area
         BCTR  R7,R0                   * Decrement length by 1 for MVC
         EX    R7,CHECKMV2             * Copy key of current record
         L     R14,UALV1SAV            * Retrieve return address
         BR    R14                     * Return to mainline of phase2
*
.CHECKDN ANOP
*
         SPACE 3
*
* CHECKOI: to open the file for input, it must be currently closed.
* If it is open, then a warning is issued. In the process of
* opening a read of the version control record is to be enforced.
* The required FDBREQ-bits are set, but the key must be set to zeroes.
*
CHECKOI  EQU   *                       * Open input request
         TM    FDBSTAT,FDBINPUT        * Is the file open ??
         BNO   CHECKOX                 * No: set key for version record
         NI    FDBREQ,FDBNOOI          * Reset open input request bit
         TM    FDBSTAT,FDBUPDAT        * Is the file open for update ??
         BNO   CHECKOI2                * No: go issue warning
         LA    R15,019                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKOI2 LA    R15,005                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
         SPACE 3
*
* CHECKOU: to open the file for update, it must be currently closed.
* If it is open, then a warning is issued. This routine is executed
* only for explicit open-update requests.
*
CHECKOU  EQU   *                       * Open update request
         TM    FDBSTAT,FDBINPUT        * Is the file open ??
         BNO   CHECKOX                 * No: set key for version record
         NI    FDBREQ,FDBNOOU          * Reset open update request bits
         TM    FDBSTAT,FDBUPDAT        * Is the file open for update ??
         BO    CHECKOU8                * Yes: go issue warning
         LA    R15,030                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKOU8 LA    R15,005                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
         SPACE 3
*
* CHECKOX routine contains coding for both open-checking routines.
*
CHECKOX  MVC   UAKEY,FDBLKEY           * Copy key of version record
         XC    UALRECAD,UALRECAD       * Set compare record addr to 0
         XC    UALRECLV,UALRECLV       * Set compare record length to 0
         CLI   UAKEY,X'FF'             * First byte of version key ok??
         BNE   CHECKOX3                * Yes: continue
         NI    FDBREQ,FDBNORX          * Reset read request
         MVC   UAKEY,=&MAXKEY.C'0'     * And reset start-key to zeroes
*
CHECKOX3 EQU   *
         TM    FDBREQ,FDBOPRND         * Open is random ??
         BO    CHECKOX5                * Yes: go read if necessary
         TM    FDBREQ,FDBREAD          * Read required ??
         BO    CHECKSN                 * Yes: execute skip-read checker
         B     CHECKSK                 * No: execute skip-checker
*
CHECKOX5 TM    FDBREQ,FDBREAD          * Read required ??
         BO    CHECKRR                 * Y: execute read random checker
         BR    R14                     * No: accept open request
*
         SPACE 3
*
* CHECKSK: to skip to a position in the file, it must be open for
* sequential processing. For skipping at least the first four digits
* of the key must be valid.
*
CHECKSK  EQU   *                       * Skip request
         L     R10,=AL4(NUMTAB)        * Get addr of TRT-table for key
         TRT   UAKEY(4),0(R10)         * Check that key is numeric
         BZ    CHECKSK2                * Yes: skip the error
         NI    FDBREQ,FDBNOSK          * Reset skip request bit
         LA    R15,037                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKSK2 EQU   *
         AIF   (&OPT).CHEKSK3          * Optimized mode: always open
         TM    FDBSTAT,FDBINPUT        * Is the file open ??
         BO    CHECKSK3                * Yes: skip error
         TM    FDBREQ,FDBOPEN          * Is file to be opened ??
         BO    CHECKSK3                * Yes: skip error
         NI    FDBREQ,FDBNOSK          * Reset skip-request bit
         LA    R15,031                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
.CHEKSK3 ANOP
*
CHECKSK3 TM    FDBSTAT,FDBACRND        * File is open, is sequential ??
         BNOR  R14                     * Yes: accept SK-request
         NI    FDBREQ,FDBNOSK          * Reset skip-request bit
         LA    R15,036                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
         SPACE 3
*
* CHECKRS: to read a record sequentially, the file must be open for
* sequential processing. Reading past end of file will cause a
* warning message to be issued, and the request to be ignored.
*
CHECKRS  EQU   *                       * Read sequential request
         AIF   (&OPT).CHEKRS5          * Optimized: file always open
         TM    FDBSTAT,FDBINPUT        * Is the file open ??
         BO    CHECKRS5                * Yes: skip this error
         TM    FDBREQ,FDBOPEN          * Is file to be opened ??
         BNO   CHECKRS2                * No: issue error
         TM    FDBREQ,FDBOPRND         * Open random request ??
         BNOR  R14                     * No: ok, yes: error
*
CHECKRS2 NI    FDBREQ,FDBNORX          * Reset read request bit
         LA    R15,032                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
.CHEKRS5 ANOP
*
CHECKRS5 EQU   *
         TM    FDBSTAT,FDBACRND        * Access is random ??
         BNO   CHECKRS6                * No: go check EOF-condition
         ST    R14,UALV2SAV            * Save return address
         LA    R15,007                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         L     R14,UALV2SAV            * Reload correct return address
         B     CHECKRR                 * And default to read random
*
CHECKRS6 TM    FDBSTAT,FDBEOF          * End-of-file condition raised??
         BNOR  R14                     * No: accept RS-request
         TM    FDBREQ,FDBSKIP          * Was a skip requested as well ?
         BOR   R14                     * Yes: accept RS-request
         NI    FDBREQ,FDBNORX          * Reset read request
         LA    R15,038                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
         SPACE 3
*
* CHECKRR: to read a record randomly, the file must be open for
* random processing, and the full key must be given.
*
CHECKRR  EQU   *                       * Read random request
         L     R10,=AL4(NUMTAB)        * Get addr of TRT-table for key
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain length of key
         BCTR  R7,R0                   * Decrement by one for TRT
         EX    R7,CHECKTRT             * Check that key is numeric
         BZ    CHECKRR2                * Yes: skip the error
         NI    FDBREQ,FDBNORX          * Reset read request bit
         LA    R15,039                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
* Optimized version cannot skip open checking: when the file is not
* open yet, the FDBACRND-bit still is zero, causing an erroneous
* error 008 on any call with opcode RI or RU.
*
CHECKRR2 EQU   *
         TM    FDBSTAT,FDBINPUT        * Is the file open ??
         BO    CHECKRR4                * Yes: skip error
         TM    FDBREQ,FDBOPEN          * Is file to be opened ??
         BNO   CHECKRR3                * Yes: skip error
         TM    FDBREQ,FDBOPRND         * Is file to be opened random ??
         BOR   R14                     * Yes: accept the request
*
CHECKRR3 NI    FDBREQ,FDBNORX          * Reset read-request bit
         LA    R15,032                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKRR4 TM    FDBSTAT,FDBACRND        * Is it open for random ??
         BOR   R14                     * Yes: accept the request
         ST    R14,UALV2SAV            * Save return address
         LA    R15,008                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         L     R14,UALV2SAV            * Reload original return address
         B     CHECKRS                 * Try to read sequantial
*
         SPACE 3
*
* CHECKWS: to rewrite a record sequentially, the file must be open
* for update in sequential mode, and the record to be updated must
* have been read just before the write request.
*
CHECKWS  EQU   *                       * Write sequential request
         TM    FDBSTAT,FDBACRND        * Access is random ??
         BNO   CHECKWX                 * No: skip this error
         ST    R14,UALV2SAV            * Save return address
         LA    R15,009                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         L     R14,UALV2SAV            * Reload return address
         B     CHECKWX                 * Default to 'WR'-processing
*
         SPACE 3
*
* CHECKWR: to rewrite a record randomly, the file must be open
* for update in random mode, and the record to be updated must
* have been read just before the write request.
*
CHECKWR  EQU   *                       * Write random request
         TM    FDBSTAT,FDBACRND        * Access is random ??
         BO    CHECKWX                 * Yes: skip this error
         ST    R14,UALV2SAV            * Save return address
         LA    R15,010                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         L     R14,UALV2SAV            * Reload return address
*                                      * And default to 'WS'-processing
         SPACE 3
*
* CHECKWX: to rewrite a record, whether random or sequential, it is
* required that the record to be updated has been read just before
* the write request. this checking is done here for both modes.
*
CHECKWX  EQU   *
         TM    FDBSTAT,FDBUPDAT        * Is the file open for update ??
         BO    CHECKWX1                * Yes: skip this error
         NI    FDBREQ,FDBNOWX          * Reset write request bit
         LA    R15,033                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKWX1 TM    FDBLREQ,FDBREAD         * Previous operation was read ??
         BO    CHECKWX2                * Yes: skip this error
         NI    FDBREQ,FDBNOWX          * Reset write request bit
         LA    R15,041                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKWX2 TM    FDBSTAT,FDBEOF          * Previous read succcessful??
         BNO   CHECKWX3                * Yes: skip this error
         NI    FDBREQ,FDBNOWX          * Reset write request bit
         LA    R15,041                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKWX3 XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain length of key
         LA    R8,LNSKEY(R7)           * Load start addr of data area
         BCTR  R7,R0                   * Decrement length by 1 for TRT
         EX    R7,CHECKCLC             * Check that key is still equal
         BE    CHECKWX4                * Yes: skip this error
CHECKWXR NI    FDBREQ,FDBNOWX          * Reset write request bit
         LA    R15,043                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKWX4 EQU   *
         EX    R7,CHECKCLK             * Check that keys are equal
         BER   R14                     * It is ok, accept the request
         B     CHECKWXR                * Wrong: issue error
*
         SPACE 3
*
* CHECKIR: to insert a record, the file must be open for update.
* An insert is not required to follow an unsuccessful read.
* The key, however must be numeric.
*
CHECKIR  EQU   *                       * Insert request
         L     R10,=AL4(NUMTAB)        * Get addr of TRT-table for key
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain length of key
         LA    R8,LNSKEY(R7)           * Load address of data area
         BCTR  R7,R0                   * Decrement length by 1 for TRT
         EX    R7,CHECKTRT             * Check that key is numeric
         BZ    CHECKIR2                * Ok, then skip the error
         NI    FDBREQ,FDBNOIR          * Reset insert request bit
         LA    R15,040                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKIR2 EQU   *
         EX    R7,CHECKCLK             * Check that keys are equal
         BE    CHECKIR3                * Ok, then skip the error
         NI    FDBREQ,FDBNOIR          * Reset insert request bit
         LA    R15,045                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKIR3 EQU   *
         EX    R7,CHECKCLZ             * Is this the version record ??
         BNE   CHECKIR4                * No: ok, skip the error
         NI    FDBREQ,FDBNOIR          * Reset insert request bit
         LA    R15,047                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKIR4 TM    FDBSTAT,FDBUPDAT        * Is the file open for update ??
         BOR   R14                     * Yes: request is ok
         NI    FDBREQ,FDBNOIR          * Reset request bit for insert
         LA    R15,034                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
         SPACE 3
*
* CHECKDR: to delete a record, the file must be open for update and
* the record must have been read just before this delete request.
*
CHECKDR  EQU   *                       * Delete request
         TM    FDBSTAT,FDBUPDAT        * Is the file open for update ??
         BO    CHECKDR2                * Yes: skip this error
         NI    FDBREQ,FDBNODR          * Reset delete request bit
         LA    R15,035                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKDR2 TM    FDBLREQ,FDBREAD         * Previous operation was read ??
         BO    CHECKDR3                * Yes: skip this error
         NI    FDBREQ,FDBNODR          * Reset delete request bit
         LA    R15,042                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKDR3 TM    FDBSTAT,FDBEOF          * Previous read reached eof ??
         BNO   CHECKDR4                * No: skip this error
         NI    FDBREQ,FDBNODR          * Reset delete request bit
         LA    R15,042                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
*
CHECKDR4 XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain length of key
         LA    R8,LNSKEY(R7)           * Load address of data area
         BCTR  R7,R0                   * Decrement length by 1 for TRT
         EX    R7,CHECKCLC             * Check that key is still equal
         BE    CHECKDR5                * Yes: skip this error
CHECKDRR NI    FDBREQ,FDBNODR          * Reset delete request bit
         LA    R15,044                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, then return
*
CHECKDR5 EQU   *
         EX    R7,CHECKCLK             * Check that keys are equal
         BNE   CHECKDRR                * Wrong: issue error
*
CHECKDR6 EQU   *
         EX    R7,CHECKCLZ             * Is it the version record ??
         BNER  R14                     * It is ok, accept the request
         NI    FDBREQ,FDBNODR          * Reset delete request bit
         LA    R15,048                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, then return
*
         SPACE 3
*
* CHECKCA: to close the file, it must be open.
* If not open, a warning is issued and the request is ignored.
*
CHECKCA  EQU   *                       * Close request
         AIF   (&OPT).CHEKCA           * File always open (optimized)
         TM    FDBSTAT,FDBINPUT        * Is the file open ??
         BOR   R14                     * Yes: return & continue
         NI    FDBREQ,FDBNOCA          * Reset close request
         LA    R15,006                 * Load error nr
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to caller
         AGO   .CHEKCA9
.CHEKCA  ANOP
         BR    R14                     * Optimized: return immediate
.CHEKCA9 ANOP
*
         SPACE 3
         AIF   (NOT &DBG).CHECKSD      * Checksd only in test mode
*
* CHECKSD: no checking is required. A snapdump is produced by calling
* RSNAP. No further action is required.
*
CHECKSD  EQU   *                       * Request to produce a snap-dump
         ESNAP ,                       * Call RSNAP-routine
         AIF   (&OPT).CHEKSD5
         L     R3,=AL4(RSETBASE)       * Load new base address
         L     R14,=AL4(EXIT)          * Take shortcut
         BR    R3                      * To end the program
         AGO   .CHEKSD9
.CHEKSD5 ANOP
         L     R3,=AL4(PHASE4)         * Load new base address
         L     R14,=AL4(EXIT)          * Retrieve address of exit
         BR    R14                     * Take shortcut
.CHEKSD9 ANOP
*
.CHECKSD ANOP
*
         SPACE 3
*
* CHECKXX: routine forces an error since the requested function
* is not known or not supported.
*
CHECKXX  EQU   *                       * Invalid function-code in parm
         LA    R15,027                 * Load error number
         L     R14,=AL4(EXIT)          * Get fast exit address
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to exit
*
         SPACE 3
*
CHECKCLC CLC   FDBLKEY(0),0(R8)        * Comp last key with key in parm
CHECKCLK CLC   UAKEY(0),0(R8)          * Compare keys in parameter
CHECKCLZ CLC   UAKEY(0),=&MAXKEY.C'0'  * Version record has key zero
*
CHECKTRT TRT   UAKEY(0),0(R10)         * Check that key is numeric
*
CHECKMV1 MVC   FDBXKEY(0),UAKEY        * Save key for read operation
CHECKMV2 MVC   UAKEY(0),0(R8)          * Cpy key of current rec to parm
CHECKMV3 MVC   UAKEY(0),FDBXKEY        * Restore key for read operation
*
         SPACE 3
*
         DROP  R3                      * Drop base register for phase 2
FASE2END EQU   *
*
         EJECT
         USING PHASE3,R3               * And reestablish addressability
PHASE3   EQU   *
*
* The FDBREQ field of all FDBs have now been set.
* Now we must process the FDBs one by one according to their request
* bit settings. Thus all requested I/O handlers shall be executed.
* For asynchronous processing to be effective, it is essential that
* as many requests overlap as possible. This is achieved by looping
* through all FDBs for each possible asynchronous request. Thus the
* requested files will be handled more in parallel, especially with
* combined opcodes: SN, WN, DN, and get sequential with implied open.
*
* Remarks on optimized coding:
* Since the capability to handle more than one file (FDB) at a time
* is currently not being used, we need to loop through the FDBs only
* once. Therefore the repeated loop-logic is skipped when optimizing.
* While the opcodes WN and DN are not being used (yet), the order
* of handling the request bits can be changed so that a read-request
* is recognized earlier. Thus a few unsuccessful compares can be
* avoided for each read request. Additionally, after executing a
* request that cannot be followed by another (combined) request
* we skip to the end of phase3 at once.
*
         LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOP3    L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * If it is zero, we're through
         BZ    LOOP3EX                 * If no next FDB, then exit loop
         CLI   FDBREQ,FDBNOREQ         * Anything to do for this file ?
         BE    LOOP3                   * No: try next FDB
*
* If an insert is not requested while the RPL is still in insert
* status, then the RPL must be reset to normal
*
         TM    FDBSTAT,FDBRPLIR        * Is RPL in insert mode??
         BNO   LOOP3E                  * No: skip resetting the RPL
         TM    FDBREQ,FDBINSRT         * Is insert requested ??
         BO    LOOP3E                  * Yes: leave the RPL as it is
         L     R2,FDBRPL               * Retrieve RPL-address
         LA    R6,FDBREC               * Address of record in buffer
         MODCB RPL=(R2),               * Reset current RPL from insert *
               AREA=(S,0(R6)),         *  specify the correct data area*
               OPTCD=(UPD,LOC),        *  updating, locate mode        *
               MF=(G,UAWORKAR,MODCNILV) * use UAWORKAR to build plist
         LTR   R15,R15                 * Modcb was ok ??
         BZ    LOOP3D                  * Yes: skip error
         ST    R15,UAVSAMRC            * Save retcode for error handler
         LA    R15,063                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     LOOP3E                  * Skip resetting the RPL-status
*
LOOP3D   NI    FDBSTAT,FDBRPLNI        * Reset RPL-status to non-insert
*
         SPACE 3
*
LOOP3E   EQU   *
*
* Open is to be executed first, because it may have been implied by
* another request, which can be executed only after opening.
*
         TM    FDBREQ,FDBOPEN          * File is to be opened ??
         BNO   LOOP3SK                 * No: skip open routine
         BAS   R14,ROP                 * Execute open routine
*
* Skip is to be executed after open (which may have been implied by
* a skip request), since a sequential open forces a skip request.
* Moreover skip should be executed before read, since open (and
* therefore skip) may have been implied by a read sequential request.
* Furthermore skip should be executed first, or it shall be impossible
* to support a combined skip-then-read request.
*
         PRINT GEN
         GBLC  &TARGET                 * Target of branch instructions
&TARGET  SETC  'LOOP3'                 * Normal process: loop thru FDBs
         AIF   (NOT &OPT).LOOP3SK      * When optimizing, then
&TARGET  SETC  'LOOPRXT'               * go test read-request
.LOOP3SK ANOP
*
LOOP3SK  TM    FDBREQ,FDBSKIP          * Skip to specified key ??
         BNO   &TARGET                 * No: skip skip routine
         BAS   R14,RSK                 * Execute skip routine
         B     &TARGET                 * Check next FDB
*
LOOP3EX  EQU   *
*
         SPACE 3
*
* Write is to be executed before read, or it will be impossible to
* support a combined write-then-read request.
*
&TARGET  SETC  'LOOPWX'                * Normal process: loop thru FDBs
         AIF   (NOT &OPT).LOOPWX       * When optimizing, then
&TARGET  SETC  'LOOPDRT'               * go test for delete-request
         AGO   .LOOPWXT                * and omit FDB-loop logic
.LOOPWX  ANOP
*
         LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOPWX   L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * If it is zero, we're through
         BZ    LOOPWXEX                * If no next FDB, then exit loop
*
.LOOPWXT ANOP
LOOPWXT  TM    FDBREQ,FDBWRITE         * Write record specified ??
         BNO   &TARGET                 * No: skip write routine
         BAS   R14,RWX                 * Execute write routine
*
         AIF   (NOT &OPT).LOOPWXU      * When optimizing:
         B     LOOPCAEX                * Skip remainder of phase3
*
.LOOPWXU AIF   (&OPT).LOOPWXX          * Opcode WN only in test mode
*
* If the write operation is to be followed by a read, then the saved
* key is to be restored into the parameter area.
*
         TM    FDBREQ,FDBREAD          * Read is to follow this write??
         BNO   &TARGET                 * No: continue with next FDB
         TM    FDBSTAT,FDBACRND        * Access is random ??
         BNO   &TARGET                 * No: key not required
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain key length
         BCTR  R7,R0                   * Decrement length by 1 for MVC
         EX    R7,LOOPWXMV             * and restore saved key
         B     &TARGET                 * Go check next FDB
*
LOOPWXMV MVC   UAKEY(0),FDBXKEY        * Restore extra key into parm
*
.LOOPWXX ANOP
LOOPWXEX EQU   *
*
         SPACE 3
*
* Delete is to be executed before read, or it will be impossible to
* support a combined delete-then-read request.
*
&TARGET  SETC  'LOOPDR'                * Normal process: loop thru FDBs
         AIF   (NOT &OPT).LOOPDR       * When optimizing, then
&TARGET  SETC  'LOOPIRT'               * go test for insert-request
         AGO   .LOOPDRT                * and omit FDB-loop logic
.LOOPDR  ANOP
*
         LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOPDR   L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * If it is zero, we're through
         BZ    LOOPDREX                * If no next FDB, then exit loop
*
.LOOPDRT ANOP
LOOPDRT  TM    FDBREQ,FDBDEL           * Delete record specified ??
         BNO   &TARGET                 * No: skip delete routine
         BAS   R14,RDR                 * Execute delete routine
*
         AIF   (NOT &OPT).LOOPDRU      * When optimizing:
         B     LOOPCAEX                * Proceed to end of phase3
.LOOPDRU AIF   (&OPT).LOOPDRX          * DN only allowed in test mode
*
* If the delete operation is to be followed by a read, then the saved
* key is to be restored into the parameter area.
*
         TM    FDBREQ,FDBREAD          * Read is to follow this write??
         BNO   LOOPDR                  * No: continue with next FDB
         TM    FDBSTAT,FDBACRND        * Access is random ??
         BNO   LOOPDR                  * No: key not required
         XR    R7,R7                   * Clear register
         IC    R7,FDBKEYLV             * to contain key length
         BCTR  R7,R0                   * Decrement length by 1 for MVC
         EX    R7,LOOPDRMV             * and restore saved key
         B     LOOPDR                  * Go check next FDB
*
LOOPDRMV MVC   UAKEY(0),FDBXKEY        * Restore extra key into parm
*
.LOOPDRX ANOP
LOOPDREX EQU   *
*
         SPACE 3
*
* Read is to be executed after open, skip, write, and delete since
* these requests may be either implied or they need to be supported
* as a combined operation.
*
&TARGET  SETC  'LOOPRX'                * Normal process: loop thru FDBs
         AIF   (NOT &OPT).LOOPRX       * When optimizing, then
&TARGET  SETC  'LOOPWXT'               * go test for write-request
         AGO   .LOOPRXT                * and omit FDB-loop logic
.LOOPRX  ANOP
*
         LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOPRX   L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * If it is zero, we're through
         BZ    LOOPRXEX                * If no next FDB, then exit loop
*
.LOOPRXT ANOP
LOOPRXT  TM    FDBREQ,FDBREAD          * Read record specified ??
         BNO   &TARGET                 * No: skip read routine
         BAS   R14,RRX                 * Execute read routine
*
         AIF   (&OPT).LOOPRXU          * When optimizing: drop-through
         B     &TARGET                 * And go check next FDB
.LOOPRXU ANOP  ,                       * To check for re-read request
*
* If a read request could not be satisfied from the current data buffer
* then the request bit is set for restart read. A skip request has been
* started: thus a skip will occur. Subsequently the read will be
* satisfiable.
*
LOOPRXEX EQU   *
&TARGET  SETC  'LOOPRYEX'              * Normal process: loop thru FDBs
         AIF   (NOT &OPT).LOOPRY       * When optimizing, then
&TARGET  SETC  'LOOPCAEX'              * no more requests to be handled
.LOOPRY  ANOP
*
         TM    UASTAT,UARQREAD         * Restart read processing ??
         BNO   &TARGET                 * No: carry on
         NI    UASTAT,UARQNORX         * Reset restart request
*
         AIF   (&OPT).LOOPRYX
         LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOPRY   L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * If it is zero, we're through
         BZ    LOOPRYEX                * If no next FDB, then exit loop
         TM    FDBREQ,FDBREAD2         * Read record specified ??
         BNO   LOOPRY                  * No: skip read routine
.LOOPRYX NI    FDBREQ,FDBNOIR          * Reset reread (=insert) request
         BAS   R14,RRX                 * And re-execute read routine
*
&TARGET  SETC  'LOOPRY'                * Normal process: loop thru FDBs
         AIF   (NOT &OPT).LOOPRZ       * When optimizing, then
&TARGET  SETC  'LOOPCAEX'              * there are no more requests
.LOOPRZ  ANOP
         B     &TARGET                 * And go check next FDB
*
LOOPRYEX EQU   *
*
         SPACE 3
*
* Insert is currently not combined with any other request, so we
* just leave it trailing behind, as the last asynchronous request.
*
&TARGET  SETC  'LOOPIR'                * Normal process: loop thru FDBs
         AIF   (NOT &OPT).LOOPIR       * When optimizing, then
&TARGET  SETC  'LOOPCAT'               * go test for close-request
         AGO   .LOOPIRT                * and omit FDB-loop logic
.LOOPIR  ANOP
*
         LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOPIR   L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * If it is zero, we're through
         BZ    LOOPIREX                * If no next FDB, then exit loop
*
.LOOPIRT ANOP   **!!
LOOPIRT  TM    FDBREQ,FDBINSRT         * Insert record specified ??
         BNO   &TARGET                 * No: skip insert routine
         BAS   R14,RIR                 * Execute insert routine
*
         AIF   (NOT &OPT).LOOPIRU      * When optimizing:
&TARGET  SETC  'LOOPCAEX'              * Skip remainder of phase3
.LOOPIRU B     &TARGET                 * And go check next FDB
*
LOOPIREX EQU   *
*
         SPACE 3
*
* Finally close requests need to be executed if requested.
* Close is a synchronous request.
*
&TARGET  SETC  'LOOPCA'                * Normal process: loop thru FDBs
         AIF   (NOT &OPT).LOOPCA       * When optimizing, then
&TARGET  SETC  'LOOPCAEX'              * go test for insert-request
         AGO   .LOOPCAT                * and omit FDB-loop logic
.LOOPCA  ANOP
*
         LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOPCA   L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * If it is zero, we're through
         BZ    LOOPCAEX                * If no next FDB, then exit loop
*
.LOOPCAT ANOP
LOOPCAT  TM    FDBREQ,FDBCLOSE         * Close this file ??
         BNO   &TARGET                 * No: skip close routine
         BAS   R14,RCA                 * Execute close routine
*
         AIF   (&OPT).LOOPCAX
         B     &TARGET                 * And go check next FDB
.LOOPCAX ANOP
*
LOOPCAEX EQU   *
*
         PRINT &PRT                    * Set print option
*
         SPACE 3
*
* Phase 3 is done. Continue with phase 4
*
         L     R3,=AL4(PHASE4)         * Get start address of phase 4
         BR    R3                      * And go execute it
*
         EJECT
*
* ROP processes any open requests: sequential / random
*                                  input / update
*
ROP      EQU   *                       * Process open request
         ST    R14,UALV1SAV            * Save R14 level 1
*
* If any last request is still present in the FDB, it is invalidated
* by the open request, so we wipe it out.
*
         MVI   FDBLREQ,FDBNOREQ        * Blank last request issued
         MVI   FDBLKEY,X'40'           * and the associated key
         MVC   FDBLKEY+1(&MAXKEY-1),FDBLKEy * Wipe remainder of key-fld
*
* If a VSAM resource does not yet exist, go allocate one.
*
         TM    UAVRPSTA,UAVEXIST       * Has VRP been allocated ??
         BO    ROP0                    * Yes: skip allocation
         BAS   R14,RBLDVRP             * Go allocate VRP
*
* Before we allocate an ACB we must put the correct DDNAME in the FDB.
* In the location of the first blank an I or a U is to be inserted,
* depending on open for input or for update respectively.
*
ROP0     EQU   *                       * Append I/U to DDNAME
         L     R10,=AL4(SEEKSPC)       * Get addr of seek-space table
         TRT   FDBDDNAM,0(R10)         * Get addr of 1st blank in field
         BZ    ROP1                    * If no spaces, dont change name
*
* R1 now contains the address of the first blank position in the
* DDNAME. This is the address where an I or a U is to be inserted
*
         MVI   0(R1),C'I'              * Default to input processing
         TM    FDBREQ,FDBOPENU         * Open file for update ??
         BNO   ROP1                    * No: leave it with the 'I'
         MVI   0(R1),C'U'              * Use 'U' for update processing
*
* The open options input/update and sequential/random are tested and
* translated into an offset in a table that contains the addresses of
* the default ACBs for each option combination. The difference between
* LSR or private pools is reflected in the table as well.
*
ROP1     MVI   UAWORK,X'00'            * Clear to calc offset in ACBTAB
         CLI   UAPOOLNR,X'0F'          * LSR pools allocated ??
         BNH   ROP1NSR                 * Yes: stick to offset 0
         OI    UAWORK,X'10'            * No: add 16 to offset for
*                                      *            private pools
ROP1NSR  TM    FDBREQ,FDBOPENU         * Open file for update ??
         BNO   ROP1INP                 * No: stick to offset 0
         OI    UAWORK,X'08'            * Yes: add 8 to offset for updat
ROP1INP  TM    FDBREQ,FDBOPRND         * Open file random ??
         BNO   ROP1SEQ                 * No: stick to offset 0
         OI    UAWORK,X'04'            * Yes: add 4 to offset for rand.
ROP1SEQ  EQU   *
*
* The offset to be used is in the UAWORK field now.
* Before building the ACB and RPL we must allocate storage for them
*
         GETMAIN RC,                   * Conditional request for ACB   *
               SP=&SP,                 *    from our own subpool       *
               LV=IFGACBLV+IFGRPLLV    *    long enough for ACB + RPL
         LTR   R15,R15                 * Getmain was ok??
         BZ    ROP1GOTM                * No: go issue error
         OI    FDBSTAT,FDBERROR        * Indicate error status
         LA    R15,023                 * Error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     ROP99                   * Skip rest of open processing
*
ROP1GOTM ST    R1,FDBACB               * Save address of area for ACB
         LR    R7,R1                   * Copy addr where ACB is to go
         LA    R1,IFGACBLV(R1)         * Point to RPL-part of area
         ST    R1,FDBRPL               * And save address for RPL
*
         XR    R1,R1                   * Clear register
         IC    R1,UAWORK               * Get offset for ACBTAB
         L     R15,=AL4(ACBTAB)        * Get address of ACBTAB
         L     R2,0(R15,R1)            * Get addr of plist from ACBTAB
         XR    R6,R6                   * Clear register
         IC    R6,UAPOOLNR             * to contain shrpool-id
         LR    R3,R2                   * Addr of gencb plist to base
         BASR  R10,R3                  * Go build plist, retaddr in R10
         L     R3,=AL4(PHASE3)         * Restore our own base register
*                                      *    no retcode in R15 !!!!
         LA    R2,UAWORKAR             * Point to generated plist
         GENCB BLK=ACB,                * Generate the ACB              *
               MF=(E,(R2))             *    using the plist in uaworkar
         LTR   R15,R15                 * Has ACB been built ok ??
         BZ    ROP2                    * Yes: skip error handling
*
ROP1ERR  OI    FDBSTAT,FDBERROR        * Indicate error status
         ST    R15,UAVSAMRC            * Save returncode from VSAM
         LA    R15,049                 * Load error number and
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     ROP99                   * Skip remainder of open process
*
* The ACB has been built successfully,
* now generate a default RPL for this ACB.
*
* The index for the table with addresses of default RPLs is equal to
* the index used with the ACBs, with the exclusion of the difference
* between LSR and private pools, so we can simply reuse the same byte
* after wiping the LSR/private bit.
*
ROP2     EQU   *
         L     R9,FDBRPL               * Retrieve address for RPL
         NI    UAWORK,X'0F'            * Remove superfluous index bits
         XR    R1,R1                   * Clear register
         IC    R1,UAWORK               * Get offset for RPLTAB
         L     R15,=AL4(RPLTAB)        * Get address of RPLTAB
         L     R2,0(R15,R1)            * Get addr of plist from RPLTAB
         L     R7,FDBACB               * Reload addr of ACB to be used
         LH    R8,FDBRECLV             * Get record length for RPL
         XR    R6,R6                   * Clear register
         IC    R6,FDBKEYLV             * to contain key length
         LR    R3,R2                   * Addr of gencb plist to base
         BASR  R10,R3                  * Go build plist, retaddr in R10
         L     R3,=AL4(PHASE3)         * Restore our own base register
*                                      *    no retcode in R15 !!!!
         LA    R2,UAWORKAR             * Point to generated plist
         GENCB BLK=RPL,                * Generate the RPL              *
               MF=(E,(R2))             *    using the plist in UAWORKAR
         LTR   R15,R15                 * Has RPL been built ok ??
         BZ    ROP3                    * Yes: skip error handling
*
ROP2ERR  OI    FDBSTAT,FDBERROR        * Indicate error status
         ST    R15,UAVSAMRC            * Save VSAM's retcd in USERAREA
         LA    R15,050                 * Error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     ROP99                   * Skip rest of open processing
*
* The RPL has been built successfully, so we save its address and
* length in the FDB. Then we can try to open the file.
* Increment IO-call counter, then open file (synchronous I/O)
*
ROP3     EQU   *
         AIF   (&OPT).ROP9
         L     R2,UAIOCNT              * Load total I/O-count
         LA    R2,1(R2)                * Increment by one
         ST    R2,UAIOCNT              * And store updated value
*
.ROP9    ANOP
         L     R2,=AL4(VSAMOPEN)       * Get address of list-form open
         MVC   UAWORKAR(VSAMOPLV),0(R2) * copy to work-area
         LA    R9,UAWORKAR             * And point to modifiable copy
         L     R2,FDBACB               * Reload address of ACB
         OPEN  ((R2)),                 * Open the ACB just generated   *
               MF=(E,(R9))             *    using the copy of the plist
         LTR   R15,R15                 * Was open successfull ??
         BZ    ROP9                    * Yes: skip error handling
         OI    FDBSTAT,FDBERROR        * Indicate error status
         ST    R15,UAVSAMRC            * Save returncode for dumping
         LA    R15,051                 * Error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     ROP99                   * Skip remainder of open process
*
* The file has been opened successfully. Now set the FDBSTAT bits
* to reflect the current status.
*
ROP9     EQU   *
         OI    FDBSTAT,FDBINPUT        * Indicate file is open
         TM    FDBREQ,FDBOPENU         * Open for update ??
         BNO   ROP9INP                 * No: skip setting update bit
         OI    FDBSTAT,FDBUPDAT        * Yes: set update bit
*
ROP9INP  TM    FDBREQ,FDBOPRND         * Open for random access ??
         BNO   ROP99                   * No: skip setting random bit
         OI    FDBSTAT,FDBACRND        * Yes: set random bit
*
* The open request uses the request bit associated with a close request
* to distinguish between random and sequential open requests. Since the
* open request has been processed now, the random/sequential option bit
* must be reset. Otherwise it will be interpreted as a close request
* and the file would be closed in the very same call as it was opened.
*
ROP99    EQU   *
         NI    FDBREQ,FDBNOCA          * Reset random/close request
         L     R14,UALV1SAV            * Reload return address
         BR    R14                     * And return to caller
*
         EJECT
*
* RSK processes any skip requests: sequential
*                                  input / update
*
RSK      EQU   *                       * Process skip request
         ST    R14,UALV1SAV            * Save R14 level 1
*
* A skip request cannot be preceded by an asynchronous request.
* Therefore, if the ECB is in use, we have run into an error.
*
         L     R0,FDBECB               * Get old ECB
         LTR   R0,R0                   * Check that the ECB is free
         BZ    RSK10                   * If it is zero, skip error
         LA    R15,011                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         ST    R3,UABASSAV             * Save current base register
         L     R3,=AL4(RCHECK)         * Get address of wait routine
         BASR  R14,R3                  * And go wait for I/O-completion
*
* If the file is in error status, no processing can take place
*
RSK10    TM    FDBSTAT,FDBERROR        * Check for problems
         BO    RSK99                   * File is in error: abort skip
*
* For skip processing, use as many numbers as are given in key field
* of the parameter, with a maximum of the actual key length and a
* minimum of four numbers.
*
         L     R10,=AL4(NUMTAB)        * Get addr of TRT-table for key
         XR    R1,R1                   * Clear register
         IC    R1,FDBKEYLV             * Get length of key
         BCTR  R1,R0                   * Decrement length by 1 for TRT
         EX    R1,RSKTRT               * Find first nonnumeric byte
         BZ    RSK11                   * If all numbers use full length
*
* R1 now contains the address of the first non-numeric position in the
* key. This is the address +1 of the last byte to be used.
*
         LA    R2,UAKEY                * Get start address of key
         SR    R1,R2                   * Difference = nr of used bytes
         LR    R2,R1                   * And put key len in right reg.
         B     RSK12                   * Skip default length setting
*
RSK11    XR    R2,R2                   * Clear register
         IC    R2,FDBKEYLV             * Pick up total key length
*
* R2 now contains the number of key-bytes to be used in this skip
* operation. Before skipping, the RPL must be changed to contain the
* required (generic or full) key length.
*
RSK12    EQU   *
         LR    R10,R2                  * Load keylen-value to be used
         L     R2,FDBRPL               * Retrieve address of RPL
         CLM   R10,1,FDBSKKLV          * Is skip-key length ok ??
         BE    RSK20                   * Yes: no modcb required.
         MODCB RPL=(R2),               * Modify current RPL to reflect *
               KEYLEN=(S,0(R10)),      *    correct key length         *
               MF=(G,UAWORKAR,MODCBKLV) * use UAWORKAR to build plist
         LTR   R15,R15                 * Modcb was ok ??
         BZ    RSK19                   * Yes: proceed to point
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,020                 * Indicate error code
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RSK20                   * And try to position
*
RSK19    EQU   *                       * Modcb was ok.
         STC   R10,FDBSKKLV            * Save current skip key-length
*
* Now request VSAM to start the skip, which is executed asynchronously.
*
RSK20    EQU   *
         POINT RPL=(R2)                * Execute asynchronous point
         LTR   R15,R15                 * Point started correctly ??
         BZ    RSK90                   * Yes: complete the request
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,052                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RSK99                   * Skip remainder of skip-process
*
* Before returning to the mainline, we must set an unused bit in the
* ECB because the ECB is used to check whether a check is required
* before issuing another VSAM request or returning to the caller.
* Normally the requested VSAM routine should set the busy bit in the
* ECB, but sometimes VSAM is too slow and a check is skipped where it
* should not have been skipped. Therefore we must set a bit in the ECB
* ourselves.
*
RSK90    EQU   *
         OI    FDBECB,X'01'            * Indicate I/O is in progress
         NI    FDBSTAT,FDBNOEOF        * Point should reset eof-status
*
RSK99    L     R14,UALV1SAV            * Reload return address
         BR    R14                     * And return to caller
*
         SPACE 3
*
RSKTRT   TRT   UAKEY(0),0(R10)         * Check nr of numeric characters
*                                      *       in key
         EJECT
*
* RRX processes any read requests: sequential / random
*                                  input / update
*
RRX      EQU   *                       * Process read request
         ST    R14,UALV1SAV            * Save R14 level 1
*
* If the ECB is in use, some operation must have been requested,
* which must finish before we can proceed.
*
         L     R1,FDBECB               * Load current contents of ECB
         LTR   R1,R1                   * Check that ECB is free (zero)
         BZ    RRX20                   * Yes: go start read
*
* Another request is being processed by VSAM. If this situation is
* unexpected, issue a warning. Before proceeding wait for the I/O
* in progress to complete.
*
RRX10    EQU   *
         TM    FDBREQ,FDBSKIP          * Was a skip requested ??
         BO    RRX18                   * Yes: skip the warning message
         AIF   (NOT &OPT).RRX18
         TM    FDBREQ,FDBWRITE         * Was a write requested ??
         BO    RRX18                   * Yes: skip the warning message
         TM    FDBREQ,FDBDEL           * Was a delete requested ??
         BO    RRX18                   * Yes: skip the warning message
*
.RRX18   ANOP
         LA    R15,012                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error routine
         BASR  R14,R3                  * Execute it, then return here
*
RRX18    EQU   *
         ST    R3,UABASSAV             * Save current base register
         L     R3,=AL4(RCHECK)         * Get address of wait routine
         BASR  R14,R3                  * Go wait for I/O completion
*
* If an error condition is raised, no reading should be done.
*
RRX20    TM    FDBSTAT,FDBERROR        * Check for problems
         BO    RRX99                   * On error: quit
*
* For random read (RR) a get must be issued to retrieve the record.
* For sequential read (RS) the next record is to be made current.
* If there's no next record in the buffer, then a skip
* must be enforced to retrieve the next control interval.
*
         TM    FDBSTAT,FDBACRND        * Access is random ??
         BO    RRX50                   * Get a record
*
* Access is sequential, check on eof-condition
*
         TM    FDBSTAT,FDBEOF          * End-of-file ??
         BNO   RRX30                   * No: go find next record in buf
         NI    FDBREQ,FDBNORX          * Reset read request bit
         TM    FDBREQ,FDBSKIP          * Skip was requested also ??
         BO    RRX99                   * Yes: skip caused eof !!
         LA    R15,038                 * Set error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Issue warning, return here
         B     RRX99                   * And skip issuing the read
*
* If the current record (according to FDB) is not valid, then the next
* record to be read is the first record in the current control interval
* otherwise the next record is to be found by incrementing the record
* pointer with the record length. If the next record lies beyond the
* current buffer, then a skip is to be forced.
*
RRX30    EQU   *                       * Locate next sequential record
         L     R2,FDBREC               * Get address of current record
         LTR   R6,R2                   * Is it valid ??
         BNE   RRX32                   * No: add record length
*                                      * Yes: use first record in buf
         MVC   FDBREC,FDBSBUF          * Copy addr of first rec in buf
         B     RRX99                   * And we're done
*
RRX32    EQU   *                       * Addr of old record saved in R6
         AH    R2,FDBRECLV             * Get addr of next record in buf
         ST    R2,FDBREC               * Store address of next record
         C     R2,FDBEBUF              * New address < end-of-buffer
         BL    RRX99                   * Yes: new record addr is valid
*
* Address of new record lies beyond end-of-buffer: force a skip
* to the next control-interval.
*
         MVC   UAKEY,0(R6)             * Move key from buf to USERAREA
         XR    R1,R1                   * Clear register
         IC    R1,FDBKEYLV             * to contain key length
         BCTR  R1,R0                   * Minus one to address last byte
         XR    R2,R2                   * Clear register
         IC    R2,UAKEY(R1)            * Get last byte of key
         LA    R2,1(R2)                * Increment last byte of key
         STC   R2,UAKEY(R1)            * Store new last byte of key
         LA    R1,1(R1)                * Reset reg to full key length
*
* The UAKEY-field now contains the key of the last record in the
* current buffer + binary 1. Since the search key is the lowest
* possible key in the next control-interval the subsequent point
* will retrieve the next control-interval.
*
         L     R2,FDBRPL               * Retrieve address of RPL
         CLM   R1,1,FDBSKKLV           * Skip-key-length is ok ??
         BE    RRX35                   * Yes: no modcb required
         LR    R10,R1                  * Load keylen-value to be used
         MODCB RPL=(R2),               * Modify current RPL to         *
               KEYLEN=(S,0(R10)),      *    correct key length         *
               MF=(G,UAWORKAR)         *    use UAWORKAR to build plist
*
         LTR   R15,R15                 * Modcb was ok ??
         BZ    RRX34                   * Yes: proceed to point
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,020                 * Indicate error code
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         NI    FDBREQ,FDBNORX          * Reset read request bit
         B     RRX99                   * Exit read routine
*
RRX34    EQU   *                       * Modcb was ok
         STC   R10,FDBSKKLV            * Save skip key-length
*
* Now request VSAM to start the skip, which is executed asynchronously.
*
RRX35    EQU   *
         POINT RPL=(R2)                * Execute asynchronous point
         LTR   R15,R15                 * Point started correctly ??
         BZ    RRX40                   * Yes: complete the request
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,052                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         NI    FDBREQ,FDBNORX          * Reset read request
         B     RRX99                   * Skip remainder of read-process
*
RRX40    EQU   *
         OI    FDBREQ,FDBREAD2         * Request re-read and indicate
*                                      *         skip-request
         OI    UASTAT,UARQREAD         * Signal restart read request
         B     RRX90                   * Postpone further reading till
*                                      *    RRX is executed again
*
* A get will have to be issued, so that VSAM may locate the correct
* control-interval.
*
RRX50    EQU   *
         L     R2,FDBRPL               * Retrieve address of RPL
         GET   RPL=(R2)                * Ask VSAM to start a read
         LTR   R15,R15                 * Has I/O been started ??
         BZ    RRX90                   * Yes: skip error handling
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,053                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RRX99                   * Skip remainder of read-process
*
RRX90    EQU   *                       * Async. request is accepted
         OI    FDBECB,X'01'            * Indicate I/O is in progress
*
RRX99    EQU   *
         L     R14,UALV1SAV            * Reload return address
         BR    R14                     * And return to caller
*
         SPACE 3
*
RRXCLC   CLC   UAKEY(0),0(R2)          * Compare requested key with
*                                      *            record key
         EJECT
*
* RWX processes any write requests: sequential / random
*                                           update
*
RWX      EQU   *                       * Process write request
         ST    R14,UALV1SAV            * Save R14 level 1
*
* If the ECB is in use, we have run into an error, since no
* asynchronous I/O-requests may precede a write request.
*
         L     R0,FDBECB               * Get old ECB
         LTR   R0,R0                   * Check that the ECB is free
         BZ    RWX10                   * If it is zero, skip error
         LA    R15,013                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         ST    R3,UABASSAV             * Save current base register
         L     R3,=AL4(RCHECK)         * Get address of wait routine
         BASR  R14,R3                  * And go wait for I/O-completion
*
* If an error condition is raised for the file, no I/O must be started.
*
RWX10    TM    FDBSTAT,FDBERROR        * Check for problems
         BO    RWX99                   * On error: quit
*
* Compare old and new keys to make sure that the key will not be
* changed by the update request.
*
         XR    R1,R1                   * Clear register
         IC    R1,FDBKEYLV             * Get key length
         LA    R8,LNSKEY(R1)           * Load address of data area
         BCTR  R1,R0                   * Decrement to length-1 for CLC
         LA    R2,FDBLKEY              * Get key-addr of previous read
         EX    R1,RWXCLC               * Compare old and new key
         BE    RWX20                   * If equal skip error handling
*
RWXERR30 LA    R15,043                 * Load error code
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RWX99                   * Skip remainder of write-logic
*
RWX20    EQU   *
         L     R2,FDBREC               * Get addr of record within buf
         EX    R1,RWXCLC               * Compare buffer-key and new key
         BNE   RWXERR30                * If not equal then abend
*
* The key has not changed. Assemble the record from the data in the
* parameter in a work area prior to the actual update.
*
         BAS   R14,RASM                * Go assemble new record
*
* Since no put is used to update the record, we must tell VSAM that
* the contents of the buffer have changed by marking the buffer for
* output. Thus the buffer will be rewritten, before its slot will be
* used to accommodate another buffer.
*
         TM    FDBSTAT,FDBBUFUP        * Buffer marked for output ?
         BO    RWX99                   * Yes: no mrkbfr required
         L     R2,FDBRPL               * Get address of RPL
         MRKBFR MARK=OUT,              * Mark buffer for output        *
               RPL=(R2)                *    for current RPL
         LTR   R15,R15                 * Mrkbfr was ok ??
         BZ    RWX90                   * If zero, conclude write logic
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,059                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RWX99                   * Skip remainder of write-logic
*
RWX90    EQU   *                       * Asynchronous request accepted
         OI    FDBECB,X'01'            * Indicate I/O is in progress
         OI    FDBSTAT,FDBBUFUP        * Indicate buffer marked
*                                      *        for output
RWX99    EQU   *
         L     R14,UALV1SAV            * Reload return address
         BR    R14                     * And return to caller
*
         SPACE 3
*
RWXCLC   CLC   0(0,R2),0(R8)           * Compare read and write keys
*
         EJECT
*
* RIR processes any insert requests: sequential / random
*                                            update
*
RIR      EQU   *                       * Process insert request
         ST    R14,UALV1SAV            * Save R14 level 1
*
* Since no other requests may accompany an insert request it is an
* error if the ECB is currently in use.
*
         L     R0,FDBECB               * Get old ECB
         LTR   R0,R0                   * Check that the ECB is free
         BZ    RIR10                   * If it is zero, skip error
         LA    R15,014                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         ST    R3,UABASSAV             * Save current base register
         L     R3,=AL4(RCHECK)         * Get address of wait routine
         BASR  R14,R3                  * And go wait for I/O-completion
*
* If the file is in error status, no I/O should be requested.
*
RIR10    TM    FDBSTAT,FDBERROR        * Check for problems
         BO    RIR99                   * On error: quit
*
* First we must rebuild the record from the parameter in a work area
*
         BAS   R14,RASM                * Assemble complete record
         TM    FDBSTAT,FDBRPLIR        * Has RPL been reset to NUP ??
         BO    RIR20                   * Yes: skip changing UPD to NUP
*
* RPL is not in insert status, so it must be changed before we can
* request VSAM to insert this record into the file.
*
         L     R2,FDBRPL               * Get address of RPL
         L     R6,FDBWAREA             * Get addr of record in workarea
         LH    R7,FDBRECLV             * Get length of record
         MODCB RPL=(R2),               * Modify RPL to insert mode     *
               AREA=(S,0(R6)),         *     specifying record area    *
               AREALEN=(S,0(R7)),      *     and record length         *
               OPTCD=(NUP,MVE),        *     non-update move mode      *
               MF=(G,UAWORKAR,MODCBILV) *    build plist in UAWORKAR
         LTR   R15,R15                 * RPL changed without error ?
         BZ    RIR19                   * Yes: skip error
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,061                 * Set error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RIR99                   * Skip remainder of insert-logic
*
RIR19    EQU   *
         OI    FDBSTAT,FDBRPLIR        * Indicate RPL status
*
* The RPL is in insert status right now. If we ask vsam to put the
* record, VSAM will try to insert it. Splitting control-intervals
* and control-areas, when not enough free space is available will be
* taken care off by VSAM.
*
RIR20    EQU   *
         L     R2,FDBRPL               * Get plist-address
         PUT   RPL=(R2)                * Have VSAM insert new record
         LTR   R15,R15                 * Request accepted by VSAM ?
         BZ    RIR90                   * Yes: skip error handling
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,054                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RIR99                   * Skip remainder of insert-logic
*
RIR90    EQU   *                       * Asynchronous request accepted
         OI    FDBECB,X'01'            * Indicate I/O is in progress
*
RIR99    L     R14,UALV1SAV            * Reload return address
         BR    R14                     * And return to caller
*
         EJECT
*
* RDR processes any delete requests: sequential / random
*                                            update
*
RDR      EQU   *                       * Process delete request
         ST    R14,UALV1SAV            * Save R14 level 1
*
* No other I/Os are allowed to accompany a delete request. Therefore
* if the ECB is in use, we have run into an error.
*
         L     R0,FDBECB               * Get old ECB
         LTR   R0,R0                   * Check that the ECB is free
         BZ    RDR10                   * If it is zero, skip error
         LA    R15,015                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         ST    R3,UABASSAV             * Save current base register
         L     R3,=AL4(RCHECK)         * Get address of wait routine
         BASR  R14,R3                  * And go wait for I/O-completion
*
* No delete requests should be initiated if an error condition exists.
*
RDR10    TM    FDBSTAT,FDBERROR        * Check for problems
         BO    RDR99                   * On error: quit
*
* Compare old and new key values to prevent inadvertent deletion of
* the wrong record.
*
         XR    R1,R1                   * Clear register
         IC    R1,FDBKEYLV             * Get key length
         LA    R8,LNSKEY(R1)           * Load address of data area
         BCTR  R1,R0                   * Decrement to length-1 for CLC
         LA    R2,FDBLKEY              * Get key-addr of previous read
         EX    R1,RDRCLC               * Compare old and new key
         BE    RDR20                   * If equal skip error handling
*
RDRERR29 LA    R15,044                 * Load error code
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RDR99                   * Skip remainder of delete-logic
*
RDR20    EQU   *
         L     R2,FDBREC               * Get addr of record in buffer
         EX    R1,RDRCLC               * Compare buffer-key and new key
         BNE   RDRERR29                * If not equal then abend
*
* Since VSAM assumes move mode for delete requests, we must rebuild
* the record in a work area before we can issue a delete request.
*
         BAS   R14,RASM                * Assemble complete record
*
* Change the RPL to move mode, and specify where our record buffer
* is located.
*
         L     R2,FDBRPL               * Get address of RPL
         L     R6,FDBWAREA             * Get addr of record in workarea
         LH    R7,FDBRECLV             * Get length of record
         MODCB RPL=(R2),               * Modify RPL to delete mode     *
               AREA=(S,0(R6)),         *     specifying record area    *
               AREALEN=(S,0(R7)),      *     and record length         *
               OPTCD=(MVE),            *     changing to move mode     *
               MF=(G,UAWORKAR,MODCBDLV) *    build plist in UAWORKAR
         LTR   R15,R15                 * RPL changed without error ?
         BZ    RDR29                   * Yes: skip error
         ST    R15,UAVSAMRC            * Save retcode for error handler
         LA    R15,062                 * Set error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RDR99                   * And abort delete-processing
*
RDR29    EQU   *
         OI    FDBSTAT,FDBRPLDR        * Indicate RPL status
*
* Now that the RPL is in delete status we can start the request to
* remove the record from the file.
*
         L     R2,FDBRPL               * Get address of RPL
         ERASE RPL=(R2)                * Delete this record
         LTR   R15,R15                 * Request issued to VSAM ??
         BZ    RDR90                   * Yes, we're done; skip error
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,055                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RDR99                   * Skip remainder of delete-logic
*
RDR90    EQU   *                       * Asynchronous request accepted
         OI    FDBECB,X'01'            * Indicate I/O is in progress
*
RDR99    EQU   *
         L     R14,UALV1SAV            * Reload return address
         BR    R14                     * And return to caller
*
         SPACE 3
*
RDRCLC   CLC   0(0,R2),0(R8)           * Compare read and write keys
*
         EJECT
*
* RCA processes any close request: sequential / random
*                                  input / update
*
RCA      EQU   *                       * Process close request
         ST    R14,UALV1SAV            * Save R14 level 1
         AIF   (NOT &DBG).RCA08        * Warning in test mode only
*
* If the last request was not an update for record with key all zeroes
* then the file version record has not been updated.
*
         TM    FDBSTAT,FDBUPDAT        * File open in update mode ??
         BNO   RCA08                   * No: skip this check
         TM    FDBLREQ,FDBWRITE        * Last request was a write ??
         BNO   RCA05                   * No: issue warning
         XR    R1,R1                   * Clear register
         IC    R1,FDBKEYLV             * To contain key length
         BCTR  R1,R0                   * Decrement by one for CLC
         EX    R1,RCACLC               * Key all zeroes ??
         BE    RCA08                   * Yes: ok
*
RCA05    EQU   *
         LA    R15,021                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
.RCA08   ANOP
*
* No error checking is done; if the file is in error it should be
* closed. However, if the ECB is in use, we have run into a rather
* serious error, because no other I/Os should accompany a close req
*
RCA08    L     R0,FDBECB               * Get old ECB
         LTR   R0,R0                   * Check that the ECB is free
         BZ    RCA10                   * If it is zero, skip error
         LA    R15,016                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         ST    R3,UABASSAV             * Save current base register
         L     R3,=AL4(RCHECK)         * Get address of wait routine
         BASR  R14,R3                  * And go wait for I/O-completion
*
* Increment IO-call counter, then close file (synchronous I/O)
*
RCA10    EQU   *
         AIF   (&OPT).RCA10
         L     R2,UAIOCNT              * Load total io-count
         LA    R2,1(R2)                * Increment by one
         ST    R2,UAIOCNT              * And store updated value
*
.RCA10   ANOP
         L     R2,=AL4(CLOSE)          * Point to list-form of close
         MVC   UAWORKAR(CLOSELV),0(R2) * Copy close-plist to work-area
         LA    R9,UAWORKAR             * Point to this modifiable copy
         L     R2,FDBACB               * Retrieve ACB-address
         CLOSE ((R2)),                 * Close the file                *
               MF=(E,(R9))             *    using copy of default plist
         LTR   R15,R15                 * Close was ok ??
         BZ    RCA19                   * Yes: free storage areas
         OI    FDBSTAT,FDBERROR        * Set error-status for this file
         LA    R15,060                 * Indicate error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RCA90                   * And skip remainder of close
*
RCA19    EQU   *
         NI    FDBSTAT,X'00'           * Reset status to closed
*
* Now that the file has been closed, the storage areas for ACB, RPL,
* and workarea should be returned to the system, because they were
* allocated dynamically.
*
RCA20    L     R2,FDBWAREA             * Retrieve address of workarea
         LTR   R2,R2                   * Does a workarea exist ??
         BZ    RCA30                   * No: skip freeing workarea
         LH    R6,FDBRECLV             * Retrieve length of area
         FREEMAIN RC,                  * Conditional freemain request  *
               SP=&SP,                 *    from our own subpool       *
               LV=(R6),                *    specifying length of area  *
               A=(R2)                  *    and address of workarea
         LTR   R15,R15                 * Freemain was ok??
         BZ    RCA29                   * Yes: continue
         LA    R15,024                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         XR    R15,R15                 * Simulate correct freemain
*
RCA29    EQU   *
         ST    R15,FDBWAREA            * Reset address-field in FDB
*
RCA30    EQU   *                       * Remove ACB and RPL
         L     R2,FDBACB               * Retrieve address of ACB
         LTR   R2,R2                   * Does an ACB exist ??
         BZ    RCA50                   * No: skip freeing ACB/RPL-area
         FREEMAIN RC,                  * Conditionally free ACB/RPL    *
               SP=&SP,                 *    from our private subpool   *
               LV=IFGACBLV+IFGRPLLV,   *    specifying its length      *
               A=(R2)                  *    and address
         LTR   R15,R15                 * Freemain was ok??
         BZ    RCA39                   * Yes: continue
         LA    R15,022                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         XR    R15,R15                 * Simulate correct freemain
*
RCA39    EQU   *
         ST    R15,FDBRPL              * Reset ptr-field in FDB for RPL
         ST    R15,FDBACB              * Reset ptr-field in FDB for ACB
*
* The file has been closed, all dynamic storage areas associated with
* FDB have been freed. Before we can free the FDB-storage it must
* be removed from the FDB-chain.
*
RCA50    EQU   *
         LR    R6,R5                   * Save address of current FDB
         LA    R5,UAFDBPTR             * Set ptr to start of FDB-chain
*
RCA52    C     R6,FDBNEXT              * Next FDB is the closed one ??
         BE    RCA55                   * Yes: go remove closed FDB
         L     R5,FDBNEXT              * Get addr of next FDB in chain
         LTR   R5,R5                   * Valid ??
         BNZ   RCA52                   * Yes: it points to closed FDB??
         B     RCA90                   * No: we're done
*
RCA55    EQU   *
         MVC   FDBNEXT,0(R6)           * Copy next field of closed FDB
*
* Closed FDB has now been removed from the FDB-chain.
*
         FREEMAIN RC,                  * Conditionally free FDB-storage*
               SP=&SP,                 *    from our private subpool   *
               LV=L'FDB,               *    specifying both its length *
               A=(R6)                  *    and its address
         LTR   R15,R15                 * Freemain was ok??
         BZ    RCA90                   * Yes: continue
         LA    R15,025                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
*
RCA90    EQU   *
         L     R14,UALV1SAV            * Reload return address
         BR    R14                     * And return to caller
*
         SPACE 3
*
RCACLC   CLC   FDBLKEY(0),=&MAXKEY.C'0' * Compare last key with zeros
RCACLCDD CLC   FDBDDLOC(0,R9),FDBDDNAM  * Compare FDBDDNAM-fields
*
         EJECT
*
* RBLDVRP allocates a VSAM resource pool (VRP) tailored for either
*                    sequential or random processing
*
RBLDVRP  EQU   *                       * Allocate VSAM resource pool
         ST    R14,UALV2SAV            * Save R14 level 2
*
* Now we will try to allocate a VSAM resource pool. If the requested
* shrpool number is too high, we skip the allocation and VSAM will
* have to use private pools.
*
         MVI   UAPOOLNR,X'00'          * Default shrpool-nr to be used
*
RBLDVRP2 EQU   *
         CLI   UAPOOLNR,X'0F'          * Is the shrpool-nr low enough??
         BH    RBLDVRP8                * No: use private pools
*
* Before inserting the shrpool-nr to be used into the plist that
* defines our bldvrp-request, the default plist must be copied to
* a location where we can modify it.
*
         L     R2,=AL4(BLDVRPD)        * Get address of bldvrp plist
         MVC   UAWORKAR(BLDVRDLV),0(R2) *Copy plist to be modified
         LA    R2,UAWORKAR             * And point to modifiable plist
*
         USING DSBLDVRP,R2             * Address plist by DSECT
         LA    R1,BLDVRPHD             * Point to header entry
         ST    R1,BLDVRPTR             * Insert header address in plist
         OI    BLDVRPTR,X'80'          * and mark end-of-plist
         MVC   BLDVRPNR,UAPOOLNR       * Copy shrpool-nr to be used
         DROP  R2                      * Drop addressability of plist
         BLDVRP MF=(E,(R2))            * Build vsam resource pool
         LTR   R15,R15                 * Check return code
         BZ    RBLDVRP5                * If ok: go allocate index pool
*
* If bldvrp was unsuccessful because a resource pool with the specified
* pool number already existed, then we should try another shrpool nr.
*
         CH    R15,=H'4'               * Double shrpool number ??
         BE    RBLDVRP3                * Yes: try next shrpool-nr
         CH    R15,=H'32'              * Shrpool exists in other amode?
         BNE   RBLDVRP8                * No: issue error message
*
* The shrpool number we used already exists, increment shrpoolnr and
* retry. If the shrpoolnr exceeds 15, then there are no free shrpool
* numbers and we must use private buffering in stead of LSR.
*
RBLDVRP3 EQU   *
         XR    R1,R1                   * Clear register
         IC    R1,UAPOOLNR             * to contain shrpool-nr
         LA    R1,1(R1)                * Increment shrpool number by 1
         STC   R1,UAPOOLNR             * And save it in the USERAREA
         B     RBLDVRP2                * Now go try allocate a shrpool
*
* The data resource pool has been built successfully.
*
RBLDVRP5 EQU   *
         OI    UAVRPSTA,UAVEXIST       * Indicate VRP now exists
*
* Now we must try to allocate the index pool. If it fails, it does not
* matter much, the only difference is that VSAM will be a bit slower.
* Before inserting the shrpool-nr to be used into the plist that
* defines our bldvrp-request, the default plist must be copied to
* a location where we can modify it. (same as above)
*
         L     R2,=AL4(BLDVRPI)        * Get address of bldvrp plist
         MVC   UAWORKAR(BLDVRILV),0(R2) *Copy plist to be modified
         LA    R2,UAWORKAR             * and point to modifiable plist
         USING DSBLDVRP,R2             * Address plist by dsect
         LA    R1,BLDVRPHD             * Point to header entry
         ST    R1,BLDVRPTR             * Insert header address in plist
         OI    BLDVRPTR,X'80'          * and mark end-of-plist
         MVC   BLDVRPNR,UAPOOLNR       * Copy shrpool-nr to be used
         DROP  R2                      * Drop addressability of plist
*
* In stead of using the execute form of the bldvrp-macro, the SVC
* itself is coded. This is because the execute form of the bldvrp
* for lsr,index contains a bug, resulting in a returncode 4 in R15.
* Reason: the plist is modified incorrectly by the generated code.
* By coding the SVC in stead of the macro this problem is circumvented
*
*        BLDVRP MF=(E,UAWORKAR)        * Build VSAM resource pool
         LR    R1,R2                   * Set parm pointer for bldvrp
         SVC   19 = BLDVRP MF=(E,...)  * Build VSAM resource pool
         LTR   R15,R15                 * Check return code
         BZ    RBLDVRP9                * If ok: we're done
         ST    R15,UAVSAMRC            * Save VSAM returncode
         LA    R15,080                 * Load error code
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RBLDVRP9                * Then exit
*
* Bldvrp encountered a serious error
*
RBLDVRP8 OI    UAVRPSTA,UAVERROR       * Indicate error status
         MVI   UAPOOLNR,X'10'          * Indicate private pools in use
         ST    R15,UAVSAMRC            * Save VSAM returncode
         LA    R15,017                 * Load error code
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
*                                      * And exit rbldvrp-routine
*
* The resource pool now is allocated successfully or VSAM will default
* to the use of private pools. In either case the VRP-status bits will
* have to be set.
*
RBLDVRP9 EQU   *
         L     R14,UALV2SAV            * Reload return address
         BR    R14                     * And return to caller (ROP)
*
         EJECT
*
* RASM assembles a complete record in a workarea from the appropriate
* key and data fields in the parameter
*
RASM     EQU   *                       * Assemble a complete record
         ST    R14,UALV2SAV            * Save R14 level 2
*
* If we are processing a write request, we must assemble the record
* in the existing record area in the buffer. Otherwise we are
* processing either a delete or an insert request, both of which
* require the record to be assembled in a work-area.
*
         TM    FDBREQ,FDBWRITE         * Is this a write request ??
         BNO   RASM05                  * No: go find work-area
         L     R2,FDBREC               * Get address of record
         B     RASM10                  * And skip finding work-area
*
* Get the address of the workarea to be used. If the address is zero
* then no area exists and one will have to be allocated.
*
RASM05   L     R2,FDBWAREA             * Get address of work-area
         LTR   R2,R2                   * Does it exist ??
         BNZ   RASM10                  * If it exists: skip getmain
         LH    R2,FDBRECLV             * Get required length
         GETMAIN RC,                   * Conditionally request storage *
               SP=&SP,                 *    from our own subpool       *
               LV=(R2)                 *    long enough for a record
         LTR   R15,R15                 * Request was ok ??
         BZ    RASM09                  * Yes: skip error
*
* A workarea for assembling the record can not be allocated. Therefore
* the insert or delete request we are processing must be aborted. This
* is done by giving the error routine the level1 return address. Thus
* error will return to the main-line (phase3) after issuing the error.
*
         LA    R15,070                 * Load error number
         L     R14,UALV1SAV            * Get return address to mainline
         L     R3,=AL4(ERROR)          * Get address of error handler
         BR    R3                      * Execute it, return to mainline
*
RASM09   EQU   *
         ST    R1,FDBWAREA             * Save addr of allocated storage
         LR    R2,R1                   * Set pointer for assembly
*
         SPACE 3
*
* Whether we are assembling in a work-area or in the buffer, R2
* now points to the area to be used for assembly. Before we can start
* moving data, we must first find the map-master-element for the
* parameter version that is requested.
*
RASM10   EQU   *
         XR    R0,R0                   * Clear reg for 0 compare value
         L     R6,FDBMAP               * Get start addr of MME-list
         USING DSMME,R6                * And use DSECT for addressing
*
         AIF   (&OPT).RASM20           * Currently only 1 version / FDB
RASM12   CLC   UAVERSI,MMEVERS         * Is this the version we seek ??
         BE    RASM20                  * Yes: go use map
         CH    R0,MMEREM               * Are there more MMEs in list ?
         BNE   RASM15                  * Yes: skip error
         LA    R15,028                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RASM90                  * Skip remainder of assembly
*
RASM15   LA    R6,L'MME(R6)            * Address next MME
         B     RASM12                  * And check this MME
.RASM20  ANOP
*
* R2 will continuously point to the start of the assembly-area.
* R6 now points to the map-master-element to be used. R7 will be used
* for addressing the consecutive map-elements to be used.
* According to the list of map-elements associated with this MME
* the data will have to be moved. R8 is used as destination pointer
* while R10 is used as source pointer. Depending on the amount of data
* associated with a map element either MVC or MVCL will be used.
*
RASM20   EQU   *
         L     R7,MMEMAP               * Get start addr of map to use
         USING DSME,R7                 * And use DSECT for addressing
*
RASM22   LA    R10,BXAIOPRM            * Get start address of parm
         AH    R10,MEPRMOFS            * Add offset within parm
         LR    R8,R2                   * Get start address of record
         AH    R8,MERECOFS             * And add offset,
*                                      *     giving data-start
         LH    R9,MEDATLV              * Get length to be used
         CLI   MEDATLV,X'00'           * Is data longer than 256 bytes?
         BNE   RASM24                  * Y: too long for MVC, use MVCL
         BCTR  R9,R0                   * Decrement length by 1 for MVC
         EX    R9,RASMMVC              * And move the data
         B     RASM29                  * Go loop to next map-element
*
RASM24   LR    R1,R11                  * Save data-area pointer
         LR    R11,R9                  * Length of target = l'source
         MVCL  R8,R10                  * Copy data: parm -> workarea
         LR    R11,R1                  * Restore data-area pointer
*
RASM29   EQU   *
         AIF   (&OPT).RASM90           * One ME per parm currently
         CH    R0,MEREM                * Any more elements ??
         BE    RASM90                  * No: go finish RASM
         LA    R7,L'ME(R7)             * Point next map-element
         B     RASM22                  * And go move data
.RASM90  ANOP
*
RASM90   EQU   *
         L     R14,UALV2SAV            * Reload return address
         BR    R14                     * And return to caller
*
         SPACE 3
*
RASMMVC  MVC   0(0,R8),0(R10)          * Move a small data segment
*
         DROP  R6                      * End of addressability of MME
         DROP  R7                      * End of addressability of ME
*
         DROP  R3                      * End of addressability phase 3
FASE3END EQU   *
*
         EJECT
         USING PHASE4,R3
PHASE4   EQU   *
*
* All requests have now been started: now we must wait for them
* to end to obtain returncodes for the caller.
* Thereafter we shall finish with some concluding processing.
*
         LA    R5,UAFDBPTR             * Point to entry of FDB-chain
LOOP4    L     R5,FDBNEXT              * Make next FDB the current one
         LTR   R5,R5                   * Points nowhere: we're through
         BZ    LOOP4EX                 * If no next FDB, then exit loop
         CLI   FDBREQ,FDBNOREQ         * Anything to do for this file ?
         BE    LOOP4                   * No: try next FDB
         ST    R3,UABASSAV             * Save current base register
         L     R3,=AL4(RCHECK)         * Get address of wait routine
         BASR  R14,R3                  * Wait for I/O completion
*
* If a record was retrieved, its data contents must be copied into
* the parameter area, so the application can access the data.
*
         TM    FDBREQ,FDBREAD          * Was a read operation executed?
         BNO   LOOP4C                  * No: skip disassembly
         TM    FDBSTAT,FDBEOF          * Did we reach end-of-file ??
         BO    LOOP4C                  * Yes: skip disassembly
         TM    FDBSTAT,FDBERROR        * Was error-status raised ??
         BO    LOOP4C                  * Yes: skip disassembly
*
* If the read was random then we must check for correct key value
*
         TM    FDBSTAT,FDBACRND        * Request was random
         BNO   LOOP4DIS                * No: no need to check key
         L     R2,FDBREC               * Get addr of record just read
         LTR   R2,R2                   * Is there such a record ??
         BE    LOOP4C                  * No: skip disassembly
         AIF   (&OPT).LUP4DIS          * No need to check key
         XR    R1,R1                   * Clear register
         IC    R1,FDBKEYLV             * to contain key length
         BCTR  R1,R0                   * Decrement by one for CLC
         EX    R1,LOOP4CLC             * Compare with correct length
         BE    LOOP4DIS                * Keys equal: disassemble
         B     LOOP4C                  * Skip disassembly of
*                                      *      erroneous record
*
LOOP4CLC CLC   0(0,R2),UAKEY           * Compare key in record
*                                      *      to key in parm
*
.LUP4DIS ANOP
*
LOOP4DIS EQU   *
         BAS   R14,RDISM               * Disassemble record into parm
*
         AIF   (NOT &DBG).LOOP4C
*
* If the read was forced by an open request, all records must be
* equal (apart from differences in length).
*
         TM    FDBREQ,FDBOPEN          * Was open requested
         BNO   LOOP4C                  * No: skip compare
*
* First we must find start address and length of record of current FDB
*
         L     R8,FDBREC               * Get address of record
         LTR   R8,R8                   * Is it valid ??
         BE    LOOP4C                  * No: skip this record
*                                      *    (error has been issued
*                                      *           by RDISM)
         LH    R9,FDBRECLV             * Get record length
         XR    R6,R6                   * Clear register
         IC    R6,FDBKEYLV             * to contain key length
         LA    R8,0(R6,R8)             * Get start of data beyond key
         SR    R9,R6                   * Get length of data without key
*
* Now retrieve addr+length of record of previous FDB before overwriting
* them with addr+length of record of current FDB
*
         L     R6,UALRECAD             * Get address of previous record
         LH    R7,UALRECLV             * Get data length of prev. rec'd
         ST    R8,UALRECAD             * Save address of last record
         STH   R9,UALRECLV             * Save data length of last rec'd
*
* If there is no record of a previous FDB, then forego comparing
*
         LTR   R6,R6                   * Previous record is defined ??
         BZ    LOOP4C                  * No: skip comparing
*
* The records are to be compared, but only for a length that is
* equal to the shortest data length.
*
         CR    R7,R9                   * Compare lengths
         BL    LOOP4LOW                * R7 is the shorter one
         LR    R7,R9                   * Compare using shortest length
         B     LOOP4CMP                * Go compare
LOOP4LOW LR    R9,R7                   * R7 is the shorter one
LOOP4CMP CLCL  R6,R8                   * Compare data areas (pad=x'00')
         BE    LOOP4C                  * Equal: ok
         LA    R15,029                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
*
.LOOP4C  ANOP
*
* If RPL has been changed for insert, it must remain so because the
* next request may well be another insert. However, if the RPL has
* been changed for delete, then the next request cannot be another
* delete, and therefore the RPL should be reset to normal right away.
*
LOOP4C   EQU   *
         TM    FDBSTAT,FDBRPLDR        * RPL changed for delete ??
         BNO   LOOP4E                  * No: go check next FDB
         TM    FDBSTAT,FDBRPLIR        * RPL changed for insert ??
         BO    LOOP4E                  * Yes: let it remain so
*
* RPL has been changed for delete, not for insert: change to normal.
*
         L     R2,FDBRPL               * Get address of changed plist
         LA    R6,FDBREC               * Record address within buffer
         MODCB RPL=(R2),               * Reset RPL from delete mode    *
               OPTCD=(LOC),            *  LOC in stead of MVE option   *
               AREA=(S,0(R6)),         *  address of data area         *
               MF=(G,UAWORKAR,MODCNDLV) * using UAWORKAR to build plist
         LTR   R15,R15                 * Modcb was ok ??
         BE    LOOP4D                  * Yes: skip error
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,063                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     LOOP4E                  * Skip resetting the RPL-status
*
LOOP4D   EQU   *
         NI    FDBSTAT,FDBRPLND        * Reset RPL-status to non-delete
*
* Post-processing for this FDB is complete: fill LREQ and LKEY fields
* unless the FDBRETCD field is greater than X'04' (I/O unsuccessful)
*
LOOP4E   EQU   *
         CLI   FDBRETCD,X'00'          * FDB-return code worse
*                                      *     than warning?
         BNE   LOOP4F                  * Yes: don't fill LREQ and LKEY
         MVC   FDBLREQ,FDBREQ          * I/O was concluded ok, hence
         MVC   FDBLKEY,LNSKEY          * save request and key we used
*
LOOP4F   EQU   *
         AIF   (&OPT).LOOP4EX          * Only one FDB can be active
         B     LOOP4                   * Go try next FDB
*
.LOOP4EX ANOP
*
LOOP4EX  EQU   *
*
         EJECT
*
* All I/O has been completed: if all files have been closed then
* the complete USERAREA (including FDBs) should be freed.
*
         CLC   LNSFCODE,=CL2'CA'       * Was a close request processed?
         BNE   EXIT                    * No: some files must be open
*
         AIF   (&OPT).LOOP6
*
* When not optimizing all FDBs of unopened files are to be removed
* before we continue.
*
         LA    R5,UAFDBPTR             * Point to start of FDB-chain
         XR    R6,R6                   * Set nr of open files to 0.
LOOP5    L     R5,FDBNEXT              * Point to next FDB in chain
         LTR   R5,R5                   * End of chain ??
         BE    LOOP5EX                 * Yes: end of this loop.
         TM    FDBSTAT,FDBINPUT        * File is open ??
         BNO   LOOP5                   * No: do not count this FDB
         LA    R6,1(R6)                * Increment open-file-counter
         B     LOOP5                   * And continue with next FDB
*
* R6 now contains the number of open files. If no files are open
* all FDBs are to be freed.
*
LOOP5EX  EQU   *
         LTR   R6,R6                   * Any open files ??
         BNE   LOOP6EX                 * Yes: skip freemains of FDBs
*
* No open files: remove and free all FDBs
*
LOOP6    L     R5,UAFDBPTR             * Point to first FDB in chain
         LTR   R5,R5                   * Is it valid ?
         BE    LOOP6EX                 * No: we're done
         MVC   UAFDBPTR,FDBNEXT        * Copy addr of next FDB in chain
         FREEMAIN RC,                  * Conditionally free unused FDB *
               SP=&SP,                 *    from our own subpool       *
               LV=L'FDB,               *    specifying length of FDB   *
               A=(R5)                  *    and its starting address
         LTR   R15,R15                 * Freemain was ok ??
         BE    LOOP6                   * Yes: go free next FDB
         LA    R15,025                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it
         B     LOOP6                   * Then go remove next FDB
*
LOOP6EX  EQU   *
*
.LOOP6   ANOP
*
* Close was requested, check whether all files are currently closed.
* If any file is still open, the USERAREA cannot be freed yet.
*
         CLC   UAFDBPTR,=F'0'          * Any files still open ??
         BNE   EXIT                    * Yes: skip freeing storage
*
* Remove the VSAM resource pool, unless private pools are being used.
*
         TM    UAVRPSTA,UAVEXIST       * Does a VRP exist ??
         BNO   DLVRPOK                 * No: go pretend dlvrp was ok.
         CLI   UAPOOLNR,X'0F'          * Is LSR active ??
         BH    FREEM                   * No: we are using private pools
*
* The plist for dlvrp-request is equal to the plist for the bldvrp-req.
* Before inserting the shrpool-nr to be used into the plist that
* defines our dlvrp-request, the default plist must be copied to
* a location where we can modify it.
*
DLVRP2   EQU   *
         L     R2,=AL4(BLDVRPD)        * Get address of plist for dlvrp
         MVC   UAWORKAR(BLDVRDLV),0(R2) *Copy plist to be modified
         LA    R2,UAWORKAR             * Point to the modifiable plist
         USING DSBLDVRP,R2             * Establish addressability
         LA    R1,BLDVRPHD             * Point to header entry
         ST    R1,BLDVRPTR             * Insert address in plist
         OI    BLDVRPTR,X'80'          * Insert end-of-plist marker
         MVC   BLDVRPNR,UAPOOLNR       * Copy shrpool-nr to be used
         DROP  R2                      * Drop addressability to plist
         DLVRP MF=(E,(R2))             * Free the VSAM resource pool
         LTR   R15,R15                 * Free was successfull ??
         BZ    DLVRPOK                 * Yes: go free USERAREA
*
* An error occurred while executing dlvrp. Warning: the returncode from
* dlvrp may be incorrect (eg. X'0C' when shrpool-nr is invalid).
*
         OI    UAVRPSTA,UAVERROR       * Set error bit
         ST    R15,UAVSAMRC            * Save VSAM retcode
         LA    R15,018                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     FREEM                   * Skip resetting VRP-indicators
*
DLVRPOK  NI    UAVRPSTA,UAVCLOSE       * Reset status to closed
         MVI   UAPOOLNR,X'00'          * Reset shrpool-nr to default
*
* Return the USERAREA to the system
*
FREEM    EQU   *
         AIF   (NOT &DBG).FREEM
*
* If snap-file is opened, then it must be closed
*
         TM    UASTAT,UASNAPOP         * Snap-file open ??
         BNO   FREEM1                  * No: skip closing the file
         L     R2,=AL4(CLOSE)          * Point to plist for close macro
         MVC   UAWORKAR(CLOSELV),0(R2) * Copy default close-plist
         LA    R9,UAWORKAR             * and point to modifiable plist
         L     R2,UASNAPTR             * Address snap control-block
         USING DSSNAP,R2               * Establish addressability
         LA    R2,SNAPDCB              * And point to the open DCB
         DROP  R2                      * Drop snapblock
         CLOSE ((R2)),                 * Close snap-file               *
               MF=(E,(R9))             *    using copy of default plist
         LTR   R15,R15                 * Close was ok ??
         BE    FREEMA                  * Yes: continue
         LA    R15,078                 * Load error code
         L     R3,=AL4(ERROR)          * Retrieve address of error-rout
         BASR  R14,R3                  * and execute it
         B     FREEM2                  * Skip remainder of snap-closing
*
FREEMA   NI    UASTAT,UASNAPCL         * Set status to closed
*
FREEM1   L     R2,UASNAPTR             * Get address of snap-block
         LTR   R2,R2                   * Valid ??
         BZ    FREEM2                  * No: skip freemain
         FREEMAIN RC,                  * Conditionally free SNAPAREA   *
               SP=&SP,                 *    from our private subpool   *
               LV=L'SNAPAREA,          *    specifying correct length  *
               A=(R2)                  *    and starting address
         LTR   R15,R15                 * Freemain was ok??
         BE    FREEM1A                 * Yes: skip error
         LA    R15,079                 * Load error code
         L     R3,=AL4(ERROR)          * Retrieve address of error-rout
         BASR  R14,R3                  * and execute it
         B     FREEM2                  * Skip remainder of snap-closing
*
FREEM1A  XC    UASNAPTR,UASNAPTR       * Yes: wipe pointer
*
.FREEM   ANOP
*
FREEM2   C     R13,=AL4(CRASHMEM+8)    * Using the emergency area ??
         BE    EXIT                    * Yes: skip freemain
         LH    R10,UAREASN             * Save retcode for application
         MVC   LNSRCODE,UARETCD        * Set returncode in parameter
         LR    R2,R13                  * Save address of USERAREA
         L     R13,SAVEPREV(R13)       * Reset R13 to previous savearea
         FREEMAIN RC,                  * Conditionally free USERAREA   *
               SP=&SP,                 *    from our private subpool   *
               A=(R2),                 *    specifying starting address*
               LV=L'USERAREA           *    and full length
         LTR   R15,R15                 * Freemain was successfull ??
         BZ    FREEM10                 * Yes: last housekeeping
         LA    R15,025                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
*                                      * USERAREA is now in crashmem !!
         LH    R10,UAREASN             * Save new returncode
         MVC   LNSRCODE,UARETCD        * Set new retcode in parameter
         L     R13,SAVEPREV(R13)       * Reset R13 to previous savearea
         XR    R15,R15                 * Simulate correct freemain
*
* Storage has been freed, since register 13 has already been reloaded
* we must skip reloading register 13, or we would skip one level of
* returning.
*
FREEM10  EQU   *
         L     R1,SAVEDR1(R13)         * Reload original plist-pointer
         L     R2,4(R1)                * Get address of 2nd parameter
         USING DS83PRM2,R2             * Address parameter 2 by R2
         ST    R15,LNSUAPTR            * Reset LNSUAPTR in parm
         DROP  R2
         B     EXIT99                  * And go return to caller
*
EXIT     EQU   *
         LH    R10,UAREASN             * Load retcode for application
         MVC   LNSRCODE,UARETCD        * Set returncode in parameter
         C     R13,=AL4(CRASHMEM+8)    * When using emergency memory
         BE    EXITUNLK                *    for our userarea
         C     R4,=AL4(CRASHMEM+8)     * or for our parameter
         BNE   EXIT90                  * then remove lock:
*
EXITUNLK L     R4,=AL4(CRASHMEM)       * Get address of lock-word
         XC    0(4,R4),0(R4)           * Remove lock
*
EXIT90   L     R13,SAVEPREV(R13)       * Reset R13 to previous savearea
*
EXIT99   EQU   *
         LR    R15,R10                 * Set correct reasoncode
*                                      *        for application
         L     R14,SAVEDR14(R13)       * Reload return-addr to caller
         LM    R0,R12,SAVEDR0(R13)     * Reload all regs for caller
         BSM   0,R14                   * And return to caller with
*                                      *           return code in R15
         EJECT
*
* Rdism disassembles a record from the VSAM-I/O-buffer to the
* appropriate key- and data-fields in the parameter.
*
RDISM    EQU   *                       * Assemble a complete record
         ST    R14,UALV2SAV            * Save R14 level 2
*
* Get the address of the last record read within the buffer.
*
         L     R6,FDBREC               * Get address of record in buf
         LTR   R6,R6                   * Check the address
         BNZ   RDISM10                 * If it exists: skip error
         LA    R15,057                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RDISM90                 * Skip remainder of this routine
*
* First we must find the map to be used in the list of
*       map-master-elements
*
RDISM10  EQU   *
         XR    R0,R0                   * Clear reg for 0 compare value
         L     R6,FDBMAP               * Get start addr of mme-list
         USING DSMME,R6                * Use DSECT MME for addressing
*
         AIF   (&OPT).RDISM20          * Currently only 1 version / FDB
RDISM12  CLC   UAVERSI,MMEVERS         * Is this the version we seek ??
         BE    RDISM20                 * Yes: go use map
         CH    R0,MMEREM               * Any more MMEs in list ?
         BNE   RDISM15                 * Yes: skip error
         LA    R15,028                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
         B     RDISM90                 * Skip remainder of disassembly
*
RDISM15  LA    R6,L'MME(R6)            * Address next MME
         B     RDISM12                 * And check this MME
*
.RDISM20 ANOP
*
* R6 now points to the map-master-element. R7 will be used for
* addressing the contiguous map-elements. R8 will be used as a source
* pointer, R10 will serve as a destination pointer. Depending on the
* amount of data being moved either MVC or MVCL will be used.
*
RDISM20  EQU   *
         L     R7,MMEMAP               * Get start addr of map to use
         USING DSME,R7                 * And use DSECT for addressing
*
RDISM22  LA    R10,BXAIOPRM            * Get start address of parameter
         AH    R10,MEPRMOFS            * Add offset within parm
         L     R8,FDBREC               * Get start address of record
         AH    R8,MERECOFS             * Add offset, giving data-start
         LH    R9,MEDATLV              * Get length to be used
         CLI   MEDATLV,X'00'           * Is data longer than 256 bytes?
         BNE   RDISM24                 * Y: too long for MVC, use MVCL
         BCTR  R9,R0                   * Decrement length by 1 for MVC
         EX    R9,RDISMMVC             * Execute move with this length
         B     RDISM29                 * Go loop to next map-element
*
RDISM24  LR    R1,R11                  * Save data-area pointer
         LR    R11,R9                  * Length of target = l'source
         MVCL  R10,R8                  * Copy data from record to parm
         LR    R11,R1                  * Restore data-area pointer
*
RDISM29  EQU   *
         AIF   (&OPT).RDISM30          * Currently only one ME per MME
         CH    R0,MEREM                * Any more elements ??
         BE    RDISM30                 * No: go finish RDISM
         LA    R7,L'ME(R7)             * Point next map-element
         B     RDISM22                 * And go move data
*
.RDISM30 ANOP
*
RDISM30  EQU   *                       * Move key from rec to LNSKEY
         L     R8,FDBREC               * Get source address
         LA    R10,LNSKEY              * Get destination address
         XR    R9,R9                   * Clear register
         IC    R9,FDBKEYLV             *       to contain key length
         BCTR  R9,R0                   * Decrement length by 1 for MVC
         EX    R9,RDISMMVC             * And move key to parm-area
*
RDISM90  EQU   *
         L     R14,UALV2SAV            * Reload return address
         BR    R14                     * Return to caller
*
         SPACE 3
*
RDISMMVC MVC   0(0,R10),0(R8)          * Move a small segment to parm
*
         DROP  R6                      * End of addressability of MME
         DROP  R7                      * End of addressability of ME
*
         DROP  R3                      * End of addressability phase 4
*
FASE4END EQU   *
*
         EJECT
         USING RCHECK,R3
*
* RCHECK issues a check macro against the current FDB (R5)
*
RCHECK   EQU   *                       * Wait for I/O completion
         ST    R14,UALV2SAV            * Save R14 level 2
*
* If the ECB is currently unused a check is quite useless.
*
         L     R1,FDBECB               * Load current contents of ECB
         LTR   R1,R1                   * See if any I/O is in progress
         BZ    RCHECK99                * No: return immediate
*
* Now we must wait until VSAM has completed the I/O and has executed
* all the exits required. First we will increment the IO-call counter.
*
         AIF   (&OPT).CHECK15
         L     R2,UAIOCNT              * Load total io-count
         LA    R2,1(R2)                * Increment by one
         ST    R2,UAIOCNT              * And store updated value
*
.CHECK15 L     R7,FDBRPL               * Get address of RPL to be used
         CHECK RPL=(R7)                * Wait until I/O & exits are
*                                      *              complete
RCHECK15 LTR   R15,R15                 * Check return code
         BZ    RCHECK30                * If ok: skip error handling
         ST    R15,UAVSAMRC            * Save retcode for error handler
         LA    R15,064                 * Load error code
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
*
* VSAM has completed the I/O and the exits. Check the ECB-returncode
* for errors.
*
RCHECK30 EQU   *
         NI    FDBECB,X'00'            * Wipe event bits in ECB
         L     R1,FDBECB               * Load returncode from ECB
         LTR   R1,R1                   * Test value of returncode
         BZ    RCHECK40                * Returncode zero: skip error
         OI    FDBSTAT,FDBERROR        * Indicate error status for file
         ST    R1,UAVSAMRC             * Save retcode for error handler
         LA    R15,065                 * Load error code
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute it, then return here
*
* If a get was executed, then the FDB is to be updated with the current
* buffer description.
*
RCHECK40 EQU   *
         USING IFGRPL,R7               * R7 still contains RPL-address
*
         CLI   RPLREQ,RPLGET           * Was a get executed ??
         BNE   RCHECK50                * No: skip updating the FDB
         NI    FDBSTAT,FDBBUFNU        * Buffer not marked for output
         CLI   FDBRETCD,X'00'          * File in error status ??
         BNE   RCHECK45                * Yes: do not update FDB
         L     R6,RPLPLHPT             * Get addr of placeholder
         USING IDAPLH,R6               * Address placeholder by DSECT
*
         CLC   FDBREC,PLHRECP          * Record pointer in FDB = PLH ??
         BNE   RCHECK48                * No: issue error
         MVC   FDBSBUF,PLHRECP         * Copy current record pointer
         MVC   FDBEBUF,PLHFSP          * Copy free space pointer
         B     RCHECK90                * Get-request has been handled
*
         DROP  R6                      * End of addressability to PLH
         DROP  R7                      * End of addressability to RPL
*
* FDB  contains errorcode, therefore the FDBREC field must be
* reset to zero. Thus the next read request will cause a get,
* which may then retrieve a valid buffer.
*
RCHECK45 XC    FDBREC,FDBREC           * Set current record to invalid
         B     RCHECK90                * And go return to mainline
*
RCHECK48 EQU   *                       * Record address mismatch
         LA    R15,073                 * Load error number
         L     R3,=AL4(ERROR)          * Get address of error handler
         BASR  R14,R3                  * Execute error, return here
         B     RCHECK90                * Checking complete
*
* If a point has been completed (seq. access) then the FDB must be
* updated to reflect the current buffer.
*
RCHECK50 EQU   *
         USING IFGRPL,R7               * R7 still contains RPL-address
*
         CLI   RPLREQ,RPLPOINT         * Was a skip executed ??
         BNE   RCHECK90                * No: skip updating the FDB
         NI    FDBSTAT,FDBBUFNU        * Buffer not marked for output
         CLI   FDBRETCD,X'00'          * File in error status ??
         BNE   RCHECK90                * Then do not update FDB
         L     R6,RPLPLHPT             * Get address of placeholder
         USING IDAPLH,R6               * Address placeholder by DSECT
*
         MVC   FDBSBUF,PLHRECP         * Copy current record pointer
         MVC   FDBEBUF,PLHFSP          * Copy free space pointer
         XC    FDBREC,FDBREC           * Invalidate current record ptr
*                                      *    (record not yet read)
         DROP  R6                      * End of addressability to PLH
         DROP  R7                      * End of addressability to RPL
*
RCHECK90 EQU   *
         XR    R0,R0                   * Clear register to wipe ECB
         ST    R0,FDBECB               * ECB now available for reuse
*
RCHECK99 EQU   *
         L     R14,UALV2SAV            * Reload return address
         L     R3,UABASSAV             * Retrieve caller's base address
         BR    R14                     * And return immmediate
*
         DROP  R3
*
RCHEKEND EQU   *
*
         EJECT
*
&ERR     SETB  1                       * Assembling error-routine
         USING ERROR,R3
*
* Error handler and error exit routines
* Since R10 is used as a pointer to the error, it should not be changed
* by any exit routine
* No storing into memory may take place, before the error exit has
* been executed. Therefore the error exit should save both R14, which
* contains the return address to error, and R0, which contains the
* error's own return address.
*
ERROR    EQU   *                       * Entry to error routine
         L     R1,=AL4(ERRORTAB)       * Start of error table
         BCTR  R15,R0                  * Decrement error number
*                                      *       to get offset number
         SLA   R15,6                   * Multiply offset number
*                                      *       by element length
*                                      *       to get byte offset
         LA    R10,0(R15,R1)           * Get address of error element
         CR    R10,R1                  * Entry too low ??
         BL    ERRORXX                 * Yes: unidentified error
         C     R10,=AL4(ERRORTND)      * Entry too high ??
         BL    ERRORDO                 * No: start error handling
*
ERRORXX  L     R10,=AL4(ERRORTND)      * Default to unidentified error
         USING DSERR,R10               * Use register for addressing
*
ERRORDO  EQU   *
         L     R15,ERRROUT             * Load error exit address
         LTR   R15,R15                 * Is an exit to be taken ??
         BZ    ERRORNOT                * If zero, skip exit
         LR    R1,R0                   * Save reasoncode that
*                                      *      may be present in R0
         LR    R0,R14                  * Copy return address
         BASR  R14,R15                 * Execute error exit
         B     ERRORFDB                * Exit must store R0 in uaerrsav
*                                      * (since user area may
*                                      *            not exist yet)
ERRORNOT EQU   *
         ST    R14,UAERRSAV            * Save return address
*
ERRORFDB EQU   *
         CLI   ERRFDBCD,X'00'          * Error for FDB ??
         BE    ERRORRCD                * No: continue with retcd/reasn
         CLC   ERRFDBCD,FDBRETCD       * More serious than last error??
         BNH   ERRORRCD                * No: continue with retcd/reasn
         MVC   FDBRETCD,ERRFDBCD       * Copy error code
         MVC   FDBREASN,ERRREASN       * And reason code
*
ERRORRCD EQU   *
         CLI   ERRRETCD,X'00'          * Error for USERAREA ??
         BE    ERRORWTO                * Yes: go check exit
         CLC   ERRRETCD,UARETCD        * Error more serious than last?
         BNH   ERRORWTO                * No: go take exit
         MVC   UARETCD,ERRRETCD        * Copy returncode
         MVC   UAREASN,ERRREASN        * And reasoncode
*
ERRORWTO EQU   *
         CLI   ERRTEXT,C' '            * Message exists ??
         BE    ERROREX                 * No: skip WTOs
         L     R2,=AL4(ERRWTO)         * Get address of WTO plist
         MVC   UAWORKAR(ERRWTOLV),0(R2) *Copy default WTO-plist
         LA    R2,UAWORKAR             * Get addr of modifiable plist
         MVI   4(R2),C' '              * Set first blank
         MVC   5(L'WTOTEXT-1,R2),4(R2) * Clear WTO-message
         MVC   4(8,R2),=C'BXAIO - '    * Set message prefix
         MVC   12(L'ERRTEXT,R2),ERRTEXT *Set message text
         WTO   MF=(E,(R2))             * And execute WTO
         MVI   4(R2),C' '              * Set first blank
         MVC   5(L'WTOTEXT-1,R2),4(R2) * Clear WTO-message
         AIF   (&OPT AND (NOT &DBG)).ERROR10
         L     R14,UACALLNR            * Retrieve call-count
         BAS   R1,TOHEX                * Convert to hexadecimal
         MVC   54(8,R2),4(R2)          * Copy call-count to message
         MVC   40(14,R2),=CL14'  Call-count: '
*
.ERROR10 MVC   12(L'LNSPARM,R2),LNSPARM *Set message text
         MVC   4(8,R2),=C'PARM IS:'    * Set message prefix
         WTO   MF=(E,(R2))             * And execute WTO
*
ERROREX  EQU   *
         ESNAP ,                       * Also execute snap-rout
         LH    R15,ERRREASN            * Load reasoncode
         L     R14,UAERRSAV            * Retrieve return/retry address
         L     R3,=AL4(RSETBASE)       * Get addr of rsetbase-routine
         BR    R3                      * To return to caller
*
         DROP  R10                     * End of addressability to
*                                      *           ERRORTAB
         EJECT
*
* Routine for handling errors when the USERAREA may not exist
*
UAERR    EQU   *                       * Exit-routine of error-rout.
*
* R14 contains return address into error-routine, R0 contains
* error's return address in turn. R3 and R11 are sure to be valid.
* R13 may point to our USERAREA, or it may point to the caller's
* savearea. the parameter may or may not be addressable.
*
         C     R11,SAVEDR11(R13)       * Is USERAREA-pointer valid ??
         BE    UAERRSVE                * Yes: go save regs in USERAREA
*
* No USERAREA exists. therefore we shall use the emergency area
* provided in this program. First we must lock it to prevent
* concurrency errors to occur over and above the error detected.
*
         L     R2,=AL4(CRASHMEM)       * Get addr of emergency storage
*
UAERRLOK L     R15,0(R2)               * Get contents of lock-word
         LTR   R15,R15                 * Lock = zero ??
         BNE   UAERRLOK                * No: storage is being used
         LA    R1,1                    * Get new lock-value
         CS    R15,R1,0(R2)            * Update lock in storage
         BNZ   UAERRLOK                * If locked by someone else:
*                                      *        go retry
         LA    R2,8(R2)                * Point beyond lock-word
         ST    R13,SAVEPREV(R2)        * Set pointer to prev. savearea
         LR    R13,R2                  * And establish new USERAREA
*
* R13 now points to our own USERAREA.
*
UAERRSVE ST    R0,UAERRSAV             * Save first-level return addr
         ST    R14,UAERXSAV            * Save error-exit return address
         ST    R11,SAVEDR11(R13)       * Mark this SAVEAREA as our own
*
* Now retrieve the address of the input parameter to check whether
* or not it is valid
*
         L     R1,SAVEPREV(R13)        * Get addr of previous savearea
         LTR   R1,R1                   * Valid ??
         BZ    UAERRPRM                * No: go use emergency storage
         L     R1,SAVEDR1(R1)          * Get original contents of R1
         LTR   R1,R1                   * Is it a valid plist pointer ??
         BZ    UAERRPRM                * No: use emergency storage
         TM    4(R1),X'80'             * End-of-plist-marker is there ?
         BNO   UAERRPRM                * No: plist is in error
         L     R4,0(R1)                * Get first word of plist
         LA    R4,0(R4)                * Strip end-of-plist bits
         LTR   R4,R4                   * Valid address ??
         BNZ   UAERRRET                * Yes: parameter found, return
*
* No parameter to be found. Use CRASHMEM as a substitute
*
UAERRPRM EQU   *
         LR    R4,R13                  * Copy USERAREA address
         C     R4,=AL4(CRASHMEM+8)     * Are we using CRASHMEM ??
         BE    UAERRRET                * Yes: go return to error
*
* Userarea was valid. Now try to gain control over CRASHMEM.
*
         L     R2,=AL4(CRASHMEM)       * Get addr of emergency storage
*
UAERRLOC L     R15,0(R2)               * Get contents of lock-word
         LTR   R15,R15                 * Lock = zero ??
         BNE   UAERRLOC                * No: storage is being used
         LA    R1,1                    * Get new lock-value
         CS    R15,R1,0(R2)            * Update lock in storage
         BNZ   UAERRLOC                * If locked by someone else
*                                      *      go retry
         LA    R4,8(R2)                * Point beyond lock-word
*
* Now both R4 and R13 are valid pointers to an input parameter
* and to a USERAREA.
*
UAERRRET EQU   *
         L     R14,UAERXSAV            * Reload return address
         BR    R14                     * And continue error proc.
*
         EJECT
*
* Routine for analyzing logical errors during VSAM execution
*
LGERR    EQU   *                       * Exit to error routine
         ST    R0,UAERRSAV             * Save return address of error
         ST    R14,UAERXSAV            * Save return address to error
*
* First we must check the UAVSAMRC for its value. If it is 8 VSAM
* detected a logical error while executing a request. The reasoncode
* is to be extracted from the RPL. According to the reasoncode a
* specific error message should be issued. If the return code is 12
* a physical I/O-error occurred, and an appropriate error message
* should be issued. If the RPL-address is invalid, no error can be
* issued.
*
         L     R2,FDBRPL               * Get address of RPL
         LTR   R2,R2                   * Is it valid ??
         BZ    LGERREX                 * No: quit this exit-routine
         USING IFGRPL,R2               * Address RPL by R2
*
         CLC   UAVSAMRC,=F'8'          * Returncode = 8 ??
         BE    LGERR001                * Yes: handle the logical error
         CLC   UAVSAMRC,=F'12'         * Returncode = 12 ??
         BNE   LGERREX                 * No: quit this exit-rout.
         LA    R15,067                 * Load physical error number
         B     LGERRGO                 * And restart the error-handler
*
* R14 and R15 will designate start and end of the table to be
* searched for the reason code. R14 will be used as a pointer to the
* current table elememnt.
*
LGERR001 L     R14,=AL4(LGERRTAB)      * Start of logical error table
         USING DSLGERR,R14             * Establish R14 as pointer
*
LGERRLUP CLC   LGREASON,RPLERRCD       * Compare RPL-condition-code
         BE    LGERRDO                 * This is the element we seek
         LA    R14,L'LGERRELM(R14)     * Point to next table element
         C     R14,=AL4(LGTABEND)      * Past end-of-table ??
         BNH   LGERRLUP                * No: go check this code
         B     LGERREX                 * Y: use default error handling
*
* We found the reasoncode in our table. Therefore we can now load the
* correct error code. Then we should restart the error-routine with
* the error-code we found. Thus the error we just found will be issued
* in stead of the global error text, that serves as a default.
*
LGERRDO  EQU   *
         LH    R15,LGERCODE            * Get the error number to use
         CH    R15,=H'001'             * Is it error nr 001 ? (eof)
         BNE   LGERRGO                 * No: go re-do error handler
         OI    FDBSTAT,FDBEOF          * Yes: indicate eof in FDB
*
LGERRGO  L     R14,UAERRSAV            * Reload return address
         LR    R0,R1                   * Reload original VSAM-reasncode
         B     ERROR                   * Now execute error for the new
*                                      *     error-number
         DROP  R2                      * R2 used to address RPL
*
* The default error message is to be used. Before returning to error
* the VSERR error exit should be executed to dump VSAM information.
* This is done by branching to VSERR as if it were called by error.
*
LGERREX  L     R14,UAERXSAV            * Reload return address to error
         L     R0,UAERRSAV             * Reload return addr from error
         B     VSERR                   * And continue with vserr
*
         DROP  R14                     * Reasoncode-table not
*                                      *           needed anymore
         EJECT
*
* Routine for dumping VSAM information after an error occurred
*
VSERR    EQU   *                       * Exit to error routine
         ST    R0,UAERRSAV             * Save return address of error
         ST    R14,UAERXSAV            * Save return address to error
*
         USING DSERR,R10               * Points current error element
         CLI   ERRTEXT,C' '            * Display error info ??
         BE    VSERREX                 * No: quit this exit
*
         DROP  R10                     * ERRORTAB no longer needed
*
* First we dump VSAM return- and reason codes (R15 and R0, resp.)
*
         L     R2,=AL4(ERRWTO)         * Retrieve address of blank WTO
         MVC   UAWORKAR(ERRWTOLV),0(R2) *Copy blank WTO to workarea
         LA    R2,UAWORKAR             * Now point to modifiable WTO
         MVI   4(R2),C' '              * Set blank in 1st text position
         MVC   5(L'WTOTEXT-1,R2),4(R2) * Wipe default text
         LR    R14,R1                  * Reason code was copied to R1
         BAS   R1,TOHEX                * Dump reasoncode, retadr in R1
         MVC   50(8,R2),4(R2)          * and move to correct location
         MVC   29(21,R2),=CL21' while reasoncode is '
         L     R14,UAVSAMRC            * Retrieve VSAM returncode
         BAS   R1,TOHEX                * Dump reasoncode, retadr in R1
         MVC   21(8,R2),4(R2)          * and move to correct location
         MVC   4(17,R2),=CL17'VSAM returncode: ' insert preceding text
         WTO   MF=(E,(R2))             * and display information
*
* Before dumping ACB and RPL data we must ensure that R5, our
* FDB-pointer, is currently valid.
*
         LA    R1,UAFDBPTR             * Point start of FDB-chain
*
VSERRLUP L     R1,0(R1)  0(R1)=FDBNEXT * Get address of next FDB
         LTR   R1,R1                   * Is it valid ??
         BZ    VSERRERR                * No: R5 matches no FDB on chain
         CR    R1,R5                   * FDB-pointer points this FDB ??
         BNE   VSERRLUP                * No: try next FDB
         B     VSERRACB                * Yes: FDB-ptr is valid: dump
*
VSERRERR EQU   *
         MVI   4(R2),C' '              * Set blank in 1st text position
         MVC   5(L'WTOTEXT-1,R2),4(R2) * Wipe default text
         LR    R14,R5                  * Retrieve FDB-address
         BAS   R1,TOHEX                * Dump invalid FDB-pointer
         MVC   29(20,R2),=CL20' is not on FDB-chain' insert error text
         MVC   21(8,R2),4(R2)          * Move to correct location
         MVC   4(17,R2),=CL17'VSERR:    FDB at ' add preceding text
         WTO   MF=(E,(R2))             * and display information
         B     VSERREX                 * Exit this error-exit
*
* Now dump ACB-data if present
*
VSERRACB EQU   *
         MVI   4(R2),C' '              * Set blank in 1st text position
         MVC   5(L'WTOTEXT-1,R2),4(R2) * Wipe default text
         L     R15,FDBACB              * Retrieve address of ACB
         LTR   R15,R15                 * Is it valid ??
         BZ    VSERRRPL                * No: skip dumping ACB-data
         LR    R2,R15                  * Copy ACB-addr to usable reg.
         SHOWCB ACB=(R2),              * Retrieve info from current ACB*
               FIELDS=(ERROR),         *    copy error-code            *
               AREA=(S,UAVSAMRC),      *    into UAVSAMRC field        *
               LENGTH=4,               *    length of field = 4        *
               MF=(G,UAWORKAR+ERRWTOLV,SHOWACLV) use UAWORKAR for plist
         LA    R2,UAWORKAR             * Point to workarea again
         LTR   R15,R15                 * Was showcb ok ??
         BZ    VSERRAC2                * Yes: dumping is ok
         MVC   50(8,R2),=CL8'*UNKNOWN' * Error-text
         B     VSERRAC3                * Continue dumping VASM-info
*
VSERRAC2 L     R14,UAVSAMRC            * Get reasoncode from ACB
         BAS   R1,TOHEX                * Dump reasoncode, retadr in R1
         MVC   50(8,R2),4(R2)          * and move to correct location
*
VSERRAC3 MVC   29(21,R2),=CL21' contains reasoncode ' add error text
         L     R14,FDBACB              * Retrieve ACB-address
         BAS   R1,TOHEX                * Dump reasoncode, retadr in R1
         MVC   21(8,R2),4(R2)          * and move to correct location
         MVC   12(9,R2),=CL9': ACB at ' * Insert preceding text
         MVC   4(8,R2),FDBDDNAM        * Add ddname of file in error
         WTO   MF=(E,(R2))             * and display information
*
* Now dump RPL-data if present
*
VSERRRPL EQU   *
         MVI   4(R2),C' '              * Set blank in 1st text position
         MVC   5(L'WTOTEXT-1,R2),4(R2) * Wipe default text
         L     R15,FDBRPL              * Retrieve address of RPL
         LTR   R15,R15                 * Is it valid ??
         BZ    VSERREX                 * No: quit dumping
*
         USING IFGRPL,R15              * Temp. addressability to RPL
         MVC   UAVSAMRC,RPLFDBWD       * Copy feedback word from RPL
         DROP  R15                     * Quit RPL-addressability
         L     R14,UAVSAMRC            * Get reasoncode from RPL
         BAS   R1,TOHEX                * Dump reasoncode, retadr in R1
         MVC   50(8,R2),4(R2)          * and move to correct location
         MVC   29(21,R2),=CL21' contains fdbk-code  ' Add error text
*
         L     R14,FDBRPL              * Retrieve ACB-address
         BAS   R1,TOHEX                * Dump reasoncode, retadr in R1
         MVC   21(8,R2),4(R2)          * And move to correct location
         MVC   12(9,R2),=CL9': RPL at ' *Insert preceding error text
         MVC   4(8,R2),FDBDDNAM        * Add DDNAME of file in error
         WTO   MF=(E,(R2))             * and display information
*
VSERREX  L     R14,UAERXSAV            * Retrieve return address
         BR    R14                     * And return to error handler
*
         EJECT
*
* TOHEX assumes a WTO in list form at (R2), the fullword to be dumped
* is in register 14, and will be put in the WTO at positions 0-15.
* Register 15 is corrupted, return address is supposed to be in R1.
*
TOHEX    EQU   *                       * Exit to error routine
         LR    R0,R1                   * Save return address
         LA    R1,7                    * Set loop counter
*
TOHEXLUP XR    R15,R15                 * Clear register
         SRDL  R14,4                   * Retrieve nibble from the right
         SRL   R15,28                  * And place it rightmost in R15
         STC   R15,4(R1,R2)            * Store nibble in message
         BCT   R1,TOHEXLUP             * And go get next nibble
         STC   R14,4(R1,R2)            * Store last remaining nibble
         L     R14,=AL4(HEXTAB)        * Retrieve addr of hexchar-table
         TR    4(8,R2),0(R14)          * Translate nibbles to chars
         LR    R1,R0                   * Retrieve return address
         BR    R1                      * And return to error handler
*
* Drop all general base registers currently in use
*
         DROP  R3                      * Base register for csect
         DROP  R4                      * Base to BXAIOPRM
         DROP  R5                      * Base to 'current' FDB
*
ERROREND EQU   *
*
&ERR     SETB  0                       * No longer assembling the
*                                      *           error-routine
         EJECT
*
* This routine resets the base register after execution of a subroutine
* That uses its own addressability.
* Upon entry R3  contains the address of RSETBASE
*            R14 contains the address to be returned to
* Upon exit  R3  must contain the base address associated with the
*                address in R14
*            all other registers should remain unchanged
*
* The table of base addresses is supposed to be ordered in descending
* order. Therefore the first element we find containing an address less
* than the return address in R14 must be the associated base address.
*
         USING RSETBASE,R3
RSETBASE EQU   *
         LA    R14,0(R14)              * Strip hi-order bits of ret-adr
         L     R1,=AL4(BASETAB)        * Get address of table to search
*
RSETLOOP C     R14,0(R1)               * R14 >= (GE) table entry??
         BNL   RSETDONE                * Yes: go use the entry
         LA    R1,8(R1)                * No: get next element
         B     RSETLOOP                * And go see if it matches
*
RSETDONE EQU   *
         C     R14,4(R1)               * End-of-section >= retaddr ?
         BL    RSETOK                  * Yes: base-addr valid, use it
         C     R14,UALV1SAV            * UALV1SAV is valid ??
         BE    RSETEXIT                * No: return to emergency exit
         L     R14,UALV1SAV            * Yes: return to mainline
         B     RSETERR                 * After issuing the error
*
RSETEXIT L     R14,=AL4(EXIT)          * After error: exit program
*
RSETERR  LA    R15,056                 * Load error number
         L     R3,=AL4(ERROR)          * Load address of error handler
         BR    R3                      * and execute error handler
*
RSETOK   L     R3,0(R1)                * Get the correct base address
         BR    R14                     * and return to caller's caller
*
         DROP  R3
         DROP  R13
*
RSETBEND EQU   *
*
         AIF   (NOT &DBG).RSNAP        * RSNAP only in test mode
         EJECT
*
         LCLA  &SNAPLEN                * Var for length of snaplist
&SNAPLEN SETA  (4+8*&AANTFIL)*8        * Maxnr of entries*entry-length
*
         USING RSNAP,R15
*
* This routine produces a snap dump of the most relevant control blocks
* Since standard mvs-linkage conventions are used, there is no need
* to return through the rsetbase-routine.
*
RSNAP    EQU   *                       * Snap dump routine
         USING DSUSERAR,R13            * R13 still points to USERAREA
         TM    UASTAT,UASNAPER         * Snap-error occurred ??
         BNO   RSNAP00                 * Yes: return immediate
         XR    R15,R15                 * Set return-code
         BR    R14                     * And return immediate
*
RSNAP00  STM   R14,R12,SAVEDR14(R13)   * Save caller's registers
         DROP  R15                     * Switch base register
         USING RSNAP,R3                * to register 3
         LR    R3,R15                  * and load base register
         XR    R15,R15                 * Set return code to zero
         L     R14,UASNAPTR            * Get address of snap-area
         LTR   R14,R14                 * Is it valid ??
         BNZ   RSNAP10                 * Yes: continue
         GETMAIN RC,                   * Try to allocate snaparea      *
               SP=&SP,                 *    in our own subpool         *
               LV=L'SNAPAREA           *    specifying its length
         LTR   R15,R15                 * Storage allocated ??
         BZ    RSNAP05                 * Yes
         LA    R15,075                 * Load error code
         B     RSNAPXI2                * And exit snap-rout
*
RSNAP05  ST    R1,UASNAPTR             * Save addr of acquired storage
         LR    R14,R1                  * Copy address
         DROP  R13                     * USERAREA no longer addressable
*
RSNAP10  EQU   *                       * R14 points to new save-area
         ST    R13,SAVEPREV(R14)       * Set backward pointer
         ST    R14,SAVENEXT(R13)       * and forward pointer
         LR    R13,R14                 * and establish new save-area
         USING DSSNAP,R13              * Set snap-block addressable
*
         L     R14,SAVEPREV(R13)       * Get address of USERAREA
         USING DSUSERAR,R14            * Address USERAREA
         TM    UASTAT,UASNAPOP         * Snap is open ??
         BO    RSNAP30                 * Yes: skip opening
         MVC   SNAPDCB,SNAP            * Copy default DCB
         MVC   UAWORKAR(SNAPOPLV),SNAPOPEN * Copy plist for open macro
         LA    R9,UAWORKAR             * And point to modifiable plist
         LA    R2,SNAPDCB              * Point to the copied DCB
         DROP  R14                     * End of addressability
         OPEN  ((R2)),                 * Open the sysudump file        *
               MF=(E,(R9))             *      using a copy of the
*                                      *        default plist
         LTR   R15,R15                 * Open was ok??
         BZ    RSNAP20                 * Yes: continue
         LA    R15,076                 * Load error code
         B     RSNAPXIT                * And quit snapping
*
RSNAP20  L     R14,SAVEPREV(R13)       * Get address of USERAREA
         USING DSUSERAR,R14            * Address USERAREA
         MVI   SNAPIDNR,X'00'          * Set initial snap-id to zero
         OI    UASTAT,UASNAPOP         * Indicate snap-file is open
         DROP  R14                     * End of addressability
*
RSNAP30  LA    R10,SNAPHDRS            * R10 is pointer in headers list
         LA    R6,SNAPLIST             * R6 is pointer in SNAPLIST
         LR    R8,R6                   * First dump the snaparea
         LA    R9,L'SNAPAREA-1(R8)     *    so we can see all beginning
*                                      *    and ending addresses
         LA    R2,SNAPHD01             * Get address of header
         BAS   R14,RSNAPSET            * Put the adresses in the list
*
         L     R8,SAVEPREV(R13)        * Get address of USERAREA
         L     R8,SAVEPREV(R8)         * Get addr of previous save-area
         L     R8,SAVEDR1(R8)          * Get plist-pointer at entry
         L     R8,0(R8)                * Get address of BXAIOPRM
         LA    R8,0(R8)                * Strip end-of-plist-bit
         LA    R9,L'BXAIOPRM-1(R8)     * Get ending addr of dump-area
         LA    R2,SNAPHD02             * Get address of header
         BAS   R14,RSNAPSET            * Put range R8-R9 in SNAPLIST
*
         L     R8,SAVEPREV(R13)        * Get address of USERAREA
         L     R8,SAVEPREV(R8)         * Get addr of previous save-area
         L     R8,SAVEDR1(R8)          * Get plist-pointer at entry
         L     R8,4(R8)                * Get address of LNSPRM2
         LA    R8,0(R8)                * Strip end-of-plist-bit
         LA    R9,L'LNSPRM2-1(R8)      * Get ending addr of dump-area
         LA    R2,SNAPHD03             * Get address of header
         BAS   R14,RSNAPSET            * Put range R8-R9 in SNAPLIST
*
         L     R8,SAVEPREV(R13)        * Get address of old savearea
         LR    R4,R8                   *    which is the user-area
         USING DSUSERAR,R4             * and establish addressability
         LA    R9,L'USERAREA-1(R8)     * Get ending addr of dump-area
         LA    R2,SNAPHD04             * Get address of header
         BAS   R14,RSNAPSET            * Put range R8-R9 in SNAPLIST
*
         LA    R5,UAFDBPTR             * Setup base pointer for loop
         USING DSFDB,R5                * And establish addressability
RSNAPLUP L     R5,FDBNEXT              * Point next FDB
         LTR   R5,R5                   * All FDBs done ??
         BE    RSNAPDO                 * Yes: go dump
*
RSNAPFDB EQU   *
         LR    R8,R5                   * Start address for of FDB
         LA    R9,L'FDB-1(R8)          * And end address of FDB
         LA    R2,SNAPHD05             * Get address of header
         BAS   R14,RSNAPSET            * And setup SNAPLIST
*
RSNAPACB EQU   *
         L     R8,FDBACB               * Get address of ACB
         LTR   R8,R8                   * Valid ??
         BZ    RSNAPRPL                * No: go on to the RPL
         LA    R9,IFGACBLV-1           * Get length - 1
         LA    R9,0(R8,R9)             * Get end address
         LA    R2,SNAPHD06             * Get address of header
         BAS   R14,RSNAPSET            * And setup SNAPLIST
*
RSNAPRPL EQU   *
         L     R8,FDBRPL               * Get address of RPL
         LTR   R8,R8                   * Valid ??
         BZ    RSNAPREC                * No: go on to the record
         LA    R9,IFGRPLLV-1           * Get length - 1
         LA    R9,0(R8,R9)             * Get end address
         LA    R2,SNAPHD07             * Get address of header
         BAS   R14,RSNAPSET            * And setup SNAPLIST
*
         USING IFGRPL,R8               * Address RPL
         L     R8,RPLPLHPT             * Get address of placeholder
         DROP  R8
         LTR   R8,R8                   * Valid ??
         BZ    RSNAPREC                * No: go on to the record
         LA    R9,IDAPLHLV-1           * Get length - 1
         LA    R9,0(R8,R9)             * Get end address
         LA    R2,SNAPHD08             * Get address of header
         BAS   R14,RSNAPSET            * And setup SNAPLIST
         AIF   (&OPT).RSNAPRC          * Skip PLH and control-interval
         LR    R15,R8                  * Save PLH-pointer
         USING IDAPLH,R15              * Address PLH by its DSECT
         L     R8,PLHDBUFC             * Point to bufc-block
         DROP  R15                     * End of addressability to PLH
         LTR   R8,R8                   * Valid ??
         BZ    RSNAPREC                * No: go on to the record
         LH    R9,=H'79'               * Get length - 1
         LA    R9,0(R8,R9)             * Get end address
         LA    R2,SNAPHD09             * Get address of header
         BAS   R14,RSNAPSET            * And setup SNAPLIST
*
         L     R8,FDBRPL               * Get address of RPL
         USING IFGRPL,R8               * Address RPL
         L     R8,RPLPLHPT             * Get address of placeholder
         DROP  R8
         LR    R15,R8                  * Save PLH-pointer
         USING IDAPLH,R15              * Address PLH by its DSECT
         L     R8,PLHRECP              * Addr of current record in buf
         DROP  R15                     * End of addressability to PLH
         LTR   R8,R8                   * Valid ??
         BZ    RSNAPREC                * No: go on to the record
         LH    R9,=H'32767'            * Get length - 1
         LA    R9,0(R8,R9)             * Get end address of buffer
         LA    R2,SNAPHD10             * Get address of header
         BAS   R14,RSNAPSET            * And setup SNAPLIST
*
.RSNAPRC ANOP
*
RSNAPREC EQU   *
         L     R8,FDBREC               * Get addr of record in buffer
         LTR   R8,R8                   * Valid ??
         BZ    RSNAPWAR                * No: go on to the workarea
         LH    R9,FDBRECLV             * Get length
         LA    R9,0(R8,R9)             * Get end address + 1
         BCTR  R9,R0                   * and decrement to get end
         LA    R2,SNAPHD11             * Get address of header
         BAS   R14,RSNAPSET            * and setup SNAPLIST
*
RSNAPWAR EQU   *
         L     R8,FDBWAREA             * Get addr of record in workarea
         LTR   R8,R8                   * Valid ??
         BZ    RSNAPNXT                * No: go on to next FDB
         LH    R9,FDBRECLV             * Get length
         LA    R9,0(R8,R9)             * Get end address + 1
         BCTR  R9,R0                   * and decrement to get end
         LA    R2,SNAPHD12             * Get address of header
         BAS   R14,RSNAPSET            * and setup SNAPLIST
*
RSNAPNXT EQU   *
         B     RSNAPLUP                * Go try next FDB
*
RSNAPDO  EQU   *
         SH    R6,=H'4'                * Point last used entry in
*                                      *              SNAPLIST
         OI    0(R6),X'80'             * Insert end-of-list indicator
         SH    R10,=H'4'               * Point last used entry in
*                                      *              HDRLIST
         OI    0(R10),X'80'            * Insert end-of-list indicator
         XR    R2,R2                   * Clear register
         IC    R2,SNAPIDNR             * and get last snapid-nr
         LA    R2,1(R2)                * Increment id-nr
         STC   R2,SNAPIDNR             * Save snapid-nr for next call
         LA    R6,SNAPLIST             * Reload start of SNAPLIST
         LA    R7,SNAPHDRS             * Load start of header-list
         LA    R8,SNAPDCB              * Load address of DCB
*********************************************************************
* This change implemented on 9-7-2001: 4 lines removed
* R4 still points to SAVEAREA in DSUSERAR, no need to use R9
*        L     R9,SAVEPREV(R13)        * Load address of USERAREA
*        USING DSUSERAR,R9             * And establish addressability
         MVC   UAWORKAR(RSNAPPLV),RSNAPSNP * copy coding of MF=L macro
*        LA    R9,UAWORKAR             * Point to the macro's coding
*        DROP  R9                      * End addressability of USERAREA
* End of change dated 9-7-2001
**********************************************************************
         SNAP  MF=(E,(R9)),            * Make dump, using remote plist *
               DCB=(R8),               *    dump snap to this DCB      *
               ID=(R2),                *    use incremented snap-id nr *
               LIST=(R6),              *    list of storage ranges     *
               STRHDR=(R7)             *    list of storage headers
         LTR   R2,R15                  * Snap was ok ??
         BE    RSNAPXIT                * Yes: exit snap-routine
         LA    R15,077                 * Load error code
*
RSNAPXIT EQU   *
         LR    R15,R2                  * R2 contains SNAP's returncode
         L     R13,SAVEPREV(R13)       * Get addr of previous save-area
*
RSNAPXI2 EQU   *
         L     R14,SAVEDR14(R13)       * Reload return address
         LM    R0,R12,SAVEDR0(R13)     * Reload caller's registers
         BR    R14                     * and return
*
RSNAPSET EQU   *                       * Put storage range in snaplist
         LA    R15,SNAPHDRS            * Point beyond snaplist
         CR    R6,R15                  * Enough room in plist ??
         BL    RSNAPSE2                * Yes: put addresses in plist
         LA    R15,081                 * Load error nr
         B     RSNAPXIT                * And exit to issue error
*
RSNAPSE2 ST    R8,0(R6)                * Put start-address of range
         ST    R9,4(R6)                * and end address in snaplist
         LA    R6,8(R6)                * Have pointer point to next one
         ST    R2,0(R10)               * Store dump header address
         LA    R10,4(R10)              * Point to next free hdr entry
         BR    R14                     * Return
*
         DROP  R3                      * Drop base register
         DROP  R4                      * Drop pointer to savearea
         DROP  R5                      * Drop FDB-pointer
*
RSNAPEND EQU   *
*
         DROP  R13                     * Drop snap-block pointer
*
         EJECT
*
* Snapheader entries
*
         DS    0F
SNAPHD01 DC    AL1(L'SNAPHD51)
SNAPHD51 DC    C'SNAPAREA - address ranges to be dumped etc.'
         DS    0F
SNAPHD02 DC    AL1(L'SNAPHD52)
SNAPHD52 DC    C'BXAIOPRM - input parameter from application'
         DS    0F
SNAPHD03 DC    AL1(L'SNAPHD53)
SNAPHD53 DC    C'LNSPRM2  - parameter for internal control information'
         DS    0F
SNAPHD04 DC    AL1(L'SNAPHD54)
SNAPHD54 DC    C'USERAREA - data related with one caller'
         DS    0F
SNAPHD05 DC    AL1(L'SNAPHD55)
SNAPHD55 DC    C'FDB      - file definition block'
         DS    0F
SNAPHD06 DC    AL1(L'SNAPHD56)
SNAPHD56 DC    C'ACB      - access method control block'
         DS    0F
SNAPHD07 DC    AL1(L'SNAPHD57)
SNAPHD57 DC    C'RPL      - request parameter list'
         DS    0F
SNAPHD08 DC    AL1(L'SNAPHD58)
SNAPHD58 DC    C'PLH      - placeholder'
         DS    0F
SNAPHD09 DC    AL1(L'SNAPHD59)
SNAPHD59 DC    C'BUFC     - buffer control block (entry)'
         DS    0F
SNAPHD10 DC    AL1(L'SNAPHD60)
SNAPHD60 DC    C'VSAM.CI  - complete VSAM control interval'
         DS    0F
SNAPHD11 DC    AL1(L'SNAPHD61)
SNAPHD61 DC    C'RECORD   - record in data buffer'
         DS    0F
SNAPHD12 DC    AL1(L'SNAPHD62)
SNAPHD62 DC    C'WORKAREA - record work-area for insert/delete'
*
         SPACE 3
RSNAPSNP SNAP  DCB=0,                  * Addr known only at run-time   *
               ID=0,                   * Id-nr incremented each snap   *
               LIST=0,                 * Dumping storage ranges        *
               STRHDR=0,               * Specifying headers per range  *
               PDATA=(PSW,REGS,SA,SAH), *Specify what to dump          *
               MF=L
RSNAPPLV EQU   *-RSNAPSNP              * Length for move of plist
*
SNAP     DCB   DDNAME=SYSUDUMP,        * Use DDNAME sysudump for snaps *
               DSORG=PS,                                               *
               MACRF=W,                                                *
               LRECL=125,                                              *
               BLKSIZE=1632,                                           *
               RECFM=VBA
SNAPDCBL EQU   *-SNAP                  * Length required for this DCB
*
SNAPOPEN OPEN  (0,(OUTPUT)),           * Open DCB for snap-output      *
               MODE=31,                * 31-bit addressing             *
               MF=L                    * DCB address not yet known
SNAPOPLV EQU   *-SNAPOPEN              * Set length for move of plist
*
.RSNAP   ANOP
         EJECT
         DROP  R11                     * Drop data-area pointer
         DS    0D                      * Realign on doubleword boundary
***********************************************************************
* Change implemented on 9-7-2001: put CONST area in a separate CSECT
* CONST  EQU   *
CONST    CSECT
* End of change dated 9-7-2001
***********************************************************************
         LTORG
*
         EJECT
*
* Non-executable code, plists, macros etc.....
*
WTOTEXT  DS    0CL64                   * Max text length is 64 chars
ERRWTO   WTO   '1234567890123456789012345678901234567890123456789012345*
               678901234',             * 64 positions reserved for text*
               ROUTCDE=11,             * Routing-code                  *
               DESC=7,                 * Descriptor-code               *
               MF=L
ERRWTOLV EQU   *-ERRWTO                * Set length for move of plist
*
         DS    0D                      * Realign on doubleword boundary
NUMTAB   DC    240X'FF'                * This table is used with TRT to
         DC    10X'00'                 *  check that any required key
         DC    6X'FF'                  *  values be decently numeric.
*
HEXTAB   DC    C'01234567'             * This table is used with TR to
         DC    C'89ABCDEF'             *  translate nibbles into EBCDIC
         DC    240C' '                 *  characters.
*
SEEKSPC  DC    64X'00'                 * This table is used with TRT to
         DC    X'FF'                   *  find the first blank in a
         DC    191X'00'                *  DDNAME.
*
         SPACE 3
*
* BASETAB is a table with all addresses that are used as base addresses
* in the program. They are listed in reverse order. The table is used
* to find the base address associated with a given return address.
* Before returning to a return address R3 (the base register) must be
* given the correct value from the table. That is: the first value
* in the table that is less than or equal to the return address.
*
         CNOP  0,4                     * Realign on fullword boundary
BASETAB  EQU   *
         AIF   (&OPT).BASETB           * Skip some routines
         AIF   (NOT &DBG).BASETAB      * RSNAP invalid if not test
         DC    AL4(RSNAP),AL4(RSNAPEND)    * Is never returned to
.BASETAB ANOP
         DC    AL4(RSETBASE),AL4(RSETBEND) * Is never returned to
         DC    AL4(ERROR),AL4(ERROREND)    * Is never returned to
.BASETB  ANOP
         DC    AL4(RCHECK),AL4(RCHEKEND)
         DC    AL4(PHASE4),AL4(FASE4END)
         DC    AL4(PHASE3),AL4(FASE3END)
         DC    AL4(PHASE2),AL4(FASE2END)
         DC    AL4(PHASE1),AL4(FASE1END)
         DC    F'0',F'0'                   * End-of-list marker
*
         EJECT
*
* Table of supported function codes (opcodes)
* The bit coding corresponds to FDBREQ. The close-request bit
* is used double: it is also used to indicate update mode for
* open processing. The open routine will have to reset this bit,
* to prevent the data set from being closed in the same call.
* The order of opcodes in this table is designed for optimum efficiency
* in the process of looking up the requested function code.
*
OPCODES  DS    0D
         DC    CL2'RS',B'00100000',X'00',AL4(CHECKRS)
         DC    CL2'RR',B'00100000',X'00',AL4(CHECKRR)
         DC    CL2'WS',B'00010000',X'00',AL4(CHECKWS)
         DC    CL2'WR',B'00010000',X'00',AL4(CHECKWR)
         DC    CL2'SK',B'01000000',X'00',AL4(CHECKSK)
         DC    CL2'SN',B'01100000',X'00',AL4(CHECKSN)
         DC    CL2'IR',B'00001000',X'00',AL4(CHECKIR)
         DC    CL2'DR',B'00000100',X'00',AL4(CHECKDR)
         DC    CL2'SI',B'11100000',X'00',AL4(CHECKOI)
         DC    CL2'RI',B'10100001',X'00',AL4(CHECKOI)
         DC    CL2'SU',B'11100010',X'00',AL4(CHECKOU)
         DC    CL2'RU',B'10100011',X'00',AL4(CHECKOU)
         AIF   (NOT &DBG).OPCODE
         DC    CL2'WN',B'00110000',X'00',AL4(CHECKWN)
         DC    CL2'DN',B'00100100',X'00',AL4(CHECKDN)
         DC    CL2'SD',B'00000000',X'00',AL4(CHECKSD)
.OPCODE  ANOP
OPCODEND DC    CL2'CA',B'00000010',X'00',AL4(CHECKCA)
         DC    CL2'  ',B'00000000',X'00',AL4(CHECKXX)
* Last element forces error (invalid fcode in parm)
*
         EJECT
*
* VSAM macros
*
         GBLA  &DBUF,&IBUF             * Nr of data and index buffers
&DBUF    SETA  8*&AANTFIL              * 8 databuffers per seq. file
&IBUF    SETA  160*&AANTFIL            * 160 indexbuffers / random file
*
BLDVRPD  BLDVRP BUFFERS=(22528(&DBUF)), *Allocate VSAM resource pool   *
               TYPE=(LSR,DATA),        * Local shared, for data buffers*
               STRNO=&AANTFIL,         * Max nr. of concurrent requests*
               KEYLEN=&MAXKEY,         * Max key length to accommodate *
               SHRPOOL=0,              * Shrpool-nr                    *
               MODE=24,                * Plist in 24bit addressing mode*
               RMODE31=ALL,            * Buffers and control blocks in *
               MF=L                    *                high storage
BLDVRDLV EQU   *-BLDVRPD               * Set length for move of plist
*
BLDVRPI  BLDVRP BUFFERS=(512(&IBUF)),  * Allocate VSAM resource pool   *
               TYPE=(LSR,INDEX),       * Local shared, for index bufs  *
               STRNO=&AANTFIL,         * Max nr of concurrent requests *
               KEYLEN=&MAXKEY,         * Maximum key length            *
               SHRPOOL=0,              * Shrpool-nr                    *
               MODE=24,                * Plist in 24bit addressing mode*
               RMODE31=ALL,            * Buffers and control blocks in *
               MF=L                    *               high storage
BLDVRILV EQU   *-BLDVRPI               * Set length for move of plist
*
         SPACE 3
*
* All gencb-macros below generate a plist in the UAWORKAR-field,
* The plist can the be modified by the program (ROP-routine)
* before the control block is actually generated.
*
         USING DSUSERAR,R13            * Valid for all gencb-macros
         USING DSFDB,R5                * Valid for all gencb-macros
*
ACBTAB   EQU   *                       * Table with addresses of GENCB
         DC    AL4(GENACLIS)           *  plists for generating an ACB
         DC    AL4(GENACLIR)           *
         DC    AL4(GENACLUS)           *
         DC    AL4(GENACLUR)           * Using local shared resources
         DC    AL4(GENACPIS)           *  or private pools
         DC    AL4(GENACPIR)           *
         DC    AL4(GENACPUS)           *
         DC    AL4(GENACPUR)           *
*
         USING GENACLIS,R3
GENACLIS EQU   *
         GENCB BLK=ACB,                * Generate plist for gencb ACB  *
               AM=VSAM,                * Access method                 *
               WAREA=(R7),             * Location for generated ACB    *
               LENGTH=IFGACBLV,        * Max length for generated ACB  *
               DDNAME=(*,FDBDDNAM),    * Gencb ACB is to copy DDNAME   *
               SHRPOOL=(S,0(R6)),      * Shrpool-nr varies from 0-15   *
               MACRF=(KEY,DFR,SEQ,SKP,SIS,LSR), * Options for this ACB *
               BUFND=8,                * Minimum nr of data buffers    *
               BUFNI=1,                * Minimum nr of index buffers   *
               RMODE31=ALL,            * Buffer and control bl. > 16M  *
               MF=(L,UAWORKAR,GACLISLV) *Generate plist in UAWORKAR
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENACLIR,R3
GENACLIR EQU   *
         GENCB BLK=ACB,                * Generate plist for gencb ACB  *
               AM=VSAM,                * Access method                 *
               WAREA=(R7),             * Location for generated ACB    *
               LENGTH=IFGACBLV,        * Max length for generated ACB  *
               DDNAME=(*,FDBDDNAM),    * Gencb ACB is to copy DDNAME   *
               SHRPOOL=(S,0(R6)),      * Shrpool-nr varies from 0-15   *
               MACRF=(KEY,DFR,DIR,SIS,LSR), * Options for this ACB     *
               BUFND=2,                * Minimum nr of data buffers    *
               BUFNI=160,              * Minimum nr of index buffers   *
               RMODE31=ALL,            * Buffer and control bl. > 16M  *
               MF=(L,UAWORKAR,GACLIRLV) *Generate plist in UAWORKAR
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENACLUS,R3
GENACLUS EQU   *
         GENCB BLK=ACB,                * Generate plist for gencb ACB  *
               AM=VSAM,                * Access method                 *
               WAREA=(R7),             * Location for generated ACB    *
               LENGTH=IFGACBLV,        * Max length for generated ACB  *
               DDNAME=(*,FDBDDNAM),    * Gencb ACB is to copy DDNAME   *
               SHRPOOL=(S,0(R6)),      * Shrpool-nr varies from 0-15   *
               MACRF=(KEY,DFR,SEQ,SKP,IN,OUT,SIS,LSR), * ACB-options   *
               BUFND=8,                * Minimum nr of data buffers    *
               BUFNI=1,                * Minimum nr of index buffers   *
               RMODE31=ALL,            * Buffer and control bl. > 16M  *
               MF=(L,UAWORKAR,GACLUSLV) *Generate plist in UAWORKAR
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENACLUR,R3
GENACLUR EQU   *
         GENCB BLK=ACB,                * Generate plist for gencb ACB  *
               AM=VSAM,                * Access method                 *
               WAREA=(R7),             * Location for generated ACB    *
               LENGTH=IFGACBLV,        * Max length for generated ACB  *
               DDNAME=(*,FDBDDNAM),    * Gencb ACB is to copy DDNAME   *
               SHRPOOL=(S,0(R6)),      * Shrpool-nr varies from 0-15   *
               MACRF=(KEY,DFR,SEQ,SKP,IN,OUT,SIS,LSR), * ACB-options   *
               BUFND=2,                * Minimum nr of data buffers    *
               BUFNI=160,              * Minimum nr of index buffers   *
               RMODE31=ALL,            * Buffer and control bl. > 16M  *
               MF=(L,UAWORKAR,GACLURLV) *Generate plist in UAWORKAR
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENACPIS,R3
GENACPIS EQU   *
         GENCB BLK=ACB,                * Generate plist for gencb ACB  *
               AM=VSAM,                * Access method                 *
               WAREA=(R7),             * Location for generated ACB    *
               LENGTH=IFGACBLV,        * Max length for generated ACB  *
               DDNAME=(*,FDBDDNAM),    * Gencb ACB is to copy DDNAME   *
               SHRPOOL=(S,0(R6)),      * Shrpool-nr varies from 0-15   *
               MACRF=(KEY,DFR,SEQ,SKP,SIS,NSR), * Options for this ACB *
               BUFND=8,                * Minimum nr of data buffers    *
               BUFNI=1,                * Minimum nr of index buffers   *
               RMODE31=ALL,            * Buffer and control bl. > 16M  *
               MF=(L,UAWORKAR,GACPISLV) *Generate plist in UAWORKAR
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENACPIR,R3
GENACPIR EQU   *
         GENCB BLK=ACB,                * Generate plist for gencb ACB  *
               AM=VSAM,                * Access method                 *
               WAREA=(R7),             * Location for generated ACB    *
               LENGTH=IFGACBLV,        * Max length for generated ACB  *
               DDNAME=(*,FDBDDNAM),    * Gencb ACB is to copy DDNAME   *
               SHRPOOL=(S,0(R6)),      * Shrpool-nr varies from 0-15   *
               MACRF=(KEY,DFR,DIR,SIS,NSR), * Options for this ACB     *
               BUFND=2,                * Minimum nr of data buffers    *
               BUFNI=160,              * Minimum nr of index buffers   *
               RMODE31=ALL,            * Buffer and control bl. > 16M  *
               MF=(L,UAWORKAR,GACPIRLV) *Generate plist in UAWORKAR
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENACPUS,R3
GENACPUS EQU   *
         GENCB BLK=ACB,                * Generate plist for gencb ACB  *
               AM=VSAM,                * Access method                 *
               WAREA=(R7),             * Location for generated ACB    *
               LENGTH=IFGACBLV,        * Max length for generated ACB  *
               DDNAME=(*,FDBDDNAM),    * Gencb ACB is to copy DDNAME   *
               SHRPOOL=(S,0(R6)),      * Shrpool-nr varies from 0-15   *
               MACRF=(KEY,DFR,SEQ,SKP,IN,OUT,SIS,NSR), * ACB-options   *
               BUFND=8,                * Minimum nr of data buffers    *
               BUFNI=1,                * Minimum nr of index buffers   *
               RMODE31=ALL,            * Buffer and control bl. > 16M  *
               MF=(L,UAWORKAR,GACPUSLV) *Generate plist in UAWORKAR
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENACPUR,R3
GENACPUR EQU   *
         GENCB BLK=ACB,                * Generate plist for gencb ACB  *
               AM=VSAM,                * Access method                 *
               WAREA=(R7),             * Location for generated ACB    *
               LENGTH=IFGACBLV,        * Max length for generated ACB  *
               DDNAME=(*,FDBDDNAM),    * Gencb ACB is to copy DDNAME   *
               SHRPOOL=(S,0(R6)),      * Shrpool-nr varies from 0-15   *
               MACRF=(KEY,DFR,SEQ,SKP,IN,OUT,SIS,NSR), * ACB-options   *
               BUFND=2,                * Minimum nr of data buffers    *
               BUFNI=160,              * Minimum nr of index buffers   *
               RMODE31=ALL,            * Buffer and control bl. > 16M  *
               MF=(L,UAWORKAR,GACPURLV) *Generate plist in UAWORKAR
         BR    R10                     * Return to open routine
         DROP  R3
*
         SPACE 3
RPLTAB   EQU   *                       * Table with addresses of gencb
         DC    AL4(GENRPLIS)           * plists for generating an RPL
         DC    AL4(GENRPLIR)
         DC    AL4(GENRPLUS)
         DC    AL4(GENRPLUR)
*
         USING GENRPLIS,R3
GENRPLIS GENCB BLK=RPL,                * Generate plist for gencb RPL  *
               AM=VSAM,                * For VSAM files                *
               WAREA=(R9),             * Specify address for RPL       *
               LENGTH=IFGRPLLV,        * And length available          *
               ACB=(R7),               * Specify ACB-address for RPL   *
               AREA=(S,FDBREC),        * and data-area                 *
               AREALEN=4,              * Length of data-area           *
               ARG=(S,UAKEY),          * Specify key location          *
               KEYLEN=(S,0(R6)),       * and key length                *
               ECB=(S,FDBECB),         * Specify ECB-address           *
               RECLEN=(R8),            * and record length             *
               OPTCD=(KEY,SEQ,ASY,NUP,KGE,GEN,LOC), * Options for RPL  *
               MF=(G,UAWORKAR,GRPLISLV) *
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENRPLIR,R3
GENRPLIR GENCB BLK=RPL,                * Generate plist for gencb RPL  *
               AM=VSAM,                * For VSAM files                *
               WAREA=(R9),             * Specify address for RPL       *
               LENGTH=IFGRPLLV,        * And length available          *
               ACB=(R7),               * Specify ACB-address for RPL   *
               AREA=(S,FDBREC),        * and data-area                 *
               AREALEN=4,              * Length of data-area           *
               ARG=(S,UAKEY),          * Specify key location          *
               KEYLEN=(S,0(R6)),       * and key length                *
               ECB=(S,FDBECB),         * Specify ECB-address           *
               RECLEN=(R8),            * and record length             *
               OPTCD=(KEY,DIR,ASY,NUP,KEQ,FKS,LOC), * Options for RPL  *
               MF=(G,UAWORKAR,GRPLIRLV) *
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENRPLUS,R3
GENRPLUS GENCB BLK=RPL,                * Generate plist for gencb RPL  *
               AM=VSAM,                * For VSAM files                *
               WAREA=(R9),             * Specify address for RPL       *
               LENGTH=IFGRPLLV,        * and length available          *
               ACB=(R7),               * Specify ACB-address for RPL   *
               AREA=(S,FDBREC),        * and data-area                 *
               AREALEN=4,              * Length of data-area           *
               ARG=(S,UAKEY),          * Specify key location          *
               KEYLEN=(S,0(R6)),       * and key length                *
               ECB=(S,FDBECB),         * Specify ECB-address           *
               RECLEN=(R8),            * and record length             *
               OPTCD=(KEY,SEQ,ASY,UPD,KGE,GEN,LOC), * Options for RPL  *
               MF=(G,UAWORKAR,GRPLUSLV) *
         BR    R10                     * Return to open routine
         DROP  R3
*
         USING GENRPLUR,R3
GENRPLUR GENCB BLK=RPL,                * Generate plist for gencb RPL  *
               AM=VSAM,                * For VSAM files                *
               WAREA=(R9),             * Specify address for RPL       *
               LENGTH=IFGRPLLV,        * And length available          *
               ACB=(R7),               * Specify ACB-address for RPL   *
               AREA=(S,FDBREC),        * and data-area                 *
               AREALEN=4,              * Length of data-area           *
               ARG=(S,UAKEY),          * Specify key location          *
               KEYLEN=(S,0(R6)),       * and key length                *
               ECB=(S,FDBECB),         * Specify ECB-address           *
               RECLEN=(R8),            * and record length             *
               OPTCD=(KEY,DIR,ASY,UPD,KEQ,FKS,LOC), * Options for RPL  *
               MF=(G,UAWORKAR,GRPLURLV) *
         BR    R10                     * Return to open routine
         DROP  R3
*
         DROP  R5                      * FDB no longer valid
         DROP  R13                     * USERAREA no longer valid
         SPACE 3
VSAMOPEN OPEN  (0),                    * Open VSAM file                *
               MODE=31,                * 31-bit addressing             *
               MF=L                    * ACB-address not yet known
VSAMOPLV EQU   *-VSAMOPEN              * Set length for move of plist
CLOSE    CLOSE (0),                    * Close a file                  *
               MODE=31,                * 31-bit addressing             *
               MF=L                    * ACB/DCB-address unknown
CLOSELV  EQU   *-CLOSE                 * Set length for move of plist
*
         EJECT
*
* Default file descriptor blocks
*
CCDFDB   DS    0D
         DC    AL4(CPDFDB)
         DC    F'0'
         DC    CL8'CCD     '
         DC    6F'0'
         DC    AL4(CCDMAP)
         DC    2H'0'
         DC    H'350'
         DC    AL1(14)
         DC    X'00'
         DC    7X'00'
         DC    CL14'00000000000000',X'00' * Key of version record
         DC    CL14' ',X'00'
         DC    7X'00'
*
         SPACE 3
CPDFDB   DS    0D
         DC    AL4(CCXFDB)
         DC    F'0'
         DC    CL8'CPD     '
         DC    6F'0'
         DC    AL4(CPDMAP)
         DC    2H'0'
         DC    H'300'
         DC    AL1(15)
         DC    X'01'
         DC    7X'00'
         DC    CL15'000000000000000'   * Key of version record
         DC    CL15' '
         DC    7X'00'
*
         SPACE 3
CCXFDB   DS    0D
         DC    AL4(PDDFDB)
         DC    F'0'
         DC    CL8'CCX     '
         DC    6F'0'
         DC    AL4(CCXMAP)
         DC    2H'0'
         DC    H'74'
         DC    AL1(14)
         DC    X'02'
         DC    7X'00'
         DC    CL14'00000000000000',X'00' * Key of version record
         DC    CL14' ',X'00'
         DC    7X'00'
*
         SPACE 3
PDDFDB   DS    0D
         DC    AL4(CSCFDB)
         DC    F'0'
         DC    CL8'PDD     '
         DC    6F'0'
         DC    AL4(PDDMAP)
         DC    2H'0'
         DC    H'42'
         DC    AL1(14)
         DC    X'03'
         DC    7X'00'
         DC    CL14'00000000000000',X'00' * Key of version record
         DC    CL14' ',X'00'
         DC    7X'00'
*
         SPACE 3
CSCFDB   DS    0D
         DC    AL4(ACDFDB)
         DC    F'0'
         DC    CL8'CSC     '
         DC    6F'0'
         DC    AL4(CSCMAP)
         DC    2H'0'
         DC    H'47'
         DC    AL1(14)
         DC    X'04'
         DC    7X'00'
         DC    CL14'00000000000000',X'00' * Key of version record
         DC    CL14' ',X'00'
         DC    7X'00'
*
         SPACE 3
ACDFDB   DS    0D
         DC    F'0'
         DC    F'0'
         DC    CL8'ACD     '
         DC    6F'0'
         DC    AL4(ACDMAP)
         DC    2H'0'
         DC    H'46'
         DC    AL1(14)
         DC    X'05'
         DC    7X'00'
         DC    CL14'00000000000000',X'00' * Key of version record
         DC    CL14' ',X'00'
         DC    7X'00'
*
         SPACE 3
*
* Data map-lists defining mapping of data between record and parameter
*
CCDMAP   DC    H'0'                    * Nr of elements after this one
         DC    CL2'01'                 * Version number
         DC    AL4(CCD01)              * Start addr of map version 01
*
CCD01    DC    H'0'                    * Nr of elements after this one
         DC    H'350'                  * Data length
         DC    AL2(17)                 * Offset in parameter
         DC    H'0'                    * Offset in record
*
CPDMAP   DC    H'0'                    * Nr of elements after this one
         DC    CL2'02'                 * Version number
         DC    AL4(CPD01)              * Start addr of map version 02
*
CPD01    DC    H'0'                    * Nr of elements after this one
         DC    H'300'                  * Data length
         DC    AL2(18)                 * Offset in parameter
         DC    H'0'                    * Offset in record
*
CCXMAP   DC    H'0'                    * Nr of elements after this one
         DC    CL2'03'                 * Version number
         DC    AL4(CCX01)              * Start addr of map version 03
*
CCX01    DC    H'0'                    * Nr of elements after this one
         DC    H'74'                   * Data length
         DC    AL2(17)                 * Offset in parameter
         DC    H'0'                    * Offset in record
*
PDDMAP   DC    H'0'                    * Nr of elements after this one
         DC    CL2'04'                 * Version number
         DC    AL4(PDD01)              * Start addr of map version 04
*
PDD01    DC    H'0'                    * Nr of elements after this one
         DC    H'42'                   * Data length
         DC    AL2(17)                 * Offset in parameter
         DC    H'0'                    * Offset in record
*
CSCMAP   DC    H'0'                    * Nr of elements after this one
         DC    CL2'05'                 * Version number
         DC    AL4(CSC01)              * Start addr of map version 05
*
CSC01    DC    H'0'                    * Nr of elements after this one
         DC    H'47'                   * Data length
         DC    AL2(17)                 * Offset in parameter
         DC    H'0'                    * Offset in record
*
ACDMAP   DC    H'0'                    * Nr of elements after this one
         DC    CL2'06'                 * Version number
         DC    AL4(ACD01)              * Start addr of map version 05
*
ACD01    DC    H'0'                    * Nr of elements after this one
         DC    H'46'                   * Data length
         DC    AL2(17)                 * Offset in parameter
         DC    H'0'                    * Offset in record
*
         EJECT
*
* Error codes: error text + returncode + reasoncode + error exit addr
*
* Whenever returncodes are changed: do check that returning is done
* correctly for all locations where the error is initiated.
*
ERRORTAB DS    0D
         AIF   (&DBG).ERROR1
         DC    CL50' 1 - sequential end-of-file has been reached'
         DC    CL6'      ',X'00',C'1',H'001',F'0'
         DC    CL50' 2 - requested record not found'
         DC    CL6'      ',X'04',C'1',H'002',AL4(VSERR)
         AGO   .ERROR1A
.ERROR1  ANOP
         DC    CL50'01 - sequential end-of-file has been reached'
         DC    CL6'      ',X'00',C'1',H'001',F'0'
         DC    CL50'02 - requested record not found'
         DC    CL6'      ',X'04',C'1',H'002',AL4(VSERR)
.ERROR1A ANOP
         DC    CL50'03 - file selector not 0 or 1: 0 assumed'
         DC    CL6'      ',X'00',C'2',H'003',F'0'
         DC    CL50'04 - no files selected, request ignored'
         DC    CL6'      ',X'00',C'2',H'004',F'0'
         DC    CL50'05 - file is open: open request ignored'
         DC    CL6'      ',X'00',C'2',H'005',F'0'
         DC    CL50'06 - file is not open: close request ignored'
         DC    CL6'      ',X'00',C'2',H'006',F'0'
         DC    CL50'07 - cannot read sequential, trying random read'
         DC    CL6'      ',X'00',C'2',H'007',F'0'
         DC    CL50'08 - cannot read random, trying sequential read'
         DC    CL6'      ',X'00',C'2',H'008',F'0'
         DC    CL50'09 - cannot write sequential, trying random write'
         DC    CL6'      ',X'00',C'2',H'009',F'0'
         DC    CL50'10 - cannot write random, trying sequential write'
         DC    CL6'      ',X'00',C'2',H'010',F'0'
         DC    CL50'11 - ECB unexpectedly in use, skip postponed'
         DC    CL6'      ',X'04',C'2',H'011',F'0'
         DC    CL50'12 - ECB unexpectedly in use, read postponed'
         DC    CL6'      ',X'04',C'2',H'012',F'0'
         DC    CL50'13 - ECB unexpectedly in use, write postponed'
         DC    CL6'      ',X'04',C'2',H'013',F'0'
         DC    CL50'14 - ECB unexpectedly in use, insert postponed'
         DC    CL6'      ',X'04',C'2',H'014',F'0'
         DC    CL50'15 - ECB unexpectedly in use, delete postponed'
         DC    CL6'      ',X'04',C'2',H'015',F'0'
         DC    CL50'16 - ECB unexpectedly in use, close postponed'
         DC    CL6'      ',X'04',C'2',H'016',F'0'
         DC    CL50'17 - VSAM resource pool could not be allocated'
         DC    CL6'      ',X'00',C'2',H'017',AL4(VSERR)
         DC    CL50'18 - VSAM resource pool could not be freed'
         DC    CL6'      ',X'00',C'2',H'018',AL4(VSERR)
         DC    CL50'19 - cannot open input: file is open for update'
         DC    CL6'      ',X'00',C'2',H'019',F'0'
         DC    CL50'20 - key length not changed for skip'
         DC    CL6'      ',X'04',C'2',H'020',AL4(VSERR)
         DC    CL50'21 - file closed, last update was not version rec'
         DC    CL6'      ',X'00',C'2',H'021',F'0'
         DC    CL50'22 - ACB/RPL-storage could not be freed'
         DC    CL6'      ',X'00',C'2',H'022',F'0'
         DC    CL50'23 - cannot obtain storage for ACB/RPL'
         DC    CL6'      ',X'00',C'5',H'023',F'0'
         DC    CL50'24 - workarea for insert/delete could not be freed'
         DC    CL6'      ',X'00',C'2',H'024',F'0'
         DC    CL50'25 - storage for USERAREA/FDB could not be freed'
         DC    CL6'      ',X'00',C'2',H'025',AL4(UAERR)
         DC    CL50'26 - no input parameter'
         DC    CL6'      ',X'00',C'3',H'026',AL4(UAERR)
         DC    CL50'27 - requested function code not supported'
         DC    CL6'      ',X'00',C'3',H'027',F'0'
         DC    CL50'28 - requested version of parameter not supported'
         DC    CL6'      ',X'00',C'3',H'028',F'0'
         DC    CL50'29 - file version records are not equal'
         DC    CL6'      ',X'00',C'3',H'029',F'0'
         DC    CL50'30 - cannot open update: file is open for input'
         DC    CL6'      ',X'00',C'3',H'030',F'0'
         DC    CL50'31 - file is not open, skip request ignored'
         DC    CL6'      ',X'00',C'3',H'031',F'0'
         DC    CL50'32 - file is not open, read request ignored'
         DC    CL6'      ',X'00',C'3',H'032',F'0'
         DC    CL50'33 - file not open for update, cannot write'
         DC    CL6'      ',X'00',C'3',H'033',F'0'
         DC    CL50'34 - file not open for update, cannot insert'
         DC    CL6'      ',X'00',C'3',H'034',F'0'
         DC    CL50'35 - file not open for update, cannot delete'
         DC    CL6'      ',X'00',C'3',H'035',F'0'
         DC    CL50'36 - skip request illegal, file is opened random'
         DC    CL6'      ',X'00',C'3',H'036',F'0'
         DC    CL50'37 - cannot skip: specified skip-key is too short'
         DC    CL6'      ',X'04',C'3',H'037',F'0'
         DC    CL50'38 - sequential input requested after end-of-file'
         DC    CL6'      ',X'00',C'3',H'038',F'0'
         DC    CL50'39 - cannot read: specified key is not numeric'
         DC    CL6'      ',X'00',C'3',H'039',F'0'
         DC    CL50'40 - cannot insert: specified key is not numeric'
         DC    CL6'      ',X'00',C'3',H'040',F'0'
         DC    CL50'41 - write request not preceded by successful read'
         DC    CL6'      ',X'00',C'3',H'041',F'0'
         DC    CL50'42 - delete request not preceded by successful rea'
         DC    CL6'd     ',X'00',C'3',H'042',F'0'
         DC    CL50'43 - write requested, but keys are not equal'
         DC    CL6'      ',X'00',C'3',H'043',F'0'
         DC    CL50'44 - delete requested, but keys are not equal'
         DC    CL6'      ',X'00',C'3',H'044',F'0'
         DC    CL50'45 - insert requested, but keys are not equal'
         DC    CL6'      ',X'00',C'3',H'045',F'0'
         DC    CL50'46 - insert requested, but key is not unique'
         DC    CL6'      ',X'04',C'3',H'046',AL4(VSERR)
         DC    CL50'47 - insert of version record not allowed'
         DC    CL6'      ',X'00',C'3',H'047',F'0'
         DC    CL50'48 - delete of version record not allowed'
         DC    CL6'      ',X'00',C'3',H'048',F'0'
         DC    CL50'49 - cannot create ACB: file not opened'
         DC    CL6'      ',X'00',C'4',H'049',AL4(VSERR)
         DC    CL50'50 - cannot create RPL: file not opened'
         DC    CL6'      ',X'00',C'4',H'050',AL4(VSERR)
         DC    CL50'51 - file could not be opened'
         DC    CL6'      ',X'00',C'4',H'051',AL4(VSERR)
         DC    CL50'52 - skip request rejected by VSAM'
         DC    CL6'      ',X'08',C'4',H'052',AL4(VSERR)
         DC    CL50'53 - read request rejected by VSAM'
         DC    CL6'      ',X'08',C'4',H'053',AL4(VSERR)
         DC    CL50'54 - insert request rejected by VSAM'
         DC    CL6'      ',X'08',C'4',H'054',AL4(VSERR)
         DC    CL50'55 - delete request rejected by VSAM'
         DC    CL6'      ',X'08',C'4',H'055',AL4(VSERR)
         DC    CL50'56 - cannot re-establish addressability'
         DC    CL6'      ',X'00',C'5',H'056',F'0'
         DC    CL50'57 - VSAM returned no record nor EOF on read'
         DC    CL6'      ',X'08',C'4',H'057',F'0'
         DC    CL50'58 - sequential position in file not defined'
         DC    CL6'      ',X'08',C'4',H'058',AL4(VSERR)
         DC    CL50'59 - data buffer could not be marked for output'
         DC    CL6'      ',X'08',C'4',H'059',AL4(VSERR)
         DC    CL50'60 - close request failed'
         DC    CL6'      ',X'08',C'4',H'060',F'0'
         DC    CL50'61 - RPL could not be changed: insert impossible'
         DC    CL6'      ',X'08',C'4',H'061',AL4(VSERR)
         DC    CL50'62 - RPL could not be changed: delete impossible'
         DC    CL6'      ',X'08',C'4',H'062',AL4(VSERR)
         DC    CL50'63 - cannot reset RPL to normal processing'
         DC    CL6'      ',X'04',C'4',H'063',AL4(VSERR)
         DC    CL50'64 - I/O could not be completed successfully'
         DC    CL6'      ',X'08',C'4',H'064',AL4(LGERR)
         DC    CL50'65 - VSAM returned errorcode in ECB'
         DC    CL6'      ',X'04',C'4',H'065',AL4(VSERR)
         DC    CL50'66 - cannot extend (shared) data set'
         DC    CL6'      ',X'08',C'4',H'066',AL4(VSERR)
         DC    CL50'67 - a physical I/O-error occurred'
         DC    CL6'      ',X'08',C'4',H'067',AL4(VSERR)
         DC    CL50'68 - cannot load dynamic module BXAIO00'
         DC    CL6'      ',X'00',C'5',H'068',F'0'      *** Cannot occur
         DC    CL50'69 - dynamic storage request for USERAREA/FDB fail'
         DC    CL6'ed    ',X'00',C'5',H'069',AL4(UAERR)
         DC    CL50'70 - cannot allocate work-area for insert/delete'
         DC    CL6'      ',X'00',C'5',H'070',F'0'
         DC    CL50'71 - not enough virtual storage for VSAM'
         DC    CL6'      ',X'08',C'5',H'071',AL4(VSERR)
         DC    CL50'72 - not enough buffers in buffer pool'
         DC    CL6'      ',X'08',C'5',H'072',AL4(VSERR)
         DC    CL50'73 - current record address in PLH and FDB not equ'
         DC    CL6'al    ',X'08',C'4',H'073',F'0'
         DC    CL50'74 - cannot remove dynamic module BXAIO00'
         DC    CL6'      ',X'00',C'5',H'074',F'0'
         DC    CL50'75 - cannot obtain storage for snap control block'
         DC    CL6'      ',X'00',C'2',H'075',F'0'
         DC    CL50'76 - cannot open snap output file (sysudump)'
         DC    CL6'      ',X'00',C'2',H'076',F'0'
         DC    CL50'77 - snap was unsuccessful'
         DC    CL6'      ',X'00',C'2',H'077',F'0'
         DC    CL50'78 - cannot close snap output file (sysudump)'
         DC    CL6'      ',X'00',C'2',H'078',F'0'
         DC    CL50'79 - cannot free storage of snap control block'
         DC    CL6'      ',X'00',C'2',H'079',F'0'
         DC    CL50'80 - cannot build resource pool for index buffers'
         DC    CL6'      ',X'00',C'2',H'080',AL4(VSERR)
         DC    CL50'81 - not enough storage for snaplist, cannot snap'
         DC    CL6'      ',X'00',C'2',H'081',F'0'
ERRORTND DC    CL50'82 - unidentified error'
         DC    CL6'      ',X'00',C'5',H'082',F'0'
*
         SPACE 3
*
* LGERRTAB is a table used for translating RPL-reasoncodes (1 byte)
* to errorcodes that can be used with the errortab.
*
LGERRTAB DS    0D
         DC    X'04',X'00',H'001'      * End-of-file
         DC    X'08',X'00',H'046'      * Duplicate key
         DC    X'10',X'00',H'002'      * Record not found
         DC    X'1C',X'00',H'066'      * Dataset not extendable
         DC    X'28',X'00',H'071'      * Insufficient virtual storage
         DC    X'58',X'00',H'058'      * Sequential location undefined
LGTABEND DC    X'98',X'00',H'072'      * Insufficient buffers in pool
*
         SPACE 3
*
* CRASHMEM area is used only in emergencies when a USERAREA cannot be
* obtained or the parameter was not supplied by the caller.
* The first word of this area serves as a lock-word against concurrency
* errors. A value of zero indicates the area is available.
* A total length equal to that of USERAREA is quite enough to
* accomodate space for an emergency USERAREA, overlaid with the part
* of the parameter that may be used yet.
*
CRASHMEM DC    (8+L'USERAREA)X'00'     * Prefill with zeros.
LASTADDR EQU   *
*
         EJECT
*
* This DSECT describes the elements of the opcode table
*
DSOPC    DSECT
OPC      DS    0D                      * Opcode table element
OPCFCOD  DS    CL2                     * Text of opcode (LNSFCODE)
OPCMASK  DS    XL1                     * Mask for FDBREQ
         DS    XL1                     * Filler byte
OPCROUT  DS    AL4                     * Exit routine
*
         SPACE 3
*
* This DSECT describes the elements of the error table
*
DSERR    DSECT
ERR      DS    0D                      * Error table element
ERRTEXT  DS    CL56                    * Text of error
ERRFDBCD DS    X                       * Error code for FDB
ERRRETCD DS    X                       * Return code for caller
ERRREASN DS    H                       * Reasoncode
ERRROUT  DS    AL4                     * Error exit routine
ERR_LEN  EQU   *-DSERR                 * Length of error entry
         AIF   (ERR_LEN EQ 64).ERLENOK
         MNOTE 8,'ERROR routine uses fixed length of 64 for DSERR'
.ERLENOK ANOP
*
         SPACE 3
*
* This DSECT describes the elements of the LGERRTAB table
*
DSLGERR  DSECT
LGERRELM DS    0F                      * Error table element
LGREASON DS    X                       * Reason code
         DS    X                       * Filler
LGERCODE DS    H                       * Error code for error table
*
         EJECT
*
* This DSECT describes the caller-dependent data-area.
* Its length is dependent on the number of FDBs to be accomodated in
* the UAFILES field. if &NOOFFDB changes, the length of USERAREA may
* have to be changed as well. The &WORKLV variable is calculated
* elsewhere such that UAWORKAR will be long enough to accommodate
* any code that needs to be changed.
* Remember never to move the UASAVEAR-field from its first position
* in the user-area
*
DSUSERAR DSECT
USERAREA DS    0CL(168+&WORKLV)
UASAVEAR DS    18F                     * Savearea for any called module
UAWORKAR DS    XL&WORKLV               * Space for work-area
UALV1SAV DS    F                       * Ret addr from level1 routines
UALV2SAV DS    F                       * Ret addr from level2 routines
UAERRSAV DS    F                       * Ret addr from error routine
UAERXSAV DS    F                       * Ret addr from error exits
UABASSAV DS    F                       * Saved basereg of calling rout
UASNAPTR DS    AL4                     * Addr of snap control block
UAFDBPTR DS    AL4                     * Addr of first FDB on chain
UALRECAD DS    AL4                     * Addr record read for last FDB
UAOPCADR DS    AL4                     * Addr of opcode element
UACALLNR DS    F                       * Call count for current caller
UAIOCNT  DS    F                       * Total nr of check/open/close
UAVSAMRC DS    F                       * Saved returncode from VSAM
UALRECLV DS    H                       * Compare length for UALRECAD
UAREASN  DS    H                       * Reasoncode of worst error
UARETCD  DS    X                       * Highest returncode encountered
UASTAT   DS    X                       * Status bits
UAPOOLNR DS    X                       * LST-poolnr 00-0f or no LSR 10
UAVRPSTA DS    X                       * Status of VSAM resource pool
UAWORK   DS    X                       * Working byte
UAVERSI  DS    CL2                     * Version / release level
UASELECT DS    0CL8                    * Logical file selectors
UASCCDI  DS    CL1                     * Customer Contract Data
UASCPDI  DS    CL1                     * Customer Personal Data
UASCCXI  DS    CL1                     * Customer Contract eXtension
UASPDDI  DS    CL1                     * Product Definition Data
UASCSCI  DS    CL1                     * Capitalized Savings Contract
UASACDI  DS    CL1                     * ACounting Data
         DS    CL2                     * Reserved
UAFILES  DS    CL&NOOFFDB              * File indicators
UAKEY    DS    CL&MAXKEY               * Current key (from LNSKEY)
         DS    (29-&NOOFFDB-&MAXKEY)X  * Reserved
*
         SPACE
*
* Bit masks for UASTAT
*
UANOREQ  EQU   B'00000000'             * No outstanding requests
UARQREAD EQU   B'00100000'             * Request to restart read
UASNAPOP EQU   B'10000000'             * Snap-file is open
UASNAPER EQU   B'01000000'             * Rsnap encountered serious err
*
UARQNORX EQU   B'11011111'             * Reset mask for restart read
UASNAPCL EQU   B'01111111'             * Reset mask for closed snapfile
*
         SPACE
*
* Bit masks for UAVRPSTA
*
UAVCLOSE EQU   B'00000000'             * No VRP is defined
UAVEXIST EQU   B'00000001'             * VRP is defined
UAVRANDM EQU   B'00000100'             * VRP allocated for random acces
UAVERROR EQU   B'10000000'             * Error on VRP processing
*
         SPACE 3
*
* Equates for offsets in the savearea (first 18 words of USERAREA)
*
SAVEPLI  EQU   0                       * First word used by PL/I only
SAVEPREV EQU   4                       * Pointer ro previous save-area
SAVENEXT EQU   8                       * Pointer to next savearea
SAVEDR14 EQU   12                      * Return addr for current call
SAVEDR15 EQU   16                      * Entry-point address of
*                                      *          current call
SAVEDR0  EQU   20                      * Original contents of R0
SAVEDR1  EQU   24                      * Address of plist for this call
SAVEDR2  EQU   28                      * Original contents of R2
SAVEDR3  EQU   32                      * Original contents of R3
SAVEDR4  EQU   36                      * Original contents of R4
SAVEDR5  EQU   40                      * Original contents of R5
SAVEDR6  EQU   44                      * Original contents of R6
SAVEDR7  EQU   48                      * Original contents of R7
SAVEDR8  EQU   52                      * Original contents of R8
SAVEDR9  EQU   56                      * Original contents of R9
SAVEDR10 EQU   60                      * Original contents of R10
SAVEDR11 EQU   64                      * Original contents of R11
SAVEDR12 EQU   68                      * Original contents of R12
*
         SPACE 3
*
* Statements below are for ensuring that UAWORKAR will be large
* enough for all data and coding that is to be put into it.
* If - for any reason - lengths are changed so that a data area
* that is to use the UAWORKAR-field does not fit in it anymore
* an error (due to negative length) will be generated.
*
         DS    0CL(&WORKLV-VSAMOPLV)   * Plist of vsamopen
         DS    0CL(&WORKLV-CLOSELV)    * Plist of close
         DS    0CL(&WORKLV-BLDVRDLV)   * Plist of bldvrpd
         DS    0CL(&WORKLV-BLDVRILV)   * Plist of bldvrpi
         DS    0CL(&WORKLV-ERRWTOLV)   * Plist of errwto
         DS    0CL(&WORKLV-SHOWACLV)   * Plist generated by showcb ACB
         DS    0CL(&WORKLV-ERRWTOLV-SHOWACLV) * Used together in vserr
         DS    0CL(&WORKLV-MODCBDLV)   * Plist gen'ed by modcb (delete)
         DS    0CL(&WORKLV-MODCBILV)   * Plist gen'ed by modcb (insert)
         DS    0CL(&WORKLV-MODCNDLV)   * Plist gen'ed by modcb (no del)
         DS    0CL(&WORKLV-MODCNILV)   * Plist gen'ed by modcb (no ins)
         DS    0CL(&WORKLV-MODCBKLV)   * Plist gen'ed by modcb (key)
         DS    0CL(&WORKLV-GACLISLV)   * Plist generated for gencb ACB
         DS    0CL(&WORKLV-GACLIRLV)   * Plist generated for gencb ACB
         DS    0CL(&WORKLV-GACLUSLV)   * Plist generated for gencb ACB
         DS    0CL(&WORKLV-GACLURLV)   * Plist generated for gencb ACB
         DS    0CL(&WORKLV-GACPISLV)   * Plist generated for gencb ACB
         DS    0CL(&WORKLV-GACPIRLV)   * Plist generated for gencb ACB
         DS    0CL(&WORKLV-GACPUSLV)   * Plist generated for gencb ACB
         DS    0CL(&WORKLV-GACPURLV)   * Plist generated for gencb ACB
         DS    0CL(&WORKLV-GRPLISLV)   * Plist generated for gencb RPL
         DS    0CL(&WORKLV-GRPLIRLV)   * Plist generated for gencb RPL
         DS    0CL(&WORKLV-GRPLUSLV)   * Plist generated for gencb RPL
         DS    0CL(&WORKLV-GRPLURLV)   * Plist generated for gencb RPL
         AIF   (NOT &DBG).DSFDB
         DS    0CL(&WORKLV-SNAPOPLV)   * Plist of snapopen
         DS    0CL(&WORKLV-RSNAPPLV)   * Plist of rsnapsnp
.DSFDB   ANOP
*
         EJECT
*
* This DSECT describes the file descriptor blocks.
* Each FDB is used to control 1 physical file; logical files are
* mapped onto physical files in a n:m relationship. (currently 1:1)
* This mapping is done in phase1.
*
DSFDB    DSECT
FDB      DS    0CL96                   * File Descriptor Block
FDBNEXT  DS    AL4                     * Pointer to next FDB
FDBECB   DS    F                       * Event control block
FDBDDNAM DS    CL8                     * DDNAME to use for this file
FDBDDLOC EQU   FDBDDNAM-FDB            * Offset of DDNAME within FDB
FDBACB   DS    AL4                     * Address of ACB
FDBRPL   DS    AL4                     * Address of RPL
FDBREC   DS    AL4                     * Record-address within buffer
FDBSBUF  DS    AL4                     * Start-of-data current buffer
FDBEBUF  DS    AL4                     * End-of-data in current buffer
FDBWAREA DS    AL4                     * Addr of working area for rec'd
FDBMAP   DS    AL4                     * Address of rec'd/parm map-list
         DS    H                       * Len of allocated ACB (unused)
         DS    H                       * Len of allocated RPL (unused)
FDBRECLV DS    H                       * Logical record length
FDBKEYLV DS    X                       * Key-length
FDBNR    DS    X                       * File-group number
FDBREASN DS    H                       * Reasoncode for FDBRETCD
FDBRETCD DS    X                       * Retcd of worst error this FDB
FDBSTAT  DS    X                       * Status bits
FDBSKKLV DS    X                       * Skip-key length value
FDBREQ   DS    X                       * I/O request bits
FDBLREQ  DS    X                       * Last completed I/O request
FDBLKEY  DS    CL&MAXKEY               * Key of FDBLREQ
FDBXKEY  DS    CL&MAXKEY               * Extra key for double requests
         DS    (37-2*&MAXKEY)X         * Reserved
*
* FDBNEXT must be the first field (thus it is valid, even when the
*         base register for FDB points to UAFDBPTR)
* FDBDDNAM must be on a doubleword boundary
*
         SPACE
*
* Bit masks for FDBSTAT
*
FDBCLSD  EQU   B'00000000'             * File is currently closed
FDBINPUT EQU   B'00000001'             * File is open for read only
FDBUPDAT EQU   B'00000011'             * File is open for read/write
FDBACRND EQU   B'00000100'             * Access to file is random
FDBRPLDR EQU   B'00001000'             * RPL-optcd = UPD,MVE (LOC->MVE)
FDBRPLIR EQU   B'00011000'             * RPL-optcd = NUP,MVE
*                                      *                 (ID.+UPD->NUP)
FDBBUFUP EQU   B'00100000'             * Buffer marked for output
FDBEOF   EQU   B'01000000'             * Eof / file pointer not valid
FDBERROR EQU   B'10000000'             * Uncorrectable I/O error
*
FDBRPLND EQU   B'11110111'             * Reset-mask from delete-status
FDBRPLNI EQU   B'11100111'             * Reset-mask from insert status
FDBBUFNU EQU   B'11011111'             * Reset-mask from buffer marked
FDBNOEOF EQU   B'10111111'             * Reset eof-condition
         SPACE
*
* Bit masks for FDBREQ and FDBLREQ
*
FDBNOREQ EQU   B'00000000'             * No outstanding requests
FDBOPEN  EQU   B'10000000'             * Request to open the file
FDBOPENU EQU   B'10000010'             * Request to open file for updat
FDBSKIP  EQU   B'01000000'             * Request to seek a partial key
FDBREAD  EQU   B'00100000'             * Request to read a record
FDBREAD2 EQU   B'01101000'             * Request to re-execute
*                                      *                   RRX-routine
FDBWRITE EQU   B'00010000'             * Request to update a record
FDBINSRT EQU   B'00001000'             * Request to insert a new record
FDBDEL   EQU   B'00000100'             * Request to delete a record
FDBCLOSE EQU   B'00000010'             * Request to close the file
FDBOPRND EQU   B'00000001'             * Request to open random
*
FDBNOOI  EQU   B'00011110'             * Reset open input request
FDBNOOU  EQU   B'00011100'             * Reset open update request
FDBNOSK  EQU   B'10111111'             * Reset skip request
FDBNORX  EQU   B'11011111'             * Reset read request
FDBNOWX  EQU   B'11101111'             * Reset write request
FDBNOIR  EQU   B'11110111'             * Reset insert request
FDBNODR  EQU   B'11111011'             * Reset delete request
FDBNOCA  EQU   B'11111101'             * Reset close request
FDBNORND EQU   B'11111110'             * Reset random specifier
*
* The close-request bit serves also as an update-indicator during open
* processing. After opening it is reset: Therefore open and close
* requets cannot be combined in one opcode. This is no problem:
* the combination would be quite useless anyway.
*
* The insert-request-bit serves a double function as well: it also
* indicates a re-read request (issued when read-sequntial reaches
* end-of-buffer). Thus read and insert cannot be combined into
* one opcode.
*
         EJECT
*
* This DSECT describes the map master elements (1 per version)
* For each FDB there is a list of map master elements. These must
* be in contiguous storage.
*
DSMME    DSECT
MME      DS    0CL8                    * Map Master Element
MMEREM   DS    H                       * Remaining elements in list
MMEVERS  DS    CL2                     * Version identifier
MMEMAP   DS    AL4                     * Start of map for this version
*
* MMEREM gives the number of MME-elements there are in this MME-list
*        (that is: for the current FDB)
* MMEMAP points to the start of the map for the current FDB and for
*        the current version
*
         SPACE 3
*
* This DSECT describes the map-elements. For each version of each file
* there must be a map describing how data is to be transferred between
* record and parameter. The map-elements must be in contiguous storage.
*
DSME     DSECT
ME       DS    0CL8                    * Parameter block
MEREM    DS    H                       * Nr of remaining MEs in list
MEDATLV  DS    H                       * Data length
MEPRMOFS DS    H                       * Offset of data in parm
MERECOFS DS    H                       * Offset of data in record
*
         EJECT
*
* This DSECT describes the parameter that is used for communication
*                                      with the application program
*
DS83PARM DSECT
BXAIOPRM DS    0CL1024                 * Parameter block
         SPACE
LNSPARM  DS    0CL(3+&MAXKEY)
LNSFCODE DS    CL2                     * Function code
LNSRCODE DS    CL1                     * Return code
LNSKEY   DS    CL&MAXKEY               * Key
         SPACE
         DS    CL(1021-&MAXKEY)        * Start of record/data area
*                                      *   for records with
*                                      *   FDBKEYLV = &MAXKEY
         SPACE 3
*
* This DSECT describes the parameter that is used for communication
*                                      with the static part of BXAIO
*
DS83PRM2 DSECT
LNSPRM2  DS    0CL16
LNSUAPTR DS    AL4                     * Address of USERAREA
LNSVERSI DS    CL2                     * Version number of parameter 1
LNSFILES DS    CL8                     * Logical data-group selectors
         DS    CL2                     * Reserved
*
         EJECT
         AIF   (NOT &DBG).DSSNAP
*
* This DSECT is used by the RSANP-routine
*
DSSNAP   DSECT
SNAPAREA DS    0CL(120+&SNAPLEN+(&SNAPLEN/2)+SNAPDCBL)
SNAPSAVE DS    18F                     * Register save-area
SNAPLIST DS    XL&SNAPLEN              * Space for storage ranges
SNAPHDRS DS    XL(&SNAPLEN/2)          * Space for storage header ptrs
SNAPIDNR DS    X                       * Idnr of last snap, initial 0
         DS    XL3                     * Filler to realign
SNAPDCB  DS    XL(SNAPDCBL)            * Space for DCB of snap-file
         DS    XL40                    * Extension space for DCB
*
         SPACE 3
.DSSNAP  ANOP
*
* This DSECT describes an access method control block
*
         IFGACB DSECT=YES,             * Generate DSECT for ACBs       *
               AM=VSAM                 *    used for VSAM-files
IFGACBLV EQU   *-IFGACB
*
         AIF   (NOT &DBG).IFGRPL
         EJECT
.IFGRPL  ANOP
*
* This DSECT describes a request parameter list
*
         IFGRPL DSECT=YES,             * Generate DSECT for RPLs       *
               AM=VSAM                 *    used for VSAM-files
IFGRPLLV EQU   *-IFGRPL
*
         AIF   (NOT &DBG).IDAPLH
         EJECT
.IDAPLH  ANOP
*
* This DSECT describes a placeholder
*
*        IDAPLH DSECT=YES,AM=VSAM      * IDAPLH macro not present
IDAPLH   DSECT ,                       * Placeholder
         DS    13F                     * First 13 words not described
PLHDBUFC DS    AL4                     * Addr of current data bufc
PLHNBUFC DS    AL4                     * Addr of next read bufc
PLHRECP  DS    AL4                     * Addr of current record
PLHFSP   DS    AL4                     * Addr of 1st byte of free space
*                                      * Remainder of PLH not described
IDAPLHLV EQU   332                     * Total length of a placeholder
*
         SPACE 3
*
* Shrpool-nr in bldvrp is to be changeable. The bldvrp macro does not
* support register specification of shrpool-parameter. Therefore we
* must alter the shrpool-byte in the bldvrp-pool ourselves. The
* shrpool-number is located at offset X'20' in the bldvrp request list.
*
DSBLDVRP DSECT ,                       * Describes bldvrp/dlvrp plists
BLDVRPTR DS    F                       * Pointer to only element
BLDVRPHD DS    0F                      * Start of header = only element
         DS    7F                      * First 28 bytes not described
BLDVRPNR DS    X                       * Location of shrpoolnr in
*                                      *              bldvrp-request
*                                      * Remainder not described
         END
./ ADD NAME=BXALOWPG 0100-20110-20110-2315-00043-00043-00000-BXAASM  15
*PROCESS RENT
*PROCESS FLAG(SUBSTR)
***********************************************************************
*
* BIXXAMS - Bixoft Cross Access Method Services
* Licensed material - Property of B.V. Bixoft
*
* This program can be licensed or used on an as-is basis.
* No warranty, neither implicit nor explicit, is given.
* It remains your own responsibility to ensure the correct
* working of this program in your installation.
*
* Suggestions for improvement are always welcome at
* http://www.bixoft.com  or mail to  bixoft@bixoft.nl
*
* (C) Copyright B.V. Bixoft, 1999-2000
***********************************************************************
*
* Entry for stand-alone testing new mapping macro's
         PGM   VERSION=V00R00M00,      * Version number                *
               HDRTXT='Testpgm for GLUE macro',                        *
               ENTRY=MAIN,             * Entry for subroutine          *
               AMODE=24,               * 24-bit addr. mode             *
               RMODE=24,               * Resides below 16 Mb           *
               ABND=4090,              * Abend code for BXALOWPG       *
               MAPS=(BITS,REGS),       * Standard mappings             *
               LIST=NO                 *
*
R_RCD    EQUREG ,                      * Allocate retcode register
         USE   R_RCD                   *
*
         RWTO  'BXALOWPG is now running'
         ABND  TSTRC,RCD=R5            * warning messages in assembly
*
         RETRN RC=0                    * Normal return to caller
***********************************************************************
*
* Constants etc.
*
***********************************************************************
         LTORG ,                       *
*
         END
./ ADD NAME=BXAMAPS  0100-20110-20110-2315-00232-00232-00000-BXAASM  15
*PROCESS FLAG(SUBSTR)
*PROCESS RENT
***********************************************************************
*
* BIXXAMS - Bixoft Cross Access Method Services
* Licensed material - Property of B.V. Bixoft
*
* This program can be licensed or used on an as-is basis.
* No warranty, neither implicit nor explicit, is given.
* It remains your own responsibility to ensure the correct
* working of this program in your installation.
*
* Suggestions for improvement are always welcome at
* http://www.bixoft.com  or mail to  bixoft@bixoft.nl
*
* (C) Copyright B.V. Bixoft, 1999-2000
***********************************************************************
*
* This program performs no function:
*   it is used only for generating a listing of all dsects used.
*
***********************************************************************
         LCLC  &SELECT                 * Selection variable
&SELECT  SETC  'UCB'                   * Select a single map macro
&SELECT  SETC  '*BXA'                  * Select bixxams map-macros
&SELECT  SETC  '*ALLMAPS'              * Select all map-macros
&SELECT  SETC  '*ALLMACS'              * Select all macros
*
         AIF   ('&SELECT'(1,1) EQ '*').NOTSA
*
* Entry for stand-alone testing new mapping macro's
         PGM   VERSION=V00R00M00,      * Version number                *
               HDRTXT='Map testing',   * Header for loadmod            *
               ENTRY=SUBPGM,           * Entry for subroutine          *
               ABND=1,                 * User abend code               *
               MAPS=(&SELECT),         * Map to be tested              *
               LIST=YES                * Generate listing
         AGO   .END                    *
.NOTSA   ANOP  ,                       *
&SAVES   SETC  '0'                     * Default
         AIF   ('&SELECT' NE '*ALLMACS').SAVESOK
&SAVES   SETC  '1'                     * Required for *ALLMACS
.SAVESOK ANOP  ,                       *
*
* Entry for a complete overview of all BIXXAMS mapping macro's
         PGM   VERSION=V00R00M00,      * Version number                *
               HDRTXT='Mapping module for BIXXAMS',                    *
               ENTRY=SUBPGM,           * Entry for subroutine          *
               ABND=1,                 * User abend code               *
               SAVES=&SAVES,           * Internal save areas           *
               MAPS=($AMQS,$BDS,$BDSD,$BDSL,$BDST,$COPY,$DAPL,$DBG,    *
               $OCW,$PCW,$SCB,$SNAP,$SRB,$TST,$UNLD),                  *
               LIST=YES                * And generate a listing
         AIF   ('&SELECT' EQ '*BXA').END
         AIF   ('&SELECT' EQ '*ALLMAPS').GENALL
         AIF   ('&SELECT' EQ '*ALLMACS').GENALL
&SELECT  SETC  (DOUBLE '&SELECT')      *
         MNOTE 8,'Invalid value for &&SELECT - &SELECT'
         AGO   .END                    *
.GENALL  ANOP  ,                       *
*
* Other mapping macros (A-C):
         GENMAPS (ABEP,ACB,ACEE,ADSR,ADYENF,AE,ASCB,ASEO,              *
               ASMVT,ASSB,ASVT,ASXB,   *                               *
               BASEA,BITS,             *                               *
               CAM,CDE,CIB,COM,CQE,CSCB,CVT),                          *
               LIST=YES                *
*
* Other mapping macros (D-I):
         GENMAPS (DCB,DCBE,DDRCOM,DEB,DECB,DES,DFA,DOTU,DSAB,DSABQDB,  *
               DSCB,DSCB1,DSCB2,DSCB3,DSCB4,DSCB5,                     *
               ECB,ECVT,EPAL,EQU,EVNT, *                               *
               FRRPL,FRRS,             *                               *
               GVT,GVTX,               *                               *
               IEANT,IECEQ,IHSA,IOB,IOQ,IOSB),                         *
               LIST=YES                *
*
* Other mapping macros (J-R):
         GENMAPS (JCT,JCTX,JESCT,JFCB,JFCBE,JFCBX,JSCB,                *
               LCT,LDA,LLE,LMASM,LPDE, *                               *
               OCPL,ORE,OUCB,          *                               *
               PCCA,PCCAVT,PDAB,PDS,PEL,PMAR,PRB,PRMLB,PSA,PSL,PVT,    *
               QCB,QEL,QHT,QMIDS,      *                               *
               RB,RCTD,REGS,RMCT,RMPL,RPL,RQE,RT1W),                   *
               LIST=YES                *
*
* Other mapping macros (S-Z):
         GENMAPS (SAVE,SCCB,SCT,SCTX,SCVT,SDWA,SIOT,SMCA,SMDE,SNAP,SRB,*
               SSDR,SSL,SSOB,SSRB,STCB,SVCE,SVRB,SVT,SWAPX,S99,        *
               TAXE,TCB,TCCW,TCT,TIOT,TQE,                             *
               UCB,UCM,                *                               *
               VRA,VSL,                *                               *
               WQE,WTOPL,              *                               *
               XSB),                   *                               *
               LIST=YES                *
         AIF   ('&SELECT' NE '*ALLMACS').END
*
* Routine that will never execute
         IF    R12,EQ,R13              * Can never be true
          EXSR ALLMACS                 *
         ELSE  ,                       * Always taken: leave empty
         ENDIF ,                       *
*
.END     ANOP  ,                       *
*
         RETRN RC=0                    * Normal return to caller
         AIF   ('&SELECT' NE '*ALLMACS').LTORG
***********************************************************************
*
* Routine to inlcude all macros
*
***********************************************************************
ALLMACS  BEGSR ,                       *
*
R_SLIST  EQUREG ,                      *
         USE   SNAPLIST,R_SLIST        *
R_HLIST  EQUREG ,                      *
         USE   SNAPHLIST,R_HLIST       *
R_DBG    EQUREG ,                      *
         USE   DBG,R_DBG,              *                               *
               OVR=((DBGSAVE,DBGSA))   *
*
         DBG   ABND,NOWARN             *
         DS    0F                      *
FLD1     DCOVR AL4(266)                *
FLD1     DC    FL2'66'                 *
         DCOVR *END                    *
TESTRDTA RDATA CMDTXT,'TEST'           *
*
         BALE  R14,ALLMACSX            *
         BALH  R14,ALLMACSX            *
         BALL  R14,ALLMACSX            *
         BALM  R14,ALLMACSX            *
         BALO  R14,ALLMACSX            *
         BALP  R14,ALLMACSX            *
         BALZ  R14,ALLMACSX            *
         BALNE R14,ALLMACSX            *
         BALNH R14,ALLMACSX            *
         BALNL R14,ALLMACSX            *
         BALNM R14,ALLMACSX            *
         BALNO R14,ALLMACSX            *
         BALNP R14,ALLMACSX            *
         BALNZ R14,ALLMACSX            *
*
         BASE  R14,ALLMACSX            *
         BASH  R14,ALLMACSX            *
         BASL  R14,ALLMACSX            *
         BASM  R14,ALLMACSX            *
         BASO  R14,ALLMACSX            *
         BASP  R14,ALLMACSX            *
         BASZ  R14,ALLMACSX            *
         BASNE R14,ALLMACSX            *
         BASNH R14,ALLMACSX            *
         BASNL R14,ALLMACSX            *
         BASNM R14,ALLMACSX            *
         BASNO R14,ALLMACSX            *
         BASNP R14,ALLMACSX            *
         BASNZ R14,ALLMACSX            *
*
         BHER  R14                     *
         BLER  R14                     *
         BLHR  R14                     *
         BNHER R14                     *
         BNLER R14                     *
         BNLHR R14                     *
*
         CASE  DBG_PROB                *
          RWTO 'DBG:PROB'              *
         ENDCASE ,                     *
*
         DO    UNTIL,R0,Z              *
          BXAEPSW R0                   *
          LEAVE NZ                     *
          LOOP ,                       *
         ENDDO ,                       *
*
         EXCLC 0(R1,R2),0(R4)          *
         EXMVC 0(R1,R2),0(R4)          *
         EXSVC (R14)                   *
         EXTR  0(R1,R2),0(R4)          *
         EXTRT 0(R1,R2),0(R4)          *
         EXXC  0(R1,R2),0(R4)          *
         MVPL  DBGENQ,DBG_ENQ          *
*
         IF$ALC R5                     *
         IF$LS R4,FLD1,4,A             *
         IF$LU R4,FLD1,4,A             *
*
         INC   R5                      *
         LC    R5,0(R4)                *
         LTA24 R5,0(R4)                *
         LTC   R5,0(R4)                *
         LTH   R5,0(R4)                *
         LTHU  R5,0(R4)                *
         STA24 R5,0(R4)                *
*
         SET   DBGINIT                 *
         SETOF DBG_PROB                *
         SETON DBG_PROB                *
         SETMODE PSWKEY,KEY=8          *
*
         SNAPNTRY (R4),                *                               *
               LEN=(R6),               *                               *
               HDR='>> CB - Some Control Block'
*
         GOTO  ALLMACSX                *
TRTAB1   TRTAB UC                      *
         USEDREGS ,                    *
*
DBG_ENQ  ENQ   (0,0,E,0,SYSTEM),       * Prototype for ENQ             *
               RET=NONE,MF=L           *   plist
*
ALLMACSX LABEL ,                       *
         GBLB  &SP_OPT                 * Optimize switch
         AIF   (&SP_OPT).NOOPSYNS      *
         OPSYNS LA,LR                  *
.NOOPSYNS ANOP ,                       *
         IPK   ,                       * Macro IPK
         LA    R7,4                    * Macro LA
         LR    R15,R7                  * Macro LR
         TRT   0(8,R4),0(R8)           * Macro TRT
*
         ENDSR ,                       *
.LTORG   ANOP  ,                       *
***********************************************************************
*
* Constants etc.
*
***********************************************************************
         LTORG ,                       *
*
         END
./ ADD NAME=BXAPRIM  0100-20110-20110-2315-01066-01066-00000-BXAASM  15
BXAPRIM  TITLE 'Find Primes Using Sieve of Erathostenes'
***********************************************************************
* Start create : 06-06-2006
* 1st delivery :
* Designer     : AF Kornelis
* Programmer   : AF Kornelis
***********************************************************************
*
* Parameter: [charmode][separator][spacing]
* Where charmode = EBCDIC|ASCII
*       separator= PERIOD|COMMA
*       spacing  = SPACING(n|nn) - n|nn being a number between 1 and 99
*
* Options may appear in any order and must be separated by a comma.
* Default: EBCDIC,PERIOD,SPACING(4)
*
***********************************************************************
*
* Internal calculus is done in excess-30/210 notation. That is, each
* number is represented by the results of its division by 30/210:
* both its quotient and its remainder. 30/210 are chosen because it is
* the product of the first three/four primes: 2, 3, 5 (and 7).
* The remainder thus tells us straight away whether the number might
* be divisible by 2, 3, 5 (or 7). If it is not, it might be a prime.
* Each stretch of 30/210 numbers thus contains 8/48 potential primes.
* The status of these 8/48 numbers can be represented in 1/6 byte(s).
*
***********************************************************************

***********************************************************************
*
* Define constants and environment
*
***********************************************************************
         YREGS ,                       * Define register equates
         DCBD  DSORG=PS

***********************************************************************
*
* Define workareas and fixed constants
*
***********************************************************************
#LPP     EQU   66                      * Nr of lines per page
#CPL     EQU   80                      * Nr of characters per line
*
&#MAXP   SETA  7                       * Highest pre-determined prime
&INTVALS SETA  1200                    * Nr of intervals to process
#MAXP    EQU   &#MAXP                  * Max pre-calculated prime
         AIF   ('&#MAXP' EQ '7').INTVAL7
#INTVAL  EQU   2*3*5                   * Interval size = 30
#CAND    EQU   8                       * Nr of candidates per interval
         AGO   .INTVAL
.INTVAL7 ANOP  ,
#INTVAL  EQU   2*3*5*7                 * Interval size = 210
#CAND    EQU   48                      * Nr of candidates per interval
.INTVAL  ANOP  ,
&CAND    SETA  #CAND                   * Nr of candidates per interval

WORKAREA DSECT ,                       *
SAVEAREA DS    18F                     * Save area for GPRs
WAEYE    DS    CL8                     * Eye Catcher
WACHARS  DS    C                       * Character set: Ebcdic / Ascii
WASEPRTR DS    C                       * Thousands separator
WASPACE  DS    H                       * Column spacing
WAINTVBITS DS  H                       * Nr of candidate primes/intval
WAINTVBYTS DS  H                       * Interval size in bytes
WAPRHDR1 DS    A                       * Ptr to first PRIMHDR area
WARPTBUF DS    A                       * Ptr to reporting buffer
WARPTBSZ DS    F                       * Size of reporting buffer
WAPRMRET DS    A                       * Return address from PARMS
WAPRMPTR DS    A                       * Ptr to parameter string
WASTPRET DS    A                       * Return address from SETUP
WAFNPRET DS    A                       * Return address from FNP
WAFNPR5  DS    F                       * Pointer to current bit
WAFNPR9  DS    F                       * Address of current bitstring
WASQPRET DS    A                       * Return address from SQP
WARMVRET DS    A                       * Return address from RMV
WARPTRET DS    A                       * Return address from RPT-rtns
WAWRTRET DS    A                       * Return address from WRT
WAPRIMB  DS    F                       * Current prime (Base)
WADBLB   DS    F                       * Double of WAPRIMB (base)
WACURB   DS    F                       * Current number (Base)
WAPRIMX  DS    X                       * Current prime (excess)
WADBLX   DS    X                       * Double of WAPRIMB (excess)
WACURX   DS    X                       * Current number (excess)
         DS    0D
WAPRIMPK DS    PL8                     * Packed prime number
WAPRIMNR DS    ZL16                    * Same nr in zoned format
         DS    0D
WASYSOUT_EYE DS XL8                    * Room for eyecatcher
WASYSOUT Ds    XL(SYSOUT_LEN)          * Room for runtime copy of DCB
         DS    0D
WAMASKS_EYE DS XL8                     * Room for eyecatcher
WAMASKS  DS    8X                      * Bit masks for AND-ing a bit
         DS    0D
WAPRIMES_EYE DS XL8                    * Room for eyecatcher
WAPRIMES DS    XL(#INTVAL)             * Byte-size entries for 1 intval
*                                      * 0   = not a candidate prime
*                                      * 1-n = candidate prime nr
*                                      * Also bit nr in bit string
*                                      *   counting bits from 1 thru n
*                                      *   rather than 0 thru n-1
         DS    0D
WABIT2OF_EYE DS XL8                    * Room for eyecatcher
WABIT2OF DS    XL(&CAND)               * Bit nr to offset in interval
*                                      * Each byte corresponds to a bit
*                                      * in each bitstring (interval).
*                                      * Each byte holds the value that
*                                      * the corresponding bit in its
*                                      * interval represents.
*                                      * E.g. if #MAXP=5, then the
*                                      * first bit represents 1, the
*                                      * second 7, the third 11, etc.
*                                      * The values are used to convert
*                                      * between binary and
*                                      * excess-30/210 notation.
         DS    0D                      * Re-align to Double-word
WAEYE2   DS    CL8                     * Second Eye-catcher
WORKAREA_LEN EQU *-WORKAREA

*
* Header for a primes area. Each primes area consists of a series
* of consecutive bitstrings of length &CAND bits. &CAND is always a
* multiple of 8, thus each string is &CAND/8 bytes in size
*
PRIMHDR  DSECT
PRIMNEXT DS    A                       * Ptr to next PRIMHDR
PRIMBASE DS    F                       * Interval number (30s/210s)
PRIMLAST DS    F                       * Last interval number
PRIMPTR  DS    A                       * Area of bit map
PRIMLEN  DS    A                       * Length of bitmap area
PRIMSTAT DS    X                       * Status flag
PRIMSINI EQU   X'80'                   * -bit0 = area initialized
PRIMSOK  EQU   X'40'                   * -bit1 = all primes located
PRIMSWR  EQU   X'01'                   * -bit7 = area needs to be writ
         DS    0D                      * Re-align
PRIMHDR_LEN EQU *-PRIMHDR


***********************************************************************
*
* Program entry and linkage
*
***********************************************************************
BXAPRIM  RSECT ,                       *
BXAPRIM  AMODE 31
BXAPRIM  RMODE ANY
***********************************************************************
         USING BXAPRIM,R15             * Establish addressability
         B     BXAPRIM0                * Skip header data
         DC    AL1(BXAPRIM-*),C'BXAPRIM  &SYSDATE &SYSTIME'
BXAPRIM0 EQU   *
         STM   R14,R12,12(R13)         * Save GPRs
         LR    R12,R15                 * Copy base address
         LR    R2,R1                   * Copy ptr to parm string
         DROP  R15                     * No longer needed
         USING BXAPRIM,R12             * Re-establish addressability
         LA    R11,WORKAREA_LEN        * Size of req'd workarea
         GETMAIN R,LV=(R11),LOC=BELOW  * Acquire working storage
         ST    R1,8(,R13)              * Set ptr to new savearea
         ST    R13,4(,R1)              * Set ptr from ne to prev save
         LR    R13,R1                  * Activate new savearea
         USING WORKAREA,R13            * Set addressable
         XR    R0,R0                   * Set to zero
         ST    R0,SAVEAREA             * Nullify header-word
         ST    R2,WAPRMPTR             * Save pointer to parmstring

***********************************************************************
*
* Set up working storage areas
*
***********************************************************************
         MVC   WAEYE,=CL8'BXAPRIM '    * Init Eye-catcher
         MVC   WAEYE2,=CL8'BXAPRIM '   * and ending eye-catcher as well
         MVC   WASYSOUT_EYE,=CL8'WASYSOUT'
         MVC   WAMASKS_EYE,=CL8'WAMASKS'
         MVC   WAPRIMES_EYE,=CL8'WAPRIMES'
         MVC   WABIT2OF_EYE,=CL8'WABIT2OF'
         XR    R0,R0
         ST    R0,WAPRIMB
         ST    R0,WADBLB
         ST    R0,WACURB
         MVI   WAPRIMX,#MAXP
         MVI   WADBLX,0
         MVI   WACURX,0
         BAL   R14,PARMS               * Extract parameters from string
         BAL   R14,SETUP               * Setup various arrays

***********************************************************************
*
* Obtain and init first area for finding primes
*
***********************************************************************
         LA    R11,PRIMHDR_LEN         * Size of header area
         GETMAIN R,LV=(R11),LOC=ABOVE  * Acquire header area
         LR    R11,R1                  * Get pointer to header
         USING PRIMHDR,R11             * Set header area addressable
         ST    R11,WAPRHDR1            * Save pointer
         XC    PRIMHDR(PRIMHDR_LEN),PRIMHDR * Wipe area
         L     R2,=F'&INTVALS'         * Nr of intervals to allocate
         LH    R3,WAINTVBYTS           * Interval size in bytes
         LR    R1,R2                   * Save nr of intervals
         BCTR  R1,R0                   * Get highest interval nr
         ST    R1,PRIMLAST             * Insert that into header
         MR    R2,R2                   * R2*R3 --> R2R3
         GETMAIN R,LV=(R3),LOC=ABOVE   * Get storage
         ST    R3,PRIMLEN              * Save length of area
         ST    R1,PRIMPTR              * Save pointer to area
         LR    R10,R1                  * Get pointer to storage
*
         LR    R0,R1                   * Destination pointer
         L     R1,PRIMLEN              * Destination length
         XR    R14,R14                 * Source pointer
         XR    R15,R15                 * Source length
         ICM   R15,B'1000',=X'FF'      * Filler byte
         MVCL  R0,R14                  * Init entire bit map
*
         OI    PRIMSTAT,PRIMSINI       * Set status to init ok
         LA    R1,1                    * First 'potential' prime
         STC   R1,WAPRIMX              * Multiples of 1 do not need
*                                      *     to be removed
         NI    0(R10),X'FF'-X'80'      * Reset '1' - it is no prime

*
** Setup data for FNP routine to pretend '1' was lastly processed
         LA    R15,&CAND               * Bit pointer in bitstring
         ST    R15,WAFNPR5             *
         MVC   WAFNPR9,PRIMPTR         * Pointer to bitstring

***********************************************************************
*
* Prepare for processing: Find first prime to process
*
***********************************************************************
NEXTPRIM DS    0H                      *
         BAL   R14,FNP                 * Find Next Prime
         BAL   R14,SQP                 * SQuare Prime nr
         CLC   WACURB,PRIMLAST         * Square exceeds area?
         BH    REPORT                  * Yes: Report primes found
         BAL   R14,RMV                 * ReMoVe all multiples
         B     NEXTPRIM                * Go find & Process next prime

REPORT   DS    0H
         OI    PRIMSTAT,PRIMSOK        * Mark area completed
*
** Setup data for FNP routine to pretend '1' was lastly processed
         XC    WAPRIMB,WAPRIMB         * First prime is in interval 0
         XC    WAPRIMX,WAPRIMX         * First prims not found yet
         LA    R15,&CAND               * Bit pointer in bitstring
         ST    R15,WAFNPR5             *
         MVC   WAFNPR9,PRIMPTR         * Pointer to bitstring
*
         BAL   R14,INITRPT             * Setup for printing
RPTLOOP  DS    0H
         BAL   R14,FNP                 * Find Next Prime
         LTR   R15,R15                 * No more primes?
         BNZ   RPTDONE                 * No: we're done
         BAL   R14,RPTPRIM             * Ok: Report this prime
         B     RPTLOOP                 *
RPTDONE  DS    0H
         BAL   R14,ENDRPT              * Terminate printing
         WTO   'OK, klaar'             **!!
         B     EXIT                    * Quit program

ABEND001 ABEND 001                     * User Abend 001:
*                                      * Nr of candidate primes per
*                                      * interval does not match preset
*                                      * value: initialization error
ABEND002 ABEND 002                     * User Abend 002:
*                                      * Last prime processed cannot be
*                                      * located in bit string
ABEND003 ABEND 003                     * User Abend 003:
*                                      * Next prime to process has a
*                                      * square that exceeds 2**31
ABEND004 ABEND 004                     * User Abend 004:
*                                      * Input parameterstring cannot
*                                      * be processed correctly
ABEND005 ABEND 005                     * User Abend 005:
*                                      * Internal error while
*                                      * processing parameter string
         DROP  ,
***********************************************************************
*
* Subroutine to process run-time parameter string
*
* Input : Workarea - WAPRMPTR
* Output: Workarea - wachars, WASEPRTR, WASPACE
*
* Allowed parameters:
* EBCDIC
* ASCII
* COMMA
* PERIOD
* SPACING
*
* Register allocations:
* R13 - workarea
* R12 - codebase
* R11 - parmstring
* R10 - length of string
*
***********************************************************************
PARMS    DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         ST    R14,WAPRMRET            * Save return address

*
** Start with setting appropriate defaults
         MVI   WACHARS,C'E'            * EBCDIC
         MVI   WASEPRTR,C'.'           * Period
         MVC   WASPACE,=H'04'          * Spacing(4)

*
** Get to parmstring content
         L     R11,WAPRMPTR            * Point to parmlist ptr
         LTR   R11,R11                 * Valid pointer?
         BZ    PARMDONE                * No: exit with defaults
         L     R11,0(,R11)             * Point to parmlist string
         LTR   R11,R11                 * Valid pointer?
         BZ    PARMDONE                * No: exit with defaults
         LH    R10,0(R11)              * Get length from string
         LA    R11,2(,R11)             * Point to first char in string
         LTR   R10,R10                 * Valid length?
         BZ    PARMDONE                * No: exit with defaults

*
** Loop to find all paramters
PARMLOOP DS    0H
         LTR   R10,R10                 * Any characters left in string?
         BZ    PARMDONE                * Nope: we're done

         CH    R10,=H'5'               * Enough chars left?
         BL    ABEND004                * No: can't be right
         CLC   0(5,R11),=CL5'ASCII'    * ASCII requested?
         BE    PARMASC                 * Yes: go process
         CLC   0(5,R11),=CL5'COMMA'    * COMMA requested?
         BE    PARMCOM                 * Yes: Go process

         CH    R10,=H'6'               * Enough chars left?
         BL    ABEND004                * No: can't be right
         CLC   0(6,R11),=CL6'EBCDIC'   * EBCDIC requested?
         BE    PARMEBC                 * Yes: go process
         CLC   0(6,R11),=CL6'PERIOD'   * PERIOD requested?
         BE    PARMPER                 * Yes: go process

         CH    R10,=H'7'               * Enough chars left?
         BL    ABEND004                * No: can't be right
         CLC   0(7,R11),=CL7'WASPACE'  * SPACING requested?
         BE    PARMSPA                 * Yes: go process
         B     ABEND004                * Invalid keyword

*
** ASCII requested
PARMASC  DS    0H
         MVI   WACHARS,C'A'            * Set charmode to Ascii
         LA    R11,5(,R11)             * Advance pointer
         SH    R10,=H'5'               * Reduce length
         BO    ABEND005                * Signal internal error
         BE    PARMDONE                * Nothing left to process
         B     PARMNEXT                * Check for next comma

*
** EBCDIC requested
PARMEBC  DS    0H
         MVI   WACHARS,C'E'            * Set charmode to Ebcdic
         LA    R11,6(,R11)             * Advance pointer
         SH    R10,=H'6'               * Reduce length
         BO    ABEND005                * Signal internal error
         BE    PARMDONE                * Nothing left to process
         B     PARMNEXT                * Check for next comma

*
** COMMA requested
PARMCOM  DS    0H
         MVI   WASEPRTR,C','           * Set separator to a comma
         LA    R11,5(,R11)             * Advance pointer
         SH    R10,=H'5'               * Reduce length
         BO    ABEND005                * Signal internal error
         BE    PARMDONE                * Nothing left to process
         B     PARMNEXT                * Check for next comma

*
** PERIOD requested
PARMPER  DS    0H
         MVI   WASEPRTR,C'.'           * Set separator to a period
         LA    R11,6(,R11)             * Advance pointer
         SH    R10,=H'6'               * Reduce length
         BO    ABEND005                * Signal internal error
         BE    PARMDONE                * Nothing left to process
         B     PARMNEXT                * Check for next comma

*
** SPACING(n|nn) requested
PARMSPA  DS    0H
         LA    R11,7(,R11)             * Advance pointer
         SH    R10,=H'7'               * Reduce length
         BO    ABEND005                * Signal internal error
         BZ    ABEND005                * Nothing left to process
* Ok, now check for opening parenthesis
         CLI   0(R11),C'('             * Left parenthesis present?
         BNE   ABEND004                * No: string in error
         LA    R11,1(,R11)             * Advance pointer
         SH    R10,=H'1'               * Reduce length
         BO    ABEND005                * Signal internal error
         BZ    ABEND005                * Nothing left to process
* Ok, check for first digit
         CLI   0(R11),C'0'             * Valid digit?
         BL    ABEND004                * No: string in error
         CLI   0(R11),C'9'             * Valid digit?
         BH    ABEND004                * No: string in error
         XR    R3,R3                   * Set spacing to 0
         IC    R3,0(R11)               * Obtain firts digit
         LA    R2,C'0'                 *
         SR    R3,R2                   * Get numerical value
         LA    R11,1(,R11)             * Advance pointer
         SH    R10,=H'1'               * Reduce length
         BO    ABEND005                * Signal internal error
         BZ    ABEND005                * Nothing left to process
* Ok, check for second digit (or closing parenthesis)
         CLI   0(R11),C'0'             * Valid digit?
         BL    PARMSPA2                * No: should be closing par.
         CLI   0(R11),C'9'             * Valid digit?
         BH    ABEND004                * No: string in error
         LA    R2,10                   * Ok: valid digit, therefore
         MR    R2,R3                   * R2*R3 --> R2R3 ==> R3=10n
         IC    R2,0(R11)               * Get second digit
         LA    R1,C'0'                 *
         SR    R2,R1                   * Get numerical value
         AR    R3,R2                   * And add to total
         LA    R11,1(,R11)             * Advance pointer
         SH    R10,=H'1'               * Reduce length
         BO    ABEND005                * Signal internal error
         BZ    ABEND005                * Nothing left to process
* Ok, check for closing parenthesis
PARMSPA2 DS    0H
         STH   R3,WASPACE              * Save spacing from parm
         CLI   0(R11),C')'             * Right parenthesis present?
         BNE   ABEND004                * No: string in error
         LA    R11,1(,R11)             * Advance pointer
         SH    R10,=H'1'               * Reduce length
         BO    ABEND005                * Signal internal error
         BZ    PARMDONE                * Nothing left to process
         B     PARMNEXT                * Check for next comma

*
** Start processing next parameter
PARMNEXT DS    0H
         CLI   0(R11),C','             * Comma present?
         BNE   ABEND004                * No: string in error
         LA    R11,1(,R11)             * Advance pointer
         BCT   R10,PARMLOOP            * Reduce length and loop
*                                      * Length is reduced to zero
*                                      * i.e. parm ends with a comma
*                                      * Allow this; just end

PARMDONE DS    0H
         L     R14,WAPRMRET            * Retrieve return address
         BR    R14                     * Return to mainline

         DROP  ,
***********************************************************************
*
* Subroutine to setup various arrays
*
* Input : Workarea
* Output: Workarea - PRIMES, WABIT2OF, WAMASKS, WAINTVBITS, WAINTVBYTS
*
* Register allocations:
* R13 - workarea
* R12 - codebase
*
***********************************************************************
SETUP    DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         ST    R14,WASTPRET            * Save return address
*
** Step 1: Setup the PRIMES array using a simple sieve algorithm
         MVI   WAPRIMES,X'01'          * Set all numbers to primes
         MVC   WAPRIMES+1(#INTVAL-1),WAPRIMES
*
* Mark all even numbers as non-primes
         LA    R14,2                   * First prime
         LA    R15,WAPRIMES+#INTVAL-1  * End of interval
         LA    R1,WAPRIMES             * Point start of interval
LOOP2    DS    0H
         MVI   0(R1),X'00'             * Mark as non-prime
         BXLE  R1,R14,LOOP2            * Repeat for entire interval
*
* Mark all multiples of three as non-primes
         LA    R14,3                   * Second prime
         LA    R15,WAPRIMES+#INTVAL-1  * End of interval
         LA    R1,WAPRIMES             * Point start of interval
LOOP3    DS    0H
         MVI   0(R1),X'00'             * Mark as non-prime
         BXLE  R1,R14,LOOP3            * Repeat for entire interval
*
* Mark all multiples of five as non-primes
         LA    R14,5                   * Third prime
         LA    R15,WAPRIMES+#INTVAL-1  * End of interval
         LA    R1,WAPRIMES             * Point start of interval
LOOP5    DS    0H
         MVI   0(R1),X'00'             * Mark as non-prime
         BXLE  R1,R14,LOOP5            * Repeat for entire interval

         AIF   (&#MAXP LT 7).SKIP7
*
* Mark all multiples of seven as non-primes
         LA    R14,7                   * Third prime
         LA    R15,WAPRIMES+#INTVAL-1  * End of interval
         LA    R1,WAPRIMES             * Point start of interval
LOOP7    DS    0H
         MVI   0(R1),X'00'             * Mark as non-prime
         BXLE  R1,R14,LOOP7            * Repeat for entire interval
.SKIP7   ANOP

*
** Count the number of potential primes per interval
** Also update the table to contain bit sequence numbers
** And fill table WABIT2OF for translating bit nrs to offset in intval
         LA    R14,1                   * Count each byte
         LA    R15,WAPRIMES+#INTVAL-1  * End of interval
         LA    R1,WAPRIMES             * Point start of interval
         XR    R2,R2                   * Init counter
         XR    R3,R3                   * To hold copy of each byte
         LA    R4,WABIT2OF             * Point first table entry
LOOPCT   DS    0H
         IC    R3,0(R1)                * Obtain byte value
         LA    R2,0(R3,R2)             * And add to total
         LTR   R3,R3                   * This is a possible prime?
         BZ    LOOPCTNX                * Yes: process next entry
         STC   R2,0(R1)                * Insert bit sequence nr.
         LR    R5,R1                   * Copy address
         LA    R6,WAPRIMES             *
         SR    R5,R6                   * Determine offset in table
         STC   R5,0(R4)                * Save offset for bit nr
         LA    R4,1(,R4)               * and point next wabit2of entry
LOOPCTNX DS    0H
         BXLE  R1,R14,LOOPCT           * Repeat for entire interval
         STH   R2,WAINTVBITS           * Nr of candidates per interval
         CLC   WAINTVBITS,=H'&CAND'    * Nr of candidates matches?
         BNE   ABEND001                * On mismatch: Abend
         LA    R2,7(,R2)               * Add for rounding up
         SRA   R2,3                    * Divide by 8 to get bytes
         STH   R2,WAINTVBYTS           * Save nr of bytes per interval

*
** Fill entire wamasks array
         LH    R3,=X'FF7F'             * Mask for bit 1
         LA    R2,8                    * Nr of bit masks required
         LA    R1,WAMASKS              * Point to masks array
MASKLOOP DS    0H
         STC   R3,0(,R1)               * Save bit mask
         SRA   R3,1                    * Shift 0-bit 1 position
         LA    R1,1(,R1)               * Point next entry
         BCT   R2,MASKLOOP             * Repeat for each mask

         L     R14,WASTPRET            * Retrieve return address
         BR    R14                     * Return to mainline

         DROP  ,
***********************************************************************
*
* Subroutine to find next prime to be processed
*
* Input : Workarea fields WAPRIMB+WAPRIMX = current prime
*         Workarea PRIMPTR1 = pointer to first bitmap array
*         R11 --> Current PRIMHDR
* Output: R15=0: ok, R15=4: No more primes
*         WAPRIMB+WAPRIMX updated
*
* Register allocations:
* R13 - workarea
* R12 - codebase
* R11 - Current primhdr
* R10 - Start of first bitstring array
* R9  - Pointer in bitstring array
* R8  - Highest interval number in area
* R6/7- Copy of bitstring of current interval
* R5  - Loop counter
*
***********************************************************************
FNP      DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         USING PRIMHDR,R11
         ST    R14,WAFNPRET            * Save return address
*
** First step: locate currently processed prime's bit location
         L     R10,WAPRHDR1            * Point first Header area
         L     R10,PRIMPTR-PRIMHDR(R10) * Point bitmap area
         L     R5,WAFNPR5              * Reload bit index
         L     R9,WAFNPR9              * Reload bitstring pointer
         L     R8,PRIMLAST             * Get highest valid interval nr
*
** Load bitstring - may have been changed by removing non-primes!
         AIF   (&#MAXP EQ 5).LOAD5
         AIF   (&#MAXP EQ 7).LOAD7
         MNOTE 12,'Unsupported value for #MAXP'
.LOAD5   ANOP  ,
         XR    R6,R6                   * Set sign bit
         IC    R7,0(R9)                * Get interval bitstring
         SLDA  R6,63-&CAND             * Move bitstring to hi-order
*                                      *    excluding sign position
         AGO   .LOADED
.LOAD7   ANOP  ,
         XR    R6,R6                   * Set sign bit to zero
         ICM   R6,B'0011',0(R9)        * Load first 16 bits
         ICM   R7,B'1111',2(R9)        * Load trailing 32 bits
         SLDA  R6,63-&CAND             * Move bitstring to hi-order
*                                      *    excluding sign position
.LOADED  ANOP  ,
         LA    R15,&CAND+1             * Determine nr of bits used up
         SR    R15,R5                  * this is the nr of bits to
         SLDA  R6,0(R15)               * shift out before searching
         BCTR  R5,R0                   * Decrement nr of bits left

*
** Ok, we've found the right bit - search the next 1-bit
FNPSRCH  DS    0H
         SLDA  R6,1                    * Shift out next bit
         BO    FNPFOUND                * One out = found next prime;
*                                      * But index will be 1 too high
         BZ    FNPNEXT                 * Remainder of bit string is 0
         BCT   R5,FNPSRCH              * Go try next bit in string
*
* Bitstring has been emptied: load next string
FNPNEXT  DS    0H
         L     R1,WAPRIMB              * Get interval nr
         LA    R1,1(,R1)               * Increment
         ST    R1,WAPRIMB              * Save incremented interval nr
         CR    R1,R8                   * Compare with highest valid
         BH    FNPEND                  * End of strings area!
         LA    R9,&CAND/8(,R9)         * Point next bitstring
*        XR    R6,R6                   * Sign bit always 0 here
         AIF   (&#MAXP EQ 5).LOAD_5
         AIF   (&#MAXP EQ 7).LOAD_7
         MNOTE 12,'Unsupported value for #MAXP'
.LOAD_5  ANOP  ,
         ICM   R7,B'0001',0(R9)        * Get interval bitstring
         BZ    FNPNEXT                 * Skip interval: no primes
         SLDA  R6,63-&CAND             * Move bitstring to hi-order
*                                      *    excluding sign position
         AGO   .LOADED_
.LOAD_7  ANOP  ,
         ICM   R6,B'0011',0(R9)        * Load first 16 bits
         ICM   R7,B'1111',2(R9)        * Load trailing 32 bits
         SLDA  R6,63-&CAND             * Move bitstring to hi-order
*                                      *    excluding sign position
         BZ    FNPNEXT                 * Skip interval: no primes
.LOADED_ ANOP  ,

*
** Now we must scan the bitstring for a '1' value
         LA    R5,&CAND                * Nr of bits in string
         B     FNPSRCH                 * Ok: start scanning

* We've found a one-bit, WAPRIMB is correct for the current interval
* Determine new value for WAPRIMX
FNPFOUND DS    0H                      * Index in R5 is 1 too high
*                                      * R5 now in range 8 thru 1
         LA    R1,&CAND                * Convert decremented loop ctr
*                                      *   in range 0 thru 7
         SR    R1,R5                   * to incremented index value
         IC    R1,WABIT2OF(R1)         * for wabit2of array
         STC   R1,WAPRIMX              * Save new excess value

*
** Save current status before leaving
         ST    R5,WAFNPR5              * Save bit index
         ST    R9,WAFNPR9              * Save bitstring address

         XR    R15,R15                 * Set retcode 0
         L     R14,WAFNPRET            * Retrieve return address
         BR    R14                     * Return to mainline

FNPEND   DS    0H                      * Not found handler
         LA    R15,4                   * Set retcode 4
         L     R14,WAFNPRET            * Retrieve return address
         BR    R14                     * Return to mainline

         DROP  ,
***********************************************************************
*
* Square a Prime nr in excess-30/210 notation
*
* Input : Workarea fields WAPRIMB+WAPRIMX = current prime
* Output: PRIMSQR+PRIMSQRX updated
*         WADBLB+WADBLX updated
*
* Register allocations:
* R13 - workarea
* R12 - codebase
* R11 - Current primhdr
*
* Number in excess notation = N*I+O
* where n=interval nr, I=interval size, O=offset in interval
*
***********************************************************************
SQP      DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         USING PRIMHDR,R11
         ST    R14,WASQPRET            * Save return address

*
** First we'll take the current number
         LA    R10,#INTVAL             * Get interval size
         L     R9,WAPRIMB              * Get interval nr
         XR    R1,R1                   * Wipe register
         IC    R1,WAPRIMX              * To contain offset

*
** Calculate the double value
         LA    R6,0(R9,R9)             * Double interval nr
         LA    R7,0(R1,R1)             * Double offset
         CR    R7,R10                  * Exceeds interval size?
         BNH   SQPDBLOK                * If <= tehn no need to adjust
         LA    R6,1(,R6)               * Increment interval count
         SR    R7,R10                  * Decrement excess
SQPDBLOK DS    0H
         ST    R6,WADBLB               * Save intervals for DBL
         STC   R7,WADBLX               * Save excess for DBL

*
** Calculate square = starting number
         MR    R8,R10                  * R9*R10 --> R8R9
         AR    R9,R1                   * Add offset
         BO    ABEND003                * Abort if too large
         MR    R8,R9                   * Take square into R8R9
         DR    R8,R10                  * Divide by interval size
         ST    R9,WACURB               * Save interval number
         STC   R8,WACURX               * Save excess (remainder)

         L     R14,WASQPRET            * Retrieve return address
         BR    R14                     * Return to mainline

         DROP  ,
***********************************************************************
*
* Remove all multiples of current prime
*
* Register allocations:
* R15    - work register
* R14    - Size of interval
* R13    - workarea
* R12    - codebase
* R11    - Current primhdr
* R10    - Pointer to waprimes
* R8/9   - Current number (base/excess)
* R6/7   - Doubled prime (base/excess)
* R5     - Doubled prime (base * interval-size in bytes)
* R4     - pointer to current bitstring
* R3     - Mask pointer for resetting non-primes
* R2     - Byte index of bit within bitstring
* R1     - work register / bit index of bit within byte
* R0     - High interval number of bitstring area
*
***********************************************************************
RMV      DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         USING PRIMHDR,R11
         ST    R14,WARMVRET            * Save return address
*
** Setup registers
         LA    R14,#INTVAL             * Interval size
         LA    R10,WAPRIMES            * Point validity array
         L     R8,WACURB               * Get current number (base)
         XR    R9,R9                   *
         IC    R9,WACURX               * Get current number (excess)
         L     R6,WADBLB               * Get doubled prime (base)
         XR    R7,R7                   *
         IC    R7,WADBLX               * Get doubled prime (excess)
         AIF   (&#MAXP EQ 7).PTR7
.PTR5    ANOP  ,
         L     R15,PRIMPTR             * Point to Primes area
         LA    R4,0(R8,R15)            * Save current interval address
         LR    R5,R6                   * Interval size = 1
         AGO   .PTROK
.PTR7    ANOP  ,
         LH    R2,WAINTVBYTS           * Bytes per interval
         LR    R3,R8                   * Current interval nr
         MR    R2,R2                   * R2*R3 --> R2R3
         L     R2,PRIMPTR              * Point to Primes area
         LA    R4,0(R3,R2)             * Save current interval address
         LR    R3,R6                   * WADBLB
         LA    R2,&CAND/8              * Nr of bytes per interval
         MR    R2,R2                   * R2*R3 --> R2R3
         LR    R5,R3                   * Nr of bytes for WADBLB
.PTROK   ANOP  ,
         XR    R3,R3                   *
         XR    R2,R2                   *
         XR    R1,R1                   *
         L     R0,PRIMLAST             * Get last interval to process

*
** Remove current number
RMVNEXT  DS    0H
         IC    R1,0(R9,R10)            * Get candidate index nr
         LTR   R1,R1                   * Is it a one?
         BZ    RMVADD                  * No candidate - go add
         AIF   (&#MAXP NE 7).BITADROK
         LR    R2,R1                   * Copy bit index in bitstring
         SRA   R2,3                    * Create byte index
         N     R1,=X'00000007'         * Create bit index within byte
         BNZ   RMVADROK                * Bit address down to zero
         BCTR  R2,R0                   * Adjust byte index
         LA    R1,8                    *   and bit index too
RMVADROK DS    0H
.BITADROK ANOP ,
         LA    R3,WAMASKS-1(R1)        * Point at mask to be used
         LA    R15,0(R2,R4)            * Point byte to update
         NC    0(1,R15),0(R3)          * Set current bit to 'noprime'

*
** Number has been processed: Add the doubled prime to find next number
RMVADD   DS    0H
         LA    R9,0(R9,R7)             * New offset
         CR    R9,R14                  * Exceeds interval size?
         BNH   RMVADD0                 * No: simple addition
         LA    R8,1(R6,R8)             * New interval number
         SR    R9,R14                  * New excess value
         LA    R4,&CAND/8(R4,R5)       * New bitstring address
         B     RMVADDOK                * Ok: done
RMVADD0  DS    0H
         LA    R8,0(R6,R8)             * New interval number
         LA    R4,0(R4,R5)             * New bitstring address
RMVADDOK DS    0H
         CR    R8,R0                   * End of bitstring area?
         BNH   RMVNEXT                 * No: remove this non-prime too

         L     R14,WARMVRET            * Retrieve return address
         BR    R14                     * Return to mainline

         DROP  ,
***********************************************************************
*
* Open Report file and setup for printing
*
* Register allocations:
* R13 - Workarea
* R12 - Codebase
* R11 - PRIMHDR pointer (not used)
* R10 - DCB pointer, record pointer
*
***********************************************************************
INITRPT  DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         ST    R14,WARPTRET            * Save return address

*
** Open DCB - z390 will only open a DCB in static storage :-(
         MVC   WASYSOUT(SYSOUT_LEN),SYSOUT * Copy DCB prototype
         OPEN  (WASYSOUT,OUTPUT)       * Open Sysout

*
** Allocate and init print buffer
         LH    R10,=AL2(#LPP*(#CPL+1)) * Nr of bytes for a page
         ST    R10,WARPTBSZ            * Save buffer size
         GETMAIN R,LV=(R10),LOC=ABOVE  * Acquire page buffer
         LR    R10,R1                  * Set ptr to first line
         ST    R10,WARPTBUF            * Save ptr to report buffer
*
         LR    R0,R1                   * Destination pointer
         L     R1,WARPTBSZ             * Destination length
         XR    R14,R14                 * Source pointer
         XR    R15,R15                 * Source length
         ICM   R15,B'1000',=C' '       * Filler byte
         MVCL  R0,R14                  * Fill buffer with spaces
*
** Report pre-determined primes
         MVC   0(1,R10),=C'2'          * Report 2 as a prime
         BAL   R14,WRT                 * Go write the line
         MVC   0(1,R10),=C'3'          * Report 3 as a prime
         BAL   R14,WRT                 * Go write the line
         MVC   0(1,R10),=C'5'          * Report 5 as a prime
         BAL   R14,WRT                 * Go write the line
         AIF   (&#MAXP EQ 5).INRPTOK
         MVC   0(1,R10),=C'7'          * Report 7 as a prime
         BAL   R14,WRT                 * Go write the line
.INRPTOK ANOP  ,
*
         L     R14,WARPTRET            * Retrieve return address
         BR    R14                     * Return to mainline

         DROP  ,
***********************************************************************
*
* Report a single prime
*
* Input : WAPRIMB+WAPRIMX
* Output: Printed line on SYSOUT
*
* Register allocations:
* R13 - Workarea
* R12 - Codebase
* R11 - Current primhdr area (not used)
*
***********************************************************************
RPTPRIM  DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         ST    R14,WARPTRET            * Save return address
*
* Create correct number in binary
         LA    R10,#INTVAL             * Interval size
         L     R9,WAPRIMB              * Interval nr
         MR    R8,R10                  * R9*R10 --> R8R9
         XR    R10,R10                 *
         IC    R10,WAPRIMX             * Get offset
         AR    R9,R10                  * Add to number
*
* Convert to display format
         CVD   R9,WAPRIMPK             *
         MVC   WAPRIMNR,RPTPRIM_MASK   * Setup mask for edit/mark
         EDMK  WAPRIMNR,WAPRIMPK       * Set R1 to first digit
         OI    WAPRIMNR+L'WAPRIMNR-1,X'F0' * Remove sign
*
         L     R10,WARPTBUF            * Point printer buffer
         LA    R15,WAPRIMNR+L'WAPRIMNR-2 * Point end of edited number
         SR    R15,R1                  * Get nr of digits -1 for MVC
         EX    R15,RPTPRIM_MOVE        * Move valid digits
         BAL   R14,WRT
*
         L     R14,WARPTRET            * Retrieve return address
         BR    R14                     * Return to mainline

RPTPRIM_MASK DC (L'WAPRIMNR)X'20'      * Required nr of digit selectors
RPTPRIM_MOVE DC 0H
         MVC   0(0,R10),0(R1)          * Move edited number to line

         DROP  ,
***********************************************************************
*
* Write a line from the print buffer
*
* Register input:
* R13 - Workarea
* R12 - Codebase
* R11 - First primhdr area (not used)
* R10 - Record pointer
*
***********************************************************************
WRT      DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         ST    R14,WAWRTRET            * Save return address
*
** Data is in EBCDIC - if ASCII requested: translate
         CLI   WACHARS,C'A'            * Ascii requested?
         BNE   WRTPUT
         TR    0(#CPL,R10),EBC2ASC     * Change to ASCII
         MVI   #CPL-1(R10),X'0D'       * Add carriage return
         MVI   #CPL(R10),X'0A'         *   and newline characters

WRTPUT   DS    0H
         PUT   WASYSOUT,(R10)          * Write the line
*
** Re-init buffer with spaces
         LR    R0,R10                  * Point start of buffer
         L     R1,WARPTBSZ             * Destination length
         XR    R14,R14                 * Source pointer
         XR    R15,R15                 * Source length
         ICM   R15,B'1000',=C' '       * Filler byte
         MVCL  R0,R14                  * Fill buffer with spaces
*
         L     R14,WAWRTRET            * Retrieve return address
         BR    R14                     * Return to mainline

         DROP  ,
***********************************************************************
*
* Close Report file
*
* Register allocations:
* R13 - Workarea
* R12 - Codebase
* R11 - PRIMHDR area (not used)
* R10 - DCB pointer
*
***********************************************************************
ENDRPT   DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         ST    R14,WARPTRET            * Save return address

*
** Release print buffer storage
         L     R10,WARPTBUF            * Point buffer area
         L     R9,WARPTBSZ             * Obtain area length
         FREEMAIN RU,LV=(R9),A=(R10)   * Free report buffer area
         SR    R0,R0                   * Set to zero
         ST    R0,WARPTBUF             * Wipe pointer to buffer
         ST    R0,WARPTBSZ             * And length

*
** Close DCB - z390 will only open/close a DCB in static storage :-(
         CLOSE (WASYSOUT)              * Close Sysout

         L     R14,WARPTRET            * Retrieve return address
         BR    R14                     * Return to mainline

         DROP  ,
***********************************************************************
*
* To exit program - release all acquired storage
*
* Register allocations:
* R13 - Workarea
* R12 - Codebase
* R11 - PRIMHDR area
* R10 - bitmap pointer
*
***********************************************************************
EXIT     DS    0H
         USING WORKAREA,R13
         USING BXAPRIM,R12
         USING PRIMHDR,R11

         ICM   R11,B'1111',WAPRHDR1    * Point first HDR area
         BZ    EXIT_WA                 * No more HDR areas
         ICM   R10,B'1111',PRIMPTR     * Point to bitmap area
         BZ    EXIT_HDR                * Not allocated: free HDR
         L     R9,PRIMLEN              * Get bitmap length
         FREEMAIN RU,LV=(R9),A=(R10)   * Free bitmap area
         XC    PRIMPTR,PRIMPTR         * Set ptr to zero
         XC    PRIMLEN,PRIMLEN         *     and length as well
EXIT_HDR DS    0H                      * Free HDR area
         MVC   WAPRHDR1,PRIMNEXT       * Remove HDR from chain
         LA    R9,PRIMHDR_LEN          *
         FREEMAIN RU,LV=(R9),A=(R11)   * Free PRIMHDR area
         B     EXIT                    * And go free next HDR
         DROP  R11                     * HDR no longer addressable

EXIT_WA  DS    0H                      * Workarea handling
         L     R11,4(,R13)             * Get ptr to prev savearea
         LA    R10,WORKAREA_LEN        * Size of area to be freed
         FREEMAIN RU,LV=(R10),A=(R13)  * Free workarea
         DROP  R13                     * End addressability of workarea
         LR    R13,R11                 * Set prev savearea current
         LM    R14,R12,12(R13)         * Reset all registers
         XR    R15,R15                 * Set RC=0
         BR    R14                     * Return

         DROP  ,
***********************************************************************
         DS    0D
EBC2ASC  DC    256X'00'
         ORG   EBC2ASC+C' '
         DC    X'20'                   * Ascii space
         ORG   EBC2ASC+C'.'
         DC    X'2E'                   * Ascii period
         ORG   EBC2ASC+C','
         DC    X'2C'                   * Ascii comma
         ORG   EBC2ASC+C'0'
         DC    X'30313233343536373839' * Ascii digits
         ORG   ,

&LRECL   SETA  #CPL+1
SYSOUT   DCB   DDNAME=SYSOUT,DSORG=PS,MACRF=PM,LRECL=&LRECL,RECFM=FBA
SYSOUT_LEN EQU *-SYSOUT
         LTORG
         END
./ ADD NAME=BXATEST  0100-20110-20110-2315-00170-00170-00000-BXAASM  15
*PROCESS FLAG(SUBSTR)
*PROCESS RENT
***********************************************************************
*
* BIXXAMS - Bixoft Cross Access Method Services
* Licensed material - Property of B.V. Bixoft
*
* This program can be licensed or used on an as-is basis.
* No warranty, neither implicit nor explicit, is given.
* It remains your own responsibility to ensure the correct
* working of this program in your installation.
*
* Suggestions for improvement are always welcome at
* http://www.bixoft.com  or mail to  bixoft@bixoft.nl
*
* (C) Copyright B.V. Bixoft, 1999-2000
***********************************************************************
*
* This program tests a condition string, which is passed as a
* parameter on the exec statement. Syntax:
* PARM='parm1 oper parm2'
* where parm1 and parm2 are the comparands and
* oper is either EQ or NE
* The delimiters are single spaces
*
***********************************************************************
         PGM   VERSION=V00R00M00,      * Version number                *
               HDRTXT='Bixxams condition tester',                      *
               WORKAREA=BXASAVE,       * Dynamic area                  *
               SAVES=0,                * Internal save-areas           *
               ABND=4090               * Abend code for BXATEST
*
* Assign some global registers
R_RCD    EQUREG ,                      * Assign retcode register
         USE   R_RCD,SCOPE=CALLED      * Set register in use
R_TMP    EQU   R_RCD                   * retcode reg also temp reg
R_PTR1   EQUREG ,                      * Ptr to first operand
         USE   R_PTR1                  * Set register in use
R_PTR2   EQUREG ,                      * Ptr to second operand
         USE   R_PTR2                  * Set register in use
R_PTROP  EQUREG ,                      * Ptr to operator
         USE   R_PTROP                 * Set register in use
R_LEN1   EQUREG ,                      * Length of first operand
         USE   R_LEN1                  * Set register in use
R_LEN2   EQUREG ,                      * Length of second operand
         USE   R_LEN2                  * Set register in use
R_LENOP  EQUREG ,                      * Length of operator
         USE   R_LENOP                 * Set register in use
*
* Retrieve JCL parameter - if specified - and save in R_PTR1
         IF    R1,Z                    * Pointer to parmlist valid?
          ABND ,                       * No: issue error
         ENDIF ,                       *
         L     R_PTR1,0(,R1)           * Retrieve ptr to JCL parm
         CLEAR (R_PTR1,*ADDR)          * Wipe hi-order bit
         IF    R_PTR1,Z                * If it is invalid
          ABND ,                       * issue error
         ENDIF ,                       *
         LH    R_LEN1,0(R_PTR1)        * First halfword is length
         INC   R_PTR1,2                * Point start of text of parm
         IF    R_LEN1,GT,256           * If it is too long
          ABND ,                       * Issue error
         ENDIF ,                       *
         IF    R_LEN1,Z                * If no parm was specified
          ABND ,                       * Issue error
         ENDIF ,                       *
*
* Find first space in input string
         L     R_TMP,=A(TRTAB1)        * Point table to be used
         EXTRT 0(R_LEN1,R_PTR1),0(R_TMP) * Search first space
         ABND  Z                       * Abend if no space found
*
* Set pointer to opcode
         LA    R_PTROP,1(,R1)          * Point first byte of opcode
         CPY   R_PTR2,R_PTROP          * Start of remainder of string
*
* Determine length of operand 1 and remainder of string
         CPY   R_LEN2,R_LEN1           * Copy string length
         CPY   R_TMP,R1                * Delimiter location
         SR    R_TMP,R_PTR1            * Nr of chars in first operand
         ABND  Z                       * Empty operand is error
         CPY   R_LEN1,R_TMP            * Set length of operand 1
         SR    R_LEN2,R_LEN1           * Remaining string length
         DEC   R_LEN2                  *    after delimiter
         IF    R_LEN2,LE,0             * Something left?
          ABND ,                       * No: error
         ENDIF ,                       *
*
* Determine length of opcode and remainder of string
         L     R_TMP,=A(TRTAB1)        * Point table to be used
         EXTRT 0(R_LEN2,R_PTR2),0(R_TMP) * Search next space
         ABND  Z                       * Abend if no space found
         CPY   R_LENOP,R1              * Point to delimiter
         SR    R_LENOP,R_PTROP         * Nr of chars in operator
         ABND  Z                       * No operator: error
         LA    R_PTR2,1(,R1)           * Point after delimiter
         SR    R_LEN2,R_LENOP          * Remove operator from length
         DEC   R_LEN2                  *    and delimiter as well
         IF    R_LEN2,LE,0             * Something left?
          ABND ,                       * No: error
         ENDIF ,                       *
*
* Determine length of operand 2
         L     R_TMP,=A(TRTAB1)        * Point table to be used
         EXTRT 0(R_LEN2,R_PTR2),0(R_TMP) * Search next space
         IF    NZ                      * Delimiter found
          CPY  R_LEN2,R1               * Set to delimiter location
          SR   R_LEN2,R_PTR2           * Nr of chars in operand 2
          ABND Z                       * Missing operand: error
         ENDIF ,                       *
*
* Test for equal comparison?
         IF    E,EXCLC,0(R_LENOP,R_PTROP),=CL2'EQ' * EQ comparison?
          IF   R_LEN1,NE,R_LEN2        * Lengths should be equal
           GOTO RETCD4                 * Return mismatch
          ENDIF ,                      *
          EXCLC 0(R_LEN1,R_PTR1),0(R_PTR2) * Operands equal?
          GOTO RETCD0,E                * Yes: return ok
          GOTO RETCD4                  * No: return mismatch
         ENDIF ,
*
* Test for unequal comparison?
         IF    E,EXCLC,0(R_LENOP,R_PTROP),=CL2'NE' * NE comparison?
          IF   R_LEN1,NE,R_LEN2        * Lengths should be unequal
           GOTO RETCD0                 * Return mismatch
          ENDIF ,                      *
          EXCLC 0(R_LEN1,R_PTR1),0(R_PTR2) * Operands unequal?
          GOTO RETCD0,NE               * Yes: return ok
          GOTO RETCD4                  * No: return mismatch
         ENDIF ,
*
* Invalid operator
         ABND  ,                       *
*
* Return 4 when specified condition is not met
RETCD4   LABEL ,                       *
         LA    R15,4                   * Set retcode
         GOTO  EXIT                    *
*
* Return 0 when specified condition is met
RETCD0   LABEL ,                       *
         CLEAR R15                     * Set retcode
*
EXIT     LABEL ,                       * Exit point
*
* Release registers
         DROP  R_PTR1                  *
         DROP  R_PTR2                  *
         DROP  R_PTROP                 *
         DROP  R_LEN1                  *
         DROP  R_LEN2                  *
         DROP  R_RCD                   *
*
* And exit
         RETRN RC=*                    * Quit this program
***********************************************************************
*
* Constants etc.
*
***********************************************************************
         LTORG ,                       *
***********************************************************************
*
* Indirectly addressable Plists and constants
*
***********************************************************************
TRTAB1   TRTAB ,                       * Select no characters          *
               CHARS=(C' ')            * Except space
*
         END
./ ADD NAME=BXAUNLD  0100-20110-20110-2315-00671-00671-00000-BXAASM  15
*PROCESS FLAG(SUBSTR)
*PROCESS RENT
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License
* or (at your option) any later version.
* The license text is available at the following internet addresses:
* - http://www.bixoft.com/english/gpl.htm
* - http://fsf.org
* - http://opensource.org
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
* See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to either of the following:
* the Free Software Foundation, Inc.      B.V. Bixoft
* 59 Temple Place, Suite 330              Rogge 9
* Boston, MA 02111-1307                   7261 JA Ruurlo
* United States of America                The Netherlands
*
*                                         e-mail: bixoft@bixoft.nl
*                                         phone : +31-6-22755401
*
***********************************************************************
*
* BIXXAMS - Bixoft Cross Access Method Services
* Licensed material - Property of B.V. Bixoft
*
* This program can be licensed or used on an as-is basis.
* No warranty, neither implicit nor explicit, is given.
* It remains your own responsibility to ensure the correct
* working of this program in your installation.
*
* Suggestions for improvement are always welcome at
* http://www.bixoft.com  or mail to  bixoft@bixoft.nl
*
* (C) Copyright B.V. Bixoft, 1999-2000
***********************************************************************
*
* This program converts a PDS or PDSE to a sequential dataset that
*      contains a job stream, capable of recreating the dataset.
*
***********************************************************************
         PGM   VERSION=V00R00M00,      * Version number                *
               HDRTXT='Bixxams PDS unload program',                    *
               WORKAREA=UNLD,          * Dynamic area                  *
               SAVES=3,                * Internal save-areas           *
               ABND=0130,              * Abend code for BXAUNLD        *
               MAPS=($UNLD,            * Private control blocks        *
               CVT,DCB,DCBE,JESCT,JFCB,IOB,PDS,PSA,TCB,TIOT)
*
* Assign some global registers
R_RCD    EQUREG ,                      * Assign retcode register
         USE   R_RCD,SCOPE=CALLED      * Set register in use
R_TMP    EQU   R_RCD                   * Use for temp. also
R_LEN    EQUREG ,                      * Assign length register
         USE   R_LEN,SCOPE=CALLED      * Set register in use
*
* Retrieve JCL parameter - if specified - and save in UNLD
         IF    R1,NZ                   * Parm ptr was passed?
          L    R_TMP,0(,R1)            * Retrieve ptr to JCL parm
          CLEAR (R_TMP,*ADDR)          * Wipe hi-order bit
          IF   R_TMP,NZ                * If it is valid
           LH  R_LEN,0(R_TMP)          * First halfword is length
           IF  R_LEN,GT,8              * If it is too long
            LA R_LEN,8                 * Truncate to 8 characters
           ELSE ,                      * It might be too short
            MVC UNLPARM,=CL8' '        * pre-fill with spaces
           ENDIF ,                     *
           IF  R_LEN,NZ                * If length is valid
            EXMVC UNLPARM(R_LEN),2(R_TMP) * Copy parameter text
            SETON UNLSPRM              * Set valid parm indicator
           ENDIF ,                     *
          ENDIF ,                      *
         ENDIF ,                       *
*
* Create in-storage table of directory entries
         EXSR  CRTDIR                  * Create directory table
*
* Process the library: read & copy all members
         EXSR  RDLIB                   * Read all members in the lib
*
* Release the directory table
         CPY   R_TMP,UNLDIRP           * Point table
         CPY   R_LEN,UNLDIRSZ          * Retrieve length of table
         STORAGE RELEASE,              * Free the directory table      *
               LENGTH=(R_LEN),         *                               *
               ADDR=(R_TMP)            *
         CLEAR UNLDIRP                 * Wipe ptr to buffer
         CLEAR UNLDIRFP                * Wipe ptr to free entry
         CLEAR UNLDIRSZ                * And buffer size
*
* Release remaining registers
         DROP  R_LEN                   *
         DROP  R_RCD                   *
*
* And exit
         RETRN RC=0                    * Quit this program
***********************************************************************
*
* Routine to create an in-storage table of directrory entries
*
***********************************************************************
CRTDIR   BEGSR ,                       *
*
* Create BPAM DCB and open it.
         MVPL  UNLDCB1,UNL_DCB1        * Copy DCB for PDS
         MVPL  UNLDCBE1,UNL_DCBE       * Copy DCBE for PDS
         USE   DCB,UNLDCB1             * Set DCB fields addressable
         USE   DCBE,UNLDCBE1           * Set DCBE fields addressable
         SET   DCBDCBE,UNLDCBE1        * Point from DCB to DCBE
         SET   DCBEEODA,LIST_EODAD     * Set ptr to end-of-member rtn
*
         MVPL  UNLOPEN,UNL_OPEN        * Copy OPEN parmlist
         OPEN  (UNLDCB1,INPUT),        * Open the input dataset        *
               MF=(E,UNLOPEN)          *
         ABND  TSTRC,RCD=R_RCD         *
*
* Allocate buffer for reading dir blocks
         LA    R_LEN,PDSDIRBS          * Room for 8 entries
         STORAGE OBTAIN,               * Allocate storage              *
               LENGTH=(R_LEN),         * for 8 entries                 *
               LOC=ANY                 *
         CPY   UNLBUFP,R1              * Save ptr to buffer
         CPY   UNLBUFSZ,R_LEN          * Save length of buffer
*
* Allocate initial buffer for 8 directory entries
         LA    R_LEN,8*PDS_LEN         * Room for 8 entries
         STORAGE OBTAIN,               * Allocate storage              *
               LENGTH=(R_LEN),         * for 8 entries                 *
               LOC=ANY                 *
         CPY   UNLDIRP,R1              * Save ptr to table
         CPY   UNLDIRFP,R1             * Set ptr to 1st free element
         CPY   UNLDIRSZ,R_LEN          * Save length of table
*
* Prepare for reading the directory
         CPY   UNLBLKSI,DCBBLKSI       * Save blocksize
         CPY   DCBBLKSI,PDSDIRBS       * Set blocksize for dir block
         SETOF UNLSEOF                 * Signal No EOF reached yet
*
* Read directory - 1 block at a time to copy relevant dir-info
         DO    UNTIL,UNLSEOF           * Repeat until EOF occurs
          MVPL UNLDECB1,UNL_DECB       * Set up prototype DECB
          CPY  R_TMP,UNLBUFP           * Point to block buffer
          READ UNLDECB1,SF,            * Read forward                  *
               UNLDCB1,(R_TMP),'S',    *   1 directory block into buf  *
               MF=E                    *
          CHECK UNLDECB1               * Wait for read to complete
          EXSR CPYDIRB                 * Copy directory block
         ENDDO ,                       *
*
* Restore correct blocksize to DCB
         CPY   DCBBLKSI,UNLBLKSI       * Restore blocksize
*
* Release buffer area
         CPY   R_TMP,UNLBUFP           * Point record buffer
         CPY   R_LEN,UNLBUFSZ          * Retrieve length of buffer
         STORAGE RELEASE,              * Free the directory buffer     *
               LENGTH=(R_LEN),         *                               *
               ADDR=(R_TMP)            *
         CLEAR UNLBUFP                 * Wipe ptr to buffer
         CLEAR UNLBUFSZ                * And buffer size
*
* Close input dataset
         MVPL  UNLCLOS,UNL_CLOS        * Copy CLOSE plist
         CLOSE (UNLDCB1),MF=(E,UNLCLOS) * Close the input dataset
         ABND  TSTRC,RCD=R_RCD         *
*
         ENDSR ,                       *
***********************************************************************
*
* Routine to copy direntries from a dirblock to our own table
*
***********************************************************************
CPYDIRB  BEGSR ,                       *
*
R_PDS    EQUREG ,                      * Assign ptr to PDS entry
         USE   PDS,R_PDS               * Set PDS direntry addressable
         CPY   R_PDS,UNLBUFP           * Point to dir buffer
*
R_PDSEND EQUREG ,                      * Assign ptr to end of PDS block
         USE   R_PDSEND                * Set register in use
         CPY   R_PDSEND,R_PDS          * Point to buffer
         AH    R_PDSEND,0(R_PDS)       * Nr of occupied bytes in 1st H
         INC   R_PDS,2                 * Point to first entry
*
* Process all entries in the current directory block
         DO    WHILE,R_PDS,LT,R_PDSEND * For each valid entry
          CPY  R1,R_PDS                * Ptr to entry to be copied
          EXSR CPYDIRE                 * Copy a single direntry
          LA   R_LEN,TTRNUSLN          * Load mask for length bits
          IC   R_TMP,TTRNINDC          * Retrieve indicator byte
          NR   R_LEN,R_TMP             * Extract length indication
          SLL  R_LEN,1                 * Length of user data in bytes
          LA   R_PDS,PDS_LEN(R_LEN,R_PDS) * Point next entry
         ENDDO ,                       *
*
         ENDSR ,                       *
***********************************************************************
*
* Routine to copy a single direntry to our table
*
***********************************************************************
CPYDIRE  BEGSR ,                       *
*
         USE   PDS,R_PDS               * Set PDS direntry addressable
         CPY   R_PDS,R1                * Point to current entry
*
R_TABEND EQUREG ,                      * Allocate ptr to end of table
         USE   R_TABEND                * Set reg in use
         CPY   R_TABEND,UNLDIRP        * Point to dir table
         A     R_TABEND,UNLDIRSZ       * Point past table
*
R_TAB    EQUREG ,                      * Assign current entry pointer
         USE   R_TAB                   * Set poiner reg in use
         CPY   R_TAB,UNLDIRFP          * Point current free entry
*
* If last entry: set EOF indicator
         IF    E,CLC,PDSNAME,=8X'FF'   * Terminating entry is all X'FF'
          SETON UNLSEOF                * Set end-of-directory
         ENDIF ,                       *
*
* If our table is full we must enlarge it
         IF    NOT,UNLSEOF,AND,        * Entry is valid?               *
               R_TAB,EQ,R_TABEND       * And table is full?
          L    R_LEN,UNLDIRSZ          * Retrieve current size
          SLL  R_LEN,1                 * Double current size
          STORAGE OBTAIN,              * Allocate new buffer           *
               LENGTH=(R_LEN),         *                               *
               LOC=ANY                 *
          CPY  R_TAB,R1                * Save ptr to new table
          CPY  R_LEN,UNLDIRSZ          * Reload old table size
          CPY  R_TMP,UNLDIRP           * Point existing table
          CPY  ((R_TAB),(R_LEN)),((R_TMP),(R_LEN)) *
          STORAGE RELEASE,             * Free the old buffer           *
               LENGTH=(R_LEN),         *                               *
               ADDR=(R_TMP)            *
          CPY  UNLDIRP,R_TAB           * Save ptr to start of new table
          AR   R_TAB,R_LEN             * Add old size, point free entry
          CPY  UNLDIRFP,R_TAB          * Set current free pointer
          SLL  R_LEN,1                 * Size of new table
          CPY  UNLDIRSZ,R_LEN          * Set new table size
         ENDIF ,                       *
*
* Copy entry to table, advance free entry pointer
         IF    NOT,UNLSEOF             * A valid entry to process?
          MVC  0(PDS_LEN,R_TAB),PDS    * Copy entry to table
          INC  R_TAB,PDS_LEN           * Point next entry
          CPY  UNLDIRFP,R_TAB          * Update free entry ptr
         ENDIF ,                       *
*
         ENDSR ,                       *
***********************************************************************
*
* Routine to read thru all members in sequence
*
***********************************************************************
RDLIB    BEGSR ,                       *
*
* Create BSAM DCB and open it.
         MVPL  UNLDCB2,UNL_DCB2        * Copy DCB for PDS
         MVPL  UNLDCBE2,UNL_DCBE       * Copy DCBE for PDS
         USE   DCB,UNLDCB2             * Set DCB fields addressable
         USE   DCBE,UNLDCBE2           * Set DCBE fields addressable
         SET   DCBDCBE,UNLDCBE2        * Point from DCB to DCBE
         SET   DCBEEODA,LIST_EODAD     * Set ptr to end-of-member rtn
*
         MVPL  UNLOPEN,UNL_OPEN        * Copy OPEN parmlist
         OPEN  (UNLDCB2,INPUT),        * Open the input dataset        *
               MF=(E,UNLOPEN)          *
         ABND  TSTRC,RCD=R_RCD         *
*
* RECFM must be F, FB, V, or VB
         IF    NM,TM,DCBRECFM,DCBRECF+DCBRECV * Either bit must be on
          ABND ,                       * RECFM=U: error
         ENDIF ,
*
* Allocate a buffer
         CPY   R_LEN,DCBBLKSI          * Retrieve block size
         STORAGE OBTAIN,               * Allocate buffer for block     *
               LENGTH=(R_LEN),         *                               *
               LOC=ANY                 *
         CPY   UNLBUFP,R1              * Save ptr to buffer
         CPY   UNLBUFSZ,R_LEN          * and save length of buffer
*
* Create output DCB and open it.
         MVPL  UNLDCBO,UNL_DCBO        * Copy DCB for output dataset
         MVPL  UNLOPEN,UNL_OPEN        * Copy OPEN parmlist
         OPEN  (UNLDCBO,OUTPUT),       * Open the output dataset       *
               MF=(E,UNLOPEN)          *
         ABND  TSTRC,RCD=R_RCD         *
*
* Create jcl statements
         EXSR  CRTJCL                  *
*
* Set up table pointer
         USE   PDS,R_TAB               * Set direntry addressable
         CPY   R_TAB,UNLDIRP           * Point first entry
*
* Loop thru direntries in table
         DO    WHILE,R_TAB,LT,UNLDIRFP * UNLDIRFP points unused entry
          CPY  R1,R_TAB                * Set ptr
          EXSR RDMEM                   * Read the member
          INC  R_TAB,PDS_LEN           * Point next entry
         ENDDO ,                       *
*
* Create terminating control statement for IEBUPDTE
         L     R_TMP,=A(CNTLEND)       * Point prototype end statement
         MVC   UNLBUFO,0(R_TMP)        * Copy prototype control line
         PUT   UNLDCBO,UNLBUFO         * Write control line to output
*
* Create terminating JCL statement for SYSIN dataset
         CLEAR UNLBUFO,C' '            * Pre-fill with spaces
         MVC   UNLBUFO(2),=C'()'       * Insert eof-marker for sysin
         PUT   UNLDCBO,UNLBUFO         * Write JCL line to output
*
* Close output dataset
         MVPL  UNLCLOS,UNL_CLOS        * Copy CLOSE plist
         CLOSE (UNLDCBO),MF=(E,UNLCLOS) * Close the input dataset
         ABND  TSTRC,RCD=R_RCD         *
*
* Close input dataset
         MVPL  UNLCLOS,UNL_CLOS        * Copy CLOSE plist
         CLOSE (UNLDCB2),MF=(E,UNLCLOS) * Close the input dataset
         ABND  TSTRC,RCD=R_RCD         *
*
         ENDSR ,                       *
***********************************************************************
*
* Routine to read 1 member from the library
*
* On entry R1 points to the current directory entry in the table
*
***********************************************************************
RDMEM    BEGSR ,                       *
*
* Set up addressability
         USE   PDS,R_TAB               * Set direntry addressable
         CPY   R_TAB,R1                * Point current entry
*
         USE   DCB,UNLDCB2             * Set DCB fields addressable
         USE   DECB,UNLDECB2           * Set DECB fields addressable
*
* Create control statement for IEBUPDTE
         L     R_TMP,=A(CNTLADD)       * Point prototype add statement
         MVC   UNLBUFO,0(R_TMP)        * Copy prototype control line
         MVC   UNLBUFO+12(8),PDSNAME   * Insert member name
         PUT   UNLDCBO,UNLBUFO         * Write control line to output
*
* Point to start of member
         CPY   UNLTTRN,PDSTTRN         * Copy TTR value for member
         CLEAR UNLTTRN_.TTRNINDC       * Append hex zeroes
         POINT UNLDCB2,UNLTTRN         * Point to start of dataset
         ABND  TSTRC,RCD=R_RCD         * Abend on error
*
* Loop thru all member blocks
         SETOF UNLSEOF                 * Reset end-of-member bit
         DO    UNTIL,UNLSEOF           * Until end-of-member
          MVPL UNLDECB2,UNL_DECB       * Set up prototype DECB
          CPY  R_TMP,UNLBUFP           * Point to block buffer
          READ UNLDECB2,SF,            * Read forward                  *
               UNLDCB2,(R_TMP),'S',    *   1 member data block         *
               MF=E                    *
          CHECK UNLDECB2               * Wait for read to complete
          IF   NOT,UNLSEOF             * A valid block was read?
* For Fixed records: use IOB to determine end-of-buffer
* For Variable records: use BDW to determine end-of-buffer
           IF  DCBRECF                 * Fixed or FB records?
            CPY R_LEN,DCBBLKSI         * Load block length
R_IOB       EQUREG ,                   * Assign IOB ptr
            USE IOBSTDRD,R_IOB         * Set IOB addressable
            CPY R_IOB,DECIOBPT         * And point to IOB
            CPY R_TMP,IOBRESCT         * Load residual count
            DROP R_IOB                 * IOB no longer needed
            SR R_LEN,R_TMP             * Nr of bytes in input buffer
            A  R_LEN,UNLBUFP           * Point past end-of-data
            ST R_LEN,UNLBUFND          * Save end-of-block ptr
            CPY UNLRCDP,UNLBUFP        * Set ptr to first record
           ELSE  ,                     * Must be variable or VB records
R_BUF       EQUREG ,                   * Assign buffer ptr
            USE BDW,R_BUF              * Address block descriptor word
            CPY R_BUF,UNLBUFP          * Point to filled buffer
            CPY R_LEN,BDWBLKLN         * Retrieve length of block
            A  R_LEN,UNLBUFP           * Point past end-of-data
            ST R_LEN,UNLBUFND          * Save end-of-block ptr
            INC R_BUF,BDW_LEN          * Point to first RDW in buffer
            CPY UNLRCDP,R_BUF          * Set ptr to current record
            DROP R_BUF                 * Buffer ptr no longer needed
           ENDIF ,                     *
           EXSR CPYBLK                 * Go copy a block to output
          ENDIF ,                      *
         ENDDO ,                       *
*
         ENDSR ,                       *
***********************************************************************
*
* Routine to copy a whole block of data to the output dataset
*
***********************************************************************
CPYBLK   BEGSR ,                       *
*
* Set up to loop thru the block
R_REC    EQUREG ,                      * Assign record ptr
         USE   RDW,R_REC               * Assume RECFM=V or VB
*
         USE   DCB,UNLDCB2             * Set DCB fields addressable
*
* For each record in the buffer:
* - determine length, advance current record pointer
* - copy record, truncate if too long, pad if too short
* - write record to output dataset
*
         DO    WHILE,UNLRCDP,LT,UNLBUFND * For each record in buffer
*         Determine length, advance current record pointer
          CPY  R_REC,UNLRCDP           * Copy ptr to current record
          IF   DCBRECF                 * Fixed record length:
           CPY R_LEN,DCBLRECL          * Retrieve rec length from DCB
           CPY R_TMP,R_REC             * Copy current record ptr
           INC R_TMP,(R_LEN)           * Point to next record
           CPY UNLRCDP,R_TMP           * Update current record ptr
          ELSE ,                       * Variable records:
           CPY R_LEN,RDWRECLN          * Retrieve length of record
           CPY R_TMP,R_REC             * Copy current record pointer
           INC R_TMP,(R_LEN)           * Point next record in buffer
           CPY UNLRCDP,R_TMP           * Update current record pointer
           INC R_REC,RDW_LEN           * Point to start of record data
           DEC R_LEN,RDW_LEN           * And adjust data length
          ENDIF ,                      *
*         Copy record, truncate if too long, pad if too short
          IF   R_LEN,GE,UNLBUFO_LEN    * Truncating move needed?
           MVC UNLBUFO,0(R_REC)        * Copy 80 bytes of input data
          ELSE ,                       * Need to pad
           CLEAR UNLBUFO               * Pre-fill with blanks
           EXMVC UNLBUFO(R_LEN),0(R_REC) * Copy whole input record
          ENDIF ,                      *
*         Write record to output dataset
          PUT  UNLDCBO,UNLBUFO         * Write record to output dataset
         ENDDO ,                       *
*
         ENDSR ,                       *
***********************************************************************
*
* Routine to create jcl statements
*
***********************************************************************
CRTJCL   BEGSR ,                       *
*
* Set input DCB subfields addressable
         USE   DCB,UNLDCB2             * Opened input DCB
*
* Retrieve datasetname from JFCB
R_TCBT   EQUREG TEMP=YES               * Assign TCB pointer
         CPY   R_TCBT,PSATOLD          * Load TCB-address
         USE   TCB,R_TCBT              * And set it addressable
R_TIOT   EQUREG ,                      * Assign TIOT pointer
         CPY   R_TIOT,TCBTIO           * Retrieve TIOT-pointer
         DROP  R_TCBT                  * TCB no longer needed
         LTHU  R_LEN,DCBTIOT           * Load TIOT-offset from DCB
         AR    R_TIOT,R_LEN            * Point to TIOT entry
         USE   TIOENTRY,R_TIOT         * Set TIOT entry addressable
*
* Find JFCB to retrieve dataset name
         LTA24 R1,TIOEJFCB             * Load JFCB token value
         DROP  R_TIOT                  * TIOENTRY no longer needed
*
         CLEAR UNLEPAX                 * Clear SWAREQ's EPA
EPA      USE   UNLD.UNLEPAX            * Set subfields addressable
         STA24 R1,EPA.SWVA             * Put JFCB token into EPAX
         SET   UNLEPAPT,UNLEPAX        * Set up pointer to EPAX
         MVPL  UNLSWARQ,UNL_SWARQ      * Copy prototype SWAREQ plist
         SWAREQ FCODE=RL,              * Request a read-locate         *
               UNAUTH=YES,             *   in unauthorized mode        *
               EPA=UNLEPAPT,           *   using this EPA pointer      *
               MF=(E,UNLSWARQ)         *   and this parmlist
         CPY   R_RCD,R15               * Save retcode
*
* Check validity of the results
         IF    R_RCD,NZ,OR,            * Skip ORCB if SWAREQ erred     *
               EPA.SWLVERS,NZ,OR,      * Only version 0 supported      *
               NOT,EPA.SWJFCBID        * Returned block is JFCB?
          ABND ,                       * Then we cannot proceed!
         ENDIF ,                       *
R_JFCB   EQUREG ,                      * Assign JFCB pointer
         LT    R_JFCB,EPA.SWBLKPTR     * Valid JFCB pointer?
         ABND  Z                       * No: abend
         DROP  EPA                     * UNLEPAX no longer needed
*
* R_JFCB now points to the JFCB for the opened DCB
         USE   JFCB,R_JFCB             * Set JFCB addressable.
         MVC   UNLDSN,JFCBDSNM         * Copy data set name
         CPY   UNLPQTY,JFCBPQTY        * Primary allocation
         CPY   UNLSQTY,JFCBSQTY        * Secondary allocation
         CPY   UNLDQTY,JFCBDQTY        * Directory allocation
         CASE  JFCBCYL                 * Cylinder allocation?
          SETON UNLALCYL               *
         CASE  JFCBTRK                 * Track allocation?
          SETON UNLALTRK               *
         ELSE  ,                       * Must be block allocation
          SETON UNLALBLK               *
         ENDCASE ,                     *
         DROP  R_JFCB                  * JFCB no longer needed
*
* Find length of data set name
         L     R_TMP,=AL4(TRTAB1)      * Point to TRT table
         TRT   UNLDSN(44),0(R_TMP)     * Find first blank in name
         IF    Z                       * No blanks found:
          CPY  UNLDSNLN,44             * Length is 44
         ELSE  ,                       * R1 points first blank
          LA   R_TMP,UNLDSN            * Point to start of name
          SR   R1,R_TMP                * R1 points invalid char
          CPY  UNLDSNLN,R1             * Save length of DSN
         ENDIF ,                       *
*
* Determine allocation sizes
         IF    UNLSQTY,Z               * Secondary quantity valid?
          CPY  UNLSQTY,10              * No, assume 10
         ENDIF ,                       *
*
         IF    UNLPQTY,Z               * Secondary quantity valid?
          CPY  R_TMP,UNLSQTY           * No, use secondary space
          LA   R_TMP,0(R_TMP,R_TMP)    *     times two
          CPY  UNLPQTY,R_TMP           *     for primary space
         ENDIF ,                       *
*
         IF    UNLDQTY,Z               * Directory quantity valid?
R_EVEN    EQUREG ODD=R_ODD,PAIR=YES,TEMP=YES * Assign pair of regs
          CPY  R_ODD,UNLDIRFP          * Point free entry
          S    R_ODD,UNLDIRP           * Minus start = size of table
          CLEAR R_EVEN                 * Make it a 64-bit integer
          LA   R_LEN,12*5              * 5 direntries into a dir block
          DR   R_EVEN,R_LEN            * using 4 gives some spare room
          INC  R_ODD,5                 * Add room for 25 more entries
          CPY  UNLDQTY,R_ODD           *
         ENDIF ,                       *
*
* Set up to loop thru the JCL records
         USE   R_REC                   * Set register in use
         L     R_REC,=A(JCLTAB)        * Point to JCL table
         DO    WHILE,R_REC,LT,=A(JCLTAB_END) * For each statement
          MVC  UNLBUFO,0(R_REC)        * Copy record to buffer
*         +1 triggers insertion of dataset name
          CASE E,CLC,UNLBUFO(2),=C'+1' * Type 1 substitution?
           MVC UNLBUFO(2),=C'//'       * Make it a decent JCL statement
           CPY R_LEN,UNLDSNLN          * Retrieve length of DSN
           EXMVC UNLBUFO+20(R_LEN),UNLDSN * Insert data set name
           LA  R_TMP,UNLBUFO+20(R_LEN) * Point beyond dataset name
           MVI 0(R_TMP),C','           * Insert comma
*         +2 triggers insertion of allocation parameters
          CASE E,CLC,UNLBUFO(2),=C'+2' * Type 2 substitution?
           MVC UNLBUFO(2),=C'//'       * Make it a decent JCL statement
*          Allocate cylinders, tracks or blocks?
           CASE UNLALCYL,NEST=YES      * Allocation is in cylinders?
            MVC UNLBUFO+22(3),=C'CYL'  *
            MVC UNLBUFO+25(52),UNLBUFO+27 * Remove superfluous chars
            MVC UNLBUFO+78(2),=CL2'  ' * and add trailing spaces
           CASE UNLALTRK               * Allocation in tracks?
            MVC UNLBUFO+22(3),=C'TRK'  *
            MVC UNLBUFO+25(52),UNLBUFO+27 * Remove superfluous chars
            MVC UNLBUFO+78(2),=CL2'  ' * and add trailing spaces
           CASE UNLALBLK               * Allocation in blocks?
            CPY R_TMP,UNLBLKSI         * Load block size
            CVD R_TMP,UNLCVD           * Make result decimal
            UNPK UNLQTY,UNLCVD         * Make result readable
            OI  UNLQTY+L'UNLQTY-1,C'0' * Without a sign
            MVC UNLBUFO+22(L'UNLQTY),UNLQTY * And insert into JCL line
           ELSE ,                      * Programming error!
            ABND ,                     *
           ENDCASE ,                   *
*          Insert primary allocation quantity
           CPY  R_TMP,UNLPQTY          * Load primary qty
           CVD  R_TMP,UNLCVD           * Make result decimal
           UNPK UNLQTY,UNLCVD          * Make result readable
           OI   UNLQTY+L'UNLQTY-1,C'0' * Without a sign
           MVC  UNLBUFO+29(L'UNLQTY),UNLQTY * And insert into JCL line
*          Insert secondary allocation quantity
           CPY  R_TMP,UNLSQTY          * Load secondary qty
           CVD  R_TMP,UNLCVD           * Make result decimal
           UNPK UNLQTY,UNLCVD          * Make result readable
           OI   UNLQTY+L'UNLQTY-1,C'0' * Without a sign
           MVC  UNLBUFO+35(L'UNLQTY),UNLQTY * And insert into JCL line
*          Insert directory allocation quantity
           CPY  R_TMP,UNLDQTY          * Load directory qty
           CVD  R_TMP,UNLCVD           * Make result decimal
           UNPK UNLQTY,UNLCVD          * Make result readable
           OI   UNLQTY+L'UNLQTY-1,C'0' * Without a sign
           MVC  UNLBUFO+41(L'UNLQTY),UNLQTY * And insert into JCL line
*         +3 triggers insertion of step name
          CASE E,CLC,UNLBUFO(2),=C'+3' * Type 3 substitution?
           MVC UNLBUFO(2),=C'//'       * Make it a decent JCL statement
           IF  UNLSPRM                 * Valid parm was passed?
            MVC UNLBUFO+2(8),UNLPARM   * Insert step name from parm
           ENDIF ,                     *
          ENDCASE ,                    *
*         Write completed JCL record
          PUT  UNLDCBO,UNLBUFO         * Write record to output dataset
          INC  R_REC,80                * Point next record
         ENDDO ,                       *
         DROP  R_REC                   * Record ptr done
*
         ENDSR ,                       *
***********************************************************************
*
* Constants etc.
*
***********************************************************************
         LTORG ,                       *
***********************************************************************
*
* Out-of-line routines
*
***********************************************************************
*
* EOF-routine for input dataset
LIST_EODAD LABEL H                     *
         SETON UNLSEOF                 * Signal EOF reached
         BR    R14                     * Return to main line
***********************************************************************
*
* Indirectly addressable Plists and constants
*
***********************************************************************
UNL_DCB1 DCB   DDNAME=SYSUT1,          * Prototype for DCB             *
               DSORG=PO,               * Directory is sequential       *
               DCBE=UNL_DCBE,          * EODAD in DCBE                 *
               MACRF=R                 * Read blocks only
*
UNL_DCB2 DCB   DDNAME=SYSUT1,          * Prototype for DCB             *
               DSORG=PS,               * Directory is sequential       *
               DCBE=UNL_DCBE,          * EODAD in DCBE                 *
               MACRF=RP                * Read blocks only
*
UNL_DCBO DCB   DDNAME=SYSUT2,          * Prototype for DCB             *
               DSORG=PS,               * output is sequential          *
               MACRF=PM                * use Put in Move mode
*
UNL_DCBE DCBE  EODAD=LIST_EODAD        * DCBE to be used with DCB1/DCB2
*
         READ  UNL_DECB,SF,MF=L        * Read forward DCB1/DCB2
*
UNL_OPEN OPEN  (0,INPUT),MF=L          * Prototype for OPEN
UNL_CLOS CLOSE (0),MF=L                * Prototype for CLOSE
*
UNL_SWARQ SWAREQ EPA=0,                * Prototype for SWAREQ parmlist *
               MF=L                    *
*
TRTAB1   TRTAB NOTUC,                  * Uppercase chars are valid     *
               CHARS=(0,1,2,3,4,5,6,7,8,9, * Digits are valid too      *
               C'#',C'@',C'$',C'.')    * Other valid chars
*
JCLTAB   DS    0D                      * Table with JOB jcl
*                   012345678901234567890123456789012345678901234567890
         DC    CL80'//BXALOAD  JOB  ,''Load BIXOFT libs'',CLASS=A'
         DC    CL80'//*'
         DC    CL80'//* This job loads source libraries for BIXXAMS'
         DC    CL80'//*'
         DC    CL80'+3CRTLIB   EXEC PGM=IEBUPDTE,PARM=NEW'
         DC    CL80'+1SYSUT2   DD   DSN='
         DC    CL80'+2             SPACE=(00080,(00020,00010,00005)),'
         DC    CL80'//             DISP=(MOD,CATLG),DSORG=PO,'
         DC    CL80'//             RECFM=FB,LRECL=80,UNIT=SYSALLDA'
         DC    CL80'//SYSPRINT DD   DUMMY'
         DC    CL80'//SYSIN    DD   DATA,DLM=''()'''
JCLTAB_END EQU *
CNTLADD  DC    CL80'./ ADD NAME='
CNTLEND  DC    CL80'./ ENDUP'
*
         END
