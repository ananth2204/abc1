{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011634000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE276.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE276.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\n'", "DS1TRBAL": "b'w\\xcc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xed\\x00\\x0c\\x01\\xed\\x00\\x0e\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x964_\\x00\\x964_\\x18R\\x00\\r\\x00\\r\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-10T00:00:00", "modifydate": "1996-12-10T18:52:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "SBGCSC"}, "text": "This edit macro called CHECKSUM makes ZAPping with checksums extremely\neasy.  Just edit the ZAP job, place a CC-CC block as a line command\nagainst the VER and REP statements you want to look at, include a\nblank CHECKSUM word on a new line below the CC-CC block, and invoke\nthe macro CHECKSUM from the command line.  A calculated CHECKSUM value\nwill be inserted after the blank CHECKSUM word you've included.\n\n      Address:     Steve Smith\n                   Serena International\n                   500 Airport Blvd\n                   Burlingame, CA  94010\n                   415-696-6218\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CHECKSUM": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x964_\\x00\\x964_\\x17P\\x00\\xe8\\x00\\xe8\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1996-12-10T00:00:00", "modifydate": "1996-12-10T17:50:00", "lines": 232, "newlines": 232, "modlines": 0, "user": "SBGCSC"}, "text": "/* REXX EXEC: CHECKSUM ******************************************** */\n/*                                                                  */\n/* REXX EXEC TO CALCULATE THE CHECKSUM OF A AMASPZAP INPUT STREAM   */\n/* THIS WAS ORIGINALLY WRITTEN BY JIM LEONE ON 1995/08/22.          */\n/* MODIFIED BY: STEVE SMITH ON 1996/09/17.                          */\n/*                                                                  */\n/* TO USE THIS EDIT MACRO DURING AN EDIT SESSION, PLACE A CHECKSUM  */\n/* STATEMENT JUST AFTER THE LAST VER/REP TO BE CHECKED, MARK THE    */\n/* LINE RANGE THAT YOU NEED A CHECKSUM FOR WITH \"CC\" MARKERS        */\n/* AND ENTER A CHECKSUM COMMAND ON THE COMMAND LINE.  THIS EDIT     */\n/* MACRO WILL PLACE THE COMPUTED CHECKSUM ON THE CHECKSUM LINE.     */\n/*                                                                  */\n/* FOR EXAMPLE, AFTER ALL SETUP AND LINES ARE MARKED:               */\n/*     COMMAND ===> CHECKSUM                                        */\n/*000012   NAME ANYMODULE CSECTNAME                                 */\n/*CC 013   VER 01C0 ABAB                                            */\n/*000014   VER 01CC C1C2                                            */\n/*000015   REP 01C0 CCCC                                            */\n/*CC 016   REP 01CC C3C4                                            */\n/*000017   CHECKSUM                                                 */\n/*000018   IDRDATA P510STR                                          */\n/****************************************************************** */\n/************************************************************** */\n/* TRACE I                                                      */\n/*REXX EXEC: CHECKSUM                                           */\n/*         COMMAND: CHECKSUM BEG END                            */\n/*         BEG = FIRST REP/VER STATEMENT                        */\n/*         END = LAST  REP/VER STATEMENT                        */\n/*         NOTE: IF BEG AND END ARE NOT GIVEN THEN C CC CNN     */\n/*               LINE COMMAND RANGE WILL BE USED                */\n/*         ADDED SUPPORT FOR REMAINING HEX LENGTH OF  2,6,10,14 */\n/*         ADDED SUPPORT TO REMOVE COMMAS IN HEX VALUES         */\n/*         ADDED SUPPORT FOR CC RANGE SELECTION                 */\n/************************************************************** */\nNUMERIC DIGITS 15\nADDRESS \"ISREDIT\" \"MACRO (BEGL,ENDL) NOPROCESS\"\n IF ENDL = '' THEN DO\n    ADDRESS \"ISREDIT\" \"PROCESS RANGE C\"\n         IF RC >  0  THEN DO\n            SAY \"NO LINES SPECIFIED\"\n            EXIT\n         END\n         ELSE DO\n         ADDRESS \"ISREDIT\" \"(BEGL) = LINENUM .ZFRANGE\"  /* FIRST LINE*/\n         ADDRESS \"ISREDIT\" \"(ENDL) = LINENUM .ZLRANGE\"  /* LAST LINE */\n         END\n END\nLOOPCTRL = ENDL - BEGL + 1\nALLVALUES = ''\n DO LOOPCTRL\n         \"ISREDIT (DATAL) = LINE\" BEGL\n         PARSE VAR DATAL OPER BASE HEXES .\n         IF OPER = 'VER' | OPER = 'VERIFY'  | ,\n            OPER = 'REP' | OPER = 'REPLACE' | OPER = 'BASE'\n         THEN ALLVALUES = ALLVALUES || BASE || HEXES\n         BEGL = BEGL + 1\n END\nDONE = 'NO'\nHEXTOT = 0\nDO UNTIL DONE = 'YES'\n         PARSE VAR ALLVALUES  ALLVALUES ',' TRAIL\n         IF TRAIL = ''\n            THEN DONE = 'YES'\n            ELSE ALLVALUES = ALLVALUES || TRAIL\n END\nDONE = 'NO'\nHEXTOT = 0\nDO UNTIL DONE = 'YES'\n         HEXLENGTH = LENGTH(ALLVALUES)\n  IF HEXLENGTH < 16\n         THEN\n         DO\n         DONE = 'YES'\n         CALL LASTONE\n         HEXTOTAL = \"'CHECKSUM \" || HEXTOT || \"' .HERE .HERE\"\n         \"ISREDIT RESET LABEL\"\n         \"ISREDIT LABEL \"ENDL + 1\" = .HERE\"\n         ADDRESS \"ISREDIT \"\n         \"CHANGE 'CHECKSUM' \" HEXTOTAL\n         EXIT\n         END\nELSE\n         DO  /* DO SUB1 */\n         FIRST8 = SUBSTR(ALLVALUES,1,8)\n         NEXT8  = SUBSTR(ALLVALUES,9,8)\n         DEC1   = X2D(FIRST8)\n         DEC2   = X2D(NEXT8)\n         DECNUM = DEC1 + DEC2\n         HEXSUB = D2X(DECNUM)\n         IF LENGTH(HEXSUB) > 8\n         THEN HEXSUB = SUBSTR(HEXSUB,2,8)\n         DECTOT = X2D(HEXTOT) + X2D(HEXSUB)\n         HEXTOT = D2X(DECTOT)\n         IF LENGTH(HEXTOT) > 8\n         THEN HEXTOT = SUBSTR(HEXTOT,2,8)\n         ALLVALUES = SUBSTR(ALLVALUES,17)\n         END /* DO SUB1 */\nEND  /* MAIN DO */\n         HEXTOTAL = \"'CHECKSUM \" || HEXTOT || \"' .HERE .HERE\n         ADDRESS \"ISREDIT \"\n         \"ISREDIT RESET LABEL\"\n         \"ISREDIT LABEL \"ENDL + 1\" = .HERE\n         \"CHANGE 'CHECKSUM' \" HEXTOTAL\nEXIT\nLASTONE:\n  IF HEXLENGTH = 2\n         THEN\n         CALL LAST2\n  IF HEXLENGTH = 4\n         THEN\n         CALL LAST4\n  IF HEXLENGTH = 6\n         THEN\n         CALL LAST6\n  IF HEXLENGTH = 8\n         THEN\n         CALL LAST8\n  IF HEXLENGTH = 10\n         THEN\n         CALL LAST10\n  IF HEXLENGTH = 12\n         THEN\n         CALL LAST12\n  IF HEXLENGTH = 14\n         THEN\n         CALL LAST14\nRETURN ''\nLAST2:\n         DO\n         FIRST8 = ALLVALUES\n         FIRST8 = FIRST8 || '000000'\n         DEC1   = X2D(FIRST8)\n         DECT1  = X2D(HEXTOT)\n         DECNUM = DEC1 + DECT1\n         HEXTOT = D2X(DECNUM)\n         IF LENGTH(HEXTOT) > 8\n         THEN HEXTOT = SUBSTR(HEXTOT,2,8)\n         END\nRETURN ''\nLAST4:\n         DO\n         FIRST8 = ALLVALUES\n         FIRST8 = FIRST8 || '0000'\n         DEC1   = X2D(FIRST8)\n         DECT1  = X2D(HEXTOT)\n         DECNUM = DEC1 + DECT1\n         HEXTOT = D2X(DECNUM)\n         IF LENGTH(HEXTOT) > 8\n         THEN HEXTOT = SUBSTR(HEXTOT,2,8)\n         END\nRETURN ''\nLAST6:\n         DO\n         FIRST8 = ALLVALUES\n         FIRST8 = FIRST8 || '00'\n         DEC1   = X2D(FIRST8)\n         DECT1  = X2D(HEXTOT)\n         DECNUM = DEC1 + DECT1\n         HEXTOT = D2X(DECNUM)\n         IF LENGTH(HEXTOT) > 8\n         THEN HEXTOT = SUBSTR(HEXTOT,2,8)\n         END\nRETURN ''\nLAST8:\n         DO\n         FIRST8 = ALLVALUES\n         DEC1   = X2D(FIRST8)\n         DECT1  = X2D(HEXTOT)\n         DECNUM = DEC1 + DECT1\n         HEXTOT = D2X(DECNUM)\n         IF LENGTH(HEXTOT) > 8\n         THEN HEXTOT = SUBSTR(HEXTOT,2,8)\n         END\nRETURN ''\nLAST10:\n         DO\n         FIRST8 = SUBSTR(ALLVALUES,1,8)\n         NEXT8  = SUBSTR(ALLVALUES,9,2)\n         NEXT8  = NEXT8 || '000000'\n         DEC1   = X2D(FIRST8)\n         DEC2   = X2D(NEXT8)\n         DECNUM = DEC1 + DEC2\n         HEXSUB = D2X(DECNUM)\n         IF LENGTH(HEXSUB) > 8\n         THEN HEXSUB = SUBSTR(HEXSUB,2,8)\n         DECT1  = X2D(HEXTOT)\n         DECT2  = X2D(HEXSUB)\n         DECTOT = DECT1 + DECT2\n         HEXTOT = D2X(DECTOT)\n         IF LENGTH(HEXTOT) > 8\n         THEN HEXTOT = SUBSTR(HEXTOT,2,8)\n         END\nRETURN ''\nLAST12:\n         DO\n         FIRST8 = SUBSTR(ALLVALUES,1,8)\n         NEXT8  = SUBSTR(ALLVALUES,9,4)\n         NEXT8  = NEXT8 || '0000'\n         DEC1   = X2D(FIRST8)\n         DEC2   = X2D(NEXT8)\n         DECNUM = DEC1 + DEC2\n         HEXSUB = D2X(DECNUM)\n         IF LENGTH(HEXSUB) > 8\n         THEN HEXSUB = SUBSTR(HEXSUB,2,8)\n         DECT1  = X2D(HEXTOT)\n         DECT2  = X2D(HEXSUB)\n         DECTOT = DECT1 + DECT2\n         HEXTOT = D2X(DECTOT)\n         IF LENGTH(HEXTOT) > 8\n         THEN HEXTOT = SUBSTR(HEXTOT,2,8)\n         END\nRETURN ''\nLAST14:\n         DO\n         FIRST8 = SUBSTR(ALLVALUES,1,8)\n         NEXT8  = SUBSTR(ALLVALUES,9,6)\n         NEXT8  = NEXT8 || '00'\n         DEC1   = X2D(FIRST8)\n         DEC2   = X2D(NEXT8)\n         DECNUM = DEC1 + DEC2\n         HEXSUB = D2X(DECNUM)\n         IF LENGTH(HEXSUB) > 8\n         THEN HEXSUB = SUBSTR(HEXSUB,2,8)\n         DECT1  = X2D(HEXTOT)\n         DECT2  = X2D(HEXSUB)\n         DECTOT = DECT1 + DECT2\n         HEXTOT = D2X(DECTOT)\n         IF LENGTH(HEXTOT) > 8\n         THEN HEXTOT = SUBSTR(HEXTOT,2,8)\n         END\nRETURN ''\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT276/FILE276.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT276", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}