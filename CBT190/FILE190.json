{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011451000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 940576, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE190.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE190.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x10\\x06'", "DS1TRBAL": "b'\\x91n'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x80\\x00\\t\\x01\\x81\\x00\\n\\x00\\x11'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93\\x08?\\x00\\x93\\x08?\\x10\\x03\\x01T\\x01E\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-03-24T00:00:00", "modifydate": "1993-03-24T10:03:00", "lines": 340, "newlines": 325, "modlines": 0, "user": "SBGCSC"}, "text": "**********************************************************************\n*\n*  THIS PROGRAM TELLS YOU WHO IS USING CSA.  THIS PROGRAM CAN BE\n*  RUN EITHER AGAINST THE CURRENT TSO ADDRESS SPACE, OR IT CAN BE\n*  RUN UNDER IPCS AGAINST A DUMP FILE.  IT CAN TELL YOU WHO WAS\n*  USING CSA AT THE TIME OF THE DUMP.\n*\n**********************************************************************\n*  PLEASE REFER ANY QUESTIONS OR INQUIRIES TO:\n*\n*  ROBERT E. STYMA    GTE COMMUNICATION SYSTEMS\n*                     2500 WEST UTOPIA ROAD\n*                     PHOENIX, ARIZONA 85027\n*                     (602) 582-7323\n*\n**********************************************************************\n*\n* PROGRAM VSMDUMP (VIRTUAL STORAGE MANAGER DUMP) AND\n*          VSMDATA (VSM DUMP FOR CURRENT ADDRESS SPACE)\n*\n*  PROGRAM TO RUN ALL THE DQE'S FOR AN MVS/XA ADDRESS SPACE\n*  ALSO SELECTED DATA FROM THE GDA AND LDA ARE ROUTED TO FILE OUTPUT\n*  ALSO CVT LPA AND NUC DATA IS ROUTED TO FILE OUTPUT\n*  THE SPT IS LOOKED AT\n*  THE LPA DIRECTORY IS DUMPED\n*\n*  TWO OUTPUTS, DDNAMES PRINT AND OUTPUT\n*  DCB ATTRIBUTES ARE HARD CODED IN THIS PROGRAM\n*  FBA 133\n*\n*  TO CALL AS AN IPCS VERB EXIT,  GO INTO IPCS OPTION 4 AND TYPE:\n*  VERBX  VSMDUMP 'QC22505.OUTPUT.DATA'\n*             OR\n*  VERBX  VSMDUMP 'QC22505.OUTPUT.DATA PRINT NOLPA CDE'\n*\n*  REPLACE QC22505.OUTPUT.DATA WITH THE TARGET OUTPUT FILE.  THE\n*  FULLY QUALIFIED NAME IS REQUIRED, THE FILE MUST BE SEQUENTIAL,\n*  THE FILE WILL BE CREATED IF NECESSARY.   THE DCB IS HARD CODED\n*  IN THIS PROGRAM.\n*\n*  THE KEYWORDS PRINT, NOLPA, AND CDE ARE OPTIONS.\n*  PRINT  CAUSES THE VSM DATA TO BE PUT IN THE IPCS PRINT DATASET.\n*  CDE    CAUSES CDE RECORDS TO BE DISPLAYED IN THE IPCS PRINT DATASET.\n*  NOLPA  CAUSES TYPE 3 AND 4 RECORDS FOR LPA MODULES TO BE OMITTED\n*         IN THE OUTPUT FILE.\n*\n*\n*  THIS PROGRAM RUNS AMODE=31 RMODE=24\n*  THIS PROGRAM CAN BE COMPILED AS EITHER AN IPCS VERB EXIT OR\n*  A REGULAR PROGRAM.  AS A REGULAR PROGRAM, THE CURRENT ADDRESS\n*  SPACE IS PROCESSED.  AS AN IPCS VERB EXIT, THE DUMP ADDRESS SPACE\n*  IS PROCESSED.\n*\n*  A NORMAL ASSEMBLER H COMPILE WILL COMPILE THIS PROGRAM AS AN NORMAL\n*  PROGRAM.  SPECIFY  'SYSPARM(IPCS)' IN THE IEV90 PARM TO COMPILE AS\n*  AN IPCS EXIT.\n*  ASSEMBLER ROUTINES FG500215  ARE REQUIRED.\n*                     FG201887\n*                     FG201693\n*\n*  SIX RECORD TYPES ARE GENERATED BY THIS ROUTINE.  THEY ARE\n*  IDENTIFIED BY A CHARACTER NUMBER 1 THROUGH 6 IN COLUMN 112.  THE\n*  RECORD DESCRIPTIONS FOLLOW:\n*  KEY:\n*  HEX FIELDS:  PADDED ON LEFT WITH ZEROS.\n*  DEC FIELDS:  RIGHT JUSTIFIED IN FIELD, PADDED ON LEFT WITH BLANKS\n*  CHAR FIELDS: LEFT JUSTIFIED IN FIELD, PADDED ON RIGHT WITH BLANKS\n*\n**********************************************************************\n*\n*  TYPE 1:   MEMORY RECORD\n*  THIS RECORD IS GENERATED FOR A DQE, OR AQAT ENTRY.  IT DESCRIBES\n*  A CONTIGUOUS AREA OF MEMORY.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   START ADDRESS OF THE AREA\n*\n*  SIZE      13    8   HEX   LENGTH OF THE AREA\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*\n*  SUBPOOL   35    8   DEC   SUBPOOL NUMBER.\n*\n*  KEY       46    8   DEC   MEMORY KEY.  NOT AVAILABLE FOR SUBPOOLS\n*                            227, 228, 231, 241 IF PROCESSING A DUMP.\n*                            THESE SUBPOOLS COME FROM THE SPT.\n*\n*  PGMNAME   57    8   CHAR  PROGRAM NAME ASSOCIATED WITH THE TCB WHICH\n*                            DID THE GETMAIN.  FOR SYSTEM SUBPOOLS,\n*                            FIXED VALUES ARE USED:\n*                            226  - SQA\n*                            227  - SPT CSA\n*                            228  - SPT CSA\n*                            231  - SPT CSA\n*                            239  - SQA\n*                            241  - SPT CSA\n*                            245  - SQA\n*                            255  - LSQA\n*\n*  ENTRYPT   68    8   HEX   ENTRY POINT OF THE PROGRAM ASSOCIATED WITH\n*                            THE TCB WHICH DID THE GETMAIN.  FOR THE\n*                            SYSTEM SUBPOOLS, THIS IS BLANK.\n*\n*  TCBADDR   79    8   HEX   ADDRESS OF THE TCB WHICH DID THE GETMAIN.\n*                            FOR THE SYSTEM SUBPOOLS, THIS IS BLANK\n*\n*  SHARED    90    8   CHAR  IF THE DQE MARKS THIS SUBPOOL SHARED, THE\n*                            WORD SHARED APPEARS HERE.\n*                            FOR THE SYSTEM SUBPOOLS, THIS IS BLANK\n*\n*  OWNED    101    8   CHAR  IF THS DQE MARKS THIS SUBPOOL OWNED, THE\n*                            WORD OWNED APPEARS HERE.\n*                            FOR THE SYSTEM SUBPOOLS, THIS IS BLANK\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 1 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*\n*  TYPE 2:   REGION RECORD\n*  THIS RECORD IS GENERATED FOR VARIOUS SYSTEM BOUNDARY MARKERS. THE\n*  FIELDS FILLED IN VARY.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   START ADDRESS OF THE AREA\n*                            THE EXCEPTIONS ARE LPVT END, HPVT END,\n*                            REGION LIMIT, REGION END.  WHEN THIS IS\n*                            THE MARKER ADDRESS.\n*\n*  SIZE      13    8   HEX   LENGTH OF THE AREA. BLANK FOR MARKER ADDRS\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*                            BLANK FOR MARKER ADDRESSES.\n*\n*  SUBPOOL   35    8   DEC   BLANK\n*\n*  KEY       46    8   DEC   BLANK\n*\n*  PGMNAME   57    8   CHAR  VALUES:\n*                            MLPA     - MODIFIED LINK PACK AREA\n*                            FLPA     - FIXED LINK PACK AREA\n*                            PLPA     - PAGABLE LINK PACK AREA\n*                            PLPA EXT - PLPA ABOVE 16 MEG LINE\n*                            FLPA EXT - FLPA ABOVE 16 MEV LINE\n*                            MLPA EXT - MLPA ABOVE 16 MEG LINE\n*                            R/W NUC  - READ/WRITE NUCLEUS\n*                            R/O NUC  - READ ONLY NUCLEUS\n*                            R/W NUCE - READ/WRITE NUCLEUS ABOVE 16MEG\n*                            CSA LOW  - COMMON SERVICE AREA\n*                            CSA HIGH - COMMON SERVICE AREA ABOVE 16MEG\n*                            SQA LOW  - SYSTEM QUEUE AREA\n*                            SQA HIGH - SYSTEM QUEUE AREA ABOVE 16MEG\n*                            PVT LOW  - PRIVATE (USER) AREA\n*                            PVT HIGH - PRIVATE (USER) AREA\n*                            MGT AREA - VSM MANAGEMENT AREA\n*                            PG TBLS  - PAGE TABLES\n*                            PVT STRT - START OF USEABLE PRIVATE AREA\n*                            SYSREG L - SYSTEM REGION IN PRIVATE AREA\n*                            SYSREG H - SYSTEM REGION IN PRIVATE AREA\n*                            LPVT END - END OF USED PART OF PVT AREA\n*                            HPVT END - END OF USED PVT AREA > 16 MEG\n*                            REG END  - END OF REGION FROM < 16 MEG\n*                                       PARM ON EXEC. USED FIELDS\n*                            REG LMT  - ACTUAL MAX ADDR+1 AVAILABLE TO\n*                                       THE PRIVATE AREA BELOW 16 MEG.\n*                            VSM MGMT - VIRTUAL STORAGE MANAGER\n*                                       MANAGEMENT AREA.\n*                            LPA DIR  - LINK PACK AREA DIRECTORY\n*\n*  ENTRYPT   68    8   HEX   BLANK\n*\n*  TCBADDR   79    8   HEX   BLANK\n*\n*  SHARED    90    8   CHAR  BLANK\n*\n*  OWNED    101    8   CHAR  SYSTEM TABLE THIS DATA TAKEN FROM.\n*                            CVT, GDA, LDA\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 2 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*  TYPE 3:   LPA RECORD\n*  THIS RECORD IS GENERATED FOR EACH MAJOR LPDE FOUND IN THE\n*  LINK PACK AREA DIRECTORY.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   LOAD POINT OF MODULE\n*\n*  SIZE      13    8   HEX   LENGTH OF THE STORAGE CONTAINING MODULE\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*\n*  SUBPOOL   35    8   DEC   SUBPOOL NUMBER.\n*\n*  KEY       46    8   DEC   CONTAINS AC(1) FOR APF AUTHORIZED PROGRAMS\n*\n*  PGMNAME   57    8   CHAR  LPA PROGRAM NAME\n*\n*  ENTRYPT   68    8   HEX   ENTRY POINT OF THE LPA MODULE\n*\n*  TCBADDR   79    8   HEX   BLANK\n*\n*  SHARED    90    8   CHAR  THE STRING 'LPA MOD '\n*\n*  OWNED    101    8   CHAR  BLANK\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 3 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*  TYPE 4:   ACTIVE CDE RECORD\n*  THIS RECORD IS GENERATED FOR THE FIRST CDE FOUND ASSOCIATED\n*  WITH A PRB FOR A TASK ON THE TCB CHAIN.  THERE MAY BE DUPLICATE\n*  RECORDS FOR A CDE IF THE CDE IS FIRST FOR MORE THAN ONE PRB.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   LOAD POINT OF MODULE\n*\n*  SIZE      13    8   HEX   LENGTH OF THE STORAGE CONTAINING MODULE\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*\n*  SUBPOOL   35    8   DEC   SUBPOOL NUMBER.\n*\n*  KEY       46    8   DEC   CONTAINS AC(1) FOR APF AUTHORIZED PROGRAMS\n*\n*  PGMNAME   57    8   CHAR  PROGRAM NAME\n*\n*  ENTRYPT   68    8   HEX   ENTRY POINT OF THE MODULE\n*\n*  TCBADDR   79    8   HEX   TCB ASSOCIATED WITH THIS PROGRAM\n*\n*  SHARED    90    8   CHAR  THE STRING 'LPA MOD ' IF THIS IS AN LPA\n*                            MODULE.\n*\n*  OWNED    101    8   CHAR  IF THIS IS A MINOR CDE, THIS IS THE NAME\n*                            OF THE MAJOR CDE.\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 4 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*  TYPE 5:   LOAD LIST RECORD\n*  THIS RECORD IS GENERATED FOR EACH CDE FOUND ON THE LLE (LOAD LIST\n*  ENTRY) FOR EACH TASK ON THE TCB CHAIN.  THESE ARE MODULES LOADED VIA\n*  THE LOAD (SVC 6) SYSTEM CALL.  THERE MAY BE DUMPLICATES IF A MODULE\n*  IS LOADED BY MORE THAN ONE TCB.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   LOAD POINT OF MODULE\n*\n*  SIZE      13    8   HEX   LENGTH OF THE STORAGE CONTAINING MODULE\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*\n*  SUBPOOL   35    8   DEC   SUBPOOL NUMBER.\n*\n*  KEY       46    8   DEC   CONTAINS AC(1) FOR APF AUTHORIZED PROGRAMS\n*\n*  PGMNAME   57    8   CHAR  PROGRAM NAME\n*\n*  ENTRYPT   68    8   HEX   ENTRY POINT OF THE MODULE\n*\n*  TCBADDR   79    8   HEX   TCB ASSOCIATED WITH THIS PROGRAM\n*\n*  SHARED    90    8   CHAR  THE STRING 'LPA MOD ' IF THIS IS AN LPA\n*                            MODULE.\n*\n*  OWNED    101    8   CHAR  IF THIS IS A MINOR CDE, THIS IS THE NAME\n*                            OF THE MAJOR CDE.\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 4 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*  TYPE 6:   ACTIVE CDE RECORD B\n*  THIS RECORD IS JUST LIKE A TYPE 4 RECORD EXCEPT IT IS GENERATED\n*  FOR ENTRIES ON THE CDE CHAIN AFTER THE FIRST FOR A PRB.\n*\n**********************************************************************\n*\n*  ERROR RECORDS:\n*  WHEN THIS PROGRAM IS RUNNING AS AN IPCS VERB EXIT.  ERROR RECORDS\n*  ARE GENERATED TO BOTH THE PRINT AND OUTPUT DATASETS FOR STORAGE\n*  LOCATIONS WHICH WERE NOT IN THE DUMP.\n*\n*  THESE RECORDS HAVE BLANKS IN COLUMS 1 AND 2 AND A # IN COLUMN 3.\n*\n**********************************************************************\n*\n*  SORTING RECORDS:\n*  ALL RECORDS WRITTEN TO FILE OUTPUT HAVE A TRAILING RECORD CONSISTING\n*  OF DASHES AND PLUSSES.  THE RECORDS IN THIS FILE MAY BE SORTED\n*  AS 266 BYTE RECORDS AND THEN \"FIXDCB\"ED BACK TO 133 BYTE RECORDS.\n*\n*  THE FOLLOWING JCL WILL PERFORM THE SORT.\n*\n*  //QC225054 JOB (),'VSMDATA2',\n*  //    NOTIFY=QC22505,\n*  //    MSGLEVEL=(2,0),PRTY=0,CLASS=K,MSGCLASS=X\n*  /*JOBPARM LINES=150\n*  //KILL   EXEC  PGM=IEFBR14\n*  //FILE     DD  DSN=QC22505.OUTPUT2.DATA,\n*  //             DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,1)\n*  //SORT1  EXEC  PGM=SORT,REGION=5000K\n*  //*\n*  //SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n*  //*\n*  //SORTIN    DD DSN=QC22505.OUTPUT.DATA,DISP=SHR,\n*  //             DCB=(LRECL=266,RECFM=FB,BLKSIZE=10640)\n*  //*\n*  //SORTOUT   DD DSN=QC22505.OUTPUT2.DATA,\n*  //             DISP=(NEW,CATLG),UNIT=SYSDA,\n*  //             SPACE=(CYL,(5,1),RLSE),\n*  //             DCB=(LRECL=266,RECFM=FB,BLKSIZE=10640)\n*  //*\n*  //SYSOUT    DD SYSOUT=*\n*  //SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,(65))\n*  //SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,(65))\n*  //SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,(65))\n*  //SYSIN     DD *\n*   SORT FIELDS=(2,8,AC,A),EQUALS\n*   RECORD TYPE=F,LENGTH=(266,266,266)\n*  //FIXDCB  EXEC PGM=FIXDCB\n*  //STEPLIB  DD  DISP=SHR,DSN=EXD.EAX.LOADLIB\n*  //FILE     DD  DSN=QC22505.OUTPUT.DATA,DISP=SHR,\n*  //             DCB=(LRECL=133,RECFM=FB,BLKSIZE=10640)\n*  //FIXDCB2 EXEC PGM=FIXDCB\n*  //STEPLIB  DD  DISP=SHR,DSN=EXD.EAX.LOADLIB\n*  //FILE     DD  DSN=QC22505.OUTPUT2.DATA,DISP=SHR,\n*  //             DCB=(LRECL=133,RECFM=FB,BLKSIZE=10640)\n*\n**********************************************************************\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@CLIST": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 18, "newlines": 18, "modlines": 0, "user": "STYMA"}, "text": "PROC 0 DIAGNOSE TEST ATEST N LPA NOLPA PRINT NOPRINT CDE NOCDE FQE NOFQE\n/* THIS IS CLISET VSAMDATA\nIF &DIAGNOSE. \u00ac=   -\n   THEN CONTROL   PROMPT   LIST   CONLIST   SYMLIST MSG END(ENDD)\n   ELSE CONTROL NOPROMPT NOLIST NOCONLIST NOSYMLIST MSG END(ENDD)\n%ALLOCDS FI(PRINT) DA(PRINT.DATA&N)\n%ALLOCDS FI(OUTPUT) DA('QC22505.OUTPUT.DATA&N')\nSET LOAD=QC22505.VSMDUMP.LOAD(VSMDATA&N)\nIF &TEST \u00ac=   -\nTHEN -\n   TSOEXEC TEST '&LOAD' +\n 'QC22505.OUTPUT.DATA&N &NOLPA &NOPRINT &NOCDE &CDE &PRINT &LPA &FQE &NOFQE'\nELSE -\n   DO\n    CALL '&LOAD' +\n 'QC22505.OUTPUT.DATA&N &NOLPA &NOPRINT &NOCDE &CDE &PRINT &LPA &FQE &NOFQE'\n      FREE FI(PRINT OUTPUT)\n   ENDD\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@COMPILE": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00n\\x00n\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 110, "newlines": 110, "modlines": 0, "user": "STYMA"}, "text": "//QC225050 JOB (),'VSMDUMP COMPILE',\n//     NOTIFY=QC22505,\n//     MSGLEVEL=(1,1),PRTY=0,CLASS=D,MSGCLASS=X\n/*JOBPARM LINES=80\n//*\n//*   REPLACE QC22505.VSMDUMP.ASM WITH THE NAME OF THE PDS\n//*   CONTAINING THIS FILE AND THE SOURCE\n//*\n//*   REPLACE QC22505.VSMDUMP.LOAD WITH THE NAME OF THE\n//*   TARGET LOAD LIBRARY\n//*\n//*   THIS PDS SHOULD EXIST AS 80 BYTE WIDE FIXED FORMAT RECORDS\n//*\n//*\n//ASM1     EXEC PGM=IEV90,\n//             PARM=('OBJECT,LOAD,NODECK,BATCH,LINECOUNT=75',\n//             'TEST,XREF(SHORT),RENT,SYSPARM(IPCS)')\n//*STEPLIB  DD   DO YOU NEED A STEPLIB???\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=23440\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM,DISP=SHR\n//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),\n//             SPACE=(CYL,(10,5)),DSN=&SYSUT1\n//SYSLIN   DD  DSN=&&OBJECT,\n//             DISP=(MOD,PASS),UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=80,RECFM=FB,BLKSIZE=3200)\n//SYSIN    DD  DSN=QC22505.VSMDUMP.ASM(VSMDUMP),DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM(LOCATE1),DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM(GETDSN),DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM(ALLOCDS),DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM(SWAREQ1),DISP=SHR\n//*\n//NAME1 EXEC  PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT2   DD  DSN=&&OBJECT,DISP=(MOD,PASS)\n//SYSUT1   DD  *\n NAME VSMDUMP(R)\n//*\n//*\n//ASM2     EXEC PGM=IEV90,\n//             PARM=('OBJECT,LOAD,NODECK,BATCH,LINECOUNT=75',\n//             'TEST,XREF(SHORT),RENT,SYSPARM(OS)')\n//*STEPLIB  DD   DO YOU NEED A STEPLIB???\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=23440\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM,DISP=SHR\n//*        DD  DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),\n//             SPACE=(CYL,(10,5)),DSN=&SYSUT1\n//SYSLIN   DD  DSN=&&OBJECT,\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DSN=QC22505.VSMDUMP.ASM(VSMDUMP),DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM(LOCATE1),DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM(GETDSN),DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM(ALLOCDS),DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM(SWAREQ1),DISP=SHR\n//*\n//*\n//*\n//NAME2 EXEC  PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT2   DD  DSN=&&OBJECT,DISP=(MOD,PASS)\n//SYSUT1   DD  *\n NAME VSMDATA(R)\n//*\n//ASM3     EXEC PGM=IEV90,\n//             PARM=('OBJECT,LOAD,NODECK,BATCH,LINECOUNT=75',\n//             'TEST,XREF(SHORT)')\n//*STEPLIB  DD   DO YOU NEED A STEPLIB???\n//SYSPRINT DD  SYSOUT=*\n//SYSPUNCH DD  DUMMY\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=23440\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=QC22505.VSMDUMP.ASM,DISP=SHR\n//*        DD  DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=(SYSDA,SEP=SYSLIB),\n//             SPACE=(CYL,(10,5)),DSN=&SYSUT1\n//SYSLIN   DD  DSN=&&OBJECT,\n//             DISP=(MOD,PASS)\n//SYSIN    DD  DSN=QC22505.VSMDUMP.ASM(FIXDCB),DISP=SHR\n//*\n//*\n//*\n//NAME3 EXEC  PGM=IEBGENER\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n//SYSUT2   DD  DSN=&&OBJECT,DISP=(MOD,PASS)\n//SYSUT1   DD  *\n NAME FIXDCB(R)\n//*\n//*\n//*\n//LKED     EXEC  PGM=IEWL,\n//             COND=(0,LT),\n//             REGION=2000K,\n//             PARM='LET,DCBS,LIST,MAP,SIZE=(2000K,100K),RENT,TEST'\n//SYSPRINT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSDA,           < LINKAGE EDITOR WORK FILE       >\n//             SPACE=(CYL,(1,1))\n//SYSLMOD  DD  DSN=QC22505.VSMDUMP.LOAD,\n//             DISP=SHR\n//SYSLIN   DD  DSN=&&OBJECT,\n//             DISP=(OLD,DELETE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@REPORT": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x007\\x007\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "STYMA"}, "text": "//QC225054 JOB (),'VSMDUMP REPORT',\n//    NOTIFY=QC22505,\n//    MSGLEVEL=(2,0),PRTY=0,CLASS=K,MSGCLASS=X\n/*JOBPARM LINES=150\n//*\n//*   THIS JOB GENERATES A SORTED OUTPUT FILE FROM THE VSMDUMP\n//*   OR VSMDATA PROGRAMS.\n//*\n//*   REPLACE QC22505.OUTPUT.DATA WITH THE OUTPUT FILE FROM\n//*   THE VSMDUMP OR VSMDATA PROGRAM.\n//*\n//*   REPLACE QC22505.OUTPUT2.DATA WITH THE NAME OF THE NEW FILE\n//*   YOU WANT TO PUT THE REPORT IN.\n//*\n//*   REPLACE QC22505.VSMDUMP.LOAD WITH THE NAME OF THE\n//*   LOAD LIBRARY PROGRAM FIXDCB (COMPILED IN @COMPILE) IS IN.\n//*\n//*   SEE THE BEGINING OF MEMBER VSMDUMP FOR A DESCRIPTION OF\n//*   THE FIELDS IN THE REPORT\n//*\n//*\n//*\n//KILL   EXEC  PGM=IEFBR14\n//FILE     DD  DSN=QC22505.OUTPUT2.DATA,\n//             DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,1)\n//*\n//SORT1  EXEC  PGM=SORT,REGION=5000K\n//*\n//SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n//*\n//SORTIN    DD DSN=QC22505.OUTPUT.DATA,DISP=SHR,\n//             DCB=(LRECL=266,RECFM=FB,BLKSIZE=10640)\n//*\n//SORTOUT   DD DSN=QC22505.OUTPUT2.DATA,\n//             DISP=(NEW,CATLG),UNIT=SYSDA,\n//             SPACE=(CYL,(5,1),RLSE),\n//             DCB=(LRECL=266,RECFM=FB,BLKSIZE=10640)\n//*\n//SYSOUT    DD SYSOUT=*\n//SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,(65))\n//SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,(65))\n//SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,(65))\n//SYSIN     DD *\n SORT FIELDS=(2,8,AC,A),EQUALS\n RECORD TYPE=F,LENGTH=(266,266,266)\n//*\n//FIXDCB  EXEC PGM=FIXDCB\n//STEPLIB  DD  DISP=SHR,DSN=QC22505.VSMDUMP.LOAD\n//FILE     DD  DSN=QC22505.OUTPUT.DATA,DISP=SHR,\n//             DCB=(LRECL=133,RECFM=FB,BLKSIZE=10640)\n//*\n//FIXDCB2 EXEC PGM=FIXDCB\n//STEPLIB  DD  DISP=SHR,DSN=QC22505.VSMDUMP.LOAD\n//FILE     DD  DSN=QC22505.OUTPUT2.DATA,DISP=SHR,\n//             DCB=(LRECL=133,RECFM=FB,BLKSIZE=10640)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@TEST1": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x009\\x009\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "STYMA"}, "text": "//QC225054 JOB (),'TEST VSMDATA',\n//    NOTIFY=QC22505,\n//    MSGLEVEL=(2,0),PRTY=0,CLASS=K,MSGCLASS=X\n/*JOBPARM LINES=150\n//*\n//*   THIS JOB RUNS PROGRAM VSMDATA ON ITSELF IN BATCH AND\n//*   GENERATES THE REPORT.\n//*\n//*   REPLACE QC22505.OUTPUT2.DATA WITH THE NAME OF THE NEW FILE\n//*   YOU WANT TO PUT THE REPORT IN.\n//*\n//*   REPLACE QC22505.VSMDUMP.LOAD WITH THE NAME OF THE\n//*   LOAD LIBRARY PROGRAM FIXDCB (COMPILED IN @COMPILE) IS IN.\n//*\n//*   SEE THE BEGINING OF MEMBER VSMDUMP FOR A DESCRIPTION OF\n//*   THE FIELDS IN THE REPORT\n//*\n//KILL      EXEC PGM=IEFBR14\n//DD2       DD DSN=QC22505.OUTPUT2.DATA,\n//             DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,1)\n//*\n//VSMDATA EXEC PGM=VSMDATA\n//STEPLIB   DD DSN=QC22505.VSMDUMP.LOAD,DISP=SHR\n//PRINT     DD SYSOUT=*\n//*\n//OUTPUT    DD DSN=&&OUTPUT,\n//             DISP=(NEW,CATLG),\n//             UNIT=SYSDA,SPACE=(CYL,(5,1),RLSE)\n//*\n//SORT1  EXEC  PGM=SORT,REGION=5000K\n//*\n//SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n//*\n//SORTIN    DD DSN=&&OUTPUT,DISP=(OLD,DELETE),\n//             DCB=(LRECL=266,RECFM=FB,BLKSIZE=10640)\n//*\n//SORTOUT   DD DSN=QC22505.OUTPUT2.DATA,\n//             DISP=(NEW,CATLG),\n//             UNIT=SYSDA,SPACE=(CYL,(5,1),RLSE),\n//             DCB=(LRECL=266,RECFM=FB,BLKSIZE=10640)\n//*\n//SYSOUT    DD SYSOUT=*\n//*\n//SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,(65))\n//*\n//SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,(65))\n//*\n//SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,(65))\n//*\n//SYSIN     DD *\n SORT FIELDS=(2,8,AC,A),EQUALS\n RECORD TYPE=F,LENGTH=(266,266,266)\n//*\n//FIXDCB2 EXEC PGM=FIXDCB\n//STEPLIB   DD DSN=QC22505.VSMDUMP.LOAD,DISP=SHR\n//FILE     DD  DSN=QC22505.OUTPUT2.DATA,DISP=SHR,\n//             DCB=(LRECL=133,RECFM=FB,BLKSIZE=10640)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALLOCDS": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x03\\xa5\\x03\\xa5\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 933, "newlines": 933, "modlines": 0, "user": "STYMA"}, "text": "ALLOCDS  TITLE 'ALLOCATE A DATASET SHR OR OLD FROM PL/I'\n**********************************************************************\n*\n* SEGMENT NAME:\n*\n*    ALLOCDS -- ALLOCATE DATASET NAME FROM PL/I\n*\n* INPUTS (*TO FUNCTIONS):\n*\n*    DDNAME -- DDNAME TO BE ALLOCATED (*1,2)\n*\n*    DSNAME -- DATSET NAME TO BE ALLOCATED (*1)\n*\n*    TYPE -- TYPE OF ALLOCATION (*1)\n*       VALUES: 0   - ALLOCATE DISP=SHR\n*               1   - ALLOCATE DISP=OLD\n*               2   - ALLOCATE DISP=NEW\n*               3   - ALLOCATE DISP=MOD\n*\n* OUTPUTS (*FROM FUNCTIONS):\n*\n*    REASON -- REASON FOR NON-ZERO RETURN CODE (*3,6)\n*\n*    RC -- RETURN CODE (*3,6)\n*\n         EJECT\n*    WTP -- WRITE TO PROGRAMMER (*4)\n*       A WRITE TO PROGRAMMER IS ISSUED TO GIVE THE REASON FOR A\n*       DYNAMIC ALLOCATION FAILURE.\n*       VALUES: HASP LOG ENTRY\n*\n* NOTES:\n*\n*    1. THIS MODULE IS RMODE 31 COMPATIBLE.\n*\n*    2. SAMPLE CALL (AS FUNCTION):\n*\n*       DCL ALLOCDS ENTRY(VARYING CHAR(44),VARYING CHAR(8), FIXED\n*       BINARY(31),(2) FIXED BINARY(15))) RETURNS(FIXED BINARY(31));\n*       DECLARE DDNAME CHAR(8)  VARYING;\n*       DECLARE DSNAME CHAR(44) VARYING;\n*       DECLARE TYPE   FIXED BINARY(31);\n*       DECLARE REASON_CODE(2) FIXED BINARY(15);\n*       DECLARE RETURN_CODE FIXED BINARY(31);\n*\n*       RETURN_CODE = ALLOCDS(DSNAME,DDNAME,TYPE,REASON_CODE);\n*\n*    3. SAMPLE CALL (AS PROCEDURE):\n*\n*       DCL ALLOCDS ENTRY(VARYING CHAR(44),VARYING CHAR(8), FIXED\n*       BINARY(31), (2) FIXED BINARY(15), FIXED BINARY(31));\n*       DECLARE DDNAME CHAR(8)  VARYING;\n*       DECLARE DSNAME CHAR(44) VARYING;\n*       DECLARE TYPE   FIXED BINARY(31);\n*       DECLARE REASON_CODE(2) FIXED BINARY(15);\n*       DECLARE RETURN_CODE FIXED BINARY(31);\n*\n*       CALL ALLOCDS(DSNAME,DDNAME,TYPE,REASON_CODE,RETURN_CODE);\n*\n**********************************************************************\n         EJECT\nALLOCDS  RENTR BASE=11,WORK=(WORKLEN,WORKAREA),PARM=(R10,PLIPARMS),    X\n               ENV=BOTH\n         SPACE 2\n**********************************************************************\n*\n* INITIALIZE THE SVC 99 REQUEST BLOCK POINTER AND THE SVC 99 REQUEST\n* BLOCK.\n*\n*      REGISTER USAGE:\n*              R10 -> PARM LIST FROM PL/I\n*              R11 -  BASE FOR PROGRAM\n*              R12 -  RESERVED FOR PL/I ERROR ROUTINES - DO NOT\n*                     MODIFY\n*              R13 -> DYNAMIC SAVE AND WORK AREA\n*              R14 -> SVC 99 REQUEST BLOCK\n*              R15 -  WORK REGISTER FOR MOVING DATA\n*\n**********************************************************************\n         SPACE\n         LA    R15,RBLK       INITIALIZE REQUEST BLOCK POINTER\n         ST    R15,RBLKPTR\n         OI    RBLKPTR,S99RBPND     TURN ON HIGH BIT IN ADDRESS\n         SPACE\n         XC    RBLK(RBLKLEN),RBLK   CLEAR THE SVC 99 REQUEST BLOCK\n         SPACE\n         LA    R14,RBLK       LOAD THE REQUEST BLOCK ADDRESS AND\n         USING S99RB,R14      OVERLAY THE DESCRIPTIVE DSECT\n         SPACE\n         LA    R15,RBLKLEN    LOAD REQUEST BLOCK LEN (20)\n         STC   R15,S99RBLN    STORE IN REQUEST BLOCK\n         SPACE\n         LA    R15,S99VRBAL   LOAD VERB FOR ALLOCATION BY DSNAME\n         STC   R15,S99VERB    STORE VERB (FUNCTION) IN REQUEST BLK\n         SPACE\n         LA    R15,TXTPTR     LOAD ADDR OF TEXT POINTER LIST\n         ST    R15,S99TXTPP   STORE IN REQUEST BLOCK\n         SPACE\n         DROP  R14\n         EJECT\n**********************************************************************\n*\n* BUILD THE TEXT POINTER LIST.  IT HAS 3 FULL WORD ELEMENTS, EACH OF\n* WHICH POINTS TO A TEXT UNIT.  THE LAST TEXT UNIT POINTER HAS X'80'\n* IN THE HIGH BYTE.\n*\n**********************************************************************\n         SPACE\n         LA    R14,DSNAME     POINT TO THE DSNAME TEXT UNIT\n         LA    R15,DDNAME     POINT TO THE DDNAME TEXT UNIT\n         LA    R0,INITDSP     POINT TO THE DISPOSITION TEXT UNIT\n         STM   R14,R0,TXTPTR  STORE THE ADDRS IN THE TEXT POINTER LIST\n         OI    TXTPTR+8,X'80' MARK THE HIGH BIT OF THE LAST ENTRY\n         EJECT\n**********************************************************************\n*\n* LOAD THE FIRST TEXT UNIT.  THIS IS THE DSNAME TEXT UNIT AND\n* CONTAINS THE DSNAME PASSED IN THE FIRST PARM BY PL/I.  THE LENGTH\n* OF THIS PARM MUST BE GTEATER THAN ZERO AND NOT GREATER THAN 44.  IF\n* THIS IS THE CASE, RETURN WITH RC = 12.\n*\n*      REGISTER USAGE:\n*              R1  -> THE TEXT UNIT, USED IN EX OF MVC INSTRUCTION\n*              R10 -> PARM LIST FROM PL/I\n*              R11 -  BASE FOR PROGRAM\n*              R12 -  RESERVED FOR PL/I ERROR ROUTINES - DO NOT\n*                     MODIFY\n*              R13 -> DYNAMIC SAVE AND WORK AREA\n*              R14 -> THE PARM FROM PL/I\n*              R15 -  WORK REGISTER FOR DATA TRANSFER.\n*\n**********************************************************************\n       SPACE\n         LA    R1,DSNAME      POINT TO THE DSNAME TEXT UNIT\n         L     R14,PLIDS      POINT TO THE DSNAME LOCATOR/DESCRIPTOR\n         L     R14,0(R14)     POINT TO THE DSNAME LENGTH FIELD\n         SPACE\n         L     R15,=XL4'00020001'  LOAD DSNAME KEY AND #\n         ST    R15,DSNAME          AND SAVE IN THE TEXT UNIT\n         SPACE\n         LH    R15,0(R14)     GET THE PARM LENGTH\n         LTR   R15,R15        TEST FOR ZERO LENGTH\n         BZ    BADDSN         IF ZERO, FLAG AS A BAD LENGTH\n         SPACE\n         CH    R15,=H'54'     IS DSNAME TOO LONG? 44 + ( + MEMNAME + )\n         BH    BADDSN         IF SO, FLAG AS A BAD LENGTH\n         SPACE\n         LA    R15,1(R15)     LOAD LENGTH OF PARM + LENGTH FIELD - 1\n         EX    R15,MOVE\n         SPACE 2\n**********************************************************************\n*\n* CHECK IF THE DSNAME IS 'NULLFILE'.  IF SO, MAKE THE DCB\n* CHARACTERISTICS RECFM(FB) BLKSIZE(800) LRECL(80).  THIS IS TO MAKE\n* PANVALET VERSION 14 HAPPY.\n*\n**********************************************************************\n         SPACE\n         CLC   0(10,14),NULLFILE\n         BNE   DODDN\n         SPACE\n         LA    R14,BLKSIZE          LOAD BLOCK SIZE TEXT UNIT\n         LA    R15,LRECL            LOAD LRECL TEXT UNIT\n         LA    R0,RECFM             LOAD RECFM TEXT UNIT\n         STM   R14,R0,TXTPTR+12     ADD TO TEXT POINTER LIST\n         OI    TXTPTR+20,X'80'      MARK AND OF LIST\n         NI    TXTPTR+8,X'7F'       REMOVE OLD END MARKER\n         SPACE\n         MVC   BLKSIZE(8),=X'0030000100020320'  BLKSIZE 800\n         MVC   LRECL(8),=X'0042000100020050'    LRECL 80\n         MVC   RECFM(7),=X'00490001000190'      RECFM F B\n         EJECT\n**********************************************************************\n*\n* CHECK IF THE DDNAME IS BLANK.  IF NOT, SET THE DDNAME TEXT UNIT FOR\n* THE DDNAME PARM.  THE DDNAMFLG IS X'00' WHEN THE DDNAME PARM IS\n* USED AND X'FF' WHEN S SYSTEM DDNAME IS TO BE RETRIEVED AND PASSED\n* BACK TO PLI.\n*\n**********************************************************************\n         SPACE\nDODDN    DS    0H\n         CLC   0(7,14),DUMMY  IS THIS SPECIAL NAME 'DUMMY'?\n         BNE   NOTDUMMY       IF NOT, FINE\n         SPACE\n         MVC   DSNAME+4(10),NULLFILE MAKE IT NULLFILE\n         SPACE\nNOTDUMMY DS    0H\n         MVI   DDNAMFLG,X'00' CLEAR THE DDNAME FLAG\n         LA    R1,DDNAME      POINT TO DDNAME TEXT UNIT\n         L     R14,PLIDD      POINT TO THE DDNAME LOACATOR/DESCRIPTOR\n         L     R14,0(R14)     POINT THE DDANEM PARM LENGTH FIELD\n         LH    R15,0(R14)     GET THE PARM LENGTH\n         LTR   R15,R15        IS IT ZERO?\n         BZ    SYSNAME        IF SO, SET UP FOR A SYSTEM NAME\n         SPACE\n         CLI   2(R14),C' '    IS THE DDNAME PARM BLANK\n         BE    SYSNAME        IF SO, SET UP FOR A SYSTEM NAME\n         SPACE\n         CH    R15,=H'8'      IS DDNAME TOO LONG?\n         BH    BADDD          IF SO FLAG AS A BAD LENGTH\n         SPACE\n         LA    R15,1(R15)     LOAD LENGTH OF PARM + LENGTH FIELD - 1\n         EX    R15,MOVE       MOVE LENGTH AND DDNAME TO TEXT UNIT\n         SPACE\n         L     R15,=XL4'00010001' SET UP TEXT UNIT CONTROL INFO\n         ST    R15,DDNAME     AND STORE IN TEXT UNIT\n         B     SETDISP        GO ON TO THE NEXT PARM\n         EJECT\n**********************************************************************\n*\n* THE DDNAME PARM WAS NOT SPECIFIED BY PL/I.  SET UP THE DDNAME TEXT\n* UNIT TO RETRIEVE A SYSTEM GENERATED DDNAME WHICH WILL BE PASSED\n* BACK TO PL/I IN THE DDNAME PARM.  SET FLAG DDNAMFLG TO SHOW THAT\n* THIS MUST BE DONE.\n*\n**********************************************************************\n         SPACE\nSYSNAME  DS    0H\n         MVI   DDNAMFLG,X'FF'     SET FLAG TO SHOW SYSTEM NAME USED\n         L     R15,=XL4'00550001' LOAD TEXT UNIT CONTROL INFORMATION\n         ST    R15,DDNAME         AND STORE IN TEXT UNIT\n         SPACE\n         LA    R15,8          SET LENGTH TO 8\n         STH   R15,DDNAME+4   STORE IN DDNAME TEXT UNIT LENGTH FIELD\n         SPACE\n         MVI   DDNAME+6,C' '  SEED DDNAME FIELD WITH BLANKS AND\n         MVC   DDNAME+7(7),DDNAME+6  PROPAGATE\n         SPACE\n         L     R14,PLIDD      POINT TO DDNAME LOCATOR DESCRIPTOR\n         LH    R15,4(R14)     GET DECLARED LENGTH\n         CH    R15,=H'8'      COMPARE TO THE MINIMUM LENGTH ALLOWED\n         BL    TOOSHORT       IF TO SHORT, ERROR\n         EJECT\n**********************************************************************\n*\n* SET UP THE DISP TEXT UNIT TO SHOW EITHER OLD OR SHR.  THE THIRD\n* PARM PASSED BY PL/I, \"TYPE\", SPECIFIES WHICH TO USE IF TYPE IS\n* ZERO, USE SHR. IF TYPE IS NON-ZERO, USE OLD.\n*\n**********************************************************************\n         SPACE\nSETDISP  DS    0H\n         L     R15,=XL4'00040001'   LOAD KEY AND #\n         ST    R15,INITDSP          AND STORE IN DISP TEXT UNIT\n         SPACE\n         LA    R15,1                LOAD PARM LENGTH\n         STH   R15,INITDSP+4        LOAD PARM LENGTH\n         SPACE\n         L     R14,PLITYPE          POINT TO TYPE PARM\n         L     R14,0(R14)           AND LOAD IT.\n         CH    R14,=H'02'           IS THE PARM DISP=NEW?\n         BE    DISPNEW\n         SPACE\n         CH    R14,=H'03'           IS THE PARM DISP=MOD?\n         BE    DISPMOD\n         SPACE\n         LTR   R14,R14              IS THE PARM ZERO?\n         BZ    DISPSHR\n         SPACE\n         MVI   INITDSP+6,X'01'      SHOW DISP=OLD\n         B     FINDMEM\n         SPACE\nDISPMOD  DS    0H\n         MVI   INITDSP+6,X'02'      SHOW DISP=MOD\n         B     CALL99\n         SPACE\nDISPSHR  DS    0H\n         MVI   INITDSP+6,X'08'      SHOW DISP=SHR\n**********************************************************************\n*\n* ALLOCATION OF A PDS MEMBER IS ALLOWED. TO CHECK FOR IT WE MUST\n* SEARCH THE DSNAME FOR A (, IF THIS IS FOUND WE ADD A TEXT UNIT FOR\n* IT\n*\n**********************************************************************\n         SPACE\nFINDMEM  DS    0H\n         SPACE\n         LH    R15,DSNAME+4         LOAD LENGTH OF DSNAME\n         BCTR  R15,0                SUBTRACT ONE\n         SPACE\n         LA    R14,TRBL             LOAD ADDRESS OF TRANSLATE TABLE\n         EX    R15,TRANSLAT         CHECK IF LEFT PAREN\n         BZ    NOMEMBER             IF SO EXIT LOOP\n         SPACE\nFOUNDMEM DS 0H\n         SPACE\n         LA    R14,MEMNAME          LOAD MEMNAME\n         ST    R14,TXTPTR+12        ADD TO TEXT POINTER LIST\n         OI    TXTPTR+12,X'80'      MARK AND OF LIST\n         NI    TXTPTR+8,X'7F'       REMOVE OLD END MARKER\n         SPACE\n**********************************************************************\n*\n* IF WE GET HERE WE MUST 1. SHORTEN THE DSNAME TO ITS REAL VALUE 2.\n* CREATE A TEXT UNIT FOR THE MEMBER NAME, AND 3. MOVE THE MEMBER NAME\n* IN.\n*\n**********************************************************************\n         SPACE\n         LR    R2,R1                SAVE POINTER TO MEMBER NAME\n         LA    R14,DSNAME+6         LOAD START ADDRESS\n         SR    R1,R14               LENGTH IN R1 (R1 POINTS TO '(')\n         STH   R1,DSNAME+4          STORE NEW LENGTH OF DSNAME\n         SPACE\n         LA    R14,1(R1)            ACCOUNT FOR 2 ( IN MEMBER NAME\n         SR    R15,R14              LENGTH OF MEMBER NAME IN R15\n         STH   R15,MEMNAME+4        STORE LENGTH OF MEMBER\n         SPACE\n         L     R15,=X'00030001'     LOAD KEY AND NUMBER FOR MEMBER\n         ST    R15,MEMNAME          STORE\n         SPACE\n         LH    R15,MEMNAME+4        LENGTH OF MEMBER IN R15\n         LA    R14,1(R2)            POINT TO MEMBER NAME\n         LA    R1,MEMNAME+2         POINT TO LOCATION-4 FOR MOVE\n         EX    R15,MOVE             MOVE IN NAME\n         SPACE\nNOMEMBER DS 0H\n         SPACE\n         B     CALL99\n         SPACE\nDISPNEW  DS    0H\n         MVI   INITDSP+6,X'04'      SHOW DISP=NEW\n**********************************************************************\n*\n* IF WE GET HERE 7 NEW TEXT UNITS ARE ADDED TO THE CHAIN. DSDISP FOR\n* DISP=CATLG,DSCDISP FOR NO CATLG IF AN ERROR OCCURS, DSUNIT TO SHOW\n* UNIT=SYSDA, SPACE=(CYL,(1,2),RLSE)\n*\n**********************************************************************\n         LA    R14,DSDISP           LOAD ADDRESS OF DSDISP TEXT UNIT\n         LA    R15,DSCDISP          LOAD ADDRESS OF DSCDISP TEXT UNIT\n         LA    R0,DSUNIT            LOAD ADDRESS OF DSUNIT TEXT UNIT\n         SPACE\n         STM   R14,R0,TXTPTR+12     SAVE IN TEXT POINTER AREA\n         SPACE\n         LA    R14,PRSPACE          LOAD ADDRESS OF PRSPACE TEXT UNIT\n         LA    R15,SECSPACE         LOAD ADDRESS OF SECSPACE TEXT UNIT\n         LA    R0,RLSE              LOAD ADDRESS OF RLSE TEXT UNIT\n         SPACE\n         STM   R14,R0,TXTPTR+24     SAVE IN TEXT POINTER AREA\n         SPACE\n         LA    R14,CYL              LOAD ADDRESS OF CYL TEXT UNIT\n         ST    R14,TXTPTR+36        SAVE IN TEXT POINTER AREA\n         SPACE\n         OI    TXTPTR+36,X'80'      MARK END OF LIST\n         NI    TXTPTR+8,X'7F'       REMOVE OLD END OF LIST MARKER\n         SPACE\n         L     R14,=X'00050001'     LOAD KEY AND NUMBER\n         ST    R14,DSDISP           STORE\n         SPACE\n         LH    R14,=H'0001'         LOAD LENGTH PARM\n         STH   R14,DSDISP+4         STORE\n         SPACE\n         MVI   DSDISP+6,X'02'       MARK DISP=CATLG\n         SPACE\n         L     R14,=X'00060001'     LOAD KEY AND NUMBER\n         ST    R14,DSCDISP          STORE\n         SPACE\n         LH    R14,=H'0001'         LOAD LENGTH PARM\n         STH   R14,DSCDISP+4        STORE\n         SPACE\n         MVI   DSCDISP+6,X'02'      MARK DISP=CATLG\n         SPACE\n         L     R14,=X'00150001'     LOAD KEY AND NUMBER\n         ST    R14,DSUNIT           STORE\n         SPACE\n         L     R14,=X'0005E2E8'     LOAD LENGTH AND FIRST 2 UNIT BYTES\n         ST    R14,DSUNIT+4         STORE\n         SPACE\n         LH    R14,=X'E2C4'         LOAD 3RD AND 4TH UNIT BYTES\n         STH   R14,DSUNIT+8         STORE\n         SPACE\n         MVI   DSUNIT+10,X'C1'      MOVE IN LAST UNIT BYTE\n         L     R14,=X'000A0001'     LOAD KEY AND NUMBER\n         ST    R14,PRSPACE          STORE\n         SPACE\n         L     R14,=X'00030000'     LOAD LENGTH AND FIRST 2 SPACE BYTES\n         ST    R14,PRSPACE+4        STORE\n         SPACE\n         MVI   PRSPACE+8,X'0A'      SPACE IS 10 CYL INITIAL\n         L     R14,=X'000B0001'     LOAD KEY AND NUMBER\n         ST    R14,SECSPACE         STORE\n         SPACE\n         L     R14,=X'00030000'     LOAD LENGTH AND FIRST 2 SPACE BYTES\n         ST    R14,SECSPACE+4       STORE\n         SPACE\n         MVI   SECSPACE+8,X'02'     SPACE IS 2 CYL SECONDARY\n         L     R14,=X'000D0000'     LOAD KEY AND NUMBER\n         ST    R14,RLSE             STORE\n         SPACE\n         L     R14,=X'00080000'     LOAD KEY AND NUMBER\n         ST    R14,CYL              STORE\n         SPACE\n         B     CALL99\n         EJECT\nCALL99   DS    0H\n         LA    R1,RBLKPTR            LOAD SVC 99 PARM LIST\n         DYNALLOC\n         SPACE\n         ST    R15,S99RETC           SAVE THE SVC 99 RETURN CODE\n         LTR   R15,R15               TEST THE SVC 99 RETURN CODE\n         BZ    DDPARM                IF ZERO,  CONTINUE NORMALLY\n         EJECT\n         MVC   S99FAIL1(LENS99F1),CONS99F1  MOVE IN THE WTO BASE MSG\n         MVC   S99FAIL2(LENS99F2),CONS99F2  MOVE IN THE WTO BASE MSG\n         MVC   S99FAIL3(LENS99F3),CONS99F3  MOVE IN THE WTO BASE MSG\n         MVC   S99FAIL4(LENS99F4),CONS99F4  MOVE IN THE WTO BASE MSG\n         SPACE\n         LA    R15,WTORC+S99FAIL1          POINT TO RETURN CODE FIELD\n         UNPK  0(3,R15),S99RETC+3(2)       GET SVC 99 RETURN CODE AND\n         TR    0(3,R15),HEXCHAR            TRANSLATE TO PRINTABLE HEX\n         MVI   2(R15),C' '                 BLAST EXTRA BYTE\n         SPACE\n         LA    R15,WTOREA+S99FAIL2         POINT TO REASON CODE FIELD\n         UNPK  WORK1(9),RBLK+S99RSC-S99RB(5)  UNPACK REASON CODE\n         MVC   0(4,R15),WORK1              MOVE 1ST PART OF REASON CODE\n         MVC   5(4,R15),WORK1+4            AND 2ND PART TO MESSAGE\n         TR    0(4,R15),HEXCHAR            TRANSLATE REASON CODE\n         TR    5(4,R15),HEXCHAR            TO PRINTABLE HEX\n         SPACE\n         L     R14,PLIDS                   POINT TO DSNAME PARM L/D\n         L     R14,0(R14)                  POINT PLI DSNAME PARM\n         LH    R15,0(R14)                  LOAD PARM LENGTH\n         LA    R14,2(R14)                  POINT TO DATASET NAME\n         LA    R1,WTODSN+S99FAIL3          POINT TO MESSAGE\n         BCTR  R15,0                       SUBTRACT 1 FOR MVC\n         EX    R15,MOVE                    AND MOVE THE DATASET NAME\n         SPACE\n         L     R14,PLIDD                   POINT TO DDNAME PARM L/D\n         L     R14,0(R14)                  POINT PLI DDNAME PARM\n         LH    R15,0(R14)                  LOAD PARM LENGTH\n         LTR   R15,R15                     TEST FOR ZERO LENGTH\n         BZ    ISSUEWTO                    SKIP DDNAME ON ZERO LENGTH\n         SPACE\n         LA    R14,2(R14)                  POINT TO DD NAME\n         LA    R1,WTODDN+S99FAIL4          POINT TO MESSAGE\n         BCTR  R15,0                       SUBTRACT 1 FOR MVC\n         EX    R15,MOVE                    AND MOVE THE DATASET NAME\n         SPACE\nISSUEWTO DS    0H\n         WTO   MF=(E,S99FAIL1)             ISSUE WRITE TO PROGRAMMER\n         WTO   MF=(E,S99FAIL2)             ISSUE WRITE TO PROGRAMMER\n         WTO   MF=(E,S99FAIL3)             ISSUE WRITE TO PROGRAMMER\n         WTO   MF=(E,S99FAIL4)             ISSUE WRITE TO PROGRAMMER\n         B     RETURN                      AND QUIT\n         EJECT\n**********************************************************************\n*\n* CHECK TO SEE IF A SYSTEM DDNAME WAS OBTAINED FROM THE OPERATING\n* SYSEM VIA REQUEST FROM THE CLIENT PL/I PROGRAM.  THIS IS SIGNALLED\n* BY DDNAMEFLG BEING SET TO X'FF'.  IF THIS IS THE CASE, THEN MOVE\n* THE DDNAME INTO THE DDNAME PARM.\n*\n*      REGISTER USAGE:\n*              R1  -> THE DDNAME PARM\n*              R10 -> PARM LIST FROM PL/I\n*              R11 -  BASE FOR PROGRAM\n*              R12 -  RESERVED FOR PL/I ERROR ROUTINES - DO NOT\n*                     MODIFY\n*              R13 -> DYNAMIC SAVE AND WORK AREA\n*\n**********************************************************************\n         SPACE\nDDPARM   DS    0H\n         CLI   DDNAMFLG,X'FF'      WAS A SYSTEM DDNAME RETRIEVED?\n         BNE   RETURN              IF NOT, RETURN TO PL/I\n         SPACE\n         L     R1,PLIDD            LOAD THE ADDR OF THE PLI\n*                                  LOCATOR DESCRIPTOR\n         L     R1,0(R1)            POINT TO THE DDANME PARM\n         MVC   0(10,R1),DDNAME+4   MOVE THE DDNAME AND ITS LENGTH\n         EJECT\nRETURN   DS    0H\n         L     R15,S99RETC    LOAD THE SVC 99 RETURN CODE\n         L     R14,PLIRC      POINT TO THE RETURN CODE PARM\n         ST    R15,0(R14)     AND PUT IT IN THE PL/I PARM\n         SPACE\n         L     R14,PLIREA     LOAD PLI REASON CODE LOCATOR\n         L     R14,0(R14)     POINT TO BEGINNING OF ARRAY\n         MVC   0(4,R14),RBLK+S99RSC-S99RB  MOVE REASON CODE\n         SPACE\n         REXIT ENV=BOTH\n         EJECT\n**********************************************************************\n*\n* HANDLER FOR  INVALID DSNAMES AND DDNAMES DETECTED BEFORE CALL TO\n* DYNAMIC ALLOCATION.\n*\n**********************************************************************\n         SPACE\nBADDSN   DS    0H\n         MVC   S99FAIL1(LENBADDS),CONBADDS  MOVE IN WTO BASE MESSAGE\n         SPACE\n         L     R14,PLIDS                   POINT TO DSNAME PARM L/D\n         L     R14,0(R14)                  POINT PLI DSNAME PARM\n         LH    R15,0(R14)                  LOAD PARM LENGTH\n         LA    R14,2(R14)                  POINT TO DATASET NAME\n         LA    R1,WTODSN2+S99FAIL1         POINT TO MESSAGE\n         BCTR  R15,0                       SUBTRACT 1 FOR MVC\n         EX    R15,MOVE                    AND MOVE THE DATASET NAME\n         SPACE\n         WTO   MF=(E,S99FAIL1)\n         SPACE\n         LA    R15,RBLK+S99RSC-S99RB   POINT TO REQUEST BLOCK STORAGE\n         XC    0(4,R15),0(R15)         AND ZERO TO SHOW NO SVC 99\n         SPACE\n         LA    R15,12         SET RETURN CODE TO INVALID PARM AND\n         ST    R15,S99RETC    STORE IN THE SAVE PLACE AS THE SVC 99\n*                             RETURN CODE\n         B     RETURN\n         SPACE 3\nBADDD    DS    0H\n         MVC   S99FAIL1(LENBADDD),CONBADDD  MOVE IN WTO BASE MESSAGE\n         SPACE\n         L     R14,PLIDD                   POINT TO DDNAME PARM L/D\n         L     R14,0(R14)                  POINT PLI DDNAME PARM\n         LH    R15,0(R14)                  LOAD PARM LENGTH\n         LA    R14,2(R14)                  POINT TO DD NAME\n         LA    R1,WTODDN2+S99FAIL1         POINT TO MESSAGE\n         BCTR  R15,0                       SUBTRACT 1 FOR MVC\n         EX    R15,MOVE                    AND MOVE THE DATASET NAME\n         SPACE\n         WTO   MF=(E,S99FAIL1)\n         SPACE\n         LA    R15,RBLK+S99RSC-S99RB   POINT TO REQUEST BLOCK STORAGE\n         XC    0(4,R15),0(R15)         AND ZERO TO SHOW NO SVC 99\n         SPACE\n         LA    R15,12         SET RETURN CODE TO INVALID PARM AND\n         ST    R15,S99RETC    STORE IN THE SAVE PLACE AS THE SVC 99\n*                             RETURN CODE\n         B     RETURN\n         SPACE 3\nTOOSHORT DS    0H\n         WTO   'ALLOCDS - 0 - DDNAME FIELD TOO SHORT',ROUTCDE=11\n         SPACE\n         LA    R15,RBLK+S99RSC-S99RB   POINT TO REQUEST BLOCK STORAGE\n         XC    0(4,R15),0(R15)         AND ZERO TO SHOW NO SVC 99\n         SPACE\n         LA    R15,12         SET RETURN CODE TO INVALID PARM AND\n         ST    R15,S99RETC    STORE IN THE SAVE PLACE AS THE SVC 99\n*                             RETURN CODE\n         B     RETURN\n         EJECT\n**********************************************************************\n*\n*                            CONSTANT DATA\n*\n**********************************************************************\n         SPACE\nMOVE     MVC   4(*-*,R1),0(R14)   MOVE PARMS TO TEST UNITS\n         SPACE\nNULLFILE DC    H'8',CL8'NULLFILE'\nDUMMY    DC    H'5',CL8'DUMMY'\n         SPACE 3\nTRANSLAT TRT   DSNAME+6(*-*),0(R14) SEARCH FOR LEFT PARENTHESIS\n         SPACE\nTRBL     DC    XL256'00'\n         ORG   TRBL+C'('\n         DC    X'FF'\n         ORG\n         SPACE 3\nCONS99F1 WTO   'ALLOCDS - 1 - SVC 99 FAILED  RETURN CODE = XX          *\n                              ',                                       *\n               ROUTCDE=11,MF=L\nLENS99F1 EQU   *-CONS99F1\n         SPACE\nCONS99F2 WTO   'ALLOCDS - 2 - REASON CODE = XXXX XXXX                  *\n                              ',                                       *\n               ROUTCDE=11,MF=L\nLENS99F2 EQU   *-CONS99F2\n         SPACE\nCONS99F3 WTO   'ALLOCDS - 3 - DSNAME =                                 *\n                              ',                                       *\n               ROUTCDE=11,MF=L\nLENS99F3 EQU   *-CONS99F3\n         SPACE\nCONS99F4 WTO   'ALLOCDS - 4 - DDNAME =                                 *\n                              ',                                       *\n               ROUTCDE=11,MF=L\nLENS99F4 EQU   *-CONS99F4\n         SPACE\nWTOSTART EQU   X'04'          OFFSET IN WTO TO START OF TEXT\nWTORC    EQU   X'04'+43       OFFSET TO SVC 99 RETURN CODE FIELD IN WTO\nWTOREA   EQU   X'04'+28       OFFSET TO SVC 99 REASON CODE FIELD IN WTO\nWTODSN   EQU   X'04'+23       OFFSET TO DATASET NAME FIELD IN WTO\nWTODDN   EQU   X'04'+23       OFFSET TO DDNAME FIELD IN WTO\n         SPACE 4\nCONBADDS WTO   'ALLOCDS - 0 - INVALID DSNAME PASSED. DSNAME =          *\n                                                                     ',*\n               ROUTCDE=11,MF=L\nLENBADDS EQU   *-CONBADDS\n         SPACE\nCONBADDD WTO   'ALLOCDS - 0 - INVALID DDNAME PASSED. DDNAME =          *\n                                                                     ',*\n               ROUTCDE=11,MF=L\nLENBADDD EQU   *-CONBADDD\n         SPACE\nWTODSN2  EQU   X'04'+47       OFFSET TO DSNAME FIELD IN WTO\nWTODDN2  EQU   X'04'+47       OFFSET TO DDNAME FIELD IN WTO\n         EJECT\n         LTORG\n         EJECT\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         EJECT\nWORKAREA DSECT\n         DS    18D\nRBLKPTR  DS    A\nRBLK     DS    0F\n         DS    XL(RBLKLEN)\nRBLKLEN  EQU   S99RBEND-S99RB\nTXTPTR   DS    44A\nDSNAME   DS    F,H,CL54      TEXT UNIT FOR DATASET NAME\nDDNAME   DS    F,H,CL8       TEXT UNIT FOR DD NAME\nINITDSP  DS    F,H,CL1       TEXT UNIT FOR DATASET DISPOSITION\nMEMNAME  DS    F,H,CL8       TEXT UNIT FOR MEMBER NAME\nDSDISP   DS    F,H,CL1       TEXT UNIT FOR NEW DATA SET DISP\nDSCDISP  DS    F,H,CL1       TEXT UNIT FOR NEW DATA SET ERROR DISP\nDSUNIT   DS    F,H,CL5       TEXT UNIT TO SAY UNIT=SYSDA\nPRSPACE  DS    F,H,CL3       TEXT UNIT FOR SPACE=(?,(*,?))\nSECSPACE DS    F,H,CL3       TEXT UNIT FOR SPACE=(?,(?,*))\nSYSOUT   DS    F,H,CL1       TEXT UNIT FOR SYSOUT=(?)\nSYSCNT   DS    F,H,CL3       TEXT UNIT FOR LINES=?\nSYSCPY   DS    F,H,CL1       TEXT UNIT FOR COPIES=?\nSYSFRE   DS    F             TEXT UNIT FOR FREE=CLOSE\nSYSPGM   DS    F,H,CL8       TEXT UNIT FOR SYSOUT=(A,?)\nPERMALOC DS    F,H           TEXT UNIT FOR PARMALLOC\nBLKSIZE  DS    F,H,H         TEXT UNIT FOR BLKSIZE\nLRECL    DS    F,H,H         TEXT UNIT FOR LRECL\nRECFM    DS    F,H,CL1       TEXT UNIT FOR RECFM\nBUFNO    DS    F,H,CL1       TEXT UNIT FOR BUFNO\nCYL      DS    F             TEXT UNIT FOR SPACE=(CYL,(?,?))\nRLSE     DS    F             TEXT UNIT FOR SPACE=(?,(?,?),RLSE)\nS99FAIL1 DS    0F            WTP FOR SVC 99 LINE 1\n         DS    XL(LENS99F1)\nS99FAIL2 DS    0F            WTP FOR SVC 99 LINE 2\n         DS    XL(LENS99F2)\nS99FAIL3 DS    0F            WTP FOR SVC 99 LINE 3\n         DS    XL(LENS99F3)\nS99FAIL4 DS    0F            WTP FOR SVC 99 LINE 4\n         DS    XL(LENS99F4)\nS99RETC  DS    F\nS99FFLAG DS    H\nDDNAMFLG DS    CL1            FLAG SET WHEN SYSTEM DDNAME IS TO BE\n*                             RETRIEVED.\nWORK1    DS    2D             WORK AREA FOR CONVERSIONS\nWORKLEN  EQU   *-WORKAREA\n         EJECT\nPLIPARMS DSECT         OVERLAY FOR ALLOCDS PARMS\nPLIDS    DS    A       POINTS TO LOCATOR/DESCRIPTOR FOR DSNAME PARM\nPLIDD    DS    A       POINTS TO LOCATOR/DESCRIPTOR FOR DDNAME PARM\nPLITYPE  DS    A       POINTS TO THE FULLWORD TYPE PARM\nPLIREA   DS    A       POINTS TO LOCATOR FOR REASON_CODE ARRAY\nPLIRC    DS    A       POINTS TO THE FULLWORD RETURN CODE PARM\n         SPACE 5\n         EJECT\n*        PRINT NOGEN\n         IEFZB4D0\n         SPACE 5\nERRDSECT IKJEFFDF DFDSECT=YES\n         EJECT\n         SYMBAR MODE=DEC\n         END\nFREEDD   TITLE 'FREEDD - FREE A DDNAME FROM PL/I DYNAMICALLY'\n**********************************************************************\n*\n* SEGMENT NAME:\n*\n*    FREEDD -- FREE DDNAME FROM PL/I DYNAMICALLY\n*\n* INPUTS (*TO FUNCTIONS):\n*\n*    DDNAME -- DDNAME TO BE FREED (*1)\n*       THIS IS THE NAME OF THE DDNAME TO BE FREED.  IT IS PASSED IN\n*       A PL/I VARYING LENGTH CHARACTER STRING OF 8 CHARACTERS.\n*       VALUES: 1 - 8 CHARACTER DDNAME\n*\n* OUTPUTS (*FROM FUNCTIONS):\n*\n*    REASON -- REASON FOR NON-ZERO RETURN CODE (*3,5)\n*    RC -- RETURN CODE (*3,5)\n*    WTP -- WRITE TO PROGRAMMER (*4)\n*\n* NOTES:\n*\n*    1. SAMPLE CALL (AS FUNCTION):\n*\n*       DCL FREEDD ENTRY(VARYING CHAR(8), (2) FIXED BINARY(15)))\n*       RETURNS(FIXED BINARY(31)) EXTERNAL;\n*       DECLARE DDNAME CHAR(8)  VARYING;\n*       DECLARE REASON_CODE(2) FIXED BINARY(15);\n*       DECLARE RETURN_CODE FIXED BINARY(31);\n*\n*       RETURN_CODE = FREEDD(DDNAME,REASON_CODE);\n*\n**********************************************************************\n         EJECT\nFREEDD   RENTR WORK=(WORKLEN,WORKAREA),PARM=(10,PLIPARM2),BASE=11,     X\n               ENV=BOTH\n         SPACE 2\n         LA    R15,RBLK       INITIALIZE REQUEST BLOCK POINTER\n         ST    R15,RBLKPTR\n         OI    RBLKPTR,S99RBPND     TURN ON HIGH BIT IN ADDRESS\n         SPACE\n         XC    RBLK(RBLKLEN),RBLK   CLEAR THE SVC 99 REQUEST BLOCK\n         SPACE\n         LA    R14,RBLK       LOAD THE REQUEST BLOCK ADDRESS AND\n         USING S99RB,R14      OVERLAY THE DESCRIPTIVE DSECT\n         SPACE\n         LA    R15,RBLKLEN    LOAD REQUEST BLOCK LEN (20)\n         STC   R15,S99RBLN    STORE IN REQUEST BLOCK\n         SPACE\n         LA    R15,S99VRBUN   LOAD VERB FOR UNALLOCATION\n         STC   R15,S99VERB    STORE VERB (FUNCTION) IN REQUEST BLK\n         SPACE\n         LA    R15,TXTPTR     LOAD ADDR OF TEXT POINTER LIST\n         ST    R15,S99TXTPP   STORE IN REQUEST BLOCK\n         SPACE\n         DROP  R14\n         EJECT\n**********************************************************************\n*\n* BUILD THE TEXT POINTER LIST.  IT HAS 1 FULL WORD ELEMENT WITH X'80'\n* IN THE HIGH BYTE.\n*\n**********************************************************************\n         SPACE\n         LA    R14,DDNAME     POINT TO THE DDNAME TEXT UNIT\n         LA    R15,SYSFRE     POINT TO THE FORCE UNALLOCATION TXT UNIT\n         STM   R14,R15,TXTPTR STORE THE ADDRS IN THE TEXT POINTER LIST\n         OI    TXTPTR+4,X'80' MARK THE HIGH BIT OF THE LAST ENTRY\n         SPACE 2\n**********************************************************************\n*\n* BUILD THE DDNAME TEXT UNIT.  IF THE DDNAME IS MISSING OR BLANK OR\n* TOO LONG, FLAG AN ERROR.\n*\n**********************************************************************\n         SPACE\n         MVC   SYSFRE(4),=X'00070000' FORCE FREE\n         MVI   DDNAMFLG,X'00' CLEAR THE DDNAME FLAG\n         LA    R1,DDNAME      POINT TO DDNAME TEXT UNIT\n         L     R14,PLIDD2     POINT TO THE DDNAME LOACATOR/DESCRIPTOR\n         L     R14,0(R14)     POINT THE DDNAME PARM LENGTH FIELD\n         LH    R15,0(R14)     GET THE PARM LENGTH\n         LTR   R15,R15        IS IT ZERO?\n         BZ    BADDD2         IF SO, FLAG AS AN ERROR\n         SPACE\n         CLI   2(R14),C' '    IS THE DDNAME PARM BLANK\n         BE    BADDD2         IF SO, FLAG AS AN ERROR\n         SPACE\n         CH    R15,=H'8'      IS DDNAME TOO LONG?\n         BH    BADDD2         IF SO FLAG AS A BAD LENGTH\n         SPACE\n         LA    R15,1(R15)     LOAD LENGTH OF PARM + LENGTH FIELD - 1\n         EX    R15,MOVE       MOVE LENGTH AND DDNAME TO TEXT UNIT\n         SPACE\n         L     R15,=XL4'00010001' SET UP TEXT UNIT CONTROL INFO\n         ST    R15,DDNAME     AND STORE IN TEXT UNIT\n         EJECT\n**********************************************************************\n*\n* CALL SVC 99 PASSING THE PARM LIST WHICH WAS CONTRUCTED BY THIS\n* ROUTINE.  SAVE THE DYNALLOC RETURN CODE IN THE RETURN CODE PARM AND\n* THEN TEST THE PARM TO SEE IF AN ERROR MESSAGE MUST BE OUTPUT.\n*\n**********************************************************************\n         SPACE\n         LA    R1,RBLKPTR            LOAD SVC 99 PARM LIST\n         DYNALLOC\n         SPACE\n         ST    R15,S99RETC           SAVE THE SVC 99 RETURN CODE\n         LTR   R15,R15               TEST THE SVC 99 RETURN CODE\n         BZ    FREEDONE              IF ZERO,  CONTINUE NORMALLY\n         EJECT\n         MVC   S99FAIL1(LENS99F1),CONS99F1       MOVE IN THE WTO BASE\n         MVC   S99FAIL1+WTOSTART(7),=CL7'FREEDD' MSG AND NEW ID\n         MVC   S99FAIL2(LENS99F2),CONS99F2       MOVE IN THE WTO BASE\n         MVC   S99FAIL2+WTOSTART(7),=CL7'FREEDD' MSG AND NEW ID\n         MVC   S99FAIL4(LENS99F4),CONS99F4       MOVE IN THE WTO BASE\n         MVC   S99FAIL4+WTOSTART(7),=CL7'FREEDD' MSG AND NEW ID\n         SPACE\n         LA    R15,WTORC+S99FAIL1          POINT TO RETURN CODE FIELD\n         UNPK  0(3,R15),S99RETC+3(2)       GET SVC 99 RETURN CODE AND\n         TR    0(3,R15),HEXCHAR            TRANSLATE TO PRINTABLE HEX\n         MVI   2(R15),C' '                 BLAST EXTRA BYTE\n         SPACE\n         LA    R15,WTOREA+S99FAIL2         POINT TO REASON CODE FIELD\n         UNPK  WORK1(9),RBLK+S99RSC-S99RB(5)  UNPACK REASON CODE\n         MVC   0(4,R15),WORK1              MOVE 1ST PART OF REASON CODE\n         MVC   5(4,R15),WORK1+4            AND 2ND PART TO MESSAGE\n         TR    0(4,R15),HEXCHAR            TRANSLATE REASON CODE\n         TR    5(4,R15),HEXCHAR            TO PRINTABLE HEX\n         SPACE\n         L     R14,PLIDD2                  POINT TO DDNAME PARM L/D\n         L     R14,0(R14)                  POINT PLI DDNAME PARM\n         LH    R15,0(R14)                  LOAD PARM LENGTH\n         LA    R14,2(R14)                  POINT TO DD NAME\n         LA    R1,WTODDN+S99FAIL4          POINT TO MESSAGE\n         BCTR  R15,0                       SUBTRACT 1 FOR MVC\n         EX    R15,MOVE                    AND MOVE THE DATASET NAME\n         SPACE\n         WTO   MF=(E,S99FAIL1)             ISSUE WRITE TO PROGRAMMER\n         WTO   MF=(E,S99FAIL2)             ISSUE WRITE TO PROGRAMMER\n         WTO   MF=(E,S99FAIL4)             ISSUE WRITE TO PROGRAMMER\n*                                          AND QUIT\n         EJECT\nFREEDONE DS    0H\n         L     R15,S99RETC    LOAD THE SVC 99 RETURN CODE\n         L     R14,PLIRC2     POINT TO THE RETURN CODE PARM\n         ST    R15,0(R14)     AND PUT IT IN THE PL/I PARM\n         SPACE\n         L     R14,PLIREA2    LOAD PLI REASON CODE LOCATOR\n         L     R14,0(R14)     POINT TO BEGINNING OF ARRAY\n         MVC   0(4,R14),RBLK+S99RSC-S99RB  MOVE REASON CODE\n         SPACE\n         REXIT ENV=BOTH\n         EJECT\nBADDD2   DS    0H\n         MVC   S99FAIL1(LENBADDD),CONBADDD  MOVE IN WTO BASE MESSAGE\n         MVC   S99FAIL1+WTOSTART(7),=CL7'FREEDD'     AND FREEDD ID\n         SPACE\n         L     R14,PLIDD2                  POINT TO DDNAME PARM L/D\n         L     R14,0(R14)                  POINT PLI DDNAME PARM\n         LH    R15,0(R14)                  LOAD PARM LENGTH\n         LA    R14,2(R14)                  POINT TO DD NAME\n         LA    R1,WTODDN2+S99FAIL1         POINT TO MESSAGE\n         BCTR  R15,0                       SUBTRACT 1 FOR MVC\n         EX    R15,MOVE                    AND MOVE THE DATASET NAME\n         SPACE\n         WTO   MF=(E,S99FAIL1)\n         SPACE\n         LA    R15,RBLK+S99RSC-S99RB   POINT TO REQUEST BLOCK STORAGE\n         XC    0(4,R15),0(R15)         AND ZERO TO SHOW NO SVC 99\n         SPACE\n         LA    R15,12         SET RETURN CODE TO INVALID PARM AND\n         ST    R15,S99RETC    STORE IN THE SAVE PLACE AS THE SVC 99\n*                             RETURN CODE\n         B     FREEDONE\n         EJECT\nMOVE     MVC   4(*-*,R1),0(R14)   MOVE PARMS TO TEST UNITS\n         SPACE\nNULLFILE DC    H'8',CL8'NULLFILE'\nDUMMY    DC    H'5',CL8'DUMMY'\n         SPACE 3\nCONS99F1 WTO   'ALLOCDS - 1 - SVC 99 FAILED  RETURN CODE = XX          *\n                              ',                                       *\n               ROUTCDE=11,MF=L\nLENS99F1 EQU   *-CONS99F1\n         SPACE\nCONS99F2 WTO   'ALLOCDS - 2 - REASON CODE = XXXX XXXX                  *\n                              ',                                       *\n               ROUTCDE=11,MF=L\nLENS99F2 EQU   *-CONS99F2\n         SPACE\nCONS99F4 WTO   'ALLOCDS - 4 - DDNAME =                                 *\n                              ',                                       *\n               ROUTCDE=11,MF=L\nLENS99F4 EQU   *-CONS99F4\n         SPACE\nWTOSTART EQU   X'04'          OFFSET IN WTO TO START OF TEXT\nWTORC    EQU   X'04'+43       OFFSET TO SVC 99 RETURN CODE FIELD IN WTO\nWTOREA   EQU   X'04'+28       OFFSET TO SVC 99 REASON CODE FIELD IN WTO\nWTODSN   EQU   X'04'+23       OFFSET TO DATASET NAME FIELD IN WTO\nWTODDN   EQU   X'04'+23       OFFSET TO DDNAME FIELD IN WTO\n         SPACE 4\nCONBADDD WTO   'ALLOCDS - 0 - INVALID DDNAME PASSED. DDNAME =          *\n                                                                     ',*\n               ROUTCDE=11,MF=L\nLENBADDD EQU   *-CONBADDD\n         SPACE\nWTODDN2  EQU   X'04'+47       OFFSET TO DDNAME FIELD IN WTO\n         EJECT\n         LTORG\n         EJECT\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0123456789ABCDEF'\n         ORG\n         EJECT\nWORKAREA DSECT\n         DS    18D\nRBLKPTR  DS    A\nRBLK     DS    0F\n         DS    XL(RBLKLEN)\nRBLKLEN  EQU   S99RBEND-S99RB\nTXTPTR   DS    44A\nDDNAME   DS    F,H,CL8       TEXT UNIT FOR DD NAME\nSYSFRE   DS    F             TEXT UNIT FOR FREE=CLOSE\nS99FAIL1 DS    0F            WTP FOR SVC 99 LINE 1\n         DS    XL(LENS99F1)\nS99FAIL2 DS    0F            WTP FOR SVC 99 LINE 2\n         DS    XL(LENS99F2)\nS99FAIL4 DS    0F            WTP FOR SVC 99 LINE 4\n         DS    XL(LENS99F4)\nS99RETC  DS    F\nS99FFLAG DS    H\nDDNAMFLG DS    CL1            FLAG SET WHEN SYSTEM DDNAME IS TO BE\n*                             RETRIEVED.\nWORK1    DS    2D             WORK AREA FOR CONVERSIONS\nWORKLEN  EQU   *-WORKAREA\n         EJECT\nPLIPARM2 DSECT         OVERLAY FOR FREEDD AND AINTRDR PARMS\nPLIDD2   DS    A       POINTS TO LOCATOR/DESCRIPTOR FOR DDNAME PARM\nPLIREA2  DS    A       POINTS TO LOCATOR FOR REASON_CODE ARRAY\nPLIRC2   DS    A       POINTS TO THE FULLWORD RETURN CODE PARM\n         EJECT\n*        PRINT NOGEN\n         IEFZB4D0\n         SPACE 5\nERRDSECT IKJEFFDF DFDSECT=YES\n         EJECT\n         SYMBAR MODE=DEC\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FIXDCB": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00#\\x00#\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "STYMA"}, "text": "*\n*  PROGRAM FIXDCB\n*\n*  USES DDNAME:  FILE\n*\n*  THIS PROGRAM MODIFIES THE DCB ATTRIBUTES OF A FILE WITHOUT\n*  DESTROYING THE CONTENTS.  THE ATTRIBUTES ARE PICKED UP FROM\n*  THE DCB PARAMETER OF THE DD STATEMENT WHICH REFERENCES DDNAME\n*  FILE.\n*\n*\n*\n*\n         USING FIXDCB,R15\nFIXDCB   CSECT\n         STM   R14,R12,12(R13)\n         LR    R14,R13\n         LA    R13,SAVEAREA\n         ST    R14,4(R13)\n         ST    R13,8(R14)\n         LR    R12,R15\n         USING FIXDCB,R12\n         DROP  R15\n         OPEN  (DCB,(OUTPUT))\n         NI    DCB+(DCBOFLGS-IHADCB),X'7F'  SHOW LAST I/O WAS READ\n         CLOSE DCB\n         L     R13,4(R13)\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14\nDCB      DCB   DDNAME=FILE,DSORG=PS,MACRF=PM\nSAVEAREA DS    20F\n         SYMBAR MODE=DEC\n         DCBD  DSORG=PS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GETDSN": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00\\xf0\\x00\\xf0\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 240, "newlines": 240, "modlines": 0, "user": "STYMA"}, "text": "GETDSN   TITLE 'GET DATASET NAME OR VOLUME SERIAL NUMBER'\n**********************************************************************\n*\n* SEGMENT NAME:\n*\n*    GETDSN\n*\n* INPUTS (*TO FUNCTIONS):\n*\n*    DDNAME -- A CHARACTER(8) PL/I STRING PASSED AS INPUT. (*2)\n*\n*\n* NOTES:\n*\n*    1. SAMPLE DECLARES AND CALLS:\n*\n*       DECLARE  GETDSN  ENTRY(CHAR(8)) RETURNS(CHAR(44));\n*       DECLARE  DDNAME  CHAR(8) INIT('DD1');\n*       DECLARE  DSNAME  CHAR(8);\n*\n*       DSNAME = GETDSN(DDNAME);\n*\n*       DECLARE  GETVOL  ENTRY(CHAR(8)) RETURNS(CHAR(6));\n*       DECLARE  VOLUME  CHAR(6);\n*\n*       VOLUME = GETVOL(DDNAME);\n*\n*       DECLARE  GETMEM  ENTRY(CHAR(8)) RETURNS(CHAR(8));\n*       DECLARE  MEMBER  CHAR(8);\n*\n*       MEMBER = GETMEM(DDNAME);\n*       DECLARE  MODE    FIXED BINARY(15);\n*\n*    2. EACH FUNCTION RETURNS A BLANK STRING IF THE DDNAME IS NOT\n*       FOUND.\n*\n**********************************************************************\n         EJECT\n         PRINT OFF\n         GBLC  &XA\n&XA      SETC  'YES'\n         PRINT ON\nGETDSN   RENTR BASE=11,PARM=10,WORK=(WORKLEN,WORKAREA)\n         SPACE 2\n         L     R11,COMBASE              EXTABLISH\n         DROP  R11                      COMMON\n         USING GETDSN,R11               ADDRESSABILITY\n         SPACE 2\n         MVI   STATUSFL,CGETDSN         INDICATE THAT GETDSN WAS CALLED\n         B     COMCODE                  GO TO THE COMMON CODE\n         EJECT\n         DS    0D\nGETMEM   RENTR *,BASE=11,PARM=10,WORK=(WORKLEN,WORKAREA)\n         SPACE 2\n         L     R11,COMBASE              ESTABLISH\n         DROP  R11                      COMMON\n         USING GETDSN,R11               ADDRESSABILITY\n         SPACE 2\n         MVI   STATUSFL,CGETMEM         INDICATE THAT GETMEM WAS CALLED\n         B     COMCODE                  GO TO THE COMMON CODE\n         EJECT\n         DS    0D\nGETVOL   RENTR *,BASE=11,PARM=10,WORK=(WORKLEN,WORKAREA)\n         SPACE 2\n         L     R11,COMBASE              ESTABLISH\n         DROP  R11                      COMMON\n         USING GETDSN,R11               ADDRESSABILITY\n         SPACE 2\n         MVI   STATUSFL,CGETVOL         INDICATE THAT GETVOL WAS CALLED\n         EJECT\n**********************************************************************\n*\n* COMMON EXECUTION CODE STARTS HERE. A FLAG HAS BEEN SET IN THE\n* PROLOG CODE TO SHOW WHETHER WE WANT THE DATASET NAME, MEMBER NAME,\n* OR VOLSER FROM THE JFCB. USE THIS FLAG TO CLEAR THE CORRECT LENGTH\n* IN THE TARGET PARM.\n*\n*      REGISTER USAGE:\n*              R4  -> DDNAME\n*              R5  -> TARGET DSNAME, MEMBER, OR VOLSER\n*              R6  -> THE TIOT\n*              R9  -  CURRENT ADDRESSING MODE IN THE HIGH BIT\n*              R11 -  BASE REGISTER\n*              R12 -  PL/I TCA, DO NOT MODIFY\n*              R13 -> LOWER DSA AND SAVE AREA\n*\n**********************************************************************\n         SPACE\nCOMCODE  DS    0H                       HERE STARTS THE COMMON CODE\n         LM    R4,R5,0(R10)             LOAD PARAMETER LOCATOR ADDR.\n*                                       R4 -> LOCATOR -> DDNAME\n*                                       R5 -> LOCATOR -> DSN./VOL. SER.\n         L     R4,0(R4)                 LOAD DDNAME ADDRESS\n         L     R5,0(R5)                 LOAD DSN. OR VOL. SER. ADDRESS\n         MVI   0(R5),C' '               FILL OUT A BLANK AS FIRST\n*                                       DSNAME OR VOL. SER. CHARACTER\n         MVC   1(5,R5),0(R5)            PROPAGATE THAT BLANK FOR 5 MORE\n*                                       CHARACTERS, THEREBY BLANKING\n*                                       OUT THE VOLSER\n         AIF   ('&XA' NE 'YES').NOXA3\n         SLR   R9,R9\n         BSM   R9,0                     SAVE CURRENT ADDRESSING MODE\n.NOXA3   ANOP\n         SPACE\n         TM    STATUSFL,CGETDSN         IS THIS A GETDSN CALL?\n         BNO   MEMCK                    NO, THEN CHECK FOR GETMEM\n         MVC   6(38,R5),5(R5)           PROPAGATE THE SIXTH BLANK FOR\n         B     GETTIOT                  38 MORE SPACES\n         SPACE 2\nMEMCK    DS    0H\n         TM    STATUSFL,CGETMEM         IS THIS A GETMEM CALL ?\n         BNO   GETTIOT                  NO, THEN GOTO GETTIOT\n         MVC   6(2,R5),5(R5)            BLANK TWO MORE SPACES FOR MEM\n         SPACE 2\nGETTIOT  DS    0H\n         L     R6,16                    POINT TO THE CVT\n         L     R6,0(R6)                 POINT TO THE TCB DOUBLEWORD\n         L     R6,0(R6)                 POINT TO OUR TCB\n         USING TCB,R6                   ADDRESS THE TCB\n         SPACE\n         L     R6,TCBTIO                GET ADDR OF THE TIOT\n         DROP  R6                       DON'T NEED THE TCB ANY MORE\n         USING TIOT1,R6                 ADDRESS THE TIOT\n         EJECT\n**********************************************************************\n*\n* SCAN THE TIOT ENTRIES LOOKING FOR THE DDNAME WE WANT.\n*\n*      REGISTER USAGE:\n*              R4  -> DDNAME\n*              R5  -> TARGET DSNAME, MEMBER, OR VOLSER\n*              R6  -> THE TIOT ENTRY UNDER CONSIDERATION\n*              R7  -  WORK REGISTER USED TO BUMP TIOT POINTER TO NEXT\n*                     ENTRY\n*              R9  -  CURRENT ADDRESSING MODE IN THE HIGH BIT\n*              R11 -  BASE REGISTER\n*              R12 -  PL/I TCA, DO NOT MODIFY\n*              R13 -> LOWER DSA AND SAVE AREA\n*\n**********************************************************************\n         SPACE\nTIOTSCAN DS    0H\n         CLI   TIOELNGH,X'00'           IS THIS THE END OF THE TIOT ?\n         BE    RETURN                   YES, SO WE DIDN'T FIND THE DD\n*                                       ENTRY AND WE RETURN\n         CLC   0(8,R4),TIOEDDNM         IS THIS DD ENTRY THE ONE ?\n         BE    DDFOUND                  YES, SO GO TO DDFOUND\n         SLR   R7,R7                    NO, SO CLEAR R7\n         IC    R7,TIOELNGH              AND LOAD THE DDENTRY LENGTH\n         AR    R6,R7                    AND POSITION R6 TO POINT TO\n*                                       THE NEXT DD ENTRY\n         B     TIOTSCAN                 AND SCAN THE NEXT TIOT DD ENTRY\n         EJECT\n**********************************************************************\n*\n* WE HAVE FOUND THE DDNAME WE ARE LOOKING FOR IN THE TIOT. CONVERT\n* THE JCFB TOKEN IN THE TIOT TO THE REAL JCFB ADDRESS WHICH IS 4\n* BYTES LONG.\n*\n*      REGISTER USAGE:\n*              R4  -> DDNAME\n*              R5  -> TARGET DSNAME, MEMBER, OR VOLSER\n*              R6  -> THE TIOT ENTRY UNDER CONSIDERATION\n*              R7  -> JFCB FOR DDNAME\n*              R9  -  CURRENT ADDRESSING MODE IN THE HIGH BIT\n*              R11 -  BASE REGISTER\n*              R12 -  PL/I TCA, DO NOT MODIFY\n*              R13 -> LOWER DSA AND SAVE AREA\n*\n**********************************************************************\n         SPACE\nDDFOUND  DS    0H\n         AIF   ('&XA' NE 'YES').NOXA5\n         SMODE 31\n         SPACE\n         LA    R1,TIOEJFCB              POINT TO THE JFCB TOKEN\n         L     R15,=V(SWAREQ)           POINT TO THE CONVERT ROUTINE\n         BALR  R14,R15                  CONVERT TOKEN TO ADDRESS\n         SPACE\n         LR    R7,R0                    RETURNED JFCB ADDR IN R0\n         AGO   .XA5\n.NOXA5   ANOP\n         SLR   R7,R7                    CLEAR R7 FOR LOADING JFCB ADDR\n         ICM   R7,X'7',TIOEJFCB         GET THE JFCB ADDRESS\n         LA    R7,16(R7)\n.XA5     ANOP\n         DROP  R6\n         USING INFMJFCB,R7              WE USE R7 AS THE JFCB\n*                                       BASE REGISTER\n         TM    STATUSFL,CGETDSN         WAS GETDSN CALLED ?\n         BNO   MEMNAM                   NO, THEN CHECK THE MEMNAM\n         MVC   0(44,R5),JFCBDSNM        GET THE DATASET NAME\n         B     RETURN                   AND RETURN\n         SPACE 2\nMEMNAM   DS    0H\n         TM    STATUSFL,CGETMEM         WAS GETMEM CALLED ?\n         BNO   VOLSER                   NO, SO THE VOL. SER. IS NEEDED\n         TM    JFCBIND1,JFCPDS          IS THIS DATASET A PDS?\n         BNO   RETURN                   NO, THEN RETURN\n         MVC   0(8,R5),JFCBELNM         GET THE MEMBER\n         B     RETURN                   AND RETURN\n         SPACE 2\nVOLSER   DS    0H\n         MVC   0(6,R5),JFCBVOLS         GET THE FIRST VOL. SER. NUMBER\n         EJECT\nRETURN   DS    0H\n         AIF   ('&XA' NE 'YES').NOXA4\n         SMODE (R9)                     RESTORE THE ADDRESSING MODE\n.NOXA4   ANOP\n         REXIT                          RETURN\n         SPACE\nCOMBASE  DC    V(GETDSN)                THE COMMON BASE ADDRESS\n         LTORG\n         DROP  R11\n         EJECT\nWORKAREA DSECT\n         DS    30F                      SAVE AREA\nSTATUSFL DS    XL1                      X'80' INDICATES\n*                                       ENTRY POINT GETDSN WAS CALLED\n*                                       X'40' INDICATES\n*                                       ENTRY POINT GETMEM WAS CALLED\n*                                       X'00' INDICATES\n*                                       ENTRY POINT GETVOL WAS CALLED\nCGETDSN  EQU   X'80'\nCGETMEM  EQU   X'40'\nCGETVOL  EQU   X'00'\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE 2\n         PRINT NOGEN\n         IEFTIOT1                       TASK INPUT OUTPUT TABLE MACRO\n         SPACE 2\n         IEFJFCBN                       JOB FILE CONTROL BLOCK MACRO\n         SPACE 2\n         IKJTCB                         TASK CONTROL BLOCK MACRO\n         SPACE\n         CVT    DSECT=YES\n         SPACE\n         SYMBAR MODE=DEC\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPCSLMSG": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00D\\x00D\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 68, "newlines": 68, "modlines": 0, "user": "STYMA"}, "text": "         MACRO ,\n&LAB IPCSLMSG &REG,&DUMPREG,&MSG,&MSGOFF,&L2,&OUTDCB,&PRDCB,&WORK=LINE\n.*\n.*   THIS MACRO GENERATES AN IPCS CALL TO GET THE STORAGE\n.*   SPECIFIED IN PARM FROM FROM THE DUMP AN LOAD ITS ADDRESS\n.*   INTO REGISTER REG.\n.*\n.*         #########################################################\n.*   NOTE: #  THE RENTR AND REXIT MACROS WITH ENV=IPCS MUST BE\n.*         #  USED IN PROGRAMS USING THIS MACRO\n.*         #########################################################\n.*\n.*   REGISTER  &REG IS MODIFIED BY THIS MACRO.\n.*\n.* FORMAT:\n.*LABEL IPCSLOAD REG,FROMADDR,LEN=20,PERM=TCBAREA\n.*\n.*   PARMS:\n.*\n.*   REG  - A REGISTER NUMBER.  THE ADDRESS ACCESSABLE BY\n.*          THE PROGRAM IS LISTED HERE.\n.*\n.*   FROM - THE ADDRESS TO BE LOADED.\n.*          IF (REG) IS SPECIFIED, THE REGISTER IS ASSUMED TO HAVE\n.*          THE DUMP ADDRESS TO BE ACCESSED.  OTHERWISE, THE PASSED\n.*          SYMBOL IS LOADED, AND THE ADDRESS IS ASSUMED TO BE AN\n.*          ADDRESS IN THE DUMP.\n.*\n.*   LEN  - THIS IS THE LENGTH OF THE STORAGE TO REQUEST FROM THE\n.*          DUMP.  THIS CAN BE A SYMBOL < WITH A VALUE UP TO 4096\n.*          OR A REGISTER (REG).\n.*\n.*   PERM - THIS IS AN ADDRESS (OR REGISTHER (REG) WHICH IS AT LEAST\n.*          LEN= BYTES LONG.  THE DATA FROM THE CALL IS COPIED TO THIS\n.*          AREA.  THIS AREA IS THEN RETURNED IN REG.\n.*\n.*   SA   - THIS IS A WORK AREA OF AT LEAST 16 BYTES USED TO PROTECT\n.*          REGISTERS.  A DEFAULT IS GIVEN FOR BEAUTIFICATION REASONS.\n.*\n.* SAMPLE:\n.*       IPCSLOAD R5,TCBTCB,LEN=TCBLEN\n.*\n.*\n         LCLC  &IDX\n&IDX     SETC  '&SYSNDX'\n&LAB     LTR   &REG,&REG\n         BNZ   ISOK&IDX\n         AIF   ('&MSG' EQ '&WORK').NOMOVE\n         SPACE\n         MVC   &WORK,&MSG\n.NOMOVE  ANOP\n         AIF   ('&DUMPREG' EQ '').NODUMP\n         SPACE\n         ST    &DUMPREG,AREA24\n         UNPK  &WORK+&MSGOFF.(9),AREA24(5)\n         TR    &WORK+&MSGOFF.(8),HEXCHAR\n         MVI   &WORK+&MSGOFF+8,C' '\n.NODUMP  ANOP\n         AIF   ('&OUTDCB' EQ '').NOOUT\n         PUT31 AREA24,&OUTDCB,&WORK\n         AIF   ('&L2' EQ '').NOL2\n         PUT31 AREA24,&OUTDCB,&L2\n.NOL2    ANOP\n.NOOUT   AIF   ('&PRDCB' EQ '').NOPR\n         VSMPRNT AREA24,&PRDCB,&WORK\n.NOPR    ANOP\nISOK&IDX DS    0H\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPCSLOAD": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00\\x98\\x00\\x98\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 152, "newlines": 152, "modlines": 0, "user": "STYMA"}, "text": "         MACRO ,\n&LABL    IPCSLOAD &REG,&FROM,&LEN=16,&PERM=,&SA=AREA24\n.*\n.*   THIS MACRO GENERATES AN IPCS CALL TO GET THE STORAGE\n.*   SPECIFIED IN PARM FROM FROM THE DUMP AN LOAD ITS ADDRESS\n.*   INTO REGISTER REG.\n.*\n.*         #########################################################\n.*   NOTE: #  THE RENTR AND REXIT MACROS WITH ENV=IPCS MUST BE\n.*         #  USED IN PROGRAMS USING THIS MACRO\n.*         #########################################################\n.*\n.*   REGISTER  &REG IS MODIFIED BY THIS MACRO.\n.*\n.* FORMAT:\n.*LABEL IPCSLOAD REG,FROMADDR,LEN=20,PERM=TCBAREA\n.*\n.*   PARMS:\n.*\n.*   REG  - A REGISTER NUMBER.  THE ADDRESS ACCESSABLE BY\n.*          THE PROGRAM IS LISTED HERE.\n.*\n.*   FROM - THE ADDRESS TO BE LOADED.\n.*          IF (REG) IS SPECIFIED, THE REGISTER IS ASSUMED TO HAVE\n.*          THE DUMP ADDRESS TO BE ACCESSED.  OTHERWISE, THE PASSED\n.*          SYMBOL IS LOADED, AND THE ADDRESS IS ASSUMED TO BE AN\n.*          ADDRESS IN THE DUMP.\n.*\n.*   LEN  - THIS IS THE LENGTH OF THE STORAGE TO REQUEST FROM THE\n.*          DUMP.  THIS CAN BE A SYMBOL < WITH A VALUE UP TO 4096\n.*          OR A REGISTER (REG).\n.*\n.*   PERM - THIS IS AN ADDRESS (OR REGISTHER (REG) WHICH IS AT LEAST\n.*          LEN= BYTES LONG.  THE DATA FROM THE CALL IS COPIED TO THIS\n.*          AREA.  THIS AREA IS THEN RETURNED IN REG.\n.*\n.*   SA   - THIS IS A WORK AREA OF AT LEAST 16 BYTES USED TO PROTECT\n.*          REGISTERS.  A DEFAULT IS GIVEN FOR BEAUTIFICATION REASONS.\n.*\n.* SAMPLE:\n.*       IPCSLOAD R5,TCBTCB,LEN=TCBLEN\n.*\n.*\n         GBLB  &IPCSFG\n         LCLC  &IDX\n         LCLC  &TMPSA\n&IDX     SETC  '&SYSNDX'\n         AIF   ('&IPCSFG' EQ '1').IPCSOK\n         MNOTE 8,'ENV=IPCS NOT SPECIFIED IN RENTR MACRO OR, RENTR NOT UX\n               SED'\n         MEXIT\n.IPCSOK  ANOP\n         AIF   (('&REG' NE '14') AND ('&REG' NE 'R14') AND             X\n               ('&REG' NE '15') AND ('&REG' NE 'R15') AND              X\n               ('&REG' NE '0')  AND ('&REG' NE 'R0')  AND              X\n               ('&REG' NE '1')  AND ('&REG' NE 'R1')).REGOK\n         MNOTE 8,'INVALID TARGET REGISTER &REG, REGS 14,15,0,1 ARE INVAX\n               LID'\n         MEXIT\n.REGOK   ANOP\n.*********************************************************************\n.*\n.*       SAVE THE REGISTERS THE IPCS ROUTINES (AND US) WILL USE\n.*\n.*********************************************************************\n         AIF   ('&SA'(1,1) EQ '(').REGSA\n&TMPSA   SETC  '&SA'\n         AGO   .GOTSA\n.REGSA   ANOP\n&TMPSA   SETC  '0(&SA(1))'\n.GOTSA   ANOP\n&LABL    STM   R14,R1,&TMPSA      SAVE WORK REGISTERS IN USERS AREA\n         L     R1,72(,R13)        GET IPCS PARM FROM WHERE RENTR PUT IT\n.*********************************************************************\n.*\n.*       GET THE DUMP ADDRESS TO RETRIEVE INTO REGISTER R0\n.*\n.*********************************************************************\n         AIF   ('&FROM'(1,1) EQ '(').REGFROM\n         L     R0,&FROM            PUT DUMP ADDR IN R0 FOR IPCS\n         AGO   .GOTFROM\n.REGFROM ANOP\n         LR    R0,&FROM(1)         PUT DUMP ADDR IN R0 FOR IPCS\n.GOTFROM ANOP\n.*********************************************************************\n.*\n.*       PUT THE LENGTH IN THE ADPL PARM LIST\n.*\n.*********************************************************************\n         AIF   ('&LEN'(1,1) EQ '(').REGLEN\n         L     R14,=A(&LEN)        SAVE LEN IN ADPL\n         STH   R14,ADPLDLEN-ABDPL(,R1) SAVE LEN IN ADPL\n         AGO   .GOTLEN\n.REGLEN  ANOP\n         STH   &LEN(1),ADPLDLEN-ABDPL(,R1) SAVE LEN IN ADPL\n.GOTLEN  ANOP\n.*********************************************************************\n.*\n.*       CALL THE SERVICE ROUTINE AND TEST THE RC\n.*\n.*********************************************************************\n         XR    &REG,&REG              CLEAR REG IN CASE OF FAILURE\n         L     R15,ADPLMEMA-ABDPL(,R1) POINT TO SERVICE ROUTINE\n         BALR  R14,R15                 CALL STORAGE ROUTINE\n         LTR   R15,R15                DID THE CALL WORK\n         BNZ   DON&IDX\n.*********************************************************************\n.*\n.*       IF WE AREN'T SAVING A PERMANENT COPY SKIP TO THE END,\n.*       OTHERWISE COPY THE DATA TO THE PERM ADDRESS\n.*       A LOOP OF MVC'S IS USED BECAUSE WE DON'T HAVE ENOUGH\n.*       REGISTERS FOR AN MVCL AND MOST OF THE TIME WE MOVE < 256\n.*\n.*********************************************************************\n         AIF   ('&PERM' EQ '').SHORT\n         AIF   ('&LEN'(1,1) EQ '(').REGLEN2\n         L     R1,=A(&LEN)         GET LENGTH IN REGISTER\n         AGO   .GOTLEN2\n.REGLEN2 ANOP\n         LR    R1,&LEN(1)          GET LENGTH IN REGISTER\n.GOTLEN2 ANOP\n         AIF   ('&PERM'(1,1) EQ '(').REGPERM\n         LA    R14,&PERM           GET TARGET IN REGISTER\n         AGO   .GOTPERM\n.REGPERM ANOP\n         LR    R14,&PERM(1)        GET TARGET IN REGISTER\n.GOTPERM ANOP\n         LR    R15,R0              GET SOURCE IN ADDRESSABLE REGISTER\n         LR    R0,R14              SAVE NEW RETURED ADDRESS\nLOP&IDX  DS    0H\n         C     R1,=F'256'          IS THERE MORE THAN 256\n         BNH   LST&IDX             IF NOT USE AN EXECUTE\n         MVC   0(256,R14),0(R15)   MOVE 256\n         S     R1,=F'256'          DECREMENT COUNT\n         LA    R14,256(,R14)       BUMP TARGET\n         LA    R15,256(,R15)       BUMP SOURCE\n         B     LOP&IDX\nMOV&IDX  MVC   0(*-*,R14),0(R15)   MOVE 256 OR LESS BYTES\nLST&IDX  DS    0H\n         BCTR  R1,0                DECREMENT FOR EX INSTRUCTION\n         EX    R1,MOV&IDX          MOVE THE DATA\n.SHORT   ANOP\n         LR    &REG,R0             PUT DATA IN REQUESTERS REG\n.*********************************************************************\n.*\n.*       RESTORE THE WORK REGISTERS AND WE ARE DONE\n.*\n.*********************************************************************\n.RESTORE ANOP\nDON&IDX  DS    0H\n         LM    R14,R1,&TMPSA      RESTORE WORK REGISTERS\n         MEND  , IPCSLOAD         RES 05/91\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPCSPRNT": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00@\\x00@\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "STYMA"}, "text": "         MACRO ,\n&LABL    IPCSPRNT &BUFF\n.*\n.*   THIS MACRO GENERATES AN IPCS CALL TO THE PRINT ROUTINE\n.*   TO PRINT THE 133 BYTE BUFFER POINTED TO BY PARM BUFF133.\n.*\n.*   REGISTER  &REG IS MODIFIED BY THIS MACRO.\n.*\n.*\n.*   PARMS:\n.*\n.*   BUFF - POINTER TO A FIXED LENGTH BUFFER OF LENGTH 133 TO\n.*          BE PRINTED.\n.*\n.*\n.*\n.*\n.* SAMPLE:\n.*       IPCSPRNT ZBUFF\n.*\n.*\n         GBLB  &IPCSFG\n         LCLC  &IDX\n&IDX     SETC  '&SYSNDX'\n         AIF   ('&IPCSFG' EQ '1').IPCSOK\n         MNOTE 8,'ENV=IPCS NOT SPECIFIED IN RENTR MACRO OR, RENTR NOT UX\n               SED'\n         MEXIT\n.IPCSOK  ANOP\n&LABL    L     R1,72(,R13)        GET IPCS PARM FROM WHERE RENTR PUT IT\n.*********************************************************************\n.*\n.*       POINT TO IPCS BUFFER\n.*\n.*********************************************************************\n         L     R14,ADPLBUF-ABDPL(,R1) POINT TO BUFFER\n.*********************************************************************\n.*\n.*       GET THE DUMP ADDRESS TO RETRIEVE INTO REGISTER R0\n.*\n.*********************************************************************\n         AIF   ('&BUFF'(1,1) EQ '(').REGBUFF\n         MVC   0(133,R14),&BUFF       COPY OUTPUT BUFFER TO IPCS AREA\n         AGO   .GOTBUFF\n.REGBUFF ANOP\n         MVC   0(133,R14),0(&BUFF(1)) COPY OUTPUT BUFFER TO IPCS AREA\n.GOTBUFF ANOP\n.*********************************************************************\n.*\n.*       CALL THE SERVICE ROUTINE AND TEST THE RC\n.*\n.*********************************************************************\n         L     R15,ADPLPRNT-ABDPL(,R1) POINT TO SERVICE ROUTINE\n         BALR  R14,R15                 CALL PRINT ROUTINE\n.*       LTR   R15,R15                DID THE CALL WORK?\n.*       BZ    DON&IDX                IF SO, GREAT\n.*********************************************************************\n.*\n.*       ISSUE A WTO TO SHOW THE PRINT FAILED.\n.*\n.*********************************************************************\n.*       WTO   'IPCS PRINT CALL FAILED',ROUTCDE=11\n.*DON&IDX  DS    0H\n         MEND  , IPCSPRNT         RES 05/91\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOCATE1": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00\\x91\\x00\\x91\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 145, "newlines": 145, "modlines": 0, "user": "STYMA"}, "text": "LOCATE   TITLE 'DETERMINE IF DATASET IS EXISTS FOR PL/I'\n**********************************************************************\n*\n* SEGMENT NAME:\n*\n*    LOCATE -- DETERMINE IF A DATASET EXISTS FOR PL/I\n*\n* INPUTS (*TO FUNCTIONS):\n*\n*    DSN -- DATASET NAME (*1,2)\n*       THE PARM TO THIS FUNCTION IS THE FULLY QUALIFIED DATASET NAME\n*       WHOSE EXISTENCE IS TO BE CHECKED.  QUOTES ARE NOT TO BE\n*       SUPPLIED IN THE STRING.\n*\n* OUTPUTS (*FROM FUNCTIONS):\n*\n*    RC -- RETURN CODE (*1,2,3)\n*       THE RETURNED PARAMETER IS SHOWS THE STATUS OF THE DATASET\n*       VALUES: 0  -  DATASET IS CATALOGUED AND EXISTS ON A DISK PACK\n*               4  -  DATASET IS CATALOGUED AND EXISTS ON A WORK PACK\n*               8  -  DATASET IS NOT CATALOGUED\n*               11 -  DATASET IS MIGRATED BY HSM\n*               12 -  DATASET IS CATALOGUED BUT DOES NOT EXIST ON\n*                     DISK (OBTAIN)\n*\n* NOTES:\n*\n*    1. SAMPLE CALL AND DECLARE:\n*\n*       DECLARE LOCATE  ENTRY(CHAR(44)) RETURNS(FIXED BINARY(15))\n*       EXT;\n*       DECLARE DSN     CHAR(44)  INIT('LT22505.TSO.CNTL');\n*\n*       RC = LOCATE(DSN);\n*\n*    2. ISSUE HISTORY:\n*\n*       REASON FOR ISSUE 06:\n*       ADD CODE TO WORK PACK CHECK.  WORK PACKS NOW START WITH SWK,\n*       SMS, AND WRK.\n*\n**********************************************************************\n         EJECT\nLOCATE   RENTR BASE=R11,PARM=R10,WORK=(WORKLEN,WORKAREA)\n         SPACE\n         LM    R9,R10,0(R10)   LOAD THE PARM LIST\n         L     R9,0(R9)        POINT TO DSNAME STRING\n         SPACE\n**********************************************************************\n*\n* CHECK TO SEE IF THE DATASET IS CATALOGED ON THE VOLUME SPECIFIED\n* WHICH THE LOCATE MACRO.  IF IT IS, PUT UP THE CONFIRMATION PANEL.\n* IF NOT, GO GETHER THE INFORMATION NECESSARY TO GENERATE THE ZAP\n*\n**********************************************************************\n         SPACE\n         MVC   OLDNAME(44),0(R9)    MOVE NAME TO LOCATE PARM AREA\n         LA    R8,8                 LOAD NOT CATALOGUED RETURN CODE\n         SPACE\n         MVC   CATLIST(CATLEN),CONCAT  INITIALIZE CAMLST FOR LOCATE\n         LA    R15,OLDNAME             POINT TO NAME PARM\n         ST    R15,CATLIST+4\n         LA    R15,VOLLIST             POINT TO TARGET AREA\n         ST    R15,CATLIST+12\n         SPACE\n         LOCATE CATLIST       IS THE DATASET CATALOGUED?\n         SPACE\n         LTR   R15,R15        CHECK FOR FOUND CATALOG ENTRY\n         BNZ   RETURN         IF ERROR, DSN IS NOT CATALOGED\n         SPACE\n         CLC   VOLLIST+6(6),=CL6'MIGRAT'  IS THIS THE HSM MIGRATED VOL\n         BNE   DOOBTAIN       IF NOT, KEEP PROCESSING.\n         SPACE\n         LA    R8,11          LOAD RC, FOR HSM MIGRATED\n         B     RETURN\n         SPACE 2\n**********************************************************************\n*\n* DO THE OBTAIN TO THE VOLUME SPECIFIED BY THE PANEL.  IF IT IS NOT\n* FOUND, SET UP A MESSAGE AND GO BACK TO THE DISPLAY.\n*\n* THE MESSAGE IS SET UP FROM THE TABLE OF MESSAGE IDS FOR THE OBTAIN.\n* THE RC CAN BE 4, 8, 12, OR 16.  THE OFFSETS INTO THE TABLE ARE 0,\n* 8, 16, AND 24 RESPECTIVELY.  THUS WE SUBTRACT 4 AND MULTIPLY BY 2.\n*\n**********************************************************************\n         SPACE\nDOOBTAIN DS    0H\n         MVC    OLDVOL,VOLLIST+6  MOVE VOLUME TO OBTAIN CAMLIST\n         LA     R8,12             LOAD RC FOR BAD OBTAIN\n         SPACE\n         MVC   OBLIST(OBLEN),CONOB     INITIALIZE CAMLST FOR LOCATE\n         LA    R15,OLDNAME             POINT TO NAME PARM\n         ST    R15,OBLIST+4\n         LA    R15,OLDVOL              POINT TO VOLUME SERIAL PARM\n         ST    R15,OBLIST+8\n         LA    R15,DSCB1               POINT TO TARGET AREA\n         ST    R15,OBLIST+12\n         SPACE\n         OBTAIN OBLIST\n         SPACE\n         LTR   R15,R15              DID THE OBTAIN WORK?\n         BNZ   RETURN               IF NOT, FLAG THE ERROR\n         SPACE\n         LA    R8,4                 SHOW DSN IS ON A WORK PACK\n         SPACE\n         CLC   OLDVOL(3),=CL3'WRK'  IS THIS A WORK GTE CSC PACK?\n         BE    RETURN               IF SO, SHOW WORK PACK VALUE\n         SPACE\n         CLC   OLDVOL(3),=CL3'SWK'  IS THIS A WORK GTE CSC PACK?\n         BE    RETURN               IF SO, SHOW WORK PACK VALUE\n         SPACE\n         CLC   OLDVOL(3),=CL3'SMS'  IS THIS A WORK GTE CSC PACK?\n         BE    RETURN               IF SO, SHOW WORK PACK VALUE\n         SPACE\n         SLR   R8,R8                SHOW ZERO RETURN CODE\n         EJECT\nRETURN   DS    0H\n         STH   R8,0(R10)      SAVE IN PL/I PARM\n         SPACE\n         REXIT\n         SPACE 2\nCONCAT   CAMLST NAME,DUMMYARG,,DUMMYARG\nCATLEN   EQU   *-CONCAT\n         SPACE 2\nCONOB    CAMLST SEARCH,DUMMYARG,DUMMYARG,DUMMYARG\nOBLEN    EQU   *-CONOB\n         SPACE\nDUMMYARG DC    A(0)\n         EJECT\nWORKAREA DSECT\n         DS    26F            DYNAMIC SAVE AREA\nOLDNAME  DS    CL46\nOLDVOL   DS    CL6\nCATLIST  DS    XL(CATLEN)\nOBLIST   DS    XL(OBLEN)\n         SPACE\nDSCB1    DS    0D\n         DS    CL140\n         SPACE\nVOLLIST  DS    0D\n         DS    265X           TWO SIX FIVE\nWORKLEN  EQU   *-WORKAREA\n         SYMBAR MODE=DEC\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PUT31": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00/\\x00/\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "STYMA"}, "text": "         MACRO\n&NAME    PUT31  &AREA24,&DCB,&AREA,&RPL=\n.*  DATE OF CREATION    01/08/90\n.*  DATE OF LAST CHANGE 01/08/90\n.*\n.*   THIS MACRO ALLOWS THE EXECUTION OF AN OS PUT MACRO FROM A\n.*   PROGRAM RUNING RMODE ANY.  THE TEXT OF THE PUT MACRO IS\n.*   COPIED TO THE 24 BIT ADDRESSABLE STORAGE REFERECED BY ADDED\n.*   PARM AREA24.\n.*\n.*   AREA24 MUST POINT TO A 24 BIT ADDRESSABLE AREA OF MINIMUM\n.*   LENGTH 20 FOR USE WITH DCB'S AND 34 FOR USE WITH RPL'S.\n.*   THE RPL= PARM IS ADDED FOR COMPLETENESS.  RPL'S AND ACB'S CAN\n.*   BE USED FROM 31 BIT ADDRESSING MODE.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO (JUST LIKE PUT)\n.*\n.*   WARNING:\n.*   THE CALLER MUST INSURE THAT THE DCB AND TARGET AREA ARE 24 BIT\n.*   ADDRESSABLE.  (LOCATE MODE DOES NOT USE AN AREA ADDRESS.)\n.*\n.*   THIS MACRO IS REENTRANT ASSUMING AREA24 IS REENTRANT.\n.*\n.* SAMPLE:\n.*        PUT31  WORK24,MYDCB\n.*\n.*\n&IDX     SETC  '&SYSNDX'\n&NAME    MVC   &AREA24.(LEN&IDX),COD&IDX    MOVE 24 BIT CODE\n         LA    15,&AREA24                  POINT TO THE AREA\n         BASSM 14,15                       CALL SWITCHING AMODE\n         B     DON&IDX\n         SPACE\n*        THE FOLLOWING CODE IS COPIED TO 24 BIT ADDRESSABLE STORAGE\n*        AND EXECUTED AS A LINKAGE ASSIST ROUTINE\n*--------------------------------------------------------------------\nCOD&IDX  DS    0H\n         ST    14,DAT&IDX-COD&IDX.(,15)\n         PUT   &DCB,&AREA,RPL=&RPL\n         L     14,DAT&IDX-*(,14)           LOAD REAL RETURN POINT\n         BSM   0,14                        RETURN TO INLINE CODE\nDAT&IDX  DC    F'0'                        TEMP SAVE AREA\nLEN&IDX  EQU   *-COD&IDX\n*--------------------------------------------------------------------\nDON&IDX  DS    0H\n         SPACE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RENTR": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x01 \\x01 \\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 288, "newlines": 288, "modlines": 0, "user": "STYMA"}, "text": "         MACRO ,\n&LABL    RENTR &ID,&BASE=11,&PARM=,&WORK=120,&ENV=PLI,&MAIN=NO\n.*\n.*   THIS MACRO GENERATES A REENTRANT STANDARD LINKAGE\n.*   IN PL/I FORMAT.  THE GENERATED CODE MAKES USE OF THE PL/I\n.*   RUN TIME STACK AND ALLOCATION ROUTINES.\n.*\n.*   REGISTERS 0,1,14 AND 15 ARE MODIFIED BY THIS MACRO.\n.*\n.*   FOR REENTRANT LINKAGE IN A NON-PL/I ENVIRONMENT SEE\n.*   FG500224.TSRENTR (SAME PARMS, GETS WORK AREA WITH A GETMAIN)\n.*\n.* FORMAT:\n.*LABEL RENTR BASE=(B1,...),PARM=(PREG,PNAME),WORK=(LEN,WNAME)\n.*\n.*   PARMS:\n.*\n.*   ID   - IF NULL, CSECT STATEMENT GENERATED.  CSECT NAME IS ENTRY\n.*          NAME (LABEL) FOLLOWED BY A CHARACTER 1.  AN ENTRY STATEMENT\n.*          IS GENERATED FOR THE LABEL.\n.*          IF *, ONLY THE ENTRY STATEMENT IS GENERATED\n.*\n.*   BASE - DESCRIBES REGISTERS(S) TO USE FOR PROGRAM BASE\n.*          B1,... - BASE REGISTER(S) FOR ENTRY\n.*\n.*   PARM - CONTROLS ADDRESS OF PARM LIST (REGISTER 1)  REGISTER 1 IS\n.*          DESTROYED BY THIS MACRO.\n.*          PREG - REG. TO BE LOADED W/CONTENTS OF R1, IF DESIRED\n.*          PNAME - NAME FOR USING ON PREG, IF DESIRED\n.*\n.*   WORK - DESCRIPTION OF GENERATED DSA AND SAVE AREA.\n.*          LEN - LENGTH OF WORK AREA (DSA PLUS LOCAL VARS), IF DESIRED\n.*          WNAME - DSECT NAME DESCRIBING THE WORK AREA (DSA\n.*                                                        + LOCAL VARS)\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - (THE DEFAULT). EXPAND THE MACRO FOR PL/I ENVIRONMENT\n.*                 USING THE PL/I RUN TIME STACK FOR THE DSA\n.*                 AND WORK AREA.\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*          IPCS - EXPAND MACRO USING GETMAIN.  ALSO HANDLE THE\n.*                 SPECIAL REQUIREMENTS OF THE IPCS PARM LIST.  THE\n.*                 PARM LIST SPECIFIES THE SUBPOOL TO USE FOR GETMAINS.\n.*                 ALSO, THE IPCS PARM LIST IS PASSED IN WORD 19 OF\n.*                 THE SAVE AREA.  IF MAIN=YES, IT IS SET FROM THE\n.*                 PASSED REGISTER 1.  OTHERWISE IT IS COPIED FROM\n.*                 WORD 19 OF THE PREVIOUS SAVE AREA.  GLOBAL ASSEMBLY\n.*                 VARIABLE IPCSFG IS SET TO 1 WHEN IPCS IS TURNED\n.*                 ON AND SET TO 0 OTHERWISE.  THE MACROS FOR IPCS\n.*                 FUNCTIONS USED IN THIS SUPERSET MAKE USE OF THIS\n.*                 FLAG AND WORD 19 OF THE SAVE AREA.\n.*                 NOTE:\n.*                 SPECIFYING ENV=IPCS REQUIRES YOU TO INCLUDE DSECT\n.*                 SYSTEM MACRO:\n.*                    BLSABDPL               AND SPECIFY\n.*                    PARM=(<NUM>,ABDPL)     WHERE <NUM> IS 2 TO 12.\n.*          THIS PARM CAN BE OVERRIDDEN VIA THE SYSPARM VALUE PASSED\n.*          TO THE ASSEMBLER.  FOR EXAMPLE:\n.*          //ASM  EXEC PGM=IEV90,PARM='SYSPARM(OS)'\n.*          WILL OVERRIDE THE ENV PARM TO OS\n.*\n.*\n.*   MAIN - THIS ROUTINE IS THE MAIN PROCEDURE\n.*          VALUES:\n.*          NO   - (THE DEFAULT).  ESTABLISH PL/I ENTRY FORMAT WITH\n.*                 THE REAL ENTRY 8 BYTES OFFSET FORM THE CSECT START.\n.*          YES  - MAKE THE ENTRY AT THE CSECT START.  USE THE\n.*                 ENTRY NAME AS THE CSECT NAME\n.*\n.*\n.* SAMPLE:\n.*REVERSE RENTR BASE=11,PARM=(10,PLIPARMS),WORK=(WORKLEN,WORKAREA)\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         GBLB  &IPCSFG\n         GBLB  &DEFADPL\n         LCLA  &L,&M,&N\n         LCLC  &B,&C,&D,&LCLENV,&IDX,&S,&LCLPRM\n&IDX     SETC  '&SYSNDX'\n&IPCSFG  SETB  0\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       VALIDATE THE LABEL PARM TO MAKE SURE IT IS 7 OR LESS CHARS\n.*       SAVE THE LABLE PARM IN LOCAL VARIABLE C\n.*\n&@LWRWKL SETC  '&WORK(1)'\n&C       SETC  '&LABL'\n         AIF   ('&MAIN' EQ 'YES').DOMAIN\n&L       SETA  K'&C\n         AIF   (&L LE 7).LABLOK\n&D       SETC  '&C'(1,4).'&C'(&L-2,3)\n         MNOTE 8,'NAME &C TOO LONG COMPRESSED TO &D'\n&C       SETC  '&D'\n.LABLOK  ANOP\n.*\n.*       GENERATE THE CSECT STATEMENT (IF REQUIRED),\n.*       GENERATE THE ENTRY STATEMENT FOR THE LABEL NAME,\n.*       AND BUILD THE CHARACTER ENTRY NAME IN PL/I FORMAT\n.*\n.*\n&N       SETA  7-&L\n         AIF   ('&ID' EQ '*').STARID\n&C.1     CSECT ,\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&DEFADPL' EQ '1')).NOIPCS0\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS0 ANOP\n.STARID  ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n         DS    0D                  FORCE DOUBLEWORD ALIGNMENT\n&B       SETC  '&C'\n&L       SETA  K'&C\n         AIF   (&N LE 0).NOPAD\n         DC    CL&N' '             PADDING TO 8 BYTES\n.NOPAD   ANOP\n         DC    C'&B',AL1(&L)       IDENTIFIER IN PL/I FORMAT\n&C       DS    0H\n         AGO   .DOSAVE\n.DOMAIN  ANOP\n         AIF   ('&ID' EQ '*').STARID2\n&LABL    CSECT\n         AIF   (('&LCLENV' NE 'IPCS') OR                               X\n               ('&DEFADPL' EQ '1')).NOIPCS1\nADPLDSA  EQU   72\n&DEFADPL SETB  1\n.NOIPCS1 ANOP\n         AGO   .DOSAVE\n.STARID2 ANOP\n         ENTRY &C                  INDICATE ENTRY POINT\n&C       DS    0H\n.*\n.*       GENERATE THE REGISTER SAVE AND THE PL/I ADDRESS CONSTANTS.\n.*       THE ONLY ONE WE USE THE THE DSA LENGTH.\n.*\n.DOSAVE  ANOP\n         STM   14,12,12(13)        SAVE REGISTERS\n         B     20(,15)             BRANCH AROUND CONSTANTS\n         DC    A(0)                STATEMENT NUMBER TABLE ADDR (NONE)\n         DC    A(&@LWRWKL)         LENGTH OF DSA AND AUTOMATIC VARS\n         DC    A(0)                ADDR OF STATIC VAR CSECT (NONE)\n.*\n.*       GENERATE THE STATEMENTS FOR THE ONE OR MORE BASE REGISTERS\n.*\n&B       SETC  '&BASE(1)'\n         AIF   ('&B' NE '0' AND '&B' NE '15' AND '&B' NE '12').BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'OS' ).BASEOK\n         AIF   ('&B' EQ '12' AND '&ENV' EQ 'IPCS' ).BASEOK\n         MNOTE 12,'BAD BASE REGISTER &B'\n         MEXIT\n.BASEOK  ANOP\n         LR    &B,15               ENTRY ADDRESS\n         AIF   (N'&BASE LE 1).ONEBASE\n         LA    15,2048(0,0)        HALF PAGE CONSTANT\n&N       SETA  2\n.BASES   LA    &BASE(&N),2048(15,&BASE(&N-1))    SET NEXT BASE\n&B       SETC  '&B,&BASE(&N)'\n&N       SETA  &N+1\n         AIF   (&N LE N'&BASE).BASES\n.ONEBASE USING &C,&B\n.*\n.*       IF A PARM IS TO BE SAVED, SAVE THE VALUE IN THE REGISTER\n.*       AND OVERLAY THE DSECT, IF ONE WAS PROVIDED\n.*       FOR IPCS, IF THIS IS THE MAIN AND NO PARM OVERLAY WAS\n.*       SUPPLIED, MAKE THE PARM ABDPL, USER MUST SUPPLY BLSABDPL\n.*\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(1)' NE '')).IPCSOK1\n         AIF   ('&MAIN' NE 'YES').IPCSOK1\n         MNOTE 8,'PARM= REQUIRED WHEN ENV=IPCS'\n.IPCSOK1 ANOP\n         AIF   ('&PARM(1)' EQ '').NOPARM\n         LR    &PARM(1),1          PARM ADDRESS\n&LCLPRM  SETC  '&PARM(2)'\n         AIF   (('&LCLENV' NE 'IPCS') OR ('&PARM(2)' NE '')).IPCSOK2\n         AIF   ('&MAIN' NE 'YES').IPCSOK2\n&LCLPRM  SETC  'ABDPL'\n*        PARM OVERLAY FROM MACRO BLSABDPL (SYS1.MACLIB)\n.IPCSOK2 ANOP\n         AIF   ('&LCLPRM' EQ '').NOPARM\n         USING &LCLPRM,&PARM(1)\n.NOPARM  ANOP  ,\n.*\n.*  IF ENV=BOTH THEN SET UP THE WEAK EXTERNAL REFERENCE TO PLISTART\n.*  TO DETERMINE IF THE PL/I ENVIRONMENT IS ACTIVE.  THIS TEST IS\n.*  NOT ALWAYS ACCURATE.  BUT FOR THE WAY GTE CSC USES ASSEMBLER MIXED\n.*  WITH PL/I, IT IS JUST FINE.\n.*\n.*\n         AIF   (('&@LWRWKL' EQ '') OR ('&@LWRWKL' EQ '0')).NOWORK1\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH1\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN PLISTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(PLISTART)\n         L     15,*-4         LOAD PLISTART ADDR\n         LTR   15,15          IS PLISTART LINKED IN?\n         BNZ   PL1&IDX\n.SKBOTH1 AIF   ('&LCLENV' EQ 'PLI').SKIPOS\n*        TYPE R GETMAIN ALWAYS GETS STG BELOW 16M (USE RU FOR ABOVE)\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         AIF   ('&LCLENV' NE 'IPCS').NOSUBPL\n         AIF   ('&MAIN' EQ 'YES').MAINPR0\n         L     1,ADPLDSA(,13)  GET IPCS PARM FROM HSA\n.MAINPR0 ANOP\n         ICM   0,B'1000',6(1) LOAD SUBPOOL IPCS WANTS US TO USE\n&IPCSFG  SETB  1\n.NOSUBPL ANOP\n         GETMAIN R,LV=(0)     DO GETMAIN IN OS ENV\n         AIF   ('&LCLENV' NE 'IPCS').NOWD19\n         AIF   ('&MAIN' EQ 'YES').MAINPRM\n         MVC   ADPLDSA(4,1),ADPLDSA(13) CARRY IPCS PARM FROM HSA TO LSA\n         AGO   .NOWD19\n.MAINPRM ANOP\n         ST    &PARM(1),ADPLDSA(,1) SAVE IPCS PARM IN WD 19 OF LSA\n.NOWD19  ANOP\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         LR    13,1           POINT REG 13 AT NEW DSA\n         AIF   ('&LCLENV' NE 'BOTH').SKIPOS\n         B     COM&SYSNDX     SKIP AROUND PL/I CODE\nPL1&IDX  DS    0H\n.SKIPOS  AIF   (('&LCLENV' EQ 'OS') OR                                 X\n               ('&LCLENV' EQ 'IPCS')).SKIPPLI\n         L     0,12(,&BASE(1)) LENGTH FOR DSA AND WORK VARS\n         L     1,76(,13)      ADDR OF START OF CURRENTLY AVAIL STORAGE\n         ALR   0,1            POINT PAST STORAGE NEEDED\n         CL    0,12(,12)      IS THERE ENOUGH? (EOS POINTER IN TCA)\n         BNH   *+10           IF ENOUGH, USE IT\n         SPACE\n         L     15,116(,12)    LOAD ADDR. OF OVERFLOW ROUTINE\n         BALR  14,15          AND BRANCH TO IT\n         SPACE\n         ST    0,76(,1)       STORE ADDR OF REMAINING PLI LIFO STORAGE\n*                             IN NEW DSA OFFSET 76\n         ST    13,4(,1)       SET BACK DSA CHAIN\n         ST    1,8(,13)       SET FORWARD CHAIN\n         MVC   72(4,1),72(13) COPY ADDR OF WORKSPACE USED BY PLI LIB\n         LR    13,1           POINT REG 13 AT NEW DSA\n         MVI   0(13),X'80'    PRESERVE PL/I ERROR HANDLING\n         MVI   1(13),X'00'    IN THE\n         MVI   86(13),X'91'   ASSEMBLER\n         MVI   87(13),X'C0'   ROUTINE\n         SPACE\n* REMEMBER R5 MUST BE ZERO WHEN CALLING A PL/I EXTERNAL PROCEDURE\n.SKIPPLI ANOP\n         AIF   ('&LCLENV' NE 'BOTH').SKBOTH2\nCOM&IDX  DS    0H\n.SKBOTH2 ANOP\n         SPACE\n         AIF   ('&WORK(2)' EQ '').NOWORK\n         USING &WORK(2),13\n         AGO   .NOWORK\n.NOWORK1 ANOP\n         AIF   (('&WORK(1)' EQ '') OR ('&WORK(1)' EQ '0')).NOWORK\n         LA    15,&WORK(2)         SAVE AREA ADDR\n         ST    13,4(0,15)          CHAIN\n         ST    15,8(0,13)            SAVE\n         LR    13,15                   AREAS\n&@LWRWKL SETC  '*'   INDICATE CHAINED SAVE AREAS\n.NOWORK  ANOP  ,\n         MEND  , RENTR            RES 05/91\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REXIT": {"ttr": 1543, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00\\xa5\\x00\\xa5\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 165, "newlines": 165, "modlines": 0, "user": "STYMA"}, "text": "         MACRO ,\n&LABL    REXIT &T,&RC=0,&LSA=YES,&RETURN=,&ENV=PLI\n.*\n.*   THIS MACRO IS USED TO EXIT FROM A REENTRANT PROGRAM\n.*    ENTERED WITH THE RENTR MACRO\n.*\n.*   PARMS:\n.*   T    - IF SET TO THE VALUE T, BYTE ZERO OF THE HIGHER SAVE AREA\n.*          IS SET TO X'FF' TO MARK THE ROUTINE COMPLETE\n.*\n.*   RC   - REGISTER OR LITERAL VALUE TO BE PASSES BACK TO THE\n.*          CALLING ROUTINE VIA REG 15.  FOR REGISTER SPECIFY THE\n.*          REGISTER NUMBER EG. (15).  REGISTERS 2-12 AND 15\n.*          MAY BE USED.  FOR LITERAL VALUES CODE RC=XXX WHERE XXX\n.*          IS A NUMBER OR ABSOLUTE SYMBOL LESS THAN 4096.\n.*\n.*   LSA -  IF SET TO THE VALUE NO, THEN IT ASSUMED THAT THIS\n.*          ROUTINE HAS NO LOWER SAVE AREA AND THAT R13 POINTS\n.*          TO THE PLACE WE WILL RESTORE OUR REGISTERS FROM\n.*\n.*   RETURN - REGISTER VALUE IN THE FORM (R) (WHERE R IS 2-12 OR 0)\n.*          THIS VALUE IS RETURNED IN REGISTER 0 TO THE CALLING\n.*          ROUTINE.\n.*\n.*\n.*   ENV  - ENVIRONMENT TO EXPAND THE MACRO FOR\n.*          VALUES:\n.*          PLI  - EXPAND THE MACRO FOR PL/I ENVIRONMENT USING THE\n.*                 PL/I RUN TIME STACK FOR THE DSA AND WORK AREA\n.*          OS   - EXPAND THE MACRO FOR GENERAL OS USE.  DO A GETMAIN\n.*                 FOR THE DSA AND WORK AREA.\n.*          BOTH - (THE DEFAULT).  DETERMINE IF THIS IS A PL/I\n.*                 ENVIROMENT AT RUN TIME AND USE THE STACK IF IT IS.\n.*                 IF NOT, USE A GETMAIN\n.*\n.*\n.* SAMPLE:\n.*RET     REXIT RC=(15)\n.*\n.*\n         GBLC  &@LWRWKL\n         GBLA  &@RENTR1\n         LCLC  &LCLENV,&IDX\n.*\n.*       VALIDATE THE ENV PARM AND STORE IT IN LOCAL VAR LCLENV\n.*       IF THE SYSPARM HAS A VALID ENV VALUE, USE IT INSTEAD\n.*\n&IDX     SETC  '&SYSNDX'\n&LCLENV  SETC  '&ENV'\n         AIF   ('&ENV' EQ 'IPCS').ENVOK\n         AIF   ('&ENV' EQ 'BOTH').ENVOK\n         AIF   ('&ENV' EQ 'OS').ENVOK\n         AIF   ('&ENV' EQ 'PLI').ENVOK\n         MNOTE 8,'INVALID ENV VALUE &ENV, ENV=BOTH ASSUMED'\n         MNOTE 0,'VALID VALUES ARE BOTH, OS, PLI, IPCS'\n&LCLENV  SETC  'BOTH'\n.ENVOK   ANOP\n.*\n.*       IF THE SYSPARM WAS SET TO BOTH, PLI, OR OS, THEN OVERRIDE\n.*       THE ENV PARM TO THIS VALUE.\n.*\n         AIF   (('&SYSPARM' NE 'BOTH') AND                             X\n               ('&SYSPARM' NE 'PLI') AND                               X\n               ('&SYSPARM' NE 'IPCS') AND                              X\n               ('&SYSPARM' NE 'OS')).LSACHK\n&LCLENV  SETC  '&SYSPARM'\n.LSACHK  ANOP\n.*\n.*       IF LSA=NO WAS SPECIFIED, THEN THERE IS NO LOWER SAVE\n.*       AREA OR ANY AUTOMATIC VARIABLES.  DO NOT ATTEMPT TO BACK\n.*       UP ONE SAVE AREA.\n.*\n         AIF   ('&LSA' EQ 'NO').NOLEN\n.*\n.*       FOR NORMAL SAVE AREA PROCESSING, BACK UP ONE SAVE AREA.\n.*       IF THE SAVE AREA WAS GOTTEN WITH A GETMAIN (OS FORMAT),\n.*       THEN WE NEED THE LENGTH OF IT.  THIS IS STORED AT OFFSET\n.*       12 PAST THE ENTRY POINT BY THE RENTR MACRO.  WE DO NOT\n.*       NEED THE SAVE AREA LENGTH FOR PL/I PROCESSING CODE\n.*\n         AIF   ('&LABL' EQ '').NOLABL\n&LABL    DS    0H\n.NOLABL  ANOP\n         LA    1,0(0,13)           WORK AREA ADDRESS\n         L     13,4(0,13)          OLD SAVE AREA ADDRESS\n.*\n.*       IF A REGISTER WAS SPECIFIED FOR THE RETURN VALUE, PUT IT IN\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.\n.*\n         AIF   ('&RETURN' EQ '').NORET\n         AIF   ('&RETURN'(1,1) NE '(').NORET\n         ST    &RETURN(1),20(0,13)     SAVE RETURNED PARM\n.NORET   ANOP\n.*\n.*       IF THIS IS NOT PL/I, GET THE LENGTH OF THE WORK AREA FOR\n.*       DOING THE FREEMAIN\n.*\n         AIF   ('&LCLENV' EQ 'PLI').PLI1\n         L     14,16(0,13)         GET ORIG ENTRY POINT\n         L     0,12(14)            LOAD LENGTH OF WORK AREA (RENTR)\n.*\n.*       IF A REGISTER WAS SPECIFIED FOR THE RC VALUE, PUT IT IN\n.*       THE APPROPRIATE PLACE IN THE SAVE AREA SO THAT IT\n.*       WILL GET RESTORED WHEN THE LOAD MULTIPLE IS DONE.\n.*\n.PLI1    ANOP\n         AIF   ('&RC' EQ '').RCNREG\n         AIF   ('&RC'(1,1) NE '(').RCNREG\n         ST    &RC(1),16(0,13)     SAVE RETURN CODE\n.RCNREG  ANOP  ,\n.*\n.*       DO FREEMAIN PROCESSING IF WE NEED TO\n.*       FOR FORMAT OS WE ALWAYS DO THE FREEMAIN.  FOR FORMAT BOTH\n.*       WE DO THE FREEMAIN IF THE EXTERNAL REFERENCE TO PLISTART IS\n.*       UNRESOLVED.  THIS IS NOT A FOOLPROOF WAY OF DETECTING THE\n.*       PL/I ENVIRONMENT, BUT AT GTE CSC THIS WORKS BECAUSE BAL\n.*       ROUTINES IN A PL/I PROGRAM ARE ALWAYS PL/I CALLED SUBROUTINES.\n.*\n         AIF   ('&LCLENV' EQ 'PLI').CKRC\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH\n         AIF   (&@RENTR1 NE 0).NOWXTRN\n         WXTRN PLISTART\n&@RENTR1 SETA  1\n.NOWXTRN ANOP\n         CNOP  0,4\n         B     *+8            SKIP ADDRESS CONSTANT\n         DC    V(PLISTART)\n         L     15,*-4         LOAD PLISTART ADDR\n         LTR   15,15          IS PLISTART LINKED IN?\n         BNZ   PL1&IDX\n.NOBOTH  ANOP\n         FREEMAIN R,LV=(0),A=(1)\n.CKRC    ANOP\n         AIF   ('&LCLENV' NE 'BOTH').NOBOTH1\nPL1&IDX  DS    0H\n.NOBOTH1 ANOP\n.*\n.*       RELOAD THE REGISTERS AND RETURN.  IF A LITERAL WAS\n.*       SPECIFIED FOR THE RETURN CODE, INSERT IT IN R15 AT THIS TIME.\n.*\n         LM    14,12,12(13)        RESTORE REGISTERS\n         AIF   ('&RC' EQ '').NORC\n         AIF   ('&RC'(1,1) EQ '(').NORC\n         AIF   ('&RC' EQ '0').ZERORC\n         LA    15,&RC              SET RETURN CODE\n         AGO   .NORC\n.ZERORC  SLR   15,15               ZERO RETURN CODE\n.NORC    AIF   ('&T' NE 'T').NOT\n         MVI   12(13),X'FF'        SET RETURN INDICATION\n.NOT     BR    14                  RETURN\n         MEXIT\n.*\n.*       THIS BLOCK OF CODE IS GENERATED WHEN THERE IS NO LOWER DSA.\n.*\n.NOLEN   AIF   ('&LABL' EQ '').NOLAB\n&LABL    DS    0H\n.NOLAB   ANOP  ,\n         AIF   ('&RC'(1,1) NE '(').CKRC\n         AIF   ('&RC' EQ '(15)').RC15\n         LR    15,&RC(1)           LOAD RETURN CODE\n.RC15    L     14,12(0,13)         RESTORE R14\n         LM    2,12,28(13)         RESTORE R2-R12\n         AGO   .NORC\n         MEND  , REXIT                                   RES 09/86\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SMODE": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x000\\x000\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "STYMA"}, "text": "         MACRO\n&LABL    SMODE  &MODE,&CLEAR=YES\n.*\n.*       THIS MACRO WILL SWITCH TO 24 OR 31 BIT ADDRESSING MODE IN\n.*       AN MVS XA ENVIRONMENT.  THE CURRENT ADDRESSING MODE IS\n.*       SAVED IN THE HIGH BIT OF REGISTER 14.\n.*\n.*       VALID VALUES FOR &MODE MODE ARE:\n.*       24  -  SWITCH TO 24 BIT ADDRESSING MODE\n.*       31  -  SWITCH TO 31 BIT ADDRESSING MODE\n.*       (R0)-(R14) SWITCH TO THE ADDRESSING MODE SPECIFIED IN THE\n.*              HIGH BIT OF THE SPECIFIED REGISTER.  OTHER BITS CLEARED\n.*              BY THIS MACRO.\n.*       CLEAR - IF YES (THE DEFAULT) AND A REGISTER VALUE IS SPECIFIED\n.*               FOR MODE, THE LOW ORDER 31 BITS IN THE WORD ARE\n.*               CLEARED PRIOR TO ORING IN THE HIGH BIT.  CLEAR SHOULD\n.*               REMAIN YES UNLESS THE USER IS SURE OTHER BITS IN THE\n.*               REGISTER SPECIFIED BY MODE ARE ZERO\n.*\n.*       THIS MACRO USES REGISTERS 14 AND 15\n.*\n         AIF   (('&MODE' EQ '24') OR                                   X\n               ('&MODE' EQ '31')  OR                                   X\n               ('&MODE'(1,1) EQ '(')).PARMOK\n         MNOTE 8,'INVALID MODE SPECIFIED, 24 AND 31 ARE VALID VALUES'\n         MEXIT\n.PARMOK  ANOP\n         AIF   ('&MODE'(1,1) EQ '(').REGPARM\n         CNOP  0,4                  MAKE SURE \"A\" CON IS ALIGNED\n         L     15,*+8               LOAD NEW AMODE\n         SLR   14,14                CLEAR OLD AMODE REGISTER\n         BSM   14,15                BRANCH AROUND CONST AND SET AMODE\n         AIF   ('&MODE' EQ '31').MODE31\n         DC    A(X'00000000'+(*+4))\n         MEXIT\n.MODE31  ANOP\n         DC    A(X'80000000'+(*+4))\n         MEXIT\n.REGPARM ANOP\n         AIF   ('&CLEAR' NE 'YES').NOCLEAR\n         SRL   &MODE(1),31          SHIFT OUT ALL BUT HIGH BYTE\n         SLL   &MODE(1),31          SHIFT IN ZEROS FOR THE OR INSTR\n.NOCLEAR ANOP\n         LA    15,*+10              ADDR JUST PAST BSM INSTR\n         OR    15,&MODE(1)          SET HIGH ORDER BIT FROM PARM\n         SLR   14,14                CLEAR OLD AMODE REGISTER\n         BSM   14,15                BRANCH AROUND CONST AND SET AMODE\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SWAREQ1": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00I\\x00I\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "STYMA"}, "text": "SWAREQ   TITLE 'SWAREQ_RL_INVOCATION_ROUTINE'\n**********************************************************************\n*\n* SEGMENT NAME:\n*\n*    SWAREQ -- SWAREQ_RL_INVOCATION_ROUTINE\n*\n* INPUTS (*TO FUNCTIONS):\n*\n*    SWATOK -- SWA (SCHEDULER WORK AREA) TOKEN (*1)\n*       THE PARM TO THIS ROUTINE IS THE ADDRESS OF THE 3 BYTE TOKEN\n*       REPRESENTING THE SWA CONTROL BLOCK.  IN PRE-ESA DAYS, THIS\n*       WAS THE THREE BYTE ADDRESS.  NOW, WITH THE SWA ABOVE THE 16\n*       MEGABYTE LINE. THIS IS A THREE BYTE TOKEN.  ON ENTRY R1\n*       POINTS TO THE 3 BYTE TOKEN.\n*\n* OUTPUTS (*FROM FUNCTIONS):\n*\n*    ADDR -- CONTROL BLOCK ADDRESS (*2)\n*       THE CONTROL BLOCK ADDRESS IS RETURNED IN REGISTER R0.\n*\n*    RC -- RETURN CODE (*2)\n*       THE RETURN CODE FROM SWAREQ IS RETURNED IN REGISTER R15.\n*       VALUES: 00  -  CONVERSION WORKED\n*               08  -  INVALID SVA IN THE SWA PREFIX\n*               24  -  (HEX) ATTEMPT TO READ A BLOCK NOT YET WRITTEN\n*               28  -  (HEX) INVALID POINTER TO THE EPA\n*\n* NOTES:\n*\n*    1. THIS ROUTINE SUPPORTS BEING CALLED IN A PL/I ENVIRONMENT, BUT\n*       IS DESIGNED TO BE CALLED FROM ASSEMBLER.\n*\n**********************************************************************\n         EJECT\nSWAREQ   RENTR  BASE=11,PARM=10,WORK=(WORKLEN,WORKAREA),ENV=BOTH\n         MVC   SWALIST(SWALEN),CONSWA   INITIALIZE SWA PARM LIST\n         XC    EPAAREA(EPALEN),EPAAREA  ZERO OUT THE EPA\n         LA    R3,EPAAREA               POINT TO THE EPA\n         ST    R3,EPAPTR                SAVE THE ADDRESS\n         USING SWAEPA,R3                ADDRESS THE EPA SYMBOLICLY\n         SPACE\n         MVC   SWVA(3),0(R10)           COPY THE SWA BLOCK TOKEN\n         SPACE\n         SWAREQ FCODE=RL,EPA=EPAPTR,UNAUTH=YES,MF=(E,SWALIST)\n         SPACE\n         L     R0,SWBLKPTR              GET THE 31 BIT ADDR OF THE JFCB\nRETURN   DS    0H\n         REXIT ENV=BOTH,RETURN=(0),RC=(15)\n         DROP  R3,R11\n         SPACE\nCONSWA   SWAREQ FCODE=RL,MF=L\nSWALEN   EQU   *-CONSWA\n         LTORG\nWORKAREA DSECT\n         DS    26F\n         DS    0F\nEPAPTR   DS    A\nSWALIST  DS    XL(SWALEN)\nEPAAREA  DS    XL(EPALEN)\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\nEPALEN   EQU   L'SWAEPAX\n         SPACE 3\n         PRINT NOGEN\n         CVT   DSECT=YES\n         SPACE\n         IEFZB505 LOCEPAX=YES\n         SPACE\n         IEFJESCT\n         SPACE\n         SYMBAR MODE=DEC\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYMBAR": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00 \\x00 \\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "STYMA"}, "text": "         MACRO\n         SYMBAR &MODE=DEC\nR0       EQU   0  PARAMETER PASSING REG./UTILITY\nR1       EQU   1  PARAMETER PASSING REG./UTILITY\nR2       EQU   2  UTILITY\nR3       EQU   3  UTILITY\nR4       EQU   4  UTILITY\nR5       EQU   5  UTILITY\nR6       EQU   6  UTILITY\nR7       EQU   7  UTILITY\nR8       EQU   8 UTILITY\nR9       EQU   9  UTILITY\n         AIF   (K'&MODE NE 3).MHEX\n         AIF   ('&MODE'(1,3) EQ 'HEX').HEX\n         AIF   ('&MODE'(1,3) EQ 'DEC').DEC\n.MHEX    MNOTE 4,'INVALID KEYWORD OPERAND, ASSUME ''HEX'''\n.HEX     ANOP\nRA       EQU   10 UTILITY\nRB       EQU   11 UTILITY\nRC       EQU   12 UTILITY\nRD       EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS\nRE       EQU   14 NORMALLY CONTAINS RETURN ADDRESS\nRF       EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS\n         AGO   .END\n.DEC     ANOP\nR10      EQU   10 UTILITY\nR11      EQU   11 UTILITY\nR12      EQU   12 UTILITY\nR13      EQU   13 NORMALLY CONTAINS SAVE AREA ADDRESS\nR14      EQU   14 NORMALLY CONTAINS RETURN ADDRESS\nR15      EQU   15 NORMALLY CONTAINS ENTRY POINT ADDRESS\n.END     MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TESTSYS": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x004\\x004\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 52, "newlines": 52, "modlines": 0, "user": "STYMA"}, "text": "         MACRO\n&LABL    TESTSYS  &XAADDR,&S370ADDR\n.*\n.*     THIS MACRO WILL TEST THE SYSTEM ENVIRONMENT TO DETERMINE\n.*     IF THE PROGRAM IS RUNNING UNDER MVS XA OR MVS 370.\n.*     THE TWO POSITIONAL PARAMETERS ARE THE BRANCH ADDRESS IF\n.*     THIS IS AN XA ENVIRONMENT AND THE BRANCH ADDRESS IF THIS\n.*     IS A SYSTEM 370 ENVIRONMENT.  EITHER OR BOTH OF THE PARMS\n.*     MAY BE OMMITTED.\n.*\n.*     THIS MACRO USES REGISTER 15\n.*\n.*     EXAMPLES:\n.*********************************************************************\n.*               TESTSYS LABELXA,LABEL370\n.*                 . THIS POINT WILL NEVER BE REACHED\n.*     LABELXA   DS    0H\n.*                 .\n.*               MVS XA SPECIFIC CODE\n.*                 .\n.*     LABEL370  DS    0H\n.*                 .\n.*               MVS 370 SPECIFIC CODE\n.*                 .\n.*********************************************************************\n.*               TESTSYS LABELXA\n.*                 .\n.*               MVS 370 SPECIFIC CODE\n.*                 .\n.*     LABELXA   DS    0H\n.*                 .\n.*               MVS XA SPECIFIC CODE\n.*                 .\n.*********************************************************************\n.*               TESTSYS ,LABEL370\n.*                 .\n.*               MVS XA SPECIFIC CODE\n.*                 .\n.*     LABEL370  DS    0H\n.*                 .\n.*               MVS 370 SPECIFIC CODE\n.*                 .\n.*********************************************************************\n         L    15,16               POINT TO CVT\n         TM    CVTDCB-CVT(15),CVTMVSE\n         AIF   ('&XAADDR' EQ '').NOXA\n         BO    &XAADDR\n.NOXA    ANOP\n         AIF   ('&S370ADDR' EQ '').NO370\n         BZ    &S370ADDR\n.NO370   ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSMDUMP": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x16c\\x16c\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 5731, "newlines": 5731, "modlines": 0, "user": "STYMA"}, "text": "**********************************************************************\n*\n* PROGRAM VSMDUMP (VIRTUAL STORAGE MANAGER DUMP) AND\n*          VSMDATA (VSM DUMP FOR CURRENT ADDRESS SPACE)\n*\n*  PROGRAM TO RUN ALL THE DQE'S FOR AN MVS/XA ADDRESS SPACE\n*  ALSO SELECTED DATA FROM THE GDA AND LDA ARE ROUTED TO FILE OUTPUT\n*  ALSO CVT LPA AND NUC DATA IS ROUTED TO FILE OUTPUT\n*  THE SPT IS LOOKED AT\n*  THE LPA DIRECTORY IS DUMPED\n*\n*  TWO OUTPUTS, DDNAMES PRINT AND OUTPUT\n*  DCB ATTRIBUTES ARE HARD CODED IN THIS PROGRAM\n*  FBA 133\n*\n*  TO CALL AS AN IPCS VERB EXIT,  GO INTO IPCS OPTION 4 AND TYPE:\n*  VERBX  VSMDUMP 'QC22505.OUTPUT.DATA'\n*             OR\n*  VERBX  VSMDUMP 'QC22505.OUTPUT.DATA PRINT NOLPA CDE'\n*\n*  REPLACE QC22505.OUTPUT.DATA WITH THE TARGET OUTPUT FILE.  THE\n*  FULLY QUALIFIED NAME IS REQUIRED, THE FILE MUST BE SEQUENTIAL,\n*  THE FILE WILL BE CREATED IF NECESSARY.   THE DCB IS HARD CODED\n*  IN THIS PROGRAM.\n*\n*  THE KEYWORDS PRINT, NOLPA, AND CDE ARE OPTIONS.\n*  PRINT  CAUSES THE VSM DATA TO BE PUT IN THE IPCS PRINT DATASET.\n*  CDE    CAUSES CDE RECORDS TO BE DISPLAYED IN THE IPCS PRINT DATASET.\n*  NOLPA  CAUSES TYPE 3 AND 4 RECORDS FOR LPA MODULES TO BE OMITTED\n*         IN THE OUTPUT FILE.\n*\n*\n*  THIS PROGRAM RUNS AMODE=31 RMODE=24\n*  THIS PROGRAM CAN BE COMPILED AS EITHER AN IPCS VERB EXIT OR\n*  A REGULAR PROGRAM.  AS A REGULAR PROGRAM, THE CURRENT ADDRESS\n*  SPACE IS PROCESSED.  AS AN IPCS VERB EXIT, THE DUMP ADDRESS SPACE\n*  IS PROCESSED.\n*\n*  A NORMAL ASSEMBLER H COMPILE WILL COMPILE THIS PROGRAM AS AN NORMAL\n*  PROGRAM.  SPECIFY  'SYSPARM(IPCS)' IN THE IEV90 PARM TO COMPILE AS\n*  AN IPCS EXIT.\n*  ASSEMBLER ROUTINES FG500215  ARE REQUIRED.\n*                     FG201887\n*                     FG201693\n*\n*  SIX RECORD TYPES ARE GENERATED BY THIS ROUTINE.  THEY ARE\n*  IDENTIFIED BY A CHARACTER NUMBER 1 THROUGH 6 IN COLUMN 112.  THE\n*  RECORD DESCRIPTIONS FOLLOW:\n*  KEY:\n*  HEX FIELDS:  PADDED ON LEFT WITH ZEROS.\n*  DEC FIELDS:  RIGHT JUSTIFIED IN FIELD, PADDED ON LEFT WITH BLANKS\n*  CHAR FIELDS: LEFT JUSTIFIED IN FIELD, PADDED ON RIGHT WITH BLANKS\n*\n**********************************************************************\n*\n*  TYPE 1:   MEMORY RECORD\n*  THIS RECORD IS GENERATED FOR A DQE, OR AQAT ENTRY.  IT DESCRIBES\n*  A CONTIGUOUS AREA OF MEMORY.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   START ADDRESS OF THE AREA\n*\n*  SIZE      13    8   HEX   LENGTH OF THE AREA\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*\n*  SUBPOOL   35    8   DEC   SUBPOOL NUMBER.\n*\n*  KEY       46    8   DEC   MEMORY KEY.  NOT AVAILABLE FOR SUBPOOLS\n*                            227, 228, 231, 241 IF PROCESSING A DUMP.\n*                            THESE SUBPOOLS COME FROM THE SPT.\n*\n*  PGMNAME   57    8   CHAR  PROGRAM NAME ASSOCIATED WITH THE TCB WHICH\n*                            DID THE GETMAIN.  FOR SYSTEM SUBPOOLS,\n*                            FIXED VALUES ARE USED:\n*                            226  - SQA\n*                            227  - SPT CSA\n*                            228  - SPT CSA\n*                            231  - SPT CSA\n*                            239  - SQA\n*                            241  - SPT CSA\n*                            245  - SQA\n*                            255  - LSQA\n*\n*  ENTRYPT   68    8   HEX   ENTRY POINT OF THE PROGRAM ASSOCIATED WITH\n*                            THE TCB WHICH DID THE GETMAIN.  FOR THE\n*                            SYSTEM SUBPOOLS, THIS IS BLANK.\n*\n*  TCBADDR   79    8   HEX   ADDRESS OF THE TCB WHICH DID THE GETMAIN.\n*                            FOR THE SYSTEM SUBPOOLS, THIS IS BLANK\n*\n*  SHARED    90    8   CHAR  IF THE DQE MARKS THIS SUBPOOL SHARED, THE\n*                            WORD SHARED APPEARS HERE.\n*                            FOR THE SYSTEM SUBPOOLS, THIS IS BLANK\n*\n*  OWNED    101    8   CHAR  IF THS DQE MARKS THIS SUBPOOL OWNED, THE\n*                            WORD OWNED APPEARS HERE.\n*                            FOR THE SYSTEM SUBPOOLS, THIS IS BLANK\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 1 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*\n*  TYPE 2:   REGION RECORD\n*  THIS RECORD IS GENERATED FOR VARIOUS SYSTEM BOUNDARY MARKERS. THE\n*  FIELDS FILLED IN VARY.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   START ADDRESS OF THE AREA\n*                            THE EXCEPTIONS ARE LPVT END, HPVT END,\n*                            REGION LIMIT, REGION END.  WHEN THIS IS\n*                            THE MARKER ADDRESS.\n*\n*  SIZE      13    8   HEX   LENGTH OF THE AREA. BLANK FOR MARKER ADDRS\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*                            BLANK FOR MARKER ADDRESSES.\n*\n*  SUBPOOL   35    8   DEC   BLANK\n*\n*  KEY       46    8   DEC   BLANK\n*\n*  PGMNAME   57    8   CHAR  VALUES:\n*                            MLPA     - MODIFIED LINK PACK AREA\n*                            FLPA     - FIXED LINK PACK AREA\n*                            PLPA     - PAGABLE LINK PACK AREA\n*                            PLPA EXT - PLPA ABOVE 16 MEG LINE\n*                            FLPA EXT - FLPA ABOVE 16 MEV LINE\n*                            MLPA EXT - MLPA ABOVE 16 MEG LINE\n*                            R/W NUC  - READ/WRITE NUCLEUS\n*                            R/O NUC  - READ ONLY NUCLEUS\n*                            R/W NUCE - READ/WRITE NUCLEUS ABOVE 16MEG\n*                            CSA LOW  - COMMON SERVICE AREA\n*                            CSA HIGH - COMMON SERVICE AREA ABOVE 16MEG\n*                            SQA LOW  - SYSTEM QUEUE AREA\n*                            SQA HIGH - SYSTEM QUEUE AREA ABOVE 16MEG\n*                            PVT LOW  - PRIVATE (USER) AREA\n*                            PVT HIGH - PRIVATE (USER) AREA\n*                            MGT AREA - VSM MANAGEMENT AREA\n*                            PG TBLS  - PAGE TABLES\n*                            PVT STRT - START OF USEABLE PRIVATE AREA\n*                            SYSREG L - SYSTEM REGION IN PRIVATE AREA\n*                            SYSREG H - SYSTEM REGION IN PRIVATE AREA\n*                            LPVT END - END OF USED PART OF PVT AREA\n*                            HPVT END - END OF USED PVT AREA > 16 MEG\n*                            REG END  - END OF REGION FROM < 16 MEG\n*                                       PARM ON EXEC. USED FIELDS\n*                            REG LMT  - ACTUAL MAX ADDR+1 AVAILABLE TO\n*                                       THE PRIVATE AREA BELOW 16 MEG.\n*                            VSM MGMT - VIRTUAL STORAGE MANAGER\n*                                       MANAGEMENT AREA.\n*                            LPA DIR  - LINK PACK AREA DIRECTORY\n*\n*  ENTRYPT   68    8   HEX   BLANK\n*\n*  TCBADDR   79    8   HEX   BLANK\n*\n*  SHARED    90    8   CHAR  BLANK\n*\n*  OWNED    101    8   CHAR  SYSTEM TABLE THIS DATA TAKEN FROM.\n*                            CVT, GDA, LDA\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 2 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*  TYPE 3:   LPA RECORD\n*  THIS RECORD IS GENERATED FOR EACH MAJOR LPDE FOUND IN THE\n*  LINK PACK AREA DIRECTORY.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   LOAD POINT OF MODULE\n*\n*  SIZE      13    8   HEX   LENGTH OF THE STORAGE CONTAINING MODULE\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*\n*  SUBPOOL   35    8   DEC   SUBPOOL NUMBER.\n*\n*  KEY       46    8   DEC   CONTAINS AC(1) FOR APF AUTHORIZED PROGRAMS\n*\n*  PGMNAME   57    8   CHAR  LPA PROGRAM NAME\n*\n*  ENTRYPT   68    8   HEX   ENTRY POINT OF THE LPA MODULE\n*\n*  TCBADDR   79    8   HEX   BLANK\n*\n*  SHARED    90    8   CHAR  THE STRING 'LPA MOD '\n*\n*  OWNED    101    8   CHAR  BLANK\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 3 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*  TYPE 4:   ACTIVE CDE RECORD\n*  THIS RECORD IS GENERATED FOR THE FIRST CDE FOUND ASSOCIATED\n*  WITH A PRB FOR A TASK ON THE TCB CHAIN.  THERE MAY BE DUPLICATE\n*  RECORDS FOR A CDE IF THE CDE IS FIRST FOR MORE THAN ONE PRB.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   LOAD POINT OF MODULE\n*\n*  SIZE      13    8   HEX   LENGTH OF THE STORAGE CONTAINING MODULE\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*\n*  SUBPOOL   35    8   DEC   SUBPOOL NUMBER.\n*\n*  KEY       46    8   DEC   CONTAINS AC(1) FOR APF AUTHORIZED PROGRAMS\n*\n*  PGMNAME   57    8   CHAR  PROGRAM NAME\n*\n*  ENTRYPT   68    8   HEX   ENTRY POINT OF THE MODULE\n*\n*  TCBADDR   79    8   HEX   TCB ASSOCIATED WITH THIS PROGRAM\n*\n*  SHARED    90    8   CHAR  THE STRING 'LPA MOD ' IF THIS IS AN LPA\n*                            MODULE.\n*\n*  OWNED    101    8   CHAR  IF THIS IS A MINOR CDE, THIS IS THE NAME\n*                            OF THE MAJOR CDE.\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 4 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*  TYPE 5:   LOAD LIST RECORD\n*  THIS RECORD IS GENERATED FOR EACH CDE FOUND ON THE LLE (LOAD LIST\n*  ENTRY) FOR EACH TASK ON THE TCB CHAIN.  THESE ARE MODULES LOADED VIA\n*  THE LOAD (SVC 6) SYSTEM CALL.  THERE MAY BE DUMPLICATES IF A MODULE\n*  IS LOADED BY MORE THAN ONE TCB.\n*\n*           COL  LEN  TYPE\n*\n*  AREA       2    8   HEX   LOAD POINT OF MODULE\n*\n*  SIZE      13    8   HEX   LENGTH OF THE STORAGE CONTAINING MODULE\n*\n*  ENDADDR   24    8   HEX   ENDING ADDRESS (FIRST BYTE PAST AREA)\n*\n*  SUBPOOL   35    8   DEC   SUBPOOL NUMBER.\n*\n*  KEY       46    8   DEC   CONTAINS AC(1) FOR APF AUTHORIZED PROGRAMS\n*\n*  PGMNAME   57    8   CHAR  PROGRAM NAME\n*\n*  ENTRYPT   68    8   HEX   ENTRY POINT OF THE MODULE\n*\n*  TCBADDR   79    8   HEX   TCB ASSOCIATED WITH THIS PROGRAM\n*\n*  SHARED    90    8   CHAR  THE STRING 'LPA MOD ' IF THIS IS AN LPA\n*                            MODULE.\n*\n*  OWNED    101    8   CHAR  IF THIS IS A MINOR CDE, THIS IS THE NAME\n*                            OF THE MAJOR CDE.\n*\n*  RECTYPE  112    1   DEC   CONSTANT CHAR 4 FOR THIS RECORD TYPE\n*\n**********************************************************************\n*\n*  TYPE 6:   ACTIVE CDE RECORD B\n*  THIS RECORD IS JUST LIKE A TYPE 4 RECORD EXCEPT IT IS GENERATED\n*  FOR ENTRIES ON THE CDE CHAIN AFTER THE FIRST FOR A PRB.\n*\n**********************************************************************\n*\n*  ERROR RECORDS:\n*  WHEN THIS PROGRAM IS RUNNING AS AN IPCS VERB EXIT.  ERROR RECORDS\n*  ARE GENERATED TO BOTH THE PRINT AND OUTPUT DATASETS FOR STORAGE\n*  LOCATIONS WHICH WERE NOT IN THE DUMP.\n*\n*  THESE RECORDS HAVE BLANKS IN COLUMS 1 AND 2 AND A # IN COLUMN 3.\n*\n**********************************************************************\n*\n*  SORTING RECORDS:\n*  ALL RECORDS WRITTEN TO FILE OUTPUT HAVE A TRAILING RECORD CONSISTING\n*  OF DASHES AND PLUSSES.  THE RECORDS IN THIS FILE MAY BE SORTED\n*  AS 266 BYTE RECORDS AND THEN \"FIXDCB\"ED BACK TO 133 BYTE RECORDS.\n*\n*  THE FOLLOWING JCL WILL PERFORM THE SORT.\n*\n*  //QC225054 JOB (),'VSMDATA2',\n*  //    NOTIFY=QC22505,\n*  //    MSGLEVEL=(2,0),PRTY=0,CLASS=K,MSGCLASS=X\n*  /*JOBPARM LINES=150\n*  //KILL   EXEC  PGM=IEFBR14\n*  //FILE     DD  DSN=QC22505.OUTPUT2.DATA,\n*  //             DISP=(MOD,DELETE),UNIT=SYSDA,SPACE=(TRK,1)\n*  //SORT1  EXEC  PGM=SORT,REGION=5000K\n*  //*\n*  //SORTLIB   DD DSN=SYS1.SORTLIB,DISP=SHR\n*  //*\n*  //SORTIN    DD DSN=QC22505.OUTPUT.DATA,DISP=SHR,\n*  //             DCB=(LRECL=266,RECFM=FB,BLKSIZE=10640)\n*  //*\n*  //SORTOUT   DD DSN=QC22505.OUTPUT2.DATA,\n*  //             DISP=(NEW,CATLG),UNIT=SYSDA,\n*  //             SPACE=(CYL,(5,1),RLSE),\n*  //             DCB=(LRECL=266,RECFM=FB,BLKSIZE=10640)\n*  //*\n*  //SYSOUT    DD SYSOUT=*\n*  //SORTWK01  DD UNIT=SYSDA,SPACE=(CYL,(65))\n*  //SORTWK02  DD UNIT=SYSDA,SPACE=(CYL,(65))\n*  //SORTWK03  DD UNIT=SYSDA,SPACE=(CYL,(65))\n*  //SYSIN     DD *\n*   SORT FIELDS=(2,8,AC,A),EQUALS\n*   RECORD TYPE=F,LENGTH=(266,266,266)\n*  //FIXDCB  EXEC PGM=FIXDCB\n*  //STEPLIB  DD  DISP=SHR,DSN=EXD.EAX.LOADLIB\n*  //FILE     DD  DSN=QC22505.OUTPUT.DATA,DISP=SHR,\n*  //             DCB=(LRECL=133,RECFM=FB,BLKSIZE=10640)\n*  //FIXDCB2 EXEC PGM=FIXDCB\n*  //STEPLIB  DD  DISP=SHR,DSN=EXD.EAX.LOADLIB\n*  //FILE     DD  DSN=QC22505.OUTPUT2.DATA,DISP=SHR,\n*  //             DCB=(LRECL=133,RECFM=FB,BLKSIZE=10640)\n*\n**********************************************************************\n*\n         PRINT    NOGEN\nVSMDUMP  RMODE 24\nVSMDUMP  AMODE 31\nVSMDUMP  RENTR BASE=11,ENV=OS,MAIN=YES,WORK=(WORKLEN,WORKAREA),PARM=12\n         LA    R8,DATAAREA\n         USING  DATAAREA,R8\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').NOPR            ###############\n**********************************************************************\n*\n* OPEN THE PRINT FILE\n*\n**********************************************************************\n         SPACE\n         MVC   SYSPRINT(DCBLEN),CONDCB1\n         MVC   OPENLIST(OPENLEN),CONOPEN\n         OPEN  (SYSPRINT,(OUTPUT)),MF=(E,OPENLIST)\n         TM    (DCBOFLGS-IHADCB)+SYSPRINT,DCBOFOPN  DID IT OPEN?\n         BO    OPENOK1\n         SPACE\n         MVC   (DCBDDNAM-IHADCB)+SYSPRINT(8),=CL8'SYSPRINT'\n         OPEN  (SYSPRINT,(OUTPUT)),MF=(E,OPENLIST)\n         TM    (DCBOFLGS-IHADCB)+SYSPRINT,DCBOFOPN  DID IT OPEN?\n         BNO   NOOPEN1\n         SPACE\nOPENOK1  DS    0H\n.NOPR    ANOP\n**********************************************************************\n*\n* PROCESS THE IPCS PARM TO GET THE DATASET NAME WE ARE TO OPEN. WE\n* PASS THE SAME PARM WE WERE PASSED, WHICH IS THE IPCS PARM.\n*\n**********************************************************************\n         SPACE\n         CALL  IPCSPRM,((R12),OPTIONS,SYSPRINT),MF=(E,CALLLIST)\n         LTR   R15,R15\n         BNZ   RETURN\n         SPACE\n**********************************************************************\n*\n* OPEN THE OUTPUT FILE.  THIS IS WHERE THE FORMATTED DUMP DATA GOES.\n*\n**********************************************************************\n         SPACE\n         MVC   OUTPUT(DCBLEN),CONDCB2\n         MVC   OPENLIST(OPENLEN),CONOPEN\n         OPEN  (OUTPUT,(OUTPUT)),MF=(E,OPENLIST)\n         TM    (DCBOFLGS-IHADCB)+OUTPUT,DCBOFOPN    DID IT OPEN?\n         BNO   NOOPEN2\n         SPACE\n         SPACE\n         LA    R9,SYSPRINT\n         LA    R10,OUTPUT\n*        PRINT NOGEN\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS01          ###############\n**********************************************************************\n*\n* GET THE TCB ADDRESS AND THE ASID FOR THE HEADER LINE. ALSO STORE\n* THE ENTRY POINT ADDRESS FOR THIS ROUTINE.\n*\n*      REGISTER USAGE:\n*              R3  -> TCB\n*              R4  -  ASID\n*              R8  -> ADDRESSABILITY TO DATA AREA\n*              R9  -> SYSPRINT DCB\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R12 -  OS PARM\n*              R13 -  DSA AND WORK VARIABLES\n*\n**********************************************************************\n         SPACE\n         USING PSA,0\n         L     R3,PSATOLD      POINT TO THE TCB\n         USING TCB,R3\n         DROP  R0\n         ST    R11,WORD        PREPARE TO PRINT ENTRY ADDRESS\n         SPACE\n         L     R14,TCBJSCB     POINT TO JSCB\n         USING IEZJSCB,R14\n         LH    R4,JSCBASID     GET ASID FROM JSCB\n         DROP  R14\n         AGO   .NPCS01\n.IPCS01  ANOP\n**********************************************************************\n*\n* GET THE TCB ADDRESS AND THE ASID FOR THE HEADER LINE. ALSO STORE\n* THE ENTRY POINT ADDRESS FOR THE ABENDING PROGRAM.\n*\n*      REGISTER USAGE:\n*              R2  -  TCB ADDRESS IN DUMP\n*              R3  -> TCB OF ABENDING PROGRAM (IN THIS ADDR SP)\n*              R4  -  ASID\n*              R8  -> ADDRESSABILITY TO DATA AREA\n*              R9  -> SYSPRINT DCB\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R12 -  OS PARM\n*              R13 -  DSA AND WORK VARIABLES\n*\n**********************************************************************\n         SPACE\n         NI    ADPLPRDP,X'FE'  MAKE SURE ADPLSAMK IS OFF\n         SLR   R0,R0           ABSOLUTE ADDRESS ZERO (THE PSA)\n         IPCSLOAD R2,(R0),LEN=1024\n         IPCSLMSG R2,,NOPSA,40,ZHDR4,(R10),(R9)\n         LTR      R2,R2        DID WE FIND THE PSA\n         BZ       DONE         IF NOT, BAIL OUT.\n         SPACE\n         USING PSA,R2\n         L     R2,PSATOLD      POINT TO THE TCB\n         DROP  R2\n         IPCSLOAD R3,(R2),LEN=TCBLEN,PERM=ABENDTCB\n         IPCSLMSG R3,(R2),NOTCB,40,ZHDR4,(R10),(R9)\n         LTR   R3,R3           SAVE IN A REG\n         BZ    RETURN          POINT TO ABENDING TASKS TCB THIS ADR SPC\n         SPACE\n         USING TCB,R3\n         SPACE\n         CALL  FINDCDE,((R2)), GET THE CDE IN R0, PASS THE TCB         X\n               MF=(E,CALLLIST)\n         LTR   R15,R0          COPY CDE ADDRESS\n         BZ    PR1             IF NO CDE, SKIP IT\n         SPACE\n         USING CDENTRY,R15\n         MVC   WORD(4),CDENTPT\n         LH    R4,ADPLASID\n         DROP  R15\nPR1      DS    0H\n.NPCS01  ANOP\n         SPACE\n**********************************************************************\n*\n* PRINT THE HEADER INFORMATION AND THE HEADERS FOR WALKING THE TCB'S\n* BACKWARDS.\n*\n**********************************************************************\n         SPACE\n         VSMPRNT AREA24,(R9),BLANK\n         MVI   LINE,C' '\n         MVC   LINE+1(132),LINE\n         MVC   LINE(40),=CL40' OPTIONS USED:   PRINT   LPA   CDE   FQE'\n         CLI   OPTIONS+PRTPRM,X'FF'     PRINT ON\n         BE    *+10\n         MVC   LINE+15(2),=CL2'NO'\n         CLI   OPTIONS+LPAPRM,X'FF'     GET LPA ON\n         BE    *+10\n         MVC   LINE+23(2),=CL2'NO'\n         CLI   OPTIONS+CDEPRM,X'FF'     CDE PRINT ON\n         BE    *+10\n         MVC   LINE+29(2),=CL2'NO'\n         CLI   OPTIONS+FQEPRM,X'FF'     FQE ON  (NOT AVAILABLE)\n         BE    *+10\n         MVC   LINE+35(2),=CL2'NO'\n         VSMPRNT AREA24,(R9),LINE\n         VSMPRNT AREA24,(R9),BLANK\n         MVI   LINE,C' '\n         MVC   LINE+1(132),LINE\n         MVC   LINE(20),=CL20' ENTRY ADDRESS:  '\n         UNPK  LINE+17(9),WORD(5)\n         TR    LINE+17(8),HEXCHAR\n         MVI   LINE+25,C' '\n         MVC   LINE+26(6),=CL6' ASID:'\n         CVD   R4,WORD\n         MVC   LINE+32(8),=X'4020202020202021'\n         ED    LINE+32(8),WORD+4\n         OI    LINE+39,X'F0'\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS01A\n         VSMPRNT AREA24,(R9),BLANK\n         VSMPRNT AREA24,(R9),MSG1\n         VSMPRNT AREA24,(R9),MSG2\n         VSMPRNT AREA24,(R9),BLANK\n.NPCS01A ANOP\n         CLI   OPTIONS+PRTPRM,X'FF'  IS THE PRINT OPTION ON?\n         BNE   PTCB1                 IF NOT, SKIP THE HEADERS\n         SPACE\n         VSMPRNT AREA24,(R9),LINE\n         VSMPRNT AREA24,(R9),BLANK\n         VSMPRNT AREA24,(R9),HDR1\n         VSMPRNT AREA24,(R9),HDR4\n         EJECT\n**********************************************************************\n*\n* FIRST PASS, PRINT THE TCB'S WALKING BACKWARD THEN. BACK UP TO THE\n* FRONT OF THE LIST AND WALK THE LIST FORWARD PRINTING EACH TCB\n*\n**********************************************************************\nPTCB1    DS    0H\n         CALL  PRTTCB,((R9),OPTIONS,(R3),(R2)),MF=(E,CALLLIST)\n         L     R0,TCBBACK   POINT TO PREV TCB\n         LTR   R0,R0        LAST TCB?\n         BZ    FORWARD      IF YES, GO START WALKING OTHER WAY\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS02          ###############\n         LR    R3,R0        MAKE THIS THE CURRENT TCB\n         AGO   .NPCS02\n.IPCS02  ANOP\n         LR    R2,R0        MAKE THIS THE CURRENT TCB (DUMP)\n         IPCSLOAD R3,(R2),LEN=TCBLEN,PERM=TCBHOLD\n         IPCSLMSG R3,R2,NOTCB,40,ZHDR4,(R10),(R9)\n         LTR   R3,R3        DID WE GET A TCB\n         BZ    FORWARD      IF NOT, LEAVE THE LOOP\n.NPCS02  ANOP\n         B     PTCB1        AND CONTINUE THE LOOP\n         EJECT\n**********************************************************************\n*\n* PRINT THE HEADERS FOR THE SECOND PASS THROUGH THE TCB'S WALK THE\n* TCB CHAIN FORWARD LISTING THE INFORMATION TO THE PRINT DATASET.\n* THIS LOOP (PTCB2) JUST SENDS MORE TCBS TO THE PRINT FILE.\n*\n*      REGISTER USAGE:\n*              R2  -  TCB ADDRESS IN DUMP (IPCS ONLY) - ON ENTRY TOP\n*                     TCB\n*              R3  -> TCB - ON ENTRY TOP TCB\n*              R8  -> ADDRESSABILITY TO DATA AREA\n*              R9  -> SYSPRINT DCB\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R12 -  OS PARM\n*              R13 -  DSA AND WORK VARIABLES\n*\n**********************************************************************\n         SPACE\nFORWARD  DS    0H\n         ST    R3,SAVETCB   SAVE FIRST TCB ADDR\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS03          ###############\n**********************************************************************\n*\n* COPY THE TOP TCB TO A PERMANENT AREA. WE WILL NEED IT FOR THE\n* SECOND PASS, SO WE NEED TO KEEP IT AROUND.\n*\n**********************************************************************\n         ST    R2,SAVETCBD  SAVE FIRST TCB ADDR (DUMP IF IPCS)\n         MVC   FIRSTTCB(256),0(R3)   SAVE FIRST TCB\n         MVC   FIRSTTCB+256(TCBLEN-256),256(R3)   SAVE FIRST TCB\n         LA    R3,FIRSTTCB\n         ST    R3,SAVETCB\n.NPCS03  ANOP\n         CLI   OPTIONS+PRTPRM,X'FF'  IS THE PRINT OPTION ON?\n         BNE   SPQERUN                IF NOT, SKIP THE NEXT LOOP\n         SPACE\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS03D         ###############\n         OI    ADPLFLAG,ADPLEJEC    CAUSE PAGE EJECT\n.NPCS03D ANOP\n         VSMPRNT AREA24,(R9),BLANK\n         VSMPRNT AREA24,(R9),HDR2\n         VSMPRNT AREA24,(R9),HDR4\n         SPACE\nPTCB2    DS    0H\n         CALL  PRTTCB,((R9),OPTIONS,(R3),(R2)),MF=(E,CALLLIST)\n         L     R0,TCBTCB    POINT TO NEXT TCB\n         LTR   R0,R0        LAST TCB?\n         BZ    SPQERUN      WALK FORWARD\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS04          ###############\n         LR    R3,R0        MAKE THIS THE CURRENT TCB\n         AGO   .NPCS04\n.IPCS04  ANOP\n         LR    R2,R0        MAKE THIS THE CURRENT TCB (DUMP)\n         IPCSLOAD R3,(R2),LEN=TCBLEN,PERM=TCBHOLD\n         IPCSLMSG R3,R2,NOTCB,40,ZHDR4,(R10),(R9)\n         LTR   R3,R3        DID WE GET A TCB?\n         BZ    SPQERUN      IF NOT, LEAVE THE LOOP\n.NPCS04  ANOP\n         B     PTCB2        AND CONTINUE THE LOOP\n         EJECT\n**********************************************************************\n*\n* ERROR MESSAGES FOR FILES WHICH DID NOT OPEN\n*\n**********************************************************************\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS04A         ###############\nNOOPEN1  DS    0H\n         WTO   'COULD NOT OPEN DDNAME PRINT OR SYSPRINT',ROUTCDE=11\n         LA    R15,16\n         B     RETURN\n         SPACE\n.IPCS04A ANOP\nNOOPEN2  DS    0H\n         WTO   'COULD NOT OPEN FILE OUTPUT',ROUTCDE=11\n         LA    R15,16\n         B     RETURN\n         EJECT\n**********************************************************************\n*\n* THIRD PASS THROUGH THE TCB'S.  FORWARD, JUST LIKE THE SECOND PASS.\n* FIRST PRINT THE HEADERS.\n*\n* THEN DUMP THE GDA, LDA, AND LPA STUFF TO THE OUTPUT FILE. THIS\n* STUFF DOES NOT GO TO THE PRINT FILE.\n*\n**********************************************************************\n         SPACE\nSPQERUN  DS    0H\n         CLI   OPTIONS+PRTPRM,X'FF'  IS THE PRINT OPTION ON?\n         BNE   NOHDR2                     IF NOT, SKIP THE HEADERS\n         VSMPRNT AREA24,(R9),BLANK\n         VSMPRNT AREA24,(R9),HDR5\n         VSMPRNT AREA24,(R9),BLANK\n         VSMPRNT AREA24,(R9),HDR2\n         VSMPRNT AREA24,(R9),HDR4\nNOHDR2   DS    0H\n         PRINT GEN\n         PUT31 AREA24,(R10),ZHDR1\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         DS    0H\n         CALL  DUMPGDA,((R10),(R9),OPTIONS),MF=(E,CALLLIST)\n         DS    0H\n         CALL  DUMPLDA,((R10),(R9),OPTIONS),MF=(E,CALLLIST)\n         SPACE\n         CLI   OPTIONS+LPAPRM,X'FF'       IS LPA OPTION ON?\n         BNE   LPADONE                    IF SO, SKIP THE LPA\n         DS    0H\n         CALL  DUMPLPA,((R10),(R9),OPTIONS),MF=(E,CALLLIST)\n         SPACE\nLPADONE  DS    0H\n         L     R3,SAVETCB          POINT TO THE FIRST TCB\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS05          ###############\n         L     R2,SAVETCBD         POINT TO FIRST TCB IN DUMP\n         OI    ADPLFLAG,ADPLEJEC    CAUSE PAGE EJECT\n.NPCS05  ANOP\n         EJECT\n**********************************************************************\n*\n* THIRD TCB WALKING LOOP. DUMP THE SPQES FOR THE TCB.  THIS GOES TO\n* BOTH OUTPUT AND THE PRINT FILE.  SPQES DUMPS THE TCB, SPQES, SPQAS,\n* AND DQES.\n*\n*      REGISTER USAGE:\n*              R2  -  TCB ADDRESS IN DUMP (IPCS ONLY)\n*              R3  -> TCB\n*              R8  -> ADDRESSABILITY TO DATA AREA\n*              R9  -> SYSPRINT DCB\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R12 -  OS PARM\n*              R13 -  DSA AND WORK VARIABLES\n*\n**********************************************************************\n         SPACE\nPTCB3    DS    0H\n         CALL  DUMPLLE,((R10),(R9),(R3),(R2),OPTIONS),MF=(E,CALLLIST)\n         CALL  DUMPCDE,((R10),(R9),(R3),(R2),OPTIONS),MF=(E,CALLLIST)\n         CALL  SPQES,((R10),(R9),(R3),(R2),OPTIONS),MF=(E,CALLLIST)\n         L     R0,TCBTCB    POINT TO NEXT TCB\n         LTR   R0,R0        LAST TCB?\n         BZ    DONE         WALK FORWARD\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS06          ###############\n         LR    R3,R0        MAKE THIS THE CURRENT TCB\n         AGO   .NPCS06\n.IPCS06  ANOP\n         LR    R2,R0        MAKE THIS THE CURRENT TCB (DUMP)\n         IPCSLOAD R3,(R2),LEN=TCBLEN,PERM=TCBHOLD\n         IPCSLMSG R3,R2,NOTCB,40,ZHDR4,(R10),(R9)\n         LTR   R3,R3        DID WE GET THE TCB?\n         BZ    DONE\n.NPCS06  ANOP\n         B     PTCB3        AND CONTINUE THE LOOP\n         EJECT\n**********************************************************************\n*\n* FINALLY, DUMP THE SPT, WHICH CONTAINS DATA FOR SOME SYSTEM\n* SUBPOOLS.\n*\n* THEN PUT OUT THE TRAILERS AND CLOSE THE FILES.\n*\n**********************************************************************\n         SPACE\nDONE     DS    0H\n         CALL  RUNSPT,((R10),(R9),OPTIONS),MF=(E,CALLLIST)\n         SPACE\n         VSMPRNT AREA24,(R9),BLANK\n         VSMPRNT AREA24,(R9),HDR6\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS07          ###############\n         MVC   OPENLIST(CLOSELEN),CONCLOSE\n         CLOSE ((R9)),MF=(E,OPENLIST)\n.IPCS07  ANOP\n         MVC   OPENLIST(CLOSELEN),CONCLOSE\n         CLOSE ((R10)),MF=(E,OPENLIST)\n         SPACE\n         DROP  R3\n         SLR   R15,R15\nRETURN   DS    0H\n*        CNOP  0,4\n*        DC    A(0)\n         REXIT ENV=OS,RETURN=(15)\n         SPACE\n         LTORG\n         SPACE\nDATAAREA DS    0D\nHDR1     DC    CL133' WALKING BACKWARDS THROUGH THE TCBS'\nHDR2     DC    CL133' WALKING FOREWARDS THROUGH THE TCBS'\nHDR3     DC    CL133' TCB      \u00a6 TCBTCB   \u00a6 TCBBACK  \u00a6 PGM NAME \u00a6 ENTRY*\n                PT \u00a6 TCBNTC   \u00a6 TCBOTC   \u00a6 TCBLTC   \u00a6 TCBJSTCB \u00a6'\nHDR4     DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+'\nHDR5     DC    CL133' TCB LIST COMPLETE'\nHDR6     DC    CL133' LAST LIST COMPLETE'\nBLANK    DC    CL133' '\n         SPACE\nSHDR4    DC    CL133'          +----------+----------+----------+------*\n               ----+----------+----------+----------+'\n         SPACE\nZHDR1    DC    CL133'  AREA    \u00a6 SIZE     \u00a6 END ADDR \u00a6 SUBPOOL  \u00a6 KEY  *\n                   \u00a6 PGM NAME \u00a6 ENTRY PT \u00a6 TCB ADDR \u00a6 SHARED?  \u00a6 OWNED?*\n                  \u00a6'\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\n         SPACE\nNOTCB    DC    CL133' # UNABLE TO ACCESS TCB AT DUMP ADDRESS XXXXXXXX  X\n               (VSMDUMP) '\nNOPSA    DC    CL133' # UNABLE TO ACCESS PSA AT DUMP ADDRESS 00000000  X\n               (VSMDUMP) '\n         SPACE\nMSG1     DC    CL133' NOTE:  TO GET ALL DUMP DATA, YOU MUST SCROLL TO '\nMSG2     DC    CL133' THE BOTTOM OF THE PRINT LISTING.                '\n         SPACE\nCONDCB1  DCB   MACRF=(PM),DSORG=PS,BLKSIZE=10773,DDNAME=PRINT,         X\n               LRECL=133,RECFM=FBA\n         SPACE\nCONDCB2  DCB   MACRF=(PM),DSORG=PS,BLKSIZE=10640,DDNAME=OUTPUT,        X\n               LRECL=133,RECFM=FBA   THIS BLKSIZE HAS EVEN # OF LRECLS\nDCBLEN   EQU   *-CONDCB2\n         SPACE\nCONOPEN  OPEN  (0,(OUTPUT)),MF=L\nOPENLEN  EQU   *-CONOPEN\n         SPACE\nCONCLOSE OPEN  (0,(OUTPUT)),MF=L\nCLOSELEN EQU   *-CONCLOSE\n         SPACE\n         EJECT\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\n         LTORG\nWORKAREA DSECT\n         DS    26F              SAVE AREA\nRETSV4   DS    A\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nSAVETCB  DS    A\nSAVETCBD DS    A\nOPTIONS  DS    2A\n         DS    0D\nTCBHOLD  DS    XL(TCBLEN)\n         DS    0D\nFIRSTTCB DS    XL(TCBLEN)\n         DS    0D\nABENDTCB DS    XL(TCBLEN)\n         DS    0D\nLINE     DS    CL133\n         DS    0D\nOUTPUT   DS    XL(DCBLEN)\n         DS    0D\nSYSPRINT DS    XL(DCBLEN)\n         DS    0D\nOPENLIST DS    XL(OPENLEN)\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*        PRINT NOGEN\n         SYMBAR MODE=DEC\n         IKJTCB\n         IHAPSA\n         IHACDE\n         IHADQE\n         IEZJSCB\n         CVT   DSECT=YES,LIST=YES\n         DCBD\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         END\n*\n*     DUMPGDA\n*\n*     DUMP DATA AREAS FROM THE GDA\n*     PARMS:\n*         1  ->  OUTPUT DCB\n*         2  ->  PRINT DCB\n*\n*\n         PRINT NOGEN\nDUMPGDA  RENTR BASE=(11,12),ENV=OS,PARM=(10,PARMLST),                  X\n               WORK=(WORKLEN,WORKAREA)\n         MVC   OPTPTR(4),OPTR\n         L     R9,PRINTDCB           POINT TO THE PRINT DCB\n         L     R10,OUTDCB            POINT TO THE OUTPUT DCB\n         DROP  R10\n         MVC   BUFFZ,BUFFINIT       INIT OUTPUT BUFFER\n         SPACE\n**********************************************************************\n*\n* FIRST ACCESS THE CVT AND THE CVT VSM EXTENSION.\n*\n**********************************************************************\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS01          ###############\n         USING PSA,0\n         L     R3,FLCCVT            POINT TO THE CVT\n         DROP  R0\n         USING CVT,R3               ADDRESS THE CVT\n         SPACE\n         L     R4,CVTSMEXT          POINT TO STORAGE MAP EXTENSION\n         USING CVTVSTGX,R4          AND GET ADDRESSABILTY\n         SPACE\n         AGO   .NPCS01\n.IPCS01  ANOP\n         L     R3,ADPLDSA(,R13)     GET THE ADPL ADDRESS PASSED\n         USING ABDPL,R3\n         L     R3,ADPLCVT           POINT TO THE CVT FOR THE DUMP\n         DROP  R3\n         USING CVT,R3               ADDRESS THE CVT\n         SPACE\n         L     R2,CVTSMEXT          POINT TO STORAGE MAP EXTENSION\n         LA    R14,(CVTEMLPE-CVTVSTGX)+4 GET LEN OF VSM EXTENSION\n         IPCSLOAD R4,(R2),LEN=(R14)\n         IPCSLMSG R4,R2,NOCVT1,48,ZHDR4,(R10),(R9)\n         LTR   R4,R4                DID WE GET IT?\n         BZ    GETGDA\n         SPACE\n         USING CVTVSTGX,R4          AND GET ADDRESSABILTY\n         SPACE\n.NPCS01  ANOP\n         MVC   ZENTRYPT(8),=CL8'  '\n         MVC   ZOWNED(8),=CL8'CVT '\n         SPACE\n**********************************************************************\n*\n* DUMP THE LPA STUFF FROM THE CVT EXTENSION.\n*\n**********************************************************************\n         SPACE\n         MVI   ZRECTYPE,RECTREG\n         L     R15,CVTMLPAS         GET MLPA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTMLPAE         GET MLPA END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET MLPA LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'MLPA'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,CVTFLPAS         GET FLPA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTFLPAE         GET FLPA END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET FLPA LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'FLPA'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,CVTPLPAS         GET PLPA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTPLPAE         GET PLPA END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET PLPA LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'PLPA'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,CVTEPLPS         GET EXTENDED PLPA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTEPLPE         GET EXTENDED PLPA END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET EXTENDED PLPA LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'PLPA EXT'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,CVTEFLPS         GET EXTENDED FLPA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTEFLPE         GET EXTENDED FLPA END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET EXTENDED FLPA LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'FLPA EXT'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,CVTEMLPS         GET EXTENDED MLPA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTEMLPE         GET EXTENDED MLPA END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET EXTENDED MLPA LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'MLPA EXT'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,CVTRWNS          GET R/W NUCLEUS START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTRWNE          GET R/W NUCLEUS END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET R/W NUCLEUS LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'R/W NUC '\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,CVTRONS          GET R/O NUCLEUS START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTRONE          GET R/O NUCLEUS END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET R/O NUCLEUS LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'R/O NUC '\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,CVTERWNS         GET EXTENDED R/W NUCLEUS START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         L     R14,CVTERWNE         GET EXTENDED R/W NUCLEUS END\n         ST    R14,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SR    R14,R15              GET EXTENDED R/W NUCLEUS LENGTH\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'R/W NUCE'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n**********************************************************************\n*\n* NOW GET THE GDA FROM THE CVT AND PROCESS IT\n*\n**********************************************************************\n         SPACE\nGETGDA   DS    0H\n         L     R4,CVTGDA            POINT TO THE GDA\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS02          ###############\n         IPCSLOAD R2,(R4),LEN=GDALEN,PERM=HOLDGDA\n         IPCSLMSG R2,R4,NOGDA,40,ZHDR4,(R10),(R9)\n         LTR   R2,R2                DID WE GET IT?\n         BZ    RETURN\n         SPACE\n         LR    R4,R2\n         SPACE\n.NPCS02  ANOP\n         DROP  R3,R4                GET RID OF THE CVT\n         USING GDA,R4               ADDRESS THE GDA\n         SPACE\n**********************************************************************\n*\n* FIRST DUMP THE DATA FOR SQA SUBPOOLS 245, 226, AND 239. THIS ARE\n* CONTROLLED BY AQAT'S (ADDRESS QUEUE ANCHOR TABLES).\n*\n**********************************************************************\n         SPACE\n         L     R2,OPTPTR            POINT TO THE OPTIONS\n         SPACE\n         L     R5,GDAAQAT5          POINT TO SQA AQAT\n         LA    R6,245               SHOW SUBPOOL 245\n         LA    R7,=CL8'SQA     '    LOAD NAME\n         SPACE\n         CALL  DMPAQAT,((R10),(R5),(R6),(R7),(R2)),MF=(E,CALLLIST)\n         SPACE\n         L     R5,GDAAQAT6          POINT TO SQA AQAT\n         LA    R6,226               SHOW SUBPOOL 226 (INCLUDES 253)\n         LA    R7,=CL8'SQA     '    LOAD NAME\n         SPACE\n         CALL  DMPAQAT,((R10),(R5),(R6),(R7),(R2)),MF=(E,CALLLIST)\n         SPACE\n         L     R5,GDAAQAT9          POINT TO SQA AQAT\n         LA    R6,239               SHOW SUBPOOL 239 (INCLUDES 253)\n         LA    R7,=CL8'SQA     '    LOAD NAME\n         SPACE\n         CALL  DMPAQAT,((R10),(R5),(R6),(R7),(R2)),MF=(E,CALLLIST)\n         SPACE\n**********************************************************************\n*\n* NOW DUMP THE HIGH AND LOW WATER MARKERS FROM THE GDA. THESE ARE ALL\n* RECTREG (2) RECORDS.\n*\n**********************************************************************\n         SPACE\n         MVC   ZENTRYPT(8),=CL8'  '\n         MVC   ZOWNED(8),=CL8'GDA '\n         SPACE\n         L     R15,GDACSA           GET LOWER CSA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),GDACSASZ(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,GDACSASZ         ADD IN LENGTH OF CSA\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'CSA LOW'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,GDAECSA           GET UPPER CSA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),GDAECSAS(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,GDAECSAS         ADD IN LENGTH OF CSA\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'CSA HIGH'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,GDASQA            GET LOWER SQA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),GDASQASZ(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,GDASQASZ         ADD IN LENGTH OF SQA\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'SQA LOW '\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,GDAESQA           GET UPPER SQA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),GDAESQAS(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,GDAESQAS         ADD IN LENGTH OF SQA\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'SQA HIGH'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,GDAPVT            GET LOWER PVT START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),GDAPVTSZ(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,GDAPVTSZ         ADD IN LENGTH OF PVT\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'PVT LOW '\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,GDAEPVT           GET UPPER PVT START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),GDAEPVTS(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,GDAEPVTS         ADD IN LENGTH OF PVT\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'PVT HIGH'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,GDASMAD           GET MANAGEMENT AREA\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),GDASMSZ(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,GDASMSZ         ADD IN LENGTH OF MANAGEMENT AREA\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'MGT AREA'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,GDAPGTAD          GET PAGE TABLE AREA ADDR\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),GDAPGTSZ(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,GDAPGTSZ         ADD IN LENGTH OF PAGE TABLE AREA\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'PG TBLS '\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         MVC   ZENTRYPT(8),=CL8'    '\n         MVC   ZTCBADDR(8),=CL8'    '\n         SPACE\nRETURN   REXIT ENV=OS\n         EJECT\n         LTORG\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         SPACE\n         SPACE\nNOCVT1   DC    CL133' # UNABLE TO ACCESS CVT VSM EXT AT DUMP ADDRESS XX*\n               XXXXXX (DUMPGDA) '\nNOGDA    DC    CL133' # UNABLE TO ACCESS GDA AT DUMP ADDRESS XXXXXXXX  *\n               (DUMPGDA) '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F              SAVE AREA\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nHOLDGDA  DS    XL(GDALEN)\nLINE     DS    CL133\nBUFFZ    DS    0CL133\n         DC    CL1' '\nZAREA    DC    CL9' '\n         DC    CL2'\u00a6 '\nZSIZE    DC    CL9' '\n         DC    CL2'\u00a6 '\nZENDADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSUBPOOL DC    CL9' '\n         DC    CL2'\u00a6 '\nZKEY     DC    CL9' '\n         DC    CL2'\u00a6 '\nZPGMNAME DC    CL9' '\n         DC    CL2'\u00a6 '\nZENTRYPT DC    CL9' '\n         DC    CL2'\u00a6 '\nZTCBADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSHARED  DC    CL9' '\n         DC    CL2'\u00a6 '\nZOWNED   DC    CL9' '\n         DC    CL2'\u00a6 '\nZRECTYPE DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nOPTR     DS    A\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IHAGDA\nGDALEN   EQU   *-GDA\n         IHAPSA\n         CVT   DSECT=YES,LIST=YES\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\nRECTDQE  EQU   C'1'\nRECTREG  EQU   C'2'\nRECTLPDE EQU   C'3'\nRECTCDEA EQU   C'4'\nRECTLLE  EQU   C'5'\nRECTCDEB EQU   C'6'\n         END\n*\n*     DUMPLDA\n*\n*     DUMP DATA AREAS FROM THE LDA  (SUBPOOL 255 TOO)\n*     PARMS:\n*         1  ->  OUTPUT DCB\n*         2  ->  PRINT DCB\n*\n*\n         PRINT NOGEN\nDUMPLDA  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         MVC   OPTPTR(4),OPTR\n         L     R9,PRINTDCB           POINT TO THE PRINT DCB\n         L     R10,OUTDCB            POINT TO THE OUTPUT DCB\n         DROP  R10\n         MVC   BUFFZ,BUFFINIT\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS01          ###############\n         USING PSA,0\n         SPACE\n         L     R3,PSAAOLD           POINT TO THE ASCB\n         DROP  R0\n         USING ASCB,R3              ADDRESS THE ASCB\n         SPACE\n         L     R4,ASCBLDA           POINT TO THE LDA\n         DROP  R3                   GET RID OF THE ASCB\n         AGO   .NPCS01\n.IPCS01  ANOP\n         LA    R14,(PSAAOLD-PSA)+8\n         SLR   R0,R0\n         IPCSLOAD R3,(R0),LEN=(R14)    GET PSA FOR THE DUMP\n         IPCSLMSG R2,,NOPSA,40,ZHDR4,(R10),(R9)\n         LTR   R3,R3                DID WE GET THE PSA\n         BZ    RETURN\n         USING PSA,R3\n         SPACE\n         L     R3,PSAAOLD           POINT TO THE ASCB IN THE DUMP\n         DROP  R3\n         IPCSLOAD R2,(R3),LEN=ASCBLEN\n         IPCSLMSG R2,R3,NOASCB,41,ZHDR4,(R10),(R9)\n         LTR   R2,R2\n         BZ    RETURN\n         USING ASCB,R2              ADDRESS THE ASCB\n         SPACE\n         L     R3,ASCBLDA           POINT TO THE DUMP LDA\n         DROP  R2                   GET RID OF THE ASCB\n         IPCSLOAD R4,(R3),LEN=LDALEN,PERM=HOLDLDA\n         IPCSLMSG R4,R3,NOLDA,40,ZHDR4,(R10),(R9)\n         LTR   R4,R4\n         BZ    RETURN\n.NPCS01  ANOP\n         USING LDA,R4               ADDRESS THE LDA\n         SPACE\n         L     R5,LDAAQAT           POINT TO LSQA AQAT\n         LA    R6,255               SHOW SUBPOOL 255 (INCLUDES 253)\n         LA    R7,=CL8'LSQA    '    LOAD NAME\n         SPACE\n         L     R12,OPTPTR\n         SPACE\n         CALL  DMPAQAT,((R10),(R5),(R6),(R7),(R12)),MF=(E,CALLLIST)\n         SPACE\n         MVI   ZRECTYPE,RECTREG\n         MVC   ZOWNED(8),=CL8'LDA '\n         L     R15,LDASTRTA         GET LOWER ADD SPACE REG START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),LDASIZA(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,LDASIZA          ADD IN LENGTH OF ADD SP REG\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'PVT STRT'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,LDAESTRA          GET UPPER ADD SPACE REG START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),LDAESIZA(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,LDAESIZA         ADD IN LENGTH UPPER ADD SP REG\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'PVT STRT'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,LDASTRTS         GET LOWER SYSREG START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),LDASIZS(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,LDASIZS          ADD IN LENGTH OF SYSREG\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'SYSREG L'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,LDAESTRS          GET UPPER SYSREG START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),LDAESIZS(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,LDAESIZS         ADD IN LENGTH UPPER SYSREG\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'SYSREG H'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,LDACRGTP         GET LOW PRIVATE END ADDR\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         MVC   ZSIZE(9),=CL9' '\n         MVC   ZENDADDR(9),=CL9' '\n         MVC   ZPGMNAME(8),=CL8'LPVT END'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,LDASTRTA         GET LOWER ADD SPACE REG START\n         A     R15,LDAREGRQ         ADD IN REQUESTED REGION LENGTH\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         MVC   ZSIZE(9),=CL9' '\n         MVC   ZENDADDR(9),=CL9' '\n         MVC   ZPGMNAME(8),=CL8'REG END'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,LDASTRTA         GET LOWER ADD SPACE REG START\n         A     R15,LDALIMIT         ADD IN ABSOLUTE REGION LIMIT\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         MVC   ZSIZE(9),=CL9' '\n         MVC   ZENDADDR(9),=CL9' '\n         MVC   ZPGMNAME(8),=CL8'REG LMT'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R15,LDAERGTP         GET HIGH PRIVATE END ADDR\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         MVC   ZSIZE(9),=CL9' '\n         MVC   ZENDADDR(9),=CL9' '\n         MVC   ZPGMNAME(8),=CL8'HPVT END'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         L     R15,LDASMAD          GET MGMT AREA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),LDASMSZ(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,LDASMSZ          ADD IN LENGTH OF MGMT AREA\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         MVC   ZPGMNAME(8),=CL8'VSM MGMT'\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\nRETURN   REXIT ENV=OS\n         EJECT\n         LTORG\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         SPACE\nNOPSA    DC    CL133' # UNABLE TO ACCESS PSA AT DUMP ADDRESS 00000000  *\n               (DUMPLDA) '\nNOASCB   DC    CL133' # UNABLE TO ACCESS ASCB AT DUMP ADDRESS XXXXXXXX *\n                (DUMPLDA) '\nNOLDA    DC    CL133' # UNABLE TO ACCESS LDA AT DUMP ADDRESS XXXXXXXX  *\n               (DUMPLDA) '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F              SAVE AREA\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nHOLDLDA  DS    XL(LDALEN)\nLINE     DS    CL133\nBUFFZ    DS    0CL133\n         DC    CL1' '\nZAREA    DC    CL9' '\n         DC    CL2'\u00a6 '\nZSIZE    DC    CL9' '\n         DC    CL2'\u00a6 '\nZENDADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSUBPOOL DC    CL9' '\n         DC    CL2'\u00a6 '\nZKEY     DC    CL9' '\n         DC    CL2'\u00a6 '\nZPGMNAME DC    CL9' '\n         DC    CL2'\u00a6 '\nZENTRYPT DC    CL9' '\n         DC    CL2'\u00a6 '\nZTCBADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSHARED  DC    CL9' '\n         DC    CL2'\u00a6 '\nZOWNED   DC    CL9' '\n         DC    CL2'\u00a6 '\nZRECTYPE DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nOPTR     DS    A\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IHALDA\nLDALEN   EQU   *-LDA\n         IHAPSA\n         IHAASCB\nASCBLEN  EQU   *-ASCB\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         CVT   DSECT=YES,LIST=NO\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\nRECTDQE  EQU   C'1'\nRECTREG  EQU   C'2'\nRECTLPDE EQU   C'3'\nRECTCDEA EQU   C'4'\nRECTLLE  EQU   C'5'\nRECTCDEB EQU   C'6'\n         END\n*\n*    DUMPLPA\n* DUMP THE LPA DIRECTORY\n*\n*    PARMS:\n*         1   ->  OUTPUT DCB\n*         2  ->  PRINT DCB\n*\n*\n         PRINT NOGEN\nDUMPLPA  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         MVC   OPTPTR(4),OPTR\n         L     R9,PRINTDCB           POINT TO THE PRINT DCB\n         L     R10,OUTDCB           POINT TO THE OUTPUT DCB\n         DROP  R10\n         MVC   BUFFZ,BUFFINIT\n         MVI   ZRECTYPE,RECTLPDE\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS81          ###############\n         USING PSA,0\n         SPACE\n         L     R3,FLCCVT            POINT TO THE CVT\n         DROP  R0\n         USING CVT,R3               ADDRESS THE CVT\n         SPACE\n         L     R4,CVTLPDIA          POINT TO THE LPA DIRECTORY\n         LA    R4,0(,R4)\n         LR    R3,R4                SAVE A COPY OF THE START\n         USING LPDE,R4\n         DROP  R3                   GET RID OF THE CVT\n         AGO   .NPCS81\n.IPCS81  ANOP\n         L     R3,ADPLDSA(,R13)     GET THE ADPL ADDRESS PASSED\n         USING ABDPL,R3\n         L     R3,ADPLCVT           POINT TO THE CVT FOR THE DUMP\n         DROP  R3\n         USING CVT,R3               ADDRESS THE CVT\n         SPACE\n         L     R5,CVTLPDIA          POINT TO THE LPA DIRECTORY\n         DROP  R3                   GET RID OF THE CVT\n         LA    R5,0(,R5)\n         LR    R3,R5                SAVE A COPY OF THE START\n         IPCSLOAD R4,(R5),LEN=SEGMAX\n         IPCSLMSG R4,R5,NOLPA1,50,ZHDR4,(R10),(R9)\n         LTR   R4,R4\n         BZ    RETURN\n         SPACE\n         MVC   SEGSIZE(4),=A(SEGMAX) START GETTING LARGE SEGMENTS\n         SPACE\n         USING LPDE,R4\n.NPCS81  ANOP\n         SPACE\n         MVC   ZSHARED(8),=CL8'LPA MOD'\n         SLR   R5,R5                ZERO LENGTH OF LPA DIRECTORY\n         SLR   R6,R6                ZERO LENGTH OF LPA DIRECTORY PAGE\n         SPACE\nLPDELOOP DS    0H\n         MVC   ZPGMNAME(8),LPDENAME\n         L     R15,LPDEXTAD        GET AREA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),LPDEXTLN(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,LPDEXTLN         ADD IN LENGTH OF ADD SP REG\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SPACE\n         SLR   R15,R15\n         IC    R15,LPDESP\n         CVD   R15,WORD\n         MVC   ZSUBPOOL(8),=X'4020202020202021'\n         ED    ZSUBPOOL(8),WORD+4\n         OI    ZSUBPOOL+7,X'F0'\n         L     R15,LPDENTP         GET ENTRY POINT\n         ST    R15,WORD\n         UNPK  ZENTRYPT(9),WORD(5)\n         TR    ZENTRYPT(8),HEXCHAR\n         MVI   ZENTRYPT+8,C' '\n         SPACE\n         TM    LPDEATTR,LPDEMIN\n         BO    NEXTLPDE                   SKIP MINOR LPDE'S NO STG\n         SPACE\n         MVC   ZTCBADDR(8),=CL8' '\n         TM    LPDEATTB,LPDELPDE\n         BO    YESLPDE\n         SPACE\n         MVC   ZTCBADDR(8),=CL8'NOT LPDE'\n         SPACE\nYESLPDE  DS    0H\n         TM    LPDEATT2,LPDEAUTH      IS THIS MODULE AC 1?\n         BZ    NOTAC1                 IF NOT, DON'T MARK AS SUCH\n         SPACE\n         MVC   ZKEY(8),=CL8'AC(1)'\n         SPACE\nNOTAC1   DS    0H\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\nNEXTLPDE DS    0H\n         LA    R4,LPDELEN(,R4)      GO TO NEXT ENTRY\n         LA    R5,LPDELEN(,R5)      ACCUMULATE LENGTH\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS83          ###############\n         LA    R6,LPDELEN(,R6)      ACCUMULATE LENGTH WITHIN SEGMENT\n         C     R6,SEGSIZE           ARE WE AT THE END?\n         BL    SAMESEG              NO, KEEP GOING\n         SPACE\n         LA    R2,0(R5,R3)          GET ADDR OF NEXT SEGMENT IN DUMP\n         SPACE\nGETSEG   DS    0H\n         L     R7,SEGSIZE\n         IPCSLOAD R4,(R2),LEN=(R7)\n         LTR   R4,R4\n         BNZ   GOTSEG\n         SPACE\n         C     R7,=A(SEGMAX)        ARE WE AT THE LARGE SEGMENTS?\n         BNE   QUIT                 IF NOT, STOP SEARCH\n         SPACE\n         LA    R7,LPDELEN           ONE LPDE AT A TIME\n         ST    R7,SEGSIZE\n         B     GETSEG\n         SPACE\nQUIT     DS    0H\n         IPCSLMSG R4,R2,NOLPA2,55,ZHDR4,(R10),(R9)\n         B     DONE\n         SPACE\nGOTSEG   DS    0H\n         SLR   R6,R6                ZERO LENGTH OF LPA DIRECTORY PAGE\n         SPACE\nSAMESEG  DS    0H\n.NPCS83  ANOP\n         CLC   LPDENAME(8),=X'FFFFFFFFFFFFFFFF'  END OF LIST?\n         BNE   LPDELOOP\n         SPACE\nDONE     DS    0H\n         MVI   ZRECTYPE,RECTREG\n         ST    R3,WORD              SAVE LPDE TABLE START\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         LA    R4,LPDELEN(,R4)      GO PAST DUMMY LAST ENTRY\n         LA    R5,LPDELEN(,R5)      ADD IN LENGTH OF THIS ENTRY\n         ST    R4,WORD              SAVE LPDE TABLE END\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         ST    R5,WORD              SAVE LPDE TABLE LEN\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         MVC   ZPGMNAME(8),=CL8'LPA DIR'\n         MVC   ZSHARED(8),=CL8' '\n         MVC   ZOWNED(8),=CL8'CVT '\n         MVC   ZSUBPOOL(8),=CL8' '\n         MVC   ZKEY(8),=CL8' '\n         MVC   ZENTRYPT(8),=CL8' '\n         MVC   ZTCBADDR(8),=CL8' '\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\nRETURN   REXIT ENV=OS\n         EJECT\n         LTORG\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         SPACE\nNOLPA1   DC    CL133' # UNABLE TO ACCESS LPA DIRECTORY AT DUMP ADDRESS *\n               XXXXXXXX (DUMPLPA) '\nNOLPA2   DC    CL133' # UNABLE TO ACCESS LPA DIRECTORY AREA AT DUMP ADD*\n               RESS XXXXXXXX (DUMPLPA) '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F              SAVE AREA\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nLINE     DS    CL133\nSEGSIZE  DS    F\nBUFFZ    DS    0CL133\n         DC    CL1' '\nZAREA    DC    CL9' '\n         DC    CL2'\u00a6 '\nZSIZE    DC    CL9' '\n         DC    CL2'\u00a6 '\nZENDADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSUBPOOL DC    CL9' '\n         DC    CL2'\u00a6 '\nZKEY     DC    CL9' '\n         DC    CL2'\u00a6 '\nZPGMNAME DC    CL9' '\n         DC    CL2'\u00a6 '\nZENTRYPT DC    CL9' '\n         DC    CL2'\u00a6 '\nZTCBADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSHARED  DC    CL9' '\n         DC    CL2'\u00a6 '\nZOWNED   DC    CL9' '\n         DC    CL2'\u00a6 '\nZRECTYPE DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nOPTR     DS    A\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         CVT   DSECT=YES\n         IHAPSA\n         IHALPDE\nLPDELEN  EQU   *-LPDE\nSEGMAX   EQU   LPDELEN*100\n         IHAASCB\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\nRECTDQE  EQU   C'1'\nRECTREG  EQU   C'2'\nRECTLPDE EQU   C'3'\nRECTCDEA EQU   C'4'\nRECTLLE  EQU   C'5'\nRECTCDEB EQU   C'6'\n         END\n*\n*\n*  DQE  PRINTER / DUMPER\n*\n*  PARMS:  NON IPCS:\n*          1  -  OUTPUT DCB ADDRESS\n*          2  -  PRINT DCB ADDRESS\n*          3  -  TCB ADDRESS\n*          4  -  CDE ADDRESS\n*          5  -  SPQE ADDRESS\n*          6  -  DQE ADDRESS\n*  PARMS:  IPCS\n*          1  -  OUTPUT DCB ADDRESS\n*          2  -  PRINT DCB ADDRESS (DUMMY PARM)\n*          3  -  TCB ADDRESS (DUMP ADDRESS)\n*          4  -  CDE ADDRESS (THIS ADDRESS SPACE)\n*          5  -  SPQE ADDRESS (THIS ADDRESS SPACE)\n*          6  -  DQE ADDRESS (THIS ADDRESS SPACE)\n*          7  -  DQE ADDRESS (DUMP ADDRESS)\n*\n         PRINT    NOGEN\nDUMPDQE  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         L     R3,OUTDCB            POINT TO OUTPUT DCB\n         L     R4,PRINTDCB          POINT TO PRINT DCB\n         L     R5,TCBPTR            GET THE TCB ADDRESS (IPCS - DUMP)\n         L     R6,CDEPTR            POINT TO THE CDE\n         L     R7,SPQEPTR           POINT TO THE SPQE\n         L     R8,DQEPRM            POINT TO THE DQE\n         SPACE\n**********************************************************************\n*\n* MAKE SURE WE HAVE A DQE TO DUMP.  IF NOT, JUST RETURN. IF SO,\n* INTIALIZE THE DATA AREA AND PUT IN ALL THE DATA\n*\n*      REGISTER USAGE:\n*              R3  -> OUTPUT DCB\n*              R4  -> PRINT DCB\n*              R5  -  TCB ADDRESS, (FOR IPCS, THIS IS DUMP ADDRESS)\n*              R6  -> CDE FOR THE PASSED TCB\n*              R7  -> SPQE FOR THIS DQE\n*              R8  -> THE DQE TO DUMP\n*              R9  -  IPCS ONLY, THE DQE ADDRESS IN THE DUMP\n*\n**********************************************************************\n         SPACE\n         USING CDENTRY,R6\n         USING SPQE,R7\n         USING DQE,R8\n         SPACE\n         SLR   R0,R0                CLEAR RETURNED PARM IN CASE NO DQE\n         LTR   R8,R8                DO WE HAVE A DQE?\n         BZ    RETURN               IF NOT, QUIT\n         SPACE\n         MVC   BUFFZ,BUFFINIT\n         MVC   BUFFD,BUFFDINT\n         MVI   ZRECTYPE,RECTDQE     SET RECORD TYPE\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS01          ###############\n         ST    R8,WORD\n         AGO   .NPCS01\n.IPCS01  ANOP\n         L     R9,DQEDUMP           LOAD DUMP DQE ADDRESS\n         ST    R9,WORD\n.NPCS01  ANOP\n         DROP  R10\n         UNPK  THISDQE(9),WORD(5)   DQE ADDR TO PRINT RECORD\n         TR    THISDQE(8),HEXCHAR\n         MVI   THISDQE+8,C' '\n         SPACE\n         UNPK  AREA(9),DQEAREA(5)   DQE START ADDR TO BOTH RECS\n         TR    AREA(8),HEXCHAR\n         MVI   AREA+8,C' '\n         MVC   ZAREA(8),AREA\n         SPACE\n         MVC   WORD(4),DQESIZE      AREA SIZE TO BOTH RECS\n         UNPK  SIZE(9),WORD(5)\n         TR    SIZE(8),HEXCHAR\n         MVI   SIZE+8,C' '\n         MVC   ZSIZE(8),SIZE\n         SPACE\n         L     R15,DQEAREA          END ADDR TO DUMP REC\n         A     R15,DQESIZE\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SPACE\n         UNPK  NEXTDQE(9),DQENEXT(5)  NEXT DQE TO PRINT REC\n         TR    NEXTDQE(8),HEXCHAR\n         MVI   NEXTDQE+8,C' '\n         SPACE\n         UNPK  FFQE(9),DQEFFQE(5)     FQE DATA TO PRINT REC\n         TR    FFQE(8),HEXCHAR\n         MVI   FFQE+8,C' '\n         UNPK  LFQE(9),DQELFQE(5)\n         TR    LFQE(8),HEXCHAR\n         MVI   LFQE+8,C' '\n         SPACE\n         MVC   ZPGMNAME(8),=CL8' '     CLEAR PROGRAM NAME\n         MVC   ZENTRYPT(9),=CL8' '     CLEAR ENTRY POINT\n         SPACE\n         LTR   R6,R6                   IS THERE A CDE?\n         BZ    NOCDE\n         SPACE\n         MVC   ZPGMNAME(8),CDNAME      PGM NAME TO DUMP REC\n         L     R15,CDENTPT             LOAD ENTRY POINT\n         LTR   R15,R15                 IS IT ZERO? (FAKE CDE)\n         BZ    NOCDE                   IF SO, LEAVE BLANK\n         SPACE\n         UNPK  ZENTRYPT(9),CDENTPT(5)  PGM ENTRY POINT TO DUMP REC\n         TR    ZENTRYPT(8),HEXCHAR\n         MVI   ZENTRYPT+8,C' '\n         SPACE\nNOCDE    DS    0H\n         MVC   ZTCBADDR(8),=CL8' '     CLEAR TCB ADDR FIELD\n         LTR   R5,R5                   IS THERE A TCB?\n         BZ    NOTCB\n         SPACE\n         ST    R5,WORD\n         UNPK  ZTCBADDR(9),WORD(5)     TCB ADDR TO DUMP RECORD\n         TR    ZTCBADDR(8),HEXCHAR\n         MVI   ZTCBADDR+8,C' '\n         SPACE\nNOTCB    DS    0H\n         SLR   R15,R15\n         IC    R15,SPQEID              SUBPOOL NUM TO DUMP RECORD\n         CVD   R15,WORD\n         MVC   ZSUBPOOL(8),=X'4020202020202021'\n         ED    ZSUBPOOL(8),WORD+4\n         OI    ZSUBPOOL+7,X'F0'\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS04\n         CLI   SPQEKEY,X'FF'           CHECK SPECIAL VALUE\n         BNE   SPQEOK\n         SPACE\n         L     R14,DQEAREA             POINT TO THE DQE AREA\n         IVSK  R15,R14                 GET THE PROTECT KEY\n         B     SPQEKEY2\n.IPCS04  ANOP\n         SPACE\nSPQEOK   DS    0H\n         IC    R15,SPQEKEY             KEY NUM TO DUMP RECORD\nSPQEKEY2 DS    0H\n         SRL   R15,4\n         CVD   R15,WORD\n         MVC   ZKEY(8),=X'4020202020202021'\n         ED    ZKEY(8),WORD+4\n         OI    ZKEY+7,X'F0'\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS03          ###############\n         CLI   SPQEKEY,X'FF'           CHECK SPECIAL VALUE\n         BNE   SPQEOK2\n         SPACE\n         MVC   ZKEY(8),=CL8' '         IPCS, CLEAR PROTECT KEY\n         SPACE\nSPQEOK2  DS    0H\n.NPCS03  ANOP\n         SPACE\n         MVC   ZSHARED(8),=CL8' '         SHARED TO DUMP RECORD\n         TM    SPQEFLGS,SPQESHR\n         BZ    *+10\n         MVC   ZSHARED(8),=CL8'SHARED'\n         SPACE\n         MVC   ZOWNED(8),=CL8' '          OWNED TO DUMP RECORD\n         TM    SPQEFLGS,SPQEOWN\n         BZ    *+10\n         MVC   ZOWNED(8),=CL8'OWNED'\n         SPACE\n         LTR   R3,R3                      IS THERE A DUMP DCD?\n         BZ    TRYPRT                     IF NOT, SKIP THE DUMP\n         SPACE\n         PUT31 AREA24,(R3),BUFFZ DUMP RECORD\n         PUT31 AREA24,(R3),ZHDR4\n         SPACE\nTRYPRT   DS    0H\n         LTR   R4,R4                      IS THERE A PRINT DCB?\n         BZ    DONE                       IF NOT, SKIP THE PRINT\n         SPACE\n         VSMPRNT AREA24,(R4),BUFFD PRINT RECORD\n         VSMPRNT AREA24,(R4),DHDR4\n         SPACE\nDONE     DS    0H\n*        IF WE ARE TO CALL RUNFQE, CHECK FOR VALID DQE HERE FIRST.\n         L     R0,DQESIZE                 AREA SIZE\nRETURN   DS    0H\n         REXIT ENV=OS,RETURN=(0)\n         DROP  R6    CDE\n         DROP  R7    SPQE\n         DROP  R8    DQE\n         SPACE\n         LTORG\n         SPACE\nDHDR4    DC    CL133'                     +----------+----------+------*\n               ----+----------+----------+----------+'\nBUFFDINT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'  '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL44' '\n         SPACE\n         SPACE\nZHDR1    DC    CL133'  AREA    \u00a6 SIZE     \u00a6 END ADDR \u00a6 SUBPOOL  \u00a6 KEY  *\n                   \u00a6 PGM NAME \u00a6 ENTRY PT \u00a6 TCB ADDR \u00a6 SHARED?  \u00a6 OWNED?*\n                  \u00a6'\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         SPACE\n         EJECT\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\n         LTORG\nWORKAREA DSECT\n         DS    26F              SAVE AREA\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nLINE     DS    CL133\nBUFFZ    DS    0CL133\n         DC    CL1' '\nZAREA    DC    CL9' '\n         DC    CL2'\u00a6 '\nZSIZE    DC    CL9' '\n         DC    CL2'\u00a6 '\nZENDADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSUBPOOL DC    CL9' '\n         DC    CL2'\u00a6 '\nZKEY     DC    CL9' '\n         DC    CL2'\u00a6 '\nZPGMNAME DC    CL9' '\n         DC    CL2'\u00a6 '\nZENTRYPT DC    CL9' '\n         DC    CL2'\u00a6 '\nZTCBADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSHARED  DC    CL9' '\n         DC    CL2'\u00a6 '\nZOWNED   DC    CL9' '\n         DC    CL2'\u00a6 '\nZRECTYPE DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         SPACE\nBUFFD    DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'  '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\nTHISDQE  DC    CL9' '\n         DC    CL2'\u00a6 '\nAREA     DC    CL9' '\n         DC    CL2'\u00a6 '\nSIZE     DC    CL9' '\n         DC    CL2'\u00a6 '\nNEXTDQE  DC    CL9' '\n         DC    CL2'\u00a6 '\nFFQE     DC    CL9' '\n         DC    CL2'\u00a6 '\nLFQE     DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL44' '\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\nCDEPTR   DS    A\nSPQEPTR  DS    A\nDQEPRM   DS    A\nOPTR     DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\nCDEPTR   DS    A\nSPQEPTR  DS    A\nDQEPRM   DS    A\nDQEDUMP  DS    A\nOPTR     DS    A\n.NPCS3P  ANOP\n*        PRINT NOGEN\n         SYMBAR MODE=DEC\n         IKJTCB\n         IHASPQE\n         IHACDE\n         IHADQE\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\nRECTDQE  EQU   C'1'\nRECTREG  EQU   C'2'\nRECTLPDE EQU   C'3'\nRECTCDEA EQU   C'4'\nRECTLLE  EQU   C'5'\nRECTCDEB EQU   C'6'\n         END\n*\n*   FIND CDE GIVEN TCB\n*   FOR IPCS TAKES TCB DUMP ADDR\n*   ALWAYS RETURNS CDE ADDR IN THIS ADDRESS SPACE\n*\n         PRINT NOGEN\nFINDCDE  RENTR BASE=11,ENV=OS,PARM=10,WORK=(WORKLEN,WORKAREA)\n         SPACE\n         L     R3,0(,R10)            POINT TO THE TCB\n         SPACE\n         SLR   R5,R5                 CLEAR CDE POINTER HOLDER\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS21          ###############\n         USING TCB,R3\n         AGO   .NPCS21\n.IPCS21  ANOP\n         IPCSLOAD R6,(R3),LEN=TCBLEN\n         LTR   R6,R6                  BAD DUMP ADDR?\n         BZ    RETURN\n         USING TCB,R6                OVERLAY TCB IN THIS ADDR SP\n.NPCS21  ANOP\n         L     R4,TCBRBP             POINT TO THE RB\n         N     R4,=X'00FFFFFF'       THIS IS A 24 BIT ADDRESS\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS22          ###############\n         USING RBBASIC,R4\n         AGO   .NPCS22\n.IPCS22  ANOP\n         USING RBBASIC,R7\n.NPCS22  ANOP\n         SPACE\nRBLOOP   DS    0H\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS24          ###############\n         IPCSLOAD R7,(R4),LEN=RBLEN\n         LTR   R7,R7                  BAD DUMP ADDR?\n         BZ    RETURN\n.NPCS24  ANOP\n         TM    RBSTAB1,RBFTP         IS THIS THE PRB?\n         BZ    GOTPRB                PRB HAS ALL THREE BITS ZERO.\n         SPACE\nNOTPRB   DS    0H\n         TM    RBSTAB2,RBTCBNXT      LAST RB BEFORE THE TCB?\n         BO    RETURN\n         SPACE\nRBNEXT   DS    0H\n         L     R4,RBLINK             NEXT RB\n         N     R4,=X'00FFFFFF'       THIS IS A 24 BIT ADDRESS\n         CR    R4,R3                 IS THIS THE TCB?\n         BNE   RBLOOP                NO, KEEP TRYING\n         B     RETURN\n         SPACE\nGOTPRB   DS    0H\n         ICM   R5,7,RBCDE1           24 BIT CDE ADDRESS\n         LTR   R5,R5                 IS R0 ZERO?\n         BZ    NOTPRB                IF NOT, KEEP TRYING\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS29          ###############\n         DROP  R3,R4\n         AGO   .NPCS29\n.IPCS29  ANOP\n         DROP  R6,R7\n.NPCS29  ANOP\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS23          ###############\n         LR    R0,R5\n         AGO  .NPCS23\n.IPCS23  ANOP\n         IPCSLOAD R4,(R5),LEN=CDELEN\n         LR    R0,R4                  SAVE CDE ADDRESS\n.NPCS23  ANOP\n         SPACE\nRETURN   REXIT ENV=OS,RETURN=(0)\n         SPACE\n         LTORG\n         SPACE\n*        PRINT NOGEN\n         SYMBAR MODE=DEC\n         IKJTCB\n         IHACDE\nCDELEN   EQU    *-CDENTRY\n         IHARB  LIST=YES\nRBLEN    EQU    *-RBBASIC\nWORKAREA DSECT\n         DS    26F\nAREA24   DS    XL128\nCALLLIST DS    8D\nLINE     DS    CL133\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         END\n*\n*   DUMP CDE(S) GIVEN TCB\n*   FOR IPCS TAKES TCB DUMP ADDR\n*\n*   PARMS:\n*        1  -> OUTPUT DCB\n*        2  -> PRINT DCB\n*        3  -> TCB\n*        4  -> TCB DUMP ADDRESS (IPCS ONLY)\n*\n         PRINT NOGEN\nDUMPCDE  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         L     R9,PRINTDCB           POINT TO THE PRINT  DCB\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS21          ###############\n         L     R3,TCBPTR             POINT TO THE TCB\n         USING TCB,R3\n         SPACE\n         AGO   .NPCS21\n.IPCS21  ANOP\n         L     R3,TCBDUMP            GET DUMP ADDRESS FOR TCB\n         L     R6,TCBPTR             POINT TO THE TCB\n         USING TCB,R6                OVERLAY TCB IN THIS ADDR SP\n.NPCS21  ANOP\n         L     R10,OUTDCB            POINT TO THE OUTPUT DCB\n         DROP  R10\n         EJECT\n**********************************************************************\n*\n* FOR IPCS, FIRST ACCESS THE TCB.  NON-IPCS THE PARM POINTS TO IT.\n* THEN WALK THE RB CHAIN LOOKING FOR PRB'S.  THE PRB POINTS TO THE\n* CDE AND THE CDE POINTS TO THE CDE XLST.  THE CDE HAS THE NAME OF\n* THE PROGRAM, ITS ENTRY POINT.  THE XTLST HAS IT'S SIZE.\n*\n*      REGISTER USAGE:\n*              R2  -  RECORD TYPE (RECTCDEA OR RECTCDEB)\n*              R3  -  TCB ADDRESS.  IPCS - ADDR IN DUMP\n*              R4  -  CURRENT RB ADDRESS.  IPCS - ADDR IN DUMP\n*              R5  -  THE CDE ADDRESS.  IPCS - ADDR NIN DUMP\n*              R6  -  IPCS ONLY, -> TCB IN THIS ADDRESS SPACE\n*              R7  -  IPCS ONLY, -> RB IN THIS ADDRESS SPACE\n*              R8  -  IPCS ONLY, -> CDE IN THIS ADDRESS SPACE.\n*              R9  -  CURRENT BIT BEING TESTED\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R13 -> DSA AND AUTOMATIC STORAGE\n*              R14 -  WORK REGISTER\n*              R15 -  WORK REGISTER\n*\n**********************************************************************\n         SPACE\n         SLR   R5,R5                 CLEAR CDE POINTER HOLDER\n         L     R4,TCBRBP             POINT TO THE RB\n         N     R4,=X'00FFFFFF'       THIS IS A 24 BIT ADDRESS\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS22          ###############\n         USING RBBASIC,R4\n         AGO   .NPCS22\n.IPCS22  ANOP\n         USING RBBASIC,R7\n.NPCS22  ANOP\n         SPACE\n**********************************************************************\n*\n* TEST THIS RB TO SEE IF IT IS A PRB - PROGRAM REQUEST BLOCK.\n*\n**********************************************************************\n         SPACE\nRBLOOP   DS    0H\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS23          ###############\n         IPCSLOAD R7,(R4),LEN=RBLEN,PERM=HOLDRB\n         IPCSLMSG R7,R4,NORB,40,ZHDR4,(R10),(R9)\n         LTR   R7,R7                  BAD DUMP ADDR?\n         BZ    RETURN\n.NPCS23  ANOP\n         TM    RBSTAB1,RBFTP         IS THIS THE PRB?\n         BZ    GOTPRB                PRB HAS ALL THREE BITS ZERO.\n         SPACE\n**********************************************************************\n*\n* IF THIS IS THE LAST RB BEFORE WE ARE BACK AT THE TCB, WE ARE DONE\n* WITH THIS TCB.\n*\n**********************************************************************\n         SPACE\nNOTPRB   DS    0H\n         TM    RBSTAB2,RBTCBNXT      LAST RB BEFORE THE TCB?\n         BO    RETURN\n         SPACE\n**********************************************************************\n*\n* LINK TO THE NEXT RB.  IF IT IS THE TCB ADDRESS, WE ARE DONE.  THIS\n* SHOULD NOT HAPPEN SINCE THE TEST AT LABEL NOTPRB SHOULD CATCH THE\n* LAST RB.\n*\n**********************************************************************\n         SPACE\nRBNEXT   DS    0H\n         L     R4,RBLINK             NEXT RB\n         N     R4,=X'00FFFFFF'       THIS IS A 24 BIT ADDRESS\n         CR    R4,R3                 IS THIS THE TCB?\n         BNE   RBLOOP                NO, KEEP TRYING\n         B     RETURN\n         SPACE\n**********************************************************************\n*\n* WE HAVE THE PRB.  MAKE SURE IT POINTS TO A CDE.  SOME PRB'S HAVE A\n* ZERO CDE ADDRESS.\n*\n**********************************************************************\n         SPACE\nGOTPRB   DS    0H\n         ICM   R5,7,RBCDE1           24 BIT CDE ADDRESS\n         LTR   R5,R5                 IS R0 ZERO?\n         BZ    NOTPRB                IF NOT, KEEP TRYING\n         SPACE\n         LA    R2,RECTCDEA           SHOW FIRST CDE IS TYPE 4\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS24          ###############\n         DROP  R3,R4\n         AGO   .NPCS24\n.IPCS24  ANOP\n         DROP  R6,R7\n.NPCS24  ANOP\n         EJECT\n**********************************************************************\n*\n* WE HAVE A CDE.  INITIALIZE THE BUFFER AND GET THE INFORMATION WE\n* NEED FROM THE CDE.\n*\n*      REGISTER USAGE:\n*              R2  -  RECORD TYPE TO PASS TO PRTCDE\n*              R3  -  TCB ADDRESS.  IPCS - ADDR IN DUMP\n*              R4  -  CURRENT RB ADDRESS.  IPCS - ADDR IN DUMP\n*              R5  -  THE CDE ADDRESS.  IPCS - ADDR IN DUMP\n*              R6  -  IPCS ONLY, -> TCB IN THIS ADDRESS SPACE\n*              R7  -  IPCS ONLY, -> RB IN THIS ADDRESS SPACE\n*              R8  -  IPCS ONLY, -> CDE IN THIS ADDRESS SPACE.\n*              R9  -  CURRENT BIT BEING TESTED\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R12 -  TEMP POINTER TO OPTIONS FOR CALLS\n*              R13 -> DSA AND AUTOMATIC STORAGE\n*              R14 -  WORK REGISTER\n*              R15 -  WORK REGISTER\n*\n**********************************************************************\n         SPACE\nGOTCDE   DS    0H\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS25          ###############\n         USING CDENTRY,R5\n         SPACE\n         L     R15,OPTPTR\n         CLI   LPAPRM(R15),X'FF'      LPA OPTION ON?\n         BE    SK1                    IF SO, CONTINUE PROCESSING\n         SPACE\n         TM    CDATTR,CDNIP           IS THIS AN LPA MODULE?\n         BO    SKIPCDE                IF SO, SKIP IT BECAUSE OF NOLPA\n         SPACE\nSK1      DS    0H\n         L     R12,OPTPTR\n         CALL  PRTCDE,((R10),(R9),(R2),(R5),(R12)),MF=(E,CALLLIST)\n         SPACE\n         AGO  .NPCS25\n.IPCS25  ANOP\n         IPCSLOAD R8,(R5),LEN=CDELEN,PERM=HOLDCDE\n         IPCSLMSG R8,R5,NOCDE,40,ZHDR4,(R10),(R9)\n         LTR   R8,R8                  DID WE GET A CDE?\n         BZ    NOTPRB                 IF NOT, DON'T PROCESS THE CDE\n         USING CDENTRY,R8\n         SPACE\n         L     R15,OPTPTR\n         CLI   LPAPRM(R15),X'FF'      LPA OPTION ON?\n         BE    SK1                    IF SO, CONTINUE PROCESSING\n         SPACE\n         TM    CDATTR,CDNIP           IS THIS AN LPA MODULE?\n         BO    SKIPCDE                IF SO, SKIP IT BECAUSE OF NOLPA\n         SPACE\nSK1      DS    0H\n         L     R12,OPTPTR\n         CALL  PRTCDE,((R10),(R9),(R2),(R8),(R5),(R12)),MF=(E,CALLLIST)\n         SPACE\n.NPCS25  ANOP\nSKIPCDE  DS    0H\n*        TM    CDATTRB,CDELPDE        IS THIS REALLY AN LPDE?\n*        BO    NOTPRB                 IF SO, GO TO THE NEXT RB.\n         SPACE\nNEXTCDE  DS    0H\n         L     R5,CDCHAIN\n         LTR   R5,R5\n         BZ    NOTPRB                 TRY NEXT RB\n         LA    R2,RECTCDEB            SHOW FIRST CDE IS TYPE 6\n         B     GOTCDE\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS29A         ###############\n         DROP  R5\n         AGO  .NPCS29A\n.IPCS29A ANOP\n         DROP  R8\n.NPCS29A ANOP\n         SPACE\nRETURN   DS    0H\n         REXIT ENV=OS\n         SPACE\n         LTORG\nNOCDE    DC    CL133' # UNABLE TO ACCESS CDE AT DUMP ADDRESS XXXXXXXX  X\n               (DUMPCDE) '\nNORB     DC    CL133' # UNABLE TO ACCESS RB AT DUMP ADDRESS XXXXXXXX   X\n               (DUMPCDE) '\nNOCDEX   DC    CL133' # UNABLE TO ACCESS CDE EXTLST AT DUMP ADDRESS XXX*\n               XXXXX  (DUMPCDE) '\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IKJTCB\n         IHACDE\nCDELEN   EQU    *-CDENTRY\n         IHAXTLST\nXLSTLEN  EQU    *-XTLST\n         IHARB  LIST=YES\nRBLEN    EQU    *-RBBASIC\n         IHALPDE\nLPDELEN  EQU   *-LPDE\nWORKAREA DSECT\n         DS    26F\nAREA24   DS    XL128\nWORD     DS    D\nCALLLIST DS    8D\nOPTPTR   DS    A\nLINE     DS    CL133\n         DS    0F\nHOLDRB   DS    XL(RBLEN)\n         DS    0F\nHOLDCDE  DS    XL(CDELEN)\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\n         DS    A          NOT USED\nOPTR     DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\nTCBDUMP  DS    A\nOPTR     DS    A\n.NPCS3P  ANOP\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         SPACE\nRECTDQE  EQU   C'1'\nRECTREG  EQU   C'2'\nRECTLPDE EQU   C'3'\nRECTCDEA EQU   C'4'\nRECTLLE  EQU   C'5'\nRECTCDEB EQU   C'6'\n         END\n*\n*   DUMP CDE(S) FOR MODULES LOADED (SVC 6) BY A GIVEN TCB\n*   FOR IPCS TAKES TCB DUMP ADDR\n*\n*   PARMS:\n*        1  -> OUTPUT DCB\n*        2  -> PRINT DCB\n*        3  -> TCB\n*        4  -  IPCS ONLY - TCB ADDRESS IN DUMP\n*\n*        PRINT NOGEN\nDUMPLLE  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         L     R9,PRINTDCB           POINT TO THE PRINT  DCB\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS21          ###############\n         L     R3,TCBPTR             POINT TO THE TCB\n         USING TCB,R3\n         SPACE\n         AGO   .NPCS21\n.IPCS21  ANOP\n         L     R3,TCBDUMP            GET DUMP ADDRESS FOR TCB\n         L     R6,TCBPTR             POINT TO THE TCB\n         USING TCB,R6                OVERLAY TCB IN THIS ADDR SP\n.NPCS21  ANOP\n         L     R10,OUTDCB            POINT TO THE OUTPUT DCB\n         DROP  R10\n         EJECT\n**********************************************************************\n*\n* FOR IPCS, FIRST ACCESS THE TCB.  NON-IPCS, THE PARM POINTS TO IT.\n* THEN WALK THE LLE CHAIN DUMPING THE CDE'S. THE CDE POINTS TO THE\n* CDE XLST.  THE CDE HAS THE NAME OF THE PROGRAM, ITS ENTRY POINT.\n* THE XTLST HAS ITS SIZE.\n*\n*      REGISTER USAGE:\n*              R3  -  TCB ADDRESS.  IPCS - ADDR IN DUMP\n*              R4  -  CURRENT RB ADDRESS.  IPCS - ADDR IN DUMP\n*              R5  -  THE CDE ADDRESS.  IPCS - ADDR NIN DUMP\n*              R6  -  IPCS ONLY, -> TCB IN THIS ADDRESS SPACE\n*              R7  -  IPCS ONLY, -> RB IN THIS ADDRESS SPACE\n*              R8  -  IPCS ONLY, -> CDE IN THIS ADDRESS SPACE.\n*              R9  -> PRINT DCB\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R13 -> DSA AND AUTOMATIC STORAGE\n*              R14 -  WORK REGISTER\n*              R15 -  WORK REGISTER\n*\n**********************************************************************\n         SPACE\n         SLR   R5,R5                 CLEAR CDE POINTER HOLDER\n         L     R4,TCBLLS             POINT TO THE LOAD LIST\n         LTR   R4,R4                 ANYTHING IN THE LIST?\n         BZ    RETURN                IF NOT, WE ARE DONE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS22          ###############\n         USING LLE,R4\n         AGO   .NPCS22\n.IPCS22  ANOP\n         USING LLE,R7\n.NPCS22  ANOP\n         SPACE\n**********************************************************************\n*\n* GET THE LLE AND THE CDE FROM POINTED TO BY THE LLE.\n*\n**********************************************************************\n         SPACE\nLLELOOP  DS    0H\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS23          ###############\n         IPCSLOAD R7,(R4),LEN=LLELEN,PERM=HOLDLLE\n         IPCSLMSG R7,R4,NOLLE,41,ZHDR4,(R10),(R9)\n         LTR   R7,R7                  BAD DUMP ADDR?\n         BZ    RETURN\n.NPCS23  ANOP\n         SPACE\n**********************************************************************\n*\n* GET THE CDE FROM THE LLE\n*\n**********************************************************************\n         SPACE\n         L     R5,LLECDPT           CDE POINTER\n         LTR   R5,R5                IS THERE ONE?\n         BZ    NEXTLLE              IF NOT, SKIP IT\n         EJECT\n**********************************************************************\n*\n* WE HAVE A CDE.  INITIALIZE THE BUFFER AND GET THE INFORMATION WE\n* NEED FROM THE CDE.\n*\n*      REGISTER USAGE:\n*              R3  -  TCB ADDRESS.  IPCS - ADDR IN DUMP\n*              R4  -  CURRENT RB ADDRESS.  IPCS - ADDR IN DUMP\n*              R5  -  THE CDE ADDRESS.  IPCS - ADDR NIN DUMP\n*              R6  -  IPCS ONLY, -> TCB IN THIS ADDRESS SPACE\n*              R7  -  IPCS ONLY, -> RB IN THIS ADDRESS SPACE\n*              R8  -  IPCS ONLY, -> CDE IN THIS ADDRESS SPACE.\n*              R9  -> PRINT CDE\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R12 -  TEMP ADDR OF RUN TIME OPTIONS TO PASS TO PRTCDE\n*              R13 -> DSA AND AUTOMATIC STORAGE\n*              R14 -  WORK REGISTER\n*              R15 -  WORK REGISTER\n*\n**********************************************************************\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS25          ###############\n         USING CDENTRY,R5\n         SPACE\n         L     R12,OPTPTR\n         CALL  PRTCDE,((R10),(R9),RECTLLE,(R5),(R12)),MF=(E,CALLLIST)\n         SPACE\n         AGO  .NPCS25\n.IPCS25  ANOP\n         IPCSLOAD R8,(R5),LEN=CDELEN,PERM=HOLDCDE\n         IPCSLMSG R8,R5,NOCDE,40,ZHDR4,(R10),(R9)\n         LTR   R8,R8                  DID WE GET A CDE?\n         BZ    NEXTLLE                IF NOT, DON'T PROCESS THE CDE\n         USING CDENTRY,R8\n         SPACE\n         L     R12,OPTPTR\n         CALL  PRTCDE,((R10),(R9),RECTLLE,(R8),(R5),(R12)),            X\n               MF=(E,CALLLIST)\n         SPACE\n.NPCS25  ANOP\n         SPACE\n**********************************************************************\n*\n* LINK TO THE NEXT LLE.  THE END OF THE LIST HAS A ZERO.\n*\n**********************************************************************\n         SPACE\nNEXTLLE  DS    0H\n         L     R4,LLECHN             NEXT LLE\n         LTR   R4,R4                 END OF LIST?\n         BNZ   LLELOOP\n         B     RETURN\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS27          ###############\n         DROP  R3,R4,R5\n         AGO  .NPCS27\n.IPCS27  ANOP\n         DROP  R6,R7,R8\n.NPCS27  ANOP\n         SPACE\n         SPACE\nRETURN   DS    0H\n         REXIT ENV=OS\n         SPACE\n         LTORG\nNOTCB    DC    CL133' # UNABLE TO ACCESS TCB AT DUMP ADDRESS XXXXXXXX  X\n               (DUMPLLE) '\nNOCDE    DC    CL133' # UNABLE TO ACCESS CDE AT DUMP ADDRESS XXXXXXXX  X\n               (DUMPLLE) '\nNOLLE    DC    CL133' # UNABLE TO ACCESS LLE AT DUMP ADDRESS XXXXXXXX  X\n               (DUMPLLE) '\nNOCDEX   DC    CL133' # UNABLE TO ACCESS CDE EXTLST AT DUMP ADDRESS XXX*\n               XXXXX  (DUMPLLE) '\n         SPACE\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n*        PRINT NOGEN\n         SYMBAR MODE=DEC\n         IKJTCB\n         IHACDE\nCDELEN   EQU    *-CDENTRY\n         IHAXTLST\nXLSTLEN  EQU    *-XTLST\n         IHALLE\nLLELEN   EQU    *-LLE\n         IHALPDE\nLPDELEN  EQU   *-LPDE\nWORKAREA DSECT\n         DS    26F\nAREA24   DS    XL128\nWORD     DS    D\nCALLLIST DS    8D\nOPTPTR   DS    A\nLINE     DS    CL133\n         DS    0F\nHOLDLLE  DS    XL(LLELEN)\n         DS    0F\nHOLDCDE  DS    XL(CDELEN)\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\n         DS    A          NOT USED\nOPTR     DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\nTCBDUMP  DS    A\nOPTR     DS    A\n.NPCS3P  ANOP\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\nRECTDQE  EQU   C'1'\nRECTREG  EQU   C'2'\nRECTLPDE EQU   C'3'\nRECTCDEA EQU   C'4'\nRECTLLE  EQU   C'5'\nRECTCDEB EQU   C'6'\n         END\n*\n*   PRINT A CDE\n*   FOR IPCS TAKES TCB DUMP ADDR\n*\n*   PARMS:\n*        1  -> OUTPUT DCB\n*        2  -> PRINT DCB\n*        3  -  REC TYPE VALUE\n*        4  -> CDE TO PRINT\n*        5  -> CDE ADDRESS IN DUMP (IPCS ONLY)\n*\n         PRINT NOGEN\nPRTCDE   RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         L     R9,PRINTDCB           POINT TO THE PRINT  DCB\n         L     R2,RECT               GET THE REC TYPE\n         L     R5,CDEPTR             POINT TO THE CDE\n         USING CDENTRY,R5\n         SPACE\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS21          ###############\n         L     R6,CDEDUMP            GET CDE ADDRESS FROM DUMP\n         SPACE\n.NPCS21  ANOP\n         L     R10,OUTDCB            POINT TO THE OUTPUT DCB\n         DROP  R10\n         MVC   BUFFZ(133),BUFFINIT\n         STC   R2,ZRECTYPE           FILL IN THE RECORD TYPE\n         MVC   BUFFP(133),BUFFINIT\n         STC   R2,PRECTYPE           FILL IN THE RECORD TYPE\n         EJECT\n**********************************************************************\n*\n* WE HAVE A CDE.  INITIALIZE THE BUFFER AND GET THE INFORMATION WE\n* NEED FROM THE CDE.\n*\n*      REGISTER USAGE:\n*              R2  -  CDE XLST ADDRESS.  IPCS - ADDR IN DUMP\n*              R5  -> THE CDE TO PRINT\n*              R6  -  IPCS ONLY, - CDE ADDRESS IN DUMP\n*              R9  -> PRINT DCB\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R12 -  IPCS ONLY, -> CDE XLST IN THIS ADDRESS SPACE\n*              R13 -> DSA AND AUTOMATIC STORAGE\n*              R14 -  WORK REGISTER\n*              R15 -  WORK REGISTER\n*\n**********************************************************************\n         SPACE\n         MVI   MINORFLG,X'00'        CLEAR FLAG FOR MINOR CDE\n         SPACE\n**********************************************************************\n*\n* FILL IN THE STUFF FROM THIS CDE\n*\n**********************************************************************\n         SPACE\n         L     R15,CDENTPT            GET ENTRY POINT\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)       TEMP USE ZAREA (MAY FIX LATER)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         SPACE\n         MVC   ZENTRYPT(8),ZAREA\n         MVC   ZPGMNAME(8),CDNAME\n         SPACE\n         ST    R3,WORD                TCB ADDRESS\n         UNPK  ZTCBADDR(9),WORD(5)\n         TR    ZTCBADDR(8),HEXCHAR\n         MVI   ZTCBADDR+8,C' '\n         SPACE\n         SLR   R15,R15\n         IC    R15,CDSP\n         CVD   R15,WORD\n         MVC   ZSUBPOOL(8),=X'4020202020202021'\n         ED    ZSUBPOOL(8),WORD+4\n         OI    ZSUBPOOL+7,X'F0'\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS21Z         ###############\n         ST    R5,WORD                CDE ADDRESS\n         AGO   .NPCS21Z\n.IPCS21Z ANOP\n         ST    R6,WORD                CDE ADDRESS\n.NPCS21Z ANOP\n         UNPK  PTHISCDE(9),WORD(5)\n         TR    PTHISCDE(8),HEXCHAR\n         MVI   PTHISCDE+8,C' '\n         SPACE\n         UNPK  PATTR(9),CDATTRB(5)\n         TR    PATTR(8),HEXCHAR\n         MVI   PATTR+8,C' '\n         SPACE\n*.NPCS21Z ANOP\n         TM    CDATTR,CDNIP           IS THIS AN LPA MODULE?\n         BZ    NOTLPA                 IF NOT, DON'T MARK AS SUCH\n         SPACE\n         MVC   ZSHARED(8),=CL8'LPA MOD'\n         SPACE\nNOTLPA   DS    0H\n         TM    CDATTR2,CDAUTH         IS THIS MODULE AC 1\n         BZ    NOTAC1                 IF NOT, DON'T MARK AS SUCH\n         SPACE\n         MVC   ZKEY(8),=CL8'AC(1)'\n         SPACE\nNOTAC1   DS    0H\n         EJECT\n**********************************************************************\n*\n* CHECK TO SEE IF THIS IS REALLY AN LPDE (LINK PACK DIRECTORY ENTRY).\n* IF SO, THE LOAD POINT AND LENGTH ARE PART OF THE LPDE.  OTHERWISE\n* WE NEED TO GET THE CDE EXT LIST TO GET THIS INFORMATION.\n*\n* IF THIS IS A MINOR CDE, WE HAVE TO GET TO THE MAJOR CDE TO GET THE\n* EXT LIST ADDRESS.  DO THIS IF REQUIRED.\n*\n**********************************************************************\n         SPACE\n         TM    CDATTRB,CDELPDE        IS THIS REALLY AN LPDE?\n         BO    ISLPDE                 IF SO, PROCESS AS SUCH.\n         SPACE\n         L     R2,CDXLMJP             POINT TO EXIT LIST IF MAJOR\n         TM    CDATTR,CDMIN           IS THIS A MINOR CDE\n         BZ    GOTMAJOR               IF NOT, WE GOT THE MAJOR\n         SPACE\n         MVI   MINORFLG,X'FF'         SHOW THIS IS A MINOR CDE\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS25A         ###############\n         LR    R5,R2                   ADDRESS THE MAJOR CDE\n         SPACE\n         AGO  .NPCS25A\n.IPCS25A ANOP\n         LR    R6,R2                   ADDRESS THE MAJOR CDE\n         IPCSLOAD R5,(R6),LEN=CDELEN\n         IPCSLMSG R5,R6,NOCDE,40,ZHDR4,(R10),(R9)\n         LTR   R5,R5                  DID WE GET A MAJOR CDE?\n         BZ    CDEOUT                 IF NOT, DUMP WHAT WE HAVE\n         SPACE\n.NPCS25A ANOP\n         SPACE\n         SLR   R15,R15                 REDO THE SUBPOOL\n         IC    R15,CDSP\n         CVD   R15,WORD\n         MVC   ZSUBPOOL(8),=X'4020202020202021'\n         ED    ZSUBPOOL(8),WORD+4\n         OI    ZSUBPOOL+7,X'F0'\n         SPACE\n         TM    CDATTRB,CDELPDE         IS THIS REALLY AN LPDE?\n         BO    ISLPDE                  IF SO, PROCESS AS SUCH.\n         L     R2,CDXLMJP              POINT TO EXIT LIST IN MAJOR\n         EJECT\n**********************************************************************\n*\n* ACCESS THE CDE XTLST AND GET THE RELEVANT DATA FROM IT.\n*\n**********************************************************************\n         SPACE\nGOTMAJOR DS    0H\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS26          ###############\n         USING XTLST,R2\n         SPACE\n         AGO  .NPCS26\n.IPCS26  ANOP\n         IPCSLOAD R12,(R2),LEN=XLSTLEN\n         IPCSLMSG R12,R2,NOCDEX,47,ZHDR4,(R10),(R9)\n         LTR   R12,R12                  DID WE GET A XLST\n         BZ    CDEOUT                 IF NOT, DUMP WHAT WE HAVE\n         USING XTLST,R12\n         SPACE\n.NPCS26  ANOP\n         SPACE\n         L     R15,XTLMSBAD            GET LOAD POINT\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         SPACE\n         SLR   R14,R14\n         ICM   R14,7,XTLMSBLN         GET LOAD POINT\n         ST    R14,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         SPACE\n         AR    R15,R14\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SPACE\n         CLI   MINORFLG,X'FF'         IS THE MINOR CDE FLAG SET?\n         BNE   CDEOUT                 IF NOT, WE ARE DONE\n         SPACE\n         MVC   ZOWNED(8),CDNAME      SAVE MAJOR NAME\n         SPACE\n**********************************************************************\n*\n* DUMP THE OUTPUT RECORD WITH THE CDE INFORMATION.\n*\n**********************************************************************\n         SPACE\nCDEOUT   DS    0H\n         L     R15,OPTPTR\n         CLI   CDEPRM(R15),X'FF'      CDE PARM ON?\n         BNE   NP1\n         CLI   ZRECTYPE,RECTLLE\n         BE    NP1\n         MVC   PAREA(8),ZAREA        REARANGE AREA\n         MVC   PSUBPOOL(8),ZSUBPOOL\n         MVC   PKEY(8),ZKEY\n         MVC   PPGMNAME(8),ZPGMNAME\n         MVC   PENTRYPT(8),ZENTRYPT\n         MVC   PTCBADDR(8),ZTCBADDR\n         MVC   PSHARED(8),ZSHARED\n         MVC   POWNED(8),ZOWNED\n         SPACE\n         VSMPRNT AREA24,(R9),ZHDR4\n         VSMPRNT AREA24,(R9),PHDR1\n         VSMPRNT AREA24,(R9),BUFFP\n         VSMPRNT AREA24,(R9),ZHDR4\nNP1      DS    0H\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         B     RETURN                 TRY NEXT RB\n         SPACE\n         DROP  R5\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS27          ###############\n         DROP  R2\n         AGO  .NPCS27\n.IPCS27  ANOP\n         DROP  R12\n.NPCS27  ANOP\n         EJECT\n**********************************************************************\n*\n* WE HAVE AN LPDE.  FOR IPCS, REGET THE ENTRY WITH THE NEW LENGTH.\n*\n**********************************************************************\n         SPACE\nISLPDE   DS    0H\n         MVC   ZSHARED(8),=CL8'LPDE'\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS28          ###############\n         USING LPDE,R5\n         SPACE\n         AGO  .NPCS28\n.IPCS28  ANOP\n         IPCSLOAD R5,(R6),LEN=LPDELEN\n         IPCSLMSG R5,R6,NOLPDE,41,ZHDR4,(R10),(R9)\n         LTR   R5,R5                  DID WE GET AN LPDE?\n         BZ    CDEOUT                 IF NOT, DUMP WHAT WE HAVE\n         SPACE\n         USING LPDE,R5\n.NPCS28  ANOP\n         SPACE\n**********************************************************************\n*\n* AS WITH CDE'S, LPDE'S COME IN MAJOR AND MINOR VARIETIES. TEST FOR A\n* MINOR LPDE, AND IF FOUND, GO GET THE MAJOR.\n*\n**********************************************************************\n         SPACE\n         TM    LPDEATTR,LPDEMIN    IS IT A MINOR LPDE\n         BO    MINOR               IF SO, GO GET THE MAJOR\n         SPACE\n         L     R15,LPDEXTAD        GET AREA START\n         ST    R15,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         UNPK  ZSIZE(9),LPDEXTLN(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         A     R15,LPDEXTLN\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         CLI   MINORFLG,X'FF'         IS THE MINOR CDE FLAG SET?\n         BNE   CDEOUT                 IF NOT, WE ARE DONE\n         SPACE\n         MVC   ZOWNED(8),LPDENAME\n         B     CDEOUT                 GO DUMP IT\n         SPACE\nMINOR    DS    0H\n         MVI   MINORFLG,X'FF'         SHOW THIS IS A MINOR CDE\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS28A         ###############\n         L     R5,LPDEMJP             POINT TO THE MAJOR\n         AGO  .NPCS28A\n.IPCS28A ANOP\n         L     R6,LPDEMJP             POINT TO THE MAJOR\n         IPCSLOAD R5,(R6),LEN=LPDELEN\n         IPCSLMSG R5,R6,NOLPDE,41,ZHDR4,(R10),(R9)\n         LTR   R5,R5                  DID WE GET AN LPDE?\n         BZ    CDEOUT                 IF NOT, DUMP WHAT WE HAVE\n         SPACE\n.NPCS28A ANOP\n         B     ISLPDE                 AND TRY AGAIN\n         SPACE\n         DROP  R5\n         SPACE\nRETURN   DS    0H\n         REXIT ENV=OS\n         SPACE\n         LTORG\nNOCDEX   DC    CL133' # UNABLE TO ACCESS CDE EXTLST AT DUMP ADDRESS XXX*\n               XXXXX  (PRTCDE) '\nNOLPDE   DC    CL133' # UNABLE TO ACCESS LPDE AT DUMP ADDRESS XXXXXXXX X\n               (PRTCDE) '\nNOCDE    DC    CL133' # UNABLE TO ACCESS CDE AT DUMP ADDRESS XXXXXXXX  X\n               (PRTCDE) '\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\nPHDR1    DC    CL133' CDE ADDR \u00a6 ATTRB    \u00a6 PGM AREA \u00a6 SUBPOOL  \u00a6 APF? *\n                   \u00a6 PGM NAME \u00a6 ENTRY PT \u00a6 TCB ADDR \u00a6 LPA?     \u00a6 MAJOR *\n                  \u00a6   \u00a6 '\n         SPACE\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\nWORKAREA DSECT\n         DS    26F\nAREA24   DS    XL128\nWORD     DS    D\nCALLLIST DS    8D\nOPTPTR   DS    A\nLINE     DS    CL133\nBUFFZ    DS    0CL133\n         DC    CL1' '\nZAREA    DC    CL9' '\n         DC    CL2'\u00a6 '\nZSIZE    DC    CL9' '\n         DC    CL2'\u00a6 '\nZENDADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSUBPOOL DC    CL9' '\n         DC    CL2'\u00a6 '\nZKEY     DC    CL9' '\n         DC    CL2'\u00a6 '\nZPGMNAME DC    CL9' '\n         DC    CL2'\u00a6 '\nZENTRYPT DC    CL9' '\n         DC    CL2'\u00a6 '\nZTCBADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSHARED  DC    CL9' '\n         DC    CL2'\u00a6 '\nZOWNED   DC    CL9' '\n         DC    CL2'\u00a6 '\nZRECTYPE DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\nBUFFP    DS    0CL133\n         DC    CL1' '\nPTHISCDE DC    CL9' '\n         DC    CL2'\u00a6 '\nPATTR    DC    CL9' '\n         DC    CL2'\u00a6 '\nPAREA    DC    CL9' '\n         DC    CL2'\u00a6 '\nPSUBPOOL DC    CL9' '\n         DC    CL2'\u00a6 '\nPKEY     DC    CL9' '\n         DC    CL2'\u00a6 '\nPPGMNAME DC    CL9' '\n         DC    CL2'\u00a6 '\nPENTRYPT DC    CL9' '\n         DC    CL2'\u00a6 '\nPTCBADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nPSHARED  DC    CL9' '\n         DC    CL2'\u00a6 '\nPOWNED   DC    CL9' '\n         DC    CL2'\u00a6 '\nPRECTYPE DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\nMINORFLG DS    X\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nRECT     DS    A\nCDEPTR   DS    A\nOPTR     DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nRECT     DS    A\nCDEPTR   DS    A\nCDEDUMP  DS    A\nOPTR     DS    A\n.NPCS3P  ANOP\n         SPACE 3\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IKJTCB\n         IHACDE\nCDELEN   EQU    *-CDENTRY\n         IHAXTLST\nXLSTLEN  EQU    *-XTLST\n         IHARB  LIST=YES\nRBLEN    EQU    *-RBBASIC\n         IHALPDE\nLPDELEN  EQU   *-LPDE\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         SPACE\nRECTDQE  EQU   C'1'\nRECTREG  EQU   C'2'\nRECTLPDE EQU   C'3'\nRECTCDEA EQU   C'4'\nRECTLLE  EQU   C'5'\nRECTCDEB EQU   C'6'\n         END\nDMPAQAT  TITLE 'DUMP ADDRESS DATA FROM AN AQAT INDEX TABLE'\n**********************************************************************\n*\n* SEGMENT NAME:\n*\n*    DMPAQAT -- DUMP ADDRESS DATA FROM AN AQAT INDEX TABLE\n*\n* INPUTS (*TO FUNCTIONS):\n*\n*    OUTPUT -- OUTPUT DCB (*1)\n*       THE ADDESS OF THE OUTPUT DCB IS PASSED TO THIS ROUTINE THE\n*       DCB HAS FIXED LENGTH RECORDS OF LENGTH 133.\n*\n*    AQAT -- POINTER TO THE AQAT INDEX TABLE (*1,2,3)\n*       THE SECOND PARM TO THIS ROUTINE IS A THE ADDRESS OF AN AQAT\n*       INDEX TABLE.  THIS TABLE CONTAINS 256 FULLWORD ENTRIES. EACH\n*       NONZERO ENTRY POINTS TO AN AQAT.  EACH ENTRY REPRESENTS AN 8\n*       MEG REGION OF ADDRESSES.  THERE ARE 256 * 8MEG REGIONS IN THE\n*       2 GEG ADDRESS SPACE.  A ZERO ENTRY MEANS THERE IS NO AQAT FOR\n*       THIS ENTRY AND THIS SUBPOOL HAS NO PAGES ALLOCATED IN THIS 8\n*       MEG REGION. THE AQAT HAS A 4 BYTE HEADER WITH THE CHARS AQAT\n*       IN IT.  FOLLOWING THIS ARE 6 BYTE ENTRIES CONSISTING OF A\n*       POINTER (WHICH WE ARE NOT INTERESTED IN) AND A 2 BYTE BITMAP.\n*       THE BITMAP CORRESPONDS TO 16 PAGES (64K) OF MEMORY.  THERE\n*       ARE 128 OF THESE 6 BYTE ENTRIES.\n*\n*    SUBPOOL -- SUBPOOL NUMBER (*1)\n*       THE THIRD PARM TO THIS ROUTINE IS A FULLWORD INTEGER.  THIS\n*       IS THE SUBPOOL NUMBER BEING PROCESSED.  THIS DATA IS PUT IN\n*       THE OUTPUT RECORD.\n*\n*    NAME -- NAME FOR THE PGM FIELD (*1)\n*       THE ADDRESS OF AN 8 BYTE CHARACTER STRING TO BE PUT IN THE 8\n*       BYTE PROGRAM NAME FIELD IS THE 4TH PARM TO THIS ROUTINE.\n*\n* FUNCTIONS:\n*\n*    1. LOAD THE PARM LIST INTO REGISTERS\n*\n*    2. WALK THE AQAT INDEX LOOKING FOR AQAT TABLES.\n*\n*    3. WHEN AN AQAT IS FOUND, WALK IT DUMPING THE PAGE ALLOCATION\n*       DATA\n*\n* OUTPUTS (*FROM FUNCTIONS):\n*\n*    OUTPUT -- OUTPUT DCB (*3)\n*       THE ADDESS OF THE OUTPUT DCB IS PASSED TO THIS ROUTINE THE\n*       DCB HAS FIXED LENGTH RECORDS OF LENGTH 133.\n*\n**********************************************************************\n         EJECT\n         PRINT NOGEN\nDMPAQAT  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         MVC   OPTPTR(4),OPTR\n         L     R5,AQATNADR          POINT TO THE AQAT INDX TABLE\n         L     R15,SUBPOOLP         LOAD THE SUBPOOL\n         L     R14,NAMEPRM          POINT TO NAME FOR EP\n         L     R10,OUTDCB           POINT TO THE OUTPUT DCB\n         DROP  R10\n         MVC   BUFFZ,BUFFINIT\n         MVI   ZRECTYPE,RECTDQE\n         SPACE\n**********************************************************************\n*\n* COPY THE SUBPOOL AND NAME DATA TO THE OUTPUT RECORD\n*\n**********************************************************************\n         SPACE\n         CVD   R15,WORD\n         MVC   ZSUBPOOL(8),=X'4020202020202021'\n         ED    ZSUBPOOL(8),WORD+4\n         OI    ZSUBPOOL+7,X'F0'\n         SPACE\n         MVC   ZKEY(8),=CL8'       0'  SHOW KEY ZERO\n         SPACE\n         MVC   ZPGMNAME(8),0(R14)   COPY NAME TO EP\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS01          ###############\n         EJECT\n**********************************************************************\n*\n* THE AQAT INDEX TABLE ADDRESS PASSED IN IS THE DUMP ADDRESS, CONVERT\n* IT TO THE REAL ADDRESS.\n*\n**********************************************************************\n         SPACE\n         IPCSLOAD R2,(R5),LEN=1024,PERM=HOLDAQDX\n         IPCSLMSG R2,R5,NOAQATN,47,ZHDR4,(R10),''\n         LTR   R2,R2                   DID WE GET THE AQAT INDEX.\n         BZ    RETURN                  IF NOT, FORGET IT\n         LR    R5,R2                   PUT IN THE CORRECT ADDRESS\n.NPCS01  ANOP\n         EJECT\n**********************************************************************\n*\n* TOP OF THE 8 MEG LOOP.  WALK THE AQAT INDEX TABLE LOOKING FOR\n* NONZERO ENTRIES.  THESE HAVE AQAT.\n*\n* THE AQAT INDEX TABLE CONSISTS OF 256 4 BYTE ENTRIES.  EACH ONE IS\n* EITHER ZERO OR POINTS TO AN AQAT TABLE.  EACH AQAT TABLE COVERS 8\n* MEG OF STORAGE.  EACH AQAT TABLE CONSISTS OF 128 6 BYTE ENTRIES.\n* EACH AQAT ENTRY COVERS 64K OF STORAGE.  EACH AQAT ENTRY CONTAINS A\n* 16BIT PAGE MAP TO DESCRIBE THE PAGES IN THE THE 64K OF STORAGE.\n* EACH PAGE IS OF COURSE 4K.  IF THE ZEROTH BIT IN THE ENTRY IS ONE,\n* THE FIRST PAGE OF STORAGE IN THIS 64K BLOCK IS ALLOCATED IN THIS\n* SUBPOOL CONTROLLED BY THIS AQAT TABLE. THE FIRST BIT IS FOR THE\n* NEXT BLOCK OF STORAGE, AND SO ON.\n*\n* THE STORAGE ADDRESSES COVERED ARE CALCULATED FROM THE OFFSET INTO\n* THE AQAT INDEX TABLE (TO DETERMINE WHICH 8 MEG ADDRESS RANGE) AND\n* THE OFFSET INTO THE AQAT TABLE (TO DETERMINE WHICH 64K ADDRESS\n* RANGE) AND THE BIT INDEX INTO THE AQAT TABLE ENTRY, TO DETERMINE\n* WHICH 4K PAGE WITHIN THE 64K.\n*\n*      REGISTER USAGE:\n*              R3  -  LENGTH OF ALLOCATED AREA\n*              R4  -> START OF ALLOCATED AREA\n*              R5  -> AQAT INDX TABLE\n*              R6  -  OFFSET INTO AQAT INDEX TABLE\n*              R7  -> CURRENT AQAT\n*              R8  -  AQAT ENTRY OFFSET\n*              R9  -  CURRENT BIT BEING TESTED\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R13 -> DSA AND AUTOMATIC STORAGE\n*              R14 -  WORK REGISTER\n*              R15 -  WORK REGISTER\n*\n**********************************************************************\n         SPACE\n         SLR   R6,R6                THIS AQAT START ADDR\n         SPACE\nMEG8LOOP DS    0H\n         L     R7,0(R6,R5)          LOAD AQAT TABLE ADDR\n         LTR   R7,R7                IS THERE ONE?\n         BZ    NEXTAQAT             NO, SKIP IT\n         SPACE\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS02          ###############\n         EJECT\n**********************************************************************\n*\n* THE AQAT ADDRESS IS IN THE DUMP, GET IT INTO THIS ADDRESS SPACE.\n*\n**********************************************************************\n         SPACE\n         IPCSLOAD R2,(R7),LEN=768,PERM=HOLDAQAT\n         IPCSLMSG R2,R7,NOAQAT,41,ZHDR4,(R10),''\n         LTR   R2,R2                   DID WE GET THE AQAT INDEX.\n         BZ    RETURN                  IF NOT, FORGET IT\n         LR    R7,R2                   PUT IN THE CORRECT ADDRESS\n.NPCS02  ANOP\n         LA    R7,4(,R7)            SKIP THE AQAT HEADER\n         SLR   R8,R8                START AT FIRST AQAT ENTRY\n         SLR   R3,R3                ZERO LENGTH FIELD\n         SPACE\n**********************************************************************\n*\n* THIS LOOP PROCESSES AN AQAT. R9 IS A MASK TO SHOW WHICH BIT WE ARE\n* LOOKING AT.  THE REASON WE ONLY RECALCULATE THE ADDRESS IF R3 = 0\n* IS THAT WE WANT TO ALLOW AQAT ENTRIES TO BE SPANNED.  THAT IS IF\n* THE LAST BIT IN ONE ENTRY WITHIN THE AQAT IS 1 AND SO IS THE FIRST\n* BIT IN THE NEXT AQAT ENTRY, WE WANT TO GROUP THAT DATA INTO THE\n* SAME RECORD.\n*\n* TO CALCULATE THE ADDRESS FOR THE START OF THIS ENTRY.  MULTIPLY THE\n* ZERO BASED INDEX INTO THE AQAT INDEX TABLE BY 8 MEG AND ADD IN THE\n* ZERO BASED INDEX INTO THE AQAT.  NOTE THAT SINCE R6 IS AN OFFSET\n* INCREMENTED BY 4 WE ONLY HAVE TO MULTIPLY BY 2 MEG.\n*\n**********************************************************************\n         SPACE\nAQATLOOP DS    0H\n         L     R9,=X'00008000'      START WITH THE FIRST BIT\n*        CALCULATE THE ADDRESS FOR THIS AQAT ENTRY.\n*        AQAT TABLE OFFSET/4 * 8MEG + AQAT ENTRY OFFSET/6 * 64K +\n         LTR   R3,R3                ARE WE IN THE MIDDLE OF SOMETHING?\n         BNZ   AQATBITS             IF SO, DON'T REINIT ADDR\n         SPACE\n         LR    R4,R6                AQAT INDEX TABLE OFFSET\n         SLA   R4,21                MULTIPLY BY 2 MEG\n         LR    R15,R8               AQAT OFFSET\n         SLR   R14,R14\n         D     R14,=F'6'            DIVIDE BY AQA TBL LEN\n         SLA   R15,16               MULTIPLY BY 64K\n         AR    R4,R15               GET VS ADDR FOR THIS AQAT ENTRY\n         SPACE\n**********************************************************************\n*\n* LOAD THE ALLOCATION BITS FROM THE AQAT ENTRY.  IF ZERO, WE DON'T\n* HAVE TO LOOK FURTHER.  OTHERWISE MASK OFF THE LOW HALFWROD AND TEST\n* THE CURRENT PAGE BIT AS SPECIFIED BY R9.\n*\n**********************************************************************\n         SPACE\nAQATBITS DS    0H\n         LH    R15,AQATALOC(R8,R7)  LOAD AQAT ALLOCATION BITS\n         LTR   R15,R15              ANY BITS ON AT ALL?\n         BZ    NXTAQATE             IF NOT, GO TO NEXT ENTRY IN AQAT\n         SPACE\n         N     R15,=X'0000FFFF'     TURN OFF HIGH HALFWORD\n         SPACE\n         NR    R15,R9               CHECK THE BIT\n         BZ    AQATTST              IF ZERO SEE IF ANYTHING TO OUTPUT\n         SPACE\n**********************************************************************\n*\n* THE BIT IS ON.  BUMP THE LENGTH BY 4K.  SHIFT OVER TO THE NEXT PAGE\n* BIT.  IF THE TEST BIT HAS SHIFTED OFF THE REGISTER, GO GET THE NEXT\n* AQAT ENTRY.  OTHERWISE GO BACK AND TEST THIS NEW BIT.\n*\n**********************************************************************\n         SPACE\n         A     R3,=F'4096'          PUT IN LENGTH OF PAGE\n         SRA   R9,1                 CHECK NEXT BIT\n         BNZ   AQATBITS             IF THERE IS ONE\n         B     NXTAQATE             IF NOT, GO TO THE NEXT\n         SPACE\n**********************************************************************\n*\n* THE BIT IS OFF.  SEE IF WE HAVE ACCUMULATED ANY LENGTH TO DUMP. IF\n* SO, CALL PUTIT TO WRITE THE DATA OUT. THEN BUMP THE ADDRESS BY THE\n* LENGTH OF THE ALLOCATED AREA AND ZERO OUT THE CURRENT ALLOCATED\n* LENGTH.\n*\n**********************************************************************\n         SPACE\nAQATTST  DS    0H\n         LTR   R3,R3                ANYTHING TO OUTPUT?\n         BZ    NOOUT\n         SPACE\n         BAL   R14,PUTIT            DUMP THE RECORD\n         SPACE\n         AR    R4,R3                ADD LENGTH DUMPED TO ADDRESS\n         SLR   R3,R3                ZERO OUT CURRENT LENGTH\n         SPACE\n**********************************************************************\n*\n* THE RECORD HAS BEEN OUTPUT OR THERE WAS NO DATA TO DUMP. THE\n* CURRENT BIT IS ZERO, SO BUMP THE ADDRESS BY THIS 4K. SHIFT THE TEST\n* BIT AND IF THE BIT HAS NOT SHIFTED INTO OBLIVION, TRY AGAIN.\n*\n**********************************************************************\n         SPACE\nNOOUT    DS    0H\n         A     R4,=F'4096'          ADD 4K FOR OFF BIT\n         SRA   R9,1                 CHECK NEXT BIT\n         LTR   R9,R9                ANYTHING BITS LEFT TO TEST?\n         BNZ   AQATBITS             GO TEST THEM\n         SPACE\n**********************************************************************\n*\n* POINT TO THE NEXT AQAT TABLE ENTRY.  ENTRIES ARE 6 BYTES LONG. IF\n* WE OVERFLOW THE AQAT, CHECK IF THERE IS ANYTHING WAITING FOR OUTPUT\n* AND DUMP IT.  OTHERWISE GO TO THE NEXT AQAT UNLESS THE AQAT INDEX\n* TABLE IS DONE TOO.  IN THAT CASE, WE ARE DONE.\n*\n**********************************************************************\n         SPACE\nNXTAQATE DS    0H\n         LA    R8,6(,R8)            OFFSET OF NEXT AQAT ENTRY\n         C     R8,=F'768'  '6*128'  PAST END OF AQAT?\n         BL    AQATLOOP             IF NOT, PROCESS THE ENTRY\n         SPACE\n         LTR   R3,R3                ANYTHING TO OUTPUT?\n         BZ    NEXTAQAT\n         SPACE\n         BAL   R14,PUTIT            DUMP THE RECORD\n         SPACE\n**********************************************************************\n*\n* GO TO THE NEXT AQAT TABLE.\n*\n**********************************************************************\n         SPACE\n         AR    R4,R3                ADD LENGTH DUMPED TO ADDRESS\nNEXTAQAT DS    0H\n         LA    R6,4(,R6)            NEXT AQAT OFFSET\n         C     R6,=F'1024' '4*256'  PAST THE TABLE END?\n         BL    MEG8LOOP             IF NO, TRY NEXT AQAT\n         SPACE\nRETURN   DS    0H\n         REXIT ENV=OS\n         EJECT\n**********************************************************************\n*\n* WRITE OUT A DATA RECORD. THE INTERESTING DATA IS IN R3 AND R4.\n*\n*      REGISTER USAGE:\n*              R3  -  LENGTH OF ALLOCATED AREA\n*              R4  -> START OF ALLOCATED AREA\n*              R5  -> AQAT INDX TABLE\n*              R6  -  OFFSET INTO AQAT INDEX TABLE\n*              R7  -> CURRENT AQAT\n*              R8  -  AQAT ENTRY OFFSET\n*              R9  -  CURRENT BIT BEING TESTED\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R13 -> DSA AND AUTOMATIC STORAGE\n*              R14 -  WORK REGISTER - USED BY PUT\n*              R15 -  WORK REGISTER - USED BY PUT\n*\n**********************************************************************\n         SPACE\nPUTIT    DS    0H\n         ST    R4,WORD\n         UNPK  ZAREA(9),WORD(5)\n         TR    ZAREA(8),HEXCHAR\n         MVI   ZAREA+8,C' '\n         ST    R3,WORD\n         UNPK  ZSIZE(9),WORD(5)\n         TR    ZSIZE(8),HEXCHAR\n         MVI   ZSIZE+8,C' '\n         LR    R15,R4               ADD IN LENGTH OF ADD SP REG\n         AR    R15,R3\n         ST    R15,WORD\n         UNPK  ZENDADDR(9),WORD(5)\n         TR    ZENDADDR(8),HEXCHAR\n         MVI   ZENDADDR+8,C' '\n         SPACE\n         ST    R14,WORD             WE STILL NEED R14\n         SPACE\n         PUT31 AREA24,(R10),BUFFZ\n         PUT31 AREA24,(R10),ZHDR4\n         SPACE\n         L     R14,WORD\n         BR    R14\n         EJECT\n         LTORG\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         SPACE\nNOAQAT   DC    CL133' # UNABLE TO ACCESS AQAT AT DUMP ADDRESS XXXXXXXX *\n                (DMPAQAT) '\nNOAQATN  DC    CL133' # UNABLE TO ACCESS AQAT INDEX AT DUMP ADDRESS XXX*\n               XXXXX (DMPAQAT) '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS09          ###############\nHOLDAQDX DS    4XL256\nHOLDAQAT DS    6XL128\n.NPCS09  ANOP\nLINE     DS    CL133\nBUFFZ    DS    0CL133\n         DC    CL1' '\nZAREA    DC    CL9' '\n         DC    CL2'\u00a6 '\nZSIZE    DC    CL9' '\n         DC    CL2'\u00a6 '\nZENDADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSUBPOOL DC    CL9' '\n         DC    CL2'\u00a6 '\nZKEY     DC    CL9' '\n         DC    CL2'\u00a6 '\nZPGMNAME DC    CL9' '\n         DC    CL2'\u00a6 '\nZENTRYPT DC    CL9' '\n         DC    CL2'\u00a6 '\nZTCBADDR DC    CL9' '\n         DC    CL2'\u00a6 '\nZSHARED  DC    CL9' '\n         DC    CL2'\u00a6 '\nZOWNED   DC    CL9' '\n         DC    CL2'\u00a6 '\nZRECTYPE DC    CL2' '\n         DC    CL2'\u00a6 '\n         DC    CL18' '\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\nPARMLST  DSECT\nOUTDCB   DS    A\nAQATNADR DS    A\nSUBPOOLP DS    A\nNAMEPRM  DS    A\nOPTR     DS    A\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IHALDA\n         IHAPSA\n         IHAAQAT\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\nRECTDQE  EQU   C'1'\nRECTREG  EQU   C'2'\nRECTLPDE EQU   C'3'\nRECTCDEA EQU   C'4'\nRECTLLE  EQU   C'5'\nRECTCDEB EQU   C'6'\n         END\n*\n*\n*  SPQA RUNNER\n*  PARMS:  NON-IPCS\n*          1   OUTPUT DCB  R10\n*          2   PRINT DCB   R9\n*          3   TCB         R3\n*          4   SPQE        R5\n*          5   SPQA        R6\n*  PARMS:  IPCS\n*          1   OUTPUT DCB                  R10\n*          2   PRINT DCB (DUMMY PARM)      R9\n*          3   TCB  (DUMP ADDRESS          R3\n*          4   SPQE (THIS ADDR SP COPY)    R5\n*          5   SPQA (DUMP ADDRESS)         R8\n*          6   SPQA (THIS ADDR SP COPY)    R6\n*\n*\n         PRINT    NOGEN\n         EJECT\nRUNSPQA  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n*                      OUTDCB, PRTDCB, TCB, SPQE, SPQA\n         MVC   OPTPTR(4),OPTR\n         XC    TOTCORE(4),TOTCORE  CLEAR MEMORY ALLOCATED ACCUMULATOR\n         L     R3,TCBPTR           POINT TO TCB\n         L     R5,SPQEPTR          POINT TO SPQE THIS ADDR SP\n         L     R6,SPQAPTR          POINT TO SPQA\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS71          ###############\n         AGO   .NPCS71\n.IPCS71  ANOP\n         L     R8,SPQADUMP         LOAD DUMP SPQA ADDR\n.NPCS71  ANOP\n         L     R9,PRINTDCB         POINT TO PRINT DCB\n         L     R10,OUTDCB          POINT TO OUTPUT DCB\n         SPACE\n         DROP  R10\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS72          ###############\n         LTR   R6,R6               IS THERE AN SPQA?\n         USING DQE,R7\n         SPACE\n         AGO   .NPCS72\n.IPCS72  ANOP\n         LTR   R8,R8               IS THERE AN SPQA?\n         USING DQE,R2\n         SPACE\n.NPCS72  ANOP\n         BZ    RETURN              IF NOT, FORGET IT.\n         SPACE\n**********************************************************************\n*\n*      REGISTER USAGE:   SPACE\n*              R2  -> DQE THIS ADDR SPACE (IPCS ONLY)\n*              R3  -  TCB ADDR (IPCS IS DUMP COPY)\n*              R4  -> CDE ADDR\n*              R5  -> SPQE (IPCS IN THIS ADDR SPACE)\n*              R6  -> SPQA (IPCS IN THIS ADDR SPACE)\n*              R7  -  DQE ADDR (IPCS IS ADDR FROM DUMP)\n*              R8  -  SPQA ADDR FROM DUMP (IPCS ONLY)\n*              R9  -> PRINT DCB\n*              R10 -> OUTPUT DCB\n*              R12 -  TEMP POINTER TO RUN TIME OPTIONS\n*              R11 -  PROGRAM BASE\n*              R13 -> DSA AND LOCAL VARS\n*\n**********************************************************************\n         SPACE\n         USING SPQA,R6\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS7Z\n.IPCS7Z  ANOP\n         SPACE\n         CALL  FINDCDE,((R3)),MF=(E,CALLLIST) GET THE CDE INTO R0\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS72A         ###############\n         LR    R4,R0                 SAVE CDE ADDR (OR ZERO)\n         AGO   .NPCS72A\n.IPCS72A ANOP\n         LTR   R4,R0                 PUT CDE ADDR IN ADDRESSING REG\n         BZ    NOCDE\n         SPACE\n         MVC   HOLDCDE(CDELEN),0(R4) COPY TO PERMANENT PLACE\n         LA    R4,HOLDCDE            USE THIS COPY OF THE CDE\n         SPACE\nNOCDE    DS    0H\n.NPCS72A ANOP\n         USING CDENTRY,R4\n         SPACE\n         L     R7,SPQAFBDQ\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS73          ###############\n         LA    R15,SPQAFBDQ    GET ADDR OF SPQAFBDQ\n         AGO   .NPCS73\n.IPCS73  ANOP\n         LA    R15,SPQAFBDQ-SPQA(R8)   GET DUMP ADDR OF SPQAFBDQ\n.NPCS73  ANOP\n         CR    R7,R15          IS ADDR SAME AS CONTENTS?\n         BE    DDONE1\nDLOOP1   DS    0H\n         L     R12,OPTPTR\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS74          ###############\n         CALL  DUMPDQE,((R10),0,(R3),(R4),(R5),(R7),(R12)),            X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE)\n         AGO   .NPCS74\n.IPCS74  ANOP\n         IPCSLOAD R2,(R7),LEN=DQELEN\n         IPCSLMSG R2,R7,NODQE,40,ZHDR4,(R10),(R9)\n         LTR   R2,R2\n         BZ    DDONE1\n         CALL  DUMPDQE,((R10),0,(R3),(R4),(R5),(R2),(R7),(R12)),       X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,DQEDUMP)\n.NPCS74  ANOP\n         A     R0,TOTCORE\n         ST    R0,TOTCORE\n         C     R7,SPQALBDQ\n         L     R7,DQENEXT\n         BNE   DLOOP1\n         SPACE\nDDONE1   DS    0H\n         L     R7,SPQAFADQ\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS75          ###############\n         LA    R15,SPQAFADQ    GET ADDR OF SPQAFADQ\n         AGO   .NPCS75\n.IPCS75  ANOP\n         LA    R15,SPQAFADQ-SPQA(R8)   GET DUMP ADDR OF SPQAFADQ\n.NPCS75  ANOP\n         CR    R7,R15          IS ADDR SAME AS CONTENTS?\n         BE    DDONE2\nDLOOP2   DS    0H\n         L     R12,OPTPTR\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS76          ###############\n         CALL  DUMPDQE,((R10),0,(R3),(R4),(R5),(R7),(R12)),            X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE)\n         AGO   .NPCS76\n.IPCS76  ANOP\n         IPCSLOAD R2,(R7),LEN=DQELEN\n         IPCSLMSG R2,R7,NODQE,40,ZHDR4,(R10),(R9)\n         LTR   R2,R2\n         BZ    DDONE2\n         CALL  DUMPDQE,((R10),0,(R3),(R4),(R5),(R2),(R7),(R12)),       X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,DQEDUMP)\n.NPCS76  ANOP\n         A     R0,TOTCORE\n         ST    R0,TOTCORE\n         C     R7,SPQALADQ\n         L     R7,DQENEXT\n         BNE   DLOOP2\n         SPACE\nDDONE2   DS    0H\n         L     R7,SPQAFEDQ\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS77          ###############\n         LA    R15,SPQAFEDQ    GET ADDR OF SPQAFEDQ\n         AGO   .NPCS77\n.IPCS77  ANOP\n         LA    R15,SPQAFEDQ-SPQA(R8)   GET DUMP ADDR OF SPQAFEDQ\n.NPCS77  ANOP\n         CR    R7,R15          IS ADDR SAME AS CONTENTS?\n         BE    DDONE3\nDLOOP3   DS    0H\n         L     R12,OPTPTR\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS78          ###############\n         CALL  DUMPDQE,((R10),0,(R3),(R4),(R5),(R7),(R12)),            X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE)\n         AGO   .NPCS78\n.IPCS78  ANOP\n         IPCSLOAD R2,(R7),LEN=DQELEN\n         IPCSLMSG R2,R7,NODQE,40,ZHDR4,(R10),(R9)\n         LTR   R2,R2\n         BZ    DDONE3\n         CALL  DUMPDQE,((R10),0,(R3),(R4),(R5),(R2),(R7),(R12)),       X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,DQEDUMP)\n.NPCS78  ANOP\n         A     R0,TOTCORE\n         ST    R0,TOTCORE\n         C     R7,SPQALEDQ\n         L     R7,DQENEXT\n         BNE   DLOOP3\n         SPACE\nDDONE3   DS    0H\n*        DROP  R3    TCB\n         DROP  R4    CDE\n*        DROP  R5    SPQE\n         DROP  R6    SPQA\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS79          ###############\n         DROP  R7    DQE\n         AGO   .NPCS79\n.IPCS79  ANOP\n         DROP  R2    DQE\n.NPCS79  ANOP\nRETURN   DS    0H\n         L     R0,TOTCORE\n         REXIT ENV=OS,RETURN=(0)\n         SPACE 3\nDHDR1    DC    CL133'                     \u00a6 DQE      \u00a6 AREA     \u00a6 SIZE *\n                   \u00a6 NEXT DQE \u00a6 1ST FQE  \u00a6 LAST FQE \u00a6'\nDHDR4    DC    CL133'                     +----------+----------+------*\n               ----+----------+----------+----------+'\nNODQE    DC    CL133' # UNABLE TO ACCESS DQE AT DUMP ADDRESS XXXXXXXX  *\n               (RUNSPAQ) '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\n         SPACE 3\nWORKAREA DSECT\n         DS    26F\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nTOTCORE  DS    F\nHOLDDQE  DS    XL(DQELEN)\nHOLDCDE  DS    XL(CDELEN)\nLINE     DS    CL133\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\nSPQEPTR  DS    A\nSPQAPTR  DS    A\nOPTR     DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\nSPQEPTR  DS    A\nSPQADUMP DS    A\nSPQAPTR  DS    A\nOPTR     DS    A\n.NPCS3P  ANOP\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IHACDE\nCDELEN   EQU   *-CDENTRY\n         IHADQE\nDQELEN   EQU   *-DQE\n         IKJTCB\n*        IHASPQE\n         IHASPQA\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         END\n*\n*   TCB PRINTER\n*   PARMS: NON-IPCS\n*        1  -> PRINT DCB\n*        2  -  TCB PONTER\n*   PARMS: IPCS\n*        1  -  PRINT DCB (DUMMY ARG)\n*        2  -> TCB IN THIS ADDRESS SPACE\n*        3  -  TCB ADDRESS FROM DUMP\n*\n*\n         PRINT NOGEN\nPRTTCB   RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         USING TCB,R3\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         MVC   BUFF,BUFFINIT\n         L     R9,PRINTDCB             PRINT DCB POINTER\n         L     R3,TCBPTR               TCB POINTER\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS30          ###############\n**********************************************************************\n*\n* FORMAT THE TCB ADDRESS PLUS INTERESTING DATA ABOUT THE TCB\n*\n*      REGISTER USAGE:\n*              R3  -> TCB IN THIS ADDESS SP\n*              R9  -> PRINT CDE POINTER\n*              R10 -> PASSED PARM\n*              R11 -> PROGRAM BASE\n*              R13 -> DSA\n*\n**********************************************************************\n         ST    R3,WORD\n         AGO   .NPCS30\n.IPCS30  ANOP\n**********************************************************************\n*\n* FORMAT THE TCB ADDRESS PLUS INTERESTING DATA ABOUT THE TCB\n*\n*      REGISTER USAGE:\n*              R2  -  TCB ADDRESS FROM DUMP\n*              R3  -> TCB IN THIS ADDESS SP\n*              R9  -> PRINT CDE POINTER\n*              R10 -> PASSED PARM\n*              R11 -> PROGRAM BASE\n*              R13 -> DSA\n*\n**********************************************************************\n         L     R2,TCBDUMP              TCB ADDRESS FROM DUMP\n         ST    R2,WORD\n.NPCS30  ANOP\n         L     R15,OPTPTR\n         CLI   PRTPRM(R15),X'FF'  PRINT PARM?\n         BNE   RETURN\n         SPACE\n         UNPK  THISTCB(9),WORD(5)\n         TR    THISTCB(8),HEXCHAR\n         MVI   THISTCB+8,C' '\n         UNPK  NTCB(9),TCBTCB(5)\n         TR    NTCB(8),HEXCHAR\n         MVI   NTCB+8,C' '\n         UNPK  BACK(9),TCBBACK(5)\n         TR    BACK(8),HEXCHAR\n         MVI   BACK+8,C' '\n         UNPK  JSTCB(9),TCBJSTCB(5)\n         TR    JSTCB(8),HEXCHAR\n         MVI   JSTCB+8,C' '\n         UNPK  CMP(9),TCBCMP(5)\n         TR    CMP(8),HEXCHAR\n         MVI   CMP+8,C' '\n         UNPK  OTC(9),TCBOTC(5)\n         TR    OTC(8),HEXCHAR\n         MVI   OTC+8,C' '\n         UNPK  LTC(9),TCBLTC(5)\n         TR    LTC(8),HEXCHAR\n         MVI   LTC+8,C' '\n         SPACE\n         MVC   TCBCDE(8),=CL8' '\n         MVC   TCBEP(8),=CL8' '\n         SPACE\n**********************************************************************\n*\n* FIND THE CDE TO GET THE NAME AND ENTRY POINT DATA\n*\n**********************************************************************\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS31          ###############\n         CALL  FINDCDE,((R3)),MF=(E,CALLLIST) GET THE CDE IN R0\n         AGO   .NPCS31\n.IPCS31  ANOP\n         CALL  FINDCDE,((R2)),MF=(E,CALLLIST) GET THE CDE IN R0\n.NPCS31  ANOP\n         LTR   R0,R0                 DID WE FIND A CDE?\n         BZ    TCBPRINT              IF NOT, LEAVE THE DATA BLANK\n         SPACE\n         LR    R14,R0                PUT CDE ADDR IN A GOOD REG\n         USING CDENTRY,R14\n         SPACE\nGOTCDE   DS    0H\n         MVC   TCBCDE(8),CDNAME      PUT IN THE PROGRAM NAME\n         UNPK  TCBEP(9),CDENTPT(5)\n         TR    TCBEP(8),HEXCHAR\n         MVI   TCBEP+8,C' '\n         DROP  R14\n         SPACE\nTCBPRINT DS    0H\n         VSMPRNT AREA24,(R9),HDR4\n         VSMPRNT AREA24,(R9),HDR3\n         VSMPRNT AREA24,(R9),BUFF\n         VSMPRNT AREA24,(R9),HDR4\n         SPACE\n         DROP  R3,R10\nRETURN   DS    0H\n         REXIT ENV=OS\n         SPACE\n         LTORG\n         SPACE\nHDR3     DC    CL133' TCB      \u00a6 TCBTCB   \u00a6 TCBBACK  \u00a6 PGM NAME \u00a6 ENTRY*\n                PT \u00a6 TCBCMP   \u00a6 TCBOTC   \u00a6 TCBLTC   \u00a6 TCBJSTCB \u00a6'\nHDR4     DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+'\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL33' '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nLINE     DS    CL133\nBUFF     DS    0CL133\n         DC    CL1' '\nTHISTCB  DC    CL9' '\n         DC    CL2'\u00a6 '\nNTCB     DC    CL9' '\n         DC    CL2'\u00a6 '\nBACK     DC    CL9' '\n         DC    CL2'\u00a6 '\nTCBCDE   DC    CL9' '\n         DC    CL2'\u00a6 '\nTCBEP    DC    CL9' '\n         DC    CL2'\u00a6 '\nCMP      DC    CL9' '\n         DC    CL2'\u00a6 '\nOTC      DC    CL9' '\n         DC    CL2'\u00a6 '\nLTC      DC    CL9' '\n         DC    CL2'\u00a6 '\nJSTCB    DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL33' '\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nPRINTDCB DS    A\nOPTR     DS    A\nTCBPTR   DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nPRINTDCB DS    A\nOPTR     DS    A\nTCBPTR   DS    A\nTCBDUMP  DS    A\n.NPCS3P  ANOP\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IKJTCB\n         IHACDE\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         END\n*\n*\n*  SPQE PRINTER\n*\n*\n*   PARMS: NON-IPCS\n*        1  -> PRINT DCB\n*        2  -  SPQE TO PRINT\n*   PARMS: IPCS\n*        1  -  PRINT DCB (DUMMY ARG)\n*        2  -  SPQE IN MEMORY\n*        3  -> SPQE ADDR IN DUMP\n*\n*\nPRTSPQE  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         MVC   BUFFS,BUFFINIT\n         L     R9,PRINTDCB      POINT TO SYSPRINT DCB\n         L     R5,SPQEPTR       POINT TO SPQE\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS50          ###############\n         L     R7,SPQEDUMP      LOAD SPQE DUMP ADDRESS\n         DROP  R10\n         SPACE\n.NPCS50  ANOP\n         L     R15,OPTPTR\n         CLI   PRTPRM(R15),X'FF'  PRINT PARM?\n         BNE   RETURN\n         SPACE\n         USING SPQE,R5\n         LTR   R5,R5\n         BZ    RETURN\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS51          ###############\n         ST    R5,WORD\n         AGO   .NPCS51\n.IPCS51  ANOP\n         ST    R7,WORD\n.NPCS51  ANOP\n         UNPK  THISSPQE(9),WORD(5)\n         TR    THISSPQE(8),HEXCHAR\n         MVI   THISSPQE+8,C' '\n         UNPK  SPQAPTR(9),SPQESPQA(5)\n         TR    SPQAPTR(8),HEXCHAR\n         MVI   SPQAPTR+8,C' '\n         SLR   R15,R15\n         IC    R15,SPQEID\n         CVD   R15,WORD\n         MVC   SUBPOOL(8),=X'4020202020202021'\n         ED    SUBPOOL(8),WORD+4\n         OI    SUBPOOL+7,X'F0'\n         IC    R15,SPQEKEY\n         SRL   R15,4\n         CVD   R15,WORD\n         MVC   KEY(8),=X'4020202020202021'\n         ED    KEY(8),WORD+4\n         OI    KEY+7,X'F0'\n         MVC   SPQEF(8),=CL8' '\n         MVC   WORD(1),SPQEFLGS\n         UNPK  SPQEF+6(3),WORD(2)\n         TR    SPQEF+6(2),HEXCHAR\n         MVI   SPQEF+8,C' '\n         VSMPRNT AREA24,(R9),SHDR4\n         VSMPRNT AREA24,(R9),SHDR1\n         VSMPRNT AREA24,(R9),BUFFS\n         VSMPRNT AREA24,(R9),SHDR4\n         DROP  R5    SPQE\nRETURN   DS    0H\n         REXIT ENV=OS\n         SPACE\n         LTORG\n         SPACE\nSHDR1    DC    CL133'          \u00a6 SUBPOOL  \u00a6 KEY      \u00a6 SPQE     \u00a6 SPQA *\n                   \u00a6 FLAGS    \u00a6          \u00a6          \u00a6'\nSHDR4    DC    CL133'          +----------+----------+----------+------*\n               ----+----------+----------+----------+'\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL44' '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nLINE     DS    CL133\nBUFFS    DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\nSUBPOOL  DC    CL9' '\n         DC    CL2'\u00a6 '\nKEY      DC    CL9' '\n         DC    CL2'\u00a6 '\nTHISSPQE DC    CL9' '\n         DC    CL2'\u00a6 '\nSPQAPTR  DC    CL9' '\n         DC    CL2'\u00a6 '\nSPQEF    DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL44' '\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nPRINTDCB DS    A\nSPQEPTR  DS    A\nOPTR     DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nPRINTDCB DS    A\nSPQEPTR  DS    A\nSPQEDUMP DS    A\nOPTR     DS    A\n.NPCS3P  ANOP\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IHASPQE\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         END\n*\n*\n*  SPQA PRINTER\n*\n*\n*   PARMS: NON-IPCS\n*        1  -> PRINT DCB\n*        2  -  SPQA TO PRINT\n*   PARMS: IPCS\n*        1  -  PRINT DCB (DUMMY ARG)\n*        2  -  SPQA IN MEMORY\n*        3  -> SPQA ADDR IN DUMP\n*\n*\nPRTSPQA  RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         MVC   BUFFA,BUFFINIT\n         L     R9,PRINTDCB      POINT TO SYSPRINT DCB\n         L     R6,SPQAPTR       POINT TO SPQA\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS50          ###############\n         L     R8,SPQADUMP      LOAD SPQA DUMP ADDRESS\n.NPCS50  ANOP\n         L     R15,OPTPTR\n         CLI   PRTPRM(R15),X'FF'  PRINT PARM?\n         BNE   RETURN\n         SPACE\n         USING SPQA,R6\n         LTR   R6,R6\n         BZR   R14\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS61          ###############\n         ST    R6,WORD\n         AGO   .NPCS61\n.IPCS61  ANOP\n         ST    R8,WORD\n.NPCS61  ANOP\n         DROP  R10\n         SPACE\n         UNPK  THISSPQA(9),WORD(5)\n         TR    THISSPQA(8),HEXCHAR\n         MVI   THISSPQA+8,C' '\n         UNPK  FBDQE(9),SPQAFBDQ(5)\n         TR    FBDQE(8),HEXCHAR\n         MVI   FBDQE+8,C' '\n         UNPK  LBDQE(9),SPQALBDQ(5)\n         TR    LBDQE(8),HEXCHAR\n         MVI   LBDQE+8,C' '\n         UNPK  FADQE(9),SPQAFADQ(5)\n         TR    FADQE(8),HEXCHAR\n         MVI   FADQE+8,C' '\n         UNPK  LADQE(9),SPQALADQ(5)\n         TR    LADQE(8),HEXCHAR\n         MVI   LADQE+8,C' '\n         UNPK  FEDQE(9),SPQAFEDQ(5)\n         TR    FEDQE(8),HEXCHAR\n         MVI   FEDQE+8,C' '\n         UNPK  LEDQE(9),SPQALEDQ(5)\n         TR    LEDQE(8),HEXCHAR\n         MVI   LEDQE+8,C' '\n         VSMPRNT AREA24,(R9),AHDR1\n         VSMPRNT AREA24,(R9),BUFFA\n         VSMPRNT AREA24,(R9),AHDR4\n         DROP  R6    SPQA\n         SPACE\nRETURN   DS    0H\n         REXIT ENV=OS\n         SPACE\n         LTORG\n         SPACE\nAHDR1    DC    CL133'          \u00a6 SPQA     \u00a6 F L DQE  \u00a6 L L DQE  \u00a6 F H  *\n               DQE \u00a6 L H DQE  \u00a6 F E DQE  \u00a6 L E DQE  \u00a6'\nAHDR4    DC    CL133'          +----------+----------+----------+------*\n               ----+----------+----------+----------+'\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL44' '\n         SPACE\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nLINE     DS    CL133\nBUFFA    DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\nTHISSPQA DC    CL9' '\n         DC    CL2'\u00a6 '\nFBDQE    DC    CL9' '\n         DC    CL2'\u00a6 '\nLBDQE    DC    CL9' '\n         DC    CL2'\u00a6 '\nFADQE    DC    CL9' '\n         DC    CL2'\u00a6 '\nLADQE    DC    CL9' '\n         DC    CL2'\u00a6 '\nFEDQE    DC    CL9' '\n         DC    CL2'\u00a6 '\nLEDQE    DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL44' '\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nPRINTDCB DS    A\nSPQAPTR  DS    A\nOPTR     DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nPRINTDCB DS    A\nSPQAPTR  DS    A\nSPQADUMP DS    A\nOPTR     DS    A\n.NPCS3P  ANOP\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IHASPQA\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         END\n*\n*\n*  SPQE RUNNER\n*\n*\n*   PARMS: NON-IPCS\n*        1  -> OUTPUT DCB\n*        2  -> PRINT DCB\n*        3  -  TCB ADDRESS\n*   PARMS: IPCS\n*        1  -> OUTPUT DCB\n*        2  -> PRINT DCB  (DUMMY ARG)\n*        3  -  TCB ADDRESS\n*        4  -> TCB ADDR IN DUMP\n*\n*\n         PRINT NOGEN\nSPQES    RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         L     R9,PRINTDCB       LOAD SYSPRINT DCB ADDR\n         L     R3,TCBPTR         LOAD TCB ADDRESS\n         AIF   ('&SYSPARM' NE 'IPCS').NPCS40          ###############\n         L     R2,TCBDUMP        LOAD DUMP TCB ADDRESS\n.NPCS40  ANOP\n         L     R10,OUTDCB        LOAD OUTPUT DCB ADDRESS\n         DROP  R10\n         EJECT\n**********************************************************************\n*\n*      REGISTER USAGE:\n*              R2  -  IPCS ONLY, THE TCB ADDRESS IN THE DUMP\n*              R3  -> TCB\n*              R5  -> SPQE ADDRESS, IPCS -> ADDRESS IN THE DUMP\n*              R6  -> SPQA ADDRESS, IPCS -> ADDRESS IN THE DUMP\n*              R7  -> IPCS ONLY, POINTS TO SPQE IN THIS ADDRESS SPACE\n*              R8  -> IPCS ONLY, POINTS TO SPQA IN THIS ADDRESS SPACE\n*              R9  -> PRINT DCB\n*              R10 -> OUTPUT DCB\n*              R11 -  PROGRAM BASE\n*              R12 -  TEMP VAR TO HOLD ADDR OF RUN TIME OPTIONS\n*\n**********************************************************************\n         SPACE\n         USING TCB,R3\n*        VSMPRNT AREA24,(R9),HDR4\n         L     R12,OPTPTR\n         CALL  PRTTCB,((R9),(R12),(R3),(R2)),MF=(E,CALLLIST)\n         SPACE\n*        VSMPRNT AREA24,(R9),SHDR4\n         SLR   R6,R6\n         L     R5,TCBMSS\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS41          ###############\n         USING SPQE,R5\n         AGO   .NPCS41\n.IPCS41  ANOP\n         USING SPQE,R7\n.NPCS41  ANOP\nSLOOP4   DS    0H\n         LTR   R5,R5           ANY MORE SPQE'S (COULD BE ZERO)\n         BZ    SDONE4          NO MORE, LEAVE LOOP\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS43          ###############\n         L     R12,OPTPTR\n         CALL  PRTSPQE,((R9),(R5),(R12)),MF=(E,CALLLIST)\n         L     R6,SPQESPQA\n         SPACE\n*        CALL  PRTSPQA,((R9),(R6),(R12)),MF=(E,CALLLIST)\n         CALL  RUNSPQA,((R10),(R9),(R3),(R5),(R6),(R12)),              X\n               MF=(E,CALLLIST)\n         AGO   .NPCS43\n.IPCS43  ANOP\n         IPCSLOAD R7,(R5),LEN=SPQELEN,PERM=SPQEHOLD\n         IPCSLMSG R7,R5,NOSPQE,41,ZHDR4,(R10),(R9)\n         LTR      R7,R7\n         BZ       SDONE4       CAN'T GET THE SPQE, LEAVE THE LOOP\n         SPACE\n         L     R12,OPTPTR\n         CALL  PRTSPQE,((R9),(R7),(R5),(R12)),MF=(E,CALLLIST)\n         L     R6,SPQESPQA\n         IPCSLOAD R8,(R6),LEN=SPQALEN,PERM=SPQAHOLD\n         IPCSLMSG R8,R6,NOSPQA,41,ZHDR4,(R10),(R9)\n         LTR      R8,R8\n         BZ       SDONE4       CAN'T GET THE SPQA, LEAVE THE LOOP\n         CALL  RUNSPQA,((R10),(R9),(R2),(R7),(R6),(R8),(R12)),         X\n               MF=(E,CALLLIST)\n.NPCS43  ANOP\n         SPACE\n         CLI   PRTPRM(R12),X'FF'  PRINT OPTION?\n         BNE   SNEXT4\n         SPACE\n         MVC   LINE(133),BUFFINIT\n         ST    R0,WORD\n         UNPK  LINE+12(9),WORD(5)\n         TR    LINE+12(8),HEXCHAR\n         MVI   LINE+20,C' '\n         VSMPRNT AREA24,(R9),LINE\n         VSMPRNT AREA24,(R9),SHDR4\n         SPACE\nSNEXT4   DS    0H\n         L     R5,SPQENEXT     NEXT SPQE\n         B     SLOOP4\n         SPACE\nSDONE4   DS    0H\n         L     R5,TCBUKYSP\nSLOOP5   DS    0H\n         LTR   R5,R5           ANY MORE SPQE'S (COULD BE ZERO)\n         BZ    SDONE5          NO MORE, LEAVE LOOP\n         SPACE\n         L     R12,OPTPTR\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS45          ###############\n         CALL  PRTSPQE,((R9),(R5),(R12)),MF=(E,CALLLIST)\n         L     R6,SPQESPQA\n         SPACE\n*        CALL  PRTSPQA,((R9),(R6),(R12)),MF=(E,CALLLIST)\n         CALL  RUNSPQA,((R10),(R9),(R3),(R5),(R6),(R12)),              X\n               MF=(E,CALLLIST)\n         AGO   .NPCS45\n.IPCS45  ANOP\n         IPCSLOAD R7,(R5),LEN=SPQELEN,PERM=SPQEHOLD\n         IPCSLMSG R7,R5,NOSPQE,41,ZHDR4,(R10),(R9)\n         LTR      R7,R7\n         BZ       SDONE5          CANT GET THE SPQE, LEAVE LOOP\n         SPACE\n         CALL  PRTSPQE,((R9),(R7),(R5),(R12)),MF=(E,CALLLIST)\n         L     R6,SPQESPQA\n         SPACE\n         IPCSLOAD R8,(R6),LEN=SPQALEN,PERM=SPQAHOLD\n         IPCSLMSG R8,R6,NOSPQA,41,ZHDR4,(R10),(R9)\n         LTR      R8,R8\n         BZ       SDONE5       CAN'T GET THE SPQA, LEAVE THE LOOP\n         CALL  RUNSPQA,((R10),(R9),(R2),(R7),(R6),(R8),(R12)),         X\n               MF=(E,CALLLIST)\n         SPACE\n.NPCS45  ANOP\n         CLI   PRTPRM(R12),X'FF'  PRINT OPTION?\n         BNE   SNEXT5\n         SPACE\n         MVC   LINE,BUFFINIT\n         ST    R0,WORD\n         UNPK  LINE+12(9),WORD(5)\n         TR    LINE+12(8),HEXCHAR\n         MVI   LINE+20,C' '\n         VSMPRNT AREA24,(R9),LINE\n         VSMPRNT AREA24,(R9),SHDR4\n         SPACE\nSNEXT5   DS    0H\n         L     R5,SPQENEXT     NEXT SPQE\n         B     SLOOP5\n         SPACE\nSDONE5   DS    0H\n         L     R5,TCBSWA\nSLOOP6   DS    0H\n         LTR   R5,R5           ANY MORE SPQE'S (COULD BE ZERO)\n         BZ    SDONE6          NO MORE, LEAVE LOOP\n         SPACE\n         L     R12,OPTPTR\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS47          ###############\n         CALL  PRTSPQE,((R9),(R5),(R12)),MF=(E,CALLLIST)\n         L     R6,SPQESPQA\n         SPACE\n         CALL  PRTSPQA,((R9),(R6),(R12)),MF=(E,CALLLIST)\n         CALL  RUNSPQA,((R10),(R9),(R3),(R5),(R6),(R12)),              X\n               MF=(E,CALLLIST)\n         AGO   .NPCS47\n.IPCS47  ANOP\n         IPCSLOAD R7,(R5),LEN=SPQELEN,PERM=SPQEHOLD\n         IPCSLMSG R7,R5,NOSPQE,41,ZHDR4,(R10),(R9)\n         LTR      R7,R7\n         BZ       SDONE6          CANT GET THE SPQE, LEAVE LOOP\n         SPACE\n         CALL  PRTSPQE,((R9),(R7),(R5)),MF=(E,CALLLIST)\n         L     R6,SPQESPQA\n         SPACE\n         IPCSLOAD R8,(R6),LEN=SPQALEN,PERM=SPQAHOLD\n         IPCSLMSG R8,R6,NOSPQA,41,ZHDR4,(R10),(R9)\n         LTR      R8,R8\n         BZ       SDONE6       CAN'T GET THE SPQA, LEAVE THE LOOP\n*        CALL  PRTSPQA,((R9),(R6),(R8),(R12)),MF=(E,CALLLIST)\n         CALL  RUNSPQA,((R10),(R9),(R2),(R7),(R6),(R8),(R12)),         X\n               MF=(E,CALLLIST)\n         SPACE\n.NPCS47  ANOP\n         CLI   PRTPRM(R12),X'FF'  PRINT OPTION?\n         BNE   SNEXT6\n         SPACE\n         MVC   LINE,BUFFINIT\n         ST    R0,WORD\n         UNPK  LINE+12(9),WORD(5)\n         TR    LINE+12(8),HEXCHAR\n         MVI   LINE+20,C' '\n         VSMPRNT AREA24,(R9),LINE\n         VSMPRNT AREA24,(R9),SHDR4\n         SPACE\nSNEXT6   DS    0H\n         L     R5,SPQENEXT     NEXT SPQE\n         B     SLOOP6\n         SPACE\nSDONE6   DS    0H\n         SPACE\n         DROP  R3 TCB\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS49          ###############\n         DROP  R5    SPQE\n         AGO   .NPCS49\n.IPCS49  ANOP\n         DROP  R7    SPQE\n.NPCS49  ANOP\nRETURN   DS    0H\n         REXIT ENV=OS\n         SPACE\n         LTORG\n         SPACE\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\n         SPACE\nHDR4     DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+ '\n         SPACE\nSHDR4    DC    CL133'          +----------+----------+----------+------*\n               ----+----------+----------+----------+'\n         SPACE\nBUFFINIT DS    0CL133\n         DC    CL1' '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' BYTES '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL9' '\n         DC    CL2'\u00a6 '\n         DC    CL44' '\n         SPACE\n         SPACE\nNOSPQE   DC    CL133' # UNABLE TO ACCESS SPQE AT DUMP ADDRESS XXXXXXXX *\n               (SPQES)   '\nNOSPQA   DC    CL133' # UNABLE TO ACCESS SPQA AT DUMP ADDRESS XXXXXXXX *\n               (SPQES)   '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nSPQEHOLD DS    XL(SPQELEN)\nSPQAHOLD DS    XL(SPQELEN)\nLINE     DS    CL133\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS3P          ###############\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\n         DS    A           NOT USED\nOPTR     DS    A\n         AGO   .NPCS3P\n.IPCS3P  ANOP\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nTCBPTR   DS    A\nTCBDUMP  DS    A\nOPTR     DS    A\n.NPCS3P  ANOP\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IHASPQE\nSPQELEN  EQU   *-SPQE\n         IHASPQA\nSPQALEN  EQU   *-SPQA\n         IKJTCB\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         END\n*\n*\n*  SPT  RUNNER\n*\n*\n*   PARMS:\n*        1  -> OUTPUT DCB\n*        2  -> PRINT DCB\n*\n*\n         PRINT NOGEN\nRUNSPT   RENTR BASE=11,ENV=OS,PARM=(10,PARMLST),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         MVC   OPTPTR(4),OPTR\n         L     R9,PRINTDCB          POINT TO PRINT DCB\n         L     R10,OUTDCB           POINT TO OUTPUT DCB\n         DROP  R10\n         MVC   FAKECDE(FAKECDEL),FAKECDEI\n         MVC   FAKESPQE(FAKSPQEL),FAKSPQEI\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS11          ###############\n         USING PSA,0\n         SPACE\n         L     R1,FLCCVT            POINT TO THE CVT\n         DROP  R0\n         USING CVT,R1               ADDRESS THE CVT\n         SPACE\n         L     R1,CVTGDA            POINT TO THE GDA\n         DROP  R1\n         USING GDA,R1               ADDRESS THE GDA\n         SPACE\n         L     R6,GDASPT\n         DROP  R1\n         USING DQE,R7\n         SPACE\n         AGO   .NPCS11\n.IPCS11  ANOP\n         L     R1,ADPLDSA(,R13)     GET THE ADPL ADDRESS PASSED\n         USING ABDPL,R1\n         L     R1,ADPLCVT           POINT TO THE CVT FOR THE DUMP\n         DROP  R1\n         USING CVT,R1               ADDRESS THE CVT\n         SPACE\n         L     R3,CVTGDA            POINT TO THE GDA IN THE DUMP\n         DROP  R1\n         IPCSLOAD R2,(R3),LEN=GDALEN\n         IPCSLMSG R2,R3,NOGDA,40,ZHDR4,(R10),(R9)\n         LTR   R2,R2                DID WE GET IT?\n         BZ    RETURN\n         SPACE\n         USING GDA,R2               ADDRESS THE GDA\n         SPACE\n         L     R4,GDASPT\n         DROP  R2                   DROP THE GDA\n         IPCSLOAD R6,(R4),LEN=SPTLEN,PERM=HOLDSPT\n         IPCSLMSG R6,R4,NOSPT,40,ZHDR4,(R10),(R9)\n         LTR   R6,R6                DID WE GET IT?\n         BZ    RETURN\n         SPACE\n         USING DQE,R2\n         SPACE\n.NPCS11  ANOP\n         USING SPT,R6\n         SPACE\n         LA    R6,SPTNTRY\n         LA    R4,SPTNTRY-SPT(,R4)  BUMP DUMP ADDRESS\n         DROP  R6\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS1Z\n         L     R15,OPTPTR\n         CLI   PRTPRM(R15),X'FF'  PRINT PARM?\n         BNE   SKIPDH\n         SPACE\n         VSMPRNT AREA24,(R9),DHDR1\n         VSMPRNT AREA24,(R9),DHDR4\nSKIPDH   DS    0H\n.IPCS1Z  ANOP\n         SPACE\n         MVC   FCDENAM(8),=CL8'SPT CSA '\n         SLR   R8,R8\n         EJECT\n**********************************************************************\n*\n* TOP LOOP ZERO\n*\n* THIS OUTER LOOP IS EXECUTED FOR EACH SUBPOOL IN THE SPT. THAT IS,\n* IT IS EXECUTED 4 TIMES.\n*\n*      REGISTER USAGE:\n*              R2  -> DQE IN THIS ADDR SP (IPCS ONLY)\n*              R4  -  SPT ENTRY ADDRESS IN DUMP (IPCS ONLY)\n*              R5  -\n*              R6  -> CURRENT ENTRY IN THE SPT\n*              R7  -  DQE ADDRESS (FOR IPCS THIS IS THE DUMP ADDRESS)\n*              R8  -  SUBPOOL TABLE INDEX (BUMPED BY 4 EACH VLOOP00)\n*              R9  -> PRINT DCB\n*              R10 -> OUTPUT DCB\n*              R11 -> PROGRAM BASE\n*              R12 -  TEMP HOLDER FOR POINTER TO RUN TIME PARMS\n*\n**********************************************************************\n         SPACE\nVLOOP00  DS    0H\n         L     R15,SUBNAMES(R8)\n         STH   R15,FSPID\n         SLR   R5,R5                 START KEY COUNT\n         STC   R5,FSPKEY          SAVE KEY IN FAKE SPQE\n         SPACE\nVLOOP0   DS    0H\n         SPACE\n         L     R7,SPTFBDQE(,R6)  POINT TO FIRST DQE BACKED BELOW 16 MEG\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS1A          ###############\n         LA    R15,SPTFBDQE(,R6) GET ADDR OF SPTFBDQ\n         AGO   .NPCS1A\n.IPCS1A  ANOP\n         LA    R15,SPTFBDQE(,R4) FIRST DQE IN DUMP BACKED BELOW16 MEG\n.NPCS1A  ANOP\n         CR    R7,R15          IS ADDR SAME AS CONTENTS?\n         BE    VDONE1\nVLOOP1   DS    0H\n         L     R12,OPTPTR\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS12          ###############\n         CALL  DUMPDQE,((R10),0,0,FAKECDE,FAKESPQE,(R7),(R12)),        X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,OPTIONS)\n         AGO   .NPCS12\n.IPCS12  ANOP\n         IPCSLOAD R2,(R7),LEN=DQELEN\n         IPCSLMSG R2,R7,NODQE,40,ZHDR4,(R10),(R9)\n         LTR   R2,R2\n         BZ    VDONE1\n         CALL  DUMPDQE,((R10),0,0,FAKECDE,FAKESPQE,(R2),(R7),(R12)),   X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,OPTIONS)\n.NPCS12  ANOP\n         L     R15,=X'00000FFF'   MASK FOR < 4096 BITS\n         N     R15,DQESIZE        SIZE BETTER BE MULTIPLE OF 4096\n         BZ    VDQEOK1            ALL ZEROS IS WHAT WE WANT\n         SPACE\n         SLR   R15,R15            MAKE MACRO WORK IN ODD CASE\n         IPCSLMSG R15,R7,BADDQE,32,ZHDR4,(R10),(R9)\n         B     VDONE1\n         SPACE\nVDQEOK1  DS    0H\n         C     R7,SPTLBDQE(,R6)\n         L     R7,DQENEXT\n         BNE   VLOOP1\n         SPACE\nVDONE1   DS    0H\n         L     R7,SPTFADQE(,R6)\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS1B          ###############\n         LA    R15,SPTFADQE(,R6)   FIRST DQE BACKED ANYWHERE\n         AGO   .NPCS1B\n.IPCS1B  ANOP\n         LA    R15,SPTFADQE(,R4) FIRST DQE BACKED ANYWHERE IN DUMP\n.NPCS1B  ANOP\n         CR    R7,R15          IS ADDR SAME AS CONTENTS?\n         BE    VDONE2\nVLOOP2   DS    0H\n         L     R12,OPTPTR\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS13          ###############\n         CALL  DUMPDQE,((R10),0,0,FAKECDE,FAKESPQE,(R7),(R12)),        X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,OPTIONS)\n         AGO   .NPCS13\n.IPCS13  ANOP\n         IPCSLOAD R2,(R7),LEN=DQELEN\n         IPCSLMSG R2,R7,NODQE,40,ZHDR4,(R10),(R9)\n         LTR   R2,R2\n         BZ    VDONE2\n         CALL  DUMPDQE,((R10),0,0,FAKECDE,FAKESPQE,(R2),(R7),(R12)),   X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,OPTIONS)\n.NPCS13  ANOP\n         L     R15,=X'00000FFF'   MASK FOR < 4096 BITS\n         N     R15,DQESIZE        SIZE BETTER BE MULTIPLE OF 4096\n         BZ    VDQEOK2            ALL ZEROS IS WHAT WE WANT\n         SPACE\n         SLR   R15,R15            MAKE MACRO WORK IN ODD CASE\n         IPCSLMSG R15,R7,BADDQE,32,ZHDR4,(R10),(R9)\n         B     VDONE2\n         SPACE\nVDQEOK2  DS    0H\n         C     R7,SPTLADQE(,R6)\n         L     R7,DQENEXT\n         BNE   VLOOP2\n         SPACE\nVDONE2   DS    0H\n         L     R7,SPTFEDQE(,R6)\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS1C          ###############\n         LA    R15,SPTFEDQE(,R6)   FIRST EXTENDED DQE\n         AGO   .NPCS1C\n.IPCS1C  ANOP\n         LA    R15,SPTFEDQE(,R4)   FIRST EXTENDED DQE IN DUMP\n.NPCS1C  ANOP\n         CR    R7,R15          IS ADDR SAME AS CONTENTS?\n         BE    VDONE3\nVLOOP3   DS    0H\n         L     R12,OPTPTR\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS14          ###############\n         CALL  DUMPDQE,((R10),0,0,FAKECDE,FAKESPQE,(R7),(R12)),        X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,OPTIONS)\n         AGO   .NPCS14\n.IPCS14  ANOP\n         IPCSLOAD R2,(R7),LEN=DQELEN\n         IPCSLMSG R2,R7,NODQE,40,ZHDR4,(R10),(R9)\n         LTR   R2,R2\n         BZ    VDONE3\n         CALL  DUMPDQE,((R10),0,0,FAKECDE,FAKESPQE,(R2),(R7),(R12)),   X\n               MF=(E,CALLLIST)\n*        CALL  DUMPDQE,(DCBD,DCBP,TCB,CDE,SPQE,DQE,OPTIONS)\n.NPCS14  ANOP\n         L     R15,=X'00000FFF'   MASK FOR < 4096 BITS\n         N     R15,DQESIZE        SIZE BETTER BE MULTIPLE OF 4096\n         BZ    VDQEOK3            ALL ZEROS IS WHAT WE WANT\n         SPACE\n         SLR   R15,R15            MAKE MACRO WORK IN ODD CASE\n         IPCSLMSG R15,R7,BADDQE,32,ZHDR4,(R10),(R9)\n         B     VDONE3\n         SPACE\nVDQEOK3  DS    0H\n         C     R7,SPTLEDQE(,R6)\n         L     R7,DQENEXT\n         BNE   VLOOP3\n         SPACE\nVDONE3   DS    0H\n         LA    R6,24(,R6)         NEXT SPT ENTRY?\n         LA    R4,24(,R4)         NEXT SPT ENTRY DUMP ADDRESS (IPCS)\n         LA    R5,1(,R5)          BUMP KEY\n         SLL   R5,4               PUT IN HIGH BITS OF BYTE\n         STC   R5,FSPKEY          SAVE KEY IN FAKE SPQE\n         SRL   R5,4               PUT BACK WHERE IT BELONGS\n         C     R5,=F'16'          PAST LAST KEY?\n         BL    VLOOP0             IF NOT, NEXT KEY THIS SUBPOOL\n         SPACE\n         LA    R8,4(,R8)          NEXT SUBPOOL\n         C     R8,=F'16'          PAST 4TH SUBPOOL\n         BL    VLOOP00\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCS15\n         DROP  R7\n         AGO   .NPCS15\n.IPCS15  ANOP\n         DROP  R2\n.NPCS15  ANOP\n         SPACE\nRETURN   DS    0H\n         REXIT ENV=OS\nSUBNAMES DC    F'227',F'228',F'231',F'241'\nFAKECDEI DC    XL8'00'\n         DC    CL8' '\n         DC    XL8'00'\nFAKECDEL EQU   *-FAKECDEI\nFAKSPQEI DC    4F'0'\n         DC    H'0'\n         DC    X'FF'\n         DC    X'00'\nFAKSPQEL EQU   *-FAKSPQEI\n         SPACE\n         LTORG\n         SPACE\nDHDR1    DC    CL133'                     \u00a6 DQE      \u00a6 AREA     \u00a6 SIZE *\n                   \u00a6 NEXT DQE \u00a6 1ST FQE  \u00a6 LAST FQE \u00a6'\nDHDR4    DC    CL133'                     +----------+----------+------*\n               ----+----------+----------+----------+'\n         SPACE\nNOGDA    DC    CL133' # UNABLE TO ACCESS GDA AT DUMP ADDRESS XXXXXXXX  *\n               (RUNSPT)  '\nNOSPT    DC    CL133' # UNABLE TO ACCESS SPT AT DUMP ADDRESS XXXXXXXX  *\n               (RUNSPT)  '\nNODQE    DC    CL133' # UNABLE TO ACCESS DQE AT DUMP ADDRESS XXXXXXXX  *\n               (RUNSPT)  '\nBADDQE   DC    CL133' # INVALID DQE FOUND AT ADDRESS XXXXXXXX SIZE NOT *\n               MULTIPLE OF 4K (RUNSPT)  '\n         SPACE\nZHDR4    DC    CL133' ---------+----------+----------+----------+------*\n               ----+----------+----------+----------+----------+-------*\n               ---+---+ '\n         SPACE\nHEXCHAR  DC    256X'F0'\n         ORG   HEXCHAR+X'F0'\n         DC    C'0'\n         DC    C'1'\n         DC    C'2'\n         DC    C'3'\n         DC    C'4'\n         DC    C'5'\n         DC    C'6'\n         DC    C'7'\n         DC    C'8'\n         DC    C'9'\n         DC    C'A'\n         DC    C'B'\n         DC    C'C'\n         DC    C'D'\n         DC    C'E'\n         DC    C'F'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nOPTPTR   DS    A\nHOLDSPT  DS    XL(SPTLEN)\nLINE     DS    CL133\nFAKECDE  DC    XL8'00'\nFCDENAM  DC    CL8' '\nFCDEEP   DC    XL8'00'\nFAKESPQE DC    4F'0'\nFSPID    DC    H'0'\nFSPKEY   DC    X'FF'\nFSPFLAGS DC    X'00'\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         SPACE\nPARMLST  DSECT\nOUTDCB   DS    A\nPRINTDCB DS    A\nOPTR     DS    A\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         IHADQE\nDQELEN   EQU   *-DQE\n         IHAGDA\nGDALEN   EQU   *-GDA\n         IHASPT\nSPTLEN   EQU   1540      LEN TAKEN FROM DATA AREAS MANUAL\n         IKJTCB\n         CVT   DSECT=YES\n         IHAPSA\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         END\n         MACRO\n&L       PRINTBUF &TEXT\n         LCLC  &L2\n&L2      SETC  '&L'\n         AIF   ('&TEXT' EQ '').NOMOVE\n&L2      L     R15,ADPLBUF         GET BUFFER ADDRESS.\n         MVI   0(R15),C' '         BLANK OUT PREVIOUS JUNK.\n         MVC   1(132,R15),0(R15)\n         MVC   0(L'&TEXT,R15),&TEXT MOVE ITEM TO BUF'R.\n&L2      SETC  ''\n.NOMOVE  ANOP\n&L2      LA    R1,ABDPL            ADDRESS PARAMETER LIST.\n         L     R15,ADPLPRNT        EXTRACT PRINT ROUTINE ADDR.\n         BALR  R14,R15             BRANCH TO PRINT SUBROUTINE.\n         MEND\n*\n*\n*  PRPARM  PROCESS THE IPCS PARM STRING\n*\n*\n*   PARM:  THE ADPL\n*\n         SPACE\nIPCSPRM  RENTR BASE=11,ENV=OS,PARM=(10),WORK=(WORKLEN,WORKAREA)\n         SPACE\n         L     R8,4(,R10)        POINT TO TARGET FLAGS\n         L     R9,8(,R10)        POINT TO PRINT DCB\n         SLR   R15,R15           CLEAR RC IN CASE THERE ARE NO PARMS\n         SPACE\n         AIF   ('&SYSPARM' EQ 'IPCS').IPCSX         ###############\n         MVC   0(4,R8),=X'FFFFFF00' DEFAULT PARM FLAGS\n         SPACE\n         L     R12,0(R10)        POINT TO OS PARM LIST\n         L     R12,0(,R12)       POINT TO OS PARM\n         LA    R3,2(,R12)        POINT TO PARMS\n         LH    R4,0(,R12)        LOAD PARM LENGTH\n         LTR   R4,R4             LENGTH IS ZERO?\n         BZ    RETURN            IF SO, DO NOTHING\n         AGO   .NIPCSX\n.IPCSX   ANOP\n         MVC   0(4,R8),=X'00FF0000' DEFAULT PARM FLAGS\n         SPACE\n         L     R12,0(,R10)       POINT TO THE ABDPL\n         USING ABDPL,R12\n         SPACE\n         L     R2,ADPLEXT        POINT TO OPERANDS PARM\n         LTR   R2,R2             IS THERE A PARM?\n         BZ    RETURN            IF NOT, DO NOTHING\n         SPACE\n         L     R3,0(,R2)         POINT TO OPERANDS\n         LH    R4,ADPLOPLN       GET LENGTH OF OPERANDS\n         LTR   R4,R4             LENGTH IS ZERO?\n         BZ    RETURN            IF SO, DO NOTHING\n.NIPCSX  ANOP\n         SPACE\n         XC    MOREPARM(4),MOREPARM CLEAR EXTRA PARMS FIELD\n         SPACE\n         ST    R3,SAVEMAIN       SAVE MAIN PARM ADDR\n         ST    R4,SAVEMLEN       SAVE MAIN PARM LEN\n         SPACE\n         BCTR  R4,0              SUB 1 FOR EXECUTE INSTRUCTIONS\n         EX    R4,TRT1           CHECK FOR BLANKS, MULTIPLE PARMS\n         BZ    CHK1\n         SPACE\n         ST    R1,MOREPARM       SAVE POINTER TO BLANK\n         SR    R1,R3             GET DSN LEN\n         SR    R4,R1             GET REMAINING PARMS LEN (-1)\n         ST    R4,MORELEN        SAVE FOR LATER\n         BCTR  R1,0              SUB 1 FOR EXECUTE INSTRUCTIONS\n         LR    R4,R1             MAKE IT THE CURRENT PARM LEN\n         SPACE\nCHK1     DS    0H\n         EX    R4,DCHK           CHECK FOR DOT IN NAME\n         BNZ   CHK1A             IF SO, IT IS A NAME\n         SPACE\n*        NO DOTS IN FIRST NAME, MUST BE A KEYWORD, RESET\n         MVC   MOREPARM(4),SAVEMAIN\n         MVC   MORELEN(4),SAVEMLEN\n         B     DONE              GO PROCESS AS KEYWORDS\n         SPACE\nCHK1A    DS    0H\n         EX    R4,PCHK           CHECK FOR PARENS\n         BZ    CHK2\n         SPACE\n         MVC   LINE(133),DSN5\n         EX    R4,MOVEDS2\n         VSMPRNT AREA24,(R9),LINE\n         MVC   0(4,R2),=F'12'    SHOW BAD NAME\n         LA    R15,12            SHOW BAD PARSE TO CALLER\n         B     RETURN\n         SPACE\nCHK2     DS    0H\n         C     R4,=F'43'         NAME (-1) TOO LONG?\n         BNH   NAMEOK\n         SPACE\n         MVC   LINE(133),DSN1\n         EX    R4,MOVEDS2\n         VSMPRNT AREA24,(R9),LINE\n         MVC   0(4,R2),=F'12'    SHOW BAD NAME\n         LA    R15,12            SHOW BAD PARSE TO CALLER\n         B     RETURN\n         SPACE\nTRT1     TRT   0(*-*,R3),FINDBLK FIND BLANK AT END OF NAME\nPCHK     TRT   0(*-*,R3),FINDPRN FIND OPEN PAREN, MEMBER IS NOT ALLOWED\nDCHK     TRT   0(*-*,R3),FINDDOT FIND DOT IN DATASET NAME,\nMOVEDSN  MVC   DSN(*-*),0(R3)\nMOVEDS2  MVC   LINE+25(*-*),0(R3)\n         SPACE\n**********************************************************************\n*\n* THE NAME IS OK, USE LOCATE TO SEE IF IT ALREADY EXISTS\n*\n**********************************************************************\n         SPACE\nNAMEOK   DS    0H\n         MVI   DSN,C' '          CLEAR DSN PARM TO BLANKS\n         MVC   DSN+1(43),DSN\n         EX    R4,MOVEDSN        COPY DSN TO PARM\n         LA    R4,1(R4)          BUMP BACK TO FULL LEN VALUE\n         STH   R4,DSNLEN         SAVE IN THE DSN PARM\n         LA    R14,DSN\n         L     R15,=X'002C0000'\n         STM   R14,R15,DSNPRM\n         CALL  LOCATE,(DSNPRM,LOCRC),MF=(E,CALLLIST)\n         LH    R15,LOCRC         GET LOCATE RC\n         C     R15,=F'8'         DOES IT EXIST?\n         BE    NEW               IF NOT, GO CREATE IT\n         BL    EXISTS            IF SO, GREAT\n         C     R15,=F'11'        IS IT MIGRATED BY HSM?\n         BE    EXISTS            IF SO, IT EXISTS\n*        MUST BE RC=12, NO GOOD\n         MVC   LINE(133),DSN2\n         MVC   LINE+51(44),DSN\n         VSMPRNT AREA24,(R9),LINE\n         MVC   0(4,R2),=F'12'    SHOW BAD NAME\n         LA    R15,12            SHOW BAD PARSE TO CALLER\n         B     RETURN\n         SPACE\nEXISTS   DS    0H\n         MVC   GETDDN(8),=CL8'OUTPUT  '\n         LA    R14,GETDDN\n         L     R15,=X'00080000'\n         STM   R14,R15,DDNPRM\n         LA    R14,GETDSN\n         L     R15,=X'002C0000'\n         STM   R14,R15,DSNPRM\n         LA    R14,REA\n         L     R15,=X'00000000'\n         STM   R14,R15,REAPRM\n         MVC   DDNLEN(2),=H'6'\n         LA    R14,DDNLEN\n         L     R15,=X'00088000'\n         STM   R14,R15,DDNPRM2\n         LA    R14,DSNLEN\n         L     R15,=X'002C8000'\n         STM   R14,R15,DSNPRM2\n         SPACE\n         CALL  GETDSN,(DDNPRM,DSNPRM),MF=(E,CALLLIST)\n         CLI   GETDSN,C' '              IS DDNAME OUTPUT IN USE?\n         BE    ALLOCSHR                 IF NOT, GO ALLOCATE IT\n         SPACE\n         CLC   DSN(44),GETDSN           IS NAME ALREADY ALLOCATED?\n         BE    DONE                     IF SO, WE ARE DONE\n         SPACE\n         CALL  FREEDD,(DDNPRM2,REAPRM,FREERC),MF=(E,CALLLIST)\n         SPACE\nALLOCSHR DS    0H\n         XC    ALLOCT(4),ALLOCT         SHOW DISP=SHR\n         CALL  ALLOCDS,(DSNPRM2,DDNPRM2,ALLOCT,REAPRM,ALOCRC),         X\n               MF=(E,CALLLIST)\n         L     R15,ALOCRC\n         LTR   R15,R15\n         BZ    DONE\n         SPACE\n         MVC   LINE(133),DSN3\n         MVC   LINE+36(44),DSN\n         VSMPRNT AREA24,(R9),LINE\n         MVC   0(4,R2),=F'12'    SHOW BAD NAME\n         LA    R15,12            SHOW BAD PARSE TO CALLER\n         B     RETURN\n         SPACE\nNEW      DS    0H\n         MVC   GETDDN(8),=CL8'OUTPUT  '\n         LA    R14,GETDDN\n         L     R15,=X'00080000'\n         STM   R14,R15,DDNPRM\n         LA    R14,GETDSN\n         L     R15,=X'002C0000'\n         STM   R14,R15,DSNPRM\n         LA    R14,REA\n         L     R15,=X'00000000'\n         STM   R14,R15,REAPRM\n         MVC   DDNLEN(2),=H'6'\n         LA    R14,DDNLEN\n         L     R15,=X'00088000'\n         STM   R14,R15,DDNPRM2\n         LA    R14,DSNLEN\n         L     R15,=X'002C8000'\n         STM   R14,R15,DSNPRM2\n         SPACE\n         CALL  GETDSN,(DDNPRM,DSNPRM),MF=(E,CALLLIST)\n         CLI   GETDSN,C' '              IS DDNAME OUTPUT IN USE?\n         BE    ALLOCNEW                 IF NOT, GO ALLOCATE IT\n         SPACE\n         CALL  FREEDD,(DDNPRM2,REAPRM,FREERC),MF=(E,CALLLIST)\n         SPACE\nALLOCNEW DS    0H\n         MVC   ALLOCT(4),=F'2'          SHOW DISP=NEW\n         CALL  ALLOCDS,(DSNPRM2,DDNPRM2,ALLOCT,REAPRM,ALOCRC),         X\n               MF=(E,CALLLIST)\n         L     R15,ALOCRC\n         LTR   R15,R15\n         BZ    DONE\n         SPACE\n         MVC   LINE(133),DSN4\n         MVC   LINE+31(44),DSN\n         VSMPRNT AREA24,(R9),LINE\n         MVC   0(4,R2),=F'12'    SHOW BAD NAME\n         LA    R15,12            SHOW BAD PARSE TO CALLER\n         B     RETURN\n         SPACE\nDONE     DS    0H\n         L     R3,MOREPARM       POINT TO REMAINING PARMS\n         SLR   R15,R15           CLEAR RC IN CASE WE ARE DONE\n         LTR   R3,R3             ARE THERE ANY?\n         BZ    RETURN            IF ZERO, THEN NO\n         SPACE\n         L     R4,MORELEN        GET REMAINING LEN -1\n         SPACE\nFBLANKS  DS    0H\n         CLI   0(R3),C' '        BLANK?\n         BNE   TSTPRM            IF NOT, FORGET IT\n         SPACE\n         LA    R3,1(,R3)         NEXT CHAR\n         BCT   R4,FBLANKS\n         SLR   R15,R15           CLEAR RC\n         B     RETURN            RAN OUT OF CHARS.\n         SPACE\n**********************************************************************\n*\n**********************************************************************\nTSTPRM   DS    0H\n         L     R6,PARMCNT        GET COUNT OF POSSIBLE VALUES\n         LA    R5,PARMS          POINT TO LIST OF PARMS\n         SPACE\n         EX    R4,TRT1           FIND END OF PARM\n         BZ    LASTPRM\n         SR    R1,R3             GET PARM LEN\n         BCTR  R1,0              SUB 1 FOR EXECUTES\n         B     TST1\n         SPACE\nLASTPRM  DS    0H\n         LR    R1,R4             LAST PARM LENGTH\n         SPACE\nTST1     DS    0H\n         CH    R1,0(,R5)         PARM LEN OK?\n         BNE   NXTVALUE\n         SPACE\n         EX    R1,PARMTST        MATCH?\n         BNE   NXTVALUE\n         SPACE\n         LR    R15,R8            POINT TO PARM AREA\n         AH    R15,10(,R5)       ADD OFFSET OF FLAG\n         MVC   0(1,R15),12(R5)   SET FLAG\nNXTPRM   DS    0H\n         LA    R1,1(,R1)         GET FULL LENGTH OF PARM\n         LA    R3,0(R1,R3)       POINT TO NEXT ENTRY\n         SLR   R15,R15           CLEAR RC IN CASE WE ARE DONE\n         SR    R4,R1             SUB OFF PARM LENGTH\n         BNP   RETURN            IF NOTHING LEFT, WE ARE DONE\n         B     FBLANKS           GO PROCESS NEXT PARM\n         SPACE\nNXTVALUE DS    0H\n         LA    R5,ENTLEN(,R5)    POINT TO NEXT PARM ENTRY\n         BCT   R6,TST1\n         SPACE\n         MVC   LINE(133),PRM1\n         EX    R1,PARMMV\n         LR    R7,R1             SAVE R1\n         VSMPRNT AREA24,(R9),LINE\n         SPACE\n         LR    R1,R7             RESTORE R1\n         B     NXTPRM\n         SPACE\nRETURN   DS    0H\n         REXIT ENV=OS,RC=(15)\n         SPACE 3\nDSN1     DC    CL133' DATASET NAME TOO LONG'\nDSN2     DC    CL133' DATASET CATALOGED BUT DOES NOT EXIST ON VOLUME'\nDSN3     DC    CL133' COULD NOT ALLOCATE EXISTING DATASET'\nDSN4     DC    CL133' COULD NOT ALLOCATE NEW DATASET'\nDSN5     DC    CL133' MEMBER NAME NOT ALLOWED'\nPRM1     DC    CL133' UNKNOWN KEYWORD PARM:  '\n         SPACE 3\n**********************************************************************\n*\n* KEYWORD PARMS.  MUST BE ARRANGED BY LENGTH, LONGEST FIRST THEY MUST\n* BE CHECKED IN THAT ORDER\n*\n**********************************************************************\n         SPACE\nPARMTST  CLC   0(*-*,R3),2(R5)\nPARMMV   MVC   LINE+24(*-*),0(R3)\nPARMCNT  DC    A(NUMPARMS)\n*\n*              LEN-1    KEYWORD   PARM OFFSET VALUE  PADDING\nPARMS    DC    H'4',CL8'PRINT   ',AL2(PRTPRM),X'FF',X'00'\nENTLEN   EQU   *-PARMS\n         DC    H'6',CL8'NOPRINT ',AL2(PRTPRM),X'00',X'00'\n         DC    H'2',CL8'LPA     ',AL2(LPAPRM),X'FF',X'00'\n         DC    H'4',CL8'NOLPA   ',AL2(LPAPRM),X'00',X'00'\n         DC    H'2',CL8'CDE     ',AL2(CDEPRM),X'FF',X'00'\n         DC    H'4',CL8'NOCDE   ',AL2(CDEPRM),X'00',X'00'\n         DC    H'2',CL8'FQE     ',AL2(FQEPRM),X'FF',X'00'\n         DC    H'4',CL8'NOFQE   ',AL2(FQEPRM),X'00',X'00'\nNUMPARMS EQU   (*-PARMS)/ENTLEN\n         SPACE 3\n*        TRT TABLE TO FIND OPEN PAREN\nFINDPRN  DC    XL256'00'\n         ORG   FINDPRN+C'('\n         DC    X'FF'\n         ORG\n*        TRT TABLE TO FIND BLANK OR COMMA\nFINDBLK  DC    XL256'00'\n         ORG   FINDBLK+C' '\n         DC    X'FF'\n         ORG   FINDBLK+C','\n         DC    X'FF'\n         ORG\n*        TRT TABLE TO FIND DOT\nFINDDOT  DC    XL256'00'\n         ORG   FINDDOT+C'.'\n         DC    X'FF'\n         ORG\n         SPACE 3\nWORKAREA DSECT\n         DS    26F\nWORD     DS    D\nAREA24   DS    XL128\nCALLLIST DS    8D\nMOREPARM DS    A\nMORELEN  DS    F\nSAVEMAIN DS    A\nSAVEMLEN DS    F\nDSNPRM   DS    2A\nDSNPRM2  DS    2A\nDSNLEN   DS    H\nDSN      DS    CL44\nDDNPRM   DS    2A\nDDNPRM2  DS    2A\nGETDSN   DS    CL44\nDDNLEN   DS    H\nGETDDN   DS    CL44\nLOCRC    DS    H\nREAPRM   DS    2A\nREA      DS    F\nFREERC   DS    F\nALOCRC   DS    F\nALLOCT   DS    F\nLINE     DS    CL133\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n         PRINT NOGEN\n         SYMBAR MODE=DEC\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCSX         ###############\n         BLSABDPL AMDEXIT=YES,AMDCPST=NO,AMDPFMT=NO\n.NOIPCSX ANOP\n         SPACE\nPRTPRM   EQU   0\nLPAPRM   EQU   1\nCDEPRM   EQU   2\nFQEPRM   EQU   3\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSMPRNT": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x06\\x7f\\x00\\x93\\x06\\x7f\\x18\\x12\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe3\\xe8\\xd4\\xc1@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-03-08T00:00:00", "modifydate": "1993-03-08T18:12:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "STYMA"}, "text": "         MACRO ,\n&LABL    VSMPRNT &AREA24,&DCB,&BUFF,&WORK=LINE\n         AIF   ('&BUFF' EQ '&WORK').NOMOVE\n         MVC   &WORK,&BUFF\n.NOMOVE  ANOP\n         AIF   ('&SYSPARM' NE 'IPCS').NOIPCS\n&LABL    IPCSPRNT &WORK\n         MEXIT\n.NOIPCS  ANOP\n&LABL    PUT31 &AREA24,&DCB,&WORK\n         MEND\n##\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT190/FILE190.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT190", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}