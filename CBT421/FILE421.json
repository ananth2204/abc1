{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012004000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 529074, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE421.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE421.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\t\\x06'", "DS1TRBAL": "b'yd'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\r\\x00\\x03\\x03\\r\\x00\\x0c\\x00\\n'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$CHANGES": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x904\\x8f\\x00\\x905\\x1f\\x15$\\x00\\x17\\x00\\x07\\x00\\x00\\xe3\\xe2\\xe3\\xf2\\xe2\\xe2\\xc7@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1990-12-14T00:00:00", "modifydate": "1990-12-17T15:24:00", "lines": 23, "newlines": 7, "modlines": 0, "user": "TST2SSG"}, "text": "*                                                             12/90 JEB\n*         1990 - CHANGED HARD CODED LOAD (SVC 8) TO STANDARD  12/90 JEB\n*         MACRO FORM TO SUPPORT LSEARCH=YES SO THAT LPA       12/90 JEB\n*         MODULES WILL LOAD WHEN 'LOCAL' IS SPECIFIED.        12/90 JEB\n*         THIS CHANGED WORKED ON BOTH SP1.3.5 AND XA2.2.0     12/90 JEB\n*         JOHN E. BRYANT, COMPUSOURCE, CARY NC                12/90 JEB\n*         (919) 469-3325                                      12/90 JEB\n*                                                             12/90 JEB\n*   This change was necessary to get the LOCAL option         12/90 JEB\n*   working correctly under XA 2.2.  The LOAD did not         12/90 JEB\n*   do its work properly when SYSLIB pointed to SYS1.LPALIB.  12/90 JEB\n*                                                             12/90 JEB\n*   A message of \"MODULE NOT FOUND IN MAIN STORAGE\" was       12/90 JEB\n*   produced, due to the failure of LOAD to put a copy of     12/90 JEB\n*   the module into the Job Pack Queue when LOCAL was         12/90 JEB\n*   specified.                                                12/90 JEB\n*                                                             12/90 JEB\n*   The hard-coded SVC 8 was replaced to allow LOAD to load   12/90 JEB\n*   the module into the Job Pack Queue.  Without the          12/90 JEB\n*   LSEARCH=YES parameter coded, the LOAD macro would return  12/90 JEB\n*   the address of the module, but would not move the copy    12/90 JEB\n*   into the Job Pack Queue.                                  12/90 JEB\n*                                                             12/90 JEB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CBTJCL": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904\\x8f\\x00\\x904\\x8f\\x14\\x19\\x00\\x05\\x00\\x05\\x00\\x00\\xd1\\xc2\\xd9\\xe8\\xc1\\xd5\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-14T00:00:00", "modifydate": "1990-12-14T14:19:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "JBRYANT"}, "text": "//CBT1616 JOB 527TSO000S0008,ARNIE,CLASS=J,MSGCLASS=6,\n// NOTIFY=TA15500\n// EXEC ASMBLR,SO=6\n//SYSIN DD DSN=TS15500.CBT1616.PDS(XAZAPSRC),DISP=SHR\n// EXEC TESTLINK,SO=6,LIB='SYS2.MLINKLIB',NAME=CBT1616,OPT=',AC=1'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UGUPCASE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904\\x8f\\x00\\x904\\x8f\\x14\\x19\\x03w\\x03w\\x00\\x00\\xd1\\xc2\\xd9\\xe8\\xc1\\xd5\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-14T00:00:00", "modifydate": "1990-12-14T14:19:00", "lines": 887, "newlines": 887, "modlines": 0, "user": "JBRYANT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "USERGUID": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904\\x8f\\x00\\x904\\x8f\\x14\\x19\\x03\\x87\\x03\\x87\\x00\\x00\\xd1\\xc2\\xd9\\xe8\\xc1\\xd5\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-14T00:00:00", "modifydate": "1990-12-14T14:19:00", "lines": 903, "newlines": 903, "modlines": 0, "user": "JBRYANT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "XACORZAP": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904\\x8f\\x00\\x904\\x8f\\x14\\x19\\x00\\x9c\\x00\\x9c\\x00\\x00\\xd1\\xc2\\xd9\\xe8\\xc1\\xd5\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-14T00:00:00", "modifydate": "1990-12-14T14:19:00", "lines": 156, "newlines": 156, "modlines": 0, "user": "JBRYANT"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "XAZAPSRC": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904\\x8f\\x00\\x904\\x8f\\x14 \\t\\xe0\\t\\xe0\\x00\\x00\\xd1\\xc2\\xd9\\xe8\\xc1\\xd5\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-14T00:00:00", "modifydate": "1990-12-14T14:20:00", "lines": 2528, "newlines": 2528, "modlines": 0, "user": "JBRYANT"}, "text": "  TITLE 'INCORZAP  --  MAIN STORAGE SUPERZAP FOR MVS/XA AND MVS/370'\n***********************************************************************\n*                                                                     *\n*     'INCORZAP' PROGRAM                                              *\n*                                                                     *\n*         MAIN STORAGE SUPERZAP PROGRAM FOR BOTH MVS/370 AND MVS/XA.  *\n*                                                                     *\n*         NOTE:  THIS SOURCE PROGRAM USES MVS/XA MACROS AND MUST BE   *\n*                ASSEMBLED USING AN MVS/XA MACLIB.                    *\n*                                                                     *\n***********************************************************************\n*\n*      -- MODULE HISTORY:\n*\n*         1974 - ORIGINAL WRITTEN BY R. BUDGE, IBM CORP.\n*         IN PL/S LANGUAGE.\n*\n*         1979-81 - ASSEMBLER SOURCE GENERATED AND COMMENTED BY\n*         BILL GODFREY, PRC (PLANNING RESEARCH CORPORATION), MCLEAN VA,\n*         ALSO MADE PARM FIELD INPUT INDEPENDENT OF ENTRY POINT NAME.\n*\n*         1983 - XA AND SP1.3 CHANGES ADDED, ALONG WITH ADDITIONAL\n*         COMMENTS BY R. BUDGE, NAS CORP.\n*                                                             12/90 JEB\n*         1990 - CHANGED HARD CODED LOAD (SVC 8) TO STANDARD  12/90 JEB\n*         MACRO FORM TO SUPPORT LSEARCH=YES SO THAT LPA       12/90 JEB\n*         MODULES WILL LOAD WHEN 'LOCAL' IS SPECIFIED.        12/90 JEB\n*         THIS CHANGED WORKED ON BOTH SP1.3.5 AND XA2.2.0     12/90 JEB\n*         JOHN E. BRYANT, COMPUSOURCE, CARY NC                12/90 JEB\n*                                                             12/90 JEB\n*\n*      -- COMPLETE DOCUMENTATION IS IN A SEPARATE FILE.\n*\n*      -- BRIEF DOCUMENTATION.\n*\n*          THIS PROGRAM MODIFIES LOAD MODULES IN THE NUCLEUS OR\n*          IN THE LINK PACK AREA.  MODIFIED PAGES IN LPA WILL BE\n*          FIXED TO PREVENT PAGE-INS THAT WOULD UN-MODIFY THE\n*          MODIFIED PAGE.  CONTROL STATEMENT INPUT IS COMPATIBLE\n*          WITH THE 'AMASPZAP' SERVICE AID PROGRAM, EXCEPT THE\n*          PRESENCE OF A SLASH ('/') ANYWHERE IN A CARD IS USED\n*          AS AN INDICATION OF MULTIPLE STATEMENTS PER CARD.\n*          A 'RES' IS LIKE A 'REP' EXCEPT IT FREES A FIXED LPA PAGE.\n*\n*          DDNAMES USED:\n*           SYSPRINT - MESSAGE AND DUMP OUTPUT.\n*           SYSLIB   - SYS1.LPALIB FOR LPA ZAPS,\n*                      SYS1.NUCLEUS FOR NUCLEUS ZAPS.\n*                      OPENED FOR UPDATE, BUT NOT ACTUALLY UPDATED.\n*           SYSIN    - CONTROL STATEMENT INPUT.\n*\n*           IF DDNAMES PROGLIST, PROGLIB, AND PROGIN ARE PRESENT,\n*           THEY WILL BE USED INSTEAD OF THE OTHERS.\n*\n*          CONTROL STATEMENTS MAY OPTIONALLY BE SPECIFIED IN\n*          THE PARM FIELD INSTEAD OF SYSIN.\n*\n*          'VER' 'REP' AND 'RES' COMMANDS MAY USE PROGRAM LABELS\n*          INSTEAD OF HEX OFFSETS IF DESIRED.  ANY ENTRY POINT\n*          MAY BE USED AS A LABEL. OTHER LABELS CAN BE USED ONLY\n*          IF PROGRAM IS COMPILED AND LINKED WITH THE 'TEST'\n*          ATTRIBUTE.  (DOES NOT APPLY NUCLEUS MODULES IN MVS/XA.\n*          TELL INCORZAP YOU ARE USING A LABEL INSTEAD\n*          OF A HEX OFFSET BY ENCLOSING IT IN SINGLE QUOTES.\n*\n*          THE PROGRAM MUST BE LINK-EDITED AS AUTHORIZED IN ORDER\n*          TO MODIFY STORAGE, BUT OTHER FUNCTIONS WILL WORK EVEN\n*          IF IT IS NOT AUTHORIZED.\n*-------------------------------------------------------------------*\n         EJECT\nINCORZAP CSECT\nINCORZAP AMODE 24\nINCORZAP RMODE 24\n         SPLEVEL SET=1\n         B     START-*(,R15)\n         DC    AL1(16)\n         DC    C'INCORZAP  &SYSDATE '\nSTART    STM   R14,R12,12(R13)\n         BALR  R12,R0              BASE REGISTER\n         USING *,R12\n         USING *+4095,R6\n         LA    R6,4095(,R12)       BASE REGISTER\n         LA    R12,0(,R12)         CLEAR BAL STUFF FOR 31-BIT\n         L     R0,SIZE\n         GETMAIN R,LV=(0)\n         LR    R10,R1              WORKAREA BASE\n         USING @DATA,R10\n         LA    R5,4095(,R10)       WORKAREA BASE\n         USING @DATA+4095,R5\n         ST    R13,4(,R10)         PUT OLD ADDRESS IN NEW SAVEAREA\n         LM    R0,R1,20(R13)       RESTORE R0 AND R1\n         ST    R10,8(,R13)         PUT NEW ADDRESS IN OLD SAVEAREA\n         LR    R13,R10             SWITCH TO NEW SAVEAREA\n         MVC   @PARMPTR,0(R1)      SAVE ADDRESS OF PARM FIELD\n         BAL   R14,INIT            INITIALIZE\n         EJECT\n*\n*   MAINLINE ROUTINE\n*\n*               DO WHILE XFEOD=0\n*                  CALL GETREC\n*                  IF XFEOD=0 THEN\n*                     CALL PRINTREC\n*                     CALL VERBSCN\n*                     END\n*                  END\n*               CLOSE FILES\n*               RETURN\n*\n         SPACE\n         B     DOTEST01\nDOLOOP01 BAL   R14,GETREC          GET A LOGICAL RECORD\n         TM    XFLAGS,XFEOD\n         BNZ   DOTEST01\n         MVI   @LINE+2,C' '\n         MVC   @LINE+3(118),@LINE+2\n         L     R14,XFLDSTRT        POINT TO DATA TO BE MOVED\n         L     R11,XENDREC         GET ADDRESS OF END OF DATA\n         SLR   R11,R14             COMPUTE LENGTH\n         EX    R11,LOGMVC          MOVE R14 TO @LINE01\n         OI    @SWB,XFNOWTO        FOR PRINT BUT NOT FOR XFCON\n         BAL   R14,PUTLINE         LOG THE STATEMENT\n         NI    @SWB,255-XFNOWTO\n         BAL   R14,VERBSCN\nDOTEST01 TM    XFLAGS,XFEOD\n         BZ    DOLOOP01\n         MVC   XDCBCLS(12),CLOSE\n*        CLOSE (XDCBL,,XDCBIN,,XDCBO),MF=(E,XDCBCLS)\n         LA    R1,XDCBCLS\n         IC    R14,0(R1)\n         LA    R0,XDCBL\n         ST    R0,0(R1)\n         STC   R14,0(R1)\n         IC    R14,4(R1)\n         LA    R0,XDCBIN\n         ST    R0,4(R1)\n         STC   R14,4(R1)\n         IC    R14,8(R1)\n         LA    R0,XDCBO\n         ST    R0,8(R1)\n         STC   R14,8(R1)\n         SVC   20                  CLOSE\n         L     R11,XCODE           SAVE RC ACROSS FREEMAIN\n         L     R13,4(,R13)         SWITCH TO OLD SAVEAREA\n         L     R0,SIZE             LENGTH FOR FREEMAIN\n         LR    R1,R10              ADDRESS FOR FREEMAIN\n         FREEMAIN R,LV=(0),A=(1)\n         LR    R15,R11             RETURN CODE\n         L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14                 EXIT PROGRAM\n         EJECT\n*\n*   ROUTINE TO DUMP MAIN STORAGE\n*\n*        INPUT: XCSADDR=ADDRESS OF CSECT TO BE DUMPED\n*               XCSLEN = LENGTH TO DUMP\n*\n         SPACE\nDUMP     STM   R14,R12,@SAVE13\n         L     R14,XCSLEN          IS\n         LA    R14,0(,R14)          AN\n         LTR   R14,R14               ENDING ADDRESS SPECIFIED\n         BNZ   A00012A             YES, BRANCH\n         MVC   XCSLEN+1(3),ONE+1\nA00012A  L     R14,MINUS032        FFFFFFE0\n         L     R11,XCSADDR         GET STARTING ADDRESS\n         L     R7,XCSLEN           GET LENGTH\n         LA    R7,0(,R7)\n         ALR   R7,R11              ADD TO START ADDRESS\n         BCTR  R7,R0\n         NR    R7,R14              ROUND DOWN TO MULTIPLE OF 32\n         ST    R7,XDUMPEND         SAVE DUMP END ADDRESS\n         OI    @SWB,XFNOWTO        DON'T DUMP TO CONSOLE\n         MVI   @LINE02,C' '\n         MVC   @LINE03(118),@LINE02\n         MVI   @LINE01,C' '\n         MVC   XHEXL,FOUR\n         NR    R11,R14             ROUND DOWN TO MULTIPLE OF 32\n         ST    R11,XDP             DUMP START ADDRESS\n         B     DUMPGO\nDUMPLP   LA    R14,@LINE01\n         ST    R14,XEBAD\n         LA    R14,XDP\n         ST    R14,XHEX\n         BAL   R14,HEXCV           PUT HEX ADDRESS IN LINE\n         L     R14,XDP\n         ST    R14,XHEX\n         LA    R14,1\n         ST    R14,I               SET SUBSCRIPT TO 1\nDUMPLLP  MH    R14,H9              ADD SUBSCRIPT*9\n         LA    R14,@LINE03(14)      TO LINE+3\n         ST    R14,XEBAD           SAVE RESULT IN HEX TO ADDRESS\n         BAL   R14,HEXCV           PERFORM HEX CONVERSION\n         L     R14,XHEX          ADD\n         AL    R14,XHEXL          HEXLEN\n         ST    R14,XHEX            TO HEXFR\n         LA    R14,1               ADD 1\n         AL    R14,I                TO\n         ST    R14,I                 SUBSCRIPT\n         C     R14,FOUR            IS SUBSCRIPT GT 4\n         BNH   DUMPLLP             NO, LOOP (LEFT HALF OF PAGE)\n         SPACE\n         LA    R14,1               YES,\n         ST    R14,I                RESET SUBSCRIPT TO 1\nDUMPRLP  MH    R14,H9\n         LA    R14,@LINE41(14)\n         ST    R14,XEBAD\n         BAL   R14,HEXCV\n         L     R14,XHEX\n         AL    R14,XHEXL\n         ST    R14,XHEX\n         LA    R14,1\n         AL    R14,I\n         ST    R14,I\n         C     R14,FOUR            IS SUBSCRIPT GT 4\n         BNH   DUMPRLP             NO, LOOP (RIGHT HALF OF PAGE)\n         SPACE\n         MVI   @LINE87,C'*'\n         MVI   @LIN120,C'*'\n         BAL   R14,MODESET1        GET INTO KEY 0\n         BAL   R14,BIT31           GET INTO 31-BIT MODE\n         L     R14,XDP\n         MVC   @LINE88(32),0(R14)  MOVE IN CHAR PORTION\n         BAL   R14,BIT24           GET BACK TO 24-BIT MODE\n         BAL   R14,MODESET2        GET BACK TO USER KEY\n         TR    @LINE88(32),EBCDIC\n         BAL   R14,PUTLINE\n         LA    R11,32              ADD 32\n         AL    R11,XDP              TO\n         ST    R11,XDP               DUMP ADDRESS\nDUMPGO   C     R11,XDUMPEND\n         BNH   DUMPLP\n         NI    @SWB,255-XFNOWTO\n         LM    R14,R12,@SAVE13\n         BR    R14\n         EJECT\n*\n*   FIND MODULE ON PROGRAM LIBRARY\n*\n         SPACE\nFIND     STM   R14,R12,@SAVE14\n         LA    R1,XDCBL\n         LA    R0,XEBLM\n         LCR   R1,R1\n         SVC   18                  FIND\n         LTR   R15,R15             WAS MEMBER FOUND\n         BZ    FINDOK              YES, BRANCH\n         LA    R14,MSG08           MEMBER NOT FOUND IN LIBRARY\n         ST    R14,XMSE\n         BAL   R14,GENERR\n         B     FINDX\nFINDOK   EQU   *\nFINDX    LM    R14,R12,@SAVE14\n         BR    R14\n         EJECT\n*\n*   PGFIX/FREE ROUTINE\n*\n*        INPUT:\n*              XZADDR = ADDR OF STORAGE TO BE CHANGED\n*              XHL = LENGTH OF STORAGE\n*              XEBV = VERB\n*\n         SPACE\nFIXER    STM   R14,R12,@SAVE16\n         L     R14,16              CVT ADDRESS\n         TM    XFLAGS,XFLOCSW\n         BNZ   PAGEX\n         CLC   XEBLM(6),IEANUC     IS THIS A NUCLEUS ZAP\n         BE    PAGEX               YES, NO NEED TO FIX/FREE\n         BAL   R14,MODESET1        SUP STATE, KEY ZERO\n         AL    R13,TWELVE          CHANGE R13 FOR SETLOCK\n         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,RELATED=X\n         SLR   R4,R4               NO TCB - PGFIX NOT TO BE OWNED\n         SLR   R14,R14             CLEAR\n         ST    R14,XPECB           THE ECB\n         LA    R0,XPECB            ECB ADDRESS\n         L     R14,XZADDR          GET STARTING ADDRESS\n         LR    R1,R14              STARTING ADDRESS\n         AL    R14,XHL             COMPUTE ENDING ADDRESS\n         LR    R2,R14              ENDING ADDRESS+1\n         BCTR  R14,0               ENDING ADDRESS\n         CLC   XEBV(3),RESET       IS THIS A RES\n         BE    FREEPG              YES, FREE THE PAGE\n         L     15,16\n         TM    CVTDCB-CVT(R15),CVTMVSE IS THIS MVS/XA\n         BZ    PASTFIX1            NO, SKIP XA PGFIX\nFIXPAGE  PGSER R,FIX,A=(1),EA=(R14),TCB=0,ECB=(0),LONG=Y,BRANCH=Y, XXXXX\n               RELATED=FREEPAGE\n         B     SVPSRC\nPASTFIX1 EQU   *\n         O     R1,PGFIX            NO, FIX THE PAGE\n         B     MVS370BR            SKIP OVER FREE\n*\nFREEPG   EQU   *\n         L     R15,16\n         TM    CVTDCB-CVT(R15),CVTMVSE IS THIS MVS/XA\n         BZ    PASTFRE1\nFREEPAGE PGSER R,FREE,A=(1),EA=(R14),TCB=0,BRANCH=Y,RELATED=FIXPAGE\n         B     SVPSRC\n*\nPASTFRE1 EQU   *\n         O     R1,PGFREE           FREE THE PAGE\nMVS370BR EQU   *\n         L     R11,16              CVT ADDRESS\n         L     R15,804(,R11)       CVTVPSIB - PAGE SERVICES\n         BALR  R14,R15             CALL PAGE SERVICES\nSVPSRC   EQU   *\n         ST    R15,XPSRC           SAVE RETURN CODE\n         SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=X\n         SL    R13,TWELVE          PUT R13 BACK TO NORMAL\n         BAL   R14,MODESET2        PROB STATE, KEY NZERO\n         CLC   XPSRC,EIGHT         DID PAGE SERVICES RETURN AN 8\n         BNE   PAGEX               NO, NO NEED TO WAIT\n         WAIT  ECB=XPECB\nPAGEX    LM    R14,R12,@SAVE16\n         BR    R14\n         EJECT\n*\n*   GENERAL ERROR ROUTINE\n*\n*        INPUT:  XMSE = ADDR OF MESSAGE LIST\n*\n         SPACE\nGENERR   STM   R14,R12,@SAVE15\n         MVI   @LINE02,C' '\n         MVC   @LINE03(118),@LINE02\n         L     R14,XMSE            GET ADDRESS OF MESSAGE\n         L     R11,0(,R14)         GET LENGTH OF MESSAGE\n         BCTR  R11,R0              LENGTH MINUS 1 FOR EX\n         EX    R11,PUTMSGM         MOVE R14+4 TO @LINE01\n         BAL   R14,PUTLINE         WRITE THE MESSAGE\n         MVC   XCODE,TWELVE        SET RETURN CODE\n         OI    XFLAGS,XFEOD        XFEOD\n         LM    R14,R12,@SAVE15\n         BR    R14\n         EJECT\n*\n*    FIELD FETCHING ROUTINE\n*\n*        INPUT:\n*              XRCVADDR = ADDR OF RECEIVING FIELD\n*              XRCVLEN = LENGTH OF RECEIVING FIELD\n*        OUTPUT:\n*              XFLDALEN = ACTUAL LENGTH OF FETCHED FIELD\n*                  (BLANKS ARE RETURNED IF NO FIELD IS FOUND)\n*\n         SPACE\nGETFLD   STM   R14,R12,@SAVE19\n         L     R14,XFLDSTRT\n         ST    R14,XFLDCUR         SET CURRENT = STARTING\n         SLR   R14,R14             SET\n         ST    R14,XSCANSW         SW = 0\n*\n*   SCAN PAST LEADING DELIMITERS\n*\n         B     PARGO1              DO UNTIL SW NE 0\nPARLP1   CLC   XFLDCUR,XENDREC     STILL WITHIN STATEMENT\n         BNH   PARIN1              YES, BRANCH\n*                                  IS BEYOND END OF STMT\n         LA    R14,1               SET\n         ST    R14,XSCANSW         SW = 1\n         B     PARGO1\nPARIN1   L     R14,XFLDCUR\n         CLI   0(R14),C' '         BLANK\n         BE    PARNX1\n         CLI   0(R14),X'7D'        QUOTE\n         BNE   PARFN1\nPARNX1   LA    R14,1               QUOTE OR BLANK\n         AL    R14,XFLDCUR         POINT TO\n         ST    R14,XFLDCUR          NEXT CHARACTER\n         B     PARGO1\n*                                  NEITHER QUOTE NOR BLANK\n*                                  SET TO EXIT LOOP\nPARFN1   LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\nPARGO1   SLR   R14,R14\n         C     R14,XSCANSW\n         BE    PARLP1              END OF DO LOOP (SKIPPING LEADING\n*                                  DELIMITERS\n*\n*   SCAN FOR END OF FIELD\n*\n         L     R11,XFLDCUR         GET TRUE START OF FIELD\n         ST    R11,XFLDSTRT\n         ST    R14,XSCANSW         SET SW = 0\n         B     PARGO2              DO UNTIL SW NE 0\nPARLP2   CLC   XFLDCUR,XENDREC     STILL WITHIN STATEMENT\n         BNH   PARIN2              YES, BRANCH\n         LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\n         B     PARGO2\nPARIN2   LA    R14,1               POINT XFLDCUR TO\n         AL    R14,XFLDCUR          NEXT\n         ST    R14,XFLDCUR           CHARACTER\n         CLI   0(R14),C' '         BLANK\n         BE    PARFN2\n         CLI   0(R14),X'7D'        QUOTE\n         BNE   PARGO2\nPARFN2   LA    R14,1               SET\n         ST    R14,XSCANSW          SW = 1\nPARGO2   L     R14,XSCANSW\n         LTR   R14,R14\n         BZ    PARLP2              END OF DO LOOP (FOUND END)\n*\n*   CALCULATE LENGTH AND CHECK FOR A TOO LONG FIELD\n*\n         L     R14,XFLDCUR         GET ADDRESS OF BLANK OR QUOTE\n         SL    R14,XFLDSTRT        COMPUTE LENGTH\n         ST    R14,XFLDALEN        SAVE LENGTH\n         C     R14,XRCVLEN         WILL IT FIT IN RESULT\n         BNH   PAROKL              YES, BRANCH\n         LA    R14,MSG01           FIELD IS TOO LONG\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX ERROR\n         B     PARMOV              GO TRUNCATE MOVE\n*\n*   MOVE IN FETCHED FIELD (IF ANY)\n*\nPAROKL   L     R14,XRCVADDR        GET ADDRESS OF GETFLD RESULT\n         L     R11,XRCVLEN\n         BCTR  R11,R0\n         EX    R11,PARBLNK         MOVE BLANKS TO GETFLD RESULT\nPARMOV   L     R14,XFLDALEN        IF LENGTH\n         LTR   R14,R14              GREATER THAN\n         BZ    PARNUL                ZERO\n         L     R11,XRCVADDR        GET ADDRESS OF GETFLD RESULT\n         BCTR  R14,R0\n         L     R7,XFLDSTRT\n         EX    R14,PARMVC          MOVE R7 TO R11\nPARNUL   L     R14,XFLDCUR         GET ADDR OF TRAILING DELIMITER\n         ST    R14,XFLDSTRT        READY FOR NEXT CALL\n         CLI   0(R14),X'7D'        QUOTE\n         BNE   PARX                BRANCH IF NOT QUOTED\n         AL    R14,ONE             POINT BEYOND QUOTE\n         ST    R14,XFLDSTRT\nPARX     LM    R14,R12,@SAVE19\n         BR    R14                 RETURN\n         EJECT\n*\n*   HEXADECIMAL FIELD FETCHING ROUTINE\n*\n*        INPUT:\n*              XFLDSTRT = ADDR OF START OF FIELD\n*        OUTPUT:\n*              XHS = HEX STRING\n*              XHSL = LENGTH OF HEX STRING\n*\nGETHEX   STM   R14,R12,@SAVE21\n         SLR   R14,R14\n         ST    R14,XHSW         SET SW = 0\n         ST    R14,XHL          SET LEN = 0\n         L     R14,XFLDSTRT\n         ST    R14,XHP\n*\n*   MOVE FIELD TO 'XHW' AND STRIP OUT COMMAS\n*\n         B     HPAGO1           DO UNTIL XHSW NE 0\nHPALP1   CLC   XHP,XENDREC      STILL WITHIN STATEMENT\n         BNH   HPAIN1           YES, BRANCH\n         MVC   XHSW,ONE\n         B     HPAGO1\nHPAIN1   L     R14,XHP\n         CLI   0(R14),C' '      IS IT A BLANK\n         BNE   A0004DC          NO, BRANCH\n         L     R14,XHL\n         LTR   R14,R14\n         BNP   A0004CC\n         MVC   XHSW,ONE\n         B     HPAGO1\nA0004CC  LA    R14,1\n         AL    R14,XHP\n         ST    R14,XHP\n         B     HPAGO1\n*                                  NOT A BLANK\nA0004DC  L     R14,XHP\n         CLI   0(R14),X'6B'        IS IT A COMMA\n         BE    HPAINCR             YES, GO IGNORE IT\n         LA    R11,1               ADD 1\n         AL    R11,XHL              TO\n         ST    R11,XHL               MODLEN\n         LA    R7,XHW-1(R11)\n         MVC   0(1,R7),0(R14)      COPY THE CHARACTER TO WORK AREA\nHPAINCR  LA    R14,1               POINT\n         AL    R14,XHP              TO\n         ST    R14,XHP               NEXT CHARACTER\nHPAGO1   SLR   R14,R14\n         C     R14,XHSW\n         BE    HPALP1\n*\n*   CHECK FOR MISSING FIELD\n*\n         L     R11,XHP\n         ST    R11,XFLDSTRT\n         C     R14,XHL             IS LENGTH ZERO\n         BNE   HPAOK1              NO, BRANCH\n         LA    R14,MSG11           REQUIRED FIELD MISSING\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX\n         B     HPAX\n*\n*   CHECK FOR INVALID (NON-HEX) CHARACTERS\n*\nHPAOK1   SLR   R2,R2\n         L     R1,XHL\n         BCTR  R1,R0\n         EX    R1,HPRTRT           TRT WORK AREA\n         LTR   R2,R2               ARE ALL CHARACTERS HEX\n         BZ    HPAOK2              YES, BRANCH\n         LA    R14,MSG03           INVALID HEX CHARACTER\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX\n         B     HPAX\n*\n*   TRANSLATE FROM EBCDIC TO HEXADECIMAL\n*\nHPAOK2   TR    XHW,HEXTR-193       TRANSLATE TO 'UNPACKED' HEX\n         LA    R14,XHS\n         ST    R14,XHSPTR\n         LA    R14,XHW             SET\n         ST    R14,XHWPTR           PTR = ADDR(WORK AREA)\n         B     HPAGO2              DO WHILE PTR LE ADDR(WRK AREA)+LEN\nHPALP2   L     R14,XHWPTR\n         PACK  XHPW,0(16,R14)      PACK 16 BYTES AT A TIME\n         L     R11,XHSPTR\n         MVO   0(9,R11),XHPW SHIFT TO GET RID OF SIGN\n         AL    R11,EIGHT           ADD 8 TO\n         ST    R11,XHSPTR           HEX RESULT ADDRESS\n         AL    R14,SIXTEEN         ADD 16 TO\n         ST    R14,XHWPTR           PTR\nHPAGO2   L     R14,XHL\n         LA    R11,XHW\n         ALR   R11,R14\n         C     R11,XHWPTR\n         BH    HPALP2              END OF DO LOOP\n*\n*   CHECK FOR EVEN NUMBER OF HEX DIGITS\n*\n         ST    R14,Y\n         LR    R2,R14              PREPARE TO DIVIDE\n         SRDA  R2,32               PREPARE TO DIVIDE\n         D     R2,TWO              HALVE THE LENGTH\n         ST    R3,XHL              SAVE LENGTH\n         ALR   R3,R3               DOUBLE IT\n         CR    R14,R3              AND COMPARE TO ORIGINAL\n         BE    HPAX                IF EQUAL, THERE WERE AN EVEN NUMBER\n         LA    R14,MSG12           UNEVEN NUMBER OF HEX DIGITS\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX\nHPAX     LM    R14,R12,@SAVE21\n         BR    R14\nHPRTRT   TRT   XHW(1),HEXTRT     (EXECUTED)\n         B     HPAX\n         EJECT\n*\n*   GET OFFSET ROUTINE\n*\n*        INPUT:\n*              XFLDSTRT\n*        OUTPUT:\n*              XZADDR = IN-CORE ADDR CORRESPONDING TO OFFSET\n*\nGETOFF   STM   R14,R12,@SAVE08\n         SLR   R14,R14\n         ST    R14,XGOS\n         MVI   XGOC,C' '\n*\n*   SCAN FOR 1ST CHAR OF OFFSET\n*\n         B     BASGO1\nBASLP1   L     R14,XFLDSTRT\n         C     R14,XENDREC\n         BNH   BASOK1\n         ST    R14,XGOS\n         B     BASGO1\nBASOK1   L     R14,XFLDSTRT\n         CLI   0(R14),C' '\n         BNE   BASOK2\n         AL    R14,ONE\n         ST    R14,XFLDSTRT\n         B     BASGO1\nBASOK2   L     R14,XFLDSTRT\n         MVC   XGOC,0(R14)\n         ST    R14,XGOS\nBASGO1   L     R14,XGOS\n         LTR   R14,R14\n         BZ    BASLP1\n*\n*   CHECK FIRST CHARACTER TO DETERMINE TYPE OF OFFSET (HEX OR LBL)\n*\n         CLI   XGOC,X'7D'          QUOTE (LABEL OFFSET)\n         BE    BASQOT              YES, BRANCH\n*\n*   PROCESS A HEXADECIMAL OFFSET\n*\n         BAL   R14,GETHEX          GET HEX OFFSET\n         L     R14,XHL\n         C     R14,FOUR\n         BNH   BASOK3\n         LA    R14,MSG02           OFFSET FIELD IS TOO LONG\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX\n         B     BASX\nBASOK3   L     R14,XHL\n         SLR   R11,R11\n         CR    R14,R11             IS XHL ZERO\n         BE    BASNUL              YES, BRANCH\n         ST    R11,XHOP            LEADING ZEROES\n         LCR   R14,R14             1,2,3, OR 4 BECOME -1,-2,-3,-4\n         AL    R14,FIVE            BECOME +4 +3 +2 +1\n         LA    R11,XHOP-1(R14)\n         LCR   R14,R14             BECOME -4 -3 -2 -1\n         AL    R14,FOUR            BECOME 0 1 2 3 LENGTH CODE\n         EX    R14,A001638         MOVE REPDATA TO R11\n         CLC   XEBV(3),LITBAS      IS THIS A BASE STATEMENT\n         BNE   BASINN              NO, ITS A VER OR REP, BRANCH\n         L     R14,XHOP\n         ST    R14,XBASE           STORE BASE VALUE\n         B     BASX\nBASINN   L     R14,XCSADDR         GET ADDRESS OF CSECT\n         AL    R14,XHOP            ADD OFFSET\n         SL    R14,XBASE           SUBTRACT VALUE FROM 'BASE' VERB\n         ST    R14,XZADDR          SAVE THIS AS ADDRESS TO ZAP\nBASNUL   B     BASX                GO EXIT\n*\n*   PROCESS A SYMBOLIC (LABEL) OFFSET\n*\nBASQOT   MVI   XEBLBL+1,C' '\n         MVC   XEBLBL+2(6),XEBLBL+1\n         MVI   XEBLBL,C' '\n         LA    R14,XEBLBL\n         ST    R14,XRCVADDR\n         MVC   XRCVLEN,EIGHT\n         BAL   R14,GETFLD         GO GET LABEL\n         CLC   XEBLBL(8),BLANKS\n         BE    BASMISS\n         BAL   R14,SCANMOD        GO SCAN MOD FOR VALUE OF LABEL\n         L     R14,XLMADDR        GET ADDRESS OF MODULE\n         AL    R14,XOFFSET        ADD OFFSET TO CSECT\n         ST    R14,XZADDR         STORE ADDR TO ZAP\n         ST    R14,XLOC\n         TM    XFLAGS,XFEOD\n         BNZ   BASX               BR IF NOT EOD\n         BAL   R14,PRADDR         GO PRINT ADDRESS\n         B     BASX               GO EXIT\nBASMISS  LA    R14,MSG11          REQUIRED FIELD MISSING\n         ST    R14,XMSE\n         BAL   R14,SYNERR         SYNTAX\nBASX     LM    R14,R12,@SAVE08\n         BR    R14\n         EJECT\n*\n*   RECORD FETCHING ROUTINE\n*\n         SPACE\nGETREC   STM   R14,R12,@SAVE10\n         TM    XFLAGS,XFCON       ARE WE IN CONSOLE MODE\n         BNO   GETSIN             NO, BRANCH\n*\n*   CONSOLE INPUT SECTION\n*\n         BAL   R14,GLREC          TRY TO GET A LOGICAL RECORD\n         B     GETCGO1            DO WHILE LOGICAL REC NOT GOTTEN\n*                                 (USE WTOR TO GET ANOTHER PHYS REC)\nGETCLP1  SLR   R14,R14\n         ST    R14,XWECB          CLEAR ECB\n         MVI   XREPLY+1,C' '      CLEAR WTO AREA\n         MVC   XREPLY+2(128),XREPLY+1\n         MVI   XREPLY,C' '\n         LA    R1,XWTOR\n         LA    R15,XREPLY\n         ST    R15,0(R1)\n         MVI   0(R1),130           LENGTH OF REPLY\n         LA    R14,XWECB\n         ST    R14,4(R1)\n         SVC   35                          WTOR\n         LA    R0,1\n         LA    R1,XWECB\n         SVC   1                           WAIT\n         TR    XREPLY(130),EBCDIC  TRANSLATE TO UPPER CASE\n         LA    R14,XREPLY\n         LR    R11,R14\n         BCTR  R11,R0\n         ST    R11,XENDREC         SET END OF LAST LOGICAL\n*                                  REC TO BEGINNING OF REPLY AREA - 1\n         SL    R14,MINUS129\n         ST    R14,XPENDREC        SET END OF PHYSICAL RECORD\n         BAL   R14,GLREC           NOW EXTRACT A LOGICAL REC\nGETCGO1  CLC   XENDREC,XPENDREC\n         BH    GETCLP1             END OF DO LOOP\n         B     GETCX\n*\n*   PROCESS PARM FIELD INPUT\n*\nGETSIN   TM    XFLAGS,XFMAIN       IS THERE PARM FIELD INPUT\n         BNZ   GETCSYIN            NO, BRANCH\n         CLC   XENDREC,XPENDREC    MORE IN PARM\n         BL    GETCPARM            YES, BRANCH\n         OI    XFLAGS,XFEOD        XFEOD\n         B     GETCX\nGETCPARM BAL   R14,GLREC           EXTRACT LOGICAL REC FROM PARM\n         B     GETCX\n*\n*   INPUT IS FROM SYSIN DD\n*\nGETCSYIN BAL   R14,GLREC           TRY TO GET A LOGICAL RECORD\n         B     GETCGO2             DO WHILE NO LOGICAL REC GOTTEN\nGETCLP2  EQU   *\n         GET   XDCBIN,XCARD        READ A PHYSICAL RECORD\n         LA    R14,XCARD\n         LR    R11,R14\n         BCTR  R11,R0\n         ST    R11,XENDREC         POINT TO BYTE PRECEDING COL 1\n         SL    R14,=F'-71'         POINT TO COLUMN 72\n         ST    R14,XPENDREC        THIS IS END OF PHYSICAL RECORD\n         BAL   R14,GLREC           NOW GO GET LOGICAL RECORD\nGETCGO2  CLC   XENDREC,XPENDREC    IS THERE MORE PHYS REC LEFT\n         BH    GETCLP2             BR IF NOT\n*\nGETCX    LM    R14,R12,@SAVE10\n         BR    R14\n*\n*   END-OF-DATA (EODAD) FOR SYSIN\n*\nCTLEOD   OI    XFLAGS,XFEOD          XFEOD\n         B     GETCX\n         EJECT\n*\n*    LOGICAL RECORD EXTRACTION ROUTINE (CALLED BY 'GETREC')\n*\n         SPACE\nGLREC    STM   R14,R12,12(R13)\n         L     R14,XENDREC\n         C     R14,XPENDREC\n         BH    SEPX\n         AL    R14,ONE             ADD 1 TO\n         ST    R14,XENDREC          END POINTER\n         ST    R14,XFLDSTRT        INITIALIZE GETFLD BEGIN ADDRESS\n         SLR   R14,R14             SET\n         ST    R14,XPS              SW = 0\n         B     SEPGO1              DO UNTIL SW NE 0\nSEPLP1   CLC   XENDREC,XPENDREC\n         BL    SEPOK1\n         LA    R14,1               SET\n         ST    R14,XPS              SW = 1\n         B     SEPGO1\nSEPOK1   L     R14,XENDREC\n         CLI   0(R14),C'/'         MULTIPLE STATEMENTS PER CARD\n         BNE   SEPNXT              NO\n         MVI   0(R14),C' '         YES, CHANGE SLASH TO BLANK\n         LA    R14,1               SET\n         ST    R14,XPS              SW = 1\n         B     SEPGO1\nSEPNXT   LA    R14,1               ADD 1\n         AL    R14,XENDREC          TO\n         ST    R14,XENDREC           END POINTER\nSEPGO1   L     R14,XPS\n         LTR   R14,R14\n         BZ    SEPLP1\nSEPX     LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n*\n*   HEX TO EBCDIC CONVERSION ROUTINE\n*\n*        INPUT:\n*              XHEX = ADDR OF HEX DATA TO BE CONVERTED\n*              XHEXL = LENGTH OF HEX DATA\n*              XEBAD = ADDR OF TARGET AREA TO RECEIVE EBCDIC DATA\n*\n         SPACE\nHEXCV    STM   R14,R12,12(R13)\n         BAL   R14,MODESET1          GET INTO KEY 0\n         LA    R14,1                 SET UP LOOP VARIABLE\n         B     HEXCT\nHEXLP    L     R11,XEBAD             GET ADDR OF TARGET EBCDIC AREA\n         L     R7,XHEX               GET ADDR OF 'FROM' FIELD\n         ALR   R7,R14\n         BCTR  R7,R0                 POINT AT CURRENT CHARACTER\n*\n         LR    R4,R14                SAVE LOOP COUNTER\n         BAL   R14,BIT31             GET 31-BIT MODE IF XA\n         MVC   1(1,R11),0(R7)        MOVE CHARACTER TO TARGET AREA\n         BAL   R14,BIT24             GET BACK TO 24-BIT MODE\n         LR    R14,R4\n*\n         UNPK  0(1,R11),1(1,R11)     GET FIRST NIBBLE INTO NEXT BYTE\n         NC    0(2,R11),HEX0F0F      STRIP ZONE BITS\n         TR    0(2,R11),HEXTAB       TRANSLATE INTO EBCDIC\n         AL    R11,TWO               BUMP TARGET CHAR POINTER\n         ST    R11,XEBAD\n         AL    R14,ONE               INCREMENT LOOP COUNTER\nHEXCT    ST    R14,XX\n         C     R14,XHEXL             ARE THERE MORE CHAR'S TO CONVERT\n         BNH   HEXLP\n         BAL   R14,MODESET2          GET BACK TO USER KEY\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n*\n*   HOUSEKEEPING ROUTINE (PERFORMS PROGRAM INITIALIZATION)\n*\n         SPACE\nINIT     STM   R14,R12,@SAVE09\n         MVI   XWTO+127,C' '\n         MVC   XWTO+128(16),XWTO+127\n         MVC   XWTO(127),BLINE\n         MVC   XWTOR,WTORM\n         XC    XDCBCLS(12),XDCBCLS\n         XC    XHW,XHW\n         SLR   R14,R14\n         ST    R14,XCODE\n         XC    XFLAGS(2),XFLAGS\n         L     R14,16              CVTPTR\n         L     R14,0(,R14)         CVTTCBP\n         L     R14,4(,R14)         CURRENT TCB\n         L     R14,0(,R14)         TCBRBP\n*        L     R14,12(,R14)        RBCDE                          .***.\n*        CLC   8(8,R14),LINKZAP    CDNAME LINKZAP                 .***.\n*        BE    INIT1               YES, NO CONTROL XFMAIN         .***.\n         L     R14,@PARMPTR        PARM FIELD                     .PRC.\n         LH    R14,0(,R14)         LENGTH OF PARM                 .PRC.\n         LTR   R14,R14             IS THERE A PARM                .PRC.\n         BNZ   INIT1               YES, NO CONTROL XFMAIN         .PRC.\n         OI    XFLAGS,XFMAIN         CONTROL XFMAIN\nINIT1    LA    R14,PRTDEF\n         ST    R14,XDDN\n         LA    R14,XDCBO\n         ST    R14,XDCBA\n         BAL   R14,OPEN            OPEN PRT\n         LTR   R15,R15             WAS OPEN SUCCESSFUL\n         BNZ   INIT2\n         OI    XFLAGS,XFOOP          PRT IS OPEN\nINIT2    LA    R14,LIBDEF\n         ST    R14,XDDN\n         LA    R14,XDCBL\n         ST    R14,XDCBA\n         BAL   R14,OPEN            OPEN LIB\n         LTR   R15,R15\n         BZ    INIT3\n         LA    R14,MSG07           DD STATEMENT FOR LIBRARY NOT FOUND\n         ST    R14,XMSE\n         BAL   R14,GENERR\n         B     INITX\nINIT3    TM    XFLAGS,XFMAIN       IS INPUT FROM PARM FIELD\n         BNO   INITPARM            YES, GO GET PARM FIELD\n         LA    R14,CTLDEF\n         ST    R14,XDDN\n         LA    R14,XDCBIN\n         ST    R14,XDCBA\n         BAL   R14,OPEN            OPEN SYSIN\n         LTR   R15,R15\n         BZ    INIT4\n         LA    R14,MSG06           INPUT DD STATEMENT NOT FOUND\n         ST    R14,XMSE\n         BAL   R14,GENERR\n         B     INITX\nINIT4    L     R14,XPENDREC\n         ST    R14,XENDREC\n         B     INITX\nINITPARM LA    R14,@PARMCPY\n         BCTR  R14,R0\n         ST    R14,XENDREC\n         L     R11,@PARMPTR\n         LH    R7,0(,R11)          GET LENGTH OF PARM\n         ALR   R14,R7              GET ADDRESS OF LAST CHAR IN PARM\n         ST    R14,XPENDREC         SAVE IT\n         LTR   R7,R7               IS THERE A PARM\n         BNP   INITX               NO, BRANCH\n         BCTR  R7,R0               LENGTH MINUS 1 FOR EX\n         EX    R7,PARMMVC          MOVE PARM TO PARMCPY\nINITX    LM    R14,R12,@SAVE09\n         BR    R14\n         EJECT\n*\n*   ROUTINE TO OPEN FILES\n*\n         SPACE\nOPEN     STM   R14,R12,@SAVE24\n         L     R14,XDCBA\n         L     R11,XDDN\n         L     R7,0(,R11)\n         MVC   0(100,R14),0(R7)            MOVE DCB PROTOTYPE\n         LR    R1,R11\n         LA    R1,8(,R1)                   PRIMARY DDNAME\n*        DEVTYPE (1),XCARD\n         LA    R0,XCARD\n         SVC   24                          DEVTYPE\n         LTR   R15,R15                     IS DDNAME PRESENT\n         BNZ   A000A02                     NO, BRANCH\n         L     R14,XDCBA\n         L     R11,XDDN\n         MVC   40(8,R14),8(R11)            USE PRIMARY DDNAME\n         B     A000A10\nA000A02  L     R14,XDCBA\n         L     R11,XDDN\n         MVC   40(8,R14),16(R11)           USE SECONDARY DDNAME\nA000A10  L     R14,XDDN\n         L     R14,4(,R14)         POINT TO OPEN MF=L IMAGE\n         L     R11,XDCBA\n         ICM   R7,15,0(R14)        LOAD OPEN MF=L IMAGE\n         OR    R11,R7              OR IMAGE OVER R11\n         ST    R11,XDCBA           STORE COMBINED IMAGE IN OPEN MF=L\n         LA    R1,XDCBA\n*        OPEN\n         SVC   19                  OPEN\n         L     R14,XDCBA\n         TM    48(R14),X'10'       WAS OPEN SUCCESSFUL\n         BNO   OPENRC4             NO, BRANCH\n         SLR   R14,R14\n         ST    R14,XOCODE\n         B     OPENRET\nOPENRC4  MVC   XOCODE,FOUR\nOPENRET  L     R15,XOCODE\n         L     R14,@SAVE24\n         LM    R0,R12,@SAVE24+8\n         BR    R14\n         EJECT\n*\n*   PRINT ADDRESS OF SYMBOL (CSECT, LABEL, ETC.)\n*\n*        INPUT:\n*              XLOC = FOUR-BYTE ADDRESS TO BE DISPLAYED\n*\nPRADDR   STM   R14,R12,@SAVE23\n         MVI   @LINE47,C' '\n         MVC   @LINE48(73),@LINE47\n         MVC   @LINE01(46),WHEREMSG\n         LA    R14,XLOC\n         ST    R14,XHEX            ADDR OF WHERE HEX IS COMING FROM\n         MVC   XHEXL,FOUR\n         LA    R14,@LINE01\n         ST    R14,XEBAD           ADDR WHERE WE WANT EBCDIC ADDR\n         BAL   R14,HEXCV           CONVERT HEX ADDR TO EBCDIC\n         BAL   R14,PUTLINE         GO PRINT IT OUT\n         LM    R14,R12,@SAVE23\n         BR    R14\n         EJECT\n*\n*   OUTPUT RECORD PRINTING ROUTINE\n*\n         SPACE\nPUTLINE  STM   R14,R12,@SAVE11\n         TM    XFLAGS,XFOOP                  PRT OPEN\n         BNO   A000ACE\n         TM    @SWB,XF1ST\n         BNZ   A000ABC\n         OI    @SWB,XF1ST\n         PUT   XDCBO,HEADING\n         MVI   @LINE,C'0'\n         B     A000AC0\nA000ABC  MVI   @LINE,C' '\nA000AC0  EQU   *\n         PUT   XDCBO,@LINE\nA000ACE  TM    XFLAGS,XFCON\n         BNO   A000AEA\n         TM    @SWB,XFNOWTO        FOR PRINT ONLY\n         BNZ   A000AEA             YES, BYPASS WTO\n         MVC   XWTO+4(120),@LINE01\n         WTO   MF=(E,XWTO)\nA000AEA  LM    R14,R12,@SAVE11\n         BR    R14\n         EJECT\n*\n*   READ RECORD FROM LIBRARY\n*\n         SPACE\nREADLIB  STM   R14,R12,@SAVE25\n         READ  @DECB,SF,XDCBL,XLREC,248,MF=E\n         SPACE\n         CHECK @DECB\n         SPACE\n         LM    R14,R12,@SAVE25\n         BR    R14\n         EJECT\n*\n*   SCAN LPA/JPA LOOKING FOR LOAD MODULE\n*\n*        INPUT:\n*              XEBLM = NAME OF LOAD MODULE\n*        OUTPUT:\n*              XLMADDR = ADDR OF LOAD MODULE\n*\nSCANLPA  STM   R14,R12,@SAVE26\n         TM    XFLAGS,XFLOCSW      IS IT LOCAL MODE\n         BNZ   A000B4E             YES, GO LOOK IN JPA\n         L     R8,16               CVT ADDRESS\n         LA    R8,188(,R8)         CVTQLPAQ\n         B     A000B64\nA000B4E  L     R14,16              CVT ADDRESS\n         L     R14,0(,R14)\n         L     R14,4(,R14)\n         L     R8,124(,R14)        TCBJSTCB\n         LA    R14,44(,R8)         TCBJPQ - LAST CDE\n         LR    R8,R14\nA000B64  LA    R9,XEBLM\n         LR    R4,R9\n         SL    R4,FORTY8\n         L     R7,16               CVT ADDRESS\n         L     R15,184(,R7)        CVTQCDSR - CDE SEARCH RTN\n         BALR  R14,R15             STD LINKAGE\n*                                  (RETURNS AT +4 IF NAME NOT FOUND)\n         LA    R0,0                INDICATE NAME WAS FOUND\n         LTR   R0,R0\n         BNZ   A000BD6             BR IF NAME NOT FOUND\n         TM    28(R11),X'04'       IS THIS A MINOR CDE\n         BZ    GETEXTL             NO, SKIP OBTAINING MAJOR CDE\n         L     R11,20(,R11)        GET ADDR OF MAJOR CDE\nGETEXTL  L     R14,20(,R11)        GET ADDR OF EXTENT LIST\n         L     R7,12(,R14)         GET ADDR OF LOAD MOD\n         ST    R7,XLMADDR          ADDRESS OF MODULE\n         L     R7,XCSLEN\n         LA    R7,0(,R7)\n         LTR   R7,R7               IS CSECT LENGTH CURRENTLY 0\n         BNZ   A000BD2             NO, SKIP\n         MVC   XCSLEN+1(3),9(R14)  USE LOAD MODULE LENGTH\nA000BD2  B     A000BDC\nA000BD6  SLR   R14,R14\n         ST    R14,XLMADDR         INDICATE NO CDE FOUND\n*\n*   SCAN LPA DIRECTORY (LPDE'S)\n*\nA000BDC  L     R14,XLMADDR\n         LTR   R14,R14\n         BNZ   A000C68             BRANCH IF MODULE ALREADY FOUND\n         TM    XFLAGS,XFLOCSW\n         BNZ   A000C68             BR IF LOCAL MODE (SKIP SEARCH)\n         L     R14,16              CVT ADDRESS\n         TM    116(R14),X'01'      CVTDCB - MVS BIT ON\n         BNO   A000C68\n         SLR   R0,R0               SET\n         BCTR  R0,R0                R0 NEGATIVE\n         L     R1,360(,R14)        CVTLPDIR - LPA DIRECTORY\n         LA    R1,0(,R1)\n         B     LOCATGO1            DO WHILE R0 NEGATIVE\nLOCATLP1 CLC   8(8,R1),XEBLM\n         BNE   A000C4E\n         TM    28(R1),X'04'        ALIAS\n         BNO   A000C32             NO\n         MVC   XEBLM,32(R1)        YES, GET REAL NAME AND START OVER\n         L     R14,16              CVT ADDRESS\n         L     R1,360(,R14)        CVTLPDIR - LPA DIRECTORY\n         LA    R1,0(,R1)\n         B     LOCATINC\nA000C32  L     R0,36(,R1)          SET R0 TO MODULE ADDRESS\n         L     R14,XCSLEN\n         LA    R14,0(,R14)\n         LTR   R14,R14             IS THERE A CSECT LENGTH YET\n         BNZ   LOCATINC            YES, BRANCH\n         MVC   XCSLEN+1(3),33(R1)  USE LOAD MOD LEN AS CSECT LEN\n         B     LOCATINC\nA000C4E  CLC   8(8,R1),FFFFFFFF    HAVE WE LOOKED AT ALL LPDE'S\n         BNE   LOCATINC            NO, BRANCH\n         SLR   R0,R0               END OF DIRECTORY, SET R0 NON NEG\nLOCATINC AL    R1,FORTY            POINT AT NEXT LPDE\nLOCATGO1 LTR   R0,R0\n         BM    LOCATLP1\n         ST    R0,XLMADDR          SAVE LOCATION OF MODULE\nA000C68  L     R14,XLMADDR\n         LTR   R14,R14             WAS END OF DIRECTORY HIT\n         BNZ   SCANLPAX            NO, BRANCH\n         LA    R14,MSG04           MODULE NOT FOUND IN MAIN STORAGE\n         ST    R14,XMSE\n         BAL   R14,GENERR\nSCANLPAX LM    R14,R12,@SAVE26\n         BR    R14\n         EJECT\n*\n*   ROUTINE TO CONTROL SCANNING OF A MODULE FOR A DESIRED LABEL\n*\n*        INPUT:\n*              XEBLM = LOAD MODULE TO SCAN\n*              XEBLBL = CESD LABEL WHOSE OFFSET IS TO BE RETURNED\n*              XEBCS = CSECT WHEREIN THE LABEL RESIDES\n*                      (BLANK MEANS FIRST CSECT)\n*        OUTPUT:\n*              XOFFSET = OFFSET IN LOAD MODULE TO LABEL\n*              XCSLEN = LENGTH OF SPECIFIED CSECT\n*\nSCANMOD  STM   R14,R12,@SAVE22\n         BAL   R14,FIND           GO FIND MODULE ON LIBRARY\n         TM    XFLAGS,XFEOD\n         BNZ   SCMEXIT\n         SLR   R14,R14\n         BCTR  R14,R0\n         ST    R14,XOFFSET        SHOW LABEL REMAINS TO BE FOUND\n         ST    R14,XSYMOFF        SHOW SYMBOL REMAINS TO BE FOUND\n         SLR   R14,R14\n         ST    R14,XCESDN\n*\n*   PERFORM SPECIAL PROCESSING FOR THE NUCLEUS LOAD MODULE\n*\n         CLC   XEBLM(6),IEANUC\n         BNE   A000CB8\n         L     R14,16             GET CVT ADDR\n         TM    CVTDCB-CVT(R14),CVTMVSE IS THIS XA\n         BZ    PASTXANC           NO, SKIP XA CODE\n         BAL   R14,BIT31          GET INTO 31-BIT MODE\n         CLC   XEBCS,=C'IEAVFX00' IS THIS PSA CSECT\n         BNE   PASTCS0            NO, SKIP\n         SR    R2,R2              CLEAR REGISTER\n         ST    R2,XLMADDR         ADDR IS ZERO\n         B     PASTLKU1           SKIP LOOKUP STUFF\n*\nPASTCS0  EQU   *\n         NUCLKUP BYNAME,NAME='IEAVBK00',ADDR=(R2)  ADDR OF 1ST CSECT\n         LA    R2,0(,R2)          CLEAR HI-ORDER BIT\n         ST    R2,XLMADDR         SAVE AS ADDR OF LOAD MOD\nPASTLKU1 EQU   *\n         NUCLKUP BYNAME,NAME=XEBLBL,ADDR=(R3)  GET ADDR OF LABEL\n         LTR   R15,R15\n         BNZ   LBLNTFND           BR IF LABEL NOT FOUND\n         LA    R3,0(,R3)          CLEAR HI-ORDER BIT\n         SLR   R3,R2              GET OFFSET INTO NUC LOAD MOD\n         ST    R3,XOFFSET         SAVE THIS OFFSET\n         NUCLKUP BYNAME,NAME=XEBCS,ADDR=(R3)  GET LENGTH OF CSECT\n         LTR   R15,R15\n         BNZ   LBLNTFND           BR IF LABEL NOT FOUND\n         ST    R1,XCSLEN          SAVE CSECT LENGTH\n         BAL   R14,BIT24          GET BACK TO 24-BIT MODE\n         B     SCMEXIT            EXIT THIS ROUTINE\nPASTXANC EQU   *\n         OI    XFLAGS,XFSKIP1     SKIP 1ST CESD (IEAVNIP0)\n         B     A000CBC\nA000CB8  NI    XFLAGS,255-XFSKIP1\n*\n*   CLEAR THE CSECT DESCRIPTOR ARRAY\n*\nA000CBC  SLR   R14,R14\n         ST    R14,XSDCNT\n         LA    R14,1\n         ST    R14,@ESDSUB\nA000CCA  LR    R11,R14\n         MH    R11,FIVE+2\n         LA    R7,XSDNO(R11)\n         XC    1(4,R7),1(R7)\n         MVI   0(R7),X'00'\n         AL    R14,ONE\n         ST    R14,@ESDSUB\n         C     R14,F400\n         BNH   A000CCA\n*\n*   READ AND PROCESS CESD RECORDS\n*\n         SLR   R14,R14\n         ST    R14,XCRSW         CLEAR LOOP SWITCH\n         B     A000DF0\nA000CF8  BAL   R14,READLIB\n         CLI   XLREC,C' '        SYM RECORD\n         BNE   A000D08           NO, BRANCH\n         BAL   R14,SYMCHK        GO PROCESS SYM RECORD\nA000D08  CLI   XLREC,X'20'       CESD RECORD\n         BE    A000D1C           YES, BRANCH\n         LA    R14,1\n         ST    R14,XCRSW\n*\n*   SCAN CESD ENTRIES ON CESD RECORD\n*\n         B     A000DF0\nA000D1C  LH    R2,XLREC+6        GET LENGTH OF ESD DATA\n         SRDA  R2,32\n         D     R2,SIXTEEN        GET NUMBER OF ENTRIES\n         ST    R3,XNUMCESD\n*\n         LA    R14,1             START WITH ENTRY NUMBER 1\n         B     ESDGO\nA000D34  LA    R14,1\n         AL    R14,XCESDN\n         ST    R14,XCESDN\n         TM    XFLAGS,XFSKIP1\n         BNO   A000D50\n         NI    XFLAGS,255-XFSKIP1\n         B     ESDINCR\nA000D50  L     R14,@ESDSUB\n         SLA   R14,4             MULTIPLY BY 16\n         LA    R11,XLREC(14)     ACTUALLY XLREC+16-16\n         TM    0(R11),X'0F'      IS IT AN SD\n         BZ    GOTSD             YES, BRANCH\n         LA    R11,XLREC(14)\n         TM    0(R11),X'03'      COULD IT BE AN LR\n         BNO   ESDINCR           NO, BRANCH\n         TM    0(R11),X'0C'      MAYBE, IS IT AN LR\n         BNZ   ESDINCR           NO, BRANCH\nGOTSD    L     R14,@ESDSUB\n         ST    R14,XCESDX        SET INDEX TO CESD ENTRY\n         BAL   R14,SECTMAP       USE THIS CESD TO MAP LOAD MODULE\n         L     R14,@ESDSUB\n         SLA   R14,4\n         LA    R11,XLREC-8(14)   ACTUALLY BUFFER+8-16\n         CLC   0(8,R11),XEBLBL   IS THIS THE RIGHT LABEL\n         BNE   A000DA6           NO, BRANCH\n         L     R14,XLREC(14)     ACTUALLY BUFFER+16-16\n         LA    R14,0(,R14)       ZERO HI ORDER BYTE OF ADDRESS\n         ST    R14,XOFFSET       SAVE CSECT ADDRESS\nA000DA6  L     R14,@ESDSUB\n         SLA   R14,4\n         LA    R11,XLREC(14)     ACTUALLY BUFFER+8-16\n         TM    0(R11),X'0F'      IS THIS AN SD\n         BNZ   ESDINCR           NO, BRANCH\n         LA    R11,XLREC-8(14)\n         CLC   0(8,R11),XEBCS    IS THIS THE REQUESTED CSECT\n         BNE   ESDINCR           NO, BRANCH\n         L     R14,XLREC(14)     ACTUALLY BUFFER+16-16\n         LA    R14,0(,R14)       ZERO HI ORDER BYTE OF ADDRESS\n         ST    R14,XCSDADR       SAVE CSECT ADDRESS\n         L     R14,XSDX\n         ST    R14,XCSECNO\nESDINCR  LA    R14,1             ADD 1 TO\n         AL    R14,@ESDSUB       ESD SUBSCRIPT\nESDGO    ST    R14,@ESDSUB\n         C     R14,XNUMCESD      HAS SUBSCRIPT HIT SIZE YET\n         BNH   A000D34           NO, BRANCH\n*\n*   CHECK FOR SUCCESSFUL SCAN\n*\nA000DF0  SLR   R14,R14\n         C     R14,XCRSW\n         BE    A000CF8\n         CLC   XEBCS,BLANKS\n         BNE   A000E0E           IF NO CSECT SPECIFIED\n         MVC   XCSECNO,ONE       USE THE FIRST CSECT\n         ST    R14,XCSDADR       AND RELATIVE ADDRESS IS 0\nA000E0E  L     R14,XSYMOFF\n         LTR   R14,R14           WAS LABEL FOUND IN A SYM REC\n         BM    A000E20           NO, BR\n         AL    R14,XCSDADR       GET POSITION WITHIN LOAD MOD\n         ST    R14,XOFFSET       STORE SYM OFFSET + CSECT ADDR\nA000E20  SLR   R14,R14\n         C     R14,XSDCNT        WAS AT LEAST ONE CSECT FOUND\n         BNL   LBLNTFND          BR IF NO\n         L     R11,XCSECNO\n         CR    R11,R14           WAS OWNING CSECT FOUND\n         BNH   LBLNTFND          BR IF NO\n         C     R14,XOFFSET       WAS DESIRED LABEL FOUND\n         BH    LBLNTFND          BR IF NO\n         MH    R11,FIVE+2\n         LA    R7,XSDLEN(R11)\n         MVC   XCSLEN+1(3),0(R7) MOVE IN CSECT LENGTH\n*\n*   SCATTER LOAD PROCESSING FOR NUCLEUS\n*\n*        GO THROUGH TABLE ADDING UP LENGTH OF EACH CSECT\n*        (ROUNDED UP TO NEAREST DOUBLE WORD) PREVIOUS\n*        TO DESIRED CSECT.\n*\n         CLC   XEBLM(6),IEANUC\n         BNE   A000E9E\n         ST    R14,XACCUM        CLEAR ACCUMULATED LENGTH\n         LA    R14,1             SET CSECT COUNTER\n         B     A000E8E           GO DO LOOP TEST\nA000E60  L     R11,XACCUM        GET ACCUMULATED LENGTH\n         ST    R11,XSMCSD        SAVE IT\n         LR    R7,R14            GET CSECT NUMBER\n         MH    R7,FIVE+2         GET OFFSET INTO TABLE\n         SR    R4,R4             CLEAR REG.\n         LA    R7,XSDLEN(R7)     POINT AT CSECT LENGTH\n         ICM   R4,X'7',0(R7)     LOAD CSECT LENGTH\n         LA    R4,7(,R4)         ADD IN ROUNDUP VALUE\n         N     R4,MINUS008       GET DBL WORD ROUNDED UP VALUE\n         ST    R4,XWORK\n         ALR   R11,R4            ADD TO ACCUMULATED VALUE\n         ST    R11,XACCUM\n         AL    R14,ONE           INCREMENT CSECT COUNTER\nA000E8E  ST    R14,@ESDSUB\n         C     R14,XCSECNO       ALL PREV CSECTS PROCESSED\n         BNH   A000E60           NO, BRANCH\n         B     A000EA6\n*\n*   NON-SCATTER-LOAD PROCESSING\n*\nA000E9E  L     R14,XCSDADR\n         ST    R14,XSMCSD          DISK ADDR IS SAME AS IN-CORE\nA000EA6  L     R14,XOFFSET\n         SL    R14,XCSDADR         GET OFFSET WITHIN CSECT\n         ST    R14,XOFFSET\n         AL    R14,XSMCSD          GET OFFSET WITHIN LOAD MOD\n         ST    R14,XOFFSET\n         B     SCMEXIT\n*\nLBLNTFND EQU   *\n         BAL   R14,BIT24           BE SURE WE ARE IN 24 BIT MODE\n         LA    R14,MSG09           SYMBOL NOT FOUND IN LOAD MODULE\n         ST    R14,XMSE\n         BAL   R14,GENERR\nSCMEXIT  LM    R14,R12,@SAVE22\n         BR    R14\n         EJECT\n*\n*   CSECT MAPPING ROUTINE\n*\n*        INPUT:\n*              XCESDX = INDEX INTO ARRAY OF CESD ENTRIES IN A CESD REC\n*              XCESDN = CESD NO. OF CURRENT CESD ENTRY\n*              CESD = A CESD RECORD\n*              XEBLM = LOAD MODULE NAME\n*        OUTPUT:\n*              XSDNO = ARRAY OF CESD NO.S FRO CSECTS (SD'S) IN LD MOD\n*              XSDLEN = ARRAY OF CSECT LENGTHS\n*              XSDCNT = COUNT OF CSECTS IN LOAD MODULE (THUS FAR)\n*              XSDX = FOR A SD ENTRY, THE RELATIVE CSECT NUMBER\n*                     WITHIN THE IN-CORE VERSION OF THE LOAD MODULE\n*\nSECTMAP  STM   R14,R12,12(R13)\n         L     R14,XCESDX          GET ESD SUBSCRIPT\n         SLA   R14,4               MULTIPLY BY 16\n         LA    R11,XLREC(14)       POINT TO ESD ENTRY + 8\n         TM    0(R11),X'03'        IS IT AN LR\n         BNO   A000F70             NO, BRANCH\n         TM    0(R11),X'0C'        IS IT AN LR\n         BNZ   A000F70             NO, BRANCH\n*\n*   IF CESD ENTRY IS A LABEL REFERENCE (ENTRY POINT) CHECK FOR\n*   SCATTER LOADING (IE. NUCLEUS). SINCE THE SCATTER-LOADED\n*   NUCLEUS IS LOADED AS CESD ENTRIES (SD'S OR LR'S) OCCUR IN THE\n*   CESD RECORDS, ADD THE CESD NUMBER OF THE LABEL'S CSECT TO\n*   THE SD (CSECT) ARRAY\n*\n         CLC   XEBLM(6),IEANUC   IS THIS A NUCLEUS ZAP\n         BNE   A000F70             NO, BRANCH\n         MVC   XSDX,ONE\n         B     A000F46\nA000F04  L     R14,XSDX\n         L     R11,XSDCNT\n         CR    R14,R11\n         BNH   A000F3A\n         AL    R11,ONE\n         ST    R11,XSDCNT\n         MH    R14,FIVE+2\n         L     R11,XCESDX\n         SLA   R11,4\n         LH    R11,XLREC+6(R11)\n         N     R11,X000FFFF\n         LA    R7,XSDNO(14)\n         STCM  R11,3,0(R7)\n         B     A000F46\nA000F3A  LA    R14,1\n         AL    R14,XSDX\n         ST    R14,XSDX\nA000F46  L     R14,XSDX\n         MH    R14,FIVE+2\n         L     R11,XCESDX\n         SLA   R11,4\n         LH    R11,XLREC+6(R11)\n         N     R11,X000FFFF\n         LA    R7,XSDNO(14)\n         ICM   R14,12,0(R7)\n         SRA   R14,16\n         CR    R11,R14\n         BNE   A000F04\n*\n*   IF CESD ENTRY IS A SECTION DEFINITION (SD OR CSECT), ADD THE\n*   CESD NO. FOR THE CSECT TO THE ARRAY.  IF LOAD MOD IS THE NUCLEUS\n*   CHECK FIRST THAT AN ENTRY MIGHT ALREADY BE IN THE ARRAY FOR\n*   THIS CESD NO. FROM AN EARLIER 'LR' ENTRY.  ONCE THE PROPER\n*   CESD ENTRY HAS BEEN FOUND OR ADDED TO THE ARRAY, PUT IN THE\n*   LENGTH OF THIS CSECT.\n*\nA000F70  L     R14,XCESDX          GET ESD SUBSCRIPT\n         SLA   R14,4               MULTIPLY BY 16\n         LA    R11,XLREC(14)       POINT TO ESD ENTRY + 8\n         TM    0(R11),X'0F'        IS IT AN SD\n         BNZ   A00102C             NO, BRANCH\n         CLC   XEBLM(6),IEANUC     IS THIS A NUCLEUS ZAP\n         BNE   A000FEE             NO, BRANCH\n         MVC   XSDX,ONE\n         B     A000FCE\nA000F98  L     R14,XSDX\n         L     R11,XSDCNT\n         CR    R14,R11\n         BNH   A000FC2\n         AL    R11,ONE\n         ST    R11,XSDCNT\n         MH    R14,FIVE+2\n         L     R11,XCESDN\n         LA    R7,XSDNO(14)\n         STCM  R11,3,0(R7)\n         B     A000FCE\nA000FC2  LA    R14,1\n         AL    R14,XSDX\n         ST    R14,XSDX\nA000FCE  L     R14,XSDX\n         MH    R14,FIVE+2\n         LA    R11,XSDNO(14)\n         ICM   R14,12,0(R11)\n         SRA   R14,16\n         C     R14,XCESDN\n         BNE   A000F98\n         B     A00100E\nA000FEE  LA    R14,1\n         AL    R14,XSDCNT\n         ST    R14,XSDCNT\n         ST    R14,XSDX\n         MH    R14,FIVE+2\n         L     R11,XCESDN\n         LA    R7,XSDNO(14)\n         STCM  R11,3,0(R7)\nA00100E  L     R14,XSDX\n         MH    R14,FIVE+2\n         L     R11,XCESDX          GET SUBSCRIPT\n         SLA   R11,4               MULTIPLY BY 16\n         LA    R7,XSDLEN(14)\n         LA    R14,XLREC+4+1(R11)\n         MVC   0(3,R7),0(R14)\nA00102C  LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n*\n*   SYM REC PROCESSING ROUTINE\n*\n*        INPUT:\n*              XEBCS = CSECT CONTAINING LABEL\n*              XEBLBL = LABEL BEING SEARCHED FOR\n*              XLREC = FIRST SYMREC\n*        OUTPUT:\n*              XSYMOFF = OFFSET OF LABEL IN CSECT\n*              XLREC = NEXT LIBRARY RECORD AFTER ALL SYMREC'S\n*\nSYMCHK   STM   R14,R12,@SAVE27\n         SLR   R14,R14\n         ST    R14,XSYMTOTX\n         LA    R14,XLREC+4\n         ST    R14,XSYMCPT\n         OI    @SWB,XFSYMSKP\n         OI    XFLAGS,XFSYMGO\n         BAL   R14,SYMNEW\n         B     A00118A\nA001054  LA    R14,@WAY08\n         B     A001068\nA00105C  BAL   R14,SYMFETCH\n         LA    R14,1\n         AL    R14,XSYMFAD\nA001068  ST    R14,XSYMFAD\n         LA    R11,@WAY08\n         SL    R11,MINUS003\n         CR    R14,R11\n         BNH   A00105C\n         TM    XFLAGS,XFSYMGO\n         BNO   A00118A\n         TM    @WAY08,X'88'\n         BO    A00113A\n         MVC   @WAY08A(8),BLANKS\n         LA    R14,@WAY08A\n         B     A0010A4\nA001098  BAL   R14,SYMFETCH\n         LA    R14,1\n         AL    R14,XSYMFAD\nA0010A4  ST    R14,XSYMFAD\n         LA    R11,@WAY08A\n         LA    R7,7\n         SLR   R4,R4\n         IC    R4,@WAY08\n         NR    R7,R4\n         ALR   R11,R7\n         CR    R14,R11\n         BNH   A001098\n         TM    @SWB,XFSYMSKP\n         BNO   A0010FC\n         TM    @WAY08,X'80'\n         BNZ   A0010F8\n         TM    @WAY08,X'10'\n         BNO   A0010F8\n         TM    @WAY08,X'60'\n         BNZ   A0010F8\n         CLC   @WAY08A(8),XEBCS\n         BE    A0010F4\n         CLC   XEBCS,BLANKS\n         BNE   A0010F8\nA0010F4  NI    @SWB,255-XFSYMSKP\nA0010F8  B     A00113A\nA0010FC  TM    @WAY08,X'80'\n         BNZ   A001126\n         TM    @WAY08,X'10'\n         BNO   A001126\n         TM    @WAY08,X'60'\n         BNZ   A001126\n         CLC   XEBCS,BLANKS\n         BE    A001122\n         OI    @SWB,XFSYMSKP\nA001122  B     A00113A\nA001126  CLC   @WAY08A(8),XEBLBL\n         BNE   A00113A\n         SLR   R14,R14\n         ICM   R14,7,@WAY08Z\n         ST    R14,XSYMOFF\nA00113A  TM    @WAY08,X'80'\n         BNO   A00118A\n         LA    R14,@WAY08B\n         ST    R14,XSYMFAD\n         BAL   R14,SYMFETCH\n         LA    R14,@WAY08C\n         ST    R14,XSYMFAD\n         BAL   R14,SYMFETCH\n         CLI   @WAY08B,X'10'\n         BNL   A001166\n         BAL   R14,SYMFETCH\nA001166  TM    @WAY08,X'40'\n         BNO   A00117A\n         BAL   R14,SYMFETCH\n         BAL   R14,SYMFETCH\n         BAL   R14,SYMFETCH\nA00117A  TM    @WAY08,X'10'\n         BNO   A00118A\n         BAL   R14,SYMFETCH\n         BAL   R14,SYMFETCH\nA00118A  TM    XFLAGS,XFSYMGO\n         BO    A001054\n         LM    R14,R12,@SAVE27\n         BR    R14\n         EJECT\n*\n*   CHARACTER FETCHING ROUTINE FOR SYMREC PROCESSING\n*\n*        INPUT:\n*              XSYMFAD = ADDR OF BYTE TO RECEIVE FETCHED CHARACTER.\n*        OUTPUT:\n*              XSYMFAD->BYTE = FETCHED CHARACTER\n*              XSYMFGO = ON IF DATA IS EXHAUSTED\n*\nSYMFETCH  STM   R14,R12,@SAVE29\n         L     R14,XSYMRECX\n         L     R11,XSYMCPT\n         ICM   R11,12,10(R11)\n         SRA   R11,16\n         CR    R14,R11\n         BL    A0011B6\n         BAL   R14,SYMNEW\nA0011B6  TM    XFLAGS,XFSYMGO\n         BNO   A0011E0\n         L     R14,XSYMFAD\n         L     R11,XSYMFPT\n         MVC   0(1,R14),0(R11)\n         LA    R14,1\n         L     R7,XSYMRECX\n         ALR   R7,R14\n         ST    R7,XSYMRECX\n         ALR   R11,R14\n         ST    R11,XSYMFPT\nA0011E0  LM    R14,R12,@SAVE29\n         BR    R14\n         EJECT\n*\n*   ROUTINE TO GET A NEW SYMREC LOGICAL RECORD\n*\nSYMNEW  STM   R14,R12,@SAVE28\n         SLR   R14,R14\n         ST    R14,XSYMRECX\n         ST    R14,XSYMFPT       SET PNTR = 0\n         B     A001268           DO WHILE PNTR = 0 AND XFSYMGO ON\nA0011F8  L     R14,XSYMTOTX\n         CH    R14,XLREC+2\n         BL    A001226\n         SLR   R14,R14\n         ST    R14,XSYMTOTX\n         BAL   R14,READLIB\n         CLI   XLREC,C' '        SYM\n         BNE   A001222             NO, BRANCH\n         LA    R14,XLREC+4\n         ST    R14,XSYMCPT\n         B     A001226\nA001222  NI    XFLAGS,255-XFSYMGO    SET XFSYMGO OFF\nA001226  L     R14,XSYMTOTX\n         LTR   R14,R14\n         BZ    A00123C\n         LA    R14,80\n         AL    R14,XSYMCPT\n         ST    R14,XSYMCPT\nA00123C  LA    R14,80\n         AL    R14,XSYMTOTX\n         ST    R14,XSYMTOTX\n         L     R14,XSYMCPT\n         CLC   1(3,R14),SYM\n         BNE   A001268\n         L     R11,XSYMOFF\n         LTR   R11,R11\n         BNM   A001268\n         LA    R14,16(,R14)\n         ST    R14,XSYMFPT\nA001268  L     R14,XSYMFPT\n         LTR   R14,R14\n         BNZ   A00127A\n         TM    XFLAGS,XFSYMGO\n         BO    A0011F8\nA00127A  LM    R14,R12,@SAVE28\n         BR    R14\n         EJECT\n*\n*    SYNTAX ERROR MESSAGE ROUTINE\n*\n         SPACE\nSYNERR STM   R14,R12,@SAVE20\n         MVI   @LINE02,C' '\n         MVC   @LINE03(118),@LINE02\n         MVI   @LINE01,C' '\n         MVC   @LINE01(15),SYNTAX\n         L     R14,XMSE\n         L     R11,0(,R14)\n         EX    R11,PUTM8MV         MOVE 4(R14) TO LINE+16\n         BAL   R14,PUTLINE\n         MVC   XCODE,EIGHT\n         OI    XFLAGS,XFEOD          XFEOD\n         LM    R14,R12,@SAVE20\n         BR    R14\n         SPACE\n*\n*   ROUTINE TO GAIN SUPERVISOR STATE, KEY ZERO\n*\n         SPACE\nMODESET1 STM   R14,R12,@SAVE17\n         MODESET KEY=ZERO,MODE=SUP\n         LM    R14,R12,@SAVE17\n         BR    R14\n         SPACE\n*\n*   ROUTINE TO RETURN TO PROBLEM STATE AND KEY\n*\n         SPACE\nMODESET2 STM   R14,R12,@SAVE18\n         MODESET KEY=NZERO,MODE=PROB\n         LM    R14,R12,@SAVE18\n         BR    R14\n         EJECT\n*\n*    VERB SCANNING AND ROUTING ROUTINE\n*\n         SPACE\nVERBSCN  STM   R14,R12,@SAVE12\n         LA    R14,XEBV\n         ST    R14,XRCVADDR\n         MVC   XRCVLEN,EIGHT\n         BAL   R14,GETFLD\n         SLR   R14,R14\n         ST    R14,XVXSW           SET SW OFF\n         LA    R14,1\n         ST    R14,XVX             SET SUBSCRIPT TO 1\nPROCLOOP L     R11,XVXSW\n         LTR   R11,R11             HAS SW BEEN SET ON\n         BNZ   PROCDONE            YES, JUMP OUT\n         LR    R11,R14\n         MH    R11,THREE+2\n         LA    R7,OPCODES-3(R11)   GET ADDRESS OF VERB TABLE ENTRY\n         CLC   XEBV(3),0(R7)       IS THIS THE RIGHT VERB\n         BNE   PROCINCR            NO, GO INCREMENT TO NEXT ONE\n         SLA   R14,2\n         L     R15,OPENTRY-4(14)\n         BALR  R14,R15             CALL THE ROUTINE FOR THIS OPERATION\n         LA    R14,1\n         ST    R14,XVXSW           SET SW ON\nPROCINCR LA    R14,1\n         AL    R14,XVX\n         ST    R14,XVX\n         C     R14,SIXTEEN         HAVE ALL VERBS BEEN CHECKED\n         BNH   PROCLOOP            NO, KEEP CHECKING\nPROCDONE L     R14,XVXSW           WAS SW EVER SET ON\n         LTR   R14,R14             YES, BRANCH\n         BNZ   VERBSCNX\n         LA    R14,MSG10           OPERATION REQUESTED IS INVALID\n         ST    R14,XMSE\n         BAL   R14,SYNERR          SYNTAX\nVERBSCNX LM    R14,R12,@SAVE12\n         BR    R14\n         EJECT\n*\n*   ROUTINE TO HANDLE COMMENT STATEMENTS\n*\n         SPACE\nCOMMENT  BR    R14\n         SPACE\n*\n*   CONSOLE VERB ROUTINE\n*\n         SPACE\nCON      STM   R14,R12,12(R13)\n         OI    XFLAGS,XFCON\n         L     R14,XENDREC\n         ST    R14,XCSER\n         L     R14,XPENDREC\n         ST    R14,XCSPER\n         ST    R14,XENDREC\n         LM    R14,R12,12(R13)\n         BR    R14\n         SPACE\n*\n*   END VERB ROUTINE\n*\n         SPACE\nEND      STM   R14,R12,12(R13)\n         NI    XFLAGS,255-XFCON\n         L     R14,XCSER\n         ST    R14,XENDREC\n         L     R14,XCSPER\n         ST    R14,XPENDREC\n         LM    R14,R12,12(R13)\n         BR    R14\n         EJECT\n*\n*   DUMP VERB ROUTINE\n*\n         SPACE\nDUM      STM   R14,R12,@SAVE05\n         BAL   R14,NAM\n         BAL   R14,DUMP\n         LM    R14,R12,@SAVE05\n         BR    R14\n         SPACE\n*\n*   GLOBAL VERB ROUTINE\n*\n         SPACE\nGLO      NI    XFLAGS,255-XFLOCSW\n         BR    R14\n         SPACE\n*\n*   LOCAL VERB ROUTINE\n*\n         SPACE\nLOC      OI    XFLAGS,XFLOCSW\n         BR    R14\n         EJECT\n*\n*   NAME VERB ROUTINE\n*\n         SPACE\nNAM      STM   R14,R12,@SAVE04\n         NI    XFLAGS,255-XFNOGO\n         SLR   R14,R14\n         STCM  R14,7,XCSLEN+1\n*\n*   GET OPERANDS\n*\n         ST    R14,XBASE\n         MVC   XRCVLEN,EIGHT\n         LA    R14,XEBLM            PUT ADDRESS OF MEMBER\n         ST    R14,XRCVADDR          IN GETFLD RESULT POINTER\n         B     NAMGO1               DO UNTIL POINTER GT MEMBER+8\nNAMLP1   BAL   R14,GETFLD           CALL GETFLD TO GET NEXT OPERAND\n         LA    R14,8                ADD 8\n         AL    R14,XRCVADDR          TO\n         ST    R14,XRCVADDR           GETFLD RESULT ADDRESS\nNAMGO1   LA    R11,XEBCS            IF R14 GT MEMBER+8\n         CR    R14,R11               THEN\n         BNH   NAMLP1                 EXIT DO LOOP\n*\n*   CHECK FOR A GLOBAL MODULE IN LOCAL MODE\n*\n         TM    XFLAGS,XFLOCSW        LOCAL MODE\n         BNO   NAMOK1                NO, BRANCH\n         CLC   XEBLM(6),IEANUC       YES, DOES NAME LOOK GLOBAL\n         BE    NAMWARN               YES, ISSUE WARNING\n         CLC   XEBLM(5),IGC00        DOES NAME LOOK GLOBAL\n         BNE   NAMOK1                NO, BRANCH\nNAMWARN  MVI   @LINE58,C' '          ISSUE WARNING\n         MVC   @LINE59(62),@LINE58\n         MVC   @LINE01(57),WARNMSG\n         BAL   R14,PUTLINE\n*\n*   IF A CSECT WAS SPECIFIED, GET THE OFFSET TO THIS CSECT FROM\n*   THE BEGINNING OF THE LOAD MODULE\n*\nNAMOK1   TM    XFLAGS,XFEOD\n         BNZ   A001468\n         CLC   XEBCS,BLANKS\n         BNE   A001456\n         SLR   R14,R14               CSECT OMITTED\n         ST    R14,XCSOFF            OFFSET ZERO INTO MODULE\n         B     A001468\nA001456  MVC   XEBLBL(8),XEBCS       MAKE CSECT THE LABEL TO LOOKUP\n         BAL   R14,SCANMOD           GO SCAN MODULE FOR THIS LABEL\n         L     R14,XOFFSET\n         ST    R14,XCSOFF            OFFSET INTO MODULE\n*\n*   GET IN-CORE ADDRESS OF LOAD MODULE\n*\nA001468  TM    XFLAGS,XFEOD\n         BNZ   NAMEX\n         TM    XFLAGS,XFLOCSW\n         BNO   A00148A               BR IF NOT LOCAL MODE\n*                                                             12/90 JEB\n*   LOAD A COPY FOR LOCAL MODE                                12/90 JEB\n*                                                             12/90 JEB\n         MVC   XLOADPL(LOADLEN),LOADPL                        12/90 JEB\n         LOAD  EPLOC=XEBLM,DCB=XDCBL,SF=(E,XLOADPL)           12/90 JEB\n         BAL   R14,SCANLPA           GO FIND LOADED MODULE IN JPA\n         B     NAMEEOD\nA00148A  CLC   XEBLM(6),IEANUC\n         BNE   NAMSCNL\n         CLC   XEBCS,BLANKS          NUCLEUS, IS CSECT SPECIFIED\n         BNE   PASTNCSE              YES, BRANCH\n         LA    R14,MSG05             NO, CSECT REQUIRED WITH NUCLEUS\n         ST    R14,XMSE\n         BAL   R14,GENERR\n         B     NAMEX                 EXIT\n*\nPASTNCSE EQU   *\n         L     R14,16\n         TM    CVTDCB-CVT(R14),CVTMVSE   IS THIS MVS/XA\n         BO    NAMEEOD               YES, SKIP SETTING LM ADDR (SET\n*                                    BY SCANMOD ROUTINE)\n         SLR   R14,R14\n         ST    R14,XLMADDR           NUCLEUS LOCATION IS ZERO\n         B     NAMEEOD\nNAMSCNL  BAL   R14,SCANLPA\nNAMEEOD  TM    XFLAGS,XFEOD\n         BNZ   NAMEX\n         L     R14,XLMADDR\n         AL    R14,XCSOFF\n         ST    R14,XCSADDR           ADDRESS OF CSECT\n         ST    R14,XLOC\n         BAL   R14,PRADDR\nNAMEX    LM    R14,R12,@SAVE04\n         BR    R14\n         EJECT\n*\n*   RETURN CODE ROUTINE\n*\n         SPACE\nRC       STM   R14,R12,@SAVE06\n         MVI   @LINE17,C' '\n         MVC   @LINE18(103),@LINE17\n         MVC   @LINE01(16),EQRC    = RETURN CODE\n         LA    R14,XCODE\n         AL    R14,THREE\n         ST    R14,XHEX\n         LA    R14,@LINE01\n         ST    R14,XEBAD\n         MVC   XHEXL,ONE\n         BAL   R14,HEXCV\n         BAL   R14,PUTLINE\n         LM    R14,R12,@SAVE06\n         BR    R14\n         EJECT\n*\n*    REP OR RES OR RESET\n*\n         SPACE\nREP      STM   R14,R12,@SAVE03\n         CLC   XEBV,RESET          IS IT RESET\n         BNE   REPIN               NO, BRANCH IF REP OR RES\n         NI    XFLAGS,255-XFNOGO   RESET, JUST SET XFNOGO OFF\n         B     REPX\nREPIN    TM    XFLAGS,XFNOGO       IS XFNOGO SWITCH ON\n         BNO   REPGO               NO, BRANCH\n         MVI   @LINE37,C' '\n         MVC   @LINE38(83),@LINE37\n         MVC   @LINE01(36),IGNORED\n         BAL   R14,PUTLINE\n         B     REPX\nREPGO    BAL   R14,GETOFF\n         BAL   R14,GETHEX\n         TM    XFLAGS,XFEOD\n         BO    REPX\n         CLC   XEBV,=CL8'REP'      IS THIS A REP\n         BNE   RESTOREX            NO, GO DO RESTORE PROCESSING\n         BAL   R14,FIXER           FIX PAGE IF REP\n         BAL   R14,MODIFY          GO MODIFY STORAGE\n         B     REPX                SKIP RESTORE PROCESSING\nRESTOREX EQU   *\n         BAL   R14,MODIFY          GO MODIFY STORAGE\n         BAL   R14,FIXER           GO UNFIX STORAGE\nREPX     LM    R14,R12,@SAVE03\n         BR    R14\n         EJECT\n*\n*   VERIFY ROUTINE\n*\n         SPACE\nVER      STM   R14,R12,@SAVE02\n         BAL   R14,GETOFF          GO GET VALUE OF OFFSET\n         BAL   R14,GETHEX          GO GET HEX STRING\n         BAL   R14,BIT31           GET INTO 31-BIT MODE\n         TM    XFLAGS,XFEOD\n         BNZ   VERX\n         L     R14,XHL\n         BCTR  R14,R0\n         L     R11,XZADDR\n         EX    R14,VERCLC          VERIFY THE DATA\n         BE    VERX                EXIT IF IT VERIFIES OK\n         OI    XFLAGS,XFNOGO       SET XFNOGO SWITCH\n         MVC   XCODE,FOUR\n         MVI   @LINE33,C' '\n         MVC   @LINE34(87),@LINE33\n         MVC   @LINE01(32),REJECT\n         BAL   R14,BIT24           GET BACK TO 24-BIT MODE\n         BAL   R14,PUTLINE         ISSUE REJECT MESSAGE\n         BAL   R14,DUMP            DUMP THE MODULE\nVERX     EQU   *\n         BAL   R14,BIT24           INSURE BACK TO 24-BIT MODE\n         LM    R14,R12,@SAVE02\n         BR    R14\n         EJECT\n*\n*   ZERO (AND PGFIX) STORAGE ROUTINE\n*\n         SPACE\nZAP      STM   R14,R12,@SAVE07\n         BAL   R14,VER\n         TM    XFLAGS,XFEOD+XFNOGO\n         BNZ   ZAPX\n         BAL   R14,FIXER           FIX PAGE IF LPA\n         L     R14,XHL\n         BCTR  R14,R0              LENGTH MINUS 1 FOR EX\n         EX    R14,ZAPXC           MAKE REP DATA ALL ZEROS\n         BAL   R14,MODIFY\nZAPX     LM    R14,R12,@SAVE07\n         BR    R14\n*\n*   ROUTINE TO OBTAIN 24-BIT ADDRESSING MODE\n*\nBIT24    EQU   *\n         L     R15,16              GET CVT ADDR\n         TM    CVTDCB-CVT(R15),CVTMVSE IS THIS MVS/XA\n         BZR   R14                 NO, RETURN TO CALLER\n         LA    R14,0(,R14)         CLEAR HI-ORDER PORTION\n         BSM   0,R14               RETURN IN 24-BIT MODE\n*\n*   ROUTINE TO OBTAIN 31-BIT ADDRESSING MODE\n*\nBIT31    EQU   *\n         L     R15,16              GET CVT ADDR\n         TM    CVTDCB-CVT(R15),CVTMVSE IS THIS MVS/XA\n         BZR   R14                 NO, RETURN TO CALLER\n         LA    R14,0(,R14)         CLEAR OUT BAL STUFF, ETC.\n         O     R14,HIORDBIT        TURN ON AMODE-31 BIT\n         BSM   0,R14               RETURN IN 31-BIT MODE\n         EJECT\n*\n*   ROUTINE TO MODIFY STORAGE\n*\n*        INPUT:\n*              XHS = HEX STRING\n*              XHL = LENGTH OF HEX STRING\n*              XZADDR = ADDRESS OF CORE TO BE OVERLAYED\n*\nMODIFY   STM   R14,R12,@SAVE30\n         MVI   @LINE14,C' '\n         MVC   @LINE15(106),@LINE14\n         MVC   @LINE01(13),OLDWAS\n         L     R14,XHL            LENGTH OF DATA TO BE MODIFIED\n         ST    R14,XHEXL\n         L     R14,XZADDR         ADDRESS OF DATA TO BE MODIFIED\n         ST    R14,XHEX\n         LA    R14,@LINE01\n         AL    R14,THIRTEEN\n         ST    R14,XEBAD          PUT HEX DUMP AT LINE+1+13\n         BAL   R14,HEXCV          CONVERT OLD DATA TO HEX\n         BAL   R14,PUTLINE        DISPLAY OLD DATA\n         BAL   R14,MODESET1       SUPV STATE KEY ZERO\n         BAL   R14,BIT31          GET 31-BIT MODE\n         L     R14,XZADDR         GET ADDRESS TO BE MODIFIED\n         L     R11,XHL            GET LENGTH OF DATA\n         B     MODLPTST           GO DO LOOP TEST\n*\nMODLOOP  EQU   *\n         LA    R8,0(R11,R14)      POINT AT BYTE TO MOVE\n         L     R2,PSAAOLD         GET ADDR OF CURRENT ASCB\n         N     R8,MASKPAGE        GET LOWER PAGE BOUNDARY\n         STCTL 1,1,I              GET SET TABLE ORIGIN\n         L     R2,I               GET CONTENTS OF STO REG\n         L     R15,16             GET ADDR OF CVT\n         TM    CVTDCB-CVT(R15),CVTMVSE  IS THIS MVS/XA\n         BO    MODXA              YES, GO DO XA PROCESSING\n*\n*   TEMPORARILY TURN OFF SEGMENT PROTECTION\n*\n         SRL   R8,16              ISOLATE SEG INDEX (SX)\n         SLL   R8,2               MULT SX*4 TO GET OFFSET\n         N     R2,MASKSTO3        ISOLATE ADDR OF SEG TBL\n         BAL   R15,REAL2VIR       CONVERT TO VIRTUAL ADDR\n         ALR   R2,R8              GET ADDR OF SEG TBL ENTRY\n         L     R8,MASKSPBT        GET MASK FOR SEG PROT BIT\n         LA    R9,3(,R2)          POINT AT BYTE CONTAINING SP BIT\n         N     R8,0(,R2)          ISOLATE SEG PROT BIT\n         BZ    MODIT              BR IF NOT PROTECTED\n         NI    0(R9),X'FB'        TURN OFF SEG PROT\n         B     MODPTLB            SKIP XA PROCESSING\n*\n*   TURN OFF PAGE PROTECTION FOR XA\n*\nMODXA    EQU   *\n         SR    R9,R9              CLEAR SECOND REG OF PAIR\n         SRDL  R8,20              ISOLATE SX & PUT PX IN R9\n         SLL   R8,2               GET SEG TBL OFFSET (SX*4)\n         N     R2,MASKSTOX        ISOLATE ADDR OF SEG TABLE\n         BAL   R15,REAL2VIR       GET VIRTUAL ADDR\n         ALR   R2,R8              GET ADDR OF SEG TBL ENTRY\n         SRL   R9,22              GET PAGE TABLE OFFSET (PX*2)\n         L     R2,0(,R2)          GET CONTENT OF SEG TBL ENTRY\n         N     R2,MASKSTE         ISOLATE ADDR OF PAGE TBL ORIGIN\n         BAL   R15,REAL2VIR       GET VIRTUAL ADDR\n         ALR   R9,R2              GET ADDR OF PAGE TBL ENTRY\n         L     R8,0(,R9)          GET CONTENTS OF PAGE TABLE ENTRY\n         N     R8,MASKPPBT        ISOLATE PAGE PROT BIT\n         BZ    MODIT              BR IF NO PAGE PROT\n         SRL   R8,8               SHIFT BYTE TO LO-ORDER\n         LA    R9,2(,R9)          GET ADDR OF BYTE WITH PP BIT IN IT\n         NI    0(R9),X'FD'        TURN OFF PAGE PROT\nMODPTLB  EQU   *\n         PTLB  ,                  ELIM PROT BIT FROM TLB\n*\n*   MODIFY STORAGE A BYTE AT A TIME\n*\nMODIT    EQU   *\n         IC    R0,XHS(R11)        GET FROM BYTE\n         STC   R0,0(R11,R14)      MODIFY STORAGE\n         EX    R8,ORPROT          TURN PROT BIT BACK ON\nMODLPTST EQU   *\n         S     R11,ONE            DECREMENT\n         BNM   MODLOOP            BRANCH UNTIL DONE\n         BAL   R14,BIT24          GET BACK TO 24-BIT MODE\n*\n         BAL   R14,MODESET2       PROB STATE KEY NZERO\n         LM    R14,R12,@SAVE30\n         BR    R14\n         EJECT\n*\n*   REAL TO VIRTUAL CONVERSION SUBROUTINE\n*\n*        INPUT\n*              R2 - REAL ADDR\n*              R15 - RETURN ADDR\n*        OUTPUT\n*              R1,R3 - ALTERED\n*              R2 - CONVERTED VIRTUAL ADDRESS\n*\nREAL2VIR EQU   *\n         LR    R1,R2              COPY INPUT ADDR\n         SRL   R1,12              SHIFT OFF DISPLACEMENT\n         L     R3,CVTPTR          GET ADDR OF CVT\n         TM    CVTDCB-CVT(R3),CVTMVSE IS THIS MVS/XA\n         L     R3,CVTPVTP-CVT(,R3)  GET ADDR OF PVT\n         BO    R2VXA              YES, BRANCH\n*\n         L     R3,PVTPFTP(,R3)    GET ADDR OF PFT\n         SLL   R1,4               GET PFT DISPLACEMENT\n         AR    R3,R1              GET PFTE ADDR\n         SR    R1,R1              CLEAR\n         ICM   R1,6,PFTVBN(R3)    GET VIRT BLK NO.\n         B     R2VB               SKIP XA PROCESSING\n*\nR2VXA    EQU   *\n         L     R3,PVTRIT(,R3)     GET ADDR IF RIT\n         L     R3,RITPFT(,R3)     GET ADDR OF PFT\n         SLL   R1,5               GET PFT DISPLACEMENT\n         L     R1,PFTVSA(R1,R3)   GET VIRT PAGE ADDR\n*\nR2VB     EQU   *\n         N     R2,MASKPGDP        GET PAGE DISPLACEMENT\n         OR    R2,R1              COMBINE WITH VIRT PAGE NO.\n         BR    R15                RETURN\n         EJECT\n*\n*   EXECUTED INSTRUCTIONS\n*\n         SPACE\nH9       DC    H'0009'\nLOGMVC   MVC   @LINE01,0(R14)\nPUTMSGM  MVC   @LINE01,4(R14)\nPARBLNK  MVC   0(1,R14),BLANKS\nPARMVC   MVC   0(1,R11),0(R7)\nA001638  MVC   0(1,R11),XHS\nPARMMVC  MVC   @PARMCPY(1),2(R11)\nPUTM8MV  MVC   @LINE16,4(R14)\nVERCLC   CLC   0(1,R11),XHS\nZAPXC    XC    XHS(1),XHS\nORPROT   OI    0(R9),*-*\n         EJECT\n***********************************************************************\n*                                                                     *\n*         CONSTANTS                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE\nONE      DC    F'1'\nTWO      DC    F'2'\nTHREE    DC    F'3'\nFOUR     DC    F'4'\nFIVE     DC    F'5'\nEIGHT    DC    F'8'\nTWELVE   DC    F'12'\nTHIRTEEN DC    F'13'\nFOURTEEN DC    F'14'\nSIXTEEN  DC    F'16'\nFORTY    DC    F'40'\nFORTY8   DC    F'48'\nF400     DC    F'400'\nMINUS129 DC    F'-129'\nMINUS079 DC    F'-79'\nMINUS032 DC    F'-32'\nMINUS008 DC    F'-8'\nMINUS003 DC    F'-3'\nPGFIX    EQU   *\n         DC    X'42000000'\nPGFREE   EQU   *\n         DC    X'20000000'\nX000FFFF DC    F'65535'\nMASKPAGE DC    X'FFFFF000'           PAGE BOUNDARY MASK\nMASKPGDP DC    X'00000FFF'           PAGE DISPLACEMENT MASK\nMASKSTO3 DC    X'00FFFFC0'           370-MODE STO REG MASK\nMASKSTOX DC    X'7FFFF000'           XZ-MODE STO REG MASK\nMASKSPBT DC    X'00000004'           SEG PROT BIT MASK\nMASKSTE  DC    X'7FFFFFC0'           SEG TBL ENTRY MASK\nMASKPPBT DC    X'00000200'           PAGE PROT BIT MASK\nHIORDBIT DC    X'80000000'           HI-ORDER BIT MASK\nSIZE     DC    A(@DATAL)             LENGTH OF GETMAINED AREA\n         DC    F'0'\nBLANKS   DC    C'        '\nLINKZAP  DC    C'LINKZAP '\nRESET    DC    C'RESET   '\nIEANUC   DC    C'IEANUC'\nIGC00    DC    C'IGC00'\nLITBAS   DC    C'BAS'\nSYM      DC    C'SYM'\nFFFFFFFF DC    XL8'FFFFFFFFFFFFFFFF'\nHEX0F0F  DC    X'0F0F'\nHEXTR    EQU   *\n         DC    X'0A0B0C0D0E0F'\n         DC    41X'00'             C7-EF\n         DC    X'00010203040506070809'\n         DC    6X'00'              FA-FF\n         DC    X'00'\nBLINE    DC    H'127,0'\n         DC    CL123' '\nEBCDIC   DC    74C' '              00-49\n         DC    X'4A4B4C4D4E4F50'\n         DC    C'         '        51-59\n         DC    X'5A5B5C5D5E5F6061'\n         DC    C'        '         62-69\n         DC    X'6A6B6C6D6E6F'\n         DC    C'         '        70-78\n         DC    X'797A7B7C7D7E7F'\n         DC    C' '                80\n         DC    C'ABCDEFGHI'        81-89\n         DC    C' '                8A\n         DC    X'8B8C8D8E8F'\n         DC    C' '                90\n         DC    C'JKLMNOPQR'        91-99\n         DC    C' '                9A\n         DC    X'9B9C9D9E9FA0A1'\n         DC    C'STUVWXYZ'         A2-A9\n         DC    X'AAABACADAEAF'     AA-AF\n         DC    X'B0B1B2B3B4B5B6B7B8B9'\n         DC    C' '                BA\n         DC    X'BBBCBDBEBFC0'\n         DC    C'ABCDEFGHI'        C1-C9\n         DC    C'      '           CA-CF\n         DC    X'D0'\n         DC    C'JKLMNOPQR'        D1-D9\n         DC    C'      '           DA-DF\n         DC    X'E0'\n         DC    C' '                E1\n         DC    C'STUVWXYZ'         E2-E9\n         DC    C'      '           EA-EF\n         DC    C'0123456789'       F0-F9\n         DC    X'FA'\n         DC    C'     '            FB-FF\n         LTORG\n*\n*   MESSAGES\n*\nWHEREMSG DC    C'         = IN-CORE ADDRESS OF PRECEDING SYMBOL'\nIGNORED  EQU   *,36\n         DC    C'OPERATION IGNORED - NO GO SWITCH SET'\nREJECT   EQU   *,32\n         DC    C'VERIFY REJECT - SET NO GO SWITCH'\nOLDWAS   EQU   *,13\n         DC    C'OLD DATA WAS '\nEQRC     EQU   *,16\n         DC    C'   = RETURN CODE'\nSYNTAX   EQU   *,15\n         DC    C'SYNTAX ERROR - '\nWARNMSG  EQU   *,57\n         DC    C'WARNING -- LOCAL MODE IS PROBABLY INVALID '\n         DC    C'FOR THIS MODULE'\nHEADING  EQU   *,121\n         DC    CL121'1MAIN STORAGE ZAP SERVICE AID PROGRAM'\n         DC    X'00'\nMSG01    DC    F'00017'\n         DC    C'FIELD IS TOO LONG'\n         DC    X'00'\n         DC    H'0'\nMSG02    DC    F'00024'\n         DC    C'OFFSET FIELD IS TOO LONG'\nMSG03    DC    F'00029'\n         DC    C'INVALID HEXADECIMAL CHARACTER'\n         DC    X'00'\n         DC    H'0'\nMSG04    DC    F'00032'\n         DC    C'MODULE NOT FOUND IN MAIN STORAGE'\nMSG05    DC    F'00046'\n         DC    C'CSECT MUST BE SUPPLIED FOR NUCLEUS LOAD MODULE'\n         DC    H'0'\nMSG06    DC    F'00028'\n         DC    C'INPUT DD STATEMENT NOT FOUND'\nMSG07    DC    F'00042'\n         DC    C'DD STATEMENT FOR PROGRAM LIBRARY NOT FOUND'\n         DC    H'0'\nMSG08    DC    F'00035'\n         DC    C'MEMBER NOT FOUND ON PROGRAM LIBRARY'\n         DC    X'00'\nMSG09    DC    F'00031'\n         DC    C'SYMBOL NOT FOUND IN LOAD MODULE'\n         DC    X'00'\nMSG10    DC    F'00030'\n         DC    C'OPERATION REQUESTED IS INVALID'\n         DC    H'0'\nMSG11    DC    F'00022'\n         DC    C'REQUIRED FIELD MISSING'\n         DC    H'0'\nMSG12    DC    F'00035'\n         DC    C'UNEVEN NUMBER OF HEXADECIMAL DIGITS'\n         DC    X'00'\nWTORM    EQU   *,44\n         DC    F'0'\n         DC    F'0'\n         DC    AL2(36,0)\n         DC    C'ENTER INCORZAP STATEMENTS OR END'\n*\n*   LIBRARY DEFINITION TABLES\n*\nLIBDEF   EQU   *,24\n         DC    A(LIBDCB)           POINTER TO DCB IMAGE\n         DC    A(LIBOPEN)          POINTER TO OPEN MF=L\n         DC    C'PROGLIB '         PRIMARY DDNAME\n         DC    C'SYSLIB  '         SECONDARY DDNAME\nPRTDEF   EQU   *,24\n         DC    A(PRTDCB)           POINTER TO DCB IMAGE\n         DC    A(PRTOPEN)          POINTER TO OPEN MF=L\n         DC    C'PROGLIST'         PRIMARY DDNAME\n         DC    C'SYSPRINT'         SECONDARY DDNAME\nCTLDEF   EQU   *,24\n         DC    A(CTLDCB)           POINTER TO DCB IMAGE\n         DC    A(CTLOPEN)          POINTER TO OPEN MF=L\n         DC    C'PROGIN  '         PRIMARY DDNAME\n         DC    C'SYSIN   '         SECONDARY DDNAME\n*\n*   HEXADECIMAL VALIDATION TRANSLATE TABLE\n*\nHEXTRT   DC    193X'01'            00-C0\n         DC    6X'00'              C1-C6 (A-F)\n         DC    41X'01'             C7-EF\n         DC    10X'00'             F0-F9\n         DC    6X'01'              FA-FF\n*\n*   VERB NAME TABLE\n*\nOPCODES  DC    C'VER'                      01\n         DC    C'REP'                      02\n         DC    C'NAM'                      03\n         DC    C'DUM'                      04\n         DC    C'RES'                      05\n         DC    C'   '                      06\n         DC    C'*  '                      07\n         DC    C'CON'                      08\n         DC    C'END'                      09\n         DC    C'RC '                      10\n         DC    C'ZAP'                      11\n         DC    C'GLO'                      12\n         DC    C'LOC'                      13\n         DC    C'BAS'                      14\n         DC    C'IDR'                      15\n         DC    C'SET'                      16\n         DC    H'0'\n*\n*   VERB ROUTINE ADDRESS TABLS\n*\nOPENTRY  DC    A(VER)\n         DC    A(REP)\n         DC    A(NAM)\n         DC    A(DUM)\n         DC    A(REP)\n         DC    A(COMMENT)\n         DC    A(COMMENT)\n         DC    A(CON)\n         DC    A(END)\n         DC    A(RC)\n         DC    A(ZAP)\n         DC    A(GLO)\n         DC    A(LOC)\n         DC    A(GETOFF)\n         DC    A(COMMENT)\n         DC    A(COMMENT)\n*\nHEXTAB   DC    C'0123456789ABCDEF'\n         SPACE\nCLOSE    EQU   *,12\n         DC    F'0'\n         DC    F'0'\n         DC    X'80000000'\nLOADPL   LOAD  EPLOC=0,DCB=0,LSEARCH=YES,SF=L                 12/90 JEB\nLOADLEN  EQU   *-LOADPL                                       12/90 JEB\nLIBDCB   DCB   DDNAME=0,DSORG=PO,MACRF=R\nLIBDCBL  EQU   *-LIBDCB\n         SPACE\nPRTDCB   DCB   DDNAME=0,DSORG=PS,MACRF=PM,                             +\n               RECFM=FA,LRECL=121,BLKSIZE=121\nPRTDCBL  EQU   *-PRTDCB\n         SPACE\nCTLDCB   DCB   DDNAME=0,DSORG=PS,MACRF=GM,EODAD=CTLEOD,LRECL=80\nCTLDCBL  EQU   *-CTLDCB\n         SPACE\nLIBOPEN  DC    X'84000000'\nCTLOPEN  DC    X'80000000'\nPRTOPEN  DC    X'8F000000'\n         EJECT\n*\n*   FLAG MAPPINGS\n*\nXFMAIN   EQU   X'80'               INPUT NOT FROM PARM FIELD\nXFEOD    EQU   X'40'\nXFLOCSW  EQU   X'20'\nXFNOGO   EQU   X'10'\nXFCON    EQU   X'08'\nXFSKIP1  EQU   X'04'               SKIP 1ST CESD (NUC MOD)\nXFOOP    EQU   X'02'               OUTPUT DATASET OPEN\nXFSYMGO  EQU   X'01'               SW FOR SYMREC PROCESSING\nXFSYMSKP EQU   X'80'               SKIP SYMBOLS (WRONG CSECT)\nXF1ST    EQU   X'40'               1ST TIME SW FOR PRINTING\nXFNOWTO  EQU   X'20'\nSWB10    EQU   X'10'\n         EJECT\n*\n*   REGISTERS\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5                   DATA BASE REG NO. 2\nR6       EQU   6                   PROG BASE REG NO. 2\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10                  DATA BASE REG NO. 1\nR11      EQU   11\nR12      EQU   12                  PROG BASE REG NO. 1\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n*\n*   CONTROL BLOCK MAPPINGS\n*\nPVTRIT   EQU   X'04'               POINTER TO RIT (XA)\nPVTPFTP  EQU   X'0C'               POINTER TO APPARENT PFT (370)\nRITPFT   EQU   X'D0'               POINTER TO APPARENT PFT (XA)\nPFTVBN   EQU   X'2'                VIRT BLK NUMBER (370)\nPFTVSA   EQU   X'14'               VIRT STORAGE ADDR (XA)\nCVT      DSECT\n         CVT   DSECT=YES\n*\n*        IHAPSA\nFLC      DSECT                     USED BY SETLOCK\nPSAAOLD  EQU   X'224'              ADDR OF CURRENT ASCB\nPSALITA  EQU   FLC+764             USED BY SETLOCK\n         EJECT\n***********************************************************************\n*                                                                     *\n*         MAP OF GETMAINED WORK AREA                                  *\n*                                                                     *\n***********************************************************************\n         SPACE\n@DATA    DSECT\n@SAVE01  DS    18F\n@PARMPTR DS    F\n@SAVE02  DS    15F                 SUBROUTINE SAVE AREAS\n@SAVE03  DS    15F\n@SAVE04  DS    15F\n@SAVE05  DS    15F\n@SAVE06  DS    15F\n@SAVE07  DS    15F\n@SAVE08  DS    15F\n@SAVE09  DS    15F\n@SAVE10  DS    15F\n@SAVE11  DS    15F\n@SAVE12  DS    15F\n@SAVE13  DS    15F\n@SAVE14  DS    15F\n@SAVE15  DS    15F\n@SAVE16  DS    15F\n@SAVE17  DS    15F\n@SAVE18  DS    15F\n@SAVE19  DS    15F\n@SAVE20  DS    15F\n@SAVE21  DS    15F\n@SAVE22  DS    15F\n@SAVE23  DS    15F\n@SAVE24  DS    15F\n@SAVE25  DS    15F\n@SAVE26  DS    15F\n@SAVE27  DS    15F\n@SAVE28  DS    15F\n@SAVE29  DS    15F\n@SAVE30  DS    15F\n@ESDSUB  DS    0F\nI        DS    F                    WORK VARIABLE\nXACCUM   DS    F                    ACCUMULATED CSECT LENGTH\nXBASE    DS    F                    BASE VALUE FOR OFFSET ADJ\nXCESDN   DS    F                    CESD NUMBER\nXCSECNO  DS    F                    CSECT NO. FOR 'XEBLBL'\nXCESDX   DS    F                    INDEX TO CESD ENTRY\nXCRSW    DS    F                    CESD RECORD SCAN SW\nXCSADDR  DS    F                    ADDRESS OF CSECT\nXCSDADR  DS    F                    REL ADDR OF CSECT ON DISK\nXCSER    DS    F                    LENGTH OF CSECT\nXCSPER   DS    F                    SAVE XPENDREC - CONSOLE MODE\nXCSOFF   DS    F                    OFFSET TO CSECT IN LOAD MOD\nXCODE    DS    F                    RETURN CODE\nXDCBA    DS    F                    ADDR OF DCB\nXDDN     DS    F                    PNTR TO DD NAME TABLE\nXDUMPEND DS    F                    END OF DUMP\nXDP      DS    F                    DUMP POINTER\nXEBAD    DS    F                    ADDR OF EBCDIC DATA\nXENDREC  DS    F                    ADDR OF END OF LOGICAL DATA\nXFLDCUR  DS    F                    CURRENT CHARACTER POINTER\nXRCVADDR DS    F                    ADDR OF RECEIVING FIELD\nXFLDALEN DS    F                    ACTUAL FIELD LENGTH\nXFLDSTRT DS    F                    START OF FIELD\nXGOS     DS    F                    'GET OFFSET' ROUTINE SW\nXHEX     DS    F                    ADDR OF HEX DATA\nXHEXL    DS    F                    LENGTH OF HEX DATA\nXHL      DS    F                    LENGTH OF HEX STRING\nXHP      DS    F                    POINTER TO HEX STRING\nXHSPTR   DS    F                    HEX STRING POINTER\nXHSW     DS    F                    SWITCH\nXHWPTR   DS    F                    HEX WORK AREA POINTER\nXLMADDR  DS    F                    IN-CORE ADDR OF LOAD MOD\nXLOC     DS    F                    LOCATION TO BE DISPLAYED\nXMSE     DS    F                    ADDR OF SYNTAX ERR MSG\nXNUMCESD DS    F                    NO. OF ENTRIES IN CESD REC\nXOCODE   DS    F\nXOFFSET  DS    F                    OFFSET TO CESD IN LOAD MOD\nXPECB    DS    F\nXPENDREC DS    F                    POINTER TO END OF PHYSICAL REC\nXPS      DS    F                    LOOP SWITCH\nXPSRC    DS    F                    PAGE SERVICE RETURN CODE\nXRCVLEN  DS    F                    RECEIVING FIELD LEN\nXSCANSW  DS    F                    SW TO CONTROL SCAN\nXSDCNT   DS    F                    COUNT OF CSECTS IN MODULE\nXSDX     DS    F                    ARRAY INDEX FOR XSD\nXSMCSD   DS    F\nXSYMCPT  DS    F\nXSYMFAD  DS    F\nXSYMFPT  DS    F\nXSYMOFF  DS    F\nXSYMRECX DS    F\nXSYMTOTX DS    F\nXVX      DS    F                    VERB INDEX\nXVXSW    DS    F\nXWECB    DS    F\nXWORK    DS    F\nXX       DS    F\nXZADDR   DS    F                    IN-CORE STORAGE ADDR\nY        DS    F\n@FILL01  DS    CL12\nXCSLEN   DS    F\nXCARD    DS    CL80\n         DS    0F\nXDCBL    DS    CL100\n         DS    0F\nXDCBO    DS    CL100\n         DS    0F\nXDCBIN   DS    CL100\nXDCBCLS  DS    3F\n         DS    F\nXLOADPL  DS    (LOADLEN)X                                     12/90 JEB\nXEBLM    DS    CL8\nXEBCS    DS    CL8\n         DS    CL8\nXEBLBL   DS    CL8\nXEBV     DS    CL8\nXFLAGS   DS    C\n@SWB     DS    C\nXGOC     DS    C\n         DS    C                   XHOP-1\nXHOP     DS    F\nXHPW     DS    CL9\nXHS      DS    CL40\n         DS    C                   XHW-1\nXHW      DS    CL80\n@DECB    DS    5F\n         SPACE\n@LINE    DS    CL121               @DATA+2642\n         ORG   @LINE\n         DS    C\n@LINE01  DS    C\n@LINE02  DS    C\n@LINE03  DS    CL11\n@LINE14  DS    C\n@LINE15  DS    C\n@LINE16  DS    C\n@LINE17  DS    C\n@LINE18  DS    CL15\n@LINE33  DS    C\n@LINE34  DS    CL3\n@LINE37  DS    C\n@LINE38  DS    CL3\n@LINE41  DS    CL6\n@LINE47  DS    C\n@LINE48  DS    CL10\n@LINE58  DS    C\n@LINE59  DS    CL28\n@LINE87  DS    C\n@LINE88  DS    CL26\n         DS    CL6\n@LIN120  DS    C\n         SPACE\n         DS    C\nXLREC    DS    0F,CL248\n@PARMCPY DS    CL200\nXREPLY   DS    CL130\n@FILL9C  DS    CL2\nXWTO     DS    CL144\nXWTOR    DS    CL44\n@WAY08   DS    CL1\n@WAY08Z  DS    CL3\n@WAY08A  DS    CL5\n*\n*   CSECT MAPPING ARRAY (912 ENTRIES)\n*\nXSDNO    DS    C                     CSECT NUMBER (2 BYTES)\n         DS    C\nXSDLEN   DS    C                     CSECT LENGTH (3 BYTES)\n@WAY08B  DS    C\n@WAY08C  DS    C\n         DS    2000C\n         DS    2560C\n@DATAL   EQU   *-@DATA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT421/FILE421.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT421", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}