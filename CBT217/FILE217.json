{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011519000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 764218, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE217.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 764218, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE217.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\r\\t'", "DS1TRBAL": "b'l`'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x92\\x00\\x05\\x01\\x93\\x00\\x03\\x00\\x0e'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$ASM": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x00\\x11\\x00\\x11\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "FIELD"}, "text": "//QC22505M JOB (),'DISASM COMPILE',\n//  CLASS=D,NOTIFY=QC22505,MSGCLASS=X,MSGLEVEL=(1,1)\n//* JOB(DISASMA) - ASSEMBLE DISASSEMBLER\n//S0  EXEC ASMHCL,CLASS='*',\n// PARM.ASM='OBJECT,NODECK,BATCH',\n// PARM.LKED='XREF,LET,LIST,NCAL'\n//ASM.SYSLIB DD DISP=SHR,DSN=SYS1.MACLIB\n//           DD DISP=SHR,DSN=SYS1.MODGEN\n//           DD DISP=SHR,DSN=SYS1.ATSOMAC\n//           DD DISP=SHR,DSN=QC22505.DISASM2.ASM\n//ASM.SYSIN DD DISP=SHR,DSN=QC22505.DISASM2.ASM(DISASM)\n//          DD DISP=SHR,DSN=QC22505.DISASM2.ASM(DISASM1)\n//          DD DISP=SHR,DSN=QC22505.DISASM2.ASM(DISASM2)\n//LKED.SYSLMOD DD DISP=SHR,DSN=QC22505.TSO2.LOAD\n//LKED.SYSIN DD *\n NAME DISASM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x01\\xa3\\x01\\xa3\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 419, "newlines": 419, "modlines": 0, "user": "FIELD"}, "text": "DISASM is a one-pass disassembler which produces an assembler language\nsource program from a CSECT within a load module. Control cards permit\nspecification of areas containing no instructions, allow base registers\nto be provided so that symbolic labels may be created during\ndisassembly, and definition of DSECTs to be used during disassembly.\nConditional branch instructions use the extended mnemonics, where\npossible, and explicit registers are denoted by R0, R1, ... R15.\nInformational comments are given on SVC's, and various BAL instructions\nto aid in creating a documented source program.\n\n1. JCL requirements:\n      a. EXEC card:        To execute PGM=DISASM. A parm field may\n                           be specified if floating point and/or\n                           privileged instructions are to be\n                           found in the module.\n      b. STEPLIB DD card:  Optional, specify the PDS containing\n                           the module DISASM.\n      c. LOADLIB DD card:  optional, specify PDS containing the\n                           modules DISASM1 and DISASM2, if other than\n                           a linklist library or STEPLIB.\n      d. SYSLIB DD card:   specify PDS containing the module to be\n                           disassembled.\n      e. SYSPRINT DD card: optional, specify the printed\n                           output dataset. BLKSIZE must be\n                           specified as a multiple of 121.\n                           RECFM=FBA,LRECL=121 is hard coded.\n      f. SYSPUNCH DD card: optional, specify printed output\n                           dataset. BLKSIZE must be specified\n                           as a multiple of 80.\n                           RECFM=FB,LRECL=80 is hard coded.\n      g. SYSIN DD card:    contains control cards. The MODULE-CSECT\n                           card is required. BLKSIZE must be a\n                           multiple of 80. RECFM=FB,LRECL=80 is\n                           hard-coded.\n\n  JCL example: Disassemble CSECT IECIOSCN in module IEANUC01,\n               which is in the PDS SYS1.NUCLEUS. The modules\n               DISASM, DISASM1, and DISASM2 are all in the PDS\n               SYS1.TECHLOAD. A printed listing is to be made,\n               and the source program output will be placed in\n               the sequential dataset USER02.IECIOSCN.ASM.\n\n      //DISASM EXEC PGM=DISASM\n      //STEPLIB DD DSN=SYS1.TECHLOAD,DISP=SHR\n      //SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=121\n      //SYSLIB DD DSN=SYS1.NUCLEUS,DISP=SHR\n      //SYSPUNCH DD DSN=USER02.IECIOSCN.ASM,DISP=(,CATLG),\n      //            UNIT=SYSDA,DCB=23440,\n      //            SPACE=(TRK,(5,2),RLSE)\n      //SYSIN DD *\n      IEANUC01 IECIOSCN\n      /*\n\n\n2. PARM field on the EXEC card: Omit the parm field, unless floating\n        point and/or privileged instructions are to be found in the\n        CSECT being disassembled. When the parm field is not specified,\n        entries for the privileged and floating point instructions are\n        erased from the internal instruction tables used during\n        disassembly. Valid PARM fields are:\n\n            PARM=(SUPVR)     assemble privileged instructions\n            PARM=(FLTPT)     assemble floating point instructions\n            PARM=(SUPVR,FLTPT) assemble both privileged and\n                             floating point instructions.\n\n\n3. Control cards entered in the SYSIN dataset.\n        Data is contained only in columns 1-72. Columns 73-80 may be\n        used for any desired purpose. Comment cards may be entered with\n        an asterisk (*) in column 1. In addition, columns beyond the\n        last specified may be used for any purpose. Leading zeros must\n        be included in all fields giving hex or decimal data. Name\n        fields must be left justified with trailing blanks. Hex fields\n        may contain only the hex digits 0-9 and A-F, while decimal\n        fields may contain only digits 0-9.  The MODUKE-CSECT card must\n        be the first card in the input stream. DSECT definitions may not\n        include any other control cards. Using cards for DSECTs must be\n        entered at some point after the DSECT definition. Data-only\n        cards and program USING cards may be entered in any order except\n        within DSECT definitions.\n\n\n   a. MODULE-CSECT card (required), must be the first card in the SYSIN\n        stream. Specifies the module name and CSECT name. Module name\n        is required, and must name an entry in the directory of the PDS\n        specified by the SYSLIB DD card. CSECT name is optional. If\n        specified, the named CSECT must exist in the module. If omitted,\n        the CSECT with ESDid=0001 is disassembled.\n      format: free-form, with module name preceding CSECT name.\n              At least one blank must separate module name and\n              CSECT name. The names may be surrounded by any number\n              of blanks (see the JCL example).\n\n\n   b. Data-only card (optional). Used to describe areas of the CSECT\n                being disassembled which contain no instructions. Use of\n                this card eliminates creation of instructions from\n                constant data. Up to 256 data-only cards may be entered.\n                These cards may occur anywhere in the SYSIN stream after\n                the MODULE-CSECT card, but not within a DSECT definition\n                set.\n      format:\n              col  1-4  : literal 'data'\n              col   5   : blank\n              col  6-11 : offset to beginning of area in hex\n              col   12  : blank\n              col 13-18 : offset to end of area in hex\n\n\n\n   c. DSECT definitions (optional). A DSECT is defined by a header card\n              followed by a variable number of field definition cards\n              (up to 9999 of them). No other control card may be entered\n              within a DSECT definition. Up to 256 DSECT definitions may\n              be entered.\n\n      DSECT header card format:\n           col 1-8    : DSECT name\n           col 9      : blank\n           col 10-14  : literal 'DSECT'\n           col 15     : blank\n           col 16-19  : number of field cards to follow (decimal)\n\n      DSECT field card format:\n           col 1-8    : field name\n           col 9      : blank\n           col 10-13  : offset to left end of field (decimal)\n                        maximum offset is 4095\n           col 14     : blank\n           col 15-17  : length of field in bytes (decimal)\n                        maximum length is 256\n\n\n\n   d. Ulabl cards. These cards define user labels to be placed on\n                 statements within the program. If program base\n                 registers are set up with using cards, these will also\n                 be generated as symbolic operands on instructions.\n                 Format is:\n\n           col  1-5   : literal 'ulabl'\n           col   6    : blank\n           col  7-14  : label name\n           col  15    : blank\n           col 16-21  : offset to left end of field, in hex.\n           col  22    : blank\n           col 23-25  : length of field in dec. 256 is max.\n\n\n\n   e. Using cards. These cards define base register usage. Up to 256\n                 using cards may be entered. Use of these cards permits\n                 the disassembler to convert explicit base-displacement\n                 addresses to symbolic labels. Labels created within the\n                 program will be 7 characters long. The first character\n                 is 'A', followed by the 6-hex-digit offset to the\n                 label. A using card must be entered for each DSECT to\n                 be used.\n\n     format:\n\n          col 1-5   : literal 'USING'\n          col 6     : blank\n          col 7-12  : offset to begin loc for using range in hex\n                      (this is where the using statement will occur)\n          col 13    : blank\n          col 14-19 : offset to ending loc for using range in hex\n                      (this is where the drop statement will occur)\n          col 20    : blank\n          col 21    : base resister to be used (hex, 1-F)\n          col 22    : blank\n          col 23    : type, P=program base, D=DSECT base\n          col 24    : blank\n          col 25-30 : initial base register value if type P in hex\n          col 25-32 : DSECT name if type D\n\n\n4. Suggestions for use: On the first pass, do not use a SYSPUNCH DD\n          card, but print the SYSPRINT listing. Use the listing to\n          determine which registers are used as program base registers,\n          their initial values, and their ranges. Make up USING cards\n          for these. Find any places where no instructions should be\n          generated (only constants), and make up data-only cards for\n          these ranges. If you can determine any registers that are\n          bases for areas which can be used for DSECTs (CVT reference,\n          etc.), determine the range of valid use, and make up DSECT\n          definitions and using cards for these. Make a second run,\n          including the above cards, and creating a source program\n          output with the SYSPUNCH DD card.\n\n\n\n5. Output description:\n\n   a. SYSPUNCH: this output contains the disassembled source program.\n           Statement names begin in column 1, mnemonics begin in column\n           10, operands in col 16, and an occasional comment begins in\n           column 44. A sequence number (by tens) is in columns 73-80.\n           Comments are included to show the macro name associated with\n           SVC's, and other statements are flagged to aid in\n           identification of certain operations:\n\n                BALR 14,15              STD LINKAGE\n                BALR X,0                ADDRESS SET\n                other BALR'S            NON-STD LINKAGE\n                BAL 0,XXX and BAL 1,XXX PARM SET BRCH\n                BAL X,XXX               PERFORM\n                STM instructions        SAVE REGS\n                LM  instructions        RESTORE REGS\n                BR R14                  EXIT\n                Abs. location X'10'     CVT ADDRESS\n                Abs. location X'4C'     CVT ADDRESS\n                Other abs. locations    PSA REFERENCE\n\n           When used in explicitly in instructions, registers are\n           specified as R0, R1,... R15. An REQU macro is generated at\n           the end of the program to create the appropriate EQU\n           statements. If any DSECTs were defined in the SYSIN dataset,\n           they will be near the end of the source program. The extended\n           mnemonics are used for conditional branches wherever\n           possible.\n\n\n\n    b. SYSPRINT content:\n\n       directory information: contains data from the directory\n                              entry of the module containing\n                              the CSECT to be disassembled.\n       ESD table: a formatted list of all external symbol entries\n                              found in the module.\n       RLD table: a formatted listing of all relocation dictionary\n                              entries pertaining to this CSECT.\n       user entered cards: a list of the cards entered by the user,\n                              with diagnostics, if appropriate.\n       phase 1 label table: a list of all the labels to be used during\n                              disassembly including those developed from\n                              ESD entries, RLD entries, and generated\n                              names resulting from using card\n                              processing.\n       text: a storage-dump formatted listing of the text which\n                              comprises the CSECT being disassembled.\n       source listing: a printout of the generated source program\n                              statements, including the hex value which\n                              resulted in the instruction's creation.\n\n\n6. User Abends:\n\n        DISASM may end with one of two user abends:\n\n        U0777 - There is an invalid parm specified.\n        U0888 - Check in the SYSPRINT listing for an error message\n                describing the error causing the abend (e.g. table\n                overflow).\n\n\nProgram processing description.\n\n DISASM functions:\n\n . Process the parm field, if any: set indicators used by\n   DISASM1 and DISASM2 to set up their instruction tables.\n . Open all files.\n . Get storage for the symbol table, RLD table, and data-only\n   tables (109,544 bytes total).\n . Process the module-CSECT card to obtain the member\n   and CSECT names.\n . Issue BLDL against SYSLIB to obtain directory info for\n   the member specified. If the specified member is an\n   alias, re-issue a BLDL for the real member. Print\n   directory information.\n . Point to the member in the SYSLIB PDS, and process the\n   member. Load modules contain an external symbol dictionary\n   followed by text and relocation dictionary information.\n   all ESD info for the module precedes the first control\n   record. A control record precedes each block of text.\n   RLD info for the text follows each text block. Processing\n   of load module information is as follows:\n   a. Build an external symbol table, using the CESD blocks.\n   b. Search for the desired CSECT as the table is being built. This\n      CSECT must be found before the first control record.\n   c. Read blocks until a control record for the desired CSECT is found\n      (by ESD-id).\n   d. When found, issue GETMAIN for an area large enough to contain the\n      entire text.\n   e. Place text blocks in contiguous storage locations and maintain\n      during disassembly.\n   f. Use RLD information for the CSECT to build the RLD table.\n . Load and perform DISASM1.\n . If any errors found by DISASM1, terminate processing.\n . Print the final label table to be used during disassembly.\n . Load and execute DISASM2.\n . Generate the DSECT entries.\n . Generate the REQU macro and end statements\n . Terminate processing\n\n\n\n DISASM1 functions:\n\n DISASM1 is the second phase of disassembly, and is performed by\n DISASM. A common data area, defined in DISASM, is passed to this\n program on entry.\n\n The SYSIN file is read to exhaustion. Using cards are reformatted and\n stored in a table - up to 256 using statements may be entered. DSECT\n cards may follow the using statements. When used, DSECT statements are\n reformatted, and built into tables. A maximum of 256 DSECTs may be\n entered. Data only cards may be included before, between, or after\n DSECTs to show areas in the program where no instructions occur. Up to\n 256 data only areas may be specified.\n\n At eof on SYSIN, a pseudo dis-assembly pass is made using the text\n stored by disasm. Any resolvable address within the text is used to\n create a new entry in the label table, which will be used by DISASM2\n in the actual dis-assembly pass.\n\n Disassembly tables are set up similarly to those used by DISASM2 for\n the simulated disassembly performed in this module when any program\n base register using statements are entered.\n\n Storage is obtained for the DSECT table and using table, and addresses\n of these tables are stored in the common parameter area. Using and\n DSECT cards are edited, reformatted, and placed in the appropriate\n tables. If any errors are found, they are printed, and the disassembly\n will be terminated on return to disasm.\n\n Storage is obtained for the label table, and a simulated dis-assembly\n is performed to create label table entries for labels which will be\n generated for base-displacement addresses by DISASM2. On return to\n disasm, these labels will be sorted with external symbol and RLD\n labels to form the final label table to be used by DISASM2.\n\n\n\n DISASM2 functions:\n\n This sub-program is called by DISASM after completion of processing by\n DISASM1. The final label table and module text is in an area of\n storage. A common parameter area is defined in disasm, and passed to\n this program.\n\n Text bytes are used to create assembly language statements, and\n machine instruction statements. Output is written to the SYSPUNCH\n dataset for further processing by other modules.\n\n A text byte is considered to be an instruction if it occurs on a\n halfword boundary, is a valid op-code, and is followed by a valid\n op-code. Unconditional branches need not be followed by a valid\n op-code, however. The privileged and floating point instructions are\n not treated as instructions unless the user specified their inclusion\n at exec time.\n\n\n\nInstallation.\n\n a. Assemble and link the three csects, DISASM, DISASM1, and DISASM2.\n    The three csects will all be linked into a single module with entry\n    point DISASM.\n b. If storage utilization is found to be excessive, investigate the\n    possibility of reducing the size of the table GETMAINs in DISASM\n    lines 1360, 1380, 1440, 1500, 5460, and 9450, and in DISASM1 lines\n    1520, 1610, 4160. The programs were written for ease of use with an\n    MVS operating system, and may cause problems in a storage\n    constrained environment.\n c. The SVC table and instruction op code tables in DISASM3A and\n    DISASM3B (which are copied into DISASM1 and DISASM2) should be\n    checked for operating system validity, and currency with the\n    hardware from time to time.\n d. Macros used by the disassembler include SVLNK and REQU. SVLNK is\n    used to establish addressability and chain save areas during\n    initialization in each program, and set up register equates by use\n    of the REQU macro. The REQU macro is also placed in each\n    disassembled program if these macros are used, they should be\n    placed in a macro library or prefixed to the source before\n    assembly. If other macros are used in their place, make appropriate\n    source code changes in DISASM, DISASM1, and DISASM2 before\n    assembly.\n\n e. Direct technical inquiries, comments, suggestions for improvements,\n    etc, to:\n         Dick Thornton\n         Blue Cross of Virginia\n         2015 Staples Mill Road\n         Richmond, Va. 23279\n         Phone: (804) 359-7248\n f. Version updated and modified January 1991 by:\n         Alan C Field\n         Wetterau Inc.,\n         345 Dunn Road,\n         Florissant, Mo., 63031-7995\n         Phone: (314) 839-7040\n g. Version updated and modified March 1991 by:\n         Robert Styma\n         AG Communication Systems\n         P.O. Box 52179\n         Phoenix, Az 85702-2179\n         Phone: (602) 582-7323\n    Made the 3 module format into a 1 module format. Changed the work\n    area sizes to be symbolics and bumped buffer area to handle max\n    length records. This is in DISASM1. Fatal messages are written to\n    the screen using TPUT in addition to going to the print file.\n    DISASM1 and DISASM2 have code which deals with BAS, BASSM and\n    similar instructions. Minor fixes for handling weak externs and\n    label problems. Changes to some of the 2 byte opcodes to show\n    they are not proviledged.\n i. Version updated and modified May 1992 by:\n         Alan C Field\n         Wetterau Inc.,\n         345 Dunn Road,\n         Florissant, Mo., 63031-7995\n         Phone: (314) 839-7040\n    Extensions to opcode tables, change format of printed listing to\n    look more like ASSEMBLER output (easier to read on 80 col screen)\n    and bug fixes where some instructions didn't dis-assemble correctly,\n    increases to some table sizes to handle BIG modules.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$REQU": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "FIELD"}, "text": "         MACRO\n         REQU\n**                           EQUATES FOR SYMBOLIC REG USAGE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nRA       EQU   10\nRB       EQU   11\nRC       EQU   12\nRD       EQU   13\nRE       EQU   14\nRF       EQU   15\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CBTJCL": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "FIELD"}, "text": "//CBT839 JOB 527TSO000S0008,ARNIE,CLASS=8,MSGCLASS=5,NOTIFY=TA15500\n//STEP01 EXEC BANNER,\n// PARM='SYSPRINTCBT839  DISASMBLCBT839  CBT839'\n//STEP02 EXEC ASMBLR,SO=5,P=AEV90,LIB='TS15500.CBT839.PDS'\n//SYSIN DD DISP=SHR,DSN=TS15500.CBT839.PDS(DISASM)\n//STEP03 EXEC TESTLINK,SO=5,LIB='SYS2.MLINKLIB',NAME=CBT839\n//STEP04 EXEC ASMBLR,SO=5,P=AEV90,LIB='TS15500.CBT839.PDS'\n//SYSIN DD DISP=SHR,DSN=TS15500.CBT839.PDS(DISASM1)\n//STEP05 EXEC TESTLINK,SO=5,LIB='SYS2.MLINKLIB',NAME=DISASM1\n//STEP06 EXEC ASMBLR,SO=5,P=AEV90,LIB='TS15500.CBT839.PDS'\n//SYSIN DD DISP=SHR,DSN=TS15500.CBT839.PDS(DISASM2)\n//STEP07 EXEC TESTLINK,SO=5,LIB='SYS2.MLINKLIB',NAME=DISASM2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLIST": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x00?\\x00?\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "FIELD"}, "text": "PROC 1 LIB PUNCHOUT(PUNCHOUT) PRINTOUT(PRINTOUT) SUPVR FLTPT LIST -\n       DIAGNOSE CONTROL(*) CALL(CALL) LOAD('')\n/*\n/*    THIS CLIST INVOLVES THE DISASSEMBLER:\n/*      (DISASSEMBLER IS A PRODUCT OF:\n/*        DISK THORNTON\n/*        BLUE CROSS OF VIRGINIA\n/*        2015 STAPLES MILL ROAD\n/*        RICHMOND, VA. 23279).\n/*\nIF ('&DIAGNOSE.' EQ 'DIAGNOSE')  -\n   THEN CONTROL   PROMPT   LIST   CONLIST   SYMLIST MSG\n   ELSE CONTROL NOPROMPT NOLIST NOCONLIST NOSYMLIST MSG\nIF &SUPVR = SUPVR THEN +\n    IF &FLTPT = FLTPT THEN +\n        SET &PARM = 'SUPVR,FLTPT'\n    ELSE +\n        SET &PARM = 'SUPVR'\nELSE +\n    IF &FLTPT = FLTPT THEN +\n        SET &PARM = 'FLTPT'\n    ELSE\n        SET &PARM = &STR()\nALLOC FI(SYSLIB) DA(&LIB) SHR REU\nCONTROL NOMSG\nFREE FI(SYSPUNCH) ATTR(DAPRATTR DAPUATTR)\nCONTROL MSG\nATTR DAPUATTR BLKSIZE(19040)\n%ALLOCDS FI(SYSPUNCH) DA(&PUNCHOUT) PRIME(60) USING(DAPUATTR)\nATTR DAPRATTR BLKSIZE(18997)\n%ALLOCDS FI(SYSPRINT) DA(&PRINTOUT) PRIME(90) USING(DAPRATTR)\nALLOC FI(SYSIN) DA(&STR(&CONTROL)) REUSE\nIF &STR(&CONTROL) \u00ac= &STR(*) -\nTHEN -\n   GOTO DOIT\nCLEAR\nWRITE ENTER CONTROL STATEMENTS:\nWRITE 1ST CARD: MODULE CSECT  (CSECT IS OPTIONAL)   <== REQUIRED 1ST CARD\nWRITE ALL OTHER CARDS ARE OPTIONAL--THEY INCLUDE:\nWRITE DATA ONLY CARD: 1-4='DATA';6-11=START OFFSET(HEX);13-18=END OFFSET(HEX)\nWRITE DSECT DEFINITIONS--HEADER AND DEFINITION CARDS:\n/* W AT THE END OF THE NEXT LINE WAS TRUNCATED, ADD IT BACK PLEASE\nWRITE  HEADER: 1-8=DSECT NAME;10-14='DSECT';16-19=# OF DEFINITION CARDS TO FOLLO\n/* TH AT THE END OF THE NEXT LINE WAS TRUNCATED, ADD IT BACK PLEASE\nWRITE  DEFINITION: 1-8=FIELD-NAME;10-13=DECIMAL OFFSET TO FIELD;15-17=FIELD LENG\nWRITE ULABL CARDS: 1-5='ULABL';7-14=LABEL-NAME;16-21=HEX OFFSET TO START;\nWRITE              23-25=LENGTH(DEC)\nWRITE USING CARD: 1-5='USING';7-12=BEGIN LOC(HEX)-IE, WHERE USING GOES;\nWRITE             14-19=END LOC(HEX)-IE, WHERE DROP GOES; 21=BASE(0-F);\nWRITE             23=TYPE('P'=PROGRAM,'D'=DSECT);\nWRITE             25-30=INITIAL BASE VALUE-FOR TYPE 'P'\nWRITE             25-32=DSECT NAME-FOR TYPE 'D'\nWRITE ---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+\nDOIT: +\n&CALL. 'QC22505.TSO&LOAD..LOAD(DISASM)' &PARM\nIF &CALL=TEST THEN GOTO DONE\nWRITE ******  END OF DISASSEMBLY  ******\nIF &LIST=LIST THEN -\n   LIST PUNCHOUT\nWRITE SEE DATASET &PRINTOUT FOR LISTING;\nWRITE SEE DATASET &PUNCHOUT FOR DECK.\nTERMIO\nDONE: SET A = 1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x06\\xe8\\x06\\xe8\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 1768, "newlines": 1768, "modlines": 0, "user": "FIELD"}, "text": "DIS      TITLE ' DISASSEMBLY PHASE 0 '\n         MACRO\n&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=\n         GBLC  &EQU\n         GBLC  &GM\n         GBLC  &CSECT\n         LCLC  &REGA\n         AIF   (T'&NAME EQ 'O').NOCSECT\n         AIF   ('&NAME' EQ '*').NOCSECT\n&CSECT   SETC  '&NAME'\n&CSECT   CSECT                         NAME OF PROGRAM\n         AGO   .RST\n.NOCSECT ANOP\n&CSECT   SETC  '*'\n         CSECT                         BEGINNING OF PROGRAM\n.RST     ANOP\n         AIF   ('&EQU' EQ 'ON').NRQ\n&EQU     SETC  'ON'\n*\n***REGISTER EQUATES***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.NRQ     ANOP\n*\n*******************  PROGRAM INITIALIZATION  *************************\n*\n         AIF   (T'&REG1 EQ 'O').NOREG\n&REGA    SETC  '&REG1'\n         AIF   (T'&REG2 EQ 'O').ONEREG\n         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY\n         AGO   .BYUSE\n.NOREG   ANOP\n&REGA    SETC  'R3'\n.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY\n.BYUSE   ANOP\n         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA\n         LR    &REGA,R15                  INITIALIZE BASE REG\n         AIF   (T'&REG2 EQ 'O').NOLA\n         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND\n         LA    &REG2,1(&REG2)                BASE REGISTER\n.NOLA    ANOP\n         AIF   (T'&REG3 EQ 'O').NOLNK\n         L     &REG3,0(R1)                GET PARAMETER LIST ADDR\n.NOLNK   ANOP\n         AIF (T'&IND EQ 'O').GETIT\n         CNOP  0,4\n         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA\nSAVEAREA DS    18F                     REGISTER SAVE AREA\n         ST    R15,8(R13)\n         ST    R13,SAVEAREA+4\n         LR    R13,R15\n         AGO   .NOSAVE\n.GETIT   ANOP\n         AIF   (T'&LV EQ 'O').GMD\n&GM      SETC  '&LV'\n         AGO   .DGM\n.GMD     ANOP\n&GM      SETC  '72'\n.DGM     ANOP\n*\n***GET MAIN STORAGE FOR SAVE AREA***\n*\n         AIF   ('&GM' LT '4096').LA\n         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA\n         AGO   .EGM\n.LA      ANOP\n         LA    R0,&GM                  GET &GM BYTES\n         GETMAIN R,LV=(0)\n.EGM     ANOP\n*\n***SET UP SAVE AREA POINTERS***\n*\n         ST    R1,8(R13)               STORE LOW SAVE POINTER\n         ST    R13,4(R1)               STORE HIGH SAVE POINTER\n         LR    R13,R1                  INITIALIZE SAVE POINTER\n         AIF   (T'&REG3  NE 'O').NOSAVE\n         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG\n         L     R1,24(R1)               RESTORE PARAMETER REGISTER\n.NOSAVE  ANOP\n         AIF   ('&CSECT' EQ '*').EXIT\n         B     *+12\n         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.\n.EXIT    ANOP\n*\n*********************  END INITIALIZATION  ***************************\n*\n         MEND\n         EJECT\nDISASM   SVLNK R3,R4\n*        PRINT NOGEN\n*DISASSEMBLER PROGRAM TO CREATE AN ASSEMBLER SOURCE PROGRAM\n*FROM A LOAD MODULE IN A PDS. DD CARDS REQUIRED INCLUDE\n*SYSPRINT FOR MESSAGES AND DIAGNOSTICS USING BLKSIZE A MULTIPLE\n*OF 121, SYSLIB SPECIFYING THE PDS CONTAINING THE MEMBER,        FIX***\n*WHICH MUST BE A PDS, SYSPUNCH FOR THE ASSEMBLER SOURCE\n*PROGRAM, HAVING BLKSIZE A MULTIPLE OF 80, AND SYSIN\n*FOR THE CONTROL CARD INPUT. CONTROL INPUT MAY OPTIONALLY\n*BE ENTERED VIA THE PARM ON THE EXECUTE CARD. CONTROL\n*INFORMATION INCLUDES THE MEMBER NAME AND CSECT NAME\n*TO BE DISASSEMBLED. IF CSECT NAME IS OMITTED, THE CSECT\n*FOR ESD-ID 0001 WILL BE USED.\n*\n*\n* FILES USED BY THIS PROGRAM INCLUDE THE FOLLOWING:\n*\n* DDNAME SYSLIB: RECFM=U. INPUT LOAD MODULE LIBRARY.\n*\n* DDNAME SYSPUNCH: RECFM=FB,LRECL=80. OUTPUT FILE CONTAINING\n*                 DISASSEMBLED TEXT. (MAXBLK=18,960)\n*\n* DDNAME SYSPRINT: RECFM=FBA,LRECL=121.  PRINTED OUTPUT CONTAINING A\n*                LIST OF THE ESD TABLE, RLD TABLE, AND TEXT.\n*                (MAXBLK=18997)\n* DDNAME LOADLIB: (OPTIONAL) NAMES A PDS CONTAINING THE\n*                 MODULES OF DISASM IF DIFFERENT FROM\n*                 THE STEPLIB. USED PRIMARILY FOR TSO.\n*\n* DDNAME SYSIN: RECFM=FB, LRECL=80. CONTROL CARD INPUT.\n*\n*\n* THE CONTROL CARD PROVIDES THE MEMBER NAME AND CSECT NAME\n* OF THE PROGRAM TO BE DISASSEMBLED. MEMBER NAME IS REQUIRED.\n* IF CSECT NAME IS OMITTED, THE CSECT WITH ESDID 0001 WILL\n* BE USED. FORMAT IS FREE-FORM. MEMBER NAME MUST PRECEDE CSECT\n* NAME. ANY NUMBER OF BLANKS MAY PRECEDE AND FOLLOW MEMBER NAME.\n* A COMMA MAY IMMEDIATELY FOLLOW MEMBER NAME IF DESIRED.\n*\n*\n* PARM DATA FROM THE EXECUTE CARD MAY BE USED TO SPECIFY\n* VALIDITY OF PRIVILEGED OR FLOATING POINT INSTRUCTIONS.\n* IF NOT SPECIFIED, PRIVILEGED AND FLOATING POINT OPERATION\n* CODES WILL NOT BE TREATED AS INSTRUCTION OP-CODES. TO\n* INCLUDE THESE INSTRUCTIONS, CODE:\n*     PARM=(SUPVR)      PRIVILEGED INSTRUCTIONS\n*     PARM=(FLTPT)      FLOATING POINT INSTRUCTIONS\n*     PARM=(SUPVR,FLTPT) BOTH\n*\n*\n*PROCESSING FLOW:\n* 1. PROCESS THE CONTROL INFORMATION TO OBTAIN THE MEMBER\n*    AND CSECT NAMES.\n* 2. ISSUE BLDL AGAINST SYSLIB TO OBTAIN DIRECTORY INFO FOR\n*    THE MEMBER SPECIFIED. IF THE SPECIFIED MEMBER IS AN\n*    ALIAS, RE-ISSUE A BLDL FOR THE REAL MEMBER. PRINT\n*    DIRECTORY INFORMATION.\n* 3. POINT TO THE MEMBER IN THE SYSLIB PDS, AND PROCESS THE\n*    MEMBER. LOAD MODULES CONTAIN AN EXTERNAL SYMBOL DICTIONARY\n*    FOLLOWED BY TEXT AND RELOCATION DICTIONARY INFORMATION.\n*    ALL ESD INFO FOR THE MODULE PRECEDES THE FIRST CONTROL\n*    RECORD. A CONTROL RECORD PRECEDES EACH BLOCK OF TEXT.\n*    RLD INFO FOR THE TEXT FOLLOWS EACH TEXT BLOCK. PROCESSING\n*    OF LOAD MODULE INFORMATION IS AS FOLLOWS:\n*    A. BUILD AN EXTERNAL SYMBOL TABLE, USING THE CESD BLOCKS.\n*    B. SEARCH FOR THE DESIRED CSECT AS THE TABLE IS BEING\n*       BUILT. THIS CSECT MUST BE FOUND BEFORE THE FIRST\n*       CONTROL RECORD.\n*    C. READ BLOCKS UNTIL A CONTROL RECORD FOR THE DESIRED\n*       CSECT IS FOUND (BY ESD-ID). WHEN FOUND, SAVE THE\n*       TEXT FOR DISASSEMBLY, AND USE THE FOLLOWING RLD\n*       INFORMATION TO BUILD A RELOCATION DICTIONARY TO BE USED\n*       DURING DISASSEMBLY.\n* 4. DISASSEMBLY USES THE EXTERNAL SYMBOL TABLE, RELOCATION\n*    DICTIONARY, AND TEXT BUILT BY THE PREVIOUS STEPS.\n*\n*\n* AUTHOR R THORNTON - NOV 1977\n*\n* UPDATES BY R. STYMA  JAN 1989\n* UPDATE SGLOP TABLES IN PHASE 1 AND PHASE2 TO CONTAIN XA ONLY\n* INSTRUCTIONS LIKE BSM, BAS, AND SO ON.  ALSO IDENTIFY BSM AND\n* BAS AS BRANCH INSTRUCTIONS IN PHASES 1 AND 2.\n* UPDATE INPUT BUFFER LENGTH TO CONTAIN MAX BSAM BLOCK SIZE.\n* CHANGE GETMAIN LENGTHS TO CONSTANTS.\n*\n* UPDATED ALAN C FIELD - APR 1990\n*\n* UPDATES BY R. STYMA  MAR 1991\n* MERGED CHANGES BY ALAN C FIELD WITH PREVIOUS CHANGES BY MYSELF\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS THE PARM FIELD, IF ANY.                              *\n*                                                              *\n****************************************************************\n*\n         L     R12,0(R1)               GET PARM FIELD ADDRESS\n         SR    R1,R1                   CLEAR WORK REG\n         ICM   R1,3,0(R12)             PICK UP PARM LENGTH\n         BZ    OPENS                   NO PARM INFO ENTERED\n         CH    R1,H5                   5-BYTES OF PARM\n         BE    SGLPARM                 YES, SINGLE PARM FIELD\n         CH    R1,H11                  11-BYTES OF PARM\n         BE    DBLPARM                 YES, BOTH PARMS\nBADPARM  WTO   'INVALID PARM, SPECIFY ONLY SUPVR AND/OR FLTPT',        X\n               ROUTCDE=11\n         ABEND 777,DUMP\nSGLPARM  CLC   2(5,R12),=C'SUPVR'      IS PARM=SUPVR\n         BE    SUPARM                  YES\n         CLC   2(5,R12),=C'FLTPT'      PARM IS FLTPT\n         BNE   BADPARM                 NO, ERROR\n         MVI   FLPTASM,1               SET FLOATING POINT O.K.\n         B     OPENS                   CONTINUE\nDBLPARM  CLC   2(5,R12),=C'SUPVR'      IS 1ST PARM SUPVR\n         BE    CK2FPT                  YES\n         CLC   2(5,R12),=C'FLTPT'      IS 1ST PARM FLTPT\n         BNE   BADPARM                 NO, ERROR\n         CLC   8(5,R12),=C'SUPVR'      IS 2ND PARM SUPVR         FIX***\n         BNE   BADPARM                 NO, ERROR\n         B     FPT2PARM                BOTH O.K.\nCK2FPT   CLC   8(5,R12),=C'FLTPT'      IS 2ND PARM FLTPT         FIX***\n         BNE   BADPARM                 YES\nFPT2PARM MVI   FLPTASM,1               SET FLOATING POINT O.K.\nSUPARM   MVI   PRIVASM,1               SET PRIVILEGED INSTR O.K.\nOPENS    RDJFCB LOADLIB                WAS LOADLIB DD CARD INCLUDED\n         LTR   R15,R15                 JFCB READ O.K.\n         BNZ   OPEN1                   NO, DONT OPEN\n         OPEN  LOADLIB                 GOT DD CARD, OPEN FILE\n*\n****************************************************************\n*                                                              *\n* GET STORAGE FOR THE SYMBOL TABLE, RLD TABLE, AND DATA-ONLY   *\n* TABLES, AND OPEN FILES.                                      *\n*                                                              *\n****************************************************************\n*\nOPEN1    OPEN  (SYSPRINT,OUTPUT,SYSPUNCH,OUTPUT)\n         OPEN  (SYSLIB,,SYSIN)         OPEN FILES\n         TM    SYSIN+48,X'10'          DID SYSIN OPEN O.K.\n         BZ    NOCTL                   NO\n         BAL   R9,GETCTL               EXTRACT DESIRED MEMBER AND CSECT\n         BAL   R9,BLDL                 ISSUE BLDL AND PRINT\n         MVI   CCAT,0                  INSURE TTR0\n         POINT SYSLIB,TTRMOD           POINT TO 1ST BLOCK OF MODULE\n*        GET BUFFER STORAGE\n         GETMAIN RU,LV=32768,BNDRY=PAGE,LOC=BELOW\n         ST    R1,BUFAD                SAVE BUFFER ADDRESS\n         GETMAIN R,LV=SYMTABL          GET SYMBOL TABLE STORAGE\n         ST    R1,SYMTBAD              SAVE SYMBOL TABLE ADDRESS\n         ST    R1,CURRSYM              SAVE CURRENT SYMBOL ADDR\n         MVI   0(R1),X'FF'             TABLE END INDIC\n         A     R1,ENDSYM               COMPUTE END ADDR\n         ST    R1,ENDSYM               STORE TBL END ADDR\n         GETMAIN R,LV=RLDTABL          GET RLD TABLE STORAGE\n         ST    R1,RLDTBL               SAVE RLD TABLE ADDRESS\n         ST    R1,CURRLD               SAVE CURRENT RLD ADDR\n         MVI   0(R1),X'FF'             TABLE END INDIC\n         A     R1,ENDRLD               COMPUTE END ADDR\n         ST    R1,ENDRLD               STORE TBL END ADDR\n         GETMAIN R,LV=DATOLEN+8        GET DATA ONLY TABLE STORAGE\n         ST    R1,DATONLY              SAVE TBL ADDRESS\n         MVC   0(3,R1),HIVAL           SET END VALUE\n         ST    R1,DATOCUR              SET CURRENT ADDRESS\n         A     R1,ENDATO               COMPUTE TABLE END ADDR\n         ST    R1,DATOEND              SAVE END ADDR\n         MVC   PRT+15(29),=C'*** EXTERNAL SYMBOL TABLE ***'\n         MVI   PCC,C'-'                SET SKIP 3 LINES\n         BAL   R9,PRINT                PRINT\n         MVC   PRTLINE,SYMHDR          SYM TBL HEADER\n         BAL   R9,PRINT                PRINT\n*\n*\n*\n****************************************************************\n*                                                              *\n* MAINLINE PROCESSING FOR THE LOAD MODULE. THE DIRECTORY ENTRY *\n* AND TEXT ARE PROCESSED.                                      *\n*                                                              *\n****************************************************************\n*\nMAINLINE EQU   *                       MAINLINE ROUTINE\n         L     R6,BUFAD                GET BUFFER ADDRESS\n         READ  DECB,SF,SYSLIB,(6),'S'  READ BLOCK FROM MEMBER\n         CHECK DECB                    AWAIT COMPLETION\n         CLI   0(R6),X'20'             CESD RECORD\n         BNE   TESTOTHR                NO\n         BAL   R9,CESDREC              PROCESS CESD RECORDS\n         B     MAINLINE                GO READ AGAIN\nTESTOTHR LA    R9,CNTLRECS             ASSUME CONTROL RECORD\n         CLI   0(R6),1                 IT IS CONTROL\n         BE    PERFORM                 YES\n         CLI   0(R6),5                 IS IT CONTROL\n         BE    PERFORM                 YES\n         CLI   0(R6),13                IS IT CONTROL\n         BE    PERFORM                 YES\n         LA    R9,RLDRECS              ASSUME RLD RECORD\n         CLI   0(R6),2                 IS IT RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),6                 IS IT RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),14                IS IT RLD\n         BE    PERFORM                 YES\n         LA    R9,CTRLRECS             ASSUME CONTROL AND RLD\n         CLI   0(R6),3                 IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),7                 IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         CLI   0(R6),15                IS IT CTL AND RLD\n         BE    PERFORM                 YES\n         B     MAINLINE                NONE OF THESE, SKIP\nPERFORM  TM    PROCESS,X'80'           WAS CSECT FOUND\n         BZ    MISSCS                  NO, ERROR\n         BALR  R9,R9                   PERFORM APPROPRIATE ROUTINE\n         TM    PROCESS,X'40'           MODULE PROCESSING DONE\n         BZ    MAINLINE                NO, GO READ AGAIN\n         MVI   EOFSW+1,0               SET END OF FILE SWITCH\n         B     ENDINIT                 GO COMPLETE PROCESSING\n*\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS LOAD MODULE CONTROL RECORDS. THESE RECORDS PRECEDE   *\n* TEXT RECORDS, WHICH ARE READ AND PLACED IN STORAGE IN CONTIG-*\n* UOUS LOCATIONS SO THAT THE TEXT FOR THE DESIRED CSECT WILL   *\n* ALL BE IN STORAGE FOR THE REMAINDER OF DISASSEMBLY.          *\n*                                                              *\n****************************************************************\n*\nCNTLRECS EQU   *                       CONTROL RECORD PROCESSING\n         ST    R9,CT9                  SAVE RETURN ADDR\n         SR    R8,R8                   CLEAR WORK\n         ICM   R8,7,9(R6)              LKED ASGND @ OF TXT\n         TM    0(R6),X'08'             RECORD PRECEDES LAST RECORD OF M\n         BZ    CNCKTYP                 NO\n         OI    PROCESS,X'40'           YES, SHOW PROCESSING COMPLETE\nCNCKTYP  TM    0(R6),X'02'             CONTROL AND RLD\n         BO    CNPASRLD                YES\n         LA    R12,16(R6)              @ CESD ENTRY NBR\n         B     CNCKESD                 CONTINUE\nCNPASRLD LH    R12,6(R6)               GET RLD SECTION LENGTH\n         LA    R12,16(R6,R12)          @ CESD ENTRY NBR\nCNCKESD  LH    R11,4(R6)               LENGTH OF CONTROL INFO SECTION\n         SRL   R11,2                   COMPUTE NBR CNTL ENTRIES\n         SR    R10,R10                 OFFSET TO 1ST BYTE\n         SR    R9,R9                   LENGTH OF TEXT\nCNCKESD1 CLC   ESDID,0(R12)            THIS THE DESIRED ESD   FIX***\n         BE    CNFNDIT                 YES\n         AH    R10,2(R12)              MAINTAIN OFFSET TO 1ST TEXT BYTE\n         LA    R12,4(R12)              TO NEXT CNTL ENTRY\n         BCT   R11,CNCKESD1            LOOP THRU CNTL ENTRIES  FIX***\n         B     READTEXT                GO READ FOLLOWING TEXT\nCNFNDIT  LH    R9,2(R12)               GET TEXT LENGTH\nREADTEXT READ  DECB,SF,,(6),MF=E       READ FOLLOWING TEXT RECORD\n         CHECK DECB                    AWAIT COMPLETION\n         LTR   R9,R9                   DOES IT CONTAIN DESIRED TEXT\n         BZ    CTXIT                   NO, SKIP IT\n         S     R8,START                (-) OFFSET IN MODULE    FIX***\n         AR    R8,R10                  ADD OFFSET OF PORTION IN RCD  **\n*           R8 SHOULD NOW CONTAIN THE OFFSET WITHIN THE CSECT\n*           THAT THIS BLOCK CONTAINS (TRICKY).\n*\n         A     R10,BUFAD               @ 1ST TEXT BYTE\n***      S     R8,START    MOVED UP    RELATIVIZE TEXT ADDR    FIX***\n         A     R8,TXTSTRT              @ PLACE TO MOVE TEXT\n         LR    R11,R9                  COPY LENGTH TO MOVE\n         MVCL  R8,R10                  MOVE TEXT TO STORAGE\nCTXIT    L     R9,CT9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS RLD RECORDS. A TABLE OF RLD DATA IS BUILT WHICH WILL *\n* LATER BE USED TO BUILD PROGRAM LABELS AND ADCONS.            *\n*                                                              *\n****************************************************************\n*\nRLDRECS  EQU   *                       RLD RECORD PROCESSING\n         TM    0(R6),X'08'             LAST RECORD OF MODULE\n         BZ    RLSV9                   NO\n         OI    PROCESS,X'40'           SHOW PROCESSING COMPLETE\nRLSV9    ST    R9,RL9                  SAVE RETURN ADDR\nRLDSW    NOP   RLDST                   FIRST TIME SWITCH\n         MVI   RLDSW+1,C'0'            RESET 1ST TIME SW\n         MVC   PRT+15(20),=C'***** RLD INFO *****'\n         MVI   PCC,C'-'                SKIP 3 LINES\n         BAL   R9,PRINT                PRINT\n         MVC   PRTLINE,RLDHDR          RLD HEADER\n         BAL   R9,PRINT                PRINT RLD HEADER\nRLDST    LH    R8,6(R6)                NBR BYTES OF RLD DATA\n         LA    R6,16(R6)               @ 1ST BYTE OF RLD DATA\n         AR    R8,R6                   END OF RLD DATA ADDR\n         L     R7,CURRLD               @ NEXT RLD TBL ENTRY\n         USING RLDTBLD,R7\n         LH    R10,0(R6)               RELOCATION POINTER\n         LH    R11,2(R6)               POSITION POINTER\n         LA    R6,4(R6)                PASS POINTERS\nRLDNXT   CLC   1(3,R6),START+1         RLD ADDR BELOW CSECT\n         BL    RLDSTEP                 LOW, IGNORE\n         CLC   1(3,R6),END+1           RLD ADDR ABOVE CSECT\n         BH    RLDSTEP                 HIGH, IGNORE\n         C     R7,ENDRLD               END OF RLD TBL\n         BE    RLDFULL                 YES, ERROR\n         STH   R10,RLDRP               SAVE RELOC PTR\n         STH   R11,RLDPP               POS PTR\n         PACK  RLDTYPE,0(1,R6)         INVERT FLAG BYTE\n         NI    RLDTYPE,X'0F'           CLEAR HI-ORDER\n         CLI   RLDTYPE,9               UNRESOLVED\n         BNE   RLDMOVLN                NO\n         MVI   RLDTYPE,8               YES, USE PREFERRED VALUE\nRLDMOVLN MVC   RLDLEN,0(R6)            FLAG BYTE\n         NI    RLDLEN,X'0F'            CLEAR HI-ORDER\n         SR    R12,R12                 CLEAR WORK\n         IC    R12,RLDLEN              PICK UP BYTE\n         SRL   R12,2                   SHIFT OUT DIR, IND BITS\n         LA    R12,1(R12)              ADD 1 = LENGTH\n         STC   R12,RLDLEN              LENGTH CODE\n         MVI   RLDDIR,C'+'             ASSUME POS RELOC\n         TM    0(R6),2                 IS IT POSITIVE\n         BZ    RLADMV                  YES\n         MVI   RLDDIR,C'-'             NO, SHOW NEGATIVE\nRLADMV   SR    R1,R1                   CLEAR WORK REG\n         ICM   R1,7,1(R6)              PICK UP ADDRESS\n         S     R1,START                RELATIVIZE WITHIN CSECT\n         STCM  R1,7,RLDADDR            SAVE RELATIVE ADDRESS\n         LA    R12,RLDRP               @ RELOC PTR\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+6(4),PRTABL         RELOC PTR\n         LA    R12,RLDPP               @ POS PTR\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+14(4),PRTABL        POS PTR\n         MVC   PRT+24(4),=C'ACON'      ASSUME A TYPE ADCON\n         CLI   RLDTYPE,0               IS IT ADCON\n         BE    RLDLN                   YES\n         MVC   PRT+24(4),=C'VCON'      ASSUME VCON\n         CLI   RLDTYPE,1               IS IT VCON\n         BE    RLDLN                   YES\n         MVC   PRT+22(6),=C'PRDISP'    ASSUME PSEUDO REG DISPL\n         CLI   RLDTYPE,2               IS IT P.R. DISPL\n         BE    RLDLN                   YES\n         MVC   PRT+22(6),=C'PRCUM'     ASSUME PSEUDO REG CUMUL DISPL\n         CLI   RLDTYPE,3               IS IT P.R. CUM DISPL\n         BE    RLDLN                   YES\n         MVC   PRT+21(10),=C'UNRESOLVED' ASSUME UNRESOLVED\n         CLI   RLDTYPE,8               IS IT UNRESOLVED\n         BE    RLDLN                   YES\n         MVC   PRT+21(10),BLANX        CLEAR FIELD\n         MVC   PRT+24(3),=C'??:'\n         LA    R12,RLDTYPE             @ TYPE\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(1),PRTABL+1      TYPE\nRLDLN    MVC   PRT+35(1),RLDLEN        LENGTH\n         OI    PRT+35,C'0'             CLEAR ZONE\n         MVC   PRT+42(1),RLDDIR        RELOCATION DIRECTION\n         LA    R12,RLDADDR             @ ADDRESS\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+46(6),PRTABL        ADDRESS\n         XC    RLDNAME(9),RLDNAME      CLEAR\n         LH    R15,RLDRP               GET RELOCATION POINTER\n         BCTR  R15,R0                  DEDUCT 1\n         LTR   R15,R15                 TEST DIFFERENCE\n         BM    RLPRT                   NEG, ERROR\n         MH    R15,SYMLEN              TIMES SYM TBL ENTRY LENG\n         A     R15,SYMTBAD             @ ESD SYMBOL TBL ENTRY\n         C     R15,CURRSYM             PAST END OF TABLE\n         BH    RLPRT                   YES, ERROR\n         USING SYMTBL,R15\n         MVC   RLDNAME,EXTSYM          ESD SYMBOL TO RLD TBL ENTRY\n         MVC   RLDESDTP,TYPSYM         ESD TYPE TO RLD ENTRY\n         DROP  R15\n         MVC   PRT+60(8),RLDNAME       NAME TO PRINT\n         MVC   PRT+70(2),=C'LR'        ASSUME LR\n         CLI   RLDESDTP,3              IS IT LR\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'SD'        ASSUME SD\n         CLI   RLDESDTP,0              IS IT SD\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'ER'        ASSUME ER\n         CLI   RLDESDTP,2              IS IT ER\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'PC'        ASSUME PC\n         CLI   RLDESDTP,4              IS IT PC\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'PR'        ASSUME PR\n         CLI   RLDESDTP,6              IS IT PR\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'CM'        ASSUME CM\n         CLI   RLDESDTP,5              IS IT CM\n         BE    RLPRT                   YES\n         MVC   PRT+70(2),=C'WX'        ASSUME WX\n         CLI   RLDESDTP,X'0A'          IS IT WX\n         BE    RLPRT                   YES\n         MVC   PRT+70(4),=C'NULL'      ASSUME NULL\n         CLI   RLDESDTP,7              IS IT NULL\n         BE    RLPRT                   YES\n         MVC   PRT+70(6),=C'E/STAB'    ASSUME E/STAB\n         CLI   RLDESDTP,X'0F'          IS IT E/STAB\n         BE    RLPRT                   YES\n         MVC   PRT+70(6),=C'??????'    UNKNOWN TYPE\nRLPRT    BAL   R9,PRINT                PRINT\n         CLC   RLDNAME,CSECT           RLD NAME IS CSECT NAME\n         BNE   GOODRLD                 NO\n         CLC   RLDADDR,XZROS           RELATIVE OFFSET IS ZERO\n         BE    RLDSTEP                 YES, IGNORE ENTRY\nGOODRLD  LA    R7,L'RLDENT(R7)         TO NEXT TBL ENTRY\nRLDSTEP  TM    0(R6),1                 NEXT ITEM HAS REL AND POS PTRS\n         BO    RLSAME                  NO\n         LH    R10,4(R6)               PICK UP NEW REL PTR\n         LH    R11,6(R6)               PICK UP NEW POS PTR\n         LA    R6,4(R6)                STEP OVER 4 BYTES\nRLSAME   LA    R6,4(R6)                TO NEXT RLD ITEM\n         CR    R6,R8                   END OF RLD DATA\n         BL    RLDNXT                  NO\n         MVI   0(R7),X'FF'             SET TBL END INDIC\n         ST    R7,CURRLD               SET NEW CURRENT ADDRESS\n         L     R9,RL9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R7\n*\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS CONTROL AND RLD RECORDS. THESE RECORDS CONTAIN BOTH  *\n* RLD AND CONTROL INFORMATION, AND ARE PROCESSED BY BOTH       *\n* THE RLDRECS AND CNTLRECS ROUTINES.                           *\n*                                                              *\n****************************************************************\n*\nCTRLRECS EQU   *                       CONTROL AND RLD RECORDS\n         ST    R9,CR9                  SAVE RETURN ADDR\n         BAL   R9,RLDRECS              PROCESS RLD DATA\n         L     R6,BUFAD                RESET BUFFER ADDRESS\n         BAL   R9,CNTLRECS             PROCESS CONTROL DATA\n         L     R9,CR9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n*\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS COMPOSITE ESD RECORDS. DATA FROM THESE RECORDS IS    *\n* PLACED IN THE SYMBOL TABLE, AND IS USED TO CREATE PROGRAM    *\n* ENTRY STATEMENTS, AND TO IDENTIFY THE NAMES OF EXTERNAL      *\n* SYMBOLS USED BY THE PROGRAM.                                 *\n*                                                              *\n****************************************************************\n*\nCESDREC  EQU   *                       CESD RECORD PROCESSING\n         ST    R9,CES9                 SAVE RETURN\n         L     R7,CURRSYM              GET SYMBOL TBL ADDR\n         USING SYMTBL,R7\n         LH    R10,4(R6)               GET ESD ID OF 1ST ITEM\n         LH    R8,6(R6)                NBR BYTES OF ESD DATA\n         SRL   R8,4                    COMPUTE NBR ENTRIES\n         LA    R6,8(R6)                STEP TO 1ST RECORD ESD ITEM\nCESDNXT  C     R7,ENDSYM               END OF TABLE\n         BNL   SYMFULL                 YES, ERROR\n         MVC   EXTSYM,0(R6)            SYMBOL NAME\n         MVC   TYPSYM,8(R6)            TYPE\n         NI    TYPSYM,X'0F'            CLEAR BITS 0-3\n         MVC   SYMIND,8(R6)            INDICATOR BYTE\n         NI    SYMIND,X'0F'            CLEAR BITS 4-7\n         MVC   SYMARMOD,12(R6)         COPY RSECT/AMODE/RMODE BYTE\n         TM    8(R6),X'14'             POSSIBLE ENTAB/SEGTAB\n         BNO   CEMVAD                  NO\n         TM    8(R6),X'03'             IS IT ENTAB/SEGTAB\n         BNZ   CEMVAD                  NO\n         MVC   TYPSYM(2),=X'0F00'      SHOW ENTAB/SEGTAB\nCEMVAD   MVC   SYMADDR,9(R6)           ADDRESS OF SYMBOL\n         MVC   SYMSEG,12(R6)           SEGMENT WHERE DEFINED\n         MVC   SYMLENG,13(R6)          LENGTH OR LR ESD ID\n         STCM  R10,3,SYMESDID          ESD ID\n         MVC   PRT+5(8),EXTSYM         SYMBOL NAME\n         MVC   PRT+20(2),=C'SD'        ASSUME SD\n         CLI   TYPSYM,0                IS IT SD\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'LR'        ASSUME LR\n         CLI   TYPSYM,3                IS IT LR\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'ER'        ASSUME ER\n         CLI   TYPSYM,2                IS IT ER\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'PC'        ASSUME PC\n         CLI   TYPSYM,4                IS IT PC\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'PR'        ASSUME PR\n         CLI   TYPSYM,6                IS IT PR\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'CM'        ASSUME CM\n         CLI   TYPSYM,5                IS IT CM\n         BE    CEPIND                  YES\n         MVC   PRT+20(2),=C'WX'        ASSUME WX\n         CLI   TYPSYM,X'0A'            IS IT WX\n         BE    CEPIND                  YES\n         MVC   PRT+19(4),=C'NULL'      ASSUME NULL\n         CLI   TYPSYM,7                IS IT NULL\n         BE    CEPIND                  YES\n         MVC   PRT+18(6),=C'E/STAB'    ASSUME ENTAB/SEGTAB\n         CLI   TYPSYM,X'0F'            IS IT ENTAB/SEGTAB\n         BE    CEPIND                  YES\n         MVC   PRT+18(4),=C' ??: '     UNIDENTIFIABLE TYPE\n         LA    R12,TYPSYM              @ TYPE\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+23(2),PRTABL        TYPE\nCEPIND   LA    R12,SYMIND              @ INDICATOR\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(1),PRTABL        INDICATOR\n         LA    R12,SYMADDR             @ SYMBOL ADDR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+30(6),PRTABL        SYMBOL ADDR\n         LA    R12,SYMSEG              @ SEGMENT NBR\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+39(2),PRTABL        SEGMENT NBR\n         CLI   TYPSYM,2                IS IT ER\n         BE    CEESD                   YES\n         CLI   TYPSYM,3                IS IT AN LR\n         BNE   CENOTLR                 NO\n         LA    R12,SYMLRID             @ LR ESD ID\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+43(4),PRTABL        LR ESD ID\n         B     CEESD                   CONTINUE\nCENOTLR  LA    R12,SYMLENG             @ LENGTH\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+49(6),PRTABL        SYMBOL LENGTH\nCEESD    LA    R12,SYMESDID            @ ESD ID\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+57(4),PRTABL        ESD ID\n         MVC   PRT+65(3),=C'YES'       RSECT\n         TM    SYMARMOD,X'08'          YES\n         BO    CEAMODE\n         MVC   PRT+65(3),=C'NO '       RSECT\nCEAMODE  MVC   PRT+72(3),=C'ANY'       AMODE\n         TM    SYMARMOD,X'03'\n         BO    CERMODE\n         MVC   PRT+72(3),=C'31 '       31\n         TM    SYMARMOD,X'20'\n         BO    CERMODE\n         MVC   PRT+72(3),=C'24 '       24\nCERMODE  MVC   PRT+79(3),=C'ANY'       RMODE\n         TM    SYMARMOD,X'04'\n         BO    CECONT\n         MVC   PRT+79(3),=C'24 '\nCECONT   TM    PROCESS,X'80'           FOUND CSECT\n         BO    CESDPT                  YES\n         CLI   TYPSYM,0                SD\n         BE    CECKCSB                 YES\n         CLI   TYPSYM,4                PC\n         BNE   CESDPT                  NO\nCECKCSB  CLC   CSECT,BLANX             ANY CSECT NAME ENTERED\n         BNE   CECKNM                  YES\n         MVC   CSECT,EXTSYM            NAME TO CSECT\n         B     CSGOTCS                 CONTINUE\nCECKNM   CLI   TYPSYM,4                PC\n         BE    CESDPT                  YES\n         CLC   CSECT,EXTSYM            FOUND DESIRED NAME\n         BNE   CESDPT                  NO\n         TM    PROCESS,X'80'           ALREADY FOUND CSECT\n         BZ    CSGOTCS                 NO\n         MVC   PRT+15(2),=C'??'        SHOW DUPL\n         B     CESDPT                  CONTINUE\nCSGOTCS  OI    PROCESS,X'80'           SHOW CSECT FOUND\n         MVC   PRT+15(2),=C'**'        FLAG ON PRINTOUT\n         MVC   ESDID,SYMESDID          SAVE ESD ID FOUND\n         MVC   START+1,SYMADDR         SAVE CSECT START ADDR\n         MVC   LENGTH+1(3),SYMLENG     SAVE CSECT LENGTH\n         L     R1,LENGTH               PICK UP LENGTH\n         A     R1,START                COMPUTE CSECT END ADDR\n         ST    R1,END                  SAVE CSECT END ADDR\n         L     R11,LENGTH              TEXT LENGTH\n         LA    R11,256(R11)            ADD FOR SAFETY\n         GETMAIN R,LV=(11)             GET STORAGE FOR TEXT\n         ST    R1,TXTSTRT              SAVE TEXT ADDR\n         SH    R11,H256                DEDUCT SAFETY FACTOR\n         AR    R1,R11                  TXT END ADDR\n         ST    R1,TXTEND               SAVE TEXT END ADDR\nCESDPT   BAL   R9,PRINT                PRINT\n         LA    R7,L'SYMENT(R7)         TO NEXT TBL ENTRY LOCATION\n         LA    R10,1(R10)              ADD 1 TO ESD COUNTER\n         LA    R6,16(R6)               TO NEXT ESD ITEM IN INPUT\n         BCT   R8,CESDNXT              LOOP THRU INPUT RECORD\n         MVI   0(R7),X'FF'             SET END OF TABLE INDIC\n         ST    R7,CURRSYM              SAVE NEXT TABLE ADDR\n         L     R9,CES9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R7\n*\n*\n*\n****************************************************************\n*                                                              *\n* ISSUE BLDL FOR THE MAIN MODULE, AND PRINT MODULE RELATED INFO*\n*                                                              *\n****************************************************************\n*\nBLDL     EQU   *                       ISSUE BLDL AND PRINT INFO\n         ST    R9,BL9                  SAVE RETURN ADDR\nISSBLDL  BLDL  SYSLIB,BLDLIST          ISSUE BLDL\n         LTR   R15,R15                 ANY ERRORS\n         BNZ   MISSMEM                 YES\n         LA    R1,MEMBER+35            END OF BASIC PORTION\n         TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLREFA1                 NO\n         LA    R1,4(R1)                ADD FOR SSI\n         LR    R15,R1                  COPY FOR HALF WORD CHECK   ACF\n         SRL   R15,1                   SHIFT OUT LAST BIT         ACF\n         SLL   R15,1                   AND BACK AGAIN             ACF\n         CR    R1,R15                  CHECK AGAINST ORIGINAL     ACF\n         BE    BLREFA1                 NO ADJUSTMENT NECESSARY    ACF\n         LA    R1,1(R1)                NOW PTS TO HALFWORD BNDRY  ACF\nBLREFA1  TM    ALIASIND,X'80'          ALIAS\n         BZ    BLREFA2                 NO\n         LA    R1,11(R1)               ADD FOR ALIAS\nBLREFA2  TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLREFA3                 NO\n         LA    R1,8(R1)                ADD FOR SCATTER\nBLREFA3  MVC   AUTHLEN(2),0(R1)        AUTH LENGTH AND CODE\n         TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLCKALI                 NO\n         LA    R1,MEMBER+35            END OF BASIC PORTION\n         TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLSSI2                  NO\n         TM    ALIASIND,X'80'          ALIAS\n         BO    BLFMTED                 YES, NO REFORMAT NEEDED\n         LA    R1,8(R1)                NO, STEP PAST SCATTER SECTION\n         B     BLMVSSI                 GO MOVE SSI\nBLSSI2   TM    ALIASIND,X'80'          ALIAS\n         BZ    BLMVSSI                 NO\n         LA    R1,11(R1)               YES, STEP PAST ALIAS SECTION\nBLMVSSI  EQU   *                                                  ACF\n         LR    R15,R1                  COPY FOR HALF WORD CHECK   ACF\n         SRL   R15,1                   SHIFT OUT LAST BIT         ACF\n         SLL   R15,1                   AND BACK AGAIN             ACF\n         CR    R1,R15                  CHECK AGAINST ORIGINAL     ACF\n         BE    BLMVSSI1                NO ADJUSTMENT NECESSARY    ACF\n         LA    R1,1(R1)                NOW PTS TO HALFWORD BNDRY  ACF\nBLMVSSI1 MVC   SSI,0(R1)               MOVE SSI DATA\nBLCKALI  TM    ALIASIND,X'80'          ALIAS\n         BO    BLASC                   YES\n         B     BLFMTED                 FINISHED\nBLASC    TM    ATTR1A,X'04'            SCATTER FORMAT\n         BO    BLFMTED                 YES, NO REFORMAT NEEDED\n         MVC   ALMEM,MEMBER+38         MOVE ALIAS MEMBER\n         MVC   ALEPA(3),MEMBER+35      YES, MOVE ALIAS DATA\nBLFMTED  MVC   PRT(26),=C'DIRECTORY INFO FOR MODULE '\n         MVC   PRT+27(8),MEMBER        MEMBER NAME TO PRINT\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(14),=C'TTR OF MODULE='\n         LA    R12,TTRMOD              @ TTR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+24(6),PRTABL        TTR TO PRINT\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'CONCATENATION NBR='\n         LA    R12,CCAT                @ CONCATENATION NBR\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+28(2),PRTABL        CONCATENATION NBR\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(12),=C'ALIAS INDIC='\n         LA    R12,ALIASIND            @ ALIAS INDICATOR\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+22(2),PRTABL        ALIAS INDICATOR\n         TM    ALIASIND,X'80'          IS IT AN ALIAS\n         BZ    BLALPRT                 NO\n         MVC   PRT+50(13),=C'*** ALIAS ***'\nBLALPRT  BAL   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'TTR, 1ST TXT RECD='\n         LA    R12,TTR1TXT             @ TTR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+28(6),PRTABL        TTR OF 1ST TXT BLOCK\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(25),=C'TTR OF NOTE/SCATTER LIST='\n         LA    R12,TTRNS               @ TTR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+35(6),PRTABL        TTR OF NOTE/SCATTER\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(17),=C'NBR NOTE ENTRIES='\n         LA    R12,NNOTE               @ NBR NOTES\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+27(2),PRTABL        NBR NOTE ENTRIES\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'ATTRIBUTES 1='\n         LA    R12,ATTR1A              @ ATTRIBUTES\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+23(4),PRTABL        ATTRIBUTES 1\n         TM    ATTR1A,X'80'            RENT\n         BZ    BLAT1A                  NO\n         MVC   PRT+30(4),=C'RENT'\nBLAT1A   TM    ATTR1A,X'40'            REUS\n         BZ    BLAT1B                  NO\n         MVC   PRT+35(4),=C'REUS'\nBLAT1B   TM    ATTR1A,X'20'            OVLY\n         BZ    BLAT1C                  NO\n         MVC   PRT+40(4),=C'OVLY'\nBLAT1C   TM    ATTR1A,X'10'            TEST\n         BZ    BLAT1D                  NO\n         MVC   PRT+45(4),=C'TEST'\nBLAT1D   TM    ATTR1B,X'08'            OL\n         BZ    BLAT1E                  NO\n         MVC   PRT+50(2),=C'OL'\nBLAT1E   TM    ATTR1A,X'04'            SCTR\n         BZ    BLAT1F                  NO\n         MVC   PRT+53(4),=C'SCTR'\nBLAT1F   TM    ATTR1A,X'02'            EXEC\n         BZ    BLAT1G                  NO\n         MVC   PRT+58(4),=C'EXEC'\nBLAT1G   TM    ATTR1B,X'01'            REFR\n         BZ    BLAT1PRT                NO\n         MVC   PRT+63(4),=C'REFR'\nBLAT1PRT BAL   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'TOTAL LENGTH='\n         LA    R12,TOTVIRT             @ TOTAL LENGTH\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+23(6),PRTABL        TOTAL LENGTH OF MODULE\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(23),=C'LENGTH OF 1ST TXT RECD='\n         LA    R12,LENG1               @ 1ST TXT LENG\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+33(4),PRTABL        LENGTH OF 1ST TXT BLOCK\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(11),=C'E. P. ADDR='\n         LA    R12,LKEPA               @ E.P. ADDR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+21(6),PRTABL        E.P. ADDR\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(13),=C'ATTRIBUTES 2='\n         LA    R12,ATTR2               @ ATTRIBUTES 2\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+23(2),PRTABL        ATTRIBUTES 2\n         TM    ATTR2,X'20'             PAGE ALIGNMENT\n         BZ    BLAT3A                  NO\n         MVC   PRT+30(16),=C'PAGE ALIGN REQRD'\nBLAT3A   TM    ATTR2,X'10'             SSI PRESENT\n         BZ    BLAT3PRT                NO\n         MVC   PRT+50(11),=C'SSI PRESENT'\nBLAT3PRT BAL   R9,PRINT                PRINT\n         TM    ATTR1A,X'04'            SCATTER FORMAT\n         BZ    BLFAL                   NO\n         MVC   PRT+10(8),=C'SCTRLEN='\n         LA    R12,SCTRLEN             @ SCATTER LIST LENGTH\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+18(4),PRTABL        SCATTER LIST LENGTH\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'TRANSLATE TBL LEN='\n         LA    R12,TTLEN               @ TRANS TBL LEN\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+28(4),PRTABL        TRANSLATION TABLE LENGTH\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(18),=C'ESD ID OF 1ST TXT='\n         LA    R12,SCESDID             @ ESD ID\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+28(4),PRTABL        ESD ID OF 1ST TXT\n         BAL   R9,PRINT                PRINT\n         MVC   PRT+10(23),=C'ESD ID CONTAINING E.P.='\n         LA    R12,SCEPESD             @ ESD ID\n         BAL   R9,HEXPRT2              CONVERT\n         MVC   PRT+33(4),PRTABL        @ ESD ID OF CSECT CONTAINING E.P\n         BAL   R9,PRINT                PRINT\nBLFAL    TM    ALIASIND,X'80'          ALIAS\n         BZ    BLFSSI                  NO\n         MVC   PRT+10(28),=C'E.P. ADDRESS OF THIS MEMBER='\n         LA    R12,ALEPA               @ E.P. ADDR\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT+38(6),PRTABL        E.P. ADDR\n         BAL   R9,PRINT\n         MVC   PRT+10(17),=C'REAL MEMBER NAME='\n         MVC   PRT+27(8),ALMEM         REAL MEMBER NAME\n         BAL   R9,PRINT\nBLFSSI   TM    ATTR2,X'10'             ANY SSI INFO\n         BZ    BLAUTHC                 NO\n         MVC   PRT+10(9),=C'SSI INFO='\n         LA    R12,SSI                 @ SSI INFO\n         BAL   R9,HEXPRT4              CONVERT\n         MVC   PRT+19(8),PRTABL        SSI INFO\n         BAL   R9,PRINT                PRINT\nBLAUTHC  MVC   PRT+10(10),=C'AUTH CODE='\n         LA    R12,AUTHCOD             @ AUTH CODE\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+20(2),PRTABL        AUTH CODE\n         BAL   R9,PRINT                PRINT\nBLMODES  MVC   PRT+10(9),=C'AMODE=24 '\n         LA    R9,3                    BIT MASK FOR TM OF MAIN MEMBER\n         TM    ALIASIND,X'80'          ALIAS\n         BZ    *+8\n         LA    R9,12                   BIT MASK FOR TM OF ALIAS\n         EX    R9,EXTM                 AMODE OF MAIN/ALIAS\n         BZ    BLMODEP\n         MVC   PRT+16(3),=C'ANY'\n         BO    BLMODEP\n         MVC   PRT+16(3),=C'31 '\nBLMODEP  BAL   R9,PRINT                PRINT\n         MVC   PRT+10(9),=C'RMODE=24 '\n         TM    ATTR2A,X'10'            TEST FOR ANY RESIDENCE MODE\n         BZ    *+10                    BR ROUND NEXT MVC INSTR\n         MVC   PRT+16(3),=C'ANY'       MOVE IN ANY\n         BAL   R9,PRINT                PRINT\n         TM    ALIASIND,X'80'          ALIAS\n         BZ    BLXIT                   NO\n         MVC   PRT+5(38),=C'***** REAL MEMBER DIRECTORY INFO *****'\n         MVI   PCC,C'0'                DOUBLE SPACE\n         BAL   R9,PRINT                PRINT\n         MVC   MEMBER,ALMEM            REAL MEMBER NAME TO LIST\n         B     ISSBLDL                 DO OVER FOR REAL MEMBER\nBLXIT    L     R9,BL9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\nEXTM     TM    ATTR2A,X'00'            AMODE OF MAIN X'03', ALIAS X'0C'\n*\n*\n****************************************************************\n*                                                              *\n* CREATE PRINTABLE HEX FROM HEX. ON ENTRY, REG 12 CONTAINS THE *\n* ADDRESS OF THE DATA TO BE REFORMATTED. ENTRY POINT USED      *\n* DETERMINES THE SIZE OF THE FIELD. OUTPUT DATA IS PLACED IN   *\n* THE PRTABL FIELD, 2 CHARACTERS PER BYTE.                     *\n*                                                              *\n****************************************************************\n*\nHEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n*\n*\n*\n****************************************************************\n*                                                              *\n* PRINT USING SYSPRINT.                                        *\n*                                                              *\n****************************************************************\n*\nPRINT    EQU   *                       PRINT ROUTINE\n         TM    SYSPRINT+48,X'10'       IS SYSPRINT OPEN\n         BNO   TPUT                    NO\n         PUT   SYSPRINT,PRTLINE        WRITE PRINT LINE\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\nNEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n         BR    R9                      EXIT\nTPUT     DS    0H\n         TPUT  PRT,L'PRT\n         BR    R9                      EXIT\n*\n*\n****************************************************************\n*                                                              *\n* PROCESS THE CONTROL CARD CONTAINING MODULE NAME AND CSECT.   *\n* THIS MUST BE THE FIRST CARD IN THE SYSIN DECK.               *\n*                                                              *\n****************************************************************\n*\nGETCTL   EQU   *                       EXTRACT DESIRED MEMBER/CSECT\n         GET   SYSIN                   READ THE CONTROL CARD\n         LA    R12,72                  LENGTH OF CONTROL CARD\n         LA    R11,8                   MAX LENGTH OF MEMBER NAME\n         LA    R10,MEMBER              @ MEMBER NAME FIELD\nCKBLK1   CLI   0(R1),C' '              CONTROL BYTE IS BLANK\n         BNE   GCMEMOV                 NO, GO MOVE MEMBER NAME\n         LA    R1,0(R1)                TO NEXT CONTROL BYTE\n         BCT   R12,CKBLK1              SUBTRACT 1 FROM REMAINING LENGTH\n         B     GCEND                   ALL BLANKS, EXIT\nGCMEMOV  MVC   0(1,R10),0(R1)          CONTROL BYTE TO MEMBER NAME\n         LA    R1,1(R1)                TO NEXT CONTROL BYTE\n         BCTR  R12,R0                  SUBTRACT 1 FROM LENGTH\n         LA    R10,1(R10)              TO NEXT NAME BYTE\n         BCTR  R11,R0                  SUBTRACT 1 FROM LENGTH\n         CLI   0(R1),C' '              GOT A BLANK\n         BE    GCSETUP2                YES\n         CLI   0(R1),C','              GOT A COMMA\n         BE    GCSETUP2                YES\n         LTR   R12,R12                 END OF CONTROL DATA\n         BE    GCEND                   YES\n         LTR   R11,R11                 NAME FULL\n         BNZ   GCMEMOV                 NO, CONTINUE\n         B     NAMEOV8                 YES, NAME TOO LONG\nGCSETUP2 LA    R11,8                   CSECT NAME MAX LENGTH\n         LA    R10,CSECT               @ CSECT NAME FIELD\nGCSTEP2  LA    R1,1(R1)                STEP PAST BLANK\n         BCT   R12,GCHKBK2             CHECK NEXT FOR BLANK\n         B     GCEND                   END OF SCAN\nGCHKBK2  CLI   0(R1),C' '              CONTROL DATA IS BLANK\n         BE    GCSTEP2                 YES\nGCCSMOV  MVC   0(1,R10),0(R1)          CONTROL BYTE TO CSECT NAME\n         LA    R1,1(R1)                TO NEXT CONTROL BYTE\n         LA    R10,1(R10)              TO NEXT NAME BYTE\n         BCTR  R12,R0                  DEDUCT 1 FROM CONTROL LENGTH\n         BCTR  R11,R0                  DEDUCT 1 FROM NAME LENGTH\n         LTR   R12,R12                 ANY CONTROL BYTES LEFT\n         BZ    GCEND                   NO\n         CLI   0(R1),C' '              NEXT CONTROL BYTE BLANK\n         BE    GCEND                   YES\n         LTR   R11,R11                 ANY NAME BYTES LEFT\n         BNZ   GCCSMOV                 YES, LOOP\n         B     NAMEOV8                 NAME TOO LONG, ERROR\nGCEND    CLC   MEMBER,BLANX            ANY MEMBER NAME FOUND\n         BE    NOMBR                   NO\n         BR    R9                      EXIT\n*\n*\n*\n****************************************************************\n*                                                              *\n* MISCELLANEOUS ERROR MESSAGES.                                *\n*                                                              *\n****************************************************************\n*\nERRORS   EQU   *                       ERROR END MESSAGES\nNOCTL    MVC   PRT(L'NOCNTRL),NOCNTRL  NO CONTROL INFO MESSAGE\n         B     ERREND                  GO PRINT\nNAMEOV8  MVC   PRT(L'OVER8),OVER8      NAME OVER 8 MESSAGE\n         B     ERREND                  GO PRINT\nNOMBR    MVC   PRT(L'NOMEM),NOMEM      MISSING MEMBER NAME MESSAGE\n         B     ERREND                  GO PRINT\nMISSMEM  MVC   PRT(L'INVMEM),INVMEM    MEMBER NOT IN PDS MESSAGE\n         B     ERREND                  GO PRINT\nMISSCS   MVC   PRT(L'INVCSECT),INVCSECT CSECT NOT IN MEMBER MESSAGE\n         B     ERREND                  GO PRINT\nSYMFULL  MVC   PRT(L'FULLSYM),FULLSYM  FULL SYM TBL MSG\n         B     ERREND                  GO PRINT\nRLDFULL  MVC   PRT(L'FULLRLD),FULLRLD  RLD TBL FULL MSDG\n         B     ERREND                  GO PRINT\nERREND   DS    0H\n         TPUT  PRT,L'PRT\n         BAL   R9,PRINT                GO PRINT MESSAGE\n         CLOSE (SYSPRINT)\n         ABEND 888,DUMP                ABEND\n*\n*\n*\n*\n****************************************************************\n*                                                              *\n* COUNT THE ENTRIES IN THE ESD TABLE WHICH WILL RESULT IN      *\n* ENTRIES IN THE LABEL TABLE.                                  *\n*                                                              *\n****************************************************************\nENDINIT  EQU   *                       *** FINAL PROCESSING ***\n*\n         L     R6,SYMTBAD              GET @ ESD TABLE\n         USING SYMTBL,R6\n         LA    R7,4                    INITIAL LABEL COUNT VALUE\nSYMCNT   CLI   0(R6),X'FF'             END OF ESD TBL\n         BE    RLDCNT                  YES\n         CLI   TYPSYM,3                IS ESD AN LR ENTRY\n         BNE   SCSTP                   NO, IGNORE\n         CLC   SYMADDR,START+1         ADDR BELOW DESIRED CSECT\n         BL    SCSTP                   YES, IGNORE\n         CLC   SYMADDR,END+1           ADDR ABOVE DESIRED CSECT\n         BH    SCSTP                   YES, IGNORE\n         LA    R7,1(R7)                ADD TO LABEL COUNT\n         MVC   SYMLENG,=C'***'         FLAG AS USABLE\nSCSTP    LA    R6,L'SYMENT(R6)         TO NEXT ESD ENTRY\n         B     SYMCNT\n         DROP  R6\n*\n****************************************************************\n*                                                              *\n* COUNT THE ENTRIES IN THE RLD TABLE WHICH WILL RESULT IN      *\n* ENTRIES IN THE LABEL TABLE.                                  *\n*                                                              *\n****************************************************************\n*\nRLDCNT   L     R6,RLDTBL               GET RLD TBL ADDR\n         USING RLDTBLD,R6\nRLDCEND  CLI   0(R6),X'FF'             END OF RLD TABLE\n         BE    LBLGET                  YES\n         CLC   RLDRP,ESDID             ESDID SAME AS DESIRED CSECT\n         BNE   RLDC1                   NO, EXTRN REF\n         LA    R7,1(R7)                ADD 1 TO LABEL COUNT\nRLDC1    LA    R7,1(R7)                ADD 1 TO LABEL COUNT\n         LA    R6,L'RLDENT(R6)         TO NEXT RLD ENTRY\n         B     RLDCEND                 LOOP THRU RLD TBL\n         DROP  R6\nLBLGET   MH    R7,LBLLGTH              COMPUTE LABEL TABLE SIZE\n         L     R1,LENGTH               GET CSECT LENGTH\n         SRL   R1,2                    DIVIDE BY 4\n         MH    R1,LBLLGTH              TIMES LABEL ENTRY LENGTH\n         AR    R7,R1                   TOTAL LABEL TABLE LENGTH\n*\n****************************************************************\n*                                                              *\n* CREATE INITIAL ENTRIES IN THE LABEL TABLE USING DATA FROM    *\n* THE ESD AND RLD TABLES.                                      *\n*                                                              *\n****************************************************************\n*\n         GETMAIN R,LV=(7)              GET LABEL TBL STORAGE\n         ST    R1,LBLTBL               SAVE LABEL TBL ADDR\n         ST    R1,CURRLBL              SAVE CURRENT LABEL ADDR\n         AR    R1,R7                   COMPUTE LABEL TBL END ADDR\n         ST    R1,ENDLBL               SAVE END OF LBL TBL ADDR\n         L     R6,LBLTBL               GET @ LABEL TABLE\n         USING LABELD,R6\n         L     R7,SYMTBAD              GET ESD TBL ADDR\n         USING SYMTBL,R7\n         CLC   LKEPA,XZROS             E.P. ADDR ZERO\n         BE    LRENTS                  YES\n         SR    R1,R1                   CLEAR WORK\n         ICM   R1,7,LKEPA              PICK UP E.P. ADDR\n         S     R1,START                RELATIVIZE IN CSECT\n         BM    LRENTS                  NEG, ERROR\n         STCM  R1,7,LBLADR             SAVE OFFSET\n         MVI   LBLTYP,C'L'             SET LABEL TYPE IN ENTRY\n         LA    R12,LBLADR              POINT TO OFFSET\n         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVI   LBLNAME,C'A'            1ST CHAR OF LABEL IS 'A'\n         MVC   LBLNAME+1(6),PRTABL     END OF LABEL IS OFFSET\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         ST    R6,CURRLBL              SAVE IT'S ADDRESS\nLRENTS   CLI   0(R7),X'FF'             END OF ESD TBL\n         BE    RLDLBLS                 YES\n         CLC   SYMLENG,=C'***'         THIS DESIRED LR ENTRY\n         BE    GOTLR                   YES\nLRESTP   LA    R7,L'SYMENT(R7)         TO NEXT ESD ENTRY\n         B     LRENTS                  LOOP THRU ESD TBL\nGOTLR    SR    R12,R12                 CLEAR WORK REG\n         ICM   R12,7,SYMADDR           GET SYMBOL ADDR\n         S     R12,START               RELATIVIZE IN CSECT\n         STCM  R12,7,LBLADR            SAVE RELATIVE ADDR\n         MVC   LBLNAME,EXTSYM          SYMBOL NAME TO OUTPUT\n         MVI   LBLTYP,C'L'             SHOW LABEL ENTRY\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         ST    R6,CURRLBL              SAVE NEXT LABEL ENTRY ADDR\n         B     LRESTP                  CONTINUE ESD PROCESSING\n         DROP  R7\nRLDLBLS  L     R7,RLDTBL               GET RLD TBL ADDR\n         USING RLDTBLD,R7\nRLDLBND  CLI   0(R7),X'FF'             END OF RLD TABLE\n         BE    PHASE1                  YES\n         CLC   RLDRP,ESDID             RLD ESDID = DESIRED CSECT ESDID\n         BE    INTREFS                 YES, INTERNAL ADCON\n         CLI   RLDTYPE,1               VCON\n         BE    EXTREFS                 YES\n         CLI   RLDTYPE,8               IS IT UNRESOLVED\n         BE    EXTREFS                 YES\nRLLSTP   LA    R7,L'RLDENT(R7)         TO NEXT RLD ENTRY\n         B     RLDLBND                 LOOP THRU RLD TABLE\nEXTREFS  CLI   RLDESDTP,X'0A'          W-CON\n         BNE   VCONLBL                 NO, BUILD V-CON\n         MVI   LBLTYP,C'W'             SHOW W-CON\n         B     FXTLBL                  CONTINUE LABEL ENTRY FORMAT\nVCONLBL  MVI   LBLTYP,C'V'             SHOW V-CON\nFXTLBL   MVC   LBLNAME,RLDNAME         NAME TO LABEL ENTRY\nFINLBL   MVC   LBLADR,RLDADDR          ADDRESS TO LABEL ENTRY\n         MVC   LBLLEN,RLDLEN           LENGTH TO LABEL ENTRY\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         ST    R6,CURRLBL              SAVE CURRENT LABEL TBL ADDR\n         B     RLLSTP                  CONTINUE LABEL TABLE BUILD\nINTREFS  CLI   RLDTYPE,0               A-CON\n         BNE   RLLSTP                  NO, IGNORE\n         MVI   LBLTYP,C'L'             SHOW LABEL ENTRY TYPE\n         SR    R12,R12                 CLEAR WORK REG\n         ICM   R12,7,RLDADDR           GET RLD ADDR\n         A     R12,TXTSTRT             FIND LOC IN TEXT\n         MVC   LBLADR,1(R12)           MOVE TO LABEL ENTRY\n         CLI   RLDLEN,4                ADCON IS 4-BYTES\n         BE    INTGOTL                 YES\n         MVC   LBLADR,0(R12)           TEXT TO LABEL ENTRY\n         CLI   RLDLEN,3                ADCON IS 3-BYTES\n         BE    INTGOTL                 YES\n         MVC   LBLADR+1(2),0(R12)      TEXT TO LABEL ENTRY\n         MVI   LBLADR,0                CLEAR 1ST BYTE\n         CLI   RLDLEN,2                ADCON IS 2-BYTES\n         BE    INTGOTL                 YES\n         XC    LBLADR,LBLADR           CLEAR LABEL ENTRY ADDR\n         MVC   LBLADR+2(1),0(R12)      TEXT TO LABEL ENTRY\nINTGOTL  SR    R12,R12                 CLEAR WORK\n         ICM   R12,7,LBLADR            GET ADDRESS\n         S     R12,START               RELATIVIZE IN CSECT\n         BM    RLLSTP                  NEGATIVE, IGNORE\n         STCM  R12,7,LBLADR            STORE RELATIVE ADDRESS\n         LA    R12,LBLADR              POINT TO ADDRESS\n         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVI   LBLNAME,C'A'            SET LABEL ENTRY TYPE\n         MVC   LBLNAME+1(6),PRTABL     LOW ORDER NAME POSITIONS\n         MVI   LBLNAME+7,C' '          CLEAR LAST NAME BYTE\n         MVC   L'LABEL(L'LABEL,R6),0(R6) COPY THIS ENTRY TO NEXT\n         MVI   LBLLEN,0                SET LENGTH = 0\n         LA    R6,L'LABEL(R6)          STEP TO NEXT\n         MVI   LBLTYP,C'A'             SHOW TYPE\n         B     FINLBL                  FINISH LABEL\n         DROP  R6\n         DROP  R7\n*\n****************************************************************\n*                                                              *\n* LOAD AND EXECUTE PHASE 1: DISASM1                            *\n*                                                              *\n****************************************************************\n*\nPHASE1   MVC   0(3,R6),HIVAL           SET END OF LABEL TABLE  FIX***\n*        TM    LOADLIB+48,X'10'        LOADLIB DD CARD ENTERED\n*        BZ    NODCB1                  NO\n*        LOAD  EP=DISASM1,DCB=LOADLIB  LOAD PHASE1\n*        B     EXEC1                   CONTINUE\n*NODCB1   LOAD  EP=DISASM1              LOAD PHASE1\n*EXEC1    LR    R15,R0                  COPY E.P. ADDRESS\n*         LA    R1,=A(COMMPARM)         @ PARAMETER LIST\n*         BALR  R14,R15                 LINK TO PHASE1\n*         DELETE EP=DISASM1             DELETE AFTER USE\n****************************************************************\n*        CALLING SEQUENCE CODE\n         CALL  DISASM1,(COMMPARM)\n****************************************************************\n         CLI   USERR,0                 ANY ERRORS\n         BNE   CLOSES                  YES, STOP THE RUN\n*\n****************************************************************\n*                                                              *\n* PRINT THE LABEL TABLE AFTER PHASE 1 COMPLETION.              *\n*                                                              *\n****************************************************************\n*\n         MVC   PRTLINE,PH1LBL          HEADER 1\n         BAL   R9,PRINT                PRINT IT\n         MVC   PRTLINE,PH1HDR          HEADER 2\n         BAL   R9,PRINT                PRINT IT\n         L     R6,LBLTBL               GET LABEL TABLE ADDR\n         USING LABELD,R6\nLPEND    C     R6,CURRLBL              END OF TABLE       FIX****\n         BNL   FREESTRG                YES                FIX****\n         LA    R12,LBLADR              @ LABEL ADDRESS\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT(6),PRTABL           ADDRESS TO PRINT\n         MVC   PRT+9(1),LBLTYP         TYPE TO PRINT\n         MVC   PRT+12(8),LBLNAME       SYMBOL TO PRINT\n         CLI   LBLLEN,0                ANY LENGTH\n         BE    LTPPRT                  NO\n         LA    R12,LBLLEN              GET @ LENGTH\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   PRT+22(2),PRTABL        LENGTH TO PRINT\nLTPPRT   BAL   R9,PRINT                PRINT TBL ENTRY\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     LPEND                   LOOP THRU TABLE\nFREESTRG L     R12,RLDTBL              @ RLD TABLE\n         FREEMAIN R,A=(12),LV=RLDTABL  FREE RLD TABLE\n*\n****************************************************************\n*                                                              *\n* PRINT THE TEXT FOR THE CSECT TO BE DISASSEMBLED.             *\n*                                                              *\n****************************************************************\n*\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   PRT+50(19),=C'***** T E X T *****'\n         BAL   R9,PRINT                PRINT TEXT HEADER\n         MVI   PCC,C'0'                SET DOUBLE SPACING\n         L     R11,TXTSTRT             GET TEXT START ADDRESS\nPNEXLIN  LA    R10,2                   GROUPS PER LINE\n         LA    R12,POFSET+1            @ OFFSET\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   PRT(6),PRTABL           OFFSET TO PRINT\n         MVC   PRT+85(32),0(R11)       TEXT TO PRINT\n         TR    PRT+85(32),PRTCHAR      TRANSLATE TO PRINTABLE\n         LA    R8,PRT+9                @ 1ST PRINT WORD\n         LA    R7,4                    4 WORDS PER GROUP\nPGRP     LA    R12,0(R11)              @ TEXT WORD\n         BAL   R9,HEXPRT4              CONVERT\n         MVC   0(8,R8),PRTABL          TEXT TO PRINT WORD\n         LA    R11,4(R11)              TO NEXT TEXT WORD\n         LA    R8,9(R8)                TO NEXT PRINT LOC\n         BCT   R7,PGRP                 DO 4 TIMES\n         LA    R8,2(R8)                SPACE BETWEEN GROUPS\n         LA    R7,4                    FOR 2ND GROUP\n         BCT   R10,PGRP                DO 4 MORE TIMES\n         BAL   R9,PRINT                PRINT THE LINE\n         L     R9,POFSET               GET OFFSET\n         LA    R9,32(R9)               ADD 32 BYTES\n         ST    R9,POFSET               UPDATE OFFSET\n         C     R11,TXTEND              END OF TEXT\n         BL    PNEXLIN                 NO, CONTINUE\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         MVC   NAME,CSECT              CSECT NAME\n*\n****************************************************************\n*                                                              *\n* CREATE THE INITIAL CSECT INSTRUCTION, AND ANY ENTRY STATE-   *\n* MENTS WHICH MAY BE INDICATED BY ESD TABLE ENTRIES.           *\n*                                                              *\n****************************************************************\n*\n         MVC   MNEMONIC,=C'CSECT'      SET MNEMONIC\n         BAL   R9,WRTOUT               WRITE OUTPUT RECORD\n         BAL   R9,PRINT                AND PRINT IT\n         L     R7,SYMTBAD              GET ESD TBL ADDR\n         USING SYMTBL,R7\nLREFSS   CLI   0(R7),X'FF'             END OF ESD TBL\n         BE    CKLDLB                  YES\n         CLC   SYMLENG,=C'***'         THIS DESIRED LR ENTRY\n         BE    MAKEXT                  YES\nESDTSTP  LA    R7,L'SYMENT(R7)         TO NEXT ESD ENTRY\n         B     LREFSS                  LOOP THRU ESD TBL\nMAKEXT   MVC   MNEMONIC,=C'ENTRY'      MNEMONIC IS ENTRY\n         MVC   OPNDS(8),EXTSYM         SYMBOL TO OPERAND\n         BAL   R9,WRTOUT               WRITE OUTPUT RECORD\n         BAL   R9,PRINT                AND PRINT IT\n         B     ESDTSTP                 CONTINUE ESD PROCESSING\n         DROP  R7\n         DROP  R6\nCKLDLB   L     R12,SYMTBAD             @ ESD SYMBOL TABLE\n*\n****************************************************************\n*                                                              *\n* LOAD AND EXECUTE PHASE 2: DISASM2                            *\n*                                                              *\n****************************************************************\n*\n         FREEMAIN R,A=(12),LV=SYMTABL  FREE SYMBOL TABLE\n*         TM    LOADLIB+48,X'10'        LOADLIB DD CARD SUPPLIED\n*         BZ    NODCB                   NO\n*         LOAD  EP=DISASM2,DCB=LOADLIB  LOAD DISASM2\n*         B     EXEC2                   CONTINUE\n*NODCB    LOAD  EP=DISASM2              LOAD DISASM2\n*EXEC2    LR    R15,R0                  COPY E.P. ADDRESS\n*         LA    R1,=A(COMMPARM)         GET PARAMETER ADDRESS\n*         BALR  R14,R15                 CALL DISASM2\n*         DELETE EP=DISASM2             DELETE AFTER USE\n****************************************************************\n*        CALLING SEQUENCE CODE\n         CALL  DISASM2,(COMMPARM)\n****************************************************************\n         B     EOJ                     GO FINISH\n*\n*\n*\n*\n*\n*\n****************************************************************\n*                                                              *\n* WRITE OUTPUT TO SYSPUNCH.                                    *\n*                                                              *\n****************************************************************\n*\nWRTOUT   EQU   *                       WRITE OUTPUT RECORDS\n         MVC   PRT+30(80),WORKREC      SAVE IN PRINT            ACF\n         TM    SYSPUNCH+48,X'10'       IS FILE OPEN\n         BZ    CLRWKR                  NO\n         AP    CARDNO,=P'10'           INCREMENT CARD NO\n         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD\n         OI    SEQNBR+7,C'0'           CLEAR SIGN\n         PUT   SYSPUNCH,WORKREC        WRITE SOURCE CARD\nCLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         BR    R9                      RETURN\n*\n*\n*\n****************************************************************\n*                                                              *\n* END OF JOB. DISASSEMBLY COMPLETE.                            *\n*                                                              *\n****************************************************************\nEOJ      EQU   *                       END OF JOB\nEOFSW    B     NOCTL                   RESET IF CTL CARD FOUND\n         MVC   MNEMONIC,=CL5'REQU'     SET MNEMONIC\n         BAL   R9,WRTOUT               WRITE RECORD\n         BAL   R9,PRINT                GO PRINT IT\n         L     R12,DTBSTRT             @ DSECT HEADER TBL\nCENDSTB  CLI   0(R12),X'FF'            END OF TABLE\n         BE    ENDSTMT                 YES\n         MVC   NAME,0(R12)             DSECT NAME TO RECORD\n         MVC   MNEMONIC(5),=C'DSECT'   OPERATION IS DSECT\n         BAL   R9,WRTOUT               WRITE DSECT HEADER\n         BAL   R9,PRINT                AND PRINT IT\n         ICM   R11,7,8(R12)            GET FIELD TABLE ADDR\n         USING DSECTD,R11\nCENDFTB  CLI   0(R11),X'FF'            END OF FIELD TABLE\n         BNE   DFMTFLD                 NO\n         LA    R12,11(R12)             TO NEXT DSECT HEADER\n         B     CENDSTB                 LOOP\nDFMTFLD  MVC   NAME,DSNAME             NAME TO RECORD\n         MVC   MNEMONIC(3),=C'EQU'     OPERATION IS EQU\n         MVC   OPNDS(8),0(R12)         BASE NAME TO OPERAND\n         LA    R10,OPNDS+7             @ NAME RHE\nCFRHE    CLI   0(R10),C' '             AT RHE\n         BNE   CFPLUS                  YES\n         BCT   R10,CFRHE               BACK UP 1 AND LOOP\nCFPLUS   LA    R10,1(R10)              TO NEXT POS\n         MVI   0(R10),C'+'             DELIMITER\n         SR    R1,R1                   CLEAR WORK\n         ICM   R1,7,DSOFSET            GET OFFSET\n         CVD   R1,DBLWD                CONVERT\n         UNPK  DBLWD(4),DBLWD+4(4)     UNPACK\n         OI    DBLWD+3,C'0'            CLEAR SIGN\n         CH    R1,H1000                OFFSET < 1000\n         BL    CFO100                  YES\n         MVC   1(4,R10),DBLWD          NO, MOVE 4-DIGIT OFFSET\n         LA    R10,5(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO100   CH    R1,H100                 OFFSET < 100\n         BL    CFO10                   YES\n         MVC   1(3,R10),DBLWD+1        NO, MOVE 3-DIGIT OFFSET\n         LA    R10,4(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO10    CH    R1,H10                  OFFSET < 10\n         BL    CFO1                    YES\n         MVC   1(2,R10),DBLWD+2        MOVE 2-DIGIT OFFSET\n         LA    R10,3(R10)              TO NEXT POS\n         B     CFCMA                   CONTINUE\nCFO1     LTR   R1,R1                   ANY OFFSET\n         BZ    CFCMA                   NO\n         MVC   1(1,R10),DBLWD+3        YES, MOVE 1-DIGIT OFFSET\n         LA    R10,2(R10)              TO NEXT POS\nCFCMA    MVI   0(R10),C','             DELIMITER\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,DSLENG               PICK UP LENGTH\n         CVD   R1,DBLWD                CONVERT\n         UNPK  DBLWD(3),DBLWD+4(4)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R1,H100                 LENGTH < 100\n         BL    CFL10                   YES\n         MVC   1(3,R10),DBLWD          NO, MOVE 3-DIGIT LENGTH\n         B     CFWRT                   CONTINUE\nCFL10    CH    R1,H10                  LENGTH < 10\n         BL    CFL1                    YES\n         MVC   1(2,R10),DBLWD+1        NO, MOVE 2-DIGIT LENGTH\n         B     CFWRT                   CONTINUE\nCFL1     MVC   1(1,R10),DBLWD+2        MOVE 1-DIGIT LENGTH\nCFWRT    BAL   R9,WRTOUT               WRITE THE RECORD\n         BAL   R9,PRINT                PRINT THE RECORD\n         LA    R11,L'DSECT(R11)        TO NEXT FIELD ENTRY\n         B     CENDFTB                 LOOP\nENDSTMT  MVC   MNEMONIC,=CL5'END'      MNEMONIC TO OUTPUT RECORD\n         MVC   OPNDS(8),ENDLBLNM       POINT END STMT TO BEGIN LOC\n         BAL   R9,WRTOUT               WRITE THE RECORD\n         BAL   R9,PRINT                GO PRINT IT\nCLOSES   CLOSE (SYSLIB,,SYSPUNCH,,SYSPRINT,,SYSIN) CLOSE FILES\n         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE\n         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS\n         SR    R15,R15                 CLEAR RETURN CODE\n         BR    R14                     RETURN TO CALLER\n         DROP  R11\n*\n*\n*\n*                 *** DATA AND WORK AREAS ***\n****************************************************************\n*\n* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED\n* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED\n* WITH ALL OTHER PROGRAMS.\n*\n****************************************************************\n*\n         DS    0D\nCOMMPARM EQU   *                       COMMON AREAS\nDBLWD    DS    D                       DOUBLEWORD WORK AREA\nPUNCHDCB DC    A(SYSPUNCH)             @ SYSPUNCH DCB\nPRINTDCB DC    A(SYSPRINT)             @ SYSPRINT DCB\nINDCB    DC    A(SYSIN)                @ SYSIN DCB\nCSECT    DC    CL8' '                  SPECIFIED CSECT NAME\nESDID    DC    X'0001'                 ESD ID OF SPECIFIED CSECT\nENDLBLNM DC    CL8' '                  SYMBOL FOR END STMT BEGIN POINTE\nLINECT   DC    PL2'0'                  PRINT LINE COUNTER\nSTART    DC    F'0'                    LKED ASSIGNED START ADDR OF CSEC\nEND      DC    F'0'                    CSECT END ADDRESS\nLENGTH   DC    F'0'                    LENGTH OF SPECIFIED CSECT\nLBLTBL   DS    F                       @ LABEL TABLE\nCURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR\nENDLBL   DS    F                       @ END OF LABEL TBL\nLBLLGTH  DC    AL2(L'LABEL)            LENGTH OF LABEL ENTRY         */\nTXTSTRT  DS    F                       @ TEXT STORAGE AREA\nTXTEND   DS    F                       @ END OF TEXT AREA\nTXTCURR  DS    F                       @ CURRENT TEXT LOC\nDTBCURR  DC    F'0'                    DSECT TABLE CURRENT ENTRY ADDR\nDTBEND   DC    F'0'                    DSECT TABLE END ADDR\nDTBSTRT  DC    A(HIVAL)                DSECT TABLE START ADDR\nUSGSTRT  DC    A(HIVAL)                USING TABLE START ADDR\nUSGCUR   DC    F'0'                    USING TABLE CURRENT ADDR\nUSGEND   DC    F'0'                    USING TABLE END ADDR\nDATONLY  DS    F                       DATA ONLY TABLE ADDR\nDATOCUR  DS    F                       CURRENT DATA ONLY ADDR\nDATOEND  DS    F                       END OF DATA ONLY TABLE\nFLPTASM  DC    X'00'                   FLOATING POINT INDICATOR\nPRIVASM  DC    X'00'                   PRIVILEGED INDICATOR\nUSERR    DC    X'00'                   ERROR INDIC FOR DISASM1\nNBRLBLS  DC    H'0'                    NBR LABELS FROM DISASM1\n*\n*\n*\nWORKREC  DS    0CL80                   DISASSEMBLY WORK AREA\nNAME     DS    CL8                     NAME\n         DS    CL1\nMNEMONIC DS    CL5                     INSTRUCTION MNEMONIC\n         DS    CL1\nOPNDS    DS    CL27                    1ST OPERAND\n         DS    CL1\nCOMMENT  DS    CL28                    COMMENT\nCOL72    DS    CL1\nSEQNBR   DS    CL8                     CARD SEQ NBR\n*\n*\n*\nCARDNO   DC    PL4'0'                  OUTPUT CARD NBR\nPRTLINE  DS    0CL121                  PRINT LINE\nPCC      DC    C'1'                    CARRIAGE CONTROL\nPRT      DC    CL120' '                PRINT DATA\n*\n*\n*\n         DS    0F\nBLDLIST  DS    0CL62                   BLDL LIST\n         DC    H'1'                    ONE ENTRY\n         DC    H'58'                   LENGTH OF ENTRY\nMEMBER   DC    CL8' '                  MEMBER NAME\nTTRMOD   DC    XL3'000000'             TTR OF MODULE\nCCAT     DC    XL1'00'                 CONCATENATION NUMBER\n         DC    XL1'00'\nALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR\n*                           80=ALIAS\nTTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD\n         DC    XL1'00'\nTTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST\nNNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST\nATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1\n*                           80=RENT\n*                           40=REUS\n*                           20=OVERLAY\n*                           10=UNDER TEST\n*                           08=ONLY LOADABLE\n*                           04=SCATTER FORMAT\n*                           02=EXECUTABLE\n*                           01=ONE TXT, NO RLD RECORDS\nATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2\n*                           80=CANNOT BE REPROCESSED BY LKED E\n*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO\n*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO\n*                           10=CONTAINS NO RLD RECORD\n*                           08=CANNOT BE REPROCESSED BY LKED\n*                           04=CONTAINS TESTRAN SYMBOLS\n*                           02=CREATED BY LKED\n*                           01=REFR\nTOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD\nLENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD\nLKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR\nATTR2    DC    XL1'00'                 ATTRIBUTES 2\n*                           80=PROCESSED BY OS/VS LKED\n*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE\n*                           10=SSI PRESENT\nATTR2A   DC    XL1'00'\n*                           X'10' - RMODE = 24 IF 0, ELSE ANY\n*                           B'....XX..' ALIAS ADDRESS MODE\n*                           B'......XX' MAIN ADDRESS MODE\n*                           AMODE = 24 IF 00, 31 IF 10, ANY IF 11\nATTR2B   DC    XL1'00'\nSCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH\nTTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH\nSCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD\nSCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT\nALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME\nALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS\nSSI      DS    XL4'00000000'           SSI BYTES\nAUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH\nAUTHCOD  DC    XL1'00'                 AUTH CODE\n*\n*\n*\nCOMMEND  EQU   *\n*\n*\n*\nLABELD   DSECT ,                       LABEL TABLE ENTRY\nLABEL    DS    0CL13                   13-BYTE ENTRIES\nLBLADR   DS    XL3                     RELATIVE ADDR IN TEXT\nLBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,\nLBLNAME  DS    CL8                     NAME (SYMBOL)\nLBLLEN   DS    XL1                     LENGTH IF A, V, OR W\n*\n*\n*\nUSINGD   DSECT ,                       USING TABLE ENTRY\nUSING    DS    0CL11\nUSBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE\nUSEND    DS    XL3                     OFFSET TO END OF RANGE\nUSREG    DS    XL1                     BASE REGISTER USED\nUSTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT\nUSVALU   DS    XL3                     BASE REG VALUE\n*\n*\n*\nDSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY\nDSECT    DS    0CL13\nDSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD\nDSLBTYP  DS    CL1                     LABEL TYPE = L\nDSNAME   DS    CL8                     FIELD NAME\nDSLENG   DS    XL1                     FIELD LENGTH\n*\n*\n*\nDISASM   CSECT\n*\n*\n*\n*\n*\n*\nRLDTBLD  DSECT ,                       RELOCATION DICTIONARY TABLE\nRLDENT   DS    0CL20                   11 BYTE ENTRIES\nRLDRP    DS    XL2                     RELOCATION POINTER\nRLDPP    DS    XL2                     POS PTR (SYMBOL CESD NBR)\nRLDTYPE  DS    XL1                     TYPE\n*                    00=A-TYPE ADCON\n*                    01=V-TYPE ADCON\n*                    02=PSEUDO REGISTER DISPLACEMENT\n*                    03=PSEUDO REG CUMULATIVE DISPL\n*                    08=UNRESOLVED\nRLDLEN   DS    XL1                     LENGTH OF CONSTANT\nRLDDIR   DS    CL1                     RELOCATION DIRECTION, + OR\nRLDADDR  DS    XL3                     LKED ASSGND ADDR OF CONSTANT\nRLDNAME  DS    CL8                     NAME FROM ASSOC ESD\nRLDESDTP DS    XL1                     TYPE FROM ASSOC ESD\n         DS    XL1\nDISASM   CSECT\n*\n*\n*\nSYMTBL   DSECT ,                       EXTERNAL SYMBOL TABLE ENTRY\nSYMENT   DS    0CL19                   19 BYTE ENTRIES\nEXTSYM   DS    CL8                     EXTERNAL SYMBOL NAME\nTYPSYM   DS    XL1                     SYMBOL TYPE\n*                        00=SD (NAMED CSECT)\n*                        02=ER (EXTRN)\n*                        03=LR (ENTRY)\n*                        04=PC (UNNAMED CSECT)\n*                        05=CM (COM)\n*                        06=PR (PSEUDO REGISTER)\n*                        07=NULL\n*                        0A=WX (WXTRN)\n*                        0F=ENTAB OR SEGTAB\nSYMIND   DS    XL1                     INDICATOR\n*                        BIT 0 = MAP\n*                        BIT 1 = CHAIN\n*                        BIT 2 = INSERT\n*                        BIT 3 = DELETE/REPLACE\nSYMADDR  DS    XL3                     SYMBOL ADDRESS (0 FOR ER, WX, NU\nSYMARMOD DS    XL1                     AMODE/RMODE                  ACF\n*                       X'08' - RSECT; READ ONLY IF ON              ACF\n*                       X'04' - RMODE; ANY IF ONE, 24 IF 0          ACF\n*                       X'03' - AMODE 00,01 = 24, 10 = 31, 11 = ANY ACF\nSYMSEG   DS    XL1                     SEGMENT ID (0 FOR ER, WX, NULL)\nSYMLRID  DS    0XL2                    ESD ID OF DEF FOR LR\nSYMLENG  DS    XL3                     LENGTH FOR SD, PC, CM, PR\n*                                      0 FOR ER, WX, NULL\nSYMESDID DS    XL2                     ESD ID OF THIS ITEM\nDISASM   CSECT\n*\n*\n*\nBUFAD    DS    F                       SYSLIB BUFFER ADDR\nSYMTBAD  DS    F                       SYMBOL TABLE ADDRESS\nCURRSYM  DS    F                       CURRENT SYM TBL ADDR\nENDSYM   DC    A(SYMTABL)              SYM TBL END ADDR\nSYMTABL  EQU   80000       *** ACF - WAS 40000\nRLDTBL   DS    F                       ADDR OF RLD TABLE\nCURRLD   DS    F                       CURR RLD TBL ADDR\nENDRLD   DC    A(RLDTABL)              RLD TBL END ADDR\nRLDTABL  EQU   60000\nENDATO   DC    A(DATOLEN)              DATA ONLY TBL LENGTH\nDATOLEN  EQU   1536\nPROCESS  DC    XL1'00'                 PROCESS INDIC 80=SYM TBL BUILT\nCES9     DS    F                       CESDREC RETURN ADDR\nBL9      DS    F                       BLDL RTN RETURN ADDR\nCR9      DS    F                       CTRLRECS RETURN ADDR\nCT9      DS    F                       CNTLRECS RETURN ADDR\nRL9      DS    F                       RLDRECS RETURN ADDR\nTX9      DS    F                       TXTFMT RETURN ADDR\nHIVAL    DC    4X'FF'                  CONSTANT F'S\nH1000    DC    H'1000'                 CONSTANT 1000\nH100     DC    H'100'                  CONSTANT 100\nH10      DC    H'10'                   CONSTANT 10\nSYMLEN   DC    AL2(L'SYMENT)           LENGTH OF SYMTBL ENTRY        */\nPRTABL   DS    CL9                     HEX-PRINTABLE CONVERSION AREA\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nJFCBAD   DS    0F                      DCB EXIT LIST\n         DC    X'87'                   RDJFCB, END OF LIST\n         DC    AL3(JFCB)               ADDRESS OF JFCB READ AREA\nJFCB     DS    CL176                   JFCB\nSYMHDR   DC    C'0     SYMBOL        TYPE   IND  ADDR'\n         DC    C'    SEG  LRID   LENG  ESDID  RSECT  AMODE  RMODE'\n         DC    CL64' '\n*\n*\n*\nRLDHDR   DC    C'0     RELPTR  POSPTR      TYPE     LEN'\n         DC    C'    DIR   ADDR'\n         DC    CL90' '\n*\n*\n*\nPH1LBL   DC    CL121'1***** PHASE 1 LABEL TABLE *****'\nPH1HDR   DC    CL121'0  ADDR TYPE  SYMBOL  LEN'\n*\n*\n*\nH1       DC    H'1'                    CONSTANT 1\nH5       DC    H'5'                    CONSTANT 5\nH11      DC    H'11'                   CONSTANT 11\nH16      DC    H'16'                   CONSTANT 16\nH256     DC    H'256'                  CONSTANT 256\nBLANX    DC    CL121' '                CONSTANT BLANKS\nXZROS    DC    8X'00'                  CONSTANT ZEROS\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nNOCNTRL  DC    C'MEMBER AND CSECT MUST BE ENTERED VIA SYSIN'\nOVER8    DC    C'MEMBER OR CSECT NAME OVER 8 CHARACTERS'\nNOMEM    DC    C'NO MEMBER NAME FOUND IN CONTROL CARD OR PARM'\nINVMEM   DC    C'SPECIFIED MEMBER NOT FOUND IN SYSLIB PDS'\nINVCSECT DC    C'SPECIFIED CSECT NOT FOUND IN MEMBER'\nFULLSYM  DC    C'SYMBOL TABLE FULL: OVER 4000 ENTRIES'\nFULLRLD  DC    C'RLD TABLE FULL: OVER 3000 ENTRIES'\nPOFSET   DC    F'0'                    OFFSET FOR TEXT PRINT\nPRTCHAR  DC    256C'.'                 CHARACTER TRANSLATE TABLE\n         ORG   PRTCHAR+C' '\n         DC    C' '\n         ORG   PRTCHAR+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   PRTCHAR+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   PRTCHAR+C'S'\n         DC    C'STUVWXYZ'\n         ORG   PRTCHAR+C'0'\n         DC    C'0123456789'\n         ORG\n*\n*\n*\nSYSPUNCH DCB   DSORG=PS,MACRF=(PM,GM),DDNAME=SYSPUNCH,                 X\n               RECFM=FB,LRECL=80\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,                         X\n               RECFM=FB,LRECL=80,EODAD=NOCTL\nSYSLIB   DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB,                         X\n               RECFM=U,NCP=1\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=121\nLOADLIB  DCB   DSORG=PO,MACRF=R,DDNAME=LOADLIB,EXLST=JFCBAD\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM1": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x06\\xd1\\x06\\xd1\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 1745, "newlines": 1745, "modlines": 0, "user": "FIELD"}, "text": "DIS1     TITLE '*** DISASSEMBLY PHASE 1 ***'\n         MACRO\n&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=\n         GBLC  &EQU\n         GBLC  &GM\n         GBLC  &CSECT\n         LCLC  &REGA\n         AIF   (T'&NAME EQ 'O').NOCSECT\n         AIF   ('&NAME' EQ '*').NOCSECT\n&CSECT   SETC  '&NAME'\n&CSECT   CSECT                         NAME OF PROGRAM\n         AGO   .RST\n.NOCSECT ANOP\n&CSECT   SETC  '*'\n         CSECT                         BEGINNING OF PROGRAM\n.RST     ANOP\n         AIF   ('&EQU' EQ 'ON').NRQ\n&EQU     SETC  'ON'\n*\n***REGISTER EQUATES***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.NRQ     ANOP\n*\n*******************  PROGRAM INITIALIZATION  *************************\n*\n         AIF   (T'&REG1 EQ 'O').NOREG\n&REGA    SETC  '&REG1'\n         AIF   (T'&REG2 EQ 'O').ONEREG\n         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY\n         AGO   .BYUSE\n.NOREG   ANOP\n&REGA    SETC  'R3'\n.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY\n.BYUSE   ANOP\n         STM   R14,R12,12(R13)         STORE REGS IN HIGH SAVE AREA\n         LR    &REGA,R15                  INITIALIZE BASE REG\n         AIF   (T'&REG2 EQ 'O').NOLA\n         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND\n         LA    &REG2,1(&REG2)                BASE REGISTER\n.NOLA    ANOP\n         AIF   (T'&REG3 EQ 'O').NOLNK\n         L     &REG3,0(R1)                GET PARAMETER LIST ADDR\n.NOLNK   ANOP\n         AIF (T'&IND EQ 'O').GETIT\n         CNOP  0,4\n         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA\nSAVEAREA DS    18F                     REGISTER SAVE AREA\n         ST    R15,8(R13)\n         ST    R13,SAVEAREA+4\n         LR    R13,R15\n         AGO   .NOSAVE\n.GETIT   ANOP\n         AIF   (T'&LV EQ 'O').GMD\n&GM      SETC  '&LV'\n         AGO   .DGM\n.GMD     ANOP\n&GM      SETC  '72'\n.DGM     ANOP\n*\n***GET MAIN STORAGE FOR SAVE AREA***\n*\n         AIF   ('&GM' LT '4096').LA\n         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA\n         AGO   .EGM\n.LA      ANOP\n         LA    R0,&GM                  GET &GM BYTES\n         GETMAIN R,LV=(0)\n.EGM     ANOP\n*\n***SET UP SAVE AREA POINTERS***\n*\n         ST    R1,8(R13)               STORE LOW SAVE POINTER\n         ST    R13,4(R1)               STORE HIGH SAVE POINTER\n         LR    R13,R1                  INITIALIZE SAVE POINTER\n         AIF   (T'&REG3  NE 'O').NOSAVE\n         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG\n         L     R1,24(R1)               RESTORE PARAMETER REGISTER\n.NOSAVE  ANOP\n         AIF   ('&CSECT' EQ '*').EXIT\n         B     *+12\n         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.\n.EXIT    ANOP\n*\n*********************  END INITIALIZATION  ***************************\n*\n         MEND\n         EJECT\nDISASM1  SVLNK R3,R4\n         PRINT NOGEN\n* THIS SUB-PROGRAM IS CALLED BY DISASM, AND IS PHASE 2 OF\n* THE DISASSEMBLY PROCESS. A COMMON DATA\n* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.\n*\n*    THE SYSIN FILE IS READ TO EXHAUSTION. USING CARDS ARE\n* REFORMATTED AND STORED IN A TABLE - UP TO 256 USING\n* STATEMENTS MAY BE ENTERED. DSECT CARDS MAY FOLLOW THE\n* USING STATEMENTS. WHEN USED, DSECT STATEMENTS ARE\n* REFORMATTED, AND BUILT INTO TABLES. A MAXIMUM OF 256 DSECTS\n* MAY BE ENTERED. DATA ONLY CARDS MAY BE INCLUDED BEFORE, BETWEEN,\n* OR AFTER DSECTS TO SHOW AREAS IN THE PROGRAM WHERE NO INSTRUCTIONS\n* OCCUR. UP TO 256 DATA ONLY AREAS MAY BE SPECIFIED.\n*\n*     AT EOF ON SYSIN, A PSEUDO DIS-ASSEMBLY PASS IS MADE\n* USING THE TEXT STORED BY DISASM. ANY RESOLVABLE ADDRESS\n* WITHIN THE TEXT IS USED TO CREATE A NEW ENTRY IN THE\n* LABEL TABLE, WHICH WILL BE USED BY DISASM2 IN THE\n* ACTUAL DIS-ASSEMBLY PASS.\n*\n* THE USING CARDS FOR BASE REGISTERS ASSOCIATED WITH DSECT DEFINITIONS\n* MUST BE ENTERED AT SOME POINT AFTER THE DSECT CARDS HAVE BEEN\n* INCLUDED. USING CARDS FOR PROGRAM BASE REGISTERS MAY BE ENTERED\n* AT ANY POINT. THE USING CARD FORMAT IS:\n*       COL 1-5   : LITERAL 'USING'\n*       COL 6     : BLANK\n*       COL 7-12  : OFFSET TO BEGIN LOCATION FOR USING RANGE (HEX)\n*       COL 13    : BLANK\n*       COL 14-19 : OFFSET TO ENDING LOCATION FOR USING RANGE (HEX)\n*       COL 20    : BLANK\n*       COL 21    : BASE RESISTER TO BE USED (HEX, 1-F)\n*       COL 22    : BLANK\n*       COL 23    : TYPE, P=PROGRAM BASE, D=DSECT BASE\n*       COL 24    : BLANK\n*       COL 25-30 : INITIAL BASE REGISTER VALUE IF TYPE P (HEX)\n*       COL 25-32 : DSECT NAME IF TYPE D\n*\n*     A DSECT IS ENTERED USING A HEADER CARD,FOLLOWED BY\n* ONE OR MORE FIELD DEFINITION CARDS. ALL FIELD DEFINITION\n* CARDS MUST FOLLOW THE DSECT HEADER CARD. USING CARDS MAY\n* NOT BE INTERSPERSED WITH DSECT DEFINITIONS, BUT MAY PRECEDE\n* OR FOLLOW ANY DSECT.\n*     DSECT HEADER CARD FORMAT:\n*        COL 1-8    : DSECT NAME\n*        COL 9      : BLANK\n*        COL 10-14  : LITERAL 'DSECT'\n*        COL 15     : BLANK\n*        COL 16-19  : NUMBER OF FIELD CARDS TO FOLLOW (DECIMAL)\n*\n*     DSECT FIELD CARD FORMAT:\n*        COL 1-8    : FIELD NAME\n*        COL 9      : BLANK\n*        COL 10-13  : OFFSET TO LEFT END OF FIELD (DECIMAL)\n*        COL 14     : BLANK\n*        COL 15-17  : LENGTH OF FIELD IN BYTES (DECIMAL)\n*\n*     A DATA ONLY CARD IS USED TO DESIGNATE A RANGE OF OFFSETS\n* BETWEEN WHICH NO INSTRUCTIONS EXIST. USE OF THESE CARDS ELIMINATES\n* THE CHANCE THAT DATA ELEMENTS WILL BE TREATED AS INSTRUCTIONS\n* BETWEEN THE OFFSETS SPECIFIED. FORMAT IS:\n*        COL 1-4    : LITERAL 'DATA'\n*        COL 5      : BLANK\n*        COL 6-11   : OFFSET TO BEGINNING OF AREA (HEX)\n*        COL 12     : BLANK\n*        COL 13-18  : OFFSET TO END OF AREA (HEX)\n*\n*\n*     USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF\n* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY DISASM. THEY\n* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST\n* CARD, OR WITHIN A DSECT DEFINITION.\n*        COL  1-5  : LITERAL 'ULABL'\n*        COL   6   : BLANK\n*        COL  7-14 : FIELD NAME\n*        COL   15  : BLANK\n*        COL 16-21 : OFFSET TO LEFT END OF AREA (HEX)\n*        COL   22  : BLANK\n*        COL 23-25 : FIELD LENGTH (DECIMAL)\n*\n*      DISASSEMBLY TABLES ARE SET UP IDENTICALLY TO THOSE USED BY\n* DISASM2 FOR THE SIMULATED DISASSEMBLY PERFORMED IN THIS\n* MODULE WHEN ANY PROGRAM BASE REGISTER USING STATEMENTS\n* ARE ENTERED.\n*\n*     STORAGE IS OBTAINED FOR THE DSECT TABLE AND USING TABLE,\n* AND ADDRESSES OF THESE TABLES ARE STORED IN THE COMMON PARAMETER\n* AREA. USING AND DSECT CARDS ARE EDITED, REFORMATTED, AND PLACED\n* IN THE APPROPRIATE TABLES. IF ANY ERRORS ARE FOUND, THEY ARE\n* PRINTED, AND THE DISASSEMBLY WILL BE TERMINATED ON RETURN\n* TO DISASM.\n*\n*     STORAGE IS OBTAINED FOR THE LABEL TABLE, AND A SIMULATED\n* DIS-ASSEMBLY IS PERFORMED TO CREATE LABEL TABLE ENTRIES FOR\n* LABELS WHICH WILL BE GENERATED FOR BASE-DISPLACEMENT ADDRESSES\n* BY DISASM2. ON RETURN TO DISASM, THESE LABELS WILL BE SORTED\n* WITH EXTERNAL SYMBOL AND RLD LABELS TO FORM THE FINAL LABEL\n* TABLE TO BE USED BY DISASM2.\n*\n*\n*\n*\n* AUTHOR R THORNTON - FEB 1978\n* UPDATED ROBERT STYMA - JAN 1989 AND MARCH 1991\n* UPDATED ALAN C FIELD - APR 1990\n*\n*\n******************************************************************\n*                                                                *\n* CHECK FOR PRIVILEGED AND/OR FLOATING POINT INSTRUCTION OPTION. *\n* IF THESE INSTRUCTIONS ARE NOT TO BE ASSEMBLED, CLEAR THEIR     *\n* INSTRUCTION TABLE ENTRIES.                                     *\n*                                                                *\n******************************************************************\n*\n         L     R5,0(R1)                GET PARM FIELD ADDRESS\n         USING COMMPARM,R5\n         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.\n         BE    TSTPRIV                 YES\n         LA    R12,SGLOP               POINT TO OP-CODE TBL\nTSTOPND  CLI   0(R12),X'FF'            END OF TBL\n         BE    TSTPRIV                 YES\n         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT\n         BZ    FLPSTP                  NO\n         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY\nFLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TSTOPND                 LOOP THRU TABLE\nTSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    GETUSGTB                YES\n         LA    R12,SGLOP               POINT TO OP-CODE TBL\nTTOPND   CLI   0(R12),X'FF'            END OF TABLE\n         BE    CKDBLS                  YES\n         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR\n         BZ    PRIVSTP                 NO\n         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY\nPRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TTOPND                  LOOP THRU TABLE\nCKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL\nCKDBND   CLI   0(R12),X'FF'            END OF TBL\n         BE    GETUSGTB                YES\n         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE\n         BZ    DBSTP                   NO\n         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY\nDBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY\n         B     CKDBND                  LOOP THRU TABLE\n*\n******************************************************************\n*                                                                *\n* GET STORAGE FOR USING AND DSECT POINTER TABLES.                *\n*                                                                *\n******************************************************************\n*\nGETUSGTB GETMAIN R,LV=2864             GET STORAGE FOR USING TABLE\n         MVI   0(R1),X'FF'             SET TABLE END INDIC\n         ST    R1,USGSTRT              SAVE TABLE START ADDR\n         ST    R1,USGCUR               SET TABLE CURRENT ADDR\n         LA    R1,2816(R1)             COMPUTE TABLE END ADDR\n         ST    R1,USGEND               SAVE USING TABLE END ADDR\n         L     R2,INDCB                GET SYSIN DCB ADDR\n         LA    R1,EOFCARD              GET EOF ADDR\n         STCM  R1,7,33(R2)             SET EOF ADDR IN DCB\n         GETMAIN R,LV=2864             GET STORAGE FOR DSECT TABLE\n         MVI   0(R1),X'FF'             SET TABLE END ADDR\n         ST    R1,DTBSTRT              SAVE DSECT TABLE START ADDR\n         ST    R1,DTBCUR               SAVE DSECT TABLE CURRENT ADDR\n         LA    R1,2816(R1)             COMPUTE TABLE END ADDR\n         ST    R1,DTBEND               SAVE DSECT TABLE END ADDR\n         L     R1,INDCB                @ SYSIN DCB\n         TM    48(R1),X'10'            IS IT OPEN\n         BZ    EOFCARD                 NO\n*\n*\n*\n******************************************************************\n*                                                                *\n* READ SYSIN CARDS, AND DISTRIBUTE TO THE APPROPRIATE PROCESSING *\n* ROUTINE: USINGS, DSECTS, OR DATAS. DETECT ANY ERRORS AND PRINT *\n* ALL CARDS WITH MESSAGES AS NECESSARY.                          *\n*                                                                *\n******************************************************************\n*\nRDCARD   EQU   *                       *** PROCESS SYSIN CARDS ***\n         L     R1,INDCB                GET SYSIN DCB ADDR\n         GET   (1)                     READ NEXT CARD\n         MVC   WORKREC,0(R1)           MOVE IT TO WORK AREA\n         NOP   MVPRT                   FIRST TIME SWITCH\n         MVI   *-3,C'0'                RESET FIRST TIME SWITCH\n         MVI   PCC,C'1'                SET SKIP TO HEAD\n         MVC   PRT+10(26),=C'*** USER ENTERED CARDS ***'\n         BAL   R9,PRINT                GO PRINT\nMVPRT    MVC   PRT(80),WORKREC         CARD TO PRINT\nRDGRTN   LA    R9,RCCKERR              GET RETURN ADDRESS\n         CLC   WORKREC(5),=C'USING'    IS IT A USING CARD\n         BE    USINGS                  YES\n         CLC   WORKREC+9(5),=C'DSECT'  IS IT A DSECT HEADER\n         BE    DSECTS                  YES\n         CLC   WORKREC(4),=C'DATA'     IS IT DATA ONLY CARD\n         BE    DATAS                   YES\n         CLC   WORKREC(5),=C'ULABL'    IS IT A USER LABEL\n         BE    ULABLS                  YES\n         MVC   PRT+85(21),=C'UNIDENT OR OUT OF SEQ'\n         MVI   USERR,X'FF'             SET ERROR FLAG\nRCCKERR  NI    USERR,X'FE'             RESET CURRENT ERROR FLAG\n         BAL   R9,PRINT                GO PRINT\n         B     RDCARD                  CONTINUE\nEOFCARD  CLI   USERR,0                 ANY ERRORS FOUND\n         BNE   EOJ                     YES, EXIT\n*\n******************************************************************\n*                                                                *\n* CHECK FOR ANY USING CARDS ENTERED. IF NOT, NO PRE-ASSEMBLY IS  *\n* NECESSARY. IF ANY USING CARDS FOUND, CREATE LABEL TABLE ENTRIES*\n* SO THAT USING STATEMENTS WILL BE VALID.                        *\n*                                                                *\n******************************************************************\n*\n         L     R1,DATOCUR              GET CURRENT DATA ONLY @\n         MVC   NOINAD,DATONLY          SAVE DATA ONLY TBL ADDR\n         MVC   0(3,R1),HIVAL           SET END\n         L     R11,USGSTRT             GET USING TBL ADDR\nCUSNGND  CLI   0(R11),X'FF'            END OF TABLE\n         BE    CKPRE                   GO CHECK FOR PRE-DISASM\n         L     R10,CURRLBL             GET LABEL ADDRESS\n         USING USINGD,R11\n         USING LABELD,R10\n         MVC   LBLADR,USVALU           OFFSET TO LABEL\n         MVI   LBLTYP,C'L'             LABEL TYPE ENTRY\n         MVI   LBLLEN,1                SET LENGTH TO 1\n         MVI   LBLNAME,C'A'            1ST CHAR OF NAME\n         LA    R12,USVALU              @ OFFSET\n         BAL   R9,HEXPRT3              CONVERT\n         MVC   LBLNAME+1(6),PRTABL     MIDDLE OF NAME\n         MVI   LBLNAME+7,C' '          BLANK LAST POS\n         LA    R10,L'LABEL(R10)        STEP TO NEXT LABEL\n         ST    R10,CURRLBL             SAVE IN CURRLBL     FIX******\n         MVC   0(3,R10),HIVAL          SET END VALUE       FIX******\n         LA    R11,L'USING(R11)        STEP TO NEXT USING\n         B     CUSNGND                 LOOP\n         DROP  R10\n         DROP  R11\nCKPRE    L     R1,USGSTRT              GET USING TBL START ADDR\n         CLI   0(R1),X'FF'             ANY ENTRIES\n         BNE   MAINLINE                YES, GO TO PRE-DISASM\n         B     EOJ                     OTHERWISE GET OUT\n*\n*\n*\n*\n******************************************************************\n*                                                                *\n* EDIT USING CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* USING TABLE.                                                   *\n*                                                                *\n******************************************************************\n*\nUSINGS   EQU   *                       *** USING CARD PROCESSING ***\n         L     R12,USGCUR              GET CURRENT USING TBL ADDR\n         C     R12,USGEND              END OF TBL\n         BNL   UERR6                   YES, TABLE FULL\n         USING USINGD,R12\n         TR    WORKREC+6(6),TRHEX      TRANSLATE TO MAKE HEX\n         TRT   WORKREC+6(6),TRTHEX     CHECK VALID\n         BNZ   UERR1                   INVALID BEGIN ADDR\n         TR    WORKREC+13(6),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+13(6),TRTHEX    CHECK VALID\n         BNZ   UERR2                   INVALID END ADDR\n         TR    WORKREC+20(1),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+20(1),TRTHEX    CHECK VALID\n         BNZ   UERR3                   INVALID BASE REG\n*        CLI   WORKREC+20,0            VALID BASE REG\n*        BE    UERR3                   NO\n         CLI   WORKREC+22,C'P'         VALID TYPE\n         BE    CKINIT                  YES, PROGRAM BASE\n         CLI   WORKREC+22,C'D'         VALID TYPE\n         BNE   UERR8                   NO, ERROR\n         L     R1,DTBSTRT              GET DSECT TABLE STRT\nCKDSEND  CLI   0(R1),X'FF'             END OF TABLE\n         BE    UERR5                   YES, MISSING DSECT\n         CLC   0(8,R1),WORKREC+24      THIS THE DSECT ENTRY\n         BE    USDSMV                  YES\n         LA    R1,11(R1)               TO NEXT ENTRY\n         B     CKDSEND                 LOOP THRU DSECT TABLE\nUSDSMV   MVC   USVALU,8(R1)            MOVE DSECT TBL ADDR\n         B     USFINI                  CONTINUE\nCKINIT   TR    WORKREC+24(6),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+24(6),TRTHEX    CHECK VALIDITY\n         BNZ   UERR4                   INVALID BASE REG VALUE\n         PACK  DBLWD(4),WORKREC+24(7)  PACK TO MAKE HEX\n         MVC   USVALU,DBLWD            BASE REG VALUE TO USING TBL\nUSFINI   PACK  DBLWD(4),WORKREC+6(7)   PACK TO MAKE HEX\n         MVC   USBGN,DBLWD             BEGIN ADDR TO USING TABLE\n         PACK  DBLWD(4),WORKREC+13(7)  PACK TO MAKE HEX\n         MVC   USEND,DBLWD             END ADDR TO USING TABLE\n         TM    USEND+2,1               IS IT ODD\n         BO    UERR2                   YES, ERROR\n         CLI   WORKREC+22,C'D'         DSECT BASE\n         BE    USFREG                  YES\n         CLC   USEND,LENGTH+1          WITHIN PROGRAM\n         BH    UERR2                   YES, ERROR\nUSFREG   MVC   USREG,WORKREC+20        BASE REG TO USING TABLE\n         MVC   USTYPE,WORKREC+22       TYPE TO USING TABLE\n         CLC   USBGN,USEND             END < BEGIN\n         BH    UERR7                   YES, ERROR\n         LA    R12,L'USING(R12)        TO NEXT USING TBL ENTRY\n         MVI   0(R12),X'FF'            SET TABLE END INDIC\n         ST    R12,USGCUR              SAVE UPDATED TABLE ADDR\n         BR    R9                      EXIT\nUERR1    MVC   PRT+85(22),=C'INVALID BEGIN COL 7-12'\n         B     UERRS                   CONTINUE\nUERR2    MVC   PRT+85(21),=C'INVALID END COL 14-19'\n         B     UERRS                   CONTINUE\nUERR3    MVC   PRT+85(18),=C'INVALID REG COL 21'\n         B     UERRS                   CONTINUE\nUERR4    MVC   PRT+85(25),=C'INVALID ADDRESS COL 25-30'\n         B     UERRS                   CONTINUE\nUERR5    MVC   PRT+85(25),=C'UNDEFINED DSECT COL 25-32'\n         B     UERRS                   CONTINUE\nUERR6    MVC   PRT+85(20),=C'OVER 256 USING CARDS'\n         B     UERRS                   CONTINUE\nUERR7    MVC   PRT+85(16),=C'END BEFORE BEGIN'\n         B     UERRS                   CONTINUE\nUERR8    MVC   PRT+85(19),=C'INVALID TYPE COL 23'\nUERRS    MVI   USBGN,X'FF'             INSURE TABLE END INDIC\n         MVI   USERR,X'FF'             SHOW ERROR\n         BR    R9                      EXIT\n         DROP  R12\n*\n*\n*\n******************************************************************\n*                                                                *\n* EDIT ULABL CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* LABEL TABLE. SEARCH FOR ANY TYPE A (ADCON) ENTRIES HAVING A    *\n* SYMBOL OF AXXXXXX, WHERE XXXXXX IS THE HEX OFFSET TO THE USER  *\n* LABEL. IF AN A TYPE ENTRY IS FOUND, CHANGE ITS SYMBOLIC NAME TO*\n* THAT OF THE USER LABEL.                                        *\n*                                                                *\n******************************************************************\n*\nULABLS   EQU   *                       PROCESS USER LABEL CARDS\n         STM   R6,R12,ULSAV            SAVE REGS\n         CLI   WORKREC+6,C' '          NAME VALID\n         BE    ULERR1                  NO, 1ST CHAR CANNOT BE BLANK\n         MVC   UNAME+1(6),WORKREC+15   BUILD AXXXXXX NAME\n         TR    WORKREC+15(6),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+15(6),TRTHEX    CHECK VALID HEX\n         BNZ   ULERR2                  NOT VALID\n         MVZ   NUMCK,WORKREC+22        ZONES FOR NUMERIC TEST\n         CLC   NUMCK(3),ZEROS          LENGTH IS NUMERIC\n         BNE   ULERR3                  NO, ERROR\n         L     R6,CURRLBL              GET CURRENT LABEL TABLE ADDRESS\n         USING LABELD,R6\n         C     R6,ENDLBL               END OF TABLE\n         BNL   ULERR4                  YES, ERROR\n         MVC   LBLNAME,WORKREC+6       NAME TO LABEL ENTRY\n         MVI   LBLTYP,C'U'             TYPE TO LABEL ENTRY\n         PACK  DBLWD,WORKREC+22(3)     PACK LENGTH\n         CP    DBLWD,P256              LENGTH > 256\n         BH    ULERR2                  YES, ERROR\n         CVB   R12,DBLWD               CONVERT TO BINARY\n         STC   R12,LBLLEN              LENGTH TO LABEL ENTRY\n         PACK  DBLWD(4),WORKREC+15(7)  PACK TO MAKE VALID HEX\n         MVC   LBLADR,DBLWD            OFFSET TO LABEL\n         LA    R7,L'LABEL(R6)          @ NEXT LABEL ENTRY\n         MVC   0(3,R7),HIVAL           SET END INDIC\n         ST    R7,CURRLBL              SET NEW TABLE END ADDR\n         LR    R7,R6                   SAVE NEW ENTRY ADDRESS\n         L     R6,LBLTBL               GET 1ST LABEL ENTRY ADDR\nULBCKND  C     R6,CURRLBL              END OF TABLE\n         BNL   ULXIT                   YES, EXIT\n         CLI   LBLTYP,C'A'             IS IT ADCON ENTRY\n         BNE   ULBSTEP                 NO\n         CLC   LBLNAME,UNAME           ADCON SYMBOL AT USER LBL ADDR\n         BNE   ULBSTEP                 NO\n         MVC   LBLNAME,LBLNAME-LABEL(R7) SET USER SYMBOL IN ADCON\nULBSTEP  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         B     ULBCKND                 LOOP THRU LABEL TABLE\n         B     ULXIT                   EXIT\nULERR1   MVC   PRT+85(21),=C'INVALID NAME COL 7-14'\n         B     ULERRS                  CONTINUE\nULERR2   MVC   PRT+85(28),=C'INVALID HEX OFFSET COL 16-21'\n         B     ULERRS                  CONTINUE\nULERR3   MVC   PRT+85(32),=C'INVALID DECIMAL LENGTH COL 23-25'\n         B     ULERRS                  CONTINUE\nULERR4   MVC   PRT+85(20),=C'LABEL TABLE OVERFLOW'\nULERRS   MVI   USERR,X'FF'             SET ERROR FLAG\nULXIT    LM    R6,R12,ULSAV            RESTORE REGS\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* EDIT DSECT CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*\n* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*\n* DSECT HEADER TABLE, GETMAIN AN AREA TO CONTAIN THE FIELD       *\n* DESCRIPTION ENTRIES, READ AND BUILD FIELD ENTRIES FOR ALL FIELD*\n* DESCRIPTION CARDS ENTERED.                                     *\n*                                                                *\n******************************************************************\n*\nDSECTS   EQU   *                       *** DSECT PROCESSING ***\n         ST    R9,DSCT9                SAVE RETURN ADDR\n         CLI   WORKREC,C' '            NAME IS BLANK\n         BE    DSERR1                  YES, ERROR\n         MVZ   NUMCK,WORKREC+15        ZONES FOR CHECK\n         CLC   NUMCK,ZEROS             IS NBR FIELDS NUMERIC\n         BNE   DSERR2                  NO, ERROR\n         L     R12,DTBCUR              GET CURRENT DSECT TBL ADDR\n         C     R12,DTBEND              AT END OF TABLE\n         BNL   DSERR3                  YES, ERROR\n         MVC   0(8,R12),WORKREC        NAME TO DSECT TABLE\n         PACK  DBLWD,WORKREC+15(4)     PACK NBR ENTRIES\n         CVB   R10,DBLWD               CONVERT TO BINARY\n         LA    R10,4(R10)              ADD FOR SAFETY\n         MH    R10,DTBLEN              TIMES ENTRY LENGTH\n         GETMAIN R,LV=(10)             GET STORAGE FOR FIELD TABLE\n         STCM  R1,7,8(R12)             SAVE FIELD TABLE ADDRESS\n         LA    R12,11(R12)             TO NEXT DSECT TABLE ENTRY\n         ST    R12,DTBCUR              UPDATE CURRENT DSECT TBL ADDR\n         MVI   0(R12),X'FF'            SET END INDIC\n         LR    R12,R1                  COPY FIELD TABLE ADDR\n         BAL   R9,PRINT                PRINT DSECT RECORD\n         USING DSECTD,R12\n         CVB   R11,DBLWD               NBR ENTRIES IN LOOP REG\nRDFLD    L     R1,INDCB                GET SYSIN DCB ADDR\n         GET   (1)                     READ NEXT CARD\n         MVC   WORKREC,0(R1)           MOVE RECORD TO WORK AREA\n         MVC   PRT(80),WORKREC         MOVE RECORD TO PRINT AREA\n         CLI   WORKREC,C' '            NAME FIELD BLANK\n         BE    DSERR1                  YES, ERROR\n         MVC   DSNAME,WORKREC          NAME TO ENTRY\n         MVI   DSLBTYP,C'L'            SET LABEL TYPE\n         MVZ   NUMCK,WORKREC+9         ZONES FOR TEST\n         CLC   NUMCK,ZEROS             IS OFFSET NUMERIC\n         BNE   DSERR3                  NO, ERROR\n         PACK  DBLWD,WORKREC+9(4)      PACK OFFSET\n         CP    DBLWD,P4096             OFFSET > 4096\n         BH    DSERR3                  YES, ERROR\n         CVB   R1,DBLWD                CONVERT\n         STCM  R1,7,DSOFSET            OFFSET TO TABLE ENTRY\n         MVZ   NUMCK(3),WORKREC+14     ZONES FOR TEST\n         CLC   NUMCK(3),ZEROS          IS LENGTH NUMERIC\n         BNE   DSERR4                  NO, ERROR\n         PACK  DBLWD,WORKREC+14(3)     PACK LENGTH\n         CP    DBLWD,P256              LENGTH OVER 256\n         BH    DSERR4                  YES, ERROR\n         CVB   R1,DBLWD                CONVERT\n         LTR   R1,R1                   LENGTH IS ZERO\n         BZ    DSERR4                  YES, ERROR\n         STC   R1,DSLENG               LENGTH TO TABLE ENTRY\n         LA    R12,L'DSECT(R12)        TO NEXT ENTRY\n         MVI   0(R12),X'FF'            SET TBL END INDIC\n         BAL   R9,PRINT                GO PRINT CARD\n         BCT   R11,RDFLD               LOOP THRU DSECT\n         MVC   DSOFSET,HIVAL           TABLE STOPPER\n         L     R9,DSCT9                GET RETURN ADDR\n         BR    R9                      EXIT\nDSERR1   MVC   PRT+85(20),=C'INVALID NAME COL 1-8'\n         B     DSERRS                  CONTINUE\nDSERR2   MVC   PRT+85(28),=C'INVALID NBR FIELDS COL 16-19'\n         B     DSERRS                  CONTINUE\nDSERR3   MVC   PRT+85(24),=C'INVALID OFFSET COL 10-13'\n         B     DSERRS                  CONTINUE\nDSERR4   MVC   PRT+85(24),=C'INVALID LENGTH COL 15-18'\n         B     DSERRS                  CONTINUE\nDSERRS   MVI   USERR,X'FF'             SHOW ERROR FOUND\n         L     R9,DSCT9                GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R12\n*\n*\n*\n******************************************************************\n*                                                                *\n* EDIT DATA ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN  *\n* PRINT LINE IF ERRORS FOUND. CREATE DATA ONLY TABLE ENTRY IF NO *\n* ERRORS ARE FOUND.                                              *\n*                                                                *\n******************************************************************\n*\nDATAS    EQU   *                       *** DATA CARD PROCESSING ***\n         TR    WORKREC+5(6),TRHEX      TRANSLATE TO MAKE HEX\n         TRT   WORKREC+5(6),TRTHEX     CHECK VALID\n         BNZ   DERR1                   INVALID HEX\n         TR    WORKREC+12(6),TRHEX     TRANSLATE TO MAKE HEX\n         TRT   WORKREC+12(6),TRTHEX    CHECK VALID\n         BNZ   DERR2                   INVALID HEX\n         PACK  DBLWD(4),WORKREC+5(7)   PACK TO MAKE HEX\n         PACK  DBLWD+4(4),WORKREC+12(7) PACK TO MAKE HEX\n         CLC   DBLWD(3),DBLWD+4        CHECK 1ST LOW\n         BNL   DERR3                   1ST NOT LOW, ERROR\n         L     R1,DATOCUR              GET TBL ADDR\n         MVC   0(3,R1),DBLWD           MOVE 1ST OFFSET TO TBL\n         MVC   3(3,R1),DBLWD+4         MOVE 2ND OFFSET TO TBL\n         LA    R1,6(R1)                TO NEXT ENTRY\n         ST    R1,DATOCUR              SAVE CURRENT ENTRY ADDR\n         BR    R9                      EXIT\nDERR1    MVC   PRT+85(22),=C'1ST OFFSET INVALID HEX'\n         B     DERRS                   CONTINUE\nDERR2    MVC   PRT+85(22),=C'2ND OFFSET INVALID HEX'\n         B     DERRS                   CONTINUE\nDERR3    MVC   PRT+85(23),=C'END OFFSET BEFORE BEGIN'\nDERRS    MVI   USERR,X'FF'             FLAG ERROR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* MAINLINE ROUTINE FOR THE PRE-DISASSEMBLY. PURPOSE OF THIS PART *\n* OF THE PROGRAM IS TO ATTEMPT TO CREATE A LABEL ENTRY FOR INSTR-*\n* UCTIONS HAVING STORAGE OPERANDS. THE RESULTING LABEL TABLE WILL*\n* BE SORTED, AND DUPLICATE ENTRIES ELIMINATED BEFORE EXIT FROM   *\n* THIS PHASE OF DISASSEMBLY.                                     *\n*                                                                *\n******************************************************************\n*\nMAINLINE EQU   *                       MAINLINE ROUTINE\n         L     R6,LBLTBL               @ LABEL TABLE\n         USING LABELD,R6\n         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR\nGETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE\n         C     R7,TXTEND               END OF TEXT\n         BNL   EOJ                     YES             FIX********\n         LR    R12,R7                  COPY TEXT ADDR\n         S     R12,TXTSTRT             COMPUTE OFFSET\n         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE\n         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE USING TBLS\n         BH    CKDARNG                 NO\n         BAL   R9,NEXUSG               YES, GO DO IT\nCKDARNG  L     R12,NOINAD              GET DATA ONLY ENTRY ADDRESS\n         CLC   TXTOFSET,0(R12)         NOT YET TO THIS RANGE\n         BL    CKLOSEQ                 TRUE\n         CLC   TXTOFSET,3(R12)         NOW IN THE RANGE\n         BNH   CONST                   TRUE, TREAT AS CONSTANT\n         LA    R12,6(R12)              PAST THIS ONE, STEP TO NEXT\n         ST    R12,NOINAD              SAVE NEW ADDRESS\n         B     CKDARNG                 AND CHECK AGAIN\nCKLOSEQ  DS    0H\n         C     R6,CURRLBL              END OF USED LABEL TABLE?\n         BNL   GCKODD                  IF SO, IGNORE LABEL STUFF\n         CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ\n         BNH   GCKODD                  NO, CONTINUE\n         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL\n         B     CKLOSEQ                 CONTINUE SEQ CHK\nGCKODD   TM    TXTCURR+3,1             ODD ADDRESS\n         BO    CONST                   YES, NOT INSTR\n         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES\n         BE    CONST                   YES, NOT INSTR\n         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE\n         BNZ   CKINSTR                 NOT CHARACTER\n         CLI   CONPROG,1               IS CONSTANT IN PROGRESS\n         BNE   CK6                     NO\n         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE\n         BE    CONST                   YES, ADD THIS TO CONSTANT\nCK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS\n         BZ    CONST                   YES, NOT INSTRUCTION\nCKINSTR  SR    R8,R8                   CLEAR WORK\n         IC    R8,0(R7)                PICK UP TXT BYTE\n         MH    R8,SGOPLEN              TIMES TABLE LENGTH\n         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY\n         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY\n         CLI   INAME,0                 IS IT AN INSTR OP-CODE\n         BE    CONST                   NO\n         CLI   ITYPE,TWO               TWO-BYTE OP-CODE\n         BNE   INSTR                   NO\n         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR\nDBLND    CLI   0(R8),X'FF'             END OF TABLE\n         BE    CONST                   YES, NOT INSTR\n         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT\n         BE    GOTDBLI                 YES\n         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY\n         B     DBLND                   LOOP THRU TBL\nGOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES\n*\n*\n*\n******************************************************************\n*                                                                *\n* CHECK TO SEE IF THIS BYTE OF THE PROGRAM IS AN INSTRUCTION OP  *\n* CODE. IF SO, PERFORM THE APPROPRIATE PROCESSING ROUTINE.       *\n*                                                                *\n******************************************************************\n*\nINSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***\n         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH\n         LH    R12,ILENG               PICK UP LENGTH\n         AR    R12,R7                  ADDR OF NEXT OP CODE\n         SR    R15,R15                 CLEAR WORK\n         IC    R15,0(R12)              PICK UP NEXT OP-CODE\n         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG\n         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR\n         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE\n         BNE   ICKSEC                  YES\n         CLI   0(R7),X'45'             IS IT BAL\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'4D'            IS IT BAS\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'0B'            IS IT BSM\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R7),7                 NO, IS IT BCR\n         BE    POSSB                   YES\n         CLI   0(R7),X'47'             IS IT BC\n         BNE   CONST                   NO, THEN THIS NOT INSTR\nPOSSB    TM    1(R7),X'F0'             IS IT UNCONDL BRCH\n         BNO   CONST                   NO, THEN THIS NOT INSTR\n         B     ICKTBL                  ACCEPT UNCOND BRCHS\nICKSEC   SR    R1,R1                   CLEAR WORK\n         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH\n         AR    R1,R12                  ADDR OF NEXT OP CODE\n         SR    R14,R14                 CLEAR WORK\n         IC    R14,0(R1)               PICK UP NEXT OP-CODE\n         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG\n         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR\n         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE\n         BNE   ICKTBL                  YES\n         CLI   0(R12),X'45'            IS IT BAL\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'4D'            IS IT BAS\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'0B'            IS IT BSM\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'07'            NO, IS IT BCR\n         BE    POSSB2                  YES\n         CLI   0(R12),X'47'            IS IT BC\n         BNE   CONST                   NO, THEN THIS NOT INSTR\nPOSSB2   TM    1(R12),X'F0'            IS IT UNCONDL BRCH\n         BNO   CONST                   NO, THEN THIS NOT INSTR\nICKTBL   LH    R12,ILENG               GET INSTR LENGTH\n         AR    R12,R7                  @ NEXT TEXT LOC\n         BCTR  R12,R0                  BACK UP 1\n         S     R12,TXTSTRT             RELATIVIZE IN CSECT\n         CLM   R12,7,LBLADR            LBL TBL ADDR HERE\n         BL    NOILBL                  NO\n         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START\n         BNE   CONST                   NO, MUST BE CONSTANT\n         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CONST                   NO\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   SETLBL                  NO\n         BAL   R9,FORCONST             YES, FORCE IT OUT\nSETLBL   LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         B     ICKTBL                  GO CHECK NEXT LABEL\nNOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   MVMNE                   NO\n         BAL   R9,FORCONST             YES, FORCE IT OUT\nMVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC\n         MVC   OFFSET,TXTOFSET         SET OFFSET\n         MVC   INSTYP,5(R8)            SET INSTR TYPE\n         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION\n         MVC   LEN,ILENG+1             SHOW LENGTH\n         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT\nOPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE\n         BO    FPVERFY                 YES, GO VERIFY\n         CLI   IEDT,0                  ANY EDIT REQUIRED\n         BE    PFMFMT                  NO\n         B     IVERFY                  YES, GO EDIT\nPFMFMT   SR    R1,R1                   CLEAR WORK\n         IC    R1,INSTYP               GET INSTRUCTION TYPE\n         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR\n         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN\n         B     INSTOUT                 TYPE=0, RR\n         B     RXOPND                  TYPE=4, RX\n         B     SOPND                   TYPE=8, S\n         B     SIOPND                  TYPE=C, SI\n         B     RSOPND                  TYPE=10, RS\n         B     SS1OPND                 TYPE=14, 1-LENGTH SS\n         B     SS2OPND                 TYPE=18, 2-LENGTH SS\n         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES\n         B     RXOPND                  TYPE=20, CONDITIONAL BRANCH\n         B     SVCOPND                 TYPE=24, SVC\n         B     SSEOPND                 TYPE=28, SSE\n         B     EOPND                   TYPE=2C, E\n         B     INSTOUT                 TYPE=30, RRE 1 OPERAND\n         B     INSTOUT                 TYPE=34, RRE 2 OPERANDS\nOPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN\n         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS\nINSTOUT  AH    R7,ILENG                STEP TO NEXT TEXT BYTE\n         ST    R7,TXTCURR              SAVE NEXT ADDR\n         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE\n         B     GETCURR                 CONTINUE TXT PROCESSING\n*\n*\n*\n******************************************************************\n*                                                                *\n* GENERAL OP-CODE TESTS TO VERIFY THAT NON-FLOATING-POINT OP     *\n* CODES ARE INDEED OP-CODES.                                     *\n*                                                                *\n******************************************************************\n*\nIVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION\n         TM    IEDT,EPR                EVEN-ODD REG PAIR\n         BZ    IVE2                    NO\n         TM    1(R7),X'10'             R1 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'0E'             IS IT MVCL\n         BE    IVTRG2                  YES\n         CLI   0(R7),X'0F'             IS IT CLCL\n         BNE   IVE2                    NO\nIVTRG2   TM    1(R7),X'01'             R2 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         SR    R1,R1                   CLEAR WORK\n         SR    R2,R2                   CLEAR WORK\n         IC    R1,1(R7)                GET R1R2\n         SRL   R1,4                    SHIFT OUT R2\n         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE\n         IC    R2,DBLWD                PICK UP R2R1\n         SRL   R2,4                    SHIFT OUT R1\n         CR    R1,R2                   R1=R2\n         BE    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT\n         BZ    IVE4                    NO\n         TM    3(R7),X'01'             DISPL IS ODD\n         BZ    IVES2                   NO, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   0(R7),X'44'             EX OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'47'             BC OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG IS 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   CONTINUE\nIVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND\n         BZ    IVE8                    NO\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   ITYPE,RS                RS INSTRUCTION OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   NO, CONTINUE\nIVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND\n         BZ    IVES2                   NO\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\nIVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    PFMFMT                  YES\n         TM    IEDT,S2                 OPND2 MUST HAVE BASE\n         BZ    IVES1                   NO\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   PFMFMT                  NO, O.K.\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'92'             IS IT MVI OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE\n         BZ    PFMFMT                  NO, CONTINUE\n         TM    2(R7),X'F0'             1ST OPND HAS BASE\n         BZ    CONST                   NO, NOT INSTR\n         B     PFMFMT                  YES, INSTR O.K.\n*\n*\n*\n******************************************************************\n*                                                                *\n* GENERAL OP-CODE TESTS TO VERIFY THAT FLOATING-POINT OP-CODES   *\n* ARE INDEED OP-CODES.                                           *\n*                                                                *\n******************************************************************\n*\nFPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C\n         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'27'             MXDR OP-CODE\n         BE    FPR1EXT                 YES\n         CLI   0(R7),X'67'             MXD OP-CODE\n         BNE   FPCKTYP                 NO\nFPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4\n         BNZ   CONST                   NO, NOT INSTR\nFPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION\n         BNE   FPRXVER                 NO\n         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'25'             LRDR OP CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'37'             SXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'26'             MXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'36'             AXR OP-CODE\n         BNE   PFMFMT                  NO, GOOD INSTR\nFPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4\n         BZ    PFMFMT                  YES, GOOD INSTR\n         B     CONST                   NO, NOT INSTR\nFPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.\n         BE    FPALIGN                 YES\n         TM    2(R7),X'F0'             ANT BASE REG\n         BNZ   FPALIGN                 YES\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BZ    CONST                   NO, NOT INSTR\nFPALIGN  TM    2(R7),X'F0'             ANY BASE REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BNZ   CONST                   NO, NOT INSTR\n         TM    ICLASS,FLSHT            SHORT PRECISION\n         BO    PFMFMT                  YES, ACCEPT INSTRUCTION\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    PFMFMT                  YES, ACCEPT INSTR\n         B     CONST                   NO, NOT INSTR\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS TEXT BYTES DETERMINED TO BE CONSTANT DATA.             *\n*                                                                *\n******************************************************************\n*\nCONST    EQU   *                       *** PROCESS CONSTANTS ***\n         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CCNEW                   NO\n         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET\n         BNE   CGETYP                  NO\nCSTNEW   BAL   R9,FORCONST             FORCE IT OUT\n         B     CCNEW                   GO START A NEW ONE\nCGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE\n         BNZ   CHEX                    IT'S HEX\n         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE\n         B     CCKTYP                  GO COMPARE\nCHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE\nCCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE\n         BNE   CSTNEW                  NO\nCUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH\n         LA    R11,1(R11)              ADD 1\n         STH   R11,CONLEN              UPDATE LENGTH\n         CLI   CONTYPE,C'C'            CHARACTER CONSTANT\n         BE    CCK8                    YES\n         TM    CONOFST+3,1             OFFSET IS ODD\n         BO    CCFIN1                  YES\n         TM    CONOFST+3,2             HALFWORD OFFSET\n         BZ    CCFWD                   NO\n         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1\n         BE    CCXIT1                  YES\n         B     CCFIN1                  NO\nCCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES\n         BL    CCXIT1                  NOT YET\nCCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT\n         B     CCXIT1                  FINISH\nCCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES\n         BNL   CCFIN1                  YES\nCCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDR\n         B     GETCURR                 CONTINUE TEXT PROCESSING\nCCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS\n         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE\n         MVC   CONLEN,XZROS            CLEAR LENGTH\n         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET\n         BE    CLBLD                   YES\nTRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE\n         BNZ   CCSHX                   IT'S HEX\n         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CDATACON                NO\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR\n         BNE   TRTYPE                  NO\n         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY\n         BNE   CDATACON                NO\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         B     CCNEW                   GO TO NEXT LABEL\nCDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH\n         STH   R1,CONLEN               SAVE CONSTANT LENGTH\n         SR    R11,R11                 CLEAR WORK REG\n         IC    R11,LBLLEN              PICK UP LENGTH\n         AR    R7,R11                  STEP PAST TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDRESS\n         BAL   R9,FORCONST             FORCE CONSTANT OUT\n         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY\n         B     GETCURR                 CONTINUE TEXT PROCESS\n         DROP  R6\n*\n*\n*\n******************************************************************\n*                                                                *\n* CLEAR OUT AREAS SET UP FOR CONSTANT DATA.                      *\n*                                                                *\n******************************************************************\n*\nFORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE\n         MVI   CONPROG,0               RESET CONSTANT IN PROGRESS\n         MVI   CONTYPE,0               RESET TYPE\n         XC    CONLEN,CONLEN           CLEAR LENGTH\n         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS RX-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n*\nRXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***\n         SR    R11,R11                 CLEAR WORK REG\n         ICM   R11,3,TEXT+2            GET BDDD\n         LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    RXBDDD                  YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    RXBDDD                  YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    RXBDDD                  NO\n         LA    R10,8                   YES, SET LENGTH = 8\nRXBDDD   B     BDLADR                  CHECK LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS S-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS   *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n*\nSOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***\n         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO\n         BE    SCK2                    YES\n         CLI   0(R7),X'80'             NO, IS IT SSM\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'82'             NO, IS IT LPSW\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'93'             NO, IS IT TS\n         BE    4(R9)                   YES, NOT INSTR\nSCK2     CLI   0(R7),X'B2'             OP-CODE IS B2\n         BNE   SSTRT                   NO\n         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO\n         BE    SSTRT                   YES\n         CLI   1(R7),X'0B'             IPK INSTRUCTION\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   1(R7),X'0D'             PTLB INSTR\n         BE    4(R9)                   YES, NOT INSTR\nSSTRT    SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD\n         LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    SBDDD                   YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    SBDDD                   YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    SBDDD                   NO\n         LA    R10,8                   YES, SET LENGTH = 8\nSBDDD    B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SI-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n*\nSIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         LA    R10,0                   LENGTH=DON'T CARE\n         B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS RS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *\n*                                                                *\n******************************************************************\n*\nRSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***\n         CLI   0(R7),X'88'             IS IT SHIFT INSTR\n         BL    RSCMA1                  NO\n         CLI   0(R7),X'8F'             IS IT SHIFT INSTR\n         BH    RSCMA1                  NO\n         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0\n         BZ    0(R9)                   YES, GOOD SHIFT\n         B     4(R9)                   NO, NOT INSTR\nRSCMA1   SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDD ADDRESS\n         LA    R10,4                   SET LENGTH = 4\n         TM    INLNG,E4                FULLWORD OPERAND\n         BO    RSBDDD                  YES\n         LA    R10,2                   SET LENGTH = 2\n         TM    INLNG,E2                HALFWORD OPERAND\n         BO    RSBDDD                  YES\n         LA    R10,1                   SET LENGTH = 1\n         TM    INLNG,E8                DOUBLEWORD OPERAND\n         BZ    RSBDDD                  NO\n         LA    R10,8                   YES, SET LENGTH = 8\nRSBDDD   B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *\n* SINGLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *\n*                                                                *\n******************************************************************\n*\nSS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET LENGTH CODE\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         LA    R1,SS1RTN               GET RTEURN ADDR\n         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR\n         ST    R1,OPND9                CHANGE RETURN ADDR\n         B     BDLADR                  CHECK LABEL\nSS1RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS\n         SR    R10,R10                 CLEAR LENGTH REG\n         IC    R10,TEXT+1              GET INSTR LENGTH\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*\n* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *\n* DOUBLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *\n*                                                                *\n******************************************************************\n*\nSS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET L1L2\n         SRL   R10,4                   SHIFT OUT L2\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         LA    R1,SS2RTN               GET RETURN ADDR\n         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR\n         ST    R1,OPND9                CHANGE RETURN ADDRESS\n         B     BDLADR                  CHECK LABEL\nSS2RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP L2L1\n         SRL   R10,4                   SHIFT OUT L1\n         CLI   TEXT,X'F0'              SRP OP-CODE\n         BNE   SS2BDDD                 NO\n         IC    R10,TEXT+1              GET INSTR LENGTH\n         SRL   R10,4                   SHIFT OUT I3\nSS2BDDD  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         B     BDLADR                  CHECK LABEL\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SVC INSTRUCTIONS. THE SOLE PROCESSING IS TO VERIFY THAT*\n* THIS IS A VALID SVC.                                           *\n*                                                                *\n******************************************************************\n*\nSVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***\n         CLI   TEXT+1,126              VALID OPERAND\n         BH    NOTSVC                  NO, NOT SVC\n         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS\nSVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE\n         BE    NOTSVC                  YES, MUST NOT BE SVC\n         CLC   0(1,R1),TEXT+1          THIS THE ENTRY\n         BE    GOTSVC                  YES\n         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY\n         B     SVCKND                  LOOP THRU TABLE\nNOTSVC   B     4(R9)                   ERROR RETURN\nGOTSVC   BR    R9                      EXIT, NO STORAGE OPND\n*\n*\n*\n******************************************************************\n*                                                                *\n* PROCESS SSE INSTRUCTIONS.                                      *\n*                                                                *\n******************************************************************\n*\nSSEOPND  EQU   *                       *** SSE INSTRUCTIONS ***\n         LA    R1,SSERTN               GET RTEURN ADDR\n         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR\n         ST    R1,OPND9                CHANGE RETURN ADDR\n         SR    R10,R10                 CLEAR LENGTH REG\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET FIRST BDDD ADDRESS\n         B     BDLADR                  CHECK LABEL\nSSERTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR\n         SR    R10,R10                 CLEAR LENGTH REG\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS\n         B     BDLADR                  CHECK FOR LABEL\n*\n*\n*\n******************************************************************\n* PROCESS E INSTRUCTIONS                                         *\n******************************************************************\nEOPND    EQU   *\n         BR    R9\n*\n*\n*\n******************************************************************\n*                                                                *\n* SET UP CURRENT BASE REGISTERS IN THE BASE TABLE. THE USING     *\n* TABLE IS SCANNED FOR ENTRIES VALID AT THE CURRENT TEXT OFFSET. *\n* WHEN A BASE REGISTER ENTRY IS FOUND TO BE VALID AT THE CURRENT *\n* TEXT OFFSET, THE USING ENTRY IS MOVED TO THE APPROPRIATE LOC-  *\n* ATION IN THE BASE TABLE FOR USE BY THE BDLADR ROUTINE. THE TEXT*\n* OFFSET TO THE NEXT BASE REGISTER CHANGE IS SET SO THAT THIS    *\n* ROUTINE WILL AGAIN BE ENTERED WHEN THE CURRENT BASE REGISTERS  *\n* ARE EXHAUSTED.                                                 *\n*                                                                *\n******************************************************************\n*\nNEXUSG   EQU   *                       *** GET NEXT BASE REGS ***\n         MVI   MORUSG,0                RESET INDICATOR\n         XC    BASES,BASES             CLEAR OLD BASE REG VALUES\n         MVC   NEXCHG,HIVAL            SET NEXT CHANGE LOC HIGH\n         L     R2,USGSTRT              GET USING TBL START\n         USING USINGD,R2\nENDUS    CLI   0(R2),X'FF'             END OF TABLE\n         BCR   8,R9                    YES, EXIT\n         CLC   TXTOFSET,USEND          PAST THIS ONE\n         BNL   ECSTEP                  YES\n         OI    MORUSG,1                SHOW MORE BASES AVAILABLE\nUSBGCK   CLC   TXTOFSET,USBGN          THIS STARTS LATER\n         BNL   CKNEWLO                 NO\n         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHG\n         DS    0H\n         BNL   ECSTEP                  NO\n         MVC   NEXCHG,USBGN            YES, SET NEW CHANGE OFFSET\n         B     ECSTEP                  CONTINUE\nCKNEWLO  CLC   USEND,NEXCHG            NEW LOW CHANGE ADDR\n         BNL   ECMVC                   NO\n         MVC   NEXCHG,USEND            YES, SET LOWER OFFSET\nECMVC    SR    R1,R1                   CLEAR WORK\n         IC    R1,USREG                PICK UP REGISTER\n         MH    R1,USGLEN               TIMES ENTRY LENGTH\n         LA    R1,BASES(R1)            @ TABLE ENTRY\n         MVC   0(L'USING,R1),USING     ENTRY TO TABLE\n         OI    MORUSG,X'80'            SHOW BASE REG CURRENT\nECSTEP   LA    R2,L'USING(R2)          TO NEXT USING TBL ENTRY\n         B     ENDUS                   LOOP THRU USING TBL\n         DROP  R2\n*\n*\n*\n******************************************************************\n*                                                                *\n* A BASE-DISPLACEMENT IS PROVIDED IN REG 11 ON ENTRY. IF ANY     *\n* BASE REGISTERS ARE CURRENT, AND THE BASE REGISTER FOR THE GIVEN*\n* ADDRESS IS A CURRENT PROGRAM BASE REGISTER, A LABEL ENTRY IS   *\n* BUILT. OFFSET TO THE LABEL WILL BE FOUND BY ADDING THE ASSUMED *\n* BASE REGISTER VALUE TO THE GIVEN DISPLACEMENT. THE LABEL NAME  *\n* WILL BE THE LETTER 'A' FOLLOWED BY THE OFFSET.                 *\n*                                                                *\n******************************************************************\n*\nBDLADR   EQU   *                       *** BUILD LABEL ENTRIES ***\n         TM    MORUSG,1                ANY BASES CURRENT\n         BZ    BDLXIT                  NO\n         LR    R2,R11                  COPY BDDD ADDRESS\n         SRL   R2,12                   RIGHT JUSTIFY BASE REG\n         MH    R2,USGLEN               TIMES ENTRY LENGTH\n         LA    R2,BASES(R2)            @ BASE REG TABLE ENTRY\n         USING USINGD,R2\n         CLI   USTYPE,C'P'             IS IT A PROGRAM BASE\n         BNE   BDLXIT                  NO\n         SLL   R11,20                  ISOLATE THE\n         SRL   R11,20                  DDD IN R11\n         SR    R1,R1                   CLEAR WORK\n         ICM   R1,7,USVALU             GET BASE REG VALUE\n         AR    R11,R1                  COMPUTE PROGRAM OFFSET\n         DROP  R2\n         L     R1,CURRLBL              GET LBL TBL ADDR\n         C     R1,ENDLBL               END OF TABLE\n         BL    GOTHOLE                 NO\n         BAL   R9,COMPLBL              YES, COMPRESS DUPLICATES\n         L     R1,CURRLBL              GET NEW CURRENT LBL ADDR\n         C     R1,ENDLBL               STILL AT END\n         BNL   TXTEND                  YES, TERMINATE THIS STAGE\n         USING LABELD,R1\nGOTHOLE  STCM  R11,7,LBLADR            SET LABEL ENTRY OFFSET\n         MVI   LBLNAME,C'A'            BEGIN LABEL NAME\n         LA    R12,LBLADR              @ OFFSET\n         BAL   R9,HEXPRT3              GO CONVERT\n         MVC   LBLNAME+1(6),PRTABL     REST OF NAME\n         MVI   LBLNAME+7,C' '          FINAL BLANK IN NAME\n         MVI   LBLTYP,C'L'             SET LABEL TYPE\n         CLI   TEXT,X'47'              THIS A CONDITIONAL BRANCH\n         BE    INSTREF                 YES\n         CLI   TEXT,X'45'              BAL INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'46'              BCT INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'44'              EX INSTR\n         BE    INSTREF                 YES\n         CLI   TEXT,X'87'              BXLE INSTRUCTION\n         BE    INSTREF                 YES\n         CLI   TEXT,X'86'              BXH INSTRUCTION\n         BNE   BDLSTP                  NO\nINSTREF  SR    R12,R12                 CLEAR WORK REG\n         A     R11,TXTSTRT             BRCH ADDR IN STORED TEXT\n         LA    R10,4                   ASSUME LENGTH IS 4\n         TM    0(R11),X'C0'            TEST HI 2-BITS OF OP-CODE\n         BM    BDLSTP                  01 OR 10 IS 4-BYTE INSTR\n         BO    BDLSIX                  YES, SIX-BYTE INSTR\n         LA    R10,2                   BOTH OFF, 2-BYTE INSTR\n         B     BDLSTP                  CONTINUE\nBDLSIX   LA    R10,6                   SET LENGTH TO 6\nBDLSTP   STC   R10,LBLLEN              LENGTH TO LABEL ENTRY\n         LA    R1,L'LABEL(R1)          TO NEXT ENTRY\n         ST    R1,CURRLBL              SAVE UPDATED TBL ADDR\nBDLXIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R1\n*\n*\n*\n******************************************************************\n*                                                                *\n* SORT THE LABEL TABLE AND ELIMINATE ANY DUPLICATE ENTRIES.      *\n*                                                                *\n******************************************************************\n*\nCOMPLBL  EQU   *                       *** COMPRESS AND SORT LABEL TABL\n         USING LABELD,R6\n         L     R6,LBLTBL               GET LABEL TABLE ADDR\nLBSTPASS LA    R7,L'LABEL(R6)          @ NEXT LABEL TABLE ENTRY\nLBLND    C     R7,CURRLBL              AT TABLE END\n         BL    LBSAMPS                 NO\nNEXPAS0  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         C     R6,CURRLBL              END OF TABLE\n         BL    LBSTPASS                NO\n         B     LBFEND                  YES, FIND END\nLBSAMPS  CLC   LBLADR,LBLADR-LABEL(R7) IDENTICAL OFFSETS\n         BH    LBSWCH                  NO, FIRST HIGH, SWITCH\n         BL    LBSTP                   NO, LOW, CONTINUE SCAN\n         CLC   LABEL,0(R7)             ENTRIES ARE IDENTICAL\n         BNE   LBCKLBL                 NO\nLBNULL2  MVC   LBLADR-LABEL(3,R7),HIVAL YES, NULL 2ND\n         B     LBSTP                   AND CONTINUE SCAN\nLBCKLBL  CLC   LBLNAME,LBLNAME-LABEL(R7) IDENTICAL LABELS\n         BNE   LBCKTYP                 NO, CHECK TYPES\nLBCKLN   CLI   LBLLEN,0                THIS ENTRY LENGTH = 0\n         BNE   LBCKLN2                 NO\n         MVI   LBLLEN,X'FF'            YES, SET HIGH LENGTH\nLBCKLN2  CLC   LBLLEN,LBLLEN-LABEL(R7) COMPARE LENGTHS\n         BH    LBSWCH                  1ST LENGTH HIGH, SWITCH ENTRIES\n         B     LBNULL2                 1ST LOW/=, NULL 2ND\nLBCKTYP  CLC   LBLTYP,LBLTYP-LABEL(R7) SAME ENTRY TYPE\n         BNE   LBCK1L                  NO, CHK TYPE ORDER\n         CLI   LBLTYP,C'L'             ARE THEY TYPE L\n         BE    LBSTP                   YES, CONTINUE SCAN\n         CLI   LBLTYP,C'U'             USER LABEL\n         BNE   LBNULL2                 NO\n         B     LBSTP                   YES\nLBCK1L   CLI   LBLTYP,C'U'             1ST IS USER LABEL\n         BNE   LBCK2L                  NO\n         CLI   LBLTYP-LABEL(R7),C'L'   2ND IS TYPE L\n         BE    LBNULL2                 YES, NULL THE 2ND\n         B     LBSTP                   CONTINUE SCAN\nLBCK2L   CLI   LBLTYP-LABEL(R7),C'U'   2ND IS USER LABEL\n         BE    LBSWCH                  YES\n         CLI   LBLTYP,C'L'             1ST IS LABEL TYPE\n         BE    LBSTP                   YES, CONTINUE SCAN\nLBSWCH   MVC   WORKREC(L'LABEL),LABEL  HOLD 1ST ENTRY\n         MVC   LABEL,0(R7)             MOVE 2ND ENTRY TO 1ST\n         MVC   0(L'LABEL,R7),WORKREC   1ST ENTRY TO 2ND LOCATION\n         B     LBSAMPS                 GO RECHECK\nLBSTP    LA    R7,L'LABEL(R7)          TO NEXT LABEL ENTRY\n         B     LBLND                   CONTINUE SCAN\nLBFEND   L     R6,LBLTBL               @ LABEL TABLE\nLBFCKFF  CLI   LABEL,X'FF'             NULL ENTRY\n         BE    LBSTCURR                YES\n         C     R6,CURRLBL              AT FORMER END\n         BE    LBSTCURR                YES\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     LBFCKFF                 LOOP TO FIND END\nLBSTCURR ST    R6,CURRLBL              SAVE NEW TBL END ADDR\n         BR    R9                      EXIT\n         DROP  R6\n*\n*\n*\n******************************************************************\n*                                                                *\n* END OF PHASE 1. SORT/COMPRESS THE LABEL TABLE AND RETURN.      *\n*                                                                *\n******************************************************************\n*\nEOJ      EQU   *                       END OF JOB\n         BAL   R9,COMPLBL              SORT/COMPRESS LABEL TBL\n         L     R6,LBLTBL               GET LABEL TABLE ADDR\n         USING LABELD,R6\nEOJCKND  C     R6,CURRLBL              END OF TABLE\n         BNL   EOJ2                    YES\n         CLI   LBLTYP,C'U'             USER LABEL\n         BNE   EOJSTEP                 NO\n         MVI   LBLTYP,C'L'             YES, CHANGE TO TYPE L\nEOJSTEP  LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     EOJCKND                 CONTINUE LOOP\n         DROP  R6\nEOJ2     MVC   PRT,BLANX               CLEAR PRINT\n         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE\n         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS\n         SR    R15,R15                 CLEAR RETURN CODE\n         BR    R14                     RETURN TO CALLER\n*\n*\n*\n******************************************************************\n*                                                                *\n* CONVERT HEX BYTES TO THEIR PRINTABLE EQUIVALENTS. ON ENTRY, REG*\n* 12 CONTAINS THE ADDRESS OF THE FIRST BYTE TO BE CONVERTED. THE *\n* NUMBER OF BYTES IS DETERMINED BY THE ENTRY SELECTED. PRINTABLE *\n* HEX IS PLACED IN THE FIELD PRTABL, TWO CHARACTERS PER BYTE.    *\n*                                                                *\n******************************************************************\n*\nHEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *\n*                                                                *\n******************************************************************\n*\nPRINT    EQU   *                       PRINT ROUTINE\n         L     R1,PRINTDCB             @ SYSPRINT DCB\n         TM    48(R1),X'10'            IS SYSPRINT OPEN\n         BNO   CLRPRT                  NO\n         PUT   (1),PRTLINE             WRITE PRINT LINE\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\nNEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n         BR    R9                      EXIT\n*\n*\n*\n*                 *** DATA AND WORK AREAS ***\n*\n******************************************************************\n*                                                                *\n* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED\n* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED\n* WITH ALL OTHER PROGRAMS.\n*\n******************************************************************\n*\n         DS    0D\nCOMMPARM DSECT ,                       COMMON AREAS\nDBLWD    DS    D                       DOUBLEWORD WORK AREA\nPUNCHDCB DS    F                       @ SYSPUNCH DCB\nPRINTDCB DS    F                       @ SYSPRINT DCB\nINDCB    DS    F                       @ SYSIN DCB\nCSECT    DS    CL8                     SPECIFIED CSECT NAME\nESDID    DS    XL2                     ESD ID OF SPECIFIED CSECT\nENDLBLNM DS    CL8                     SYMBOL FOR END STMT BEGIN POINTE\nLINECT   DS    PL2                     PRINT LINE COUNTER\nSTART    DS    A                       LKED ASSIGNED START ADDR OF CSEC\nEND      DS    A                       CSECT END ADDRESS\nLENGTH   DS    F                       LENGTH OF SPECIFIED CSECT\nLBLTBL   DS    F                       @ LABEL TABLE\nCURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR\nENDLBL   DS    F                       @ END OF LABEL TBL\nLBLLGTH  DS    AL2                     LENGTH OF LABEL ENTRY\nTXTSTRT  DS    F                       @ TEXT STORAGE AREA\nTXTEND   DS    F                       @ END OF TEXT AREA\nTXTCURR  DS    F                       @ CURRENT TEXT LOC\nDTBCUR   DS    F                       @ CURRENT DSECT TBL ENTRY\nDTBEND   DS    F                       @ DSECT TBL END\nDTBSTRT  DS    F                       @ DSECT TBL START\nUSGSTRT  DS    F                       @ USING TBL START\nUSGCUR   DS    F                       @ CURRENT USING TBL ENTRY\nUSGEND   DS    F                       @ USING TBL END\nDATONLY  DS    F                       @ DATA ONLY TABLE\nDATOCUR  DS    F                       @ CURRENT DATA ONLY ENTRY\nDATOEND  DS    F                       @ END OF DATA ONLY TABLE\nFLPTASM  DS    XL1                     FLOATING POINT INDICATOR\nPRIVASM  DS    XL1                     PRIVILEGED INDICATOR\nUSERR    DS    XL1                     ERROR INDIC FOR DISASM1\nNBRLBLS  DS    H                       NBR LABELS FROM DISASM1\n*\n*\n*\nWORKREC  DS    0CL80                   DISASSEMBLY WORK AREA\nNAME     DS    CL8                     NAME\n         DS    CL1\nMNEMONIC DS    CL5                     INSTRUCTION MNEMONIC\n         DS    CL1\nOPNDS    DS    CL27                    1ST OPERAND\n         DS    CL1\nCOMMENT  DS    CL28                    COMMENT\nCOL72    DS    CL1                     CONTINUATION COLUMN\nSEQNBR   DS    CL8                     CARD SEQUENCE NBR\n*\n*\n*\nCARDNO   DS    PL4                     CURRENT OUTPUT CARD NBR\nPRTLINE  DS    0CL121                  PRINT LINE\nPCC      DS    CL1                     CARRIAGE CONTROL\nPRT      DS    CL120                   PRINT DATA\n*\n*\n*\n         DS    0F\nBLDLIST  DS    0CL62                   BLDL LIST\n         DC    H'1'                    ONE ENTRY\n         DC    H'58'                   LENGTH OF ENTRY\nMEMBER   DC    CL8' '                  MEMBER NAME\nTTRMOD   DC    XL3'000000'             TTR OF MODULE\nCCAT     DC    XL1'00'                 CONCATENATION NUMBER\n         DC    XL1'00'\nALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR\n*                           80=ALIAS\nTTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD\n         DC    XL1'00'\nTTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST\nNNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST\nATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1\n*                           80=RENT\n*                           40=REUS\n*                           20=OVERLAY\n*                           10=UNDER TEST\n*                           08=ONLY LOADABLE\n*                           04=SCATTER FORMAT\n*                           02=EXECUTABLE\n*                           01=ONE TXT, NO RLD RECORDS\nATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2\n*                           80=CANNOT BE REPROCESSED BY LKED E\n*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO\n*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO\n*                           10=CONTAINS NO RLD RECORD\n*                           08=CANNOT BE REPROCESSED BY LKED\n*                           04=CONTAINS TESTRAN SYMBOLS\n*                           02=CREATED BY LKED\n*                           01=REFR\nTOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD\nLENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD\nLKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR\nATTR2    DC    XL1'00'                 ATTRIBUTES 2\n*                           80=PROCESSED BY OS/VS LKED\n*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE\n*                           10=SSI PRESENT\n         DC    XL2'0000'\nSCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH\nTTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH\nSCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD\nSCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT\nALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME\nALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS\nSSI      DS    XL4'00000000'           SSI BYTES\nAUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH\nAUTHCOD  DC    XL1'00'                 AUTH CODE\n*\n*\n*\nCOMMEND  EQU   *\n*\n*\n*\nLABELD   DSECT ,                       LABEL TABLE ENTRY\nLABEL    DS    0CL13                   13-BYTE ENTRIES\nLBLADR   DS    XL3                     RELATIVE ADDR IN TEXT\nLBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,\nLBLNAME  DS    CL8                     NAME (SYMBOL)\nLBLLEN   DS    XL1                     LENGTH IF A, V, OR W\n*\n*\n*\nUSINGD   DSECT ,                       USING TABLE ENTRY\nUSING    DS    0CL11\nUSBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE\nUSEND    DS    XL3                     OFFSET TO END OF RANGE\nUSREG    DS    XL1                     BASE REGISTER USED\nUSTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT\nUSVALU   DS    XL3                     BASE REG VALUE\n*\n*\n*\nDSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY\nDSECT    DS    0CL13\nDSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD\nDSLBTYP  DS    CL1                     LABEL TYPE = L\nDSNAME   DS    CL8                     FIELD NAME\nDSLENG   DS    XL1                     FIELD LENGTH\n*\n*\n*\nDISASM1  CSECT\n*\n*\n*\nSVCTBLAD DC    A(SVCOP)                @ SVC TABLE\nDBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL\nOPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES\nDSCT9    DS    F                       RETURN FOR DSECTS\nSAVOP9   DS    F                       SAVE AREA FOR OPND9\nULSAV    DS    7F                      SAVE AREA FOR CKADCON\nNOINAD   DS    F                       DATA ONLY TABLE ADDRESS\nSGOPLEN DC AL2(L'SGLOP) SINGLE BYTE OP COD TBL LEN                   */\nDTBLEN DC AL2(L'DSECT) DSECT TABLE ENTRY LENGTH                      */\nNUMCK    DC    C'0000'                 NUMERIC CHECK AREA\nZEROS    DC    C'0000'                 CONSTANT ZEROS\nILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***\nCONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC\nBASES    DC    XL256'0'                CURRENT BASE REGS\nHIVAL    DC    4X'FF'                  CONSTANT F'S\n         DS    0H\nUSGLEN DC AL2(L'USING) LENGTH OF USING TBL ENTRY                     */\nNEXCHG   DC    XL3'00'                 NEXT BASE REG CHG OFFSET\nMORUSG   DC    X'00'                   80=CURRENT BASE, 0=NO MORE BASES\nCONTYPE  DS    CL1                     TYPE\nCONLEN   DS    H                       CONSTANT LENGTH\nCONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT\nCCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING\nTXTOFST  DS    0F\n         DS    X\nTXTOFSET DS    XL3                     OFFSET TO TEXT BYTE\nOFFSET   DS    XL3                     OFFSET FROM PGM START\nINSTYP   DS    CL1                     INSTRUCTION TYPE\nTYPE     DS    XL1                     TYPE CODE\n*                                       0=CSECT, 1=ADCON, 2=CONST\n*                                       E=USING, D=INSTRUCTION\n*                                       C=COMMENT, 9=ENTRY\n*                                       A=EQU\nLEN      DS    XL1                     TEXT LENGTH\nTEXT     DS    XL8                     TEXT\nH1       DC    H'1'                    CONSTANT 1\nH2       DC    H'2'                    CONSTANT 2\nH4       DC    H'4'                    CONSTANT 4\nH7       DC    H'7'                    CONSTANT 7\nH8       DC    H'8'                    CONSTANT 8\nH10      DC    H'10'                   CONSTANT 10\nH11      DC    H'11'                   CONSTANT 11\nH13      DC    H'13'                   CONSTANT 13\nH14      DC    H'14'                   CONSTANT 14\nH100     DC    H'100'                  CONSTANT 100\nH1000    DC    H'1000'                 CONSTANT 1000\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nP256     DC    P'256'                  CONSTANT 256\nP4096    DC    P'4096'                 CONSTANT 4096\nBLANX    DC    CL121' '                CONSTANT BLANKS\nUNAME    DC    CL8'A'                  USER NAME AREA\nXZROS    DC    8X'00'                  CONSTANT ZEROS\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nPRTABL   DS    CL9                     PRINTABLE HEX WORK\nCHARTRAN DC    256X'FF'                TRT TABLE FOR CHAR/HEX DETERMINA\n         ORG   CHARTRAN+C' '\n         DC    X'00'                   BLANK IS CHARACTER\n         ORG   CHARTRAN+C'A'\n         DC    9X'00'                  A-I ARE CHARACTERS\n         ORG   CHARTRAN+C'J'\n         DC    9X'00'                  J-R ARE CHARACTERS\n         ORG   CHARTRAN+C'S'\n         DC    8X'00'                  S-Z ARE CHARACTERS\n         ORG   CHARTRAN+C'0'\n         DC    10X'00'                 0-9 ARE CHARACTERS\n         ORG\nTRHEX    DC    256X'FF'                HEX TRANSLATION TABLE\n         ORG   TRHEX+C'A'\n         DC    X'0A0B0C0D0E0F'\n         ORG   TRHEX+C'0'\n         DC    X'00010203040506070809'\n         ORG\nTRTHEX   DS    0X                      VERIFY HEX TABLE\n         DC    XL16'00'\n         DC    XL240'FF'\n         ORG\n         LTORG\n*\n         COPY  DISASM3A                COPY INSTRUCTION TABLES\n         COPY  DISASM3B                COPY SVC TABLE\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM2": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x08\\xfd\\x08\\xfd\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 2301, "newlines": 2301, "modlines": 0, "user": "FIELD"}, "text": "DIS2     TITLE '*** DISASSEMBLY PHASE 2 ***'\n         MACRO\n&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=\n         GBLC  &EQU\n         GBLC  &GM\n         GBLC  &CSECT\n         LCLC  &REGA\n         AIF   (T'&NAME EQ 'O').NOCSECT\n         AIF   ('&NAME' EQ '*').NOCSECT\n&CSECT   SETC  '&NAME'\n&CSECT   CSECT                         NAME OF PROGRAM\n         AGO   .RST\n.NOCSECT ANOP\n&CSECT   SETC  '*'\n         CSECT                         BEGINNING OF PROGRAM\n.RST     ANOP\n         AIF   ('&EQU' EQ 'ON').NRQ\n&EQU     SETC  'ON'\n*\n***REGISTER EQUATES***\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n.NRQ     ANOP\n*\n*******************  PROGRAM INITIALIZATION  *************************\n*\n         AIF   (T'&REG1 EQ 'O').NOREG\n&REGA    SETC  '&REG1'\n         AIF   (T'&REG2 EQ 'O').ONEREG\n         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY\n         AGO   .BYUSE\n.NOREG   ANOP\n&REGA    SETC  'R3'\n.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY\n.BYUSE   ANOP\n         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA\n         LR    &REGA,R15                  INITIALIZE BASE REG\n         AIF   (T'&REG2 EQ 'O').NOLA\n         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND\n         LA    &REG2,1(&REG2)                BASE REGISTER\n.NOLA    ANOP\n         AIF   (T'&REG3 EQ 'O').NOLNK\n         L     &REG3,0(R1)                GET PARAMETER LIST ADDR\n.NOLNK   ANOP\n         AIF (T'&IND EQ 'O').GETIT\n         CNOP  0,4\n         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA\nSAVEAREA DS    18F                     REGISTER SAVE AREA\n         ST    R15,8(R13)\n         ST    R13,SAVEAREA+4\n         LR    R13,R15\n         AGO   .NOSAVE\n.GETIT   ANOP\n         AIF   (T'&LV EQ 'O').GMD\n&GM      SETC  '&LV'\n         AGO   .DGM\n.GMD     ANOP\n&GM      SETC  '72'\n.DGM     ANOP\n*\n***GET MAIN STORAGE FOR SAVE AREA***\n*\n         AIF   ('&GM' LT '4096').LA\n         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA\n         AGO   .EGM\n.LA      ANOP\n         LA    R0,&GM                  GET &GM BYTES\n         GETMAIN R,LV=(0)\n.EGM     ANOP\n*\n***SET UP SAVE AREA POINTERS***\n*\n         ST    R1,8(R13)               STORE LOW SAVE POINTER\n         ST    R13,4(R1)               STORE HIGH SAVE POINTER\n         LR    R13,R1                  INITIALIZE SAVE POINTER\n         AIF   (T'&REG3  NE 'O').NOSAVE\n         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG\n         L     R1,24(R1)               RESTORE PARAMETER REGISTER\n.NOSAVE  ANOP\n         AIF   ('&CSECT' EQ '*').EXIT\n         B     *+12\n         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.\n.EXIT    ANOP\n*\n*********************  END INITIALIZATION  ***************************\n*\n         MEND\n         EJECT\nDISASM2  SVLNK R3,R4\n         PRINT NOGEN\n* THIS SUB-PROGRAM IS CALLED BY DISASM AFTER THE DIRECTORY\n* ENTRY AND LOAD MODULE ARE PROCESSED. THE ESD AND RLD\n* ENTRIES HAVE BEEN USED TO CREATE A PROGRAM LABEL TABLE,\n* AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER\n* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.\n*\n* TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,\n* AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN\n* TO THE WORK1 DATASET FOR FURTHER PROCESSING BY OTHER\n* MODULES.\n*   A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF\n* IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,\n* AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES\n* NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE\n* PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT\n* TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED\n* THEIR INCLUSION AT EXEC TIME.\n*\n*\n*\n*\n* AUTHOR R THORNTON - NOV 1977\n* UPDATED ROBERT STYMA - JAN 1989 AND MARCH 1991\n* UPDATED ALAN C FIELD - APR 1990\n*\n*\n******************************************************************\n*                                                                *\n* CHECK IF USER WISHES FLOATING POINT AND PRIVILEGED INSTRUCTIONS*\n* IF NOT, CLEAR THE APPROPRIATE ENTRIES IN THE INSTRUCTION OP    *\n* CODE TABLES.                                                   *\n*                                                                *\n******************************************************************\n*\n         L     R5,0(R1)                GET PARM FIELD ADDRESS\n         USING COMMPARM,R5\n         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.\n         BE    TSTPRIV                 YES\n         LA    R12,SGLOP               POINT TO OP-CODE TBL\nTSTOPND  CLI   0(R12),X'FF'            END OF TBL\n         BE    TSTPRIV                 YES\n         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT\n         BZ    FLPSTP                  NO\n         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY\nFLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TSTOPND                 LOOP THRU TABLE\nTSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    MAINLINE                YES\n         LA    R12,SGLOP               POINT TO OP-CODE TBL\nTTOPND   CLI   0(R12),X'FF'            END OF TABLE\n         BE    CKDBLS                  YES\n         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR\n         BZ    PRIVSTP                 NO\n         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY\nPRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY\n         B     TTOPND                  LOOP THRU TABLE\nCKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL\nCKDBND   CLI   0(R12),X'FF'            END OF TBL\n         BE    MAINLINE                YES\n         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE\n         BZ    DBSTP                   NO\n         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY\nDBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY\n         B     CKDBND                  LOOP THRU TABLE\n*\n*\n*\n******************************************************************\n*                                                                *\n* MAINLINE ROUTINE FOR DISASSEMBLY. EACH BYTE OF TEXT IS CHECKED *\n* TO DETERMINE WHETHER IT MAY BE AN INSTRUCTION OP-CODE. IF NOT, *\n* THE CONST ROUTINE IS PERFORMED TO HANDLE CONSTANT DATA. IF IT  *\n* APPEARS TO BE AN OP-CODE, THE INSTR ROUTINE IS PERFORMED.      *\n* WHEN TEXT IS EXHAUSTED, THIS PHASE TERMINATES.                 *\n*                                                                *\n******************************************************************\n*\nMAINLINE EQU   *                       MAINLINE ROUTINE\n         L     R6,LBLTBL               @ LABEL TABLE\n         USING LABELD,R6\n         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR\nGETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE\n         C     R7,TXTEND               END OF TEXT\n         BNL   EOJ                     YES          FIX******\n         LR    R12,R7                  COPY TEXT ADDR\n         S     R12,TXTSTRT             COMPUTE OFFSET\n         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE\n         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE BASES\n         BH    CKDARNG                 NO\n         BAL   R9,NEXUSG               YES, GO DO IT\nCKDARNG  L     R12,DATONLY             GET DATA ONLY TBL ADDR\n         CLC   TXTOFSET,0(R12)         RANGE BEGINS LATER\n         BL    CKLOSEQ                 YES\n         CLC   TXTOFSET,3(R12)         THIS BYTE IN THE RANGE\n         BNH   CONST                   YES\n         LA    R12,6(R12)              PAST THIS ENTRY, STEP OVER 1\n         ST    R12,DATONLY             SAVE UPDATED ADDR\n         B     CKDARNG                 GO CHECK AGAIN\nCKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ\n         BNH   GCKODD                  NO, CONTINUE\n         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT\n         MVC   NAME,LBLNAME            NAME TO OUTPUT\n         MVC   MNEMONIC,=CL5'EQU'      MNEMONIC\n         MVI   OPNDS,C'*'              OPERAND\n         MVC   COMMENT(14),=14C'?'     SHOW ERROR\n         BAL   R9,WRTOUT               WRITE ERROR RECORD\n         BAL   R9,PRINT                GO PRINT IT\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL\n         B     CKLOSEQ                 CONTINUE SEQ CHK\nGCKODD   TM    TXTCURR+3,1             ODD ADDRESS\n         BO    CONST                   YES, NOT INSTR\n         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES\n         BE    CONST                   YES, NOT INSTR\n         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE\n         BNZ   CKINSTR                 NOT CHARACTER\n         CLI   CONPROG,1               IS CONSTANT IN PROGRESS\n         BNE   CK6                     NO\n         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE\n         BE    CONST                   YES, ADD THIS TO CONSTANT\nCK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS\n         BZ    CONST                   YES, NOT INSTRUCTION\nCKINSTR  SR    R8,R8                   CLEAR WORK\n         IC    R8,0(R7)                PICK UP TXT BYTE\n         MH    R8,SGOPLEN              TIMES TABLE LENGTH\n         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY\n         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY\n         CLI   INAME,0                 IS IT AN INSTR OP-CODE\n         BE    CONST                   NO\n         CLI   ITYPE,TWO               TWO-BYTE OP-CODE\n         BNE   INSTR                   NO\n         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR\nDBLND    CLI   0(R8),X'FF'             END OF TABLE\n         BE    CONST                   YES, NOT INSTR\n         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT\n         BE    GOTDBLI                 YES\n         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY\n         B     DBLND                   LOOP THRU TBL\nGOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES\n         MVC   INSTENT,0(R8)           SAVE INSTR TBL ENTRY\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED WHEN CURSORY CHECKS IN THE MAINLINE    *\n* INDICATE THIS TEXT BYTE IS AN INSTRUCTION OP-CODE. FURTHER     *\n* TESTING IS DONE BY THE IVERFY (NON-FLOATING POINT), OR FPVERFY *\n* (FLOATING POINT) ROUTINES. BYTES PASSING THESE TESTS ARE       *\n* ACCEPTED AS OP-CODES, AND ARE PASSED TO THE APPROPRIATE FORMAT *\n* ROUTINES. FORMAT ROUTINES ARE ENTERED VIA A BRANCH TABLE USING *\n* A BYTE IN THE INSTRUCTION OP-CODE TABLE ENTRY.                 *\n*                                                                *\n******************************************************************\n*\nINSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***\n         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH\n         LH    R12,ILENG               PICK UP LENGTH\n         AR    R12,R7                  ADDR OF NEXT OP CODE\n         SR    R15,R15                 CLEAR WORK\n         IC    R15,0(R12)              PICK UP NEXT OP-CODE\n         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG\n         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR\n         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE\n         BNE   ICKSEC                  YES\n         CLI   0(R7),X'45'             IS IT BAL\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R7),X'0B'             IS IT BSM\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R7),X'4D'             IS IT BAS\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R7),7                 NO, IS IT BCR\n         BE    POSSB                   YES\n         CLI   0(R7),X'47'             IS IT BC\n         BNE   CONST                   NO, THEN THIS NOT INSTR\nPOSSB    TM    1(R7),X'F0'             IS IT UNCONDL BRCH\n         BNO   CONST                   NO, THEN THIS NOT INSTR\n         B     ICKTBL                  ACCEPT UNCOND BRCHS\nICKSEC   SR    R1,R1                   CLEAR WORK\n         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH\n         AR    R1,R12                  ADDR OF NEXT OP CODE\n         SR    R14,R14                 CLEAR WORK\n         IC    R14,0(R1)               PICK UP NEXT OP-CODE\n         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG\n         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR\n         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE\n         BNE   ICKTBL                  YES\n         CLI   0(R12),X'45'            IS IT BAL\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'0B'            IS IT BSM\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'4D'            IS IT BAS\n         BE    ICKTBL                  YES, CONTINUE\n         CLI   0(R12),X'07'            NO, IS IT BCR\n         BE    POSSB2                  YES\n         CLI   0(R12),X'47'            IS IT BC\n         BNE   CONST                   NO, THEN THIS NOT INSTR\nPOSSB2   TM    1(R12),X'F0'            IS IT UNCONDL BRCH\n         BNO   CONST                   NO, THEN THIS NOT INSTR\nICKTBL   LH    R12,ILENG               GET INSTR LENGTH\n         AR    R12,R7                  @ NEXT TEXT LOC\n         BCTR  R12,R0                  BACK UP 1\n         S     R12,TXTSTRT             RELATIVIZE IN CSECT\n         CLM   R12,7,LBLADR            LBL TBL ADDR HERE\n         BL    NOILBL                  NO\n         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START\n         BNE   NOTINST                 NO, MUST BE CONSTANT      FIX***\n         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   NOTINST                 NO                        FIX***\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CKLBLNG                 NO\n         BAL   R9,FORCONST             YES, FORCE IT OUT\nCKLBLNG  CLC   LBLLEN,INLNG            LENGTHS SAME\n         BE    SETLBL                  YES\n         CLI   LBLLEN,0                DON'T CARE LENGTH\n         BE    SETLBL                  YES\n         BAL   R9,EQUSTMT              NO, BUILD EQU STATEMENT\n         B     ISTPLBL                 CONTINUE\nSETLBL   MVC   NAME,LBLNAME            LABEL ENTRY NAME TO INSTR\n         MVC   CONLEN,LBLLEN           SET CONSTANT LENGTH IN CASE\nISTPLBL  DS    0H\n         LR    R9,R6                   GET TEMP COPY OF LABEL TAB ENT\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY\n         CLC   LBLADR(3),LBLADR-LABEL(R9)  THIS ENTRY SAME ADDR?\n         BNE   ICKTBL                  NO\n         LR    R6,R9                   BACK UP TO PREV ENTRY\n         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT\n         LA    R6,L'LABEL(R6)          TO NEXT ENTRY\n         B     ICKTBL                  GO CHECK NEXT LABEL\nNOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   MVMNE                   NO\n         BAL   R9,FORCONST             YES, FORCE IT OUT\nMVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC\n         MVC   OFFSET,TXTOFSET         SET OFFSET\n         MVC   INSTYP,5(R8)            SET INSTR TYPE\n         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION\n         MVC   LEN,ILENG+1             SHOW LENGTH\n         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT\nOPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE\n         BO    FPVERFY                 YES, GO VERIFY\n         CLI   IEDT,0                  ANY EDIT REQUIRED\n         BE    PFMFMT                  NO\n         B     IVERFY                  YES, GO EDIT\nPFMFMT   SR    R1,R1                   CLEAR WORK\n         IC    R1,INSTYP               GET INSTRUCTION TYPE\n         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR\n         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN\n         B     RROPND                  TYPE=0, RR\n         B     RXOPND                  TYPE=4, RX\n         B     SOPND                   TYPE=8, S\n         B     SIOPND                  TYPE=C, SI\n         B     RSOPND                  TYPE=10, RS\n         B     SS1OPND                 TYPE=14, 1-LENGTH SS\n         B     SS2OPND                 TYPE=18, 2-LENGTH SS\n         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES\n         B     BCOPND                  TYPE=20, CONDITIONAL BRANCH\n         B     SVCOPND                 TYPE=24, SVC\n         B     SSEOPND                 TYPE=28, SSE\n         B     EOPND                   TYPE=2C, E\n         B     RROPND                  TYPE=30, RRE 1 OPERAND\n         B     RROPND                  TYPE=34, RRE 2 OPERANDS\nOPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN\n         MVC   CONNAME,NAME            ANY NAME TO CONSTANT AREA\n         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS\nNOTINST  CLC   NAME,BLANX              IS NAME FILLED IN?        FIX***\n         BE    CONST                                             FIX***\n         SH    R6,LBLLGTH              BACK UP                   FIX***\n         B     CONST                                             FIX***\nINSTOUT  BAL   R9,WRTOUT               WRITE INSTRUCTION RECORD\n         BAL   R9,TXTFMT               FORMAT HEX DATA\n         BAL   R9,PRINT                GO PRINT IT\n         AH    R7,ILENG                STEP TO NEXT TEXT BYTE\n         ST    R7,TXTCURR              SAVE NEXT ADDR\n         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE\n         B     GETCURR                 CONTINUE TXT PROCESSING\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR NON FLOATING*\n* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *\n* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *\n* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *\n*                                                                *\n******************************************************************\n*\nIVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION\n         TM    IEDT,EPR                EVEN-ODD REG PAIR\n         BZ    IVE2                    NO\n         TM    1(R7),X'10'             R1 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'0E'             IS IT MVCL\n         BE    IVTRG2                  YES\n         CLI   0(R7),X'0F'             IS IT CLCL\n         BNE   IVE2                    NO\nIVTRG2   TM    1(R7),X'01'             R2 IS ODD\n         BO    CONST                   YES, NOT INSTR\n         SR    R1,R1                   CLEAR WORK\n         SR    R2,R2                   CLEAR WORK\n         IC    R1,1(R7)                GET R1R2\n         SRL   R1,4                    SHIFT OUT R2\n         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE\n         IC    R2,DBLWD                PICK UP R2R1\n         SRL   R2,4                    SHIFT OUT R1\n         CR    R1,R2                   R1=R2\n         BE    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT\n         BZ    IVE4                    NO\n         TM    3(R7),X'01'             DISPL IS ODD\n         BZ    IVES2                   NO, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   0(R7),X'44'             EX OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'47'             BC OP CODE\n         BE    CONST                   YES, NOT INSTR\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG IS 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   CONTINUE\nIVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND\n         BZ    IVE8                    NO\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO, CONTINUE\n         CLI   ITYPE,RS                RS INSTRUCTION OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     IVES2                   NO, CONTINUE\nIVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND\n         BZ    IVES2                   NO\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    IVES2                   YES, O.K.\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   IVES2                   NO\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\nIVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.\n         BE    PFMFMT                  YES\n         TM    IEDT,S2                 OPND2 MUST HAVE BASE\n         BZ    IVES1                   NO\n         TM    2(R7),X'F0'             BASE REG = 0\n         BNZ   PFMFMT                  NO, O.K.\n         CLI   ITYPE,RS                RS INSTRUCTION\n         BE    CONST                   YES, NOT INSTR\n         CLI   0(R7),X'92'             IS IT MVI OP CODE\n         BE    CONST                   YES, NOT INSTR\n         TM    1(R7),X'0F'             INDEX REG = 0\n         BZ    CONST                   YES, NOT INSTR\n         B     PFMFMT                  NO, GOOD INSTR\nIVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE\n         BZ    PFMFMT                  NO, CONTINUE\n         TM    2(R7),X'F0'             1ST OPND HAS BASE\n         BZ    CONST                   NO, NOT INSTR\n         B     PFMFMT                  YES, INSTR O.K.\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR FLOATING    *\n* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *\n* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *\n* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *\n*                                                                *\n******************************************************************\n*\nFPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C\n         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'27'             MXDR OP-CODE\n         BE    FPR1EXT                 YES\n         CLI   0(R7),X'67'             MXD OP-CODE\n         BNE   FPCKTYP                 NO\nFPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4\n         BNZ   CONST                   NO, NOT INSTR\nFPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION\n         BNE   FPRXVER                 NO\n         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6\n         BNZ   CONST                   NO, NOT INSTR\n         CLI   0(R7),X'25'             LRDR OP CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'37'             SXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'26'             MXR OP-CODE\n         BE    FPR2EXT                 YES\n         CLI   0(R7),X'36'             AXR OP-CODE\n         BNE   PFMFMT                  NO, GOOD INSTR\nFPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4\n         BZ    PFMFMT                  YES, GOOD INSTR\n         B     CONST                   NO, NOT INSTR\nFPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.\n         BE    FPALIGN                 YES\n         TM    2(R7),X'F0'             ANT BASE REG\n         BNZ   FPALIGN                 YES\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BZ    CONST                   NO, NOT INSTR\nFPALIGN  TM    2(R7),X'F0'             ANY BASE REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    1(R7),X'0F'             ANY INDEX REG\n         BNZ   PFMFMT                  YES, ACCEPT INSTR\n         TM    3(R7),X'03'             DISPL DIV BY 4\n         BNZ   CONST                   NO, NOT INSTR\n         TM    ICLASS,FLSHT            SHORT PRECISION\n         BO    PFMFMT                  YES, ACCEPT INSTRUCTION\n         TM    3(R7),X'07'             DISPL DIV BY 8\n         BZ    PFMFMT                  YES, ACCEPT INSTR\n         B     CONST                   NO, NOT INSTR\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED FROM VARIOUS OTHER ROUTINES WHEN THE   *\n* CURRENT TEXT BYTE IS DETERMINED NOT TO BE AN INSTRUCTION OP    *\n* CODE. A CONSTANT AREA IS BUILT TO CONTAIN THE CONSTANT, IT'S   *\n* DATA TYPE, SYMBOL TO BE USED FOR ADCONS, LABEL TO BE USED, IF  *\n* ANY, ETC. THE CONSTANT IS BUILT BYTE BY BYTE, AND IS TERMINATED*\n* FOR OUTPUT BY THE FORCONST ROUTINE. THIS ROUTINE DETECTS END OF*\n* CONSTANT WHEN THE CONSTANT IN PROGRESS EXCEEDS 2 BYTES FOR A   *\n* HALFWORD, 4 BYTES FOR A FULLWORD, OR 8 BYTES AS A MAXIMUM. IT  *\n* IS ALSO TERMINATED WHEN A CHANGE IN DATA TYPE OCCURS.          *\n*                                                                *\n******************************************************************\n*\nCONST    EQU   *                       *** PROCESS CONSTANTS ***\n         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA\n         CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   CCNEW                   NO\n         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET\n         BNE   CGETYP                  NO\nCSTNEW   BAL   R9,FORCONST             FORCE IT OUT\n         B     CCNEW                   GO START A NEW ONE\nCGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE\n         BNZ   CHEX                    IT'S HEX\n         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE\n         B     CCKTYP                  GO COMPARE\nCHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE\nCCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE\n         BNE   CSTNEW                  NO\nCUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH\n         LA    R11,1(R11)              ADD 1\n         STH   R11,CONLEN              UPDATE LENGTH\n         L     R11,CONLOC              GET CURRENT LOC IN CONST DATA\n         MVC   0(1,R11),0(R7)          MOVE BYTE TO DATA\n         LA    R11,1(R11)              STEP OVER ONE BYTE\n         ST    R11,CONLOC              SAVE UPDATED DATA ADDR\n         CLI   CONTYPE,C'C'            CHARACTER CONSTANT\n         BE    CCK8                    YES\n         TM    CONOFST+3,1             OFFSET IS ODD\n         BO    CCFIN1                  YES\n         TM    CONOFST+3,2             HALFWORD OFFSET\n         BZ    CCFWD                   NO\n         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1\n         BE    CCXIT1                  YES\n         B     CCFIN1                  NO\nCCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES\n         BL    CCXIT1                  NOT YET\nCCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT\n         B     CCXIT1                  FINISH\nCCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES\n         BNL   CCFIN1                  YES\nCCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDR\n         B     GETCURR                 CONTINUE TEXT PROCESSING\nCCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS\n         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE\n         MVC   CONNAME,BLANX           CLEAR NAME\n         XC    CONDATA,CONDATA         CLEAR DATA AREA\n         MVC   CONSYM,BLANX            CLEAR SYMBOL NAME\n         MVC   CONLEN,XZROS            CLEAR LENGTH\n         LA    R11,CONDATA             GET 1ST DATA BYTE ADDR\n         ST    R11,CONLOC              SET STARTING ADDRESS OF DATA\n         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET\n         BE    CLBLD                   YES\nTRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE\n         BNZ   CCSHX                   IT'S HEX\n         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE\n         B     CUPDCON                 GO COMPLETE\nCLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY\n         BNE   CDATACON                NO\n         MVC   CONNAME,LBLNAME         NAME TO CONSTANT WORK AREA\n         MVC   CONLLEN,LBLLEN         SAVE LENGTH\n         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY\n         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR\n         BNE   TRTYPE                  NO\n         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY\n         BNE   CDATACON                NO\n         SH    R6,LBLLGTH             BACK UP TO LABEL ENTRY\n         BAL   R9,EQUSTMT             GO BUILD EQU STATEMENT\n         LA    R6,L'LABEL(R6)          TO NEXT LABELENTRY\n         B     CCNEW                   GO TO NEXT LABEL\nCDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH\n         STH   R1,CONLEN               SAVE CONSTANT LENGTH\n         BCTR  R1,R0                   COMPUTE CONSTANT LENGTH CODE\n         STC   R1,MCD+1                SET MOVE LENGTH CODE\nMCD      MVC   CONDATA,0(R7)           MOVE DATA TO RECORD\n         MVC   CONSYM,LBLNAME          SYMBOL TO CONSTANT AREA\n         SR    R11,R11                 CLEAR WORK REG\n         IC    R11,LBLLEN              PICK UP LENGTH\n         AR    R7,R11                  STEP PAST TEXT\n         ST    R7,TXTCURR              UPDATE TEXT ADDRESS\n         BAL   R9,FORCONST             FORCE CONSTANT OUT\n         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY\n         B     GETCURR                 CONTINUE TEXT PROCESS\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS ENTERED BY VARIOUS ROUTINES WHEN IT IS         *\n* NECESSARY TO WRITE THE CONSTANT CURRENTLY IN PROGRESS, AND     *\n* CLEAR FIELDS FOR THE NEXT CONSTANT TO BE CREATED.              *\n*                                                                *\n******************************************************************\n*\nFORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE\n         ST    R9,FC9                  SAVE RETURN ADDR\n         CLC   CONNAME,BLANX           ANY LABEL NAME SET UP\n         BE    CKCNPRG                 NO, CONTINUE\n         CLC   CONLLEN,CONLEN+1        LENGTHS SAME\n         BE    CKCNPRG                 YES, CONTINUE\n         ST    R6,FC6                  SAVE LABEL TABLE ADDR\n         LA    R6,CONPSLBL             @ PSEUDO LABEL ENTRY\n         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT\n         MVC   CONNAME,BLANX           CLEAR STATEMENT LABEL FIELD\n         L     R6,FC6                  RESTORE LABEL TABLE POINTER\nCKCNPRG  CLI   CONPROG,1               CONSTANT IN PROGRESS\n         BNE   FCCLR                   NO\n         CLI   CONLEN+1,0              ANY DATA LENGTH\n         BE    FCCLR                   NO\n         XC    TEXT,TEXT               CLEAR TEXT FIELD\n*****************************************************************\n         CLI   CONTYPE,C'W'            IS THIS A WEAK EXTERN?\n         BNE   NOTWEXT                 IF NOT, LEAVE IT ALONE\n         MVC   MNEMONIC(5),=C'WXTRN'   BUILD AN ENTRY STATEMENT\n         MVC   OPNDS(8),CONSYM         FOR THE WEAK EXTERNAL REF\n         BAL   R9,WRTOUT               PUT WEXTRN RECORD OUT\n         BAL   R9,PRINT                TO THE PRINT FILE ALSO.\n         MVI   CONTYPE,C'A'            CHANGE TO AN A CONSTANT\nNOTWEXT  DS    0H\n*****************************************************************\n         MVC   MNEMONIC(2),=C'DC'      SET MNEMONIC\n         MVC   OPNDS(1),CONTYPE        SET TYPE\n         MVI   OPNDS+1,C''''           OPERAND DELIMITER\n         MVC   NAME,CONNAME            NAME TO RECORD\n         MVC   OFFSET,CONOFST+1        OFFSET TO RECORD\n         MVI   INSTYP,0                NOT AN INSTRUCTION\n         MVI   TYPE,2                  NON-ADDRESS CONSTANT\n         MVC   LEN,CONLEN+1            DATA LENGTH\n         LH    R11,CONLEN              DATA LENGTH\n         BCTR  R11,R0                  DATA LENGTH CODE\n         STC   R11,FMCON+1             MOVE LENGTH TO MVC\nFMCON    MVC   TEXT,CONDATA            DATA TO RECORD\n         CLI   CONTYPE,C'C'            CHARACTER TYPE\n         BE    FCHAR                   YES\n         CLI   CONTYPE,C'X'            HEX TYPE\n         BNE   FSYMBOL                 NO\n         TM    CONOFST+3,1             OFFSET TO CONSTANT IS ODD\n         BO    FHEX                    YES\n         TM    CONLEN+1,1              LENGTH IS ODD\n         BO    FHEX                    YES\n         TM    CONOFST+3,2             OFFSET DIVISIBLE BY 4\n         BO    FHWD                    NO\n         CLI   CONLEN+1,4              IS IT 4-BYTES\n         BNE   FHWD                    NO, JUST HALFWORD\n         CLC   CONDATA(4),XZROS        CONSTANT IS ALL ZEROS\n         BNE   FFCKNEG                 NO\n         MVC   OPNDS(4),=C'F''0'''     BUILD OPERANDS\n         B     FCWRT                   CONTINUE\nFFCKNEG  ICM   R11,15,CONDATA          GET DATA\n         BM    FHEX                    NEG, TREAT AS HEX\n         C     R11,=F'99999'           VALUE EXCEEDS 99,999\n         BH    FHEX                    YES, TREAT AS HEX\n         MVC   OPNDS(2),=C'F'''        OPERAND DATA TYPE IS F\n         CVD   R11,DBLWD               CONVERT VALUE TO PACKED\n         UNPK  OPNDS+2(5),DBLWD+5(3)   UNPACK INTO OPERAND\n         OI    OPNDS+6,C'0'            SET SIGN = F\n         MVI   OPNDS+7,C''''           ENDING QUOTE\n         B     FCWRT                   CONTINUE\nFHWD     LH    R11,CONDATA             PICK UP HALFWORD\n         LTR   R11,R11                 TEST CONSTANT VALUE\n         BM    FHEX                    NEGATIVE, TREAT AS HEX\n         BNZ   FHCMAX                  NOT ZERO, CHECK MAX VALUE\n         MVC   OPNDS(4),=C'H''0'''     SET OPERAND FOR ZERO\n         B     FCWRT                   CONTINUE\nFHCMAX   CH    R11,=H'9999'            VALUE EXCEEDS 9,999\n         BH    FHEX                    YES, TREAT AS HEX\n         CVD   R11,DBLWD               CONVERT TO PACKED\n         OI    DBLWD+7,X'0F'           CLEAR SIGN TO F\n         MVC   OPNDS(2),=C'H'''        SET DELIMITER IN OPERAND\n         UNPK  OPNDS+2(4),DBLWD+5(3)   UNPACK VALUE TO OPERAND\n         MVI   OPNDS+6,C''''           ENDING DELIMITER\n         B     FCWRT                   CONTINUE\nFCHAR    MVC   OPNDS(2),=C'C'''        OPERAND DELIMITER FOR CHARACTER\n         LH    R11,CONLEN              GET DATA LENGTH\n         BCTR  R11,R0                  LENGTH CODE\n         STC   R11,FMCNT+1             SET MOVE LENGTH\nFMCNT    MVC   OPNDS+2,CONDATA         DATA TO OPERAND\n         LA    R11,OPNDS+3(R11)        STEP PAST OPERAND DATA\n         MVI   0(R11),C''''            ENDING QUOTE\n         B     FCWRT                   CONTINUE\nFSYMBOL  CLC   CONSYM,BLANX            IS IT BLANK\n         BE    FHEX                    YES, TREAT AS HEX\n         CLI   CONLEN+1,4              LENGTH IS 4\n         BH    FHEX                    NO, GREATER\n         BE    AC4                     YES, 4 BYTES\n         CLI   CONLEN+1,3              LENGTH IS 3\n         BE    AC3                     YES\n         CLI   CONLEN+1,2              LENGTH IS 2\n         BE    AC2                     YES\n         MVC   OPNDS+1(2),=C'L1'       OPND LENGTH\n         B     FSLHE1                  CONTINUE\nAC2      MVC   OPNDS+1(2),=C'L2'       OPND LGTH\n         B     FSLHE1                  CONTINUE\nAC3      MVC   OPNDS+1(2),=C'L3'       OPND LENGTH\n         B     FSLHE1                  CONTINUE\nAC4      LA    R11,OPNDS+1             STEP TO ( POS\n         B     FSLHE                   CONTINUE\nFSLHE1   LA    R11,OPNDS+3             STEP TO ( POS\nFSLHE    MVI   0(R11),C'('             DELIMITER\n         MVC   1(8,R11),CONSYM         SYMBOL TO RECORD\n         LA    R11,9(R11)              @ RHE SYMBOL IN OPERAND\nFRHE     CLI   0(R11),C' '             CHARACTER IS BLANK\n         BNE   SETRPAR                 NO\n         BCT   R11,FRHE                LOOP TO FIND RHE\nSETRPAR  MVI   1(R11),C')'             SET CLOSING PAREN\n         B     FCWRT                   CONTINUE\nFHEX     MVC   OPNDS(2),=C'X'''        TYPE AND BEGIN QUOTE\n         LA    R12,CONDATA             @ CONSTANT DATA\n         BAL   R9,HEXPRT4              CONVERT TO PRINTABLE\n         LH    R12,CONLEN              GET DATA LENGTH\n         SLL   R12,1                   DOUBLE IT\n         BCTR  R12,R0                  -1 = LENGTH CODE\n         STC   R12,MVHX+1              SET MOVE LENGTH\nMVHX     MVC   OPNDS+2(1),PRTABL       HEX CHARS TO OPERAND\n         LA    R12,OPNDS+2(R12)        OPERAND END ADDRESS\n         MVI   1(R12),C''''            ENDING QUOTE\n         B     FCWRT                   CONTINUE\nFCWRT    BAL   R9,WRTOUT               WRITE RECORD\n         BAL   R9,TXTFMT               GO FORMAT HEX DATA\n         BAL   R9,PRINT                GO PRINT IT\nFCCLR    MVI   CONPROG,0               RESET CONSTANT IN PROGRESS\n         MVC   CONNAME,BLANX           CLEAR NAME\n         MVI   CONTYPE,0               RESET TYPE\n         XC    CONDATA,CONDATA         CLEAR CONSTANT DATA\n         MVC   CONSYM,BLANX            CLEAR SYMBOL\n         XC    CONLEN,CONLEN           CLEAR LENGTH\n         MVC   CONLOC,XZROS            CLEAR LOCATION\n         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT\n         L     R9,FC9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE FORMATS RR-FORMAT INSTRUCTIONS FOR OUTPUT.        *\n*                                                                *\n******************************************************************\n*\nRROPND   EQU   *                       *** RR FORMAT INSTRUCTIONS ***\n         CLI   0(R7),X'05'             IS IT BALR\n         BNE   RRSTRT\n         CLI   1(R7),X'EF'             IS IT BALR 14,15\n         BE    RRSTDL                  YES\n         TM    1(R7),X'0F'             NO, IS R2 = 0\n         BNZ   RRNSTD                  NO\n         MVC   COMMENT(11),=C'ADDRESS SET'\n         B     RRSTRT                  CONTINUE\nRRSTDL   MVC   COMMENT(11),=C'STD LINKAGE'\n         B     RRSTRT                  CONTINUE\nRRNSTD   MVC   COMMENT(14),=C'NONSTD LINKAGE'\nRRSTRT   EQU   *\n         LA    R15,TEXT+1              POINT TO TEXT\n         LR    R11,R1                  COPY INSTRUCTION TYPE\n         CH    R11,=H'48'              RRE TYPE?\n         BL    *+8                     NO, JUST RR\n         LA    R15,2(R15)              ADJ FO 2 BYTE OPCODE\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,0(R15)               GET 2ND BYTE\n         SRL   R1,4                    SHIFT OUT R2\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGIN R1 OPERAND\n         CH    R1,H10                  REG NBR > 9\n         BL    RR11                    NO, 0-9\n         MVC   OPNDS+1(2),DBLWD        YES, 10-15\n         LA    R1,OPNDS+3              TO NEXT POS\n         B     RRCMA                   CONTINUE\nRR11     MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR\n         LA    R1,OPNDS+2              TO NEXT POS\nRRCMA    EQU   *\n         CH    R11,=H'48'              RRE WITH ONE OPERAND?\n         BE    RRXIT                   YES\n         CLI   TEXT,X'04'              IS IT SPM\n         BNE   RRCMA1                  NO\n         TM    1(R7),X'0F'             YES, IS R2 FIELD = 0\n         BZ    RRXIT                   YES, GOOD INSTR\n         B     4(R9)                   ERROR RETURN (NOT INSTR)\nRRCMA1   MVC   0(2,R1),=C',R'          DELIMITERS\n         PACK  DBLWD(1),0(1,R15)       FLIP 2ND BYTE\n         SR    R15,R15                 CLEAR WORK\n         IC    R15,DBLWD               GET R2R1\n         SRL   R15,4                   SHIFT OUT R1\n         CVD   R15,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R15,H10                 R2 > 9\n         BL    RR21                    NO, 0-9\n         MVC   2(2,R1),DBLWD           YES, MOVE REG 10-15\n         BR    R9                      EXIT\nRR21     MVC   2(1,R1),DBLWD+1         MOVE REG 0-9\nRRXIT    BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RX-TYPE  *\n* INSTRUCTIONS. THE BDXADR ROUTINE IS CALLED TO FORMAT THE       *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n*\nRXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***\n         CLI   0(R7),X'45'             IS IT BAL OP CODE\n         BNE   RXSTRT                  NO\n         MVC   COMMENT(7),=C'PERFORM'\n         TM    1(R7),X'E0'             R1 = 0 OR 1\n         BNZ   RXSTRT                  NO\n         MVC   COMMENT(13),=C'PARM SET BRCH'\nRXSTRT   SR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               GET R1X2\n         SRL   R1,4                    SHIFT OUT X2\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND\n         CH    R1,H10                  R1 < 10\n         BL    RXR11                   YES, 0-9\n         MVC   OPNDS+1(2),DBLWD        NO, MOVE REG 10-15\n         LA    R15,OPNDS+3             TO NEXT POS\n         B     RXCMA                   CONTINUE\nRXR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9\n         LA    R15,OPNDS+2             TO NEXT POS\nRXCMA    MVI   0(R15),C','             DELIMITER\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP X2R1\n         SRL   R10,4                   SHIFT OUT R1\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD\n         BAL   R9,BDXADR               CONVERT RX ADDRESS\n         STC   R10,BDXMVC+1            SET MOVE LENGTH\nBDXMVC   MVC   1(1,R15),OPNDWK         MOVE RX OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT S-TYPE   *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n*\nSOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***\n         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO\n         BE    SCK2                    YES\n         CLI   0(R7),X'80'             NO, IS IT SSM\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'82'             NO, IS IT LPSW\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   0(R7),X'93'             NO, IS IT TS\n         BE    4(R9)                   YES, NOT INSTR\nSCK2     CLI   0(R7),X'B2'             OP-CODE IS B2\n         BNE   SSTRT                   NO\n         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO\n         BE    SSTRT                   YES\n         CLI   1(R7),X'0B'             IPK INSTRUCTION\n         BE    4(R9)                   YES, NOT INSTR\n         CLI   1(R7),X'0D'             PTLB INSTR\n         BE    4(R9)                   YES, NOT INSTR\nSSTRT    SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD\n         BAL   R9,BDADR                CONVERT BDDD ADDRESS\n         STC   R10,SOPMVC+1            SET MOVE LENGTH\nSOPMVC   MVC   OPNDS,OPNDWK            MOVE OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SI-TYPE  *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n*\nSIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         BAL   R9,BDADR                CONVERT ADDRESS\n         STC   R10,SIOMVC+1            SET MOVE LENGTH\nSIOMVC   MVC   OPNDS,OPNDWK            MOVE BDDD OPERAND\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         TRT   TEXT+1(1),CHARTRAN      TEST IF CHARACTER\n         BNZ   HEXIMM                  NO, HEX\n         CLI   TEXT,X'95'              IS IT CLI\n         BE    CHIMM                   YES\n         CLI   TEXT,X'92'              IS IT MVI\n         BNE   HEXIMM                  NO\nCHIMM    MVC   1(2,R15),=C'C'''        DELIMITER\n         MVC   3(1,R15),TEXT+1         CHARACTER TO OPERAND\n         MVI   4(R15),C''''            ENDING DELIMITER\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nHEXIMM   MVC   1(2,R15),=C'X'''        DELIMITER FOR HEX\n         LA    R12,TEXT+1              @ HEX BYTE\n         BAL   R9,HEXPRT1              CONVERT\n         MVC   3(2,R15),PRTABL         PRINTABLE HEX TO OPERAND\n         MVI   5(R15),C''''            FINAL QUOTE\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RS-TYPE  *\n* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *\n* STORAGE OPERAND.                                               *\n*                                                                *\n******************************************************************\n*\nRSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***\n         CLI   TEXT,X'90'              IS IT STM\n         BE    RSSTM                   YES\n         CLI   TEXT,X'98'              IS IT LM\n         BNE   RSCLR1                  NO\n         MVC   COMMENT(12),=C'RESTORE REGS'\n         B     RSCLR1                  CONTINUE\nRSSTM    MVC   COMMENT(9),=C'SAVE REGS'\nRSCLR1   SR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               PICK UP R1R3\n         SRL   R1,4                    SHIFT OUT R3\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         MVI   OPNDS,C'R'              BEGINNING OPERAND 1\n         CH    R1,H10                  REG NBR < 10\n         BL    RSR11                   YES\n         MVC   OPNDS+1(2),DBLWD        MOVE REG 10-15\n         LA    R15,OPNDS+3             TO NEXT POS\n         B     RSCMA                   CONTINUE\nRSR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9\n         LA    R15,OPNDS+2             TO NEXT POS\nRSCMA    CLI   0(R7),X'88'             IS IT SHIFT INSTR\n         BL    RSCMA1                  NO\n         CLI   0(R7),X'8F'             IS IT SHIFT INSTR\n         BH    RSCMA1                  NO\n         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0\n         BZ    RSBDD                   YES, GOOD SHIFT\n         B     4(R9)                   NO, NOT INSTR\nRSCMA1   MVC   0(2,R15),=C',R'         DELIMITERS\n         CLI   0(R7),X'BD'             CLM, STCM, OR ICM\n         BL    RSPK2                   NO\n         CLI   0(R7),X'BF'             CLM,STCM, OR ICM\n         BH    RSPK2                   NO\n         BCTR  R15,R0                  CLM, STCM, ICM HAVE MASK IN R3 P\nRSPK2    PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,DBLWD                GET R3R1\n         SRL   R1,4                    SHIFT OUT R1\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R1,H10                  REG NBR < 10\n         BL    RSR31                   YES, 0-9\n         MVC   2(2,R15),DBLWD          MOVE REG 10-15\n         LA    R15,4(R15)              TO NEXT POS\n         B     RSBDD                   CONTINUE\nRSR31    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9\n         LA    R15,3(R15)              TO NEXT POS\nRSBDD    MVI   0(R15),C','             DELIMITER\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDD ADDRESS\n         BAL   R9,BDADR                CONVERT BDDD ADDRESS\n         STC   R10,RSMVC+1             SET MOVE LENGTH\nRSMVC    MVC   1(1,R15),OPNDWK         MOVE BDDD ADDRESS\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *\n* INSTRUCTIONS OF THE SINGLE LENGTH VARIETY. THE BDLADR ROUTINE  *\n* IS CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.  *\n*                                                                *\n******************************************************************\n*\nSS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET LENGTH CODE\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         BAL   R9,BDLADR               CONVERT ADDRESS\n         STC   R10,SS1MV1+1            SET MOVE LENGTH\nSS1MV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS\n         BAL   R9,BDADR                CONVERT ADDRESS\n         STC   R10,SS1MV2+1            SET MOVE LENGTH\nSS1MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *\n* INSTRUCTIONS OF THE DOUBLE LENGTH VARIETY. THE BDLADR ROUTINE  *\n* IS CALLED TO FORMAT THE STORAGE OPERANDS.                      *\n*                                                                *\n******************************************************************\n*\nSS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET L1L2\n         SRL   R10,4                   SHIFT OUT L2\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         BAL   R9,BDLADR               CONVERT ADDRESS\n         STC   R10,SS2MV1+1            SET MOVE LENGTH\nSS2MV1   MVC   OPNDS,OPNDWK            MOVE 1ST OPERAND\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP L2L1\n         SRL   R10,4                   SHIFT OUT L1\n         CLI   TEXT,X'F0'              SRP OP-CODE\n         BE    SRPOP2                  YES\n         TM    IEDT,M1                 SPECIAL MOVE INST OP-CODE\n         BO    SRPOP2                  YES\n         BAL   R9,BDLADR               CONVERT ADDRESS\n         STC   R10,SS2MV2+1            SET MOVE LENGTH\nSS2MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND\nSS2XIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nSRPOP2   BAL   R9,BDADR                GO BUILD OPERAND 2\n         STC   R10,SRMV1+1             SET MOVE LENGTH\nSRMV1    MVC   1(1,R15),OPNDWK         MOVE OPERAND 2\n         LA    R15,2(R10,R15)          TO NEXT OPERAND POS  FIX***\n         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP I3/R3\n         SRL   R10,4                   SHIFT OUT L1\n         CVD   R10,DBLWD               CONVERT I3/R3\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         MVI   0(R15),C','             OPERAND SEPARATOR    FIX***\n         UNPK  1(1,R15),DBLWD+7(1)     UNPACK I3/R3 TO OPERAND FIX***\n         CH    R2,H10                  I3/R3 < 10\n         BL    SS2XIT                  YES\n         UNPK  1(2,R15),DBLWD+6(2)     NO, UNPACK MORE\n         B     SS2XIT                  CONTINUE\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT COND-    *\n* ITIONAL BRANCH INSTRUCTIONS. AN ATTEMPT IS MADE TO USE THE     *\n* EXTENDED MNEMONICS WHERE POSSIBLE. FOR RR-TYPE BRANCHES, ONLY  *\n* THE BR AND NOPR MNEMONICS ARE USED. FOR RX-TYPE BRANCHES, THE  *\n* FULL SET OF EXTENDED MNEMONICS IS USED. THE TYPES USED ARE     *\n* ARITHMETIC, COMPARE, AND 8=ZERO TYPES. THE SET TO BE USED IS   *\n* DETERMINED BY THE TYPE SAVED BY THE LAST CONDITION-CODE-SETTING*\n* INSTRUCTION GENERATED.                                         *\n*\n******************************************************************\n*\nBCOPND   EQU   *                       *** CONDITIONAL BRANCH INSTRUCTI\n         TM    TEXT+1,X'F0'            UNCONDITIONAL BRANCH\n         BZ    NOPS                    NO, NOP\n         BO    UNCNDS                  YES, UNCONDITIONAL\n         SR    R11,R11                 CLEAR WORK\n         IC    R11,TEXT+1              PICK UP M1X2\n         SRL   R11,4                   SHIFT OUT ALL BUT M1\n         CLI   TEXT,X'07'              BCR OP CODE\n         BE    NOEXTND                 YES, NO EXTENDED MNEMONICS\n         CLI   CCTYPE,0                LAST INSTR SET CC\n         BE    NOEXTND                 NO\n         TM    CCTYPE,ARITH            YES, WAS IT ARITHMETIC\n         BO    EXTARITH                YES\n         TM    CCTYPE,CPR              WAS IT COMPARE\n         BO    EXTCPR                  YES\n         TM    CCTYPE,ZRO8             IS IT VALID FOR 8 = BZ\n         BO    EXTZRO                  YES\nNOEXTND  CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 MASK < 10\n         BL    BCM1                    YES, SINGLE DIGIT MASK\n         MVC   OPNDS(2),DBLWD          2-DIGIT MASK TO OPERAND\n         LA    R15,OPNDS+2             TO NEXT POS\n         B     BCCMA                   CONTINUE\nBCM1     MVC   OPNDS(1),DBLWD+1        SINGLE DIGIT MASK TO OPERAND\n         LA    R15,OPNDS+1             TO NEXT POS\nBCCMA    MVI   0(R15),C','             DELIMITER\n         CLI   TEXT,X'07'              RR BRANCH\n         BE    BCROPND                 YES\nBCXOPND  PACK  DBLWD(1),TEXT+1(1)      PACK 2ND BYTE\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,DBLWD               PICK UP X2M1\n         SRL   R10,4                   SHIFT OUT M1\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            PICK UP BDDD ADDRESS\n         BAL   R9,BDXADR               CONVERT ADDRESS\n         STC   R10,BLDXMVC+1           SET MOVE LENGTH\nBLDXMVC  MVC   1(1,R15),OPNDWK         MOVE OPERAND\n         B     BCOXIT                  GO TO EXIT\nBCROPND  MVI   1(R15),C'R'             REGISTER DELIMITER\n         SR    R10,R10                 CLEAR WORK\n         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE\n         IC    R10,DBLWD               PICK UP R2M1\n         SRL   R10,4                   SHIFT OUT M1\n         CVD   R10,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R10,H10                 REG NBR < 10\n         BL    BCRR1                   YES, 0-9\n         MVC   2(2,R15),DBLWD          MOVE 2-DIGIT REG NBR\n         B     BCOXIT                  GO TO EXIT\nBCRR1    MVC   2(1,R15),DBLWD+1        MOVE 1-DIGIT REG NBR\n         B     BCOXIT                  GO TO EXIT\nNOPS     CLI   TEXT,X'07'              RR NOP\n         BNE   BCXNOP                  NO, RX\n         MVC   MNEMONIC,=CL5'NOPR'     SET MNEMONIC\n         LA    R15,OPNDS-1             TO OPND POS\n         B     BCROPND                 FINISH\nBCXNOP   MVC   MNEMONIC,=CL5'NOP'      SET MNEMONIC\n         LA    R15,OPNDS-1             TO OPND POS\n         B     BCXOPND                 FINISH\nUNCNDS   CLI   TEXT,X'07'              IS IT RR BRANCH\n         BNE   BCXBRCH                 NO, RX\n         MVC   MNEMONIC,=CL5'BR'       SET MNEMONIC\n         LA    R15,OPNDS-1             OPERAND ADDR\n         CLI   TEXT+1,X'FE'            IS IT BR 14\n         BNE   BCROPND                 NO\n         MVC   COMMENT(4),=C'EXIT'     COMMENT\n         B     BCROPND                 FINISH FORMATTING\nBCXBRCH  MVC   MNEMONIC(5),=CL5'B'     SET MNEMONIC\nBCXTFIN  LA    R15,OPNDS-1             SET OPND POS\n         B     BCXOPND                 FINISH FORMAT\nBCOXIT   L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\nEXTARITH CH    R11,H8                  COND CODE = 8\n         BE    ARBZ                    YES\n         BL    ARLOW                   NO, LOWER\n         CH    R11,H14                 COND CODE = 14\n         BE    ARBNO                   YES\n         CH    R11,H13                 COND CODE = 13\n         BE    ARBNP                   YES\n         CH    R11,H11                 COND CODE = 11\n         BE    ARBNM                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nARLOW    CH    R11,H7                  COND CODE = 7\n         BE    ARBNZ                   YES\n         CH    R11,H1                  COND CODE = 1\n         BE    ARBO                    YES\n         CH    R11,H2                  COND CODE = 2\n         BE    ARBP                    YES\n         CH    R11,H4                  COND CODE = 4\n         BE    ARBM                    YES\n         B     NOEXTND                 NO, NOT EXTENDED\nARBZ     MVC   MNEMONIC(2),=C'BZ'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBNO    MVC   MNEMONIC(3),=C'BNO'     SET EXTENDED MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBNP    MVC   MNEMONIC(3),=C'BNP'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBNM    MVC   MNEMONIC(3),=C'BNM'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBNZ    MVC   MNEMONIC(3),=C'BNZ'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBO     MVC   MNEMONIC(2),=C'BO'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBP     MVC   MNEMONIC(2),=C'BP'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nARBM     MVC   MNEMONIC(2),=C'BM'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nEXTZRO   CH    R11,H8                  COND CODE = 8\n         BE    ARBZ                    YES, USE BZ MNEMONIC\n         CH    R11,H7                  COND CODE IS 7\n         BE    ARBNZ                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nEXTCPR   CH    R11,H8                  COND CODE = 8\n         BE    CPBE                    YES\n         CH    R11,H7                  COND CODE = 7\n         BE    CPBNE                   YES\n         BL    CPLOW                   NO, LOWER\n         CH    R11,H13                 COND CODE = 13\n         BE    CPBNH                   YES\n         CH    R11,H11                 COND CODE = 11\n         BE    CPBNL                   YES\n         B     NOEXTND                 NO, NOT EXTENDED\nCPLOW    CH    R11,H4                  COND CODE = 4\n         BE    CPBL                    YES\n         CH    R11,H2                  COND CODE = 2\n         BE    CPBH                    YES\n         B     NOEXTND                 NO, NOT EXTENDED\nCPBE     MVC   MNEMONIC(2),=C'BE'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBNE    MVC   MNEMONIC(3),=C'BNE'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBNH    MVC   MNEMONIC(3),=C'BNH'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBNL    MVC   MNEMONIC(3),=C'BNL'     SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBL     MVC   MNEMONIC(2),=C'BL'      SET EXT MNEMONIC\n         B     BCXTFIN                 CONTINUE\nCPBH     MVC   MNEMONIC(2),=C'BH'      SET EXTENDED MNEMONIC\n         B     BCXTFIN                 CONTINUE\n*\n*\n*\n******************************************************************\n*                                                                *\n* VALIDATE AND FORMAT SVC INSTRUCTIONS. IF THE SVC OP-CODE IS    *\n* FOUND IN THE SVC TABLE, IT IS ACCEPTED AS AN SVC, AND THE TABLE*\n* LITERAL IS MOVED TO THE COMMENTS FIELD OF THE INSTRUCTION.     *\n*                                                                *\n******************************************************************\n*\nSVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***\n         CLI   TEXT+1,126              VALID OPERAND\n         BH    NOTSVC                  NO, NOT SVC\n         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS\nSVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE\n         BE    NOTSVC                  YES, MUST NOT BE SVC\n         CLC   0(1,R1),TEXT+1          THIS THE ENTRY\n         BE    GOTSVC                  YES\n         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY\n         B     SVCKND                  LOOP THRU TABLE\nNOTSVC   B     4(R9)                   ERROR RETURN\nGOTSVC   MVC   COMMENT(14),1(R1)       COMMENT TO WORK AREA\n         SR    R1,R1                   CLEAR WORK\n         IC    R1,TEXT+1               GET SVC OPERAND\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         CH    R1,H100                 OPERAND > 100\n         BL    SVCK10                  YES\n         MVC   OPNDS(3),DBLWD          MOVE 3-DIGIT OPERAND\n         B     SVCXIT                  EXIT\nSVCK10   CH    R1,H10                  OPERAND < 10\n         BL    SVCL10                  YES\n         MVC   OPNDS(2),DBLWD+1        MOVE 2-DIGIT OPERAND\n         B     SVCXIT                  EXIT\nSVCL10   MVC   OPNDS(1),DBLWD+2        MOVE 1-DIGIT OPERAND\nSVCXIT   BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SSE-TYPE *\n* INSTRUCTIONS. THE BDADDR ROUTINE IS CALLED TO FORMAT THE STOR- *\n* AGE OPERANDS.                                                  *\n*                                                                *\n******************************************************************\nSSEOPND  EQU   *\n         SR    R10,R10                 CLEAR WORK\n         IC    R10,TEXT+1              GET LENGTH CODE\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+2            GET BDDD ADDRESS\n         BAL   R9,BDADR                CONVERT ADDRESS\n         STC   R10,SSEMV1+1            SET MOVE LENGTH\nSSEMV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS\n         LA    R15,OPNDS+1(R10)        TO NEXT POS\n         MVI   0(R15),C','             DELIMITER\n         SR    R11,R11                 CLEAR WORK\n         ICM   R11,3,TEXT+4            GET BDDD ADDRESS\n         BAL   R9,BDADR                CONVERT ADDRESS\n         STC   R10,SSEMV2+1            SET MOVE LENGTH\nSSEMV2   MVC   1(1,R15),OPNDWK         MOVE ADDRESS\n         L     R9,OPND9                GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*   E INSTR, NO OPERANDS                                         *\n******************************************************************\nEOPND    EQU   *\n         BR    R9\n*\n*\n*\n******************************************************************\n*   RRE INSTRUCTIONS, 1 OR 2 OPERANDS                            *\n******************************************************************\nRREOPND  EQU   *\n         BR    R9\n*\n*\n*\n******************************************************************\n* BUILD EQU STATEMENTS USING THE LABEL TABLE ENTRY ADDRESSED BY  *\n* REG 6 ON ENTRY.                                                *\n*                                                                *\n******************************************************************\n*                                                                *\nEQUSTMT  EQU   *                       BUILD EQU STATEMENTS\n         ST    R9,EQU9                 SAVE RETURN ADDR\n         USING LABELD,R6\n         MVC     NAME,LBLNAME          NAME TO EQU STMT\n         MVC   MNEMONIC,=CL5'EQU'      BUILD EQU STATEMENT\n         MVI   OPNDS,C'*'              SET EQU OPERAND\n         CLI   LBLLEN,1                LENGTH 0 OR 1\n         BNH   CCXEQU                  YES\n         SR    R9,R9                   CLEAR WORK\n         IC    R9,LBLLEN               GET LENGTH\n         CVD   R9,DBLWD                CONVERT\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R9,H100                 LENGTH < 100\n         BL    CCXQ10                  YES\n         MVC   OPNDS+2(3),DBLWD        MOVE LENGTH\n         B     CCXEQC                  GO SET COMMA\nCCXQ10   CH    R9,H10                  LENGTH < 10\n         BL    CCXQ1                   YES\n         MVC   OPNDS+2(2),DBLWD+1      MOVE 2-DIGIT LENGTH\n         B     CCXEQC                  GO SET COMMA\nCCXQ1    MVC   OPNDS+2(1),DBLWD+2      MOVE 1-DIGIT LENGTH\nCCXEQC   MVI   OPNDS+1,C','            SET COMMA\nCCXEQU   BAL   R9,WRTOUT               OUTPUT EQU STATEMENT\n         BAL   R9,PRINT                GO PRINT IT\n         L     R9,EQU9                 GET RETURN ADDR\n         BR    R9                      RETURN\n         DROP  R6\n*\n*\n*\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *\n* LENGTH. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10 *\n* CONTAINS THE LENGTH. THE SCHLBL ROUTINE IS CALLED TO CREATE A  *\n* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*\n* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *\n* DDDD(LLL,RRR) IS CREATED.                                      *\n*                                                                *\n******************************************************************\n*\nBDLADR   EQU   *                       *** FORMAT DDDD(LLL,RRR) OPERAND\n         ST    R9,BDL9                 SAVE RETURN ADDR\n         SR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDLSCHL                 NO\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDLCVTR                 YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDLCVTR                 YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDLSCHL                 CONTINUE\nBDLCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'\nBDLSCHL  BAL   R9,SCHLBL               SEARCH FOR LABEL\n         B     BDLGLBL                 BRANCH IF LABEL FOUND\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT B\n         SRL   R1,20                   RIGHT JUSTIFY DDD\n         CVD   R1,DBLWD                CONVERT DDD\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         MVC   OPNDWK,BLANX            CLEAR WORK AREA\n         CH    R1,H1000                DISPL < 1000\n         BL    BDLD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD100  CH    R1,H100                 DISPL < 100\n         BL    BDLD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD10   CH    R1,H10                  DISPL < 10\n         BL    BDLD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDLLPN                  CONTINUE\nBDLD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDLLPN   MVI   0(R1),C'('              LEFT PAREN DELIMITER\n         TM    IEDT,M1                 IS THIS A SPECIAL MOVE INSTR\n         BO    *+8                     DON'T ADJUST LENGTH\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH FROM LENG\n         CVD   R10,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK\n         CH    R10,H100                LENGTH < 100\n         BL    BDLL10                  YES\n         MVC   1(3,R1),DBLWD           MOVE 3-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLCMA                  CONTINUE\nBDLL10   CH    R10,H10                 LENGTH < 10\n         BL    BDLL1                   YES\n         MVC   1(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\n         B     BDLCMA                  CONTINUE\nBDLL1    MVC   1(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH\n         LA    R1,2(R1)                TO NEXT POS\nBDLCMA   MVC   0(2,R1),=C',R'          DELIMITERS\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 REG < 10\n         BL    BDLR1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT REGISTER\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLRPN                  CONTINUE\nBDLR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT REG\n         CLI   2(R1),C'0'              IS REG = 0\n         BNE   BDLB1                   NO\n         MVC   0(2,R1),BLANX           YES, BLANK IT\n***      BCTR  R1,R0                   BACK UP 1            FIX***\n         B     BDLRPN                  CONTINUE\nBDLB1    LA    R1,3(R1)                TO NEXT POS\nBDLRPN   MVI   0(R1),C')'              FINAL DELIMITER\n         LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE OPERAND LENGTH CODE\n         L     R9,BDL9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDLGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDLGRHE  CLI   0(R1),C' '              AT RHE\n         BNE   BDLGCKLN                YES\n         BCT   R1,BDLGRHE              LOOP TO RHE\nBDLGCKLN CLM   R10,1,LBLLEN            LBL AND INSTR LENGTHS SAME\n         BE    BDLGCMP                 YES\n         MVI   1(R1),C'('              NO, DELIMITER\n         CVD   R10,DBLWD               CONVERT LENGTH\n         UNPK  DBLWD(3),DBLWD+5(3)     UNPACK\n         OI    DBLWD+2,C'0'            CLEAR SIGN\n         CH    R10,H100                LENGTH < 100\n         BL    BDLG10                  YES\n         MVC   2(3,R1),DBLWD           MOVE 3-DIGIT LENGTH\n         LA    R1,5(R1)                TO NEXT POS\n         B     BDLGRPN                 CONTINUE\nBDLG10   CH    R10,H10                 LENGTH < 10\n         BL    BDLG1                   YES\n         MVC   2(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDLGRPN                 CONTINUE\nBDLG1    MVC   2(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\nBDLGRPN  MVI   0(R1),C')'              FINAL DELIMITER\nBDLGCMP  LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BDL9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         DROP  R12\n*\n*\n*\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE AND DISPLACEMENT.      *\n* THE SCHLBL ROUTINE IS CALLED TO SEE WHETHER A LABEL REFERENCE  *\n* MAY BE USED, RATHER THAN AN EXPLICIT ADDRESS. IF LBLSCH IS NOT *\n* SUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM DDDD(RRR) IS FORMED*\n* ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS.                    *\n*                                                                *\n******************************************************************\n*\nBDADR    EQU   *                       *** FORMAT DDDD(RRR) OPERANDS **\n         ST    R9,BD9                  SAVE RETURN ADDR\n         SR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDSCHL                  NO\n         CLI   TEXT,X'8F'              IS IT SLDA??              FIX***\n         BH    BDSADR1                 YES                       FIX***\n         CLI   TEXT,X'88'              IS IT SRL                 FIX***\n         BNL   BDSCHL                  YES                       FIX***\nBDSADR1  SRL   R1,20                   RIGHT JUSTIFY DISPL       FIX***\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDCVTR                  YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDCVTR                  YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDSCHL                  CONTINUE\nBDCVTR   MVC   COMMENT(11),=C'CVT ADDRESS'\nBDSCHL   BAL   R9,SCHLBL               GO SEARCH FOR LABEL\n         B     BDGLBL                  BRANCH IF FOUND\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT B\n         SRL   R1,20                   RIGHT JUSTIFY DDD\n         CVD   R1,DBLWD                CONVERT DISPL\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         CH    R1,H1000                DISPL < 1000\n         BL    BDAD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD100  CH    R1,H100                 DISPL < 100\n         BL    BDAD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD10   CH    R1,H10                  DISPL < 10\n         BL    BDAD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDALPN                  CONTINUE\nBDAD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDALPN   MVC   0(2,R1),=C'(R'          DELIMITERS\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 BASE REG < 10\n         BL    BDAR1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDARPN                  CONTINUE\nBDAR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG\n         LA    R1,3(R1)                TO NEXT POS\nBDARPN   MVI   0(R1),C')'              FINAL DELIMITER\n         LR    R2,R1                   COPY END ADDRESS\n         SH    R2,H4                   BACK UP 4\n         CLC   1(4,R2),=C'(R0)'        BASE REG IS ZERO\n         BNE   BDCE                    NO\n         MVC   1(4,R2),BLANX           CLEAR BASE REG\n         LR    R1,R2                   COPY NEW END ADDR\nBDCE     LR    R10,R1                  COPY END ADDR\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R9,BD9                  GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDGLBL   MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDGRHE   CLI   0(R1),C' '              AT RHE\n         BNE   BDGCMP                  YES\n         BCT   R1,BDGRHE               LOOP TO RHE\nBDGCMP   LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BD9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *\n* INDEX. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10  *\n* CONTAINS THE INDEX. THE SCHLBL ROUTINE IS CALLED TO CREATE A   *\n* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*\n* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *\n* DDDD(XXX,RRR) IS CREATED.                                      *\n*                                                                *\n******************************************************************\n*\nBDXADR   EQU   *                       *** FORMAT DDDD(XXX,BBB) OPERAND\n         ST    R9,BDX9                 SAVE RETURN ADDR\n         LTR   R10,R10                 ANY INDEX REG\n         BNZ   BDXSCHL                 YES\n         SR    R0,R0                   CLEAR WORK REG\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLDL  R0,20                   BASE REG TO R0\n         LTR   R0,R0                   IS BASE REG 0\n         BNZ   BDXSCHL                 NO\n         CLI   TEXT,X'41'              IS IT LA\n         BE    BDXSCHL                 YES\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         CH    R1,H16                  REFERENCE TO CVT ADDR\n         BE    BDXCVTR                 YES\n         CH    R1,H76                  REF TO ALTERNATE CVT ADDR\n         BE    BDXCVTR                 YES\n         MVC   COMMENT(13),=C'PSA REFERENCE'\n         B     BDXSCHL                 CONTINUE\nBDXCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'\nBDXSCHL  BAL   R9,SCHLBL               GO SEARCH FOR LABEL\n         B     BDXGLBL                 BRANCH IF FOUND\n         LR    R1,R11                  COPY BDDD ADDRESS\n         SLL   R1,20                   SHIFT OUT BASE REG\n         SRL   R1,20                   RIGHT JUSTIFY DISPL\n         SRL   R11,12                  RT JUSTIFY BASE REG\n         CVD   R1,DBLWD                CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK\n         CH    R1,H1000                DISPL < 1000\n         BL    BDXD100                 YES\n         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL\n         LA    R1,OPNDWK+4             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD100  CH    R1,H100                 DISPL < 100\n         BL    BDXD10                  YES\n         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL\n         LA    R1,OPNDWK+3             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD10   CH    R1,H10                  DISPL < 10\n         BL    BDXD1                   YES\n         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL\n         LA    R1,OPNDWK+2             TO NEXT POS\n         B     BDXLPN                  CONTINUE\nBDXD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL\n         LA    R1,OPNDWK+1             TO NEXT POS\nBDXLPN   LTR   R10,R10                 ANY INDEX REG\n         BNZ   BDXLPNR                 YES\n         LTR   R11,R11                 ANY BASE REG\n         BNZ   PREPB                   YES\n         BCTR  R1,R0                   NO, BACK UP TO RHE\n         B     BDXCE                   CONTINUE\nPREPB    MVC   0(3,R1),=C'(,R'         DELIMITERS\n         LA    R1,1(R1)                STEP OVER 1 BYTE\n         B     BDXCBAS                 CONTINUE\nBDXLPNR  MVC   0(2,R1),=C'(R'          DELIMITERS\n         CVD   R10,DBLWD               CONVERT INDEX REG\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R10,H10                 INDEX REG < 10\n         BL    BDXX1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT INDEX REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXCMA                  CONTINUE\nBDXX1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT INDEX REG\n         LA    R1,3(R1)                TO NEXT POS\nBDXCMA   LTR   R11,R11                 ANY BASE REG\n         BZ    BDXRPN                  NO\n         MVC   0(2,R1),=C',R'          DELIMITERS\nBDXCBAS  CVD   R11,DBLWD               CONVERT\n         OI    DBLWD+7,X'0F'           CLEAR SIGN\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         CH    R11,H10                 BASE REG < 10\n         BL    BDXB1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXRPN                  CONTINUE\nBDXB1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG\n         LA    R1,3(R1)                TO NEXT POS\nBDXRPN   MVI   0(R1),C')'              FINAL DELIMITER\nBDXCE    LR    R10,R1                  COPY END ADDR\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R9,BDX9                 GET RETURN ADDR\n         BR    R9                      EXIT\n         USING LABELD,R12\nBDXGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK\n         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER\nBDXGRHE  CLI   0(R1),C' '              AT RHE\n         BNE   BDXGCKLN                YES\n         BCT   R1,BDXGRHE              LOOP TO RHE\nBDXGCKLN LTR   R10,R10                 ANY INDEX REGISTER\n         BZ    BDXGCMP                 NO\n         MVI   1(R1),C'('              YES, DELIMITER\n         CVD   R10,DBLWD               CONVERT LENGTH\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         OI    DBLWD+1,C'0'            CLEAR SIGN\nBDXG10   CH    R10,H10                 LENGTH < 10\n         BL    BDXG1                   YES\n         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT LENGTH\n         LA    R1,4(R1)                TO NEXT POS\n         B     BDXGRPN                 CONTINUE\nBDXG1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH\n         LA    R1,3(R1)                TO NEXT POS\nBDXGRPN  MVI   0(R1),C')'              FINAL DELIMITER\nBDXGCMP  LR    R10,R1                  COPY END ADDRESS\n         S     R10,OWSTRT              COMPUTE LENGTH CODE\n         L     R12,SLSAV+12            RESTORE R12\n         L     R9,BDX9                 GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\nWRTOUT   EQU   *                       WRITE OUTPUT RECORDS\n         L     R1,PUNCHDCB             @ SYSPUNCH DCB\n         MVC   PRT+30(80),WORKREC      SAVE IN PRINT\n         TM    48(R1),X'10'            IS FILE OPEN\n         BZ    CLRWKR                  NO\n         AP    CARDNO,=P'10'           INCREMENT CARD NO\n         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD\n         OI    SEQNBR+7,C'0'           CLEAR SIGN\n         PUT   (1),WORKREC             WRITE SOURCE CARD\nCLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD\n         BR    R9                      RETURN\n*\n*\n*\n******************************************************************\n*                                                                *\n* SEARCHES THE BASE REGISTER TABLE TO FIND THE BASE REGISTER     *\n* ASSOCIATED WITH THE BDDD OPERAND ADDRESS PASSED IN REG 11 ON   *\n* ENTRY. IF THE BASE REGISTER GIVEN IS NOT A CURRENT BASE REG    *\n* THE UNSUCCESSFUL RETURN IS MADE TO 4 BYTES PAST THE ADDRESS    *\n* IN REG 9 ON ENTRY. WHEN THE CURRENT BASE REGISTER ENTRY IS FOR *\n* A PROGRAM BASE REG, THE DISPLACEMENT IS ADDED TO THE ASSUMED   *\n* BASE REGISTER VALUE IS ADDED TO THE DISPLACEMENT TO GIVE AN    *\n* OFFSET IN THE PROGRAM. THE LABEL TABLE IS SEARCHED FOR AN ENTRY*\n* WITH THIS OFFSET, AND IF FOUND, IS RETURNED TO THE CALLER. WHEN*\n* THE BASE REGISTER FOUND IS FOR A DSECT, THE DSECT HEADER ENTRY *\n* ADDRESS IS GIVEN IN THE BASE TABLE ENTRY. THE DSECT HEADER HAS *\n* THE ADDRESS OF THE FIELD DEFINITION TABLE FOR THE DSECT. THE   *\n* FIELD DEFINITION TABLE IS SEARCHED FOR AN ENTRY HAVING THE     *\n* DISPLACEMENT IN THE BDDD INSTRUCTION, AND IF FOUND IS PASSED   *\n* BACK TO THE CALLER. IF THE LABEL/FIELD TABLE SEARCHES ARE      *\n* UNSUCCESSFUL, RETURN IS TO 4 BYTES PAST REG 9.                 *\n*                                                                *\n******************************************************************\n*\nSCHLBL   EQU   *                       *** SEARCH FOR LABEL AT BDDD ADD\n         TM    MORUSG,X'80'            ANY BASES ACTIVE\n         BZ    4(R9)                   NO, UNSUCCESSFUL EXIT\n         STM   R9,R12,SLSAV            YES, SAVE REGS USED\n         LR    R12,R11                 COPY BDDD ADDRESS\n         SRL   R12,12                  CLEAR WORK REG\n*        LTR   R12,R12                 IS BASE REG ZERO\n*        BZ    SCHNF                   YES, NO LABEL\n         MH    R12,USGLEN              BASE X BASE TBL ENTRY LENG\n         LA    R12,BASES(R12)          @ BASE TBL ENTRY\n         USING USINGD,R12\n         CLI   USTYPE,0                ENTRY IN USE\n         BE    SCHNF                   NO, EXIT\n         LR    R9,R11                  COPY BDDD ADDRESS\n         SLL   R9,20                   SHIFT OUT BASE\n         SRL   R9,20                   RIGHT JUSTIFY DDD\n         ICM   R11,7,USVALU            GET BASE REG VALUE\n         LA    R11,0(R11)              CLEAR HI-ORDER\n         CLI   USTYPE,C'P'             PROGRAM BASE REG\n         BE    PGMBASE                 YES\n         DROP  R12\n         LR    R12,R11                 COPY DSECT FIELD TBL ADDRESS\n         USING DSECTD,R12\nCKDSCTND CLM   R9,7,DSOFSET            THIS THE ENTRY\n         BE    SCHFD                   YES\n         CLC   DSOFSET,HIVAL           NO, AT TABLE END\n         BE    SCHNF                   YES, NO LABEL FOUND\n         LA    R12,L'DSECT(R12)        STEP TO NEXT ENTRY\n         B     CKDSCTND                LOOP THRU DSECT FIELDS\nPGMBASE  AR    R9,R11                  COMPUTE OFFSET\n         DROP  R12\n         L     R12,LBLTBL              @ LABEL TABLE\n         USING LABELD,R12\nCKENTFD  CLM   R9,7,LBLADR             THIS THE ENTRY\n         BE    SCHFD                   YES\n         LA    R12,L'LABEL(R12)        TO NEXT ENTRY\n         C     R12,CURRLBL             END OF TBL\n         BNL   SCHNF                   YES, NO LABEL\n         B     CKENTFD                 NO, CONTINUE SEARCH\nSCHNF    LM    R9,R12,SLSAV            NOT FOUND, RESTORE REGS\n         B     4(R9)                   NOT FOUND RETURN\nSCHFD    LM    R9,R11,SLSAV            FOUND RESTORE ALL BUT 12\n         BR    R9                      FOUND RETURN\n         DROP  R12\n*\n*\n*\n******************************************************************\n*                                                                *\n* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *\n*                                                                *\n******************************************************************\n*\nPRINT    EQU   *                       PRINT ROUTINE\n         L     R1,PRINTDCB             @ SYSPRINT DCB\n         TM    48(R1),X'10'            IS SYSPRINT OPEN\n         BNO   CLRPRT                  NO\n         PUT   (1),PRTLINE             WRITE PRINT LINE\nCLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C' '                SINGLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'0'                DOUBLE SPACED\n         BE    SETSGL                  YES\n         AP    LINECT,P1               INCR LINE COUNTER\n         CLI   PCC,C'-'                TRIPLE SPACED\n         BE    SETSGL                  YES\n         ZAP   LINECT,P0               NO, MUST BE NEW PAGE\nSETSGL   MVI   PCC,C' '                SET SINGLE SPACING\n         CP    LINECT,P58              PAST END OF PAGE\n         BH    NEWPAGE                 YES\n         BR    R9                      EXIT\nNEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF\n         ZAP   LINECT,P0               RESET LINE COUNTER\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* CONVERT HEX DATA TO PRINTABLE FORM: 2 CHARACTERS PER BYTE. ON  *\n* ENTRY, REG 12 CONTAINS THE ADDRESS OF THE LEFT END OF THE FIELD*\n* TO BE CONVERTED, AND THE ENTRY POINT USED DETERMINES THE LENGTH*\n* FORMATTED OUTPUT IS PLACED IN THE PRTABL FIELD.                *\n*                                                                *\n******************************************************************\n*\nHEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE\nHEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX\n         B     HEXCLTR                 CONTINUE\nHEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX\nHEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE\n         TR    PRTABL(8),TRTBL         MAKE PRINTABLE\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* FORMATS THE HEX DATA CORRESPONDING TO THE FORMATTED INSTRUCTION*\n* BEING OUTPUT. PRINTABLE HEX IS PLACED AT THE RIGHT OF THE LINE *\n* ON THE SYSPRINT OUTPUT.                                        *\n*                                                                *\n******************************************************************\n*\nTXTFMT   EQU   *                       *** FORMAT TEXT FOR PRINT ***\n         ST    R9,TX9                  SAVE RETURN ADDR\n         LA    R11,PRT                 @ PRINT LINE\n         CLI   TYPE,1                  ADCON\n         BE    TFOFST                  YES\n         CLI   TYPE,2                  CONSTANT\n         BE    TFOFST                  YES\n         CLI   TYPE,X'0D'              INSTRUCTION\n         BNE   TXTCLEAN                NO\nTFOFST   LA    R12,OFFSET              @ OFFSET TO INSTR\n         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVC   PRT+00(6),PRTABL        OFFSET TO PRINT\n         LA    R12,LEN                 @ DATA LENGTH\n         BAL   R9,HEXPRT1              MAKE PRINTABLE\n         MVC   PRT+08(2),PRTABL        LENGTH TO PRINT\n         LA    R12,TEXT                @ TEXT TO PRINT\n         BAL   R9,HEXPRT4              CONVERT 1ST 4 BYTES\n         CLI   LEN,4                   IS IT 4 BYTES\n         BNL   TXT4                    YES, OR MORE\n         CLI   LEN,3                   IS IT 3 BYTES\n         BE    TXT3                    YES\n         CLI   LEN,2                   IS IT 2 BYTES\n         BE    TXT2                    YES\n         MVC   PRT+14(2),PRTABL        TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT2     MVC   PRT+14(4),PRTABL        TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT3     MVC   PRT+14(6),PRTABL        TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT4     MVC   PRT+14(8),PRTABL        TEXT TO PRINT\n         CLI   LEN,4                   IS IT 4 BYTES\n         BE    TXTCLEAN                YES, FINISH\n         LA    R12,TEXT+4              @ TEXT\n         BAL   R9,HEXPRT4              CONVERT\n         CLI   LEN,8                   8 BYTES OF TEXT\n         BE    TXT8                    YES\n         CLI   LEN,7                   7 BYTES OF TEXT\n         BE    TXT7                    YES\n         CLI   LEN,6                   6 BYTES OF TEXT\n         BE    TXT6                    YES\n         MVC   PRT+18(2),PRTABL        TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT6     MVC   PRT+022(4),PRTABL       TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT7     MVC   PRT+022(6),PRTABL       TEXT TO PRINT\n         B     TXTCLEAN                FINISH\nTXT8     MVC   PRT+022(8),PRTABL       TEXT TO PRINT\nTXTCLEAN XC    OFFSET,OFFSET           CLEAR\n         L     R9,TX9                  GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* ENTERED WHENEVER THE CURRENT TEXT OFFSET IS PAST THE NEXCHG    *\n* FIELD VALUE. THIS ROUTINE CREATES DROP CARDS FOR EXHAUSTED BASE*\n* REGISTERS, AND USING STATEMENTS FOR NEW BASE REGISTERS. THE    *\n* BASES TABLE IS SCANNED, AND ANY ENTRY WHICH IS NO LONGER IN USE*\n* IS ZEROED OUT, AND A DROP RECORD IS CREATED. NEXT, THE USING   *\n* TABLE IS SCANNED. WHEN AN ENTRY IS FOUND WHICH IS VALID AT THE *\n* CURRENT OFFSET, THE BASE TABLE IS CHECKED. IF THE ENTRY IS NOT *\n* IN USE, A USING STATEMENT IN CREATED, AND THE USING TABLE ENTRY*\n* IS MOVED TO THE BASES TABLE. THE NEXCHG FIELD IS CHANGED TO    *\n* CONTAIN THE OFFSET AT WHICH THE NEXT SCAN MUST BE MADE. AN IND-*\n* ICATOR CALLED MORUSG IS SET TO SHOW WHEN ANY BASE REGISTERS ARE*\n* CURRENTLY IN USE. WHEN NO MORE REGISTERS ARE AVAILABLE, THE    *\n* NEXCHG FIELD IS SET TO HEX FF'S.                               *\n*                                                                *\n******************************************************************\n*\nNEXUSG   EQU   *                       *** GET NEXT BASE REG SET ***\n         MVC   NEXCHG,HIVAL            RESET NEXT CHANGE ADDR\n         MVI   MORUSG,0                CLEAR BASE REG AVAIL INDIC\n         ST    R9,USG9                 SAVE RETURN ADDR\n*        XC    BASES(L'USING),BASES    CLEAR R0 ELEMENT\n         MVC   BASES+16*L'USING(4),HIVAL SET TABLE STOPPER\n         USING USINGD,R2\n         LA    R2,BASES                @ R0'S ELEMENT\n*        LA    R2,BASES+L'USING        @ R1'S ELEMENT\nDRPCKND  CLI   0(R2),X'FF'             END OF TABLE\n         BE    USGUSG                  YES\n         CLC   USEND,XZROS             ENTRY USED\n         BE    DRPSTEP                 NO\n         CLC   TXTOFSET,USEND          PAST END OF THIS ONE\n         BL    DRPSTEP                 NO\n         MVC   MNEMONIC(4),=C'DROP'    OPERATION IS DROP\n         MVI   OPNDS,C'R'              DELIMITER FOR REGS\n         SR    R12,R12                 CLEAR WORK\n         IC    R12,USREG               GET REG\n         CVD   R12,DBLWD               CONVERT TO PACKED\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK\n         OI    DBLWD+1,C'0'            CLEAR SIGN\n         CH    R12,H10                 REG < 10\n         BL    DPR1                    YES\n         MVC   OPNDS+1(2),DBLWD        MOVE REG NBR\n         B     WRTDROP                 GO WRITE DROP\nDPR1     MVC   OPNDS+1(1),DBLWD+1      MOVE 1-DIGIT REG\nWRTDROP  BAL   R9,WRTOUT               WRITE DROP RECORD\n         BAL   R9,PRINT                PRINT DROP RECORD\n         XC    USING,USING             CLEAR THE ENTRY\nDRPSTEP  LA    R2,L'USING(R2)          TO NEXT BASE ELEMENT\n         B     DRPCKND                 LOOP\nUSGUSG   L     R2,USGSTRT              GET FIRST USING TBL ADDR\nENDUS    CLI   0(R2),X'FF'             END OF TABLE\n         BE    XITUS                   YES\n         CLC   TXTOFSET,USEND          PAST END OF THIS ONE\n         BNL   ECSTEP                  YES\n         OI    MORUSG,1                SHOW MORE BASES AVAIL\nUSBGCK   CLC   TXTOFSET,USBGN          CURR LOC BEFORE THIS\n         BNL   CKNEWLO                 NO\n         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHANGE\n         BNL   ECSTEP                  NO\n         MVC   NEXCHG,USBGN            YES, SET LOWER CHANGE OFFSET\n         B     ECSTEP                  CONTINUE\nCKNEWLO  CLC   USEND,NEXCHG            THIS ENTRY ENDS EARLIER\n         BNL   ECMVC                   NO\n         MVC   NEXCHG,USEND            YES, SET NEW END\nECMVC    SR    R1,R1                   CLEAR WORK\n         IC    R1,USREG                PICK UP REG\n         MH    R1,USGLEN               TIMES ENTRY LENGTH\n         LA    R1,BASES(R1)            @ BASE TABLE ENTRY\n         OI    MORUSG,X'80'            SHOW BASE IN USE\n         CLC   USING,0(R1)             OLD AND NEW IDENTICAL\n         BE    ECSTEP                  YES\nMAKUSG   MVC   0(L'USING,R1),USING     NEW USING TO TABLE\n         MVC   MNEMONIC(5),=C'USING'   OPERATION IS USING\n         CLI   USTYPE,C'D'             IS IT A DSECT\n         BNE   CKUTPS                  NO\n         ICM   R12,7,USVALU            YES, GET DSECT HEADER ADDR\n         L     R11,DTBSTRT             @ 1ST DSECT HEADER ENTRY\nDSCTEND  C     R11,DTBCURR             END OF TABLE\n         BH    MVDSNAME                YES\n         CLM   R12,7,8(11)             THIS THE HEADER ENTRY\n         BNE   DSCTSTEP                NO\n         LR    R12,R11                 YES, COPY IT'S ADDRESS\n         B     MVDSNAME                CONTINUE\nDSCTSTEP LA    R11,11(R11)             TO NEXT HEADER ENTRY\n         B     DSCTEND                 LOOP THRU TABLE\nMVDSNAME MVC   OPNDS(8),0(R12)         DSECT NAME TO OPERANDS\n         LA    R12,OPNDS+7             TO END OF NAME\nUSFRHED  CLI   0(R12),C' '             FOUND RHE\n         BNE   USFMADD                 YES\n         BCT   R12,USFRHED             BACK UP 1 AND LOOP\nUSFMADD  LA    R12,1(R12)              TO NEXT BYTE\nUSFMCMA  MVC   0(2,R12),=C',R'         DELIMITERS\n         SR    R11,R11                 CLEAR WORK\n         IC    R11,USREG               GET REGISTER NBR\n         CVD   R11,DBLWD               CONVERT TO PACKED\n         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK REG NBR\n         OI    DBLWD+1,C'0'            CLEAR SIGN\n         CH    R11,H10                 REG < 10\n         BL    USFMR1                  YES\n         MVC   2(2,R12),DBLWD          MOVE 2-DIGIT REG NBR\n         B     USINGOUT                GO WRITE USING\nUSFMR1   MVC   2(1,R12),DBLWD+1        MOVE 1-DIGIT REG NBR\nUSINGOUT BAL   R9,WRTOUT               WRITE USING STMT\n         BAL   R9,PRINT                PRINT USING STMT\n         B     ECSTEP                  CONTINUE\nCKUTPS   CLC   USVALU,TXTOFSET         USING AT CURR LOC\n         BNE   USFMLBL                 NO\n         MVI   OPNDS,C'*'              SET CURRENT LOC SYMBOL IN OPERAN\n         LA    R12,OPNDS+1             GET NEXT POS ADDR\n         B     USFMCMA                 GO FORMAT REG\nUSFMLBL  MVI   OPNDS,C'A'              SET 1ST CHAR OF LABEL NAME\n         LA    R12,USVALU              GET OFFSET\n         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE\n         MVC   OPNDS+1(6),PRTABL       PRINTABLE HEX TO LABEL\n         LA    R12,OPNDS+7             TO NEXT LOC\n         B     USFMCMA                 FORMAT REG\nECSTEP   LA    R2,L'USING(R2)          TO NEXT USING ENTRY\n         B     ENDUS                   CONTINUE SCAN\nXITUS    L     R9,USG9                 GET RETURN ADDR\n         BR    R9                      EXIT\n*\n*\n*\n******************************************************************\n*                                                                *\n* END OF PHASE 2 - RETURN TO PHASE 0                             *\n*                                                                *\n******************************************************************\n*\nEOJ      EQU   *                       END OF JOB\n         BAL   R9,FORCONST             YES, FORCE IT OUT\n         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE\n         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS\n         SR    R15,R15                 CLEAR RETURN CODE\n         BR    R14                     RETURN TO CALLER\n*\n*\n*\n*                 *** DATA AND WORK AREAS ***\n******************************************************************\n*                                                                *\n*\n* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED\n* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED\n* WITH ALL OTHER PROGRAMS.\n*\n******************************************************************\n*\n         DS    0D\nCOMMPARM DSECT ,                       COMMON AREAS\nDBLWD    DS    D                       DOUBLEWORD WORK AREA\nPUNCHDCB DS    F                       @ SYSPUNCH DCB\nPRINTDCB DS    F                       @ SYSPRINT DCB\nINDCB    DS    F                       @ SYSIN DCB\nCSECT    DS    CL8                     SPECIFIED CSECT NAME\nESDID    DS    XL2                     ESD ID OF SPECIFIED CSECT\nENDLBLNM DS    CL8                     SYMBOL FOR END STMT BEGIN POINTE\nLINECT   DS    PL2                     PRINT LINE COUNTER\nSTART    DS    A                       LKED ASSIGNED START ADDR OF CSEC\nEND      DS    A                       CSECT END ADDRESS\nLENGTH   DS    F                       LENGTH OF SPECIFIED CSECT\nLBLTBL   DS    F                       @ LABEL TABLE\nCURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR\nENDLBL   DS    F                       @ END OF LABEL TBL\nLBLLGTH  DS    AL2                     LENGTH OF LABEL ENTRY\nTXTSTRT  DS    F                       @ TEXT STORAGE AREA\nTXTEND   DS    F                       @ END OF TEXT AREA\nTXTCURR  DS    F                       @ CURRENT TEXT LOC\nDTBCURR  DS    F                       @ CURRENT DSECT TABLE ENTRY\nDTBEND   DS    F                       @ DSECT TABLE END\nDTBSTRT  DS    F                       @ DSECT TABLE START\nUSGSTRT  DS    F                       @ USING TABLE START\nUSGCUR   DS    F                       @ CURRENT USING TABLE ENTRY\nUSGEND   DS    F                       @ USING TABLE END\nDATONLY  DS    F                       @ DATA ONLY TABLE\nDATOCUR  DS    F                       @ CURRENT DATA ONLY ENTRY\nDATEND   DS    F                       @ END OF DATA ONLY TABLE\nFLPTASM  DS    XL1                     FLOATING POINT INDICATOR\nPRIVASM  DS    XL1                     PRIVILEGED INDICATOR\nUSERR    DS    XL1                     ERROR INDIC FOR DISASM1\nNBRLBLS  DS    H                       NBR LABELS FROM DISASM1\n*\n*\n*\nWORKREC  DS    0CL80                   DISASSEMBLY WORK AREA\nNAME     DS    CL8                     NAME\n         DS    CL1\nMNEMONIC DS    CL5                     INSTRUCTION MNEMONIC\n         DS    CL1\nOPNDS    DS    CL27                    1ST OPERAND\n         DS    CL1\nCOMMENT  DS    CL28                    COMMENT\nCOL72    DS    CL1                     CONTINUATION COLUMN\nSEQNBR   DS    CL8                     CARD SEQUENCE NBR\n*\n*\n*\nCARDNO   DS    PL4                     CURRENT OUTPUT CARD NBR\nPRTLINE  DS    0CL121                  PRINT LINE\nPCC      DS    CL1                     CARRIAGE CONTROL\nPRT      DS    CL120                   PRINT DATA\n*\n*\n*\n         DS    0F\nBLDLIST  DS    0CL62                   BLDL LIST\n         DC    H'1'                    ONE ENTRY\n         DC    H'58'                   LENGTH OF ENTRY\nMEMBER   DC    CL8' '                  MEMBER NAME\nTTRMOD   DC    XL3'000000'             TTR OF MODULE\nCCAT     DC    XL1'00'                 CONCATENATION NUMBER\n         DC    XL1'00'\nALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR\n*                           80=ALIAS\nTTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD\n         DC    XL1'00'\nTTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST\nNNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST\nATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1\n*                           80=RENT\n*                           40=REUS\n*                           20=OVERLAY\n*                           10=UNDER TEST\n*                           08=ONLY LOADABLE\n*                           04=SCATTER FORMAT\n*                           02=EXECUTABLE\n*                           01=ONE TXT, NO RLD RECORDS\nATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2\n*                           80=CANNOT BE REPROCESSED BY LKED E\n*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO\n*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO\n*                           10=CONTAINS NO RLD RECORD\n*                           08=CANNOT BE REPROCESSED BY LKED\n*                           04=CONTAINS TESTRAN SYMBOLS\n*                           02=CREATED BY LKED\n*                           01=REFR\nTOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD\nLENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD\nLKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR\nATTR2    DC    XL1'00'                 ATTRIBUTES 2\n*                           80=PROCESSED BY OS/VS LKED\n*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE\n*                           10=SSI PRESENT\n         DC    XL2'0000'\nSCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH\nTTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH\nSCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD\nSCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT\nALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME\nALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS\nSSI      DS    XL4'00000000'           SSI BYTES\nAUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH\nAUTHCOD  DC    XL1'00'                 AUTH CODE\n*\n*\n*\nCOMMEND  EQU   *\n*\n*\n*\nLABELD   DSECT ,                       LABEL TABLE ENTRY\nLABEL    DS    0CL13                   13-BYTE ENTRIES\nLBLADR   DS    XL3                     RELATIVE ADDR IN TEXT\nLBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,\nLBLNAME  DS    CL8                     NAME (SYMBOL)\nLBLLEN   DS    XL1                     LENGTH IF A, V, OR W\n*\n*\n*\nUSINGD   DSECT ,                       USING TABLE ENTRY\nUSING    DS    0CL11\nUSBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE\nUSEND    DS    XL3                     OFFSET TO END OF RANGE\nUSREG    DS    XL1                     BASE REGISTER USED\nUSTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT\nUSVALU   DS    XL3                     BASE REG VALUE\n*\n*\n*\nDSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY\nDSECT    DS    0CL13\nDSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD\nDSLBTYP  DS    CL1                     LABEL TYPE = L\nDSNAME   DS    CL8                     FIELD NAME\nDSLENG   DS    XL1                     FIELD LENGTH\n*\n*\n*\nDISASM2  CSECT\n*\n*\n*\n*\n*\n*\nSVCTBLAD DC    A(SVCOP)                @ SVC TABLE\nDBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL\nOWSTRT   DC    A(OPNDWK)               @ OPERAND WORK AREA\nOPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES\nUSG12    DS    2F                      REG SAVE AREA\nUSG9     DS    F                       RETURN SAVE\nEQU9     DS    F                       RETURN ADDR FOR EQUSTMT\nFC6      DS    F                       SAVE AREA FOR R6\nFC9      DS    F                       FORCONST RETURN ADDR\nTX9      DS    F                       RETURN ADDR FOR TXTFMT\nBD9      DS    F                       RETURN FOR BDADR\nBDX9     DS    F                       RETURN FOR BDXADR\nBDL9     DS    F                       RETURN FOR BDLADR\nSLSAV    DS    4F                      SAVE FOR SCHLBL\nSGOPLEN  DC    AL2(L'SGLOP)            SINGLE BYTE OP COD TBL LEN\nILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***\nCONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC\nCONPSLBL DS    0CL13                   PSEUDO LABEL ENTRY FOR CONSTANTS\n         DS    XL4\nCONNAME  DS    CL8                     CONSTANT NAME\nCONLLEN  DS    XL1                     LABEL LENGTH\nCONTYPE  DS    CL1                     TYPE\n         DS    0H\nCONDATA  DS    XL8                     CONSTANT DATA\nCONSYM   DS    CL8                     CONSTANT SYMBOL\nCONLEN   DS    H                       CONSTANT LENGTH\nCONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT\nCONLOC   DS    F                       @ CURRENT BYTE IN CONSTANT\nCCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING\nTXTOFST  DS    0F\n         DS    X\nTXTOFSET DS    XL3                     OFFSET TO TEXT BYTE\nOPNDWK   DS    CL13                    OPERAND BUILD AREA\nOFFSET   DS    XL3                     OFFSET FROM PGM START\nINSTYP   DS    CL1                     INSTRUCTION TYPE\nTYPE     DS    XL1                     TYPE CODE\n*                                       0=CSECT, 1=ADCON, 2=CONST\n*                                       E=USING, D=INSTRUCTION\n*                                       C=COMMENT, 9=ENTRY\n*                                       A=EQU\nLEN      DS    XL1                     TEXT LENGTH\nTEXT     DS    XL8                     TEXT\nH1       DC    H'1'                    CONSTANT 1\nH2       DC    H'2'                    CONSTANT 2\nH4       DC    H'4'                    CONSTANT 4\nH7       DC    H'7'                    CONSTANT 7\nH8       DC    H'8'                    CONSTANT 8\nH10      DC    H'10'                   CONSTANT 10\nH11      DC    H'11'                   CONSTANT 11\nH13      DC    H'13'                   CONSTANT 13\nH14      DC    H'14'                   CONSTANT 14\nH16      DC    H'16'                   CONSTANT 16\nH76      DC    H'76'                   CONSTANT 76\nH100     DC    H'100'                  CONSTANT 100\nH1000    DC    H'1000'                 CONSTANT 1000\nP0       DC    P'0'                    CONSTANT 0\nP1       DC    P'1'                    CONSTANT 1\nP58      DC    P'58'                   CONSTANT 58\nBLANX    DC    CL121' '                CONSTANT BLANKS\nXZROS    DC    16X'00'                 CONSTANT ZEROS\nHIVAL    DC    4X'FF'                  CONSTANT X F'S\nNEXCHG   DC    XL3'00'                 OFFSET TO NEXT BASE REG CHG\nUSGLEN DC AL2(L'USING) LENGTH OF USING TBL ENTRIES\nMORUSG   DC    X'00'                   0=NO MORE BASES, 80=MORE BASES A\nTRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL\nPRTABL   DS    CL9                     PRINTABLE HEX WORK\nBASES    DC    XL256'00'               BASE REG TABLE\n*        TRT TABLE FOR CHAR/HEX DETERMINATION\n*        00 FOR VALID CHARACTERS, FF FOR HEX VALUES\n*\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\nCHARTRAN DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 0\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 1\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 2\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 3\n         DC    X'00FFFFFFFFFFFFFFFFFFFF00FFFFFFFF' 4   BLANK AND DOT\n         DC    X'FFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF' 5   $\n         DC    X'0000FFFFFFFFFFFFFFFFFFFFFF00FFFF' 6   /, -, AND _\n         DC    X'FFFFFFFFFFFFFFFFFFFFFF0000FFFFFF' 7   # AND @\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 8\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 9\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' A\n         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' B\n         DC    X'FF000000000000000000FFFFFFFFFFFF' C   A-I\n         DC    X'FF000000000000000000FFFFFFFFFFFF' D   J-R\n         DC    X'FFFF0000000000000000FFFFFFFFFFFF' E   S-Z\n         DC    X'00000000000000000000FFFFFFFFFFFF' F   0-9\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\n         LTORG\n*\n         COPY  DISASM3A                COPY INSTRUCTION TABLES\n         COPY  DISASM3B                COPY SVC TABLE\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM3A": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x01\\xa1\\x01\\xa1\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 417, "newlines": 417, "modlines": 0, "user": "FIELD"}, "text": "         EJECT\n***********************************************************************\n*                                                                     *\n* INSTRUCTION DISASSEMBLY TABLES. THESE TABLES DEFINE VALID           *\n* INSTRUCTION OP-CODES, AND GIVE MNEMONICS, FORMAT-TYPES,             *\n* AND AN INDICATOR TO SHOW CONDITION SETTING INSTRUCTIONS,            *\n* PRIVILEGED INSTRUCTIONS, AND FLOATING POINT INSTRUCTIONS.           *\n*                                                                     *\n***********************************************************************\nINSTENT  DS    0CL10                   CURRENT INSTRUCTION ENTRY\nINAME    DS    CL5                   * INSTR NAME (MNEMONIC)\nITYPE    DS    XL1                   * INSTRUCTION TYPE\nRR       EQU   0                       RR FORMAT\nRX       EQU   4                       RX FORMAT\nS        EQU   8                       S FORMAT\nSI       EQU   12                      SI FORMAT\nRS       EQU   16                      RS FORMAT\nSS1      EQU   20                      SS FORMAT, SINGLE LENGTH\nSS2      EQU   24                      SS FORMAT, 2 LENGTHS\nTWO      EQU   28                      TWO BYTE OP-CODE\nCONDBR   EQU   32                      CONDITIONAL BRANCH\nSVC      EQU   36                      SUPERVISOR CALL\nSSE      EQU   40                      SS EXTENDED FORMAT\nE        EQU   44                      E FORMAT\nRRE1     EQU   48                      RR EXTENDED FORMAT, 1 OPERAND\nRRE2     EQU   52                      RR EXTENDED FORMAT, 2 OPERANDS\nICLASS   DS    XL1                   * INSTRUCTION CLASS\nPRIV     EQU   2                       PRIVILEGED INSTRUCTION\nFLTPT    EQU   4                       FLOATING POINT INSTRUCTION\nFLSHT    EQU   5                       SHORT PREC FLT PT INSTR\nIEDT     DS    XL1                   * INSTRUCTION EDITS\nEPR      EQU   X'40'                   EVEN-ODD REGISTER PAIR\nE2       EQU   X'20'                   2ND OPND ON HALFWORD BOUND\nE4       EQU   X'10'                   2ND OPND ON FULLWORD BOUND\nE8       EQU   X'08'                   2ND OPND ON DBL WORD BOUND\nM1       EQU   X'04'                   SPECIAL MOVE TYPE\nS1       EQU   X'02'                   1ST OPND MUST HAVE BASE/INDEX\nS2       EQU   X'01'                   2ND OPND MUST HAVE BASE\nICCSET   DS    XL1                   * TYPE CONDITION CODE SET\nARITH    EQU   X'80'                   ARITHMETIC TYPE\nCPR      EQU   X'40'                   COMPARE TYPE\nZRO8     EQU   X'20'                   BC 8 MAY BE BZ\nINLNG    DS    XL1                     INSTRUCTION LENGTH\n*\n         EJECT\n***********************************************************************\n* THESE ARE THE INSTRUCTION OP CODE AND SVC TABLES COPIED INTO        *\n* DISASM1 AND DISASM2. THEY HAVE BEEN UPDATED TO XA LEVELS.           *\n* NON XA INSTRUCTIONS STILL APPEAR IN THE TABLES.                     *\n* PARTIALLY UPDATED FOR SORTING AND VECTOR INSTRUCTION FORMATS.       *\n***********************************************************************\nSGLOP    DS    0CL10                   SINGLE BYTE OP-CODE TABLE\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR 00\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 01\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR 02\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'02' NOT INSTR 03\n         DC    CL5'SPM',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 04\n         DC    CL5'BALR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 05\n         DC    CL5'BCTR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 06\n         DC    CL5'BCR',AL1(CONDBR),AL1(0),AL1(0),AL1(0),X'02' 07\n         DC    CL5'SSK',AL1(RR),AL1(PRIV),AL1(0),AL1(0),X'02' 08 \u00acXA\n         DC    CL5'ISK',AL1(RR),AL1(PRIV),AL1(0),AL1(0),X'02' 09 \u00acXA\n         DC    CL5'SVC',AL1(SVC),AL1(0),AL1(0),AL1(0),X'02' 0A\n         DC    CL5'BSM',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 0B - XA\n         DC    CL5'BASSM',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 0C - XA\n         DC    CL5'BASR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 0D - XA\n         DC    CL5'MVCL',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 0E\n         DC    CL5'CLCL',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 0F\n         DC    CL5'LPR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 10\n         DC    CL5'LNR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 11\n         DC    CL5'LTR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 12\n         DC    CL5'LCR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 13\n         DC    CL5'NR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 14\n         DC    CL5'CLR',AL1(RR),AL1(0),AL1(0),AL1(CPR),X'02' 15\n         DC    CL5'OR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 16\n         DC    CL5'XR',AL1(RR),AL1(0),AL1(0),AL1(ZRO8),X'02' 17\n         DC    CL5'LR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 18\n         DC    CL5'CR',AL1(RR),AL1(0),AL1(0),AL1(CPR),X'02' 19\n         DC    CL5'AR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 1A\n         DC    CL5'SR',AL1(RR),AL1(0),AL1(0),AL1(ARITH),X'02' 1B\n         DC    CL5'MR',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 1C\n         DC    CL5'DR',AL1(RR),AL1(0),AL1(EPR),AL1(0),X'02' 1D\n         DC    CL5'ALR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 1E\n         DC    CL5'SLR',AL1(RR),AL1(0),AL1(0),AL1(0),X'02' 1F\n         DC    CL5'LPDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 20\n         DC    CL5'LNDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 21\n         DC    CL5'LTDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 22\n         DC    CL5'LCDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 23\n         DC    CL5'HDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 24\n         DC    CL5'LRDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 25\n         DC    CL5'MXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 26\n         DC    CL5'MXDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 27\n         DC    CL5'LDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 28\n         DC    CL5'CDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(CPR),X'02' 29\n         DC    CL5'ADR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2A\n         DC    CL5'SDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2B\n         DC    CL5'MDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 2C\n         DC    CL5'DDR',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 2D\n         DC    CL5'AWR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2E\n         DC    CL5'SWR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 2F\n         DC    CL5'LPER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 30\n         DC    CL5'LNER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 31\n         DC    CL5'LTER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 32\n         DC    CL5'LCER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 33\n         DC    CL5'HER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 34\n         DC    CL5'LRER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 35\n         DC    CL5'AXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 36\n         DC    CL5'SXR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 37\n         DC    CL5'LER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 38\n         DC    CL5'CER',AL1(RR),AL1(FLTPT),AL1(0),AL1(CPR),X'02' 39\n         DC    CL5'AER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3A\n         DC    CL5'SER',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3B\n         DC    CL5'MER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 3C\n         DC    CL5'DER',AL1(RR),AL1(FLTPT),AL1(0),AL1(0),X'02' 3D\n         DC    CL5'AUR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3E\n         DC    CL5'SUR',AL1(RR),AL1(FLTPT),AL1(0),AL1(ARITH),X'02' 3F\n         DC    CL5'STH',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 40\n         DC    CL5'LA',AL1(RX),AL1(0),AL1(0),AL1(0),X'04' 41\n         DC    CL5'STC',AL1(RX),AL1(0),AL1(S2),AL1(0),X'04' 42\n         DC    CL5'IC',AL1(RX),AL1(0),AL1(0),AL1(0),X'04' 43\n         DC    CL5'EX',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 44\n         DC    CL5'BAL',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 45\n         DC    CL5'BCT',AL1(RX),AL1(0),AL1(E2+S2),AL1(0),X'04' 46\n         DC    CL5'BC',AL1(CONDBR),AL1(0),AL1(E2),AL1(0),X'04' 47\n         DC    CL5'LH',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 48\n         DC    CL5'CH',AL1(RX),AL1(0),AL1(E2),AL1(CPR),X'04' 49\n         DC    CL5'AH',AL1(RX),AL1(0),AL1(E2),AL1(ARITH),X'04' 4A\n         DC    CL5'SH',AL1(RX),AL1(0),AL1(E2),AL1(ARITH),X'04' 4B\n         DC    CL5'MH',AL1(RX),AL1(0),AL1(E2),AL1(0),X'04' 4C\n         DC    CL5'BAS',AL1(RX),AL1(0),AL1(0),AL1(0),X'04' 4D - XA\n         DC    CL5'CVD',AL1(RX),AL1(0),AL1(E8+S2),AL1(0),X'04' 4E\n         DC    CL5'CVB',AL1(RX),AL1(0),AL1(E8),AL1(0),X'04' 4F\n         DC    CL5'ST',AL1(RX),AL1(0),AL1(E4+S2),AL1(0),X'04' 50\n         DC    CL5'LAE',AL1(RS),AL1(0),AL1(0),AL1(0),X'04'   51\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    CL5'N',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 54\n         DC    CL5'CL',AL1(RX),AL1(0),AL1(E4),AL1(CPR),X'04' 55\n         DC    CL5'O',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 56\n         DC    CL5'X',AL1(RX),AL1(0),AL1(E4),AL1(ZRO8),X'04' 57\n         DC    CL5'L',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 58\n         DC    CL5'C',AL1(RX),AL1(0),AL1(E4),AL1(CPR),X'04' 59\n         DC    CL5'A',AL1(RX),AL1(0),AL1(E4),AL1(ARITH),X'04' 5A\n         DC    CL5'S',AL1(RX),AL1(0),AL1(E4),AL1(ARITH),X'04' 5B\n         DC    CL5'M',AL1(RX),AL1(0),AL1(E4+EPR),AL1(0),X'04' 5C\n         DC    CL5'D',AL1(RX),AL1(0),AL1(E4+EPR),AL1(0),X'04' 5D\n         DC    CL5'AL',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 5E\n         DC    CL5'SL',AL1(RX),AL1(0),AL1(E4),AL1(0),X'04' 5F\n         DC    CL5'STD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 60\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    CL5'MXD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 67\n         DC    CL5'LD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 68\n         DC    CL5'CD',AL1(RX),AL1(FLTPT),AL1(0),AL1(CPR),X'04' 69\n         DC    CL5'AD',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6A\n         DC    CL5'SD',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6B\n         DC    CL5'MD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 6C\n         DC    CL5'DD',AL1(RX),AL1(FLTPT),AL1(0),AL1(0),X'04' 6D\n         DC    CL5'AW',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6E\n         DC    CL5'SW',AL1(RX),AL1(FLTPT),AL1(0),AL1(ARITH),X'04' 6F\n         DC    CL5'STE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 70\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    CL5'LE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 78\n         DC    CL5'CE',AL1(RX),AL1(FLSHT),AL1(0),AL1(CPR),X'04' 79\n         DC    CL5'AE',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7A\n         DC    CL5'SE',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7B\n         DC    CL5'ME',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 7C\n         DC    CL5'DE',AL1(RX),AL1(FLSHT),AL1(0),AL1(0),X'04' 7D\n         DC    CL5'AU',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7E\n         DC    CL5'SU',AL1(RX),AL1(FLSHT),AL1(0),AL1(ARITH),X'04' 7F\n         DC    CL5'SSM',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04' 80\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    CL5'LPSW',AL1(S),AL1(PRIV),AL1(E8),AL1(0),X'04' 82\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' DIAGNOSE 83\n         DC    CL5'WRD',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' 84 \u00acXA\n         DC    CL5'RDD',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' 85 \u00acXA\n         DC    CL5'BXH',AL1(RS),AL1(0),AL1(E2+S2),AL1(0),X'04' 86\n         DC    CL5'BXLE',AL1(RS),AL1(0),AL1(E2+S2),AL1(0),X'04' 87\n         DC    CL5'SRL',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 88\n         DC    CL5'SLL',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 89\n         DC    CL5'SRA',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 8A\n         DC    CL5'SLA',AL1(RS),AL1(0),AL1(0),AL1(ARITH),X'04' 8B\n         DC    CL5'SRDL',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8C\n         DC    CL5'SLDL',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8D\n         DC    CL5'SRDA',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8E\n         DC    CL5'SLDA',AL1(RS),AL1(0),AL1(EPR),AL1(ARITH),X'04' 8F\n         DC    CL5'STM',AL1(RS),AL1(0),AL1(E4+S2),AL1(0),X'04' 90\n         DC    CL5'TM',AL1(SI),AL1(0),AL1(0),AL1(ARITH),X'04' 91\n         DC    CL5'MVI',AL1(SI),AL1(0),AL1(S2),AL1(0),X'04' 92\n         DC    CL5'TS',AL1(S),AL1(0),AL1(0),AL1(0),X'04' 93\n         DC    CL5'NI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 94\n         DC    CL5'CLI',AL1(SI),AL1(0),AL1(0),AL1(CPR),X'04' 95\n         DC    CL5'OI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 96\n         DC    CL5'XI',AL1(SI),AL1(0),AL1(0),AL1(ZRO8),X'04' 97\n         DC    CL5'LM',AL1(RS),AL1(0),AL1(E4),AL1(0),X'04' 98\n         DC    CL5'TRACE',AL1(RS),AL1(0),AL1(0),AL1(0),X'04' 99 - XA\n         DC    CL5'LAM',AL1(RS),AL1(0),AL1(0),AL1(0),X'04' 9A - ESA\n         DC    CL5'STAM',AL1(RS),AL1(0),AL1(0),AL1(0),X'04' 9B - ESA\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9C\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9D\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9E\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' 9F\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A0\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A1\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A2\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A3\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'  A4\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'  A5\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04'  A6\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A7\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A8\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR A9\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR AA\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR AB\n         DC    CL5'STNSM',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' AC\n         DC    CL5'STOSM',AL1(SI),AL1(PRIV),AL1(0),AL1(0),X'04' AD\n         DC    CL5'SIGP',AL1(RS),AL1(PRIV),AL1(0),AL1(0),X'04' AE\n         DC    CL5'MC',AL1(SI),AL1(0),AL1(0),AL1(0),X'04' AF\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    CL5'LRA',AL1(RX),AL1(PRIV),AL1(0),AL1(0),X'04' B1\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' B2\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    CL5'STCTL',AL1(RS),AL1(PRIV),AL1(0),AL1(0),X'04' B6\n         DC    CL5'LCTL',AL1(RS),AL1(PRIV),AL1(E4),AL1(0),X'04' B7\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    CL5'CS',AL1(RS),AL1(0),AL1(E4+EPR),AL1(0),X'04' BA\n         DC    CL5'CDS',AL1(RS),AL1(0),AL1(E4+EPR),AL1(0),X'04' BB\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'04' NOT INSTR\n         DC    CL5'CLM',AL1(RS),AL1(0),AL1(0),AL1(CPR),X'04' BD\n         DC    CL5'STCM',AL1(RS),AL1(0),AL1(S2),AL1(0),X'04' BE\n         DC    CL5'ICM',AL1(RS),AL1(0),AL1(0),AL1(ZRO8),X'04' BF\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    CL5'MVN',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D1\n         DC    CL5'MVC',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D2\n         DC    CL5'MVZ',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' D3\n         DC    CL5'NC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D4\n         DC    CL5'CLC',AL1(SS1),AL1(0),AL1(0),AL1(CPR),X'06' D5\n         DC    CL5'OC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D6\n         DC    CL5'XC',AL1(SS1),AL1(0),AL1(S1),AL1(ZRO8),X'06' D7\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    CL5'MVCK',AL1(SS2),AL1(0),AL1(S1+M1),AL1(ARITH),X'06'\n         DC    CL5'MVCP',AL1(SS2),AL1(0),AL1(S1+M1),AL1(ARITH),X'06'\n         DC    CL5'MVCS',AL1(SS2),AL1(0),AL1(S1+M1),AL1(ARITH),X'06'\n         DC    CL5'TR',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' DC\n         DC    CL5'TRT',AL1(SS1),AL1(0),AL1(0),AL1(ZRO8),X'06' DD\n         DC    CL5'ED',AL1(SS1),AL1(0),AL1(S1),AL1(ARITH),X'06' DE\n         DC    CL5'EDMK',AL1(SS1),AL1(0),AL1(S1),AL1(ARITH),X'06' DF\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' E4\n         DC    CL5' ',AL1(TWO),AL1(0),AL1(0),AL1(0),X'04' E5 - XA\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    CL5'MVCIN',AL1(SS1),AL1(0),AL1(S1),AL1(0),X'06' E8\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    CL5'SRP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' F0\n         DC    CL5'MVO',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F1\n         DC    CL5'PACK',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F2\n         DC    CL5'UNPK',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' F3\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    CL5'ZAP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' F8\n         DC    CL5'CP',AL1(SS2),AL1(0),AL1(0),AL1(CPR),X'06' F9\n         DC    CL5'AP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' FA\n         DC    CL5'SP',AL1(SS2),AL1(0),AL1(S1),AL1(ARITH),X'06' FB\n         DC    CL5'MP',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' FC\n         DC    CL5'DP',AL1(SS2),AL1(0),AL1(S1),AL1(0),X'06' FD\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    XL5'00',AL1(0),AL1(0),AL1(0),AL1(0),X'06' NOT INSTR\n         DC    X'FFFF'                 TABLE END\n         EJECT\n***********************************************************************\n* TWO-BYTE OP CODES                                                   *\n***********************************************************************\nDBLOP    DS    0CL12                   TWO-BYTE OP-CODE TABLE\n         DC    X'0101',CL5'PR ',AL1(E),AL1(0),AL1(0),AL1(0),X'02'\n         DC    X'0102',CL5'UPT',AL1(E),AL1(0),AL1(0),AL1(0),X'02'\n*\n         DC    X'9C00',CL5'SIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9C01',CL5'SIOF',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9D00',CL5'TIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9D01',CL5'CLRIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9E00',CL5'HIO',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9E01',CL5'HDV',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'9F00',CL5'TCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n*\n         DC    X'A400',CL5'VAE',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'A500',CL5'VAER',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'A600',CL5'VMXSE',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n*\n         DC    X'B202',CL5'STIDP',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B203',CL5'STIDC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B204',CL5'SCK',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B205',CL5'STCK',AL1(S),AL1(0),AL1(E8+S2),AL1(0),X'04'\n         DC    X'B206',CL5'SCKC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B207',CL5'STCKC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B208',CL5'SPT',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B209',CL5'STPT',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B20A',CL5'SPKA',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B20B',CL5'IPK',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B20D',CL5'PTLB',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B210',CL5'SPX',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B211',CL5'STPX',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B212',CL5'STAP',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B213',CL5'RRB',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B214',CL5'SIE',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B218',CL5'PC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B219',CL5'SAC',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC    X'B21A',CL5'CFC',AL1(S),AL1(0),AL1(0),AL1(0),X'04'\n*\n         DC  X'B220',CL5'SERVC',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B221',CL5'IPTE',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B222',CL5'IPM',AL1(RRE1),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B223',CL5'IVSK',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B224',CL5'IAC',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B225',CL5'SSAR',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B226',CL5'EPAR',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B227',CL5'ESAR',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B228',CL5'PT',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B229',CL5'ISKE',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B22A',CL5'RRBE',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B22B',CL5'SSKE',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B22C',CL5'TB',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B22D',CL5'DXR',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n*\n         DC   X'B230',CL5'CSCH',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B231',CL5'HSCH',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B232',CL5'MSCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B233',CL5'SSCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B234',CL5'STSCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B235',CL5'TSCH',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B236',CL5'TPI',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B237',CL5'SAL',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B238',CL5'RSCH',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B239',CL5'STCRW',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B23A',CL5'STCPS',AL1(S),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B23B',CL5'RCHP',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC   X'B23C',CL5'SCHM',AL1(E),AL1(PRIV),AL1(0),AL1(0),X'04'\n*\n         DC  X'B240',CL5'BAKR',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B246',CL5'STURA',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B247',CL5'MSTA',AL1(RRE1),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B248',CL5'PALB',AL1(RRE1),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B249',CL5'EREG',AL1(RRE1),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24A',CL5'ESTA',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24B',CL5'LURA',AL1(RRE2),AL1(PRIV),AL1(0),AL1(0),X'04'\n         DC  X'B24C',CL5'TAR ',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24D',CL5'CPYA',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24E',CL5'SAR ',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B24F',CL5'EAR ',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B254',CL5'MVPG',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC  X'B259',CL5'IESBE',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n***********************************************************************\n* THESE ARE MATHEMATICAL ASSIST INSTRUCTIONS DESCRIBED IN SA22-7094   *\n***********************************************************************\n         DC   X'B243',CL5'MADS',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B244',CL5'SQDR',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B245',CL5'SQER',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B280',CL5'LGND',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B281',CL5'LGNE',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B282',CL5'EXPD',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B283',CL5'EXPE',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B284',CL5'LGCD',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n         DC   X'B285',CL5'LGCE',AL1(RRE2),AL1(0),AL1(0),AL1(0),X'04'\n*\n         DC    X'E400',CL5'VLI ',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n*\n         DC    X'E500',CL5'LASP',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n         DC    X'E501',CL5'TPROT',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n         DC    X'E50E',CL5'MVCSK',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n         DC    X'E50F',CL5'MVCDK',AL1(SSE),AL1(PRIV),AL1(0),AL1(0)\n         DC    X'06'\n         DC    X'FFFF'                 TABLE END\n         EJECT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISASM3B": {"ttr": 3329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x00\\xa3\\x00\\xa3\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 163, "newlines": 163, "modlines": 0, "user": "FIELD"}, "text": "         EJECT\n***********************************************************************\n* SVC NAME TABLE - SYSTEM SVCS                                        *\n***********************************************************************\nSVCOP    DS    0CL15                          SVC NAME TABLE\n         DC    AL1(0),CL14'EXCP/XDAP'\nSVCNAML  EQU   *-SVCOP                        LENGTH OF EACH ENTRY\n         DC    AL1(1),CL14'WAIT/WAITR/...'\n         DC    AL1(2),CL14'POST'\n         DC    AL1(3),CL14'EXIT'\n         DC    AL1(4),CL14'GETMAIN'\n         DC    AL1(5),CL14'FREEMAIN'\n         DC    AL1(6),CL14'LINK'\n         DC    AL1(7),CL14'XCTL'\n         DC    AL1(8),CL14'LOAD'\n         DC    AL1(9),CL14'DELETE'\n         DC    AL1(10),CL14'GET/FREEMAIN R'\n         DC    AL1(11),CL14'TIME'\n         DC    AL1(12),CL14'SYNCH'\n         DC    AL1(13),CL14'ABEND'\n         DC    AL1(14),CL14'SPIE'\n         DC    AL1(15),CL14'ERREXCP'\n         DC    AL1(16),CL14'PURGE'\n         DC    AL1(17),CL14'RESTORE'\n         DC    AL1(18),CL14'BLDL/FIND'\n         DC    AL1(19),CL14'OPEN'\n         DC    AL1(20),CL14'CLOSE'\n         DC    AL1(21),CL14'STOW'\n         DC    AL1(22),CL14'OPEN TYPE J'\n         DC    AL1(23),CL14'CLOSE TYPE T'\n         DC    AL1(24),CL14'DEVTYPE'\n         DC    AL1(25),CL14'TRKBAL'\n         DC    AL1(26),CL14'LOCATE, ETC'\n         DC    AL1(27),CL14'OBTAIN'\n         DC    AL1(28),CL14'''RESERVED'''\n         DC    AL1(29),CL14'SCRATCH'\n         DC    AL1(30),CL14'RENAME'\n         DC    AL1(31),CL14'FEOV'\n         DC    AL1(32),CL14'ALLOC'\n         DC    AL1(33),CL14'IOHALT'\n         DC    AL1(34),CL14'MGCR/QEDIT'\n         DC    AL1(35),CL14'WTO/WTOR'\n         DC    AL1(36),CL14'WTL'\n         DC    AL1(37),CL14'SEGLD/SEGWT'\n         DC    AL1(38),CL14'''RESERVED'''\n         DC    AL1(39),CL14'LABEL'\n         DC    AL1(40),CL14'EXTRACT'\n         DC    AL1(41),CL14'IDENTIFY'\n         DC    AL1(42),CL14'ATTACH'\n         DC    AL1(43),CL14'CIRB'\n         DC    AL1(44),CL14'CHAP'\n         DC    AL1(45),CL14'OVLYBRCH'\n         DC    AL1(46),CL14'TTIMER'\n         DC    AL1(47),CL14'STIMER'\n         DC    AL1(48),CL14'DEQ'\n         DC    AL1(49),CL14'''RESERVED'''\n         DC    AL1(50),CL14'''RESERVED'''\n         DC    AL1(51),CL14'SNAP/SDUMP'\n         DC    AL1(52),CL14'RESTART'\n         DC    AL1(53),CL14'RELEX'\n         DC    AL1(54),CL14'DISABLE'\n         DC    AL1(55),CL14'EOV'\n         DC    AL1(56),CL14'ENQ/RESERVE'\n         DC    AL1(57),CL14'FREEDBUF'\n         DC    AL1(58),CL14'RELBUF/REQBUF'\n         DC    AL1(59),CL14'OLTEP'\n         DC    AL1(60),CL14'(E)STAE/STAI'\n         DC    AL1(61),CL14'IKJEGS6A'\n         DC    AL1(62),CL14'DETACH'\n         DC    AL1(63),CL14'CHKPT'\n         DC    AL1(64),CL14'RDJFCB'\n         DC    AL1(65),CL14'''RESERVED'''\n         DC    AL1(66),CL14'BTAMTEST'\n         DC    AL1(67),CL14'''RESERVED'''\n         DC    AL1(68),CL14'SYNAD...'\n         DC    AL1(69),CL14'BSP'\n         DC    AL1(70),CL14'GSERV'\n         DC    AL1(71),CL14'ASGNBFR, ETC'\n         DC    AL1(72),CL14'''NO MACRO'''\n         DC    AL1(73),CL14'SPAR'\n         DC    AL1(74),CL14'DAR'\n         DC    AL1(75),CL14'DQUEUE'\n         DC    AL1(76),CL14'IFBSTAT'\n         DC    AL1(78),CL14'LSPACE'\n         DC    AL1(79),CL14'STATUS'\n         DC    AL1(81),CL14'SETPRT'\n         DC    AL1(82),CL14'     '\n         DC    AL1(83),CL14'SMFWTM'\n         DC    AL1(84),CL14'GRAPHICS'\n         DC    AL1(85),CL14'DDRSWAP'\n         DC    AL1(86),CL14'ATLAS'\n         DC    AL1(87),CL14'DOM'\n         DC    AL1(88),CL14'     '\n         DC    AL1(91),CL14'VOLSTAT'\n         DC    AL1(92),CL14'TCBEXCP'\n         DC    AL1(93),CL14'TGET/TPUT'\n         DC    AL1(94),CL14'STCC'\n         DC    AL1(95),CL14'SYSEVENT'\n         DC    AL1(96),CL14'STAX'\n         DC    AL1(97),CL14'IKJEGS9G'\n         DC    AL1(98),CL14'PROTECT'\n         DC    AL1(99),CL14'DYNALLOC'\n         DC    AL1(100),CL14'IKJEFFIB'\n         DC    AL1(101),CL14'QTIP'\n         DC    AL1(102),CL14'AQCTL (TCAM)'\n         DC    AL1(103),CL14'XLATE'\n         DC    AL1(104),CL14'TOPCTL (TCAM)'\n         DC    AL1(105),CL14'IMGLIB'\n         DC    AL1(107),CL14'MODESET'\n         DC    AL1(109),CL14'ESR TYPE 4'\n         DC    AL1(110),CL14'DSTATUS'\n         DC    AL1(111),CL14'''NO MACRO'''\n         DC    AL1(112),CL14'PGRLSE'\n         DC    AL1(113),CL14'PGFIX/PGFREE/..'\n         DC    AL1(114),CL14'EXCPVR'\n         DC    AL1(116),CL14'ESR TYPE 1'\n         DC    AL1(117),CL14'DEBCHK'\n         DC    AL1(119),CL14'TESTAUTH'\n         DC    AL1(120),CL14'GETMAIN/FREEMAIN'\n         DC    AL1(121),CL14'VSAM'\n         DC    AL1(122),CL14'ESR TYPE 2'\n         DC    AL1(123),CL14'PURGEDQ'\n         DC    AL1(124),CL14'TPIO'\n         DC    AL1(125),CL14'EVENTS'\n         DC    AL1(126),CL14'MSS INTERFACE'\n         DC    AL1(127),CL14' '\n         DC    AL1(128),CL14' '\n         DC    AL1(129),CL14' '\n         DC    AL1(130),CL14'RACHECK'\n         DC    AL1(131),CL14'RACINIT'\n         DC    AL1(132),CL14'RACLIST'\n         DC    AL1(133),CL14'RACDEF'\n         DC    AL1(134),CL14' '\n         DC    AL1(135),CL14' '\n         DC    AL1(136),CL14' '\n         DC    AL1(137),CL14'ESR TYPE 6'\n         DC    AL1(138),CL14'PGSER (XA)'\n         DC    AL1(139),CL14'CVAF...'\n***********************************************************************\n* SVC NAME TABLE - USER SVCS (SVCS BELOW 200 ARE RESERVED FOR IBM)    *\n***********************************************************************\nSVCUSR   DC    AL1(200),CL14'             '    FIRST USER SVC\n         DC    AL1(215),CL14'CICS(HPSVC)  '\n         DC    AL1(216),CL14'CICS(CSVC)   '\n         DC    AL1(235),CL14'             '\n         DC    AL1(238),CL14'TMON CICS    '\n         DC    AL1(240),CL14'             '\n         DC    AL1(241),CL14'             '\n         DC    AL1(242),CL14'CA-7         '\n         DC    AL1(243),CL14'             '\n         DC    AL1(244),CL14'             '\n         DC    AL1(245),CL14'CA-11        '\n         DC    AL1(246),CL14'             '\n         DC    AL1(247),CL14'CA-1 (X)     '\n         DC    AL1(248),CL14'CA-1 (Y)     '\n         DC    AL1(249),CL14'             '\n         DC    AL1(250),CL14'             '\n         DC    AL1(251),CL14'             '\n         DC    AL1(252),CL14'             '\n         DC    AL1(253),CL14'             '\n         DC    AL1(254),CL14'             '\n         DC    AL1(255),CL14'JES3 SDF     '\n         DC    X'FF'                   END OF TABLE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "REQU": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x00(\\x00(\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 40, "newlines": 40, "modlines": 0, "user": "FIELD"}, "text": "         MACRO\n&LABEL   REQU &RF,&RL\n.* MACRO TO GENERATE EQUATES FOR REGISTERS: 0(R0) TO 15(R15).\n.* IF NO OPERAND IS SPECIFIED 0-15 ASSUMED.\n.* TWO OPERANDS MAY BE CODED FOR A SERIES OF REGISTERS.\n.* ERROR CHECKING IS FOR LESS THAN 0 OR GREATER THAN 15.\n.* IN CASE OF ERROR CONDITION, 0-15 ARE GENERATED WITH MNOTE.\n         LCLA  &NUM,&MAX\n         AIF   (T'&RF EQ 'O').ALL\n         AIF   ('&RF' LT '0' OR '&RL' GT '15').OPERR\n         AIF   ('&RL' LT '&RF').OPERR\n         AIF   (N'&SYSLIST NE 2).OPERR\n&NUM     SETA &RF\n&MAX     SETA  &RL\n         AGO   .GEN\n.OPERR   ANOP\n         MNOTE 0,'IMPROPER REGISTER SPECIFICATION. R0-R15 GENERATED.'\n.ALL     ANOP\n&NUM     SETA  0\n&MAX     SETA  15\n.GEN     ANOP\n*****   EQUATES FOR REGISTERS   *****\n.LOOP    ANOP\nR&NUM    EQU   &NUM\n         AIF   ('&NUM' EQ '&MAX').END\n&NUM     SETA  &NUM+1\n         AGO   .LOOP\n.END     ANOP\n         SPACE 2\nMASK80   EQU   X'80'\nMASK40   EQU   X'40'\nMASK20   EQU   X'20'\nMASK10   EQU   X'10'\nMASK08   EQU   X'08'\nMASK04   EQU   X'04'\nMASK02   EQU   X'02'\nMASK01   EQU   X'01'\n         EJECT\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SVLNK": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x13\\x1f\\x00\\x92\\x13\\x1f\\x18\\x12\\x00e\\x00e\\x00\\x00\\xc6\\xc9\\xc5\\xd3\\xc4@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-05-10T00:00:00", "modifydate": "1992-05-10T18:12:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "FIELD"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT217/FILE217.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT217", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}