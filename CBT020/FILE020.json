{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011053000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 529074, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 13, "INMDSNAM": "CBT.V500.FILE020.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 529074, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE020.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\n\\x03'", "DS1TRBAL": "b'\\xbb\\x00'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x005\\x00\\x08\\x006\\x00\\x03\\x00\\x0b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Z\\x00Y\\x01\\x15$/\\x01\\x15$/\\x16\\x00\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf0@@@'", "ispf": {"version": "04.90", "flags": 0, "createdate": "2015-08-30T00:00:00", "modifydate": "2015-08-30T16:00:59", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-490"}, "text": "REGULAR CBT TAPE - VERSION 490    FILE:  020\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT490.FILE020\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 44 MEMBERS COUNTED; CUMULATIVE SIZE IS 4,523 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   08/30/15    16:00:59    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x92\"_\\x00\\x92#\\x0f\\x10\\x14\\x00\\x1c\\x00\\x15\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-08-12T00:00:00", "modifydate": "1992-08-17T10:14:00", "lines": 28, "newlines": 21, "modlines": 0, "user": "FILE020"}, "text": "DOC FOR REXX EXECS (AND WHAT THEY NEED).\n\n       AUTHOR:   ANONYMOUSLY DONATED\n\n       CALL:     SAM GOLOB\n                 SCG SERVICES INC.\n                 1417 LAURELWOOD AVENUE\n                 LAKEWOOD, NJ 08701-1732\n                 (908) 901-0943\n\n   THIS IS A COLLECTION OF HANDY DANDY, QUICK N DIRTY REXX EXECS\n   THAT DO SOME USEFUL THINGS.  TRY EM.  YOU (MAY) LIKE EM.\n\n   THERE ARE TWO ASSEMBLER ROUTINES:  UCBSUBR, RDSNALL\n   THERE IS ONE TSO HELP MEMBER    :  LST#\n   THERE IS ONE ASSEMBLER MACRO    :  REGS\n\n   PLEASE NOTE THAT SOME DISPLACEMENTS IN CONTROL BLOCKS MAY VARY\n   FROM ONE RELEASE OF MVS TO ANOTHER.  IF AN EXEC DOESN'T WORK ON\n   YOUR SYSTEM, THAT MAY BE SOMETHING THAT'S WORTH LOOKING INTO.\n\n   THERE MAY ALSO BE SOME DEPENDENCY ON THE RELEASE OF TSO/E REXX.\n   ANYWAY, ALL THE STUFF IN THIS FILE IS OF THE NATURE THAT THE\n   USER HAS TO TRY AND MAKE IT WORK (IF IT DOESN'T DO SO BY ITSELF).\n\n   GOOD LUCK.\n\n           (DOC BY SBG)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00V\\x01\\x15$/\\x01\\x15$/\\x15X\\x00A\\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2015-08-30T00:00:00", "modifydate": "2015-08-30T15:58:56", "lines": 65, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "            NOTES ABOUT THE EXECS IN THIS FILE\n\n\n0.  These execs were tested on a z/OS 2.1 system, and some of\n    them were found wanting, while others worked.\n\n    Some of the REXX execs in this file didn't have the word\n    \"REXX\" in a comment on the first line.  So this had to be\n    corrected.\n\n1.  ASCB and ASCB2 need to be fixed.\n\n2.  The APFLIST exec is programmed to look for an \"old format\"\n    APF list, from before the list became dynamic.  I have copied\n    LISTAPFT and LISTAPF2 REXX execs from CBT File 275 to give\n    you 2 tools that work for z/OS 2.1.\n\n3.  UCB lookups have been changed.  If you use the UCBSCAN macro\n    in an assembler program, it is possible (probable) that the\n    tool will still work.  But the REXX execs that try and go\n    directly to control blocks, to list UCBs, will probably fail.\n    I have copied the LISTDCQ member here to show you one way to\n    look up UCB stuff nowadays.  This does the ULUT headers only,\n    and will not be completely adequate for going through all the\n    UCB's, so I included the LISTDASD and LISTTAPE execs from File\n    220 to show you how to do that.\n\n4.  EDT**** don't work because the EDT is type 2 or higher.  There\n    is a different way of accessing the EDT now.\n    For a substitute to obtain this information, install MXI from\n    Files 409 and 410, and use the EDT display from there, which\n    is very nice.\n\n5.  The DSCB EXEC works nicely.\n\n6.  DIRPDS works fine.  DASDUCB (when the subroutine has been\n    assembled) works, but needs to be customized for your shop.\n\n7.  LDSITEST appears to work fine.\n\n8.  The DSCB command works very well.\n\n9.  CAXWA command works, except for lining up the output.  Useful\n    anyway.\n\n10. For RDSNTEST, you have to have a compatible WHOHAS command\n    installed.  I haven't found one, so therefore I haven't gotten\n    RDSNTEST to work.  Doesn't mean that you can't fix it.\n\n11. RETSTORE does UCB lookups, and will have to be reworked.\n\n12. SYSBASE works pretty well, except for a few fields.\n\n13. The SUBSYS exec seems to work fine.\n\n14. SSCTLOOK appears to work fine.\n\n\n  So far so good.  Please let me know about your experiences\n  with the things in this file, so that the next guy won't have\n  to fix as much.\n\n  email:  sbgolob@cbttape.org    (Sam Golob - 2015/08/30)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE020": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Z\\x00S\\x01\\x15$/\\x01\\x15$/\\x16\\x00\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf0@@@'", "ispf": {"version": "04.90", "flags": 0, "createdate": "2015-08-30T00:00:00", "modifydate": "2015-08-30T16:00:53", "lines": 14, "newlines": 14, "modlines": 0, "user": "CBT-490"}, "text": "//***FILE 020 IS A COLLECTION OF VERY HANDY TSO/E REXX EXECS        *   FILE 020\n//*           THAT WAS CONTRIBUTED ANONYMOUSLY.  THESE REXX         *   FILE 020\n//*           EXECS DO VARIOUS FUNCTIONS, FROM SIMPLE TO HIGHLY     *   FILE 020\n//*           SOPHISTICATED ONES.  THIS FILE IS WORTH A GOOD        *   FILE 020\n//*           LOOK IF YOU HAVE TSO/E REXX OR WANT TO LEARN MORE     *   FILE 020\n//*           ABOUT WHAT REXX CAN DO FOR YOU.                       *   FILE 020\n//*                                                                 *   FILE 020\n//*       File was gone over at the z/OS 2.1 level bu Sam Golob,    *   FILE 020\n//*       who made several improvements, etc.  Please see member    *   FILE 020\n//*       $$NOTE01 for more detail.             (2015/08/30)        *   FILE 020\n//*                                                                 *   FILE 020\n//*       email:  sbgolob@cbttape.org     or                        *   FILE 020\n//*               sbgolob@attglobal.net                             *   FILE 020\n//*                                                                 *   FILE 020\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "APFLIST": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x91\\x12o\\x00\\x92\\x00o\\x13\"\\x00>\\x00*\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1991-05-06T00:00:00", "modifydate": "1992-01-06T13:22:00", "lines": 62, "newlines": 42, "modlines": 0, "user": "FILE020"}, "text": "/******************************  REXX  *******************************/\n/*     THIS REXX PROGRAM LISTS ALL THE APF LIBRARIES BY BROWSING     */\n/*     THE AUTHORIZED LIBRARY TABLE AT OFFSET 484 IN THE CVT.        */\n/*     THE LAYOUT IS: NUMBER OF ENTRIES    2                         */\n/*                    LEN OF ENTRY         1        )   TIMES        */\n/*                    VOLUME               6        )   NUMBER       */\n/*                    DSN                  VARIABLE )   OF ENTRIES   */\n/*********************************************************************/\nARG     NAME\nCLEAR                                        /* CLEAR SCREEN        */\nCVT     = STORAGE(10,4)                      /* DECIMAL 16 ==> CVT  */\nCCVT    = C2X(CVT)                           /* CHAR CVT ADDRESS    */\nDCVT    = C2D(CVT)                           /* DECIMAL CVT ADDR    */\nDAUTH   = DCVT + 484                         /* DECIMAL AUTH ADDR   */\nAUTH    = D2C(DAUTH,4)                       /* AUTH TAB ADDRESS    */\nCAUTH   = C2X(AUTH)                          /* CHAR AUTH TAB ADDR  */\nADDR1   = STORAGE(CAUTH,4)                   /* ADDRESS OF AUTH TAB */\nCADDR1  = C2X(ADDR1)                         /* CHAR ADDR OF AUTH   */\nDATA    = STORAGE(CADDR1,2)                  /* GET LUMP OF DATA    */\nNUMENT  = SUBSTR(DATA,1,2)                   /* NUMBER OF ENTRIES   */\nDNUMENT = C2D(NUMENT)                        /* CONVERT TO DECIMAL  */\nLEN     = (DNUMENT * 51) + 2                 /* MAX STORAGE POSS    */\nDATA    = STORAGE(CADDR1,LEN)                /* GET LUMP OF DATA    */\nSTART   = 3                                  /* START OF 1ST ENTRY  */\nHEADER  = 'AUTHORIZED LIBRARY LIST'          /* INIT HEADER LINES   */\nHEADER  = CENTER(HEADER,80)                  /* CENTERS IT          */\nSAY     HEADER                               /* PUT IT OUT          */\nHEADER  = 'SEQ  VOLUME  DATASET NAME'        /* INIT HEADER LINES   */\nHEADER  = LEFT(HEADER,56)                    /* FORMAT INTO 56 BYTE */\nHEADER  = CENTER(HEADER,79)                  /* CENTERS IT          */\nSAY     HEADER                               /* PUT IT OUT          */\nHEADER  = '===  ======  ===============' ||, /* INIT HEADER LINES   */\n          '============================='    /*   \"     \"     \"     */\nHEADLEN = LENGTH(HEADER)                     /* GET HEADER LENGTH   */\nHEADER  = CENTER(HEADER,79)                  /* CENTERS THE HEADER  */\nSAY     HEADER                               /* PUT IT OUT          */\nDO I = 1 TO DNUMENT                          /* PROCESS ALL ENTRY   */\n   LEN     = SUBSTR(DATA,START,1)            /* GET 1ST ENTRY LENGTH*/\n   DLEN1   = C2D(LEN)                        /* CONVERT TO DECIMAL  */\n   DLEN2   = DLEN1 - 6                       /* DECREASE BY 6       */\n   VOL     = SUBSTR(DATA,START+1,6)          /* GET VOLUME SERIAL   */\n   DSN     = SUBSTR(DATA,START+7,DLEN2)      /* GET DATASET NAME    */\n   START   = START + 1 + DLEN1               /* BUMP TO NEXT ENTRY  */\n   SEQ     = RIGHT(I,3)                      /* FORMAT SEQ. NUMBER  */\n   HEADER  = SEQ || ' ' VOL || '  ' ||,      /* FORMAT DATA LINE    */\n             DSN                             /*    \"        \"       */\n   HEADER  = LEFT(HEADER,HEADLEN)            /* JUSTIFY TO 56 BYTES */\n   HEADER  = CENTER(HEADER,79)               /* CENTERS IT          */\n   IF   LENGTH(NAME) > 0 THEN                /* ANY PARM ENTERED?   */\n        DO                                   /* YES, CHECK IT OUT   */\n           LEN = LENGTH(NAME)                /* GET PARM LENGTH     */\n           IF  SUBSTR(VOL,1,LEN) = NAME |,   /* IS IT MATCH VOLSER  */\n               SUBSTR(DSN,1,LEN) = NAME THEN /* IS IT MATCH DSNAME  */\n               SAY HEADER                    /* YES, PUT IT OUT     */\n        END                                  /*                     */\n   ELSE SAY    HEADER                        /* NO PARM, PUT ALL OUT*/\nEND                                          /* END OF DO WHILE     */\nSAY                                          /* PUT OUT A BLANK LINE*/\nHEADER  = 'THE NUMBER OF APF LIBRARIES',     /* INIT TOTAL LINE     */\n          'IS ' DNUMENT                      /*                     */\nHEADER  = CENTER(HEADER,79)                  /* CENTERS IT          */\nSAY     HEADER                               /* PUT IT OUT          */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASCB": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x03\\x0f\\x00\\x92\\x03\\x0f\\x106\\x00E\\x00E\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-01-30T00:00:00", "modifydate": "1992-01-30T10:36:00", "lines": 69, "newlines": 69, "modlines": 0, "user": "FILE020"}, "text": "/****************************** REXX *********************************/\n/*   THE REXX IS USED TO PULL OUT ALL JOB RELATED INFORMATION FROM   */\n/*   ADDRESS CONTROL BLOCK (ASCB) AND OTHER RELATED CONTROL BLOCKS   */\n/*   LISTED BELOW:                                                   */\n/*           CVT, ASVT, ASCB, ASXB, TSB, LWA, PSCB, CSCB             */\n/*********************************************************************/\nARG      TAR OPT                               /* PULL IN PARMS      */\nCVT    = STORAGE(10,4)                         /* ADDR CVT           */\nDCVT   = C2D(CVT)                              /* CONVERT TO DECIMAL */\nASVT   = STORAGE(C2X(D2C(DCVT+556)),4)         /* ADDR ASVT          */\nDASVT  = C2D(ASVT)                             /* CONVERT TO DECIMAL */\nASCNT  = C2D(STORAGE(C2X(D2C(DASVT+516)),4))   /* ADDR ASCBCNT       */\nCOUNT  = 0                                     /* INIT THE SEQ-COUNT */\nCLEAR                                          /* CLEAR SCREEN       */\nHEADER = 'A C T I V E    J O B    L I S T'     /*INIT HEADER LINE    */\nHEADER = CENTER(HEADER,80)                     /* CENTERS IT         */\nSAY      HEADER                                /* PUT OUT HEADER LINE*/\nDO I     = 1 TO ASCNT\n   ASCB  = STORAGE(C2X(D2C(DASVT+524+I*4)),4)  /* ADDR ASCB FROM ASVT*/\n   IF   ABBREV(C2X(ASCB),'80')  = 1            /* IS IT VALID?       */\n        THEN ITERATE                           /* NO, LEAVE FOR NEXT */\n   ELSE IF   STORAGE(C2X(ASCB),4) \\= 'ASCB'    /* IS IT ALLOCATED?   */\n             THEN ITERATE                      /* NO, LEAVE FOR NEXT */\n   DASCB = C2D(ASCB)                           /* CONVERT TO DECIMAL */\n   COUNT = COUNT + 1                           /* INCREASE COUNTER   */\n   TSB   = STORAGE(C2X(D2C(DASCB+60)),4)       /* LOAD TSB ADDRESS   */\n   IF    TSB \\= '00000000'X  THEN              /* ANY ADDR IN THERE  */\n         TYPE = TSO                            /* YES, ITS A TSO     */\n   ELSE  TYPE = STC                            /* NO, ASSUME STC     */\n   UID   = STORAGE(C2X(D2C(DASCB+172)),4)      /* LOAD ASCBJOBI ADDR */\n   IF    C2X(UID) = 00000000 THEN              /* IS THERE AN ADDR?  */\n         UID = STORAGE(C2X(D2C(DASCB+176)),4)  /* NO, MUST BE A STC  */\n   ELSE  TYPE = JOB                            /* YES, MAKE TYPE JOB */\n   UID   = STORAGE(C2X(UID),8)                 /* GET JOB/STC NAME   */\n   STAT  = STORAGE(C2X(D2C(DASCB+X2D(66))),1)  /*                    */\n   STAT  = C2X(STAT)                           /*                    */\n   IF    LENGTH(TAR) > 0 THEN                  /* ANY TARGET ENTERED */\n         DO                                    /* DO USERID CHECKING */\n            LN  = LENGTH(TAR)                  /* GET PARM LENGTH    */\n            IF  TAR \\= SUBSTR(UID,1,LN) THEN   /* IS IT MATCH UID?   */\n                ITERATE                        /* NO, GO GET NEXT ONE*/\n         END                                   /*                    */\n   IF    LENGTH(OPT) > 0 &,                    /* ANY OPTION ENTERED */\n         OPT \\= TYPE   THEN                    /* IS IT MATCH TYPE?  */\n         ITERATE                               /* NO, GO GET NEXT ONE*/\n   ASID  = STORAGE(C2X(D2C(DASCB+X2D(24))),2)  /* LOAD ASID IN HEX   */\n   ASID  = C2X(ASID)                           /* CONVERT TO CHAR.   */\n   ASXB  = STORAGE(C2X(D2C(DASCB+108)),4)      /* LOAD ASXB ADDRESS  */\n   DASXB = C2D(ASXB)                           /* CONVERT TO DECIMAL */\n   ACEE  = STORAGE(C2X(D2C(DASXB+X2D(C8))),4)  /* LOAD LAST TCB ADDR */\n   DACEE = C2D(ACEE)                           /* CONVERT TO DECIMAL */\n   ACEID = STORAGE(C2X(D2C(DACEE+X2D(00))),4)  /* LOAD LAST TCB ADDR */\n   CRTID = STORAGE(C2X(D2C(DACEE+X2D(40))),8)  /* LOAD LAST TCB ADDR */\n   CSCB  = STORAGE(C2X(D2C(DASCB+X2D(38))),4)  /* LOAD CSCB ADDRESS  */\n   DCSCB = C2D(CSCB)                           /* CONVERT TO DECIMAL */\n   CHKEY = STORAGE(C2X(D2C(DCSCB+8)),8)        /* GET PROC NAME      */\n   CHCLS = STORAGE(C2X(D2C(DCSCB+16)),8)       /* GET STEP NAME      */\n   LWA   = STORAGE(C2X(D2C(DASXB+20)),4)       /* LOAD LWA ADDRESS   */\n   DLWA  = C2D(LWA)                            /* CONVERT TO DECIMAL */\n   PSCB  = STORAGE(C2X(D2C(DLWA+24)),4)        /* LOAD PSCB ADDRESS  */\n   DPSCB = C2D(PSCB)                           /* CONVERT TO DECIMAL */\n   XFLAG = C2X(STORAGE(C2X(D2C(DPSCB+16)),1))  /* GET PROFILE ATTRIB */\n   OTCNT = RIGHT(COUNT,3)                      /* FORMAT COUNT FIELD */\n   LINE  = OTCNT UID CHCLS C2X(ASCB) ASID,     /* FORMAT OUTPUT LINE */\n           TYPE ' ' STAT ' ' C2X(ACEE) CRTID   /*                    */\n   LINE  = CENTER(LINE,79)                     /* CENTERS THE LINE   */\n   SAY     LINE                                /* PUT OUT TITLE LINE */\nEND\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASCB2": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x916\\x0f\\x00\\x92\\x04?\\x159\\x00S\\x00@\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1991-12-26T00:00:00", "modifydate": "1992-02-12T15:39:00", "lines": 83, "newlines": 64, "modlines": 0, "user": "FILE020"}, "text": "/****************************** REXX *********************************/\n/*   THE REXX IS USED TO PULL OUT ALL JOB RELATED INFORMATION FROM   */\n/*   ADDRESS CONTROL BLOCK (ASCB) AND OTHER RELATED CONTROL BLOCKS   */\n/*   LISTED BELOW:                                                   */\n/*           CVT, ASVT, ASCB, ASXB, TSB, LWA, PSCB, CSCB             */\n/*********************************************************************/\nARG      TAR OPT                               /* PULL IN PARMS      */\nCVT    = STORAGE(10,4)                         /* ADDR CVT           */\nDCVT   = C2D(CVT)                              /* CONVERT TO DECIMAL */\nASVT   = STORAGE(C2X(D2C(DCVT+556)),4)         /* ADDR ASVT          */\nDASVT  = C2D(ASVT)                             /* CONVERT TO DECIMAL */\nASCNT  = C2D(STORAGE(C2X(D2C(DASVT+516)),4))   /* ADDR ASCBCNT       */\nCOUNT  = 0                                     /* INIT THE SEQ-COUNT */\nCLEAR                                          /* CLEAR SCREEN       */\nHEADER = 'A C T I V E    J O B    L I S T'     /*INIT HEADER LINE    */\nHEADER = CENTER(HEADER,80)                     /* CENTERS IT         */\nSAY      HEADER                                /* PUT OUT HEADER LINE*/\nHEADER = 'SEQ JOB NAME   PROC     ' ||,        /* INIT TITLE LINE 1  */\n         'ASCB   ASID TYPE  ST  ATTB'          /*                    */\nHEADER = CENTER(HEADER,79)                     /* CENTERS IT         */\nSAY      HEADER                                /* PUT OUT TITLE LINE */\nHEADER = '=== ======== ======== ==' ||,        /* INIT TITLE LINE 2  */\n         '====== ==== ==== ==== ===='          /*                    */\nHEADER = CENTER(HEADER,79)                     /* CENTERS IT         */\nSAY      HEADER                                /* PUT OUT TITLE LINE */\nDO I     = 1 TO ASCNT\n   ASCB  = STORAGE(C2X(D2C(DASVT+524+I*4)),4)  /* ADDR ASCB FROM ASVT*/\n   IF   ABBREV(C2X(ASCB),'80')  = 1            /* IS IT VALID?       */\n        THEN ITERATE                           /* NO, LEAVE FOR NEXT */\n   ELSE IF   STORAGE(C2X(ASCB),4) \\= 'ASCB'    /* IS IT ALLOCATED?   */\n             THEN ITERATE                      /* NO, LEAVE FOR NEXT */\n   DASCB = C2D(ASCB)                           /* CONVERT TO DECIMAL */\n   COUNT = COUNT + 1                           /* INCREASE COUNTER   */\n   TSB   = STORAGE(C2X(D2C(DASCB+60)),4)       /* LOAD TSB ADDRESS   */\n   IF    TSB \\= '00000000'X  THEN              /* ANY ADDR IN THERE  */\n         TYPE = TSO                            /* YES, ITS A TSO     */\n   ELSE  TYPE = STC                            /* NO, ASSUME STC     */\n   UID   = STORAGE(C2X(D2C(DASCB+172)),4)      /* LOAD ASCBJOBI ADDR */\n   IF    C2X(UID) = 00000000 THEN              /* IS THERE AN ADDR?  */\n         UID = STORAGE(C2X(D2C(DASCB+176)),4)  /* NO, MUST BE A STC  */\n   ELSE  TYPE = JOB                            /* YES, MAKE TYPE JOB */\n   DUID  = C2D(UID)                            /*                    */\n   IF    TYPE = JOB THEN                       /* IS IT A JOB?       */\n         CHKEY= STORAGE(C2X(D2C(DUID+24)),8)   /*                    */\n   ELSE  IF    TYPE = STC THEN                 /* IS IT A STC?       */\n               CHKEY= STORAGE(C2X(D2C(DUID+16)),8)\n         ELSE  CHKEY= STORAGE(C2X(D2C(DUID+08)),8)\n   CHKEY = LEFT(CHKEY,8)                       /* MAKE IT PRINTABLE  */\n   UID   = STORAGE(C2X(UID),8)                 /* GET JOB/STC NAME   */\n   STAT  = STORAGE(C2X(D2C(DASCB+X2D(66))),1)  /*                    */\n   STAT  = C2X(STAT)                           /*                    */\n   IF    LENGTH(TAR) > 0 &,                    /* ANY TARGET ENTERED */\n         TAR \\= '*'   THEN                     /* DO USERID CHECKING */\n         DO                                    /* DO USERID CHECKING */\n            LN  = LENGTH(TAR)                  /* GET PARM LENGTH    */\n            IF  TAR \\= SUBSTR(UID,1,LN) THEN   /* IS IT MATCH UID?   */\n                ITERATE                        /* NO, GO GET NEXT ONE*/\n         END                                   /*                    */\n   IF    LENGTH(OPT) > 0 &,                    /* ANY OPTION ENTERED */\n         OPT \\= TYPE   THEN                    /* IS IT MATCH TYPE?  */\n         ITERATE                               /* NO, GO GET NEXT ONE*/\n   ASID  = STORAGE(C2X(D2C(DASCB+X2D(24))),2)  /* LOAD ASID IN HEX   */\n   ASID  = C2X(ASID)                           /* CONVERT TO CHAR.   */\n   ASXB  = STORAGE(C2X(D2C(DASCB+108)),4)      /* LOAD ASXB ADDRESS  */\n   DASXB = C2D(ASXB)                           /* CONVERT TO DECIMAL */\n   LTCB  = STORAGE(C2X(D2C(DASXB+8)),4)        /* LOAD LAST TCB ADDR */\n   DLTCB = C2D(LTCB)                           /* CONVERT TO DECIMAL */\n   CSCB  = STORAGE(C2X(D2C(DASCB+X2D(38))),4)  /* LOAD CSCB ADDRESS  */\n   DCSCB = C2D(CSCB)                           /* CONVERT TO DECIMAL */\n/* CHKEY = STORAGE(C2X(D2C(DCSCB+8)),8)         * GET PROC NAME      */\n/* CHCLS = STORAGE(C2X(D2C(DCSCB+16)),8)        * GET STEP NAME      */\n   LWA   = STORAGE(C2X(D2C(DASXB+20)),4)       /* LOAD LWA ADDRESS   */\n   DLWA  = C2D(LWA)                            /* CONVERT TO DECIMAL */\n   PSCB  = STORAGE(C2X(D2C(DLWA+24)),4)        /* LOAD PSCB ADDRESS  */\n   DPSCB = C2D(PSCB)                           /* CONVERT TO DECIMAL */\n   XFLAG = C2X(STORAGE(C2X(D2C(DPSCB+16)),1))  /* GET PROFILE ATTRIB */\n   OTCNT = RIGHT(COUNT,3)                      /* FORMAT COUNT FIELD */\n   LINE  = OTCNT UID CHKEY C2X(ASCB) ASID,     /* FORMAT OUTPUT LINE */\n           TYPE ' ' STAT ' ' XFLAG ' '         /*                    */\n   LINE  = CENTER(LINE,79)                     /* CENTERS THE LINE   */\n   SAY     LINE                                /* PUT OUT TITLE LINE */\nEND\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BRODCAST": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00(\\x00\\x91)\\x8f\\x01\\x143\\x0f\\x18V\\x00Q\\x00\\x06\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1991-10-25T00:00:00", "modifydate": "2014-11-26T18:56:28", "lines": 81, "newlines": 6, "modlines": 0, "user": "SBGOLOB"}, "text": "/*==== REXX ==========================================================*/\n/*                                                                    */\n/*        THIS ROUTINE GOES THROUGH ALL THE ASCB'S IN THE SYSTEM AND  */\n/*   PICKS OUT THOSE RELATING TO TSO USERS CURRENTLY ON LINE.  IT     */\n/*   DOES THIS BY LOOKING FOR A NON-ZERO TSB IN AN ACTIVE ASCB AND    */\n/*   IF ONE IS FOUND, IT USES THE JBNS POINTER TO GET THE JOB NAME.   */\n/*   THE SUBROUTINE SENDER MAY BE EASILY MODIFIED TO SENT THE WHAT-   */\n/*   EVER MESSAGES ARE NECESSARY.                                     */\n/*                                                                    */\n/*====================================================================*/\n\nCVT = 10                              /* THE CVT POINTER IS AT HEX 10 */\nCVT = C2D(STORAGE(CVT,4))             /* GET THE CVT ADDRESS          */\nASVT = CVT + 556                      /* ASVT IS IN THE CVT           */\nASVT = C2D(STORAGE(D2X(ASVT),4))      /* GET THE ASVT ADDRESS         */\nNUM = ASVT + 516                      /* POINT TO MAX NUMBER ASIDS    */\nNUM = C2D(STORAGE(D2X(NUM),4))        /* GET THE NUMBER OF ASIDS      */\nASCBPTR = ASVT + 528                  /* POINT TO THE VECTOR TABLE    */\nACTIVE = 0                            /* START WITH 0 ACTIVE JOBS     */\nNTSO = 0                              /* AND 0 ACTIVE TSO USERS       */\nDO I = 1 TO NUM                       /* LOOP THROUGH ALL ASIDS       */\n  ASCB = C2X(STORAGE(D2X(ASCBPTR),4)) /* GET NEXT ASCB POINTER        */\n  X = LEFT(ASCB,1)                    /* HIGH BIT SAYS FREE ASCB      */\n  IF X < 8 THEN DO                    /* ACTIVE ASCB                  */\n    ACTIVE = ACTIVE + 1               /* COUNT ACTIVE ASCB'S          */\n    TSB = X2D(ASCB) + 60              /* GET TSB OFFSET IN ASCB       */\n    TSB = C2X(STORAGE(D2X(TSB),4))    /* GET TSB                      */\n    IF TSB \u00ac= 0 THEN DO               /* ZERO TSB MEANS NOT TSO USER  */\n      ASID = X2D(ASCB) + 36           /* POINT TO ASID FOR KICKS      */\n      ASID = C2X(STORAGE(D2X(ASID),2))/* GET ASID FOR LATER USE       */\n      JOBID = X2D(ASCB) + 176         /* OFFSET TO JOB NAME POINTER   */\n      JOBID = C2X(STORAGE(D2X(JOBID),4)) /* PICK UP JOB NAME POINTER  */\n      JOBID = STORAGE(JOBID,8)        /* PICK UP JOB NAME             */\n      NTSO = NTSO + 1                 /* COUNT ANOTHER ACTIVE TSO USER*/\n      CALL SENDER(JOBID ASID)         /* CALL PROCESSING ROUTINE      */\n      END\n    END\n  ASCBPTR = ASCBPTR + 4               /* POINT TO NEXT ASCB ADDRESS   */\n  END\n\n                                      /* SHOW RESULTS OF OUR LABOR    */\nSAY 'THERE WERE' NUM 'ASCB SLOTS IN THE/TABLE.'\nSAY 'THERE WERE' ACTIVE 'ACTIVE ASCB''S/FOUND.'\nSAY 'THERE WERE' NTSO 'ACTIVE TSO USERS/FOUND.'\nRETURN\n\n/*                 E N D   O F   M A I N   R O U T I N E              */\n\n/*====================================================================*/\n/*                                                                    */\n/*        THIS ROUTINE RECIEVES A CALL FOR EACH CURRENTLY ACTIVE TSO  */\n/*   USER ON THE SYSTEM.  IT CAN EASILY BE MADE TO SEND THE USER ONE  */\n/*   OR MORE LINES OF MESSAGE TEXT.  THE PROGRAM TO DO THIS GREW OUT  */\n/*   OF A DESIRE TO SEND MULTIPLE LINE MESSAGES TO ALL USERS ON THE   */\n/*   SYSTEM WITHOUT THE LONG WAIT BETWEEN LINES EXPERIENCED WHEN THE  */\n/*   SEND WAS USED FOR EACH LINE TO ALL USERS.                        */\n/*        IT APPEARS THAT THERE IS A SYSTEM LIMITATION OF 3 LINES TO  */\n/*   BE QUEUED FOR EACH USER.  ANY MORE THAT THAT SEEMS TO BE LOST    */\n/*   EVEN ON A TRANSMISSION TO A SINGLE USER.                         */\n/*                                                                    */\n/*====================================================================*/\n\nSENDER: PROCEDURE                     /* THIS IS A PROCEDURE          */\n\nPARSE UPPER ARG USERID ASID .         /* PULL SUPPLIED ARGS           */\n\nSAY USERID 'IN ADDRESS SPACE' ASID 'IS RECEIVING THE MESSAGES NOW.'\n\n\"SEND \" ||,\n\"'ANDY CAPALOFF FOUND A RING NEAR THE FOURTH FLOOR ELEVATORS.'\"||,\n     \",USER(\" || USERID || \"),LOGON\"\n\"SEND \" ||,\n\"'PLEASE CONTACT HIM AT EXTENSION 3308 IF IT IS YOURS'\"||,\n     \",USER(\" || USERID || \"),LOGON\"\n\"SEND \" ||,\n\"'OR, IF YOU HAD ANY VISITORS, PLEASE INFORM THEM.'\"||,\n     \",USER(\" || USERID || \"),LOGON\"\n\nRETURN\n\n/*          E N D   O F   S E N D E R   R O U T I N E                 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CARDS": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01J\\x006\\x00\\x913\\x1f\\x01\\x143\\x0f\\x19\\x01\\x01h\\x00!\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.74", "flags": 0, "createdate": "1991-11-27T00:00:00", "modifydate": "2014-11-26T19:01:36", "lines": 360, "newlines": 33, "modlines": 0, "user": "SBGOLOB"}, "text": "/*==== REXX =========================================================*/\n/*                                                                   */\n/*        THIS REXX SIMULATES A GAME OF BLACKJACK BETWEEN A HUMAN    */\n/*   PLAYER AND SEVERAL OTHER PLAYERS ALL CONTROLLED BY THE COMPUTER */\n/*   WHO LEARNS FROM WATCHING THE PLAY WHAT THE PERCENTAGES ARE IN   */\n/*   TAKING ANOTHER CARD ( HIT ) AND STANDING PAT AT A COUNT.  THE   */\n/*   MACHINE SHOULD GET TO PLAY BETTER AS IT ENLARGES ITS DATA BASE. */\n/*                                                                   */\n/*===================================================================*/\nPARSE UPPER ARG VARS\nDO WHILE LENGTH(VARS) < 1\n  SAY 'PLEASE ENTER THE NUMBER OF DECKS YOU WANT TO PLAY WITH.'\n  PARSE UPPER PULL VARS\n  END\nPARSE VAR VARS NDECK VARS\nNCARD = 52 * NDECK\nDO WHILE LENGTH(VARS) < 1\n  SAY 'PLEASE ENTER THE NUMBER OF HANDS TO BE PLAYED.'\n  PARSE UPPER PULL VARS\n  END\nPARSE VAR VARS HANDS VARS\nIF LENGTH(VARS) > 0 THEN PARSE VAR VARS DEBUG VARS\nELSE DEBUG = 0\n\nDO J = 1 TO 4\n  DO I = 1 TO 13\n    K = ( J - 1 ) * 13 + I\n    DO L = 1 TO NDECK\n      M = K + 52 * ( L - 1 )\n      A.M = J I\n      END\n    END\n  END\n\nI = INIT()\nDO I = 1 TO HANDS\n  WON.I = 0\n  BUST.I = 0\n  LOST.I = 0\n  END\n\nDO I = 1 TO 52 * NDECK\n  COPIES = 0\n  PARSE VAR B.I SUIT VAL\n  IF I < 53 THEN DO\n    DO J = 1 TO 52 * NDECK\n      IF B.I = B.J THEN COPIES = COPIES + 1\n      END\n    IF COPIES \u00ac= NDECK THEN ,\n      SAY 'PROBLEM WITH DECK INTEGRITY' COPIES 'COPIES OF' B.I '#' I\n    END\n  END\n\nCARD = 1\nDO FOREVER\n  DO I = 1 TO HANDS\n    HAND.I.1 = B.CARD\n    IF DEBUG > 0 THEN DO\n      PARSE VAR B.CARD SUIT VAL\n      SAY 'HOLE CARD WAS THE' RANK.VAL 'OF' LETTER.SUIT 'FOR HAND' I'.'\n      END\n    J = BUMPCARD()\n    END\n  DO I = 1 TO HANDS\n    HAND.I.2 = B.CARD\n    IF DEBUG > 0 THEN DO\n      PARSE VAR B.CARD SUIT VAL\n      SAY 'FACE CARD WAS THE' RANK.VAL 'OF' LETTER.SUIT 'FOR HAND' I'.'\n      END\n    J = BUMPCARD()\n    HAND.I.0 = 2\n    END\n  DO I = 1 TO HANDS\n    PARSE VAR HAND.I.1 SUIT1 RANK1\n    PARSE VAR HAND.I.2 SUIT2 RANK2\n    SAY 'STARTING TO PROCESS HAND' I 'WITH' RANK.RANK1 'OF' ,\n      LETTER.SUIT1 'AND' RANK.RANK2 'OF' LETTER.SUIT2\n    CUR = VAL(I)\n    IF CUR < 22 THEN COUNT.CUR = COUNT.CUR + 1\n    IF CUR = 21 THEN DO\n      SAY 'TWENTY ONE !!'\n      CUR = 1\n      RAN = 997\n      END\n    ELSE RAN = RANDOM(1,100)\n    DO WHILE ( RAN / 100. > ( OVER.CUR / HIT.CUR ) ) & ( RAN < 101 )\n/*    IF DEBUG > 0 THEN SAY 'RAN/100., OVER.CUR, COUNT.CUR :' RAN / , */\n      SAY 'RAN/100., OVER.CUR, HIT.CUR :' RAN / ,\n        100. OVER.CUR HIT.CUR STRIP(LEFT(OVER.CUR/HIT.CUR,5),'B')\n      SAY 'ELECTING TO HIT WITH' CUR 'POINTS IN HAND.'\n      HIT.CUR = HIT.CUR + 1\n      HAND.I.0 = HAND.I.0 + 1\n      J = HAND.I.0\n      HAND.I.J = B.CARD\n      IF DEBUG > 0 THEN DO\n        PARSE VAR B.CARD SUIT VAL\n        SAY 'PULLED CARD WAS THE' RANK.VAL 'OF' LETTER.SUIT'.'\n        END\n      OLD = BUMPCARD()\n      OLD = CUR\n      CUR = VAL(I)\n      IF CUR > 21 THEN DO\n        SAVEDIG = DIGITS()\n        NUMERIC DIGITS 2\n        SAY 'THIS HAND WENT BUST WITH A PCTAGE OF' RAN/100. 'AGAINST' ,\n          STRIP(LEFT(OVER.OLD/HIT.OLD,5),'B')\n        NUMERIC DIGITS SAVEDIG\n        PARSE VAR WLB.OLD X Y Z\n        Z = Z + 1\n        WLB.OLD = X Y Z\n        RAN = 999\n        OVER.OLD = OVER.OLD + 1\n        CUR = 1\n        END\n      ELSE DO\n        COUNT.CUR = COUNT.CUR + 1\n        IF CUR = 21 THEN DO\n          SAY '21 WITH' HAND.I.0 'CARDS.'\n          RAN = 998\n          CUR = 1\n          END\n        ELSE DO\n          RAN = RANDOM(1,100)\n          END\n        END\n      END\n      IF RAN < 900 THEN DO\n/*   IF DEBUG > 0 THEN SAY 'RAN/100., OVER.CUR, COUNT.CUR :' RAN / , */\n        SAY 'RAN/100., OVER.CUR, COUNT.CUR :' RAN / ,\n        100. OVER.CUR HIT.CUR STRIP(LEFT(OVER.CUR/HIT.CUR,5),'B')\n          SAY 'ELECTING TO STAND PAT WITH' CUR 'POINTS.'\n        STAND.CUR = STAND.CUR + 1\n        END\n    END\n    SAY 'ROUND SUMMARY IS :'\n    WIN = 0\n    DO I = 1 TO HANDS\n      TEMP = VAL(I)\n      IF TEMP > 21 THEN BUST.I = BUST.I + 1\n      ELSE IF TEMP > WIN THEN WIN = TEMP\n      END\n    DO I = 1 TO HANDS\n      TEMP = VAL(I)\n      PARSE VAR WLB.TEMP X Y Z\n      IF TEMP = WIN THEN DO\n        X = X + 1\n        WLB.TEMP = X Y Z\n        WON.I = WON.I + 1\n        END\n      ELSE DO\n        LOST.I = LOST.I + 1\n        IF TEMP < 22 THEN DO\n          Y = Y + 1\n          WLB.TEMP = X Y Z\n          END\n        END\n      SAY 'HAND' I 'HAD' HAND.I.0 'CARDS AND A COUNT OF' TEMP ' *' ,\n        WON.I LOST.I BUST.I WLB.TEMP '*' COUNT.TEMP OVER.TEMP HIT.TEMP ,\n          STAND.TEMP\n      END\n  END\n\nSAY 'LEAVING MAIN PROGRAM.'\nEXIT\n\n/*           E N D   O F   M A I N   R O U T I N E                   */\n\nVAL: PROCEDURE EXPOSE HAND.\nPARSE ARG N\n\nVAL = 0\nACE = 0\nDO I = 1 TO HAND.N.0\n  PARSE VAR HAND.N.I SUIT RANK\n  IF RANK < 10 THEN VAL = VAL + RANK\n  ELSE VAL = VAL + 10\n  IF RANK = 1 THEN ACE = ACE + 1\n  END\nDO WHILE ( ACE > 0 ) & VAL < 12\n  ACE = ACE - 1\n  VAL = VAL + 10\n  END\n\nRETURN VAL\n\n/*                                                                   */\n\nBUMPCARD: PROCEDURE EXPOSE A. B. CARD NCARD NDECK COUNT. OVER. WLB. ,\n                           HIT. STAND.\n\nCARD = CARD + 1\nIF CARD > NCARD THEN DO\n  CARD = 1\n  I = SHUFFLE()\n  END\n\nRETURN 0\n\n/*                                                                   */\n\nSHUFFLE: PROCEDURE EXPOSE A. B. NDECK COUNT. OVER. WLB. HIT. STAND.\n\nSAY ' '\nSAY 'SHUFFLING A NEW SET OF DECKS.'\nSAY ' '\n\"ALLOC DA('TSOCGLA.EXEC(CARDS)') F(OUTPUT) SHR REU\"\nIF RC \u00ac= 0 THEN DO\n  SAY 'UNABLE TO ALLOCATE FILE FOR STATISTICAL UPDATE.'\n  EXIT\n  END\n\nDO I = 52 * NDECK TO 1 BY -1\n  RAN = RANDOM(1,I)\n  B.I = A.RAN\n  A.RAN = A.I\n  END\n\nNREC = 0\n\nRC = 0\nJ = 1\nSEARCH = 'COUNT.'J '='\nLEN = LENGTH(SEARCH)\nA = 'COUNT.'\nREP =\nDO WHILE RC = 0\n  'EXECIO 1 DISKRU OUTPUT'\n  IF RC \u00ac= 0 THEN IF ( RC \u00ac= 2 ) | ( J < 21 ) THEN IOERR(1)\n    ELSE LEAVE\n  NREC = NREC + 1\n  PARSE PULL LINE\n  LINE = STRIP(LINE,'B')\n  IF LEFT(LINE,LEN) = SEARCH THEN DO\n    INST = \"LINE = '\" SEARCH VALUE(A||J) \"'\"\n    INTERPRET INST\n    IF A = 'COUNT.' THEN DO\n      A = 'WLB.'\n      TEMP = 'COUNT.'J '=' COUNT.J OVER.J HIT.J STAND.J\n      IF ( HIT.J > 0 ) & ( OVER.J > 0 ) THEN DO\n        PCT = 100 * OVER.J / HIT.J\n        IF PCT < 10 THEN PCT = '0'PCT\n        TEMP = TEMP STRIP(LEFT(PCT,5),'B') \"'%'\"\n        END\n      PUSH TEMP\n      'EXECIO 1 DISKW OUTPUT'\n      IF RC \u00ac= 0 THEN IOERR(2)\n      END\n    ELSE DO\n      PCT = OVER.J / HIT.J\n      PCT = LEFT(PCT,5)\n      TEMP = ' ' J OVER.J COUNT.J PCT WLB.J\n      IF ( DEBUG > 0 ) & ( LENGTH(TEMP) + LENGTH(REP) > 80 ) THEN DO\n        SAY REP\n        REP =\n        END\n      ELSE REP = REP || TEMP\n      J = J + 1\n      A = 'COUNT.'\n      END\n    SEARCH = A||J '='\n    LEN = LENGTH(SEARCH)\n    IF LEFT(LINE,4) = ' WLB' THEN DO\n      PUSH LINE\n      'EXECIO 1 DISKW OUTPUT'\n      IF RC \u00ac= 0 THEN IOERR(2)\n      END\n    END\n  END\nIF ( DEBUG > 0 ) & ( LENGTH(REP) > 1 ) THEN SAY REP\n\n'EXECIO 0 DISKW OUTPUT (FINIS)'\n'FREE F(OUTPUT)'\n\nRETURN 0\n\n/*                                                                   */\nIOERR: PROCEDURE EXPOSE RC NREC\n\nPARSE ARG LOC\nSAY 'IOERROR DETECTED AT' LOC  'FURTHER INVESTIGATION IS NEEDED.'\nSAY 'RC WAS' RC 'AFTER' NREC 'RECORDS.'\nEXIT\n\n/*                                                                   */\n\nINIT: PROCEDURE EXPOSE NDECK COUNT. OVER. LETTER. WLB. RANK. A. B. ,\n                       HIT. STAND.\n\n/*   COUNT HAS THE NUMBERS FOR COUNT.I OVER.I HIT.I  STAND.I   */\n/*   WLB   HAS THE NUMBERS FOR WON.I   LOST.I BUST.I           */\n\nCOUNT.1 = 1 0 1 0\n WLB.1 = 0 0 0\nCOUNT.2 = 1 0 1 0\n WLB.2 = 0 0 0\nCOUNT.3 = 1 0 1 0\n WLB.3 = 0 0 0\nCOUNT.4 = 24 0 24 0\n WLB.4 = 0 0 0\nCOUNT.5 = 17 0 17 0\n WLB.5 = 0 0 0\nCOUNT.6 = 42 0 42 0\n WLB.6 = 0 0 0\nCOUNT.7 = 55 0 55 0\n WLB.7 = 0 0 0\nCOUNT.8 = 71 0 71 0\n WLB.8 = 0 0 0\nCOUNT.9 = 69 0 69 0\n WLB.9 = 0 0 0\nCOUNT.10 = 174 0 174 0\n WLB.10 = 0 0 0\nCOUNT.11 = 128 0 128 0\n WLB.11 = 0 0 0\nCOUNT.12 = 394 113 284 110 39.78 '%'\n WLB.12 = 10 100 113\nCOUNT.13 = 363 117 246 117 47.56 '%'\n WLB.13 = 14 103 117\nCOUNT.14 = 352 145 230 122 63.04 '%'\n WLB.14 = 21 101 145\nCOUNT.15 = 503 195 286 217 68.18 '%'\n WLB.15 = 47 170 195\nCOUNT.16 = 404 164 236 168 69.49 '%'\n WLB.16 = 37 131 164\nCOUNT.17 = 424 179 236 188 75.84 '%'\n WLB.17 = 58 130 179\nCOUNT.18 = 714 318 388 326 81.95 '%'\n WLB.18 = 132 194 318\nCOUNT.19 = 532 237 293 239 80.88 '%'\n WLB.19 = 112 127 237\nCOUNT.20 = 1345 647 680 665 95.14 '%'\n WLB.20 = 555 109 647\nCOUNT.21 = 335 0 1 0\n WLB.21 = 334 0 0\n\nLETTER.1 = CLUBS\nLETTER.2 = DIAMONDS\nLETTER.3 = HEARTS\nLETTER.4 = SPADES\n\nRANK.1 = ACE\nRANK.2 = 2\nRANK.3 = 3\nRANK.4 = 4\nRANK.5 = 5\nRANK.6 = 6\nRANK.7 = 7\nRANK.8 = 8\nRANK.9 = 9\nRANK.10 = 10\nRANK.11 = JACK\nRANK.12 = QUEEN\nRANK.13 = KING\n\nDO I = 1 TO 21\n  PARSE VAR COUNT.I COUNT.I OVER.I HIT.I STAND.I J\n  END\n\nI = SHUFFLE()\n\nRETURN 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CAXWA": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x05\\x00\\x92\\x02\\x0f\\x01\\x143\\x0f\\x19\\x03\\x00n\\x00E\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1992-01-20T00:00:00", "modifydate": "2014-11-26T19:03:05", "lines": 110, "newlines": 69, "modlines": 0, "user": "SBGOLOB"}, "text": "/***** REXX **********************************************************/\n/*                                                                   */\n/*                    SYSTEM CAXWA TABLE LOOKUP                      */\n/*  THIS REXX PROGRAM IS USED TO MAP ALL OPEN USER CATAOLGS AND      */\n/*  SHOW RELATED UCB INFORMATION FROM THE DASD THEY RESIDE UPON.     */\n/*                                                                   */\n/*===================================================================*/\n/*                      CONTROL BLOCK CHAINING                       */\n/*  AMCBS      : CVT+X'100' ACCESS METHOD CONTROL BLOCK  (CVTCBSP)   */\n/*  CAXWA     -> AMCBS+X'14' CATALOG WORK AREA                       */\n/*  CAXNEXT   -> CAXWA+X'04' NEXT CAXWA ENTRY                        */\n/*  CATFLAG1  -> CAXWA+X'08' CATALOG FLAG BYTE 1                     */\n/*   X....... -> BUILD REQUESTED                                     */\n/*   .X...... -> OPEN IN CONTROL                                     */\n/*   ..X..... -> CLOSE IN CONTROL                                    */\n/*   ...X.... -> END OF VOLUME IN CONTROL                            */\n/*   ....X... -> I/O SUPPORT COMPLETED                               */\n/*   .....X.. -> 1:MASTER CATALOG, 0:USER CATALOG                    */\n/*   ......X. -> CATALOG MANAGEMENT IN CONTROL                       */\n/*   .......X -> SCHEDULER IN CONTROL                                */\n/*  CATFLAG2  -> CAXWA+X'09' CATALOG FLAG BYTE 2                     */\n/*   X....... -> CATALOG DELETED                                     */\n/*   .X...... -> NO DDNAME FOUND                                     */\n/*   ..X..... -> UNABLE TO GET CORE                                  */\n/*   ...X.... -> I/O ERROR                                           */\n/*   ....X... -> RPL CLEAN UP REQUESTED                              */\n/*   .....X.. -> FREE CAXWA IF ERROR                                 */\n/*   ......X. -> RECOVERABLE CATALOG                                 */\n/*   .......X -> VOLUME TIME STAMP UPDATED                           */\n/*  CATFLAG3  -> CAXWA+X'0A' CATALOG FLAG BYTE 3                     */\n/*   X....... -> CRA ALT TIOT EXIST                                  */\n/*   .X...... -> CRA NOT EXIST                                       */\n/*   ..X..... -> RESERVED                                            */\n/*   ...X.... -> CATALOG IS RAC DEFINED                              */\n/*   ....X... -> NO CATALOG PSWD DEFINED                             */\n/*   .....XX. -> 01 NO UPDATE 10 UPDATE                              */\n/*   .......X -> RESERVED                                            */\n/*   CATACT   -> CAXWA+X'0B' CATALOG ACTIVITY                        */\n/*   X....... -> IN STORAGE                                          */\n/*   .X...... -> ALLOCATED                                           */\n/*  CATUCBP   -> CAXWA+X'1C' ADDRESS OF CATALOG UCB                  */\n/*  CATNAME   -> CAXWA+X'34' CATALOG NAME FIELD 44 BYTES             */\n/*                                                                   */\n/*********************************************************************/\nARG     OPTION                                /* PULL IN OPTION PARM */\nCLEAR                                         /* CLEAR SCREEN        */\nCVT     = STORAGE(10,4)                       /* ADDR CVT            */\nDCVT    = C2D(CVT)                            /* CONVERT TO DECIMAL  */\nAMCB    = STORAGE(C2X(D2C(DCVT+X2D(100))),4)  /* ADDR AMCB FROM CVT  */\nDAMCB   = C2D(AMCB)                           /* CONVERT TO DECIMAL  */\nCAXWA   = STORAGE(C2X(D2C(DAMCB+X2D(14))),4)  /* ADDR CAXWA FROM AMCB*/\nHEADER  = 'ACTIVE CATALOG TABLE LOOKUP'       /* INIT HEADER LINE    */\nHEADER  = CENTER(HEADER,80)                   /* CENTERS IT          */\nIF   SYSVAR(SYSNEST) = NO THEN                /* CALL BY PROGRAM?    */\n     SAY     HEADER                           /* NO, PUT OUT HEADER  */\nELSE DO                                       /* YES, INIT RETURN    */\n        RETC = 0                              /* YES, INIT RETURN CNT*/\n        RETD = ''                             /* YES, INIT RETURN    */\n     END                                      /* YES, INIT RETURN    */\nHEADER  = '=============================' ||, /* INIT HEADER LINE    */\n          '=================================' /*   \"    \"     \"   \"  */\nHEADER  = CENTER(HEADER,79)                   /* CENTERS IT          */\nIF   SYSVAR(SYSNEST) = NO THEN                /* CALL BY PROGRAM?    */\n     SAY     HEADER                           /* NO, PUT OUT HEADER  */\nDO   I  = 1 BY 1 UNTIL CAXWA = '00000000'X        /* SCAN CAXWA      */\n     DCAX    = C2D(CAXWA)                         /* CONVERT TO DEC. */\n     CAXNEXT = STORAGE(C2X(D2C(DCAX+X2D(04))),4)  /* ADDR NEXT CAXWA */\n     CATFLAG = STORAGE(C2X(D2C(DCAX+X2D(08))),1)  /* MAP CATALOG TYPE*/\n     CATUCBP = STORAGE(C2X(D2C(DCAX+X2D(1C))),4)  /* MAP CATALOG UCBP*/\n     CATNAME = STORAGE(C2X(D2C(DCAX+X2D(34))),44) /* MAP CATALOG NAME*/\n     CATNAME = STRIP(CATNAME,T,' ')               /* STRIP TRAILER SP*/\n     DUCB    = C2D(CATUCBP)                       /* CONVERT TO DEC. */\n     CATADDR = STORAGE(C2X(D2C(DUCB+X2D(0D))),3)  /* MAP CATALOG ADDR*/\n     CATVOLS = STORAGE(C2X(D2C(DUCB+X2D(1C))),6)  /* MAP CATALOG VOLS*/\n     IF    BITAND(CATFLAG,'04'X) = '04'X THEN     /* IS IT MASTER CAT*/\n           TYPE = MCAT                            /* YES SAY IT      */\n     ELSE  TYPE = UCAT                            /* MAP UCB TYPE 2  */\n     LINE = '|  UCB=' || CATADDR ' VOL=' ||,      /* INIT DATA LINE  */\n            CATVOLS ' DSN=' || CATNAME ||,        /*   \"   \"    \"    */\n            '  TYPE=' || TYPE || '  |'            /*   \"   \"    \"    */\n     LINE = CENTER(LINE,79)                   /* CENTERS IT          */\n     IF    SYSVAR(SYSNEST) = NO  &,           /* CALL BY TERMINAL    */\n           (LENGTH(OPTION) = 0   |,           /* AND NO PARM ENTERED */\n            OPTION = TYPE)    THEN            /* OR A MATCH WAS FOUND*/\n            SAY  LINE                         /* NO, PUT OUT THE LINE*/\n     ELSE  IF   OPTION = TYPE |,              /* NO, IS TYPE MATCH   */\n                LENGTH(OPTION) = 0 THEN       /* OR ALL REQUESTED    */\n                DO                            /* YES, DO RETURN PROC */\n                   LINE =  CATVOLS CATADDR,   /* YES, PUT OUT LINE   */\n                           CATNAME            /*         \"           */\n                   RETC = RETC + 1            /* INCREASE RETC BY 1  */\n                   RETD = RETD || LINE        /* SAVE RETURN DATA    */\n                END                           /* END OF PROCESS      */\n     CAXWA   = CAXNEXT                        /* BUMP TO NEXT CAXWA  */\nEND                                           /* END OF PROCESS      */\nHEADER  = '=============================' ||, /* INIT HEADER LINE    */\n          '=================================' /*   \"    \"     \"   \"  */\nHEADER  = CENTER(HEADER,79)                   /* CENTERS IT          */\nIF   SYSVAR(SYSNEST) = NO THEN                /* ANY OPTION ENTERED  */\n     DO                                       /* DO NOPARM PROCESS   */\n        SAY     HEADER                        /* PUT OUT HEADER 1    */\n        RETURN(0)                             /* RETURN COND=0       */\n     END                                      /* END OF NOPARM PROC  */\nELSE DO                                       /* YES, RETURN MATCHED */\n        RETC = LEFT(RETC,4)                   /* FORMAT RETURN COUNT */\n        RETD = RETC || RETD                   /* CONCAT COUNT & DATA */\n        IF   SYSVAR(SYSNEST) = NO THEN        /* CALLED BY OTHER PGM */\n             RETURN(0)                        /* NO RETURN 0         */\n        ELSE RETURN(RETD)                     /* RETURN THE REQ-DATA */\n     END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASDUCB": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x916\\x0f\\x00\\x92\"_\\x18\\x06\\x00k\\x00<\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1991-12-26T00:00:00", "modifydate": "1992-08-12T18:06:00", "lines": 107, "newlines": 60, "modlines": 0, "user": "FILE020"}, "text": "/*===REXX============================================================*/\n/*                                                                   */\n/*        THIS REXX CALLS AN ASSEMBLY LANGUAGE SUBROUTINE WHICH      */\n/*   SCANS THE SYSTEM FOR ALL DASD UCB'S.  THE REXX THEN MAKES DD    */\n/*   CARDS FOR EACH VOLUME ONLINE.  THE DD CARDS ARE PART OF A JOB   */\n/*   STREAM TO SCAN EACH VTOC FOR DFSMS INITIALIZATION.              */\n/*                                                                   */\n/*===================================================================*/\n\nTYPEDEV = 'DASD'                        /* WE ONLY WANT DISK UNITS   */\n\nPARSE UPPER ARG INPUT                   /* CHECK COMMAND LINE INPUT  */\n\nFILEOUT: ,\nDO WHILE LENGTH(INPUT) = 0              /* IF NONE, THEN ASK FOR IT  */\n  SAY 'ENTER OUTPUT FILE NAME :'        /* QUESTION                  */\n  PARSE UPPER PULL INPUT WASTE          /* ANSWER                    */\n  END\n'ALLOC F(OUTPUT) DA('INPUT') OLD REU'   /* ALLOCATE FILE             */\n\nIF RC \u00ac= 0 THEN DO                      /* CHECK RESULT              */\n  SAY 'UNABLE TO ALLOCATE THAT FILE FOR OUTPUT.  PLEASE TRY AGAIN.'\n  INPUT =                               /* FAKE NO INPUT             */\n  SIGNAL FILEOUT                        /* GO TRY AGAIN              */\n  END\nCOUNT =  0                              /* INITIALIZE LOCAL COUNTERS */\nONLINE = 0\n\nJOB1 = '//USER     JOB'                 /* SET UP FIXED JCL          */\nJOB2 = '//STEP1   EXEC PGM=ARCVTOCR'\nJOB3 = '//STEPLIB  DD  DISP=SHR,DSN=USER.DFHSM.LOAD'\nJOB4 = '//SYSUDUMP DD  SYSOUT=*'\nJOB5 = '//SYSPRINT DD  SYSOUT=*'\nJOB6 = '//SYSAUDIT DD  DISP=(,CATLG),UNIT=SYSDA,DCB=BLKSIZE=23384,'\nJOB7 = '//             SPACE=(CYL,(X,Y),RLSE),DSN=USER.AUDIT.DATA'\n\nDO I = 1 TO 7                           /* OUTPUT FIXED JCL          */\n  J = OUTER(VALUE(JOB||I))              /* OUTPUT EACH LINE          */\n  END\n\nDO WHILE GETUCB() = 0                   /* PROCESS TIL NO MORE UNITS */\n  TEMP = SUBSTR(X,4,1)                  /* LOOK AT 4TH BYTE, UCBSTAT */\n  TEMP = C2D(TEMP)                      /* CVT TO HEX DIGITS         */\n  COUNT = COUNT + 1                     /* BUMP TOTAL DASD COUNT     */\n\n  IF TEMP > 127 THEN DO                 /* LOOK FOR ONLINE STATUS    */\n    DEV = C2X(SUBSTR(X,20,1))           /* GET UNIT TYPE BYTE        */\n    IF DEV = '0E' THEN DEV = '3380'     /* ASSIGN DEVICE 3380        */\n    ELSE IF DEV = '0F' THEN DEV = '3390'/* ASSIGN DEVICE 3390        */\n    ELSE DEV = 'SYSDA'                  /* DEFAULT IS 'SYSDA'        */\n    OUT = '//'SUBSTR(X,29,6) || ,       /* USE VOL SER AS DD NAME    */\n      '   DD  DISP=SHR,UNIT='DEV || ,   /* PUT DEVICE TYPE IN CARD   */\n      ',VOL=SER='SUBSTR(X,29,6) || ,    /* USE VOL SER PROPERLY TOO  */\n      ',DCB=BLKSIZE=96'                 /* DCB INFO COMPLETES CARD   */\n    J = OUTER(OUT)                      /* WRITE IT OUT              */\n    ONLINE = ONLINE + 1                 /* BUMP COUNT OF ONLINE VOLS */\n    END\n  END\n\nSAY COUNT 'UNITS FOUND WITH' ONLINE 'UNITS ONLINE.' /* FINAL COUNT   */\n\nEXIT\n\n/***             E N D   O F   M A I N   R O U T I N E             ***/\n\n/*===================================================================*/\n/*                                                                   */\n/*        PROCEDURE TO CALL THE UCB ACQUISITION SUBROUTINE AND SET   */\n/*   THE RETURN CODE TO ZERO IF ANOTHER UCB WAS RETURNED OR ELSE     */\n/*   SETTING THE RETURN CODE TO NON-ZERO IF THE LAST UCB WAS FOUND.  */\n/*                                                                   */\n/*===================================================================*/\n\nOUTER: PROCEDURE\n\nPARSE ARG CHARS\n\nPUSH CHARS\n'EXECIO 1 DISKW OUTPUT'\nIF RC \u00ac= 0 THEN SIGNAL ERROR\nRETURN 0\n\nERROR:\nSAY 'ERROR WRITING OUTPUT FILE.  RETURN CODE WAS' RC'.'\nEXIT 4\n\n/***         E N D   O F   O U T P U T   R O U T I N E             ***/\n\n/*===================================================================*/\n/*                                                                   */\n/*        PROCEDURE TO CALL THE UCB ACQUISITION SUBROUTINE AND SET   */\n/*   THE RETURN CODE TO ZERO IF ANOTHER UCB WAS RETURNED OR ELSE     */\n/*   SETTING THE RETURN CODE TO NON-ZERO IF THE LAST UCB WAS FOUND.  */\n/*                                                                   */\n/*===================================================================*/\n\nGETUCB: PROCEDURE EXPOSE X COUNT TYPEDEV\n\nCALL UCBSUBR COUNT,X,TYPEDEV          /* CALL SUBROUTINE           */\nPARSE VAR RESULT X                    /* PICK UP RESULT (UCB+WORK) */\nIF C2X(LEFT(X,2)) = 'FFFF' THEN ,     /* IF THERE WERE NO MORE ... */\n  RETURN 4                            /* RETURN A CODE OF 4        */\nIF C2X(LEFT(X,2)) = 'FFFE' THEN DO    /* CHECK FOR EROR INDICATOR  */\n  SAY SUBSTR(X,3)                     /* AND PRINT ERROR MESSAGE   */\n  EXIT                                /* AND EXIT ENTIRELY IF SO   */\n  END\nRETURN 0                              /* ELSE RETURN A CODE OF 0   */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIRPDS": {"ttr": 781, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x91#\\x9f\\x00\\x92\"_\\x18\\x07\\x00\\x86\\x00L\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1991-08-27T00:00:00", "modifydate": "1992-08-12T18:07:00", "lines": 134, "newlines": 76, "modlines": 0, "user": "FILE020"}, "text": "/*====REXX============================================================*/\n/*                                                                    */\n/*        THIS REXX READS THE DIRECTORY OF A PDS.  IT WILL PRINT OUT  */\n/*   ALL THE MEMBER NAMES (8 PER LINE).  IF THERE IS A PARAMETER IN   */\n/*   THE COMMAND, THE FIRST ONE WILL BE USED AS THE DATA SET NAME,    */\n/*   IF THERE IS A SUBSEQUENT PARM OF DUMP, ALL THE DIRECTORY BLOCKS  */\n/*   WILL BE DUMPED IN THE RAW STATE ALSO.                            */\n/*        THE REXX CAN ALSO EASILY BE MODIFIED TO PRODUCE JCL OR A    */\n/*   CLIST OR REXX TO DO SOME PROCESSING FOR EACH MEMBER OF THE PDS.  */\n/*                                                                    */\n/*====================================================================*/\n\nPARSE UPPER ARG INPUT                    /* GET COMMAND LINE PARMS    */\nCALL OPENER(INPUT)                       /* GET FILES OPEN            */\n\nMEML =                                   /* SET UP A NULL STRING      */\nDUMP = 'N'                               /* DEFAULT IS 'NO'           */\nDO WHILE LENGTH(INPUT) > 0               /* PARSE UNITL NO MORE ARGS  */\n  PARSE VAR INPUT A INPUT                /* PARSE NEXT ARGUMENT       */\n  IF A = \"DUMP\" THEN DUMP = \"Y\"          /* REMEMBER A DUMP REQUEST   */\nEND\n\nNINP = 0                                 /* INITIALIZE COUNTERS       */\nMEM = 0\nEND = 0\n\nDO FOREVER                               /* PROCESS ALL DIR BLOCKS    */\n  'EXECIO 1 DISKR INPUT'                 /* QUEUE FILE INPUT LINE     */\n  IF RC \u00ac= 0 THEN LEAVE                  /* EXIT IF NON 0 RETURN CODE */\n  NINP = NINP + 1                        /* COUNT ANOTHER RECORD READ */\n  PARSE PULL LINE                        /* PULL RECORD FROM STACK    */\n  IF DUMP = 'Y' THEN DO                  /* WAS A RAW DUMP REQUESTED? */\n    SAY ' '\n    SAY 'RECORD' NINP 'READ SUCCESSFULLY.'\n    BLOCK = C2X(SUBSTR(LINE,1,2))        /* GET BLOCK LENGTH (HEX)    */\n    BLOCK = X2D(BLOCK)                   /* MAKE IT DECIMAL           */\n    SAY 'USEFUL BLOCK LENGTH IS' BLOCK   /* REPORT BLOCK LENGTH       */\n    DO J = 0 TO 15                       /* PROCESS 16 LINES PER REC  */\n      TEMP =                             /* MAKE HEX PART EMPTY       */\n      CHARS =                            /* MAKE EBCDIC PART EMPTY    */\n      DO I = 1 TO 16                     /* 16 BYTES PER LINE         */\n        C = SUBSTR(LINE,J*16+I,1)        /* PICK OF NEXT CHAR         */\n        IF C < ' ' THEN CHARS = CHARS' ' /* INSERT EBCDIC IN OUTPUT   */\n        ELSE CHARS = CHARS || C          /* OR SPACE IF TOO LOW       */\n        X = C2X(C)                       /* CONVERT TO HEXADECIMAL    */\n        TEMP = TEMP || ' ' || X          /* PUT HEX IN HEX PART       */\n      END\n      SAY RIGHT(D2X(4096+J*16),3) || ' ' || TEMP || ' ' || CHARS\n    END\n  END\n  IF DUMP \u00ac= 'Y' THEN DO                 /* IF WE DIDNT BEFORE ...    */\n    BLOCK = C2X(SUBSTR(LINE,1,2))        /* GET BLOCK LENGTH (HEX)    */\n    BLOCK = X2D(BLOCK)                   /* MAKE IT DECIMAL           */\n  END\n  LINE = SUBSTR(LINE,3)                  /* DROP BLOCK LENGTH         */\n  BLOCK = BLOCK - 2                      /* DECREASE REMAINING BLOCK  */\n  DO WHILE ( BLOCK > 0 ) & ( END = 0 )   /* LOOP THROUGH BLOCK        */\n    NAME = SUBSTR(LINE,1,8)              /* PICK OFF MEMBER NAME      */\n    IF NAME = 'FFFFFFFFFFFFFFFF'X THEN , /* TEST FOR LAST ENTRY MARK  */\n      IF DUMP = 'N' THEN SIGNAL NOMORE   /* IF WE'RE NOT DUMPING QUIT */\n      ELSE DO\n        END = 1                          /* ELSE JUST NO MORE NAMES   */\n        LEAVE                            /* LEAVE NAME LOOP           */\n      END\n    MEML = MEML || NAME || ' '           /* PUT NEW NAME ON LINE      */\n    IF LENGTH(MEML) > 68 THEN DO         /* IF LINE IS FULL           */\n      SAY MEML                           /* PRINT IT                  */\n      MEML =                             /* AND CLEAR IT              */\n    END\n    MEM = MEM + 1                        /* COUNT MEMBERS             */\n    LINE = SUBSTR(LINE,12)               /* DROP NAME AND TTR         */\n    BLOCK = BLOCK - 11                   /* DECREASE REMAINING BLOCK  */\n    LEN = C2X(SUBSTR(LINE,1,1))          /* GET USER DATA LENGTH (HEX)*/\n    LEN = X2D(LEN) // 32 + 1             /* MAKE IT DECIMAL           */\n    LEN = LEN * 2                        /* ALLOW FOR HALF WORD COUNT */\n    LINE = SUBSTR(LINE,LEN)              /* AND DROP USER DATA        */\n    BLOCK = BLOCK - LEN + 1              /* DECREASE REMAINING BLOCK  */\n  END\n  IF ( DUMP = 'Y' ) & ( LENGTH(MEML) > 0 ) THEN DO\n    SAY MEML                             /* PRINT PARTIAL LINE        */\n    MEML =                               /* AND CLEAR LINE            */\n  END\nEND\n\nIF LENGTH(MEML) > 0 THEN SAY MEML\n\nIF RC = 2 THEN ,\n  SAY NINP 'RECORDS WERE READ BEFORE AN EOF WAS DETECTED.'\nELSE ,                                   /* ANYTHING ELSE IS PROBLEM  */\n  SAY 'AN ERROR WAS DETECTED READING THE DATA.  THE RETURN CODE WAS' RC\n\nEXIT 0\n\nNOMORE: ,                                /* GET HERE AT DIR END       */\nIF LENGTH(MEML) > 1 THEN SAY MEML        /* MENTION LAST MEMBERS      */\nSAY ' '                                  /* SKIP A LINE               */\nSAY 'END OF DIRECTORY AFTER' MEM 'MEMBERS.'\n\nEXIT 0                                   /* NOTHING ELSE IS NEEDED    */\n\n/*             E N D   O F   M A  I N   P R O C E D U R E             */\n\nOPENER: PROCEDURE                        /* OPEN INPUT AND OUTPUT     */\n\n/*====================================================================*/\n/*                                                                    */\n/*        THIS IS THE REXX SUBROUTINE TO OPEN THE INPUT FILE.  THE    */\n/*   FILE NAME IS EITHER SUPPLIED IN THE CALLING ARGUMENT OR IS       */\n/*   REQUESTED FROM THE USER.                                         */\n/*                                                                    */\n/*====================================================================*/\n\nPARSE ARG INPUT                          /* GET COMMAND LINE PARMS    */\nERR = 0                                  /* NO ERRORS YET             */\nFILEIN:  ,\nIF ( LENGTH(INPUT) = 0 ) | ( ERR = 1 ) THEN DO /* IF NONE, ASK USER   */\n  SAY 'ENTER INPUT FILE NAME :'\n  PARSE UPPER PULL INPUT                 /* READ USER'S RESPONSE      */\nEND\nINPUT = STRIP(INPUT,'B')                 /* STRIP BLANKS BOTH SIDES   */\nPARSE VAR INPUT INPNAME INPUT            /* FIRST IS INPUT NAME       */\nINPUT = STRIP(INPUT,'L')                 /* STRIP WHAT'S LEFT         */\nIF SUBSTR(INPUT,1,4) = 'VOL(' THEN ,     /* WAS A VOLUME SPECIFIED ?  */\n  PARSE VAR INPUT VOL INPUT              /* IF IT WAS, GO GET IT      */\nELSE VOL =                               /* ELSE SET UP A NULL CLAUSE */\n\"ALLOC DA(\" || INPNAME || \") F(INPUT) SHR REU DSORG(PS) \" ,\n    \"RECFM(F) BLKSIZE(256) LRECL(256)\" || VOL\nIF RC \u00ac= 0 THEN DO                       /* IF ALLOCATE FAILED        */\n  SAY 'UNABLE TO ALLOCATE THAT FILE.  PLEASE TRY AGAIN.'\n  ERR = 1                                /* RECORD AN ERROR INDICATOR */\n  SIGNAL FILEIN\nEND\n\nRETURN 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DSCB": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x92\\x03\\x8f\\x00\\x92\\x05\\x0f\\x13&\\x00\\xf8\\x00\\xd7\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1992-02-07T00:00:00", "modifydate": "1992-02-19T13:26:00", "lines": 248, "newlines": 215, "modlines": 0, "user": "FILE020"}, "text": "/****************************** REXX ********************************/\n/*                                                                  */\n/*                          NAME: DSCB                              */\n/*  THIS REXX PROGRAM IS USED TO DISPLAY THE FORMAT-1 DSCB INFO FOR */\n/*  A CATALOGUED NON-VSAM DATASET.  ALL INFORMATION WILL BE MAPPED  */\n/*  AS PER THE MACRO IECPDSCB.                                      */\n/*                                                                  */\n/********************************************************************/\n                                                 /*                  */\nARG INDSN                                        /* ALLOW DSNAME IN  */\nIF   LENGTH(INDSN) = 0 THEN                      /* ANY IN DSNAME?   */\n     DO                                          /* NO, GO PROMPT    */\n        I = 1                                    /*     FOR INPUT    */\n        SAY 'ENTER DATASET NAME YOU WANT TO',    /* PROMPT MESSAGE   */\n            'LOOK AT:'                           /*                  */\n        DO UNTIL I > 3 |,                        /* GIVING 3 TRIES   */\n                 LENGTH(INDSN) > 0               /*                  */\n           PARSE PULL INDSN                      /* READ DSNAME      */\n           IF    LENGTH(INDSN) = 0 THEN          /* ANY DATA ENTERED */\n                 SAY 'TRY AGAIN?'                /* NO, TRY AGAIN    */\n           I = I + 1                             /* INCREASE COUNT   */\n        END                                      /*                  */\n     END                                         /*                  */\nIF   SYSDSN(INDSN) \\= OK THEN                    /* IS DSNAME EXIST  */\n     DO                                          /*                  */\n        SAY INDSN 'NOT FOUND OR NO DATASET,',    /* NO, SHOW ERROR   */\n            'REQUEST BYPASSED'                   /* NO, SHOW ERROR   */\n        RETURN                                   /*     ABORT        */\n     END                                         /*                  */\nX = OUTTRAP(\"TRAP.\",\"*\")                         /* ENABLE TRAPING   */\nLISTD INDSN LABEL                                /* TRAP ALL USERCAT */\nX = OUTTRAP(\"OFF\")                               /* DISABLE TRAPING  */\nIF   TRAP.0 = 0 THEN RETURN                      /* ANY DATA TRAPED? */\nMEM   = ''                                       /* INIT MEMBER NAME */\nDSNAME= TRAP.1                                   /*    FORM DSNAME   */\nRECFM = WORD(TRAP.3,1)                           /*     FORM RECFM   */\nLRECL = WORD(TRAP.3,2)                           /*     FORM LRECL   */\nBLKSZ = WORD(TRAP.3,3)                           /*     FORM BLKSZ   */\nDSORG = WORD(TRAP.3,4)                           /*     FORM DSORG   */\nVOLSER= STRIP(TRAP.5,L,' ')                      /*    FORM VOLSER   */\nPROC  = SUBSTR(TRAP.6,1,6)                       /* PROCESSTRAP DATA */\nIF    LRECL = VSAM THEN                          /* IS IT A VSAM FILE*/\n      DO                                         /* YES, ABORT WITH  */\n         SAY 'UNABLE TO PROCESS A VSAM',         /*      ERROR       */\n             'DATASET, REQUEST ABORTED'          /*      MESSAGE     */\n         RETURN                                  /*                  */\n      END                                        /*                  */\nIF    PROC = '--MEMB' THEN                       /* SELECT FOLLOWING */\n      DO                                         /*                  */\n         I = 10                                  /*                  */\n         MEM   = WORD(TRAP.7,1)                  /*                  */\n         TTR   = WORD(TRAP.7,2)                  /*                  */\n         ALIAS = WORD(TRAP.7,3)                  /*                  */\n         DIR   = SUBWORD(TRAP.7,6,4)             /*                  */\n         DIR   = DIR TRAP.8                      /*                  */\n      END                                        /*                  */\n ELSE I = 7                                      /*                  */\n DSCB = TRAP.I                                   /* TRAP DSCB OUTPUT */\n I = I + 1                                       /*                  */\n DSCB = DSCB TRAP.I                              /*  2ND LINE OF DSCB*/\n I = I + 1                                       /*                  */\n DSCB = DSCB TRAP.I                              /*  3RD LINE OF DSCB*/\nIF   LENGTH(MEM) = 0 THEN                        /* ANY MEM-NAME?    */\n     SIGNAL FMTDSCB                              /* NO, GO GET DSCB  */\nCLEAR                                            /* CLEAR SCREEN     */\nTITLE = 'DATASET FORMAT-1 DSCB LOOKUP'           /* PREPARE HEADER   */\nSAY     CENTER(TITLE,79)                         /* CENTER & SAY IT  */\nDATA = 'DSNAME:' DSNAME '   '  ||,               /* FORM HEADER LINE */\n       'VOLSER:' VOLSER                          /*                  */\nSAY CENTER(DATA,79)                              /* PUT OUT HEADER   */\nDATA = 'RECFM:' || RECFM '  DSORG:' || DSORG ,   /* FORM HEADER INFO */\n       '  LRECL:' || LRECL '  BLKSZ:' || BLKSZ   /*                  */\nSAY CENTER(DATA,79)                              /* PUT OUT INFO LINE*/\nDATA = '*' || LEFT('-',71,'-') || '*'            /* FORM DATA SCREEN */\nSAY CENTER(DATA,79)                              /* PUT IT OUT       */\nMUSER= X2C(WORD(DIR,6)) ||,                      /* FORM MEMBER USER */\n       X2C(WORD(DIR,7))                          /*                  */\nCDATE= SUBSTR(WORD(DIR,2),3,5)                   /*      CREATE DATE */\nMDATE= SUBSTR(WORD(DIR,3),3,5)                   /*      MODIFY DATE */\nMTIME= SUBSTR(WORD(DIR,4),1,4)                   /*      MODIFY TIME */\nMTIME= INSERT(':',MTIME,2)                       /*                  */\nVERNO= SUBSTR(WORD(DIR,1),1,4)                   /*      VERSION NO. */\nVERNO= INSERT('.',VERNO,2)                       /*                  */\nCSIZE= X2D(SUBSTR(WORD(DIR,4),5,4))              /*      CURRENT SIZE*/\nISIZE= X2D(SUBSTR(WORD(DIR,5),1,4))              /*      INITIAL SIZE*/\nDATA = '| ' || 'MEMBER NAME: ' || LEFT(MEM,8) ,  /* FORM DATA LINE   */\n       '| ' || 'MODIFIED BY: ' || LEFT(MUSER,8), /*                  */\n       '| ' || 'VERSION/MOD: ' || LEFT(VERNO,8), /*                  */\n       '|'                                       /*                  */\nSAY CENTER(DATA,79)                              /*                  */\nDATA = '| ' || 'MODIFY TIME: ' || LEFT(MTIME,8), /*                  */\n       '| ' || 'MODIFY DATE: ' || LEFT(MDATE,8), /*                  */\n       '| ' || 'CREATE DATE: ' || LEFT(CDATE,8), /*                  */\n       '|'                                       /*                  */\nSAY CENTER(DATA,79)                              /*                  */\nDATA = '| ' || 'TTR ADDRESS: ' || LEFT(TTR,8) ,  /*                  */\n       '| ' || 'CURRENT SZ : ' || LEFT(CSIZE,8), /*                  */\n       '| ' || 'INITIAL SZ : ' || LEFT(ISIZE,8), /*                  */\n       '|'                                       /*                  */\nSAY CENTER(DATA,79)                              /*                  */\nDATA = '| ' || 'ALIAS  NAME: ' || LEFT(ALIAS,8), /*                  */\n       '| ' || '             ' || LEFT(' ',8) ,  /*                  */\n       '| ' || '             ' || LEFT(' ',8) ,  /*                  */\n       '|'                                       /*                  */\nSAY CENTER(DATA,79)                              /*                  */\nDATA = '*' || LEFT('-',71,'-') || '*'            /*                  */\nSAY CENTER(DATA,79)                              /*                  */\nPULL A                                           /* BREAK HERE       */\n                                                 /*                  */\nFMTDSCB:                                         /* FORMAT DSCB      */\nCLEAR                                            /* CLEAR SCREEN     */\nTITLE = 'DATASET FORMAT-1 DSCB LOOKUP'           /* FORM HEADER      */\nSAY     CENTER(TITLE,79)                         /* PUT IT OUT       */\nDATA = 'DSNAME:' DSNAME '   '  ||,               /*                  */\n       'VOLSER:' VOLSER                          /*                  */\nSAY CENTER(DATA,79)                              /*                  */\nDATA = 'RECFM:' || RECFM '  DSORG:' || DSORG,    /*                  */\n       '  LRECL:' || LRECL '  BLKSZ:' || BLKSZ   /*                  */\nSAY CENTER(DATA,79)                              /*                  */\nDATA = '*' || LEFT('-',71,'-') || '*'            /*                  */\nSAY CENTER(DATA,79)                              /*                  */\nDATA = '|  NAME  |OFFSET|TYPE|DATA CONTENT|',\n       '       D E S C R I P T I O N        |'\nSAY CENTER(DATA,79)\nDATA = '|--------+------+----+------------+' ||,\n       '-------------------------------------|'\nSAY CENTER(DATA,79)\nDATA = '|DS1FMTID| 002C |CL1 |' || LEFT(WORD(DSCB,1),12) || '|',\n       'FORMAT IDENTIFIDER                  |'\nSAY CENTER(DATA,79)\nDATA = '|DS1DSSN | 002D |CL6 |' || LEFT(WORD(DSCB,2),12) || '|',\n       'DATASET SERIAL NUMBER (THE 1ST ONE) |'\nSAY CENTER(DATA,79)\nDATA = '|DS1VOLSQ| 0033 |XL2 |' || LEFT(WORD(DSCB,3),12) || '|',\n       'VOLUME SEQUENCE NUMBER (1-9999)     |'\nSAY CENTER(DATA,79)\nCREDT= RIGHT(X2D(SUBSTR(WORD(DSCB,4),1,2)),2,'0') || '.' ||,\n       RIGHT(X2D(SUBSTR(WORD(DSCB,4),3,4)),3,'0')\nDATA = '|DS1CREDT| 0035 |XL3 |' ||,\n       LEFT(WORD(DSCB,4),12) || '|',\n       'CREATION DATE (' || CREDT ||,\n       ')              |'\nSAY CENTER(DATA,79)\nDATA = '|DS1EXPDT| 0038 |XL3 |' || LEFT(WORD(DSCB,5),12) || '|',\n       'EXPIRATION DATE                     |'\nSAY CENTER(DATA,79)\nDATA = '|DS1NOEPV| 003B |XL1 |' || LEFT(WORD(DSCB,6),12) || '|',\n       'NUMBER OF DATA EXTENTS ON VOLUME    |'\nSAY CENTER(DATA,79)\nDATA = '|DS1NOBDB| 003C |XL1 |' || LEFT(WORD(DSCB,7),12) || '|',\n       'NO OF BYTES USED IN LAST DIR-BLOCK  |'\nSAY CENTER(DATA,79)\nDATA = '|        | 003D |XL1 |' || LEFT(WORD(DSCB,8),12) || '|',\n       'RESERVED                            |'\nSAY CENTER(DATA,79)\nDATA = '|DS1SYSCD| 003E |CL13|' ||,\n       LEFT(SUBSTR(WORD(DSCB,9),1,8),12) || '|',\n       'SYSTEM CODE                         |'\nSAY CENTER(DATA,79)\nDATA = '|        |      |    |' ||,\n       LEFT(SUBSTR(WORD(DSCB,9),9,8),12) || '|',\n       '                                    |'\nSAY CENTER(DATA,79)\nDATA = '|        |      |    |' ||,\n       LEFT(RIGHT(WORD(DSCB,9),10),12) || '|',\n       '                                    |'\nSAY CENTER(DATA,79)\nREFDT= RIGHT(X2D(SUBSTR(WORD(DSCB,10),1,2)),2,'0') || '.' ||,\n       RIGHT(X2D(SUBSTR(WORD(DSCB,10),3,4)),3,'0')\nDATA = '|DS1REFDT| 004B |XL3 |' ||,\n       LEFT(SUBSTR(WORD(DSCB,10),1,6),12) || '|',\n       'DATE LAST REFERENCED (' || REFDT ||,\n       ')       |'\nSAY CENTER(DATA,79)\nDATA = '|DS1SMSFG| 004E |XL1 |' ||,\n       LEFT(SUBSTR(WORD(DSCB,10),7,2),12) || '|',\n       'SYSTEM MANAGED DATASET FLAG         |'\nSAY CENTER(DATA,79)\nDATA = '|DS1SCEXT| 004F |XL3 |' ||,\n       LEFT(SUBSTR(WORD(DSCB,10),9,6),12) || '|',\n       'SECONDARY EXTENSION FLAG(1)/VALUE(2)|'\nSAY CENTER(DATA,79)\nDATA = '|DS1DSORG| 0052 |XL2 |' || LEFT(WORD(DSCB,11),12) || '|',\n       'DATASET DSORG FLAG (ORG,TCAM/VSAM)  |'\nSAY CENTER(DATA,79)\nDATA = '|DS1RECFM| 0054 |XL1 |' || LEFT(WORD(DSCB,12),12) || '|',\n       'DATASET RECORD FORMAT               |'\nSAY CENTER(DATA,79)\nDATA = '|DS1OPTCD| 0055 |XL1 |' || LEFT(WORD(DSCB,13),12) || '|',\n       'DATASET OPTION CODE                 |'\nSAY CENTER(DATA,79)\nDATA = '|DS1BLKL | 0056 |XL2 |' || LEFT(WORD(DSCB,14),12) || '|',\n       'DATASET BLOCK LENGTH                |'\nSAY CENTER(DATA,79)\nDATA = '|DS1LRECL| 0058 |XL2 |' || LEFT(WORD(DSCB,15),12) || '|',\n       'LOGICAL RECORD LENGTH               |'\nSAY CENTER(DATA,79)\nDATA = '|DS1KEYL | 005A |XL1 |' || LEFT(WORD(DSCB,16),12) || '|',\n       'KEY LENGTH                          |'\nSAY CENTER(DATA,79)\nDATA = '|DS1RKP  | 005B |XL2 |' || LEFT(WORD(DSCB,17),12) || '|',\n       'RELATIVE KEY POSITION               |'\nSAY CENTER(DATA,79)\nDATA = '|DS1DSIND| 005D |XL1 |' || LEFT(WORD(DSCB,18),12) || '|',\n       'DATASET INDICATORS                  |'\nSAY CENTER(DATA,79)\nDATA = '|DS1SCAL | 005E |XL4 |' || LEFT(WORD(DSCB,19),12) || '|',\n       'SPACE PARAMETERS TYPE(1)/QUANTITY(3)|'\nSAY CENTER(DATA,79)\nDATA = '|DS1STAR | 0062 |XL3 |' || LEFT(WORD(DSCB,20),12) || '|',\n       'LAST USED TRACK AND BLOCK (TTR)     |'\nSAY CENTER(DATA,79)\nDATA = '|DS1TRBAL| 0065 |XL3 |' || LEFT(WORD(DSCB,21),12) || '|',\n       'BYTES REMAINING ON LAST TRACK USED  |'\nSAY CENTER(DATA,79)\nDATA = '|        | 0067 |XL2 |' || LEFT(WORD(DSCB,22),12) || '|',\n       'RESERVED (DMS FLAG)                 |'\nSAY CENTER(DATA,79)\nJ = 1\nDO I = 23 TO WORDS(DSCB)-1\n   OFSET= D2X(X2D(69)+(J-1)*10)\n   DATA = '|DS1EXT' || LEFT(J,2) || '|',\n          RIGHT(OFSET,4,'0') '|XL1 |' ||,\n          LEFT(SUBSTR(WORD(DSCB,I),1,2),12) || '|',\n          'EXTENT TYPE INDICATOR               |'\n   SAY CENTER(DATA,79)\n   DATA = '|        |      |XL1 |' ||,\n          LEFT(SUBSTR(WORD(DSCB,I),3,2),12) || '|',\n          'EXTENT SEQUENCE NUMBER              |'\n   SAY CENTER(DATA,79)\n   DATA = '|        |      |XL4 |' ||,\n          LEFT(SUBSTR(WORD(DSCB,I),5,8),12) || '|',\n          'LOWER LIMIT (CCHH)                  |'\n   SAY CENTER(DATA,79)\n   DATA = '|        |      |XL4 |' ||,\n          LEFT(SUBSTR(WORD(DSCB,I),13,8),12) || '|',\n          'UPPER LIMIT (CCHH)                  |'\n   SAY CENTER(DATA,79)\n   J = J + 1\nEND\nOFSET= D2X(X2D(69)+(J-1)*10)\nDATA = '|DS1PTRDS|'  RIGHT(OFSET,4,'0') '|XL5 |' ||,\n       LEFT(WORD(DSCB,I),12) || '|',\n       'CCHHR OF ANY ASSOCIATED FMT-2/3 DSCB|'\nSAY CENTER(DATA,79)\nDATA = '*' || LEFT('-',71,'-') || '*'\nSAY CENTER(DATA,79)\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDTLIST": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x002\\x00\\x916\\x0f\\x01\\x143\\x0f\\x19\\x08\\x00\\xd5\\x00\\xd7\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1991-12-26T00:00:00", "modifydate": "2014-11-26T19:08:32", "lines": 213, "newlines": 215, "modlines": 0, "user": "SBGOLOB"}, "text": "/*==== REXX =========================================================*/\n/*                                                                   */\n/*                    ELIGIBLE DEVICE TABLE LOOKUP                   */\n/*   THIS REXX PROGRAM IS USED TO SHOW ALL SYMBOLIC UNIT NAMES,      */\n/*   GENERIC OR ESOTERIC AND THEIR RELATED UCB INFORMATION.  IF A    */\n/*   SPECIFIC SYMBOLIC UNIT NAME IS ENTERED, THIS PROGRAM WILL GO    */\n/*   THROUGH THE RELATED TABLES AND FIND ALL MATCHING SYMBOLIC       */\n/*   NAMES AND DISPLAY INFORMATION REGARDING THOSE DEVICES ONLY.     */\n/*                                                                   */\n/*===================================================================*/\n/*                                                                   */\n/*                  CONTROL BLOCK CHAINING USED                      */\n/*  JESCT      : CVT+X'128' JES CONTROL TABLE (CVTJESCT)             */\n/*  JESEDT     : JESCT+X'34' JES ELIGIBLE DEVICE TABLE               */\n/*   LOOKUP    : JESEDT+X'1C' EDT LOOKUP TABLE 32 BYTES              */\n/*   LOOKCNT   : LOOKUP+X'08' LOOKUP ENTRY COUNT                     */\n/*    EDTNAME  : LOOKUP+X'10' EDT ENTRY DEVICE NAME                  */\n/*    EDTDEVT  : LOOKUP+X'18' EDT ENTRY DEVICE TYPE                  */\n/*    EDTMASK  : LOOKUP+X'1C' EDT ENTRY DEVICE MASK                  */\n/*    EDTGCNT  : LOOKUP+X'24' EDT ENTRY DEVICE GROUP COUNT           */\n/*    EDTFLAG  : LOOKUP+X'28' EDT ENTRY DEVICE GROUP COUNT           */\n/*     X'10'   : EDTFLAG(1) THIS IS A GENERIC NAME                   */\n/*     X'08'   : EDTFLAG(1) THIS IS A ESOTERIC NAME                  */\n/*     X'04'   : EDTFLAG(1) THIS IS A GENERATE NAME                  */\n/*    EDTAFFN  : LOOKUP+X'2A' EDT ENTRY DEVICE GROUP COUNT           */\n/*    GROUP1ST : LOOKUP+X'2C' EDT ENTRY DEVICE GROUP COUNT           */\n/*    GROUPNXT : LOOKUP+X'2E' EDT ENTRY DEVICE GROUP COUNT           */\n/*   EDTGENR   : JESEDT+X'20' EDT GENERIC TABLE 12 BYTES             */\n/*   EDTGRP    : JESEDT+X'24' EDT GROUP TABLE 12 BYTES               */\n/*   EDTUCB    : JESEDT+X'28' EDT UCB TABLE 8 BYTES                  */\n/*   EDTGRPT   : JESEDT+X'30' EDT GROUP POINTER TABLE 4 BYTES        */\n/*                                                                   */\n/*********************************************************************/\nARG UNIT                                       /* ALLOW PARM ENTERED */\nCVT    = STORAGE(10,4)                         /* ADDR CVT           */\nDCVT   = C2D(CVT)                              /* CONVERT TO DECIMAL */\nJESCT  = STORAGE(D2X(DCVT+X2D(128)),4)         /* ADDR JESCT FROM CVT*/\nDJESCT = C2D(JESCT)                            /* CONVERT TO DECIMAL */\nJESEDT = STORAGE(D2X(DJESCT+X2D(34)),4)        /* ADDR EDT FROM JESCT*/\nDEDT   = C2D(JESEDT)                           /* CONVERT TO DECIMAL */\nGENRIC = STORAGE(D2X(DEDT+X2D(20)),4)          /* ADDR GENERIC TABLE */\nDGENR  = C2D(GENRIC)+12                        /* CONVERT TO DECIMAL */\nLOOKUP = STORAGE(D2X(DEDT+X2D(1C)),4)          /* ADDR LOOK-UP TABLE */\nDLOOK  = C2D(LOOKUP)                           /* CONVERT TO DECIMAL */\nEDTGRP = STORAGE(D2X(DEDT+X2D(24)),4)          /* ADDR GROUP TABLE   */\nDGRP   = C2D(EDTGRP)+12                        /* CONVERT TO DECIMAL */\nEDTUCB = STORAGE(D2X(DEDT+X2D(28)),4)          /* ADDR UCB TABLE     */\nDUCB   = C2D(EDTUCB)+12                        /* CONVERT TO DECIMAL */\nEDTGRPT= STORAGE(D2X(DEDT+X2D(30)),4)          /* ADDR GROUPTR TABLE */\nDGRPT  = C2D(EDTGRPT)+12                       /* CONVERT TO DECIMAL */\nLOOKCNT= STORAGE(D2X(DLOOK+X2D(08)),4)         /* ADDR LOOK-UP COUNT */\nDCOUNT = C2D(LOOKCNT)                          /* CONVERT TO DECIMAL */\nLINEC  = 0                                     /* INIT LINE CONTROL  */\nLINE   = ''                                    /* INIT OUTPUT LINE   */\nIF   LENGTH(UNIT) > 0 THEN                     /* ANY THING LEFT?    */\n     DO                                        /* DO FOLLOWING       */\n        ARGLEN = LENGTH(UNIT)                  /* SAVE PARM LENGTH   */\n        IF   SUBSTR(UNIT,ARGLEN,1) = '*' THEN  /* PREFIX CHECKING?   */\n             UNIT=SUBSTR(UNIT,1,LENGTH(UNIT)-1) /* YES, SAVE PREFIX  */\n        ARGLEN = LENGTH(UNIT)                  /* YES, SAVE NAME LENG*/\n     END\nELSE ARGLEN = 0                                /* ELSE NO ARGUMENT   */\nCLEAR                                          /* CLEAR SCREEN       */\nHEADER = 'ELIGIBLE DEVICE TABLE LOOK UP'\nHEADER = CENTER(HEADER,79)\nSAY HEADER\nIF   ARGLEN = 0 THEN\n     DO\n        HEADER = '+---------------------------------' ||,\n                 '--------------------------------------+'\n        HEADER = CENTER(HEADER,79)\n        SAY HEADER\n        HEADER = '|SEQ|EDT  NAME|DEV TYPE|EDT TYPE|V' ||,\n                 'IO|SEQ|EDT  NAME|DEV TYPE|EDT TYPE|VIO|'\n        HEADER = CENTER(HEADER,79)\n        SAY HEADER\n        HEADER = '+---+---------+--------+--------+-' ||,\n                 '--+---+---------+--------+--------+---+'\n        HEADER = CENTER(HEADER,79)\n        SAY HEADER\n     END\nDO I = 1 TO DCOUNT\n   EDTNAME= STORAGE(D2X(DLOOK+X2D(10)),8)      /* MAP LOOKUP ENT-NAME*/\n   EDTDEVT= STORAGE(D2X(DLOOK+X2D(18)),4)      /* MAP LOOKUP ENT-TYPE*/\n   EDTMASK= STORAGE(D2X(DLOOK+X2D(1C)),4)      /* MAP LOOKUP ENT-MASK*/\n   EDTAMSK= STORAGE(D2X(DLOOK+X2D(20)),4)      /* MAP LOOKUP ENT-AMSK*/\n   EDTGCNT= STORAGE(D2X(DLOOK+X2D(24)),4)      /* MAP LOOKUP ENT-FLAG*/\n   EDTFLAG= STORAGE(D2X(DLOOK+X2D(28)),1)      /* MAP LOOKUP ENT-FLAG*/\n   EDTAFFN= STORAGE(D2X(DLOOK+X2D(2A)),2)      /* MAP LOOKUP ENT-AFFN*/\n   GNIX1ST= STORAGE(D2X(DLOOK+X2D(2C)),2)      /* MAP GENERIC IX-1ST */\n   GNIXNXT= STORAGE(D2X(DLOOK+X2D(2E)),2)      /* MAP LOOKUP NEXT ENT*/\n   IF   BITAND(EDTFLAG,'10'X) = '10'X THEN     /* IS THIS A GENERIC  */\n        TYPE = GENERIC' '                      /* YES THEN SAVE IT   */\n   ELSE IF   BITAND(EDTFLAG,'04'X)= '04'X THEN /* IS THIS A GENERATED*/\n             TYPE = GENERATE                   /* YES SAVE IT        */\n   ELSE IF   BITAND(EDTFLAG,'08'X)= '08'X THEN /* IS THIS AN ESOTERIC*/\n             TYPE = ESOTERIC                   /* YES, SAVE IT       */\n        ELSE TYPE = C2X(EDTFLAG)'      '       /* ELSE SAVE THE FLAG */\n   GENP = DGENR + (C2D(GNIX1ST) - 1) * 12      /* FIND GENERIC ENTRY */\n   GRPIX= STORAGE(D2X(GENP+8),2)               /* MAP 1ST GROUP INDEX*/\n   GRPID= DGRPT + 4 * (C2D(GRPIX) - 1)         /* FIND GROUP ENTRY   */\n   GRPID= STORAGE(D2X(GRPID+X2D(00)),2)        /* MAP GROUP IDENT    */\n   GRPID= STRIP(C2X(GRPID),L,'0')              /* STRIP LEADING ZERO */\n   GRPID= RIGHT(GRPID,3)                       /* MAKE RIGHT JUSTIFY */\n   IF   TYPE \u00ac= 'GENERIC' THEN                 /* IS THIS A GENERIC  */\n        EDTDEVT = STORAGE(D2X(GENP),4)         /* YES, MAP DEV-TYPE  */\n/*                                          */\n/* IF   BITAND(EDTFLAG,'80'X) = '80'X THEN  */ /* IS VIO SUPPORTED   */\n/*      VIO  = YES                          */ /* YES, SAY IT        */\n/* ELSE VIO  = '   '                        */ /* ELSE LEAVE IT BLANK*/\n   SEQNO = SUBSTR(C2X(EDTMASK),6)\n   LINE  = LINE || '|' || SEQNO || '|' || EDTNAME '|' ||,\n           C2X(EDTDEVT) || '|' || TYPE || '|' || GRPID\n   IF   ARGLEN > 0  THEN\n        IF    SUBSTR(EDTNAME,1,ARGLEN) = UNIT THEN\n              DO\n                 LINEC = LINEC + 1\n                 SAY RIGHT(LINEC,3) || '. EDT NAME :' EDTNAME\n                 SAY '     EDT TYPE :' TYPE\n                 SAY '     DEV TYPE :' C2X(EDTDEVT)\n                 SAY '     GROUP NO :' C2D(GRPIX)\n                 CALL FINDGRP                  /* FIND ALL UCB ADDR  */\n                 DLOOK= DLOOK + 32             /* GET NEXT LOOKUP ENT*/\n                 ITERATE                       /* DO NEXT            */\n              END\n         ELSE DO\n                 DLOOK= DLOOK + 32             /* GET NEXT LOOKUP ENT*/\n                 ITERATE                       /* DO NEXT            */\n              END\n   LINEC = LINEC + 1\n   IF    LINEC = 2 THEN\n         DO\n            LINEC = 0\n            LINE = LINE || '|'\n            LINE = CENTER(LINE,79)\n            SAY LINE\n            LINE = ''\n         END\n/* SAY     SEQNO EDTNAME C2X(EDTDEVT) TYPE VIO  */\n/*      C2X(EDTAFFN) C2X(GNIX1ST) C2X(GNIXNXT)  */\n   DLOOK= DLOOK + 32                           /* GET NEXT LOOKUP ENT*/\n                                               /*                    */\nEND\nIF   ARGLEN = 0 THEN                           /* IS IN-PARM NULL    */\n     DO                                        /* YES, SAY TRAILER   */\n        HEADER = '+------------------' ||,\n                 '-------------------' ||,\n                 '-------------------' ||,\n                 '---------------+'\n        HEADER = CENTER(HEADER,79)             /* CENTERS THE HEADER */\n        SAY HEADER\n     END\nRETURN(0)\n/******************************* REXX ********************************/\n/*                                                                   */\n/*               MAPOUT UCB ADDR DEFINED IN LOOKUP TABLE             */\n/*   HERE THE SUBROUTINE IS USED TO MAP OUT ALL THE UCB ADDR FROM    */\n/*   THE UCB ADDR TABLE, AND THE RELATED GROUP REFERENCE NUMBER.     */\n/*===================================================================*/\n/*                  CONTROL BLOCK CHAINING USED                      */\n/*  GRPIX      : GRPT+X'00' GROUP POINTER                            */\n/*  GRPTN      : GRPT+X'02' INDEX TO NEXT GROUP POINTER ENTRY        */\n/*  DEVNO      : EDTGRP+X'02' NUMBER OF DEVICE                       */\n/*  UCB1ST     : EDTGRP+X'04' INDEX TO FIRST UCB                     */\n/*                                                                   */\n/*********************************************************************/\nFINDGRP:\n  GRPC = STORAGE(D2X(GENP+4),4)                /* MAP NUM OF GROUPS  */\n  GRPC = C2D(GRPC)                             /* CONVERT TO DECIMAL */\n  DO UNTIL GRPC = 0                            /* GET ALL GROUPS     */\n     GRPNX= STORAGE(D2X(GENP+10),2)            /* MAP NEXT GROUP IDX */\n     GRPIX= STORAGE(D2X(GENP+8),2)             /* MAP 1ST GROUP INDEX*/\n     DO UNTIL GRPTN = '0000'X                  /* GET ALL GRP-POINTER*/\n        IF   GRPIX \u00ac= '0000'X THEN             /* IS GRP ADDR NULL   */\n             CALL MAPUCB                       /* NO, GO MAP ALL UCB */\n        GRPIX = GRPTN                          /* ADDR TO NEXT GRPTS */\n     END                                       /* CONTINUE           */\n     GRPC = GRPC - 1                           /* DECREASE COUNT BY 1*/\n     GNIX1ST = GRPNX                           /* LOAD NEXT GENR-ENT */\n     GENP = DGENR + (C2D(GNIX1ST) - 1) * 12    /* ADDR TO THE ENTRY  */\n  END                                          /* CONTINUE           */\n  SAY ''                                       /* PUT OUT A SEPERATOR*/\nRETURN(0)\nMAPUCB:\n  GRPIX  = DGRPT + 4 * (C2D(GRPIX) - 1)        /* FIND GROUP ENTRY   */\n  GRPTN  = STORAGE(D2X(GRPIX+X2D(02)),2)       /* MAP GROUP DEV-COUNT*/\n  GRPIX  = STORAGE(D2X(GRPIX+X2D(00)),2)       /* MAP GROUP DEV-COUNT*/\n  GRPID  = STRIP(C2X(GRPIX),L,'0')             /* STRIP LEADING ZERO */\n  GRPIX  = DGRP + 12 * (C2D(GRPIX) - 1)        /* MAP GROUP DEV-COUNT*/\n  DEVNO  = STORAGE(D2X(GRPIX+X2D(02)),2)       /* MAP GROUP DEV-COUNT*/\n  DDEVNO = C2D(DEVNO)                          /* CONVERT TO DECIMAL */\n  UCB1ST = STORAGE(D2X(GRPIX+X2D(04)),4)       /* MAP UCB TABLE ADDR */\n  UCBADDR= (C2D(UCB1ST) - 1) * 8 + DUCB        /* FIND UCB ENTRY ADDR*/\n  SAY '     GROUP ID :' GRPID || '/' || DDEVNO /* PUT GROUP ID.      */\n  LINECNT= 0                                   /* INIT LINE COUNT    */\n  LINE   = '     UCB ADDR : '                  /* PUT OUT LINE HEADER*/\n  DO DDEVNO                                    /* GO GET ALL DEVICES */\n     IF   LINECNT > 0 THEN                     /* PREPARE OUTPUT LINE*/\n          LINE = LINE || ','                   /* CONCAT WITH ','    */\n     UCBNM   = STORAGE(D2X(UCBADDR),3)         /* MAP DEVICE NUMBER  */\n     LINE    = LINE || UCBNM                   /* FILL-IN DEVICE NUM */\n     LINECNT = LINECNT + 1                     /* INCREASE DEVICE-CNT*/\n     IF   LINECNT = 16 THEN                    /* IS DEVICE-CNT = 16 */\n          DO                                   /* YES, PUT OUT LINE  */\n             SAY  LINE                         /*                    */\n             LINECNT = 0                       /* CLEAR DEVICE COUNT */\n             LINE    = '                '      /* RE-INIT LINE HEADER*/\n          END\n     UCBADDR = UCBADDR+8                       /* GET NEXT UCB ADDR  */\n  END\n  IF   LINECNT > 0  THEN                       /* ANY LEFT OVER?     */\n       SAY  LINE                               /* YES, PUT IT OUT    */\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDTLOOK": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01+\\x001\\x00\\x912?\\x01\\x143\\x0f\\x19\\t\\x00\\xd4\\x00+\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.43", "flags": 0, "createdate": "1991-11-19T00:00:00", "modifydate": "2014-11-26T19:09:31", "lines": 212, "newlines": 43, "modlines": 0, "user": "SBGOLOB"}, "text": "/***** REXX **********************************************************/\n/*                                                                   */\n/*                    ELIGIBLE DEVICE TABLE LOOKUP                   */\n/*   THIS REXX PROGRAM IS USED TO PRINT OPUT ALL SYMBOLIC UNIT       */\n/*   NAMES, BOTH GENERIC AND ESOTERIC.  IF A NAME IS ENTERED AS      */\n/*   A PARAMETER, THE PROGRAM WILL DISPLAY INFORMATION ABOUT ONLY    */\n/*   THOSE DEVICES OF THE TYPE ENTERED.                              */\n/*                                                                   */\n/*===================================================================*/\n/*                  CONTROL BLOCK CHAINING USED                      */\n/*  JESCT      : CVT+X'128' JES CONTROL TABLE (CVTJESCT)             */\n/*  JESEDT     : JESCT+X'34' JES ELIGIBLE DEVICE TABLE               */\n/*   LOOKUP    : JESEDT+X'1C' EDT LOOKUP TABLE 32 BYTES              */\n/*   LOOKCNT   : LOOKUP+X'08' LOOKUP ENTRY COUNT                     */\n/*    EDTNAME  : LOOKUP+X'10' EDT ENTRY DEVICE NAME                  */\n/*    EDTDEVT  : LOOKUP+X'18' EDT ENTRY DEVICE TYPE                  */\n/*    EDTMASK  : LOOKUP+X'1C' EDT ENTRY DEVICE MASK                  */\n/*    EDTGCNT  : LOOKUP+X'24' EDT ENTRY DEVICE GROUP COUNT           */\n/*    EDTFLAG  : LOOKUP+X'28' EDT ENTRY DEVICE GROUP COUNT           */\n/*     X'10'   : EDTFLAG(1) THIS IS A GENERIC NAME                   */\n/*     X'08'   : EDTFLAG(1) THIS IS A ESOTERIC NAME                  */\n/*     X'04'   : EDTFLAG(1) THIS IS A GENERATE NAME                  */\n/*    EDTAFFN  : LOOKUP+X'2A' EDT ENTRY DEVICE GROUP COUNT           */\n/*    GROUP1ST : LOOKUP+X'2C' EDT ENTRY DEVICE GROUP COUNT           */\n/*    GROUPNXT : LOOKUP+X'2E' EDT ENTRY DEVICE GROUP COUNT           */\n/*   EDTGENR   : JESEDT+X'20' EDT GENERIC TABLE 12 BYTES             */\n/*   EDTGRP    : JESEDT+X'24' EDT GROUP TABLE 12 BYTES               */\n/*   EDTUCB    : JESEDT+X'28' EDT UCB TABLE 8 BYTES                  */\n/*   EDTGRPT   : JESEDT+X'30' EDT GROUP POINTER TABLE 4 BYTES        */\n/*                                                                   */\n/*********************************************************************/\nARG UNIT                                       /* ALLOW PARM ENTERED */\nCVT    = STORAGE(10,4)                         /* ADDR CVT           */\nDCVT   = C2D(CVT)                              /* CONVERT TO DECIMAL */\nJESCT  = STORAGE(C2X(D2C(DCVT+X2D(128))),4)    /* ADDR JESCT FROM CVT*/\nDJESCT = C2D(JESCT)                            /* CONVERT TO DECIMAL */\nJESEDT = STORAGE(C2X(D2C(DJESCT+X2D(34))),4)   /* ADDR EDT FROM JESCT*/\nDEDT   = C2D(JESEDT)                           /* CONVERT TO DECIMAL */\nGENRIC = STORAGE(C2X(D2C(DEDT+X2D(20))),4)     /* ADDR GENERIC TABLE */\nDGENR  = C2D(GENRIC)+12                        /* CONVERT TO DECIMAL */\nLOOKUP = STORAGE(C2X(D2C(DEDT+X2D(1C))),4)     /* ADDR LOOK-UP TABLE */\nDLOOK  = C2D(LOOKUP)                           /* CONVERT TO DECIMAL */\nEDTGRP = STORAGE(C2X(D2C(DEDT+X2D(24))),4)     /* ADDR GROUP TABLE   */\nDGRP   = C2D(EDTGRP)+12                        /* CONVERT TO DECIMAL */\nEDTUCB = STORAGE(C2X(D2C(DEDT+X2D(28))),4)     /* ADDR UCB TABLE     */\nDUCB   = C2D(EDTUCB)+12                        /* CONVERT TO DECIMAL */\nEDTGRPT= STORAGE(C2X(D2C(DEDT+X2D(30))),4)     /* ADDR GROUPTR TABLE */\nDGRPT  = C2D(EDTGRPT)+12                       /* CONVERT TO DECIMAL */\nLOOKCNT= STORAGE(C2X(D2C(DLOOK+X2D(08))),4)    /* ADDR LOOK-UP COUNT */\nDCOUNT = C2D(LOOKCNT)                          /* CONVERT TO DECIMAL */\nLINEC  = 0                                     /* INIT LINE CONTROL  */\nLINE   = ''                                    /* INIT OUTPUT LINE   */\nIF   LENGTH(UNIT) > 0 THEN                     /* ANY THING LEFT?    */\n     DO                                        /* DO FOLLOWING       */\n        ARGLEN = LENGTH(UNIT)                  /* SAVE PARM LENGTH   */\n        IF   SUBSTR(UNIT,ARGLEN,1) = '*' THEN  /* PREFIX CHECKING?   */\n             UNIT=SUBSTR(UNIT,1,LENGTH(UNIT)-1) /* YES, SAVE PREFIX  */\n        ARGLEN = LENGTH(UNIT)                  /* YES, SAVE NAME LENG*/\n     END\nELSE ARGLEN = 0                                /* ELSE NO ARGUMENT   */\nCLEAR                                          /* CLEAR SCREEN       */\nHEADER = 'ELIGIBLE DEVICE TABLE LOOK UP'\nHEADER = CENTER(HEADER,80)\nSAY HEADER\nIF   ARGLEN = 0 THEN\n     DO\n        HEADER = '+---------------------------------' ||,\n                 '--------------------------------------+'\n        HEADER = CENTER(HEADER,79)\n        SAY HEADER\n        HEADER = '|' ||,\n                 COPIES('SEQ|EDT  NAME|DEV TYPE|EDT TYPE|GRP|',2)\n        HEADER = CENTER(HEADER,79)\n        SAY HEADER\n        HEADER = '+' ||,\n                 COPIES('---+---------+--------+--------+---+',2)\n        HEADER = CENTER(HEADER,79)\n        SAY HEADER\n     END\nDO I = 1 TO DCOUNT\n   EDTNAME= STORAGE(C2X(D2C(DLOOK+X2D(10))),8) /* MAP LOOKUP ENT-NAME*/\n   EDTDEVT= STORAGE(C2X(D2C(DLOOK+X2D(18))),4) /* MAP LOOKUP ENT-TYPE*/\n   EDTMASK= STORAGE(C2X(D2C(DLOOK+X2D(1C))),4) /* MAP LOOKUP ENT-MASK*/\n   EDTAMSK= STORAGE(C2X(D2C(DLOOK+X2D(20))),4) /* MAP LOOKUP ENT-AMSK*/\n   EDTGCNT= STORAGE(C2X(D2C(DLOOK+X2D(24))),4) /* MAP LOOKUP ENT-FLAG*/\n   EDTFLAG= STORAGE(C2X(D2C(DLOOK+X2D(28))),1) /* MAP LOOKUP ENT-FLAG*/\n   EDTAFFN= STORAGE(C2X(D2C(DLOOK+X2D(2A))),2) /* MAP LOOKUP ENT-AFFN*/\n   GNIX1ST= STORAGE(C2X(D2C(DLOOK+X2D(2C))),2) /* MAP GENERIC IX-1ST */\n   GNIXNXT= STORAGE(C2X(D2C(DLOOK+X2D(2E))),2) /* MAP LOOKUP NEXT ENT*/\n   IF   BITAND(EDTFLAG,'10'X) = '10'X THEN     /* IS THIS A GENERIC  */\n        TYPE = GENERIC' '                      /* YES THEN SAVE IT   */\n   ELSE IF   BITAND(EDTFLAG,'04'X)= '04'X THEN /* IS THIS A GENERATED*/\n             TYPE = GENERATE                   /* YES SAVE IT        */\n   ELSE IF   BITAND(EDTFLAG,'08'X)= '08'X THEN /* IS THIS AN ESOTERIC*/\n             TYPE = ESOTERIC                   /* YES, SAVE IT       */\n        ELSE TYPE = C2X(EDTFLAG)'      '       /* ELSE SAVE THE FLAG */\n   GENP = DGENR + (C2D(GNIX1ST) - 1) * 12      /* FIND GENERIC ENTRY */\n   GRPIX= STORAGE(C2X(D2C(GENP+8)),2)          /* MAP 1ST GROUP INDEX*/\n   GRPID= DGRPT + 4 * (C2D(GRPIX) - 1)         /* FIND GROUP ENTRY   */\n   GRPID= STORAGE(C2X(D2C(GRPID+X2D(00))),2)   /* MAP GROUP IDENT    */\n   GRPID= STRIP(C2X(GRPID),L,'0')              /* STRIP LEADING ZERO */\n   GRPID= RIGHT(GRPID,3)                       /* MAKE RIGHT JUSTIFY */\n   IF   TYPE \\= 'GENERIC' THEN                 /* IS THIS A GENERIC  */\n        EDTDEVT = STORAGE(C2X(D2C(GENP)),4)    /* YES, MAP DEV-TYPE  */\n/*                                          */\n/* IF   BITAND(EDTFLAG,'80'X) = '80'X THEN  */ /* IS VIO SUPPORTED   */\n/*      VIO  = YES                          */ /* YES, SAY IT        */\n/* ELSE VIO  = '   '                        */ /* ELSE LEAVE IT BLANK*/\n   SEQNO = SUBSTR(C2X(EDTMASK),6)\n   LINE  = LINE || '|' || SEQNO || '|' || EDTNAME '|' ||,\n           C2X(EDTDEVT) || '|' || TYPE || '|' || GRPID\n   IF   ARGLEN > 0  THEN\n        IF    SUBSTR(EDTNAME,1,ARGLEN) = UNIT THEN\n              DO\n                 LINEC = LINEC + 1\n                 SAY RIGHT(LINEC,3) || '. EDT NAME :' EDTNAME\n                 SAY '     EDT TYPE :' TYPE\n                 SAY '     DEV TYPE :' C2X(EDTDEVT)\n                 SAY '     GROUP NO :' C2D(GRPIX)\n                 CALL FINDGRP                  /* FIND ALL UCB ADDR  */\n                 DLOOK= DLOOK + 32             /* GET NEXT LOOKUP ENT*/\n                 ITERATE                       /* DO NEXT            */\n              END\n         ELSE DO\n                 DLOOK= DLOOK + 32             /* GET NEXT LOOKUP ENT*/\n                 ITERATE                       /* DO NEXT            */\n              END\n   LINEC = LINEC + 1\n   IF    LINEC = 2 THEN\n         DO\n            LINEC = 0\n            LINE = LINE || '|'\n            LINE = CENTER(LINE,79)\n            SAY LINE\n            LINE = ''\n         END\n/* SAY     SEQNO EDTNAME C2X(EDTDEVT) TYPE VIO  */\n/*      C2X(EDTAFFN) C2X(GNIX1ST) C2X(GNIXNXT)  */\n   DLOOK= DLOOK + 32                           /* GET NEXT LOOKUP ENT*/\n                                               /*                    */\nEND\nIF   ARGLEN = 0 THEN                           /* IS IN-PARM NULL    */\n     DO                                        /* YES, SAY TRAILER   */\n        HEADER = '+------------------' ||,\n                 '-------------------' ||,\n                 '-------------------' ||,\n                 '---------------+'\n        HEADER = CENTER(HEADER,79)             /* CENTERS THE HEADER */\n        SAY HEADER\n     END\nRETURN(0)\n/******************************* REXX ********************************/\n/*                                                                   */\n/*               MAPOUT UCB ADDR DEFINED IN LOOKUP TABLE             */\n/*   HERE THE SUBROUTINE IS USED TO MAP OUT ALL THE UCB ADDR FROM    */\n/*   THE UCB ADDR TABLE, AND THE RELATED GROUP REFERENCE NUMBER.     */\n/*===================================================================*/\n/*                  CONTROL BLOCK CHAINING USED                      */\n/*  GRPIX      : GRPT+X'00' GROUP POINTER                            */\n/*  GRPTN      : GRPT+X'02' INDEX TO NEXT GROUP POINTER ENTRY        */\n/*  DEVNO      : EDTGRP+X'02' NUMBER OF DEVICE                       */\n/*  UCB1ST     : EDTGRP+X'04' INDEX TO FIRST UCB                     */\n/*                                                                   */\n/*********************************************************************/\nFINDGRP:\n  GRPC = STORAGE(C2X(D2C(GENP+4)),4)           /* MAP NUM OF GROUPS  */\n  GRPNX= STORAGE(C2X(D2C(GENP+10)),2)          /* MAP NUM OF GROUPS  */\n  GRPC = C2D(GRPC)                             /* CONVERT TO DECIMAL */\n  DO UNTIL GRPNX= '0000'X                      /* GET ALL GROUPS     */\n     GRPNX= STORAGE(C2X(D2C(GENP+10)),2)       /* MAP NEXT GROUP IDX */\n     GRPIX= STORAGE(C2X(D2C(GENP+8)),2)        /* MAP 1ST GROUP INDEX*/\n     DO UNTIL GRPTN = '0000'X                  /* GET ALL GRP-POINTER*/\n        IF   GRPIX \\= '0000'X THEN             /* IS GRP ADDR NULL   */\n             CALL MAPUCB                       /* NO, GO MAP ALL UCB */\n        GRPIX = GRPTN                          /* ADDR TO NEXT GRPTS */\n     END                                       /* CONTINUE           */\n     GRPC = GRPC - 1                           /* DECREASE COUNT BY 1*/\n     GNIX1ST = GRPNX                           /* LOAD NEXT GENR-ENT */\n     GENP = DGENR + (C2D(GNIX1ST) - 1) * 12    /* ADDR TO THE ENTRY  */\n  END                                          /* CONTINUE           */\n  SAY ''                                       /* PUT OUT A SEPERATOR*/\nRETURN(0)\nMAPUCB:\n  GRPIX  = DGRPT + 4 * (C2D(GRPIX) - 1)        /* FIND GROUP ENTRY   */\n  GRPTN  = STORAGE(C2X(D2C(GRPIX+X2D(02))),2)  /* MAP NEXT GRP-INDEX */\n  GRPIX  = STORAGE(C2X(D2C(GRPIX+X2D(00))),2)  /* MAP GROUP DEV-COUNT*/\n  GRPID  = STRIP(C2X(GRPIX),L,'0')             /* STRIP LEADING ZERO */\n  GRPIX  = DGRP + 12 * (C2D(GRPIX) - 1)        /* MAP GROUP DEV-COUNT*/\n  DEVNO  = STORAGE(C2X(D2C(GRPIX+X2D(02))),2)  /* MAP GROUP DEV-COUNT*/\n  DDEVNO = C2D(DEVNO)                          /* CONVERT TO DECIMAL */\n  UCB1ST = STORAGE(C2X(D2C(GRPIX+X2D(04))),4)  /* MAP UCB TABLE ADDR */\n  UCBADDR= (C2D(UCB1ST) - 1) * 8 + DUCB        /* FIND UCB ENTRY ADDR*/\n  SAY '     GROUP ID :' GRPID || '/' || DDEVNO /* PUT GROUP ID.      */\n  LINECNT= 0                                   /* INIT LINE COUNT    */\n  LINE   = '     UCB ADDR : '                  /* PUT OUT LINE HEADER*/\n  DO DDEVNO                                    /* GO GET ALL DEVICES */\n     IF   LINECNT > 0 THEN                     /* PREPARE OUTPUT LINE*/\n          LINE = LINE || ','                   /* CONCAT WITH ','    */\n     UCBNM   = STORAGE(C2X(D2C(UCBADDR)),3)    /* MAP DEVICE NUMBER  */\n     LINE    = LINE || UCBNM                   /* FILL-IN DEVICE NUM */\n     LINECNT = LINECNT + 1                     /* INCREASE DEVICE-CNT*/\n     IF   LINECNT = 16 THEN                    /* IS DEVICE-CNT = 16 */\n          DO                                   /* YES, PUT OUT LINE  */\n             SAY  LINE                         /*                    */\n             LINECNT = 0                       /* CLEAR DEVICE COUNT */\n             LINE    = '                '      /* RE-INIT LINE HEADER*/\n          END\n     UCBADDR = UCBADDR+8                       /* GET NEXT UCB ADDR  */\n  END\n  IF   LINECNT > 0  THEN                       /* ANY LEFT OVER?     */\n       SAY  LINE                               /* YES, PUT IT OUT    */\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GDGDEL": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00G\\x00\\x91\"\\x8f\\x01\\x143\\x0f\\x19\\x10\\x009\\x00#\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-08-16T00:00:00", "modifydate": "2014-11-26T19:10:47", "lines": 57, "newlines": 35, "modlines": 0, "user": "SBGOLOB"}, "text": "/*==== REXX ==========================================================*/\n/*                                                                    */\n/*        THIS REXX WILL SCAN THE OUTPUT OF A LISTCAT DISPLAYING ALL  */\n/*   THE GDGS IN A CATALOG AND DELETE THOSE WHICH HAVE NO GENERATIONS */\n/*   IN THEM.  IT FIRST ASKS WHETHER OR NOT THE GDG'S SHOULD REALLY   */\n/*   BE DELETED.  ANSWERING 'NO' MAKES THE REXX RUN IN TEST MODE.     */\n/*                                                                    */\n/*====================================================================*/\n\nFILENAME: SAY 'ENTER INPUT FILE NAME :'\nPARSE UPPER PULL FNAME\n\"ALLOC DA(\" || FNAME || \") F(TEST) SHR REU\"\nIF RC \u00ac= 0 THEN DO\n  SAY 'UNABLE TO ALLOCATE THAT FILE.  PLEASE TRY AGAIN.'\n  SIGNAL FILENAME\n  END\nO = '0'\nNREC = 0\nNGDG = 0\nNDEL = 0\nSAY \"SHOULD GDG'S REALLY BE DELETED ( YES/NO ) : \"\nPARSE UPPER PULL ANSWR\nIF ( LEFT(ANSWR,1) = 'Y' ) THEN DELSW = ' '\nELSE DELSW = ' NOT '\nSAY 'DELETES WILL REALLY' || DELSW || 'BE PERFORMED.'\n\nDO FOREVER\n  'EXECIO 1 DISKR TEST'                  /* QUEUE FILE INPUT LINE     */\n  IF RC = 2 THEN LEAVE                   /* EXIT ON EOF               */\n  NREC = NREC + 1                        /* COUNT ANOTHER RECORD READ */\n  PARSE PULL A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15\n  IF ( A2 = 'BASE' ) & ( RIGHT(A1,3) = 'GDG' ) THEN DO\n    NGDG = NGDG + 1                      /* COUNT ANOTHER GDG        */\n    IF ( O \u00ac= '0' ) THEN DO              /* CHECK LAST ONE EXISTS    */\n      IF DEL \u00ac= 'NO' THEN DO             /* WERE THWNW GWNWRATIONS ? */\n        IF DELSW = ' ' THEN \"DELETE '\" || O || \"' GDG\"\n        ELSE SAY 'GDG' O 'WAS DELETED.'\n        NDEL = NDEL + 1\n      END\n      ELSE SAY '          GDG' O 'WAS RETAINED.'\n    END\n    O = A4                               /* MAKE NEW ONE OLD ONE     */\n    DEL = 'YES'                          /* AND NO GENERATIONS       */\n  END\n  ELSE IF ( LEFT(A1,5) = 'NONVS' ) | ( LEFT(A2,5) = 'NONVS' ) THEN DO\n    DEL = 'NO'                           /* NONVSAM GENS MEAN NO DEL */\n  END\nEND\nIF ( O \u00ac= '0' ) THEN DO                  /* CHECK LAST IN INPUT      */\n  IF DEL \u00ac= 'NO' THEN DO\n    IF DELSW = ' ' THEN \"DELETE '\" || O || \"' GDG\"\n    ELSE SAY 'A GDG' O 'WAS DELETED.'\n  END\n  ELSE SAY 'GDG' O 'WAS RETAINED.'\nEND                                      /* REPORT ON RESULTS        */\nSAY NREC 'RECORDS WERE READ BEFORE AN EOF WAS DETECTED.'\nSAY NGDG \"GDG'S WERE FOUND AND\" NDEL \"WERE DELETED.\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGSCAN": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00\\x00\\x00\\x91'o\\x00\\x92!/\\x16\\x07\\x00:\\x00&\\x005\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "1991-10-03T00:00:00", "modifydate": "1992-07-30T16:07:00", "lines": 58, "newlines": 38, "modlines": 53, "user": "FILE020"}, "text": "/*====REXX===========================================================*/\n/*                                                                   */\n/*         This REXX allocates a GDG base and then goes backwards    */\n/*   from the latest memmber until unable to allocate another        */\n/*   member.  The idea is to generate a complete listing of all GDG  */\n/*   members for TSO commands.  TSO does not support the use of      */\n/*   relative generation numbers in file allocations ( -1 ).         */\n/*                                                                   */\n/*===================================================================*/\n\nhead = 'generation was '                    /* head of command       */\ntail = '.'                                  /* tail of command       */\n\nparse upper arg gdgbase                     /* get command line args */\ndo while length(strip(gdgbase,'B')) = 0     /* process sans blanks   */\n   say 'Please enter the gdg base or add it to the command line.'\n   parse pull gdgbase                       /* if none, prompt user  */\n   end\n                                            /* allocate GDG base     */\n\"alloc da(\" || gdgbase || \") f(test) shr reu\"\nif rc = 0 then say 'The GDG was allocated successfully.'\nelse do                                     /* on failure            */\n   say 'The GDG failed allocation.'\n   exit 8\n   end\nngood = 0                                   /* good generation count */\nlastcc = outtrap(\"x.\")                      /* trap tso response     */\nrdsn test                                   /* get dsn fron ddname   */\nlastcc = outtrap(off)                       /* turn trap off         */\ncomm = 'name = x.' || x.0                   /* last trapped line     */\ninterpret comm                              /* get file name         */\nname = strip(name,'B')                      /* remove blanks         */\ngen = left(right(name,7),4)                 /* pick off generation   */\nleft = substr(name,1,length(name)-7)        /* preceeding generation */\nright = right(name,3)                       /* trailing generation   */\nfile = left || gen || right                 /* reconstruct file name */\nsay head || file || tail                    /* output name           */\noldmsg = msg('OFF')                         /* preserve old msg stat */\n\"alloc da('\" || file || \"') f(t$) shr reu\"  /* trail allocation      */\noldmsg = msg(oldmsg)                        /* return old msg stat   */\nlastcc = rc                                 /* record return code    */\ndo while lastcc = 0                         /* process all gens      */\n   ngood = ngood + 1                        /* count generations     */\n   gen = gen - 1                            /* get prior gen #       */\n   if gen > 0 then do                       /* no negatives allowed  */\n      do while length(gen) < 4              /* replace leading 0's   */\n         gen = '0' || gen\n         end\n      file = left || gen || right           /* create next file name */\n      oldmsg = msg('OFF')                   /* preserve old msg stat */\n      \"alloc da('\" || file || \"') f(t$) shr reu\" /* allocate         */\n      oldmsg = msg(oldmsg)                  /* return old msg stat   */\n      lastcc = rc                           /* preserve return code  */\n      if lastcc = 0 then say head || file || tail /* report file name*/\n      end\n   else lastcc = 4                          /* negative makes bad rc */\nend\nsay 'there were' ngood 'generations found.' /* say generation count  */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GENERIC": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x91\\x15O\\x00\\x92!/\\x16\\x11\\x00\\x12\\x00\\x11\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-06-03T00:00:00", "modifydate": "1992-07-30T16:11:00", "lines": 18, "newlines": 17, "modlines": 0, "user": "FILE020"}, "text": "/*====REXX===========================================================*/\nPARM=ARG(1)\n/*===================================================================*/\n/*                                                                   */\n/*          THIS REXX EXEC WILL ALLOW ANY COMMAND TO BE EXECUTED     */\n/*     FROM THE CONSOLE.  IT IS MEANT FOR EMERGENCIES WHEN TSO IS    */\n/*     UNAVAILABLE.                                                  */\n/*                                                                   */\n/*===================================================================*/\nCOMM = DELWORD(PARM,1,2)        /* DROP 'GENERIC' AND SYSTEM IDENT   */\nSYSTEM = WORD(PARM,2)           /* GET SYSTEM TO EXECUTE UNDER       */\nIF ( COMM = '' ) | ( SYSTEM = '' ) THEN DO\n   ADDRESS 'TSO'\n   \"SE 'PROPER USE INCLUDES SUBSYSTEM AND COMMAND.'\"\n   RETURN\n   END\nADDRESS SYSTEM\nCOMM\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LDSITEST": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x912_\\x00\\x92!/\\x16\\x11\\x00A\\x003\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1991-11-21T00:00:00", "modifydate": "1992-07-30T16:11:00", "lines": 65, "newlines": 51, "modlines": 0, "user": "FILE020"}, "text": "/*====REXX===========================================================*/\n/*                                                                   */\n/*         This REXX demonstrates the use of the LISTDSI function.   */\n/*   The function returns a lot of information about a catalogued    */\n/*   data set.  All the current information is displayed after a     */\n/*   successful call.  If the call was not successful, the reason    */\n/*   code is rshown which can be checked in the REXX ref. manual.    */\n/*                                                                   */\n/*===================================================================*/\n\nparse upper arg dsn                         /* get command line args */\ndo while length(strip(dsn,'B')) = 0         /* process sans blanks   */\n   say 'Please enter the dsn or add it to the command line.'\n   parse pull dsn                           /* if none, prompt user  */\n   say 'dsn =' dsn\n   end\n\nx = listdsi(dsn)                            /* call the LISTDSI rtn  */\nif x \u00ac= '0' then do                         /* check return code     */\n  say 'LISTDSI returned a code of' x'.'     /* say bad return        */\n  say 'The returned reason code was' sysreason'.'\n  exit 8                                    /* return code of 8      */\n  end\nsay 'LISTDSI returned the following information about' sysdsname'.'\nline = 'SYSVOLUME   =' SYSVOLUME   '            '\nline = substr(line,1,25) 'SYSUNIT     =' SYSUNIT\nsay line\nline = 'SYSDSORG    =' SYSDSORG    '            '\nline = substr(line,1,25) 'SYSRECFM    =' SYSRECFM\nsay line\nline = 'SYSLRECL    =' SYSLRECL    '            '\nline = substr(line,1,25) 'SYSBLKSIZE  =' SYSBLKSIZE\nsay line\nline = 'SYSKEYLEN   =' SYSKEYLEN   '            '\nline = substr(line,1,25) 'SYSALLOC    =' SYSALLOC\nsay line\nline = 'SYSUSED     =' SYSUSED     '            '\nline = substr(line,1,25) 'SYSPRIMARY  =' SYSPRIMARY\nsay line\nline = 'SYSSECONDS  =' SYSSECONDS  '            '\nline = substr(line,1,25) 'SYSUNITS    =' SYSUNITS\nsay line\nline = 'SYSEXTENTS  =' SYSEXTENTS  '            '\nline = substr(line,1,25) 'SYSCREATE   =' SYSCREATE\nsay line\nline = 'SYSREFDATE  =' SYSREFDATE  '            '\nline = substr(line,1,25) 'SYSEXDATE   =' SYSEXDATE\nsay line\nline = 'SYSPASSWORD =' SYSPASSWORD '            '\nline = substr(line,1,25) 'SYSRACFA    =' SYSRACFA\nsay line\nline = 'SYSUPDATED  =' SYSUPDATED  '            '\nline = substr(line,1,25) 'SYSTRKSCYL  =' SYSTRKSCYL\nsay line\nline = 'SYSBLKSTRK  =' SYSBLKSTRK  '            '\nline = substr(line,1,25) 'SYSADIRBLK  =' SYSADIRBLK\nsay line\nline = 'SYSUDIRBLK  =' SYSUDIRBLK  '            '\nline = substr(line,1,25) 'SYSMEMBERS  =' SYSMEMBERS\nsay line\nline = 'SYSREASON   =' SYSREASON   '            '\nline = substr(line,1,25) 'SYSMSGLVL1  =' SYSMSGLVL1\nsay line\nline = 'SYSMSGLVL2  =' SYSMSGLVL2\nsay line\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTAPFT": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x01\\x130\\x9f\\x01\\x130\\x9f\\x13\\t\\x00A\\x00M\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "2013-11-05T00:00:00", "modifydate": "2013-11-05T13:09:00", "lines": 65, "newlines": 77, "modlines": 0, "user": "SCNS03T"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTAPFT: REXX program to display APF table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\ncvt = c2d(storage(10,4))                       /* point to cvt        */\n@cvt = D2X(cvt)                                /* binary to hex       */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\n@ecvt = STORAGE(D2X(X2D(@cvt)+140),4)          /* get CVTAUTHL addres */\n@ecvt = D2X(C2D(@ecvt))                        /* binary to hex       */\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)      /* get CVTAUTHL addres */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\nif X2D(@cvtauthl) <> c2d('7ffff001'x) then      /*dynamic list ?   @@ */\ndo          /* Static format  */\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))   /* length of next     */\n   apfvol.i  = substr(apflib.i,1,6)                /* apf vol         */\n   apfdsn.i  = substr(apflib.i,7,44)               /* apf dsn         */\nEnd\nEnd         /* Static format  */\nElse        /* Dynamic format */\n  do\n    Say 'The eCVT is located at '@ecvt '('X2D(@ecvt)')'\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    i = 0\n    do forever\n      apfdsn.i = storage(d2x(apht+24),44)      /* apf dataset name    */\n      if substr(apfdsn.i,1,1) \u00ac= '00'x then    /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then apfvol.i = '*SMS* '\n          else apfvol.i = storage(d2x(apht+68),6)   /* apf volser     */\n          i = i + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    apfcount = i - 1\n  end       /* Dynamic format */               /* set maximum lines   */\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nSay 'The APF table contains 'apfcount 'entries, as follows:'\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\ndo i = 1 to apfcount                       /* for each line       */\n  say apfvol.i' 'left(apfdsn.i,45) i       /* build output line   */\nend\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTAPF2": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x01\\x130_\\x01\\x130\\x9f\\x122\\x00M\\x00(\\x00\\x00\\xe2\\xc3\\xd5\\xe2\\xf0\\xf3\\xe3@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2013-11-01T00:00:00", "modifydate": "2013-11-05T12:32:00", "lines": 77, "newlines": 40, "modlines": 0, "user": "SCNS03T"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTAPFT: REXX program to display APF table from CSTOR.        */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*             APFTAB - Undocumented in MVS DATA AREAS book.     */\n/*                                                               */\n/*                                                               */\n/*                                                               */\n/*****************************************************************/\nnumeric digits 30\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                          /* binary to hex       */\n\ncvt = c2d(storage(10,4))                       /* point to cvt        */\necvt = c2d(storage(d2x(cvt+140),4))            /* point to cvtecvt    */\n@ecvt = STORAGE(D2X(X2D(@cvt)+140),4)          /* get CVTAUTHL addres */\n@ecvt = D2X(C2D(@ecvt))                        /* binary to hex       */\n\n@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)      /* get CVTAUTHL addres */\n@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */\nsay '@cvtauthl= '@cvtauthl\nsay 'compare1= 'c2d('7ffff001'x)\nSay 'The CVT  is located at '@cvt '('X2D(@cvt)')'\nSay 'The eCVT is located at '@ecvt '('X2D(@ecvt)')'\nSay 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'\nif X2D(@cvtauthl) <> c2d('7ffff001'x) then      /*dynamic list ?   @@ */\ndo          /* Static format  */\nsay 'Static Format'\napfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */\napfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */\n@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */\nSay 'The APF table contains 'apfcount 'entries, as follows:'\nSay ' '\nDo i = 1 to apfcount                            /* loop thru storage  */\n   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */\n   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */\n   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))   /* length of next  */\nEnd\nSay 'VOLSER --------------DATA SET NAME-----------------'\nSay ' '\nDo i = 1 to apfcount                            /* print the list     */\n   Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i\nEnd\nEnd         /* Static format  */\nElse        /* Dynamic format */\n  do\n    say 'Dynamic Format'\n    ecvtcsvt = c2d(storage(d2x(ecvt+228),4))   /* point to ecvtcsvt   */\n    apfa = c2d(storage(d2x(ecvtcsvt+12),4))    /* addr start of list  */\n    apht = c2d(storage(d2x(apfa+8),4))         /* addr 1st entry      */\n    last = c2d(storage(d2x(apfa+12),4))        /* addr last entry     */\n    apf. = ''\n    inc = 0\n    do forever\n      apfdsn = storage(d2x(apht+24),44)        /* apf dataset name    */\n      if substr(apfdsn,1,1) \u00ac= '00'x then      /* 00 = deleted        */\n        do\n          apfesms = storage(d2x(apht+4),1)     /* sms flag            */\n          if  bitand(apfesms,'80'x)  = '80'x then apfvol = '*SMS* '\n          else apfvol = storage(d2x(apht+68),6)   /* apf volser       */\n          line.inc =left(apfdsn,45)||apfvol\n          inc = inc + 1\n        end\n      if apht = last then leave\n      else apht = c2d(storage(d2x(apht+8),4))  /* addr next entry     */\n    end\n    apfcount = inc - 1\n    Say 'The APF table contains 'apfcount 'entries, as follows:'\n\n  do inc = 1 to apfcount                       /* for each line       */\n    say ' 'line.inc                            /* build output line   */\n  end\n  end       /* Dynamic format */               /* set maximum lines   */\nExit\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTDASD": {"ttr": 1298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x01\\x15\\x02_\\x01\\x15\\x02o\\x18@\\x00~\\x00\\x82\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf2\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-26T18:40:00", "lines": 126, "newlines": 130, "modlines": 0, "user": "FILE220"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTDASD: REXX program to display all online DASD devices.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCB - Device Unit Control Block                */\n/*                DCE - Device Class Extension                   */\n/*                VIP - VTOC Information Block                   */\n/* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */\n@cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/\n@cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n@cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n@iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n@iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n@ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)    /* get IOVT address    */\n@ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\nif @ulutadr = 0 then                            /* zOS V2.2 or higher */\n  do\n   Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n   @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n   @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n  end\nulu      = STORAGE(@ulutadr,64)             /* get 64 byte ulu header */\nuluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\nulutype  = SUBSTR(ulu,5,1)                         /* ulut Type 1 or 2*/\nIf ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\nIf ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\nIf ulutype = '03'x Then                            /* ULUT Type 3     */\n Do\n   ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n   uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n   off = 12\n End\nElse\n Do                                     /* Ulut type 1 or 2           */\n   ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n   uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n End\n uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n @uluchn  = C2X(ulufirst)\nSay 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> DASD chain trace started: 'TIME()\nSay '            CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\nSay ' '\nSay '     This I/O configuration has 'C2D(ulutdasd)' DASD UCBs defined!'\nSay ' '\ni = 0 ; J = 0 ; pri = 0 ; pub = 0 ; sto = 0 ; smsv = 0\nDo i = 1 to C2D(uluucbno)               /* scan the ULUT for ALL DASD */\n    uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n    uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n    uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n   ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */\n   ucbfl5  = SUBSTR(ucb,2,1)                  /* get flags5 bitstring */\n   ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */\n   ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */\n   ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */\n   ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */\n   ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '20'x is DASD */\n   ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */\n   If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'20'x)='20'x) Then Do\n      j = j + 1; device = ' Unknown'\n      ioaddr = C2X(ucbchan)\n      If BITAND(ucbfl5,'20'x)\\='20'x Then sms = 'Not SMS'\n                                     Else Do\n                                          sms = 'SMS    '\n                                          smsv = smsv + 1\n                                          End\n      If BITAND(ucbtbyt4,'04'x)='04'x Then device = '9340   '\n      If BITAND(ucbtbyt4,'06'x)='06'x Then device = '2305-1 '\n      If BITAND(ucbtbyt4,'07'x)='07'x Then device = '2305-2 '\n      If BITAND(ucbtbyt4,'08'x)='08'x Then device = '2314   '\n      If BITAND(ucbtbyt4,'09'x)='09'x Then device = '3330   '\n      If BITAND(ucbtbyt4,'0D'x)='0D'x Then device = '3330-11'\n      If BITAND(ucbtbyt4,'0A'x)='0A'x Then device = '3340   '\n      If BITAND(ucbtbyt4,'0B'x)='0B'x Then device = '3350   '\n      If BITAND(ucbtbyt4,'0C'x)='0C'x Then device = '3375   '\n      If BITAND(ucbtbyt4,'85'x)='85'x Then device = '6421   ' /*facom*/\n      If BITAND(ucbtbyt4,'0E'x)='0E'x Then device = '3380   '\n      If BITAND(ucbtbyt4,'0F'x)='0F'x Then device = '3390   '\n      @ucbx   = SUBSTR(ucb,21,4)          /* address of ucb extension */\n      @ucbx   = D2X(C2D(@ucbx))               /* binary to dec to hex */\n      @dce    = STORAGE(D2X(X2D(@ucbx)+24),4)       /* address of DCE */\n      @dce    = D2X(C2D(@dce))                /* binary to dec to hex */\n      @vib    = STORAGE(D2X(X2D(@dce)+4),4)         /* address of VIB */\n      @vib    = D2X(C2D(@vib))                /* binary to dec to hex */\n      vibflags= STORAGE(D2X(X2D(@vib)+6),1)    /* VTOC info flag byte */\n      If BITAND(vibflags,'80'x)='80'x Then vtocix = 'VTOCIX'\n                                      Else vtocix = '      '\n      @vvds   = STORAGE(D2X(X2D(@dce)+8),4)  /* address of VVDS block */\n      If C2D(@vvds) = 0 Then vvds = '    '\n                        Else vvds = 'VVDS'\n      @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to DASD segment */\n      ucbdasd = STORAGE(@ucbchn,24)       /* get 24 byte DASD segment */\n      ucbvoli = SUBSTR(ucbdasd,5,6)              /* volser if mounted */\n      ucbstab = SUBSTR(ucbdasd,11,1)         /* mount attribute codes */\n      mount = 'Unknown '\n      If BITAND(ucbstab,'10'x)='10'x Then Do\n         mount = 'Private'\n         pri = pri + 1\n         End\n      If BITAND(ucbstab,'08'x)='08'x Then Do\n         mount = 'Public '\n         pub = pub + 1\n         End\n      If BITAND(ucbstab,'04'x)='04'x Then Do\n         mount = 'Storage'\n         sto = sto + 1\n         End\n      Say RIGHT(j,4,' ') ucbvoli RIGHT(ioaddr,4) STRIP(device),\n          mount vtocix vvds sms\n   End\n   @uluchn  = D2X(x2d(@uluchn)+12)\nEnd\nSay ' '\nSay 'Summary ===>  Private: 'pri'  Storage: 'sto'  Public: 'pub'  SMS: 'smsv\nSay ' '\nSay 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTDCQ": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x01\\x15\\x02_\\x01\\x15\\x02o\\x18@\\x00\\x89\\x00\\x8a\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf2\\xf0@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-26T18:40:00", "lines": 137, "newlines": 138, "modlines": 0, "user": "FILE220"}, "text": "/*REXX*/\n/*****************************************************************/\n/* LISTDCQ: REXX program to display the device class queue.      */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                DCQ - Device Class Queue                       */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/*               ULUT - UCB Look Up table                        */\n/* UCB count, 1st UCB addr, # Act and Inact now derived from ULUT*/\n/* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                                /* binary to hex */\n@cvtdcqa  = STORAGE(D2X(X2D(@cvt)+1248),4)     /* get CVTDCQA address */\n@cvtdcqa  = D2X(C2D(@cvtdcqa))                       /* binary to hex */\n@cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n@cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n@iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n@iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n@ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)       /* get ULUT address */\n@ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\nif @ulutadr = 0 then                            /* zOS V2.2 or higher */\n  do\n   Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n   @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n   @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n  end\nSay 'CVT:'@cvt' CVTDCQA:'@cvtdcqa' ==> Device Class Queue 'DATE() TIME()\nSay '           CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\nSay ' '\ndcq      = STORAGE(@cvtdcqa,20)             /* get 20 byte DCQ header */\ndcqname  = SUBSTR(dcq,1,4)                          /* dcq eyecatcher */\ndcqlngth = SUBSTR(dcq,5,2)                /* length of each dcq entry */\ndcqcount = SUBSTR(dcq,7,2)                      /* number of elements */\ndcqfirst = SUBSTR(dcq,9,4)              /* address of 1st dcq element */\ndcqdstct = SUBSTR(dcq,13,4)    /* entries in device class stats table */\ndcqucbno = SUBSTR(dcq,17,4) /* number of ucb's this I/O configuration */\n@dcqchn  = C2X(dcqfirst) ; i = 0\nulu      = STORAGE(@ulutadr,64)             /* get 56 byte ulu header */\nuluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\nulutype  = SUBSTR(ulu,5,1)\nIf ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\nIf ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\nIf ulutype = '03'x Then                            /* ULUT Type 3     */\n Do\n   ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n   uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n   off = 12\n End\nElse\n Do                                     /* Ulut type 1 or 2           */\n   ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n   uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n End\n uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n ulutdisp = SUBSTR(ulu,33+off,4)        /* # of DISP UCBs in I/O cfg  */\n uluturec = SUBSTR(ulu,37+off,4)        /* # of UREC UCBs in I/O cfg  */\n ulutchar = SUBSTR(ulu,41+off,4)        /* # of CHAR UCBs in I/O cfg  */\n ulutctca = SUBSTR(ulu,45+off,4)        /* # of CTCA UCBs in I/O cfg  */\n@uluchn  = C2X(ulufirst)\nSay ' This I/O configuration has defined - DCQ UCBs: 'C2D(dcqucbno)\nSay '                                     ULUT Type: 'C2D(ulutype)\nSay '                                     ULUT UCBs: 'C2D(uluucbno)\nSay '                                         DCQEs: 'C2D(dcqcount)\nSay '                                       1stDCQE: '@dcqchn\nSay '                                       1stULUT: 'D2X(C2D(ulufirst))\nSay ' '\nSay '      Name____  ID_   UCBs   1stUCB__   Active   Inactive  ID=UCB'\nSay ' '\nDo i = 1 to C2D(dcqcount)          /* scan the DCQ for all dev classes*/\n   dcqelmnt = STORAGE(@dcqchn,28)          /* get 28 byte DCQ element */\n   dcqchain = SUBSTR(dcqelmnt,1,4)      /* get next element's address */\n   @dcqchn  = D2X(C2D(dcqchain))\n   dcqdevc.i = SUBSTR(dcqelmnt,5,1)    /* device class, i.e. UCBTBYT3 */\n   dcqucbct = SUBSTR(dcqelmnt,7,2)     /* ucb's for this device class */\n   dcqucbct = C2D(dcqucbct)\n   dcqucbad = SUBSTR(dcqelmnt,9,4)       /* 1st ucb this device class */\n   dcqucba.i = C2X(dcqucbad)             /* first UCB address in DCQ  */\n   dcqdevn.i = SUBSTR(dcqelmnt,13,8)             /* device class name */\n   act.i = 0 ; inact.i = 0 ; chk.i = 0        /* Initialize counters  */\n   uluucbc.i = 0 ; ok.i ='ERROR'              /* Initialize counters  */\nEnd                                                /* END oF DCQ scan */\n Do j = 1 to C2D(uluucbno)              /* scan the ULUT for ALL UCBs */\n     uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n     uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n     uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n      ucb     = STORAGE(@ucbchn,24) /* get 24 byte ucb common segment */\n      ucbstat = SUBSTR(ucb,4,1)           /* status byte '80'x online */\n      ucbnxucb= SUBSTR(ucb,9,4)                /* pointer to next ucb */\n      ucbtbyt3= SUBSTR(ucb,19,1)           /* device ID like dcqdevcl */\n   Do k = 1 to C2D(dcqcount)           /* loop through all dev classes*/\n      If ucbtbyt3 = dcqdevc.k Then\n        Do\n          chk.k = chk.k + 1\n          If BITAND(ucbstat,'80'x)='80'x Then act.k = act.k + 1\n                                     Else inact.k = inact.k + 1\n          If chk.k = 1 Then uluucba.k = uluucbad  /* 1st UCB from ULUT*/\n          uluucbc.k = uluucbc.k + 1\n        End\n   end                                 /* End  through all dev classes*/\n   @uluchn  = D2X(x2d(@uluchn)+12)\n End                                               /* End of ULUT scan*/\nSay ' '\n   Do l = 1 to C2D(dcqcount)                     /*  Print output     */\n   Select\n     When dcqdevn.l = 'TAPE' Then\n       If uluucbc.l = X2D(C2X(uluttape)) then ok.l = '*okay*'\n     When dcqdevn.l = 'COMM' Then\n       If uluucbc.l = X2D(C2X(ulutcomm)) then ok.l = '*okay*'\n     When dcqdevn.l = 'DASD' Then\n       If uluucbc.l = X2D(C2X(ulutdasd)) then ok.l = '*okay*'\n     When dcqdevn.l = 'DISP' Then\n       If uluucbc.l = X2D(C2X(ulutdisp)) then ok.l = '*okay*'\n     When dcqdevn.l = 'UREC' Then\n       If uluucbc.l = X2D(C2X(uluturec)) then ok.l = '*okay*'\n     When dcqdevn.l = 'CHAR' Then\n       If uluucbc.l = X2D(C2X(ulutchar)) then ok.l = '*okay*'\n     Otherwise\n       If uluucbc.l = X2D(C2X(ulutctca)) then ok.l = '*okay*'\n   End\n   If uluucbc.l = 0 Then Do\n      uluucba.l = '        '\n      act.l    = '    ' ; inact.l  = '    ' ; ok.l     = '      '\n   End\n   Say RIGHT(l,3)'   'dcqdevn.l'  'C2X(dcqdevc.l)'x',\n       '  'RIGHT(uluucbc.l,4)'   'uluucba.l,\n       '   'RIGHT(act.l,4)'      'RIGHT(inact.l,4)'    'ok.l\n   end                                           /* End  Print output */\nSay ' '\nSay 'Device Class Queue scan completed 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTTAPE": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x01\\x15\\x02_\\x01\\x15\\x02o\\x18A\\x00V\\x00V\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf2\\xf2\\xf0@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2015-01-25T00:00:00", "modifydate": "2015-01-26T18:41:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "FILE220"}, "text": "/*REXX*/\n/*****************************************************************/\n/*LISTTAPE: REXX program to display all online TAPE devices.     */\n/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */\n/*****************************************************************/\n/* MVS DATA AREAS:                                               */\n/*                CVT - Communications Vector Table (@'10'x)     */\n/*                UCB - Device Unit Control Block                */\n/*                                                               */\n/* @ z/OS V2.2 the ULUT has been moved into 64 bit storage.      */\n/*                                                               */\n/*****************************************************************/\nAddress TSO ; \"CLEAR\" ; Numeric Digits 20    /* 20 can handle 64 bits */\n@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */\n@cvt = D2X(C2D(@cvt))                    /* binary to dec to hex      */\n@cvtucba  = STORAGE(D2X(X2D(@cvt)+1252),4)   /* get CVTUCBA address   */\n@cvtucba  = D2X(C2D(@cvtucba))                 /* binary to dec to hex*/\n@cvtixav  = STORAGE(D2X(X2D(@cvt)+124),4)      /* get CVTIXAVL addres */\n@cvtixav  = D2X(C2D(@cvtixav))                       /* binary to hex */\n@iovtadr  = STORAGE(D2X(X2D(@cvtixav)+208),4)  /* get IOVT address    */\n@iovtadr  = D2X(C2D(@iovtadr))                       /* binary to hex */\n@ulutadr  = STORAGE(D2X(X2D(@iovtadr)+8),4)    /* get IOVT address    */\n@ulutadr  = D2X(C2D(@ulutadr))                       /* binary to hex */\nif @ulutadr = 0 then                            /* zOS V2.2 or higher */\n  do                                            /* or V2.1/V1.13 w/PTF*/\n   Say 'zOS:'MVSVAR(SYSOPSYS)' Ulut is in 64 bit storage'\n   @ulutadr  = STORAGE(D2X(X2D(@iovtadr)+440),8)  /* get IOVT address */\n   @ulutadr  = D2X(C2D(@ulutadr))                    /* binary to hex */\n  end\nulu      = STORAGE(@ulutadr,64)             /* get 64 byte ulu header */\nuluname  = SUBSTR(ulu,1,4)                         /* ulut eyecatcher */\nulutype  = SUBSTR(ulu,5,1)\nIf ulutype = '01'x Then off = 0                    /* ULUT Type 1     */\nIf ulutype = '02'x Then off = 8                    /* ULUT Type 2     */\nIf ulutype = '03'x Then                            /* ULUT Type 3     */\n Do\n   ulufirst = SUBSTR(ulu,17,8)          /* addr of 1st ULU element(64)*/\n   uluucbno = SUBSTR(ulu,29,4)          /* # of ucb's this I/O config */\n   off = 12\n End\nElse\n Do                                     /* Ulut type 1 or 2           */\n   ulufirst = SUBSTR(ulu,13+off,4)      /* address of 1st ULU element */\n   uluucbno = SUBSTR(ulu,17+off,4)      /* # of ucb's this I/O config */\n End\n uluttape = SUBSTR(ulu,21+off,4)        /* # of TAPE UCBs in I/O cfg  */\n ulutcomm = SUBSTR(ulu,25+off,4)        /* # of COMM UCBs in I/O cfg  */\n ulutdasd = SUBSTR(ulu,29+off,4)        /* # of DASD UCBs in I/O cfg  */\n @uluchn  = C2X(ulufirst)\nSay 'CVT: '@cvt' CVTUCBA: '@cvtucba' ===> TAPE UCB scan started: 'TIME()\nSay '            CVTIXAV:'@cvtixav' IOVT:'@iovtadr' ULUT: '@ulutadr\nSay '                                        ULUT Type: 'C2D(ulutype)\nSay ' '\nSay '     This I/O configuration has 'C2D(uluttape)' TAPE UCBs defined!'\nSay ' '\n@ucbchn = @cvtucba\ni = 0 ; j = 0\nDo i = 1 to C2D(uluucbno)               /* scan the ULUT for ALL DASD */\n    uluelmnt = STORAGE(@uluchn,12)       /* get 12 byte ULUT element */\n    uluucbad = SUBSTR(uluelmnt,9,4)     /* 1st ucb this device class */\n    uluucbad = C2X(uluucbad) ; @ucbchn = uluucbad\n   ucb     = STORAGE(@ucbchn,24)    /* get 24 byte ucb common segment */\n   ucbid   = SUBSTR(ucb,3,1)                 /* get the 'FF'x id byte */\n   ucbstat = SUBSTR(ucb,4,1)              /* status byte '80'x online */\n   ucbchan = SUBSTR(ucb,5,2)                /* channel address in hex */\n   ucbnxucb= SUBSTR(ucb,9,4)                   /* pointer to next ucb */\n   ucbtbyt3= SUBSTR(ucb,19,1)                 /* device '80'x is TAPE */\n   ucbtbyt4= SUBSTR(ucb,20,1)           /* contains device type codes */\n   If (BITAND(ucbstat,'80'x)='80'x & BITAND(ucbtbyt3,'80'x)='80'x) Then Do\n      j = j + 1; device = 'Unknown'\n      ioaddr = C2X(ucbchan)\n      If BITAND(ucbtbyt4,'80'x)='80'x Then device = '3480   '\n      If BITAND(ucbtbyt4,'01'x)='01'x Then device = '2400   '\n      If BITAND(ucbtbyt4,'03'x)='03'x Then device = '3420   '\n      If BITAND(ucbtbyt4,'81'x)='81'x Then device = '3490E  '\n      @ucbchn=D2X(X2D(@ucbchn)+24)            /* bump to TAPE segment */\n      ucbtape = STORAGE(@ucbchn,24)       /* get 24 byte TAPE segment */\n      ucbfser = SUBSTR(ucbtape,5,6)              /* volser if mounted */\n      If C2X(ucbfser) = '000000000000' Then ucbfser = '-idle-'\n      Say RIGHT(j,3,' ') RIGHT(ioaddr,3) STRIP(device) ucbfser\n   End\n   @uluchn  = D2X(x2d(@uluchn)+12)\nEnd\nSay ' '\nSay 'Last UCB after 'i' blocks scanned.  Completed: 'TIME()\nExit\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LNKLIST": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x91\\x13_\\x00\\x91&\\x9f\\x15(\\x00^\\x004\\x00^\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-05-15T00:00:00", "modifydate": "1991-09-26T15:28:00", "lines": 94, "newlines": 52, "modlines": 94, "user": "FILE020"}, "text": "/*  THIS REXX LISTS ALL THE LLT LIBRARIES BY BROWSING              */\n/*  THE LINK LIST TABLE ADDRESSED FROM OFFSET 1244                 */\n/*  IN THE CVT.                                                    */\n/*  THE LAYOUT IS:                                                 */\n/*         CONSTANT             3 'LLT'                            */\n/*         NUMBER OF ENTRIES    4                                  */\n/*         LEN OF ENTRY         1        )   TIMES NUM             */\n/*         DSN                  44       )   OF ENTRIES            */\n/*  THE DSN IS PADDED WITH BLANKS SO THE LENGTH                    */\n/*  ISN'T USED.                                                    */\nARG     FLNAME\nCLEAR                             /* CLEAR SCREEN BEFORE STARTING  */\n\nCVT     = STORAGE(10,4)           /* MEMORY @ 16 POINTS TO CVT     */\nCCVT    = C2X(CVT)                /* CHARACTERIZE CVT ADDRESS      */\nDCVT    = C2D(CVT)                /* DECIMAL CVT ADDR              */\n\nSMCA    = DCVT + 196              /* ADD JESCT OFFSET (C4)         */\nSMCA    = D2X(SMCA)               /* CONVERT TO HEX                */\nSMCA    = STORAGE(SMCA,4)         /* GET SMCA ADDRESS FROM CVT     */\nSMCA    = C2X(SMCA)               /* CHARACTERIZE SMCA ADDRESS     */\nIF LEFT(SMCA,1) > 7 THEN DO       /* CHECK FOR 31 BIT ADDRESS      */\n   CHAR = LEFT(SMCA,1) - 8        /* REMOVE HIGH BIT FROM NIBBLE   */\n   SMCA = CHAR || RIGHT(SMCA,7)   /* REMAKE ADDRESS MINUS HIGH BIT */\nEND\nSMCA    = X2D(SMCA)               /* DECIMALIZE ADDRESS            */\nSMFID   = SMCA + 16               /* POINT TO SMFID ( OFFSET 16 )  */\nSMFID   = D2X(SMFID)              /* HEXIFY ADDRESS OF SMFID       */\nSMFID   = STORAGE(SMFID,4)        /* GET SMFID FROM MEMORY         */\n\nDLLT    = DCVT + 1244             /* DECIMAL LLT ADDR              */\nLLT     = D2C(DLLT,4)             /* LLT  TAB ADDRESS              */\nCLLT    = C2X(LLT)                /* CHAR LLT ADDR                 */\nADDR1   = STORAGE(CLLT,4)         /* ADDRESS OF AUTH TAB           */\nCADDR1  = C2X(ADDR1)              /* CHAR ADDR OF LLT              */\nDATA    = STORAGE(CADDR1,8)       /* GET LUMP OF DATA              */\nNUMENT  = SUBSTR(DATA,5,4)        /* NUMBER OF ENTRIES             */\nDNUMENT = C2D(NUMENT)             /* CONVERT TO DECIMAL            */\nLEN     = (DNUMENT * 45) + 8      /* MAX SIZE REQ                  */\nDATA    = STORAGE(CADDR1,LEN)     /* GET LUMP OF DATA              */\n\nDLINK   = DCVT + 8                /* DECIMAL LINK ADDR             */\nHLINK   = D2X(DLINK)              /* HEX LINK ADDRESS              */\nLADDR   = STORAGE(HLINK,4)        /* TABLE ADDRESS                 */\nCLADDR  = C2X(LADDR)              /* CHAR ADDR OF LINK             */\nDLADDR  = X2D(CLADDR)             /* DECIMALIZE ADDR               */\nDLADDR  = DLADDR + 44             /* ADD OFFSET OF 44(2C)          */\nHLADDR  = D2X(DLADDR)             /* RE-HEXIFY ADDR                */\nLDCB    = STORAGE(HLADDR,4)       /* GET DCB ADDRESS               */\nCLDCB   = C2X(LDCB)               /* CONVERT TO CHARS              */\nDLDCB   = X2D(CLDCB)              /* DECIMALIZE ADDRESS            */\nHLDCB   = DLDCB + 32              /* ADD OFFSET FOR #1             */\n\nNEWSTACK\nIF  FLNAME \\= '' THEN\n    \"ALLOC FI(TEMP) DA(\"FLNAME\") SHR REU\"\nSAY '       LINKLIST LIBRARIES ('SMFID')'\nSAY '   ' DATE(U) '     ' TIME()\nSAY 'BEG TTR  END TTR    LIBRARY NAME'\nIF FLNAME \u00ac= ' ' THEN DO\n   QUEUE '       LINKLIST LIBRARIES ('SMFID')'\n   QUEUE '   ' DATE(U) '     ' TIME()\n   QUEUE 'BEG TTR  END TTR    LIBRARY NAME'\nEND\nSTART   = 10                      /* START OF 1ST ENTRY            */\nDO I = 1 TO DNUMENT\n   DSN   = SUBSTR(DATA,START,44)\n   START = START + 45\n   HLDCB = D2X(HLDCB)\n   TTRS = STORAGE(HLDCB,16)\n   CYL1 = SUBSTR(TTRS,7,2)\n   CYL2 = SUBSTR(TTRS,11,2)\n   HEAD1 = SUBSTR(TTRS,13,1)\n   HEAD2 = SUBSTR(TTRS,14,1)\n   CYL1 = C2X(CYL1)\n   CYL2 = C2X(CYL2)\n   HEAD1 = C2X(HEAD1)\n   HEAD2 = C2X(HEAD2)\n   DSN = CYL1 HEAD1' ' CYL2 HEAD2' ' DSN\n   SAY DSN\n   IF FLNAME \u00ac= ' ' THEN QUEUE DSN\n   HLDCB = X2D(HLDCB)\n   HLDCB = HLDCB + 16\nEND\nSAY\nSAY 'THE NUMBER OF LIBRARIES IN THE LNKLST IS ' DNUMENT\nQUEUE ' '\nQUEUE 'THE NUMBER OF LIBRARIES IN THE LNKLST IS ' DNUMENT\nIF  FLNAME \\= '' THEN DO\n   SAY '** SAVING LIST TO' FLNAME' STARTED **'\n   \"EXECIO * DISKW TEMP (FINIS\"\n   \"FREE F(TEMP)\"\nEND\nDELSTACK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LST": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x92\\x16\\x0f\\x00\\x92!/\\x16\\x13\\x00\\xed\\x00\\xe7\\x00\\xed\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1992-06-08T00:00:00", "modifydate": "1992-07-30T16:13:00", "lines": 237, "newlines": 231, "modlines": 237, "user": "FILE020"}, "text": "/*====REXX===========================================================*/\n/*                                                                   */\n/*        This REXX provides an easy and convenient way for users to */\n/*   access data sets for printing, browsing or editing.  There are  */\n/*   acronyms supplied to allow easy access to common system data    */\n/*   as well as the standard prefix insertion and the over ride      */\n/*   option of apostrophes.  There is also a help member that is     */\n/*   listed when the REXX is invoked without arguments.  The help    */\n/*   member is in the SYSHELP concatenation.                         */\n/*                                                                   */\n/*===================================================================*/\nARG SEL\nIF SEL = '' THEN\n   DO\n      'HELP LST'\n      EXIT 1\n   END\nELSE NOP\nPARSE UPPER VAR SEL V.1 V.2 V.3 V.4 V.5 V.6 V.7 V.8 V.9 JUNK\nDSN = V.1\nDEB =\nPREFIX = 'N'\nACRONYM = 'Y'\nIF LEFT(DSN,1) = \"'\" THEN DO\n   DSN = STRIP(DSN,'B',\"'\")\n   ACRONYM = 'N'\n   END\nELSE IF LENGTH(SYSVAR(SYSPREF)) > 0 THEN PREFIX = 'Y'\nDST = DSN\nMEM =\nMBR =\nX = POS('(',DST)\nIF X > 0 THEN DO\n  DSN = LEFT(DSN,X-1)\n  MBR = SUBSTR(DST,X)\n  MEM = STRIP(MBR,'L','(')\n  MEM = STRIP(MEM,'T',')')\n  END\nFBA =\nPRT = 'N'\nPTR = 'U61'\nERR = 0\nFCB = ''\nCOP = '1'\nEDT = 'BROWSE'\nUSER = SYSVAR(SYSUID)\nDO I = 2 TO 7\n   IF V.I > '' THEN\n      SELECT\n         WHEN ABBREV('EDIT',V.I) = 1   THEN EDT = 'EDIT'\n         WHEN ABBREV('LOCAL',V.I) = 1  THEN PTR = 'LOCAL'\n/*       WHEN ABBREV('2UP',V.I) = 1    THEN FCB = 'FCB(G2UP)'    */\n         WHEN ABBREV('2UP',V.I) = 1    THEN DO\n            'OUTDES SPECIAL PAGEDEF(W12883) FORMDEF(A10112) REUS'\n            FCB = 'OUTDES(SPECIAL)'\n            END\n         WHEN ABBREV('PRINT',V.I) = 1  THEN PRT = 'Y'\n         WHEN ABBREV('ASA',V.I) = 1    THEN FBA = 'ASA'\n         WHEN ABBREV(V.I,'DEBUG') = 1  THEN DEB = 'D'\n         WHEN ABBREV(V.I,'C') = 1      THEN do\n                 IF LENGTH(V.I) = 1 THEN COP = '2'\n                 ELSE COP = SUBSTR(V.I,2,1)\n              END\n         WHEN ABBREV(V.I,'DEST(') = 1   THEN DO\n                 IF RIGHT(V.I,1) \u00ac= ')' THEN DO\n                    say 'Destination id must have a right parenthesis.'\n                    EXIT 4\n                    END\n                 IF LENGTH(V.I) < 7 THEN DO\n                    say 'Destination id is improperly null.'\n                    EXIT 4\n                    END\n                 PTR = SUBSTR(V.I,6,LENGTH(V.I)-6)\n              END\n         OTHERWISE ERR = ERR + 1\n      END\n   ELSE LEAVE\nEND\n/*   IF DEB = 'D' THEN TRACE I                 */\n/*          USER    LIBRARIES                  */\nIF ( ACRONYM = 'Y' ) THEN SELECT\n/*          TEST    LIBRARIES         */\n   WHEN ABBREV('TALL',DSN,2) = 1 THEN DSN = \"'CICST.APP.LOADLIB\"\n   WHEN ABBREV('TMAP',DSN,2) = 1 THEN DSN = \"'CICST.V170.TEST.MAPLIB\"\n   WHEN ABBREV('TCOM',DSN,3) = 1 THEN DSN = \"'TEST1.COMPLINK.OUTPUT\"\n   WHEN ABBREV('TCLB',DSN,3) = 1 THEN DSN = \"'TEST1.COPYLIB\"\n   WHEN ABBREV('TCNT',DSN,3) = 1 THEN DSN = \"'TEST1.CNTLCARD\"\n   WHEN ABBREV('TPRO',DSN,2) = 1 THEN DSN = \"'TEST1.PROCLIB\"\n   WHEN ABBREV('TVCN',DSN,2) = 1 THEN DSN = \"'TEST1.VSAM.CNTLCARD\"\n   WHEN ABBREV('TJCL',DSN,2) = 1 THEN DSN = \"'TSOTECH.JCL.DECKS\"\n/*       PRODUCTION LIBRARIES         */\n   WHEN ABBREV('PMAP',DSN,2) = 1 THEN DSN = \"'CICSP.MAPLIB\"\n   WHEN ABBREV('PCOM',DSN,3) = 1 THEN DSN = \"'PROD1.COMPLINK.OUTPUT\"\n   WHEN ABBREV('PCLB',DSN,3) = 1 THEN DSN = \"'PROD1.COPYLIB\"\n   WHEN ABBREV('PCNT',DSN,3) = 1 THEN DSN = \"'PROD1.CNTLCARD\"\n   WHEN ABBREV('PPRO',DSN,2) = 1 THEN DSN = \"'PROD1.PROCLIB\"\n   WHEN ABBREV('PRDA',DSN,2) = 1 THEN DSN = \"'PROD1.REPORT.DATA\"\n   WHEN ABBREV('PVCN',DSN,2) = 1 THEN DSN = \"'PROD1.VSAM.CNTLCARD\"\n   WHEN ABBREV('TSOD',DSN,2) = 1 THEN DSN = \"'TSOADMN.SOURCE.DATA\"\n   WHEN ABBREV('PJCL',DSN,2) = 1 THEN DSN = \"'TSOPROD.UCC7.JCL\"\n/*           QA     LIBRARIES         */\n   WHEN ABBREV('QMAP',DSN,2) = 1 THEN DSN = \"'QASLBP.CICST.MAPLIB\"\n   WHEN ABBREV('QSBA',DSN,3) = 1 THEN DSN = \"'QASLBP.STAGE1.BATCH\"\n   WHEN ABBREV('QSMA',DSN,3) = 1 THEN DSN = \"'QASLBP.STAGE1.MAPS\"\n   WHEN ABBREV('QSON',DSN,3) = 1 THEN DSN = \"'QASLBP.STAGE1.ONLINE\"\n   WHEN ABBREV('QCLB',DSN,3) = 1 THEN DSN = \"'QASLBP.TEST1.COPYLIB\"\n   WHEN ABBREV('QCNT',DSN,3) = 1 THEN DSN = \"'QASLBP.TEST1.CNTLCARD\"\n   WHEN ABBREV('QPRO',DSN,2) = 1 THEN DSN = \"'QASLBP.TEST1.PROCLIB\"\n   WHEN ABBREV('QVCN',DSN,2) = 1 THEN DSN = ,\n                              \"'QASLBP.TEST1.VSAM.CNTLCARD\"\n   WHEN ABBREV('QJCL',DSN,2) = 1 THEN DSN = \"'QASLBP.TSOTECH.JCL.DECKS\"\nOTHERWISE NOP\nEND\nIF LEFT(DSN,1) = \"'\" THEN DO\n  PREFIX = 'N'\n  DSN = STRIP(DSN,'L',\"'\")\n  END\nIF PREFIX = 'Y' THEN DSN = \"'\"SYSVAR(SYSPREF)\".\"DSN\nELSE DSN = \"'\"DSN\nDST = DSN\nIF LEFT(DST,1) = \"'\" THEN DST = DST || \"'\"\nDSN = DSN || MBR || \"'\"\nIF RIGHT(MEM,1) = '*' THEN MSG = 'OK'\nELSE MSG = SYSDSN(DSN)\nIF MSG /= 'OK' THEN\n   DO\n      PI = ABBREV(DSN,'P')\n      MI = ABBREV(MSG,'MEMBER NOT FOUND')\n      IF (PI = 0 & MI = 1 & EDT = 'EDIT') THEN NOP\n      ELSE ;\n         DO\n            SAY MSG':' DSN\n            EXIT 2\n         END\n   END\nELSE NOP\n/*       */\nX = POS('(',DSN)\nIF ( PRT = 'Y' ) & ( X = 0 ) THEN DO\n   TESTDS = '\"'DSN'\"'\n   X = LISTDSI(DSN)\n   IF LEFT(SYSDSORG,2) = 'PO' THEN DO\n      SAY 'YOU HAVE CHOSEN TO LIST AN ENTIRE PDS.'\n      SAY 'IF THIS IS REALLY YOUR INTENTION, ANSWER'\n      SAY 'YES, ELSE ANSWER NO.'\n      SAY 'DO YOU WANT ALL MEMBERS LISTED (Y/N) ?'\n      PARSE PULL ANS\n      IF ( LEFT(ANS,1) \u00ac= 'Y' ) & ( LEFT(ANS,1) \u00ac= 'Y' ) THEN EXIT 0\n      END\n   EXIT 0\n   END\n/*       */\nIF DATATYPE(COP,'W') = 0 THEN\n   DO\n      SAY 'INVALID NUMBER OF COPIES !'\n      EXIT 3\n   END\nELSE NOP\n/*       */\nIF (PRT = 'N') THEN DO\n  \"ISPEXEC SELECT CMD(SETISR \"EDT\" DATASET(\"DSN\")) NEWAPPL(ISR)\"\n  END\nELSE IF (ABBREV(V.1,'TOUT') = 1 ) | ( ABBREV(V.1,'POUT') = 1) THEN DO\n         MSG = \"'\"USER\".DECOMPRS.MSG'\"\n         ANS = SYSDSN(MSG)\n         IF ANS = 'OK' THEN \"DELETE\" MSG\n         \"ALLOC DD(ISRLMSG) DA(\"MSG\") LRECL(133) BLK(6650) REUSE NEW\" ,\n             \"RECFM(F B A) DSORG(PS) SPACE(10,10) TR RELEASE CATALOG\" ,\n             FCB\n         IF RC \u00ac= 0 THEN DO\n            SAY 'Unable to allocate decompression message file.'\n            EXIT 0\n            END\n         \"ALLOC DD(ISRLEXPD) SYSOUT(A) REUSE DEST(\"PTR\")\"\n         IF RC \u00ac= 0 THEN DO\n            'DELETE' MSG\n            SAY 'Unable to allocate decompression output file.'\n            EXIT 0\n            END\n         \"ALLOC DD(ISRLCODE) DA(\"DST\") SHR REUSE\"\n         IF RC \u00ac= 0 THEN DO\n            'DELETE' MSG\n            'FREE F(ISRLEXPD)'\n            SAY 'Unable to allocate decompression input file.'\n            EXIT 0\n            END\n         \"$ ISRLEMX 'SCR,\"MEM\",B,,E,,,,ENG,,,,,SYSDA'\"\n         IF RC \u00ac= 0 THEN DO\n            'DELETE' MSG\n            'FREE F(ISRLMSG,ISRLCODE)'\n            SAY 'DECOMPRESS OF' DSN ' FAILED.  MESSAGES MAY BE BROWSED.'\n            'ISPEXEC BROWSE DATASET('MSG')'\n            END\n         \"DELETE\" MSG\n         \"FREE F(ISRLCODE,ISRLEXPD)\"\n       END\n/*   ELSE \"PRINTOFF\" DSN \"DEST(\"PTR\") COPIES(\"COP\")\" FBA FCB    */\n     ELSE DO\n        ALLOC = 'ALLOC F(SYSUT1) DA('DSN') SHR REU'\n        ALLOC\n        IF RC \u00ac= 0 THEN DO\n          SAY 'ALLOCATION FAILED :' ALLOC\n          EXIT 8\n          END\n        ALLOC = 'ALLOC F(SYSUT2) SYSOUT(A) DEST('PTR') REU' FCB FBA\n        ALLOC\n        IF RC \u00ac= 0 THEN DO\n          SAY 'ALLOCATION FAILED :' ALLOC\n          IF CHECKDD SYSUT1 = 0 THEN 'FREE F(SYSUT1)'\n          IF CHECKDD SYSUT2 = 0 THEN 'FREE F(SYSUT2)'\n          IF CHECKDD SYSIN = 0 THEN 'FREE F(SYSIN)'\n          EXIT 8\n          END\n        ALLOC = 'ALLOC F(SYSIN) DUMMY REU'\n        ALLOC\n        IF RC \u00ac= 0 THEN DO\n          SAY 'ALLOCATION FAILED :' ALLOC\n          IF CHECKDD SYSUT1 = 0 THEN 'FREE F(SYSUT1)'\n          IF CHECKDD SYSUT2 = 0 THEN 'FREE F(SYSUT2)'\n          IF CHECKDD SYSIN = 0 THEN 'FREE F(SYSIN)'\n          EXIT 8\n          END\n        ALLOC = 'ALLOC F(SYSPRINT) DA(*) SHR REU'\n        ALLOC\n        IF RC \u00ac= 0 THEN DO\n          SAY 'ALLOCATION FAILED :' ALLOC\n          IF CHECKDD SYSUT1 = 0 THEN 'FREE F(SYSUT1)'\n          IF CHECKDD SYSUT2 = 0 THEN 'FREE F(SYSUT2)'\n          IF CHECKDD SYSIN = 0 THEN 'FREE F(SYSIN)'\n          EXIT 8\n          END\n        'IEBGENER'\n        IF CHECKDD SYSUT1 = 0 THEN 'FREE F(SYSUT1)'\n        IF CHECKDD SYSUT2 = 0 THEN 'FREE F(SYSUT2)'\n        IF CHECKDD SYSIN = 0 THEN 'FREE F(SYSIN)'\n        END\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LST#": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x92\\x11\\x1f\\x00\\x92\\x14/\\t!\\x00=\\x00\\x0c\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1992-04-20T00:00:00", "modifydate": "1992-05-21T09:21:00", "lines": 61, "newlines": 12, "modlines": 0, "user": "FILE020"}, "text": ")F FUNCTION -\n   This command will browse, edit or print a sequential dataset or a\n   member of a partitioned dataset (default mode: browse).  Certain\n   commonly used datasets may be accessed by abbreviated names.  To see\n   a current list of these names, issue the LST command without any\n   operands.\n)X SYNTAX -\n       LST dsname EDIT|PRINT ASA 2UP Cn DEST(x)\n)O OPERANDS -\n))DSNAME  1) a fully qualified dataset name enclosed in apostrophes\n          2) a dataset name without the user prefix and no apostrophes\n          3) an acronym from the list below described under ACRONYM\n          Note: for options 1 or 2, the dataset name may be a sequential\n          dataset, or a PDS with or without a member name.  For option\n          3, the acronym may include a member name for a PDS; if none\n          is specified, then a selection panel is displayed showing all\n          member names.\n))EDIT    (or any abbreviation) will display in an edit mode\n))PRINT   (or any abbreviation) will print member or dataset.  NOTE that\n          if a PDS is specified without a member name, then all of the\n          members in the PDS will be printed.\n))ASA     (or any abbreviation) will print dataset using printer\n          carriage control\n))2UP     (or any abbreviation) will print 2 page images to a page\n))Cn      for multiple copies, n is the number of copies desired\n))DEST(x) printer to use for printed output (U61 is the default).  To\n          get output on the third floor printer use DEST(LOCAL).\n))ACRONYM this is not a keyword, but rather an acronym abbreviation for\n          various system libraries shown below.  Letters in parentheses\n          may be omitted as further abbreviations for acronyms.\n\n TYPE        ACRONYM         LIBRARY NAME\n----------------------------------------------------------\n TEST         TA(LL)         CICST.APP.LOADLIB\n              TCL(B)         TEST1.COPYLIB\n              TCN(T)         TEST1.CNTLCARD\n              TV(CN)         TEST1.VSAM.CNTLCARD\n              TJ(CL)         TSOTECH.JCL.DECKS\n              TM(AP)         CICST.V170.TEST.MAPLIB\n              TP(RO)         TEST1.PROCLIB\n              TCO(M)         TEST1.COMPLINK.OUTPUT\n----------------------------------------------------------\n PROD         PCL(B)         PROD1.COPYLIB\n              PCN(T)         PROD1.CNTLCARD\n              PV(CN)         PROD1.VSAM.CNTLCARD\n              PJ(CL)         TSOPROD.UCC7.JCL\n              PM(AP)         CICSP.MAPLIB\n              PCO(M)         PROD1.COMPLINK.OUTPUT\n              PP(RO)         PROD1.PROCLIB\n              PR(DA)         PROD1.REPORT.DATA\n              TS(OD)         TSOADMN.SOURCE.DATA\n----------------------------------------------------------\n  QA          QCL(B)         QASLBP.TEST1.COPYLIB\n              QCN(T)         QASLBP.TEST1.CNTLCARD\n              QV(CN)         QASLBP.TEST1.VSAM.CNTLCARD\n              QJ(CL)         QASLBP.TSOTECH.JCL.DECKS\n              QM(AP)         QASLBP.CICST.MAPLIB\n              QP(RO)         QASLBP.TEST1.PROCLIB\n              QSB(A)         QASLBP.STAGE1.BATCH\n              QSM(A)         QASLBP.STAGE1.MAPS\n              QSO(N)         QASLBP.STAGE1.ONLINE\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "MOO": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x91&?\\x00\\x92!/\\x16\\x15\\x00R\\x00&\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1991-09-20T00:00:00", "modifydate": "1992-07-30T16:15:00", "lines": 82, "newlines": 38, "modlines": 0, "user": "FILE020"}, "text": "/*====REXX===========================================================*/\n/*                                                                   */\n/*        This rexx plays the game of moo.  The object is to guess a */\n/*   four digit number generated by the program.  The number must    */\n/*   have 4 non-repeating digits.  After each guess, the program     */\n/*   tells the player the number of digits in the guess that appear  */\n/*   anywhere in the number to be guessed ( cows ) and the number    */\n/*   of digits in the guess that appear in the same position in the  */\n/*   guess and the target ( bulls ).                                 */\n/*                                                                   */\n/*===================================================================*/\n\nselect = 'do j = 1 to 4;if substr(aim,i,1) = substr(line,j,1) then' ,\n   'cows = cows + 1; end'\nsay ' Should BULLS be excluded form COW count (Y/N) ?'\nparse upper pull line\nif left(line,1,1) = 'Y' then select = 'else' select\nselect = 'if substr(aim,i,1) = substr(line,i,1) then' ,\n   'bulls = bulls + 1;' select\nsum = 0\nngame = 0\ngoagain: ,\naim = genran()\nNGUESS = 0\nguessagain: ,\nnguess = nguess + 1\nreguess: ,\nsay 'Enter guess #' nguess\nparse pull line\npos = index(line,'?')\nif pos \u00ac= 0 then do\n   say 'You gave up on guess #' nguess || '.'\n   say 'The correct number was' aim || '.'\n   ngame = ngame + 1\n   sum = sum + nguess + 5\n   signal offer\n   end\nif datatype(line,'W') \u00ac= 1 then do\n   say 'Guess must be only numerics.  Please re-enter guess #' nguess\n   signal reguess\n   end\nif length(line) \u00ac= 4 then do\n   say 'Guess must be 4 characters.  Please re-enter guess #' nguess\n   signal reguess\n   end\nbulls = 0\ncows = 0\ndo i = 1 to 4\n   interpret select\n   end\nif bulls < 4 then do\n   say 'Bulls =' bulls 'and cows =' cows\n   signal guessagain\n   end\nsay 'CONGRATULATIONS you guessed the number on guess #' nguess || '.'\nngame = ngame + 1\nsum = sum + nguess\noffer: ,\nsay 'Your average for' ngame 'games was' sum / ngame || '.'\nsay 'Would you like to play again ?'\nparse upper pull ans\nif left(ans,1) = 'Y' then signal goagain\nexit\n\ngenran: procedure\ntemp = time('L')\ntemp = right(temp,6)\naim = left(temp,1)\nstart = 2\nnexttry: ,\ndo i = 6 to start by -1\n   next = substr(temp,i,1)\n   pos = index(aim,next)\n   if pos = 0 then do\n      aim = aim || next\n      if length(aim) = 4 then return aim\n      end\n   end\nstart = 1\ntemp = time('L')\ntemp = right(temp,6)\nsignal nexttry\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RDSNALL": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00V\\x00\\x91\\tO\\x01\\x15$/\\x14\\x02\\x01\\x05\\x00\\xa8\\x00z\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1991-04-04T00:00:00", "modifydate": "2015-08-30T14:02:56", "lines": 261, "newlines": 168, "modlines": 122, "user": "SBGOLOB"}, "text": "RDSNALL  TITLE 'TSO CLIST UTILITY - RETURNS DSNAMES FOR GIVEN DDNAME VI+\n               A PUTLINE.'\n*%A AMODGEN\n*\n*=====================================================================*\n*                                                                     *\n*              PROGRAM TO ACCEPT AS INPUT THE DDNAME OF AN ALLOCATED  *\n*        FILE, AND RETURN ALL THE DATA SET NAMES IN THE CONCATENATION *\n*        WITH THEIR DISPOSITIONS AND THE VOLUME SERIAL NUMBER OF THE  *\n*        DISKS THEY RESIDE ON.  THE PROGRAM USES PUTLINE TO OUTPUT    *\n*        IT'S INFORMATION MAKING IT SUITABLE FOR USE IN CLISTS WHERE  *\n*        IT MAY BE DESIREABLE TO USE SYSOUTTRAP TO CAPTURE THE OUTPUT *\n*        AND PROCESS THE LISTS FURTHER.  A RETURN CODE OF OTHER THAN  *\n*        ZERO INDICATES A PROBLEM AND SHOULD BE INVESTIGATED.         *\n*                                                                     *\n*              RETURN CODES ARE AS FOLLOWS:                           *\n*                                                                     *\n*        0     NORMAL RETURN, PROGRAM DETECTED NO ERRORS              *\n*        4     DSNAME MAY BE UNUSEABLE ( DUMMY, JES, TCAM )           *\n*        8     DDNAME IS NOT CURRENTLY ALLOCATED                      *\n*        16    PARSE FAILED ( PROGRAM PROBLEM )                       *\n*                                                                     *\n*=====================================================================*\n*\nRDSNALL  CSECT\nRDSNALL  AMODE 24\nRDSNALL  RMODE 24\n         YREGS\n         SPACE 1\n         USING RDSNALL,R15         USE TEMPORARY BASE.\n         B     BEGIN               BRANCH AROUND HEADER.\n         DC    AL1(HEADEND-HEAD)\nHEAD     DC    C'RDSNALL - &SYSDATE - &SYSTIME - LIST ALL DSNS FOR A DD+\n               NAME'\nHEADEND  EQU   *\nBEGIN    STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.\n         LR    R12,R15             COPY BASE.\n         DROP  R15                 DROP TEMPORARY BASE.\n         USING RDSNALL,R12         (TELL ASSEMBLER).\n         LR    R14,R13             POINT TO CALLER'S SAVE AREA.\n         LA    R13,SAVE            POINT TO MY SAVE AREA.\n         ST    R14,4(,R13)         CHAIN ...\n         ST    R13,8(,R14)         ... SAVE AREAS.\n*\n*        SET UP POINTERS FOR LATER USE\n*\n         LR    R10,R1              PRESERVE POINTER TO CPPL.\n         USING CPPL,R10            (TELL ASSEMBLER).\n         LA    R8,IOPLR            POINT TO IOPL.\n         USING IOPL,R8             (TELL ASSEMBLER).\n         LA    R9,PPLR             POINT TO PPL.\n         USING PPL,R9              (TELL ASSEMBLER).\n         MVC   IOPLUPT,CPPLUPT     MOVE UPT ADDRESS TO IOPL FROM CPPL.\n         MVC   PPLUPT,CPPLUPT       \"    \"     \"     \" PPL    \"   \"\n         MVC   IOPLECT,CPPLECT      \"   ECT    \"     \" IOPL   \"   \"\n         MVC   PPLECT,CPPLECT       \"    \"     \"     \" PPL    \"   \"\n         MVC   PPLCBUF,CPPLCBUF     \"   CBUF   \"     \"  \"     \"   \"\n*\n*        PARSE INPUT LOOKING FOR A  DDNAME TO PROCESS\n*\n         LR    R1,R9               POINT R1 TO THE PPL AND ...\n         CALLTSSR EP=IKJPARS       ... PARSE THE INPUT BUFFER.\n         LTR   R15,R15             DID THE PARSE GO OK?\n         BZ    GOODPRS             B IF YES.  CONTINUE.\n         LR    R1,R8               COPY IOPL POINTER FOR PUTLINE.\n         PUTLINE OUTPUT=(PARSERR),MF=(E,(1)) SAY: PARSE NO GOOD.\n         LA    R15,16              SET CC = 16 ...\n         B     EXIT                ... AND EXIT.\n*\n*        PROCESS DDNAME OBTAINED FROM PARSING INPUT\n*\nGOODPRS  L     R7,ANSWER           POINT TO PARSE PDE(S).\n         USING IKJPARMD,R7         (TELL ASSEMBLER).\n         LH    R1,DDNAMEP+4        LOAD LENGTH OF DDNAME.\n         BCTR  R1,*-*              SS-IFY LENGTH.\n         L     R2,DDNAMEP          POINT TO DDNAME.\n         EX    R1,DDMOVE           MOVE DDNAME TO HOLDER.\n*      ( MVC   DDNAME(*-*),0(R2)   )\n         LA    R1,5(,R1)           FIX LENGTH FOR MESSAGE SEGMENT.\n         STH   R1,DDNAMEH          SAVE LENGTH FOR PUTLINE.\n         IKJRLSA ANSWER            FREE THE PDS(S).\n         DROP  R7\n*\n*        READ THE JFCB OF THE DDNAME INDICATED.\n*\n         MVC   DCB+X'28'(8),DDNAME MOVE DDNAME TO DUMMY DCB.\n         RDJFCB DCB                COPY THE JFCB TO MY AREA.\n         LTR   R15,R15             WAS DDNAME FOUND?\n         BZ    DDFOUND             B IF YES.\n         LR    R1,R8               POINT R1 TO IOPL FOR PUTLINE.\n         PUTLINE OUTPUT=(DDNFERR),MF=(E,(1)) SAY: DDNAME NOT FOUND.\n         LA    R15,8               SET CC OF 8.\n         B     EXIT                EXIT.\n*\n*        CHECK THAT THE ARL PORTION OF THE READJFCB COMPLETED OK.\n*\nDDFOUND  EQU   *\n         LA    R7,LIBJFCB          POINT TO JFCB\n         USING JFCBD,R7            TELL ASSEMBLER ABOUT POINTER\n         ICM   R7,X'F',SLBAREA     GET AND TEST ARL ADDRESS\n         BNZ   ARLGOOD\n         PUTLINE OUTPUT=(ARLFAIL),MF=(E,(1)) SAY: ARL FAILURE.\n         B     EXIT\n*\n*        SET UP REGISTERS TO PROCESS ALL JFCB'S FROM ARL AREA\n*\nARLGOOD  EQU   *\n         LH    R5,SLBCONC          GET COUNT OF CONCATENATED DSN'S\n         L     R6,SLBAREA          POINT TO AREA RETURNED BY ARL\n*\n*        PROCESS ONE JFCB FROM ARL AREA AT A TIME\n*\nNEXTJFCB EQU   *\n         LA    R7,4(,R6)           GET THIS JFCB POINTER\n         USING JFCBD,R7            (TELL ASSEMBLER).\n         MVC   DSN,JFCBDSNM        MOVE DSN TO OUTPUT AREA.\n*\n*        SET UP DATA SET PERMISSIONS IN OUTPUT LINE\n*\n         MVC   PERMIT(1),JFCBIND2  GET INDICATOR BYTE #2\n         NI    PERMIT,X'C8'        AND DOWN TO PERTINENT BITS\n         LA    R15,PRMLEN          GET NUMBER OF TABLE ENTRIES\n         LA    R14,PRMTABL         AND TABLE ADDRESS\n*\n*        LOOP THROUGH PERMISSIONS LOOKING FOR A BIT PATTERN MATCH\n*\nNEXTPRM  CLC   PERMIT(1),0(R14)    COMPARE WITH AN ENTRY\n         BZ    PRMFIND             IF A MATCH WE'RE DONE\n         LA    R14,4(R14)          ELSE BUMP TO NEXT TABLE ENTRY\n         BCT   R15,NEXTPRM         CHECK NEXT ONE OR FALL THROUGH\n*\n*        MOVE MATCHING LITERAL OR *** TO OUTPUT LINE FOR DISPLAY\n*\nPRMFIND  MVC   PERMIT,1(R14)       MOVE LITERAL INTO OUTPUT LINE\n*\n*        PUT FIRST VOLUME SERIAL FOR DATA SET INTO OUTPUT LINE & PRINT\n*\n         MVC   OUTVSER,JFCBVOLS    PUT FIRST VOLSER IN LINE\n         LR    R1,R8               POINT R1 TO IOPL FOR PUTLINE.\n         PUTLINE MF=(E,(1))        OUTPUT DSNAME.\n         LA    R6,180(,R6)         POINT TO NEXT ARL AREA\n         BCT   R5,NEXTJFCB         PROCESS NEXT JFCB\n*\n         LA    R7,LIBJFCB          POINT TO ORIGINAL JFCB\n         USING JFCBD,R7            TELL ASSEMBLER ABOUT POINTER\n         LA    R15,4               SET CC = 4.\n         TM    JFCBTSDM,JFCSDS     IS THIS DATASET JES2 OR ...\n*                                  ... JES3 (SYSOUT OR SYSIN)?\n         BO    EXIT                B IF YES.  LEAVE CC = 4.\n         TM    JFCDSRG2,JFCORGTX+JFCORGTQ+JFCORGTR+JFCORGGS IS THIS\n*                                  TCAM OR GAM DD?\n         BNZ   EXIT                B IF YES.  LEAVE CC = 4.\n         XR    R15,R15             ELSE SET CC TO 0.\n         SPACE 1\nEXIT     EQU   *\n         L     R13,SAVE+4          POINT TO CALLER'S SAVE AREA.\n         L     R14,12(,R13)        RELOAD CALLER'S RETURN ADDRESS.\n         LM    R0,R12,20(R13)      RELOAD BALANCE OF CALLER'S REGS.\n         BR    R14                 RETURN TO CALLER.\n*\n         TITLE 'DATA AREAS.'\n         DS    0D\nSAVE     DS    9D                  SAVE AREA.\n*\nANDMASK  DC    X'00000F0F'         MASK DOWN TO BUSINESS DIGITS\nANSWER   DS    A\n*\nIOPLR    DS    (IOPLL)A            IOPL FOR PUTLINE.\n         ORG   IOPLR+IOPLECB-IOPL\n         DC    A(ECB)              POINTER IN IOPL TO ECB.\n         ORG   IOPLR+IOPLIOPB-IOPL\n         DC    A(PTPB)             IOPL POINTER TO PUTLINE PARM BLOCK.\n         ORG   ,                   RE-ORG FORWARD.\n         SPACE 1\nECB      DC    A(0)                PRESENTLY UNUSED ECB; CAN BE ...\n*                                  ... POSTED TO ABORT PUTLINE.\nPTPB     PUTLINE OUTPUT=(DSNBUF,,,DATA),MF=L\nPPLR     DC    (PPLL)A(0)          PPL FOR PARSE.\n         ORG   PPLR+PPLECB-PPL\n         DC    A(ECB)              POINTER IN PPL TO ECB.\n         ORG   PPLR+PPLPCL-PPL\n         DC    A(PCL)              POINTER IN PPL TO PCL.\n         ORG   PPLR+PPLANS-PPL\n         DC    A(ANSWER)           POINTER IN PPL TO ANSWER PLACE.\n         ORG   ,                   RE-ORG FORWARD.\nDSNBUF   DC    AL2(PRLEN,0)\n         DC    CL1' '\nOUTVSER  DC    CL6' '\n         DC    CL2' '\nPERMIT   DC    CL3' '\n         DC    CL2' '\nDSN      DC    CL44' '\nPRLEN    EQU   *-DSNBUF\n*\n         DS    0F\nPRMTABL  EQU   *\n         DC    AL1(JFCNEW),C'NEW'  FILE WAS ALLOCATED NEW\n         DC    AL1(JFCMOD),C'MOD'  FILE WAS ALLOCATED MOD\n         DC    AL1(JFCOLD),C'OLD'  FILE WAS ALLOCATED OLD\n         DC    AL1(JFCOLD+JFCSHARE),C'SHR'   FILE WAS ALLOCATED SHR\nPRMLEN   EQU   (*-PRMTABL)/4       END OF DISPOSITION CHOICES\n         DC    AL1(00),C'***'      UNDETERMINED FILE DISPOSITION\n*\n         DS    0H\nHEXTAB   DC    C'0123456789ABCDEF'\n*\nDDNFERR  DC    F'2'                THREE SEGMENTS.\n         DC    A(DDNF1)            SEGMENT1.\n         DC    A(DDNAMEH)          SEGMENT2.\n         SPACE 1\nDDNF1    DC    AL2(DDNF1L,0)\nDDNF1A   DC    C'ERROR; DDNAME '\nDDNF1B   DC    C' WAS NOT PRE-ALLOCATED.'\nDDNF1L   EQU   *-DDNF1\nPARSERR  DC    AL2(PARSERRL,0)\n         DC    C'CANNOT PARSE INPUT.  SYSTEM PROBLEM.  SEE SYSTEMS PROG+\n               AMMER.'\nPARSERRL EQU   *-PARSERR\n         SPACE 1\nARLFAIL  DC    AL2(ARLFERRL,0)\n         DC    C'SYSTEM DOES NOT SUPPORT ARL PROCESSING.'\nARLFERRL EQU   *-ARLFAIL\n         SPACE 1\nPCL      IKJPARM\nDDNAMEP  IKJPOSIT DSNAME,DDNAM,PROMPT='DDNAME +',                      +\n               HELP=('DDNAME FOR WHICH THE ASSOCIATED DATASET NAME IS T+\n               O BE RETURNED.')\n         IKJENDP\nDDNAMEH  DS    0H\n         DC    AL2(*-*,DDNF1B-DDNF1A)  HEADER FOR DDNAME FOR PUTLINE.\nDDNAME   DC    CL8' '              DDNAME HOLDER.\nDDMOVE   MVC   DDNAME(*-*),0(R2)   *** EXECUTED ***\n         PRINT NOGEN\nDCB      DCB   DDNAME=DUMMY,MACRF=R,EXLST=EXLST, DUMMY DCB FOR RDJFCB  X\n               DSORG=PO\n         PRINT GEN\nEXLST    DS    0A                  EXIT LIST FOR OPEN ROUTINE\n         DC    X'13',AL3(SLB)      POINT TO ALLOCATION RETRIEVAL LIST\n         DC    X'87',AL3(LIBJFCB)  POINT TO JFCB FOR FIRST DATA SET\n*                                  '80' BIT SAYS LAST ENTRY IN LIST\nSLB      IHAARL DSECT=NO,PREFIX=SLB\n         DS    0F\nLIBJFCB  DC    CL176' '            FIRST JFCB\n*\nJFCB     DS    0A                  JFCB\n         DS    XL(JFCBLGTH)\n*\n         TITLE 'DSECTS.'\n         IKJCPPL                   COMMAND PROCESSOR PARAMETER LIST\n*\n         IKJIOPL                   I/O PARAMETER LIST\nIOPLL    EQU   (*-IOPL)/4          LENGTH OF IOPL IN WORDS.\n*\n         IKJPPL                    PARSE PARAMETER LIST\nPPLL     EQU   (*-PPL)/4           LENGTH OF PPL IN WORDS.\n*\nJFCBD    DSECT\n         IEFJFCBN                  SET LIST=YES FRO FULL EXPANSION\n         PRINT NOGEN\n         CVT   DSECT=YES\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RDSNALL$": {"ttr": 1805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00Y\\x01\\x07\"_\\x01\\x15$/\\x14\\x01\\x00\\x1b\\x00\\x0e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2007-08-13T00:00:00", "modifydate": "2015-08-30T14:01:59", "lines": 27, "newlines": 14, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBU JOB (CCMVS),ASMLINK,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X,COND=(1,LT)\n//*\n//*     ASM LINKEDIT FROM SOURCE ASM\n//*\n//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,RLD)\n//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB\n//         DD DISP=SHR,DSN=SYS1.MODGEN\n//SYSIN    DD DISP=SHR,DSN=SBGOLOB.B.ASM(RDSNALL)\n//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,20)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=SYSDA,SPACE=(TRK,30),DISP=(,PASS),DCB=BLKSIZE=3200,\n//            DSN=&&TEMP\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=(OLD,PASS),DSN=&&TEMP\n//SYSLMOD  DD  DISP=SHR,DSN=SYS1.W$$.LINKLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB\n ORDER   RDSNALL\n SETSSI  CB490020\n ENTRY   RDSNALL\n NAME    RDSNALL(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RDSNTEST": {"ttr": 1807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x91\\x10\\x9f\\x00\\x92!/\\x16!\\x00(\\x00\\x1f\\x00(\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1991-04-19T00:00:00", "modifydate": "1992-07-30T16:21:00", "lines": 40, "newlines": 31, "modlines": 40, "user": "FILE020"}, "text": "/*****REXX************************************************************/\n/*                                                                   */\n/*          THIS REXX TESTS THE RDSNALL COMMAND.  IT TAKES A DDNAME  */\n/*     AS ITS INPUT, AND THEN GETS ALL THE FILE NAMES IN THE CONCAT- */\n/*     ENATION FOR THE DDNAME AND DOES NOTHING WITH THEM.  HOWEVER,  */\n/*     THE NOTHING CAN EASILY BE EXPANDED TO MORE USEFUL WORK.       */\n/*                                                                   */\n/*          THE ROUTINE RDSNALL MUST BE IN THE ISPLLIB CONCATENATION */\n/*     FOR THIS REXX TO RUN PROPERLY.                                */\n/*                                                                   */\n/*********************************************************************/\nPARSE ARG DDNAME\nIF DDNAME = '' THEN DO\n  SAY 'ENTER DDNAME FOR CHECK '\n  PARSE PULL DDNAME\n  IF DDNAME = '' THEN RETURN\n  END\nX = OUTTRAP('LIN.')\nADDRESS 'TSO'\n\"$$ RDSNALL \" || DDNAME\nIF RC > 0 THEN DO\n  SAY \"PROGRAM TERMINATING DUE TO BAD 'RDSNALL' COMMAND EXECUTION.\"\n  RETURN\n  END\nSAY 'THE NUMBER OF LINES TRAPPED IS' LIN.0\nI = 1\nDO WHILE I < LIN.0\n  DATA = \"PARSE VAR LIN.\" || I || \" A1 A2 A3 A4\"\n  INTERPRET DATA\n  DO J = 3 TO 1 BY -1\n    D = \"D = A\" || J\n    INTERPRET D\n    IF D \u00ac= '' THEN J = 0\n    END\n  D = \"WHOHAS '\" || D || \"'\"  /* BUILD A WHOHAS COMMAND, EVEN THOUGH */\n  SAY D                       /* WHOHAS USES TPUT AND DOESN'T WORK   */\n  D\n  I = I + 1\n  END\nSAY 'END'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REGS": {"ttr": 1809, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00y\\x14?\\x00\\x92\"\\x7f\\x16\\x05\\x00\\t\\x00\\t\\x00\\x02\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1979-05-23T00:00:00", "modifydate": "1992-08-14T16:05:00", "lines": 9, "newlines": 9, "modlines": 2, "user": "FILE020"}, "text": "         MACRO\n&NAME    REGS\n         LCLA  &I\n&I       SETA  0\n.LUP     ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LE 15).LUP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RETSTORE": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00V\\x00\\x92\\x02\\x7f\\x01\\x143\\x0f\\x19#\\x00@\\x00N\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1992-01-27T00:00:00", "modifydate": "2014-11-26T19:23:56", "lines": 64, "newlines": 78, "modlines": 0, "user": "SBGOLOB"}, "text": "/***** REXX ******************** REXX ********************************/\n/*                                                                  V*/\n/*                       DASD UCB TABLE LOOKUP                       */\n/*  THIS REXX PROGRAM SCANS ALL DASD UCBS AND REPORTS FOR THOSE THAT */\n/*  ARE MOUNTED WITH THE STORAGE ATTRIBUTE.                          */\n/*                                                                  V*/\n/*===================================================================*/\n/*               UCBTBYT WORD AT X'10' OFF INTO UCB                  */\n/*  LOCATE UCB:  CVT+X'4E4'(CVTUCBA) POINTS TO THE 1ST UCB ENTRY     */\n/*  UCBSTAT   -> UCB+X'03'- X'80'/ONLINE, X'08'/ALLOCATED            */\n/*  UCBTBYT   -> UCB+X'10' 4 BYTESLONG                               */\n/*   XX...... -> THE 1ST BYTE IS THE MODEL FLAG    (UCBTBYT1)        */\n/*   ..XX.... -> THE 2ND BYTE IS THE FEATURE FLAG  (UCBTBYT2)        */\n/*               X'0E' TYPE DEVICE TYPE 3380                         */\n/*               X'0F' TYPE DEVICE TYPE 3390                         */\n/*   ....XX.. -> THE 3RD BYTE MUST BE 20 FOR DASD  (UCBTBYT3)        */\n/*               X'80' FOR TAPE DEVICE                               */\n/*               X'40' FOR COMMUNICATION DEVICE                      */\n/*               X'41' FOR CTC DEVICE                                */\n/*               X'20' FOR DASD DEVICE                               */\n/*               X'10' FOR DISPLAY DEVICE                            */\n/*               X'08' FOR UNIT RECORD DEVICE                        */\n/*               X'24' FOR CHARACTER READER DEVICE                   */\n/*   ......XX -> THE 4TH BYTE IS THE TYPE TYPE     (UCBTBYT4)        */\n/*  UCBSTAB   -> UCB+X'22' 1 BYTE LONG                               */\n/*               X'40' FOR PACK BEING USED AS PAGE PACK              */\n/*               X'10' FOR PRIVATE PACK ATTRIBUTE                    */\n/*               X'08' FOR PUBLIC PACK ATTRIBUTE                     */\n/*               X'04' FOR STORAGE PACK ATTRIBUTE                    */\n/*               X'01' FOR CONTROL VOLUME (CATALOG RESIDES)          */\n/*********************************************************************/\nCVT      = STORAGE(10,4)                       /* LOAD A(CVT)        */\nDCVT     = C2D(CVT)                            /* CONVERT TO DECIMAL */\nUCB    = STORAGE(D2X(DCVT+X2D('4E4')),4)       /* LOAD A(CVTUCBA)    */\nDUCB   = C2D(UCB)                              /* CONVERT TO DECIMAL */\n\nRETC = 0                                       /* INIT RETURN COUNT  */\nTOTAL  = 0                                     /* INIT TOTAL COUNTER */\nLINEC  = 0                                     /* INIT LINE CONTROL  */\nOFFCNT = 0                                     /* INIT OFFLINE COUNT */\nONCNT  = 0                                     /* INIT ON LINE COUNT */\n\nDO WHILE DUCB \\= 0\n  UCBN   = STORAGE(D2X(DUCB+X2D('04')),2)      /* LOAD UCBNUM ADDR   */\n  UCBNX  = STORAGE(D2X(DUCB+X2D('08')),4)      /* LOAD A(UCBNEXT)    */\n  UCBSTAT= STORAGE(D2X(DUCB+X2D('03')),1)      /* LOAD UCB STATUS    */\n  UCBTYP = STORAGE(D2X(DUCB+X2D('11')),1)      /* LOAD UCBTBYT2 TYPE */\n  UCBDEV = STORAGE(D2X(DUCB+X2D('12')),1)      /* LOAD UCBTBYT3 TYPE */\n  UCBTYP = STORAGE(D2X(DUCB+X2D('13')),1)      /* LOAD UCBTBYT4 TYPE */\n  UCBSTAB= STORAGE(D2X(DUCB+X2D('22')),1)      /* LOAD UCB ATTRIBUTE */\n  IF UCBDEV = '20'X THEN DO                    /* IS THIS A DASD UCB */\n     UCBN = SUBSTR(C2X(UCBN),2)                /* CONV UCBNUM TO CHAR*/\n     VOL = STORAGE(D2X(DUCB+X2D('1C')),6)      /* LOAD UCBVOLI       */\n     IF UCBSTAB = '04'X THEN DO                /* IS IT A STO-PACK?  */\n        ATTB = STO                             /* YES, USE IT        */\n        SAY UCBN VOL ATTB\n        RETC = RETC + 1                        /* COUNT              */\n      END\n  END\n  UCB   =  UCBNX                               /* GET NEXT UCB ADDR. */\n  DUCB  =  C2D(UCB)                            /* CONVERT TO DECIMAL */\n  TOTAL = TOTAL + 1                            /* COUNT VOLUME       */\n  ITERATE                                      /* GO GET NEXT UCB    */\nEND                                            /*                    */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETISR": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00C\\x00\\x92\\x16\\x0f\\x01\\x143\\x0f\\x19#\\x00\\x12\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-06-08T00:00:00", "modifydate": "2014-11-26T19:23:43", "lines": 18, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": "/*==== REXX =========================================================*/\n/*                                                                   */\n/*        This REXX exists to be called by the LST REXX.  The LST    */\n/*   REXX executes this REXX as a command and uses the NEWAPPL       */\n/*   option to reset the function keys to those expected in an EDIT  */\n/*   or BROWSE session.                                              */\n/*                                                                   */\n/*===================================================================*/\nARG SEL\nIF SEL = '' THEN\n   DO\n      SAY 'This routine ( SETISR ) must be called with an argument.'\n      EXIT 1\n   END\nELSE DO\n  SAY \"ISPEXEC\" SEL\n  \"ISPEXEC\" SEL\n  END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SMFID": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00R\\x00\\x901\\x1f\\x01\\x143\\x0f\\x19\"\\x00#\\x000\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1990-11-07T00:00:00", "modifydate": "2014-11-26T19:22:52", "lines": 35, "newlines": 48, "modlines": 0, "user": "SBGOLOB"}, "text": "/*==== REXX =========================================================*/\n/*                                                                   */\n/*        THIS REXX LISTS SOME SYSTEM CONSTANTS FOR QUICK INFO.      */\n/*                                                                   */\n/*===================================================================*/\nNUMERIC DIGITS 10                        /* ALLOW 10 DIGITS PER NUM  */\nCVT   = ADDC(0,'10')                     /* POINT TO CVT             */\nSAY 'CVT IS AT' D2X(CVT)                 /* REPORT CVT POINTER       */\nSMCA = ADDC(CVT, '0C4' )                 /* POINT TO JESCT           */\nSAY 'SMCA IS AT' D2X(SMCA)               /* REPORT ADDRESS OF JESCT  */\nTEST = ADDC(SMCA, '10' )                 /* GET SMFID ADDRESS        */\nCRAP= D2X(TEST)                          /* RETRIEVE SMFID           */\nSAY 'SMFID IS \"' || X2C(CRAP) || '\"'     /* REPORT SMFID             */\nMODEX = ADDC(0,'208')                    /* POINT TO CPU INFO DATA   */\nMODEL = ADDC(MODEX, '04')                /* POINT TO MODEL INFO      */\nCRAP= C2X(STORAGE(D2X(AD1+X2D(AD2)),12)) /* GET CPU INFO             */\nMODELT = SUBSTR(CRAP,1,4)                /* REMOVE MODEL #           */\nCPUID = SUBSTR(CRAP,5,12)                /* REMOVE CPUID             */\nCPUTYPE = SUBSTR(CRAP,17,8)              /* REMOVE CPU TYPE          */\nSAY 'MODEL IS ' X2C(MODELT)              /* REPORT MODEL #           */\nSAY 'CPUID IS ' X2C(CPUID)               /* REPORT CPUID             */\nSAY 'CPUTYPE IS ' X2C(CPUTYPE)           /* REPORT CPU TYPE          */\nEXIT 0\n/* */\n/*********************************************************************/\n/*                                                                   */\n/*     ROUTINE TO RETURN A VALUE FROM STORAGE.  VALUE'S LOCATION IS  */\n/* AT THE ADDRESS SPECIFIED BY THE SUM OF THE TWO ARGUMENTS.  THE    */\n/* FIRST ARGUMENT IS A STANDARD DECIMAL NUMBER.  THE SECOND ONE IS   */\n/* A HEXADECIMAL CONSTANT.                                           */\n/*                                                                   */\n/*********************************************************************/\n/* */\nADDC:ARG AD1, AD2                        /* CALC ADDRESS FUNCTION    */\nRETURN C2D(STORAGE(D2X(AD1+X2D(AD2)),4)) /* AD1 = DEC, AD2 = HEX     */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SSCTLOOK": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00G\\x00\\x92\\x00?\\x01\\x143\\x0f\\x19!\\x00_\\x00P\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1992-01-03T00:00:00", "modifydate": "2014-11-26T19:21:47", "lines": 95, "newlines": 80, "modlines": 0, "user": "SBGOLOB"}, "text": "/*==== REXX =========================================================*/\n/*                                                                   */\n/*                  SUB-SYSTEM CONTROL TABLE LOOKUP                  */\n/*   THIS REXX WILL DISPLAY EACH SUB-SYSTEM ID AND THE SSVT          */\n/*   ADDRESSSD RELATED.                                              */\n/*                                                                   */\n/*===================================================================*/\n/*                  CONTROL BLOCK CHAINING USED                      */\n/*  CVT        : X'10' ABSOLUTE ADDRESS                              */\n/*  JESCT      : CVT+X'128' JES CONTROL TABLE (CVTJESCT)             */\n/*  JESNRSS    : JESCT+X'44' TOTAL ACTIVE SUBSYSTEM                  */\n/*  JESSSCT    : JESCT+X'18' SUB SYSTEM CONTROL TABLE                */\n/*   SSCTID    : SSCT+X'00'  EYE CATCHER CONTAINING C'SSCT'          */\n/*   SSCTNXT   : SSCT+X'04'  NEXT SSCT ENTRY ADDRESS                 */\n/*   SSCTNAM   : SSCT+X'08'  SUB SYSTEM NAME                         */\n/*   SSCTSVT   : SSCT+X'10'  SUB SYSTEM VECTOR TABLE ADDRESS         */\n/*   SSCTSUSE  : SSCT+X'14'  RESERVED FOR SUB SYSTEM USE             */\n/*   SSCTSYN   : SSCT+X'18'  HASH TABLE SYNONYM ADDRESS              */\n/*   SSCTSUS2  : SSCT+X'1C'  RESERVED FOR SUB SYSTEM USE             */\n/*   SSCTSUS3  : SSCT+X'20'  RESERVED                                */\n/*********************************************************************/\nCVT    = STORAGE(10,4)                         /* ADDR CVT           */\nDCVT   = C2D(CVT)                              /* CONVERT TO DECIMAL */\nJESCT  = STORAGE(C2X(D2C(DCVT+X2D(128))),4)    /* ADDR JESCT FROM CVT*/\nDJESCT = C2D(JESCT)                            /* CONVERT TO DECIMAL */\nJESSCT = STORAGE(C2X(D2C(DJESCT+X2D(18))),4)   /* ADDR SSCT FROM JSCT*/\nJESNRSS= STORAGE(C2X(D2C(DJESCT+X2D(44))),2)   /* ADDR TOTAL A/SUBS  */\nDNRSS  = C2D(JESNRSS)                          /* CONVERT TO DECIMAL */\nLA     = 0                                     /* INIT LINE CONTROL  */\nLINEC  = 0                                     /* INIT LINE CONTROL  */\nLINE   = ''                                    /* INIT LINE BUFFER   */\nCLEAR                                          /* CLEAR SCREEN       */\nSAY    ''                                      /*                    */\nHEADER = 'SUBSYSTEM CONTROL TABLE LOOK UP'     /* INIT HEADER LINE   */\nHEADER = CENTER(HEADER,80)                     /* CENTERS THE LINE   */\nSAY    HEADER                                  /* PUT OUT THE LINE   */\nHEADER = '+------------------------------' ||, /* INIT HEADER LINE 1 */\n         '-------------------------------' ||, /*        \"           */\n         '-------+'                            /*        \"           */\nHEADER = CENTER(HEADER,79)                     /* CENTERS THE LINE   */\nSAY    HEADER                                  /* PUT OUT THE LINE   */\nHEADER = COPIES('|NAME|  ADDR  |  SSVT  ',3)   /* INIT TITLE LINES   */\nHEADER = CENTER(HEADER || '|',79)              /* CENTERS THE LINE   */\nSAY    HEADER                                  /* PUT OUT THE LINE   */\nHEADER = COPIES('+----+--------+--------',3)   /* INIT TITLE LINES   */\nHEADER = CENTER(HEADER || '|',79)              /* CENTERS THE LINE   */\nSAY    HEADER                                  /* PUT OUT THE LINE   */\nSSCTCNT= 0                                     /* INIT SSCT COUNT    */\nDO UNTIL JESSCT = '00000000'X |,               /* DO UNTIL NO SSCTNXT*/\n         SSCTCNT > 150                         /*    OR COUNT > 150  */\n   DSSCT  = C2D(JESSCT)                        /* CONVERT TO DECIMAL */\n   SSCTID = STORAGE(C2X(D2C(DSSCT+X2D(00))),4) /* ADDR SSCTID        */\n   SSCTNXT= STORAGE(C2X(D2C(DSSCT+X2D(04))),4) /* LOAD NEXT SSCT ADDR*/\n   SSCTNAM= STORAGE(C2X(D2C(DSSCT+X2D(08))),4) /* ADDR SSCT NAME     */\n   SSCTSVT= STORAGE(C2X(D2C(DSSCT+X2D(10))),4) /* LOAD SSVT ADDRESS  */\n   SSCTSUE= STORAGE(C2X(D2C(DSSCT+X2D(14))),4) /* LOAD SSVT SUSE ADDR*/\n   SSCTSYN= STORAGE(C2X(D2C(DSSCT+X2D(18))),4) /* LOAD HASHTABLE ADDR*/\n   SSCTSU2= STORAGE(C2X(D2C(DSSCT+X2D(1C))),4) /* LOAD SSVT SUS2 ADDR*/\n   SSCTSU3= STORAGE(C2X(D2C(DSSCT+X2D(20))),4) /* LOAD SSVT SUS3 ADDR*/\n   ADDR   = STRIP(C2X(JESSCT),L,'0')           /* FORMAT ADDRESS     */\n   ADDR   = CENTER(ADDR,8)                     /* FORMAT ADDRESS     */\n   SSVT   = C2X(SSCTSVT)                       /* FORMAT ADDRESS     */\n   LINE   = LINE || '|' || SSCTNAM || '|' ||,  /* FORMAT OUTPUT LINE */\n            ADDR || '|' || SSVT                /* FORMAT OUTPUT LINE */\n   LINEC  = LINEC + 1                          /* INCREASE LINE CNT  */\n   IF    LINEC = 3 THEN                        /* ARE WE HAVE 4 SSCT */\n         DO                                    /* YES, DO FORMATING  */\n            LINEC = 0                          /* RESET LINE CONTROL */\n            LINE  = LINE || '|'                /* FORMAT LINE BUFFER */\n            LINE = CENTER(LINE,79)             /* CENTERS IT         */\n            SAY LINE                           /* PUT OUT THE LINE   */\n            LINE = ''                          /* RE-INIT LINE BUFFER*/\n         END                                   /* END OF OUTPUT      */\n   JESSCT = SSCTNXT                            /* ADDRESS NEXT SSCT  */\nEND\nIF    LINEC \\= 0 THEN                          /* ARE WE HAVE 4 SSCT */\n      DO                                       /* YES, DO FORMATING  */\n         TRLR  = '|    |        |        '     /* INIT EMPTY TRAILER */\n         LINE   = LINE || COPIES(TRLR,3-LINEC) /* EMPTY THE TRAILER  */\n         LINE  = LINE || '|'                   /* FORMAT LINE BUFFER */\n         LINE = CENTER(LINE,79)                /* CENTERS IT         */\n         SAY LINE                              /* PUT OUT THE LINE   */\n            LINE = ''                          /* RE-INIT LINE BUFFER*/\n         END                                   /* END OF OUTPUT      */\nHEADER = '+------------------------------' ||, /* INIT HEADER LINE   */\n         '-------------------------------' ||, /*        \"           */\n         '-------+'                            /*        \"           */\nHEADER = CENTER(HEADER,79)                     /* CENTERS THE LINE   */\nSAY    HEADER                                  /* PUT OUT THE LINE   */\nSAY    ''                                      /* PUT OUT BREAKER    */\nHEADER = 'TOTAL NUMBER OF ACTIVE SUB-SYST' ||, /* INIT TRAILR LINE   */\n         'EM' DNRSS                            /*        \"           */\nHEADER = CENTER(HEADER,79)                     /* CENTERS THE LINE   */\nSAY    HEADER                                  /* PUT OUT THE LINE   */\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SUBSYS": {"ttr": 2058, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x05\\x00\\x90&/\\x01\\x143\\x0f\\x19!\\x00N\\x00\\x1a\\x00;\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1990-09-19T00:00:00", "modifydate": "2014-11-26T19:21:05", "lines": 78, "newlines": 26, "modlines": 59, "user": "SBGOLOB"}, "text": "/***** REXX **********************************************************/\n/*                                                                   */\n/*        THIS REXX REPORTS ALL SUBSYSTEMS KNOWN TO MVS AT THE TIME  */\n/*   IT IS RUN AND THE ACTIVE FUNCTIONS FOR EACH ONE.               */\n/*                                                                   */\n/*********************************************************************/\n\nPARSE UPPER ARG A1 A2                    /* LOOK FOR POSSIBLE PARM   */\n\nDEBUG = 'X'                              /* MAKE DEFAULTS 'X'        */\nTRACE = 'X'\nIF LENGTH(A1) < 1 THEN A1 = 'X'          /* ASSURE NON-NULL ARGS     */\nIF LENGTH(A2) < 1 THEN A2 = 'X'\nIF ABBREV('DEBUG',A1) = 1 | ,            /* CHECK FOR PARTIAL MATCH  */\n   ABBREV('DEBUG',A2) = 1 THEN ,         /* & SET FULL = IF FOUND    */\n     DEBUG = 'DEBUG'\nIF ABBREV('TRACE',A1) = 1 | ,            /* CHECK FOR PARTIAL MATCH  */\n   ABBREV('TRACE',A2) = 1 THEN DO        /* & START TRACE IF FOUND   */\n     ADDRESS 'TSO'\n     TS\nEND\n\n/*********************************************************************/\n/*                                                                   */\n/* REXX :       S U B S Y S T E M   S T A T U S                      */\n/*                                                                   */\n/* DISPLAY ALL SUBSYSTEM NAMES AND WHICH FUNCTIONS ARE ACTIVE        */\n/*                                                                   */\n/*********************************************************************/\n\nNUMERIC DIGITS 10                        /* CHOOSE INT. PRECISION    */\nCVT   = ADDC(0,'10')                     /* POINT TO CVT             */\nIF VALUE(DEBUG) = 'DEBUG' THEN DO        /* IF DEBUG SET, TELL HIM   */\n  SAY 'VALUE FROM MEMORY LOCATION' ,\n    D2X(AD1+X2D(AD2)) 'IS' C2X(STORAGE(D2X(AD1+X2D(AD2)),4))\n  SAY 'CVT IS AT' D2X(CVT)\nEND\nJESCT = ADDC(CVT, '0128' )               /* POINT TO JESCT           */\nIF VALUE(DEBUG) = 'DEBUG' THEN DO        /* IF DEBUG SET REPORT      */\n  SAY 'VALUE FROM MEMORY LOCATION' D2X(AD1+X2D(AD2)) 'IS' ,\n    C2X(STORAGE(D2X(AD1+X2D(AD2)),4))\n  SAY 'JESCT IS AT' D2X(JESCT)\nEND\nSSCT  = ADDC(JESCT, '18' )               /* POINT TO SSCT            */\nIF VALUE(DEBUG) = 'DEBUG' THEN DO        /* REPORT ONLY IF DEBUG SET */\n  SAY 'VALUE FROM MEMORY LOCATION' D2X(AD1+X2D(AD2)) 'IS' ,\n    C2X(STORAGE(D2X(AD1+X2D(AD2)),4))\n  SAY 'SSCT IS AT' D2X(SSCT)\nEND\nDO WHILE ( SSCT > 0 )\n  NM = STORAGE(D2X(SSCT+8),4)\n  SAY 'SUBSYSTEM NAME IS \"'NM'\" HEX =' C2X(NM) /* SHOW NAME AND HEX  */\n  SSVT = ADDC(SSCT,'10')                 /* FIND SSCT ADDRESS        */\n  IF SSVT > 0 THEN DO\n    AL = SSVT + X2D('04')                /* OFFSET 4 = FUNC TABLE    */\n    TB = STORAGE(D2X(AL),255)            /* TABLE ITSELF, 255 BYTES  */\n    DO J = 1 TO 255\n      IF SUBSTR(TB,J,1) \u00ac= '00'X THEN    /* FUNCTION IS ACTIVE       */\n        SAY 'ACTIVE FUNCTION ' J\n    END\n  END\n  ELSE SAY 'NO SSVT'\n  SAY ' '\n  SSCT = ADDC(SSCT,'04')                 /* FIND NEXT SSCT ADDRESS   */\nEND\nEXIT 0\n/* */\n/*********************************************************************/\n/*                                                                   */\n/*     ROUTINE TO RETURN A VALUE FROM STORAGE.  VALUE'S LOCATION IS  */\n/* AT THE ADDRESS SPECIFIED BY THE SUM OF THE TWO ARGUMENTS.  THE    */\n/* FIRST ARGUMENT IS A STANDARD DECIMAL NUMBER.  THE SECOND ONE IS   */\n/* A HEXADECIMAL CONSTANT.                                           */\n/*                                                                   */\n/*********************************************************************/\n/* */\nADDC:ARG AD1, AD2                        /* CALC ADDRESS FUNCTION    */\nRETURN C2D(STORAGE(D2X(AD1+X2D(AD2)),4)) /* AD1 = DEC, AD2 = HEX     */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSBASE": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\\x14\\x00\\x915\\x0f\\x01\\x143\\x0f\\x19\\x19\\x00\\xbc\\x00\\x05\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "1991-12-16T00:00:00", "modifydate": "2014-11-26T19:19:14", "lines": 188, "newlines": 5, "modlines": 0, "user": "SBGOLOB"}, "text": "/*==== REXX =========================================================*/\n/*                                                                   */\n/*        THIS REXX LISTS SOME SUMMARY INFORMATION ABOUT THE SYSTEM  */\n/*   IT IS RUN ON SUCH AS THE CPU TYPE AND SERIAL NUMBER, MVS AND    */\n/*   JES LEVELS AND MEMORY ONLINE.                                   */\n/*                                                                   */\n/*===================================================================*/\n                                               /*                    */\nCVT    = STORAGE(10,4)                         /* LOAD A(CVT)        */\nDCVT   = C2D(CVT)                              /* CONVERT TO DECIMAL */\nPCCA   = STORAGE(208,4)                        /* LOAD A(PSAPCCAV)   */\nDPCCA  = C2D(PCCA)                             /* CONVERT TO DECIMAL */\nCVTPFX = DCVT - X2D(100)                       /* ADDR CVTFIX        */\nCPUDATA= STORAGE(C2X(D2C(DPCCA+X2D(04))),12)   /* XTRACT CPU DATA    */\nCPUVER = SUBSTR(CPUDATA,1,2)                   /* FORMAT CPU VERSION */\nCPUSER = 0 || SUBSTR(CPUDATA,4,5)              /* FORMAT CPU SERIAL  */\nCPUTYPE= SUBSTR(CPUDATA,9,4)                   /* FORMAT CPU MODEL   */\nSYSAD  = STORAGE(C2X(D2C(DCVT+X2D(30))),4)     /* LOAD A(CVTSYSAD)   */\nDSYSAD = C2D(SYSAD)                            /* CONVERT TO DECIMAL */\nICPID  = STORAGE(C2X(D2C(DCVT+X2D(5E))),2)     /* ADDR IPLED CPU ID  */\nCVTOPTB= STORAGE(C2X(D2C(DCVT+X2D(7B))),1)     /* ADDR CVTOPTB FLAG  */\nSMCA   = STORAGE(C2X(D2C(DCVT+X2D(C5))),3)     /* LOAD A(SMCA)       */\nDSMCA  = C2D(SMCA)                             /* CONVERT TO DECIMAL */\nGTFST  = STORAGE(C2X(D2C(DCVT+X2D(EC))),1)     /* ADDR GTF STATUS    */\nJESCT  = STORAGE(C2X(D2C(DCVT+X2D(128))),4)    /* ADDR JESCT FROM CVT*/\nDJESCT = C2D(JESCT)                            /* CONVERT TO DECIMAL */\nXTNT2  = STORAGE(C2X(D2C(DCVT+X2D(148))),4)    /* LOAD A(CVTEXT2A)   */\nDXTNT2 = C2D(XTNT2)                            /* CONVERT TO DECIMAL */\nASVT   = STORAGE(C2X(D2C(DCVT+X2D(22C))),4)    /* LOAD A(CVTASVT)    */\nDASVT  = C2D(ASVT)                             /* CONVERT TO DECIMAL */\nGDA    = STORAGE(C2X(D2C(DCVT+X2D(230))),4)    /* LOAD A(CVTGDA)     */\nDGDA   = C2D(GDA)                              /* CONVERT TO DECIMAL */\nCSD    = STORAGE(C2X(D2C(DCVT+X2D(294))),4)    /* LOAD A(CVTCSD)     */\nDCSD   = C2D(CSD)                              /* CONVERT TO DECIMAL */\nASMVT  = STORAGE(C2X(D2C(DCVT+X2D(2C0))),4)    /* LOAD A(CVTASMVT)   */\nDASMVT = C2D(ASMVT)                            /* CONVERT TO DECIMAL */\nMSERV  = STORAGE(C2X(D2C(DCVT+X2D(3C))),4)     /* LOAD A(CVTMSLT)    */\nDMSERV = C2D(MSERV)                            /* CONVERT TO DECIMAL */\nREAL   = STORAGE(C2X(D2C(DCVT+X2D(358))),4)    /* ADDR REAL STORAGE  */\nDREAL  = C2D(REAL)                             /* CONVERT TO DECIMAL */\nRCEP   = STORAGE(C2X(D2C(DCVT+X2D(490))),4)    /* LOAD A(CVTRCEP)    */\nDRCEP  = C2D(RCEP)                             /* CONVERT TO DECIMAL */\nDFAID  = STORAGE(C2X(D2C(DCVT+X2D(4C0))),4)    /* LOAD A(CVTDFA)     */\nDDFAID = C2D(DFAID)                            /* CONVERT TO DECIMAL */\nCPUAL  = STORAGE(C2X(D2C(DCSD+X2D(08))),1)     /* ADDR CSDCPUAL      */\nCPUOL  = STORAGE(C2X(D2C(DCSD+X2D(0A))),2)     /* ADDR CSDCPUOL      */\nDCPUOL = C2D(CPUOL)                            /* CONVERT TO DECIMAL */\nJESSCT = STORAGE(C2X(D2C(DJESCT+X2D(18))),4)   /* ADDR SSCT FROM JSCT*/\nDSSCT  = C2D(JESSCT)                           /* CONVERT TO DECIMAL */\nSSCTNAM= STORAGE(C2X(D2C(DSSCT+X2D(08))),4)    /* ADDR SSCT NAME     */\nSSCTSUE= STORAGE(C2X(D2C(DSSCT+X2D(14))),4)    /* LOAD A(SSCTSUSE)   */\nDSUSE  = C2D(SSCTSUE)                          /* CONVERT TO DECIMAL */\nJESFMID= STORAGE(C2X(D2C(DSUSE+X2D(1C))),8)    /* ADDR JES FMID      */\nPUTLVL = STORAGE(C2X(D2C(DSUSE+X2D(2A))),4)    /* ADDR SYSTEM PUT LVL*/\nNUCID  = STORAGE(C2X(D2C(DXTNT2+X2D(04))),1)   /* ADDR NUCLEUS ID    */\nIOCID  = STORAGE(C2X(D2C(DXTNT2+X2D(06))),2)   /* ADDR I/O CONFIG ID */\nNUCID  = 'IEANUC0' || NUCID                    /* APPEND WITH PREFIX */\nIPLOPT = STORAGE(C2X(D2C(DASMVT+X2D(01))),1)   /* LOAD A(ASMVT)      */\nSPREL  = STORAGE(C2X(D2C(CVTPFX+X2D(D8))),8)   /* ADDR MVS/SP RELEASE*/\nMVSREL = STORAGE(C2X(D2C(CVTPFX+X2D(FC))),4)   /* ADDR MVS RELEASE   */\nDFPREL = STORAGE(C2X(D2C(DDFAID+X2D(02))),2)   /* ADDR DFP VER/RELASE*/\nDFVT   = STORAGE(C2X(D2C(DDFAID+X2D(2C))),4)   /* LOAD A(DFADFVT)    */\nDDFVT  = C2D(DFVT)                             /* CONVERT TO DECIMAL */\nDFPFID = STORAGE(C2X(D2C(DDFVT+X2D(14))),4)    /* LOAD A(DFPFMID)    */\nDDFMID = C2D(DFPFID)                           /* CONVERT TO DECIMAL */\nDFPFMID= STORAGE(C2X(D2C(DDFMID+X2D(3F))),8)   /* ADDR DFP FMID      */\nDFPREL = SUBSTR(C2X(DFPREL),1,3)               /* FORMAT DFP RELEASE */\nDFPREL = INSERT('.',DFPREL,1)                  /* FORMAT DFP RELEASE */\nDFPREL = INSERT('.',DFPREL,3)                  /* FORMAT DFP RELEASE */\nSMPID  = STORAGE(C2X(D2C(CVTPFX+X2D(E0))),8)   /* ADDR SMP FMID      */\nSMFID  = STORAGE(C2X(D2C(DSMCA+X2D(10))),4)    /* ADDR SYSTEM SMFID  */\nIPLTME = STORAGE(C2X(D2C(DSMCA+X2D(150))),4)   /* ADDR IPL TIME FIELD*/\nIPLDTE = STORAGE(C2X(D2C(DSMCA+X2D(154))),4)   /* ADDR IPL DATE FIELD*/\nIPLDTE = INSERT('.',SUBSTR(C2X(IPLDTE),3,5),2) /* FORMAT IPL DATE    */\nIPLHH  = RIGHT(C2D(IPLTME)%100%3600,2,'0')     /* FORMAT IPL HOUR    */\nIPLMM  = RIGHT(C2D(IPLTME)%100//3600%60,2,'0') /* FORMAT IPL MINUTE  */\nIPLSS  = RIGHT(C2D(IPLTME)%100//60,2,'0')      /* FORMAT IPL SECOND  */\nIPLTME = IPLHH || ':' || IPLMM || ':' || IPLSS /* FORMAT IPL TIME    */\nRESADDR= STORAGE(C2X(D2C(DSYSAD+X2D(0D))),3)   /* ADDR SYSRES UCBADDR*/\nRESVOL = STORAGE(C2X(D2C(DSYSAD+X2D(1C))),6)   /* ADDR SYSRES VOLSER */\nREALM  = DREAL/1024 || 'M'                     /* COMP REAL STORAGE  */\nXPAND  = STORAGE(C2X(D2C(DRCEP+X2D(A0))),4)    /* ADDR IARMMRCE+A0   */\nXPAND  = C2D(XPAND)*4/1024 || 'M'              /* CONV FRAME TO MEG. */\nDDFVT  = C2D(DFVT)                             /* CONVERT TO DECIMAL */\nCSASZ  = STORAGE(C2X(D2C(DGDA+X2D(70))),4)     /* ADDR GDACSASZ      */\nECSAS  = STORAGE(C2X(D2C(DGDA+X2D(80))),4)     /* ADDR GDAECSAS      */\nDCSASZ = C2D(CSASZ)/1024 || 'K'                /* COMPUTE CSA SIZE   */\nDECSAS = C2D(ECSAS)/1024 || 'K'                /* COMPUTE CSA/E SIZE */\nSQASZ  = STORAGE(C2X(D2C(DGDA+X2D(94))),4)     /* ADDR GDASQASZ      */\nESQAS  = STORAGE(C2X(D2C(DGDA+X2D(9C))),4)     /* ADDR GDAESQAS      */\nDSQASZ = C2D(SQASZ)/1024 || 'K'                /* COMPUTE SQA SIZE   */\nDESQAS = C2D(ESQAS)/1024 || 'K'                /* COMPUTE CSA/E SIZE */\nPVTSZ  = STORAGE(C2X(D2C(DGDA+X2D(A4))),4)     /* ADDR GDAPVTSZ      */\nEPVTS  = STORAGE(C2X(D2C(DGDA+X2D(AC))),4)     /* ADDR GDAEPVTS      */\nDPVTSZ = C2D(PVTSZ)/1024/1024 || 'M'           /* COMPUTE PVT SIZE   */\nDEPVTS = C2D(SUBSTR(EPVTS,1,3))/1024/4         /* COMPUTE PVT/E SIZE */\nDEPVTS1= C2D(SUBSTR(EPVTS,4,1))/1024/4         /* COMPUTE PVT/E SIZE */\nDEPVTS = DEPVTS + DEPVTS1 || 'M'               /* COMPUTE PVT/E SIZE */\nASCBMAX= C2D(STORAGE(C2X(D2C(DASVT+516)),4))   /* FORMAT MAX USER    */\nASCBACT= 0                                     /* INIT MAX ACT ASCB  */\nDO I = 1 TO ASCBMAX                            /* SCAN ALL ASVT      */\n   ASCB  = STORAGE(C2X(D2C(DASVT+524+I*4)),4)  /* ADDR ASCB FROM ASVT*/\n   IF   ABBREV(C2X(ASCB),'80')  = 1            /* IS IT AVAILABLE?   */\n        THEN ITERATE                           /* YES,LEAVE FOR NEXT */\n   ASCBACT = ASCBACT + 1                       /* NO, COUNT IT       */\nEND                                            /* END OF SCAN        */\nIF   BITAND(CPUAL,'FC'X) = 'FC'X THEN          /* CPU 0-5 AVAILABLE? */\n     CPUAL = 'CPU 0-5'                         /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'F8'X) = 'F8'X THEN     /* CPU 0-4 AVAILABLE? */\n          CPUAL = 'CPU 0-4'                    /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'F0'X) = 'F0'X THEN     /* CPU 0-3 AVAILABLE? */\n          CPUAL = 'CPU 0-5'                    /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'E0'X) = 'E0'X THEN     /* CPU 0-2 AVAILABLE? */\n          CPUAL = 'CPU 0-2'                    /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'C0'X) = 'C0'X THEN     /* CPU 0-1 AVAILABLE? */\n          CPUAL = 'CPU 0-1'                    /* YES, SAY IT        */\nELSE IF   BITAND(CPUAL,'80'X) = '80'X THEN     /* CPU 0   AVAILABLE? */\n          CPUAL = 'CPU 0  '                    /* YES, SAY IT        */\nIF   BITAND(IPLOPT,'04'X) = '04'X THEN         /* IS IT WARM STARTED */\n     IPLOPT = 'WARM '                          /* YES, SAY IT        */\nELSE DO                                        /* ELSE CHK OTHERS    */\n        IPLOPT = 'CVIO '                       /* ASSUME CVIO START  */\n        IF   BITAND(IPLOPT,'08'X) = '08'X THEN /* IS IT QUICK START  */\n             IPLOPT = 'QUICK'                  /* YES, SAY IT        */\n        ELSE IPLOPT = 'CLPA '                  /* ELSE SAY CLPA      */\n     END                                       /* END OF IPL CHECK   */\nIF   BITAND(GTFST,'80'X) = '80'X   THEN        /* IS GTF ACTIVATED   */\n     GTFSTAT= 'ACTIVE  '                       /* YES, ACTIVE        */\nELSE GTFSTAT= 'INACTIVE'                       /* NO, INACTIVE       */\nLOGCLS = STORAGE(C2X(D2C(DMSERV+X2D(68))),1)   /* ADDR SYSLOG CLASS  */\nIF   CVTOPTB \\= '10'X THEN                     /* IS SYSLOG ACTIVE?  */\n     LOGSTAT= 'ACTIVE'                         /* YES, SAY ACTIVE    */\nELSE LOGSTAT= 'INACTIVE'                       /* NO, INACTIVE       */\nCLEAR                                          /* CLEAR SCREEN       */\nHEADER = 'BASE SYSTEM INFORMATION LOOK UP'\nHEADER = CENTER(HEADER,79)\nSAY HEADER\nLINE = 'CPU VERSION:' CPUVER,\n       ' CPU SERIAL:' CPUSER,\n       ' CPU TYPE:' CPUTYPE\nSAY  CENTER(LINE,79)\nSAY  CENTER(LEFT('*',73,'*'),79)\nICPID= SUBSTR(C2X(ICPID),3,2)\nCALL FPRINT('IPL PROCESSOR' ICPID,\n            'IPL OPTION' IPLOPT)\nCALL FPRINT('IPL DATE' IPLDTE,\n            'IPL TIME' IPLTME)\nCALL FPRINT('CPU ON-LINE' DCPUOL,\n            'CPU AVAILABLE' CPUAL)\nCALL FPRINT('NUCLEUS MEMBER' NUCID,\n            'I/O CONFIG  ' IOCID)\nCALL FPRINT('REAL STORAGE' REALM,\n            'EXPANDED STORAGE' XPAND)\nCALL FPRINT('SYSRES VOLSER' RESVOL,\n            'SYSRES ADDRESS' RESADDR)\nSAY  CENTER(LEFT('*',72,'=') || '*',79)\nCALL FPRINT('MVS RELEASE' MVSREL,\n            'MVS/SP RELEASE' SPREL)\nCALL FPRINT('PUT LEVEL' PUTLVL,\n            'SMP FMID' SMPID)\nCALL FPRINT('PRIMARY JES' SSCTNAM,\n            'JES FMID' JESFMID)\nCALL FPRINT('DFP RELEASE' DFPREL,\n            'DFP FMID' DFPFMID)\nSAY  CENTER(LEFT('*',72,'=') || '*',79)\nCALL FPRINT('CSA SIZE' DCSASZ,\n            'E/CSA SIZE' DECSAS)\nCALL FPRINT('SQA SIZE' DSQASZ,\n            'E/SQA SIZE' DESQAS)\nCALL FPRINT('PRIVATE SIZE' DPVTSZ,\n            'E/PRIVATE SIZE' DEPVTS)\nCALL FPRINT('SYSTEM SMFID' SMFID,\n            'GTF STATUS' GTFSTAT)\nCALL FPRINT('SYSLOG CLASS' LOGCLS,\n            'SYSLOG STATUS' LOGSTAT)\nCALL FPRINT('ASCB AVAILABLE' ASCBMAX,\n            'ASCB ACTIVE' ASCBACT)\nSAY  CENTER(LEFT('*',73,'*'),79)\nRETURN(0)\n/*     COMMON ROTUING TO DO THE OUTPUT FORMATING & PRINTING         */\nFPRINT:\nARG DATA\nLINE = LEFT('*' LEFT(SUBWORD(DATA,1,2),15) ||,\n            '|' SUBWORD(DATA,3,1),36) ||,\n       LEFT('*' LEFT(SUBWORD(DATA,4,2),15) ||,\n            '|' SUBWORD(DATA,6),36)\nSAY  CENTER(LINE || '*',79)\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TEMPLATE": {"ttr": 2065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x92\\x07o\\x00\\x92\"_\\x180\\x00[\\x00[\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-03-16T00:00:00", "modifydate": "1992-08-12T18:30:00", "lines": 91, "newlines": 91, "modlines": 0, "user": "FILE020"}, "text": "/*====REXX============================================================*/\n/*                                                                    */\n/*        THIS IS A SKELETON REXX TO READ A FILE, DO SOME PROCESSING  */\n/*   AND THEN WRITE OUT ANOTHER OUTPUT FILE.  THE REXX COUNTS INPUT   */\n/*   AND OUTPUT RECORDS, PROCESSES EOF AND ERROR CONDITIONS AND AT    */\n/*   THE END OF A FILE PRINTS OUT THESE COUNTS.                       */\n/*                                                                    */\n/*====================================================================*/\n\nPARSE UPPER ARG INPUT                    /* GET COMMAND LINE PARMS    */\nCALL OPENER(INPUT)                       /* GET FILES OPEN            */\n\nNINP = 0                                 /* INITIALIZE COUNTERS       */\nNOUT = 0\n\nDO FOREVER\n  IO = 'READ'                            /* REMEMBER WE'RE READING    */\n  'EXECIO 1 DISKR INPUT'                 /* QUEUE FILE INPUT LINE     */\n  IF RC \u00ac= 0 THEN LEAVE                  /* EXIT IF NON 0 RETURN CODE */\n  NINP = NINP + 1                        /* COUNT ANOTHER RECORD READ */\n  PARSE PULL LINE                        /* PULL RECORD FROM STACK    */\n\n/*\n............................\n... PROCESSING GOES HERE ...\n............................\n*/\n\n  IO = 'WRIT'                           /* REMEMBER WE'RE WRITING    */\n  PUSH LINE                              /* PUSH ONTO STACK           */\n  'EXECIO 1 DISKW OUTPUT'                /* AND WRITE FROM STACK      */\n  IF RC \u00ac= 0 THEN LEAVE                  /* EXIT IF NON 0 RETURN CODE */\n  NOUT = NOUT + 1                        /* COUNT ANOTHER RECORD READ */\nEND\nIF ( RC = 2 ) & ( IO = 'READ' ) THEN DO  /* ONLY EOF ON READ IS OK    */\n  SAY NINP 'RECORDS WERE READ BEFORE AN EOF WAS DETECTED.'\n  SAY NOUT 'RECORDS WERE OUTPUT BEFORE AN EOF WAS DETECTED.'\nEND\nELSE DO                                  /* ANYTHING ELSE IS PROBLEM  */\n  SAY 'AN ERROR WAS DETECTED' IO || 'ING THE DATA.  THE RETURN CODE' ,\n    || ' WAS ' RC\nEND\n\nEXIT 0\n\n/*             E N D   O F   M A  I N   P R O C E D U R E             */\n\nOPENER: PROCEDURE                        /* OPEN INPUT AND OUTPUT     */\n\n/*====================================================================*/\n/*                                                                    */\n/*        THIS IS THE REXX SUBROUTINE TO OPEN THE INPUT AND OUTPUT    */\n/*   FILES.  THE NAMES ARE EITHER SUPPLIED IN THE ARGUMENT OR ARE     */\n/*   ELICITED FROM USER RESPONSES.                                    */\n/*                                                                    */\n/*====================================================================*/\n\nPARSE UPPER ARG INPUT                    /* GET COMMAND LINE PARMS    */\nERR = 0                                  /* NO ERRORS YET             */\nFILEIN:  ,\nIF ( LENGTH(INPUT) = 0 ) | ( ERR = 1 ) THEN DO /* IF NONE, ASK USER   */\n  SAY 'ENTER INPUT FILE NAME :'\n  PARSE UPPER PULL INPNAME               /* READ USER'S RESPONSE      */\nEND\nELSE DO                                  /* ELSE USE ARGS SUPPLIED    */\n  INPUT = STRIP(INPUT,'B')               /* STRIP BLANKS BOTH SIDES   */\n  PARSE UPPER VAR INPUT INPNAME INPUT    /* FIRST IS INPUT NAME       */\n  INPUT = STRIP(INPUT,'L')               /* STRIP WHAT'S LEFT         */\nEND\n\"ALLOC DA(\" || INPNAME || \") F(INPUT) SHR REU\"\nIF RC \u00ac= 0 THEN DO                       /* IF ALLOCATE FAILED        */\n  SAY 'UNABLE TO ALLOCATE THAT FILE.  PLEASE TRY AGAIN.'\n  ERR = 1                                /* RECORD AN ERROR INDICATOR */\n  SIGNAL FILEIN\nEND\nFILEOUT:  ,\nIF ( LENGTH(INPUT) = 0 ) | ( ERR = 1 ) THEN DO /* IF NONE, ASK USER   */\n  SAY 'ENTER OUTPUT FILE NAME :'\n  PARSE UPPER PULL OUTNAME INPUT         /* GET RESPONSE              */\nEND\nELSE DO                                  /* ELSE USE THEM             */\n  PARSE UPPER VAR INPUT OUTNAME          /* PARSE OUTPUT FILE NAME    */\nEND\n\"ALLOC DA(\" || OUTNAME || \") F(OUTPUT) OLD REU\"\nIF RC \u00ac= 0 THEN DO\n  SAY 'UNABLE TO ALLOCATE THAT FILE.  PLEASE TRY AGAIN.'\n  ERR = 1                                /* REMEMBER THE ERROR        */\n  SIGNAL FILEOUT\n  END\n\nRETURN 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TSOTRAP": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x91\"\\x0f\\x00\\x92!\\x1f\\tR\\x00\\x19\\x00/\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1991-08-08T00:00:00", "modifydate": "1992-07-29T09:52:00", "lines": 25, "newlines": 47, "modlines": 0, "user": "FILE020"}, "text": "/* ---------------------  REXX PROCEDURE  ----------------------\n   Name:      TSOTRAP\n   Function:  This Rexx procedure will accept any TSO command\n              (including clists and other Rexx procedures)\n              that output to the terminal and trap the output\n              and then display the results using ISPF Browse.\n   Syntax:    %TSOTRAP tso-command options\n   ------------------------------------------------------------- */\narg command\nif length(command) = 0 then do\n   say \"Error:  Use of TSOTRAP requires the specification of\"\n   say \"        a TSO command whose results will be captured\"\n   say \"        and displayed using ISPF Browse.\"\n   say \"        (e.g.  %TSOTRAP LISTC)\"\n   exit 12\n   end\nx = outtrap(\"trap.\",\"*\")\ncommand\nx= outtrap(\"off\")\nAddress ISPEXEC \"VGET (ZTEMPF)\"\ndd = \"TP\"random()\n\"ALLOC DD(\"dd\") DA('\"ztempf\"') SHR\"\n\"EXECIO * DISKW\" dd \"(FINIS STEM trap.\"\nAddress ISPEXEC \"BROWSE DATASET('\"ztempf\"')\"\n\"FREE DD(\"dd\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCBINFO": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00A\\x00\\x910\\x8f\\x01\\x15$/\\x00\\x03\\x00\\x9f\\x00F\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "1991-11-04T00:00:00", "modifydate": "2015-08-30T00:03:41", "lines": 159, "newlines": 70, "modlines": 0, "user": "SBGOLOB"}, "text": "/*====REXX===========================================================*/\n/*                                                                   */\n/*                       TAPE UCB TABLE LOOKUP                       */\n/*  THIS REXX WILL SHOW TAPE DEVICE INFORMATION FROM THE UCB TABLE   */\n/*  MAINTAINED BY MVS.                                               */\n/*                                                                   */\n/*===================================================================*/\n/*               UCBTBYT WORD AT X'10' OFF INTO UCB                  */\n/*  LOCATE UCB:  CVT+X'4E4'(CVTUCBA) POINTS TO THE 1ST UCB ENTRY     */\n/*  UCBSTAT   -> UCB+X'03'- X'80'/ONLINE, X'08'/ALLOCATED            */\n/*  UCBTBYT   -> UCB+X'10\" 4 BYTESLONG                               */\n/*   XX...... -> THE 1ST BYTE IS THE MODEL FLAG    (UCBTBYT1)        */\n/*   ..XX.... -> THE 2ND BYTE IS THE FEATURE FLAG  (UCBTBYT2)        */\n/*               X'04' DEVICE WITH IDRC (COMPACT) SUPPORT            */\n/*               X'00' DEVICE WITHOUT IDRC (COMPACT) SUPPORT         */\n/*   ....XX.. -> THE 3RD BYTE MUST BE 80 FOR TAPE  (UCBTBYT3)        */\n/*               X'80' FOR TAPE DEVICE                               */\n/*               X'40' FOR COMMUNICATION DEVICE                      */\n/*               X'41' FOR CTC DEVICE                                */\n/*               X'20' FOR DASD DEVICE                               */\n/*               X'10' FOR DISPLAY DEVICE                            */\n/*               X'08' FOR UNIT RECORD DEVICE                        */\n/*               X'24' FOR CHARACTER READER DEVICE                   */\n/*   ......XX -> THE 4TH BYTE IS THE DEVICE TYPE   (UCBTBYT4)        */\n/*               X'80' FOR DEVICE 3480                               */\n/*               X'81' FOR DEVICE 3490 OR 9348                       */\n/*                                                                   */\n/*********************************************************************/\nCLEAR                                         /* CLEAR SCREEN        */\nALLOCX. =                                     /* INIT ALLOC STACKER  */\nVOLSER. =                                     /* INIT VOLSER STACKER */\nUCBJOB. =                                     /* INIT JOBNM STACKER  */\nNREDYX. =                                     /* INIT FREE STACKER   */\nALC     = 0                                   /* INIT ALLOC COUNT    */\nNRD     = 0                                   /* INIT FREE COUNT     */\nCVT     = STORAGE(10,4)                       /* ADDR CVT            */\nDCVT    = C2D(CVT)                            /* CONVERT TO DECIMAL  */\nUCB     = STORAGE(C2X(D2C(DCVT+X2D(4E4))),4)  /* ADDR UCB FROM CVT   */\nDUCB    = C2D(UCB)                            /* CONVERT TO DECIMAL  */\nSAY     '         A  L  L  O  C  A  T  E  D          ', /* HEADER 1  */\n        '    A  V  A  I  L  A  B  L  E'\nSAY     'DEV STATUS TYPE ASID JOB NAME VOLSER LAB ACL', /* HEADER 2  */\n        ' DEV STATUS TYPE DEV STATUS TYPE'\nSAY     '=== ====== ==== ==== ======== ====== === ===', /* HEADER 3  */\n        ' === ====== ==== === ====== ===='\nDO   I  = 1 BY 1 UNTIL UCBNM  = 4CF           /* SCAN UCB UNTIL 4CF  */\n     UCBNM   = STORAGE(C2X(D2C(DUCB+X2D(04))),2)  /* SAVE DEVNUM     */\n     UCBNM   = SUBSTR(C2X(UCBNM),2,3) ||' '       /* CONVERT TO CHAR */\n     UCBNXUCB= STORAGE(C2X(D2C(DUCB+X2D(08))),4)  /* MAP NEXT UCB/A  */\n     UCBSTAT = STORAGE(C2X(D2C(DUCB+X2D(03))),1)  /* MAP UCB STATUS  */\n     UCBTBYT1= STORAGE(C2X(D2C(DUCB+X2D(10))),1)  /* MAP UCB TYPE 1  */\n     UCBTBYT2= STORAGE(C2X(D2C(DUCB+X2D(11))),1)  /* MAP UCB TYPE 2  */\n     UCBTBYT3= STORAGE(C2X(D2C(DUCB+X2D(12))),1)  /* MAP UCB TYPE 3  */\n     UCBTBYT4= STORAGE(C2X(D2C(DUCB+X2D(13))),1)  /* MAP UCB TYPE 4  */\n     UCBDMCT = STORAGE(C2X(D2C(DUCB+X2D(23))),1)  /* MAP UCB MOUNT   */\n     UCBTFL1 = STORAGE(C2X(D2C(DUCB+X2D(2B))),1)  /* MAP UCB FLAG 1  */\n     UCBEXT  = STORAGE(C2X(D2C(DUCB+X2D(15))),3)  /* MAP UCB EXT     */\n     DUCBEXT = X2D(C2X(UCBEXT))                   /* CONVERT TO DEC. */\n     UCBASID = STORAGE(C2X(D2C(14+DUCBEXT)),2)    /* MAP UCBASID     */\n     UCBASID = C2X(UCBASID)                   /* CONVERT TO CHARACTER*/\n     IF   UCBSTAT \\= '00'X  &,                /* IS DEVICE ONLINED   */\n          UCBTBYT3 = '80'X  THEN              /* OR DEVICE = TAPE ?  */\n          CALL DOTAPE                         /* YES, COLLECT INFO.  */\n     UCB       = UCBNXUCB                     /* ELSE ADDR NEXT UCB  */\n     DUCB      = C2D(UCB)                     /*      CONVERT TO DEC */\nEND                                           /* END DO HERE         */\n/*********************************************************************/\n/*   MAP THE JOB NAME USING THE TAPE BY GOING THROUGH THE ASVT       */\n/*   AND COMPARE THE ASID WITH UCBASID SAVED                         */\n/*********************************************************************/\nASVT    = STORAGE(C2X(D2C(DCVT+556)),4)       /* ADDR ASVT (CVT+556) */\nDASVT   = C2D(ASVT)                           /* CONVERT TO DECIMAL  */\nASCNT   = C2D(STORAGE(C2X(D2C(DASVT+516)),4)) /* ADDR ASVT ASCBCNT   */\nDO J    = 1 TO ASCNT                          /* SCAN ASVT TABLE     */\n   ASCB = STORAGE(C2X(D2C(DASVT+524+J*4)),4)\n   IF   ABBREV(ASCB,'00'X) \\= 1 THEN ITERATE  /* IS ASCB IN USED     */\n   DASCB= C2D(ASCB)                           /* YES CONVERT TO DEC. */\n   ASID = STORAGE(C2X(D2C(DASCB+X2D(24))),2)  /* MAP ASCBASID        */\n   ASID = C2X(ASID)                           /* CONVERT TO CHAR.    */\n   JOBNM= STORAGE(C2X(D2C(DASCB+172)),4)      /* MAP ASCBJBNI (JOB)  */\n   IF   C2X(JOBNM) = 00000000 THEN            /* IS IT ALL ZEROS     */\n        JOBNM= STORAGE(C2X(D2C(DASCB+176)),4) /* MAP ASCBJBNS (STC)  */\n   JOBNM.ASID = STORAGE(C2X(JOBNM),8)         /* SAVE IT IN STACKER  */\nEND                                           /* END DO ASVT HERE    */\nI  = ALC\nIF   FORMAT(NRD/2,,0) > I  THEN               /* FREE COUNT > ALLOC  */\n     I  = FORMAT(NRD/2,,0)                    /* YES USE FREE COUNT  */\nDO   J  = 1 BY 1 UNTIL J > I                  /* SCAN ALL STACKER    */\n     IF   ALLOCX.J  = '' THEN                 /* CLEAR LEFT HALF     */\n          ALLOCX.J  = '                                          '\n     X  = SUBSTR(ALLOCX.J,17,4)               /* FORMAT SHR TAPE JOB */\n     IF   SUBSTR(VOLSER.J,1,2) = 'A ' THEN    /* IS CONTROL BY MIM   */\n          JOBNM = '**GTAF**'                  /* YES, PUT JOBNM MIM  */\n     ELSE IF   X = '' THEN JOBNM = ''         /* IS THERE A JOBNM    */\n     ELSE                  JOBNM = JOBNM.X    /* ELSE SAVE ASIS      */\n     IF   JOBNM = 'JOBNM.0000' THEN           /* IS THIS A NULL NAME */\n          JOBNM = 'UN-KNOWN'                  /* YES, SET TO UNKNOWN */\n     LST = ALLOCX.J JOBNM VOLSER.J            /* PREPARE FOR OUTPUT  */\n     K = J * 2 - 1                            /* 2 PART PER LINE     */\n     IF   LENGTH(NREDYX.K) > 0 THEN           /* IS STACKER EMPTY    */\n          LST = LST || ' ' NREDYX.K           /* NO, FORMAT IT       */\n     K = K + 1                                /* PART 2 OF THE LINE  */\n     IF   LENGTH(NREDYX.K) > 0 THEN           /* IS IT EMPTY         */\n          LST = LST NREDYX.K                  /* NO, FORMAT IT       */\n     SAY LST                                  /* OUT PUT TO SCREEN   */\nEND                                           /* END RETURN          */\nRETURN(0)\n/*********************************************************************/\n/*   FORMAT TAPE INFORMATION FROM UCB FIELD                          */\n/*********************************************************************/\nDOTAPE:\n     VOLSER    = '      '                     /* CLEAR VOLSER FIELD  */\n     IF   BITAND(UCBSTAT,'88'X) = '88'X  THEN /* IS TAPE ALLOCATED   */\n          STATUS  = ALLOC                     /* YES, SHOW ALLOC     */\n     ELSE STATUS  = FREE' '                   /* OTHERWISE SHOW FREE */\n     IF   UCBTBYT4 = '81'X THEN               /* IS IT A 3490E TAPE  */\n          DEVTYP  = 349E                      /* YES, SHOW 349E      */\n     ELSE IF   UCBTBYT4 = '80'X &,            /* NO, IS IT A 3480X   */\n               UCBTBYT2 = '04'X THEN          /* WITH COMP. FEATURE  */\n               DEVTYP = 3490                  /* YES, SHOW 3490      */\n     ELSE IF   UCBTBYT4 = '80'X &,            /* NO, IS IT A 3480    */\n               UCBTBYT2 = '00'X THEN          /* W/OUT COMP. FEATURE */\n               DEVTYP = 3480                  /* YES, SHOW 3480      */\n     ELSE IF   UCBTBYT4 = '03'X &,            /* NO, IS IT A 3400    */\n               UCBTBYT1 = '32'X &,            /* SERIOUS AND IT IS   */\n               UCBTBYT2 = '10'X THEN          /* 3420 TAPE           */\n               DEVTYP = 3420                  /* YES, SHOW 3420      */\n          ELSE DEVTYP = 3400                  /* OTHERWISE SHOW 3400 */\n     IF   UCBDMCT = '80'X  THEN               /* IS MOUNT PENDING    */\n          STATUS = MOUNT                      /* YES, SHOW MOUNT     */\n     IF   STATUS = ALLOC |,                   /* IS TAPE IN USED     */\n          STATUS = MOUNT   THEN               /* ALLOC OR MOUNT      */\n          DO                                  /* YES, DO FORMAT LIST */\n               ALC = ALC + 1\n               VOL = STORAGE(C2X(D2C(DUCB+X2D(1C))),6) /* GET VOLSER */\n               IF   VOL \\= BITOR(VOL,'404040404040'X) THEN\n                    VOL  = '      '\n               IF   BITAND(UCBTFL1,'80'X) = '80'X THEN /* LABEL = NL */\n                    LABEL  = NL' '\n               ELSE IF    BITAND(UCBTFL1,'40'X) = '40'X THEN /*   NS */\n                          LABEL  = NS' '\n               ELSE       LABEL  = SL' '                     /*   SL */\n               IF   BITAND(UCBTFL1,'0C'X) = '0C'X THEN       /*ACL=A */\n                    ACL = ACT\n               ELSE IF    BITAND(UCBTFL1,'08'X) = '08'X THEN /*ACL=Y */\n                          ACL = YES\n                     ELSE ACL = '   '                        /*NO ACL*/\n               IF   VOL = '      ' THEN\n                    LABEL = '   '\n               UCBJOB.ALC  = C2X(UCBASID)\n               ALLOCX.ALC  = UCBNM||STATUS ' 'DEVTYP UCBASID /*SAVE IT*/\n               VOLSER.ALC  = VOL LABEL ACL\n          END\n     ELSE DO\n               NRD         = NRD + 1\n               NREDYX.NRD  = UCBNM STATUS DEVTYP  /* SAVE IT AS FREE */\n\n          END\nRETURN(0)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCBSEL": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\\x00\\x00\\x913\\x9f\\x00\\x92\"_\\x18R\\x00\\xbd\\x00~\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "1991-12-05T00:00:00", "modifydate": "1992-08-12T18:52:00", "lines": 189, "newlines": 126, "modlines": 0, "user": "FILE020"}, "text": "/*====REXX===========================================================*/\n/*                                                                   */\n/*                       DASD UCB TABLE LOOKUP                       */\n/*                                                                   */\n/*  THIS REXX PROGRAM IS USED TO MAP OUT ALL DASD DEVICE INFORMATION */\n/*  FROM MVS UCB TABLE, MAPING MACRO WAS IECDUCBT STORED IN AMODGEN  */\n/*                                                                   */\n/*===================================================================*/\n/*               UCBTBYT WORD AT X'10' OFF INTO UCB                  */\n/*  LOCATE UCB:  CVT+X'4E4'(CVTUCBA) POINTS TO THE 1ST UCB ENTRY     */\n/*  UCBSTAT   -> UCB+X'03'- X'80'/ONLINE, X'08'/ALLOCATED            */\n/*  UCBTBYT   -> UCB+X'10' 4 BYTESLONG                               */\n/*   XX...... -> THE 1ST BYTE IS THE MODEL FLAG    (UCBTBYT1)        */\n/*   ..XX.... -> THE 2ND BYTE IS THE FEATURE FLAG  (UCBTBYT2)        */\n/*               X'0E' TYPE DEVICE TYPE 3380                         */\n/*               X'0F' TYPE DEVICE TYPE 3390                         */\n/*   ....XX.. -> THE 3RD BYTE MUST BE 20 FOR DASD  (UCBTBYT3)        */\n/*               X'80' FOR TAPE DEVICE                               */\n/*               X'40' FOR COMMUNICATION DEVICE                      */\n/*               X'41' FOR CTC DEVICE                                */\n/*               X'20' FOR DASD DEVICE                               */\n/*               X'10' FOR DISPLAY DEVICE                            */\n/*               X'08' FOR UNIT RECORD DEVICE                        */\n/*               X'24' FOR CHARACTER READER DEVICE                   */\n/*   ......XX -> THE 4TH BYTE IS THE TYPE TYPE     (UCBTBYT4)        */\n/*  UCBMOD    -> UCB+X'3E' 1 BYTE LONG                               */\n/*               X'24' FOR DEVICE TYPE 3390-3                        */\n/*               X'27' FOR DEVICE TYPE 3390-2                        */\n/*               X'26' FOR DEVICE TYPE 3390-1                        */\n/*               X'23' FOR DEVICE TYPE 3380-K                        */\n/*               X'1B' FOR DEVICE TYPE 3380-E                        */\n/*               X'21' FOR DEVICE TYPE 3380-J                        */\n/*               X'1C' FOR DEVICE TYPE 3380-D                        */\n/*  UCBSTAB   -> UCB+X'22' 1 BYTE LONG                               */\n/*               X'40' FOR PACK BEING USED AS PAGE PACK              */\n/*               X'10' FOR PRIVATE PACK ATTRIBUTE                    */\n/*               X'08' FOR PUBLIC PACK ATTRIBUTE                     */\n/*               X'04' FOR STORAGE PACK ATTRIBUTE                    */\n/*               X'01' FOR CONTROL VOLUME (CATALOG RESIDES)          */\n/*********************************************************************/\nARG      P1 P2                                 /* ALLOW 2 PARM IN    */\nCVT      = STORAGE(10,4)                       /* LOAD A(CVT)        */\nDCVT     = C2D(CVT)                            /* CONVERT TO DECIMAL */\nCLEAR                                          /* CLEAR SCREEN       */\nUCB    = STORAGE(D2X(DCVT+X2D(4E4)),4)         /* LOAD A(CVTUCBA)    */\nDUCB   = C2D(UCB)                              /* CONVERT TO DECIMAL */\nHEADER = ' D E V I C E   A L L O C A T E D '   /* INITIALIZE HEADER  */\nHEADER = CENTER(HEADER,80)                     /* CENTERS THE HEADER */\nIF   SYSVAR(SYSNEST) = NO THEN                 /* IS INIT FROM TERM  */\n     SAY HEADER                                /* PUT OUT HEADER     */\nELSE DO                                        /* DO INITIALIZE      */\n        RETD = ''                              /* INIT RETURN DATA   */\n        RETC = 0                               /* INIT RETURN COUNT  */\n     END                                       /* END OF INIT        */\nHEADER = 'DEV VOLSER  TYPE    ADDR   ATTB  ',  /* INIT TITLE LINE-2  */\n         'DEV VOLSER  TYPE    ADDR   ATTB '    /*                    */\nHEADER = CENTER(HEADER,79)                     /* CENTERS THE HEADER */\nIF   SYSVAR(SYSNEST) = NO THEN                 /* IS INIT FROM TERM  */\n     SAY HEADER                                /* PUT OUT HEADER     */\nHEADER = '=== ====== ====== ======== ====  ',  /* INIT TITLE LINE-2  */\n         '=== ====== ====== ======== ==== '    /*                    */\nHEADER = CENTER(HEADER,79)                     /* CENTERS THE HEADER */\nIF   SYSVAR(SYSNEST) = NO THEN                 /* IS INIT FROM TERM  */\n     SAY HEADER                                /* PUT OUT HEADER     */\nTOTAL  = 0                                     /* INIT TOTAL COUNTER */\nLINEC  = 0                                     /* INIT LINE CONTROL  */\nOFFCNT = 0                                     /* INIT OFFLINE COUNT */\nONCNT  = 0                                     /* INIT ON LINE COUNT */\nLINE   = ''                                    /* INIT LINE BUFFER   */\nDO I = 1 BY 1 UNTIL DUCB = 0\n   UCBN   = STORAGE(D2X(DUCB+X2D(04)),2)       /* LOAD UCBNUM ADDR   */\n   UCBNX  = STORAGE(D2X(DUCB+X2D(08)),4)       /* LOAD A(UCBNEXT)    */\n   UCBSTAT= STORAGE(D2X(DUCB+X2D(03)),1)       /* LOAD UCB STATUS    */\n   UCBTYP = STORAGE(D2X(DUCB+X2D(11)),1)       /* LOAD UCBTBYT2 TYPE */\n   UCBDEV = STORAGE(D2X(DUCB+X2D(12)),1)       /* LOAD UCBTBYT3 TYPE */\n   UCBTYP = STORAGE(D2X(DUCB+X2D(13)),1)       /* LOAD UCBTBYT4 TYPE */\n   UCBMOD = STORAGE(D2X(DUCB+X2D(3E)),1)       /* LOAD UCBMOD MODEL  */\n   UCBSTAB= STORAGE(D2X(DUCB+X2D(22)),1)       /* LOAD UCB ATTRIBUTE */\n   IF   UCBDEV \\= '20'X THEN                   /* IS THIS A DASD UCB */\n        DO                                     /* NO,                */\n           UCB   =  UCBNX                      /* GET NEXT UCB ADDR. */\n           DUCB  =  C2D(UCB)                   /* CONVERT TO DECIMAL */\n           ITERATE                             /* GO GET NEXT UCB    */\n        END                                    /*                    */\n   DO                                          /* FIND DEVICE TYPE   */\n      IF   UCBTYP = '0E'X      THEN            /* IS THIS A 3380?    */\n           TYPE = 3380                         /* YES, SAVE TYPE 3380*/\n      ELSE IF   UCBTYP = '0F'X THEN            /* NO, IS IT A 3390?  */\n                TYPE = 3390                    /* YES, SAVE TYPE 3390*/\n           ELSE TYPE = DASD                    /* ELSE SAVE TYPE DASD*/\n      IF   UCBMOD = '23'X        THEN          /* IS IT A 3380-K?    */\n           MODEL = '-K'                        /* YES, SAVE MODEL    */\n      ELSE IF   UCBMOD = '27'X   THEN          /* IS IT A 3390-2?    */\n                MODEL = '-2'                   /* YES, SAVE MODEL    */\n      ELSE IF   UCBMOD = '21'X   THEN          /* IS IT A 3380-J?    */\n                MODEL = '-J'                   /* YES, SAVE MODEL    */\n      ELSE IF   UCBMOD = '1B'X   THEN          /* IS IT A 3380-E?    */\n                MODEL = '-E'                   /* YES, SAVE MODEL    */\n      ELSE IF   UCBMOD = '24'X   THEN          /* IS IT A 3390-3?    */\n                MODEL = '-3'                   /* YES, SAVE MODEL    */\n      ELSE IF   UCBMOD = '26'X   THEN          /* IS IT A 3390-1?    */\n                MODEL = '-1'                   /* YES, SAVE MODEL    */\n      ELSE IF   UCBMOD = '1C'X   THEN          /* IS IT A 3380-D?    */\n                MODEL = '-D'                   /* YES, SAVE MODEL    */\n           ELSE MODEL = '-?'                   /* ELSE SAVE MODEL ?  */\n      UCBN = SUBSTR(C2X(UCBN),2)               /* CONV UCBNUM TO CHAR*/\n      VOL = STORAGE(D2X(DUCB+X2D(1C)),6)       /* LOAD UCBVOLI       */\n      IF    UCBSTAB = '10'X THEN               /* IS IT A PRI-PACK?  */\n            ATTB = PRI || ' '                  /* YES, SAVE IT       */\n      ELSE  IF    UCBSTAB = '08'X THEN         /* IS IT A PUB-PACK?  */\n                  ATTB = PUB || ' '            /* YES, SAVE IT       */\n      ELSE  IF    UCBSTAB = '04'X THEN         /* IS IT A STO-PACK?  */\n                  ATTB = STO || ' '            /* YES, SAVE IT       */\n      ELSE  IF    UCBSTAB = '50'X THEN         /* IS IT A PAG-PACK?  */\n                  ATTB = PAG || ' '            /* YES, SAVE IT       */\n            ELSE  ATTB = '??? '  THEN          /* ELSE SAVE AS ???   */\n      CNTL  = 0                                /* INIT IN-PARM COUNT */\n      MATCH = 0                                /* INIT MATCH CONTROL */\n      TYPE = TYPE || MODEL                     /* CONCAT TYPE/MODEL  */\n      IF    LENGTH(P1) > 0 THEN                /* IS IN-PARM1 ENTERED*/\n            DO                                 /* YES,               */\n               CNTL = CNTL + 1                 /* INCREASE COUNT BY 1*/\n               LEN  = LENGTH(P1)               /* FIND PARM1 LENGTH  */\n               IF   SUBSTR(TYPE,1,LEN) = P1 |, /* MATCH DEVICE TYPE? */\n                    SUBSTR(UCBN,1,LEN) = P1 |, /*  OR   UCBNUM?      */\n                    SUBSTR(ATTB,1,LEN) = P1 |, /*  OR   ATTRIB?      */\n                    SUBSTR(VOL,1,LEN)= P1 THEN /*  OR   VOLSER?      */\n                    MATCH = MATCH + 1          /* YES, INCREASE CNT  */\n            END\n      IF    LENGTH(P2) > 0 THEN                /* IS IN-PARM2 ENTERED*/\n            DO                                 /* YES,               */\n               CNTL = CNTL + 1                 /* INCREASE COUNT BY 1*/\n               LEN  = LENGTH(P2)               /* FIND PARM2 LENGTH  */\n               IF   SUBSTR(TYPE,1,LEN) = P2 |, /* MATCH DEVICE TYPE? */\n                    SUBSTR(ATTB,1,LEN)=P2 THEN /*  OR   ATTRIB?      */\n                    MATCH = MATCH + 1          /* YES, INCREASE CNT  */\n            END\n      IF    CNTL \\= MATCH THEN                 /* IS MATCH = CONTROL */\n            DO                                 /* NO,                */\n               UCB  = UCBNX                    /* SKIP IT            */\n               DUCB = C2D(UCB)                 /*   AND GO           */\n               ITERATE                         /*     GET NEXT ONE   */\n            END                                /*                    */\n      IF    SUBSTR(VOL,1,1) \\= '00'X THEN      /* IS IT A VALID VOL? */\n            DO                                 /* YES, ASSEMBLE THE  */\n               TOTAL = TOTAL + 1\n               LINEC = LINEC + 1               /*      OUTPUT LINE   */\n               LINE  = LINE UCBN VOL TYPE,     /*      AND           */\n                       C2X(UCB) ATTB || '  '   /*      FORMATS IT    */\n               RETD  = RETD || VOL || TYPE     /*      FORMATS RETURN*/\n            END                                /*                    */\n      ELSE  OFFCNT = OFFCNT + 1                /* NO, COUNT IT       */\n      IF    LINEC = 2 THEN                     /* IS THIS THE 2ND    */\n            DO                                 /* YES,               */\n               LINE = CENTER(LINE,79)          /*    CENTERS THE LINE*/\n               IF   SYSVAR(SYSNEST) = NO THEN  /* IS INIT FROM TERM  */\n                    SAY LINE                   /*    PUT OUT THE LINE*/\n               LINEC = 0                       /*    RE-INIT BUFFER  */\n               LINE = ''                       /*        AND CONTROL */\n            END                                /*                    */\n   END                                         /*                    */\n     UCB  = UCBNX                              /* SWITCH TO NEXT UCB */\n     IF   DUCB \\= 0  THEN  DUCB = C2D(UCB)     /* IS IT NULL         */\nEND                                            /*                    */\nIF    LINEC > 0 THEN                           /* ANY LEFT OVER?     */\n      DO                                       /* YES,               */\n         LINE = LEFT(LINE,LENGTH(LINE)*2)      /*    FORMATS IT      */\n         LINE = CENTER(LINE,79)                /*    CENTERS IT      */\n         IF   SYSVAR(SYSNEST) = NO THEN        /* IS INIT FROM TERM  */\n              SAY LINE                         /*    PUT OUT THE LINE*/\n      END                                      /*                    */\nSAY  ''\nTOTAL  = RIGHT(TOTAL,4)\nHEADER = 'TOTAL NUMBER OF VOLUME MATCHED = ' || TOTAL\nHEADER = CENTER(HEADER,79)\nIF   SYSVAR(SYSNEST) = NO THEN                 /* IS INIT FROM TERM  */\n     SAY HEADER                                /* PUT OUT HEADER     */\nOFFCNT = RIGHT(OFFCNT,3)\nHEADER = 'TOTAL NUMBER OF VOLUME OFFLINED= ' || OFFCNT\nHEADER = CENTER(HEADER,79)\nIF   SYSVAR(SYSNEST) = NO THEN                 /* IS INIT FROM TERM  */\n     DO                                        /* DO LIST PROCESS    */\n        SAY HEADER                             /* PUT OUT HEADER     */\n        RETURN(0)                              /* RETURN COND=0      */\n     END                                       /* END OF LIST PROC   */\nELSE DO                                        /* DO NOLIST PROCESS  */\n        RETD = TOTAL || RETD                   /* RETURN COUNT/DATA  */\n        RETURN(RETD)                           /* RETURN DATA        */\n     END                                       /* END OF NOLIST PROC */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UCBSUBR": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x910\\x8f\\x00\\x911\\x7f\\x13S\\x00\\xaf\\x00x\\x00\\x87\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1991-11-04T00:00:00", "modifydate": "1991-11-13T13:53:00", "lines": 175, "newlines": 120, "modlines": 135, "user": "FILE020"}, "text": "         TITLE 'UCBSCAN - SCAN ALL DASD UCBS FOR CACHE LIST.'\n*%A AMODGEN AUTH LOAD(TSOCGLA.LOADAUTH)\n         SPACE 1\n*===================================================================*\n*                                                                   *\n*        SUBROUTINE TO BE CALLED FROM A REXX TO SCAN ALL UCBS OF A  *\n*   GIVEN DEVICE TYPE ( DASD, TAPE ) AND REPORT BACK WITH EACH      *\n*   UNIT'S UCB.  THE REXX IS THEN FREE TO DO WHATEVER IT WANTS WITH *\n*   THE INFORMATION, INCLUDING THE STORAGE FUNCTION TO ACCESS THE   *\n*   UCB EXTENSION AND OTHER INFORMATION IF NECESSARY.               *\n*                                                                   *\n*        ON RETURN, THE FIRST 2 BYTES OF THE RESULT INDICATE THE    *\n*   STATUS.  HEX 'FFFF' MEANS THAT THE SUPPLY OF THE PARTICULAR     *\n*   UCB'S IS EXHAUSTED.  HEX 'FFFE' MEANS THAT AN ERROR IN THE      *\n*   ARGUMENTS WAS DETECTED, AND AN EXPLANATION FOLLOWS.  ANYTHING   *\n*   ELSE IS THE START OF A NORMAL UCB.  THE LAST UCB MUST BE USED   *\n*   AS THE SECOND ARGUMENT ON SUBSEQUENT CALLS TO THIS ROUTINE SO   *\n*   THE PROPER CONTINUITY OF UCB'S MAY BE MAINTAINED.               *\n*                                                                   *\n*===================================================================*\nUCBSCAN  CSECT\n         REGS\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.\n         LR    R12,R15             COPY BASE.\n         USING UCBSCAN,R12         (TELL ASSEMBLER).\n         LR    R14,R13             PRESERVE CALLER'S SAVE AREA PTR.\n         LA    R13,SAVE            POINT TO MY SAVE AREA\n         ST    R13,8(,R14)         CHAIN ...\n         ST    R14,SAVE+4          ... SAVE AREAS.\n*\n         LR    R2,R0               ADDRESS OF ENVIRONMENT BLOCK\n         LR    R3,R1               ADDRESS OF EXTERNAL FUNCTION BLOCK\n         L     R4,16(,R3)          GET FIRST PARM'S ADDRESS POINTER\n         L     R5,0(,R4)           GET FIRST PARM'S ADDRESS\n         L     R6,4(,R4)           GET FIRST PARM'S LENGTH\n         C     R6,=X'00000005'     MAKE SURE WE ARE 4 BYTES OR LESS\n         BL    GOODARG             IF SO, WE MAY CONTINUE\n         L     R4,20(,R3)          GET EVAL BLOCK POINTER ADDRESS\n         L     R4,0(,R4)           GET EVAL BLOCK ADDRESS\n         CVD   R6,TEMPWORK         DECIMALIZE REGISTER 6\n         UNPK  BADMESS1(4),TEMPWORK(8)\n         OI    BADMESS1+3,X'F0'\n         TR    BADMESS1(4),TRTAB-240\n         MVC   16(L'BADMESS1+2,R4),BADMESS1-2 PUT MESSAGE IN RETURN\n         L     R5,LBADMS1          GET RETURN ARGUMENT LENGTH\n         ST    R5,8(,R4)           PUT IT IN EVAL BLOCK\n         LH    R15,=X'0004'        SET UP NON-ZERO RETURN CODE\n         B     BADOUT              RETURN IT\n*\nGOODARG  EQU   *\n         LA    R9,8(,R4)           GET SECOND ARG ADDRESS POINTER\n         L     R4,0(,R9)           GET SECOND ARG ADDRESS\n         MVC   TEMPUCB(L'TEMPUCB+L'SCANWORK),0(R4) RECOVER WORK AREA\n         BCT   R6,COMP1            DECREMENT FOR CLC\nCOMP1    EX    R6,CLC1             COMPARE FOR ALL ZEROES\n*\n* CLC1   CLC   0(*-*,R5),ZEROES\n*\n         LA    R6,1(,R6)           RESTORE ADDRESS\n         BNZ   SEARCH              IF NOT FIRST PASS, DON'T INITIALIZE\n         XC    SCANWORK,SCANWORK   INDICATE WE'RE STARTING FRESH\n         LA    R9,8(,R9)           GET THIRD ADDRESS POINTER\n         L     R4,0(,R9)           GET THIRD ARG ADDRESS\n         L     R5,4(,R9)           GET THIRD ARG LENGTH\n         C     R5,=X'00000003'     MAKE SURE WE ARE AT LEAST 4 BYTES\n         BH    LONGOK              IF SO, WE MAY CONTINUE\n         BCT   R5,MOVE1            DECREMEMT FOR INSTRUCTIONAL USE\nMOVE1    EX    R5,MVC1             ELSE PUT PARTIAL IN MESSAGE\n*\n* MVC1   MVC   BADMESS3(*-*),0(R4) EXECUTED INSTRUCTION\n*\n         L     R4,20(,R3)          GET EVAL BLOCK POINTER ADDRESS\n         L     R4,0(,R4)           GET EVAL BLOCK ADDRESS\n         MVC   16(L'BADMESS3+2,R4),BADMESS3-2 PUT MESSAGE IN RETURN\nMVC2     MVC   8(4,R4),LBADMS3     EXECUTED INSTRUCTION\n         LH    R15,=X'0004'        SET UP NON-ZERO RETURN CODE\n         B     BADOUT              RETURN IT\nLONGOK   LA    R5,TYPES            POINT TO ALLOWED DEV TYPES\n         LH    R14,NTYPES          GET COUNT OF POSSIBILITIES\nNEXTRY   EQU   *\n         CLC   0(4,R4),0(R5)       DO WE HAVE A MATCH\n         BZ    TYPEFIND            IF SO WE'RE DONE\n         LA    R5,5(,R5)           POINT TO NEXT ONE\n         BCT   R14,NEXTRY          ELSE GO TRY AGAIN\n         MVC   BADMESS2(4),0(R4)   PUT SOUGHT DEVICE IN MESSAGE\n         L     R4,20(,R3)          GET EVAL BLOCK POINTER ADDRESS\n         L     R4,0(,R4)           GET EVAL BLOCK ADDRESS\n         MVC   16(L'BADMESS2+2,R4),BADMESS2-2 PUT MESSAGE IN RETURN\n         L     R5,LBADMS2          GET RETURN ARG LENGTH\n         ST    R5,8(,R4)           PUT IT INTO EVAL BLOCK\n         LH    R15,=X'008'         SET UP BAD RETURN CODE\n         B     BADOUT              RETURN LIKE THAT\n         DS    0H\nTYPEFIND EQU   *\n         MVC   GOSCAN+X'A1'(1),4(R5) MOVE INDICATOR INTO POSITION\nSEARCH   EQU   *\n         L     R4,20(,R3)          GET EVAL BLOCK POINTER ADDRESS\n         L     R4,0(,R4)           GET EVAL BLOCK ADDRESS\n         B     GOSCAN\n         CNOP  0,8                 ALIGN FIRST\nGOSCAN   EQU   *\n         UCBSCAN COPY,WORKAREA=SCANWORK,                               X\n               DEVCLASS=DASD,DYNAMIC=YES,UCBAREA=TEMPUCB\n         LTR   R15,R15             SEE IF WE GOT ONE\n         BNZ   NOMORE\n*        HERE WE HAVE A UCB POINTER TO PROCESS\n         MVC   16(L'TEMPUCB+L'SCANWORK,R4),TEMPUCB MOVE UCB FOR RETURN\n         L     R5,UCBLEN           GET RETURN ARGUMENT LENGTH\n         ST    R5,8(,R4)           PUT IT IN EVAL BLOCK\n         B     DONE\n*\nNOMORE   EQU   *\n         L     R5,UCBLEN           GET RETURN ARGUMENT LENGTH\n         ST    R5,8(,R4)           PUT IT IN EVAL BLOCK\n         MVI   16(R4),X'FF'        MAKE ENDING UCB\n         MVC   17(L'TEMPUCB+L'SCANWORK-1,R4),16(R4)\n*\nDONE     EQU   *\n         XR    R15,R15             MAKE ZERO RETURN CODE\n*\nBADOUT   EQU   *\n         L     R13,SAVE+4          GET CALLER'S SAVE AREA POINTER\n         ST    R15,16(,R3)         SET RETURN CODE\n         LM    R14,R12,12(R13)     GET CALLER'S REGISTERS\n         XR    R15,R15             SET UP ZERO RETURN CODE\n         BR    R14                 RETURN TO CALLER\n*\n         DS    0D\nSAVE     DS    9D                  REGISTER STORAGE\nTEMPWORK DS    1D\n*                                  EXECUTED INSTRUCTIONS\nCLC1     CLC   0(*-*,R5),ZEROES\nMVC1     MVC   BADMESS3(*-*),0(R4)\n*\nZEROES   DC    CL5'0000'\n*\n         DS    0F\nTYPES    EQU   *                   TYPES OF UCBS IT IS POSSIBLE TO\n         DC    CL4'ALL ',X'00'     SEARCH FOR WITH THIS SUBROUTINE\n         DC    CL4'TAPE',X'80'\n         DC    CL4'COMM',X'40'\n         DC    CL4'DASD',X'20'\n         DC    CL4'DISP',X'10'\n         DC    CL4'UREC',X'08'\n         DC    CL4'CHAR',X'04'\n         DC    CL4'CTC ',X'41'\nNTYPES   DC    AL2((*-TYPES)/5)    NUMBER OF 5 BYTE ENTRIES IN TABLE\n*\n         DC    X'FFFE'             ERROR INDICATOR\nBADMESS1 DC    C'XXXX FIRST ARGUMENT MAY NOT EXCEED 5 CHARS IN LENGTH'\n         DS    0F\nLBADMS1  DC    AL4(L'BADMESS1+2)\n*\n         DC    X'FFFE'             ERROR INDICATOR\nBADMESS2 DC    C'XXXX THAT DEVICE TYPE IS NOT DEFINED.'\n         DS    0F\nLBADMS2  DC    AL4(L'BADMESS2+2)\n*\n         DC    X'FFFE'             ERROR INDICATOR\nBADMESS3 DC    C'???? - A DEVICE TYPE MUST BE 4 CHARACTERS IN LENGTH.'\n         DS    0F\nLBADMS3  DC    AL4(L'BADMESS3+2)\n*\nTRTAB    DC    C'0123456789ABCDEF'\n*\n         DS    0F\nTEMPUCB  DS    CL48                AREA FOR UCB STORAGE\nSCANWORK DS    CL100               UCBSCAN WORK AREA\n         DS    0F\nUCBLEN   DC    AL4(L'TEMPUCB+L'SCANWORK)\n*\n*        PRINT NOGEN\n         DSECT\n         IEFUCBOB                      UCB\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UCBTEST": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\\x00\\x00\\x910\\x9f\\x00\\x92\"_\\x18X\\x00l\\x00\\n\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf0\\xf2\\xf0@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "1991-11-05T00:00:00", "modifydate": "1992-08-12T18:58:00", "lines": 108, "newlines": 10, "modlines": 0, "user": "FILE020"}, "text": "/*====REXX===========================================================*/\n/*                                                                   */\n/*        THIS REXX CALLS AN ASSEMBLY LANGUAGE SUBROUTINE WHICH      */\n/*   SCANS THE SYSTEM FOR ALL DASD UCB'S.  THE REXX THEN LISTS THOSE */\n/*   DASD VOLUMES THAT ARE ONLINE INCLUDING UNIT NUMBERS AND VOLUME  */\n/*   SERIAL NUMBERS.  THE REXX CAN SERVE AS A MODEL TO MAKE A SYSIN  */\n/*   DATA SET TO TURN CACHE ON OR OFF FOR ALL VOLUMES ON THE SYSTEM  */\n/*   AT A GIVEN TIME.  THIS IS SUPPOSED TO AVOID THE NECESSITY OF    */\n/*   MANUALLY MAINTAINING A VOLLUME SERIAL LIST FOR CACHING.         */\n/*                                                                   */\n/*===================================================================*/\n\nCOMM = 'ON'\nDO WHILE LENGTH(ARG) > 1\n  PARSE UPPER ARG TYPEDEV ARG\n  IF ( TYPEDEV = 'ON' ) | ( TYPEDEV = 'OFF' ) THEN COMM = TYPEDEV\n  END\nTYPEDEV = 'DASD'                        /* WE ONLY WANT DISK UNITS   */\n\nIF COMM = 'ON' THEN DO                  /* SET UP COMMANDS FOR 'ON'  */\n  TYPE1 = 'DEV' COMM\n  TYPE2 = 'NVS' COMM\n  TYPE3 = 'DFW' COMM\n  END\nELSE DO                                 /* SET UP COMMANDS FOR OFF   */\n  TYPE1 = 'DFW' COMM\n  TYPE2 = 'NVS' COMM\n  TYPE3 = 'DEV' COMM\n  END\n\nSAY 'STARTING REXX TO LIST CURRENTLY ONLINE' TYPEDEV 'VOLUMES.'\nCOUNT =  0                              /* INITIALIZE LOCAL COUNTERS */\nONLINE = 0\nOLDSTR =                                /* AND LOCAL OLD STRING ID   */\nHOLDER =\nSTART = '  SETCACHE UNIT('              /* COMMAND PREFIX            */\n\nDO WHILE GETUCB() = 0                   /* PROCESS TIL NO MORE UNITS */\n  TEMP = SUBSTR(X,4,1)                  /* LOOK AT 4TH BYTE, UCBSTAT */\n  TEMP = C2D(TEMP)                      /* CVT TO HEX DIGITS         */\n  COUNT = COUNT + 1                     /* BUMP TOTAL DASD COUNT     */\n\n  IF TEMP > 127 THEN DO                 /* LOOK FOR ONLINE STATUS    */\n    UNCODE = C2X(SUBSTR(X,20,1))        /* PICK OUT UNIT TYPE BYTE   */\n    IF UNCODE = '0E' THEN UNIT = '3380' /* ASSIGN DASD TYPE          */\n    ELSE IF UNCODE = '0F' THEN UNIT = '3390'\n    ELSE                       UNIT = '????' /* UNDEFINED            */\n    STR = X2D(SUBSTR(X,14,3)) % 32      /* COMPUTE NEW STRING ADDR   */\n    IF OLDSTR \u00ac= STR THEN DO            /* IF WE HAVE A NEW STRING   */\n      IF COMM = 'ON' THEN DO\n        OUT = START || UNIT') VOL('SUBSTR(X,29,6)') SUBSYSTEM' COMM\n        SAY OUT\n        END\n      ELSE DO\n        IF OLDVOL \u00ac= 'OLDVOL' THEN DO\n          HOLDER = HOLDER OLDUN OLDVOL\n          END\n        OLDVOL = SUBSTR(X,29,6)\n        OLDUN = UNIT\n        END\n      OLDSTR = STR                    /* AND REMEMBER NEW STRING   */\n      END\n/*                    UCBVOLI                                        */\n/*                       |                                           */\n/*                       |                                           */\n/*                      \\|/                                          */\n    DO I = 1 TO 3                       /* ISSUE ALL COMMANDS        */\n      OUT = START || UNIT') VOL('SUBSTR(X,29,6)')' VALUE(TYPE||I)\n      SAY OUT\n      END\n    ONLINE = ONLINE + 1                 /* BUMP COUNT OF ITEMS       */\n    END\n  END\n  IF OLDVOL \u00ac= 'OLDVOL' THEN DO\n    HOLDER = HOLDER OLDUN OLDVOL\n    END\n  DO WHILE LENGTH(HOLDER) > 0\n    PARSE VAR HOLDER OLDUN OLDVOL HOLDER\n    OUT = START || OLDUN') VOL('OLDVOL') SUBSYSTEM' COMM\n    SAY OUT\n    END\n\nCOUNT = COUNT -1                         /* ALLOW FOR LAST RETURN    */\nSAY COUNT 'UNITS FOUND WITH' ONLINE 'UNITS ONLINE.' /* FINAL COUNT   */\n\nEXIT\n\n/***             E N D   O F   M A I N   R O U T I N E             ***/\n\n/*===================================================================*/\n/*                                                                   */\n/*        PROCEDURE TO CALL THE UCB ACQUISITION SUBROUTINE AND SET   */\n/*   THE RETURN CODE TO ZERO IF ANOTHER UCB WAS RETURNED OR ELSE     */\n/*   SETTING THE RETURN CODE TO NON-ZERO IF THE LAST UCB WAS FOUND.  */\n/*                                                                   */\n/*===================================================================*/\n\nGETUCB: PROCEDURE EXPOSE X COUNT TYPEDEV\n\nCALL UCBSUBR COUNT,X,TYPEDEV          /* CALL SUBROUTINE           */\nPARSE VAR RESULT X                    /* PICK UP RESULT (UCB+WORK) */\nIF C2X(LEFT(X,2)) = 'FFFF' THEN ,     /* IF THERE WERE NO MORE ... */\n  RETURN 4                            /* RETURN A CODE OF 4        */\nIF C2X(LEFT(X,2)) = 'FFFE' THEN DO    /* CHECK FOR EROR INDICATOR  */\n  SAY SUBSTR(X,3)                     /* AND PRINT ERROR MESSAGE   */\n  EXIT                                /* AND EXIT ENTIRELY IF SO   */\n  END\nRETURN 0                              /* ELSE RETURN A CODE OF 0   */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT020/FILE020.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT020", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}