{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011633000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 235144, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE275.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 235144, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE275.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x05\\x08'", "DS1TRBAL": "b'S\\xac'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xed\\x00\\x06\\x01\\xed\\x00\\x0b\\x00\\x06'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\\x14/\\x00\\x96 \\x7f\\x11C\\x00#\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd4\\xe5\\xc8@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-05-21T00:00:00", "modifydate": "1996-07-25T11:43:00", "lines": 35, "newlines": 38, "modlines": 0, "user": "SYSMVH"}, "text": "*---------------------------------------------------------------------*\n*    Advent Software                                                  *\n*    340 West Butterfield Road                                        *\n*    Suite 4B                                                         *\n*    Elmhurst, IL 60126                                               *\n*    (708) 279-5449                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n*   NO WARRANTY, EXPRESSED OR IMPLIED, IS PROVIDED BY ANY OR ALL      *\n*   OF THE PERSONS AND/OR INSTALLATIONS EDITING, DUPLICATING, OR      *\n*   OTHERWISE HANDLING THIS TAPE.  PERSONS AND/OR INSTALLATIONS       *\n*   USING ANY OF THE PROGRAMS OR MATERIALS ON THIS TAPE, DO SO        *\n*   ENTIRELY AT THEIR OWN RISK.                                       *\n*                                                                     *\n*                                                                     *\n*  Author.   Mark Hedges                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* APFLIST.......List APF Data Sets using CSVAPF                       *\n*                                                                     *\n* CSVQUERY......List LPA/JPA load modules using CSVQUERY              *\n*                                                                     *\n* GETDSAB.......Obtain a DDNAME list using GETDSAB                    *\n*                                                                     *\n* ISPFEXIT......ISPF Panel exit (neat on primary panel)               *\n*                                                                     *\n* LSPACE........Obtain Free Space for SYSRES Pack                     *\n*                                                                     *\n* PACKOFF.......Output ISPF packed ifle/member to non-ISPF pack file  *\n*                                                                     *\n* UCBSCAN.......Scan some UCBs                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "APFLIST": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x934\\x1f\\x00\\x96 \\x7f\\x119\\x00\\xa4\\x00\\x83\\x00\\x00\\xe2\\xe8\\xe2\\xd4\\xe5\\xc8@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1993-12-07T00:00:00", "modifydate": "1996-07-25T11:39:00", "lines": 164, "newlines": 131, "modlines": 0, "user": "SYSMVH"}, "text": "// EXEC ASMHLC\n//C.SYSLIB DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSIN DD *\n COPY $DOC\n* Note: This is an ESA-only program due to the use of BAKR etc..\n*\nAPFLIST       AMODE    31\nAPFLIST       RMODE    ANY\nAPFLIST       CSECT\n              BAKR     R14,0                * Load ESA Stack\n              LR       R12,R15              * Establish Base\n             USING     APFLIST,R12\n              BSM      R14,0                * Save mode\n              B        GET_STOR             * Skip constants\n              DC       C'APFLIST_&SYSDATE._&SYSTIME.'\nGET_STOR      STORAGE  OBTAIN,              * Get storage for save area+\n               LENGTH=STORAGE_LEN,LOC=RES\n              ST       R1,STORADDR          * Save for later\n              LR       R13,R1               * Point R13 to save area   +\n                                              even though we don't use +\n                                              it someone might!\n              XC       0(STORAGE_LEN,R13),0(R13)\n              ST       R13,4(,R1)           * Save forward\n              ST       R1,8(,R1)            * Backwards\n              LR       R13,R1               * Point to 18F words\n              MVC      4(4,R1),=C'F1SA'     * Storage macro\n             USING     STORAGE,R13          * Talk to our storage area\n*  Determine MVS level and APF level\n              MVI    DYNAMIC_APF_LIST,NO    * Set initial flag\n              L      R9,CVTPTR              * CVT\n             USING   CVTMAP,R9              *\n              TM     CVTDCB,CVTOSEXT        * Are we ESA?\n              BZ     NOT_ESA                *.Nope, must be static APF\n              TM     CVTOSLV1,X'80'         * ESA 4.3?\n              BZ     NOT_ESA43              *.Nope, use static APF\n*  Determine if APF is Dynamic\n              CSVAPF REQUEST=QUERYFORMAT,FORMAT=APF_FORMAT\n              CLI    APF_FORMAT,CSVAPFFORMATDYNAMIC\n              BNE    STATIC_APF             *.nope, static\n              MVI    DYNAMIC_APF_LIST,YES   *.yep, set flag\nDYNAMIC_APF   DS     0H\n              L      R2,=F'16816'           * 300 * 56 + 16\n              ST     R2,APF_GETMAIN_LEN     * Save length\n              SPACE\nGET_APF_STOR  L      R2,APF_GETMAIN_LEN     * Load length\n              GETMAIN RU,LV=(R2),LOC=RES    * Get some storage\n              ST     R1,APF_GETMAIN_ADDR    *.Save storage address\n              LR     R3,R1                  *\n              CSVAPF REQUEST=LIST,                                     +\n               ANSAREA=(R3),                * Our storage area         +\n               ANSLEN=APF_GETMAIN_LEN,      *...how big it is          +\n               RETCODE=APF_RETCODE,         * return code              +\n               RSNCODE=APF_RSNCODE,         * reason code              +\n               MF=(E,CSVAPF)                * execute form\n*  Are we good for it?\n              CLC    APF_RETCODE,=AL4(CSVAPFRC_OK)\n              BE     GOOD_DYM_LIST          * Everything OK\n              CLC    APF_RETCODE,=AL4(CSVAPFRC_WARN)\n              BE     WARN_DYM_LIST          * Write your own\n              NC     APF_RETCODE,=AL4(CSVAPFRSNCODEMASK)\n              CLC    APF_RSNCODE,=AL4(CSVAPFRSNNOTALLDATARETURNED)\n              BNE    ERROR_DYM_CODES        * Write your own\n*  We have eliminated all other errors, our storage area is too SMALL!\n              L      R4,APFHTLEN-APFHDR(,R4)  From answer area, needed +\n                                              amount of core for all   +\n                                              APF entries\n              L      R2,APF_GETMAIN_LEN     * Load old Size\n              L      R3,APF_GETMAIN_ADDR    * Load old address\n              FREEMAIN RU,LV=(R2),A=(R3)    * Free old stuff\n              ST     R4,APF_GETMAIN_LEN     * Save new size\n              B      GET_APF_STOR           * GETMAIN again\n              SPACE\nGOOD_DYM_LIST DS     0H                     *\n              L      R9,APF_GETMAIN_ADDR    * Load our storage address\n              L      R8,APFH#REC-APFHDR(,R9)  Get the num. of entries\n              ST     R8,APF_ENTRIES         *.save\n              L      R8,APFHOFF-APFHDR(,R9) * =a(1st APFE)\n              AR     R8,R9                  * Go past header\n              L      R6,APF_ENTRIES         * Number of entries in R6\n             USING   APFE,R8                * here we are\nNEXT_DYM_DSN  TM     APFEFLAGS,APFESMS      * SMS MANAGED?\n              BNO    NOT_SMS                *\n              MVI    APFSMS,C'Y'            *\nNOT_SMS       MVC    APFVOL(6),APFEVOLUME   * Save APFVOL\n              XR     R2,R2\n              ICM    R2,B'0001',APFEDSLEN   * Get Length DSNAME\n              BCTR   R2,0\n              MVC    APFDSN(*-*),APFEDSNAME * Save DSNAME\n              EX     R2,*-6\n* Do something with it...\n              ICM    R1,B'0011',APFELEN     * Length of this entry\n              AR     R8,R1                  * Point to next entry\n              BCT    R6,NEXT_DYM_DSN        * goback\n             DROP    R8\nFINE_DYM      L      R2,APF_GETMAIN_LEN\n              L      R4,APF_GETMAIN_ADDR\n              FREEMAIN RU,LV=(R2),A=(R4)    * Free core\nFINE          L        R2,STORADDR          * ALL THROUGH WITH STORAGE\n              STORAGE  RELEASE,LENGTH=STORAGE_LEN,ADDR=(R2)\n              PR     ,                      * Reload ESA STAX\nWARN_DYM_LIST        DS    0H\n              B      FINE_DYM\nERROR_DYM_CODES      DS    0h\n              B      FINE_DYM\nSTATIC_APF    DS     0H                     *\nNOT_ESA43     DS     0H                     * =A(STATIC-APF)\nNOT_ESA       L      R8,CVTAUTHL            * =A(static-APF)\n              ST     R8,CVT_AUTHL           *.SAVE IT\n              XR     R7,R7                  * CLEAR\n              ICM    R7,B'0001',1(R8)       * Total APF entries\n              ST     R7,APF_LENGTH          *.save it\n              LA     R8,4(,R8)\n             USING   APF_DSECT,R8\n* do something with the old static tabel\n             DROP    R8\n              B      FINE\n              CSVAPF MF=(L,CSVAPF)\nSTORADDR        DC       F'0'\n                LTORG\nSTORAGE         DSECT\nSAVE_AREA       DS       18F\nAPF_GETMAIN_LEN DS       F\nAPF_GETMAIN_ADDR DS      F\nAPF_RETCODE     DS       F\nAPF_RSNCODE     DS       F\nAPF_ENTRIES     DS       F\nAPF_LENGTH      DS       F\nCVT_AUTHL       DS       F\nDYNAMIC_APF_LIST DS      XL1\nAPFDSN          DS       CL44\nAPFSMS          DS       CL1\nAPFVOL          DS       CL6\nAPF_FORMAT      DS       CL1\n                DS       0D\nSTORAGE_LEN     EQU      *-STORAGE\n                CVT  DSECT=YES,LIST=NO.PREFIX=NO\n                IHAXTLST\n                YREGS\nYES             EQU       C'Y'\nNO              EQU       C'N'\n                CSVAPFAA\n TITLE '>>> APF DSECT FOR STATIC TABLE <<<'\nAPF_DSECT       DSECT    WHAT THE APF TABLE IN MEMORY LOOKS LIKE ...\nAPF_LEN         DS       XL1           * ENTRIES LENGTH\nAPF_VOL         DS       CL6           * ENTRIES VOLSER\nAPF_DSN         DS       CL44          * ENTRIES DSN\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Sys/Stat for MVS is an integrated ISPF MVS search and display    *\n*    facility that uses the latest technology to improve systems      *\n*    programmers productvity.  Please call for a no obligation        *\n*    evaluation.                                                      *\n*                                                                     *\n*    Advent Software                                                  *\n*    340 West Butterfield Road                                        *\n*    Suite 4B                                                         *\n*    Elmhurst, IL 60126                                               *\n*    (708) 279-5449                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n                END\n//L.SYSLMOD DD DSN=&&TEMP(APFLIST),DISP=(,PASS),UNIT=VIO,\n// DCB=SYS1.LINKLIB,SPACE=(TRK,(2,1,10))\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CSVQUERY": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x934\\x1f\\x00\\x96 \\x7f\\x11@\\x00x\\x00`\\x00\\x00\\xe2\\xe8\\xe2\\xd4\\xe5\\xc8@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1993-12-07T00:00:00", "modifydate": "1996-07-25T11:40:00", "lines": 120, "newlines": 96, "modlines": 0, "user": "SYSMVH"}, "text": "// EXEC ASMHLC\n//C.SYSLIB DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSIN DD *\n COPY $DOC\nCSVQUERY      AMODE    31\nCSVQUERY      RMODE    ANY\nCSVQUERY      CSECT\n              BAKR     R14,0                * Load ESA Stack\n              LR       R12,R15              * Establish Base\n             USING     CSVQUERY,R12\n              BSM      R14,0                * Save mode\n              B        GET_STOR             * Skip constants\n              DC       C'CSVQUERY_&SYSDATE._&SYSTIME.'\nGET_STOR      STORAGE  OBTAIN,              * GET STORAGE FOR SAVE AREA+\n               LENGTH=STORAGE_LEN,LOC=RES\n              ST       R1,STORADDR          * Save for later\n              LR       R13,R1               * POINT R13 TO SAVE AREA   +\n                                              EVEN THOUGH WE DON'T USE +\n                                              it someone might!\n              XC       0(STORAGE_LEN,R13),0(R13)\n              ST       R13,4(,R1)           * Save forward\n              ST       R1,8(,R1)            * Backwards\n              LR       R13,R1               * Point to 18F words\n              MVC      4(4,R1),=C'F1SA'     * Storage macro\n             USING     STORAGE,R13          * Talk to our storage area\n* Copy CSVQUERY model\n              MVC    CSVQUERY(CSVQUERY_LEN),CSVQUERY_MODEL\n              LA     R1,CSVQUERY\n              ST     R1,CSVQUERY_ADDR\n*  Loop here for other invocations\n              XC     CSVQUERY_RC,CSVQUERY_RC\n              CSVQUERY INEPNAME=SEARCH_FOR,                            +\n               SEARCH=JPALPA,                                          +\n               OUTLENGTH=CSVQUERY_LENGTH,                              +\n               OUTEPA=CSVQUERY_EPA,                                    +\n               OUTEPNM=CSVQUERY_EPNM,                                  +\n               OUTMJNM=CSVQUERY_MJNM,                                  +\n               OUTLOADPT=CSVQUERY_LOADPT,                              +\n               OUTSP=CSVQUERY_SP,                                      +\n               OUTATTR1=CSVQUERY_ATTR1,                                +\n               OUTATTR2=CSVQUERY_ATTR2,                                +\n               OUTATTR3=CSVQUERY_ATTR3,                                +\n               RETCODE=RC,                                             +\n               OUTPID=CSVQUERY_OUTPID,          ESA 4.3 ONLY           +\n               MF=(E,CSVQUERY_ADDR)\n               L     R15,RC\n               B     *+4(R15)\n               B     RC00\n               B     RC04\n               B     RC08\n               B     RC12\n               B     RC16\n               B     BAD\nRC04           DS    0H\nRC08           DS    0H\nRC12           DS    0H\nRC16           DS    0H\nBAD            DS    0H\n               B     FINE\n*  Process module attributes\nRC00          MVC    LOCATION(4),=CL4' '\n              TM     CSVQUERY_ATTR3,B'00100000'\n              BNO    *+10\n              MVC    LOCATION(4),=CL4'PLPA' * PLPA\n              TM     CSVQUERY_ATTR3,B'00010000'\n              BNO    *+10\n              MVC    LOCATION(4),=CL4'MLPA' * MLPA\n              TM     CSVQUERY_ATTR3,B'00001000'\n              BNO    *+10\n              MVC    LOCATION(4),=CL4'FLPA' * FLPA\n              TM     CSVQUERY_ATTR3,B'00000100'\n              BNO    *+10\n              MVC    LOCATION(4),=CL4'CSA' * CSA\n*  Now do something\nFINE          L        R2,STORADDR          * ALL THROUGH WITH STORAGE\n              STORAGE  RELEASE,LENGTH=STORAGE_LEN,ADDR=(R2)\n              PR                            * Reload ESA STAX\nSEARCH_FOR      DC       CL8'IEFACTRT'\nCSVQUERY_MODEL  CSVQUERY MF=(L,X)\nCSVQUERY_LEN    EQU      (*-CSVQUERY_MODEL)\nSTORADDR        DS       F\nLOCATION        DS       CL4\n                LTORG\nSTORAGE         DSECT\nSAVE_AREA       DS       18F\nRC              DS       F\nCSVQUERY_DSECT  CSVQUERY MF=(L,QUERY)\nCSVQUERY_ADDR   DS       F\nCSVQUERY_RC     DS       F\nCSVQUERY_LENGTH DS       F\nCSVQUERY_EPA    DS       F\nCSVQUERY_EPNM   DS       CL8\nCSVQUERY_MJNM   DS       CL8\nCSVQUERY_LOADPT DS       F\nCSVQUERY_SP     DS       F\nCSVQUERY_ATTR1  DS       XL1\nCSVQUERY_ATTR2  DS       XL1\nCSVQUERY_ATTR3  DS       XL1\nCSVQUERY_OUTPID DS       CL4\n                DS       0D\nSTORAGE_LEN     EQU      *-STORAGE\n                CVT  DSECT=YES,LIST=NO.PREFIX=NO\n                IHAXTLST\n                YREGS\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Sys/Stat for MVS is an integrated ISPF MVS search and display    *\n*    facility that uses the latest technology to improve systems      *\n*    programmers productvity.  Please call for a no obligation        *\n*    evaluation.                                                      *\n*                                                                     *\n*    Advent Software                                                  *\n*    340 West Butterfield Road                                        *\n*    Suite 4B                                                         *\n*    Elmhurst, IL 60126                                               *\n*    (708) 279-5449                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n                END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDSAB": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x934\\x1f\\x00\\x96 \\x7f\\x11@\\x00h\\x00S\\x00\\x00\\xe2\\xe8\\xe2\\xd4\\xe5\\xc8@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1993-12-07T00:00:00", "modifydate": "1996-07-25T11:40:00", "lines": 104, "newlines": 83, "modlines": 0, "user": "SYSMVH"}, "text": "// EXEC ASMHCL\n//C.SYSLIB DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSIN DD *\n COPY $DOC\nGETDSAB       AMODE    31\nGETDSAB       RMODE    ANY\nGETDSAB       CSECT\n              BAKR     R14,0                * Load ESA Stack\n              LR       R12,R15              * Establish Base\n             USING     GETDSAB,R12\n              BSM      R14,0                * Save mode\n              B        GET_STOR             * Skip constants\n              DC       C'GETDSAB_&SYSDATE._&SYSTIME.'\nGET_STOR      STORAGE  OBTAIN,              * Get storage for save area+\n               LENGTH=STORAGE_LEN,LOC=RES\n              ST       R1,STORADDR          * Save for later\n              LR       R13,R1               * Point R13 to save area   +\n                                              even though we don't use +\n                                              it someone might!\n              XC       0(STORAGE_LEN,R13),0(R13)\n              ST       R13,4(,R1)           * Save forward\n              ST       R1,8(,R1)            * Backwards\n              LR       R13,R1               * Point to 18F words\n              MVC      4(4,R1),=C'F1SA'     * Storage macro\n             USING     STORAGE,R13          * Talk to our storage area\n*  Get 1st one...\nFIRST_DSAB    GETDSAB FIRST,                                           +\n               DSABPTR=DSABPTR,             * Storage area             +\n               RSNCODE=RSNCODE,             * Reason code              +\n               MF=(E,DSAB_LIST)             *\n              ST     R15,DSAB_RC\n              LTR    R15,R15                *\n              BNZ    BAD_DSAB               * Write your own\n              B      PROCESS_DSAB           *\n              SPACE  2\nNEXT_DSAB     GETDSAB NEXT,                                            +\n               DSABPTR=DSABPTR,                                        +\n               RSNCODE=RSNCODE,                                        +\n               MF=(E,DSAB_LIST)\n              ST     R15,DSAB_RC\n              LTR    R15,R15                *\n              BNZ    END_DSAB\nPROCESS_DSAB  DS     0H\n              L      R9,DSABPTR\n             USING   DSAB,R9\n              L      R8,DSABTIOT            * =A(TIOT)\n             USING   TIOENTRY,R8            *\n*\n*  Users familiar with processing a TIOT entry can add their own\n*  code here.  Usually, one could determine the DDNAME and then\n*  use the TIOEJFCB to obtain the data set name.\n*\n              B      NEXT_DSAB              * Loop....\n             DROP    R8\nBAD_DSAB      DS     0H\nEND_DSAB      DS     0H\nFINE          L        R2,STORADDR\n              STORAGE  RELEASE,LENGTH=STORAGE_LEN,ADDR=(R2)\n              PR       ,                    * Reload ESA STAX\nSTORADDR        DS       F\n                LTORG\n                DROP   ,\nSTORAGE         DSECT\nSAVE_AREA       DS     18F\nDSAB_RC         DS       F\n                DS      0D\nDSABPTR         DS       F\n                GETDSAB MF=(L,DSAB_LIST) <<< LABEL\nTIOT_ADDR       DS       F\nRETCODE         DS       F\nRSNCODE         DS       F\n                DS      0D\nSTORAGE_LEN     EQU      *-STORAGE\n                IHADSAB\n                CVT DSECT=YES,LIST=NO\n                PRINT OFF\n                IEFJESCT\nSIOT            DSECT\n                IEFASIOT\nJFCB            DSECT\n                IEFJFCBN  LIST=YES\nTIOT            DSECT\n                IEFTIOT1\nUCB             DSECT\n                IEFUCBOB  PREFIX=YES,LIST=YES\n                IEZJSCB\n                IKJTCB\n                YREGS\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Sys/Stat for MVS is an integrated ISPF MVS search and display    *\n*    facility that uses the latest technology to improve systems      *\n*    programmers productvity.  Please call for a no obligation        *\n*    evaluation.                                                      *\n*                                                                     *\n*    Advent Software                                                  *\n*    340 West Butterfield Road                                        *\n*    Suite 4B                                                         *\n*    Elmhurst, IL 60126                                               *\n*    (708) 279-5449                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n                END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISPFEXIT": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x96\\x14/\\x00\\x96 \\x7f\\x11A\\x02\\x8f\\x02\\x82\\x00\\x00\\xe2\\xe8\\xe2\\xd4\\xe5\\xc8@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-05-21T00:00:00", "modifydate": "1996-07-25T11:41:00", "lines": 655, "newlines": 642, "modlines": 0, "user": "SYSMVH"}, "text": "//PROCS JCLLIB ORDER=Your.proclib\n//   EXEC ASMHCL\n//C.SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.MODGEN,DISP=SHR\n//C.SYSIN DD *\n COPY $DOC\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n*                                                                     *\n*      MODULE NAME = SYSISPFE                                         *\n*                                                                     *\n*      DESCRIPTIVE NAME = ISPF 4.1 and ISPF 4.2 Primary/Panel Exit    *\n*                                                                     *\n*      OPERATING ENVIRONMENT = MVS/XA 2.3 and ISPF 4.1 or above       *\n*                                                                     *\n*      FUNCTION = Display MVS system information on an ISPF panel     *\n*                 using panel exit technology.                        *\n*                                                                     *\n*      REGISTER USAGE:                                                *\n*                                                                     *\n*                   R1 ..... ISPF passes us data here                 *\n*                   R2 .....                                          *\n*                   R3 .....                                          *\n*                   R4 .....                                          *\n*                   R5 .....                                          *\n*                   R6 .....                                          *\n*                   R7 .....                                          *\n*                   R8 .....                                          *\n*                   R9 .....                                          *\n*                  R10 ..... Base+4096+4096                           *\n*                  R11 ..... Base+4096                                *\n*                  R12 ..... Base                                     *\n*                  R13 .....                                          *\n*                  R14 .....                                          *\n*                  R15 ..... 00                                       *\n*                                                                     *\n*      MACROS = IBM:                                                  *\n*                    GETMAIN                                          *\n*                    YREGS                                            *\n*                                                                     *\n*             OTHER:                                                  *\n*                                                                     *\n*                                                                     *\n* SUBROUTINES =                                                       *\n*                                                                     *\n*      DSECTS = IBM: CVT                                              *\n*                    IHAECVT                                          *\n*                    IHAASCB                                          *\n*                    IHAASVT                                          *\n*                    IEESMCA                                          *\n*                    IEECHAIN                                         *\n*                    IRAOUCB                                          *\n*                                                                     *\n*                                                                     *\n*             OTHER:                                                  *\n*                                                                     *\n*                                                                     *\n*      MODULE TYPE = PROCEDURE                                        *\n*                                                                     *\n*         PROCESSOR = ASMH V2                                         *\n*                                                                     *\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n  EJECT\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n*                                                                     *\n*      ENTRY POINTS = SYSISPFE (ONLY ENTRY POINT)                     *\n*                                                                     *\n*      INPUT = ISPF parameters Via R1                                 *\n*                                                                     *\n*      OUTPUT = none directly                                         *\n*                                                                     *\n*                                                                     *\n*      EXIT - NORMAL = AT PROGRAM END VIA BRANCH REGISTER 14          *\n*                                                                     *\n*      EXIT - ERROR =                                                 *\n*                                                                     *\n*      EXTERNAL REFERENCES =                                          *\n*                                                                     *\n*      TABLES =                                                       *\n*                                                                     *\n*      AUTHOR = MARK V. HEDGES -                                      *\n*                                                                     *\n*    Sys/Stat for MVS is an integrated ISPF MVS search and display    *\n*    facility that uses the latest technology to improve systems      *\n*    programmers productvity.  Please call for a no obligation        *\n*    evaluation.                                                      *\n*                                                                     *\n*    Advent Software                                                  *\n*    340 West Butterfield Road                                        *\n*    Suite 4B                                                         *\n*    Elmhurst, IL 60126                                               *\n*    (708) 279-5449                                                   *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*      MESSAGES =                                                     *\n*                                                                     *\n*      ABEND CODES =                                                  *\n*                                                                     *\n*                                                                     *\n* NOTE(S):                                                            *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* -----------------------  CHANGE SECTION  ---------------------------*\n*                                                                     *\n* 11/01/95 - all new                                                  *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\n                                                             EJECT\n*---------------------------------------------------------------------*\n*  Panel definition...\n* )PANEL KEYLIST(ISRSAB,ISR)\n* )ATTR.....\n@LOW_HILITE        EQU    C'#'\n@HIGH_HILITE       EQU    C'$'\n@MIDDLE_HILITE     EQU    X'5F'\nCPU_MIDDLE_VALUE   EQU    75\nCPU_HIGH_VALUE     EQU    90\n*   \\  type(output)   color(green)   caps(off)\n*   $  type(dataout)  color(red)     caps(off)\n*   \u00ac  type(dataout)  color(yellow)  caps(off)\n*   #  type(dataout)  color(green)   caps(off)\n*   @  area(dynamic)\n* )BODY\n* +CPU:@CPU @\\CPUM       +Rel\\REL     +ID\\ID  +IPL\\IPLD    +SysPlex\\PLEX\n* )INIT\n*  /* Do NOT alter the number of X's in the following variables    */\n* &CPU = XXXXX             /* CPU Busy Percentage  (dynamic area)*/\n* &REL = XXXXXXXX          /* 'SP V.M.R' MVS level               */\n* &ID  = XXXX              /* Systems ID                         */\n* &CPUM= XXXXXXXXXXX       /* CPU Model-Serial                   */\n* &FMID= XXXXXXXX          /* MVS FMID                           */\n* &IPLD= XXXXXXXX          /* IPL Date                           */\n* &IPLT= XXXXXXXX          /* IPL Time                           */\n* &JOB = XXXX              /* # Active Jobs                      */\n* &TSU = XXXX              /* # Active TSO Users                 */\n* &STC = XXXX              /* # Active STC's                     */\n* &INI = XXXX              /* # Active Inits                     */\n* &PLEX= XXXXXXXXXXX       /* SysPlex Name '-PlexID' (if esa 5.1+*/\n* PANEXIT ((CPU,REL,ID,CPUM,FMID,IPLD,IPLT,JOB,TSU,STC,INI,PLEX),+\n* LOAD,SYSISPFE)\n* )REINIT\n* )PROC\n* )END\n*---------------------------------------------------------------------*\n TITLE 'Local DSECTS'\nSYSISPFE_RECORD      DSECT\nCPU_HILITE           DS       CL01\nCPU                  DS       CL04\nREL                  DS       CL(L'MVS_RELEASE)\nID                   DS       CL(L'MVS_SYSID)\nCPUM                 DS       CL(L'MVS_MODEL+1+L'MVS_SERIAL)\nFMID                 DS       CL(L'MVS_FMID)\nIPLD                 DS       CL08\nIPLT                 DS       CL08\nJOB                  DS       CL04\nTSO                  DS       CL04\nSTC                  DS       CL04\nINIT                 DS       CL04\nPLEX                 DS       CL11   * SYSPLEX\nSYSISPFE_RECORD_LEN  EQU      *-SYSISPFE_RECORD\n                                                                SPACE 1\n*  Getmain'd storage area for RENT Code\nSTORAGE_AREA  DSECT\nSTORAGE_SAVE  DS     20F                    * MANDATORY SAVE AREA 18F\nSTORAGE_ADDR  DS       F                    * \"    SAVE GETMAIN ADDR\nSTORAGE_LENGTH DS      F                    * \"    SAVE GETMAIN LENGTH\nSTORAGE_BASES DS      3F                    * \"    BASE REGS\nSTORAGE_PGMNAME DS     CL8                  * \"    PROGRAM NAME\nINSTR_ADDR    DS      2A                    * \"    ESTAE NEXT INSTR.\nMVS_RELEASE   DS       CL8                  *\nMVS_FMID      DS       CL8                  *\nMVS_SERIAL    DS       CL6                  *\nMVS_MODEL     DS       CL4                  *\nMVS_SYSID     DS       CL4                  *\nFULL_WORDS    DS     18F                    * GENERAL USE\nTENWORDS      EQU      FULL_WORDS+(8*4)\nBALREG_SAVE   DS     10F                    * 'BAL/BAS' SAVE AREAS\nBALREG_SAVE1  EQU      BALREG_SAVE+4        *\nBALREG_SAVE2  EQU      BALREG_SAVE+8        *\nBALREG_SAVE3  EQU      BALREG_SAVE+12       *\nBALREG_SAVE4  EQU      BALREG_SAVE+16       *\nBALREG_SAVE5  EQU      BALREG_SAVE+20       *\nSAVE_AREA     DS     18F                    * GENERAL\nSAVE_REGS     DS      8F                    * BALR'D ROUTINES\nSETUP_SAVE    EQU      SAVE_REGS+00         *\nGATHER_SAVE   EQU      SAVE_REGS+04         *\nPRESENT_SAVE  EQU      SAVE_REGS+08         *\nPROCESS_SAVE  EQU      SAVE_REGS+12         *\nCLOSE_SAVE    EQU      SAVE_REGS+16         *\nBUILD_SAVE    EQU      SAVE_REGS+20         *\nSAVE_REG1     EQU      SAVE_REGS+24         *\n              DS      0D\nDWORD         DS       D                    * DOUBLE WORD\nDWORD1        DS       D                    * \"\nDWORD2        DS       D                    * \"\nWORK_AREA     DS       CL133                * GENERAL, CLEARED\n              DS       CL(265-133)            Used by @LOCSVC !!\nBLANKS        DS       CL256                * SET TO BLANKS\nRC            DS       F                    * RETURN CODE ON EXIT\n              DS      0F\nEDITMSK       DS       XL22                 * EDIT MASK AREA\nISPF_ACTIVE   DS       XL1                  * ISPF ACTIVE FLAG: ALL\nMVSLVL        DS       XL1                  * Mvs Level: X'21' - X'53'\n              DS      0D\nCVT_FIX       DS       F\nRMCT_ADDR     DS       F\nGM_ADDR       DS       F\nGM_ADDR80     DS       F\n              DS     0D\n              DS       CL16                * Avoid 0C4's\nSTORAGE_LEN   EQU      *-STORAGE_AREA\n TITLE 'SYSISPFE ISPF 4.1 and 4.2 Panel Exit Routine'\nSYSISPFE      AMODE 31\nSYSISPFE      RMODE ANY\nSYSISPFE      CSECT\n              BSM   R14,0                   * Save Mode\n              SAVE  (14,12)\n              LR    R12,R15                 * Base register\n              LR    R2,R1                   * Save passed Parm\n             USING  SYSISPFE,R12,R11,R10\n              B     @CSECT_BASES\n              DC    C'ISPF EXIT &SYSDATE..&SYSTIME'   * ASMH\n*HLA          DC    C'ISPF EXIT &SYSDATC..&SYSTIME'   * HLA Only\n              DS   0F\n@CSECT_BASE_REGS    EQU   *\n              DC    AL4(SYSISPFE+4096)      * Base Reg\n              DC    AL4(SYSISPFE+8192)      * Base Reg\nSTORAGE_LEN_DC DC   AL4(STORAGE_LEN)          *. > 4K\n                                                                SPACE 1\n@CSECT_BASES  DS     0H\n              L      R11,@CSECT_BASE_REGS+0\n              L      R10,@CSECT_BASE_REGS+4\n              GETMAIN RU,LV=STORAGE_LEN,LOC=RES\n              LR    R14,R1                  * Save Getmain address\n              LR    R15,R1                  * =A(Area to clear)\n              LR    R1,R0                   * L'Size-of-area\n              LA    R0,0(,R1)               * Clear high order byte\n              SRDL  R0,8                    * /256\n              SRL   R1,24                   * Isolate remainder\n              LTR   R0,R0                   * is quotient zero ?\n              BZ    @CSECT_CLFINE           *.Yep,\n@CSECT_CLEAR  XC    0(256,R15),0(R15)       * Clear 256 bytes\n              LA    R15,256(,R15)           * Point to next 256\n              BCT   R0,@CSECT_CLEAR         *.Loop until EOF\n@CSECT_CLFINE LTR   R1,R1                   * Is remainder zero ?\n              BZ    @CSECT_CLDONE           *.Yep, Save reg Pointer\n              BCTR  R1,0                    * -1\n              B     *+10\n              XC    0(*-*,R15),0(R15)\n              EX    R1,*-6                  * Clear the remainder\n@CSECT_CLDONE DS    0H\n              LR    R1,R14                  * Restore R1\n             USING  STORAGE_AREA,R1         * Address storage\n              ST    R13,STORAGE_SAVE+04     * Forward pionter\n              ST    R1,08(,R13)             * Backwards pointer\n              ST    R1,STORAGE_ADDR         * Save storage address\n              LR    R13,R1                  * Address storage\n             DROP   R1\n             USING  STORAGE_AREA,R13\n              L     R1,STORAGE_LEN_DC\n              ST    R1,STORAGE_LENGTH       * SAVE FOR DEBUG\n              XC    STORAGE_BASES(6*4),STORAGE_BASES\n              ST    R12,STORAGE_BASES+0\n              ST    R11,STORAGE_BASES+4\n              ST    R10,STORAGE_BASES+8\n              MVC   STORAGE_PGMNAME(08),=CL8'SYSISPFE'\n              MVI   BLANKS,C' '             * Set BLANKS TO C' '\n              MVC   BLANKS+01(255),BLANKS   * Propagate Blanks\n              ST    R2,SAVE_REG1            * Save =A(=A(l'Parm Parm))\n              XC    RC(4),RC                * Clear RC\n*  MVS Release level: XL01'51' = MVS/ESA 5.1\n              L     R15,CVTPTR              * CVT pointer\n              SH    R15,=Y(CVTMAP-CVTFIX)   * Prefix\n             USING  CVTFIX,R15\n              TM    CVTDCB,X'08'            * ESA?\n              BNO   @MVSXA                  .Nope, XA\n              TM    CVTOSLV0,X'08'          * ESA 4.1\n              BNO   @MVSESA3                .Nope, ESA 3.+\n              TM    CVTOSLV0,X'40'          * ESA 4.2?\n              BNO   @MVSESA41               .Nope, ESA 4.1\n              TM    CVTOSLV1,X'80'          * ESA 4.3\n              BNO   @MVSESA42               .Nope, ESA 4.2\n              TM    CVTOSLV1,X'20'          * ESA 5.1\n              BNO   @MVSESA43               .Nope, ESA 4.3\n              TM    CVTOSLV1,X'10'          * ESA 5.2\n              BNO   @MVSESA51               .Nope, ESA 5.1\n              TM    CVTOSLV2,X'80'  ??      * ESA 5.3\n              BNO   @MVSESA52               .Nope, ESA 5.2\n@MVSESA53     MVI   MVSLVL,X'53'            .Yep, ESA 5.3\n              B     @REL_DONE\n@MVSESA52     MVI   MVSLVL,X'52'\n              B     @REL_DONE\n@MVSESA51     MVI   MVSLVL,X'51'\n              B     @REL_DONE\n@MVSESA43     MVI   MVSLVL,X'43'\n              B     @REL_DONE\n@MVSESA42     MVI   MVSLVL,X'42'\n              B     @REL_DONE\n@MVSESA41     MVI   MVSLVL,X'41'\n              B     @REL_DONE\n@MVSESA3      MVI   MVSLVL,X'31'            * Set default\n              TM    CVTOSLV0,X'20'          * ESA 3.1.3?\n              BNO   *+08                    .Nope, 3.1\n              MVI   MVSLVL,X'33'            .Yep, 3.1.3\n              B     @REL_DONE\n@MVSXA        MVI   MVSLVL,X'23'\n              B     @REL_DONE\n@REL_DONE     EQU    *\n                                                                SPACE 1\n              MVC   MVS_RELEASE(8),CVTPRODN * Product Number\n              MVC   MVS_FMID(8),CVTPRODI    * Product FMID\n              MVC   MVS_SERIAL(05),=X'4020202021'\n              ED    MVS_SERIAL(05),CVTMDL   * CPU NAME\n              MVC   MVS_MODEL(04),MVS_SERIAL+1\n              XC    MVS_SERIAL,MVS_SERIAL\n              XR    R14,R14\n              L     R1,CVTPCCAT             * PCCAVT (X'2FC')\n              LA    R0,16                   * 16 CPUS\nL0001         ICM   R14,15,0(R1)            * UNIPROCESSOR\n              BNZ   CPU0001                 * MOVE CPU INFO\n              LA    R1,04(,R1)\n              BCT   R0,L0001\n              B     REL0001                 * SKIP IT\nCPU0001       MVC   MVS_SERIAL(06),6(R14)   * SAVE IT\nREL0001       EQU   *\n              L     R15,CVTSMCA             * Get SMCA\n             DROP   R15 ,                   * Done with CVTFIX\n              MVC   MVS_SYSID(04),SMCASID-SMCABASE(R15)\n                                                                SPACE 1\nSTART_UP      EQU    *\n              L      R1,CVTPTR\n              SH     R1,=Y(CVTMAP-CVTFIX)\n              ST     R1,CVT_FIX\n              L      R1,CVTOPCTP-CVTFIX(,R1)  Point to RMCT\n              ST     R1,RMCT_ADDR           *.Save\n              L      R14,4(,R13)           Get previous save area\n              LM     R15,R1,16(R14)        Capture R1\n              MVC    FULL_WORDS(32),0(R1)  Save 32 bytes of R1\n              L      R6,FULL_WORDS+28      Load record area\n             USING   SYSISPFE_RECORD,R6\n              MVC    0(SYSISPFE_RECORD_LEN,R6),BLANKS\n              MVC    REL(L'MVS_RELEASE),MVS_RELEASE\n              MVC    FMID(L'MVS_FMID),MVS_FMID\n              MVC    ID(L'MVS_SYSID),MVS_SYSID\n              MVC    CPUM+00(L'MVS_MODEL),MVS_MODEL\n              MVI    CPUM+L'MVS_MODEL,C'-'\n              MVC    CPUM+L'MVS_MODEL+1(L'MVS_SERIAL),MVS_SERIAL\n              L      R1,CVT_FIX             *.save\n              L      R3,CVTSMCA-CVTFIX(,R1) * GET SMF ADDR FROM CVT\n              ICM    R1,B'1111',SMCAIDTE-SMCABASE(R3)\n              BAS    BALREG,PROCEESS_DATE\n              MVC    IPLD(06),0(R1)\n              MVC    IPLD+06(02),8(R1)\n              ICM    R1,B'1111',SMCAITME-SMCABASE(R3)\n              BAS    BALREG,PROCESS_TIME\n              MVC    IPLT(08),0(R1)\n              MVC    CPU,BLANKS\n              L      R2,RMCT_ADDR           *.Save\n              L      R2,X'E4'(,R2)          * RCT\n              LH     R1,X'38'(,R2)          * RCT+X'38' RCVCPUA/CPUBUSY\n              SRL    R1,4                   * DIVIDE BY 16\n              MVI    CPU_HILITE,@LOW_HILITE * CPU < CPU_MIDDLE\n              C      R1,CPU_MIDDLE\n              BL     *+08\n              MVI    CPU_HILITE,@MIDDLE_HILITE * CPU > CPU_MIDDLE\n              C      R1,CPU_HIGH\n              BL     *+08\n              MVI    CPU_HILITE,@HIGH_HILITE * CPU > CPU_HIGH\n              CVD    1,DWORD\n              MVC    EDITMSK(16),@EDITM16\n              ED     EDITMSK(16),DWORD\n              MVC    CPU(3),EDITMSK+1+12\n              CLI    CPU+2,C' '\n              BNE    *+8\n              MVI    CPU+2,C'0'\n              MVI    CPU+L'CPU-1,C'%'\n              XC     INIT(4),INIT\n              XC     JOB(4),JOB\n              XC     STC(4),STC\n              XC     TSO(4),TSO\n              STM    R1,R4,FULL_WORDS\n              L      R1,CVTPTR                   * CVT\n              L      R1,CVTASVT-CVTMAP(,R1)      * ASVT\n              L      R15,ASVTMAXU-ASVT(,R1)      * Max addr spaces\n              LA     R1,ASVTFRST-ASVT(,R1)       * 1st ASCB\n              ST     R1,FULL_WORDS+24            * Save ASCB\n@TASK_LOOP    L      R1,FULL_WORDS+24            * Save ASCB\n              LA     R1,04(,R1)                  * 1st ASCB + 04\n              ST     R1,FULL_WORDS+24            * Save ASCB\n              ICM    R14,B'1111',0(R1)           * ASCB\n              BM     @TASK_NEXT_ASCB             .Nope, invalid\n              L      R2,ASCBOUCB-ASCB(,R14)      * Get OUCB\n              LA     R2,0(,R2)                   * Clear high order\n              LTR    R2,R2                       * Any ?\n              BZ     @TASK_NEXT_ASCB             .Not OUCB\n              TM     OUCBSFL-OUCB(R2),OUCBINV    * Valid OUCB ?\n              BO     @TASK_NEXT_ASCB             .Nope, Next ACB\n              L      R2,ASCBJBNI-ASCB(,R14)      * JOB ?\n              LA     R2,0(,R2)                   * Clear high order\n              LTR    R2,R2                       * Anything there?\n              BZ     @TASK_NJOB                  .Nope, Not a JOB\n              L      R1,CVTPTR                   * CVT\n              TM     CVTOSLV0-CVTMAP(R1),X'08'   * ESA 4 or above?\n              BO     @TASK4                      .Nope, don't subtract\n              SH     R2,=H'8'                    .Yep, go back\n              B      *+08\n@TASK4        L      R2,CHCSCBP-CHNAME(,R2)\n@TASK_JOB     SLR    R1,R1\n              ICM    R1,B'1111',JOB\n              LA     R1,1(,R1)\n              STCM   R1,B'1111',JOB\n              B      @TASK_NEXT_ASCB\n@TASK_NJOB    EQU    *\n              L      R2,ASCBCSCB-ASCB(,R14)      * CSCB\n              LA     R2,0(,R2)\n              LTR    R2,R2\n              BZ     @TASK_NCSCB                 * Any CSCB\n              L      R1,ASCBOUCB-ASCB(,R14)      * Reget OUCB\n              TM     OUCBYFL-OUCB(R1),OUCBSTT+OUCBMNT * STC or Mount\n              BZ     @TASK_TSO                   .Must by TSO\n              CLC    CHCLS-CHAIN(04,R2),=CL04'INIT' Init?\n              BE     @TASK_INIT                  .Yep, we have one\n              CLC    CHCLS-CHAIN(07,R2),=CL07'ASCHINT' APPC Init?\n              BE     @TASK_INIT                  .Yep, we have an APPC\n              CLC    CHCLS-CHAIN(08,R2),BLANKS\n              BE     @TASK_NEXT_ASCB\n@TASK_STC     SRL    R1,R1\n              ICM    R1,B'1111',STC\n              LA     R1,1(,R1)\n              STCM   R1,B'1111',STC\n              B      @TASK_NEXT_ASCB\n@TASK_INIT    SLR    R1,R1\n              ICM    R1,B'1111',INIT\n              LA     R1,1(,R1)\n              STCM   R1,B'1111',INIT\n              B      @TASK_NEXT_ASCB\n@TASK_TSO     EQU    *\n              L      R1,ASCBOUCB-ASCB(,R14)      * Reget OUCB\n              TM     OUCBYFL-OUCB(R1),OUCBLOG    * TSO ?\n              BNO    @TASK_NTSO\n              SLR    R1,R1\n              ICM    R1,B'1111',TSO\n              LA     R1,1(,R1)\n              STCM   R1,B'1111',TSO\n@TASK_NTSO    B      @TASK_NEXT_ASCB\n                                                                SPACE 1\n@TASK_NCSCB   EQU    *                           * TASK IS 'STARTING'\n                                                                SPACE 1\n@TASK_NEXT_ASCB BCT  R15,@TASK_LOOP\n              SLR    R1,R1\n              ICM    R1,B'1111',TSO\n              CVD    R1,DWORD\n              MVC    EDITMSK(16),@EDITM16\n              ED     EDITMSK(16),DWORD\n              MVC    TSO(4),EDITMSK+1+11\n              CLI    TSO+3,C' '\n              BNE    *+8\n              MVI    TSO+3,C'0'\n              SLR    R1,R1\n              ICM    R1,B'1111',JOB\n              CVD    R1,DWORD\n              MVC    EDITMSK(16),@EDITM16\n              ED     EDITMSK(16),DWORD\n              MVC    JOB(4),EDITMSK+1+11\n              CLI    JOB+3,C' '\n              BNE    *+8\n              MVI    JOB+3,C'0'\n              SLR    R1,R1\n              ICM    R1,B'1111',STC\n              CVD    R1,DWORD\n              MVC    EDITMSK(16),@EDITM16\n              ED     EDITMSK(16),DWORD\n              MVC    STC(4),EDITMSK+1+11\n              CLI    STC+3,C' '\n              BNE    *+8\n              MVI    STC+3,C'0'\n              SLR    R1,R1\n              ICM    R1,B'1111',INIT\n              CVD    R1,DWORD\n              MVC    EDITMSK(16),@EDITM16\n              ED     EDITMSK(16),DWORD\n              MVC    INIT(4),EDITMSK+1+11\n              CLI    INIT+3,C' '\n              BNE    *+8\n              MVI    INIT+3,C'0'\n              LM     R1,R4,FULL_WORDS\n              L      R1,CVT_FIX             *.save\n              L      R1,CVTECVT-CVTFIX(,R1) * ECVT\n              MVC    PLEX(08),ECVTSPLX-ECVT(R1) SYSPLEX NAME\n              CLI    MVSLVL,X'51'\n              BL     NO_PLEXID\n              MVI    PLEX+08,C'-'\n              MVC    PLEX+09(02),X'108'(R1) * SYSPLEX ID\nNO_PLEXID     DS     0H\n              XC     RC,RC\n              DROP    R6\n                                                                SPACE 1\n@END_PROGRAM  EQU  *\n              LR    R2,R1                   * Save possible data Addr\n              L     R3,RC                   * Save RC from PGM\n              L     R1,STORAGE_ADDR         * LOAD GETMAIN'D ADDR\n              L     R4,04(,R13)             * Reload old save area\n*                                             don't Mess wWth this one\n              FREEMAIN RU,LV=STORAGE_LEN,A=(R1)\n              XR    R15,R15                 * FORCE RC=0\n              LR    R15,R3                  * Return code saved before\n              LR    R13,R4                  * Save area recalled\n              L     R14,12(,R13)            * Reload R14\n              L     R0,20(,R13)             * Reload R0\n              LR    R1,R2                   * Reload R1 from stored R2\n              LM    R2,R12,28(R13)          * Reload R2-R12, Skip R1\n              OI    15(R13),X'01'           * SET RC\n              BSM   0,R14                   * GO BACK\n                                                                SPACE 1\n TITLE 'Subroutines'\nPROCESS_TIME  ST    BALREG,BALREG_SAVE3\n              STM   R0,R4,SAVE_AREA         * RESTORE REGS\n              LR    R1,R1\n              XR    R0,R0\n              D     R0,=F'100'              * MAKE INTO SECONDS\n              LR    R2,R1                   * SAVE SECONDS   R2\n              XR    R0,R0                   * CLEAR\n              D     R0,=F'3600'             * GET HOURS\n              LR    R3,R1                   * STORE HOURS:   R3\n              M     R0,=F'3600'             * HOURS * 3600 = MINUTES\n              SR    R2,R1                   * REMOVE HOURS\n              LR    R1,R2\n              XR    R0,R0                   * CLEAR\n              D     R0,=F'60'               * GET MINUTES\n              LR    R4,R1                   * STORE MINS:    R4\n              M     R0,=F'60'               * REMOVE MINUTES\n              SR    R2,1                    * SAVE DIFFERENCE\n              CVD   R3,DWORD\n              UNPK  WORK_AREA(2),DWORD+6(2)\n              OI    WORK_AREA+1,X'F0'\n              CVD   R4,DWORD\n              UNPK  WORK_AREA+3(2),DWORD+6(2)\n              OI    WORK_AREA+1+3,X'F0'     * OR 1/2 BYTE\n              CVD   R2,DWORD\n              UNPK  WORK_AREA+3+3(2),DWORD+6(2)\n              OI    WORK_AREA+1+3+3,X'F0'   * OR 1/2 BYTE\n              MVI   WORK_AREA+2,C':'        * ADD HH:MM:SS\n              MVI   WORK_AREA+5,C':'        * ...\n              LM    R0,R4,SAVE_AREA         * RESTORE REGS\n              LA    R1,WORK_AREA\n              L     BALREG,BALREG_SAVE3\n              BR    BALREG\n                                                                SPACE 1\nPROCEESS_DATE ST BALREG,BALREG_SAVE3\n           LR     R1,1\n           LTR    R1,R1\n           BZ     NONE_0017\n           XC     SAVE_AREA,SAVE_AREA\n           STM    R0,R4,SAVE_AREA            * Save calling REGS\n           MVC    SAVE_AREA+20(12),MONTBL    * Move month table\n           XC     DWORD,DWORD                * Clear\n           LR     R4,R1                      * Save date\n           SRL    R1,4*4                     * Kill 'DDDF'\n           SLL    R1,4*1                     * make: '000Y YYY0'\n           LTR    R1,R1\n           BZ     NONE_0017\n           ST     R1,DWORD+4                 * save it\n           OI     DWORD+7,X'0F'              * make: '000Y YYYF' packe\n           UNPK   WORK_AREA+6(4),DWORD+5(3)  * save year\n           CVB    R1,DWORD                   * make binary\n           XR     R0,R0                      * clear\n           D      R0,=F'4'                   * divide YR by 4\n           LTR    R0,R0                      * any remainder\n           BNZ    *+08                       * nope, not leap year\n           MVI    SAVE_AREA+20+01,X'1D'      *\n           LR     R2,R4                      * restore 'YYYYDDDF'\n           SLL    R2,4*4                     * kill ...\n           SRL    R2,4*4                     *          'YYYY'\n           XC     DWORD,DWORD                * clear\n           ST     R2,DWORD+4                 * store: '0000 0DDDF'\n           CVB    R2,DWORD                   * convert it\n           LA     R1,SAVE_AREA+20            * load tbl address\n           LA     R3,12                      * number of months\nDO0017     XR     R0,R0                      * clear\n           ICM    R0,B'0001',0(1)            * get month in hex\n           SR     R2,R0                      * current-next\n           LTR    R2,R2                      * are we past ?\n           BNP    DON0017                    .Yep,\n           A      R1,=F'1'                   .Nope, next tbl entry\n           BCT    R3,DO0017                  * do some more\n           LA     R15,8\n           B      D0017                      * reload'm\nDON0017    AR     R2,R0                      * add back to make posit.\n           CVD    R2,DWORD                   * make decimal\n           UNPK   WORK_AREA+3(2),DWORD+6(2)  * edit results\n           OI     WORK_AREA+4,X'F0'          * edit results\n           A      R1,=F'1'                   * move addr back 1\n           LA     R3,SAVE_AREA+20            * load tbl addr\n           SR     R1,R3                      * what month we in ?\n           CVD    R1,DWORD                   * make decimal\n           UNPK   WORK_AREA+0(2),DWORD+6(2)  * edit\n           OI     WORK_AREA+1,X'F0'          * edit &rsults\n           MVI    WORK_AREA+2,C'/'           * add 'mm/dd/yyyy'\n           MVI    WORK_AREA+5,C'/'           *\n           CLI    WORK_AREA+6,C'0'\n           BNE    *+10\n           MVC    WORK_AREA+6(2),=C'19'      * Not ESA 4 assume...\n           XR     R15,R15\nD0017      LM     R0,R4,SAVE_AREA            * RELOAD'M\n           LA     R1,WORK_AREA               * ADDR OF &RSULTS\nFINE_0017  EQU    *\nNONE_0017  LA     R15,8                      * NO DATE OR INVALID\nPAST0017   EQU    *\n           LA     R1,WORK_AREA\n           L      BALREG,BALREG_SAVE3\n           BR     BALREG\n           DROP   ,\n                                                                SPACE 1\n TITLE 'DATA SECTION'\n              DS    0F\n              DC     CL16'   CPU HIGH PER:'  * Keep @ CL16\nCPU_MIDDLE    DC     AL04(CPU_MIDDLE_VALUE)\nCPU_HIGH      DC     AL04(CPU_HIGH_VALUE)\nMONTBL        DC     XL12'1F1C1F1E1F1E1F1F1E1F1E1F'  = 3F\nZERO          DC     F'0'\nONE           DC     F'1'\nTWO           DC     F'2'\nTHREE         DC     F'3'\nFOUR          DC     F'4'\n@EDITM16      DC     XL16'40202020202020202020202020202021'\nBALREG        EQU    14\nNO            EQU    X'0F'\nYES           EQU    X'F0'\n              LTORG\nSYSISPFE_PGM_LENGTH  EQU   *\n TITLE 'DSECTS'\n                YREGS\n                IHAASCB\n                IHAASVT\n                CVT      DSECT=YES,LIST=NO,PREFIX=YES\n                IHAECVT  DSECT=YES,LIST=NO\n                IEECHAIN\n                IRAOUCB\n                IEESMCA\n               END\n/*\n//L.SYSLMOD DD DSN=YOUR.LIBRARY(SYSISPFE),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LSPACE": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x934\\x1f\\x00\\x96 \\x7f\\x11A\\x01\\xe3\\x01\\xd4\\x00\\x00\\xe2\\xe8\\xe2\\xd4\\xe5\\xc8@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1993-12-07T00:00:00", "modifydate": "1996-07-25T11:41:00", "lines": 483, "newlines": 468, "modlines": 0, "user": "SYSMVH"}, "text": "//ASSEM   EXEC  ASMHCL,\n//        PARM.C='OBJECT,XREF(SHORT),TERM,SYSPARM(ESA)'  OR '(XA)'\n//C.SYSLIB  DD  DSN=SYS1.MACLIB,DISP=SHR,DCB=BLKSIZE=32000\n//          DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSIN     DD   *\n COPY $DOC\n TITLE '>>> LSPACE: OBTAIN SYSRES DEVICE CHARATERISTICS AND FREE SPACE +\n               &SYSDATE._&SYSTIME <<<'\n*---------------------------------------------------------------------*\n*                                                                     *\n* MODULE NAME   LSPACE                                                *\n*                                                                     *\n* CSECT  NAME   LSPACE                                                *\n*                                                                     *\n* DESCRIPTIVE NAME   LSPACE SVC ROUTINE EXPLORED                      *\n*                                                                     *\n* FUNCTION                                                            *\n*                                                                     *\n*  THIS ROUTINE IS AN EXAMPLE OF HOW TO IMPLEMENT THE NEWLY SUPPORTED *\n*  LSPACE SVC. IT PERFORMS THE FOLLOWING FUNCTIONS:                   *\n*                                                                     *\n*   1). OBTAINS UNITNAME, VOLSER, AND FREE SPACE INFORMATION FROM     *\n*       THE SYSRES UNIT ADDRESS.                                      *\n*                                                                     *\n*   2). CONDITIONALLY PRESENTS THE RESULTS TO THE TERMINAL OR         *\n*       TO DDNAME SYSPRINT                                            *\n*                                                                     *\n* OPERATION   LSPACE  PERFORMS THE FOLLOWING FUNCTION:                *\n*                                                                     *\n*    0   IDENTIFIES OPERATING ENVIRONMENT VIA 'SYSPARM' OF ASSEMBLER. *\n*        EITHER 'SYSPARM(XA)' OR 'SYSPARM(ESA)' FOR CONDITIONAL       *\n*        ASSEMBLY.                                                    *\n*                                                                     *\n*          'SYSPARM(XA)' USES THE STANDARD 'SAVE' AND 'RETURN'*       *\n*           MACROS AND THE GETMAIN/FREEMAIN SVC'S.                    *\n*                                                                     *\n*          'SYSPARM(ESA)' USES THE THE BAKR/PR ESA STACK AND THE      *\n*           STORAGE MACRO FOR OBTAINING A SAVE AREA.                  *\n*                                                                     *\n*    1   SETUP BASE REG (R12)                                         *\n*    2   OBATINS STORAGE FOR SAVE AREA VIA (GETMAIN/STORAGE)          *\n*    3   LOCATES CVT AND DETERMINES IF USER IS IN FOREGROUND: SETS FLG*\n*    5   OBTAINS SYSRES UCB FROM CVTSYSAD                             *\n*    6   ISSUES LSPACE MACRO (SVC 78)                                 *\n*    7   TESTS RETURN CODE FROM LSPACE                                *\n*    8   PRESENTS RESULTS TO TERMINAL/FILE, IF GOOD RETURN CODE       *\n*    9   DOES A FREEMAIN/(STORAGE RELEASE) OF STORAGE: SAVE AREA      *\n*   10   LOADS REGISTER 14 WITH RETURN ADDRESS                        *\n*   11   SETS THE RETURN CODE IN REGISTER 15                          *\n*   12   LOADS REGISTERS R0   R12 WITH CALLER'S ENTRY CONTENTS        *\n*   13   RETURNS TO CALLER                                            *\n*                                                                     *\n* RECOVERY OPERATION                                                  *\n*                                                                     *\n*          NONE.                                                      *\n*                                                                     *\n* NOTES                                                               *\n*                                                                     *\n*                                                                     *\n* DEPENDENCIES   MVS/XA AND DFP/XA 2.2 AND ABOVE,                     *\n*                ASSEMBLER H V2 AND ABOVE                             *\n*                                                                     *\n*                                                                     *\n EJECT\n*                                                                     *\n* RESTRICTIONS   NONE.                                                *\n*                                                                     *\n* ERROR MESSAGES   NONE                                               *\n*                                                                     *\n* ABEND CODES   NONE                                                  *\n*                                                                     *\n* ERROR CONDITIONS   NONE                                             *\n*                                                                     *\n* LINKAGES: NONE.                                                     *\n*                                                                     *\n* MODULE(S) CALLED: NONE                                              *\n*                                                                     *\n* ENTRY POINT   LSPACE                                                *\n*                                                                     *\n* EXIT CONDITIONS                                                     *\n*                                                                     *\n*        NONE.                                                        *\n*                                                                     *\n* REFERENCES                                                          *\n*                                                                     *\n*        ROUTINES     NONE                                            *\n*                                                                     *\n*        DATA AREAS   NONE                                            *\n*                                                                     *\n*            MACROS   CVT, IEFUCBOB, OPEN, CLOSE, PUT, TPUT,          *\n*                     LSPACE, SAVE, RETURN, TIME             (IBM)    *\n*                     MODE                                  (LOCAL)   *\n*                                                                     *\n*            DSECTS   CVT, UCB, LSPACE                                *\n*                                                                     *\n*        TABLES       NONE                                            *\n*                                                                     *\n* GLOBALS:                                                            *\n*                                                                     *\n*       PASSED VIA 'SYSPARM' IN ASSEMBLER FOR MVS/SP V3, 'ESA', OR    *\n*       FOR MVS/SP V2, 'XA'                                           *\n*                                                                     *\n*                                                                     *\n* MODULE ATTRIBUTES                                                   *\n*                     AMODE(31)                                       *\n*                     RMODE(24),                                      *\n*                     UNAUTHORIZED                                    *\n*                                                                     *\n* INPUT   NONE.                                                       *\n* OUTPUT   TPUT, IF TSO                                               *\n*          SYSPRINT FILE, VIA QSAM PUTS, IF BATCH                     *\n*                                                                     *\n* CHANGE ACTIVITY:  NONE.                                             *\n*                                                                     *\n*                                                                     *\n              EJECT\n              MACRO\n&NAME         MODE &TYPE,&REG=14\n.*                                                                    *\n.* FUNCTION: MACRO TO SWITCH MODES: EITHER AMODE 24 OR AMODE 31       *\n.*     VARS: TYPE      EITHER 'ABOVE' OR 'BELOW', OR '24' OR '31'     *\n.*     REGS: R14                                                      *\n.*                                                                    *\n&NAME         CNOP  2,4                     * FORCE FULL WORD ALIGNMENT\n              AIF   ('&TYPE' EQ 'BELOW').BELOW\n              AIF   ('&TYPE' EQ 'ABOVE').ABOVE\n              AIF   ('&TYPE' EQ '24').BELOW\n              AIF   ('&TYPE' EQ '31').ABOVE\n              MNOTE 08,'INVALID TYPE SPECIFIED: &TYPE.'\n              MNOTE 08,'... EITHER ABOVE OR BELOW'\n              AGO   .MEND\n.BELOW        LA    &REG,*+6                * POINT TO AMODE = 24 CODE\n              BSM   0,&REG                  * BRANCH TO AMODE = 24 CODE\n              AGO   .MEND\n.ABOVE        LA    &REG,*+14               * POINT TO AMODE = 31 CODE\n              O     &REG,*+6                * TURN ON AMODE = 31 BIT\n              BSM   0,&REG                  * BRANCH TO AMODE = 31 CODE\n              DC    X'80000000'             * AMODE = 31 BIT\n.MEND         MEND\n              PRINT    NOGEN\n TITLE '>>> CVT      <<<'\n              CVT      PREFIX=NO,LIST=NO,DSECT=YES\n TITLE '>>> UCB      <<<'\n              IEFUCBOB PREFIX=YES,LIST=NO,DEVCLAS=DA\n TITLE '>>> PSA      <<<'\n              IHAPSA\n TITLE '>>> ASCB     <<<'\n              IHAASCB\n              PRINT    GEN\n TITLE '>>> LSPACE CALL AND RETURN DATA DSECTS <<<'\nLSPACE_DATA_DSECT  LSPACE   MF=(D,DATA)\n              SPACE\nLSPACE_CALL_DSECT  LSPACE   MF=D\n              SPACE\n TITLE '>>> LSPACE: OBTAIN SYSRES DEVICE CHARATERISTICS AND FREE SPACE +\n               &SYSDATE._&SYSTIME <<<'\nLSPACE        AMODE    31                   * ADDRESS EVERY THING\nLSPACE        RMODE    24                   * ALLOW FOR TPUTS/PUTS\nLSPACE        CSECT\n              AIF      ('&SYSPARM' NE 'ESA').NESA1     SYSPARM(ESA) ??\n              BAKR     R14,0                * LOAD ESA STAX\n.NESA1        LR       R12,R15              * SETUP BASE\n             USING     LSPACE,R12\n              BSM      R14,0                * SAVE MODE\n              AIF      ('&SYSPARM' EQ 'ESA').ESA1      SYSPARM(ESA) ??\n              SAVE     (14,12),,,'LSPACE_&SYSDATE._&SYSTIME'\nGET_STOR      GETMAIN  RU,LV=STOR_LEN,LOC=RES\n              ST       R1,STORADDR          * SAVE FOR LATER\n              XC       0(STOR_LEN,R1),0(R1) * CLEAR STORAGE\n              ST       R13,4(,R1)           * SAVE FORWARD\n              ST       R1,8(,R1)            * BACKWARDS\n              LR       R13,R1               * POINT TO 18F WORDS\n              AGO      .START               .* SKIP ESA STUFF\n.ESA1         ANOP\n              B        GET_STOR             * SKIP OVER CONSTANTS\n              DC       C'LSPACE_&SYSDATE._&SYSTIME'\nGET_STOR      STORAGE  OBTAIN,              * GET STOR FOR SAVE AREA   +\n               LENGTH=STOR_LEN,LOC=RES\n              ST       R1,STORADDR          * SAVE FOR LATER\n              LR       R13,R1               * POINT R13 TO SAVE AREA   +\n                                              EVEN THOUGH WE DON'T USE +\n                                              IT SOMEONE ELSE MIGHT.\n              XC       0(STOR_LEN,R13),0(R13) CLEAR STORAGE\n              ST       R13,4(,R1)           * SAVE FORWARD\n              ST       R1,8(,R1)            * BACKWARDS\n              LR       R13,R1               * POINT TO 18F WORDS\n              MVC      4(4,R1),=C'F1SA'     * REQUIREMENT\n.START        ANOP\n              EJECT\n              MVC      UCB_RECORD,BLANKS    * CLEAR OUTPUT RECORD\n              SPACE\n** LET'S GET TO DAYS DATE DEPENDING ON MVS RELEASE\n              L        R1,CVTPTR            * GET CVT POINTER\n              AIF      ('&SYSPARM' NE 'ESA').NESA1A\n              TM       CVTDCB-CVT(R1),X'08' * CVTOSLVL?\n              BNO      NOT_ESA4             * WE ARN'T ESA ANY VERSION\n              TM       CVTOSLVL-CVT(R1),X'08' .ESA V4.1 OR ABOVE ?\n              BNO      NOT_ESA4             * NOPE\n              TIME     DEC,TIME_DATE,                                  +\n               ZONE=LT,DATETYPE=MMDDYYYY,LINKAGE=SYSTEM\n              MVC      WORK(30),BLANKS\n              MVC      WORK(11),=XL11'4021206120206120202020'\n              ED       WORK(11),TIME_DATE+8\n              CLI      WORK+01,C' '\n              BNE      *+08\n              MVI      WORK+01,C'0'\n              MVC      WORK+12(08),=XL08'21207A20207A2020'\n              ED       WORK+11(09),TIME_DATE+00\n              MVC      WORK+30(10+9),WORK+1\n              MVC      WORK(20),WORK+30\n              MVC      TIME_DATE(20),WORK\n              B        PAST_TIME\nNOT_ESA4      DS       0H\n.NESA1A       ANOP\n              TIME     DEC\n              STM      R0,R1,DWORD\n              MVC      WORK(07),=XL07'4021204B202020'\n              ED       WORK(07),DWORD+05\n              MVC      TIME_DATE(6),WORK+01\n              MVC      WORK(09),=XL9'4021207A20207A2020'\n              ED       WORK(09),DWORD+00\n              MVC      TIME_DATE+7(8),WORK+01\nPAST_TIME     DS       0H\n              L        R1,CVTPTR            * GET CVT POINTER\n              SPACE\n*                                                                     *\n*  DISCOVER WETHER WE ARE A FOREGROUND TASK OR BATCH JOB              *\n*                                                                     *\n              L        R15,CVTTCBP-CVT(,R1) * CVTTCBP, =A(NEXT_TCB)\n              XC       DWORD,DWORD          * CLEAR\n              ST       R15,DWORD            * SAVE IT\n              LM       R14,R15,DWORD        *  NEXT+CUR. TCB\n              L        R15,PSAAOLD-PSA(,R15) * ASCB OLD POINTER.\n              L        R15,ASCBTSB-ASCB(,R15)  ADDR OF TSB\n              LTR      R15,R15              * IS IT ZERO\n              BZ       *+8                  * YEP,  WE ARE BATCH\n              MVI      TSO_FLAG,YES         * NOPE, WE ARE TSO\n              SPACE\n*                                                                     *\n*  OBTAIN SYSRES UCB ADDRESS FROM CVT SPECIFIED IN REG1               *\n*                                                                     *\n              L        R1,CVTPTR            * GET CVT POINTER\n              L        R2,CVTSYSAD-CVT(,R1) * GET SYSRES UCB\n              ST       R2,UCB_ADDR          * SAVE UCB ADDRESS\n              LA       R1,UCBPRFX           * LENGTH OF UCB PREFIX\n              SR       R2,R1                * ADDRESS IT\n              MVC      UNITNAME(L'UCBNAME),UCBNAME-UCB(R2) * UNIT NAME\n              MVC      VOLSER(L'UCBVOLI),UCBVOLI-UCB(R2)   * VOLSER\n              SPACE\n*                                                                     *\n*  SETUP FOR CALL TO LSPACE: SVC 78                                   *\n*                                                                     *\n              LSPACE UCB=UCB_ADDR,          * UCB ADDRESS              +\n               DATA=LSPACE_DATA,            * RESULTS                  +\n               F4DSCB=FORMAT4_DSCB,         * AREA FOR FORMAT4 DSCB    +\n               MF=(E,LSPACE_CALL)           * USE EXEC FORM,\n              SPACE\n              LTR      R15,R15              * GOOD RC ?\n              BNZ      ERROR_LSPACE         * NOPE, PROCESS RESULTS\n              EJECT\n*                                                                     *\n*  PROCESS GOOD LSPACE CALL                                           *\n*                                                                     *\nGOOD_LSPACE   DS       0H\n              LA       R9,LSPACE_DATA       * ADDRESS OUTPUT AREA\n             USING     LSPACE_DATA_DSECT,R9 * USE SUPPLIED NAMES\n              TM       LSPDSTAT,LSPDIXDS    * CHECK FOR INDEX\n              BNO      *+10                 * NOPE, SKIP BELOW\n              MVC      INDEX_VTOC(12),=CL12'INDEXED'\n              TM       LSPDSTAT,LSPDIXDS+LSPDIXAC (INDEX AND ACTIVE)\n              BNO      *+10                 * NOPE, SKIP\n              MVC      INDEX_VTOC(12),=CL12'INDEX ACTIVE'\n              L        R1,LSPDNEXT          * EXTENTS\n              BAS      BALREG,CONVERT\n              MVC      EXTENTS(4),4(R1)\n              L        R1,LSPDTCYL          * TOTAL CYLS\n              BAS      BALREG,CONVERT\n              MVC      TOTAL_CYLS(4),4(R1)\n              L        R1,LSPDTTRK          * TOTAL TRACKS\n              BAS      BALREG,CONVERT\n              MVC      TOTAL_TRKS(4),4(R1)\n              L        R1,LSPDLCYL          * CONTIG CYLS\n              BAS      BALREG,CONVERT\n              MVC      CONTG_CYLS(4),4(R1)\n              L        R1,LSPDLTRK          * AVAIL TRACKS\n              BAS      BALREG,CONVERT\n              MVC      AVAIL_TRKS(4),4(R1)\n              L        R1,LSPDF0S           * FREE FROMAT0 DSCBS\n              BAS      BALREG,CONVERT\n              MVC      AVAIL_FMT0(4),4(R1)\n              L        R1,LSPDVIRS          * AVAIL VIRS\n              BAS      BALREG,CONVERT\n              MVC      AVAIL_VIRS(4),4(R1)\n              L        R1,LSPDFRAG          * FRAGMENTATION INDEX\n              BAS      BALREG,CONVERT\n              MVC      FRAG_INDEX(6),2(R1)\n              SPACE\n* WRITE RESULTS TO TERMINAL OR TO FILE SYSPRINT, BASED ON WHO WE ARE ..\n              CLI      TSO_FLAG,YES\n              BNE      BATCH_OK\nTSO_OK        DS       0H\n              MODE     BELOW                * AMODE(24)\n              TPUT     TIME_DATE,L'TIME_DATE\n              TPUT     UCB_TITLES,L'UCB_TITLES\n              TPUT     UCB_RECORD,L'UCB_RECORD\n              MODE     ABOVE                * AMODE(31)\n              B        FINE\nBATCH_OK      DS       0H\n              OPEN     (SYSPRINT,OUTPUT),MODE=31\n              MODE     BELOW                * AMODE(24)\n              PUT      SYSPRINT,BLANKS+255+L'TIME_DATE-LRECL\n              PUT      SYSPRINT,UCB_TITLES\n              PUT      SYSPRINT,UCB_RECORD\n              MODE     ABOVE                * AMODE(31)\n              CLOSE    (SYSPRINT),MODE=31\n             DROP      R9\n              B        FINE\n              SPACE\nFINE          DS       0H                   *\n              AIF      ('&SYSPARM' EQ 'ESA').ESA#3\n              L        R2,STORADDR          * STORAGE ADDRESS\n              L        R13,4(,R2)           * RELOAD FORWARD\n              FREEMAIN RU,LV=STOR_LEN,A=(R2)\n              RETURN   (14,12),T,RC=(15)    * RESTORE REGS\n              SPACE\n              AGO      .DONE\n.ESA#3        L        R2,STORADDR          * ALL THROUGH WITH STORAGE\n              STORAGE  RELEASE,                                        +\n               LENGTH=STOR_LEN,ADDR=(R2)\n              PR       ,                    * RELOAD ESA STAX\n              AGO      .DONE\n              SPACE\n.DONE         ANOP\n              EJECT\n*                                                                     *\n* LSPACE RC > 00, PROCESSING RETURN CODES AND WRITE RESULTS           *\n*                                                                     *\n              SPACE\nERROR_LSPACE  DS       0H\n              LA       R9,LSPACE_CALL\n             USING     LSPACE_CALL_DSECT,R9\n              XR       R1,R1\n              ICM      R1,B'0001',LSPAERCD  * RETURN CODE\n              BAS      BALREG,CONVERT\n              MVC      RETURN_CODE(2),6(R1)\n              ICM      R1,B'0001',LSPASFID  * SUB FUNCTION ID REQUESTED\n              BAS      BALREG,CONVERT\n              MVC      SUBFUNCT_ID(2),6(R1)\n              ICM      R1,B'0001',LSPASFRT  * SUB FUNCTION RC\n              BAS      BALREG,CONVERT\n              MVC      SUBFUNCT_RC(2),6(R1)\n              ICM      R1,B'0001',LSPASFRS  * SUB FUNCTION REASON CODE\n              BAS      BALREG,CONVERT\n              MVC      SUBFUNCT_REASON(2),6(R1)\n              SPACE\n* WRITE RESULTS TO TERMINAL OR TO FILE SYSPRINT\n              CLI      TSO_FLAG,YES\n              BNE      BATCH_ERROR\nTSO_ERROR     DS       0H\n              MODE     BELOW\n              TPUT     TIME_DATE,L'TIME_DATE\n              TPUT     UCB_TITLES,L'UCB_TITLES\n              TPUT     UCB_RECORD,L'UCB_RECORD\n              TPUT     LSPACE_ERROR_MSG,L'LSPACE_ERROR_MSG\n              MODE     ABOVE\n              B        FINE\nBATCH_ERROR   DS       0H\n              OPEN     (SYSPRINT,OUTPUT),MODE=31\n              MODE     BELOW\n              PUT      SYSPRINT,BLANKS+255+L'TIME_DATE-LRECL\n              PUT      SYSPRINT,UCB_TITLES\n              PUT      SYSPRINT,UCB_RECORD\n              PUT      SYSPRINT,LSPACE_ERROR_MSG\n              MODE     ABOVE\n              CLOSE    (SYSPRINT),MODE=31\n* PROCESS BASED ON ABOVE RESULTS HERE ....\n             DROP      R9\n              B        FINE\n              EJECT\n*                                                                     *\n* CONVERT HEX TO EBCDIC, SUBROUTINE                                   *\n*                                                                     *\n              SPACE\nCONVERT       CVD      R1,DWORD             * CONVERT HEX TO DEC\n              MVC      WORK(16),=XL16'40202020202020202020202020202021'\n              ED       WORK(16),DWORD\n              CLI      WORK+15,C' '\n              BNE      *+8\n              MVI      WORK+15,C'0'\n              LA       R1,WORK+08\n              BR       BALREG               * RETURN\n TITLE '>>> LSPACE: DATA AREAS AND EQUATES   &SYSDATE._&SYSTIME <<<'\nSTOR_LEN      EQU      18*4                 * 18 FULL WORDS\n              SPACE\nBALREG        EQU      10                   * BAL REG\n              SPACE\nLRECL         EQU      80                   * LRECL FOR TPUT/SYSPRINT\n              SPACE\nYES           EQU      X'FF'                *\nNO            EQU      X'00'                *\n              SPACE\n              YREGS                         * IBM EQUATES\n              EJECT\nTSO_FLAG      DC       XL1'00'\n              DS      0D\nDWORD         DS       D                    * DOUBLE WORD WORK AREA\nRC            DS       F                    * FUNCTION RETURN CODES\nSTORADDR      DS       F                    * GETMAIN/STORAGE ADDR\nBLANKS        DC       CL255' '             * USED TO CLEAR STUFF\nTIME_DATE     DC       CL20' '\nWORK          DC       CL100' '             * USE PART OF ABOVE AREA\nUCB_ADDR      DS       F                    * SYSRES UCB ADDRESS\n              SPACE\nUCB_TITLES    DC       CL(LRECL)' '         * TITLE LINE\n              ORG      UCB_TITLES+00\n              DC       CL(L'UCBNAME+2)'UNIT'\n              DC       CL(L'UCBVOLI+2)'VOLSER'\n              DC       CL6'TCYL'\n              DC       CL6'TTRK'\n              DC       CL6' EXT'\n              DC       CL6'CCYL'\n              DC       CL6'CTRK'\n              DC       CL6'FMT0'\n              DC       CL6'VIRS'\n              DC       CL7'FRAG-I'\n              DC       CL13'VTOC-INDX'\n              ORG      ,\n              DS      0F\nUCB_RECORD    DS       CL(LRECL)            * TARGET FIELDS\n              ORG      UCB_RECORD+00\nUNITNAME      DS       CL(L'UCBNAME),CL2\nVOLSER        DS       CL(L'UCBVOLI),CL2\nTOTAL_CYLS    DS       CL4,CL2\nTOTAL_TRKS    DS       CL4,CL2\nEXTENTS       DS       CL4,CL2\nCONTG_CYLS    DS       CL4,CL2\nAVAIL_TRKS    DS       CL4,CL2\nAVAIL_FMT0    DS       CL4,CL2\nAVAIL_VIRS    DS       CL4,CL2\nFRAG_INDEX    DS       CL6,CL2\nINDEX_VTOC    DS       CL12\n              ORG      ,\nLSPACE_ERROR_MSG   DC  CL(LRECL)' '\n              ORG      LSPACE_ERROR_MSG+00\n              DC       CL12'RETURN CODE='\nRETURN_CODE   DC       CL03' '\n              DC       CL13'SUBFUNCTION: '\n              DC       CL03'ID='\nSUBFUNCT_ID   DC       CL03' '\n              DC       CL03'RC='\nSUBFUNCT_RC   DC       CL03' '\n              DC       CL07'REASON='\nSUBFUNCT_REASON DC     CL03' '\n              ORG      ,\n              PRINT    NOGEN\nSYSPRINT      DCB      DDNAME=SYSPRINT,LRECL=LRECL,BLKSIZE=(LRECL*10), +\n               RECFM=FB,DSORG=PS,MACRF=PM\n              PRINT    GEN\n TITLE '>>> LSPACE CALL AND RETURN DATA AREAS <<<'\nLSPACE_CALL   LSPACE   MF=L\n              SPACE    2\nLSPACE_DATA   LSPACE   MF=(L,DATA)\n              SPACE\n TITLE '>>> FORMAT 4 DSCB <<<'\nFORMAT4_DSCB  DS      0F\n              IECSDSL1 (4)\n              LTORG\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Sys/Stat for MVS is an integrated ISPF MVS search and display    *\n*    facility that uses the latest technology to improve systems      *\n*    programmers productvity.  Please call for a no obligation        *\n*    evaluation.                                                      *\n*                                                                     *\n*    Advent Software                                                  *\n*    340 West Butterfield Road                                        *\n*    Suite 4B                                                         *\n*    Elmhurst, IL 60126                                               *\n*    (708) 279-5449                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n              END\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PACKOFF": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x96\\x14/\\x00\\x96 \\x7f\\x11B\\x01\\x9a\\x01\\x8c\\x00\\x00\\xe2\\xe8\\xe2\\xd4\\xe5\\xc8@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1996-05-21T00:00:00", "modifydate": "1996-07-25T11:42:00", "lines": 410, "newlines": 396, "modlines": 0, "user": "SYSMVH"}, "text": "//ASMHCL  PROC RENT=NORENT,AC=\n//C       EXEC PGM=ASMA90,REGION=4M,\n//       PARM=('TERM','OBJECT','NODECK','XREF(SHORT)','&RENT',\n//       'LINECOUNT(9999)')\n//STEPLIB  DD  DSN=HLA.SASMMOD1,DISP=SHR\n//         DD  DSN=HLA.SASMMOD2,DISP=SHR\n//SYSTERM  DD  SYSOUT=(,)\n//SYSPRINT DD  SYSOUT=(,)\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD  DSN=&&SYSUT1,UNIT=SYSALLDA,SPACE=(CYL,(3,5))\n//SYSIN    DD  DSN=NULLFILE,DISP=SHR\n//SYSLIN   DD  DSN=&&OBJ,DISP=(,PASS),UNIT=SYSALLDA,SPACE=(CYL,(1,1)),\n//         DCB=BLKSIZE=800\n//*\n//L       EXEC PGM=HEWLH096,REGION=1M,COND=(6,LT,C),\n//        PARM='XREF,LET,LIST,NCAL,&RENT.&AC'\n//SYSPRINT DD  SYSOUT=(,)\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DISP=(,PASS),UNIT=SYSALLDA,SPACE=(CYL,(1,,45)),\n//         DSN=&&GO(GO)\n// PEND\n// EXEC ASMHCL\n//C.SYSIN  DD   *\n TITLE 'ISPFUNPK - Unpack ISPF Packed Data'\n*=====================================================================*\n* Module Name: ISPFUNPK                                               *\n*                                                                     *\n*         VRM: 1.1.0                                                  *\n*                                                                     *\n* Operating Environment:  MVS/ESA                                     *\n*                                                                     *\n*  Request Function(s)/Purpose :                                      *\n*                                                                     *\n*            This routine processes ISPF packed data set (SYSIN) and  *\n*            unpacks the results into a file (SYSPUNCH).              *\n*                                                                     *\n*                                                                     *\n*  Register Usage:                                                    *\n*             R0......                                                *\n*             R1......                                                *\n*             R2......                                                *\n*             R3......                                                *\n*             R4......                                                *\n*             R5......                                                *\n*             R6......                                                *\n*             R7......                                                *\n*             R8......                                                *\n*             R9......                                                *\n*             R10.....                                                *\n*             R11.....                                                *\n*             R12.....Base                                            *\n*             R13.....Storage base                                    *\n*             R14.....                                                *\n*             R15.....                                                *\n*       Note: All registers are saved at entry                        *\n*                                                                     *\n*  Macros:  CLOSE                                                     *\n*           OPEN                                                      *\n*           STORAGE                                                   *\n*           YREGS                                                     *\n*           WTO                                                       *\n*           @24                                                       *\n*           @31                                                       *\n*                                                                     *\n*  DSECTS:  DCBD                                                      *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*  Operating Attributes                                               *\n*    AMODE: 31                                                        *\n*    RMODE: 24                                                        *\n*       AC: none                                                      *\n*     RENT: NORENT                                                    *\n*     REUS: NOREUS                                                    *\n*                                                                     *\n*  Pseudo Code                                                        *\n*   - Open SYSIN file                                                 *\n*   - Obtain SYSIN DCB LRECL and BLKSIZE                              *\n*   - - Copy DCB Attributes to SYSPUNCH                               *\n*   - Open SYSPUNCH FIle                                              *\n*   - Loop:  Read  SYSIN                                              *\n*            Call  PACKOFF                                            *\n*            Write to SYSPUNCH                                        *\n*            Branch to LOOP until EOF(SYSIN)                          *\n*   - EOF-SYSIN                                                       *\n*     - Close Files                                                   *\n*   - Return                                                          *\n*                                                                     *\n*  Example                                                            *\n*  // EXEC PGM=ISPFUNPK                                               *\n*  //SYSIN    DD DISP=SHR,DSN=file.name,DCB=RECFM=U                   *\n*  //SYSPUNCH DD SYSOUT(,)                                            *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n* -----------------------  Change  Section  ------------------------- *\n* 05/17/96 - All new                                             MVH  *\n*                                                                     *\n*=====================================================================*\n              MACRO\n&NAME         @24   &REG=14\n&NAME         LA    &REG,*+06\n              BSM   0,&REG\n              MEND\n              MACRO\n&NAME         @31   &REG=14\n&NAME         CNOP  2,4\n              LA    &REG,*+14\n              O     &REG,*+06\n              BSM   0,&REG\n              DC    X'80000000'\n              MEND\nISPFUNPK      AMODE 31\nISPFUNPK      RMODE 24\nISPFUNPK      CSECT\n              BAKR  R14,0                   Save stack\n              LR    R12,R15                 Callers addr\n              USING ISPFUNPK,R12            Addr pgm\n              B     COPYWRITE\n              DC    C'ISPFUNPK V1.1.0 &SYSDATE._&SYSTIME'\n              DS    0F\nCOPYWRITE     EQU   *\n              STORAGE  OBTAIN,              Get storage for save area  +\n               LENGTH=STORAGE_LEN,LOC=BELOW (Below for DCB's)\n              LR    R13,R1                  Point R13 to save area     +\n                                            even though we don't use   +\n                                            it someone might!\n              XC    000(255,R13),000(R13)   clear\n              XC    255(STORAGE_LEN-255,R13),255(R13)  clear\n              ST    R13,04(,R1)             Save forward\n              ST    R1,08(,R1)              Backwards\n              LR    R13,R1                  Point to 18F words\n              MVC   04(04,R1),=CL04'F1SA'   Storage macro\n             USING  STORAGE,R13             Talk to our storage area\n*  Copy DCB Models\n              MVC   SYSIN(SYSINML),SYSINM\n              MVC   SYSPUNCH(SYSPUNCHML),SYSPUNCHM\n              MVC   OPEN(OPENMDLL),OPENMDL\n              MVC   CLOSE(CLOSEMDLL),CLOSEMDL\n*  Open Sysin FIle and obtain DCB attributes\n              LA    R2,SYSIN\n              LA    R1,OPEN\n             USING  IHADCB,R2\n              OPEN  ((R2),),MF=(E,(R1)),MODE=31\n              LA    R1,SYSPUNCH             Syspunch DDName\n              MVC   LRECL(02),DCBLRECL\n              MVC   DCBLRECL-IHADCB(02,R1),DCBLRECL\n              MVC   BLKSIZE(02),DCBBLKSI\n              MVC   DCBBLKSI-IHADCB(02,R1),DCBBLKSI\n             DROP   R2\n*  Open Syspunch\n              LA    R2,SYSPUNCH\n              LA    R1,OPEN\n              OPEN  ((R2),OUTPUT),MF=(E,(R1)),MODE=31\n*  Read a 1st record from sysin\n              BAS   R14,READ_SYSIN\n              MVI   TENWORDS+00,00          reset pack/unpk flag\n              MVI   TENWORDS+01,C'F'        RECFM=F\n              B     FIRST_BLK               Process 1st block\n\nLOOP          BAS   R14,READ_SYSIN\nFIRST_BLK     MVC   TENWORDS+02(02),SYSIN+82  Pass blk length\n\nUNPACK_REC    LA    R0,TENWORDS             UnPack work area\n              L     R15,=A(PACKOFF)         UnPack routine\n              BASR  R14,R15             <== Invoke \"packoff\" routine\n              LTR   R15,R15                 Do I need another record?\n              BNZ   LOOP                    Yes, get one\n              LR    R3,R1                   Pass addr of unpk'd record\n              LA    R2,SYSPUNCH             DCB\n              @24\n              PUT   (2),(3)                 Print it\n              @31\n              B     UNPACK_REC\n\n*  Close our DCB's and go away\nEOF_SYSIN     DS    0H\n              @31   ,                       Back to A31  (a must)\n              LA    R1,CLOSE                Close model\n              LA    R2,SYSIN                SYSIN DCB\n              LA    R3,SYSPUNCH             SYSPUNCH DCB\n              CLOSE ((2),,(3)),MF=(E,(R1)),MODE=31\n              STORAGE  RELEASE,             Release                   ++\n               LENGTH=STORAGE_LEN,ADDR=(R13)\n              PR     ,                      Reload stack\n TITLE '>>> Subroutines <<<'\nREAD_SYSIN    ST    R14,R14_SAVE\n              LA    R1,SYSIN\n              @24\n              GET   (1)\n              @31\n              L     R14,R14_SAVE\n              BR    R14\n TITLE '>>> Data Area <<<'\nPATCH         DC    50CL02'AB'              Patch area\n                                                           PRINT NOGEN\nSYSINM        DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,RECFM=U,           ++\n               EODAD=EOF_SYSIN\nSYSINML       EQU   *-SYSINM\nSYSPUNCHM     DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPUNCH,RECFM=FB,       ++\n               LRECL=0,BLKSIZE=0\n                                                          PRINT ON,GEN\nSYSPUNCHML    EQU   *-SYSPUNCHM\nOPENMDL       OPEN  (,),MODE=31,MF=L\nOPENMDLL      EQU   *-OPENMDL\nCLOSEMDL      OPEN  (,),MODE=31,MF=L\nCLOSEMDLL     EQU   *-CLOSEMDL\nWTOM            WTO      '123456789012345678901234567890123456789012345X\n               67890123456789012345678901234567890',                   X\n               ROUTCDE=(11),DESC=(06),MF=L\nWTOML           EQU      *-WTOM\n TITLE '>>> Storage Area <<<'\nSTORAGE         DSECT\nSAVEAREA        DS    20F                 (Must be 1st 18 words)\nR14_SAVE        DS      F\nDWORD           DS      0D,D\nSYSIN           DS      0D,CL(SYSINML)\nSYSPUNCH        DS      0D,CL(SYSPUNCHML)\nOPEN            DS      0D,CL(OPENMDLL)\nCLOSE           DS      0D,CL(CLOSEMDLL)\nTENWORDS        DS     12F\nLRECL           DS       XL02\nBLKSIZE         DS       XL02\nWTO             DS       CL(WTOML)\n                ORG      WTO\n                DS       AL2                 * L'MESSAGE+4, =AL2(84)\n                DS       XL2\nWTOMSG          DS       CL(WTOML-4-4)\n                DS       XL2\n                DS       XL2\nSTORAGE_LEN     EQU     (((*-STORAGE)*16)/16)+08\n TITLE 'PACKOFF - Unpack ISPF Packed Data'\n\n***********************************************************************\n*\n*        PACKOFF ROUTINE  - UnModified !!!\n*\n***********************************************************************\nPACKOFF  CSECT\n         SAVE  (14,12),,*              SAVE REGISTERS\n         BALR  R10,0                   ,\n         USING *,R10                   ,\n         LR    R9,R0                   WORK AREA\n         USING UNPKWORK,R9             WORK AREA\n*\n*              #1.  C'U' UNPACKED FILE\n*              #2.  C'P' RE-ENTRY (NEXT LINE REQUESTED)\n*              #3.  C'P' RE-ENTRY (FORCED EXIT FOR NEW INPUT REC)\n*              #4.  X'00' FIRST TIME\n*\n         CLI   UNPKWORK,C'U'           IS IT UNPACKED?\n         BE    UNPK990                 YES, GOBACK                 (#1)\n         L     R2,UNPKSAVE+4           CURRENT POS IN INPUT RECORD\n         CLI   UNPKSAVE,X'FF'          FORCED EXIT?\n         BE    UNPK110                 NO, BUILD NEXT RECORD       (#2)\n         LA    R2,0(,R1)               PASS RCD ADDR, CLEAR HI-BIT\n         LR    R3,R2                   PASS ADDR\n         AH    R3,UNPKWORK+2           ADD RECORD LENGTH\n         LM    R15,R1,UNPKSAVE         RESTORE R14, R0, R1\n         STM   R2,R3,UNPKSAVE+4        BEGIN/END OF INREC\n         CLI   UNPKWORK,0              FIRST TIME?\n         BNER  R15                     NO, RESUME PROCESSING       (#3)\n*\n*        FIRST TIME - DETERMINE WHETHER THIS IS A PACKED FILE      (#4)\n*\nUNPK050  MVI   UNPKWORK,C'U'           SET \"PACK OFF\" FLAG\n         MVI   UNPKSAVE,00             INIT \"PACK OFF\" RETURN CODE\n         CLI   UNPKWORK+1,C'F'         RECFM=F?\n         BNE   UNPK990                 NO, QUIT\n***      CLC   0(8,R2),=X'0001,40,C6,0000,0050'\n         CLI   0(R2),00                PACKED FILE?\n         BNE   UNPK990                 PACK OFF, JUMP\n         CLI   1(R2),1                 CHECK LEVEL\n         BNE   UNPK990                 PACK OFF, JUMP\n***      CLC   3(1,R2),UNPKWORK+1      COMPARE RECFM\n***      BNE   UNPK990                 PACK OFF, JUMP\n***      CLC   6(2,R2),UNPKWORK+2      COMPARE LRECL\n***      BNE   UNPK990                 PACK OFF, JUMP\n*\n         MVI   UNPKWORK,C'P'           SET \"PACK ON\" FLAG\n         MVC   UNPKWHDR,0(R2)          SAVE HEADER\n         LA    R2,8(,R2)               FIRST CONTROL BYTE\n*NEW INREC\nUNPK110  ICM   R0,B'1111',UNPKW255+4   LOAD/TEST ADDR OF RECORD AREA\n         BNZ   UNPK200                 ALREADY ALLOCATED, JUMP\n         GETMAIN R,LV=255              GET A RECORD AREA\n         STM   R0,R1,UNPKW255          SAVE LEN/ADDR OF RECORD AREA\n         LR    R0,R1                   PASS ADDRESS\n*--LOOP\nUNPK200  CL    R2,UNPKSAVE+4+4         END OF LINE REACHED?\n         BL    UNPK205                 NOT YET, JUMP\n         BAL   R14,UNPK600             READ NEW INPUT RECORD\n*\nUNPK205  CLI   0(R2),X'FF'             END OF FILE OR MEMBER?\n         BE    UNPK980                 YES, NEXT MEMBER OR EODAD\n         TM    0(R2),X'80'             IS IT A STRING?\n         BO    UNPK220                 YES, JUMP\n         CLI   0(R2),X'7A'             IS IT A REPEATED CHARACTER?\n         BE    UNPK230                 YES, JUMP\n*SPACES\nUNPK210  SLR   R1,R1\n         IC    R1,0(,R2)               GET REPEAT FACTOR -1\n         LA    R1,1(,R1)               LENGTH OF STRING\n         SLR   R3,R3\n         ICM   R3,B'1000',UNPKWHDR+2   PICK UP CHARACTER TO REPEAT\n         LA    R2,1(,R2)               BUMP UP PTR IN INPUT RCD\n         B     UNPK290                 MOVE SPACES\n*STRING\nUNPK220  LA    R15,X'0000007F'         MASK FOR \"NR\"\n         IC    R1,0(,R2)               STRING LENGTH-1+X80\n         NR    R1,R15                  STRING LENGTH-1\n         LA    R1,1(,R1)               LENGTH OF STRING\n         LA    R2,1(,R2)               SKIP OVER CONTROL BYTE\n         L     R3,UNPKSAVE+4+4         1ST BYTE AFTER INREC\n         SR    R3,R2                   LENGTH REMAINING IN INPUT RECORD\n         BZ    UNPK220L                CTL BYTE IS LAST BYTE, RE-READ\n         CR    R3,R1                   BYTES LEFT, STRING LENGTH\n         BNL   UNPK290                 NOT BROKEN, MOVE FULL STRING\n*BROKEN STRING\n         XR    R1,R3                   SWAP \"FROM\" AND \"TO\" LENGTHS\n         XR    R3,R1                   SWAP \"FROM\" AND \"TO\" LENGTHS\n         XR    R1,R3                   SWAP \"FROM\" AND \"TO\" LENGTHS\n         MVCL  R0,R2                   MOVE 1ST PART OF STRING\n         LR    R1,R3                   NUMBER OF BYTES LEFT\nUNPK220L BAL   R14,UNPK600             READ NEXT INREC\n         LR    R3,R1                   REMAINING LENGTH\n         B     UNPK290                 MOVE REST OF STRING\n*ALLCHAR\nUNPK230  L     R1,UNPKSAVE+4+4         1ST BYTE AFTER INREC\n         SLR   R1,R2                   REMAINING LENGTH\n         LA    R15,0002                PREPARE \"CR\"\n         CR    R1,R15                  2 BYTES LEFT?\n         BE    UNPK232                 YES, JUMP\n         BH    UNPK233                 AT LEAST 3, JUMP\n*SPLIT ALLCHAR (1)\nUNPK231  BAL   R14,UNPK600             READ NEXT INREC\n         SLR   R1,R1\n         IC    R1,0(,R2)               GET REPEAT FACTOR\n         LA    R2,1(,R2)               BUMP UP OVER REPEAT FACTOR\n         B     UNPK240                 MOVE ALL CHARS TO OUTPUT RECORD\n*SPLIT ALLCHAR (2)\nUNPK232  SLR   R1,R1\n         IC    R1,1(,R2)               GET REPEAT FACTOR\n         BAL   R14,UNPK600             READ NEXT INREC\n         B     UNPK240                 MOVE ALL CHARS TO OUTPUT RECORD\n*ALLCHAR (3)\nUNPK233  SLR   R1,R1\n         IC    R1,1(,R2)               GET REPEAT FACTOR\n         LA    R2,2(,R2)               BUMP UP OVER 7A02\n*\nUNPK240  LA    R1,1(,R1)               \"TO\" LENGTH\n         LA    R3,0001                 MOVE JUST ONE BYTE\n         ICM   R3,B'1000',0(R2)        INSERT PADDING CHARACTER\n*\n*     MOVE  STRING - R0=UNPKW255 R1=OUTLEN R2=INADDR   R3=INLEN+PADDING\n*\nUNPK290  MVCL  R0,R2                   MOVE CHARS TO UNPKW255\nUNPK291  L     R1,UNPKW255+4           OUTPUT RECORD\n         AH    R1,UNPKWHDR+6           LRECL\n         CR    R0,R1                   EOL REACHED YET?\n         BL    UNPK200                 NO, LOOP\n*--ENDLOOP\n         ST    R2,UNPKSAVE+4           CURRENT POS IN INPUT RECORD\n         MVC   24(4,R13),UNPKW255+4    PASS ADDR OF UNPACKED RECORD\n         MVI   UNPKSAVE,X'FF'          INVALIDATE ADDRESS\n         RETURN (14,12),RC=0           NORMAL EXIT\n*\n*        FORCED EXIT (TO REQUEST NEXT INPUT RECORD)\n*\nUNPK600  LR    R15,R14                 SAVE RETURN ADDRESS\n         STM   R15,R1,UNPKSAVE         SAVE R14, R0, R1\n         RETURN (14,12),RC=4\nUNPK980  MVI   UNPKSAVE,X'00'          INVALIDATE ADDRESS\n         RETURN (14,12),RC=8           END OF FILE (X'FF')\n*\n*        \"PACK OFF\" EXIT (SENDS ALTERNATIVELY RC0 AND RC 4)\n*\nUNPK990  SLR   R15,R15                 INVALIDATE ADDRESS\n         IC    R15,UNPKSAVE            PICK UP RETURN CODE\n         XI    UNPKSAVE,X'04'          TOGGLE RETCODE\n         RETURN (14,12),RC=(15)        \"PACK OFF\" EXIT\nUNPKWORK DSECT\n         DS    X'00'               +0  X'00' C'P' C'U'\n         DS    C'F'                +1  RECORD FORMAT\n         DS    H'00'  80/2         +2  LENGTH OF INPUT RECORD/BLOCK\nUNPKW255 DS    F,A                 +4  LENGTH/ADDRESS OF RECORD AREA\nUNPKWHDR DS    0XL8,X'0001,40,C6,0000,0050'\nUNPKSAVE DS    A(R15,R0,R1)            FORCED EXIT\n         DS    (UNPKWORK+32-*)X        MAX SIZE IS 8 WORDS\n         DS    CL30\n         DCBD  DSORG=PS,DEVD=DA\n         YREGS\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Sys/Stat for MVS is an integrated ISPF MVS search and display    *\n*    facility that uses the latest technology to improve systems      *\n*    programmers productvity.  Please call for a no obligation        *\n*    evaluation.                                                      *\n*                                                                     *\n*    Advent Software                                                  *\n*    340 West Butterfield Road                                        *\n*    Suite 4B                                                         *\n*    Elmhurst, IL 60126                                               *\n*    (708) 279-5449                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         END\n//*L.SYSLMOD DD DISP=SHR,DSN=some.syslmod(ISPFUNPK)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UCBSCAN": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x934\\x1f\\x00\\x96 \\x7f\\x113\\x00w\\x00_\\x00\\x00\\xe2\\xe8\\xe2\\xd4\\xe5\\xc8@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1993-12-07T00:00:00", "modifydate": "1996-07-25T11:33:00", "lines": 119, "newlines": 95, "modlines": 0, "user": "SYSMVH"}, "text": "// EXEC ASMHCL\n//C.SYSLIB DD  DISP=SHR,DSN=SYS1.MACLIB\n//         DD  DISP=SHR,DSN=SYS1.MODGEN\n//C.SYSIN DD *\n COPY $DOC\nUCBSCAN       AMODE  31\nUCBSCAN       RMODE  ANY\nUCBSCAN       CSECT\n              BAKR   R14,0                * LOAD ESA STAX\n              LR     R12,R15              * SETUP BASE\n             USING   UCBSCAN,R12\n              BSM    R14,0                * SAVE MODE\n              B      GET_STOR             * SKIP OVER CONSTANTS\n              DC     C'UCBSCAN_&SYSDATE._&SYSTIME.'\nGET_STOR      STORAGE  OBTAIN,              * GET STOR FOR SAVE AREA   +\n               LENGTH=STORAGE_LEN,LOC=RES\n              LR     R13,R1               * POINT R13 TO SAVE AREA\n              LR     R8,R1\n              ST     R13,4(,R1)           * SAVE FORWARD\n              ST     R1,8(,R1)            * BACKWARDS\n              LR     R13,R1               * POINT TO 18F WORDS\n              MVC    4(4,R1),=C'F1SA'     * REQUIREd\n             USING   STORAGE,R13\n              ST     R8,STORADDR          * SAVE FOR LATER\n              XC     UCB_WORK,UCB_WORK\n              XC     UCB_COPY,UCB_COPY\n              XC     CONFIG_TOKEN,CONFIG_TOKEN\n              LA     R1,DCE_LEN\n              ST     R1,DCE_LENGTH\nNEXT_UCB      DS     0H\n              UCBSCAN COPY,                 * Get copy of UCB          +\n               WORKAREA=UCB_WORK,           * Our work area            +\n               UCBAREA=UCB_COPY,            * Return copy here         +\n               UCBPAREA=UCBPREFIX,          *.Get UCB prefix           +\n               DCEAREA=DCEAREA,             *.Get DCE                  +\n               DCELEN=DCE_LENGTH,           *.Speficy DCE length       +\n               DEVNCHAR=DEVTYPE_4,          *.Dev characteristics 4 byt+\n               DEVN=0,                      * start w/1st UCB          +\n               DYNAMIC=YES,                 * Get Dynamic and Static   +\n               RANGE=ALL,                   * All UCBs incld. 4 digit  +\n               NONBASE=YES,                 * Multi-exposure tape      +\n               DEVCLASS=DASD,               * DASD only                +\n               DEVCID=,                     * not needed               +\n               IOCTOKEN=CONFIG_TOKEN,       * I/O Config. Token        +\n               RETCODE=RETCODE,             * RC                       +\n               RSNCODE=RSNCODE              * Reason code\n               L     R15,RETCODE            * Parameter error ?\n               B     *+4(R15)\n               B     RC00\n               B     RC04\n               B     RC08\n               B     RC12\n               B     RC16\n               B     RC20\n               B     BAD\nRC00           DS    0H\n               LA    R9,UCB_COPY          *.Fine, process this one...\n              USING  UCB,R9\n\n               B     NEXT_UCB             * Go get next one\nRC04           B     DONE_UCB             * Finished with UCBs\nRC08           B     ERROR_IN_PARMS       *.Yep, Let's see\nRC12           B     NEXT_UCB             * I/O Config changed, reread\nRC16           B     ERROR\nRC20           B     ERROR\nBAD            B     ERROR\n              DROP   R9\nERROR_IN_PARMS LA    R10,8\n               B     DONE_UCB\nERROR          LA    R10,10\n               B     DONE_UCB\nDONE_UCB       DS    0H\n               L     R2,STORADDR\n              STORAGE  RELEASE,                                        +\n               LENGTH=STORAGE_LEN,ADDR=(R2)\n             DROP    R13\n              PR     ,                    * Reload ESA STAX\n*\n              LTORG\n              DROP   ,\nSTORAGE       DSECT\nSAVE_AREA     DS       18F\nSTORADDR      DS     F\nCONFIG_TOKEN  DS     XL48'00'\n              DS     0F\nUCB_COPY      DS      XL60\nUCBPREFIX     DS      XL256\nUCB_WORK      DS      XL100\nRSNCODE       DS      F\nRETCODE       DS      F\n              DS     0D\nDEVCLAS       DS      CL1\nADDRUCB       DS      F\nDCE_LENGTH    DS      F\nDCEAREA       DS      CL(DCE_LEN)\nDEVTYPE_4     DS      XL8\n              DS      0D\nSTORAGE_LEN     EQU      *-STORAGE\n*\n              IEFUCBOB  PREFIX=YES,LIST=NO\n              IECDDCE\nDCE_LEN       EQU    *-DCE\n              CVT DSECT=YES,LIST=NO\n              YREGS\n*---------------------------------------------------------------------*\n*                                                                     *\n*    Sys/Stat for MVS is an integrated ISPF MVS display tool          *\n*    using the latest technology to improve systems                   *\n*    programmers productvity.  Please call or write for a             *\n*    free trial.  If licenced by January 31, 1994 you can             *\n*    own Sys/Stat for $3,500!                                         *\n*                                                                     *\n*    Advent Software                                                  *\n*    11951 Sentinel Point Court                                       *\n*    Reston, Virginia 22091                                           *\n*    (703) 758-1617                                                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n              END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT275/FILE275.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT275", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}