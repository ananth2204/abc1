{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011949000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 823004, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 11, "INMDSNAM": "CBT.V500.FILE411.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 823004, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE411.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0e\\x06'", "DS1TRBAL": "b'kP'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xf7\\x00\\r\\x02\\xf8\\x00\\x0c\\x00\\x0f'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x00\\x17\\x01\\x170o\\x01\\x170o\\x14\\x19\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-11-02T00:00:00", "modifydate": "2017-11-02T14:19:17", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-495"}, "text": "REGULAR CBT TAPE - VERSION 495    FILE:  411\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT495.FILE411\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 30 MEMBERS COUNTED; CUMULATIVE SIZE IS 7,319 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/02/17    14:19:16    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x007\\x00\\x99&_\\x01\\x02 \\x7f\\tR\\x007\\x00\\x17\\x00\\x00\\xc8\\xe4\\xd2\\xd9\\xc4\\xe2@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1999-09-22T00:00:00", "modifydate": "2002-07-26T09:52:37", "lines": 55, "newlines": 23, "modlines": 0, "user": "HUKRDS"}, "text": "Rob Scott Utilities - File 411 and 412\n--------------------------------------\n\nFor up to date information on these and more please also see my\nwebsite : www.mximvs.com\n\nAny problems, comments or suggestions please e-mail : rob@mximvs.com\n\nPlease note that pre-assembled and linked versions of most of these\nutilities are available in CBT Tape File 412 which also includes the\nVTOCUTIL and DDDEFCHK programs.\n\nIndex of Members in this dataset\n--------------------------------\nCONFIGX$       Installation and usage documentation for CONFIGXX.\nCONFIGXX       Assembler source for the CONFIGXX utility.\n\nDDDEFCH$       Installation and usage documentation for the DDDEFCHK\n               utility (source not supplied). Load module is supplied\n               in CBT Tape File 412.\n\nDDDEFPT$       Installation and usage documentation for the DDDEFPTH\n               utility (source not supplied). Load module is supplied\n               in CBT Tape File 412.\n\nDELNOEN$       Installation and usage documentation for DELNOENQ.\nDELNOEN@       Sample JCL to assemble and link DELNOENQ.\nDELNOENQ       Assembler source for the DELNOENQ batch utility.\n\nIEFACTR$       Installation and usage notes for the IEFACTRT exit.\nIEFACTRT       Assembler source for the IEFACTRT step termination exit.\n\nLISTSY$        Installation and usage documentation for LISTSYM and\n               VIEWSYM.\nLISTSY@        Sample JCL to assemble and link LISTSYM.\nLISTSYM        Assembler source for the LISTSYM external REXX function.\nVIEWSYM        REXX Edit macro to show possible use of the LISTSYM\n               external REXX function.\n\nSLEE$          Installation and usage documentation for SLEEP\nSLEE@          Sample JCL to assemble and link SLEEP.\nSLEEP          Assembler source for the SLEEP external REXX function.\n\nSTEMPUL$       Installation and usage documentation for STEMPUSH and\n               STEMPULL.\nSTEMPUL@       Sample JCL to assemble and link STEMPUSH and STEMPULL.\nSTEMPULL       Assembler source for the STEMPULL external REXX function.\nSTEMPUSH       Assembler source for the STEMPUSH external REXX function.\n\nVARYDAS$       Installation and usage documentation for VARYDASD.\nVARYDASD       Assembler source for the VARYDASD utility.\n\nVTOCUTI$       Installation and usage documentation for the VTOCUTIL\n               utility (source not supplied). Load module is supplied\n               in CBT Tape File 412.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE411": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x008\\x01\\x170o\\x01\\x170o\\x14\\x17\\x00>\\x00>\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-11-02T00:00:00", "modifydate": "2017-11-02T14:17:38", "lines": 62, "newlines": 62, "modlines": 0, "user": "CBT-495"}, "text": "//***FILE 411 is from Rob Scott in England                          *   FILE 411\n//*           and contains source code for some of                  *   FILE 411\n//*           his utilities.                                        *   FILE 411\n//*                                                                 *   FILE 411\n//*               Any problems, comments or suggestions             *   FILE 411\n//*               please e-mail : rscott@rs.com                     *   FILE 411\n//*                                                                 *   FILE 411\n//*      Rob Scott's Utilities - File 411 and 412                   *   FILE 411\n//*      ----------------------------------------                   *   FILE 411\n//*                                                                 *   FILE 411\n//*      Please note that pre-assembled and linked versions of      *   FILE 411\n//*      most of these utilities are available in CBT Tape File     *   FILE 411\n//*      412 which also includes the VTOCUTIL program.              *   FILE 411\n//*                                                                 *   FILE 411\n//*      Index of Members in this dataset                           *   FILE 411\n//*      --------------------------------                           *   FILE 411\n//*      CONFIGX$       Installation and usage documentation for    *   FILE 411\n//*                     CONFIGXX                                    *   FILE 411\n//*      CONFIGXX       Utility to construct a CONFIG member for    *   FILE 411\n//*                     your active system                          *   FILE 411\n//*      DDDEFCH$       Installation and usage documentation for    *   FILE 411\n//*                     DDDEFCHK.                                   *   FILE 411\n//*      DDDEFPT$       Installation and usage documentation for    *   FILE 411\n//*                     DDDEFPTK.                                   *   FILE 411\n//*      DELNOEN$       Installation and usage documentation for    *   FILE 411\n//*                     DELNOENQ.                                   *   FILE 411\n//*      DELNOEN@       Sample JCL to assemble and link DELNOENQ.   *   FILE 411\n//*      DELNOENQ       Assembler source for the DELNOENQ batch     *   FILE 411\n//*                     utility.                                    *   FILE 411\n//*      IEFACTR$       Installation and usage notes for the        *   FILE 411\n//*                     IEFACTRT exit.                              *   FILE 411\n//*      IEFACTRT       Assembler source for the IEFACTRT step      *   FILE 411\n//*                     termination exit.                           *   FILE 411\n//*      LISTSY$        Installation and usage documentation for    *   FILE 411\n//*                     LISTSYM and VIEWSYM.                        *   FILE 411\n//*      LISTSY@        Sample JCL to assemble and link LISTSYM.    *   FILE 411\n//*      LISTSYM        Assembler source for the LISTSYM            *   FILE 411\n//*                     external REXX function.                     *   FILE 411\n//*      VIEWSYM        REXX Edit macro to show possible use of     *   FILE 411\n//*                     the LISTSYM external REXX function.         *   FILE 411\n//*      SLEE$          Installation and usage documentation for    *   FILE 411\n//*                     SLEEP                                       *   FILE 411\n//*      SLEE@          Sample JCL to assemble and link SLEEP.      *   FILE 411\n//*      SLEEP          Assembler source for the SLEEP external     *   FILE 411\n//*                     REXX function.                              *   FILE 411\n//*      STEMPUL$       Installation and usage documentation for    *   FILE 411\n//*                     STEMPUSH and STEMPULL.                      *   FILE 411\n//*      STEMPUL@       Sample JCL to assemble and link STEMPUSH    *   FILE 411\n//*                     and STEMPULL.                               *   FILE 411\n//*      STEMPULL       Assembler source for the STEMPULL           *   FILE 411\n//*                     external REXX function.                     *   FILE 411\n//*      STEMPUSH       Assembler source for the STEMPUSH           *   FILE 411\n//*                     external REXX function.                     *   FILE 411\n//*      VARYDAS$       Installation and usage documentation for    *   FILE 411\n//*                     the VARYDASD utility.                       *   FILE 411\n//*      VARYDASD       Assembler source for utility to vary DASD   *   FILE 411\n//*                     devices offline depending on the volser.    *   FILE 411\n//*      VTOCUTI$       Installation and usage documentation for    *   FILE 411\n//*                     the VTOCUTIL utility (source not            *   FILE 411\n//*                     supplied). Load module is supplied in       *   FILE 411\n//*                     CBT Tape File 412.                          *   FILE 411\n//*                                                                 *   FILE 411\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE412": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04_\\x00F\\x01\\x170o\\x01\\x170o\\x14\\x18\\x00\\x08\\x00\\x08\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf5@@@'", "ispf": {"version": "04.95", "flags": 0, "createdate": "2017-11-02T00:00:00", "modifydate": "2017-11-02T14:18:46", "lines": 8, "newlines": 8, "modlines": 0, "user": "CBT-495"}, "text": "//***FILE 412 is from Rob Scott in England                          *   FILE 412\n//*           and contains load modules for his                     *   FILE 412\n//*           utilities whose source code is on File 411, and       *   FILE 412\n//*           also for the VTOCUTIL and DDDEFCHK programs.          *   FILE 412\n//*                                                                 *   FILE 412\n//*               Any problems, comments or suggestions             *   FILE 412\n//*               please e-mail : rscott@rs.com                     *   FILE 412\n//*                                                                 *   FILE 412\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONFIGX$": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x04_\\x01\\x00\\x04_\\x10!\\x00A\\x00A\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-14T00:00:00", "modifydate": "2000-02-14T10:21:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "SBGOLOB"}, "text": "Generate the CONFIGxx Member\n----------------------------\n\n1.0 Installation of CONFIGXX\n\n    Supplied Material :\n    README.TXT    -  This file\n    CONFIGXX.TXT  -  Assembler source code for the CONFIGXX function\n\n    (a) File transfer the CONFIGXX.TXT file to the mainframe host\n        using ASCII-EBCDIC translation.\n\n    (b) Assemble and link CONFIGXX into any load library.\n        Use the following linkedit attributes :\n           AMODE(31)\n           RMODE(24)\n           NORENT\n           NOREUS\n           NOREFR\n           AC(0)\n\n 2.0 Using CONFIGXX\n\n     The CONFIGXX program is used to create the CONFIGxx member of\n     PARMLIB.  The basic idea being that you would run the CONFIGXX\n     program at a time that you are satisfied that everything that\n     should be online is online and that everything that should be\n     offline is also offline.\n\n     The program generates the following CONFIGxx statements :\n\n     (1) CPU (x)\n     (2) STOR 0M-nnnM\n     (3) ESTOR 0M-nnnM\n     (4) DEV(uuuu),(chp,chp,chp....)\n\n     The required JCL is as follows :\n\n        //CONFIG   EXEC PGM=CONFIGXX\n        //PARMLIB  DD   DISP=SHR,DSN=SYS1.PARMLIB(CONFIG00)\n\n     When started, the program will analyze the system and\n     produce the following :\n\n     (1) A 'CPU (x)' statement for each online CPU.\n     (2) A 'STOR 0M-nnnnM' statement to reflect the amount of\n         real storage\n     (3) An 'ESTOR 0M-nnnnM' statement to reflect the amount of\n         expanded storage\n     (4) A 'DEV(uuuu),(chp,chp...)' statement for each online\n         device 'uuuu' with its online CHPids in one of more\n         'chp'.\n\n     Note that the 'DEV' statements are grouped into device\n     class sections and also that the UCB type is written as\n     comments. For DASD devices, the current volser is also\n     written as a comment.\n\n\n\nRob Scott\nScott Enterprise Consultancy Ltd\n\nWebsite : www.secltd.co.uk\nEmail   : rob@secltd.co.uk\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CONFIGXX": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\t\\x01\\x02\\x14?\\x01\\x02\\x14\\x8f\\t\\x14\\x02\\t\\x02\\x05\\x00\\x00\\xc8\\xe4\\xd2\\xd9\\xc4\\xe2@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2002-05-23T00:00:00", "modifydate": "2002-05-28T09:14:09", "lines": 521, "newlines": 517, "modlines": 0, "user": "HUKRDS"}, "text": "CONFIGXX TITLE 'Construct CONFIGxx Member'\n*-------------------------------------------------------------------*\n* Name            : CONFIGXX\n*\n* Function        : This program will construct the CONFIGxx member\n*                   based on the active system.\n*                   The idea being that this program is run when you\n*                   are satisfied that the system has everything\n*                   online that you need.\n*\n*                   The output is written to the PARMLIB DDName\n*\n* Example JCL     : //CONFIG   EXEC PGM=CONFIGXX\n*                   //STEPLIB  DD   DISP=SHR,DSN=some.dataset\n*                   //PARMLIB  DD   DISP=SHR,DSN=SYS1.PARMLIB(CONFIG00)\n*\n*\n* IBM Macros Used : MODID, STORAGE, TIME, UCBSCAN, UCBDEVN, UCBINFO,\n*                   OPEN, PUT, CLOSE\n*                   DCB, CVT, IEFUCBOB, IOSDPATH, IARRCE, IHAASCB,\n*                   IHAASXB, IHAACEE\n*\n* Attributes      : Amode(31)\n*                   Rmode(24)\n*                   NORENT\n*                   NOREUS\n*                   NOREFR\n*                   AC(0)\n*\n* Register Usage  :\n*\n* R1  -\n* R2  - Device Type Table\n* R3  - Work\n* R4  - UCB\n* R5  - CVT\n* R6  - RCE\n* R7  - Work\n* R8  - Work\n* R9  - Path Info Array\n* R10 - Branch and Link\n* R11 - Branch and Link\n* R12 - Base reg\n* R13 - Workarea\n* R14 -\n*\n*\n*-------------------------------------------------------------------*\n* Changes\n* 02/11/1999  Rob Scott     Code Written                         V1.0\n* 23/02/2000  Rob Scott     Added the \"CHP\" cards                V1.1\n* 17/05/2002  Bob Rutledge  Generate \"OFFLINE\" cards             V1.2\n*                           Use ICHPT for \"CHP\" cards\n*                           Swap Stage 4 and Stage 5\n* 27/05/2002  Rob Scott     Cater for no ESTOR                   V1.3\n*                           Include 'ONLINE' keyword on\n*                           DEV statements for online devices\n*-------------------------------------------------------------------*\nCONFIGXX CSECT\nCONFIGXX AMODE 31\nCONFIGXX RMODE 24\n         BAKR  R14,R0                 linkage stack\n         LAE   R12,0(R15,0)           set R12 as base\n         USING CONFIGXX,R12           address it\n         MODID ,                      eyecatcher\nGETWORK  EQU   *\n*--------------------------------------------------------------------*\n* Get some workarea storage and init to zeros.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in r13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=BELOW,             below the line                   X\n               COND=NO                unconditional\n         USING WORKAREA,R13           address workarea\n         LR    R14,R13                Copy workarea address\n         L     R15,=A(WORKLEN)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to zeros\n         MVC   4(4,R13),=C'F1SA'      set label in savearea\nINIT     EQU   *\n*--------------------------------------------------------------------*\n* Open the PARMLIB dataset and write a comment indicating the\n* time and date of the generation.\n*--------------------------------------------------------------------*\n         OPEN  (PARMLIB,(OUTPUT))     Open the dataset\n         L     R5,CVTPTR              Get the CVT\n         USING CVTMAP,R5              Address it\n         TIME  DEC,TIMEDATE,          get time and date                X\n               DATETYPE=YYYYMMDD,     ..in format yyyymmdd             X\n               LINKAGE=SYSTEM\n         MVC   OUTREC(80),BLANKS      Blank the time\n         MVC   OUTREC(40),HEADER0     Copy in the header\n         PUT   PARMLIB,OUTREC\n         MVC   OUTREC(40),HEADER1     Blank the time\n         MVC   OUTREC+2(34),=CL34'Generated by the CONFIGXX program'\n         PUT   PARMLIB,OUTREC\n         MVC   OUTREC(80),BLANKS      Blank the time\n         MVC   OUTREC(40),HEADER1     Blank the time\n         MVC   OUTREC+2(32),=CL32'     Date : yyyy/mm/dd'\n         LA    R0,4                   Set length (yyyymmdd)\n         LA    R1,TIMEDATE+8          Point to the hex\n         LA    R15,UWORK              Point to the output\n         BAL   R14,HEX2CHAR           Make printable\n         MVC   OUTREC+14(4),UWORK     Copy in YYYY\n         MVC   OUTREC+19(2),UWORK+4   Copy in MM\n         MVC   OUTREC+22(2),UWORK+6   Copy in DD\n         PUT   PARMLIB,OUTREC\n         MVC   OUTREC(80),BLANKS      Blank the time\n         MVC   OUTREC(40),HEADER1     Blank the time\n         MVC   OUTREC+2(32),=CL32'     Time : hh.mm.ss'\n         LA    R0,3                   Set length (hhmmss)\n         LA    R1,TIMEDATE            Point to the hex\n         LA    R15,UWORK              Point to the output\n         BAL   R14,HEX2CHAR           Make printable\n         MVC   OUTREC+14(2),UWORK     Copy in HH\n         MVC   OUTREC+17(2),UWORK+2   Copy in MM\n         MVC   OUTREC+20(2),UWORK+4   Copy in SS\n         PUT   PARMLIB,OUTREC\n         MVC   OUTREC(80),BLANKS      Blank the time\n         MVC   OUTREC(40),HEADER1     Blank the time\n         MVC   OUTREC+2(32),=CL32'     User : '\nGETUSER  EQU   *\n         L     R15,0(R5)              Get the TCB words\n         L     R15,12(R15)            Get the ASCB\n         L     R15,ASCBASXB-ASCB(R15) Get the ASXB\n         L     R15,ASXBSENV-ASXB(R15) Get the ACEE address\n         MVC   OUTREC+14(8),ACEEUSRI-ACEE(R15)\n         PUT   PARMLIB,OUTREC\n         MVC   OUTREC(40),HEADER0     Copy in the header\n         PUT   PARMLIB,OUTREC\nSTAGE1   EQU   *\n*--------------------------------------------------------------------*\n* Stage One : Get the CPUs and for each one write out\n*             a \"CPU (x)\" or \"CPU (x),OFFLINE record\n*--------------------------------------------------------------------*\n         L     R6,CVTPCCAT            Get the PCCAT\n         XR    R3,R3                  Clear\nLOOPPCCA EQU   *\n         MVC   OUTREC(80),BLANKS      Yes - blank line\n         MVC   OUTREC(7),CPU          Move in 'CPU (x)'\n         STCM  R3,B'0001',UWORK       Store CPU number\n         LA    R0,1                   Set length for HEX2CHAR\n         LA    R1,UWORK               Point to input\n         LA    R15,SWORK              Point to output\n         BAL   R14,HEX2CHAR           Convert to hex\n         MVC   OUTREC+5(1),SWORK+1    Move in the CPU number\n         ICM   R8,B'1111',0(R6)       Is there a PCCA ?\n         BNZ   ISCPU                  Yes - card is OK\n         MVC   OUTREC+7(8),=C',OFFLINE' Mark CP to be offline\nISCPU    EQU   *\n         PUT   PARMLIB,OUTREC         Write it out\n         LA    R3,1(R3)               Inc CPU count\n         C     R3,=F'16'              last one ?\n         BNL   STAGE2                 yes - exit\n         LA    R6,4(R6)               Get next PCCA\n         B     LOOPPCCA\nSTAGE2   EQU   *\n*--------------------------------------------------------------------*\n* Stage Two : Get the STOR value and write out a \"STOR 0M-nnnM\"\n*             record\n*--------------------------------------------------------------------*\n         L     R15,CVTRLSTG           Get the Real Storage (K)\n         LA    R15,1(R15)             Add one\n         SRL   R15,10                 Divide by 1024 = Mb\n         CVD   R15,DWORK              Convert to decimal\n         MVC   UWORK(8),MASK          Copy in the mask\n         ED    UWORK(8),DWORK+4       Make printable\n         MVC   OUTREC(80),BLANKS      Blank the line\n         MVC   OUTREC(8),STOR         Add 'STOR 0M-'\n         MVI   UWORKLEN,8             Set max length of UWORK\n         BAL   R10,STRIP              and strip leading chars\n         LA    R1,OUTREC+8            Point to target area\n         LA    R15,SWORK              Point to source\n         XR    R14,R14                Clear\n         IC    R14,SWORKLEN           Get the length\n         BCTR  R14,R0                 -1 for execute\n         EX    R14,MOVEDATA           Move it in\n         XR    R14,R14                Clear\n         IC    R14,SWORKLEN           Get the length\n         AR    R1,R14                 Go to end of card\n         MVI   0(R1),C'M'             add 'M' for Mb\n         PUT   PARMLIB,OUTREC         Write out the record\nSTAGE3   EQU   *\n*--------------------------------------------------------------------*\n* Stage Three : Get the ESTOR value and write out a \"ESTOR 0M-nnnM\"\n*--------------------------------------------------------------------*\n         L     R6,CVTRCEP             get address of rce\n         USING RCE,R6                 address it\n         ICM   R15,B'1111',RCEESPL    Get the # expanded frames\n         BZ    STAGE4\n         SLL   R15,2                  x4 = amount in K\n         SRL   R15,10                 Divide by 1024 = Mb\n         CVD   R15,DWORK              Convert to decimal\n         MVC   UWORK(8),MASK          Copy in the mask\n         ED    UWORK(8),DWORK+4       Make printable\n         MVC   OUTREC(80),BLANKS      Blank the line\n         MVC   OUTREC(9),ESTOR        Add 'ESTOR 0M-'\n         MVI   UWORKLEN,8             Set max length of UWORK\n         BAL   R10,STRIP              and strip leading chars\n         LA    R1,OUTREC+9            Point to target area\n         LA    R15,SWORK              Point to source\n         XR    R14,R14                Clear\n         IC    R14,SWORKLEN           Get the length\n         BCTR  R14,R0                 -1 for execute\n         EX    R14,MOVEDATA           Move it in\n         XR    R14,R14                Clear\n         IC    R14,SWORKLEN           Get the length\n         AR    R1,R14                 Go to end of card\n         MVI   0(R1),C'M'             add 'M' for Mb\n         PUT   PARMLIB,OUTREC         Write out the record\nSTAGE4   EQU   *\n*--------------------------------------------------------------------*\n* Stage Four  : Scan thru the CHPID array and write out a \"CHP (xx)\"\n*               or \"CHP (xx),OFFLINE\" record for each channel\n*--------------------------------------------------------------------*\n         MVC   OUTREC(80),BLANKS      Blank the line\n         MVC   OUTREC(40),HEADER0     Write a header\n         PUT   PARMLIB,OUTREC         Write the record\n         MVC   OUTREC(40),HEADER1     Write a header\n         MVC   OUTREC+2(22),HEADER2\n         PUT   PARMLIB,OUTREC         Write the record\n         MVC   OUTREC(40),HEADER0     Write a header\n         PUT   PARMLIB,OUTREC         Write the record\n         L     R2,CVTICHPT            Point to channel array\n         XR    R11,R11                Clear\nLOOPCHAN EQU   *\n         TM    0(R2),X'80'            Channel valid ?\n         BZ    NEXTCHAN               No - get next\n         MVC   OUTREC(80),BLANKS      Blank the line\n         MVC   OUTREC(8),CHP          Move in model\n         ST    R11,DWORK              Store channel number\n         LA    R0,1                   Length of channel number\n         LA    R1,DWORK+3             Point to device type\n         LA    R15,OUTREC+5           Point to output area\n         BAL   R14,HEX2CHAR           Convert to EBCDIC\n         TM    0(R2),X'20'            Channel online ?\n         BO    ISCHAN                 Yes - all set\n         MVC   OUTREC+8(8),=C',OFFLINE' No - mark as offline\nISCHAN   EQU   *\n         PUT   PARMLIB,OUTREC         Write the record\nNEXTCHAN EQU   *\n         LA    R2,1(R2)               Point to next channel\n         LA    R11,1(R11)             add one to CHPid number\n         C     R11,=F'256'            end yet?\n         BL    LOOPCHAN\nSTAGE5   EQU   *\n*--------------------------------------------------------------------*\n* Stage Five  : Scan thru the UCBs and write out a \"DEV (uuuu),(xx)\",\n*               \"DEV (uuuu),OFFLINE\" or \"DEV (uuuu),(xx),OFFLINE\n*               record for each device class\n*--------------------------------------------------------------------*\n         LA    R2,DEVTABLE            Point to device type table\nLOOPDEVT EQU   *\n         CLI   0(R2),X'FF'            End of table\n         BE    RETURN                 Yes - finished\n         MVC   OUTREC(80),BLANKS      Blank the line\n         MVC   OUTREC(40),HEADER0     Write a header\n         PUT   PARMLIB,OUTREC         Write the record\n         MVC   OUTREC(40),HEADER1     Write a header\n         MVC   OUTREC+2(22),1(R2)\n         PUT   PARMLIB,OUTREC         Write the record\n         MVC   OUTREC(40),HEADER0     Write a header\n         PUT   PARMLIB,OUTREC         Write the record\n         MVC   DEVCID(1),0(R2)        Copy in device class\n*\n         LA    R4,UCBAREA             Point to copy of UCB\n         USING UCBCMSEG,R4            address it\n         XC    WORKUCB,WORKUCB        Clear UCB workarea\nUNITSCAN EQU   *\n         UCBSCAN COPY,                Perform UCBSCAN                  X\n               WORKAREA=WORKUCB,      Use this workarea                X\n               UCBAREA=UCBAREA,       Copy UCB here                    X\n               CMXTAREA=CMXTAREA,     UCB Common extension             X\n               DEVCID=DEVCID,         Only find this device class      X\n               DEVN=0,                Start at beginning               X\n               RANGE=ALL,             Include 4-digit devices          X\n               DYNAMIC=YES            and dynamic UCBs\n         C     R15,=F'4'              check rc\n         BH    UNITSCAN               If RC > 4 ignore\n         BE    UNITFINI               If RC = 4 then finished\n         MVC   VOLSER(6),UCBVOLI      Copy the Volser\n         UCBDEVN DEVN=UNITADDR        Get the unit address\n*\n         MVC   OUTREC(80),BLANKS      Blank the line\n         MVC   OUTREC(36),DEV         Setup the 'DEV' statement\n         MVC   OUTREC+5(4),UNITADDR   copy in the unit address\n         MVC   OUTREC+56(5),=C'Devt='\n         TM    UCBSTAT,UCBONLI        Is it Online ?\n         BNO   DEVPATHS               No - don't write volser\n         CLI   DEVCID,X'20'           Is it DASD ?\n         BNE   DEVPATHS               No - don't write volser\n         MVC   OUTREC+45(4),=CL4'Vol='\n         MVC   OUTREC+49(6),VOLSER\nDEVPATHS EQU   *\n         LA    R0,4                   Length of UCBTYP\n         LA    R1,UCBTYP              Point to device type\n         LA    R15,OUTREC+61          Point to output area\n         BAL   R14,HEX2CHAR           Convert to EBCDIC\n         MVC   OUTREC2,OUTREC         Copy the output card\n         TM    UCBSTAT,UCBONLI        Is the device online ?\n         BNO   DEVOFFLN               No - go mark device offline\n         LA    R8,OUTREC+12           Point to first path in record\n         LA    R10,OUTREC2+12         And in the other record too\n         UCBINFO PATHINFO,            Get path information             X\n               PATHAREA=PATHAREA,     Put in this area                 X\n               DEVN=UCBCHAN           Use the device addr in the UCB\n         LA    R9,PATHAREA            Point to path area\n         USING PATH,R9                address it\n         ICM   R3,B'1111',PATH#CHPIDS Get number of paths\n         LA    R9,PATHCHPID           Point to path array\n         USING PATHCHPIDARRAY,R9      Address it\nLOOPPATH EQU   *\n         TM    PATHBITS,PATHLPM+PATHPAM Online ?\n         BNO   PTHOFFLN               No - mark the path offline\n*\n         LA    R0,1                   set length for HEX2CHAR\n         LA    R1,PATHCHPID+1         Point to path number\n         LR    R15,R8                 Point to output area\n         BAL   R14,HEX2CHAR           Write out CHPid\n         MVI   2(R8),C','             add a comma\n         LA    R8,3(R8)               Point to next path\n         B     NEXTPATH               Go see if there are more paths\nPTHOFFLN EQU   *\n         LA    R0,1                   set length for HEX2CHAR\n         LA    R1,PATHCHPID+1         Point to path number\n         LR    R15,R10                Point to output area\n         BAL   R14,HEX2CHAR           Write out CHPid\n         MVI   2(R10),C','            add a comma\n         LA    R10,3(R10)             Point to next path\nNEXTPATH EQU   *\n         LA    R9,28(R9)              Get next path\n         BCT   R3,LOOPPATH            Loop for all\nENDPATH  EQU   *\n         BCTR  R8,R0                  Go back a space\n         MVC   0(8,R8),=C'),ONLINE'\n*\n         PUT   PARMLIB,OUTREC         Write the record out\n         LA    R0,OUTREC2+12          First path slot\n         CR    R10,R0                 Any offline paths ?\n         BE    UNITSCAN               No - look for another device\n         BCTR  R10,0                  Yes - back up over the comma\n         MVC   0(9,R10),=C'),OFFLINE' Terminate the offline card\n         PUT   PARMLIB,OUTREC2        And write it\n         B     UNITSCAN               Look for another device\nDEVOFFLN EQU   *\n         TM    UCBFLB,UCBNOCON        Is this device connected?\n         BO    UNITSCAN               No subchannel, skip the device\n         MVC   OUTREC+10(8),=C',OFFLINE' Mark path to be offline\n         PUT   PARMLIB,OUTREC         Send the card along\n         B     UNITSCAN               Onward\n*\nUNITFINI EQU   *\n         LA    R2,23(R2)              Point to next entry\n         B     LOOPDEVT\n*\nRETURN   EQU   *\n         CLOSE (PARMLIB)              Close the dataset\n         STORAGE RELEASE,             free workarea storage            X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in r13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         XR    R15,R15                Clear RC\n         PR\n*\nSTRIP    EQU   *\n*-------------------------------------------------------------------*\n* Routine to strip leading blanks from the UWORK field and place\n* result in the SWORK field.\n* UWORKLEN contained the source length\n* SWORKLEN contained the result length\n*-------------------------------------------------------------------*\n         XR    R0,R0                  Clear\n         IC    R0,UWORKLEN            Get max loop\n         LA    R1,UWORK               Point to 1st char\n         LA    R15,SWORK              Point to output area\n         MVC   SWORK(8),BLANKS        Blank it out\n         XR    R14,R14                Clear\nSTRIPCLI EQU   *\n         CLI   0(R1),C' '             Is it a blank ?\n         BE    STRIPBLK               Yes - no copy performed\n         MVC   0(1,R15),0(R1)         No - copy the data in\n         LA    R15,1(R15)             and adjust pointers...\n         LA    R1,1(R1)\n         LA    R14,1(R14)             add to chars copied\n         BCT   R0,STRIPCLI            Loop for all\n         B     STRIPEXT               and quit\nSTRIPBLK EQU   *\n         LA    R1,1(R1)               Point to next input char\n         BCT   R0,STRIPCLI            and loop round\nSTRIPEXT EQU   *\n         STCM  R14,B'0001',SWORKLEN   Store length\n         BR    R10\n*\nHEX2CHAR EQU   *\n*--------------------------------------------------------------------*\n* Convert a hex string to EBCDIC\n* Regs on entry :\n*   R0  :  Length of entry\n*   R1  :  Hex string\n*   R15 :  Output area\n* Regs used within routine\n*   R7  :  Work reg\n*--------------------------------------------------------------------*\nLEFTHALF EQU   *\n         XR    R7,R7                  Clear\n         ICM   R7,B'0001',0(R1)       Load up a byte (000000ab)\n         SRL   R7,4                   Remove last 4 bits (0000000a)\nLEFTNUM  EQU   *\n         CH    R7,=H'9'               00000000 - 00000009 ?\n         BH    LEFTLTTR               higher - must be A-F\n         AH    R7,=H'240'             xlate to F0-F9\n         B     LEFTDONE\nLEFTLTTR EQU   *\n         AH    R7,=H'183'             xlate to C1-C6\nLEFTDONE EQU   *\n         STCM  R7,B'0001',0(R15)      Store in token\n         LA    R15,1(R15)             Point to next char\nRGHTHALF EQU   *\n         XR    R7,R7                  Clear\n         ICM   R7,B'0001',0(R1)       Load up a byte (000000ab)\n         SLL   R7,28                  Remove first 4 bits (b0000000)\n         SRL   R7,28                  and reset           (0000000b)\nRGHTNUM  EQU   *\n         CH    R7,=H'9'               00000000 - 00000009 ?\n         BH    RGHTLTTR               higher - must be A-F\n         AH    R7,=H'240'             xlate to F0-F9\n         B     RGHTDONE\nRGHTLTTR EQU   *\n         AH    R7,=H'183'             xlate to C1-C6\nRGHTDONE EQU   *\n         STCM  R7,B'0001',0(R15)      Store in token\n         LA    R15,1(R15)             Point to next char\n         LA    R1,1(R1)               Point to next token byte\n         BCT   R0,LEFTHALF            Loop for all bytes\n         BR    R14                    return\n*\n*\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs\n*-------------------------------------------------------------------*\n*\nMOVEDATA MVC   0(0,R1),0(R15)         Executed MOVE\n         LTORG\n*\nPARMLIB  DCB   DDNAME=PARMLIB,MACRF=PM,DSORG=PS,RECFM=FB,LRECL=80\n*\nCPU      DC    CL7'CPU (x)'\nSTOR     DC    CL8'STOR 0M-'\nESTOR    DC    CL9'ESTOR 0M-'\nDEV      DC    CL36'DEV (uuuu),(                        '\nCHP      DC    CL8'CHP (xx)'\n*\nMASK     DC    XL8'4020202020202120'\nBLANKS   DC    CL80' '\nHEADER0  DC    CL40'*--------------------------------------*'\nHEADER1  DC    CL40'*                                      *'\nHEADER2  DC    CL22'Channel Path Section'\nDEVTABLE DC    X'80',CL22'TAPE Device Section'\n         DC    X'20',CL22'DASD Device Section'\n         DC    X'41',CL22'CTC Device Section'\n         DC    X'40',CL22'COMMS Device Section'\n         DC    X'10',CL22'DISP Device Section'\n         DC    X'08',CL22'UNITREC Device Section'\n         DC    X'04',CL22'CHAR Device Section'\n         DC    X'FF',CL22'***End of Table***'\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                    save area\nDWORK    DS    D                      Packed work field\nTIMEDATE DS    2D                     Area for Time+Date\nDEVCID   DS    X                      Device class ID\nUWORKLEN DS    X                      Length of UWORK\nUWORK    DS    CL8                    Unpacked work field\nSWORKLEN DS    X                      Length of SWORK\nSWORK    DS    CL8                    Stripped field\nOUTREC   DS    CL80                   PARMLIB record\nOUTREC2  DS    CL80                   Another for offline paths\n         DS    0D\nVOLSER   DS    CL6                    Volser\nUNITADDR DS    CL4                    Unit address\n         DS    0D\nUCBRC    DS    F                      Return code from UCBSCAN\nUCBRSN   DS    F                      Reason code from UCBSCAN\n         DS    0D\nUCBAREA  DS    CL48                   area to get UCB copy\nUCBPAREA DS    CL48                   area to get UCB prefix copy\nCMXTAREA DS    CL32                   area to get CMXT copy\nWORKUCB  DS    CL100                  UCBSCAN workarea\n         DS    0D\nPATHAREA DS    CL256                  Area for path info\nWORKLEN  EQU   *-WORKAREA\n*\n         CVT DSECT=YES,LIST=NO        CVT\n         IEFUCBOB                     UCB\n         IOSDPATH\n         IARRCE\n         IHAASCB\n         IHAASXB\n         IHAACEE\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDDEFCH$": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x009\\x01\\x00&o\\x01\\x170o\\x14\\x16\\x00Y\\x00U\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2000-09-22T00:00:00", "modifydate": "2017-11-02T14:16:39", "lines": 89, "newlines": 85, "modlines": 0, "user": "SBGOLOB"}, "text": " Check SMP/E DDDEF Entries - DDDEFCHK\n ------------------------------------\n\n Installation of DDDEFCHK\n ------------------------\n\n Place the DDDEFCHK load module into your load library. Source\n code for the DDDEFCHK is not available.\n\n Note:  It may be necessary to APF-authorize the DDDEFCHK load\n        module, with linkedit of SETCODE AC(1), and to run it\n        from an APF-authorized load library.  (SG - Nov 2017)\n\n Using DDDEFCHK\n --------------\n\n DDDEFCHK lists and verifies your DDDEF entries in one or more zones.\n Please note that it does not check any 'path' entries.\n\n DDDEFCHK uses the GIMAPI callable service, so please ensure that your\n version of SMP/E supports this API.\n\n DDDEFCHK JCL\n ------------\n\n //STEP1  EXEC PGM=DDDEFCHK,PARM='ZONE=zone'\n //STEPLIB  DD DISP=SHR,DSN=your.load.library\n //SYSPRINT DD SYSOUT=*\n //SMPCSI   DD DISP=SHR,DSN=your.csi\n\n Explanation of DDDEFCHK JCL\n ---------------------------\n\n PARM Values\n -----------\n\n     ZONE=*           All zones are to be processed, including the\n                      GLOBAL zone.\n\n     ZONE=xxxx        Only DDDEF entries in zone 'xxxx' are to be\n                      processed.\n\n     ZONE=ALLTZONES   All known TARGET zones will be processed.\n\n     ZONE=ALLDZONES   All known DLIB zones will be processed.\n\n\n DDNames Used\n ------------\n\n     SYSPRINT Will contain the report produced by DDDEFCHK.\n     Required DCB : RECFM=FB, LRECL=133\n\n     SMPCSI specifies the name of the input SMP/E GLOBAL CSI\n\n\n Example Uses of DDDEFCHK\n ------------------------\n\n (a) Check zone MVST100 in SMPE.MVS.GLOBAL.CSI\n\n //EX1    EXEC PGM=DDDEFCHK,PARM='ZONE=MVST100'\n //SYSPRINT DD SYSOUT=*\n //SMPCSI   DD DISP=SHR,DSN=SMPE.MVS.GLOBAL.CSI\n\n (b) Check all TARGET zones in SMPE.MVS.GLOBAL.CSI\n\n //EX1    EXEC PGM=DDDEFCHK,PARM='ZONE=ALLTZONES'\n //SYSPRINT DD SYSOUT=*\n //SMPCSI   DD DISP=SHR,DSN=SMPE.MVS.GLOBAL.CSI\n\n Output produced by DDDEFCHK\n ---------------------------\n\n The program produces a tabular report will the following headings :\n\n DDNAME            The name of the DDDEF. If there is a problem locating\n                   the dataset that this DDDEF specifies an asterix will\n                   be placed beside the DDDEF name.\n DATASET           Dataset name or '<None>'\n VOLSER            Volume serial or '<None>'\n UNIT              Unit name or '<None>'\n ZONE              The SMP/E zone that contained this DDDEF\n STATUS            One of the following :\n                   'Ignored'\n                   'Dataset found on volume vvvvvv'\n                   '**Error** Dataset not found on volume vvvvvv'\n                   '**Error** Dataset not found in catalog'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DDDEFPT$": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x15\\x01\\x02 \\x7f\\x01\\x02 \\x7f\\tQ\\x00O\\x00O\\x00\\x00\\xc8\\xe4\\xd2\\xd9\\xc4\\xe2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-07-26T00:00:00", "modifydate": "2002-07-26T09:51:15", "lines": 79, "newlines": 79, "modlines": 0, "user": "HUKRDS"}, "text": " Check SMP/E DDDEF Entries - DDDEFPTH\n ------------------------------------\n\n Installation of DDDEFPTH\n ------------------------\n\n Place the DDDEFPTH load module into your load library. Source\n code for the DDDEFPTH is not available.\n\n Using DDDEFPTH\n --------------\n\n DDDEFPTH lists and verifies your DDDEF PATH entries in one or more      .\n zones.\n\n DDDEFPTH uses the GIMAPI callable service, so please ensure that your\n version of SMP/E supports this API.\n\n DDDEFPTH JCL\n ------------\n\n //STEP1  EXEC PGM=DDDEFPTH,PARM='ZONE=zone'\n //STEPLIB  DD DISP=SHR,DSN=your.load.library\n //SYSPRINT DD SYSOUT=*\n //SMPCSI   DD DISP=SHR,DSN=your.csi\n\n Explanation of DDDEFPTH JCL\n ---------------------------\n\n PARM Values\n -----------\n\n     ZONE=*           All zones are to be processed, including the\n                      GLOBAL zone.\n\n     ZONE=xxxx        Only DDDEF entries in zone 'xxxx' are to be\n                      processed.\n\n     ZONE=ALLTZONES   All known TARGET zones will be processed.\n\n     ZONE=ALLDZONES   All known DLIB zones will be processed.\n\n\n DDNames Used\n ------------\n\n     SYSPRINT Will contain the report produced by DDDEFPTH.\n     Required DCB : RECFM=FB, LRECL=133\n\n     SMPCSI specifies the name of the input SMP/E GLOBAL CSI\n\n\n Example Uses of DDDEFPTH\n ------------------------\n\n (a) Check zone MVST100 in SMPE.MVS.GLOBAL.CSI\n\n //EX1    EXEC PGM=DDDEFPTH,PARM='ZONE=MVST100'\n //SYSPRINT DD SYSOUT=*\n //SMPCSI   DD DISP=SHR,DSN=SMPE.MVS.GLOBAL.CSI\n\n (b) Check all TARGET zones in SMPE.MVS.GLOBAL.CSI\n\n //EX1    EXEC PGM=DDDEFPTH,PARM='ZONE=ALLTZONES'\n //SYSPRINT DD SYSOUT=*\n //SMPCSI   DD DISP=SHR,DSN=SMPE.MVS.GLOBAL.CSI\n\n Output produced by DDDEFPTH\n ---------------------------\n\n The program produces a tabular report will the following headings :\n\n DDDEF             The name of the DDDEF. If there is a problem locating\n                   the dataset that this DDDEF specifies an asterix will\n                   be placed beside the DDDEF name.\n ZONE              The SMP/E zone that contained this DDDEF\n PATH              The PATH name.\n STATUS            The status of the path.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DELNOEN$": {"ttr": 779, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99&_\\x00\\x99&_\\t\\x05\\x00\\x9c\\x00\\x9f\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-09-22T00:00:00", "modifydate": "1999-09-22T09:05:00", "lines": 156, "newlines": 159, "modlines": 0, "user": "FILE411"}, "text": " Delete Datasets Without the SYSDSN Enqueue\n ------------------------------------------\n\n Installation of DELNOENQ\n\n Assemble and link DELNOENQ into an APF authorised load library.\n Use the following linkedit attributes :\n\n    AMODE(24)\n    RMODE(24)\n    NORENT\n    NOREUS\n    NOREFR\n    AC(1)\n\n\n Additional thanks to Brian Pierce of IBM for the code updates that\n allow the DSN and VOL keywords to be supplied in any order and also\n handling the situation where the dataset in aliased to another name.\n\n\n Using DELNOENQ\n\n The DELNOENQ program runs as a batch job and deletes specified\n uncataloged datasets from DASD volumes. The datasets to be\n deleted are nominated via a series of SYSIN cards. To use the\n SYSDSN enqueue bypass facility, this program must be linked\n AC(1) and must be executed from an APF-authorised load library.\n\n SYSIN Card Syntax :\n\n      DSN=dataset_name,VOL=volser\n\n Keywords :\n\n      DSN=dataset_name\n        The name of the dataset to be deleted. This must be a fully\n        qualified dataset name (without quotes).\n\n      VOL=volser\n        The DASD volume serial that contains the dataset to be\n        deleted.\n\n Important Notes :\n\n (1)  The combination of dataset_name and volser must not match the\n      cataloged version of the dataset. DELNOENQ will only allow the\n      deletion of uncataloged datasets.\n (2)  Ensure that the dataset to be deleted is not in use on any other\n      MVS system. DELNOENQ cannot verify the usage of a dataset on\n      an external MVS system, but will attempt serialization as follows:\n\n      (a) A RESERVE is issued to the VTOC of the DASD volume on which the\n          dataset resides.\n      (b) An enqueue is issued to the major name of 'DELNOENQ' with a\n          minor name constructed of the DASD volume serial and dataset\n          name.\n\n (3)  DELNOENQ can be run non-authorized, but it will be without the\n      bypass SYSDSN enqueue facility.\n\n (4)  DELNOENQ will not delete a dataset if there is a cataloged version\n      on an SMS Volume. SMS would intercept the SCRATCH request and\n      deleted the cataloged version instead of the intended uncataloged\n      dataset.\n\n Example JCL:\n\n //DELDSNS  EXEC PGM=DELNOENQ\n //STEPLIB   DD DISP=SHR,DSN=your.apf.load.library\n //SYSPRINT  DD SYSOUT=*\n //SYSIN     DD *\n    DSN=SYS1.LINKLIB,VOL=OLDRES\n    DSN=SYS1.ISP.SISPLOAD,VOL=OLDISP\n /*\n\n\n Messages\n\n The following messages can be issued by DELNOENQ and are written to\n the SYSPRINT DDName.\n\n NONQ001E  Syntax error in input card - Return Code set to 12\n\n     There is a syntax error in the SYSIN card. Check that both the\n     DSN and VOL keywords are specified. This card is ignored and\n     processing continues to the next SYSIN card.\n\n NONQ002E  Volume vvvvvv not found - Return Code set to 12\n\n     The DASD volume 'vvvvvv' is not online to the MVS system.\n     This card is ignored and processing continues to the next\n     SYSIN card.\n\n NONQ003I  Dataset scratched from volume RC(00)\n\n     The dataset identified by message SSCR005I has been successfully\n     deleted.\n\n NONQ004E  Dataset not scratched RC(xx) RSN(yyyyyyyy) - Check DFP\n           Diagnosis Reference.\n\n     An error occurred in SCRATCH processing.\n     SCRATCH returned 'xx' and the return code and 'yyyyyyyy' as the\n     reason code.\n     Check the DFSMSdfp Diagnosis manual for an explanation of the\n     error.\n\n NONQ005I  Dataset Name : dddddddd\n\n     Informational message produced to indicate that DELNOENQ is\n     processing dataset 'dddddddd'.\n\n NONQ006I  Volume Serial : vvvvvv\n\n     Informational message produced to indicate that DELNOENQ is using\n     volser 'vvvvvv' for the dataset identified in the previous SSCR005I\n     message.\n\n NONQ007W  DELNOENQ is NOT APF Authorized\n\n     Warning that the DELNOENQ is not running APF authorized. The SYSDSN\n     enqueue bypass facility is disabled.\n\n NONQ008I  DELNOENQ is APF Authorized.\n\n     DELNOENQ is running APF authorized. The SYSDSN enqueue bypass\n     is available.\n\n NONQ009E  Dataset not found on volume - Return Code set to 12.\n\n     The dataset identified by message SSCR005I could not be found on\n     the DASD volume identified by message SSCR006I.\n     This card is ignored and processing continues with the next\n     SYSIN card.\n\n NONQ010E  Dataset specified is cataloged - Return Code set to 12.\n\n     The dataset identified by message SSCR005I has been found to be\n     cataloged on DASD volume identified by message SSCR006I. DELNOENQ\n     will not delete this dataset and processing continues with the\n     next SYSIN card.\n\n NONQ011E  Cataloged version of the dataset in on SMS volume - Return\n           Code set to 12.\n\n     DELNOENQ will not delete a dataset that has a cataloged version on\n     an SMS volume.\n\n NONQ012E  Cannot determine the SMS status of the cataloged version\n           of the dataset - Return Code set to 12.\n\n     DELNOENQ has failed in its attempt to test the SMS status of the\n     cataloged version of the dataset. In this instance, the uncataloged\n     dataset is not deleted.\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DELNOEN@": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99&o\\x00\\x99&o\\x112\\x00\\x19\\x00\\x13\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-09-23T00:00:00", "modifydate": "1999-09-23T11:32:00", "lines": 25, "newlines": 19, "modlines": 0, "user": "FILE411"}, "text": "//* ADD A JOBCARD\n//*\n//* (1) CHANGE 'SYS2.SEC.SRC' TO THIS DATASET NAME\n//* (2) CHANGE 'SYS2.SEC.LOAD' TO YOUR LOAD LIBRARY DATASET NAME\n//*\n//*\n//ASM  EXEC PGM=ASMA90\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DSN=SYS2.SEC.SRC(DELNOENQ),DISP=SHR\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(,PASS),UNIT=SYSALLDA,\n//         DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=3200),\n//         SPACE=(CYL,(2,1))\n//*\n//LINK EXEC PGM=HEWL,PARM='MAP,LET,LIST,XCAL',COND=(8,LT,ASM)\n//SYSLMOD  DD  DSN=SYS2.SEC.LOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE,DELETE)\n//         DD  *\n  ENTRY DELNOENQ\n  SETCODE AC(1)\n  NAME DELNOENQ(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DELNOENQ": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x99\\x18\\x9f\\x00\\x99\\x19?\\x13(\\x02\\xfd\\x02\\xc8\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1999-07-08T00:00:00", "modifydate": "1999-07-12T13:28:00", "lines": 765, "newlines": 712, "modlines": 0, "user": "FILE411"}, "text": "DELNOENQ TITLE 'PROGRAM TO SCRATCH A LIST OF DATASETS'\n*-------------------------------------------------------------------*\n* Name            : DELNOENQ\n*\n* Function        : Scratch a list of datasets with or without the\n*                   SYSDSN ENQ. The specified datasets MUST be\n*                   uncataloged.\n*                   Read a list of dataset names and volume serials\n*                   from the SYSIN DDName and create perform DADSM\n*                   SCRATCH processing on them.\n*                   If we are APF authorized, we set up SVC Screening\n*                   before issuing the SCRATCH request. If we are not\n*                   APF authorized, we just try and delete the dataset\n*                   normally.\n*\n*                   *WARNING**WARNING**WARNING*\n*                   Be very careful to ensure that the dataset(s) you\n*                   are deleting are NOT in use on ANY system.\n*                   *WARNING**WARNING**WARNING*\n*\n* IBM Macros      : MODID, STORAGE, MODESET, SCRATCH, CAMLST, OPEN,\n*                   TESTAUTH, PUT, GET, CLOSE, UCBSCAN, RESERVE,\n*                   ENQ, DEQ, TIME, OBTAIN, LOCATE,\n*                   CVT, IEFUCBOB, IEESMCA, IKJTCB\n*\n* Programs Called : none\n*\n* Attributes      : Amode(24)\n*                   Rmode(24)\n*                   NORENT\n*                   NOREUS\n*                   NOREFR\n*                   AC(1)\n*\n* Register Usage  :\n* r1  -\n* r2  - CVT/SMCA\n* r3  - TCB\n* r4  - SVC Screening Table\n* r5  - work\n* r6  - branch and count\n* r7  - work\n* r8  - UCB\n* r9  - Max RC\n* r10 - branch and link\n* r11 - 2nd base\n* r12 - base\n* r13 - work area\n*\n*-------------------------------------------------------------------*\n* Example\n*\n* //ERASE  EXEC PGM=DELNOENQ\n* //STEPLIB  DD DISP=SHR,DSN=some.auth.loadlib\n* //SYSPRINT DD SYSOUT=*\n* //SYSIN    DD *\n*   DSN=SOME.UNCATLG.DATASET,VOL=OEMVOL\n*   DSN=ANOTHER.DATASET,VOL=ANOVOL\n* /*\n*\n*-------------------------------------------------------------------*\n* Changes\n* 07/05/93  Rob Scott - Code written\n* 02/25/99  Brian Pierce - allow either order in input card\n*           handle situation where dsn is aliased to another name\n* 30/06/99  Rob Scott -  Change message prefix from SSCR to NONQ\n* 08/07/99  Rob Scott -  Disallow deletion when cataloged version of\n*           the dataset is on SMS volume. SMS will intercept the\n*           SCRATCH in this case and causes the cataloged version\n*           being deleted!\n* 12/07/99  Rob Scott -  Correct code that issues NONQ004E.\n*-------------------------------------------------------------------*\n*\n*-------------------------------------------------------------------*\n* Copyright : Scott Enterprise Consultancy Ltd\n*-------------------------------------------------------------------*\nDELNOENQ CSECT\nDELNOENQ AMODE 24\nDELNOENQ RMODE 24\n         BAKR  R14,R0                 Linkage stack\n         LR    R12,R15                Copy entry address to base\n         USING DELNOENQ,R12           Address it\n         LA    R11,4095(R12)          Establish 2nd base\n         LA    R11,1(R11)             ..4K on from R12\n         USING DELNOENQ+4096,R11      address it\n         MODID ,                      Eyecatcher\n         LR    R2,R1                  Copy parms passed\nGETSTOR  EQU   *\n*-------------------------------------------------------------------*\n* Get some workarea storage and init to hex zeros\n*-------------------------------------------------------------------*\n         STORAGE OBTAIN,              Get the workarea storage         X\n               LENGTH=WORKLEN,        This much                        X\n               ADDR=(R13),            Put address in R13               X\n               SP=0,KEY=8,            Subpool 0 Key 8                  X\n               LOC=BELOW,             Below the line                   X\n               COND=NO                Unconditional\n         USING WORKAREA,R13           Address workarea\n         LR    R14,R13                Copy workarea address\n         L     R15,=A(WORKLEN)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to zeros\n         LA    R13,SAVEAREA           Point to savearea\n         MVC   4(4,R13),=C'F1SA'      Set Acronym\n         XR    R9,R9                  Clear rc\nINITWORK EQU   *\n*-------------------------------------------------------------------*\n* Open the datasets and write the titles\n*-------------------------------------------------------------------*\n         OPEN  (SYSIN,(INPUT))        Open the SYSIN\n         OPEN  (SYSPRINT,(OUTPUT))    Open the SYSPRINT\n         MVC   OUTCARD,TITLE          Copy the title\n         L     R2,CVTPTR              Get the CVT\n         USING CVTMAP,R2              Address it\n         L     R3,0(R2)               Get the TCB words\n         L     R3,4(R3)               Get current TCB\n         USING TCB,R3                 address it\n         L     R2,CVTSMCA             Get the SMCA\n         USING SMCABASE,R2            Address it\n         MVC   OUTCARD+39(4),SMCASID  Copy System id to title\n         DROP  R2\n         TIME  DEC,TIMEOUT,           Get the time                     x\n               DATETYPE=DDMMYYYY,     English format                   X\n               LINKAGE=SYSTEM         No SVC\n         LA    R1,TIMEOUT             Point to HHMMSSth\n         LA    R0,4                   Set the length\n         LA    R15,UWORK              Point to output area\n         BAL   R10,HEX2CHAR           Make it printable\n         MVC   OUTCARD+73(2),UWORK    Copy in HH\n         MVC   OUTCARD+76(2),UWORK+2  Copy in MM\n         MVC   OUTCARD+79(2),UWORK+4  Copy in SS\n         LA    R1,TIMEOUT+8           Point to HHMMSSth\n         LA    R0,4                   Set the length\n         LA    R15,UWORK              Point to output area\n         BAL   R10,HEX2CHAR           Make it printable\n         MVC   OUTCARD+53(2),UWORK    Copy in DD\n         MVC   OUTCARD+56(2),UWORK+2  Copy in MM\n         MVC   OUTCARD+59(4),UWORK+4  Copy in YYYY\n         PUT   SYSPRINT,OUTCARD       Put out the title\n         PUT   SYSPRINT,BLANKS        Followed by blanks\n         MVI   AUTHFLAG,X'00'         Assume not authorised\n         TESTAUTH FCTN=1              Test APF auth\n         LTR   R15,R15                Well ?\n         BNZ   NOTAUTH                Not APF auth - leave flag alone\n         OI    AUTHFLAG,X'80'         Set flag\n         PUT   SYSPRINT,NONQ008I      Tell user\n*-------------------------------------------------------------------*\n* We are running APF authorized - this means that we can use SVC\n* screening to bypass ENQ/DEQ.\n*\n* (1) We need to load the SVC Screen Table into non-pageable common\n*     storage (Chosen subpool = 245).\n*\n* (2) The SVC Screen routine to get control for SVC 48 (X'30') and\n*     SVC 56 (x'38') is just an IEFBR14 lookalike. For conveniance\n*     this is tagged behind the SVC Screen table. The address of this\n*     routine is placed at the start of the SVC Screen Table.\n*\n* (3) The address of the SVC Screen Table is placed into TCBSVCA2.\n*     This is only used when the TCBSVCS bit is on (which we do in\n*     the REMOVEDS routine).\n*-------------------------------------------------------------------*\n         MODESET KEY=ZERO,MODE=SUP    Turn into supervisor\n         STORAGE OBTAIN,              Get the SVC Screen Table         X\n               LENGTH=SSTLEN,         This much                        X\n               ADDR=(R4),             Put address in R4                X\n               SP=245,KEY=0,          Subpool 245 Key 0                X\n               LOC=BELOW,             Below the line                   X\n               COND=NO                Unconditional\n         ST    R4,@SVCSCR             Store address of SVC Screen table\n         L     R5,=A(SSTLEN)          Get the length\n         LA    R14,SSTSVCN            Point to the SVC Screen Model\n         LR    R15,R5                 Copy the length\n         MVCL  R4,R14                 Prime the SVC Screen Table\n         L     R4,@SVCSCR             Re-load address\n         LA    R15,SSTPGM-SSTSVCN(R4) Point to recovery program\n         STCM  R15,B'1111',0(R4)      Store in SVC Screen Table\n         STCM  R4,B'1111',TCBSVCA2    Store SVC Screen Table in TCB\n         MODESET KEY=NZERO,MODE=PROB  Turn into problem\n         B     READCARD\nNOTAUTH  EQU   *\n         PUT   SYSPRINT,NONQ007W      Issue non-auth warning\n         PUT   SYSPRINT,BLANKS        Blank line\nREADCARD EQU   *\n*-------------------------------------------------------------------*\n* Read a card from the SYSIN dataset\n*-------------------------------------------------------------------*\n         GET   SYSIN,INCARD           Read a SYSIN card\n         MVC   OUTCARD(133),BLANKS    Blank the output card\n         MVC   OUTCARD+1(72),INCARD   Copy the input card\n         PUT   SYSPRINT,OUTCARD       Write it out\n         PUT   SYSPRINT,BLANKS        Blank line\n*-------------------------------------------------------------------*\n* Parse the card to see if it contains both DSN= and VOL= keywords\n*-------------------------------------------------------------------*\n         BAL   R10,PARSECRD           Parse the card\n         LTR   R15,R15                Got a valid card ?\n         BE    GOODCARD               Yes - process it\n*-------------------------------------------------------------------*\n* Invalid card - tell user and ignore it\n*-------------------------------------------------------------------*\n         PUT   SYSPRINT,NONQ001E      No - tell user\n         PUT   SYSPRINT,BLANKS        Blank line\n         LA    R9,12                  Set maxrc\n         B     NEXTCARD               read next card\nGOODCARD EQU   *\n*-------------------------------------------------------------------*\n* We have the required keywords and data.\n* Tell user what we have extracted from the SYSIN card and then\n* verify that the volume exists.\n*-------------------------------------------------------------------*\n         MVC   OUTCARD(133),NONQ005I  Copy the dataset message\n         MVC   OUTCARD+28(44),DATASET Copy the dataset name\n         PUT   SYSPRINT,OUTCARD       Tell user\n         MVC   OUTCARD(133),NONQ006I  Copy the volume message\n         MVC   OUTCARD+28(6),VOLSER   Copy the volser\n         PUT   SYSPRINT,OUTCARD       Tell user\n         XC    UCBAREA,UCBAREA        Clear the UCB area\n         XC    UCBWORK,UCBWORK        Clear the UCB work area\n         LA    R8,UCBAREA             Point to the UCB\n         USING UCBCMSEG,R8            Address it\n         UCBSCAN COPY,                Find the volume serial UCB       x\n               WORKAREA=UCBWORK,      Use this workarea                x\n               UCBAREA=UCBAREA,       Store UCB copy here              x\n               VOLSER=VOLSER,         Match this volser                x\n               DEVN=0,                Start at zero                    x\n               RANGE=ALL,             All of them                      x\n               DYNAMIC=YES,           Include Dynamic                  x\n               DEVCLASS=DASD          Its DASD\n         LTR   R15,R15                Found it ?\n         BZ    GOODUCB                Yes - OK\n*-------------------------------------------------------------------*\n* Volume serial could not be found - tell user and ignore card\n*-------------------------------------------------------------------*\n         MVC   OUTCARD(133),NONQ002E  No - tell user\n         MVC   OUTCARD+19(6),VOLSER   Copy the volume serial\n         PUT   SYSPRINT,OUTCARD       Tell user\n         PUT   SYSPRINT,BLANKS        Blank line\n         LA    R9,12                  Set maxrc\n         B     NEXTCARD               Read next card\nGOODUCB  EQU   *\n*-------------------------------------------------------------------*\n* UCB is validated. We now check that the dataset is on the volume\n* and is uncataloged.\n*-------------------------------------------------------------------*\n         BAL   R10,CHECKDSN           Check the dataset\n         LTR   R15,R15                Check the rc\n         BZ    GOODDSN                if OK - scratch dataset\n         C     R15,=F'4'              dataset not on volume ?\n         BH    BADCATLG               no - check next\n*-------------------------------------------------------------------*\n* Dataset not on volume - tell user and set rc=12\n*-------------------------------------------------------------------*\n         PUT   SYSPRINT,NONQ009E      Tell user\n         PUT   SYSPRINT,BLANKS        Blank line\n         LA    R9,12                  Set maxrc\n         B     NEXTCARD               Read next card\nBADCATLG EQU   *\n         C     R15,=F'8'              cataloged dataset ?\n         BH    BADCTVOL               no - check next\n*-------------------------------------------------------------------*\n* Dataset is cataloged - tell user and set rc=12\n*-------------------------------------------------------------------*\n         PUT   SYSPRINT,NONQ010E      Tell user\n         PUT   SYSPRINT,BLANKS        Blank line\n         LA    R9,12                  Set maxrc\n         B     NEXTCARD               Read next card\nBADCTVOL EQU   *\n         C     R15,=F'12'             canniot determine SMS status?\n         BH    BADSMS                 no - check next\n*-------------------------------------------------------------------*\n* Cannot determine the SMS status of the cataloged dataset\n*-------------------------------------------------------------------*\n         PUT   SYSPRINT,NONQ012E      Tell user\n         PUT   SYSPRINT,BLANKS        Blank line\n         LA    R9,12                  Set maxrc\n         B     NEXTCARD               Read next card\nBADSMS   EQU   *\n*-------------------------------------------------------------------*\n* Cataloged version of the dataset is on SMS volume\n*-------------------------------------------------------------------*\n         PUT   SYSPRINT,NONQ011E      Tell user\n         PUT   SYSPRINT,BLANKS        Blank line\n         LA    R9,12                  Set maxrc\n         B     NEXTCARD               Read next card\nGOODDSN  EQU   *\n*-------------------------------------------------------------------*\n* Volume serial and dataset OK, copy the UCB Type into the SCRATCH\n* parameter list and then SCRATCH the dataset.\n*-------------------------------------------------------------------*\n         MVC   SYSVOL(6),VOLSER       Copy the volser\n         MVC   VOLCUA(2),UCBCHAN      Copy the device number for later\n         MVC   VOLUCBT(4),UCBTYP      Copy the UCB type\n         BAL   R10,REMOVEDS           Remove the dataset\n         CLC   SCRRC,=F'0'            Did it work ?\n         BE    GOODRC                 Yes - tell user\nBADRC    EQU   *\n*-------------------------------------------------------------------*\n* Bad Return Code from SCRATCH - tell user and get next card\n*-------------------------------------------------------------------*\n         MVC   OUTCARD(133),NONQ004E  Get the message\n         LA    R1,SCRRC               Point to the message\n         LA    R0,4                   Set the length\n         LA    R15,UWORK              Point to the output field\n         BAL   R10,HEX2CHAR           Make it printable\n         MVC   OUTCARD+37(2),UWORK+6  Print the RC\n         LA    R1,SCRRSN              Point to the message\n         LA    R0,4                   Set the length\n         LA    R15,UWORK              Point to the output field\n         BAL   R10,HEX2CHAR           Make it printable\n         MVC   OUTCARD+45(8),UWORK    Print the RC\n         PUT   SYSPRINT,OUTCARD       Tell the user\n         PUT   SYSPRINT,BLANKS        Blank line\n         C     R9,SCRRC               Is > maxcc\n         BH    NEXTCARD               No - carry on\n         L     R9,SCRRC               Yes - copy Return Code\n         B     NEXTCARD               Get next card\nGOODRC   EQU   *\n*-------------------------------------------------------------------*\n* Good Return Code from SCRATCH - tell user and get next card\n*-------------------------------------------------------------------*\n         PUT   SYSPRINT,NONQ003I      Tell user\n         PUT   SYSPRINT,BLANKS        Blank line\nNEXTCARD EQU   *\n         B     READCARD               Read next card\n*\nENDSYSIN EQU   *\n*-------------------------------------------------------------------*\n* We have finished reading the SYSIN cards - tidy up the SVC\n* Screening table (if used) and exit.\n*-------------------------------------------------------------------*\n         CLOSE (SYSIN)                Close the SYSIN\n         CLOSE (SYSPRINT)             Close the SYSPRINT\n         TM    AUTHFLAG,X'80'         Are we APF auth ?\n         BNO   RETURN00               No - ignore SVC Screen Table free\n         MODESET KEY=ZERO,MODE=SUP    Turn into supervisor\n         MVC   TCBSVCA2,=F'0'         Zero SVC Screen table address\n         STORAGE RELEASE,             Free the SVC Screen Table        X\n               LENGTH=SSTLEN,         This much                        X\n               ADDR=(R4),             Address in R4                    X\n               SP=245,KEY=0,          Subpool 245 Key 0                X\n               COND=NO                Unconditional\n         MODESET KEY=NZERO,MODE=PROB  Turn into problem\nRETURN00 EQU   *\n         BAL   R10,FREESTOR           Free the workarea\n         LR    R15,R9                 Set RC to maxrc\n         PR\n*\n*--------------------------------------------------------------------*\n* General Routines\n*--------------------------------------------------------------------*\n*\nCHECKDSN EQU   *\n*--------------------------------------------------------------------*\n* Check the dataset name and volser against the following criteria :\n* (1) Dataset Exists on the volume\n* (2) Dataset to be deleted is not cataloged\n* (3) Cataloged version of the dataset is not SMS managed\n*\n* Return Code : 0 - Dataset has been verified\n*               4 - Dataset not on volume\n*               8 - Dataset is cataloged\n*              12 - Volume cataloged dataset resides upon not found\n*              16 - Cataloged dataset is on SMS-volume\n*--------------------------------------------------------------------*\n         LA    R7,4                   Assume rc=4\n         MVC   OBTCAM(OBTL),OBTMODEL  Move in model macro\n         LA    R1,DATASET             Point to dataset name\n         ST    R1,OBTCAM+4            Store in parmlist\n         LA    R1,VOLSER              Point to volser\n         ST    R1,OBTCAM+8            Store in parmlist\n         LA    R1,CAMLSTWA            Point to workarea\n         ST    R1,OBTCAM+12           Store in parmlist\n         OBTAIN OBTCAM                Try to get the F1-DSCB\n         LTR   R15,R15                Is dataset on the volume\n         BNZ   CHECKRET               No - tell caller\n         LA    R7,8                   Assume rc=8\n         MVC   LOCCAM(LOCL),LOCMODEL  Move in model macro\n         MVC   LOCDSN,DATASET         Move dataset name to locate WORK\n         LA    R1,LOCDSN              Point to dataset name\n         ST    R1,LOCCAM+4            Store in parmlist\n         LA    R1,CAMLSTWA            Point to workarea\n         ST    R1,LOCCAM+12           Store in parmlist\n         LOCATE LOCCAM                Is dataset cataloged ?\n         LTR   R15,R15                find it\n         BNZ   CHECK00                no\n         CLC   CAMLSTWA+6(6),VOLSER   Compare volser (if any)\n         BE    CHECKRET               Dataset is catloged - error\n         LA    R7,12                  Assume rc = 12\n         LA    R5,TEMPUCB             Point to the UCB\n         UCBSCAN COPY,                Find the volume serial UCB       x\n               WORKAREA=TEMPWORK,     Use this workarea                x\n               UCBAREA=TEMPUCB,       Store UCB copy here              x\n               VOLSER=CAMLSTWA+6,     Match the catalog volser         x\n               DEVN=0,                Start at zero                    x\n               RANGE=ALL,             All of them                      x\n               DYNAMIC=YES,           Include Dynamic                  x\n               DEVCLASS=DASD          Its DASD\n         LTR   R15,R15                Found it ?\n         BZ    CHECKSMS               Yes - check SMS status\n         B     CHECKRET               No - tell user\nCHECKSMS EQU   *\n         LA    R7,16                  Assume rc=16\n         TM    UCBFL5-UCBCMSEG(R5),UCBSMS\n         BO    CHECKRET               Is it SMS ?\nCHECK00  XR    R7,R7                  Clear rc\nCHECKRET EQU   *\n         LR    R15,R7                 Copy rc\n         BR    R10                    Return\n*\nPARSECRD EQU   *\n*--------------------------------------------------------------------*\n* Get the dataset name and volser from the card\n* Card format :\n*\n*   DSN=<dataset-name>,VOL=<volser>\n*   VOL=<volser>,DSN=<dataset-name>\n*\n* Return Code : 0 - Got both DATASET and VOLSER\n*               8 - Error in card\n*--------------------------------------------------------------------*\n         MVC   DATASET(44),BLANKS     Clear the dataset name\n         MVC   VOLSER(6),BLANKS       Clear the volume serial\n         LA    R1,INCARD              Point to the input card\n         LA    R6,71                  Set max loop count\n         XR    R15,R15                Zero rc\nFINDDSN  EQU   *\n         CLC   0(4,R1),=C'DSN='       Is it DSN= ?\n         BE    GOTDSN                 Yes - found dsn\n         LA    R1,1(R1)               No - get next byte\n         BCT   R6,FINDDSN             Loop for all chars\n         LA    R15,8                  Set rc\n         BR    R10\nGOTDSN   EQU   *\n         LA    R7,DATASET             Point to dataset name\n         LA    R1,4(R1)               Point to start of dataset\n         S     R6,=F'4'               Adjust branch and count\nISDSNE   EQU   *\n         CLI   0(R1),C','             End of dataset name ?\n         BE    ENDDSN                 Yes\n         CLI   0(R1),C' '             End of dataset name ?\n         BE    ENDDSN                 Yes\n         MVC   0(1,R7),0(R1)          Copy the dataset name byte\n         LA    R7,1(R7)               Update pointer\n         LA    R1,1(R1)               Get next input byte\n         BCT   R6,ISDSNE              loop thru dataset name\n         LA    R15,8                  Set rc\n         BR    R10                    go to return/error\nENDDSN   EQU   *\n         LA    R1,INCARD              Point to the input card again\n         LA    R6,71                  Set max loop count\nFINDVOL  EQU   *                      Now locate the VOL=\n         CLC   0(4,R1),=C'VOL='       Is it VOL= ?\n         BE    GOTVOL                 Yes - found vol\n         LA    R1,1(R1)               No - get next byte\n         BCT   R6,FINDVOL             Loop for all chars\n         LA    R15,8                  Set rc\n         BR    R10\nGOTVOL   EQU   *\n         LA    R7,VOLSER              Point to volser\n         LA    R1,4(R1)               Point to start of dataset\n         S     R6,=F'4'               Adjust branch and count\nISVOLE   EQU   *\n         CLI   0(R1),C','             End of volser?\n         BE    ENDVOL                 Yes\n         CLI   0(R1),C' '             End of volser?\n         BE    ENDVOL                 Yes\n         MVC   0(1,R7),0(R1)          Copy the volser byte\n         LA    R7,1(R7)               Update pointer\n         LA    R1,1(R1)               Get next input byte\n         BCT   R6,ISVOLE              loop thru volser\n         LA    R15,8                  Set rc\n         BR    R10                    go to return\nENDVOL   EQU   *\n         XR    R15,R15                Zero rc\n         BR    R10\n*\nREMOVEDS EQU   *\n*        BR    R10  ********* FOR TESTING, COMMENT OUT for REAL *****\n*--------------------------------------------------------------------*\n* Remove the dataset\n*\n* Dynamically create the SCRATCH parm list in the workarea and plug\n* in the address of the dataset name and volume entry.\n*\n* If the program is running without APF authorization we skip the\n* next bit ...\n*\n* First of all, we get the ACTUAL UCB address for the dataset's\n* volume so that we can issue the RESERVE on the VTOC. We do this\n* because SCRATCH will be SVC screened to ENQ/RESERVE. We then ENQ\n* the dataset to a major of 'DELNOENQ' and a minor that is made up\n* of the volume followed by the dataset name.\n*\n* We flip the TCBSVCS flag in TCBFLGS7 in the TCB to indicate that\n* SVC Screening is enabled for this task. The TCBSVCA2 field has\n* previously been populated by the address of the SVC Screen table.\n*--------------------------------------------------------------------*\n         MVC   SCRCAM(SCRL),SCRMODEL  Copy the model scratch macro\n         MVC   VOLENT(2),=H'1'        Indicate 1 volser\n         MVC   VOLSTAT(2),=H'0'       Zero status bytes\n         LA    R1,DATASET             Point to the dataset name\n         STCM  R1,B'1111',SCRCAM+4    Store in SCRATCH parm list\n         LA    R1,VOLENT              Point to the volume entry\n         STCM  R1,B'1111',SCRCAM+12   Store in SCRATCH parm list\n         TM    AUTHFLAG,X'80'         Are we APF auth ?\n         BNO   ERASE                  No - bypass authorised bit\n*--------------------------------------------------------------------*\n* Get the actual UCB address for RESERVE. The binary device number\n* used from the earlier UCBSCAN COPY.\n*--------------------------------------------------------------------*\n         MODESET KEY=ZERO,MODE=SUP    Turn into supervisor\n         XC    UCBWORK,UCBWORK        Clear the UCB work area\n         UCBSCAN ADDRESS,             Find the volume serial UCB       x\n               WORKAREA=UCBWORK,      Use this workarea                x\n               UCBPTR=@UCB,           Store UCB address here           x\n               DEVN=VOLCUA,           For the stored dev number        x\n               LOC=ANY,               Anywhere in storage              x\n               NOPIN,                 Do not pin it                    x\n               RANGE=ALL,             All of them                      x\n               DYNAMIC=YES,           Include Dynamic                  x\n               DEVCLASS=DASD          Its DASD\n         LTR   R15,R15                Have we got it ?\n         BZ    ENQVTOC                Yes - no enqueue it\n         ABEND 987,DUMP               No - abend (should not happen)\nENQVTOC  EQU   *\n*--------------------------------------------------------------------*\n* Issue the RESERVE on the VTOC for the volume and enq the dataset\n* and volume to the DELNOENQ major name.\n*--------------------------------------------------------------------*\n         LA    R7,SYSVOL              Point to the volser\n         RESERVE (SYSVTOC,(R7),E,6,SYSTEMS),                           X\n               UCB=@UCB\n         ENQ   (MAJOR,(R7),E,50,SYSTEMS)\n         OI    TCBFLGS7,TCBSVCS       Indicate SVC Screening\nERASE    EQU   *\n         XR    R0,R0                  Clear R0\n         SCRATCH SCRCAM               Scratch the dataset\n         STCM  R0,B'1111',SCRRSN      Store the reason code\n         STCM  R15,B'1111',SCRRC      Store the Return Code\n         TM    AUTHFLAG,X'80'         Are we APF auth ?\n         BNO   DONESCR                No - bypass authorised bit\n*--------------------------------------------------------------------*\n* Turn off SVC Screening and DEQ the dataset and SYSVTOC RESERVE.\n*--------------------------------------------------------------------*\n         NI    TCBFLGS7,255-TCBSVCS   Turn off SVC Screening\n         DEQ   (MAJOR,(R7),50,SYSTEMS)\n         DEQ   (SYSVTOC,(R7),6,SYSTEMS)\n*--------------------------------------------------------------------*\n* SCRATCH sets the TCBFJMC bit (Step-Must-Complete). The STATUS macro\n* is required to reset it. As we have issued the RESERVE on the VTOC\n* outside of the SVC Screening it is OK to do this.\n*--------------------------------------------------------------------*\n         STATUS RESET,MC,STEP         Ensure SMC is off\n         MODESET KEY=NZERO,MODE=PROB  Turn back into problem state\nDONESCR  EQU   *\n         BR    R10\n*\nHEX2CHAR EQU   *\n*--------------------------------------------------------------------*\n* Convert a hex string to EBCDIC\n* Registers on entry :\n* R0 - Length of input hex bytes\n* R1 - Input hex bytes\n* R15- Output EBCDIC area\n*\n* R14 is used as a work register\n*\n*--------------------------------------------------------------------*\nLEFTHALF EQU   *\n         XR    R14,R14                Clear\n         ICM   R14,B'0001',0(R1)      Load up a byte (000000ab)\n         SRL   R14,4                  Remove last 4 bits (0000000a)\nLEFTNUM  EQU   *\n         CH    R14,=H'9'              00000000 - 00000009 ?\n         BH    LEFTLTTR               higher - must be A-F\n         AH    R14,=H'240'            xlate to F0-F9\n         B     LEFTDONE\nLEFTLTTR EQU   *\n         AH    R14,=H'183'            xlate to C1-C6\nLEFTDONE EQU   *\n         STCM  R14,B'0001',0(R15)     Store in output field\n         LA    R15,1(R15)             Point to next char\nRGHTHALF EQU   *\n         XR    R14,R14                Clear\n         ICM   R14,B'0001',0(R1)      Load up a byte (000000ab)\n         SLL   R14,28                 Remove first 4 bits (b0000000)\n         SRL   R14,28                 and reset           (0000000b)\nRGHTNUM  EQU   *\n         CH    R14,=H'9'              00000000 - 00000009 ?\n         BH    RGHTLTTR               higher - must be A-F\n         AH    R14,=H'240'            xlate to F0-F9\n         B     RGHTDONE\nRGHTLTTR EQU   *\n         AH    R14,=H'183'            xlate to C1-C6\nRGHTDONE EQU   *\n         STCM  R14,B'0001',0(R15)     Store in output area\n         LA    R15,1(R15)             Point to next char\n         LA    R1,1(R1)               Point to next input byte\n         BCT   R0,LEFTHALF            Loop for all bytes\n         BR    R10                    return\n*\nFREESTOR EQU   *\n*--------------------------------------------------------------------*\n* Free workarea storage\n*--------------------------------------------------------------------*\n         STORAGE RELEASE,             Release workarea storage         X\n               LENGTH=WORKLEN,        This much                        X\n               ADDR=(R13),            Use address in R13               X\n               SP=0,KEY=8,            Subpool 0 key 8                  X\n               COND=NO                Unconditional\n         BR    R10\n*\n*--------------------------------------------------------------------*\n* Constants, Variables and DSECTs\n*--------------------------------------------------------------------*\n         LTORG\n*\nSYSIN    DCB   DDNAME=SYSIN,          DD Name                          x\n               DSORG=PS,              Sequential                       x\n               MACRF=GM,              Input                            x\n               RECFM=FB,              Variable block                   x\n               LRECL=80,              Max LRECL                        x\n               EODAD=ENDSYSIN         End-of-data branch\n*\nSYSPRINT DCB   DDNAME=SYSPRINT,       DD Name                          x\n               DSORG=PS,              Sequential                       x\n               MACRF=PM,              Output                           x\n               RECFM=FBA,             Fixed block                      x\n               LRECL=133              Max LRECL\n*\n         DS    0F\nDUMMY    DC    F'0'\n@UCB     DC    F'0'                   UCB Address\nSYSVTOC  DC    CL8'SYSVTOC'           Major name for RESERVE\nMAJOR    DC    CL8'DELNOENQ'          Major name for DELNOENQ\nBLANKS   DC    CL133' '               Blanks\n*\nSCRMODEL CAMLST SCRATCH,DUMMY,,DUMMY,,OVRD\nSCRL     EQU   *-SCRMODEL             Length of SCRATCH\nLOCMODEL CAMLST NAME,DUMMY,,DUMMY\nLOCL     EQU   *-LOCMODEL             Length of LOCATE\nOBTMODEL CAMLST SEARCH,DUMMY,DUMMY,DUMMY\nOBTL     EQU   *-OBTMODEL             Length of OBTAIN\n*\n*--------------------------------------------------------------------\n* SVC Screening Table\n*--------------------------------------------------------------------\nSSTSVCN  DC    A(SSTPGM)              Address of error routine\n         DC    X'80'                  Emulate type-2 SVC\n         DC    X'00'                  AR mode not allowed\n         DC    X'0000'                No locks\nSSTMASK  DS    0C\n*--------------------------------------------------------------------\n* SVC Screen Mask Table\n* Entries marked x'80' allow the SVC to be executed, those marked\n* x'00' cause control to be passed to SSTPGM.\n*--------------------------------------------------------------------\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    XL16'80808080808080808080808080808080'  SVC 00 - 0F\n         DC    XL16'80808080808080808080808080808080'  SVC 10 - 1F\n         DC    XL16'80808080808080808080808080808080'  SVC 20 - 2F\n         DC    XL16'00808080808080800080808080808080'  SVC 30 - 3F\n         DC    XL16'80808080808080808080808080808080'  SVC 40 - 4F\n         DC    XL16'80808080808080808080808080808080'  SVC 50 - 5F\n         DC    XL16'80808080808080808080808080808080'  SVC 60 - 6F\n         DC    XL16'80808080808080808080808080808080'  SVC 70 - 7F\n         DC    XL16'80808080808080808080808080808080'  SVC 80 - 8F\n         DC    XL16'80808080808080808080808080808080'  SVC 90 - 9F\n         DC    XL16'80808080808080808080808080808080'  SVC A0 - AF\n         DC    XL16'80808080808080808080808080808080'  SVC B0 - BF\n         DC    XL16'80808080808080808080808080808080'  SVC C0 - CF\n         DC    XL16'80808080808080808080808080808080'  SVC D0 - DF\n         DC    XL16'80808080808080808080808080808080'  SVC E0 - EF\n         DC    XL16'80808080808080808080808080808080'  SVC F0 - FF\n*                   0 1 2 3 4 5 6 7 8 9 A B C D E F\n*--------------------------------------------------------------------\n* SVC Screen Recovery Routine\n*--------------------------------------------------------------------\nSSTPGM   DC    X'17FF'                Asm code for 'XR R15,R15'\n         DC    X'07FE'                Asm code for 'BR R14'\nSSTLEN   EQU   *-SSTSVCN              Length of storage required\n*\n*\n*\nTITLE    DC    CL133'1 DELNOENQ Version 2.3        System : ssss   Datex\n                : dd/mm/yyyy   Time : hh:mm:ss'\nNONQ001E DC    CL133'  NONQ001E  Syntax error in input card - Return CoX\n               de set to 12'\nNONQ002E DC    CL133'  NONQ002E  Volume xxxxxx not found - Return Code x\n               set to 12'\nNONQ003I DC    CL133'  NONQ003I  Dataset scratched from volume RC(00)'\nNONQ004E DC    CL133'  NONQ004E  Dataset not scratched RC(00) RSN(00000x\n               000) - Check DFP Diagnosis Reference'\nNONQ005I DC    CL133'  NONQ005I  Dataset Name  : '\nNONQ006I DC    CL133'  NONQ006I  Volume Serial : '\nNONQ007W DC    CL133'  NONQ007W  DELNOENQ is NOT APF Authorized'\nNONQ008I DC    CL133'  NONQ008I  DELNOENQ is APF Authorized'\nNONQ009E DC    CL133'  NONQ009E  Dataset not found on volume - Return Cx\n               ode set to 12'\nNONQ010E DC    CL133'  NONQ010E  Dataset specified is cataloged - Returx\n               n Code set to 12'\nNONQ011E DC    CL133'  NONQ011E  Cataloged version of the dataset is onx\n                SMS volume - Return Code set to 12'\nNONQ012E DC    CL133'  NONQ012E  Cannot determine SMS status of the catx\n               aloged version of the dataset - Return Code set to 12'\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                    SaveArea\n@SVCSCR  DS    F                      SVC Screen Table Address\nAUTHFLAG DS    X                      APF auth flag\n         DS    0F\nUWORK    DS    CL8                    work area\nTIMEOUT  DS    CL16                   Output from time\nSYSVOL   DC    CL6' '                 Volser to be RESERVEd\nLOCDSN   DS    CL44                   Datset Name\nDATASET  DS    CL44                   Datset Name\n         DS    0F\nVOLENT   DS    H                      Number of Volume entries\nVOLUCBT  DS    CL4                    UCB Type\nVOLSER   DS    CL6                    Volume serial\nVOLSTAT  DS    H                      Status byte\nVOLCUA   DS    H                      Device address\nINCARD   DS    CL80                   Input card\nOUTCARD  DS    CL133                  Output message\n         DS    0F\nSCRCAM   DS    CL(SCRL)               Area for SCRATCH\n         DS    0F\nLOCCAM   DS    CL(LOCL)               Area for LOCATE\n         DS    0F\nOBTCAM   DS    CL(OBTL)               Area for OBTAIN\n         DS    0F\nSCRRC    DS    F                      SCRATCH rc\nSCRRSN   DS    F                      SCRATCH rsn\nTEMPUCB  DS    CL48                   Area for TEMP UCB copy\nUCBAREA  DS    CL48                   Area for UCB copy\nTEMPWORK DS    CL100                  UCBSCAN temp work area\nUCBWORK  DS    CL100                  UCBSCAN work area\n         DS    0D\nCAMLSTWA DS    CL265                  Work area for CAMLST macros\nWORKLEN  EQU   *-WORKAREA\n*\n         CVT   DSECT=YES,LIST=NO\n         IEESMCA\n         IEFUCBOB\n         IKJTCB\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   DELNOENQ\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEFACTR$": {"ttr": 1284, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99&_\\x00\\x99&_\\t(\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-22T00:00:00", "modifydate": "1999-09-22T09:28:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "FILE411"}, "text": " A Sample Step Termination Exit - IEFACTRT\n -----------------------------------------\n\n Installation of IEFACTRT\n\n Assemble and link IEFACTRT into SYS1.LPALIB (this is\n normally performed using an SMP/E USERMOD). For further\n information see the MVS Installation Exits manual.\n\n Usage Notes\n\n The supplied source processes SMF Type 30 records and produces\n information messages for started tasks and batch jobs. The messages\n are produced in two places :\n\n JESMSGLG via a WTO instruction\n   A one line summary of the jobstep activity including return code,\n   CPU times (TCB and SRB), service units, elapsed time,  step and\n   procstep names.\n\n\n JESYSMSG via a call to IEFYS\n   A more detailed summary including all of the information written by\n   to the JESMSGLG dataset and a summary of I/O counts for each DDName\n   accessed during the jobstep.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IEFACTRT": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00S\\x01\\x00\\x03?\\x01\\x01\\x17\\x1f\\x16\\x19\\x040\\x03\\x88\\x040\\xc8\\xe4\\xd2\\xd9\\xc4\\xe2@@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "2000-02-02T00:00:00", "modifydate": "2001-06-20T16:19:53", "lines": 1072, "newlines": 904, "modlines": 1072, "user": "HUKRDS"}, "text": "IEFACTRT TITLE 'STEP TERMINATION EXIT ROUTINE'\n*---------------------------------------------------------------------*\n* Function\n*\n* IEFACTRT provides Step and Job Statistic Messages that are written\n* to the JES2 Job log via a WTO and also to the JESYSMSG dataset by\n* invoking IEFYS.\n*\n* This exit is coded to use the type 30 records and associated\n* subtypes to get information for the step termination messages.\n* On entry Register 0 contains an indicator to which record type\n* the exit has been passed. an value of 20 (x'1E') in R0 indicates\n* a type 30 SMF record has been passed to this exit. The record\n* subtypes available for type 30 records are :\n*\n* subtype 01 : Job start\n* subtype 02 : Interval\n* subtype 03 : Step termination\n* subtype 04 : Step total\n* subtype 05 : Job termination\n* subtype 06 : System address space\n*\n* The exit processes the subtypes 4 and 5 to produce the messages.\n*\n*---------------------------------------------------------------------*\n* Attributes\n*\n* AMODE(31)\n* RMODE(ANY)\n* RENT\n* REUS\n* AC(0)\n*\n*---------------------------------------------------------------------*\n* IBM Macros\n*\n* GETMAIN, TIME, FREEMAIN, WTO, IFASMFR\n*\n*---------------------------------------------------------------------*\n* Register Usage\n*\n* R1    - Parameter List\n* R2    - SMF Record Base Address\n* R3    - SMF Record SECTION\n* R4    - Message to be written (WTO)\n* R5    - CEPA\n* R6    - Work Register\n* R7    - Work Register\n* R8    - Branch and Link\n* R9    - Message to be written (IEFYS)\n* R10   - Entry reason code\n* R11   - Base Register\n* R12   - Used by IEFYS\n* R13   - Workarea\n*\n*---------------------------------------------------------------------*\n* Changes\n*\n* 17/02/1991  Rob Scott    Code written\n* 22/06/2000  Rob Scott    Added storage values and changed IEFYS\n*                          messages to 80-bytes\n* 20/06/2001  Rob Scott    Cater for increased EXCP section length\n*                          in OS/390 R10+\n*---------------------------------------------------------------------*\nIEFACTRT CSECT\nIEFACTRT AMODE 31\nIEFACTRT RMODE ANY\n         BAKR  R14,R0                   Linkage stack\n         LR    R11,R15                  Get entry point\n         USING IEFACTRT,R11             Establish base reg\n         LR    R10,R0                   Save reason code\n         LR    R5,R1                    Save parameter list address\n         USING PARMLIST,R5              Address it\n         C     R10,=F'20'               SMF type30 record ?\n         BNE   RETURN00                 No - quick exit\n         B     SUBTYPES                 Yes - check subtypes\nRETURN00 EQU   *                        Ho back rc=0\n         XR    R15,R15                  Zero R15\n         PR\n*\nSUBTYPES EQU   *\n*---------------------------------------------------------------------*\n*  Check sub-system for batch and STC only\n*---------------------------------------------------------------------*\n         L     R2,SUBSYS                Get the sub-system address\n         CLC   0(4,R2),=C'STC '         Is it STC ?\n         BE    VALID                    Yes - valid\n         CLC   0(4,R2),=C'JES2'         Is it batch ?\n         BE    VALID                    Yes - valid\n         B     RETURN00                 No - quick exit\nVALID    EQU   *\n*---------------------------------------------------------------------*\n*  Check SMF30 sub-type records\n*---------------------------------------------------------------------*\n         L     R2,SMFRDW                Get addr SMF record type 30\n         USING SMFRCD30,R2              Address it\n         CLI   SMF30UON+1,K1            Is it a continuation record ?\n         BL    RETURN00                 Yes - quick exit\n         CLC   SMF30STP(2),=X'0004'     Is it step termination subtype?\n         BE    STEPTERM                 Yes - process it\n         CLC   SMF30STP(2),=X'0005'     Is it job termination subtype ?\n         BE    JOBTERM                  Yes - process it\n         B     RETURN00                 Otherwise exit\n*\nSTEPTERM EQU   *                        SMF type 30-4\n*---------------------------------------------------------------------*\n*  Process SMF30-4 records to produce WTO and IEFYS messages\n*\n*  First task is to produce to WTO message. During the processing to\n*  capture the values for this message, we save away things like the\n*  program and stepname so that we can write the IEFYS messages\n*  later without having to re-establish addressability to the\n*  various DSECTs within the record.\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30IOF              Get id section\n         USING SMF30ID,R3               Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\nGETWORKA EQU   *\n         GETMAIN R,LV=WORKEND           Get storage for workarea\n         LR    R13,R1                   Store address in R13\n         MVC   4(4,R13),=C'F1SA'        Set label in savearea\n         USING WORKAREA,R13             Address workarea\n         LA    R4,MSGAREA               Point to WTO msgarea\n         USING MSG,R4                   Address it\n         LA    R9,YSGAREA               Point to IEFYS msg area\n         USING FYS,R9                   Address it\n         XR    R15,R15                  Zero R15\n         LA    R15,MSGTLEN(R15)         Get msg text length\n         STH   R15,MSGWTOL              Store WTO msg length\n         MVC   WTO1(L#WTO),WTOM         Move in WTO model\n         MVC   MSGTEXT(MSGTLEN),LABEL1  Move in first label text\n         L     R1,CANBIT                Load up step count/cancel\n         CLI   1(R1),X'01'              First step ?\n         BNE   YSLABEL1                 No - do not issue WTO\n         BAL   R8,WTOMSG                Issue WTO\nYSLABEL1 EQU   *\n         MVC   MSGTEXT(MSGTLEN),LABEL2  Move in second label text\n         L     R1,CANBIT                Load up step count/cancel\n         CLI   1(R1),X'01'              First step ?\n         BNE   GETPROC                  No - do not issue WTO\n         BAL   R8,WTOMSG                Issue WTO\nGETPROC  EQU   *\n*---------------------------------------------------------------------*\n* Capture Stepname, ProcStepName and Program from the ID section\n*---------------------------------------------------------------------*\n         MVC   MSGTEXT(MSGTLEN),BLANKS  Move in blank line\n         MVC   MSGID(8),=CL8'HTRT03I'\n         CLC   SMF30PSN(8),BLANKS       Is it blanks ?\n         BE    NOPROC                   Yes - not expanded proc\n         MVC   MSGSTEP(8),SMF30PSN      Move in stepname\n         MVC   MSGPROC(8),SMF30STM      Move in procstep\n         B     GETPGM                   Carry on\nNOPROC   EQU   *\n         MVC   MSGSTEP(8),SMF30STM      Move in step name\nGETPGM   EQU   *\n         MVC   PGMNAME(8),SMF30PGM      Move in pgm name\n         MVC   MSGJOBN(8),SMF30JBN      Move in job name\n         MVC   SAVEPGM(8),PGMNAME       Remember for later\n         MVC   SAVESTEP(8),MSGSTEP\n         MVC   SAVEPROC(8),MSGPROC\nGETELAP  EQU   *\n*---------------------------------------------------------------------*\n* Calculate elapsed time.\n* The outut field only goes up to 99 hours, so if the time is over\n* this limit we throw out a '>4 days' message.\n*---------------------------------------------------------------------*\n         TIME  BIN                      Get the current time\n         LR    R7,R0                    Store current time\n         B     MANYDAYS                 How many days ?\nBADDAYS  EQU   *\n         XR    R7,R7                    Clear so that we ..\n         B     ELAPCONV                 Force 00:00:00.00 (error)\n*\nMANYDAYS EQU   *\n         XC    DWORK,DWORK              Clear\n         ST    R1,DWORK+4               Save date (0cyydddf)\n         CLC   DWORK+5(1),SMF30STD+1    Same year ?\n         BNE   BADDAYS                  no - force error\n         CLC   DWORK+6(2),SMF30STD+2    Same day ?\n         BE    SAMEDAY                  yes - no adjust\n         SP    DWORK,SMF30STD           How many days\n         BM    BADDAYS                  error\n         CVB   R6,DWORK                 convert to binary\n         C     R6,=F'4'                 more than 4 days ?\n         BNH   DAYADJST                 no -\n         MVC   MSGELAP(11),=CL11'>4 Days'\n         B     ELAPDONE\nDAYADJST EQU   *\n         LR    R1,R6                    Copy number of days\n         XR    R0,R0                    Clear\n         M     R0,ONEDAY\n         ALR   R7,R1                    Add on 24 hours\nSAMEDAY  EQU   *\n         S     R7,SMF30SIT              Take away step init time\nELAPCONV EQU   *\n         LA    R1,MSGELAP               Point to elapsed section\n         BAL   R8,TIMECONV              Format it\nELAPDONE EQU   *\n         MVC   SAVEELA(11),MSGELAP      Remeber for later\n*---------------------------------------------------------------------*\n* Capture return code from the completion section\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30TOF              Add offset to comp section\n         USING SMF30CMP,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         TM    SMF30STI,SMF30FLH        Was step flushed ?\n         BNO   NOTFLUSH                 No - carry on\n         MVC   MSGRC(5),FLUSH           Move in flush message\n         B     CPUTIME                  Get CPU time\nNOTFLUSH EQU   *\n         TM    SMF30STI,SMF30ABD        Has it abended ?\n         BNO   CONVERT                  No - normal completion\n         CLC   SMF30SCC,=X'7FFF'        Is it system code ?\n         BH    CONVERT                  No - user abend\n         LA    R15,UWORK                Point to output\n         LA    R1,SMF30SCC              Point to comp code\n         LA    R0,2                     Set length of input\n         BAL   R8,HEX2CHAR              make it printable\n         MVC   MSGRC(2),=C' S'          Move system code indicator\n         MVC   MSGRC+2(3),UWORK+1       Move in the code\n         B     CPUTIME                  Go and get CPU time\nCONVERT  EQU   *\n         LA    R7,0                     Clear out r7\n         LH    R7,SMF30SCC              Load up cond code\n         N     R7,=X'00000FFF'          Get rid of indicator\n         CVD   R7,PWORK                 Convert to decimal\n         MVC   CWORK(8),CCMASK          Move in the mask\n         TM    SMF30STI,SMF30ABD        was it abend ?\n         BNO   CONVRTCC                 no - just normal rc\nCONVRTUB EQU   *\n         MVC   CWORK(8),UBMASK          Move in the mask\n         ED    CWORK(8),PWORK+4         Edit cond code\n         MVC   MSGRC(5),CWORK+3         move in the cond code\n         MVI   MSGRC,C'U'               add a U for User abend\n         B     CPUTIME\nCONVRTCC EQU   *\n         ED    CWORK(8),PWORK+4         Edit cond code\n         MVC   MSGRC(5),CWORK+3         move in the cond code\nCPUTIME  EQU   *\n         MVC   SAVERC(5),MSGRC          Remember for later\n*---------------------------------------------------------------------*\n* Capture CPU times from the processor section\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30COF              Set to processor section\n         USING SMF30CAS,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         L     R7,SMF30CPT              Load up CPU time (TCB)\n         LA    R1,MSGTCB                Point to WTO TCB time\n         BAL   R8,TIMECONV              Format it\n         MVC   SAVETCB(11),MSGTCB       Remember for later\n         L     R7,SMF30CPS              Load SRB time\n         LA    R1,MSGSRB                Point to WTO SRB time\n         BAL   R8,TIMECONV              Format it\n         MVC   SAVESRB(11),MSGSRB       Remember for later\n         L     R7,SMF30CPT              Load up CPU time (TCB)\n         A     R7,SMF30CPS              Add  SRB time\n         LA    R1,MSGCPU                Point to total CPU\n         BAL   R8,TIMECONV              Format it\n         MVC   SAVETOT(11),MSGCPU       Remember for later\nPERFORM  EQU   *\n*---------------------------------------------------------------------*\n* Capture Service Units from the performance section\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30POF              Set to performance section\n         USING SMF30PRF,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         LA    R7,0                     Zero R7\n         LA    R15,MSGSERV              Point to serv\n         L     R7,SMF30CSU              Load up serv units\n         C     R7,MAXNUM                Check for maximum number\n         BL    NORMSTEP                 Normal step\n         BCTR  R15,R0                   Minus one\n         LA    R6,0                     Zero R6\n         D     R6,=F'1000'              Divide by 1000\n         MVI   MSGSERV+7,C'K'           Move in a K\nNORMSTEP EQU   *\n         CVD   R7,EXPWKA                Convert to dec\n         MVC   0(8,R15),BIGMASK         Move in edit mask to line\n         ED    0(8,R15),EXPWKA+4        Edit the service units\n         MVC   SAVESERV(8),MSGSERV      Remember for later\nIOSECT   EQU   *\n*---------------------------------------------------------------------*\n* Capture I/O counts from the I/O section\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30UOF              Set to I/O  section\n         USING SMF30URA,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         MVC   ALLIOS(8),=D'0'          Blank out I/O fields\n         LA    R7,0                     Clear R7\n         LA    R15,MSGEXCP              Point to I/O area\n         L     R7,SMF30TEP              Load up r7 with # of excp recs\n         ST    R7,ALLIOS                Store total I/O count\n         C     R7,MAXNUM                Bigger than maximum\n         BL    NORMIO                   Normal I/O\n         BCTR  R15,R0                   Minus one\n         LA    R6,0                     Zero R6\n         D     R6,=F'1000'              Divide by 1000\n         MVI   MSGEXCP+5,C'K'           Move in a k\nNORMIO   EQU   *\n         CVD   R7,EXPWKA                Convert to dec\n         MVC   0(6,R15),GENMASK         Move in edit mask to line\n         ED    0(6,R15),EXPWKA+5        Edit the I/O  count\n         MVC   SAVEIO(6),MSGEXCP        Remember for later\n         BAL   R8,WTOMSG                Issue WTO\n*\nSTEPYS   EQU   *\n*---------------------------------------------------------------------*\n* We have issued the WTO to throw out the summary message to the job\n* log, so now we produce more detailed messages to the JESYSMSG using\n* IEFYS.\n*---------------------------------------------------------------------*\n         MVC   FYSMSGID(8),=CL8'HTRT05I'\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVC   FYSCOL1+1(FYSLEN-1),FYSCOL1\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(LCOMPANY),COMPANY\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Program Name'\n         MVC   FYSFLD1(8),SAVEPGM\n         MVC   FYSTIM2(11),=CL11'hh:mm:ss.th'\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Step Name   '\n         MVC   FYSFLD1(8),SAVESTEP\n         MVC   FYSLAB2(16),=CL16'Elapsed Time'\n         MVC   FYSTIM2(11),SAVEELA\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Procedure Step'\n         MVC   FYSFLD1(8),SAVEPROC\n         MVC   FYSLAB2(16),=CL16'TCB CPU Time  '\n         MVC   FYSTIM2(11),SAVETCB\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Return Code'\n         MVC   FYSFLD1+3(5),SAVERC\n         MVC   FYSLAB2(16),=CL16'SRB CPU Time '\n         MVC   FYSTIM2(11),SAVESRB\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Total I/O'\n         MVC   FYSFLD1+2(6),SAVEIO\n         MVC   FYSLAB2(16),=CL16'Total CPU Time  '\n         MVC   FYSTIM2(11),SAVETOT\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Service Units'\n         MVC   FYSFLD1(8),SAVESERV\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         BAL   R8,WRITEMSG              Write to JESYSMSG\nSTORSECT EQU   *\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30ROF              Set to I/O  section\n         USING SMF30RSV,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Region Size'\n         ICM   R6,B'1111',SMF30RGN      Get value\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD1(7),CWORK+1       Copy in value\n         MVI   FYSFLD1+7,C'K'           Add a 'K'\n         MVC   FYSLAB2(16),=CL16'Pages Paged '\n         ICM   R6,B'1111',SMF30PGI      Get value\n         AL    R6,SMF30PGO              Get value\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD2(8),CWORK         Copy in value\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Data/Hiperspace'\n         ICM   R6,B'1111',SMF30DSV      Get value\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD1(7),CWORK+1       Copy in value\n         MVI   FYSFLD1+7,C'M'           Add a 'K'\n         MVC   FYSLAB2(16),=CL16'Pages Swapped'\n         ICM   R6,B'1111',SMF30PSI      Get value\n         AL    R6,SMF30PSO              Get value\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD2(8),CWORK         Copy in value\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'ASID Swaps'\n         ICM   R6,B'1111',SMF30NSW      Get value\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD1(8),CWORK         Copy in value\n         MVC   FYSLAB2(16),=CL16'Pages Stolen'\n         ICM   R6,B'1111',SMF30PST      Get value\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD2(8),CWORK         Copy in value\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB2(16),=CL16'VIO (In and Out)'\n         ICM   R6,B'1111',SMF30VPI      Get value\n         AL    R6,SMF30VPO\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD2(8),CWORK         Copy in value\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(27),=CL27'--------Below 16Meg--------'\n         MVC   FYSLAB2(27),=CL27'--------Above 16Meg--------'\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Private Area'\n         ICM   R6,B'1111',SMF30RGB      Get value\n         SRL   R6,10                    divide by 1024 = K\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD1(7),CWORK+1       Copy in value\n         MVI   FYSFLD1+7,C'K'           Add a 'K'\n         MVC   FYSLAB2(16),=CL16'Private Area'\n         ICM   R6,B'1111',SMF30ERG      Get value\n         SRL   R6,10                    divide by 1024 = K\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD2(7),CWORK+1       Copy in value\n         MVI   FYSFLD2+7,C'K'           Add a 'K'\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'Max Allocated'\n         ICM   R6,B'1111',SMF30URB      Get value\n         SRL   R6,10                    divide by 1024 = K\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD1(7),CWORK+1       Copy in value\n         MVI   FYSFLD1+7,C'K'           Add a 'K'\n         MVC   FYSLAB2(16),=CL16'Max Allocated'\n         ICM   R6,B'1111',SMF30EUR      Get value\n         SRL   R6,10                    divide by 1024 = K\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD2(7),CWORK+1       Copy in value\n         MVI   FYSFLD2+7,C'K'           Add a 'K'\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'LSQA And SWA '\n         ICM   R6,B'1111',SMF30ARB      Get value\n         SRL   R6,10                    divide by 1024 = K\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD1(7),CWORK+1       Copy in value\n         MVI   FYSFLD1+7,C'K'           Add a 'K'\n         MVC   FYSLAB2(16),=CL16'LSQA And SWA '\n         ICM   R6,B'1111',SMF30EAR      Get value\n         SRL   R6,10                    divide by 1024 = K\n         CVD   R6,EXPWKA                Convert to decimal\n         MVC   CWORK(8),BIGMASK         Copy mask\n         ED    CWORK(8),EXPWKA+4        Make printable\n         MVC   FYSFLD2(7),CWORK+1       Copy in value\n         MVI   FYSFLD2+7,C'K'           Add a 'K'\n         BAL   R8,WRITEMSG              Write to JESYSMSG\nDDSECTS  EQU   *\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         BAL   R8,WRITEMSG              Write to JESYSMSG\nEXCP     EQU   *\n*---------------------------------------------------------------------*\n* Capture individual I/Os per DD Name from the EXCP section\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30EOF              Set to excp section\n         USING SMF30EXP,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         LA    R7,0                     Clear R7\n         LH    R7,SMF30EON              Load up r7 with # of excp recs\n         LTR   R7,R7                    Are there any ?\n         BZ    DONE                     No - then ignore\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         MVC   FYSLAB1(16),=CL16'DDName    Unit'\n         MVC   FYSTIM1(19),=CL19'  Blksize       I/O'\n         BAL   R8,WRITEMSG              Write to JESYSMSG\nEXCPLOOP EQU   *\n*---------------------------------------------------------------------*\n* Loop thru the entries in the EXCP section to extract the I/O count\n* for each DD Name:\n* o  DD Names with 0 I/Os will not be reported.\n* o  Only DD Names that reside on DASD, TAPE or VIO will be reported\n*---------------------------------------------------------------------*\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         CLC   SMF30CUA,VIO             Is it VIO ?\n         BNE   CUACHECK                 No - go and check if unit type\n         MVC   FYSLAB1+10(4),VIOMSG     Move 'VIO' to msg line\n         B     EXCPCNT\nCUACHECK EQU   *\n         CLI   SMF30DEV,X'20'           Is it DASD ?\n         BE    CUATRANS                 Yes - get CUA\n         CLI   SMF30DEV,X'80'           Is it TAPE ?\n         BE    CUATRANS                 Yes - get CUA\n         B     NEXTREC                  Not interested in this one\nCUATRANS EQU   *\n         LA    R15,UWORK                Point to output area\n         LA    R1,SMF30CUA              Point to CUA\n         LA    R0,2                     Set length of input\n         BAL   R8,HEX2CHAR              Make printable\n         MVC   FYSLAB1+10(4),UWORK      Move CUA to msg line\nEXCPCNT  EQU   *\n         LA    R6,0                     Zero R6\n         L     R6,SMF30BLK              Load up excp counts\n         LTR   R6,R6                    Is it zero ?\n         BZ    NEXTREC                  Yes - don't print it\n         L     R15,IOACCUM              Load up I/O accumaleted\n         A     R15,SMF30BLK             Add the current I/O\n         ST    R15,IOACCUM              Store it back\n         CVD   R6,EXPWKA                Convert to dec\n         MVC   FYSTIM1+11(8),BIGMASK       Move in edit mask to line\n         ED    FYSTIM1+11(8),EXPWKA+4      Edit the excp count\n         MVC   FYSLAB1(8),SMF30DDN      Move in assoc. ddname\n         XR    R6,R6                    Clear\n         ICM   R6,B'0011',SMF30BSZ      Get blocksize\n         CVD   R6,EXPWKA                Convert to dec\n         MVC   FYSTIM1+1(8),BIGMASK     Move in edit mask to line\n         ED    FYSTIM1+1(8),EXPWKA+4    Edit the blksize\n         BAL   R8,WRITEMSG              Write to JESYSMSG\nNEXTREC  EQU   *\n         XR    R15,R15                  Clear\n         ICM   R15,B'0011',SMF30ELN     Get length of EXCP section\n         AR    R3,R15                   Get the next excp section\n         BCT   R7,EXCPLOOP              Loop it\nDONE     EQU   *\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         CLC   ALLIOS,=F'0'             Any entry for total I/O ?\n         BE    EXCPFIN                  No - end it\n         CLC   ALLIOS(4),IOACCUM        Compare I/O fields\n         BNH   EXCPFIN                  If allios not > ioaccum\n         L     R15,ALLIOS               Load up all I/O count\n         S     R15,IOACCUM              Subtract all DASD and TAPE I/O\n         CVD   R15,EXPWKA               Convert to dec\n         MVC   FYSTIM1+11(8),BIGMASK       Move in edit mask to line\n         ED    FYSTIM1+11(8),EXPWKA+4      Edit the excp count\n         MVC   FYSLAB1(8),SYSTEM        Star out the unit address\n         BAL   R8,WRITEMSG              Write to JESYSMSG\nEXCPFIN  EQU   *\n         MVC   YSGAREA(80),BLANKS       Blank it out\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVI   FYSCOL2,C'-'             Move in dashes line\n         BAL   R8,WRITEMSG              Write to JESYSMSG\n         MVI   FYSCOL1,C'-'             Move in dashes line\n         MVC   FYSCOL1+1(FYSLEN-1),FYSCOL1\n         BAL   R8,WRITEMSG              Write to JESYSMSG\nFREE     EQU   *\n         FREEMAIN R,LV=WORKEND,A=(R13)\n         B     RETURN00\n*\n*---------------------------------------------------------------------*\n* End of Step Termination Code\n*---------------------------------------------------------------------*\n*\nJOBTERM  EQU   *                        SMF type 30-5\n*---------------------------------------------------------------------*\n*  Process SMF30-5 records to produce Job Service totals msg\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30IOF              Get id section\n         USING SMF30ID,R3               Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         GETMAIN R,LV=WORKEND           Get storage for workarea\n         LR    R13,R1                   Store address in r13\n         MVC   4(4,R13),=C'F1SA'        Set label in savearea\n         USING WORKAREA,R13             Address workarea\n         LA    R4,MSGAREA               Point to msgarea\n         USING MSG,R4                   Address it\n         XR    R15,R15                  Zero R15\n         LA    R15,MSGTLEN(R15)         Get msg text length\n         STH   R15,MSGWTOL              Store WTO msg length\n         MVC   WTO1(L#WTO),WTOM         Move in WTO model\n         MVC   MSGTEXT(MSGTLEN),BLANKS  Move in blank line\n         MVC   MSGID(8),=CL8'HTRT06I'\n         BAL   R8,WTOMSG                Issue WTO\n         MVC   MSGTEXT(MSGTLEN),LABEL3  Move in blank line\n         MVC   MSGJOBN(8),SMF30JBN      Move in job name\n*\n         TIME  BIN                      Get the current time\n         LR    R7,R0                    Store current time\n         B     MANYDAY2                 How many days ?\nBADDAYS2 EQU   *\n         XR    R7,R7                    Clear so that we ..\n         B     ELAPCON2                 Force 00:00:00.00 (error)\n*\nMANYDAY2 EQU   *\n         XC    DWORK,DWORK              Clear\n         ST    R1,DWORK+4               Save date (0cyydddf)\n         CLC   DWORK+5(1),SMF30STD+1    Same year ?\n         BNE   BADDAYS2                 no - force error\n         CLC   DWORK+6(2),SMF30STD+2    Same day ?\n         BE    SAMEDAY2                 yes - no adjust\n         SP    DWORK,SMF30STD           How many days\n         BM    BADDAYS2                 error\n         CVB   R6,DWORK                 convert to binary\n         C     R6,=F'4'                 more than 4 days ?\n         BNH   DAYADJS2                 no -\n         MVC   MSGELAP(11),=CL11'>4 Days'\n         B     ELAPDON2\nDAYADJS2 EQU   *\n         LR    R1,R6                    Copy number of days\n         XR    R0,R0                    Clear\n         M     R0,ONEDAY\n         ALR   R7,R1                    Add on 24 hours\nSAMEDAY2 EQU   *\n         S     R7,SMF30SIT              Take away step init time\nELAPCON2 EQU   *\n         LA    R1,MSGELAP               Point to elapsed section\n         BAL   R8,TIMECONV              Format it\nELAPDON2 EQU   *\n*---------------------------------------------------------------------*\n* Capture service units from the performance section\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30POF              Get performance section\n         USING SMF30PRF,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         LA    R7,0                     Zero R7\n         LA    R15,MSGSERV              Point to serv\n         L     R7,SMF30CSU              Load up serv units\n         C     R7,MAXNUM                Check for maximum number\n         BL    NORMJOB                  Normal job\n         BCTR  R15,R0                   Minus one\n         LA    R6,0                     Zero R6\n         D     R6,=F'1000'              Divide by 1000\n         MVI   MSGSERV+7,C'K'           Move in a K\nNORMJOB  EQU   *\n         CVD   R7,EXPWKA                Convert to dec\n         MVC   0(8,R15),BIGMASK         Move in edit mask to line\n         ED    0(8,R15),EXPWKA+4        Edit the service units\n*---------------------------------------------------------------------*\n* Capture I/O counts from the I/O section\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30UOF              Set to I/O  section\n         USING SMF30URA,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         LA    R7,0                     Clear R7\n         LA    R15,MSGEXCP              Point to I/O area\n         L     R7,SMF30TEP              Load up r7 with # of excp recs\n         ST    R7,ALLIOS                Store total I/O count\n         C     R7,MAXNUM                Bigger than maximum\n         BL    NORMJIO                  Normal I/O\n         BCTR  R15,R0                   Minus one\n         LA    R6,0                     Zero R6\n         D     R6,=F'1000'              Divide by 1000\n         MVI   MSGEXCP+5,C'K'           Move in a K\nNORMJIO  EQU   *\n         CVD   R7,EXPWKA                Convert to dec\n         MVC   0(6,R15),GENMASK         Move in edit mask to line\n         ED    0(6,R15),EXPWKA+5        Edit the I/O  count\n*---------------------------------------------------------------------*\n* Capture CPU times from the processor section\n*---------------------------------------------------------------------*\n         LR    R3,R2                    Set to SMF record start\n         A     R3,SMF30COF              Set to processor section\n         USING SMF30CAS,R3              Address it\n         CR    R3,R2                    Any offset ?\n         BE    RETURN00                 No - quit\n         L     R7,SMF30CPT              Load up CPU time (TCB)\n         LA    R1,MSGTCB                Point to WTO TCB time\n         BAL   R8,TIMECONV              Format it\n         L     R7,SMF30CPS              Load SRB time\n         LA    R1,MSGSRB                Point to WTO SRB time\n         BAL   R8,TIMECONV              Format it\n         L     R7,SMF30CPT              Load up CPU time (TCB)\n         A     R7,SMF30CPS              Add  SRB time\n         LA    R1,MSGCPU                Point to total CPU\n         BAL   R8,TIMECONV              Format it\n         BAL   R8,WTOMSG                Issue WTO\n         B     FREE                     Finished\n*\n*---------------------------------------------------------------------*\n* End of Job Termination Code\n*---------------------------------------------------------------------*\n*\n*---------------------------------------------------------------------*\n* General Routines\n*---------------------------------------------------------------------*\n*\nTIMECONV EQU   *\n*---------------------------------------------------------------------*\n* Routine to format SMF Time to hh:mm:ss.th\n*\n* Input Registers :\n*   R1 points to output field\n*   R6 is used as work\n*   R7 contains the time to be converted\n*---------------------------------------------------------------------*\n         MVC   0(11,R1),CPUMASK         Move in '      00.00'\n         LA    R6,0                     Clear reg for divide\n         D     R6,=F'100'               Divide by 100 for 100ths sec\n         CVD   R6,PWORK                 Convert remainder to dec\n         UNPK  UWORK,PWORK              Unpack it\n         OI    UWORK+3,X'F0'            Clear last byte\n         MVC   9(2,R1),UWORK+2          Move to msg line\n         LTR   R7,R7                    Any more ?\n         BZ    CONVFIN                  No - get out\n         LA    R6,0                     Clear reg for divide\n         D     R6,=F'60'                Divide by 60 for secs\n         CVD   R6,PWORK                 Convert to dec\n         UNPK  UWORK,PWORK              Unpack it\n         OI    UWORK+3,X'F0'            Clear last byte\n         MVC   6(2,R1),UWORK+2          Move to message line\n         LTR   R7,R7                    Any more ?\n         BZ    CONVFIN                  No - get out\n         MVI   5(R1),C':'               Stick in a colon\n         LA    R6,0                     Clear reg for divide\n         D     R6,=F'60'                Divide by 60 for mins\n         CVD   R6,PWORK                 Convert to dec\n         UNPK  UWORK,PWORK              Unpack it\n         OI    UWORK+3,X'F0'            Clear last byte\n         MVC   3(2,R1),UWORK+2          Move to message line\n         LTR   R7,R7                    Any more ?\n         BZ    CONVFIN                  No - get out\n         MVI   2(R1),C':'               Stick in a colon\n         CVD   R7,PWORK                 Convert hours to dec\n         UNPK  UWORK,PWORK              Unpack it\n         OI    UWORK+3,X'F0'            Clear last byte\n         MVC   0(2,R1),UWORK+2          Move to message line\nCONVFIN  EQU   *\n         BR    R8\n*\nWRITEMSG EQU   *\n*---------------------------------------------------------------------*\n*  Write message line to JESYSMSG via the IEFYS routine\n*---------------------------------------------------------------------*\n         LA    R6,YSGAREA               Load address of msg text\n         ST    R6,36(R12)               Move msg address to iefys\n         XR    R15,R15                  Clear r15\n         LA    R15,80                   Get msg text length\n         STH   R15,42(,R12)             Move msg length to iefys\n         L     R15,VIEFYS               Load addr of iefys\n         BALR  R14,R15                  Execute iefys\n         BR    R8                       Return\n*\nWTOMSG   EQU   *\n*---------------------------------------------------------------------*\n*  Write WTO message\n*---------------------------------------------------------------------*\n         WTO   TEXT=MSGAREA,            Issue WTO                      X\n               MF=(E,WTO1)              From this parm list\n         BR    R8                       Return\n*\nHEX2CHAR EQU   *\n*---------------------------------------------------------------------*\n* Convert a hex string to EBCDIC\n* Registers on entry :\n* R0 - Length of input hex bytes\n* R1 - Input hex bytes\n* R15- Output EBCDIC area\n*\n* R14 is used as a work register\n*\n*---------------------------------------------------------------------*\nLEFTHALF EQU   *\n         XR    R14,R14                  Clear\n         ICM   R14,B'0001',0(R1)        Load up a byte (000000ab)\n         SRL   R14,4                    Remove last 4 bits (0000000a)\nLEFTNUM  EQU   *\n         CH    R14,=H'9'                00000000 - 00000009 ?\n         BH    LEFTLTTR                 higher - must be A-F\n         AH    R14,=H'240'              xlate to F0-F9\n         B     LEFTDONE\nLEFTLTTR EQU   *\n         AH    R14,=H'183'              xlate to C1-C6\nLEFTDONE EQU   *\n         STCM  R14,B'0001',0(R15)       Store in output field\n         LA    R15,1(R15)               Point to next char\nRGHTHALF EQU   *\n         XR    R14,R14                  Clear\n         ICM   R14,B'0001',0(R1)        Load up a byte (000000ab)\n         SLL   R14,28                   Remove first 4 bits (b0000000)\n         SRL   R14,28                   and reset           (0000000b)\nRGHTNUM  EQU   *\n         CH    R14,=H'9'                00000000 - 00000009 ?\n         BH    RGHTLTTR                 higher - must be A-F\n         AH    R14,=H'240'              xlate to F0-F9\n         B     RGHTDONE\nRGHTLTTR EQU   *\n         AH    R14,=H'183'              xlate to C1-C6\nRGHTDONE EQU   *\n         STCM  R14,B'0001',0(R15)       Store in output area\n         LA    R15,1(R15)               Point to next char\n         LA    R1,1(R1)                 Point to next input byte\n         BCT   R0,LEFTHALF              Loop for all bytes\n         BR    R8                       return\n*\n*---------------------------------------------------------------------*\n*  Constants.\n*---------------------------------------------------------------------*\n*\n         LTORG\n         DS    0D\nWTOM     WTO   TEXT=(*-*),ROUTCDE=(16),MF=L\nL#WTO    EQU   *-WTOM\n         DS    0F\nMAXNUM   DC    F'99999'                 max number of service units\nONEDAY   DC    A(24*60*60*100)          24 hous in 1/100 sec\nVIEFYS   DC    V(IEFYS)                 address of iefys\nVIO      DC    X'7FFF'                  VIO mask\nVIOMSG   DC    C'VIO '                  VIO msg\nGENMASK  DC    X'4020202021202020'      mask for normal numbers\nBIGMASK  DC    X'4020202020202120'      mask for big numbers\nUBMASK   DC    X'F021202020202020'      mask for user abend\nCCMASK   DC    X'4020202020212020'      mask for return codes\nCPUMASK  DC    CL11'      00.00'        CPU time mask\nSYSTEM   DC    CL8'*System*'\nFLUSH    DC    CL5'FLUSH'               Job Flushed msg\nPGMLABL  DC    CL7'Program'\n*---------------------------------------------------------------------*\n* Change the company name below ..                                    *\n*---------------------------------------------------------------------*\nCOMPANY  DC    C'Step Termination Statistics'\nLCOMPANY EQU   *-COMPANY                Length of company name\n*\nBLANKS   DS    0C                       header label 0\n         DC    CL1' '                   dash '-'\n         DC    CL(MSGTLEN-1)' '         blanks\nLABEL1   DS    0C                       header label 1\n         DC    CL8'HTRT01I'             Message ID\n         DC    CL8'       '             job name\n         DC    CL1' '\n         DC    CL8'        '            stepname\n         DC    CL1' '\n         DC    CL8'        '            procedure step name\n         DC    CL1' '\n         DC    CL5'     '               return/abend code\n         DC    CL1' '\n         DC    CL6'      '              excp count\n         DC    CL1' '\n         DC    CL11'CPU (Total)'        total CPU time\n         DC    CL2' '\n         DC    CL11'Elapsed   '         elapsed time\n         DC    CL2' '\n         DC    CL11'CPU (TCB) '         TCB CPU time\n         DC    CL2' '\n         DC    CL11'CPU (SRB) '         SRB CPU time\n         DC    CL2' '\n         DC    CL8' Service'            service units\n*\nLABEL2   DS    0C                       header label 2\n         DC    CL8'HTRT02I'             Message ID\n         DC    CL8'Jobname'             job name\n         DC    CL1' '\n         DC    CL8'Stepname'            stepname\n         DC    CL1' '\n         DC    CL8'ProcStep'            procedure step name\n         DC    CL1' '\n         DC    CL5'   RC'               return/abend code\n         DC    CL1' '\n         DC    CL6'   I/O'              excp count\n         DC    CL1' '\n         DC    CL11'hh:mm:ss.th'        total CPU time\n         DC    CL2' '\n         DC    CL11'hh:mm:ss.th'        elapsed time\n         DC    CL2' '\n         DC    CL11'hh:mm:ss.th'        TCB CPU time\n         DC    CL2' '\n         DC    CL11'hh:mm:ss.th'        SRB CPU time\n         DC    CL2' '\n         DC    CL8'   Units'            service units\n*\nLABEL3   DS    0C                       header label 3\n         DC    CL8'HTRT04I'             Message ID\n         DC    CL8'       '             job name\n         DC    CL1' '\n         DC    CL18'Job Service Totals'\n         DC    CL5'     '\n         DC    CL1' '\n         DC    CL6'      '              excp count\n         DC    CL1' '\n         DC    CL11'          '         total CPU time\n         DC    CL2' '\n         DC    CL11'          '         elapsed time\n         DC    CL2' '\n         DC    CL11'          '         TCB CPU time\n         DC    CL2' '\n         DC    CL11'          '         SRB CPU time\n         DC    CL2' '\n         DC    CL8'     '               service units\n*\n*---------------------------------------------------------------------*\n*  DSECTs\n*---------------------------------------------------------------------*\n*\nWORKAREA DSECT\nSAVEAREA DS    9D                       savearea\nPGMNAME  DS    CL8                      saved program name\n         DS    0D\nDWORK    DS    D                        packed work area\nPWORK    DS    D                        packed work area\nUWORK    DS    F                        unpacked work area\nCWORK    DS    CL8                      unpacked work area\nEXPWKA   DS    0D                       excp work area\nEXPWKA1  DS    D\nALLIOS   DS    F\nIOACCUM  DS    F                        Accumulated I/O count\nYSGAREA  DS    CL80                     Step summary messages\nWTO1     DS    CL(L#WTO)                WTO area\nMSGAREA  DS    CL(MSGLEN)               area for WTO messages\n         DS    0D\nSAVEPGM  DS    CL8\nSAVESTEP DS    CL8\nSAVEPROC DS    CL8\nSAVERC   DS    CL8\nSAVEIO   DS    CL8\nSAVESERV DS    CL8\nSAVETCB  DS    CL11\nSAVESRB  DS    CL11\nSAVETOT  DS    CL11\nSAVEELA  DS    CL11\n         DS    0D\nWORKEND  EQU   *-SAVEAREA               length of workarea\n*\nMSG      DSECT\nMSGWTOL  DS    H                        length of message text\nMSGTEXT  DS    0C                       start of text\nMSGID    DS    CL8\nMSGJOBN  DS    CL8                      job name\n         DS    CL1\nMSGSTEP  DS    CL8                      stepname\n         DS    CL1\nMSGPROC  DS    CL8                      procedure step name\n         DS    CL1\nMSGRC    DS    CL5                      return/abend code\n         DS    CL1\nMSGEXCP  DS    CL6                      excp count\n         DS    CL1\nMSGCPU   DS    CL11                     total CPU time\n         DS    CL2\nMSGELAP  DS    CL11                     elapsed time\n         DS    CL2\nMSGTCB   DS    CL11                     TCB CPU time\n         DS    CL2\nMSGSRB   DS    CL11                     SRB CPU time\n         DS    CL2\nMSGSERV  DS    CL8                      service units\nMSGTLEN  EQU   *-MSGTEXT                length of message text\nMSGLEN   EQU   *-MSG                    length of entire dsect\nMSGPGM   EQU   MSGJOBN                  org back for I/O msgs\nMSGDDN   EQU   MSGJOBN\nMSGUNIT  EQU   MSGSTEP\nMSGBLKS  EQU   MSGPROC\nMSGIOCNT EQU   MSGRC+4\n*\nFYS      DSECT\nFYSMSGID DS    CL8\nFYSCOL1  DS    X\n         DS    X\nFYSLAB1  DS    CL16                     label number 1\nFYSTIM1  DS    CL3\nFYSFLD1  DS    CL12                     Field number 1\n         DS    XL6\nFYSLAB2  DS    CL16                     label number 1\nFYSTIM2  DS    CL3\nFYSFLD2  DS    CL12                     Field number 1\n         DS    X\nFYSCOL2  DS    X\nFYSLEN   EQU   *-FYSCOL1\n*\nPARMLIST DSECT\nCEPA     DS    A                        common exit parameter area\nJOBNAME  DS    A                        jobname\nPROGNAME DS    A                        programmer name\nCPUTME   DS    A                        CPU time\nACCTINFO DS    A                        account information\nSTEPCPU  DS    A                        CPU time for step\nEXECACT  DS    A\nCANBIT   DS    A                        cancel bit\nTERMSTAT DS    A\nSMFRDW   DS    A                        SMF record decriptor\nJOBPTME  DS    A                        job processor time\nSTEPPTME DS    A                        step processor time\nSUBSYS   DS    A                        sub-system (eg tso,jes2..)\n*---------------------------------------------------------------------*\n*  System mapping macros\n*---------------------------------------------------------------------*\n         IFASMFR 30                     SMF type 30 record\nK1       EQU   01\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTMEM": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13o\\x01\\x01\\x13o\\x16D\\x02\\x89\\x02\\x89\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-16T00:00:00", "modifydate": "2001-05-16T16:44:00", "lines": 649, "newlines": 649, "modlines": 0, "user": "FILE411"}, "text": "LISTMEM TITLE 'Gather PDS Member Names and Create REXX Stems'\n*-------------------------------------------------------------------*\n* Function        : This program provides an external REXX function\n*                   to place the PDS Member names into REXX Stem\n*                   variables.\n*\n*                   The following REXX Stem variables are created :\n*                   (a) PDS_MEMBER_NAME.   PDS Member Name\n*\n*\n* Syntax          : rcode = LISTMEM(dataset,volser)\n*\n*                   DATASET\n*                   The fully qualified PDS dataset name.\n*\n*                   VOLSER\n*                   The volume serial number if the dataset is not\n*                   cataloged (optional parameter).\n*\n*                   RCODE\n*                   The return code from the LISTMEM function :\n*                   0        : Function was successful\n*                   2        : Dataset is migrated - recall it\n*                   4        : Error accessing dataset or volume\n*                              (a) Dataset does not exist\n*                              (b) Dataset not on specified volume\n*                              (c) Dataset not PDS\n*                   8        : Parameter error\n*                   eeeeiiii : Dynamic allocation error where\n*                              'eeee' is the SVC 99 error code and\n*                              'iiii' is the SVC 99 info code.\n*\n* Example         : /* REXX */\n*\n*                   rcode = LISTMEM('IBMUSER.CNTL','IPO1DL')\n*                   if rcode <> 0 then exit\n*                   i = 1\n*                   do PDS_MEMBER_NAME.0\n*                      say PDS_MEMBER_NAME.i\n*                      i = i + 1\n*                      end\n*\n*\n* IBM Macros Used : MODID, STORAGE, LOAD, DELETE, LOCATE, OBTAIN,\n*                   DYNALLOC, GET, CAMLST, OPEN, CLOSE, IECSDSL1,\n*                   IRXEVALB, IRXEFPL, IRXSHVB, IRXARGTB, IEFZB4D0,\n*                   IEFZB4D2\n*\n* Attributes      : Amode(24)\n*                   Rmode(24)\n*                   RENT\n*                   REUS\n*                   NOREFR\n*                   AC(0)\n*\n* Register Usage  :\n*\n* R1  - Parms passed              : +0 ---> REXX EFPL\n* R2  - EFPL\n* R3  - EVALBLOCK\n* R4  - Name buffer address\n* R5  - Value buffer address\n* R6  - ARGTABLE\n* R7  -\n* R8  - arg pointer / S99RB\n* R9  - arg length / Directory block\n* R10 - Branch and Link\n* R11 - SHVBLOCK\n* R12 - Base reg\n* R13 - Workarea\n*\n*-------------------------------------------------------------------*\n* (c) Scott Enterprise Consultancy Ltd\n*-------------------------------------------------------------------*\n* Changes\n* 17/06/1996  Rob Scott  Code Written                            V1.0\n*-------------------------------------------------------------------*\nLISTMEM  CSECT\nLISTMEM  AMODE 24\nLISTMEM  RMODE 24\n         BAKR  R14,R0                 linkage stack\n         LR    R12,R15                set R12 as base\n         USING LISTMEM,R12            address it\n         MODID ,                      eyecatcher\n         LR    R2,R1                  copy any parms passed\nGETWORK  EQU   *\n*--------------------------------------------------------------------*\n* Get some workarea storage and init to ZEROs. We also load the\n* address of IRXEXCOM for later calls.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in r13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=BELOW,             below the line                   X\n               COND=NO                unconditional\n         USING WORKAREA,R13           address workarea\n         LR    R14,R13                Copy workarea address\n         L     R15,=A(WORKLEN)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to ZEROs\n         MVC   4(4,R13),=C'F1SA'      set label in savearea\n         LOAD  EP=IRXEXCOM            Get address of IRXEXCOM\n         ST    R0,AIRXEXCM            Store for later\n         MVC   PDSDCB(DCBL),DCBM      Move in model DCB\n         MVC   OPENDCB(OPENL),OPENM   Copy in the model macro\n         MVC   CLOSDCB(CLOSL),CLOSM   Copy in the model macro\n*--------------------------------------------------------------------*\n* Init the working storage text unit constants                       *\n*--------------------------------------------------------------------*\n         MVC   DDNKEY(2),=AL2(DALRTDDN) Text Unit Key\n         MVC   DDNNUM(2),=AL2(1)        Number of parms\n         MVC   DDNLEN(2),=AL2(8)        Length of parms\n         MVC   DSNKEY(2),=AL2(DALDSNAM) Text Unit Key\n         MVC   DSNNUM(2),=AL2(1)        Number of parms\n         MVC   VOLKEY(2),=AL2(DALVLSER) Text Unit Key\n         MVC   VOLNUM(2),=AL2(1)        Number of parms\n         MVC   VOLLEN(2),=AL2(6)        Length of parm\nGETSHVB  EQU   *\n*--------------------------------------------------------------------*\n* Create the storage for the REXX SHVB (required by IRXECCOM).\n* We reserve 250 bytes for the variable name and 3K for the value\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the SHVBLOCK storage         X\n               LENGTH=4096,           this much                        X\n               ADDR=(R11),            address in r11                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=ANY,               above the line                   X\n               COND=NO                unconditional\n         USING SHVBLOCK,R11           address SHVBLOCK\n         LA    R4,SHVBLEN(R11)        Point to name buffer\n         ST    R4,ASHVNAMA            Store for IRXEXCOM\n         MVC   NAMALEN,=F'250'        Set length of name buffer\n         LA    R5,256(R4)             Point to value buffer\n         ST    R5,ASHVVALA            Store for IRXEXCOM\n         MVC   VALALEN,=F'3072'       Set length of value buffer\nGETPARMS EQU   *\n*--------------------------------------------------------------------*\n* Process the parms passed to this REXX function. This will be the\n* standard REXX function parameter list.\n*--------------------------------------------------------------------*\n         USING EFPL,R2                address REXX function parms\n         L     R3,EFPLEVAL            Get pointer to Eval_Block\n         L     R3,0(R3)               REXX Eval_Block address\n         USING EVALBLOCK,R3           Address it\n         L     R6,EFPLARG             REXX Argument table\n         USING ARGTABLE_ENTRY,R6      Address it\n         CLC   0(4,R6),HEXFF          No args ?\n         BE    RETURN08               Error\nGETDSN   EQU   *\n*--------------------------------------------------------------------*\n* Get the dataset name passed\n*--------------------------------------------------------------------*\n         MVC   DATASET(44),BLANKS     Blank out the dataset name\n         L     R8,ARGTABLE_ARGSTRING_PTR\n         L     R9,ARGTABLE_ARGSTRING_LENGTH\n         LTR   R9,R9                  Test arg length\n         BZ    RETURN08               ZERO - error\n         C     R9,=F'44'              > 44 chars\n         BH    RETURN08               Yes - error\n         STH   R9,DSNLEN              Store in SVC99 TU\n         BCTR  R9,R0                  Minus 1 for execute\n         EX    R9,MOVEDSN             Copy the dataset name\nGETVOL   EQU   *\n*--------------------------------------------------------------------*\n* Get any volume serial passed\n*--------------------------------------------------------------------*\n         MVC   VOLSER(6),BLANKS       Blank out the volser\n         LA    R6,8(R6)               Point to next arg\n         CLC   0(4,R6),HEXFF          No arg ?\n         BE    GETDSCB                No - volume specified\n         L     R8,ARGTABLE_ARGSTRING_PTR\n         L     R9,ARGTABLE_ARGSTRING_LENGTH\n         LTR   R9,R9                  Test arg length\n         BZ    GETDSCB                ZERO - no volume\n         C     R9,=F'6'               = 6 chars\n         BNE   RETURN08               No - error\n         MVC   VOLSER(6),0(R8)        Copy volume serial in\nGETDSCB  EQU   *\n*--------------------------------------------------------------------*\n* We now try and locate the dataset in the catalog and then get the\n* F1-DSCB to check if it is a PDS.\n*--------------------------------------------------------------------*\n         TR    DATASET(44),UPPER      Ensure uppercase\n         MVC   LOCATE1(CAMNAMEL),CAMNAME\n         LA    R15,DATASET            point to dataset name\n         ST    R15,LOCATE1+4          store in camlst\n         LA    R15,NAMEWORK           point to work area\n         ST    R15,LOCATE1+12         store in camlst\n         MVC   OBTAIN1(CAMSRCHL),CAMSRCH\n         LA    R15,DATASET            point to dataset name\n         ST    R15,OBTAIN1+4          store in camlst\n         LA    R15,VOLSER             point to volume serial\n         ST    R15,OBTAIN1+8          store in camlst\n         LA    R15,DSCB1+44           point to dscb\n         ST    R15,OBTAIN1+12         store in camlst\n         CLI   VOLSER,C' '            blank volser ?\n         BNE   OBTAIN                 no - just need obtain\n         LOCATE LOCATE1               issue locate macro\n         MVC   VOLSER(6),NAMEWORK+6   copy in the volser\nOBTAIN   EQU   *\n         TR    VOLSER(6),UPPER        Ensure uppercase\n         CLC   VOLSER(6),=C'MIGRAT'   Migrated ?\n         BE    RETURN02               Yes - cannot process\n         OBTAIN OBTAIN1               issue obtain macro\n         LTR   R15,R15                test rc\n         BNZ   RETURN04               if not zero indicate\n         LA    R15,DSCB1              Point to DSCB-1\n         USING F1DSCB,R15             Quick addressability\n         TM    DS1DSORG,DS1DSGPO      Is it a PDS ?\n         BNO   RETURN04               no - ignore it\nALLOCDSN EQU   *\n*--------------------------------------------------------------------*\n* Dynamically allocate the dataset to a temporary ddname.\n*--------------------------------------------------------------------*\n         MVC   DDNAME(8),BLANKS       blank out the ddname\n         LA    R8,ALLOCRB             point to SVC99 RB\n         USING S99RB,R8               address it\n         MVI   S99RBLN,20             Set length of RB\n         MVI   S99VERB,S99VRBAL       Set verb in RB\n         LA    R15,ALLOCTU            Point to text units\n         ST    R15,S99TXTPP           Store in RB\n         LA    R15,DDNKEY             Point to DDName TU\n         ST    R15,ALLOCTU            store in RB\n         LA    R15,DSNKEY             Point to DSN TU\n         ST    R15,ALLOCTU+4          store in RB\n         LA    R15,UNTKEY             Point to Unit TU\n         ST    R15,ALLOCTU+8          store in RB\n         LA    R15,VOLKEY             Point to Vol TU\n         ST    R15,ALLOCTU+12         store in RB\n         LA    R15,SHRKEY             Point to SHR TU\n         ST    R15,ALLOCTU+16         store in RB\n         OI    ALLOCTU+16,X'80'       Indicate last TU\n         ST    R8,ALLOCRBP            Store RB Address\n         OI    ALLOCRBP,X'80'         Flip high bit\n         LA    R1,ALLOCRBP            Point to SVC99 parm list\n         DYNALLOC                     call SVC 99\n         LTR   R15,R15                test rc\n         BZ    ALLOCOK                if 0 - OK\n         LA    R1,S99ERROR            point to SVC99 rc+rsn\n         LA    R0,4                   set length\n         LA    R15,ERRCODE            point to output bytes\n         BAL   R10,HEX2CHAR           make it printable\n         B     RETURNCC               and tell user\nALLOCOK  EQU   *\n*--------------------------------------------------------------------*\n* If we get here, we have successfully allocated a PDS to a SYSnnnnn\n* DDName. We copy the temporary ddname (returned by SVC99) to the DCB\n* in working storage and then process the directory blocks.\n*--------------------------------------------------------------------*\n         MVC   PDSDCB+40(8),DDNAME    overwrite DDName\nLISTBLDL EQU   *\n         OPEN  (PDSDCB,(INPUT)),      Open the DCB                     X\n               MF=(E,OPENDCB)\n         MVC   PCNT,=PL3'0'           Zero the count\nDIRLOOP  EQU   *\n         GET   PDSDCB,INDIR           Get a directory block\n         LA    R15,INDIR              Get address of DIR block\n         AH    R15,INDIR              Get number of bytes used\n         S     R15,=F'2'              subtract two bytes\n         ST    R15,ENDDIR             Store as end address\n         LA    R9,INDIR+2             Point to first DIR block\n         USING DIR,R9                 address it\nDIRBLOOP EQU   *\n         CLI   DIRNAME,X'FF'          Last member\n         BE    FINISH                 yes - finished\nGOTMEMBR EQU   *\n         AP    PCNT,=PL3'1'           Add to member count\n         MVC   0(16,R4),=CL16'PDS_MEMBER_NAME.'\n         MVC   SHVNAML,=F'16'         Set name+length\n         MVC   0(8,R5),DIRNAME        Set value\n         MVC   SHVVALL,=F'8'          Set value length\n         BAL   R10,STEMNAME           Create stem name\n         BAL   R10,MAKEVAR            Create variable\nNEXTDIRE EQU   *\n         XR    R15,R15                Clear\n         NI    DIRC,X'1F'             Clear alias indicator\n         IC    R15,DIRC               Get number of user words\n         SLL   R15,1                  x2 = number of bytes\n         LA    R15,12(R15)            Add fixed portion\n         AR    R9,R15                 Add to current address\n         C     R9,ENDDIR              End of directory block ?\n         BNH   DIRBLOOP               No - carry on\nNEXTDIR  EQU   *\n         B     DIRLOOP                Yes - get next directory\nFINISH   EQU   *\n*--------------------------------------------------------------------*\n* We have finished with the dataset. Close and free it and then\n* set up the 'zero' stem values.\n*--------------------------------------------------------------------*\n         CLOSE (PDSDCB),                                               x\n               MF=(E,CLOSDCB)         Use this parm list\n         MVC   DDNKEY,=AL2(DALDDNAM)  Overwite DDName Key\n         LA    R1,DDNKEY              Point to DDName\n         ST    R1,ALLOCTU             Store as Text Unit\n         OI    ALLOCTU,X'80'          Indicate last\n         MVI   S99VERB,S99VRBUN       Change ALLOC to FREE\n         LA    R1,ALLOCRBP            Point to SVC99 parm list\n         DYNALLOC                     call SVC 99\n         MVC   0(17,R4),=CL17'PDS_MEMBER_NAME.0'\n         MVC   SHVNAML,=F'17'         Set length\n         UNPK  UCNT,PCNT              Unpack loop count\n         OI    UCNT+3,X'F0'           Remove sign\n         MVC   0(4,R5),UCNT           Copy value\n         MVC   SHVVALL,=F'4'          Set length of value\n         BAL   R10,MAKEVAR            Set zero stem value\nRETURN00 EQU   *\n*--------------------------------------------------------------------*\n* Return to the user - all OK\n*--------------------------------------------------------------------*\n         MVC   EVALBLOCK_EVLEN(4),=F'1' Set length of result\n         MVI   EVALBLOCK_EVDATA,C'0'\n         BAL   R10,RELSHVB            free the SHVB area\n         BAL   R10,RELWORK            free the workarea\n         XR    R15,R15                set rc to ZERO\n         PR                           return\nRETURN02 EQU   *\n*--------------------------------------------------------------------*\n* Return to the user - dataset is migrated\n*--------------------------------------------------------------------*\n         MVC   EVALBLOCK_EVLEN(4),=F'1' Set length of result\n         MVI   EVALBLOCK_EVDATA,C'2'\n         BAL   R10,RELSHVB            free the SHVB area\n         BAL   R10,RELWORK            free the workarea\n         XR    R15,R15                set rc to ZERO\n         PR                           return\nRETURN04 EQU   *\n*--------------------------------------------------------------------*\n* Return to the user - could not find dataset\n*--------------------------------------------------------------------*\n         MVC   EVALBLOCK_EVLEN(4),=F'1' Set length of result\n         MVI   EVALBLOCK_EVDATA,C'4'\n         BAL   R10,RELSHVB            free the SHVB area\n         BAL   R10,RELWORK            free the workarea\n         XR    R15,R15                set rc to ZERO\n         PR                           return\nRETURN08 EQU   *\n*--------------------------------------------------------------------*\n* Return to the user - parameter error\n*--------------------------------------------------------------------*\n         MVC   EVALBLOCK_EVLEN(4),=F'1' Set length of result\n         MVI   EVALBLOCK_EVDATA,C'8'\n         BAL   R10,RELSHVB            free the SHVB area\n         BAL   R10,RELWORK            free the workarea\n         XR    R15,R15                set rc to ZERO\n         PR                           return\nRETURNCC EQU   *\n*--------------------------------------------------------------------*\n* Return to the user - dynalloc error\n*--------------------------------------------------------------------*\n         MVC   EVALBLOCK_EVLEN(4),=F'8' Set length of result\n         MVC   EVALBLOCK_EVDATA(8),ERRCODE\n         BAL   R10,RELSHVB            free the SHVB area\n         BAL   R10,RELWORK            free the workarea\n         XR    R15,R15                set rc to ZERO\n         PR                           return\n*\n*--------------------------------------------------------------------*\n* General Routines\n*--------------------------------------------------------------------*\n*\nMAKEVAR  EQU   *\n*--------------------------------------------------------------------*\n* Link to IRXEXCOM to create the REXX variable\n*--------------------------------------------------------------------*\n         LA    R1,EXCOMID             Point to IRXEXCOM id\n         ST    R1,AEXCOMP1            Store in parm list\n         LA    R1,ZERO                Point to fullword ZERO\n         ST    R1,AEXCOMP2            Store in parm list\n         ST    R1,AEXCOMP3            Store in parm list\n         ST    R11,AEXCOMP4           Store SHVB as parm #4\n         LA    R1,ZERO                Point to fullword ZERO\n         ST    R1,AEXCOMP5            Store in parm list\n         LA    R1,EXCOMRC             Point to return code\n         ST    R1,AEXCOMP6            Store in parm list\n         OI    AEXCOMP6,X'80'         Indicate end of list\n         MVI   SHVCODE,SHVSTORE       Indicate \"Set\"\n         MVC   SHVNAMA,ASHVNAMA       Point to name buffer\n         MVC   SHVVALA,ASHVVALA       Point to value buffer\n         LA    R1,EXCOMPRM            Point to the parm list\n         L     R15,AIRXEXCM           Load address of routine\n         BALR  R14,R15                Call it\n         BR    R10\n*\nSTEMNAME EQU   *\n*-------------------------------------------------------------------*\n* Routine to construct a REXX stem name from the core variable\n* name plus a packed index count.\n*-------------------------------------------------------------------*\n         LR    R15,R4                 Point to the name\n         A     R15,SHVNAML            add on length of name\n         UNPK  UCNT,PCNT              unpack the count\n         OI    UCNT+3,X'F0'           get rid of sign\nTHOUSAND EQU   *\n         CLI   UCNT,C'0'              is there a ZERO ?\n         BE    HUNDRED                yes - UCNT < 1000\n         MVC   0(4,R15),UCNT          add on to name\n         L     R15,SHVNAML            load up current length\n         A     R15,=F'4'              add four\n         ST    R15,SHVNAML            store as new length\n         B     STEMDONE\nHUNDRED  EQU   *\n         CLI   UCNT+1,C'0'            is there a ZERO ?\n         BE    TENS                   yes - UCNT < 100\n         MVC   0(3,R15),UCNT+1        add on to name\n         L     R15,SHVNAML            load up current length\n         A     R15,=F'3'              add three\n         ST    R15,SHVNAML            store as new length\n         B     STEMDONE\nTENS     EQU   *\n         CLI   UCNT+2,C'0'            is there a ZERO ?\n         BE    UNITS                  yes - UCNT < 10\n         MVC   0(2,R15),UCNT+2        add on to name\n         L     R15,SHVNAML            load up current length\n         A     R15,=F'2'              add two\n         ST    R15,SHVNAML            store as new length\n         B     STEMDONE\nUNITS    EQU   *\n         MVC   0(1,R15),UCNT+3        add on to name\n         L     R15,SHVNAML            load up current length\n         LA    R15,1(R15)             add one\n         ST    R15,SHVNAML            store as new length\nSTEMDONE EQU   *\n         BR    R10\n*\nHEX2CHAR EQU   *\n*--------------------------------------------------------------------*\n* Convert a hex string to EBCDIC\n* Registers on entry :\n* R0 - Length of input hex bytes\n* R1 - Input hex bytes\n* R15- Output EBCDIC area\n*\n* R14 is used as a work register\n*\n*--------------------------------------------------------------------*\nLEFTHALF EQU   *\n         XR    R14,R14                Clear\n         ICM   R14,B'0001',0(R1)      Load up a byte (000000ab)\n         SRL   R14,4                  Remove last 4 bits (0000000a)\nLEFTNUM  EQU   *\n         CH    R14,=H'9'              00000000 - 00000009 ?\n         BH    LEFTLTTR               higher - must be A-F\n         AH    R14,=H'240'            xlate to F0-F9\n         B     LEFTDONE\nLEFTLTTR EQU   *\n         AH    R14,=H'183'            xlate to C1-C6\nLEFTDONE EQU   *\n         STCM  R14,B'0001',0(R15)     Store in output field\n         LA    R15,1(R15)             Point to next char\nRGHTHALF EQU   *\n         XR    R14,R14                Clear\n         ICM   R14,B'0001',0(R1)      Load up a byte (000000ab)\n         SLL   R14,28                 Remove first 4 bits (b0000000)\n         SRL   R14,28                 and reset           (0000000b)\nRGHTNUM  EQU   *\n         CH    R14,=H'9'              00000000 - 00000009 ?\n         BH    RGHTLTTR               higher - must be A-F\n         AH    R14,=H'240'            xlate to F0-F9\n         B     RGHTDONE\nRGHTLTTR EQU   *\n         AH    R14,=H'183'            xlate to C1-C6\nRGHTDONE EQU   *\n         STCM  R14,B'0001',0(R15)     Store in output area\n         LA    R15,1(R15)             Point to next char\n         LA    R1,1(R1)               Point to next input byte\n         BCT   R0,LEFTHALF            Loop for all bytes\n         BR    R10                    return\n*\nRELWORK  EQU   *\n*--------------------------------------------------------------------*\n* Release workarea storage\n*--------------------------------------------------------------------*\n         DELETE EP=IRXEXCOM           Delete IRXEXCOM from storage\n         STORAGE RELEASE,             release workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in R13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         BR    R10                    return\n*\nRELSHVB  EQU   *\n*--------------------------------------------------------------------*\n* Release SHVB storage\n*--------------------------------------------------------------------*\n         STORAGE RELEASE,             release SHVB storage             X\n               LENGTH=4096,           this much                        X\n               ADDR=(R11),            address in R11                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         BR    R10                    return\n*\n*\n*-------------------------------------------------------------------*\n* Executed instructions\n*-------------------------------------------------------------------*\n*\nMOVEDSN  MVC   DATASET(0),0(R8)       Copy dataset name\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs\n*-------------------------------------------------------------------*\n*\n         LTORG\nEXCOMID  DC    CL8'IRXEXCOM'          IRXEXCOM ID\nZERO     DC    F'0'                   ZERO fullword\nHEXFF    DC    X'FFFFFFFF'            high values\nBLANKS   DC    44C' '                 Blanks\n*\nDCBM     DCB   DDNAME=SYSXXXXX,       DCB for PDS directory            x\n               RECFM=F,                                                x\n               DSORG=PS,                                               x\n               LRECL=256,                                              x\n               BLKSIZE=256,                                            x\n               MACRF=GM,                                               x\n               EODAD=FINISH\nDCBL     EQU   *-DCBM                 Length of DCB\nOPENM    OPEN  (,),MF=L               Model macro for OPEN\nOPENL    EQU   *-OPENM                Length of macro\nCLOSM    CLOSE (,),MF=L               Model macro for CLOSE\nCLOSL    EQU   *-CLOSM                Length of macro\nCAMNAME  CAMLST NAME,ZERO,,ZERO       Model macro for LOCATE\nCAMNAMEL EQU   *-CAMNAME              Length of macro\nCAMSRCH  CAMLST SEARCH,ZERO,ZERO,ZERO Model macro for OBTAIN\nCAMSRCHL EQU   *-CAMSRCH              Length of macro\n*\n         DS    0F\nSHRKEY   DC    AL2(DALSTATS)          Key for DISP\nSHRNUM   DC    AL2(1)                 #\nSHRLEN   DC    AL2(1)                 Length\nSHR      DC    X'08'                  SHR\n*\n         DS    0F\nUNTKEY   DC    AL2(DALUNIT)           Key for UNIT\nUNTNUM   DC    AL2(1)                 #\nUNTLEN   DC    AL2(8)                 Length\nUNIT     DC    CL8'SYSALLDA'          UNIT=SYSALLDA\n*\nUPPER    DS    0CL256\n         DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                    save area\nAIRXEXCM DS    F                      address of IRXEXCOM\nASHVNAMA DS    F                      address of SHVB name buffer\nASHVVALA DS    F                      address of SHVB value buffer\nNAMALEN  DS    F                      length of SHVB name buffer\nVALALEN  DS    F                      length of SHVB value buffer\nEXCOMRC  DS    F                      Return code from IRXEXCOM\nEXCOMPRM DS    0F                     Parm list for IRXEXCOM\nAEXCOMP1 DS    F                      ---> IRXEXCOM ID\nAEXCOMP2 DS    F                      ---> 0\nAEXCOMP3 DS    F                      ---> 0\nAEXCOMP4 DS    F                      ---> SHVBLOCK\nAEXCOMP5 DS    F                      ---> ENVBLOCK\nAEXCOMP6 DS    F                      ---> Return Code\n         DS    0F\nUCNT     DS    F                      Unpack field\nPCNT     DS    PL3                    packed count field\n         DS    0F\nUWORK    DS    F                      unpack work\n         DS    0D\nPWORK    DS    D                      packed work\n         DS    0F\nALLOCRBP DS    F                      Address of ALLOC RB\nALLOCRB  DS    CL20                   Space for ALLOC SVC99 RB\n         DS    0F\nALLOCTU  DS    5F                     Space for ALLOC SVC99 TU ptrs\n* Dataset Text Unit for DDname Allocation (Generate SYSxxxxx)\nDDNKEY   DS    XL2                    SVC99 Key for ddname\nDDNNUM   DS    XL2                    SVC99 Number\nDDNLEN   DS    XL2                    SVC99 Length of ddname\nDDNAME   DS    CL8                    DD Name\n* Dataset Text Unit for Dynamic Allocation\nDSNKEY   DS    XL2                    SVC99 Key for dataset\nDSNNUM   DS    XL2                    SVC99 Number\nDSNLEN   DS    XL2                    SVC99 Length of dataset\nDATASET  DS    CL44                   Dataset Name\n* Volume Serial Text Unit for Dynamic Allocation\nVOLKEY   DS    XL2                    SVC99 Key for volser\nVOLNUM   DS    XL2                    SVC99 Number\nVOLLEN   DS    XL2                    SVC99 Length of volser\nVOLSER   DS    CL6                    Volume\n*\nPDSDCB   DS    CL(DCBL)               Area for DCB\nOPENDCB  DS    CL(OPENL)              Area for OPEN\nCLOSDCB  DS    CL(CLOSL)              Area for CLOSE\nDSCB1    DS    CL140                  Area for F1-DSCB\n         DS    0F\nLOCATE1  DS    CL(CAMNAMEL)           Area for LOCATE\n         DS    0F\nOBTAIN1  DS    CL(CAMSRCHL)           Area for OBTAIN\n         DS    0F\nERRCODE  DS    CL8\nENDDIR   DS    F                      End address of dir block\nNAMEWORK DS    CL256                  Work area for LOCATE/OBTAIN\nINDIR    DS    CL256                  Directory block input\nWORKLEN  EQU   *-WORKAREA\n*\n* Directory Block mapping\n*\nDIR      DSECT\nDIRNAME  DS    CL8                    Member name\nDIRTTR   DS    XL3                    TTR\nDIRC     DS    X\nDIRUDAT  DS    0C\n*\nF1DSCB   DSECT                        F1-DSCB mapping\n         IECSDSL1 (1)\n*\n         IRXEFPL                      REXX External Function\n         IRXEVALB                     REXX Evaluation Block\n         IRXSHVB                      REXX Shared Variable Block\n         IRXARGTB DECLARE=YES         REXX Shared Variable Block\n         IEFZB4D0\n         IEFZB4D2\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LISTSY$": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99&_\\x00\\x99&_\\t\\x14\\x002\\x002\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-22T00:00:00", "modifydate": "1999-09-22T09:14:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "FILE411"}, "text": " REXX Function to Place MVS Static Symbols into Stem Variables\n -------------------------------------------------------------\n\n Installation of LISTSYM\n\n Assemble and link LISTSYM into a load library that is\n available to your TSO userid. Use the following\n linkedit attributes :\n\n    AMODE(31)\n    RMODE(ANY)\n    RENT\n    REUS\n    AC(0)\n\n To use the VIEWSYM example edit macro, place VIEWSYM in a dataset\n that is in your SYSEXEC or SYSPROC concatenation.\n\n Using LISTSYM\n\n This program provides an external REXX function to place\n the MVS Static Symbol names and values into REXX stem\n variables.\n\n The following REXX stem variables are created :\n\n (a) MVS_SYMBOL_NAME.   Static Symbol Name\n (b) MVS_SYMBOL_VALUE.  Static Symbol Value\n\n\n Syntax :\n\n   rcode = LISTSYM()\n\n Keywords :\n\n   RCODE   The return code from the LISTSYM function (always 0)\n\n\n Example :\n\n   /* REXX */\n   rcode = LISTSYM()\n   if rcode <> 0 then exit\n   i = 1\n   do MVS_SYMBOL_NAME.0\n     say MVS_SYMBOL_NAME.i MVS_SYMBOL_VALUE.i\n     i = i + 1\n     end\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "LISTSY@": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x99&o\\x00\\x99&o\\x117\\x00\\x18\\x00\\x18\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1999-09-23T00:00:00", "modifydate": "1999-09-23T11:37:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "FILE411"}, "text": "//* ADD A JOBCARD\n//*\n//* (1) CHANGE 'SYS2.SEC.SRC' TO THIS DATASET NAME\n//* (2) CHANGE 'SYS2.SEC.LOAD' TO YOUR LOAD LIBRARY DATASET NAME\n//*\n//*\n//ASM  EXEC PGM=ASMA90\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DSN=SYS2.SEC.SRC(LISTSYM),DISP=SHR\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(,PASS),UNIT=SYSALLDA,\n//         DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=3200),\n//         SPACE=(CYL,(2,1))\n//*\n//LINK EXEC PGM=HEWL,PARM='MAP,LET,LIST,XCAL,RENT',COND=(8,LT,ASM)\n//SYSLMOD  DD  DSN=SYS2.SEC.LOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE,DELETE)\n//         DD  *\n  ENTRY LISTSYM\n  NAME LISTSYM(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LISTSYM": {"ttr": 2056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99&o\\x00\\x99&o\\x14\\x16\\x01\\x8a\\x01\\x8a\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-23T00:00:00", "modifydate": "1999-09-23T14:16:00", "lines": 394, "newlines": 394, "modlines": 0, "user": "FILE411"}, "text": "LISTSYM TITLE 'Gather MVS Static Symbols and Create REXX Stems'\n*-------------------------------------------------------------------*\n* Function        : This program provides an external REXX function\n*                   to place the MVS Static Symbol names and values\n*                   into REXX Stem variables.\n*\n*                   The following REXX Stem variables are created :\n*                   (a) MVS_SYMBOL_NAME.   Static Symbol Name\n*                   (b) MVS_SYMBOL_VALUE.  Static Symbol Value\n*\n*\n* Syntax          : x = LISTSYM()\n*\n* Example         : /* REXX */\n*\n*                   x = listsym()\n*                   i = 1\n*                   do MVS_SYMBOL_NAME.0\n*                      say MVS_SYMBOL_NAME.i MVS_SYMBOL_VALUE.i\n*                      i = i + 1\n*                      end\n*\n*\n* IBM Macros Used : MODID, STORAGE, LOAD, DELETE, CVT, IHAECVT,\n*                   ASASYMBP, IRXEVALB, IRXEFPL, IRXSHVB\n*\n* Attributes      : Amode(31)\n*                   Rmode(Any)\n*                   RENT\n*                   REUS\n*                   NOREFR\n*                   AC(0)\n*\n* Register Usage  :\n*\n* R1  - Parms passed              : +0 ---> REXX EFPL\n* R2  - EFPL\n* R3  - EVALBLOCK\n* R4  - Name buffer address\n* R5  - Value buffer address\n* R6  - Number of symbols (branch and count)\n* R7  - SYMBTE Start address\n* R8  - SYMBTE floating pointer\n* R9  - SYMBT\n* R10 - Branch and Link\n* R11 - SHVBLOCK\n* R12 - Base reg\n* R13 - Workarea\n*\n*-------------------------------------------------------------------*\n* (c) Scott Enterprise Consultancy Ltd\n*-------------------------------------------------------------------*\n* Changes\n* 17/06/1996  Rob Scott  Code Written                            V1.0\n*-------------------------------------------------------------------*\nLISTSYM  CSECT\nLISTSYM  AMODE 31\nLISTSYM  RMODE ANY\n         BAKR  R14,R0                 linkage stack\n         LR    R12,R15                set R12 as base\n         USING LISTSYM,R12            address it\n         MODID ,                      eyecatcher\n         LR    R2,R1                  copy any parms passed\nGETWORK  EQU   *\n*--------------------------------------------------------------------*\n* Get some workarea storage and init to zeros. We also load the\n* address of IRXEXCOM for later calls.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in r13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=ANY,               above the line                   X\n               COND=NO                unconditional\n         USING WORKAREA,R13           address workarea\n         LR    R14,R13                Copy workarea address\n         L     R15,=A(WORKLEN)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to zeros\n         MVC   4(4,R13),=C'F1SA'      set label in savearea\n         LOAD  EP=IRXEXCOM            Get address of IRXEXCOM\n         ST    R0,AIRXEXCM            Store for later\nGETPARMS EQU   *\n*--------------------------------------------------------------------*\n* Process the parms passed to this REXX function. This will be the\n* standard REXX function parameter list.\n*--------------------------------------------------------------------*\n         USING EFPL,R2                address REXX function parms\n         L     R3,EFPLEVAL            Get pointer to Eval_Block\n         L     R3,0(R3)               REXX Eval_Block address\n         USING EVALBLOCK,R3           Address it\nGETSHVB  EQU   *\n*--------------------------------------------------------------------*\n* Create the storage for the REXX SHVB (required by IRXECCOM).\n* We reserve 250 bytes for the variable name and 3K for the value\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the SHVBLOCK storage         X\n               LENGTH=4096,           this much                        X\n               ADDR=(R11),            address in r11                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=ANY,               above the line                   X\n               COND=NO                unconditional\n         USING SHVBLOCK,R11           address SHVBLOCK\n         LA    R4,SHVBLEN(R11)        Point to name buffer\n         ST    R4,ASHVNAMA            Store for IRXEXCOM\n         MVC   NAMALEN,=F'250'        Set length of name buffer\n         LA    R5,256(R4)             Point to value buffer\n         ST    R5,ASHVVALA            Store for IRXEXCOM\n         MVC   VALALEN,=F'3072'       Set length of value buffer\nGETSYMBT EQU   *\n*-------------------------------------------------------------------*\n* Chain through control blocks to find the SYMBT\n*-------------------------------------------------------------------*\n         L     R6,CVTPTR              Get CVT address\n         USING CVTMAP,R6              address it\n         L     R6,CVTECVT             Get ECVT address\n         USING ECVT,R6                address it\n         ICM   R9,B'1111',ECVTSYMT    Point to Symbol Table\n         BZ    RETURN00               if none - exit\n         USING SYMBT,R9               address it\n*-------------------------------------------------------------------*\n* We now have the address of the symbol table. We need to get the\n* address of the first entry in the table. This will be found by\n* either:\n*   a) Getting the address of the SYMBTTABLEENTRIES field\n* or:\n*   b) Getting the address of the SYMBTTABLEENTRIES field\n*   c) Getting the contents of SYMBTESYMBOLAREAADDR from the SYMBTE\n*      area if the symbol table is in indirect mode.\n*-------------------------------------------------------------------*\n         LA    R7,SYMBTTABLEENTRIES   Point to symbol table entries\n         USING SYMBTE,R7              address it\n*-------------------------------------------------------------------*\n* Now test if the symbol table is indirect\n*-------------------------------------------------------------------*\n         TM    SYMBTFLAG1,SYMBTINDIRECTSYMBOLAREA\n*\n         BNO   NORMSYMT               Normal symbol table\n*-------------------------------------------------------------------*\n* Symbol table is indirect, therefore replace address of the SYMBTE\n* with the contents of SYMBTESYMBOLAREAADDR.\n*-------------------------------------------------------------------*\n         L     R7,SYMBTESYMBOLAREAADDR\n         DROP  R7                     Drop R7 addressability to SYMBTE\nNORMSYMT EQU   *\n         LR    R8,R7                  Copy the SYMBTE address\n         USING SYMBTE,R8              Map it using R8\n*                                     Get number of active symbols\n         XR    R6,R6                  Clear R6\n         ICM   R6,B'0011',SYMBTNUMBEROFSYMBOLS\n         BZ    RETURN00               If none - exit\n*-------------------------------------------------------------------*\n* Set up the 'ZERO' stem values to tell REXX how many entries we\n* have on the stems.\n*-------------------------------------------------------------------*\n         MVC   0(17,R4),=C'MVS_SYMBOL_NAME.0'\n         MVC   SHVNAML,=F'17'         Set length of name\n         CVD   R6,PWORK               convert number to packed\n         UNPK  UWORK,PWORK            unpack it\n         OI    UWORK+3,X'F0'          remove sign\n         MVC   0(4,R5),UWORK          set the value\n         MVC   SHVVALL,=F'4'          set the value length\n         BAL   R10,MAKEVAR            Create REXX variable\n         MVC   0(18,R4),=C'MVS_SYMBOL_VALUE.0'\n         MVC   SHVNAML,=F'18'         Set length of name\n         MVC   0(4,R5),UWORK          set the value\n         MVC   SHVVALL,=F'4'          set the value length\n         BAL   R10,MAKEVAR            Create REXX variable\n*\n         MVC   PCNT,=PL3'1'           Set to first stem number\n*\nSYMTABLE EQU   *\n*-------------------------------------------------------------------*\n* This code will loop through all of the entries in the symbol\n* table. Each entry contains a pointer to the name and value of\n* a symbol. The pointers can be real addresses *or* offsets from\n* the beginning of the SYMBTE table. We use R2 here to point to\n* the required storage, initially it is set to the start address\n* of the symbte table.\n* (o) If the pointers are offsets, they are added to the contents\n*     of R2. If the pointers are addresses, R2 is set\n* (o) If the pointers are addresses, R2 is set to zero before the\n*     add\n*-------------------------------------------------------------------*\n         LR    R2,R7                  Copy start address of SYMBTE\n         TM    SYMBTFLAG0,SYMBTPTRSAREOFFSETS\n         BO    CONTINU1               ptrs are offsets - carry on\n         LA    R2,0                   ptrs are addresses - zero R2\nCONTINU1 EQU   *\n         MVC   0(16,R4),=C'MVS_SYMBOL_NAME.'\n         MVC   SHVNAML,=F'16'         move in length of name\n         BAL   R10,STEMNAME           add stem number\n*-------------------------------------------------------------------*\n* Now point to the name of the symbol - just add the address to\n* whatever is in r2 (either '0' or start address of SYMBTE)\n*-------------------------------------------------------------------*\n         A     R2,SYMBTESYMBOLOFFSET  point to symbol name\n         MVC   SHVVALL,SYMBTESYMBOLLENGTH\n         L     R15,SYMBTESYMBOLLENGTH get length of name\n         BCTR  R15,R0                 minus one for move\n         EX    R15,MOVEVAL            move in the name\n         BAL   R10,MAKEVAR            Create REXX Variable\n         MVC   0(17,R4),=C'MVS_SYMBOL_VALUE.'\n         MVC   SHVNAML,=F'17'         move in length of name\n         BAL   R10,STEMNAME           add stem number\n         LR    R2,R7                  copy start address of SYMBTE\n         TM    SYMBTFLAG0,SYMBTPTRSAREOFFSETS\n         BO    CONTINU2               ptrs are offsets - carry on\n         LA    R2,0                   ptrs are addresses - zero R2\nCONTINU2 EQU   *\n*-------------------------------------------------------------------*\n* Now point to the value of the symbol - just add the address to\n* whatever is in r2 (either '0' or start address of SYMBTE)\n*-------------------------------------------------------------------*\n         A     R2,SYMBTESUBTEXTOFFSET  point to symbol name\n         MVC   SHVVALL,SYMBTESUBTEXTLENGTH\n         L     R15,SYMBTESUBTEXTLENGTH\n         BCTR  R15,R0                 minus one for move\n         EX    R15,MOVEVAL            move in the value\n         BAL   R10,MAKEVAR            Create REXX Variable\nNEXTSYM  EQU   *\n         LA    R8,SYMBTE_LEN(R8)      get next entry\n         AP    PCNT,=PL3'1'           add to stem count\n         BCT   R6,SYMTABLE            loop back\n*\nRETURN00 EQU   *\n*--------------------------------------------------------------------*\n* Return to the user\n*--------------------------------------------------------------------*\n         MVC   EVALBLOCK_EVLEN(4),=F'1' Set length of result\n         MVI   EVALBLOCK_EVDATA,C'0'\n         BAL   R10,RELSHVB            free the SHVB area\n         BAL   R10,RELWORK            free the workarea\n         XR    R15,R15                set rc to zero\n         PR                           return\n*\n*--------------------------------------------------------------------*\n* General Routines\n*--------------------------------------------------------------------*\n*\nMAKEVAR  EQU   *\n*--------------------------------------------------------------------*\n* Link to IRXEXCOM to create the REXX variable\n*--------------------------------------------------------------------*\n         LA    R1,EXCOMID             Point to IRXEXCOM id\n         ST    R1,AEXCOMP1            Store in parm list\n         LA    R1,ZERO                Point to fullword zero\n         ST    R1,AEXCOMP2            Store in parm list\n         ST    R1,AEXCOMP3            Store in parm list\n         ST    R11,AEXCOMP4           Store SHVB as parm #4\n         LA    R1,ZERO                Point to fullword zero\n         ST    R1,AEXCOMP5            Store in parm list\n         LA    R1,EXCOMRC             Point to return code\n         ST    R1,AEXCOMP6            Store in parm list\n         OI    AEXCOMP6,X'80'         Indicate end of list\n         MVI   SHVCODE,SHVSTORE       Indicate \"Set\"\n         MVC   SHVNAMA,ASHVNAMA       Point to name buffer\n         MVC   SHVVALA,ASHVVALA       Point to value buffer\n         LA    R1,EXCOMPRM            Point to the parm list\n         L     R15,AIRXEXCM           Load address of routine\n         BALR  R14,R15                Call it\n         BR    R10\n*\nSTEMNAME EQU   *\n*-------------------------------------------------------------------*\n* Routine to construct a REXX stem name from the core variable\n* name plus a packed index count.\n*-------------------------------------------------------------------*\n         LR    R15,R4                 Point to the name\n         A     R15,SHVNAML            add on length of name\n         UNPK  UCNT,PCNT              unpack the count\n         OI    UCNT+3,X'F0'           get rid of sign\nTHOUSAND EQU   *\n         CLI   UCNT,C'0'              is there a zero ?\n         BE    HUNDRED                yes - UCNT < 1000\n         MVC   0(4,R15),UCNT          add on to name\n         L     R15,SHVNAML            load up current length\n         A     R15,=F'4'              add four\n         ST    R15,SHVNAML            store as new length\n         B     STEMDONE\nHUNDRED  EQU   *\n         CLI   UCNT+1,C'0'            is there a zero ?\n         BE    TENS                   yes - UCNT < 100\n         MVC   0(3,R15),UCNT+1        add on to name\n         L     R15,SHVNAML            load up current length\n         A     R15,=F'3'              add three\n         ST    R15,SHVNAML            store as new length\n         B     STEMDONE\nTENS     EQU   *\n         CLI   UCNT+2,C'0'            is there a zero ?\n         BE    UNITS                  yes - UCNT < 10\n         MVC   0(2,R15),UCNT+2        add on to name\n         L     R15,SHVNAML            load up current length\n         A     R15,=F'2'              add two\n         ST    R15,SHVNAML            store as new length\n         B     STEMDONE\nUNITS    EQU   *\n         MVC   0(1,R15),UCNT+3        add on to name\n         L     R15,SHVNAML            load up current length\n         LA    R15,1(R15)             add one\n         ST    R15,SHVNAML            store as new length\nSTEMDONE EQU   *\n         BR    R10\n*\nRELWORK  EQU   *\n*--------------------------------------------------------------------*\n* Release workarea storage\n*--------------------------------------------------------------------*\n         DELETE EP=IRXEXCOM           Delete IRXEXCOM from storage\n         STORAGE RELEASE,             release workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in R13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         BR    R10                    return\n*\nRELSHVB  EQU   *\n*--------------------------------------------------------------------*\n* Release SHVB storage\n*--------------------------------------------------------------------*\n         STORAGE RELEASE,             release SHVB storage             X\n               LENGTH=4096,           this much                        X\n               ADDR=(R11),            address in R11                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         BR    R10                    return\n*\n*\n*-------------------------------------------------------------------*\n* Executed instructions\n*-------------------------------------------------------------------*\nMOVEVAL  MVC   0(0,R5),0(R2)\n*\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs\n*-------------------------------------------------------------------*\n*\n         LTORG\nEXCOMID  DC    CL8'IRXEXCOM'          IRXEXCOM ID\nZERO     DC    F'0'                   Zero fullword\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                    save area\nAIRXEXCM DS    F                      address of IRXEXCOM\nASHVNAMA DS    F                      address of SHVB name buffer\nASHVVALA DS    F                      address of SHVB value buffer\nNAMALEN  DS    F                      length of SHVB name buffer\nVALALEN  DS    F                      length of SHVB value buffer\nEXCOMRC  DS    F                      Return code from IRXEXCOM\nEXCOMPRM DS    0F                     Parm list for IRXEXCOM\nAEXCOMP1 DS    F                      ---> IRXEXCOM ID\nAEXCOMP2 DS    F                      ---> 0\nAEXCOMP3 DS    F                      ---> 0\nAEXCOMP4 DS    F                      ---> SHVBLOCK\nAEXCOMP5 DS    F                      ---> ENVBLOCK\nAEXCOMP6 DS    F                      ---> Return Code\n         DS    0F\nUCNT     DS    F                      Unpack field\nPCNT     DS    PL3                    packed count field\n         DS    0F\nUWORK    DS    F                      unpack work\nPWORK    DS    D                      packed work\nWORKLEN  EQU   *-WORKAREA\n*\n*\n         IRXEFPL                      REXX External Function\n         IRXEVALB                     REXX Evaluation Block\n         IRXSHVB                      REXX Shared Variable Block\n         CVT DSECT=YES,LIST=YES       CVT\n         IHAECVT LIST=YES             ECVT\n         ASASYMBP DSECT=YES,          Symbol tables                    X\n               LIST=YES,                                               X\n               SYMBP=NO,                                               X\n               SYMBT=YES,                                              X\n               SYMBTE=YES\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SLEE$": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99&_\\x00\\x99&_\\t\\x16\\x00+\\x00+\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-22T00:00:00", "modifydate": "1999-09-22T09:16:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "FILE411"}, "text": " REXX Function to wait for a specified time\n ------------------------------------------\n\n Installation of SLEEP\n\n Assemble and link SLEEP into a load library that is\n available to your TSO userid. Use the following\n linkedit attributes :\n\n        AMODE(31)\n        RMODE(ANY)\n        RENT\n        REUS\n        AC(0)\n\n Using SLEEP\n\n The program will wait for a specified amount of seconds. The number\n of seconds to wait for is passed as a parameter to the function\n by the invoking REXX Exec. If no parameter is passed, a default of\n 10 seconds is used. The maximum specification is 99999 seconds.\n\n Syntax :\n\n     rcode = SLEEP(secs)\n\n Keywords :\n\n     RCODE\n       The return code from the SLEEP function. This can be one of\n       the following values :\n         0  - Successful execution of the function\n        -1  - Error in the parameter passed. Verify that the\n              seconds passed is numeric and between 1 and 99999.\n\n     SECS\n       The number of seconds to wait for. This value can be between 1 and\n       99999. If not specified, SLEEP will use a default value of 10.\n\n Example :\n\n   rcode = SLEEP(60)  /* Wait for a minute */\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SLEE@": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99&o\\x00\\x99&o\\x119\\x00\\x18\\x00\\x18\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-23T00:00:00", "modifydate": "1999-09-23T11:39:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "FILE411"}, "text": "//* ADD A JOBCARD\n//*\n//* (1) CHANGE 'SYS2.SEC.SRC' TO THIS DATASET NAME\n//* (2) CHANGE 'SYS2.SEC.LOAD' TO YOUR LOAD LIBRARY DATASET NAME\n//*\n//*\n//ASM  EXEC PGM=ASMA90\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DSN=SYS2.SEC.SRC(SLEEP),DISP=SHR\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(,PASS),UNIT=SYSALLDA,\n//         DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=3200),\n//         SPACE=(CYL,(2,1))\n//*\n//LINK EXEC PGM=HEWL,PARM='MAP,LET,LIST,XCAL,RENT',COND=(8,LT,ASM)\n//SYSLMOD  DD  DSN=SYS2.SEC.LOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE,DELETE)\n//         DD  *\n  ENTRY SLEEP\n  NAME SLEEP(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SLEEP": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99\\x16\\x7f\\x00\\x99&_\\x08\\x14\\x00\\xc4\\x00\\xc3\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-06-16T00:00:00", "modifydate": "1999-09-22T08:14:00", "lines": 196, "newlines": 195, "modlines": 0, "user": "FILE411"}, "text": "SLEEP    TITLE 'REXX function to wait for a specified time'\n*--------------------------------------------------------------------*\n* Program Name  : SLEEP\n*\n* Language      : Assembler\n* LinkEdit Attr : RENT REUS REFR\n* AMODE         : 31\n* RMODE         : ANY\n* AC            : 00\n*\n* IBM Macros    : MODID, STORAGE, STIMER\n*\n*--------------------------------------------------------------------*\n* Program Function\n*\n* External REXX function to wait for a specified time.\n*\n* The program will wait for a specified amount of seconds. The number\n* of seconds to wait for is passed as a parameter to the function\n* by the invoking REXX Exec. If no parameter is passed, a default of\n* 10 seconds is used. The maximum specification is 99999 seconds.\n*\n* Syntax\n*\n* rcode = sleep(secs)\n*\n* Keywords\n*\n* RCODE   The return code from sleep  :  0  Success\n*                                     : -1  Parameter error\n* SECS    The number of seconds to wait for (1 - 99999)\n*\n*--------------------------------------------------------------------*\n* Registers On Entry\n*\n* R0   -  n/a\n* R1   -  Paramters passed ---> +0  REXX EFPL\n* R15  -  n/a\n*\n* Registers Used in Program\n*\n* R2   -  REXX EFPL\n* R3   -  REXX Evalblock\n* R4   -  REXX Arg Table\n* R5   -  REXX Arg passed = time in seconds\n* R6   -  Length of arg passed\n* R7   -  work\n* R8   -\n* R9   -\n* R10  -  Branch and Link\n* R11  -\n* R12  -  Base Register\n* R13  -  Savearea\n*\n* Registers On Exit\n*\n* R0   -  n/a\n* R1   -  n/a\n* R15  -  Return Code : 0 - Success\n*\n*--------------------------------------------------------------------*\n* (c) Scott Enterprise Consultancy Ltd\n*--------------------------------------------------------------------*\n* Changes\n* 01/11/1996  Rob Scott  Code Written                             V1.0\n* 21/06/1999  Rob Scott  Correct typo in PARMERR                  V1.1\n*--------------------------------------------------------------------*\nSLEEP    CSECT\nSLEEP    AMODE 31\nSLEEP    RMODE ANY\n         BAKR  R14,R0                 linkage stack\n         LR    R12,R15                copy entry address to base\n         USING SLEEP,R12              address it\n         MODID ,                      eyecatcher\n         LR    R2,R1                  copy parms passed\nGETWORK  EQU   *\n         STORAGE OBTAIN,              Get the workarea storage         X\n               LENGTH=WORKLEN,        This much                        X\n               ADDR=(R13),            Address in R13                   X\n               SP=0,KEY=8,            Subpool 0 Key 8                  X\n               LOC=ANY,               Anywhere                         X\n               COND=NO                Unconditional\n         USING WORKAREA,R13           Address workarea\n         LR    R14,R13                Copy workarea address\n         L     R15,=A(WORKLEN)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to zeros\n         LA    R13,SAVEAREA           Point to savearea\n         MVC   4(4,R13),=C'F1SA'      Set Acronym\nGETPARMS EQU   *\n*-------------------------------------------------------------------*\n* Capture the standard REXX function control blocks passed via\n* R1. This includes the result (or evaluation) table and a table\n* of arguments used to invoke the function by the user.\n*-------------------------------------------------------------------*\n         MVC   UWORK(7),TIMEMASK      Move in default seconds\n         USING EFPL,R2                addr REXX func parms\n         L     R3,EFPLEVAL            addr of pointer to eval block\n         L     R3,0(R3)               REXX eval block addr\n         USING EVALBLOCK,R3           address it\n         L     R4,EFPLARG             REXX arg list\n         USING ARGTABLE_ENTRY,R4      address arg table\n         MVC   INTERVAL(8),TIMEMASK   set default time\n         CLC   0(4,R4),HEXFF          are there no arguments ?\n         BE    WAITFOR                no - use default\nGOTPARMS EQU   *\n         L     R5,ARGTABLE_ARGSTRING_PTR\n         ICM   R6,B'1111',ARGTABLE_ARGSTRING_LENGTH\n         BZ    WAITFOR                If no parm - use default\n         C     R6,=F'5'               Bigget than 99999 seconds ?\n         BH    PARMERR                Yes - error\n         BCTR  R6,R0                  Subtract 1 for execute\n         EX    R6,ISNUMBER            Check for numbers\n         BNZ   PARMERR                non-numeric found - error\n         MVC   UWORK(7),ZEROS         Init the time field\n         LA    R1,UWORK+6             Point to the end\n         SR    R1,R6                  Subtract length of seconds\n         EX    R6,MOVESECS            Move in the seconds\nWAITFOR  EQU   *\n         PACK  PWORK(4),UWORK(7)      Pack the seconds\n         MP    PWORK(4),=PL2'100'     x 100 for BINTVL\n         CVB   R7,PACKTIME            Convert to binary\n         ST    R7,INTERVAL            and store for STIMER\n         STIMER WAIT,BINTVL=INTERVAL  Wait for the specified time\nRETURN00 EQU   *\n         BAL   R10,FREEWORK           Free the workarea and set rc\n         MVC   EVALBLOCK_EVLEN(4),=F'1'\n         MVC   EVALBLOCK_EVDATA(1),=C'0'\n         LA    R15,0\n         PR\nPARMERR  EQU   *\n         BAL   R10,FREEWORK           Free the workarea and set rc\n         MVC   EVALBLOCK_EVLEN(4),=F'2'\n         MVC   EVALBLOCK_EVDATA(2),=C'-1'\n         LA    R15,0\n         PR\n*\n*-------------------------------------------------------------------*\n* General Routines                                                  *\n*-------------------------------------------------------------------*\n*\nFREEWORK EQU   *\n         STORAGE RELEASE,             Free the workarea storage        X\n               LENGTH=WORKLEN,        This much                        X\n               ADDR=(R13),            Address in R13                   X\n               SP=0,KEY=8,            Subpool 0 Key 8                  X\n               COND=NO                Unconditional\n         BR    R10\n*\n*-------------------------------------------------------------------*\n* Executed Instructions                                             *\n*-------------------------------------------------------------------*\nISNUMBER TRT   0(0,R5),NUMBERS        Test for numbers\nMOVESECS MVC   0(0,R1),0(R5)          Move in the seconds\n*\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs                                   *\n*-------------------------------------------------------------------*\nHEXFF    DC    X'FFFFFFFFFFFFFFFF'    hex ff\nTIMEMASK DC    CL7'0000010'           time mask (10 seconds)\nZEROS    DC    CL7'0000000'           zeros\n*\nNUMBERS  DC    256X'FF'               Translate table - Numbers\n         ORG   NUMBERS+C'0'\n         DC    10X'00'\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                    SaveArea\nINTERVAL DS    F                      Time interval\nPACKTIME DS    0D                     8-byte packed time in secs\n         DS    F                      Leading zeros\nPWORK    DS    F                      Packed time field\nUWORK    DS    CL7                    Unpacked work field\nWORKLEN  EQU   *-WORKAREA\n         IRXEFPL                      REXX mapping macros\n         IRXEVALB\n         IRXARGTB DECLARE=YES\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STEMPUL$": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99&_\\x00\\x99&\\x7f\\t \\x00\\xa6\\x00\\xa6\\x00\\x00\\xc4\\xd6\\xc3\\xd6@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-09-22T00:00:00", "modifydate": "1999-09-24T09:20:00", "lines": 166, "newlines": 166, "modlines": 0, "user": "DOCO"}, "text": " Sharing REXX Stems Using STEMPUSH and STEMPULL\n ----------------------------------------------\n\n Installation of STEMPUSH and STEMPULL\n\n Assemble and link STEMPUSH and STEMPULL into a load library\n that is available to your TSO userid. Both modules have the\n following attributes :\n\n        AMODE(31)\n        RMODE(ANY)\n        RENT\n        REUS\n        AC(0)\n\n Using STEMPUSH\n\n The STEMPUSH function places one or more REXX stem variables onto\n a stack that can be passed to other REXX Execs in the same address\n space.\n\n Syntax :\n\n token = STEMPUSH('MAXBLOCKS=nnnnn','Stem1.','Stem2.',...,'StemN.')\n\n Keywords :\n\n     TOKEN\n       The returned unique 16-byte identifier of the created stack\n       that contains the REXX stem variables. If this value is\n       0 then there is an error in the parameter list.\n\n     MAXBLOCKS=nnnnn\n       Optional keyword that specifies the size of the dataspace stack\n       in 4K blocks. The value of nnnnn must be between 10 and 99999.\n       The default value is 4000 (approx 16meg). Note that unused space\n       in the dataspace stack is released after all stems have been\n       placed onto the stack.\n\n     STEM1 to STEMn\n       Specifies the REXX stem variable name(s) that are to be\n       placed on the stack. Each STEMNAME must be enclosed in\n       quotes with the last character of the name being a dot (.).\n       If multiple STEMNAME parameters are to be coded then they\n       must be separated by commas.\n\n Example :\n\n token = STEMPUSH('line.','userlist.')\n\n\n Notes   :\n\n   (a)  If not retrieved by the STEMPULL function, any stack created\n        by STEMPUSH exists for the lifetime of the address space.\n   (b)  If there are no actual variables that match the STEMNAME\n        parameters, an empty stack is created.\n   (c)  STEMPUSH cannot copy variables that are 'hidden' by REXX,\n        i.e. non-EXPOSEd variables within a PROCEDURE.\n   (d)  If there is not enough storage available in the dataspace\n        stack, STEMPUSH will complete successfully by copying as many\n        variables as it can and will indicate to STEMPULL that\n        truncation has occurred (STEMPULL will issue return code 1).\n\n\n Using STEMPULL\n\n The STEMPULL function retrieves the REXX stem variables that exist\n on a stack that matches the specified token.\n\n Syntax :\n\n rcode = STEMPUSH(token,delflag)\n\n Keywords :\n\n     RCODE\n       The return code from the STEMPULL function. This can be one\n       of the following values :\n         0   - One or more REXX stem variables was retrieved from\n               the stack.\n         1   - One or more REXX stem variables was retrieved from\n               the stack, but STEMPUSH has indicated that one or\n               more variables could not be placed onto the stack\n               because the stack is full. Re-invoke STEMPUSH with\n               the MAXBLOCKS=nnnnn keyword to increase the size\n               of the stack.\n         2   - The specified stack is empty.\n         4   - No stack found that matches the token value.\n         8   - The token is either invalid or missing or there is\n               an error in the delflag setting.\n\n     TOKEN\n       The returned unique 16-byte identifier of the created stack\n       that contains the REXX stem variables. The value of TOKEN\n       is set by the STEMPUSH function.\n\n     DELFLAG\n       An optional keyword that specifies if the dataspace stack is to\n       be deleted after all of the variables have been retrieved from it.\n       Possible settings :\n\n      'DELETE'   Delete the stack unconditionally after processing has\n                 completed. This is the default setting.\n      'NODELETE' Do not delete the stack.\n\n Example :\n\n rcode = STEMPULL(token,'NODELETE')\n\n\n\n Example of using STEMPUSH and STEMPULL\n\n In the following example, the REXX Exec 'TOON1' calls REXX Exec\n 'TOON2' to add names to the 'first_name' and 'last_name' stems.\n\n    TOON1 :\n    /* REXX */\n    first_name.0 = 2                      /* Init the stems         */\n    first_name.1 = \"Fred\"\n    first_name.2 = \"Barney\"\n    last_name.0  = 2\n    last_name.1  = \"Flintstone\"\n    last_name.2  = \"Rubble\"\n    /*--------------------------------------------------------------*/\n    /* Push the stems onto the stack and get its token              */\n    /*--------------------------------------------------------------*/\n    token = STEMPUSH('first_name.','last_name.')\n    /*--------------------------------------------------------------*/\n    /* Now call TOON2 to add to the stems                           */\n    /*--------------------------------------------------------------*/\n    if token <> 0 then call TOON2 token\n    newtoken = result                     /* Get the token returned */\n    rcode = STEMPULL(newtoken)            /* Get stems passed back  */\n    i = 1                                 /* Init loop count        */\n    do first_name.0                       /* Print stem values      */\n        say first_name.i last_name.i\n        i = i + 1\n        end\n    exit\n\n    TOON2 :\n    /* REXX */\n    /*--------------------------------------------------------------*/\n    /* Add extra entries to the passed stem values                  */\n    /*--------------------------------------------------------------*/\n    arg token                             /* Get the token          */\n    rcode = STEMPULL(token)               /* Pull the stem values   */\n    first_name.0 = first_name.0 + 2       /* Add 2 extra entries    */\n    last_name.0 = last_name.0 + 2\n    first_name.3 = \"Wilma\"\n    first_name.4 = \"Betty\"\n    last_name.3  = \"Flintstone\"\n    last_name.4  = \"Rubble\"\n    /*--------------------------------------------------------------*/\n    /* Push the stems onto a new stack as the old one has been      */\n    /* deleted.                                                     */\n    /*--------------------------------------------------------------*/\n    newtoken = STEMPUSH('first_name.','last_name.')\n    /*--------------------------------------------------------------*/\n    /* Return the new token value to TOON1                          */\n    /*--------------------------------------------------------------*/\n    return newtoken\n    exit\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMPUL#": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x001\\x01\\x17\\x01\\x7f\\x01\\x17\\x01\\x7f\\x13\\x13\\x00J\\x00h\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2017-01-17T00:00:00", "modifydate": "2017-01-17T13:13:31", "lines": 74, "newlines": 104, "modlines": 0, "user": "HELP"}, "text": ")F Function STEMPULL\n\n Using STEMPULL\n\n     This program provides an external REXX function to retrive REXX\n     stem variables from the stack created by the STEMPUSH function.\n\n     The 'stack' is in fact a dataspace whose STOKEN is passed (in\n     EBCDIC) from the STEMPUSH function.  This 'token' is used by this\n     program to access the dataspace and set up the REXX variables.\n\n     After the stack has been processed it is deleted unless the user\n     specifies the 'NODELETE' keyword.\n\n)X Syntax\n              rcode = STEMPULL(token,delflag)\n\n)O Keywords\n))RCODE\n\n              rcode  -  Return code :\n                        0  - One or more stem variables\n                             have been 'pulled' from\n                             the stack.\n                        1  - Stack is full - truncation\n                             occurred in STEMPUSH\n                        2  - Stack is empty.\n                        4  - No stack found that\n                             matches the 'token'.\n                        8  - Token missing or delflag\n                             invalid.\n\n))TOKEN\n              token  -  The 16-byte token returned by\n                        STEMPUSH that identifies the\n                        stem variable 'stack'.\n\n))DELFLAG\n              delflag-  Indicator that specifies if the\n                        dataspace is deleted after\n                        being processed.\n                        Possible values :\n                        'DELETE'   - Always delete the\n                                     dataspace. This\n                                     is the deafult.\n                        'NODELETE' - Do not delete the\n                                     dataspace.\n\n\n)Example\n                /* REXX - EXEC1 */\n                fname.0 = 2\n                fname.1 = 'Fred'\n                fname.2 = 'Barney'\n                sname.0 = 2\n                sname.1 = 'Flinstone'\n                sname.2 = 'Rubble'\n                token = stempush('fname.','sname.')\n                if token <> 0 then call EXEC2 token\n                exit\n\n                /* REXX - EXEC2 */\n                arg token\n                rcode = STEMPULL(token,'NODELETE')\n                if rcode = 0 then do\n                  say fname.1 sname.1\n                  say fname.2 sname.2\n                end\n                exit\n\n)Author\n\n    Rob Scott\n    Scott Enterprise Consultancy Ltd\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STEMPUL@": {"ttr": 2320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99&o\\x00\\x99&o\\x11C\\x00-\\x00-\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-23T00:00:00", "modifydate": "1999-09-23T11:43:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "FILE411"}, "text": "//* ADD A JOBCARD\n//*\n//* (1) CHANGE 'SYS2.SEC.SRC' TO THIS DATASET NAME\n//* (2) CHANGE 'SYS2.SEC.LOAD' TO YOUR LOAD LIBRARY DATASET NAME\n//*\n//*\n//ASMPULL  EXEC PGM=ASMA90\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DSN=SYS2.SEC.SRC(STEMPULL),DISP=SHR\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(,PASS),UNIT=SYSALLDA,\n//         DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=3200),\n//         SPACE=(CYL,(2,1))\n//*\n//LINKPULL EXEC PGM=HEWL,\n//         PARM='MAP,LET,LIST,XCAL,RENT',COND=(8,LT,ASMPULL)\n//SYSLMOD  DD  DSN=SYS2.SEC.LOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE,DELETE)\n//         DD  *\n  ENTRY STEMPULL\n  NAME STEMPULL(R)\n//*\n//ASMPUSH  EXEC PGM=ASMA90\n//SYSPRINT DD  SYSOUT=*\n//SYSIN    DD  DSN=SYS2.SEC.SRC(STEMPUSH),DISP=SHR\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(,PASS),UNIT=SYSALLDA,\n//         DCB=(RECFM=FB,DSORG=PS,LRECL=80,BLKSIZE=3200),\n//         SPACE=(CYL,(2,1))\n//*\n//LINKPUSH EXEC PGM=HEWL,\n//         PARM='MAP,LET,LIST,XCAL,RENT',COND=(8,LT,ASMPUSH)\n//SYSLMOD  DD  DSN=SYS2.SEC.LOAD,DISP=SHR\n//SYSPRINT DD  SYSOUT=*\n//SYSUT1   DD  UNIT=SYSALLDA,SPACE=(CYL,(2,1))\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE,DELETE)\n//         DD  *\n  ENTRY STEMPUSH\n  NAME STEMPUSH(R)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STEMPULL": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99&o\\x00\\x99&o\\x14\\x16\\x02\\x12\\x02\\x12\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-23T00:00:00", "modifydate": "1999-09-23T14:16:00", "lines": 530, "newlines": 530, "modlines": 0, "user": "FILE411"}, "text": "STEMPULL TITLE 'PULL REXX STEMS FROM A STACK CREATED BY STEMPUSH'\n*-------------------------------------------------------------------*\n* Name            : STEMPULL\n*\n*\n* Function        : This program provides an external REXX function\n*                   to retrive REXX stem variables from the stack\n*                   created by the STEMPUSH function.\n*\n*                   The 'stack' is in fact a dataspace whose STOKEN\n*                   is passed (in EBCDIC) from the STEMPUSH function.\n*                   This 'token' is used by this program to access\n*                   the dataspace and set up the REXX variables.\n*\n*                   After the stack has been processed it is deleted\n*                   unless the user specifies the 'NODELETE' keyword.\n*\n* Syntax          : rcode = STEMPULL(token,delflag)\n*\n*                   where :   rcode  -  Return code :\n*                                       0  - One or more stem variables\n*                                            have been 'pulled' from\n*                                            the stack.\n*                                       1  - Stack is full - truncation\n*                                            occurred in STEMPUSH\n*                                       2  - Stack is empty.\n*                                       4  - No stack found that\n*                                            matches the 'token'.\n*                                       8  - Token missing or delflag\n*                                            invalid.\n*\n*                             token  -  The 16-byte token returned by\n*                                       STEMPUSH that identifies the\n*                                       stem variable 'stack'.\n*\n*                             delflag-  Indicator that specifies if the\n*                                       dataspace is deleted after\n*                                       being processed.\n*                                       Possible values :\n*                                       'DELETE'   - Always delete the\n*                                                    dataspace. This\n*                                                    is the deafult.\n*                                       'NODELETE' - Do not delete the\n*                                                    dataspace.\n*\n*\n*\n* Example         : /* REXX - EXEC1 */\n*                   fname.0 = 2\n*                   fname.1 = 'Fred'\n*                   fname.2 = 'Barney'\n*                   sname.0 = 2\n*                   sname.1 = 'Flinstone'\n*                   sname.2 = 'Rubble'\n*                   token = stempush('fname.','sname.')\n*                   if token <> 0 then call EXEC2 token\n*                   exit\n*\n*                   /* REXX - EXEC2 */\n*                   arg token\n*                   rcode = STEMPULL(token,'NODELETE')\n*                   if rcode = 0 then do\n*                     say fname.1 sname.1\n*                     say fname.2 sname.2\n*                   end\n*                   exit\n*\n* IBM Macros Used : MODID, STORAGE, LOAD, SYSSTATE, ALESERV, DSPSERV,\n*                   DELETE, IRXEFPL, IRXENVB, IRXEVALB, IRXSHVB,\n*                   IRXARGTB\n*\n* Attributes      : Amode(31)\n*                   Rmode(Any)\n*                   RENT\n*                   REUS\n*                   NOREFR\n*                   AC(0)\n*\n* Register Usage  :\n*\n* R1  - Parms passed              : +0 ---> REXX EFPL\n* R2  - EFPL\n* R3  - EVALBLOCK\n* R4  - ARGTABLE\n* R5  - REXX Arg Pointer\n* R6  - REXX Arg Length\n* R7  - Branch and count\n* R8  - Dataspace (RSST)\n* R9  - Current pointer in dataspace\n* R10 - Branch and Link\n* R11 - SHVB\n* R12 - Base reg\n* R13 - Workarea\n*\n*-------------------------------------------------------------------*\n* (c) Scott Enterprise Consultancy Ltd\n*-------------------------------------------------------------------*\n* Changes\n* 17/06/1998  Rob Scott  Code Written                            V1.0\n* 24/07/1998  Rob Scott  Add the code to convert the 16-byte\n*                        EBCDIC token to its 8-byte equivalent.\n*                        STEMPUSH now provides the DSPDTOKN in\n*                        EBCDIC form rather than original hex.   V1.1\n* 29/07/1998  Rob Scott  Use MVCL to copy the data from the RSST.\n*                        This allows values > 256 bytes long to\n*                        be retrieved from the RSST.             V1.2\n* 14/08/1998  Rob Scott  Ensure AR15 is zero prior to the copy\n*                        from the RSST. This prevents 0E0 abends\n*                        in OS/390 2.5.                          V1.3\n* 04/09/1998  Rob Scott  Handle truncation of the RSST by setting\n*                        a new return code of 1 to indicate to\n*                        the user that truncation has occurred.\n*                        Add the 'DELETE/NODELETE' keywords to give\n*                        users the ability to leave the dataspace\n*                        in existance after being processed.     V1.4\n*-------------------------------------------------------------------*\nSTEMPULL CSECT\nSTEMPULL AMODE 31\nSTEMPULL RMODE ANY\n         BAKR  R14,R0                 linkage stack\n         LAE   R12,0(R15,0)           set R12 as base\n         USING STEMPULL,R12           address it\n         MODID ,                      eyecatcher\n         LR    R2,R1                  copy any parms passed\nGETWORK  EQU   *\n*--------------------------------------------------------------------*\n* Get some workarea storage and init to zeros. We also load the\n* address of IRXEXCOM for later calls.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              Get the workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in r13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=ANY,               above the line                   X\n               COND=NO                unconditional\n         USING WORKAREA,R13           address workarea\n         LR    R14,R13                Copy workarea address\n         L     R15,=A(WORKLEN)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to zeros\n         MVC   4(4,R13),=C'F1SA'      set label in savearea\n         LOAD  EP=IRXEXCOM            Get address of IRXEXCOM\n         ST    R0,AIRXEXCM            Store for later\nGETPARMS EQU   *\n*--------------------------------------------------------------------*\n* Get the REXX function parameters passed.\n* The 1st parameter must be the 16-byte token with an optional 2nd\n* parm of 'DELETE' or 'NODELETE'\n*--------------------------------------------------------------------*\n         USING EFPL,R2                address REXX function parms\n         L     R3,EFPLEVAL            Get pointer to Eval_Block\n         L     R3,0(R3)               REXX Eval_Block address\n         USING EVALBLOCK,R3           Address it\n         L     R4,EFPLARG             REXX Argument table\n         USING ARGTABLE_ENTRY,R4      Address it\n         CLC   0(8,R4),HEXFF          No arguments passed ?\n         BE    RETURN08               then error\n         L     R5,ARGTABLE_ARGSTRING_PTR\n         L     R6,ARGTABLE_ARGSTRING_LENGTH\n         C     R6,=F'16'              Look at the length\n         BNE   RETURN08               not 16 ?\n         MVC   TOKEN(16),0(R5)        copy in the token\n         BAL   R10,CHAR2HEX           convert to hex\n         LA    R4,8(R4)               Point to next arg\n         CLC   0(8,R4),HEXFF          No argument ?\n         BE    GETSHVB                then use default DELETE\n*--------------------------------------------------------------------*\n* Process the optional 2nd parm\n*--------------------------------------------------------------------*\n         L     R5,ARGTABLE_ARGSTRING_PTR\n         L     R6,ARGTABLE_ARGSTRING_LENGTH\n         C     R6,=F'6'               Test length\n         BL    RETURN08               < 6 chars = error\n         C     R6,=F'8'               Test length\n         BH    RETURN08               > 8 chars = error\n         BCTR  R6,R0                  minus 1 for execute\n         EX    R6,CONVUPPR            xlate to uppercase\n         CLC   0(6,R5),=C'DELETE'     Is it DELETE ?\n         BE    GETSHVB                yes - leave flag unchanged\n         CLC   0(8,R5),=C'NODELETE'   Is it NODELETE ?\n         BNE   RETURN08               no - error\n         OI    DSPFLAG,NODELETE       Set flag to indicate\nGETSHVB  EQU   *\n*--------------------------------------------------------------------*\n* We have the token, so now we need to get storage for the\n* REXX SHVB (required by IRXEXCOM). We reserve 250 bytes for the\n* variable name and 3K for the variable value.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the SHVBLOCK storage         X\n               LENGTH=4096,           this much                        X\n               ADDR=(R11),            address in r11                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=ANY,               above the line                   X\n               COND=NO                unconditional\n         USING SHVBLOCK,R11           address SHVBLOCK\n         LA    R15,SHVBLEN(R11)       Point to name buffer\n         ST    R15,ASHVNAMA           Store for IRXEXCOM\n         MVC   NAMALEN,=F'250'        Set length of name buffer\n         LA    R15,256(R15)           Point to value buffer\n         ST    R15,ASHVVALA           Store for IRXEXCOM\n         MVC   VALALEN,=F'3072'       Set length of value buffer\nGETDSP   EQU   *\n*--------------------------------------------------------------------*\n* Now we search for the ALET that matches the STOKEN for the\n* dataspace\n*--------------------------------------------------------------------*\n         SAC   512                    Switch into AR mode\n         SYSSTATE ASCENV=AR           Set Global bit for AR mode\n         MVC   DSPALET,=F'-1'         Reset the ALET\n         ALESERV SEARCH,              Get the ALET                     x\n               STOKEN=DSPDTOKN,       For the dataspace STOKEN         x\n               ALET=DSPALET,          Place ALET here                  x\n               AL=PASN,               Available globaly                x\n               MF=(E,ALESERV1)\n         LTR   R15,R15                Test rc\n         BNZ   RETURN04\n*--------------------------------------------------------------------*\n* Set the origin to to x'1000' (STEMPUSH does this as well)\n* Establish addressability to the dataspace and check if we have any\n* entries in the RSST.\n*--------------------------------------------------------------------*\n         MVC   DSPORIG,=F'4096'       Set origin to 4K\n         LAM   R8,R8,DSPALET          Load AR8 with ALET\n         CPYA  R9,R8                  Copy AR8 into AR9\n         L     R8,DSPORIG             Load R8 with start address\n         USING RSST,R8                Address DSECT\n         LA    R9,RSSTENT             Load R9 with start entry address\n         ICM   R7,B'1111',RSSTNMBR    Any entries ?\n         BZ    RETURN02               No - tell user\nVARLOOP  EQU   *\n*--------------------------------------------------------------------*\n* We have at least one entry in the RSST, so we now loop through the\n* RSST extracting the variable names/values. For each name/value pair\n* we call IRXEXCOM with the 'Set' code to create the REXX variable.\n*--------------------------------------------------------------------*\n         LA    R1,EXCOMID             Point to IRXEXCOM id\n         ST    R1,AEXCOMP1            Store in parm list\n         LA    R1,ZERO                Point to fullword zero\n         ST    R1,AEXCOMP2            Store in parm list\n         ST    R1,AEXCOMP3            Store in parm list\n         ST    R11,AEXCOMP4           Store SHVB as parm #4\n         LA    R1,ZERO                Point to fullword zero\n         ST    R1,AEXCOMP5            Store in parm list\n         LA    R1,EXCOMRC             Point to return code\n         ST    R1,AEXCOMP6            Store in parm list\n         OI    AEXCOMP6,X'80'         Indicate end of list\n         MVI   SHVCODE,SHVSTORE       Indicate \"Set\"\n         ICM   R1,B'1111',0(R9)       Get the name length\n         STCM  R1,B'1111',SHVNAML     Set name buffer length\n         L     R15,ASHVNAMA           Point to name area\n         LA    R9,4(R9)               Point to name\n         BCTR  R1,R0                  Minus 1 from length for execute\n         CPYA  R15,R12                Ensure AR15 is same as AR12\n         EX    R1,COPYRSST            Copy in the name\n         A     R9,SHVNAML             Re-load the length\n         ICM   R1,B'1111',0(R9)       Get the value length\n         STCM  R1,B'1111',SHVVALL     Set value buffer length\n         LR    R15,R1                 Copy for MVCL\n         L     R0,ASHVVALA            Point to value area\n         LA    R9,4(R9)               Point to value\n         LR    R14,R9                 Copy R9 for MVCL\n         CPYA  R14,R9                 Copy AR9 to AR14 for MVCL\n         MVCL  R0,R14                 Copy the data\n         A     R9,SHVVALL             Re-load the length\n         MVC   SHVNAMA,ASHVNAMA       Point to name buffer\n         MVC   SHVVALA,ASHVVALA       Point to value buffer\n         SYSSTATE ASCENV=P            Reset AR Mode\n         SAC   0\n         LA    R1,EXCOMPRM            Point to the parm list\n         L     R15,AIRXEXCM           Load address of routine\n         BALR  R14,R15                Call it\n         SAC   512                    Switch into AR mode\n         SYSSTATE ASCENV=AR           Set Global bit for AR mode\n         BCT   R7,VARLOOP             Loop for all variables\n         TM    RSSTFLAG,RSSTFULL      Did truncation occur\n         BO    RETURN01               Yes - tell user\nRETURN00 EQU   *\n*--------------------------------------------------------------------*\n* RSST is OK - we only delete the dataspace if DELETE is set\n*--------------------------------------------------------------------*\n         TM    DSPFLAG,NODELETE       Do we delete the dataspace ?\n         BO    NODEL00                no - bypass delete\n         ALESERV DELETE,              Delete the ALET                  x\n               ALET=DSPALET,          for the dataspace                x\n               MF=(E,ALESERV1)\n         DSPSERV DELETE,              Delete the dataspace             x\n               STOKEN=DSPDTOKN,       With this STOKEN                 x\n               MF=(E,DSPSERV1)\nNODEL00  EQU   *\n         SYSSTATE ASCENV=P            Reset AR Mode\n         SAC   0\n         BAL   R10,RELWORK            free the workarea\n         MVC   EVALBLOCK_EVLEN(4),=F'1'  Set length of result\n         MVC   EVALBLOCK_EVDATA(1),=C'0' Move in result data\n         XR    R15,R15                set rc to zero\n         PR                           return\nRETURN01 EQU   *\n*--------------------------------------------------------------------*\n* RSST is truncated - we only delete the dataspace if DELETE is set\n*--------------------------------------------------------------------*\n         TM    DSPFLAG,NODELETE       Do we delete the dataspace ?\n         BO    NODEL01                no - bypass delete\n         ALESERV DELETE,              Delete the ALET                  x\n               ALET=DSPALET,          for the dataspace                x\n               MF=(E,ALESERV1)\n         DSPSERV DELETE,              Delete the dataspace             x\n               STOKEN=DSPDTOKN,       With this STOKEN                 x\n               MF=(E,DSPSERV1)\nNODEL01  EQU   *\n         SYSSTATE ASCENV=P            Reset AR Mode\n         SAC   0\n         BAL   R10,RELWORK            free the workarea\n         MVC   EVALBLOCK_EVLEN(4),=F'1'  Set length of result\n         MVC   EVALBLOCK_EVDATA(1),=C'1' Move in result data\n         XR    R15,R15                set rc to zero\n         PR                           return\nRETURN02 EQU   *\n*--------------------------------------------------------------------*\n* RSST is empty - we ALWAYS delete the dataspace.\n*--------------------------------------------------------------------*\n         ALESERV DELETE,              Delete the ALET                  x\n               ALET=DSPALET,          for the dataspace                x\n               MF=(E,ALESERV1)\n         DSPSERV DELETE,              Delete the dataspace             x\n               STOKEN=DSPDTOKN,       With this STOKEN                 x\n               MF=(E,DSPSERV1)\n         SYSSTATE ASCENV=P            Reset AR Mode\n         SAC   0\n         BAL   R10,RELWORK            free the workarea\n         MVC   EVALBLOCK_EVLEN(4),=F'1'  Set length of result\n         MVC   EVALBLOCK_EVDATA(1),=C'2' Move in result data\n         XR    R15,R15                set rc to zero\n         PR                           return\nRETURN04 EQU   *\n*--------------------------------------------------------------------*\n* Could not find the stack\n*--------------------------------------------------------------------*\n         SYSSTATE ASCENV=P            Reset AR Mode\n         SAC   0\n         BAL   R10,RELSHVB            free the workarea\n         BAL   R10,RELWORK            free the workarea\n         MVC   EVALBLOCK_EVLEN(4),=F'1'  Set length of result\n         MVC   EVALBLOCK_EVDATA(1),=C'4' Move in result data\n         PR                           return\nRETURN08 EQU   *\n*--------------------------------------------------------------------*\n* Token missing or invalid, or error specifying DELETE/NODELETE\n*--------------------------------------------------------------------*\n         BAL   R10,RELWORK            free the workarea\n         MVC   EVALBLOCK_EVLEN(4),=F'1'  Set length of result\n         MVC   EVALBLOCK_EVDATA(1),=C'8' Move in result data\n         PR                           return\n*\n*--------------------------------------------------------------------*\n* General Routines\n*--------------------------------------------------------------------*\n*\nCHAR2HEX EQU   *\n*--------------------------------------------------------------------*\n* Convert EBCDIC to HEX\n* We receive a 16-byte token in EBCDIC eg 'F0C1F1C2F0F0......' and\n* we need to convert it to hex eg '0A1B00.....'\n*--------------------------------------------------------------------*\n         LA    R15,TOKEN              Point to the token\n         LA    R1,DSPDTOKN            Point to the dataspace token\n         LA    R0,8                   Set loop count\nLEFTHALF EQU   *\n         XR    R7,R7                  Clear\n         ICM   R7,B'0001',0(R15)      Pick up byte of token\n         CH    R7,=H'198'             C1-C6 ?\n         BH    LEFTNMBR               No - number\n         SH    R7,=H'183'             A-F - Turn C1-C6 into 0A-0F\n         B     LEFTDONE\nLEFTNMBR EQU   *\n         SH    R7,=H'240'             0-9 - Turn F0-F9 into 0-9\nLEFTDONE EQU   *\n         LR    R14,R7                 Remember for later\n         SLL   R14,4                  Make room for next half byte\n         LA    R15,1(R15)             Next token byte\nRGHTHALF EQU   *\n         XR    R7,R7                  Clear\n         ICM   R7,B'0001',0(R15)      Pick up byte of token\n         CH    R7,=H'198'             C1-C6 ?\n         BH    RGHTNMBR               No - number\n         SH    R7,=H'183'             A-F - Turn C1-C6 into 0A-0F\n         B     RGHTDONE\nRGHTNMBR EQU   *\n         SH    R7,=H'240'             0-9 - Turn F0-F9 into 0-9\nRGHTDONE EQU   *\n         OR    R14,R7                 combine half bytes\n         STCM  R14,B'0001',0(R1)      Store as hex byte\n         LA    R1,1(R1)               point to next hex byte\n         LA    R15,1(R15)             Next token byte\n         BCT   R0,LEFTHALF            Loop for all bytes\n         BR    R10\n*\nRELWORK  EQU   *\n*--------------------------------------------------------------------*\n* Release workarea storage\n*--------------------------------------------------------------------*\n         DELETE EP=IRXEXCOM           Delete IRXEXCOM from storage\n         STORAGE RELEASE,             release workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in R13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         BR    R10                    return\n*\nRELSHVB  EQU   *\n*--------------------------------------------------------------------*\n* Release SHVB storage\n*--------------------------------------------------------------------*\n         STORAGE RELEASE,             release SHVB storage             X\n               LENGTH=4096,           this much                        X\n               ADDR=(R11),            address in R11                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         BR    R10                    return\n*\n*-------------------------------------------------------------------*\n* Executed Instructions\n*-------------------------------------------------------------------*\n*\nCOPYRSST MVC   0(0,R15),0(R9)         Executed move\nCONVUPPR TR    0(0,R5),UPPER          Xlate to upper case\n*\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs\n*-------------------------------------------------------------------*\n*\n         LTORG\nHEXFF    DC    XL8'FFFFFFFFFFFFFFFF'  High values\nEXCOMID  DC    CL8'IRXEXCOM'          IRXEXCOM ID\nZERO     DC    F'0'                   Fullword zero\nUPPER    DS    0CL256\n         DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                    save area\nTOKEN    DS    CL16                   EBCDIC token passed\nDSPTTOKN DS    CL16                   TCB Token\nDSPNAME  DS    CL8                    Dataspace name\nDSPDTOKN DS    CL8                    Dataspace token\nDSPORIG  DS    F                      Dataspace origin\nDSPALET  DS    F                      Dataspace ALET\nAIRXEXCM DS    F                      address of IRXEXCOM\nASHVNAMA DS    F                      address of SHVB name buffer\nASHVVALA DS    F                      address of SHVB value buffer\nNAMALEN  DS    F                      length of SHVB name buffer\nVALALEN  DS    F                      length of SHVB value buffer\nEXCOMRC  DS    F                      Return code from IRXEXCOM\nDSPFLAG  DS    X                      DELETE flag\nNODELETE EQU   X'80'                  Don't delete the dataspace\nEXCOMPRM DS    0F                     Parm list for IRXEXCOM\nAEXCOMP1 DS    F                      ---> IRXEXCOM ID\nAEXCOMP2 DS    F                      ---> 0\nAEXCOMP3 DS    F                      ---> 0\nAEXCOMP4 DS    F                      ---> SHVBLOCK\nAEXCOMP5 DS    F                      ---> ENVBLOCK\nAEXCOMP6 DS    F                      ---> Return Code\n         DS    0F\n         DSPSERV MF=(L,DSPSERV1)      List form of DSPSERV\nALESERV1 ALESERV MF=L                 List form of ALESERV\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*\nRSST     DSECT\n*-------------------------------------------------------------------*\n* The Pushed REXX Stem Variable Storage Table (RSST)\n*\n* The RSST consists of a 12 byte header plus a variable amount of\n* individual entries. Each entry is constructed as follows :\n* Namel     DS   AL4(Name)        Length of name\n* Name      DS   CL(Namel)        REXX Variable Name\n* Valuel    DS   AL4(Value)       Length of value\n* Value     DS   CL(Valuel)       REXX Variable value\n*\n* For example, an entry for a variable 'STEM.11' with a value 'FRED'\n* would look like this :\n*   Namel   Name          Valuel  Value\n* x'00000007E2E3C5D44BF1F100000004C6D9C5C4'\n*-------------------------------------------------------------------*\nRSSTID   DS    CL4                    Eyecatcher\nRSSTNMBR DS    CL4                    Number of entries\nRSSTSIZE DS    CL4                    Size of table (including header)\nRSSTFLAG DS    X                      Flag byte\nRSSTFULL EQU   X'80'                  RSST is full\n         DS    XL3                    Reserved\nRSSTHSIZ EQU   *-RSST                 Size of header\nRSSTENT  DS    0C                     Entry\n*\n         IRXEFPL                      REXX External Function\n         IRXEVALB                     REXX Evaluation Block\n         IRXENVB                      REXX Environment Block\n         IRXSHVB                      REXX Shared Variable Block\n         IRXARGTB DECLARE=YES         REXX Argument Table\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STEMPUS#": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x15\\x01\\x17\\x01\\x7f\\x01\\x17\\x01\\x8f\\x067\\x00F\\x00B\\x00\\x00\\xc8\\xc5\\xd3\\xd7@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2017-01-17T00:00:00", "modifydate": "2017-01-18T06:37:15", "lines": 70, "newlines": 66, "modlines": 0, "user": "HELP"}, "text": ")F Function STEMPUSH\n\n     This program provides an external REXX function to place REXX\n     stem variables onto a stack that can be passed to another REXX\n     exec running within the same address space.\n\n     The 'stack' is in fact a dataspace whose STOKEN is passed back in\n     EBCDIC form to the REXX result value. This 'token' can then be\n     used in any other REXX as an argument to the STEMPULL function to\n     retrieve the contents of the dataspace.\n\n)X Syntax\n\n     token = STEMPUSH(maxblk,'stem1.',,'stemn.')\n\n)O Keywords\n\n))TOKEN\n\n               token  -  16 byte token that identifies\n                         the 'stack' that the stems have\n                         been 'pushed' onto. If this\n                         is set to '0', then the\n                         function has failed.\n\n))MAXBLK\n\n               maxblk -  Optional keyword that specifies\n                         the size of the 'stack'. The\n                         format is 'nnnnn'\n                         where 'nnnnn' is the size of\n                         'stack' in 4K blocks.\n                         The minimum value is 10.\n                         The maximum value is 99999.\n                         The default value is 4000.\n\n))STEMN\n\n               stemn  -  The stem name(s) that are to be\n                         pushed onto the 'stack'. The\n                         variable names MUST be enclosed\n                         in quotes and the last char in\n                         each name MUST be a dot.\n\n)Examples\n\n     /* REXX - EXEC1 */\n     fname.0 = 2\n     fname.1 = 'Fred'\n     fname.2 = 'Barney'\n     sname.0 = 2\n     sname.1 = 'Fred'\n     sname.2 = 'Barney'\n     token = STEMPUSH('fname.','sname.')\n     if token <> 0 then call EXEC2 token\n     exit\n\n     /* REXX - EXEC2 */\n     arg token\n     status = stempull(token)\n     if status = 0 then do\n       say fname.1 sname.1\n       say fname.2 sname.2\n     end\n     exit\n\n)Author\n\n    Rob Scott\n    Scott Enterprise Consultancy Ltd\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STEMPUSH": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x13o\\x01\\x01\\x13o\\x16F\\x02\\x84\\x02\\x84\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-05-16T00:00:00", "modifydate": "2001-05-16T16:46:00", "lines": 644, "newlines": 644, "modlines": 0, "user": "FILE411"}, "text": "STEMPUSH TITLE 'PUSH ONE OR MORE REXX STEMS INTO A DATASPACE STACK'\n*-------------------------------------------------------------------*\n* Name            : STEMPUSH\n*\n* Function        : This program provides an external REXX function\n*                   to place REXX stem variables onto a stack that\n*                   can be passed to another REXX exec running within\n*                   the same address space.\n*\n*                   The 'stack' is in fact a dataspace whose STOKEN\n*                   is passed back in EBCDIC form to the REXX result\n*                   value. This 'token' can then be used in any\n*                   other REXX as an argument to the STEMPULL\n*                   function to retrieve the contents of the\n*                   dataspace.\n*\n* Syntax          : token = STEMPUSH(maxblk,'stem1.',,'stemn.')\n*\n*                   where :   token  -  16 byte token that identifies\n*                                       the 'stack' that the stems have\n*                                       been 'pushed' onto. If this\n*                                       is set to '0', then the\n*                                       function has failed.\n*\n*                             maxblk -  Optional keyword that specifies\n*                                       the size of the 'stack'. The\n*                                       format is 'MAXBLOCKS=nnnnn'\n*                                       where 'nnnnn' is the size of\n*                                       'stack' in 4K blocks.\n*                                       The minimum value is 10.\n*                                       The maximum value is 99999.\n*                                       The default value is 4000.\n*\n*                             stemn  -  The stem name(s) that are to be\n*                                       pushed onto the 'stack'. The\n*                                       variable names MUST be enclosed\n*                                       in quotes and the last char in\n*                                       each name MUST be a dot.\n*\n*\n* Example         : /* REXX - EXEC1 */\n*                   fname.0 = 2\n*                   fname.1 = 'Fred'\n*                   fname.2 = 'Barney'\n*                   sname.0 = 2\n*                   sname.1 = 'Fred'\n*                   sname.2 = 'Barney'\n*                   token = STEMPUSH('MAXBLOCKS=10','fname.','sname.')\n*                   if token <> 0 then call EXEC2 token\n*                   exit\n*\n*                   /* REXX - EXEC2 */\n*                   arg token\n*                   status = stempull(token)\n*                   if status = 0 then do\n*                     say fname.1 sname.1\n*                     say fname.2 sname.2\n*                   end\n*                   exit\n*\n*\n* IBM Macros Used : MODID, STORAGE, LOAD, TCBTOKEN, DSPSERV, ALESERV,\n*                   SYSSTATE, ABEND, DELETE, IRXEFPL, IRXENVB,\n*                   IRXEVALB, IRXARGTB, IRXSHVB\n*\n* Attributes      : Amode(31)\n*                   Rmode(Any)\n*                   RENT\n*                   REUS\n*                   NOREFR\n*                   AC(0)\n*\n* Register Usage  :\n*\n* R1  - Parms passed              : +0 ---> REXX EFPL\n* R2  - EFPL\n* R3  - EVALBLOCK\n* R4  - REXX Arg Table\n* R5  - REXX Arg pointer\n* R6  - REXX Arg length\n* R7  - Work\n* R8  - Dataspace base address\n* R9  - Dataspace current pointer (RSST)\n* R10 - Branch and Link\n* R11 - SHVBLOCK\n* R12 - Base reg\n* R13 - Workarea\n*\n*\n* Possible ABEND Codes :\n*\n* User Abend 111  - TCBTOKEN Failed\n* User Abend 112  - ALESERV Failed\n* User Abend 113  - DSPSERV Failed\n*\n*-------------------------------------------------------------------*\n* (c) Scott Enterprise Consultancy Ltd\n*-------------------------------------------------------------------*\n* Changes\n* 17/06/1998  Rob Scott  Code Written                            V1.0\n* 24/07/1998  Rob Scott  Add code to convert the 8-byte STOKEN to\n*                        its EBCDIC equivalent. This ensures that\n*                        the token can be passed easily to STEMPULL\n*                        by REXX without suffering from uppercase\n*                        translation and code page problems.     V1.1\n* 29/07/1998  Rob Scott  Use MVCL to copy the data from the RSST.\n*                        This allows values > 256 bytes long to\n*                        be copied into the RSST.                V1.2\n* 14/08/1998  Rob Scott  Ensure AR15 is zero prior to the copy\n*                        from the RSST. This prevents 0E0 abends\n*                        in OS/390 2.5.                          V1.3\n* 04/09/1998  Rob Scott  Cope with RSST being full by setting the\n*                        RSSTFULL flag to indicate truncation has\n*                        occurred.\n*                        Add the optional 'MAXBLOCKS' keyword so\n*                        users can specify the maximum size of the\n*                        dataspace stack.                        V1.4\n*-------------------------------------------------------------------*\nSTEMPUSH CSECT\nSTEMPUSH AMODE 31\nSTEMPUSH RMODE ANY\n         BAKR  R14,R0                 linkage stack\n         LAE   R12,0(R15,0)           set R12 as base\n         USING STEMPUSH,R12           address it\n         MODID ,                      eyecatcher\n         LR    R2,R1                  copy any parms passed\nGETWORK  EQU   *\n*--------------------------------------------------------------------*\n* Get some workarea storage and init to zeros. We also load the\n* address of IRXEXCOM for later calls.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in r13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=ANY,               above the line                   X\n               COND=NO                unconditional\n         USING WORKAREA,R13           address workarea\n         LR    R14,R13                Copy workarea address\n         L     R15,=A(WORKLEN)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to zeros\n         MVC   4(4,R13),=C'F1SA'      set label in savearea\n         LOAD  EP=IRXEXCOM            Get address of IRXEXCOM\n         ST    R0,AIRXEXCM            Store for later\n         MVC   MAXBLKS,=F'4000'       Default MAXBLKS (1000*4K)\nGETPARMS EQU   *\n*--------------------------------------------------------------------*\n* Process the parms passed to this REXX function. These will be the\n* names of the stem variables that are to be pushed onto the stack.\n* We must have at least 1 parameter. We also process the optional\n* MAXBLOCKS keyword if specified.\n*--------------------------------------------------------------------*\n         USING EFPL,R2                address REXX function parms\n         L     R3,EFPLEVAL            Get pointer to Eval_Block\n         L     R3,0(R3)               REXX Eval_Block address\n         USING EVALBLOCK,R3           Address it\n         L     R4,EFPLARG             REXX Argument table\n         USING ARGTABLE_ENTRY,R4      Address it\n         CLC   0(8,R4),HEXFF          No arguments passed ?\n         BE    RETURNCC               then error\n*--------------------------------------------------------------------*\n* Check if MAXBLOCKS has been specified.\n*--------------------------------------------------------------------*\n         L     R5,ARGTABLE_ARGSTRING_PTR\n         L     R6,ARGTABLE_ARGSTRING_LENGTH\n         C     R6,=F'11'              at least 11 chars long ?\n         BL    GETSHVB                no - ignore\n         C     R6,=F'15'              up to 15 bytes max\n         BH    GETSHVB                longer - ignore\n         LR    R1,R6                  Copy length of parm\n         BCTR  R1,R0                  Minus 1 for execute\n         EX    R1,CONVUPPR            ensure uppercase\n         CLC   0(10,R5),=C'MAXBLOCKS=' user specifying stack size ?\n         BNE   GETSHVB                no - ignore\n         S     R6,=F'11'              yes - how many numbers?\n         LA    R5,10(R5)              point to start of numbers\n         MVC   UWORK(7),=C'0000000'   init maxblocks (unpacked)\n         LA    R7,UWORK+6             Point to last number\n         SR    R7,R6                  Adjust for length\n         EX    R6,MOVEBLKS            Move in the parm\n         TRT   UWORK(7),NUMBERS       Check for numbers\n         BNZ   RETURNCC               if not - error\n         PACK  PWORK(4),UWORK(7)      Pack the MAXBLKS\n         CVB   R7,ENTNUM              Convert to binary\n         C     R7,=F'10'              greater than 10 ?\n         BNH   RETURNCC               no - error\n         C     R7,=F'99999'           greater than 99999 ?\n         BH    RETURNCC               yes - error\n         STCM  R7,B'1111',MAXBLKS     Store as MAXBLKS (binary)\nGETSHVB  EQU   *\n*--------------------------------------------------------------------*\n* We have at least 1 parm, so now we need to get storage for the\n* REXX SHVB (required by IRXEXCOM). We reserve 250 bytes for the\n* variable name and 3K for the variable value.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the SHVBLOCK storage         X\n               LENGTH=4096,           this much                        X\n               ADDR=(R11),            address in r11                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=ANY,               above the line                   X\n               COND=NO                unconditional\n         USING SHVBLOCK,R11           address SHVBLOCK\n         LA    R15,SHVBLEN(R11)       Point to name buffer\n         ST    R15,ASHVNAMA           Store for IRXEXCOM\n         MVC   NAMALEN,=F'250'        Set length of name buffer\n         LA    R15,256(R15)           Point to value buffer\n         ST    R15,ASHVVALA           Store for IRXEXCOM\n         MVC   VALALEN,=F'3072'       Set length of value buffer\nGETDSP   EQU   *\n*--------------------------------------------------------------------*\n* Now it is time to set up the 'stack'. This is going to be a\n* dataspace that is created under the ownership of the Jobstep TCB.\n* Assigning the ownership to the Jobstep TCB allows the dataspace\n* to exist until the address space terminates - otherwise it will\n* be deleted at TCB termination.\n*--------------------------------------------------------------------*\n         SAC   512                    Switch into AR mode\n         SYSSTATE ASCENV=AR           Set Global bit for AR mode\n*--------------------------------------------------------------------*\n* To set the ownership to the JSTCB, we need to acquire the TCBTOKEN\n*--------------------------------------------------------------------*\n         TCBTOKEN TYPE=JOBSTEP,       Get the TCB Token (Jobstep)      x\n               TTOKEN=DSPTTOKN,       Store for DSPSERV                x\n               MF=(E,TCBTOKN1)\n         LTR   R15,R15                Test rc\n         BNZ   ABEND111\n         MVC   DSPNAME(8),=CL8'RSS'   Set name suffix\n*--------------------------------------------------------------------*\n* TCB Token acquired, create the dataspace named 'RSS.....' with\n* 'maxblks' amount of 4K blocks. This is set initially to 4000*4K\n* (approx 16meg).\n*--------------------------------------------------------------------*\n         DSPSERV CREATE,              Create a dataspace               x\n               STOKEN=DSPDTOKN,       Store STOKEN here                x\n               TYPE=BASIC,            Indicate dataspace               x\n               NAME=DSPNAME,          Name of dataspace                x\n               GENNAME=YES,           Make name unique                 x\n               OUTNAME=DSPNAME,       Place name here                  x\n               ORIGIN=DSPORIG,        Place origin address here        x\n               BLOCKS=MAXBLKS,        Maximum blocks                   x\n               TTOKEN=DSPTTOKN,       Use Jobstep TCB Token            x\n               MF=(E,DSPSERV1)\n         LTR   R15,R15                Test rc\n         BNZ   ABEND112\n*--------------------------------------------------------------------*\n* Get the dataspace ALET and establish addressability.\n* We always set the origin to x'1000' to overcome any incompatability\n* between processors - we may waste the first 4K but that's tough.\n*--------------------------------------------------------------------*\n         ALESERV ADD,                 Get the ALET                     x\n               STOKEN=DSPDTOKN,       For the dataspace STOKEN         x\n               ALET=DSPALET,          Place ALET here                  x\n               AL=PASN,               Available globaly                x\n               MF=(E,ALESERV1)\n         LTR   R15,R15                Test rc\n         BNZ   ABEND113\n         MVC   DSPORIG(4),=F'4096'    Set origin to 4K\n         LAM   R8,R8,DSPALET          Load AR8-AR9 with ALET\n         CPYA  R9,R8                  Copy AR8 to AR9\n*--------------------------------------------------------------------*\n* Initialize the RSST control block within the dataspace\n*--------------------------------------------------------------------*\n         L     R8,DSPORIG             Load R8 with start address\n         USING RSST,R8                Address DSECT\n         LR    R9,R8                  Copy address to R9\n         MVC   RSSTID,=CL4'RSST'      Indicate Eye-catch\n         MVC   RSSTNMBR,=F'0'         Set number of entries to zero\n         MVC   RSSTSIZE,=AL4(RSSTHSIZ) Init size of table\n         MVC   HIGHADDR,RSSTSIZE      Copy init size to high used addr\n         L     R7,MAXBLKS             Get the maximum blocks\n         SLL   R7,12                  x4096 = K\n         ST    R7,MAXADDR             Store as maximum address\n         LA    R9,RSSTENT             Point to first entry\nVARLOOP  EQU   *\n*--------------------------------------------------------------------*\n* Loop through all of the known REXX variables and see if they match\n* any of the passed stem names. If so we add the REXX variable name\n* and value as an entry in the RSST.\n* We find all of the known REXX variables by invoking IRXEXCOM with\n* the 'Fetch Next' option in the SHVB until the SHVLVAR bit is set\n* in SHVRET. When calling IRXEXCOM we have to reset the AR mode\n* indicator.\n*--------------------------------------------------------------------*\n         LA    R1,EXCOMID             Point to IRXEXCOM id\n         ST    R1,AEXCOMP1            Store in parm list\n         LA    R1,ZERO                Point to fullword zero\n         ST    R1,AEXCOMP2            Store in parm list\n         ST    R1,AEXCOMP3            Store in parm list\n         ST    R11,AEXCOMP4           Store SHVB as parm #4\n         LA    R1,ZERO                Point to fullword zero\n         ST    R1,AEXCOMP5            Store in parm list\n         LA    R1,EXCOMRC             Point to return code\n         ST    R1,AEXCOMP6            Store in parm list\n         OI    AEXCOMP6,X'80'         Indicate end of list\n         MVI   SHVCODE,SHVNEXTV       Indicate \"Fetch Next\"\n         MVC   SHVNAMA,ASHVNAMA       Point to name buffer\n         MVC   SHVVALA,ASHVVALA       Point to value buffer\n         MVC   SHVUSER,NAMALEN        Set name buffer length\n         MVC   SHVNAML,NAMALEN        Set name buffer length\n         MVC   SHVVALL,VALALEN        Set value buffer length\n         MVC   SHVBUFL,VALALEN        Set value buffer length\n         SYSSTATE ASCENV=P            Reset AR Mode\n         SAC   0\n         LA    R1,EXCOMPRM            Point to the parm list\n         L     R15,AIRXEXCM           Load address of routine\n         BALR  R14,R15                Call it\n         ICM   R15,B'1111',EXCOMRC    Test rc\n         BNZ   VARFINI                if not 0 - exit\n         SAC   512                    Switch into AR mode\n         SYSSTATE ASCENV=AR           Set Global bit for AR mode\n         TM    SHVRET,SHVLVAR         Last variable ?\n         BO    VARFINI                Yes - tidy up and go\nCOMPNAME EQU   *\n*--------------------------------------------------------------------*\n* We have a variable returned from IRXEXCOM, we need to point to the\n* first REXX stem name passed to this program and then loop through\n* the stemnames until we get a match or run out of names.\n*--------------------------------------------------------------------*\n         L     R4,EFPLARG             REXX Argument table\n         USING ARGTABLE_ENTRY,R4      Address it\nARGLOOP  EQU   *\n         CLC   0(8,R4),HEXFF          End of arg list ?\n         BE    NEXTVAR                Yes - get next variable\n         ICM   R5,B'1111',ARGTABLE_ARGSTRING_PTR\n         BZ    NEXTARG                if zero address - get next arg\n         ICM   R6,B'1111',ARGTABLE_ARGSTRING_LENGTH\n         BZ    NEXTARG                if zero length - get next arg\n         BCTR  R6,R0                  Minus 1 for execute\n         LR    R15,R5                 Quick copy of parm address\n         AR    R15,R6                 Point to last char of name\n         CLI   0(R15),C'.'            Is it a stem ?\n         BNE   NEXTARG                No - ignore\n         EX    R6,CONVUPPR            Make name uppercase\n         L     R15,ASHVNAMA           Point to name buffer\n         EX    R6,NAMECLC             Do they match ?\n         BNE   NEXTARG                No - check next arg\nMATCHARG EQU   *\n*--------------------------------------------------------------------*\n* We have found a match, we now need to add the variable name and\n* value to the RSST.\n* We also maintain a counter of the number of variables copied to the\n* RSST and the current size of the RSST (including header). This\n* allows us to release unused dataspace storage at the end of the\n* program.\n*--------------------------------------------------------------------*\n         L     R7,HIGHADDR            Get current end address\n         A     R7,SHVNAML             Add the name length\n         A     R7,SHVVALL             Add the value length\n         LA    R7,8(R7)               Add the two length words\n         C     R7,MAXADDR             Would there be enough room\n         BNL   DSPFULL                No - we are full\n         ICM   R15,B'1111',SHVNAML    Get the name length\n         STCM  R15,B'1111',0(R9)      Store in RSST\n         LA    R9,4(R9)               Point to name area\n         L     R15,ASHVNAMA           Point to name buffer\n         ICM   R6,B'1111',SHVNAML     Get the name length\n         BCTR  R6,R0                  Minus 1 for execute\n         CPYA  R15,R12                Ensure AR15 is same as AR12\n         EX    R6,MVCRSST             Move in the name value\n         ICM   R15,B'1111',SHVNAML    Get the name length\n         AR    R9,R15                 Point to value length\n         ICM   R15,B'1111',SHVVALL    Get the value length\n         STCM  R15,B'1111',0(R9)      Store in RSST\n         LA    R9,4(R9)               Point to value area\n         LR    R14,R9                 Copy address for MVCL\n         CPYA  R14,R9                 Copy AR9 to AR14 as well\n         L     R0,ASHVVALA            Point to value buffer\n         ICM   R15,B'1111',SHVVALL    Get the value length\n         LR    R1,R15                 Copy to R1 for MVCL\n         MVCL  R14,R0                 Move in the value\n         ICM   R15,B'1111',SHVVALL    Get the value length\n         AR    R9,R15                 Point to next entry\n         ST    R9,HIGHADDR            Store as new high used address\n*--------------------------------------------------------------------*\n* Add to variables 'pushed' and the RSST size\n*--------------------------------------------------------------------*\n         L     R15,RSSTNMBR           Get the number of vars 'pushed'\n         LA    R15,1(R15)             Add to it\n         ST    R15,RSSTNMBR           and store it back\n         L     R15,RSSTSIZE           Get current size\n         LA    R15,8(R15)             Add space for two length fields\n         A     R15,SHVNAML            Add the length of the name\n         A     R15,SHVVALL            Add the length of the value\n         ST    R15,RSSTSIZE           Store back in RSST\n         B     NEXTVAR                and look at next variable\nNEXTARG  EQU   *\n*--------------------------------------------------------------------*\n* Get the next stem name\n*--------------------------------------------------------------------*\n         LA    R4,8(R4)               Point to next arg\n         B     ARGLOOP                and check again\nNEXTVAR  EQU   *\n*--------------------------------------------------------------------*\n* Get the next REXX variable from IRXEXCOM\n*--------------------------------------------------------------------*\n         B     VARLOOP                No - do it again\nDSPFULL  EQU   *\n         OI    RSSTFLAG,RSSTFULL      Indicate full\n         B     RETURN00               and return\nVARFINI  EQU   *\n*--------------------------------------------------------------------*\n* We have finished browsing the REXX variables. We now round up the\n* storage used in the dataspace to a 4K boundary and release the\n* unused blocks. If we have found no matches, we still return rc=00\n* as the STEMPULL function examines RSSTNMBR before doing anything.\n*--------------------------------------------------------------------*\n         LR    R1,R9                  Copy High-used address\n         A     R1,=F'4095'            Add 4K-1\n         SRL   R1,12                  How many 4K blocks ?\n         ST    R1,USEDBLKS            Remember for later\n         SLL   R1,12                  Round the address to 4K\n         ST    R1,HIGHADDR            Store for later\n         L     R15,MAXBLKS            Load up maximum blocks\n         S     R15,USEDBLKS           Subtract used blocks\n         BNP   RETURN00               If not > 0 byapss RELEASE\n         ST    R15,FREEBLKS           = blocks to be release\n         DSPSERV RELEASE,             Release unused space             x\n               STOKEN=DSPDTOKN,       Using this STOKEN                x\n               START=HIGHADDR,        From this start address          x\n               BLOCKS=FREEBLKS,       for this many blocks             x\n               MF=(E,DSPSERV1)\nRETURN00 EQU   *\n*--------------------------------------------------------------------*\n* Return to the user and pass back the 'token'\n*--------------------------------------------------------------------*\n         SYSSTATE ASCENV=P            Reset AR Mode\n         SAC   0\n         BAL   R10,HEX2CHAR           Convert dataspace token to EBCDIC\n         MVC   EVALBLOCK_EVLEN(4),=F'16' Set length of result\n         MVC   EVALBLOCK_EVDATA(16),TOKEN\n         BAL   R10,RELSHVB            free the SHVB area\n         BAL   R10,RELWORK            free the workarea\n         XR    R15,R15                set rc to zero\n         PR                           return\nRETURNCC EQU   *\n*--------------------------------------------------------------------*\n* Return to the user and indicate failed\n*--------------------------------------------------------------------*\n         BAL   R10,RELWORK            free the workarea\n         MVC   EVALBLOCK_EVLEN(4),=F'1'  Set length of result\n         MVC   EVALBLOCK_EVDATA(2),=C'0' Move in result data\n         PR                           return\n*\n*--------------------------------------------------------------------*\n* General Routines\n*--------------------------------------------------------------------*\n*\nHEX2CHAR EQU   *\n*--------------------------------------------------------------------*\n* Convert a hex string to EBCDIC\n* We convert the 8-byte dataspace token '8ABC00...' to its 16-byte\n* EBCDIC equivalent eq 'F8C1C2C3F0F0....'\n*--------------------------------------------------------------------*\n         LA    R1,DSPDTOKN            Point to the dataspace token\n         LA    R15,TOKEN              Point to the EBCDIC token\n         LA    R0,8                   Set length of input\nLEFTHALF EQU   *\n         XR    R7,R7                  Clear\n         ICM   R7,B'0001',0(R1)       Load up a byte (000000ab)\n         SRL   R7,4                   Remove last 4 bits (0000000a)\nLEFTNUM  EQU   *\n         CH    R7,=H'9'               00000000 - 00000009 ?\n         BH    LEFTLTTR               higher - must be A-F\n         AH    R7,=H'240'             xlate to F0-F9\n         B     LEFTDONE\nLEFTLTTR EQU   *\n         AH    R7,=H'183'             xlate to C1-C6\nLEFTDONE EQU   *\n         STCM  R7,B'0001',0(R15)      Store in token\n         LA    R15,1(R15)             Point to next char\nRGHTHALF EQU   *\n         XR    R7,R7                  Clear\n         ICM   R7,B'0001',0(R1)       Load up a byte (000000ab)\n         SLL   R7,28                  Remove first 4 bits (b0000000)\n         SRL   R7,28                  and reset           (0000000b)\nRGHTNUM  EQU   *\n         CH    R7,=H'9'               00000000 - 00000009 ?\n         BH    RGHTLTTR               higher - must be A-F\n         AH    R7,=H'240'             xlate to F0-F9\n         B     RGHTDONE\nRGHTLTTR EQU   *\n         AH    R7,=H'183'             xlate to C1-C6\nRGHTDONE EQU   *\n         STCM  R7,B'0001',0(R15)      Store in token\n         LA    R15,1(R15)             Point to next char\n         LA    R1,1(R1)               Point to next token byte\n         BCT   R0,LEFTHALF            Loop for all bytes\n         BR    R10                    return\n*\nRELWORK  EQU   *\n*--------------------------------------------------------------------*\n* Release workarea storage\n*--------------------------------------------------------------------*\n         DELETE EP=IRXEXCOM           Delete IRXEXCOM from storage\n         STORAGE RELEASE,             release workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in R13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         BR    R10                    return\n*\nRELSHVB  EQU   *\n*--------------------------------------------------------------------*\n* Release SHVB storage\n*--------------------------------------------------------------------*\n         STORAGE RELEASE,             release SHVB storage             X\n               LENGTH=4096,           this much                        X\n               ADDR=(R11),            address in R11                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         BR    R10                    return\n*\nABEND111 ABEND 111,DUMP               TCBTOKEN failed\nABEND112 ABEND 112,DUMP               ALESERV failed\nABEND113 ABEND 113,DUMP               DSPSERV failed\n*\n*-------------------------------------------------------------------*\n* Executed instructions\n*-------------------------------------------------------------------*\n*\nCONVUPPR TR    0(0,R5),UPPER          Xlate to upper case\nNAMECLC  CLC   0(0,R15),0(R5)         Compare variable names\nMVCRSST  MVC   0(0,R9),0(R15)         Copy in the name\nMOVEBLKS MVC   0(0,R7),0(R5)          Copy in the name\n*\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs\n*-------------------------------------------------------------------*\n*\n         LTORG\nUPPER    DS    0CL256\n         DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n*\nNUMBERS  DC    256X'FF'               Translate table - Numbers\n         ORG   NUMBERS+C'0'\n         DC    10X'00'\n*\nHEXFF    DC    XL8'FFFFFFFFFFFFFFFF'  High values\nEXCOMID  DC    CL8'IRXEXCOM'          IRXEXCOM ID\nZERO     DC    F'0'                   Zero fullword\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                    save area\nTOKEN    DS    CL16                   Token passed back\nDSPTTOKN DS    CL16                   TCB Token\nDSPNAME  DS    CL8                    Dataspace name\nDSPDTOKN DS    CL8                    Dataspace token\nDSPORIG  DS    F                      Dataspace origin\nDSPALET  DS    F                      Dataspace ALET\nAIRXEXCM DS    F                      address of IRXEXCOM\nASHVNAMA DS    F                      address of SHVB name buffer\nASHVVALA DS    F                      address of SHVB value buffer\nNAMALEN  DS    F                      length of SHVB name buffer\nVALALEN  DS    F                      length of SHVB value buffer\nEXCOMRC  DS    F                      Return code from IRXEXCOM\nEXCOMPRM DS    0F                     Parm list for IRXEXCOM\nAEXCOMP1 DS    F                      ---> IRXEXCOM ID\nAEXCOMP2 DS    F                      ---> 0\nAEXCOMP3 DS    F                      ---> 0\nAEXCOMP4 DS    F                      ---> SHVBLOCK\nAEXCOMP5 DS    F                      ---> ENVBLOCK\nAEXCOMP6 DS    F                      ---> Return Code\n         DS    0D\nENTNUM   DS    F\nPWORK    DS    F                      Fullword work area\nUWORK    DS    CL8                    Character work area\n         DS    0F\nMAXBLKS  DS    F                      Max size of data space n*4K\nUSEDBLKS DS    F                      Used Dataspace blocks\nFREEBLKS DS    F                      Used Dataspace blocks\nHIGHADDR DS    F                      High-used address in dataspace\nMAXADDR  DS    F                      Maximum address in dataspace\n         DSPSERV MF=(L,DSPSERV1)      List form of DSPSERV\nTCBTOKN1 TCBTOKEN MF=L                List form of TCBTOKEN\nALESERV1 ALESERV MF=L                 List form of ALESERV\n         DS    0D\nWORKLEN  EQU   *-WORKAREA\n*\nRSST     DSECT\n*-------------------------------------------------------------------*\n* The Pushed REXX Stem Variable Storage Table (RSST)\n*\n* The RSST consists of a 12 byte header plus a variable amount of\n* individual entries. Each entry is constructed as follows :\n* Namel     DS   AL4(Name)        Length of name\n* Name      DS   CL(Namel)        REXX Variable Name\n* Valuel    DS   AL4(Value)       Length of value\n* Value     DS   CL(Valuel)       REXX Variable value\n*\n* For example, an entry for a variable 'STEM.11' with a value 'FRED'\n* would look like this :\n*   Namel   Name          Valuel  Value\n* x'00000007E2E3C5D44BF1F100000004C6D9C5C4'\n*-------------------------------------------------------------------*\nRSSTID   DS    CL4                    Eyecatcher\nRSSTNMBR DS    CL4                    Number of entries\nRSSTSIZE DS    CL4                    Size of table (including header)\nRSSTFLAG DS    X                      Flag byte\nRSSTFULL EQU   X'80'                  RSST is full\n         DS    XL3                    Reserved\nRSSTHSIZ EQU   *-RSST                 Size of header\nRSSTENT  DS    0C                     Entry\n*\n*\n         IRXEFPL                      REXX External Function\n         IRXEVALB                     REXX Evaluation Block\n         IRXENVB                      REXX Environment Block\n         IRXSHVB                      REXX Shared Variable Block\n         IRXARGTB DECLARE=YES         REXX Argument Table\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VARYDAS$": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x04_\\x01\\x00\\x04_\\x10\"\\x00~\\x00~\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-14T00:00:00", "modifydate": "2000-02-14T10:22:00", "lines": 126, "newlines": 126, "modlines": 0, "user": "SBGOLOB"}, "text": "Vary DASD Volumes Offline By Volser\n-----------------------------------\n\n1.0 Installation of VARYDASD\n\n    Supplied Material :\n    README.TXT    -  This file\n    VARYDASD.TXT  -  Assembler source code for the VARYDASD function\n\n    (a) File transfer the VARYDASD.TXT file to the mainframe host\n        using ASCII-EBCDIC translation.\n\n    (b) Assemble and link VARYDASD into an APF authorised load library.\n        Use the following linkedit attributes :\n           AMODE(31)\n           RMODE(24)\n           NORENT\n           NOREUS\n           NOREFR\n           AC(1)\n\n 2.0 Using VARYDASD\n\n     The VARYDASD program is used to vary DASD devices offline\n     at IPL time by volser rather than the normal unit address\n     specification.\n\n     This drastically reduces the possible errors that could\n     result from the COMMNDxx member of PARMLIB being out of\n     date.\n\n     The VARYDASD started task JCL is as follows :\n\n      //VARYDASD PROC MEMBER=&SYSCLONE,TYPE=APPLY,WTO=BOTH\n      //*\n      //VARY   EXEC PGM=VARYDASD,PARM='TYPE=&TYPE,WTO=&WTO',TIME=1440\n      //SYSIN  DD  DISP=SHR,DSN=SYS1.PARMLIB(DASD&MEMBER)\n\n     During IPL, an entry in the COMMNDxx member invokes this\n     started task by issuing the command :\n\n         'S VARYDASD,SUB=MSTR'\n\n     Note that the STC is started under the MASTER subsystem, so\n     that it can run before JES2 has started.\n\n     When started, the program will read some SYSIN cards that\n     specify the volser patterns of volumes that are to remain\n     online. The program then scans through the online DASD\n     units and attempts to match the volser from a unit to any\n     of the specified patterns.\n\n     If a match is found, a message is issued stating that the\n     volume is to remain ONLINE. If no match is found, a message\n     is issued stating that the volume is to be varied offline\n     and its unit address is varied offline after all DASD units\n     have been processed.\n\n     The SYSIN Cards\n     ---------------\n\n     The SYSIN cards must be 80-byte images with the volser\n     pattern placed in columns 1-6. A single character wildcard of\n     '%' can be used to signify any character. All six character\n     MUST be specified (eg if you wish to keep all volumes\n     starting 'D2' online, you must use 'D2%%%%' and not 'D2*' or\n     'D2%'\n\n     System symbols are supported as SYSIN cards, but the\n     trailing dot must not be specified and the symbol name must\n     be exactly six characters long.\n\n     Comments are indicated by any of the following :\n     (a) Blank in column 1\n     (b) Asterix in column 1\n     (c) '/*' in columns 1-2\n\n     Example valid SYSIN cards\n     -------------------------\n\n     PAGE%%\n     D%MV%%\n     JES2%%\n     &SYSR1\n     &SYSR2\n\n     The reccommended place for the SYSIN cards is in member\n     DASDxx in PARMLIB.\n\n     Runtime paramters\n     -----------------\n\n     The program accepts two optional runtime paramters : TYPE and WTO\n\n     The TYPE keyword indicates the runtime mode as follows :\n\n     (1) TYPE=CHECK\n         The program issues messages indicating the resultant\n         status of the device.  No action is taken against any of\n         the DASD units.  This mode allows the user to verify\n         the SYSIN cards.\n         This is the default.\n\n     (2) TYPE=APPLY\n         The program varies the required devices offline to the\n         system.\n\n     The WTO keyword indicates the message level used by the program :\n\n     (1) WTO=NONE\n         No WTOs indicating device status are issued by this program\n     (2) WTO=ONLINE\n         A WTO is issued for each device that is to remain ONLINE\n     (3) WTO=OFFLINE\n         A WTO is issued for each device that is to be varied OFFLINE\n     (4) WTO=BOTH\n         A WTO is issued for each device that is to be varied\n         OFFLINE and also for devices that remain ONLINE.\n         This is the default\n\n\nRob Scott\nScott Enterprise Consultancy Ltd\n\nWebsite : www.secltd.co.uk\nEmail   : rob@secltd.co.uk\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VARYDASD": {"ttr": 3078, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x04_\\x01\\x00\\x04_\\x10\"\\x01\\xf6\\x01\\xf6\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-02-14T00:00:00", "modifydate": "2000-02-14T10:22:00", "lines": 502, "newlines": 502, "modlines": 0, "user": "SBGOLOB"}, "text": "VARYDASD TITLE 'VARY DASD OFFLINE DEPENDING ON VOLSER'\n*-------------------------------------------------------------------*\n* Name            : VARYDASD\n*\n* Function        : This program will vary DASD volumes OFFLINE by\n*                   checking to see if the volser matches a list\n*                   supplied by the SYSIN DD card. If no match, the\n*                   program uses IEEVARYD to vary the devices\n*                   offline.\n*\n*                   The list supplied by the SYSIN DD can contain a\n*                   placeholder '%' to indicate any character.\n*\n*                   The volser mask must be placed in the columns\n*                   1-6 in the SYSIN dataset.\n*\n*                   System symbols are supported - they must be\n*                   6 characters long and specified WITHOUT the\n*                   trailing dot.\n*\n*                   Comments are indicated by any of the following :\n*                   (a) Blank in column 1\n*                   (b) Asterix in column 1\n*                   (c) '/*' in columns 1-2\n*\n*                   The program can be run in two modes supplied as\n*                   a parameter to the program :\n*\n*                   (1) TYPE=CHECK\n*                       The program issues a WTO indicating the\n*                       ONLINE/OFFLINE status for each device against\n*                       the supplied SYSIN cards. No action is taken\n*                       against any unit.\n*                       This mode allows the user to verify the SYSIN\n*                       cards. This is the default h\n*                   (2) TYPE=APPLY\n*                       The program will vary required devices OFFLINE.\n*\n*                   The program can also issue WTO messages depending\n*                   on a paramter passed to the program :\n*\n*                   (1) WTO=NONE\n*                       No WTOs indicating device status are issued\n*                       by this program.\n*                   (2) WTO=ONLINE\n*                       A WTO is issued for each device that is to\n*                       remain ONLINE.\n*                   (3) WTO=OFFLINE\n*                       A WTO is issued for each device that is to\n*                       be varied OFFLINE.\n*                   (4) WTO=BOTH\n*                       A WTO is issued for each device that is to\n*                       be varied OFFLINE and also for devices that\n*                       remain ONLINE. This is the default\n*\n* Example JCL  :\n*\n* //VARY     EXEC PGM=VARYDASD,PARM='TYPE=CHECK,WTO=ONLINE'\n* //STEPLIB  DD   DISP=SHR,DSN=some.apf.dataset\n* //SYSIN    DD   *\n* D2%%%%\n* MVS2%%\n* JES2%%\n* CAT2%%\n* &SYSR1\n* &SYSR2\n* /*\n*\n*\n* IBM Macros Used : MODID, STORAGE, UCBSCAN, IEEVARYD, WTO, ABEND,\n*                   OPEN, GET, CLOSE, UCBDEVN, MODESET, LINK,\n*                   DCB, CVT, IEFUCBOB, IEEZB833, ASASYMBP\n*\n* Attributes      : Amode(31)\n*                   Rmode(24)\n*                   NORENT\n*                   NOREUS\n*                   NOREFR\n*                   AC(1)\n*\n* Register Usage  :\n*\n* R1  - Used in STATUS routine\n* R2  - work\n* R3  - Device array for IEEVARYD\n* R4  - UCB\n* R5  - Used in STATUS routine\n* R6  - Table of volser masks (float)\n* R7  - Work\n* R8  - Table of volser masks (start)\n* R9  - Number of volser masks\n* R10 - Branch and Link\n* R11 - Device count\n* R12 - Base reg\n* R13 - Workarea\n* R14 - Used in STATUS Routine\n*\n* ABEND Codes :\n* U101  = Invalid length on paramter (must be <= 22)\n*\n*\n*-------------------------------------------------------------------*\n* Changes\n* 27/10/1999  Rob Scott  Code Written                            V1.0\n* 07/12/1999  Rob Scott  Added support for System Symbols        V1.1\n*-------------------------------------------------------------------*\n*\n*-------------------------------------------------------------------*\n* Copyright : Scott Enterprise Consultancy Ltd\n*-------------------------------------------------------------------*\nVARYDASD CSECT\nVARYDASD AMODE 31\nVARYDASD RMODE 24\n         BAKR  R14,R0                 linkage stack\n         LAE   R12,0(R15,0)           set R12 as base\n         USING VARYDASD,R12           address it\n         MODID ,                      eyecatcher\n         LR    R2,R1                  copy any parms passed\nGETWORK  EQU   *\n*--------------------------------------------------------------------*\n* Get some workarea storage and init to zeros.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in r13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=BELOW,             below the line                   X\n               COND=NO                unconditional\n         USING WORKAREA,R13           address workarea\n         LR    R14,R13                Copy workarea address\n         L     R15,=A(WORKLEN)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to zeros\n         MVC   4(4,R13),=C'F1SA'      set label in savearea\n*--------------------------------------------------------------------*\n* Set runtype defaults :\n* TYPE=CHECK,WTO=ALL\n*--------------------------------------------------------------------*\n         OI    RUNTYPE,RUNCHECK+RUNWTOON+RUNWTOOF\nGETARRAY EQU   *\n*--------------------------------------------------------------------*\n* Get some storage for the IEEVARYD service\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the storage                  X\n               LENGTH=DISK65K,        enough for 65K disks             X\n               ADDR=(R3),             address in r3                    X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=ANY,               above the line                   X\n               COND=NO                unconditional\n         USING WORKAREA,R13           address workarea\n         LR    R14,R3                 Copy workarea address\n         L     R15,=A(DISK65K)        Get length of workarea\n         XR    R0,R0                  Clear\n         XR    R1,R1                  Clear\n         MVCL  R14,R0                 Init to zeros\n         XR    R11,R11                Zero device count\n         ST    R3,DEVARRAY            Store start address\nGETPARMS EQU   *\n         LTR   R2,R2                  Any parms ?\n         BZ    GETVTABL               No - leave as default\n         ICM   R2,B'1111',0(R2)       Any parms ?\n         BZ    GETVTABL               No - leave as default\n         XR    R1,R1                  Clear\n         ICM   R1,B'0011',0(R2)       Get length of parms\n         C     R1,=F'22'              Correct length ?\n         BNH   GOODPARM               Yes - OK\n         WTO   'VARYDASD - INCORRECT PARAMETER LENGTH'\n         ABEND 101,DUMP\nGOODPARM EQU   *\n         LR    R15,R1                 copy parm length\n         BCTR  R15,R0                 -1 for execute\n         EX    R15,PARMCOPY           Copy the parms in\n         LA    R2,COPYPARM            Point to the parms\nPARMLOOP EQU   *\n         CLC   0(10,R2),=CL10'TYPE=APPLY'\n         BE    SETAPPLY               Set TYPE=APPLY flag\n         CLC   0(10,R2),=CL10'TYPE=CHECK'\n         BE    SETCHECK               Set TYPE=CHECK flag\n         CLC   0(8,R2),=CL10'WTO=BOTH'\n         BE    SETBOTH                Set WTO=BOTH flag\n         CLC   0(8,R2),=CL10'WTO=NONE'\n         BE    SETNONE                Set WTO=NONE flag\n         CLC   0(10,R2),=CL10'WTO=ONLINE'\n         BE    SETON                  Set WTO=ONLINE flag\n         CLC   0(11,R2),=CL11'WTO=OFFLINE'\n         BE    SETOFF                 Set WTO=OFFLINE flag\nNEXTPARM EQU   *\n         LA    R2,1(R2)               Shuffle down parms\n         BCT   R1,PARMLOOP            Loop for all\n         B     GETVTABL               and carry on\nSETAPPLY NI    RUNTYPE,255-RUNCHECK   Reset flag\n         OI    RUNTYPE,RUNAPPLY       Set flag\n         B     NEXTPARM               and get next char\nSETCHECK NI    RUNTYPE,255-RUNAPPLY   Reset flag\n         OI    RUNTYPE,RUNCHECK       Set flag\n         B     NEXTPARM               and get next char\nSETBOTH  OI    RUNTYPE,RUNWTOON       Set flag\n         OI    RUNTYPE,RUNWTOOF       Set flag\n         B     NEXTPARM               and get next char\nSETNONE  NI    RUNTYPE,255-RUNWTOON   Reset flag\n         NI    RUNTYPE,255-RUNWTOOF   Reset flag\n         B     NEXTPARM               and get next char\nSETON    NI    RUNTYPE,255-RUNWTOOF   Reset flag\n         OI    RUNTYPE,RUNWTOON       Set flag\n         B     NEXTPARM               and get next char\nSETOFF   NI    RUNTYPE,255-RUNWTOON   Reset flag\n         OI    RUNTYPE,RUNWTOOF       Set flag\n         B     NEXTPARM               and get next char\nGETVTABL EQU   *\n*--------------------------------------------------------------------*\n* Get some storage to hold the volume serials from SYSIN.\n*--------------------------------------------------------------------*\n         STORAGE OBTAIN,              get the workarea storage         X\n               LENGTH=10000*6,        room for 10000 volsers           X\n               ADDR=(R8),             address in r8                    X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               LOC=BELOW,             above the line                   X\n               COND=NO                unconditional\n         XR    R9,R9                  init count\n         LR    R6,R8                  copy start address\n*--------------------------------------------------------------------*\n* Now open and read in the SYSIN cards\n* The volser should be specified in columns 1 to 6.\n* Comments are indicated by either :\n* (a) A Space in column 1\n* (b) An asterix in column 1\n* (c) A '/*' in column 1 and 2\n*--------------------------------------------------------------------*\n         OPEN  (SYSIN,(INPUT))        open the sysin cards\nREADCARD EQU   *\n         GET   SYSIN,INREC            Get the record\n         CLI   INREC,C' '             Space ?\n         BE    READCARD               Yes - ignore\n         CLI   INREC,C'*'             Comment ?\n         BE    READCARD               Yes - ignore\n         CLC   INREC(2),=CL2'/*'      Comment ?\n         BE    READCARD               Yes - ignore\n         MVC   TEMPVALU(6),INREC      No - copy the value\n*--------------------------------------------------------------------*\n* We now check to see if a System Symbol has been specified. If so\n* we call ASASYMBM to translate it for us and then place it in\n* the table.\n*--------------------------------------------------------------------*\n         CLI   INREC,X'50'            Is it a symbol ?\n         BNE   GOODCARD               No carry on\n         LA    R7,PARMSYMB            Point to ASASYMBM parms\n         USING SYMBP,R7               Address it\n         XC    PARMSYMB(SYMBP_LEN),PARMSYMB\n         MVC   TEMPSYMB(6),INREC      Copy the symbol\n         MVI   TEMPSYMB+6,C'.'        add a dot\n         LA    R1,TEMPSYMB            Point to the symbol\n         ST    R1,SYMBPPATTERN@       Store in parm list\n         LA    R1,7                   Set length of input\n         ST    R1,SYMBPPATTERNLENGTH  Store in parm list\n         LA    R1,TEMPVALU            Point to the answer area\n         ST    R1,SYMBPTARGET@        Store in parm list\n         LA    R1,F6                  Set length of input\n         ST    R1,SYMBPTARGETLENGTH@  Store in parmlist\n         LA    R1,TEMPRC              Point to rc\n         ST    R1,SYMBPRETURNCODE@    Store in parmlist\n         LINK  EP=ASASYMBM,MF=(E,PARMSYMB)\n         CLC   TEMPRC(4),=F'0'        did we xlate the symbol ?\n         BE    GOODCARD               yes - carry on\n         MVC   BADSYM+53(6),TEMPSYMB\nBADSYM   WTO   'VARYDASD - ERROR TRANSLATING SYSTEM SYMBOL : xxxxxx'\n         B     READCARD\nGOODCARD EQU   *\n*--------------------------------------------------------------------*\n* This is NOT a comment card, copy the six chars into the table of\n* volume masks and increment count (R9) and current pointer (R6)\n*--------------------------------------------------------------------*\n         MVC   0(6,R6),TEMPVALU       Copy in the mask\n         LA    R9,1(R9)               Add to count\n         LA    R6,6(R6)               Point to next volser\n         C     R9,=F'10000'           Maximum number ?\n         BL    READCARD               no - get next record\nENDSYSIN EQU   *\n         CLOSE (SYSIN)                Close the SYSIN dataset\n         LR    R6,R8                  Put back to start\n*\nDASDINIT EQU   *\n*--------------------------------------------------------------------*\n* Now we set up the UCBSCAN loop to shuffle thru the DASD devices and\n* compare the volser to all of the supplied masks.\n*--------------------------------------------------------------------*\n         LA    R4,UCBAREA             Point to copy of UCB\n         USING UCBCMSEG,R4            address it\n         XC    WORKUCB,WORKUCB        Clear UCB workarea\nDASDSCAN EQU   *\n         UCBSCAN COPY,                Perform UCBSCAN                  X\n               WORKAREA=WORKUCB,      Use this workarea                X\n               UCBAREA=UCBAREA,       Copy UCB here                    X\n               CMXTAREA=CMXTAREA,     UCB Common extension             X\n               DEVCLASS=DASD,         Only find DASD                   X\n               DEVN=0,                Start at beginning               X\n               RANGE=ALL,             Include 4-digit devices          X\n               DYNAMIC=YES            and dynamic UCBs\n         LR    R7,R15                 COPY RETURN CODE\n         C     R7,=F'4'               CHECK RC\n         BH    DASDSCAN               If RC > 4 ignore\n         BE    DASDFINI               If RC = 4 then finished\n         TM    UCBSTAT,UCBONLI        Is it Online ?\n         BNO   DASDSCAN               No - get next\n*--------------------------------------------------------------------*\n* We copy the volser to field VOLSER and translate the hex unit\n* address to EBCDIC field UNITADDR\n* Once this is done, we call the STATUS routine to determine if the\n* volume should be varied ONLINE or OFFLINE.\n*--------------------------------------------------------------------*\n         MVC   VOLSER(6),UCBVOLI      Copy the Volser\n         UCBDEVN DEVN=UNITADDR        Get the unit address\n         BAL   R10,STATUS             Check the status\n         LTR   R15,R15                Does volume stay online ?\n         BZ    ONLINE                 Yes - tell ops\nOFFLINE  EQU   *\n         TM    RUNTYPE,RUNWTOOF       Issue OFFLINE WTO ?\n         BNO   BYPWTOOF               No - bypass it\n         MVC   VARYOFFT+16(4),UNITADDR Copy CUA to MSG\n         MVC   VARYOFFT+28(6),VOLSER   Copy volser to MSG\n         WTO   TEXT=VARYOFF           Issue WTO\nBYPWTOOF EQU   *\n         MVC   0(2,R3),UCBCHAN        Copy UCB address (binary)\n         LA    R11,1(R11)             Add one to device count\n         LA    R3,4(R3)               Point to next\n         B     DASDSCAN               and get next UCB\nONLINE   EQU   *\n         TM    RUNTYPE,RUNWTOON       Issue ONLINE WTO ?\n         BNO   DASDSCAN               No - bypass it\n         MVC   KEEPONT+16(4),UNITADDR Copy CUA to MSG\n         MVC   KEEPONT+28(6),VOLSER   Copy volser to MSG\n         MVC   KEEPONT+43(6),MATCHED  Copy pattern to MSG\n         WTO   TEXT=KEEPON            No - just issue WTO\n         B     DASDSCAN               and get next UCB\nDASDFINI EQU   *\n*--------------------------------------------------------------------*\n* We have finished looping thru the UCBs. If we are running\n* TYPE=APPLY, we issue the IEEVARYD service to vary the devices\n* offline.\n*--------------------------------------------------------------------*\n         TM    RUNTYPE,RUNAPPLY       Do the varies ?\n         BNO   FINISHED               No\n         LTR   R11,R11                Any devices to vary ?\n         BZ    FINISHED               no - exit\n         ST    R11,NUMDEVS            Store number of devices\n         MVC   CALLERID(8),=CL8'VARYDASD'\n         LA    R2,DEVINPUT            Point to IEEVARYD input\n         USING VDEV,R2                Address it\n         MVC   VDEV_ID(4),=CL4'VDEV'  Init fields\n         MVI   VDEV_VERSION,VDEV_VERN\n         OI    VDEV_KEYWORDS1,VDEV_OFFLINE\n         L     R3,DEVARRAY            Point to start\n         MODESET MODE=SUP,KEY=ZERO\n         IEEVARYD OPERATION=DEVINPUT, Operation is VARY OFFLINE        x\n               DEVICES=(R3),          List of devices                  x\n               NUMDEVS=NUMDEVS,       Number of devices                x\n               CALLERID=CALLERID,     Plug in VARYDASD as caller       x\n               RETCODE=RETCODE,       Store RC and RSN code            x\n               RSNCODE=RSNCODE\n         MODESET MODE=PROB,KEY=NZERO\n         STORAGE RELEASE,             release storage                  X\n               LENGTH=DISK65K,        this much                        X\n               ADDR=(R3),             address in R3                    X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\nFINISHED EQU   *\n         STORAGE RELEASE,             release workarea storage         X\n               LENGTH=WORKLEN,        this much                        X\n               ADDR=(R13),            address in R13                   X\n               SP=0,KEY=8,            subpool 0 storage key 8          X\n               COND=NO                unconditional\n         XR    R15,R15                set rc to zero\n         PR                           return\n*\nSTATUS   EQU   *\n*--------------------------------------------------------------------*\n* Determine if volume is in list to be ONLINE or OFFLINE\n*\n* Regs and fields on input :\n*   R9 = Number of volser masks (patterns)\n*   R8 = Starting address of volser mask table\n*   VOLSER = Six char actual volume serial of DASD in question\n*\n* Regs used during processing\n*   R0 = Branch and count within volser mask (up to six)\n*   R1 = Pointer to character within pattern\n*   R5 = Pointer to character within volser\n*   R6 = Pointer to current mask\n*   R14= Branch and count (number of masks)\n*--------------------------------------------------------------------*\n         LR    R14,R9                 Copy number of patterns\n         LR    R6,R8                  Point to start of table\nPATNLOOP EQU   *\n*--------------------------------------------------------------------*\n* This loop processes each volser mask within the table\n*--------------------------------------------------------------------*\n         LR    R1,R6                  point to 1st char in pattern\n         LA    R0,6                   Set loop count\n         LA    R5,VOLSER              Point to the 1st char in volser\nCHARLOOP EQU   *\n*--------------------------------------------------------------------*\n* This loop processes each character within the volser and the mask\n*--------------------------------------------------------------------*\n         CLI   0(R1),C'%'             Placeholder ?\n         BE    NEXTCHAR               Yes - assume match\n         CLC   0(1,R5),0(R1)          Matched char ?\n         BE    NEXTCHAR               Yes\n         B     NEXTPATN               No - try next pattern\nNEXTCHAR EQU   *\n         LA    R1,1(R1)               Move along the pattern\n         LA    R5,1(R5)               Move along the volser\n         BCT   R0,CHARLOOP            Loop for 6 chars\n         MVC   MATCHED(6),0(R6)       Copy the pattern\n         B     STATON                 If we get here - volser ONLINE\nNEXTPATN EQU   *\n         LA    R6,6(R6)               Point to next pattern\n         BCT   R14,PATNLOOP           Loop thru all patterns\nSTATOFF  EQU   *\n         LA    R15,8                  Set RC=4\n         BR    R10                    Return\nSTATON   EQU   *\n         XR    R15,R15                Zero RC\n         BR    R10                    Return\n*\n*-------------------------------------------------------------------*\n* Constants, Variables and DSECTs\n*-------------------------------------------------------------------*\n*\nPARMCOPY MVC   COPYPARM(0),2(R2)     Copy in the parms\n         LTORG\n         DS    0F\nF6       DC    F'6'\n*\nDISK65K  EQU   65536*4\nSYSIN    DCB   DDNAME=SYSIN,MACRF=GM,DSORG=PS,EODAD=ENDSYSIN\n*\nVARYOFF  DS    0F\n         DC    H'80'\nVARYOFFT DC    CL80'VARYDASD - Unit uuuu Volser=vvvvvv placed OFFLINE'\nKEEPON   DS    0F\n         DC    H'80'\nKEEPONT  DC    CL80'VARYDASD - Unit uuuu Volser=vvvvvv Pattern=pppppp kx\n               ept ONLINE'\n*\nWORKAREA DSECT\nSAVEAREA DS    18F                    save area\nINREC    DS    CL80                   SYSIN record\n         DS    0D\nVOLSER   DS    CL6                    Volser\nMATCHED  DS    CL6                    Volser matched pattern\nUNITADDR DS    CL4                    Unit address\nCOPYPARM DS    CL48                   Copy of parms passed\nTEMPSYMB DS    CL7                    Area for system symbol\nTEMPVALU DS    CL6                    Area for returned value\n         DS    0F\nTEMPRC   DS    F                      RC from ASASYMBM\nPARMSYMB DS    CL(SYMBP_LEN)          Parmlist for ASASYMBM)\n         DS    0F\nRUNTYPE  DS    X                      Type of run\nRUNCHECK EQU   X'80'                  Just check (Issue WTO)\nRUNAPPLY EQU   X'40'                  Issue IEEVARYD\nRUNWTOON EQU   X'20'                  Issue WTO for ONLINE volumes\nRUNWTOOF EQU   X'10'                  Issue WTO for OFFLINE volumes\n         DS    0D\nUCBRC    DS    F                      Return code from UCBSCAN\nUCBRSN   DS    F                      Reason code from UCBSCAN\n         DS    0D\nUCBAREA  DS    CL48                   area to get UCB copy\nUCBPAREA DS    CL48                   area to get UCB prefix copy\nCMXTAREA DS    CL32                   area to get CMXT copy\nWORKUCB  DS    CL100                  UCBSCAN workarea\n         DS    0F\nCALLERID DS    CL8                    Caller ID for IEEVARYD\nRETCODE  DS    F                      IEEVARYD return code\nRSNCODE  DS    F                      IEEVARYD reason code\nNUMDEVS  DS    F                      Number of devices\nDEVARRAY DS    F                      Address of device array\nDEVINPUT DS    CL(VDEV_LENGTH)        Length of IEEVARYD input\nWORKLEN  EQU   *-WORKAREA\n*\n         CVT DSECT=YES,LIST=NO\n         IEFUCBOB\n         IEEZB833\n         ASASYMBP\n*\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VIEWSYM": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01I\\x00\\x00\\x00\\x96&O\\x00\\x99&_\\x08\\x15\\x00^\\x00\\x14\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.73", "flags": 0, "createdate": "1996-09-20T00:00:00", "modifydate": "1999-09-22T08:15:00", "lines": 94, "newlines": 20, "modlines": 0, "user": "FILE411"}, "text": "/* REXX   - Exec to show the translated text after substitution of    */\n/*          MVS symbols while in EDIT or VIEW of a member.            */\n/*                                                                    */\n/*          This macro isn't foolproof, but gives a good impression   */\n/*          of what the text may look like.                           */\n/*                                                                    */\n/*          Note: Uses the LISTSYM external Rexx function.            */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\n/* Changes                                                            */\n/* 20/09/1996  Rob Scott  Code Written                                */\n/*--------------------------------------------------------------------*/\n                                            /*                        */\naddress ISREDIT \"MACRO\"                     /* declare as edit macro  */\naddress ISREDIT \"(lines) = LINENUM .ZLAST\"  /* get # of source lines  */\ni = 1                                       /* stem loop count        */\nlines = strip(lines,l,'0')                  /* strip zeros for stems  */\nsrcline.0 = lines                           /* set stem count         */\nnewline.0 = lines                           /* set stem count         */\n                                            /*                        */\nx = listsym()                               /* Get the symbols        */\n                                            /*                        */\n/*--------------------------------------------------------------------*/\n/* First of all capture the current editted source and place it in    */\n/* the srcline stem variable.                                         */\n/*--------------------------------------------------------------------*/\n                                            /*                        */\ndo while i <= lines                         /* do for all lines       */\n   address ISREDIT \"(linedat) = LINE \"i     /* get the line contents  */\n   srcline.i = substr(linedat,1,80)         /* ensure 80 chars        */\n   i = i + 1                                /* get next line number   */\n   end                                      /*                        */\n                                            /*                        */\n/*--------------------------------------------------------------------*/\n/* Now examine each line in the srcline stem and see if we could have */\n/* an MVS symbol ( i.e. look for an '&' ) - if not the source line    */\n/* remains unchanged.                                                 */\n/*--------------------------------------------------------------------*/\n                                            /*                        */\ni = 1                                       /* set loop count to 1    */\ndo while i <= srcline.0                     /* go thru all lines      */\n   if index(srcline.i,'&') =0 then do       /* if not '&' then..      */\n      newline.i = srcline.i                 /* ..it remains the same  */\n      end                                   /*                        */\n   else do                                  /* we may have a symbol.. */\n      newline.i = REPLACE_SYMBOL(srcline.i) /* call routine to change */\n      end                                   /*                        */\n   i = i + 1                                /* get next line          */\n   end                                      /*                        */\n                                            /*                        */\n/*--------------------------------------------------------------------*/\n/* We have the translated lines held in newline. Lines that have been */\n/* changed are highlited by using the MSGLINE type of edit comment    */\n/* while unchanged ones are left as NOTELINEs.                        */\n/*--------------------------------------------------------------------*/\ni = newline.0                               /* get maximum line number*/\n                                            /*                        */\ndo while i > 0                              /* go backwards thru line */\n   if newline.i <> srcline.i then do        /* if line changed..      */\n      msgline = newline.i                   /* hilite it ..           */\n      address ISREDIT \"LINE_AFTER  0  = MSGLINE (msgline) \"\n      end                                   /*                        */\n   else do                                  /* if line not changed    */\n      noteline = newline.i                  /* don't hilite it.       */\n      address ISREDIT \"LINE_AFTER  0  = NOTELINE (noteline) \"\n      end                                   /*                        */\n   i = i - 1                                /* get next line          */\n   end                                      /*                        */\nexit\n\n\nREPLACE_SYMBOL: procedure expose MVS_SYMBOL_NAME. MVS_SYMBOL_VALUE.\n/*--------------------------------------------------------------------*/\n/* Procedure to replace the text in a source line with the current    */\n/* symbol values substituted (if found).                              */\n/*--------------------------------------------------------------------*/\nsrc_line = arg(1)                           /* get the passed arg     */\nj = 1                                       /* point to first         */\ndo while j <= MVS_SYMBOL_NAME.0             /* loop for all symbols   */\n/*--------------------------------------------------------------------*/\n/* check to see if any of the symbols can be found in the line.       */\n/* if so - replace ALL occurences and re-contruct the line.           */\n/*--------------------------------------------------------------------*/\n   do while index(src_line,MVS_SYMBOL_NAME.j) <> 0\n      indxsym = index(src_line,MVS_SYMBOL_NAME.j)\n      lensym = length(MVS_SYMBOL_NAME.j)\n      new_line = substr(src_line,1,indxsym-1)||MVS_SYMBOL_VALUE.j\n      new_line = new_line||substr(src_line,indxsym+lensym,80-indxsym)\n      src_line = new_line\n      end                                   /*                        */\n   j = j + 1                                /* process next symbol    */\n   end                                      /*                        */\n   return src_line                          /* returned translated    */\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VTOCUTI$": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x99&o\\x00\\x99&\\x7f\\t \\x02\\xf0\\x02\\xf0\\x00\\x00\\xc6\\xc9\\xd3\\xc5\\xf4\\xf1\\xf1@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-09-23T00:00:00", "modifydate": "1999-09-24T09:20:00", "lines": 752, "newlines": 752, "modlines": 0, "user": "FILE411"}, "text": " List and Alter Format-1 DSCB Information - VTOCUTIL\n ---------------------------------------------------\n\n Installation of VTOCUTIL\n ------------------------\n\n Place the VTOCUTIL load module into an APF authorised dataset. Source\n code for the VTOCUTIL is not available.\n\n Using VTOCUTIL\n --------------\n\n VTOCUTIL lists and optionally alters information in Format-1 DSCBs for\n specified datasets. The action taken depends on the parameters passed\n to the program and the control statements read from the SYSIN DDName.\n\n VTOCUTIL uses authorized services and MUST be executed from an APF authorized\n dataset.\n\n VTOCUTIL only examines and optionally changes the VTOC for volumes with\n indexed VTOCs. Not attempt is made to access the VVDS or catalogs in any way.\n Therefore care must be taken when dealing with SMS datasets or cataloged\n datasets. Any changes to the F1-DSCB made by VTOCUTIL will NOT be reflected\n in the VVDS or catalog.\n\n If VTOCUTIL is used to change the dataset name portion of the F1-DSCB, the\n VTOC index will not reflect the change performed. To correct this, you must\n run the ICKDSF BUILDIX utility to disable and rebuild the VTOC index.\n\n\n VTOCUTIL JCL\n ------------\n\n //STEP1  EXEC PGM=VTOCUTIL,PARM='MODE=mmmm,ENQ=eeee'\n //STEPLIB  DD DISP=SHR,DSN=your.apf.library\n //SYSPRINT DD SYSOUT=*\n //VTOC     DD DISP=OLD,UNIT=uuuu,VOL=SER=vvvvvv\n //DSCBLIST DD SYSOUT=*\n //SYSIN    DD *\n   control statements.....\n /*\n\n Explanation of VTOCUTIL JCL\n ---------------------------\n\n PARM Values\n -----------\n\n     MODE=CHECK   Specifies the execution mode of VTOCUTIL.\n          UPDATE\n\n     MODE=CHECK   Indicates that no actual updates are made to the\n                  VTOC but actions that would have been successful are\n                  indicated in the Action Summary Report produced\n                  SYSPRINT DDName. This is the default value.\n\n     MODE=UPDATE  Indicates that the VTOC is updated with any\n                  successful changes produced as a result of the SYSIN\n                  cards.\n\n\n     ENQ=FAIL     Controls the serialization to the dataset during DSCB\n         WAIT     update. This parameter only applies if VTOCUTIL is\n         BYPASS   running with MODE=UPDATE.\n\n     ENQ=FAIL     Indicates that the update to the DSCB is to be failed\n                  if the dataset is in use. This is the default value.\n\n     ENQ=WAIT     Indicates that VTOCUTIL is to wait for exclusive\n                  control of the dataset before updating the DSCB.\n\n     ENQ=BYPASS   Indicates that no serialization is to be attempted\n                  for the dataset during DSCB update processing.\n\n\n DDNames Used\n ------------\n\n     SYSPRINT Will contain the Action Summary Report produced by VTOCUTIL.\n     Required DCB : RECFM=FB, LRECL=133\n\n     DSCBLIST Will contain the DSCB Listing Report produced by VTOCUTIL.\n       Required DCB : RECFM=FB, LRECL=133\n\n     VTOC  Specifies the volume serial and unit type of the DASD volume\n       whose VTOC is to be processed.\n\n     SYSIN  Control statements passed to VTOCUTIL.\n       Required DCB : RECFM=FB, LRECL=80\n\n\n Control Statements\n ------------------\n\n o Control statements can start in any column and must end before\n   column 71.\n o Continuations are NOT permitted.\n o Comments are indicated by an asterix ('*') in column 1.\n o All of the VER and REP type keywords will be applied to ALL\n   datasets that have passed the INCLUDE and EXCLUDE criteria,\n   regardless of the order in which they appear in the SYSIN\n   dataset.\n o Multiple statements of the same type are allowed.\n o The only required control statement is INCLUDE.\n\n    INCLUDE\n      Specifies the dataset name pattern that is used to decide which\n      datasets on the DASD volume are included for processing.\n\n      Syntax :\n\n      INCLUDE pattern\n\n      The 'pattern' may use the asterix ('*') to indicate a wildcard and\n      the percent sign ('%') to indicate a placeholder.\n\n      Example :\n\n      INCLUDE IBMUSER.*\n      INCLUDE SYS%.CA*.LINKLIB\n\n    EXCLUDE\n      Specifies the dataset name pattern that is used to decide which\n      datasets on the DASD volume are excluded for processing.\n\n      Syntax :\n\n      EXCLUDE pattern\n\n      The 'pattern' may use the asterix ('*') to indicate a wildcard and\n      the percent sign ('%') to indicate a placeholder.\n\n      Example :\n\n      INCLUDE IBMUSER.*\n      EXCLUDE IBMUSER.TEST.*\n\n\n    VER\n      Specifies the hexadecimal offset and values that are to be matched against\n      the contents of the Format-1 DSCB in order for the dataset to be processed\n\n      Syntax :\n\n      VER offset hexdata\n\n      Both the 'offset and 'hexdata' must only contain the EBCDIC characters\n      0 to 9 and A to F, although the 'hexdata' can be split by commas for\n      readability purposes.\n\n      Example :\n\n      VER 0052 4000\n      VER 0000 E2E8E2F1,4B,C3C1\n\n    VERBITON\n      Specifies the hex offset and bit settings that are to be matched against\n      a single byte in the Format-1 DSCB in order for the dataset to be\n      processed.\n\n      Syntax :\n\n      VERBITON offset bitmask\n\n      The verify is accepted if the bits specified by 'bitmask' are ON\n      in the DSCB.\n\n      Both the 'offset and 'bitmask' must only contain the EBCDIC characters\n      0 to 9 and A to F. The 'bitmask' must contain only the two EBCDIC\n      characters that make up a single hex byte.\n\n      Example :\n\n      VERBITON 0052 40\n\n    VERBITOFF\n      Specifies the hex offset and bit settings that are to be matched against\n      a single byte in the Format-1 DSCB in order for the dataset to be\n      processed.\n\n      Syntax :\n\n      VERBITOFF offset bitmask\n\n      The verify is accepted if the bits specified by 'bitmask' are OFF\n      in the DSCB.\n\n      Both the 'offset and 'bitmask' must only contain the EBCDIC characters\n      0 to 9 and A to F. The 'bitmask' must contain only the two EBCDIC\n      characters that make up a single hex byte.\n\n      Example :\n\n      VERBITOFF 0052 40\n\n    REP\n      Specifies the hexadecimal offset and values that are to be updated within\n      the contents of the Format-1 DSCB.\n\n      Syntax :\n\n      REP offset hexdata\n\n      Both the 'offset and 'hexdata' must only contain the EBCDIC characters\n      0 to 9 and A to F, although the 'hexdata' can be split by commas for\n      readability purposes.\n\n      Example :\n\n      REP 0052 4000\n      REP 0000 E2E8E2F1,4B,C3C1\n\n    REPBITON\n      Specifies the hex offset and bit settings that are to be turned on in\n      a single byte in the Format-1 DSCB.\n\n      Syntax :\n\n      REPBITON offset bitmask\n\n      Both the 'offset and 'bitmask' must only contain the EBCDIC characters\n      0 to 9 and A to F. The 'bitmask' must contain only the two EBCDIC\n      characters that make up a single hex byte.\n\n      Example :\n\n      REPBITON 0052 40\n\n    REPBITOFF\n      Specifies the hex offset and bit settings that are to be turned off in\n      a single byte in the Format-1 DSCB.\n\n      Syntax :\n\n      REPBITOFF offset bitmask\n\n      Both the 'offset and 'bitmask' must only contain the EBCDIC characters\n      0 to 9 and A to F. The 'bitmask' must contain only the two EBCDIC\n      characters that make up a single hex byte.\n\n      Example :\n\n      REPBITOFF 0052 40\n\n\n\n\n\n Example Uses of VTOCUTIL\n\n (a) List the F1-DSCBs for all SYS2.CA* datasets on 3390 volume OEMRES.\n\n //EX1    EXEC PGM=VTOCUTIL\n //SYSPRINT DD SYSOUT=*\n //DSCBLIST DD SYSOUT=*\n //VTOC     DD DISP=OLD,UNIT=3390,VOL=SER=OEMRES\n //SYSIN    DD *\n    INCLUDE SYS2.CA*\n /*\n\n (b) List the F1-DSCBs for all SYS2.CA* datasets on 3390 volume OEMRES that\n     have a record length of 80. Do not list SYS2.CAT.SYSIPO1 datasets.\n\n //EX2    EXEC PGM=VTOCUTIL\n //SYSPRINT DD SYSOUT=*\n //DSCBLIST DD SYSOUT=*\n //VTOC     DD DISP=OLD,UNIT=3390,VOL=SER=OEMRES\n //SYSIN    DD *\n    INCLUDE SYS2.CA*\n    EXCLUDE SYS2.CAT.SYSIPO1*\n    VER  0058 0050\n /*\n\n (c) Delete the expiration dates for all SYS2.CA* datasets on 3390 volume OEMRES\n     have fixed length records. Do not serialize the updates.\n\n //EX3    EXEC PGM=VTOCUTIL,PARM='MODE=UPDATE,ENQ=BYPASS'\n //SYSPRINT DD SYSOUT=*\n //DSCBLIST DD SYSOUT=*\n //VTOC     DD DISP=OLD,UNIT=3390,VOL=SER=OEMRES\n //SYSIN    DD *\n    INCLUDE   SYS2.CA*\n    VERBITON  0054 80\n    VERBITOFF 0054 40\n    REP       0038 0000,00\n /*\n\n (d) Convert orphaned VSAM component SYS2.VSAM.CLUSTER.DATA on 3390 volume OEMRE\n     into a sequential dataset so that it can be deleted.\n\n //EX4    EXEC PGM=VTOCUTIL,PARM='MODE=UPDATE'\n //SYSPRINT DD SYSOUT=*\n //DSCBLIST DD SYSOUT=*\n //VTOC     DD DISP=OLD,UNIT=3390,VOL=SER=OEMRES\n //SYSIN    DD *\n    INCLUDE SYS2.VSAM.CLUSTER.DATA\n    VER 0052 0008\n    REP 0052 4000\n    REP 0054 C0\n    REP 0056 0000,00\n    REP 005D 00C0\n /*\n\n (e) Rename uncataloged dataset SYS1.LINKLIB on 3390 volume OEMRES to SYS9.LINKL\n     so that it can be deleted. Do not serialize the update.\n\n //EX5    EXEC PGM=VTOCUTIL,PARM='MODE=UPDATE,ENQ=BYPASS'\n //SYSPRINT DD SYSOUT=*\n //DSCBLIST DD SYSOUT=*\n //VTOC     DD DISP=OLD,UNIT=3390,VOL=SER=OEMRES\n //SYSIN    DD *\n    INCLUDE SYS1.LINKLIB\n    REP 0000 E2E8E2F9\n /*\n\n (f) Turn off the old RACF and password bits for all IBMUSER datasets on 3390 vo\n     USRVOL.\n\n //EX6    EXEC PGM=VTOCUTIL,PARM='MODE=UPDATE'\n //SYSPRINT DD SYSOUT=*\n //DSCBLIST DD SYSOUT=*\n //VTOC     DD DISP=OLD,UNIT=3390,VOL=SER=USRVOL\n //SYSIN    DD *\n    INCLUDE   IBMUSER.*\n    REPBITOFF 005D 54\n /*\n\n Messages\n\n The following messages can be issued by VTOCUTIL and are written to\n the SYSPRINT DDName.\n\n VTZ0001E UNKNOWN KEYWORD : xxxx\n\n  Reason\n    An unknown control statement 'xxxx' was detected in the SYSIN.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Correct the control statement in error. Ensure that it is\n    one of : INCLUDE, EXCLUDE, VER, VERBITON, VERBITOFF,\n    REP, REPBITON or REPBITOFF.\n\n VTZ0002I text\n\n  Reason\n    VTOCUTIL is echoing the control statement 'text' to the Action\n    Summary Report.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0003E REQUIRED DATASET NAME PATTERN IS MISSING FROM THE (INCLUDE/EXCLUDE)\n          STATEMENT\n\n  Reason\n    An INCLUDE or EXCLUDE statement does not specify a dataset name\n    pattern.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Specify a dataset name pattern on the control statement in error.\n\n VTZ0004E DATASET NAME PATTERN IS LONGER THAN 44 CHARACTERS\n\n  Reason\n    The dataset name pattern on the INCLUDE or EXCLUDE statement is\n    greater than the maximum length allowed.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Examine the dataset name pattern and adjust as required.\n\n VTZ0005E REQUIRED OFFSET VALUE IS MISSING\n\n  Reason\n    The offset value is missing from a VER, VERBITON, VERBITOFF,\n    REP, REBITON or REPBITOFF statement.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Specify the offset on the control statement in error.\n\n VTZ0006E OFFSET VALUE IS LONGER THAN 8 CHARACTERS\n\n  Reason\n    The length of the offset value on a VER, VERBITON, VERBITOFF,\n    REP, REPBITON or REPBITOFF statement is greater than 8 characters.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Specify a shorter offset value, perhaps by removing leading\n    zeros.\n\n VTZ0007E OFFSET VALUE CONTAINS NON-HEXADECIMAL CHARACTERS\n\n  Reason\n    The offset value on a VER, VERBITON, VERBITOFF, REP, REPBITON,\n    or REPBITOFF statement contains EBCDIC characters outside of\n    the 0-9 and A-F ranges.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Examine the offset value and replace invalid characters.\n\n VTZ0008E REQUIRED HEXADECIMAL DATA IS MISSING\n\n  Reason\n    The hex data value is missing from a VER, VERBITON, VERBITOFF,\n    REP, REBITON or REPBITOFF statement.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Specify the hex data on the control statement in error.\n\n VTZ0009E INVALID HEXADECIMAL DATA\n\n  Reason\n    (a) The hex data on a VER, VERBITON, VERBITOFF, REP, REPBITON,\n    or REPBITOFF statement contains EBCDIC characters outside of\n    the 0-9 and A-F ranges.\n\n    (b) The length of the hex data on a VERBITON, VERBITOFF,\n    REPBITON or REPBITOFF is greater than 2 EBCDIC characters.\n    Bit masks must only represent one hexadecimal byte.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Re-specify the hex data on the control statement in error.\n\n VTZ0010E OFFSET VALUE SPECIFIES AREA OUTSIDE OF THE DSCB\n\n  Reason\n    The offset value is greater than the size of the DSCB.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Check that you have used the hexadecimal offset value and\n    not a decimal value.\n\n VTZ0011E OFFSET VALUE PLUS THE LENGTH OF THE HEXADECIMAL DATA IS OUTSIDE\n          OF THE DSCB\n\n  Reason\n    If the current statement was executed, the data to be verified\n    or replaced would be outside of the DSCB.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Check that you have used the hexadecimal offset value and\n    not a decimal value.\n\n VTZ0012W THE REP STATEMENT WILL CHANGE THE DATASET NAME - THE VTOC INDEX\n          WILL HAVE TO BE REBUILT\n\n  Reason\n    The REP statement replaces data in the first 44 bytes of the DSCB.\n    This will change the dataset name and cause the VTOC index to be out\n    of step with the VTOC.\n\n  Action Taken by VTOCUTIL\n    Condition code 4 is set and the next card processed.\n\n  User Action Required\n    After the completion of the VTOCUTIL JCL, run the ICKDSF BUILDIX utility to\n    disable (OSVTOC) and rebuild (IXVTOC) the VTOC index.\n\n\n\n VTZ0020E VTOC DD STATEMENT MISSING\n\n  Reason\n    VTOCUTIL could not find the required VTOC DD Statement in the\n    JCL.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Add the VTOC DD Statement in the JCL to point to the DASD\n    volume you wish to process.\n\n VTZ0021E INDEXED VTOC NOT ACTIVE ON VOLUME vvvvvv\n\n  Reason\n    VTOCUTIL has determined that an indexed VTOC is not present\n    on the DASD volume 'vvvvvv'\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Create an indexed VTOC and re-run the job.\n\n VTZ0022E ERROR DURING CVAF SERVICE sssssss RC(cc) CVSTAT(vv)\n\n  Reason\n    VTOCUTIL encountered a non-zero return code from CVAF\n    service 'sssssss'. The return code from the CVAF service\n    is 'cc' and the hex value of the CVSTAT field is 'vv'.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Refer to DFSMS/dfp Diagnosis Reference to determine the\n    reason for the failure.\n\n VTZ0023E VERIFY REJECTED AT OFFSET oooo CURRENT DATA IS xxxx\n\n  Reason\n    The data is the DSCB at offset 'oooo' does not match the\n    data on the VER, VERBITON or VERBITOFF statement.\n\n  Action Taken by VTOCUTIL\n    The current data is listed in 'xxxx'. Condition code 8 is\n    set and the next DSCB is processed.\n\n  User Action Required\n    Examine the existing data contents and verify that the VER,\n    VERBITON or VERBITOFF statements are correct.\n\n VTZ0024I FORMAT-1 DSCB SUCCESSFULLY CHANGED FOR DATASET dsn\n\n  Reason\n    VTOCUTIL has successfully updated the DSCB for dataset 'dsn'.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0025I VERIFY ACCEPTED AT OFFSET oooo\n\n  Reason\n    The data is the DSCB at offset 'oooo' matches the\n    data on the VER, VERBITON or VERBITOFF statement.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0026I OLD DATA AT OFFSET oooo WAS xxxx\n\n  Reason\n    Informational message listing the DSCB contents prior to\n    the REP, REPBITON or REPBITOFF action.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0027I NEW DATA AT OFFSET oooo IS xxxx\n\n  Reason\n    Informational message listing the DSCB contents after\n    the REP, REPBITON or REPBITOFF action.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0028I PROCESSING DATASET dsn\n\n  Reason\n    VTOCUTIL is now processing the DSCB for dataset 'dsn'.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0029I NO REP STATEMENTS FOUND. FORMAT-1 DSCB NOT CHANGED FOR DATASET dsn\n\n  Reason\n    There are not any REP, REPBITON or REPBITOFF statements within\n    the SYSIN control statements. VTOCUTIL can therefore only\n    list DSCB information and verify data within it.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0030W VERIFY REJECT DETECTED. FORMAT-1 DSCB NOT CHANGED FOR DATASET dsn\n\n  Reason\n    One or more of the VER, VERBITON or VERBITOFF statements has\n    been rejected for dataset 'dsn'.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    Examine the Action Summary Report for VTZ0023E messages.\n\n VTZ0031W VTOC NOT UPDATED. VTOCUTIL IS RUNNING IN CHECK MODE\n\n  Reason\n    All of the VER, VERBITON and VERBITOFF statements have been\n    accepted, but the DSCB will not be updated as VTOCUTIL is\n    not running with the MODE=UPDATE parameter.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    To apply the updates to the DSCB, re-run the job with the\n    MODE=UPDATE parameter.\n\n VTZ0032E INVALID PARAMETERS PASSED TO VTOCUTIL\n\n  Reason\n    VTOCUTIL did not understand the parameters passed to it.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Check the synatx of the MODE= and ENQ= parameters passed\n    to VTOCUTIL.\n\n VTZ0033I SYSDSN ENQUEUES ARE BEING (ISSUED/TESTED/BYPASSED)\n\n  Reason\n    Informational message listing how VTOCUTIL handles SYSDSN\n    Enqueues during DSCB update processing.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0034I VTOC CHANGES ARE BEING PROCESSED IN (CHECK/UPDATE) MODE\n\n  Reason\n    Informational message listing the current mode of operation.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0035W NO DATASETS PASSED THE INCLUDE AND EXCLUDE CRITERIA\n\n  Reason\n    There are not any datasets on the DASD volume that match the\n    INCLUDE and EXCLUDE patterns.\n\n  Action Taken by VTOCUTIL\n    Condition code 4 is set and processing terminated.\n\n  User Action Required\n    Re-specify the INCLUDE and/or EXCLUDE statements.\n\n VTZ0036W NO FORMAT-1 DSCB UPDATES APPLIED TO ANY DATASET\n\n  Reason\n    There have not been any DSCB updates applied or simulated\n    during this execution of VTOCUTIL.\n\n  Action Taken by VTOCUTIL\n    Condition code 4 is set and processing terminated.\n\n  User Action Required\n    Examine the Action Summary Report.\n\n VTZ0037E SYSDSN ENQUEUE FAILED. FORMAT-1 DSCB NOT CHANGED FOR DATASET dsn\n\n  Reason\n    VTOCUTIL discovered that dataset 'dsn' was being used by another\n    task when a DSCB update was attempted.\n\n  Action Taken by VTOCUTIL\n    Condition code 8 is set and the DSCB update is NOT applied.\n    VTOCUTIL will continue processing the next dataset.\n\n  User Action Required\n    Consider using the ENQ=BYPASS parameter.\n\n VTZ0038E VTOCUTIL IS NOT APF AUTHORIZED\n\n  Reason\n    VTOCUTIL is not being executed from an APF authorized\n    library.\n\n  Action Taken by VTOCUTIL\n    Condition code 12 is set and processing terminated.\n\n  User Action Required\n    Place the VTOCUTIL is an APF authorized library and\n    re-run the job.\n\n VTZ0040I FUNCTION COMPLETED. CONDITION CODE WAS cc\n\n  Reason\n    The current action completed with condition code 'cc'.\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n VTZ0049I VTOCUTIL PROCESSING COMPLETE. MAXIMUM CONDITION CODE WAS cc\n\n  Reason\n    VTOCUTIL has finished all processing. The maximum condition code\n    encountered was 'cc'\n\n  Action Taken by VTOCUTIL\n    None - informational message to user.\n\n  User Action Required\n    None.\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT411/FILE411.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT411", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}