{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012316000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2351440, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 13, "INMDSNAM": "CBT.V500.FILE542.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2351440, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2351440, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE542.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00%\\t'", "DS1TRBAL": "b'P|'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x00\\x00\\x03\\x04\\x02\\x00\\n\\x00&'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x008\\x01\\x185?\\x01\\x185?\\x14\\x19\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2018-12-19T00:00:00", "modifydate": "2018-12-19T14:19:38", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  542\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE542\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 44 MEMBERS COUNTED; CUMULATIVE SIZE IS 21,510 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/19/18    14:19:38    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$INDEX": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x130?\\x01\\x130?\\x15I\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc1`\\xc7\\xd9\\xc1\\xe8@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2013-10-30T00:00:00", "modifydate": "2013-10-30T15:49:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "A-GRAY"}, "text": "Member   Description\n-------- -----------\n$$$#DATE ** Unknown\n$$$INDEX This member - generated by MAKEINDX\n$$$NOTE  ** Unknown\n$$$NOTE1 ** Unknown\n$$README Contains the overview for this PDS\n#DELDUP  EDIT Macro to remove duplicate lines\n#DELNDUP EDIT Macro to remove non duplicate lines\n@FILE542 ** Unknown\nALICOUN$ EXECUTE ALIAS COUNTING ROUTINE\nALICOUNT Count datasets for each alias in the system\nALIMAKE  Generate ALIAS DEFs based on catalog contents\nALIMAKE$ EXECUTE ALIMAKE DEF ALIAS CREATION PROCEDURE\nBODGECAT Get a LISTDS on an uncataloged dataset\nCSICODE  Minimum clean CSI utilisation code\nCSICODE$ CSI EXECUTION SAMPLE\nCSICODEO Minimum clean CSI utilisation code - old version\nCSICODEV VSAM detail from the CSI - LISTCATalike\nCSITAPE$ CSI TAPE DATASET EXTRACTION JCL\nCSITAPES Stripped CSICODE just for Tape datasets\nDDSCAN   Scan a selected DDNAME in JCL for a member\nHFSSTAT  Get size/space stats for an HFS file\nMAKEINDX Create a $$$INDEX from standardised comments\nRCNVTCA$ EXECUTE RCNVTCAT CATALOG CONVERSION PROCEDURE\nRCNVTCAT MCNVTCAT replacement in REXX\nRDA      SDSF DA 'replacement' code\nRINIT    SDSF INIT 'replacement' code\nSPACE    DASD pool utilisation\nSYSINF   Displays sundry IPL info. etc.\nTABLSTAT Add ISPF stats to all ISPF tables in a PDS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$$NOTE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x03\\x01\\x02\\x01\\x0f\\x01\\x130?\\x15G\\x00)\\x00)\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-01-10T00:00:00", "modifydate": "2013-10-30T15:47:03", "lines": 41, "newlines": 41, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: CSI and MCATCNVT\nDate: Thu, 10 Jan 2002 15:26:43 +0100\nFrom: \"Gray, Alastair\" <Alastair.Gray@pmi.com>\nTo: \"'sbgolob@attglobal.net'\" <sbgolob@attglobal.net>\n\nHi Sam,\n\nAfter the exchange on IBM-MAIN earlier in the week, I thought I'd\npolish these bits of code up and submit them to the CBT. I hope\nthey may be of use.\n\nThe xmitted file contains :\n\nALICOUNT - A REXX alias counter for finding our how many datasets\nare using each alias.\n\nRCNVTCAT - A REXX MCNVTCAT replacement which 'should' produce\nidentical output (more or less).\n\nMAKEINDX - A REXX to generate an index for code libraries from\nstandard comments (added because I used it on the library I've\nsent).\n\nSupporting JCL for the two CSI functions is also included.\n\nI have a significant amount of 'handy' REXX code (for sysprogs\nand others) that I hope to tidy a little bit more over the coming\nmonths this submission may then increase in size if it seems of\nuse.  (I do have a number of other MCAT related functions,\ncurrently they are rather site specific but 'may' get picked up\nas a part of my general tidy).\n\nRegards,\n\nAlastair Gray\nPhilip Morris ITSC Europe\nConsultant Systems Programmer\ne-mail : Alastair.Gray@eu.altria.com\ntel : +41 (0)21 618 7690\nfax : +41 (0)21 618 4618\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE01": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00U\\x01\\x02(\\x1f\\x01\\x130?\\x15E\\x00\\x15\\x00\\x15\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-10-08T00:00:00", "modifydate": "2013-10-30T15:45:55", "lines": 21, "newlines": 21, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:      CBT File542 - update\n   Date:      Tue, 8 Oct 2002 10:11:10 +0200\n   From:      \"Gray, Alastair\" <Alastair.Gray@pmi.com>\n     To:      'Sam Golob' <sbgolob@attglobal.net>\n\nHi Sam,\n\nAnother update, this one adds CSICODEV. Plus some re-working of\nall of the other CSI members as a result of work on CSICODEV and\nsome corrections to RCNVTCAT (thanks to a handy guinea pig !).\n\nRegards,\n\nAlastair\n\nAlastair Gray\ne-mail : gray.alistair@pmintl.ch\ntel : +41 (0)21 618 7690\nfax : +41 (0)21 618 4618\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE02": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x003\\x01\\x11%\\x1f\\x01\\x11%\\x1f\\x11'\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2011-09-08T00:00:00", "modifydate": "2011-09-08T11:27:33", "lines": 22, "newlines": 22, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  Updated contact details\nFrom:     \"Gray, Alastair\" <Alastair.Gray@pmi.com>\nDate:     Tue, 6 Sep 2011 15:15:34 +0200\nTo:       <sbgolob@cbttape.org>\n\nHi Sam,\n\nAs per our phone conversation, I'm now been 'off' the mainframe\nfor a few years, having moved into the SAN and storage area.\n\nHowever I'm still available to try and help with any queries that\nmay be raised against my code.\n\nMy updated contact details for the CBT are :\n\nalastair.gray@pmi.com\n+41 58 242 7690\n\nNice to speak to you and keep up the good work.\n\nRegards,\nAlastair\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE03": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x13\\x01\\x16#o\\x01\\x16#o\\x01Q\\x00b\\x00b\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-08-23T00:00:00", "modifydate": "2016-08-23T01:51:13", "lines": 98, "newlines": 98, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  RCNVTCAT - phase 1 complete.\nFrom:     John McKown <john.archie.mckown@gmail.com>\nDate:     8/21/2016 3:27 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nWhat I am calling \"phase 1\" of making RCNVTCAT work is complete.\nBasically what the changes allow is for the REXX program to be\ncopied into a UNIX file; marked as executabe; then run as a\nnormal UNIX command. E.g at a UNIX command prompt enter:\n\nrcnvtcat mvsuser.usercat\n\nTranscript ===\n\nrcnvtcat mvsuser.usercat\nRCNVTCAT Report DSN: JOARMC.RCNVTCAT.REPORT.T5369\n**(csi)***** Fullword processing selected\n**(csi)***** Fullword processing selected\n**(cat)** Processing CATALOG    MVSUSER.USERCAT\n**(csi)***** Fullword processing selected\n**(csi)***** Fullword processing selected\n**(csi)***** Fullword processing selected\n**(csi)***** Fullword processing selected\n**(cat)** Processing CATALOG    MVSUSER.USERCAT\n**(csi)***** Fullword processing selected\n**(cat)** Processing CATALOG    MVSUSER.USERCAT\n**(csi)***** Fullword processing selected\n?=== Transcript ends?\n\nAs you can see, the output is still in a PDS. The program\n__cannot__ be run from a PDS via the \"tsocmd\" UNIX command. It\nstill thinks that is a TSO in batch command which requires that\nthe output PDS be pre-allocated to the DD name REPORT. If you\ntry, it looks like:\n\nTranscript ===\n\ntsocmd \"ex 'joarmc.rexx.exec(rcnvtcat)'  'mvsuser.usercat'\"\nex 'joarmc.rexx.exec(rcnvtcat)'  'mvsuser.usercat'\n**(Error-1)* For execution in batch, please ensure that a PDS\n**(Error-2)* is pre-allocated to DD name REPORT.\n=== Transcript ends?\n\nI don't know if this is what is wanted or not.  The changed\nRCNVTCAT can still be used as it is currently being used with\nidentical results. That it, it can be run from TSO READY, TSO\nISPF, or via TSO in batch. In addition, it could be run in batch\nvia the BPXBATCH command, but I don't see any reason to do this\ninstead of TSO in batch.\n\nThere are more changes possible, which I will list.\nThese might be introduced in another member, which I will\n  call SCNVTCAT.\n\n1) Replace all the TSO ALLOCATE commands with the\n   equivalent BPXWDYN() calls.  This would allow two\n   things: execution in TSO batch without pre-allocation\n   of the REPORT DD statement and execution under UNIX via\n   the \"tsocmd\" command shown in the second transcript.\n   Actually, these are the same thing since use of the\n   \"tsocmd\" is identical to running TSO in batch with\n   SYSTSIN and SYSTSPRT basically being the user's\n   terminal.  This will also allow the elimination of some\n   \"dual path\" code which uses TSO ALLOCATE in TSO and\n   BPXWDYN() in non-TSO (not that the current version even\n   works correctly in non-TSO).\n\n2) Allow the output files from the command to be placed\n   in a new \"random\" UNIX subdirectory or in a specified\n   UNIX subdirectory regardless of execution environment.\n   This is meant to make the command more useful for UNIX\n   shell users. I don't know why I would want a UNIX\n   command to put its results in a z/OS legacy PDS where\n   it would be difficult to use in UNIX.\n\n3) Eliminate unnecessary code, such as the SWA chain\n   scanning logic which is still in the program but never\n   used.\n\nI would prefer to do all three. In the case of #2, an implied\nchange would be that the default output of the command would be a\n\"random\" PDS if invoked in TSO (interactive or batch) but a\n\"random\" UNIX subdirectory if invoked by a UNIX shell\n(interactive or batch = BPXBATCH or equivalent). I would allow\nspecification of the desired output location via a parameter.\nSomething like (in UNIX):\n\nrcnvtcat mvsuser.usercat # output to \"random\" __NEW__ subdirectory.\nrcnvtcat mvsuser.usercat -o specific.UNIX.directory\nrcnvtcat mvsuser.usercat -o //some.PDS.name # use existing, create new\nrcnvtcat mvsuser.usercat -o // # generate a random new PDS name,\nlike present\n\nUse of the // after the -o for a z/OS data set name is fairly\nstandard for z/OS UNIX commands which support z/OS data sets as\ninput or output. I extended this a bit to have a plain // with no\nDSN mean \"generate a DSN\".\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE04": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x11\\x01\\x16%\\x1f\\x01\\x16%\\x1f\\x01E\\x00_\\x00_\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-07T00:00:00", "modifydate": "2016-09-07T01:45:11", "lines": 95, "newlines": 95, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  RCNVTCAT UNIX implementation complete.\nFrom:     John McKown <john.archie.mckown@gmail.com>\nDate:     9/6/2016 5:16 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nWell, I think that I've done as much as I'm likely to on this for\nthe present.  There are a lot of interface and code changes.  I\nhave greatly increased the text written for the \"help\" option.\nI've also done some minor restructuring of the code in addition\nto a lot of additions. The basic functioning is completely\nbackward compatible.  That is, if you run the new RCNVTCAT with\nthe same options that you have in the past, you get (or should\nget) identical results.  The main changes are the additions to\nallow use as a UNIX command.  To use it as a UNIX command, the\ncode must be copied into a UNIX file and marked as executable.\nCommands such as the following:\n\ncd /directory/on/PATH\ncp \"//pds.exec(rcnvtcat)\" rcnvtcat\nchmod 755 rcnvtcat\n\nOne difference on running under UNIX is that the output which was\ncreated as members in the output PDS is placed, by default, as\nfiles in the current working directory. The names of the files\nare the same as the names of the PDS members, but with a suffix\nof \".txt\" appended.\n\nHelp can be displayed in TSO or UNIX by simply running the\nprogram with an argument of \"?\". E.g.\n\nrcnvtcat ?\n\nOne \"gotcha\" for the non-UNIX aware is that in UNIX a single ?\nwill cause the shell to match all files in the current directory\nand replace the \"?\" with that list of file names. So, under UNIX,\none should use somthing like:\n\nrcnvtcat \\?\n\nOr, even better, is to abandon the historic use of ? as a \"help\"\nargument, and use a simple -h. That is:\n\nrcnvtcat -h\n\nwhich works correctly under both TSO and UNIX.\n\nThe biggest interface change is the addition of 6 variant\narguments which allow the specification of where to put the\noutput. There are two \"TSO inspired\" variants and four \"UNIX\ninspired\" variants. The \"TSO inspired\" variants are:\nOUTPUT(location) and OUTPUT=location\n\nThe \"UNIX inspired\" variants are:\n-olocation\n-o location\n-Olocation\n-O location\n<I know, UNIX is weird. Or maybe it's me.>\n\nIf an OUTPUT option is not used, then the program will first try\nto put its output into the PDS defined via the REPORT DD, just as\nat present. If the REPORT DD does not exist, then when under TSO,\nthe output goes into a \"generated\" PDS name as at present. But\nunder UNIX, it goes into the current working directory.\n\nIn the above, \"location\" is either a PDS (existing or not) or an\nexisting UNIX directory. The program determines which it is via\nthe following rule:\n\nIt the \"location\" starts with a . (period), ~ (tilde) or /\n(slash), then it is a UNIX directory, otherwise it is assumed to\nbe a DSN. If it is a DSN, the program processes it as most TSO\ncommand do. That is, if if is not enclosed in ' marks, then the\nstandard TSO prefix from the PROFILE is applied. The UNIX forms\nof the location are the normal UNIX usage. That is, a period is\nrelative to the current working directory (which is the HOME\ndirectory in TSO). A slash is an absolute path specification. A\ntilde means relative to the HOME directory, as is implemented in\nmost UNIX shells. For those unused to UNIX, this means that \"~/\"\nwould mean \"relative to _my_ UNIX HOME directory\" and \"~someid/\"\nwould be \"relative to <someid>'s UNIX HOME directory\". Note that\nalthough the command will create a PDS dynamically, any UNIX\ndirectory specified must already exist. And, of course, in either\ncase, the user must have the appropriate authorities to possibly\ncreate (non-existent PDS) & update (existing PDS or UNIX\ndirectory) the \"location\".\n\n--\nUnix: Some say the learning curve is steep, but you only have to\nclimb it once. -- Karl Lehenbauer\n\nUnicode: http://xkcd.com/1726/\n\nJohn McKown\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE05": {"ttr": 532, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x16(\\x0f\\x01\\x16(\\x0f\\x19B\\x00 \\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-06T00:00:00", "modifydate": "2016-10-06T19:42:06", "lines": 32, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  RCNVTCAT Catalog Compare Feature bug\nFrom:     \"Tom Taylor\" <tomtaylo@us.ibm.com>\nDate:     10/6/2016 3:08 PM\nTo:       sbgolob@cbttape.org, sknutson@cbttape.org,\n          a_j_gray@hotmail.com\n\nHi All\n\nI found a bug in file # 542\nie  RCNVTCAT...using the catalog compare feature\n\ncsicatnm = Substr(cat.1,1,44)          /* clear catalog name         */\n\nshould be\n\ncsicatnm = Substr(cat,1,44)          /* clear catalog name           */\n\nCorrect me if I'm wrong\n\nThanks...... Tom\n\nTom Taylor\nZ/os Systems Programming Support\nIntegrated Technology Delivery\nIBM Global Services\nPhone:     732-752-7787\nCell:      732-754-2031\nE-mail:    tomtaylo@us.ibm.com\nTie line:  938-7807\n\nNote from S.Golob:  changed in SCNVTCAT as well.....\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE06": {"ttr": 534, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x17\\x01\\x185?\\x01\\x185?\\x14\\x18\\x01\\x0e\\x00X\\x00\\x00\\xd7\\xc1\\xe5\\xd3\\xc9\\xd2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2018-12-19T00:00:00", "modifydate": "2018-12-19T14:18:17", "lines": 270, "newlines": 88, "modlines": 0, "user": "PAVLIK"}, "text": "Subject:  CBT Tape file 542 SWAREQ correction suggestion -\n          and - Thanks\nFrom:     \"George.Pavlik@harlandclarke.com\"\n          <George.Pavlik@harlandclarke.com>\nDate:     12/19/2018, 12:46 PM\nTo:       \"sbgolob@cbttape.org\" <sbgolob@cbttape.org>,\n          \"sknutson@cbttape.org\" <sknutson@cbttape.org>\n\nHi Sam G., and Sam K.,\n\nI wanted to first thank you both for your work on the CBT tape\nover the many years it was been around. \u00a0 I know the support you\nprovided, was or is not your primary job role, but have\nappreciated the articles and source or techniques over the years\n(I can remember back to around the late 1980's, anyway).\n\nHey, I just wanted to let you know I was in my current account\nand the prior Sysprog implemented a one-off of some source of\nFILE 542 on the CBT tape. I wanted to make sure you all were\naware so you could place a copy of the SWAREQ22 source located in\nFILE 183 also in FILE 542. \u00a0 The CSICODE Rexx code on FILE 542\nalso uses SWAREQ, and I am just trying to help anyone else that\nmay be using this source and has not migrated it to the SWAREQ22\nversion.\n\nBelow is some history on how I stumbled upon this, and I also\nprovided a shout out to Mark Zelden, who directed me to FILE\n183. \u00a0 I found the SWAREQ22 source last updated by Sam G.\nThanks (and thanks for documenting it to make it easy to\nfollow), and modified it to work with the CSICODE implemented by\nthe previous Sysprog.\n\nLet me know if you have any questions. The block of source I\nimplemented is below the History area.\n\nMerry Christmas, and safe holidays.\nRegards,\nGeorge Pavlik\n\nInfrastructure Systems Engineer IV\nHarland Clarke Holdings\n15955 La Cantera Parkway | San Antonio, TX 78256\nOffice: 210.694-1123 | Mobile: 210.385-2745\nGeorge.Pavlik@harlandclarke.com\n\nHistory\n\nBrief summary of my exchange with Mark Z. around 11/20/2018\n\nWell back in 2003-2004 time frame a previous sysprog implemented\nsomething at this shop related to Catalog Search Interface tool.\nAfter doing some digging, I realize the code they implemented was\nfrom the CBT tape file 542 called CSICODE. \u00a0Well this code\nrecently broke and it is related to the SWAREQ subroutine in the\nCSICODE Rexx routine.\n\nSo, I've been at this shop about 2 years, and our current lead\nzOS sysprog just migrated us from zOS 2.1 to zOS 2.3.\u00a0 The batch\njob process utilizing this code broke, and after reviewing the\nmany Rexx routines involved, I narrowed the issue down to how\nthis routine was generating the address return via the SWAREQ\nsubroutine (basically relating to the SWA address).  After\nconsulting with IBM they confirmed the SWA references were move\nabove the BAR in zOS 2.2. Thus, I have a confirmation on the\nissue.\n\nBTW, thanks for the tip on CBT file 183, I actually found a\nwork-around in the PDS, member SWAREQ22, reviewed and updated to\nwork with zOS 2.2 and above.\u00a0 So, it is good to know I was not\nthe first to hit this issue. I had to re-work the SWAREQ22\nroutine to fit the CSICODE in file 542 (still a work in progress\nfor our invocation).\u00a0 When I am done, I'll send my changes to\nSam and let him make them better.\n\nSource Subroutine I implemented in HCHC CSICODE2 (aka CSICODE)\n\n**note** previous sysprog took CSICODE, and split it up to be a\nCSICODE1 and CSICODE2 routines at our company.\u00c2\u00a0 Of cource none\nof it was documented, thus debugging can be tedious, given the\nonly comments were those of the original Author, Alastair Gray.\n\nBelow, is the section I implemented.  I am sure you Sam G. can\nmake it better to fit within the member CSICODE, or, simply just\nplace a copy of SWAREQ22 routine on FILE 183 in this CBT file,\n542, and advise others to review, change, and use as they see\nfit.\n\n\n/**********************************************************************/\n/* Notes about this exec:     FILE542.PDS(CSICODE)                    */\n/* -Added by G.Pavlik, Nov. 21, 2018                                  */\n/* -This code is the second part of CSICODE1 located in this PDS      */\n/*  (P.SY.DR.EXEC). The original exec, as noted in CSICODE1, was      */\n/*  taken from CBT FILE542. Some comments have been included below    */\n/*  in order to provide some history as to where this source was      */\n/*  taken from, who wrote it, and what updates have been made.        */\n/*  -Comments from original author - originally written circa 2004    */\n/*    CSICODE : Uses Catalog Search Interface (CSI)                   */\n/*    Author : Alastair Gray - a_j_gray@hotmail.com                   */\n/*             (or the e-mail I use to post on TSO-REXX/IBM-MAIN)     */\n/*    This was an extension of previous work that was initially       */\n/*    derived from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'         */\n/*                                                                    */\n/* HCHC Comment Block:                                                */\n/* -------------------                                                */\n/* Purpose: This section of code does several things. It negotiates   */\n/*          the zOS control blocks to obtain the current DDName and   */\n/*          DSNs associated to the DDName so that it can dynamically  */\n/*          allocate them in order to populate them, or place members */\n/*          in them in the case of a PDS - members ERROR, REPORT,     */\n/*          with the information obtained via a call to a IBM module  */\n/*          called IGGCSI00 (catalog search - see DFSMS Managing      */\n/*          Catalogs manual for info).                                */\n/*                                                                    */\n/*          Thus, once the proper CATALOG and LEVEL information has   */\n/*          been entered (in this case, resides in a different        */\n/*          member), the CSI parameter list is built, the call made   */\n/*          and the data returned, analyzed, and populated into the   */\n/*          appropriate file.                                         */\n/*                                                                    */\n/* Special Notes:                                                     */\n/* --------------                                                     */\n/*         This code was altered in Nov. 2018 because the batch job   */\n/*         PSYSBK03 abended with a:                                   */\n/*          IEC141I 013-18,IGG0191B,PSYSBK03,RUNEXEC2,INPUT,A670,     */\n/*                         PPR05E,P.SY.DR.CLK2.REPORT(REPORT)         */\n/*         After some analysis by me, G.Pavlik, I was able to         */\n/*         determine the issue was in this code, specfically in the   */\n/*         SWAREQ subroutine. The routine no longer worked, because   */\n/*         when HCHC upgraded from zOS 2.1 to zOS 2.3, IBM had moved  */\n/*         the SWA, and SVA (SWA virtual Address) to above the BAR    */\n/*         (a 2GB line in storage). Reviewing Data Area manuals       */\n/*         confirmed the routine would need to be reworked. On a      */\n/*         chance this may have already been corrected, I downloaded  */\n/*         the CBT FILE542, it has not been updated, and so I pinged  */\n/*         Mark Zelden, and Sam Golob who have written many articles  */\n/*         and items for CBT. Mark pointed me to FILE 183, which had  */\n/*         contained a revised SWAREQ22 written by Don Poitras of the */\n/*         SAS institute. The version enabled below had to be         */\n/*         modified to work with this CSICODE (CSICODE2)              */\n/*         implementation.                                            */\n/* Update Activity:                                                   */\n/* ----------------                                                   */\n/* 11-21-18 GEOP-Added \"Notes about this exec\", \"HCHC Comment Block\", */\n/*               \"Special Notes\", \"Tracing\", and this area,           */\n/*               \"Update Activity\".                                   */\n/*              -Replaced (commented) original SWAREQ routine written */\n/*               circa 2004, with a version obtained from CBT FILE    */\n/*               183 written circa Nov.2015, and then modified the    */\n/*               routine to work with the original CSICODE.           */\n/*               -Note, to enable tracing, you must enable in this    */\n/*                     code, and CSICODE1.                            */\n/*               I added to the original comments from the new        */\n/*               FILE 183 routine.                                    */\n/*              -Changes to the replaced SWAREQ routine are indicated */\n/*               via the 'v01' or 'v02' off to the right.             */\n\nCSICODE stuff\n\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\n/* begin comment block ...\n\\*--------------------------------------------------------------------*/\n|* MODULE NAME = SWAREQ                                               *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Convert an SVA to a 31-bit address              *|\n|*                                                                    *|\n|* STATUS = R200                                                      *|\n|*                                                                    *|\n|* FUNCTION = The SWAREQ function simulates the SWAREQ macro to       *|\n|*            convert an SWA Virtual Address (SVA) to a full 31-bit   *|\n|*            address which can be used to access SWA control blocks  *|\n|*            in the SWA=ABOVE environment.  The input is a 3-byte    *|\n|*            SVA; the output value is a 10-digit decimal number.     *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour <gsf@pobox.com>                    *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                                                                    *|\n|* SYNTAX   =  SWAREQ(sva)                                            *|\n|*                                                                    *|\n|*             sva must contain a 3-byte SVA.                         *|\n|*                                                                    *|\n|* ****************************************************************** *|\n|* Update Activity (HCHC):                                            *|\n|* -----------------------                                            *|\n|* 11-20-18 GEOP -Routine take from CBT file 183 member SWAREA22 and  *|\n|*                modified to work within this CSICODE2 member. My    *|\n|*                changes identified by V01 or V02 in this section.   *|\n|*                The SWAREQ22 routine was modified to handle the     *|\n|*                change introduced by IBM to move the SWA above      *|\n|*                the BAR.                                            *|\n|*                                                                    *|\n|* ****************************************************************** *|\n|* Sample Invocation: SWA=BELOW -below line, above line, not above BAR*|\n|*                                                                    *|\n|*    NUMERIC DIGITS 10                                               *|\n|*    tcb = C2D(STORAGE(21C,4))         /* TCB          PSATOLD  */   *|\n|*    tiot= C2D(STORAGE(D2X(tcb+12),4)) /* TIOT         TCBTIO   */   *|\n|*    sva = STORAGE(D2X(tiot+36),3)     /* First JFCB   TIOEJFCB */   *|\n|*    jfcb=SWAREQ(sva)             /* convert SVA to 31-bit addr */   *|\n|*    dsn=STORAGE(D2X(jfcb),44)         /* dsname       JFCBDSNM */   *|\n|*    vol=STORAGE(D2X(jfcb+118),6)      /* volser       JFCBVOLS */   *|\n|*    SAY 'sva='C2X(sva) 'jfcb='D2X(jfcb) 'dsn='dsn 'vol='vol         *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\n/*SWAREQ: PROCEDURE */\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\n /*Digits()                      tracing 2 see current Digit value v02*/\nNUMERIC DIGITS 20                           /* allow up to 2**64      */\nsva=C2D(ARG(1))                             /* convert to decimal     */\ntcb = C2D(STORAGE(21C,4))                   /* TCB         PSATOLD    */\njscb = C2D(STORAGE(D2X(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2D(STORAGE(D2X(jscb+244),4))        /* QMPL        JSCBQMPI   */\n/**********************************************************************/\n/* See if qmat can be above the bar                                   */\n/**********************************************************************/\nqmsta= C2X(STORAGE(D2X(qmpl+16),1))         /* JOB STATUS BYTE        */\nIf Substr(X2B(qmsta),6,1) Then              /* is QMQMAT64 bit on?    */\nDo                                          /* yes, qmat can be ATB   */\n  If Right(X2B(C2X(ARG(1))),1) \\= '1' Then  /* SWA=BELOW ?            */\n    Return D2C(C2D(ARG(1))+16)              /* yes, return sva+16  v02*/\n  /*RETURN C2D(ARG(1))+16                      yes, return sva+16  v01*/\n  qmat=C2D(STORAGE(D2X(qmpl+10),2))*(2**48) +, /* QMAT+0  QMADD01     */\n       C2D(STORAGE(D2X(qmpl+18),2))*(2**32) +, /* QMAT+2  QMADD23     */\n       C2D(STORAGE(D2X(qmpl+24),4))            /* QMAT+4  QMADD       */\n  Return D2C(C2D(STORAGE(D2X(qmat+(sva*12)+64),4))+16)\n  /*RETURN C2D(STORAGE(D2X(qmat+(sva*12)+64),4))+16                v01*/\nEnd\nElse\nDo                                          /* no, qmat is BTB        */\n  If Right(C2X(ARG(1)),1) \\= 'F' Then       /* SWA=BELOW ?            */\n    Return D2C(C2D(ARG(1))+16)              /* yes, return sva+16  v02*/\n  /*RETURN C2D(ARG(1))+16                      yes, return sva+16  v01*/\n  qmat = C2D(STORAGE(D2X(qmpl+24),4))       /* QMAT       QMADD       */\n  Do While sva>65536\n    qmat = C2D(STORAGE(D2X(qmat+12),4))     /* next QMAT  QMAT+12     */\n    sva=sva-65536                           /* 010006F -> 000006F     */\n  End\n /* ***************************************************************** */\n /* 11-19-18 Moved RETURN to below area to make function follow    v02*/\n /*          expected exec routine coding and calling guidelines.  v02*/\n /* RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16                      v01*/\nEnd\nReturn D2C(C2D(STORAGE(D2X(qmat+sva+1),4))+16)  /* return address  v02*/\n/* RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16                       v02*/\n/* ****************************************************************** */\n/* 11-20-2018                                                         */\n/* Old SWAREQ routine below ... (original CSICODE2)                   */\n/* Below routine works for SWA=BELOW, or, zOS 2.1 and lower where     */\n/* SWA reside below the BAR, and/or below the line, above the line.   */\n/* ****************************************************************** */\n/* SWAREQ:                                     SWAREQ Procedure     ::*/\n/* Digits()                          tracing 2 see current Digit value*/\n/* If (Right(C2x(Arg(1)),1) \\= 'F') Then       SWA=BELOW ?            */\n/*  Return D2c(C2d(Arg(1))+16)                 yes, return sva+16     */\n/*                                             10 digits for 7FFFFFFF */\n/* Numeric Digits 20                           allow up to 2GB        */\n/* sva  = C2d(Arg(1))                          convert to decimal     */\n/* tcb  = C2d(Storage(21C,4))                  TCB         PSATOLD    */\n/* jscb = C2d(Storage(D2x(tcb+180),4))         JSCB        TCBJSCB    */\n/* qmpl = C2d(Storage(D2x(jscb+244),4))        QMPL        JSCBQMPI   */\n/* qmat = C2d(Storage(D2x(qmpl+24),4))         QMAT        QMADD      */\n/* Do While sva > 65536                                               */\n/*  qmat = C2d(Storage(D2x(qmat+12),4))        next QMAT     QMAT+12  */\n/*  sva=sva-65536                              010006F -> 000006F     */\n/* End                                                                */\n/* Return D2c(C2d(Storage(D2x(qmat+sva+1),4))+16)    return address   */\n/**********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$README": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00P\\x01\\x02\\x01\\x0f\\x01\\x04\\x01O\\x16Y\\x00|\\x00\\x02\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2002-01-10T00:00:00", "modifydate": "2004-01-14T16:59:50", "lines": 124, "newlines": 2, "modlines": 0, "user": "EEIT045"}, "text": "#* TEXT - $$README : Contains the overview for this PDS               */\n/**********************************************************************/\n\n Here are a number of bits of handy REXX code, the list may well grow as\n I tidy up some of my REXX library.\n\n There are some of samples of using the DFSMS/MVS Catalog Search\n Interface (CSI). More detail can be found in :\n\n DFSMS/MVS - Managing Catalogs - Document Number SC26-4914\n Appendix D \"Catalog Search Interface User's Guide\"\n\n The original code was derived from the IBM provided sample in\n 'SYS1.SAMPLIB(IGGCSIRX)' but has been heavily modified (including\n correcting the bugs in that code).\n\n Hopefully it is now correct and should work as intended. However as\n usual, no guarantee is implied.\n\n Most code is designed for either foreground or background execution.\n\n The pieces are as follows :\n\n #DELDUP  - Edit macro to delete duplicate lines\n\n #DELNDUP - Edit macro to delete non-duplicate lines\n\n ALICOUNT - This simply finds all of the aliases in the system and gives\n            a count of datasets that are using them.\n            Handy for finding all those redundant aliases cluttering up\n            your mastercat.\n\n ALIMAKE  - So you have just disconnected a usercat and lost all the\n            alises ... Reconnect the catalog and then run this to get\n            a DEF ALIAS for all the 'suitable' HLQs in the catalog.\n\n BODGECAT - A sample workaround for a LISTDS on an uncataloged dsn.\n\n CSICODE  - Base CSI code, setup to be modified for other functions.\n            As provided it simply list ALL entries.\n\n CSICODEV - Generates a LISTCAT like output for a VSAM file.\n            Contains most of the CSI VSAM fields.\n\n CSITAPES - Stripped down version of above code to simply list all tape\n            based datasets in the catalogs.\n\n DDSCAN   - Search a selected DD in JCL for a particular member.\n\n HFSSTAT  - Provide statistics for HFS files prior to the DSNINFO\n            ISPF service provided at OS/390 V2R10.\n\n RCNVTCAT - A replacement for MCNVTCAT.\n            This should allow those who are unhappy with IBMs removal of\n            MCNVTCAT support to feel 'safe'. It is faster than MCNVTCAT\n            and (hopefully) provides directly compatible output.\n            (Just in case 'anyone' has rolled their own code to use\n             the MCNVTCAT output).\n\n            Also generates RECATALOG statements for PAGE and SYS1.**\n            clusters.\n\n            Also can be used to compare two catalogs.\n\n RDA      - An SDSF DA 'replacement' displays various fields that you\n            would normally see in the SDSF DA display.\n\n RINIT    - An SDSF INIT 'replacement' displays various fields that you\n            would normally see in the SDSF INIT display.\n\n SPACE    - Displays SMS pools and allow drill down to volume/dataset\n            level. Has various extras including displaying the catalog\n            status of all datasets on a volume.\n\n SYSINF   - Another system information REXX. There are others, some are\n            worse, some are better - this is mine :-)\n\n TABLSTAT - Want to know when all those tables/profile members in a PDS\n            were created/updated ? Well this will add normal PDS stats\n            to all of the members matching the detail inside the\n            table/s.\n\n I have also added MAKEINDX in case anyone is wondering what the point\n of the strange comments in everything are (and where the $$$INDEX came\n from).\n\n Have fun and I hope these help someone.\n\n Cheers - Alastair Gray (Consultant Systems Type)\n          Lausanne, Switzerland 22nd November 2002\n\n ** UPDATE **\n\n I have now made a general change and modified all uses of the 'not'\n symbol (\u00ac) to use a slash instead (/) as this does not seem to suffer\n as much from translation table problems.\n\n I have also attempted to remove the requirement for OMVS in my CSI code\n this was added after a request for a 'no-TSO' support option. The code\n should now allow for TSO or OMVS (one of them must be available).\n As usual, let me know if this causes problems elsewhere.\n\n Cheers - Alastair Gray (Consultant Systems Type)\n          Lausanne, Switzerland 3rd March 2003\n\n ** UPDATE 2 **\n\n I have made two mods to the CSI based code, as a result of some bug\n reports and the great assistance of the reporters in running debug\n code for me (cheers to John and Don) :\n\n 1. The code has been modified to handle CSIOPTNS set as either blank or\n    'F' for fullword. This allows for field lengths greater than 65535.\n    I have also changed the code so that for OS/390 R10 and above this\n    option will be enabled automatically.\n    Please note that at the time of writing, my handling of the fullword\n    option is right - it is the manual(s) that are wrong.\n\n 2. I have added some DEBUG options to create some handy - for me -\n    info in sensitive areas.\n    They are numbered to allow for further future debug areas ;-)#\n\n Cheers - Alastair Gray (Systems and Storage Type)\n          Lausanne, Switzerland 14th January 2004\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SWABOVE": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\"\\x01\\x16#O\\x01\\x16#o\\x13T\\x00X\\x00Y\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2016-08-21T00:00:00", "modifydate": "2016-08-23T13:54:22", "lines": 88, "newlines": 89, "modlines": 0, "user": "SBGOLOB"}, "text": "                  RCNVTCAT WITH SWA ABOVE THE LINE\n                  -------- ---- --- ----- --- ----\n\n\nRCNVTCAT is a REXX exec which works under TSO.  It is also supposed to\n   work under OMVS (UNIX in z/OS) but has been in process of being\n   fixed for OMVS.  It works under TSO, which should be sufficient for\n   most people's purposes.\n\n   The old version of RCNVTCAT was supposed to work under both TSO and\n   OVMS, but it doesn't work when SWA (JES2 Scheduler Work Area) is\n   set (in JES2 parms for JOBCLASS(TSU) or TSUCLASS) as SWA=ABOVE (SWA\n   above the 16 meg line.)\n\n   RCNVTCAT was written by Alastair Gray.\n\n   RCNVTCAT was fixed further by John McKown to run under UNIX (OMVS).\n            See member $$NOTE03 in this pds for details about his part\n            of the project.  RCNVTCAT (for TSO) was originally fixed\n            for SWA above the line, by Lionel Dyck, so it now should\n            work for all cases, under TSO.\n\n\nSYNTAX :   RCNVTCAT 'catalog.name' \u00dd'second.cat.name'\u00a8 (second name\n                                                        is optional\n                                                        and is used\n                                                        to compare 2\n                                                        catalogs)\n\n\nPURPOSE:   RCNVTCAT runs against a VSAM (or ICF) catalog, and produces\n           a PDS which contains DEFINE statements to recatalog most of\n           the original catalog's entries.  This is very useful, for\n           example, when you are making a new system, and you want to\n           recatalog the entries from the old master catalog into a\n           brand new master catalog that you are making.  RCNVTCAT\n           will produce most of the DEFINE statements which (when\n           edited) will enable you to do that, and populate the new\n           master catalog with the proper dataset entries that you\n           need there.\n\n           RCNVTCAT is a \"replacement\" (not from IBM) to an unofficial\n           IBM program called MCNVTCAT, which was distributed with CBIPO\n           and CBPDO IBM software distributions.  The IBM \"system\n           packaging\" people developed MCNVTCAT (NOT the IBM development\n           programmers) and so, MCNVTCAT was an unsupported program that\n           IBM dropped support for.  All of us \"old systems programmers\"\n           tried to save copies of MCNVTCAT, which still works, but you\n           can't get new copies of it from IBM.\n\n           Alastair Gray wrote RCNVTCAT to completely replace MCNVTCAT.\n\n           RCNVTCAT is much easier to use than MCNVTCAT.  RCNVTCAT runs\n           under TSO.  MCNVTCAT ran in batch, with complicated JCL that\n           you have to set up.  (Once set up, it was easy to run.)\n           As you see above, RCNVTCAT is very easy to use.  Point it to\n           one catalog name, and it will produce DEFINE statements for\n           its entries.  Give it TWO catalog names, and it will compare\n           the two catalogs' entries to each other.\n\n\nPROBLEM:   Under TSO, RCNVTCAT stopped working when SWA=ABOVE was set\n           in the JES2 parms.  The REXX will not allocate a temporary\n           dataset to put its output in, when SWA=ABOVE is coded for\n           the TSU jobclass.\n\nSOLUTION (partial):\n           Lionel Dyck fixed RCNVTCAT to work under TSO for SWA=ABOVE,\n           but his fix works only for TSO operation (which most people\n           use) and not for OMVS operation (I don't know why Alastair\n           wrote that).\n\n           For people who run RCNVTCAT under TSO (almost everyone), and\n           if SWA=ABOVE is set for TSU in the JES2 parms (which happens\n           a lot), then those people who need to use RCNVTCAT now have a\n           solution.\n\n           Lionel's fixed RCNVTCAT is presented here as member RCNVTCAT.\n\n           Alastair Gray's original exec, is presented here as member\n           RCNVTCAO.\n\n           John McKown is currently working on enhancing RCNVTCAT to\n           work under OMVS.\n\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DELDUP": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x01\\x00\\x98%\\x9f\\x00\\x98%\\x9f\\x10H\\x00,\\x00,\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-09-16T00:00:00", "modifydate": "1998-09-16T10:48:01", "lines": 44, "newlines": 44, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - #DELDUP  : EDIT Macro to remove duplicate lines             */\n/**********************************************************************/\n/* Written - A.J.GRAY : 16/09/1998                                    */\n/**********************************************************************/\n/* The following test that this is a valid ISREDIT environment.       */\n/**********************************************************************/\noptions = ''                           /*                             */\nAddress ISPEXEC                        /*                             */\n\"IsrEdit Macro\"                        /* TEST ISREDIT                */\nmrc = rc                               /*                             */\nzerralrm = 'NO'                        /* SET MESSAGE ALARM TO NO     */\nzerrhm   = 'ISR00003'                  /* SET HELP SCREEN TO DEFAULT  */\nx = Msg(off)                           /*  DISABLE MESSAGES           */\nx = Prompt(off)                        /*  DISABLE PROMPTING          */\n/**********************************************************************/\nIf (mrc > 0) Then                      /* TEST IF EDIT ENVIRONMENT    */\n Do                                    /*                             */\n  zedsmsg = 'Edit Macro only'          /*                             */\n  zedlmsg = '\"#DELDUP\" can only be run as an Edit Macro' /*           */\n  \"SetMsg Msg(ISRZ001)\"                /*                             */\n  Signal FINISH                        /*                             */\n End                                   /*                             */\n/**********************************************************************/\nSay \"Deleting duplicate lines\"         /*                             */\nduplicate = 0                          /*                             */\nlinenum = 1                            /*                             */\n\"IsrEdit (line1) = Line \"linenum       /*                             */\nlinenum = linenum + 1                  /*                             */\nDo Forever                             /*                             */\n Address ISPEXEC \"Control Errors Return\" /*                           */\n \"IsrEdit (line2) = Line \"linenum      /*                             */\n If (rc > 0) Then Leave                /*                             */\n Address ISPEXEC \"Control Errors Cancel\" /*                           */\n If (line1 = line2) Then               /*                             */\n  Do                                   /*                             */\n   \"IsrEdit Delete \"linenum            /*                             */\n   duplicate = duplicate + 1           /*                             */\n   Iterate                             /*                             */\n  End                                  /*                             */\n line1 = line2                         /*                             */\n linenum = linenum + 1                 /*                             */\nEnd                                    /*                             */\nSay duplicate \"duplicate lines deleted\" /*                            */\nExit 0                                 /*                             */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DELNDUP": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x19\\x00\\x98%\\x9f\\x01\\x03\\x06/\\x10&\\x002\\x002\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1998-09-16T00:00:00", "modifydate": "2003-03-03T10:26:19", "lines": 50, "newlines": 50, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - #DELNDUP : EDIT Macro to remove non duplicate lines         */\n/**********************************************************************/\n/* Written - A.J.GRAY : 16/09/1998                                    */\n/**********************************************************************/\n/* The following test that this is a valid ISREDIT environment.       */\n/**********************************************************************/\noptions = ''                           /*                             */\nAddress ISPEXEC                        /*                             */\n\"IsrEdit Macro\"                        /* TEST ISREDIT                */\nmrc = rc                               /*                             */\nzerralrm = 'NO'                        /* SET MESSAGE ALARM TO NO     */\nzerrhm   = 'ISR00003'                  /* SET HELP SCREEN TO DEFAULT  */\nx = Msg(off)                           /*  DISABLE MESSAGES           */\nx = Prompt(off)                        /*  DISABLE PROMPTING          */\n/**********************************************************************/\nIf (mrc > 0) Then                      /* TEST IF EDIT ENVIRONMENT    */\n Do                                    /*                             */\n  zedsmsg = 'Edit Macro only'          /*                             */\n  zedlmsg = '\"#DELNDUP\" can only be run as an Edit Macro' /*          */\n  \"SetMsg Msg(ISRZ001)\"                /*                             */\n  Signal FINISH                        /*                             */\n End                                   /*                             */\n/**********************************************************************/\nSay \"Deleting non-duplicate lines\"     /*                             */\noldline = 1                            /*                             */\nnewline = 2                            /*                             */\nDo Forever                             /*                             */\n Address ISPEXEC \"Control Errors Return\" /*                           */\n \"IsrEdit (line1) = Line \"oldline      /*                             */\n \"IsrEdit (line2) = Line \"newline      /*                             */\n If (rc > 0) Then Leave                /*                             */\n Address ISPEXEC \"Control Errors Cancel\" /*                           */\n If (line1 = line2) Then               /*                             */\n  Do                                   /*                             */\n   flag.oldline = 'DUP'                /*                             */\n   flag.newline = 'DUP'                /*                             */\n  End                                  /*                             */\n newline = newline + 1                 /*                             */\n oldline = oldline + 1                 /*                             */\nEnd                                    /*                             */\nnondup = 0                             /*                             */\nDo loop = oldline to 1 by -1           /*                             */\n If (flag.loop /= 'DUP') Then          /*                             */\n  Do                                   /*                             */\n   \"IsrEdit Delete \"loop               /*                             */\n   nondup = nondup + 1\n  End                                  /*                             */\nEnd                                    /*                             */\nSay nondup\" non-duplicate lines deleted\" /*                           */\nExit 0                                 /*                             */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE542": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x002\\x01\\x185?\\x01\\x185?\\x14\\x19\\x00\\x89\\x00\\x89\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2018-12-19T00:00:00", "modifydate": "2018-12-19T14:19:32", "lines": 137, "newlines": 137, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 542 is from Alastair Gray and contains some handy tools   *   FILE 542\n//*           (so far), which are described below.  One is a REXX   *   FILE 542\n//*           which is an MCNVTCAT replacement, and the other is    *   FILE 542\n//*           a tool to find all the catalog alias names in the     *   FILE 542\n//*           system.  There's some more too...                     *   FILE 542\n//*                                                                 *   FILE 542\n//*           emails:  Alastair.Gray@pmi.com                        *   FILE 542\n//*                    famille_gray@freesurf.ch                     *   FILE 542\n//*                                                                 *   FILE 542\n//*           email :  Robert.Richards@opm.gov                      *   FILE 542\n//*                                                                 *   FILE 542\n//*      The overview for this PDS                                  *   FILE 542\n//*                                                                 *   FILE 542\n//*      Here are a number of bits of handy REXX code, the list     *   FILE 542\n//*      may well grow as I tidy up some of my REXX library.        *   FILE 542\n//*                                                                 *   FILE 542\n//*      There are some of samples of using the DFSMS/MVS           *   FILE 542\n//*      Catalog Search Interface (CSI). More detail can be         *   FILE 542\n//*      found in :                                                 *   FILE 542\n//*                                                                 *   FILE 542\n//*      DFSMS/MVS - Managing Catalogs - Document Number            *   FILE 542\n//*      SC26-4914 Appendix D \"Catalog Search Interface User's      *   FILE 542\n//*      Guide\"                                                     *   FILE 542\n//*                                                                 *   FILE 542\n//*      The original code was derived from the IBM provided        *   FILE 542\n//*      sample in 'SYS1.SAMPLIB(IGGCSIRX)' but has been heavily    *   FILE 542\n//*      modified (including correcting the bugs in that code).     *   FILE 542\n//*                                                                 *   FILE 542\n//*      Hopefully it is now correct and should work as             *   FILE 542\n//*      intended.  However as usual, no guarantee is implied.      *   FILE 542\n//*                                                                 *   FILE 542\n//*      All code is designed for either foreground or background   *   FILE 542\n//*      execution.                                                 *   FILE 542\n//*                                                                 *   FILE 542\n//*      The pieces are as follows :                                *   FILE 542\n//*                                                                 *   FILE 542\n//*      #DELDUP  - Edit macro to delete duplicate lines            *   FILE 542\n//*                                                                 *   FILE 542\n//*      #DELNDUP - Edit macro to delete non-duplicate lines        *   FILE 542\n//*                                                                 *   FILE 542\n//*      ALICOUNT - This simply finds all of the aliases in the     *   FILE 542\n//*                 system and gives a count of datasets that       *   FILE 542\n//*                 are using them.  Handy for finding all those    *   FILE 542\n//*                 redundant aliases cluttering up your            *   FILE 542\n//*                 mastercat.                                      *   FILE 542\n//*                                                                 *   FILE 542\n//*      ALIMAKE  - So you have just disconnected a usercat and     *   FILE 542\n//*                 lost all the alises ... Reconnect the catalog   *   FILE 542\n//*                 and then run this to get a DEF ALIAS for all    *   FILE 542\n//*                 the 'suitable' HLQs in the catalog.             *   FILE 542\n//*                                                                 *   FILE 542\n//*      BODGECAT - A sample workaround for a LISTDS on an          *   FILE 542\n//*                 uncataloged dsn.                                *   FILE 542\n//*                                                                 *   FILE 542\n//*      CSICODE  - Base CSI code, setup to be modified for other   *   FILE 542\n//*                 functions. As provided, it simply lists ALL     *   FILE 542\n//*                 entries.                                        *   FILE 542\n//*                                                                 *   FILE 542\n//*      CSICODEO - Pre-munge version taken before the fullword     *   FILE 542\n//*                 code was added for anyone who is running old.   *   FILE 542\n//*                                                                 *   FILE 542\n//*      CSICODEV - Generates a LISTCAT like output for a VSAM file.*   FILE 542\n//*                 Contains most of the CSI VSAM fields.           *   FILE 542\n//*                                                                 *   FILE 542\n//*      CSITAPES - Stripped down version of above code to simply   *   FILE 542\n//*                 list all tape based datasets in the catalogs.   *   FILE 542\n//*                                                                 *   FILE 542\n//*      DDSCAN   - Search a selected DD in JCL for a particular    *   FILE 542\n//*                 member.                                         *   FILE 542\n//*                                                                 *   FILE 542\n//*      HFSSTAT  - Provide statistics for HFS files prior to the   *   FILE 542\n//*                 DSNINFO ISPF service provided at OS/390 V2R10.  *   FILE 542\n//*                                                                 *   FILE 542\n//*      SCNVTCAT - A replacement for MCNVTCAT, converted and       *   FILE 542\n//*                 adapted for use under UNIX by John McKown.      *   FILE 542\n//*                 Works exactly like RCNVTCAT under TSO.          *   FILE 542\n//*                                                                 *   FILE 542\n//*                 See member $$NOTE04 for much detail on John's   *   FILE 542\n//*                 changes and adaptations for UNIX.               *   FILE 542\n//*                                                                 *   FILE 542\n//*                 ALIAS entries fixed by Bob Richards.            *   FILE 542\n//*                                                                 *   FILE 542\n//*      RCNVTCAT - A replacement for MCNVTCAT.                     *   FILE 542\n//*                                                                 *   FILE 542\n//*                 This should allow those who are unhappy with    *   FILE 542\n//*                 IBMs removal of MCNVTCAT support to feel        *   FILE 542\n//*                 'safe'.  It is faster than MCNVTCAT and         *   FILE 542\n//*                 (hopefully) provides directly compatible        *   FILE 542\n//*                 output.  (Just in case 'anyone' has rolled      *   FILE 542\n//*                 their own code to use the MCNVTCAT output).     *   FILE 542\n//*                                                                 *   FILE 542\n//*                 Also generates RECATALOG statements for PAGE    *   FILE 542\n//*                 and SYS1.** clusters.                           *   FILE 542\n//*                                                                 *   FILE 542\n//*                 Also can be used to compare two catalogs.       *   FILE 542\n//*                                                                 *   FILE 542\n//*                 Fixed to run under TSO when SWA=ABOVE for       *   FILE 542\n//*                 TSUCLASS or JOBCLASS(TSU) in JES2 parms.        *   FILE 542\n//*                 See member $SWABOVE in this pds for details.    *   FILE 542\n//*                                                                 *   FILE 542\n//*                 ALIAS entries fixed by Bob Richards.            *   FILE 542\n//*                                                                 *   FILE 542\n//*                 Bug fixed at z/OS 1.13 level - Sept 2012.       *   FILE 542\n//*                                                                 *   FILE 542\n//*      RDA      - An SDSF DA 'replacement' displays various       *   FILE 542\n//*                 fields that you would normally see in the SDSF  *   FILE 542\n//*                 DA display.                                     *   FILE 542\n//*                                                                 *   FILE 542\n//*      RINIT    - An SDSF INIT 'replacement' displays various     *   FILE 542\n//*                 fields that you would normally see in the SDSF  *   FILE 542\n//*                 INIT display.                                   *   FILE 542\n//*                                                                 *   FILE 542\n//*      SPACE    - Displays SMS pools and allow drill down to      *   FILE 542\n//*                 volume/dataset level. Has various extras        *   FILE 542\n//*                 including displaying the catalog status of all  *   FILE 542\n//*                 datasets on a volume.                           *   FILE 542\n//*                                                                 *   FILE 542\n//*      SPACENEW - SPACE command enhanced for EAV.                 *   FILE 542\n//*                                                                 *   FILE 542\n//*      SYSINF   - Another system information REXX.                *   FILE 542\n//*                 There are others, some are worse and some are   *   FILE 542\n//*                 better - this is mine :-)                       *   FILE 542\n//*                                                                 *   FILE 542\n//*      TABLSTAT - Want to know when all those tables/profile      *   FILE 542\n//*                 members in a PDS were created/updated? Well     *   FILE 542\n//*                 this will add normal PDS stats to all of the    *   FILE 542\n//*                 members matching the detail inside the table/s. *   FILE 542\n//*                                                                 *   FILE 542\n//*      I have also added MAKEINDX in case anyone is wondering     *   FILE 542\n//*      what the point of the strange comments in everything       *   FILE 542\n//*      are (and where the $$$INDEX came from).                    *   FILE 542\n//*                                                                 *   FILE 542\n//*      Have fun and I hope these help someone.                    *   FILE 542\n//*                                                                 *   FILE 542\n//*      Cheers - Alastair Gray (Consultant Systems Type)           *   FILE 542\n//*               Lausanne, Switzerland 22nd November,2002          *   FILE 542\n//*                                                                 *   FILE 542\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALICOUN$": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x009\\x01\\x02\\x01\\x0f\\x01\\x022o\\x10G\\x00\\x0f\\x00\\x12\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2002-01-10T00:00:00", "modifydate": "2002-11-22T10:47:39", "lines": 15, "newlines": 18, "modlines": 0, "user": "EEIT045"}, "text": "//EEIT045  JOB (1,,N#X),'ALICOUN$ EEIT045.MYC',\n//         MSGCLASS=X,MSGLEVEL=(1,1),\n//         REGION=8M,NOTIFY=&SYSUID,COND=(4,LT)\n//*USERDATA=(ALICOUN$ EEIT045.MYCBT.CODE)\n//*-----------------------------------------------------------------*\n//*   LIB : EEIT045.MYCBT.CODE(ALICOUN$)\n//*  NOTE : 10/01/02 15:29:56\n//*   DOC : EXECUTE ALIAS COUNTING ROUTINE\n//*-----------------------------------------------------------------*\n//ALICOUNT EXEC PGM=IRXJCL,COND=EVEN,PARM='ALICOUNT'\n//SYSEXEC  DD DISP=SHR,DSN=EEIT045.MYCBT.CODE\n//REPORT   DD SYSOUT=*          * PDS RECOMMENDED\n//SYSTSPRT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ALICOUNT": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x010\\x00\\x15\\x01\\x02\\x02/\\x01\\x03\\x06?\\x08S\\x02(\\x01E\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.48", "flags": 0, "createdate": "2002-01-22T00:00:00", "modifydate": "2003-03-04T08:53:15", "lines": 552, "newlines": 325, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - ALICOUNT : Count datasets for each alias in the system      */\n/**********************************************************************/\n/* ALICOUNT : Uses Catalog Search Interface (CSI)                     */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version            */\n/* 1.1.0   - 11/01/2002 - Alastair Gray - Rewrite using CLICODE base  */\n/* 1.1.1   - 14/01/2002 - Alastair Gray - Add TOT_INIT                */\n/* 1.1.2   - 22/01/2002 - Alastair Gray - In line with CSICODE        */\n/* 1.1.3   - 29/04/2002 - Alastair Gray - Added '?' option            */\n/* 1.1.4   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.1.5   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.1.6   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.1.7   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.1.8   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.2.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.2.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.2.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.2.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.2.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This processes the master catalog to get a list of aliases and  */\n/*    then processes each ALIAS/UCAT to get a dataset count.          */\n/*                                                                    */\n/* 2. The output is written to members of a PDS allocated to REPORT.  */\n/*    or in batch JES sequential output is allowed.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no OMVS environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\nArg test                             /* allow for '?' option          */\nIf (test = '?') Then                 /*                               */\n Do                                  /*                               */\n  Say \"ALICOUNT has no other parms\"  /*                               */\n  Say \" To use simply specify 'ALICOUNT' it will identify and use the \"\n  Say \" master catalog.\"             /*                               */\n  Signal FINISH                      /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat = ' '                            /* Set catalog name              */\nflt = '**'                           /* Set the filter                */\ntyp = ' '                            /* Set entry types required      */\nct1 = ' '                            /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nx = CSI(' ','**','X',' ')            /* initial CSI call              */\n/**********************************************************************/\nnvsam_cnt = 0                        /* initialise non-vsam count     */\nucat_cnt  = 0                        /* initialise usercat count      */\n/**********************************************************************/\nl_cnt = l_cnt + 2                    /* increment for loop            */\nhead1 = l_cnt - 1                    /* calculate header line 1       */\nhead2 = l_cnt                        /* calculate headre line 2       */\nDo zzzz = 1 to alias_tot             /* loop through alias list       */\n ind_tot = 0                         /*  initialise counter           */\n If (altyp.zzzz = 'A') Then          /*  if alternate is NONVSAM      */\n  Do                                 /*                               */\n   nvsam_cnt = nvsam_cnt + 1         /*   increment non-VSAM counter  */\n   l_cnt = l_cnt + 1                 /*   increment report line       */\n   l.l_cnt = Left(1,6)' 'alias.zzzz' for 'Strip(alcat.zzzz,T)\n  End                                /*                               */\nEnd                                  /*                               */\nl.head1 = 'Number of Non-VSAM aliases found = 'nvsam_cnt\nl.head2 = Left('-',Length(l.head1),'-')\n/**********************************************************************/\nl_cnt = l_cnt + 1                    /* add a blank line to report    */\nl.l_cnt = ' '                        /*                               */\n/**********************************************************************/\nl_cnt = l_cnt + 2                    /* increment for next loop       */\nhead1 = l_cnt - 1                    /* calculate header line 1       */\nhead2 = l_cnt                        /* calculate headre line 2       */\nDo zzzz = 1 to alias_tot             /* loop through alias list       */\n ind_tot = 0                         /*  initialise counter           */\n If (altyp.zzzz = 'U') Then          /*  if alternate is UCAT         */\n  Do                                 /*                               */\n   ucat_cnt = ucat_cnt + 1           /*   increment UCAT counter      */\n   l_cnt = l_cnt + 1                 /*   increment report line       */\n   x = CSI(Strip(alcat.zzzz,T),Strip(alias.zzzz)'.**','ABCGHR','Y')\n   l.l_cnt = Left(ind_tot,6)' 'alias.zzzz' in  'Strip(alcat.zzzz,T)\n  End                                /*                               */\nEnd                                  /*                               */\nl.head1 = 'Number of UCAT aliases found = 'ucat_cnt\nl.head2 = Left('-',Length(l.head1),'-')\n/**********************************************************************/\n/* Produce the ALIAS Report                                           */\n/**********************************************************************/\nmember = 'ALIASCNT'                  /* processing ALIASCNT report    */\nCall WRITE_MEMBER                    /* write-out member              */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"sysdsname\"') VOLUME(\"sysvolume\")\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\ncsiresrv = Substr(' ',1,1)           /* clear reserve character       */\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '0004'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csiresrv\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length     */\n    If (csienter = '1') Then         /* entry error                   */\n     Do\n      Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n      plus = 50                      /* length for error entry        */\n     End\n    Else                             /*                               */\n     Do                              /*                               */\n      Call ENTRY                     /* Execute entry processing      */\n      plus = 46 + csitotln           /* length for normal entry       */\n     End                             /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\ne_off = off + 46                     /* get offset to entries         */\no_fld.1 = e_off+4+(C2d(csinumen)*2)  /* get first field offset        */\nl_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length      */\ne_pos = 6                            /* set offset of second field    */\nDo flds = 2 to C2d(csinumen)         /* loop through other fields     */\n prv = flds - 1                      /* set 'previous' value          */\n o_fld.flds = o_fld.prv + l_fld.prv  /* get next offset               */\n l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length     */\n e_pos = e_pos + 2                   /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                \"Blksize(1330) Recfm(F,B) New Reuse\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    x = Listdd(REPORT)               /*                               */\n    dsn = sysdsname                  /*                               */\n   End                               /*                               */\nElse                                 /*                               */\n dsn = sysdsname                     /* get dataset name from DD      */\nIf (sysvolume = '*JES**') Then       /*                               */\n Do                                  /*                               */\n  Say '**(Warning-1)* For execution in batch, it is recommended that'\n  Say '**(Warning-2)* a PDS is pre-allocated to DD name REPORT.'\n  Say '**(Warning-3)* Processing will continue with sequential output.'\n  outflag = 'JES'                    /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nalias_tot = 0                        /* initialise alias counter      */\nind_tot   = 0                        /* initialise individual counter */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDD:                                     /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\nIf (csi_type /= '0') Then            /* processing non-catalog        */\n Do                                  /*                               */\n  If (entype = 'ALIAS') Then         /* If entry is an ALIAS          */\n   Do                                /*                               */\n    alias_tot = alias_tot + 1        /*  increment total              */\n    alias.alias_tot = entname        /*  save alias name              */\n    alcat.alias_tot = name           /*  save alias catalog           */\n    altyp.alias_tot = type           /*  save alias type              */\n   End                               /*                               */\n  Else                               /* otherwise                     */\n   Do                                /*                               */\n    ind_tot = ind_tot + 1            /*  increment individual counter */\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIMAKE": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01:\\x001\\x01\\x02\\x02/\\x01\\x03\\x06?\\x08S\\x03J\\x01\\xfe\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.58", "flags": 0, "createdate": "2002-01-22T00:00:00", "modifydate": "2003-03-04T08:53:31", "lines": 842, "newlines": 510, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - ALIMAKE : Generate ALIAS DEFs based on catalog contents     */\n/**********************************************************************/\n/* CSICODE : Uses Catalog Search Interface (CSI)                      */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 22/01/2002 - Alastair Gray - Original version            */\n/* 1.0.1   - 29/04/2002 - Alastair Gray - Added '?' option            */\n/* 1.0.2   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.0.3   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.0.4   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.0.5   - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.0.6   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.0.7   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This processes a catalog and produces a PDS member with         */\n/*    DEF ALIAS statements for all 'suitable' HLQs in the cat.        */\n/*                                                                    */\n/* 2. The output is written to members of a PDS allocated to REPORT   */\n/*    or in batch JES sequential output is allowed.                   */\n/*                                                                    */\n/* 3. Handy when you have accidentally disconnected a usercat ...     */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no OMVS environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat = ' '                            /* Set catalog name              */\nflt = '**'                           /* Set the filter                */\ntyp = ' '                            /* Set entry types required      */\nct1 = ' '                            /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Handle passed parameters                                           */\n/**********************************************************************/\nArg cat                              /* Get passed arguments          */\ncat = Strip(cat,B,\"'\")               /* clean up passed catalog       */\nIf (cat = '?') Then                  /*                               */\n Do                                  /*                               */\n  Say \"ALIMAKE has only one paramemter\" /*                            */\n  Say \" To use simply specify : ALICOUNT catname \"\n  Signal FINISH                      /*                               */\n End                                 /*                               */\nIf (cat = '') Then                   /* no catalog passed             */\n Do                                  /*                               */\n  Say '**(cat)** No entry provided for catalog name.'\n  Signal FINISH                      /* exit exec                     */\n End                                 /*                               */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* Get the Master Catalog name                                        */\n/**********************************************************************/\nCall GET_MCAT                        /* get master catalog name       */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nmember = 'ALIASGEN'                  /* processing ALIAS              */\nx = CSI(cat,'**',typ,'Y')            /* Call CSI procedure            */\nCall WRITE_MEMBER                    /* write-out member              */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"sysdsname\"') VOLUME(\"sysvolume\")\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\ncsiresrv = Substr(' ',1,1)           /* clear reserve character       */\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '000D'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */\ncsifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld09 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld10 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld11 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld12 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld13 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csiresrv\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length     */\n    If (csienter = '1') Then         /* entry error                   */\n     Do\n      Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n      plus = 50                      /* length for error entry        */\n     End\n    Else                             /*                               */\n     Do                              /*                               */\n      Call ENTRY                     /* Execute entry processing      */\n      plus = 46 + csitotln           /* length for normal entry       */\n     End                             /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\ne_off = off + 46                     /* get offset to entries         */\no_fld.1 = e_off+4+(C2d(csinumen)*2)  /* get first field offset        */\nl_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length      */\ne_pos = 6                            /* set offset of second field    */\nDo flds = 2 to C2d(csinumen)         /* loop through other fields     */\n prv = flds - 1                      /* set 'previous' value          */\n o_fld.flds = o_fld.prv + l_fld.prv  /* get next offset               */\n l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length     */\n e_pos = e_pos + 2                   /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ngdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */\ngdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */\ncattr    = Substr(dwork,o_fld.8,l_fld.8)   /* attribs page and swap   */\ndevtyp   = Substr(dwork,o_fld.9,l_fld.9)   /* device type             */\nvolser   = Substr(dwork,o_fld.10,l_fld.10) /* volume serial           */\nfileseq  = Substr(dwork,o_fld.11,l_fld.11) /* file sequence           */\nvsamreus = Substr(dwork,o_fld.12,l_fld.12) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /*                           */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /*                           */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_TYPE     - Process TYPE     field                              */\n/**********************************************************************/\nFLD_TYPE:                            /* TYPE     field processing   ##*/\ntype_list = ''                       /* loop through type             */\nDo z = 1 to Length(type)             /* loop through type             */\n astype = Substr(type,z,1)           /* decode type flag              */\n Select                              /* decode type flag              */\n  When (astype = 'C') Then astype = 'CLUSTER'  /*                     */\n  When (astype = 'D') Then astype = 'DATA'     /*                     */\n  When (astype = 'I') Then astype = 'INDEX'    /*                     */\n  When (astype = 'A') Then astype = 'NONVSAM'  /*                     */\n  When (astype = 'H') Then astype = 'GDS'      /*                     */\n  When (astype = 'B') Then astype = 'GDG'      /*                     */\n  When (astype = 'R') Then astype = 'PATH'     /*                     */\n  When (astype = 'G') Then astype = 'AIX'      /*                     */\n  When (astype = 'X') Then astype = 'ALIAS'    /*                     */\n  When (astype = 'U') Then astype = 'UCAT'     /*                     */\n  Otherwise                          /*                               */\n   Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n   Say '**(Error-2)* Entry type ='astype\n   astype = '@'                      /* unknown type                  */\n End                                 /*                               */\n type_list = type_list' 'astype      /*                               */\nEnd                                  /*                               */\ntype = Strip(type_list,L)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREUSE'     /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype /= 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOWRITECHK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOIMBED'     /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREPLICAT'  /*                               */\nIf (entype /= 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\n Else                                 /*                              */\n  vsam_attr = vsam_attr' NONSPANNED'  /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                \"Blksize(1330) Recfm(F,B) New Reuse\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    x = Listdd(REPORT)               /*                               */\n    dsn = sysdsname                  /*                               */\n   End                               /*                               */\nElse                                 /*                               */\n dsn = sysdsname                     /* get dataset name from DD      */\nIf (sysvolume = '*JES**') Then       /*                               */\n Do                                  /*                               */\n  Say '**(Warning-1)* For execution in batch, it is recommended that'\n  Say '**(Warning-2)* a PDS is pre-allocated to DD name REPORT.'\n  Say '**(Warning-3)* Processing will continue with sequential output.'\n  outflag = 'JES'                    /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDD:                                     /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\nIf (csi_type /= '0') Then            /* processing non-catalog        */\n Do                                  /*                               */\n  If (Substr(entname,1,4) = '0000') |, /* not self entry              */\n     (entype = 'CLUSTER') |,         /* not a cluster entry           */\n     (entype = 'UCAT') Then          /* not a ucat entry              */\n   Return                            /*                               */\n  If (entype = 'DATA') |,            /* not data entry or             */\n     (entype = 'INDEX') Then         /*     index entry               */\n   If (vsam_vvds = 'Y') Then         /*  when VVDS                    */\n    Return                           /*                               */\n  hlq = Word(Translate(entname,' ','.'),1) /* get hlq                 */\n  If (flag.hlq /= 'Y') Then          /* if not processed              */\n   Do                                /*                               */\n    flag.hlq = 'Y'                   /* set flag                      */\n    l_cnt = l_cnt + 1                /* build DEF ALIAS with hlq      */\n    l.l_cnt = '     DEF ALIAS(REL('cat') -'\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = '          NAME('hlq'))     -'\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = '          CAT('mast_cat')'\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* GET_MCAT - Get the Master catalog name                             */\n/**********************************************************************/\nGET_MCAT:                            /* Get the Master catalog name ##*/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtcbsp  = Storage(D2x(C2d(cvt)+256),4)  /* get the AMCBS address     */\nacb      = Storage(D2x(C2d(cvtcbsp)+8),4)/* get the acb Address       */\ncaxwa    = Storage(D2x(C2d(acb)+64),4)   /* get the caxwa Address     */\ndsncat   = Storage(D2x(C2d(caxwa)+52),44)/* dsn of master cat         */\nmast_cat = Strip(dsncat,T)           /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIMAKE$": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x17\\x01\\x02\\x02/\\x01\\x022o\\x10G\\x00\\x0f\\x00\\x14\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-01-22T00:00:00", "modifydate": "2002-11-22T10:47:17", "lines": 15, "newlines": 20, "modlines": 0, "user": "EEIT045"}, "text": "//EEIT045  JOB (1,,N#X),'ALIMAKE$ EEIT045.MYC',\n//         CLASS=L,MSGCLASS=X,MSGLEVEL=(1,1),\n//         REGION=8M,NOTIFY=&SYSUID,COND=(4,LT)\n//*USERDATA=(ALIMAKE$ EEIT045.MYCBT.CODE)\n//*-----------------------------------------------------------------*\n//*   LIB : EEIT045.MYCBT.CODE(ALIMAKE$)\n//*  NOTE : 22/01/02 14:38:35\n//*   DOC : EXECUTE ALIMAKE DEF ALIAS CREATION PROCEDURE\n//*-----------------------------------------------------------------*\n//ALIMAKE  EXEC PGM=IRXJCL,COND=EVEN,PARM='ALIMAKE CATALOG.EET.EE01'\n//SYSEXEC  DD DISP=SHR,DSN=EEIT045.MYCBT.CODE\n//REPORT   DD SYSOUT=*          * PDS RECOMMENDED\n//SYSTSPRT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BODGECAT": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x000\\x01\\x014\\x7f\\x01\\x02#\\x9f\\x14V\\x00\\x10\\x00\\x01\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "2001-12-13T00:00:00", "modifydate": "2002-08-27T14:56:30", "lines": 16, "newlines": 1, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - BODGECAT : Get a LISTDS on an uncataloged dataset           */\n/**********************************************************************/\n/* Written 13/12/2001 - Alastair Gray                                 */\n/*         in response to a thread on IBM-MAIN                        */\n/*            December 2001 \"RETRIEVE A DATASET'S EXTENTS USED\"       */\n/**********************************************************************/\ndsname = \"'SYS1.HELP'\"\nvolume = \"TMVS9A\"\ntempcat = \"'\"Userid()\".TEMPCAT'\"\nAddress TSO\n\"Define UCAT (Name(\"tempcat\") Tracks(1 1) ICFCAT)\"\n\"Define NONVSAM (Name(\"dsname\") DEVICETYPES(3390) VOLUMES(\"volume\")) \",\n       \"CATALOG(\"tempcat\")\"\n\"ListDS \"dsname\" LABEL CATALOG(\"tempcat\")\"\n\"DELETE \"tempcat\" UCAT RECOVERY\"\nExit 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSICODE": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01Y\\x00\\x15\\x01\\x03\\x06/\\x01\\x04\\x01O\\x11\\x17\\x03\\x89\\x03+\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.89", "flags": 0, "createdate": "2003-03-03T00:00:00", "modifydate": "2004-01-14T11:17:15", "lines": 905, "newlines": 811, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - CSICODE : Minimum clean CSI utilisation code                */\n/**********************************************************************/\n/* CSICODE : Uses Catalog Search Interface (CSI)                      */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 12/01/2002 - Alastair Gray - Original version            */\n/* 1.0.1   - 15/01/2002 - Alastair Gray - Added DSCRDT2 field         */\n/* 1.0.2   - 22/01/2002 - Alastair Gray - Re-ordered fields           */\n/* 1.0.3   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.0.4   - 21/06/2002 - Alastair Gray - Checked work area required  */\n/* 1.0.5   - 08/08/2002 - Alastair Gray - Updated device list         */\n/* 1.0.6   - 20/09/2002 - Alastair Gray - Updates for CSICODEV        */\n/* 1.0.7   - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.0.8   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.0.9   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.1.5   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.1.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.1.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.1.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.1.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This provides a clean base for further CSI development work.    */\n/*                                                                    */\n/* 2. This processes all catalogs and lists all entries.              */\n/*                                                                    */\n/* 3. One return codes is 'special' :                                 */\n/*    RC=44 , Reason=14                                               */\n/*    This relates to entries of greater than 65535 characters.       */\n/*    If you get this entry, then you need to enable fullword         */\n/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */\n/* 3. The output is written to members of a PDS allocated to REPORT   */\n/*    or in batch JES sequential output is allowed.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no OMVS environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\nArg vals                             /* Get passed arguments          */\nargnum = 0                           /*                               */\nDo i = 1 to Words(vals)              /* loop thru arguments           */\n testarg = Strip(Word(vals,i),B,\"'\") /* remove inverted commas        */\n Upper testarg                       /* convert to upper case         */\n Select                              /*                               */\n  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */\n   Do                                /*                               */\n    debug = Substr(testarg,7,1)      /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End                               /*                               */\n  When (testarg = '?') Then          /*                               */\n   Do                                /*                               */\n    Say \"CSICODE has no normal external parms\" /*                     */\n    Say \" To use simply specify 'CSICODE' it will identify and use the \"\n    Say \" master catalog.\"           /*                               */\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Otherwise NOP                      /*                               */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt   = '**'                         /* Set the filter                */\ntyp   = ' '                          /* Set entry types required      */\nct1   = ' '                          /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nmember = 'REPORT'                    /* processing ALIAS              */\nx = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */\nCall WRITE_MEMBER                    /* write-out member              */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"sysdsname\"') VOLUME(\"sysvolume\")\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword used        */\n Say '**(csi)***** Fullword processing selected'\nElse                                 /* check if fullword used        */\n Say '**(csi)***** Halfword processing - default'\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '000D'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */\ncsifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld09 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld10 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld11 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld12 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld13 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  If (debug = 2) Then                /*                               */\n   Do                                /*                               */\n    Say 'off=<'off'>'                /*                               */\n    Say 'entry =<'Substr(dwork,off,150)'>'\n    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'\n   End                               /*                               */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    Select                           /*                               */\n     When (csienter = '1') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     When (csiedata = '0') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* No data returned'\n       Say '**(Error-3)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     Otherwise                       /*                               */\n      Do                             /*                               */\n       If (csioptns = 'F') Then      /* check if fullword requested   */\n        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */\n       Else                          /* otherwise (default halfword)  */\n        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */\n       Call ENTRY                    /* Execute entry processing      */\n       plus = 46 + csitotln          /* length for normal entry       */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ngdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */\ngdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */\ncattr    = Substr(dwork,o_fld.8,l_fld.8)   /* attribs page and swap   */\ndevtyp   = Substr(dwork,o_fld.9,l_fld.9)   /* device type             */\nvolser   = Substr(dwork,o_fld.10,l_fld.10) /* volume serial           */\nfileseq  = Substr(dwork,o_fld.11,l_fld.11) /* file sequence           */\nvsamreus = Substr(dwork,o_fld.12,l_fld.12) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /*                           */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /*                           */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_TYPE     - Process TYPE     field                              */\n/**********************************************************************/\nFLD_TYPE:                            /* TYPE     field processing   ##*/\ntype_list = ''                       /* loop through type             */\nDo z = 1 to Length(type)             /* loop through type             */\n astype = Substr(type,z,1)           /* decode type flag              */\n Select                              /* decode type flag              */\n  When (astype = 'C') Then astype = 'CLUSTER'  /*                     */\n  When (astype = 'D') Then astype = 'DATA'     /*                     */\n  When (astype = 'I') Then astype = 'INDEX'    /*                     */\n  When (astype = 'A') Then astype = 'NONVSAM'  /*                     */\n  When (astype = 'H') Then astype = 'GDS'      /*                     */\n  When (astype = 'B') Then astype = 'GDG'      /*                     */\n  When (astype = 'R') Then astype = 'PATH'     /*                     */\n  When (astype = 'G') Then astype = 'AIX'      /*                     */\n  When (astype = 'X') Then astype = 'ALIAS'    /*                     */\n  When (astype = 'U') Then astype = 'UCAT'     /*                     */\n  Otherwise                          /*                               */\n   Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n   Say '**(Error-2)* Entry type ='astype' X=<'C2x(astype)'>'\n   astype = '@'                      /* unknown type                  */\n End                                 /*                               */\n type_list = type_list' 'astype      /*                               */\nEnd                                  /*                               */\ntype = Strip(type_list,L)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nReturn                               /* duplicates ATTR1              */\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREUSE'     /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype /= 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOWRITECHK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOIMBED'     /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREPLICAT'  /*                               */\nIf (entype /= 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\n Else                                 /*                              */\n  vsam_attr = vsam_attr' NONSPANNED'  /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                \"Blksize(1330) Recfm(F,B) New Reuse\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    x = Listdd(REPORT)               /*                               */\n    dsn = sysdsname                  /*                               */\n   End                               /*                               */\nElse                                 /*                               */\n dsn = sysdsname                     /* get dataset name from DD      */\nIf (sysvolume = '*JES**') Then       /*                               */\n Do                                  /*                               */\n  Say '**(Warning-1)* For execution in batch, it is recommended that'\n  Say '**(Warning-2)* a PDS is pre-allocated to DD name REPORT.'\n  Say '**(Warning-3)* Processing will continue with sequential output.'\n  outflag = 'JES'                    /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDD:                                     /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = Left('CATALOG',10) csicname /*                            */\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = Left(entype,10) entname dscrdt2 volsers /*                */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSICODE$": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x15\\x01\\x02\\x01O\\x01\\x04\\x01O\\x11\\x12\\x00\\x0f\\x00\\x12\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-01-14T00:00:00", "modifydate": "2004-01-14T11:12:15", "lines": 15, "newlines": 18, "modlines": 0, "user": "EEIT045"}, "text": "//EEIT045  JOB (1,,N#X),'CSICODE$ EEIT045.MYC',\n//         CLASS=L,MSGCLASS=X,MSGLEVEL=(1,1),\n//         REGION=8M,NOTIFY=&SYSUID,COND=(4,LT)\n//*USERDATA=(CSICODE$ EEIT045.MYCBT.CODE)\n//*-----------------------------------------------------------------*\n//*   LIB : EEIT045.MYCBT.CODE(CSICODE$)\n//*  NOTE : 14/01/02 12:53:10\n//*   DOC : CSI EXECUTION SAMPLE\n//*-----------------------------------------------------------------*\n//CSICODE  EXEC PGM=IRXJCL,COND=EVEN,PARM='CSICODE'\n//SYSEXEC  DD DISP=SHR,DSN=EEIT045.LIB.FILE542.PDS\n//REPORT   DD SYSOUT=*          * PDS RECOMMENDED\n//SYSTSPRT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CSICODEO": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01F\\x008\\x01\\x03\\x06/\\x01\\x04\\x01O\\x17\\x01\\x03\\x1f\\x03+\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.70", "flags": 0, "createdate": "2003-03-03T00:00:00", "modifydate": "2004-01-14T17:01:38", "lines": 799, "newlines": 811, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - CSICODE : Minimum clean CSI utilisation code - old version  */\n/**********************************************************************/\n/* CSICODE : Uses Catalog Search Interface (CSI)                      */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 12/01/2002 - Alastair Gray - Original version            */\n/* 1.0.1   - 15/01/2002 - Alastair Gray - Added DSCRDT2 field         */\n/* 1.0.2   - 22/01/2002 - Alastair Gray - Re-ordered fields           */\n/* 1.0.3   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.0.4   - 21/06/2002 - Alastair Gray - Checked work area required  */\n/* 1.0.5   - 08/08/2002 - Alastair Gray - Updated device list         */\n/* 1.0.6   - 20/09/2002 - Alastair Gray - Updates for CSICODEV        */\n/* 1.0.7   - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.0.8   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.0.9   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This provides a clean base for further CSI development work.    */\n/*                                                                    */\n/* 2. This processes all catalogs and lists all entries.              */\n/*                                                                    */\n/* 3. The output is written to members of a PDS allocated to REPORT   */\n/*    or in batch JES sequential output is allowed.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no OMVS environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat = ' '                            /* Set catalog name              */\nflt = '**'                           /* Set the filter                */\ntyp = ' '                            /* Set entry types required      */\nct1 = ' '                            /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nmember = 'REPORT'                    /* processing ALIAS              */\nx = CSI(cat,flt,typ,ct1)             /* Call CSI procedure            */\nCall WRITE_MEMBER                    /* write-out member              */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"sysdsname\"') VOLUME(\"sysvolume\")\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\ncsiresrv = Substr(' ',1,1)           /* clear reserve character       */\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '000D'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */\ncsifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld09 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld10 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld11 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld12 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld13 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csiresrv\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length     */\n    If (csienter = '1') Then         /* entry error                   */\n     Do\n      Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n      plus = 50                      /* length for error entry        */\n     End\n    Else                             /*                               */\n     Do                              /*                               */\n      Call ENTRY                     /* Execute entry processing      */\n      plus = 46 + csitotln           /* length for normal entry       */\n     End                             /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\ne_off = off + 46                     /* get offset to entries         */\no_fld.1 = e_off+4+(C2d(csinumen)*2)  /* get first field offset        */\nl_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length      */\ne_pos = 6                            /* set offset of second field    */\nDo flds = 2 to C2d(csinumen)         /* loop through other fields     */\n prv = flds - 1                      /* set 'previous' value          */\n o_fld.flds = o_fld.prv + l_fld.prv  /* get next offset               */\n l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length     */\n e_pos = e_pos + 2                   /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ngdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */\ngdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */\ncattr    = Substr(dwork,o_fld.8,l_fld.8)   /* attribs page and swap   */\ndevtyp   = Substr(dwork,o_fld.9,l_fld.9)   /* device type             */\nvolser   = Substr(dwork,o_fld.10,l_fld.10) /* volume serial           */\nfileseq  = Substr(dwork,o_fld.11,l_fld.11) /* file sequence           */\nvsamreus = Substr(dwork,o_fld.12,l_fld.12) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /*                           */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /*                           */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_TYPE     - Process TYPE     field                              */\n/**********************************************************************/\nFLD_TYPE:                            /* TYPE     field processing   ##*/\ntype_list = ''                       /* loop through type             */\nDo z = 1 to Length(type)             /* loop through type             */\n astype = Substr(type,z,1)           /* decode type flag              */\n Select                              /* decode type flag              */\n  When (astype = 'C') Then astype = 'CLUSTER'  /*                     */\n  When (astype = 'D') Then astype = 'DATA'     /*                     */\n  When (astype = 'I') Then astype = 'INDEX'    /*                     */\n  When (astype = 'A') Then astype = 'NONVSAM'  /*                     */\n  When (astype = 'H') Then astype = 'GDS'      /*                     */\n  When (astype = 'B') Then astype = 'GDG'      /*                     */\n  When (astype = 'R') Then astype = 'PATH'     /*                     */\n  When (astype = 'G') Then astype = 'AIX'      /*                     */\n  When (astype = 'X') Then astype = 'ALIAS'    /*                     */\n  When (astype = 'U') Then astype = 'UCAT'     /*                     */\n  Otherwise                          /*                               */\n   Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n   Say '**(Error-2)* Entry type ='astype\n   astype = '@'                      /* unknown type                  */\n End                                 /*                               */\n type_list = type_list' 'astype      /*                               */\nEnd                                  /*                               */\ntype = Strip(type_list,L)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nReturn                               /* duplicates ATTR1              */\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREUSE'     /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype /= 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOWRITECHK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOIMBED'     /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREPLICAT'  /*                               */\nIf (entype /= 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\n Else                                 /*                              */\n  vsam_attr = vsam_attr' NONSPANNED'  /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                \"Blksize(1330) Recfm(F,B) New Reuse\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    x = Listdd(REPORT)               /*                               */\n    dsn = sysdsname                  /*                               */\n   End                               /*                               */\nElse                                 /*                               */\n dsn = sysdsname                     /* get dataset name from DD      */\nIf (sysvolume = '*JES**') Then       /*                               */\n Do                                  /*                               */\n  Say '**(Warning-1)* For execution in batch, it is recommended that'\n  Say '**(Warning-2)* a PDS is pre-allocated to DD name REPORT.'\n  Say '**(Warning-3)* Processing will continue with sequential output.'\n  outflag = 'JES'                    /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDD:                                     /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = Left('CATALOG',10) csicname /*                            */\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = Left(entype,10) entname dscrdt2 volsers /*                */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSICODEV": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01>\\x00X\\x01\\x02$\\x9f\\x01\\x04\\x01O\\x11\"\\x07-\\x03*\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.62", "flags": 0, "createdate": "2002-09-06T00:00:00", "modifydate": "2004-01-14T11:22:58", "lines": 1837, "newlines": 810, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - CSICODEV : VSAM detail from the CSI - LISTCATalike          */\n/**********************************************************************/\n/* CSICODEV : Uses Catalog Search Interface (CSI)                     */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 06/09/2002 - Alastair Gray - CSICODE full(ish) VSAM      */\n/* 1.0.1   - 20/09/2002 - Alastair Gray - Added DCOLLECT details      */\n/* 1.0.2   - 09/10/2002 - Alastair Gray - Minor fixes                 */\n/* 1.0.3   - 09/10/2002 - Alastair Gray - Correct minor fixes!        */\n/* 1.0.4   - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.0.5   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.0.6   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.1.5   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.1.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.1.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.1.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.1.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* This is an attempt tp provide most of the information available    */\n/* for VSAM datasets with the CSI/DCOLLECT.                           */\n/* It has been arranged to match LISTCAT output as far as possible    */\n/* although there are some fields missing (??) and others are not     */\n/* displayed in exactly the same way.                                 */\n/* What it hopefully does is provide sample code for others to        */\n/* build on if required.                                              */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nNumeric Digits 30                    /* Set numeric digits            */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no OMVS environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt   = '**'                         /* Set the filter                */\ntyp   = 'CGRX'                       /* Set entry types required VSAM */\nct1   = ' '                          /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Handle passed parameters                                           */\n/**********************************************************************/\nArg vals                             /* Get passed arguments          */\nflt = ''                             /*                               */\nDo i = 1 to Words(vals)              /* loop thru arguments           */\n testarg = Strip(Word(vals,i),B,\"'\") /* remove inverted commas        */\n Upper testarg                       /* convert to upper case         */\n Select                              /*                               */\n  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */\n   Do                                /*                               */\n    debug = Substr(testarg,7,1)      /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End                               /*                               */\n  When (testarg = '?') Then          /*                               */\n   Do                                /*                               */\n    Say \"CSICODEV requires a parameter\"\n    Say \" - CSICODEV entryname     : produces LISTCAT type output\"\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Otherwise flt = testarg            /*                               */\n End                                 /*                               */\nEnd                                  /*                               */\nIf (flt = '') Then                   /* no filter passed              */\n Do                                  /*                               */\n  Say '**(ent)** No entry provided for entryname.'\n  Signal FINISH                      /* exit exec                     */\n End                                 /*                               */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nmember = 'REPORT'                    /* processing ALIAS              */\nx = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */\nCall WRITE_MEMBER                    /* write-out member              */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"sysdsname\"') VOLUME(\"sysvolume\")\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword used        */\n Say '**(csi)***** Fullword processing selected'\nElse                                 /* check if fullword used        */\n Say '**(csi)***** Halfword processing - default'\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '0037'X                   /* init number of fields         */\ncsifld01 = Left('SECFLAGS',8)        /* security flag information     */\ncsifld02 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld03 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld04 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld05 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld06 = Left('OWNERID ',8)        /* Owner id                      */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('DSEXDT2 ',8)        /* Expiration date               */\ncsifld09 = Left('ATTR1   ',8)        /* Attributes                    */\ncsifld10 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld11 = Left('RGATTR  ',8)        /* Attributes alternate index    */\ncsifld12 = Left('ATTR2   ',8)        /* Attributes share              */\ncsifld13 = Left('OPENIND ',8)        /* open indicator                */\ncsifld14 = Left('BUFSIZE ',8)        /* Maximum buffer size           */\ncsifld15 = Left('PRIMSPAC',8)        /* Primary space allocation      */\ncsifld16 = Left('SCONSPAC',8)        /* Secondary space allocation    */\ncsifld17 = Left('SPACOPTN',8)        /* Space option flags            */\ncsifld18 = Left('XHARBADS',8)        /* Dataset High-allocated RBA    */\ncsifld19 = Left('XHURBADS',8)        /* Dataset High-used RBA         */\ncsifld20 = Left('LRECL   ',8)        /* Average Logical Record Size   */\ncsifld21 = Left('EXCPEXIT',8)        /* Exception Exit                */\ncsifld22 = Left('LTBACKDT',8)        /* Last backup date              */\ncsifld23 = Left('DATACLAS',8)        /* SMS data class                */\ncsifld24 = Left('STORCLAS',8)        /* SMS storage class             */\ncsifld25 = Left('MGMTCLAS',8)        /* SMS management class          */\ncsifld26 = Left('AMDKEY  ',8)        /* KSDS key details              */\ncsifld27 = Left('AMDCIREC',8)        /* CISIZE / MAXRECSZ             */\ncsifld28 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld29 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld30 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld31 = Left('VOLFLG  ',8)        /* Volume flags                  */\ncsifld32 = Left('NOEXTNT ',8)        /* Number of extents             */\ncsifld33 = Left('XHURBA  ',8)        /* High used RBA                 */\ncsifld34 = Left('XHARBA  ',8)        /* High allocated RBA            */\ncsifld35 = Left('XHKRBA  ',8)        /* RBA of high-key RBA           */\ncsifld36 = Left('XACIFLAG',8)        /* extended attribute flag       */\ncsifld37 = Left('PHYBLKSZ',8)        /* physical blocksize only       */\ncsifld38 = Left('NOBLKTRK',8)        /* physical blocks per track     */\ncsifld39 = Left('NOTRKAU',8)         /* tracks per allocation unit    */\ncsifld40 = Left('ITYPEXT',8)         /* type of extent                */\ncsifld41 = Left('NOBYTTRK',8)        /* number of bytes per track     */\ncsifld42 = Left('NOBYTAU',8)         /* bytes per allocation unit     */\ncsifld43 = Left('LOKEYV  ',8)        /* low key on volume             */\ncsifld44 = Left('HIKEYV  ',8)        /* high key on volume            */\ncsifld45 = Left('PASSWORD',8)        /* four 8 byte passwords         */\ncsifld46 = Left('USERAREC',8)        /* User authorisation record     */\ncsifld47 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld48 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\ncsifld49 = Left('UDATASIZ',8)        /* User data size                */\ncsifld50 = Left('LOGSTRID',8)        /* Value of LOGSTREAM parameter  */\ncsifld51 = Left('LOGPARMS',8)        /* Log parameters                */\ncsifld52 = Left('RECVTIME',8)        /* Recovery Time Local           */\ncsifld53 = Left('RECVTIMG',8)        /* Recovery Time GMT             */\ncsifld54 = Left('RLSFLAGS',8)        /* Recovery flags                */\ncsifld55 = Left('RLSBWO  ',8)        /* Value of BWO parm             */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13||csifld14||csifld15\ncsifield = csifield||csifld16||csifld17||csifld18||csifld19||csifld20\ncsifield = csifield||csifld21||csifld22||csifld23||csifld24||csifld25\ncsifield = csifield||csifld26||csifld27||csifld28||csifld29||csifld30\ncsifield = csifield||csifld31||csifld32||csifld33||csifld34||csifld35\ncsifield = csifield||csifld36||csifld37||csifld38||csifld39||csifld40\ncsifield = csifield||csifld41||csifld42||csifld43||csifld44||csifld45\ncsifield = csifield||csifld46||csifld47||csifld48||csifld49||csifld50\ncsifield = csifield||csifld51||csifld52||csifld53||csifld54||csifld55\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  If (debug = 2) Then                /*                               */\n   Do                                /*                               */\n    Say 'off=<'off'>'                /*                               */\n    Say 'entry =<'Substr(dwork,off,150)'>'\n    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'\n   End                               /*                               */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    Select                           /*                               */\n     When (csienter = '1') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     When (csiedata = '0') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* No data returned'\n       Say '**(Error-3)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     Otherwise                       /*                               */\n      Do                             /*                               */\n       If (csioptns = 'F') Then      /* check if fullword requested   */\n        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */\n       Else                          /* otherwise (default halfword)  */\n        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */\n       Call ENTRY                    /* Execute entry processing      */\n       plus = 46 + csitotln          /* length for normal entry       */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nsecflags = Substr(dwork,o_fld.1,l_fld.1)   /* security flag info      */\nentype   = Substr(dwork,o_fld.2,l_fld.2)   /* type of entry           */\nentname  = Substr(dwork,o_fld.3,l_fld.3)   /* name of entry           */\ntype     = Substr(dwork,o_fld.4,l_fld.4)   /* type of associated entry*/\nname     = Substr(dwork,o_fld.5,l_fld.5)   /* name of associated entry*/\nownerid  = Substr(dwork,o_fld.6,l_fld.6)   /* Owner id                */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* Dataset creation date   */\ndsexdt2  = Substr(dwork,o_fld.8,l_fld.8)   /* Expiration date         */\nattr1    = Substr(dwork,o_fld.9,l_fld.9)   /* Attributes              */\ncattr    = Substr(dwork,o_fld.10,l_fld.10) /* Attributes page and swap*/\nrgattr   = Substr(dwork,o_fld.11,l_fld.11) /* Attributes alternate ind*/\nattr2    = Substr(dwork,o_fld.12,l_fld.12) /* Attributes share        */\nopenind  = Substr(dwork,o_fld.13,l_fld.13) /* open indicator          */\nbufsize  = Substr(dwork,o_fld.14,l_fld.14) /* Maximum buffer size     */\nprimspac = Substr(dwork,o_fld.15,l_fld.15) /* Primary space allocation*/\nsconspac = Substr(dwork,o_fld.16,l_fld.16) /* Secondary space allocati*/\nspacoptn = Substr(dwork,o_fld.17,l_fld.17) /* Space option flags      */\nxharbads = Substr(dwork,o_fld.18,l_fld.18) /* Dataset High-allocated R*/\nxhurbads = Substr(dwork,o_fld.19,l_fld.19) /* Dataset High-used RBA   */\nlrecl    = Substr(dwork,o_fld.20,l_fld.20) /* Average logical rec size*/\nexcpexit = Substr(dwork,o_fld.21,l_fld.21) /* Exception Exit          */\nltbackdt = Substr(dwork,o_fld.22,l_fld.22) /* Last backup date        */\ndataclas = Substr(dwork,o_fld.23,l_fld.23) /* SMS data class          */\nstorclas = Substr(dwork,o_fld.24,l_fld.24) /* SMS storage class       */\nmgmtclas = Substr(dwork,o_fld.25,l_fld.25) /* SMS management class    */\namdkey   = Substr(dwork,o_fld.26,l_fld.26) /* KSDS key details        */\namdcirec = Substr(dwork,o_fld.27,l_fld.27) /* CISIZE / MAXRECSZ       */\ndevtyp   = Substr(dwork,o_fld.28,l_fld.28) /* UCB Device type         */\nvolser   = Substr(dwork,o_fld.29,l_fld.29) /* Volume serial number    */\nfileseq  = Substr(dwork,o_fld.30,l_fld.30) /* File Sequence number    */\nvolflg   = Substr(dwork,o_fld.31,l_fld.31) /* Volume flags            */\nnoextnt  = Substr(dwork,o_fld.32,l_fld.32) /* Number of extents       */\nxhurba   = Substr(dwork,o_fld.33,l_fld.33) /* High used RBA           */\nxharba   = Substr(dwork,o_fld.34,l_fld.34) /* High allocated RBA      */\nxhkrba   = Substr(dwork,o_fld.35,l_fld.35) /* RBA of high-key RBA     */\nxaciflag = Substr(dwork,o_fld.36,l_fld.36) /* extended attribute flag */\nphyblksz = Substr(dwork,o_fld.37,l_fld.37) /* physical blocksize only */\nnoblktrk = Substr(dwork,o_fld.38,l_fld.38) /* physical blocks per trk */\nnotrkau  = Substr(dwork,o_fld.39,l_fld.39) /* tracks per alloctn unit */\nitypext  = Substr(dwork,o_fld.40,l_fld.40) /* type of extent          */\nnobyttrk = Substr(dwork,o_fld.41,l_fld.41) /* no of bytes per track   */\nnobytau  = Substr(dwork,o_fld.42,l_fld.42) /* bytes per alloctn unit  */\nlokeyv   = Substr(dwork,o_fld.43,l_fld.43) /* low key on volume       */\nhikeyv   = Substr(dwork,o_fld.44,l_fld.44) /* high key on volume      */\npassword = Substr(dwork,o_fld.45,l_fld.45) /* four 8 byte passwords   */\nuserarec = Substr(dwork,o_fld.46,l_fld.46) /* user authorisation rec  */\nvsamreus = Substr(dwork,o_fld.47,l_fld.47) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.48,l_fld.48) /* VSAM dataset information*/\nudatasiz = Substr(dwork,o_fld.49,l_fld.49) /* user data size          */\nlogstrid = Substr(dwork,o_fld.50,l_fld.50) /* Value of LOGSTREAM param*/\nlogparms = Substr(dwork,o_fld.51,l_fld.51) /* Log parameters          */\nrecvtime = Substr(dwork,o_fld.52,l_fld.52) /* Recovery Time Local     */\nrecvtimg = Substr(dwork,o_fld.53,l_fld.53) /* Recovery Time GMT       */\nrlsflags = Substr(dwork,o_fld.54,l_fld.54) /* Recovery flags          */\nrlsbwo   = Substr(dwork,o_fld.55,l_fld.55) /* Value of BWO parm       */\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'SECFLAGS') > 0) Then /*                           */\n Call FLD_SECFLAGS                       /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'TYPE') > 0) Then     /*                           */\n Call FLD_TYPE                           /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'OWNERID') > 0) Then  /*                           */\n Call FLD_OWNERID                        /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\nIf (Index(csifield,'DSEXDT2') > 0) Then  /*                           */\n Call FLD_DSEXDT2                        /*                           */\nIf (Index(csifield,'ATTR1') > 0) Then    /*                           */\n Call FLD_ATTR1                          /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /* must be after ENTYPE      */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ATTR2') > 0) Then    /*                           */\n Call FLD_ATTR2                          /*                           */\nIf (Index(csifield,'BUFSIZE') > 0) Then  /*                           */\n Call FLD_BUFSIZE                        /*                           */\nIf (Index(csifield,'PRIMSPAC') > 0) Then /*                           */\n Call FLD_PRIMSPAC                       /*                           */\nIf (Index(csifield,'SCONSPAC') > 0) Then /*                           */\n Call FLD_SCONSPAC                       /*                           */\nIf (Index(csifield,'SPACOPTN') > 0) Then /*                           */\n Call FLD_SPACOPTN                       /*                           */\nIf (Index(csifield,'XHARBADS') > 0) Then /*                           */\n Call FLD_XHARBADS                       /*                           */\nIf (Index(csifield,'XHURBADS') > 0) Then /*                           */\n Call FLD_XHURBADS                       /*                           */\nIf (Index(csifield,'LRECL') > 0) Then    /*                           */\n Call FLD_LRECL                          /*                           */\nIf (Index(csifield,'EXCPEXIT') > 0) Then /*                           */\n Call FLD_EXCPEXIT                       /*                           */\nIf (Index(csifield,'LTBACKDT') > 0) Then /*                           */\n Call FLD_LTBACKDT                       /*                           */\nIf (Index(csifield,'DATACLAS') > 0) Then /*                           */\n Call FLD_DATACLAS                       /*                           */\nIf (Index(csifield,'STORCLAS') > 0) Then /*                           */\n Call FLD_STORCLAS                       /*                           */\nIf (Index(csifield,'MGMTCLAS') > 0) Then /*                           */\n Call FLD_MGMTCLAS                       /*                           */\nIf (Index(csifield,'AMDKEY') > 0) Then   /*                           */\n Call FLD_AMDKEY                         /*                           */\nIf (Index(csifield,'AMDCIREC') > 0) Then /*                           */\n Call FLD_AMDCIREC                       /*                           */\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'VOLFLG') > 0) Then   /*                           */\n Call FLD_VOLFLG                         /*                           */\nIf (Index(csifield,'NOEXTNT') > 0) Then  /*                           */\n Call FLD_NOEXTNT                        /*                           */\nIf (Index(csifield,'XHKRBA') > 0) Then   /*                           */\n Call FLD_XHKRBA                         /*                           */\nIf (Index(csifield,'XHURBA') > 0) Then   /*                           */\n Call FLD_XHURBA                         /*                           */\nIf (Index(csifield,'XHARBA') > 0) Then   /*                           */\n Call FLD_XHARBA                         /*                           */\nIf (Index(csifield,'PHYBLKSZ') > 0) Then /*                           */\n Call FLD_PHYBLKSZ                       /*                           */\nIf (Index(csifield,'NOBLKTRK') > 0) Then /*                           */\n Call FLD_NOBLKTRK                       /*                           */\nIf (Index(csifield,'NOTRKAU') > 0) Then  /*                           */\n Call FLD_NOTRKAU                        /*                           */\nIf (Index(csifield,'ITYPEXT') > 0) Then  /*                           */\n Call FLD_ITYPEXT                        /*                           */\nIf (Index(csifield,'USERAREC') > 0) Then /*                           */\n Call FLD_USERAREC                       /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /* must be after VSAMTYPE    */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'UDATASIZ') > 0) Then /*                           */\n Call FLD_UDATASIZ                       /*                           */\nIf (Index(csifield,'LOGSTRID') > 0) Then /*                           */\n Call FLD_LOGSTRID                       /*                           */\nIf (Index(csifield,'LOGPARMS') > 0) Then /*                           */\n Call FLD_LOGPARMS                       /*                           */\nIf (Index(csifield,'RLSFLAGS') > 0) Then /*                           */\n Call FLD_RLSFLAGS                       /*                           */\nIf (Index(csifield,'RLSBWO') > 0) Then   /*                           */\n Call FLD_RLSBWO                         /*                           */\nCall DCOL_PROC                           /* DCOLLECT Processing       */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_SECFLAGS - Process SECFLAGS field                              */\n/**********************************************************************/\nFLD_SECFLAGS:                        /* SECFLAGS field processing   ##*/\nIf (secflags = '80'x) Then           /*                               */\n secflags = '(YES)'                  /*                               */\nElse                                 /*                               */\n secflags = '(NO)'                   /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_TYPE     - Process TYPE     field                              */\n/**********************************************************************/\nFLD_TYPE:                            /* TYPE     field processing   ##*/\ntype_list = ''                       /* loop through type             */\nDo z = 1 to Length(type)             /* loop through type             */\n astype = Substr(type,z,1)           /* decode type flag              */\n Select                              /* decode type flag              */\n  When (astype = 'C') Then astype = 'CLUSTER'  /*                     */\n  When (astype = 'D') Then astype = 'DATA'     /*                     */\n  When (astype = 'I') Then astype = 'INDEX'    /*                     */\n  When (astype = 'A') Then astype = 'NONVSAM'  /*                     */\n  When (astype = 'H') Then astype = 'GDS'      /*                     */\n  When (astype = 'B') Then astype = 'GDG'      /*                     */\n  When (astype = 'R') Then astype = 'PATH'     /*                     */\n  When (astype = 'G') Then astype = 'AIX'      /*                     */\n  When (astype = 'X') Then astype = 'ALIAS'    /*                     */\n  When (astype = 'U') Then astype = 'UCAT'     /*                     */\n  Otherwise                          /*                               */\n   Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n   Say '**(Error-2)* Entry type ='astype' X=<'C2x(astype)'>'\n   astype = '@'                      /* unknown type                  */\n End                                 /*                               */\n type_list = type_list' 'astype      /*                               */\nEnd                                  /*                               */\ntype = Strip(type_list,L)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_OWNERID  - Process OWNERID  field                              */\n/**********************************************************************/\nFLD_OWNERID:                         /* OWNERID  field processing   ##*/\nIf (Substr(ownerid,1,2) = 'FFFF'x) Then /* If blank ownerid           */\n ownerid = '(NULL)'                  /* set to null                   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSEXDT2  - Process DSEXDT2  field                              */\n/**********************************************************************/\nFLD_DSEXDT2:                         /* DSEXDT2  field processing   ##*/\nIf (Substr(dsexdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dsexdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dsexdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  dsexdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ATTR1    - Process ATTR1    field                              */\n/**********************************************************************/\nFLD_ATTR1:                           /* ATTR1    field processing   ##*/\nattr1 = X2b(c2x(attr1))              /*                               */\nIf (Substr(attr1,1,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' SPEED'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' RECOVERY'    /*                               */\nIf (Substr(attr1,2,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' UNIQUE'      /*                               */\nIf (Substr(attr1,3,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREUSE'     /*                               */\nIf (Substr(attr1,4,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' ERASE'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOERASE'     /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ATTR2    - Process ATTR2    field                              */\n/**********************************************************************/\nFLD_ATTR2:                           /* ATTR2    field processing   ##*/\nattr2 = X2b(c2x(attr2))              /*                               */\nregion = Substr(attr2,1,2)           /*                               */\nsystem = Substr(attr2,3,2)           /*                               */\nregion = b2x(region) + 1             /*                               */\nsystem = b2x(system) + 1             /*                               */\nattr2 = region','system              /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_BUFSIZE  - Process BUFSIZE  field                              */\n/**********************************************************************/\nFLD_BUFSIZE:                         /* BUFSIZE  field processing   ##*/\nIf (Substr(bufsize,1,2) /= 'FFFF'x) Then\n Do                                  /*                               */\n  bufsize = C2d(bufsize)             /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_PRIMSPAC - Process PRIMSPAC field                              */\n/**********************************************************************/\nFLD_PRIMSPAC:                        /* PRIMSPAC field processing   ##*/\nIf (Substr(primspac,1,2) /= 'FFFF'x) Then\n Do                                  /*                               */\n  primspac = C2d(primspac)           /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_SCONSPAC - Process SCONSPAC field                              */\n/**********************************************************************/\nFLD_SCONSPAC:                        /* SCONSPAC field processing   ##*/\nIf (Substr(sconspac,1,2) /= 'FFFF'x) Then\n Do                                  /*                               */\n  sconspac = C2d(sconspac)           /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_SPACOPTN - Process SPACOPTN field                              */\n/**********************************************************************/\nFLD_SPACOPTN:                        /* SPACOPTN field processing   ##*/\nspacoptn = X2b(C2x(spacoptn))        /* show binary flags             */\nSelect                               /*                               */\n When (Substr(spacoptn,1,1) = 1) Then/*                               */\n  spacoptn = 'TRACKS'                /*                               */\n When (Substr(spacoptn,8,1) = 1) Then/*                               */\n  spacoptn = 'RECORDS'               /*                               */\n Otherwise spacoptn = 'CYLINDERS'    /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_XHARBADS - Process XHARBADS field                              */\n/**********************************************************************/\nFLD_XHARBADS:                        /* XHARBADS field processing   ##*/\nIf (Substr(xharbads,1,2) /= 'FFFF'x) Then\n xharbads = C2d(xharbads)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_XHURBADS - Process XHURBADS field                              */\n/**********************************************************************/\nFLD_XHURBADS:                        /* XHURBADS field processing   ##*/\nIf (Substr(xhurbads,1,2) /= 'FFFF'x) Then\n xhurbads = C2d(xhurbads)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_LRECL    - Process LRECL    field                              */\n/**********************************************************************/\nFLD_LRECL:                           /* LRECL    field processing   ##*/\nIf (Substr(lrecl,1,2) /= 'FFFF'x) Then\n Do                                  /*                               */\n  lrecl = C2d(lrecl)                 /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_EXCPEXIT - Process EXCPEXIT field                              */\n/**********************************************************************/\nFLD_EXCPEXIT:                        /* EXCPEXIT field processing   ##*/\nIf (Substr(excpexit,1,2) = 'FFFF'x) Then\n excpexit = '(NULL)'                 /* no value set                  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_LTBACKDT - Process LTBACKDT field                              */\n/**********************************************************************/\nFLD_LTBACKDT:                        /* LTBACKDT field processing   ##*/\nbit1 = C2d(Substr(ltbackdt,1,4))\nbit2 = C2d(Substr(ltbackdt,5,4))\nltbackdt = ltbackdt||C2x(ltbackdt)   /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DATACLAS - Process DATACLAS field                              */\n/**********************************************************************/\nFLD_DATACLAS:                        /* DATACLAS field processing   ##*/\nlength = C2d(Substr(dataclas,1,2))   /*                               */\nIf (length = 0) Then                 /* no value set                  */\n dataclas = '(NULL)'                 /* set to null                   */\nElse                                 /* set to null                   */\n dataclas = Substr(dataclas,3,length)/* get value                     */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_STORCLAS - Process STORCLAS field                              */\n/**********************************************************************/\nFLD_STORCLAS:                        /* STORCLAS field processing   ##*/\nlength = C2d(Substr(storclas,1,2))   /*                               */\nIf (length = 0) Then                 /* no value set                  */\n storclas = '(NULL)'                 /* set to null                   */\nElse                                 /* set to null                   */\n storclas = Substr(storclas,3,length)/* get value                     */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_MGMTCLAS - Process MGMTCLAS field                              */\n/**********************************************************************/\nFLD_MGMTCLAS:                        /* MGMTCLAS field processing   ##*/\nlength = C2d(Substr(mgmtclas,1,2))   /*                               */\nIf (length = 0) Then                 /* no value set                  */\n mgmtclas = '(NULL)'                 /* set to null                   */\nElse                                 /* set to null                   */\n mgmtclas = Substr(mgmtclas,3,length)/* get value                     */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_AMDKEY   - Process AMDKEY   field                              */\n/**********************************************************************/\nFLD_AMDKEY:                          /* AMDKEY   field processing   ##*/\nrkp    = C2d(Substr(amdkey,1,2))     /*                               */\nkeylen = C2d(Substr(amdkey,3,2))     /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_AMDCIREC - Process AMDCIREC field                              */\n/**********************************************************************/\nFLD_AMDCIREC:                        /* AMDCIREC field processing   ##*/\nIf (Length(amdcirec) > 0) Then\n Do\n  cisize = C2d(Substr(amdcirec,1,4)) /* CISIZE                        */\n  maxrcsz = C2d(Substr(amdcirec,5,4))/* Maximum record size           */\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLFLG   - Process VOLFLG   field                              */\n/**********************************************************************/\nFLD_VOLFLG:                          /* VOLFLG   field processing   ##*/\nbuild = ''\nDo f_pos = 1 To Length(volflg) By 1  /*                               */\n flag = X2b(C2x(Substr(volflg,f_pos,1)))\n Select\n  When (Substr(flag,1,1) = '1') Then\n   flg_t = 'PRIME'\n  When (Substr(flag,2,1) = '1') Then\n   flg_t = 'CANDIDATE'\n  When (Substr(flag,3,1) = '1') Then\n   flg_t = 'OVERFLOW'\n  Otherwise flg_t = flag\n End\n build = build||flg_t||' '\nEnd                                  /*                               */\nvolflg = build                       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_NOEXTNT  - Process NOEXTNT  field                              */\n/**********************************************************************/\nFLD_NOEXTNT:                         /* NOEXTNT  field processing   ##*/\nbuild = ''\nDo e_pos = 1 To Length(noextnt) By 1 /*                               */\n build = build||C2d(Substr(noextnt,e_pos,1))||' '\nEnd                                  /*                               */\nnoextnt = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_XHKRBA   - Process XHKRBA   field                              */\n/**********************************************************************/\nFLD_XHKRBA:                          /* XHKRBA   field processing   ##*/\nIf (Substr(xhkrba,1,2) /= 'FFFF'x) Then\n Do\n  build = ''\n  Do k_pos = 1 To Length(xhkrba) By 8 /*                              */\n   build = build||C2d(Substr(xhkrba,k_pos,8))||' '\n  End                                /*                               */\n  xhkrba = build                     /*                               */\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_XHURBA   - Process XHURBA   field                              */\n/**********************************************************************/\nFLD_XHURBA:                          /* XHURBA   field processing   ##*/\nIf (Substr(xhurba,1,2) /= 'FFFF'x) Then\n Do\n  build = ''\n  Do u_pos = 1 To Length(xhurba) By 8 /*                              */\n   build = build||C2d(Substr(xhurba,u_pos,8))||' '\n  End                                /*                               */\n  xhurba = build                     /*                               */\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_XHARBA   - Process XHARBA   field                              */\n/**********************************************************************/\nFLD_XHARBA:                          /* XHARBA   field processing   ##*/\nIf (Substr(xharba,1,2) /= 'FFFF'x) Then\n Do\n  build = ''\n  Do a_pos = 1 To Length(xharba) By 8 /*                              */\n   build = build||C2d(Substr(xharba,a_pos,8))||' '\n  End                                /*                               */\n  xharba = build                     /*                               */\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_PHYBLKSZ - Process PHYBLKSZ field                              */\n/**********************************************************************/\nFLD_PHYBLKSZ:                        /* PHYBLKSZ field processing   ##*/\nIf (Substr(phyblksz,1,2) /= 'FFFF'x) Then\n Do\n  build = ''\n  Do a_pos = 1 To Length(phyblksz) By 4\n   build = build||C2d(Substr(phyblksz,a_pos,4))||' '\n  End                                /*                               */\n  phyblksz = build                   /*                               */\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_NOBLKTRK - Process NOBLKTRK field                              */\n/**********************************************************************/\nFLD_NOBLKTRK:                        /* NOBLKTRK field processing   ##*/\nIf (Substr(noblktrk,1,2) /= 'FFFF'x) Then\n Do\n  build = ''\n  Do a_pos = 1 To Length(noblktrk) By 2\n   build = build||C2d(Substr(noblktrk,a_pos,2))||' '\n  End                                /*                               */\n  noblktrk = build                   /*                               */\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_NOTRKAU  - Process NOTRKAU  field                              */\n/**********************************************************************/\nFLD_NOTRKAU:                         /* NOTRKAU  field processing   ##*/\nIf (Substr(notrkau,1,2) /= 'FFFF'x) Then\n Do\n  build = ''\n  Do a_pos = 1 To Length(notrkau) By 2\n   build = build||C2d(Substr(notrkau,a_pos,2))||' '\n  End                                /*                               */\n  notrkau = build                    /*                               */\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ITYPEXT  - Process ITYPEXT  field                              */\n/**********************************************************************/\nFLD_ITYPEXT:                         /* ITYPEXT  field processing   ##*/\nIf (Substr(itypext,1,2) /= 'FFFF'x) Then\n Do\n  build = ''\n  Do i_pos = 1 To Length(itypext) By 1 /*                             */\n   build = build||\"X'\"||C2x(Substr(itypext,i_pos,1))||\"' \"\n  End                                /*                               */\n  itypext = build                    /*                               */\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_USERAREC - Process USERAREC field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_USERAREC:                        /* USERAREC field processing   ##*/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nReturn                               /* duplicates ATTR1              */\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREUSE'     /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_attr = ''                       /*                               */\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype /= 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOWRITECHK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOIMBED'     /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nElse                                 /*                               */\n vsam_attr = vsam_attr' NOREPLICAT'  /*                               */\nIf (entype /= 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\n Else                                 /*                              */\n  vsam_attr = vsam_attr' NONSPANNED'  /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_RLSBWO   - Process RLSBWO   field                              */\n/**********************************************************************/\nFLD_RLSBWO:                          /* RLSBWO   field processing   ##*/\nIf (C2x(rlsbwo) = 'FF') Then         /*                               */\n rlsbwo = '(NULL)'                   /* no value set                  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_UDATASIZ - Process UDATASIZ field                              */\n/**********************************************************************/\nFLD_UDATASIZ:                        /* UDATASIZ field processing   ##*/\nIf (Substr(udatasiz,1,2) = 'FFFF'x) Then /* If blank ownerid          */\n udatasiz = '(NULL)'                 /* set to null                   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_LOGSTRID - Process LOGSTRID field                              */\n/**********************************************************************/\nFLD_LOGSTRID:                        /* LOGSTRID field processing   ##*/\nIf (Substr(logstrid,1,2) = 'FFFF'x) Then\n logstrid = '(NULL)'                 /* no value set                  */\n recvtime = '0000000000000000'x      /*                               */\n recvtimg = '0000000000000000'x      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_LOGPARMS - Process LOGPARMS field                              */\n/**********************************************************************/\nFLD_LOGPARMS:                        /* LOGPARMS field processing   ##*/\nSelect                               /*                               */\n When (C2x(logparms) = '01') Then    /*                               */\n  logparms = '(NONE)'                /*                               */\n When (C2x(logparms) = '02') Then    /*                               */\n  logparms = '(UNDO)'                /*                               */\n When (C2x(logparms) = '03') Then    /*                               */\n  logparms = '(ALL)'                 /*                               */\n Otherwise logparms = '(NULL)'       /* no value set                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_RLSFLAGS - Process RLSFLAGS field                              */\n/**********************************************************************/\nFLD_RLSFLAGS:                        /* RLSFLAGS field processing   ##*/\nrlsflags = X2b(C2x(rlsflags))        /* convert to binary             */\nIf (rlsflags = '11111111') Then      /*                               */\n Do                                  /*                               */\n  rlsinuse = '(NO)'                  /*                               */\n  rlsrecov = '(NO)'                  /*                               */\n  rlsquies = '(NO)'                  /*                               */\n End                                 /*                               */\nElse                                 /*                               */\n Do                                  /*                               */\n  rlsinuse = '(YES)'                 /*                               */\n  rlsquies = '(NO)'                  /*                               */\n  If (Substr(rlsflags,5,1) = '1') Then /* check indicator             */\n   rlsrecov = '(YES)'                /*                               */\n  Else                               /*                               */\n   rlsrecov = '(NO)'                 /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DCOL_PROC    - Process DCOLLECT details                            */\n/**********************************************************************/\nDCOL_PROC:                           /* DCOLLECT Processing         ##*/\nIf (Strip(volser,t) /= '') Then\n Do\n  \"NewStack\"\n  \"Alloc Fi(SYSPRINT) Da('NULLFILE') Shr Reu\"\n  \"Alloc Fi(AMSDUMP) Da('NULLFILE') Shr Reu\"\n  \"Alloc Fi(SYSIN) New Lrecl(80) Reuse\"\n  Queue \" DCOLLECT VOL(\"volser\") OUTFILE(OUTDS)\"\n  Queue \"\"\n  \"ExecIO * DiskW SYSIN (Finis)\"\n  \"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(340) Recfm(V B) Reu\"\n  \"Call *(IDCAMS)\"\n  \"ExecIO * DiskR OUTDS (Stem dcol. Finis)\"\n  \"Free Fi(OUTDS)\"\n  Do d = 1 to dcol.0\n   dcddsnam = Strip(Substr(dcol.d,25,44),T)\n   dcurctyp = Substr(dcol.d,4,2)\n   If (dcddsnam = entname) Then\n    Do\n     If (dcurctyp = '00'X||'D') Then\n      Do\n       dcdacct  = Strip(Substr(dcol.d,289,32),T)\n       If (Substr(dcdacct,1,2) = '0000'X) Then\n        dcdacct = '(NULL)'\n      End\n     If (dcurctyp = '00'X||'A') Then\n      Do\n       dcanlr   = C2d(Substr(dcol.d,125,4))\n       dcadlr   = C2d(Substr(dcol.d,129,4))\n       dcainr   = C2d(Substr(dcol.d,133,4))\n       dcaupr   = C2d(Substr(dcol.d,137,4))\n       dcartr   = C2d(Substr(dcol.d,141,4))\n       dcaasp   = C2d(Substr(dcol.d,145,4))\n       dcacis   = C2d(Substr(dcol.d,149,4))\n       dcacas   = C2d(Substr(dcol.d,153,4))\n       dcaexc   = C2d(Substr(dcol.d,157,4))\n       dcacaci  = C2d(Substr(dcol.d,185,4))\n      End\n    End\n  End\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                \"Blksize(1330) Recfm(F,B) New Reuse\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    x = Listdd(REPORT)               /*                               */\n    dsn = sysdsname                  /*                               */\n   End                               /*                               */\nElse                                 /*                               */\n dsn = sysdsname                     /* get dataset name from DD      */\nIf (sysvolume = '*JES**') Then       /*                               */\n Do                                  /*                               */\n  Say '**(Warning-1)* For execution in batch, it is recommended that'\n  Say '**(Warning-2)* a PDS is pre-allocated to DD name REPORT.'\n  Say '**(Warning-3)* Processing will continue with sequential output.'\n  outflag = 'JES'                    /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDD:                                     /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  Select\n   When (entype = 'CLUSTER') Then\n    Do\n     l_cnt = l_cnt + 1\n     l.l_cnt = ' CLUSTER ------- 'entname\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      IN-CAT --- 'csicname\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      HISTORY'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        DATASET-OWNER-'Right(ownerid,10,'-')\n     l.l_cnt = l.l_cnt||'     CREATION--------'dscrdt2\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        RELEASE-------'Right('???',10,'-')\n     l.l_cnt = l.l_cnt||'     EXPIRATION------'dsexdt2\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      SMSDATA'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        STORAGECLASS -'Right(storclas,10,'-')\n     l.l_cnt = l.l_cnt||'     MANAGEMENTCLASS'Right(mgmtclas,9,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        DATACLASS ----'Right(dataclas,10,'-')\n     l.l_cnt = l.l_cnt||'     LBACKUP ---'ltbackdt\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        BWO STATUS----'Right('???',10,'-')\n     l.l_cnt = l.l_cnt||'     BWO TIMESTAMP---'Right('???',10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        BWO-----------'Right(rlsbwo,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      RLSDATA'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        LOG ----------'Right(logparms,12,'-')\n     l.l_cnt = l.l_cnt||'   RECOVERY REQUIRED -'Right(rlsrecov,5,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        VSAM QUIESCED 'Right(rlsquies,11,'-')\n     l.l_cnt = l.l_cnt||'    RLS IN USE --------'Right(rlsinuse,5,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = ' '\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        LOGSTREAMID---'Right(logstrid,32,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = \"           RECOVERY TIMESTAMP LOCAL-----X'\"C2x(recvtime)\"'\"\n     l_cnt = l_cnt + 1\n     l.l_cnt = \"           RECOVERY TIMESTAMP GMT-------X'\"C2x(recvtimg)\"'\"\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      PROTECTION-PSWD-'Right('???',10,'-')\n     l.l_cnt = l.l_cnt||'     RACF----------'Right(secflags,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      ASSOCIATIONS'\n     Do z = 1 To Words(type)\n      l_cnt = l_cnt + 1\n      l.l_cnt = \"           \"Left(Word(type,z),9,'-')||Word(name,z)\n     End\n     l_cnt = l_cnt + 1\n     l.l_cnt = ' '\n    End\n   When (entype = 'DATA') Then\n    Do\n     l_cnt = l_cnt + 1\n     l.l_cnt = '    DATA ------- 'entname\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      IN-CAT --- 'csicname\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      HISTORY'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        DATASET-OWNER-'Right(ownerid,10,'-')\n     l.l_cnt = l.l_cnt||'     CREATION--------'dscrdt2\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        RELEASE-------'Right('???',10,'-')\n     l.l_cnt = l.l_cnt||'     EXPIRATION------'dsexdt2\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        ACCOUNT-INFO--'Right(dcdacct,39,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      PROTECTION-PSWD-'Right('',10,'-')\n     l.l_cnt = l.l_cnt||'     RACF----------'Right(secflags,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      ASSOCIATIONS'\n     Do z = 1 To Words(type)\n      l_cnt = l_cnt + 1\n      l.l_cnt = \"           \"Left(Word(type,z),9,'-')||Word(name,z)\n     End\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      ATTRIBUTES'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        KEYLEN--------'Right(keylen,10,'-')\n     l.l_cnt = l.l_cnt||'     AVGLRECL------'Right(lrecl,10,'-')\n     l.l_cnt = l.l_cnt||'     BUFSPACE------'Right(bufsize,10,'-')\n     l.l_cnt = l.l_cnt||'     CISIZE--------'Right(cisize,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        RKP-----------'Right(rkp,10,'-')\n     l.l_cnt = l.l_cnt||'     MAXLRECL------'Right(maxrcsz,10,'-')\n     l.l_cnt = l.l_cnt||'     EXCPEXIT------'Right(excpexit,10,'-')\n     l.l_cnt = l.l_cnt||'     CI/CA---------'Right(dcacaci,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        SHROPTNS('attr2') 'vsam_attr\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      STATISTICS'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-TOTAL-----'Right(dcanlr,10,'-')\n     l.l_cnt = l.l_cnt||'     SPLITS-CI-----'Right(dcacis,10,'-')\n     l.l_cnt = l.l_cnt||'     EXCPS---------'Right(dcaexc,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-DELETED---'Right(dcadlr,10,'-')\n     l.l_cnt = l.l_cnt||'     SPLITS-CA-----'Right(dcacas,10,'-')\n                           bit = Right(Strip(noextnt,T),10,'-')\n     l.l_cnt = l.l_cnt||'     EXTENTS-------'bit\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-INSERTED--'Right(dcainr,10,'-')\n     l.l_cnt = l.l_cnt||'     FREESPACE-%CI-'Right('??',10,'-')\n     l.l_cnt = l.l_cnt||'     SYSTEM-TIMESTAMP:'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-UPDATED---'Right(dcaupr,10,'-')\n     l.l_cnt = l.l_cnt||'     FREESPACE-%CA-'Right('??',10,'-')\n     l.l_cnt = l.l_cnt||'          '\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-RETRIEVED-'Right(dcartr,10,'-')\n     l.l_cnt = l.l_cnt||'     FREESPC-------'Right(dcaasp,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      ALLOCATION'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        SPACE-TYPE----'Right(spacoptn,10,'-')\n     l.l_cnt = l.l_cnt||'     HI-A-RBA------'Right(xharbads,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        SPACE-PRI-----'Right(primspac,10,'-')\n     l.l_cnt = l.l_cnt||'     HI-U-RBA------'Right(xhurbads,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        SPACE-SEC-----'Right(sconspac,10,'-')\n     Do v = 1 to Words(volsers)\n      l_cnt = l_cnt + 1\n      l.l_cnt = '      VOLUME'\n      l_cnt = l_cnt + 1\n      l.l_cnt = '        VOLSER--------'Right(Word(volsers,v),10,'-')\n                               bit = Right(Word(phyblksz,v),10,'-')\n      l.l_cnt = l.l_cnt||'     PHYREC-SIZE---'bit\n      l.l_cnt = l.l_cnt||'     HI-A-RBA------'Right(Word(xharba,v),10,'-')\n      l.l_cnt = l.l_cnt||'     EXTENT-NUMBER-'Right(Word(noextnt,v),10,'-')\n      l_cnt = l_cnt + 1\n      l.l_cnt = '        DEVTYP------'Right(Word(devices,v),12,'-')\n                               bit = Right(Word(noblktrk,v),10,'-')\n      l.l_cnt = l.l_cnt||'     PHYRECS/TRK---'bit\n      l.l_cnt = l.l_cnt||'     HI-U-RBA------'Right(Word(xhurba,v),10,'-')\n      l.l_cnt = l.l_cnt||'     EXTENT-TYPE---'Right(Word(itypext,v),10,'-')\n      l_cnt = l_cnt + 1\n      l.l_cnt = '        VOLFLAG-----'Right(Word(volflg,v),12,'-')\n                               bit = Right(Word(notrkau,v),10,'-')\n      l.l_cnt = l.l_cnt||'     TRACKS/CA-----'bit\n      l_cnt = l_cnt + 1\n      l.l_cnt = '        EXTENTS:'\n      Do e = 1 to Word(noextnt,v)\n       l_cnt = l_cnt + 1\n       l.l_cnt = '        LOW-CCHH----'Right('???',12,'-')\n       l.l_cnt = l.l_cnt||'     LOW-RBA-------'Right('???',10,'-')\n       l.l_cnt = l.l_cnt||'     TRACKS--------'Right('???',10,'-')\n       l_cnt = l_cnt + 1\n       l.l_cnt = '        HIGH-CCHH---'Right('???',12,'-')\n       l.l_cnt = l.l_cnt||'     HIGH-RBA------'Right('???',10,'-')\n      End\n     End\n     l_cnt = l_cnt + 1\n     l.l_cnt = ' '\n    End\n   When (entype = 'INDEX') Then\n    Do\n     l_cnt = l_cnt + 1\n     l.l_cnt = '    INDEX ------ 'entname\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      IN-CAT --- 'csicname\n     l_cnt = l_cnt + 1\n     l.l_cnt = ' '\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      HISTORY'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        DATASET-OWNER-'Right(ownerid,10,'-')\n     l.l_cnt = l.l_cnt||'     CREATION--------'dscrdt2\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        RELEASE-------'Right('???',10,'-')\n     l.l_cnt = l.l_cnt||'     EXPIRATION------'dsexdt2\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      PROTECTION-PSWD-'Right('',10,'-')\n     l.l_cnt = l.l_cnt||'     RACF----------'Right(secflags,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      ASSOCIATIONS'\n     Do z = 1 To Words(type)\n      l_cnt = l_cnt + 1\n      l.l_cnt = \"           \"Left(Word(type,z),9,'-')||Word(name,z)\n     End\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      ATTRIBUTES'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        KEYLEN--------'Right(keylen,10,'-')\n     l.l_cnt = l.l_cnt||'     AVGLRECL------'Right(lrecl,10,'-')\n     l.l_cnt = l.l_cnt||'     BUFSPACE------'Right(bufsize,10,'-')\n     l.l_cnt = l.l_cnt||'     CISIZE--------'Right(cisize,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        RKP-----------'Right(rkp,10,'-')\n     l.l_cnt = l.l_cnt||'     MAXLRECL------'Right(maxrcsz,10,'-')\n     l.l_cnt = l.l_cnt||'     EXCPEXIT------'Right(excpexit,10,'-')\n     l.l_cnt = l.l_cnt||'     CI/CA---------'Right(dcacaci,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        SHROPTNS('attr2') 'vsam_attr\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      STATISTICS'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-TOTAL-----'Right(dcanlr,10,'-')\n     l.l_cnt = l.l_cnt||'     SPLITS-CI-----'Right(dcacis,10,'-')\n     l.l_cnt = l.l_cnt||'     EXCPS---------'Right(dcaexc,10,'-')\n     l.l_cnt = l.l_cnt||'     INDEX:'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-DELETED---'Right(dcadlr,10,'-')\n     l.l_cnt = l.l_cnt||'     SPLITS-CA-----'Right(dcacas,10,'-')\n                           bit = Right(Strip(noextnt,T),10,'-')\n     l.l_cnt = l.l_cnt||'     EXTENTS-------'bit\n     l.l_cnt = l.l_cnt||'     LEVELS--------'Right('??',10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-INSERTED--'Right(dcainr,10,'-')\n     l.l_cnt = l.l_cnt||'     FREESPACE-%CI-'Right('??',10,'-')\n     l.l_cnt = l.l_cnt||'     SYSTEM-TIMESTAMP:'\n     l.l_cnt = l.l_cnt||'     ENTRIES/SECT--'Right('??',10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-UPDATED---'Right(dcaupr,10,'-')\n     l.l_cnt = l.l_cnt||'     FREESPACE-%CA-'Right('??',10,'-')\n     l.l_cnt = l.l_cnt||'                   'Right('',10)\n     l.l_cnt = l.l_cnt||'     SEQ-SET-RBA---'Right('??',10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        REC-RETRIEVED-'Right(dcartr,10,'-')\n     l.l_cnt = l.l_cnt||'     FREESPC-------'Right(dcaasp,10,'-')\n     l.l_cnt = l.l_cnt||'                   'Right('',10)\n     l.l_cnt = l.l_cnt||'     HI-LEVEL-RBA--'Right('??',10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '      ALLOCATION'\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        SPACE-TYPE----'Right(spacoptn,10,'-')\n     l.l_cnt = l.l_cnt||'     HI-A-RBA------'Right(xharbads,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        SPACE-PRI-----'Right(primspac,10,'-')\n     l.l_cnt = l.l_cnt||'     HI-U-RBA------'Right(xhurbads,10,'-')\n     l_cnt = l_cnt + 1\n     l.l_cnt = '        SPACE-SEC-----'Right(sconspac,10,'-')\n     Do v = 1 to Words(volsers)\n      l_cnt = l_cnt + 1\n      l.l_cnt = '      VOLUME'\n      l_cnt = l_cnt + 1\n      l.l_cnt = '        VOLSER--------'Right(Word(volsers,v),10,'-')\n                               bit = Right(Word(phyblksz,v),10,'-')\n      l.l_cnt = l.l_cnt||'     PHYREC-SIZE---'bit\n      l.l_cnt = l.l_cnt||'     HI-A-RBA------'Right(Word(xharba,v),10,'-')\n      l.l_cnt = l.l_cnt||'     EXTENT-NUMBER-'Right(Word(noextnt,v),10,'-')\n      l_cnt = l_cnt + 1\n      l.l_cnt = '        DEVTYP------'Right(Word(devices,v),12,'-')\n                               bit = Right(Word(noblktrk,v),10,'-')\n      l.l_cnt = l.l_cnt||'     PHYRECS/TRK---'bit\n      l.l_cnt = l.l_cnt||'     HI-U-RBA------'Right(Word(xhurba,v),10,'-')\n      l.l_cnt = l.l_cnt||'     EXTENT-TYPE---'Right(Word(itypext,v),10,'-')\n      l_cnt = l_cnt + 1\n      l.l_cnt = '        VOLFLAG-----'Right(Word(volflg,v),12,'-')\n                               bit = Right(Word(notrkau,v),10,'-')\n      l.l_cnt = l.l_cnt||'     TRACKS/CA-----'bit\n      l_cnt = l_cnt + 1\n      l.l_cnt = '        EXTENTS:'\n      Do e = 1 to Word(noextnt,v)\n       l_cnt = l_cnt + 1\n       l.l_cnt = '        LOW-CCHH----'Right('???',12,'-')\n       l.l_cnt = l.l_cnt||'     LOW-RBA-------'Right('???',10,'-')\n       l.l_cnt = l.l_cnt||'     TRACKS--------'Right('???',10,'-')\n       l_cnt = l_cnt + 1\n       l.l_cnt = '        HIGH-CCHH---'Right('???',12,'-')\n       l.l_cnt = l.l_cnt||'     HIGH-RBA------'Right('???',10,'-')\n      End\n     End\n     l_cnt = l_cnt + 1\n     l.l_cnt = ' '\n    End\n   Otherwise\n    Do\n     l_cnt = l_cnt + 1\n     l.l_cnt = 'Entry type not yet supported by CSICODEV:'\n     l_cnt = l_cnt + 1\n     l.l_cnt = 'Entry='entname' Type='entype\n     l_cnt = l_cnt + 1\n     l.l_cnt = ' '\n    End\n  End\n End\nReturn\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSITAPE$": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x002\\x01\\x02\"\\x0f\\x01\\x022o\\x10H\\x00\\x0f\\x00\\x12\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-08-08T00:00:00", "modifydate": "2002-11-22T10:48:32", "lines": 15, "newlines": 18, "modlines": 0, "user": "EEIT045"}, "text": "//EEIT045  JOB (1,,N#X),'CSITAPE$ EEIT045.MYC',\n//         CLASS=L,MSGCLASS=X,MSGLEVEL=(1,1),\n//         REGION=8M,NOTIFY=&SYSUID,COND=(4,LT)\n//*USERDATA=(CSITAPE$ EEIT045.MYCBT.CODE)\n//*-----------------------------------------------------------------*\n//*   LIB : EEIT045.MYCBT.CODE(CSITAPE$)\n//*  NOTE : 14/01/02 12:53:10\n//*   DOC : CSI TAPE DATASET EXTRACTION JCL\n//*-----------------------------------------------------------------*\n//CSITAPES EXEC PGM=IRXJCL,COND=EVEN,PARM='CSITAPES'\n//SYSEXEC  DD DISP=SHR,DSN=EEIT045.MYCBT.CODE\n//REPORT   DD SYSOUT=*          * PDS RECOMMENDED\n//SYSTSPRT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CSITAPES": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01.\\x00B\\x01\\x02\\x17\\x1f\\x01\\x04\\x01O\\x11\\x19\\x02u\\x01\\x8f\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.46", "flags": 0, "createdate": "2002-06-20T00:00:00", "modifydate": "2004-01-14T11:19:42", "lines": 629, "newlines": 399, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - CSITAPES : Stripped CSICODE just for Tape datasets          */\n/**********************************************************************/\n/* CSITAPES : Uses Catalog Search Interface (CSI)                     */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 20/06/2002 - Alastair Gray - Original version            */\n/* 1.0.1   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.0.2   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.0.3   - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.0.4   - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.1.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.1.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.1.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.1.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.1.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.1.5   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.1.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.1.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.1.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.1.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This processes all catalogs and lists all tape entries.         */\n/*                                                                    */\n/* 2. The output is written to members of a PDS allocated to REPORT   */\n/*    or in batch JES sequential output is allowed.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no OMVS environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\nArg vals                             /* Get passed arguments          */\nargnum = 0                           /*                               */\nDo i = 1 to Words(vals)              /* loop thru arguments           */\n testarg = Strip(Word(vals,i),B,\"'\") /* remove inverted commas        */\n Upper testarg                       /* convert to upper case         */\n Select                              /*                               */\n  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */\n   Do                                /*                               */\n    debug = Substr(testarg,7,1)      /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End                               /*                               */\n  When (testarg = '?') Then          /*                               */\n   Do                                /*                               */\n    Say \"CSITAPES has no normal external parms\"  /*                   */\n    Say \" To use simply specify 'CSITAPES' it will identify and use the\"\n    Say \" master catalog.\"           /*                               */\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Otherwise NOP                      /*                               */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt   = '**'                         /* Set the filter                */\ntyp   = 'AH'                         /* Set entry types required      */\nct1   = ' '                          /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nmember = 'REPORT'                    /* processing ALIAS              */\nx = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */\nCall WRITE_MEMBER                    /* write-out member              */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"sysdsname\"') VOLUME(\"sysvolume\")\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword used        */\n Say '**(csi)***** Fullword processing selected'\nElse                                 /* check if fullword used        */\n Say '**(csi)***** Halfword processing - default'\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '0006'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld06 = Left('VOLSER  ',8)        /* Volume serial number          */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  If (debug = 2) Then                /*                               */\n   Do                                /*                               */\n    Say 'off=<'off'>'                /*                               */\n    Say 'entry =<'Substr(dwork,off,150)'>'\n    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'\n   End                               /*                               */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    Select                           /*                               */\n     When (csienter = '1') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     When (csiedata = '0') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* No data returned'\n       Say '**(Error-3)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     Otherwise                       /*                               */\n      Do                             /*                               */\n       If (csioptns = 'F') Then      /* check if fullword requested   */\n        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */\n       Else                          /* otherwise (default halfword)  */\n        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */\n       Call ENTRY                    /* Execute entry processing      */\n       plus = 46 + csitotln          /* length for normal entry       */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ndevtyp   = Substr(dwork,o_fld.5,l_fld.5)   /* device type             */\nvolser   = Substr(dwork,o_fld.6,l_fld.6)   /* volume serial           */\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nIf (Substr(volser,1,6) = 'MIGRAT') Then  /* check if HSM migrat tape  */\n Return                                  /*                           */\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (dev_class /= 'TAPE') Then            /* reject non-tapes          */\n Return                                  /* save processing           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP - Process DEVTYP field to translate data                */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP field processing     ##*/\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_class  = Substr(device,3,1)       /* get class byte                */\n Select                              /*                               */\n  When (d_class = '80'x) Then dev_class = 'TAPE' /* Tape device       */\n  When (d_class = '20'x) Then dev_class = 'DASD' /* DASD device       */\n  Otherwise NOP                      /*                               */\n End                                 /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                \"Blksize(1330) Recfm(F,B) New Reuse\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    x = Listdd(REPORT)               /*                               */\n    dsn = sysdsname                  /*                               */\n   End                               /*                               */\nElse                                 /*                               */\n dsn = sysdsname                     /* get dataset name from DD      */\nIf (sysvolume = '*JES**') Then       /*                               */\n Do                                  /*                               */\n  Say '**(Warning-1)* For execution in batch, it is recommended that'\n  Say '**(Warning-2)* a PDS is pre-allocated to DD name REPORT.'\n  Say '**(Warning-3)* Processing will continue with sequential output.'\n  outflag = 'JES'                    /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDD:                                     /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = Left('CATALOG',10) csicname /*                            */\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  If (Substr(volser,1,6) = 'MIGRAT') Then/* check if HSM migrat tape  */\n   Return                            /*                               */\n  If (dev_class /= 'TAPE') Then      /* reject non-tapes              */\n   Return                            /* save processing               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = Left(entype,10) entname volsers /*                        */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDSCAN": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00G\\x00\\x99\\x02/\\x01\\x03\\x06/\\x10(\\x00I\\x00?\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-01-22T00:00:00", "modifydate": "2003-03-03T10:28:47", "lines": 73, "newlines": 63, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - DDSCAN : Scan a selected DDNAME in JCL for a member         */\n/**********************************************************************/\n/* Written - A.J.Gray - 22/01/1999                                    */\n/*         - A.J.Gray - 09/08/2002 - added to CBT                     */\n/**********************************************************************/\n/* Invoke with \"DDSCAN memname\" on the command line and then place    */\n/* the cursor on the DDNAME to be searched.                           */\n/*                                                                    */\n/* This exec does the easy bit by extracting the dataset names and    */\n/* allocating to ddname DDSCAN before hading over to the ISRFIND      */\n/* utility for the 'legwork'.                                         */\n/**********************************************************************/\n/* The Following test that this is a valid ISREDIT environment.       */\n/**********************************************************************/\noptions = ''                           /*                             */\nAddress ISPEXEC                        /*                             */\n\"ISREDIT Macro (scan)\"                 /* Test ISREDIT                */\nmrc = rc                               /*                             */\nzerralrm = 'NO'                        /* set message alarm to no     */\nzerrhm   = 'ISR00003'                  /* set help screen to default  */\nx = Msg(off)                           /*  disable messages           */\nx = Prompt(off)                        /*  disable prompting          */\nIf (mrc > 0) Then                      /* test if edit environment    */\n Do                                    /*                             */\n  ZedSmsg = 'Edit Macro Only'          /*                             */\n  ZedLmsg = '\"DDSCAN\" can only be run as an edit macro' /*            */\n  \"SetMsg Msg(ISRZ001)\"                /*                             */\n  Signal FINISH                        /*                             */\n End                                   /*                             */\n/**********************************************************************/\n\"IsrEdit (dsname) = Dataset\"           /* get dataset name            */\n\"IsrEdit (memname) = Member\"           /* get member name             */\n\"IsrEdit (top,bot) = Display_Lines\"    /* get number of lines in dsn  */\n\"IsrEdit (Row,Col) = Cursor\"           /* Get location of cursor      */\n/**********************************************************************/\n/* Allocate and read member being edited                              */\nAddress TSO \"Alloc Fi(MEMIN) Da('\"dsname\"(\"memname\")') Shr Reu\"\nAddress TSO \"ExecIO * DiskR MEMIN (Finis Stem line.)\"\nAddress TSO \"Free Fi(MEMIN)\"\n/**********************************************************************/\ndcnt = 0                               /* set dataset counter         */\ndsnlist = \"\"                           /* initialise dsnlist          */\nDo loop = row to line.0                /* roop thru member lines      */\n If (Substr(line.loop,1,3) /= '//*') &, /*                            */\n    (Substr(line.loop,1,3) /= '// ') &, /*                            */\n    (loop > row) Then                  /*                             */\n  Leave                                /*                             */\n If (Substr(line.loop,1,3) = '//*') Then /*                           */\n  Iterate                              /*                             */\n dpos = Index(line.loop,\"DSN=\")        /*                             */\n If (dpos > 0) Then                    /*                             */\n  Do                                   /*                             */\n   line = Substr(line.loop,dpos+4)     /*                             */\n   line = Translate(line,'',''',:;/)') /*                             */\n   Parse Upper Var line dsn .          /*                             */\n   If (Sysdsn(\"'\"dsn\"'\") <> 'OK') Then /*                             */\n    Say \"'\"dsn\"' not in catalog, not scanning.\" /*                    */\n   Else                                /*                             */\n    Do                                 /*                             */\n     dcnt = dcnt + 1                   /*                             */\n     dsn.dcnt = dsn                    /*                             */\n     dsnlist = dsnlist||\" '\"||dsn||\"'\" /*                             */\n    End                                /*                             */\n  End                                  /*                             */\nEnd                                    /*                             */\n/**********************************************************************/\nAddress TSO                            /*                             */\n\"Alloc Fi(DDSCAN) Da(\"dsnlist\") SHR REU\" /*                           */\n\"ISRFIND DD(DDSCAN) M(\"scan\") ISPF\"    /*                             */\n\"Free Fi(DDSCAN)\"                      /*                             */\n/**********************************************************************/\nFINISH:                                /*                             */\nExit 0                                 /* Exit exec                   */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFINES": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00W\\x01\\x17\\x00_\\x01\\x17\\x00_\\x14E\\x01\\xd7\\x01\\xd7\\x00\\x00\\xd1\\xd4\\xc3\\xd2\\xd6\\xe6\\xd5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2017-01-05T00:00:00", "modifydate": "2017-01-05T14:45:57", "lines": 471, "newlines": 471, "modlines": 0, "user": "JMCKOWN"}, "text": "/* REXX PROGRAM TO GENERATE IDCAMS DEFINE */\nTRACE E\nDEFINED = \"\"\nRESTARTS = 0\nDO FOREVER;\n   EXITCODE = @MAIN()\n   IF EXITCODE = 0 THEN LEAVE\n   RESTARTS = RESTARTS+1\n   IF RESTARTS > 3 THEN LEAVE\n   SAY '************ RESTART ***********'\n   ADDRESS ATTACH \"IDCAMS\"\n   IF RC <> 0 THEN LEAVE\nEND;\nEXIT EXITCODE\n@MAIN:PROCEDURE\nTYPE.1 = 'CLUSTER'\nTYPE.2 = 'PATH'\nTYPE.3 = 'AIX'\nBLANKS = COPIES(' ',80)\nDEFCL.= ''\nREF.0 = 0\nDEF.='*NO*'\nOFFSET6 = '$'\nDO FOREVER\n   \"EXECIO 1 DISKR IDCAMS\"\n   IF RC <> 0 THEN LEAVE\n   PARSE PULL RECORD\n   TEST = LEFT(RECORD,7)\n   IF TEST = '1IDCAMS' THEN ITERATE;\n   RECORD=SUBSTR(RECORD,2); /* STRIP OUT THE CARRIAGE */\n   OFFSET = VERIFY(RECORD,' '); /* FIND LOCATION OF 1ST NON-BLANK */\n   IF OFFSET = 0 THEN ITERATE; /* IGNORE BLANK LINE */\n   CALL @NODASH;\n   TOCALL = 'CALL @OFFSET'OFFSET\n   CALL @DOCALL\nEND;\nCALL @DUMPIT\n\"EXECIO 0 DISKR IDCAMS (FINIS\"\n\"EXECIO 0 DISKW DEFINES (FINIS\"\nEXITCODE = 0\nDO I = 1 TO REF.0\n   A = REF.I\n   IF DEF.A = '*YES*' THEN ITERATE\n   CARD = \" LISTC ENT('\"A\"') OUTFILE(IDCAMSO) ALL\"\n   PUSH CARD\n   \"EXECIO 1 DISKW SYSIN\"\n   SAY 'NOT FOUND \"'A'\"'\n   EXITCODE=8\nEND\nIF EXITCODE <> 0 THEN \"EXECIO 0 DISKW SYSIN(FINIS\"\nRETURN EXITCODE;\n@DOCALL:\n   SIGNAL ON SYNTAX\n   INTERPRET TOCALL\n   SIGNAL OFF SYNTAX\n   RETURN;\n@OFFSET1:\n@OFFSET4:\n   SIGNAL OFF SYNTAX\n  PARSE VAR RECORD VARNAME VARDATA\n  VARNAME = LEFT(VARNAME,LENGTH(VARNAME)-1)\n  TOCALL = 'CALL @'VARNAME\n  SIGNAL @DOCALL\n  RETURN;\n@CLUSTER:\n@AIX:\n@PATH:\n   SIGNAL OFF SYNTAX\n  CALL @DUMPIT;\n  DROP DEFCL.\n  DEFCL.=''\n  DEFCL.$TYPE = VARNAME\n  DEFCL.VARNAME = VARDATA\n  COMP = $COMP\n  OFFSET6 = '$'\n  RETURN;\n@DATA:\n@INDEX:\n   SIGNAL OFF SYNTAX\n  COMP = SPACE(VARNAME,0);\n  DEFCL.COMP = SPACE(VARDATA,0);\n  RETURN;\n@OFFSET6:\n   SIGNAL OFF SYNTAX\n  PARSE VAR RECORD FUNCTION REST\n  OFFSET6 = SPACE(FUNCTION,0)\n  RETURN;\n@OFFSET8:\n   SIGNAL OFF SYNTAX\n  DO WHILE LENGTH(RECORD) > 0\n     PARSE VAR RECORD VARNAME RECORD\n     VARNAME = SPACE(VARNAME,0)\n     IF RIGHT(VARNAME,1) = '^'\n     THEN DO;\n          PARSE VAR RECORD VALUE RECORD\n          VALUE = SPACE(VALUE,0)\n          VARNAME = LEFT(VARNAME,LENGTH(VARNAME)-1)\n          C = DEFCL.COMP.VARNAME VALUE\n          DEFCL.COMP.VARNAME = STRIP(C)\n          END;\n     ELSE DEFCL.COMP.$KEYWORD = DEFCL.COMP.$KEYWORD VARNAME' '\n  END;\n  RETURN;\n@NODASH:\n   SIGNAL OFF SYNTAX\n  TRECORD = RECORD\n  TEMP1 = ''\n  FDASH = POS('--',TRECORD)\n  DO WHILE FDASH <> 0\n     TEMP1 = TEMP1 LEFT(TRECORD,FDASH-1)\n     TEMP1 = STRIP(TEMP1,'T')'^ '\n     TRECORD = SUBSTR(TRECORD,FDASH)\n     FDASH = VERIFY(TRECORD,'-'); /* FIND NON-DASH */\n     IF FDASH =0 THEN ITERATE;\n     TRECORD = SUBSTR(TRECORD,FDASH)\n     FDASH = POS('--',TRECORD)\n  END;\n  TEMP1 = TEMP1 TRECORD\n  RECORD = SPACE(TEMP1,1)\nRETURN;\n@DUMP:\n   SIGNAL OFF SYNTAX\n  ARG NAME\n  VALUE = VALUE(NAME)\nRETURN;\n@DUMPIT:\n   SIGNAL OFF SYNTAX\n  CARD = ' '\n  CALL @OUTCARD\n  A=DEFCL.$TYPE\n  A=DEFCL.A\n  DEF.A = '*YES*'\n  DO I=1 TO 3\n     A = TYPE.I\n     B = STRIP(DEFCL.$COMP.A)\n     DO WHILE LENGTH(B) > 0\n        PARSE VAR B DATA B\n        B=STRIP(B)\n        I = REF.0+1\n        REF.0 = I\n        REF.I = DATA\n     END\n  END\n  TOCALL = 'CALL @1'DEFCL.$TYPE\n  SIGNAL @DOCALL\nRETURN;\n@1PATH:\n   SIGNAL OFF SYNTAX\n  PATH = 'PATH'\n  CARD = 'DEL 'DEFCL.PATH' PATH'\n  CALL @OUTCARD\n  CARD = 'DEF PATH(-'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,6)'NAME('DEFCL.PATH') -'\n  CALL @OUTCARD\n  AIX='AIX'\n  CARD = LEFT(BLANKS,6)'PATHENTRY('DEFCL.$COMP.AIX') -'\n  CALL @OUTCARD\n  IF POS(' NOUPDATE ',DEFCL.$COMP.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'NOUPDATE -'\n       CALL @OUTCARD\n       END\n  ELSE CARD = LEFT(BLANKS,4)')'\n  CALL @OUTCARD\nRETURN;\n@1CLUSTER:\n   SIGNAL OFF SYNTAX\n  CLUSTER = 'CLUSTER'\n  DATA = 'DATA'\n  INDEX = 'INDEX'\n  BUFSPACE='BUFSPACE'\n  VOLSER='VOLSER'\n  DEFCL.DATA.$KEYWORD = DEFCL.DATA.$KEYWORD' '\n  DEFCL.INDEX.$KEYWORD = DEFCL.INDEX.$KEYWORD' '\n  CARD = 'DEL 'DEFCL.CLUSTER' CLUSTER'\n  CALL @OUTCARD\n  CARD = 'DEF CLUSTER( -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,6)'NAME('DEFCL.CLUSTER') -'\n  CALL @OUTCARD\n  IF DEFCL.DATA.VOLSER = DEFCL.INDEX.VOLSER\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'VOLUMES('DEFCL.DATA.VOLSER') -'\n       CALL @OUTCARD\n       DEFCL.DATA.VOLSER = ''\n       DEFCL.INDEX.VOLSER = ''\n       END;\n  CARD = LEFT(BLANKS,6)'BUFFERSPACE('DEFCL.DATA.BUFSPACE') -'\n  CALL @OUTCARD\n  TEMP1 ='FREESPACE-%CI'\n  TEMP2 ='FREESPACE-%CA'\n  TEMP1 = SPACE(DEFCL.DATA.TEMP1,0)\n  TEMP2 = SPACE(DEFCL.DATA.TEMP2,0)\n  IF TEMP1 <> 0 | TEMP2 <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'FREESPACE('TEMP1 TEMP2') -'\n       CALL @OUTCARD;\n       END;\n  RKP = 'RKP'\n  KEYLEN = 'KEYLEN'\n  IF KEYLEN <> 0\n  THEN DO;\n       A = SPACE(DEFCL.DATA.KEYLEN,0)\n       B = SPACE(DEFCL.DATA.RKP,0)\n       CARD = LEFT(BLANKS,6)'KEYS('A B') -'\n       CALL @OUTCARD;\n       END;\n  MAXLRECL = 'MAXLRECL'\n  AVGLRECL = 'AVGLRECL'\n  A = SPACE(DEFCL.DATA.AVGLRECL,0)\n  B = SPACE(DEFCL.DATA.MAXLRECL,0)\n  CARD = LEFT(BLANKS,6)'RECORDSIZE('A B') -'\n  CALL @OUTCARD\n  PARSE VAR DEFCL.DATA.$KEYWORD . 'SHROPTNS(' SHRX ')' .\n  CARD = LEFT(BLANKS,6)'SHAREOPTIONS('SHRX') -'\n  CALL @OUTCARD\n  IF POS(' REPLICATE ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'/*REPLICATE */ -'\n       CALL @OUTCARD;\n       END;\n  IF POS(' IMBED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'/*IMBED*/ -'\n       CALL @OUTCARD;\n       END;\n  IF POS(' NONINDEXED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'NONINDEXED -'\n       CALL @OUTCARD;\n       END;\n  IF POS(' NUMBERED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'NUMBERED -'\n       CALL @OUTCARD\n       END\n  IF POS(' ORDERED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'ORDERED -'\n       CALL @OUTCARD\n       END\n  IF POS(' REUSE ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'REUSE -'\n       CALL @OUTCARD\n       END\n  IF POS(' SPANNED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'SPANNED -'\n       CALL @OUTCARD\n       END\n  IF POS(' SPEED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'SPEED -'\n       CALL @OUTCARD\n       END\n  IF POS(' WRITECHK ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'WRITECHECK -'\n       CALL @OUTCARD\n       END\n  CARD = LEFT(BLANKS,4)') -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,4)'DATA( -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,6)'NAME('DEFCL.DATA') -'\n  CALL @OUTCARD\n  IF DEFCL.DATA.VOLSER <> ''\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'VOLUMES('DEFCL.DATA.VOLSER') -'\n       CALL @OUTCARD\n       END;\n  CISIZE='CISIZE'\n  CARD = LEFT(BLANKS,6)'CONTROLINTERVALSIZE('DEFCL.DATA.CISIZE') -'\n  CALL @OUTCARD\n  SPRI='SPACE-PRI'\n  SSEC='SPACE-SEC'\n  STYPE='SPACE-TYPE'\n  A = SPACE(DEFCL.DATA.SPRI,0)\n  B = SPACE(DEFCL.DATA.SSEC,0)\n  C = SPACE(DEFCL.DATA.STYPE,0)\n  CARD = LEFT(BLANKS,6) || C'('A B') -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,4)')'\n  IF POS(' INDEXED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN CARD = CARD'-'\n  ELSE DO;\n       CALL @OUTCARD\n       RETURN;\n       END;\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,4)'INDEX( -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,6)'NAME('DEFCL.INDEX')-'\n  CALL @OUTCARD\n  IF DEFCL.INDEX.VOLSER <> ''\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'VOLUMES('DEFCL.INDEX.VOLSER') -'\n       CALL @OUTCARD\n       END;\n  CISIZE='CISIZE'\n  CARD = LEFT(BLANKS,6)'CONTROLINTERVALSIZE('DEFCL.INDEX.CISIZE') -'\n  CALL @OUTCARD\n  SPRI='SPACE-PRI'\n  SSEC='SPACE-SEC'\n  STYPE='SPACE-TYPE'\n  A = SPACE(DEFCL.INDEX.SPRI,0)\n  B = SPACE(DEFCL.INDEX.SSEC,0)\n  C = SPACE(DEFCL.INDEX.STYPE,0)\n  CARD = LEFT(BLANKS,6) || C'('A B') -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,4)')'\n  CALL @OUTCARD\nRETURN;\n@1AIX:\n   SIGNAL OFF SYNTAX\n  CLUSTER = 'CLUSTER'\n  AIX = 'AIX'\n  DATA = 'DATA'\n  INDEX = 'INDEX'\n  BUFSPACE='BUFSPACE'\n  VOLSER='VOLSER'\n  DEFCL.DATA.$KEYWORD = DEFCL.DATA.$KEYWORD' '\n  DEFCL.INDEX.$KEYWORD = DEFCL.INDEX.$KEYWORD' '\n  CARD = 'DEL 'DEFCL.AIX' AIX'\n  CALL @OUTCARD\n  CARD = 'DEF ALTERNATEINDEX (-'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,6)'NAME('DEFCL.AIX') -'\n  CALL @OUTCARD\n  SIGNAL ON NOVALUE\n  CARD = LEFT(BLANKS,6)'RELATE('DEFCL.$COMP.CLUSTER') -'\n  SIGNAL OFF NOVALUE\n  CALL @OUTCARD\n  IF DEFCL.DATA.VOLSER = DEFCL.INDEX.VOLSER\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'VOLUMES('DEFCL.DATA.VOLSER') -'\n       CALL @OUTCARD\n       DEFCL.DATA.VOLSER = ''\n       DEFCL.INDEX.VOLSER = ''\n       END;\n  CARD = LEFT(BLANKS,6)'BUFFERSPACE('DEFCL.DATA.BUFSPACE') -'\n  CALL @OUTCARD\n  TEMP1 ='FREESPACE-%CI'\n  TEMP2 ='FREESPACE-%CA'\n  TEMP1 = DEFCL.DATA.TEMP1; TEMP2 = DEFCL.DATA.TEMP2\n  IF TEMP1 <> 0 | TEMP2 <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'FREESPACE('TEMP1 TEMP2') -'\n       CALL @OUTCARD;\n       END;\n  AXRKP = 'AXRKP'\n  KEYLEN = 'KEYLEN'\n  IF KEYLEN <> 0\n  THEN DO;\n       A = SPACE(DEFCL.DATA.KEYLEN,0)\n       B = SPACE(DEFCL.DATA.AXRKP,0)\n       CARD = LEFT(BLANKS,6)'KEYS('A B') -'\n       CALL @OUTCARD;\n       END;\n  MAXLRECL = 'MAXLRECL'\n  AVGLRECL = 'AVGLRECL'\n  A = SPACE(DEFCL.DATA.AVGLRECL,0)\n  B = SPACE(DEFCL.DATA.MAXLRECL,0)\n  CARD = LEFT(BLANKS,6)'RECORDSIZE('A B') -'\n  CALL @OUTCARD\n  IF POS(' ERASE ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'ERASE -'\n       CALL @OUTCARD;\n       END;\n  IF POS(' IMBED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'/*IMBED*/ -'\n       CALL @OUTCARD;\n       END;\n  IF POS(' ORDERED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'ORDERED -'\n       CALL @OUTCARD\n       END\n  IF POS(' REPLICATE ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'/*REPLICATE*/ -'\n       CALL @OUTCARD\n       END\n  IF POS(' REUSE ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'REUSE -'\n       CALL @OUTCARD\n       END\n  IF POS(' SPEED ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'SPEED -'\n       CALL @OUTCARD\n       END\n  IF POS(' UNIQUEKEY ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'UNIQUEKEY -'\n       CALL @OUTCARD\n       END\n  IF POS(' NOUPGRADE ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'NOUPGRADE -'\n       CALL @OUTCARD\n       END\n  IF POS(' WRITECHK ',DEFCL.DATA.$KEYWORD) <> 0\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'WRITECHECK -'\n       CALL @OUTCARD\n       END\n  CARD = LEFT(BLANKS,4)') -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,4)'DATA( -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,6)'NAME('DEFCL.DATA') -'\n  CALL @OUTCARD\n  IF DEFCL.DATA.VOLSER <> ''\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'VOLUMES('DEFCL.DATA.VOLSER') -'\n       CALL @OUTCARD\n       END;\n  CISIZE='CISIZE'\n  CARD = LEFT(BLANKS,6)'CONTROLINTERVALSIZE('DEFCL.DATA.CISIZE') -'\n  CALL @OUTCARD\n  SPRI='SPACE-PRI'\n  SSEC='SPACE-SEC'\n  STYPE='SPACE-TYPE'\n  A = SPACE(DEFCL.DATA.SPRI,0)\n  B = SPACE(DEFCL.DATA.SSEC,0)\n  C = SPACE(DEFCL.DATA.STYPE,0)\n  CARD = LEFT(BLANKS,6) || C'('A B') -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,4)') -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,4)'INDEX( -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,6)'NAME('DEFCL.INDEX')-'\n  CALL @OUTCARD\n  IF DEFCL.INDEX.VOLSER <> ''\n  THEN DO;\n       CARD = LEFT(BLANKS,6)'VOLUMES('DEFCL.INDEX.VOLSER') -'\n       CALL @OUTCARD\n       END;\n  CISIZE='CISIZE'\n  CARD = LEFT(BLANKS,6)'CONTROLINTERVALSIZE('DEFCL.INDEX.CISIZE') -'\n  CALL @OUTCARD\n  SPRI='SPACE-PRI'\n  SSEC='SPACE-SEC'\n  STYPE='SPACE-TYPE'\n  A = SPACE(DEFCL.INDEX.SPRI,0)\n  B = SPACE(DEFCL.INDEX.SSEC,0)\n  C = SPACE(DEFCL.INDEX.STYPE,0)\n  CARD = LEFT(BLANKS,6) || C'('A B') -'\n  CALL @OUTCARD\n  CARD = LEFT(BLANKS,4)')'\n  CALL @OUTCARD\nRETURN;\n@OUTCARD:\n   SIGNAL OFF SYNTAX\n  PUSH CARD\n  \"EXECIO 1 DISKW DEFINES\"\nRETURN;\nNOVALUE:\n  SAY SIGL\n  SAY SOURCELINE(SIGL)\n  SAY ERRORTEXT(RC)\n  EXIT\nSYNTAX:\n  RETURN;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DEFINE01": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x003\\x01\\x14%\\x9f\\x01\\x17\\x00_\\x14W\\x00\\x14\\x00\\x11\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2014-09-16T00:00:00", "modifydate": "2017-01-05T14:57:33", "lines": 20, "newlines": 17, "modlines": 0, "user": "JCL"}, "text": "//SBGOLOBA  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//LISTC EXEC PGM=IDCAMS\n//SYSPRINT DD DSN=&&SYSPRINT,UNIT=SYSALLDA,\n// DISP=(NEW,PASS),SPACE=(TRK,(5,1))\n//*\n//SYSIN DD *\n LISTC ENT('CHSY227.ARCH.VSAM') ALL\n/*\n//*\n//TMP EXEC PGM=IKJEFT01,\n// PARM='%DEFINES'\n//SYSPROC  DD DISP=SHR,DSN=SBGOLOB.CBT493.FILE542\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//DEFINES  DD SYSOUT=*\n//IDCAMS   DD DISP=(SHR,PASS),DSN=*.LISTC.SYSPRINT\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HFSSTAT": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00S\\x01\\x00\\x03O\\x01\\x03\\x06/\\x10(\\x00-\\x013\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2000-02-03T00:00:00", "modifydate": "2003-03-03T10:28:53", "lines": 45, "newlines": 307, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - HFSSTAT  : Get size/space stats for an HFS file             */\n/**********************************************************************/\n/* Written - A.J.Gray : 04/02/2000 - only works if cyls/trks          */\n/*                                   requires sufficient workspace    */\n/*                      11/02/2002 - Comment s/lightly for CBT        */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nArg dsn                              /* get dsname                    */\ndsn = Strip(dsn,B,\"'\")               /* clean it up                   */\n/**********************************************************************/\nAddress ISPEXEC                      /*                               */\ndsname = ''                          /*                               */\n\"LmdInit ListID(LID) Level(\"dsn\")\"   /* initialise for detail         */\n\"LmdList ListID(\"lid\") Dataset(DSNAME) Option(LIST) Stats(YES)\"\n\"LmdFree ListID(\"lid\")\"              /* free i tup                    */\nIf (zdldsorg /= 'HFS') Then          /* check if HFS                  */\n Do                                  /*                               */\n  Say \"Not an HFS file\"              /*  not an HFS file              */\n  Signal FINISH                      /*                               */\n End                                 /*                               */\ntemp = \"T\"Right(Time(L),6)           /* build a temp dataset name     */\nAddress TSO                          /*                               */\n\"Alloc Fi(\"temp\") Da('\"userid()\".\"temp\"') \",\n                  \"New Reu Delete Like('\"dsn\"') Unit(3390) \",\n                  \"Dsorg(PS) LRECL(80) Recfm(F B) Blksize(80)\"\nx = ListDSI(temp FILE)               /* get temp file details         */\n\"Free  Fi(\"temp\")\"                   /*                               */\nIf (sysunits = 'CYLINDER') Then factor = 15 /* check if cylinders     */\nElse factor = 1                      /* otherwise tracks              */\nexspace  = (zdlext - 1) * (sysseconds * factor) /* get extent detail  */\ncalcprim = (zdlsize - exspace) / factor /* get primary detail         */\nzdlsize  = zdlsize / factor          /* get size                      */\nSay \"Volume     = \"zdlvol            /*                               */\nSay \"Device     = \"zdldev            /*                               */\nSay \"Size       = \"Left(Strip(zdlsize,B),8)\" \"zdlspacu\nSay \"Primary    = \"Left(calcprim,8)\" \"zdlspacu\nSay \"Secondary  = \"Left(sysseconds,8)\" \"zdlspacu\nSay \"%used      = \"Strip(zdlused,B)  /*                               */\nSay \"Extents    = \"Strip(zdlext,B)   /*                               */\nSay \"Creation   = \"zdlcdate          /*                               */\nSay \"Expiration = \"zdledate          /*                               */\nSay \"Referenced = \"zdlrdate          /*                               */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /*                               */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IVPJOB": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00@\\x01\\x16%\\x1f\\x01\\x16%\\x1f\\x11X\\x00\\xa0\\x00\\xa0\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-07T00:00:00", "modifydate": "2016-09-07T11:58:40", "lines": 160, "newlines": 160, "modlines": 0, "user": "JOARMC"}, "text": "//         JOB ?,RCNVTCAT,CLASS=?,MSGCLASS=?,\n//         NOTIFY=&SYSUID\n//*\n// SET REXXLIB=       DSN Containing REXX program\n// SET UNIXID=&SYSUID My userid, for UNIX test\n// SET UNIXID2=       Another userid, for UNIX test\n// SET UCAT=          User Catalog to process\n//*\n//STEP0001 EXEC PGM=IRXJCL,\n//         REGION=0M,\n//         PARM='RCNVTCAT &UCAT'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0002 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0003 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT -o /u/&UNIXID./junk1'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0004 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT -O //junk &UCAT '\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0005 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT -O //JUNK4'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0006 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT -O //''&SYSUID..JUNK5'' '\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0007 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT -o ~/junk1'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0008 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT -o ~&UNIXID./junk1'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0009 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT -o ~&UNIXID2./junk1'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0010 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT -o ~/junk2'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0011 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT OUTPUT(JUNK6)'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0012 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT OUTPUT(''&SYSUID..JUNK7'')'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0013 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT OUTPUT(''~/junk3'')'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//STEP0014 EXEC PGM=IKJEFT01,\n//         REGION=0M,\n//         PARM='%RCNVTCAT &UCAT OUTPUT(~/junk3)'\n//SYSTSPRT DD   SYSOUT=*\n//SYSTSIN  DD   *\n/*\n//SYSEXEC  DD   DISP=SHR,DSN=&REXXLIB\n//*\n//* Do some UNIX prep work.\n//*\n// SET A='cp \"//''''&REXXLIB.(RCNVTCAT)'''' ~/bin/rcnvtcat &&'\n// SET B='chmod 755 ~/bin/rcnvtcat'\n//STEP0015 EXEC PGM=BPXBATCH,\n//         REGION=0M\n//         PARM='SH mkdir -p ~/bin;&A &B'\n//STDOUT   DD   SYSOUT=*\n//STDERR   DD   SYSOUT=*\n//STDIN    DD   PATH='/dev/null'\n//STDPARM  DD   *\nSH rm ~/junk1/*.txt;./bin/rcnvtcat &UCAT -o junk1;\n//*\n//STEP0016 EXEC PGM=BPXBATCH,\n//         REGION=0M\n//         PARM='SH mkdir -p ~/junk1'\n//STDOUT   DD   SYSOUT=*\n//STDERR   DD   SYSOUT=*\n//STDIN    DD   PATH='/dev/null'\n//STDPARM  DD   *\nSH rm ~/junk1/*.txt;./bin/rcnvtcat &UCAT -o junk1;\n//*\n//STEP0017 EXEC PGM=BPXBATCH,\n//         REGION=0M,\n//         PARM='SH rm ~/junk1/*.txt;./bin/rcnvtcat -o junk1;'\n//STDOUT   DD   SYSOUT=*\n//STDERR   DD   SYSOUT=*\n//STDIN    DD   PATH='/dev/null'\n//STDPARM  DD   *\nSH rm ~/junk1/*.txt;./bin/rcnvtcat &UCAT -o junk1;\n//*\n//STEP0018 EXEC PGM=BPXBATCH,\n//         REGION=0M,\n//         PARM='SH ./bin/rcnvtcat -?'\n//STDOUT   DD   SYSOUT=*\n//STDERR   DD   SYSOUT=*\n//STDIN    DD   PATH='/dev/null'\n//STDPARM  DD   *\nSH ./bin/rcnvtcat -?\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IVPOUTPT": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00$\\x01\\x16%\\x1f\\x01\\x16%\\x1f\\x11Y\\x03\\x9c\\x03\\x9c\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-09-07T00:00:00", "modifydate": "2016-09-07T11:59:24", "lines": 924, "newlines": 924, "modlines": 0, "user": "JOARMC"}, "text": "1                   J E S 2  J O B  L O G  --  S Y S T E M  S 0 W 1  --  N O D E\n0\n 09.18.10 JOB00810 ---- WEDNESDAY, 07 SEP 2016 ----\n 09.18.10 JOB00810  IRR010I  USERID JOARMC   IS ASSIGNED TO THIS JOB.\n 09.18.11 JOB00810  ICH70001I JOARMC   LAST ACCESS AT 09:16:37 ON WEDNESDAY, SEP\n 09.18.11 JOB00810  $HASP373 JOARMCSC STARTED - INIT 1    - CLASS K        - SYS\n 09.18.11 JOB00810  -                                      -----TIMINGS (MINS.)-\n 09.18.11 JOB00810  -STEPNAME PROCSTEP    RC   EXCP   CONN       TCB       SRB\n 09.18.11 JOB00810  -STEP0001             16     74      2       .00       .00\n 09.18.16 JOB00810  -STEP0002             00    554     40       .00       .00\n 09.18.19 JOB00810  -STEP0003             00    611      3       .00       .00\n 09.18.22 JOB00810  -STEP0004             00    550     36       .00       .00\n 09.18.26 JOB00810  -STEP0005             00    551     36       .00       .00\n 09.18.30 JOB00810  -STEP0006             00    553     36       .00       .00\n 09.18.34 JOB00810  -STEP0007             00    612      3       .00       .00\n 09.18.38 JOB00810  -STEP0008             00    610      3       .00       .00\n 09.18.40 JOB00810  -STEP0009             08     94      2       .00       .00\n 09.18.42 JOB00810  -STEP0010             08     94      3       .00       .00\n 09.18.46 JOB00810  -STEP0011             00    550     36       .00       .00\n 09.18.50 JOB00810  -STEP0012             00    553     36       .00       .00\n 09.18.54 JOB00810  -STEP0013             00    600      2       .00       .00\n 09.18.56 JOB00810  -STEP0014             08     94      3       .00       .00\n 09.18.56 JOB00810  +BPXM079I BPXBATCH PROCESSING IS USING THE STDPARM DD RATHER\n 09.18.56 JOB00810  +BPXM079I BPXBATCH PROCESSING IS USING THE STDPARM DD RATHER\n 09.18.58 JOB00810  -STEP0015             00     86      2       .00       .00\n 09.18.58 JOB00810  +BPXM079I BPXBATCH PROCESSING IS USING THE STDPARM DD RATHER\n 09.18.58 JOB00810  +BPXM079I BPXBATCH PROCESSING IS USING THE STDPARM DD RATHER\n 09.18.58 JOB00810  -STEP0016             00     79      2       .00       .00\n 09.18.58 JOB00810  -JOARMCSC ENDED.  NAME-MCKOWN               TOTAL TCB CPU TI\n 09.18.58 JOB00810  $HASP395 JOARMCSC ENDED - RC=0016\n0------ JES2 JOB STATISTICS ------\n-  07 SEP 2016 JOB EXECUTION DATE\n-          133 CARDS READ\n-          958 SYSOUT PRINT RECORDS\n-            0 SYSOUT PUNCH RECORDS\n-           83 SYSOUT SPOOL KBYTES\n-         0.78 MINUTES EXECUTION TIME\n         1 //JOARMCSC JOB (H00000I),MCKOWN,CLASS=K,MSGCLASS=H,\n           // NOTIFY=&SYSUID\n           //*\n           IEFC653I SUBSTITUTION JCL - (H00000I),MCKOWN,CLASS=K,MSGCLASS=H,NOTIF\n         2 //STEP0001 EXEC PGM=IRXJCL,\n           //         REGION=0M,\n           //         PARM='RCNVTCAT MVSUSER.USERCAT'\n         3 //SYSTSPRT DD   SYSOUT=*\n         4 //SYSTSIN  DD   *\n         5 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n         6 //STEP0002 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT'\n         7 //SYSTSPRT DD   SYSOUT=*\n         8 //SYSTSIN  DD   *\n         9 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        10 //STEP0003 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT -o /u/joarmc/junk1'\n        11 //SYSTSPRT DD   SYSOUT=*\n        12 //SYSTSIN  DD   *\n        13 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        14 //STEP0004 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT -O //junk MVSUSER.USERCAT '\n        15 //SYSTSPRT DD   SYSOUT=*\n        16 //SYSTSIN  DD   *\n        17 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        18 //STEP0005 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT -O //JUNK4'\n        19 //SYSTSPRT DD   SYSOUT=*\n        20 //SYSTSIN  DD   *\n        21 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        22 //STEP0006 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT -O //''JOARMC.JUNK5'' '\n        23 //SYSTSPRT DD   SYSOUT=*\n        24 //SYSTSIN  DD   *\n        25 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        26 //STEP0007 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT -o ~/junk1'\n        27 //SYSTSPRT DD   SYSOUT=*\n        28 //SYSTSIN  DD   *\n        29 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        30 //STEP0008 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT -o ~joarmc/junk1'\n        31 //SYSTSPRT DD   SYSOUT=*\n        32 //SYSTSIN  DD   *\n        33 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        34 //STEP0009 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT -o ~rhoten/junk1'\n        35 //SYSTSPRT DD   SYSOUT=*\n        36 //SYSTSIN  DD   *\n        37 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        38 //STEP0010 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT -o ~/junk2'\n        39 //SYSTSPRT DD   SYSOUT=*\n        40 //SYSTSIN  DD   *\n        41 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        42 //STEP0011 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT OUTPUT(JUNK6)'\n        43 //SYSTSPRT DD   SYSOUT=*\n        44 //SYSTSIN  DD   *\n        45 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        46 //STEP0012 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT OUTPUT(''JOARMC.JUNK7'')'\n        47 //SYSTSPRT DD   SYSOUT=*\n        48 //SYSTSIN  DD   *\n        49 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        50 //STEP0013 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT OUTPUT(''~/junk3'')'\n        51 //SYSTSPRT DD   SYSOUT=*\n        52 //SYSTSIN  DD   *\n        53 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        54 //STEP0014 EXEC PGM=IKJEFT01,\n           //         REGION=0M,\n           //         PARM='%RCNVTCAT MVSUSER.USERCAT OUTPUT(~/junk3)'\n        55 //SYSTSPRT DD   SYSOUT=*\n        56 //SYSTSIN  DD   *\n        57 //SYSEXEC  DD   DISP=SHR,DSN=JOARMC.REXX.EXEC\n           //*\n        58 //STEP0015 EXEC PGM=BPXBATCH,\n           //         REGION=0M,\n           //         PARM='SH rm ~/junk1/*.txt;./bin/rcnvtcat -o junk1;'\n        59 //STDOUT   DD   SYSOUT=*\n        60 //STDERR   DD   SYSOUT=*\n        61 //STDIN    DD   PATH='/dev/null'\n        62 //STDPARM  DD   *\n           //*\n        63 //STEP0016 EXEC PGM=BPXBATCH,\n           //         REGION=0M,\n           //         PARM='SH ./bin/rcnvtcat -?'\n        64 //STDOUT   DD   SYSOUT=*\n        65 //STDERR   DD   SYSOUT=*\n        66 //STDIN    DD   PATH='/dev/null'\n        67 //STDPARM  DD   *\n           //*\n ICH70001I JOARMC   LAST ACCESS AT 09:16:37 ON WEDNESDAY, SEPTEMBER 7, 2016\n IEF236I ALLOC. FOR JOARMCSC STEP0001\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF142I JOARMCSC STEP0001 - STEP WAS EXECUTED - COND CODE 0016\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000117.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000101.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF373I STEP/STEP0001/START 2016251.0918\n IEF032I STEP/STEP0001/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.00 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:    40K  SYS:   272K  EXT:      848K  SYS:    10896K\n         ATB- REAL:                  3104K  SLOTS:                     0K\n              VIRT- ALLOC:      12M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0002\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IGD100I 0D30 ALLOCATED TO DDNAME REPORT   DATACLAS (        )\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF142I JOARMCSC STEP0002 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000118.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000102.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF285I   JOARMC.RCNVTCAT.REPORT.T9598                 CATALOGED\n IEF285I   VOL SER NOS= VPWRKA.\n IEF373I STEP/STEP0002/START 2016251.0918\n IEF032I STEP/STEP0002/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.24 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   396K  EXT:     3188K  SYS:    11256K\n         ATB- REAL:                  3116K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0003\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/ALIAS.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/NONVSAM.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/SYS1.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/IMPORT.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/GDG.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/MISC.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/RECAT.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/SYSCTLG.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/REPORT.txt)\n IEF142I JOARMCSC STEP0003 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000119.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000103.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF373I STEP/STEP0003/START 2016251.0918\n IEF032I STEP/STEP0003/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.24 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   372K  EXT:     4268K  SYS:    11288K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0004\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF237I 0D30 ALLOCATED TO REPORT\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF142I JOARMCSC STEP0004 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000120.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000104.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF285I   JOARMC.JUNK                                  KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF373I STEP/STEP0004/START 2016251.0918\n IEF032I STEP/STEP0004/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.23 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   396K  EXT:     4220K  SYS:    11220K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0005\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF237I 0D30 ALLOCATED TO REPORT\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF142I JOARMCSC STEP0005 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000121.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000105.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF285I   JOARMC.JUNK4                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF373I STEP/STEP0005/START 2016251.0918\n IEF032I STEP/STEP0005/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.23 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   396K  EXT:     4220K  SYS:    11220K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0006\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF237I 0D30 ALLOCATED TO REPORT\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF142I JOARMCSC STEP0006 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000122.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000106.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF285I   JOARMC.JUNK5                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF373I STEP/STEP0006/START 2016251.0918\n IEF032I STEP/STEP0006/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.24 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   396K  EXT:     4220K  SYS:    11224K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0007\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/ALIAS.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/NONVSAM.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/SYS1.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/IMPORT.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/GDG.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/MISC.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/RECAT.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/SYSCTLG.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/REPORT.txt)\n IEF142I JOARMCSC STEP0007 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000123.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000107.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF373I STEP/STEP0007/START 2016251.0918\n IEF032I STEP/STEP0007/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.25 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   380K  EXT:     4268K  SYS:    11292K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0008\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/ALIAS.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/NONVSAM.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/SYS1.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/IMPORT.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/GDG.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/MISC.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/RECAT.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/SYSCTLG.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk1/REPORT.txt)\n IEF142I JOARMCSC STEP0008 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000124.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000108.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF373I STEP/STEP0008/START 2016251.0918\n IEF032I STEP/STEP0008/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.25 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   380K  EXT:     4268K  SYS:    11296K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0009\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF142I JOARMCSC STEP0009 - STEP WAS EXECUTED - COND CODE 0008\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000125.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000109.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF373I STEP/STEP0009/START 2016251.0918\n IEF032I STEP/STEP0009/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.02 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   376K  EXT:     1176K  SYS:    11284K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0010\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF142I JOARMCSC STEP0010 - STEP WAS EXECUTED - COND CODE 0008\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000126.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000110.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF373I STEP/STEP0010/START 2016251.0918\n IEF032I STEP/STEP0010/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.01 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   376K  EXT:     1176K  SYS:    11284K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0011\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF237I 0D30 ALLOCATED TO REPORT\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF142I JOARMCSC STEP0011 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000127.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000111.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF285I   JOARMC.JUNK6                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF373I STEP/STEP0011/START 2016251.0918\n IEF032I STEP/STEP0011/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.24 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   396K  EXT:     4220K  SYS:    11228K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0012\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF237I 0D30 ALLOCATED TO REPORT\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF237I 0D30 ALLOCATED TO MEMOT\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF142I JOARMCSC STEP0012 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000128.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000112.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF285I   JOARMC.JUNK7                                 KEPT\n IEF285I   VOL SER NOS= VPWRKA.\n IEF373I STEP/STEP0012/START 2016251.0918\n IEF032I STEP/STEP0012/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.23 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   396K  EXT:     4220K  SYS:    11228K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0013\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/ALIAS.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/NONVSAM.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/SYS1.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/IMPORT.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/GDG.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/MISC.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/RECAT.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/SYSCTLG.txt)\n IGD103I SMS HFS FILE ALLOCATED TO DDNAME MEMOT\n IGD104I HFS FILE WAS RETAINED, DDNAME IS (MEMOT   )\n FILENAME IS (/u/joarmc/junk3/REPORT.txt)\n IEF142I JOARMCSC STEP0013 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000129.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000113.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF373I STEP/STEP0013/START 2016251.0918\n IEF032I STEP/STEP0013/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.25 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   380K  EXT:     4268K  SYS:    11300K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0014\n IEF237I JES2 ALLOCATED TO SYSTSPRT\n IEF237I JES2 ALLOCATED TO SYSTSIN\n IEF237I 0D32 ALLOCATED TO SYSEXEC\n IEF142I JOARMCSC STEP0014 - STEP WAS EXECUTED - COND CODE 0008\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000130.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000114.?          SYSIN\n IEF285I   JOARMC.REXX.EXEC                             KEPT\n IEF285I   VOL SER NOS= VPWRKC.\n IEF373I STEP/STEP0014/START 2016251.0918\n IEF032I STEP/STEP0014/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.01 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   540K  SYS:   376K  EXT:     1176K  SYS:    11288K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0015\n IEF237I JES2 ALLOCATED TO STDOUT\n IEF237I JES2 ALLOCATED TO STDERR\n IEF237I DMY  ALLOCATED TO STDIN\n IEF237I JES2 ALLOCATED TO STDPARM\n BPXM079I BPXBATCH PROCESSING IS USING THE STDPARM DD RATHER THAN THE INPUT PARA\n BPXM079I BPXBATCH PROCESSING IS USING THE STDPARM DD RATHER THAN THE STDIN DD.\n IEF142I JOARMCSC STEP0015 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000131.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000132.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000115.?          SYSIN\n IEF373I STEP/STEP0015/START 2016251.0918\n IEF032I STEP/STEP0015/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.00 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   168K  SYS:   276K  EXT:      136K  SYS:    10868K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF236I ALLOC. FOR JOARMCSC STEP0016\n IEF237I JES2 ALLOCATED TO STDOUT\n IEF237I JES2 ALLOCATED TO STDERR\n IEF237I DMY  ALLOCATED TO STDIN\n IEF237I JES2 ALLOCATED TO STDPARM\n BPXM079I BPXBATCH PROCESSING IS USING THE STDPARM DD RATHER THAN THE INPUT PARA\n BPXM079I BPXBATCH PROCESSING IS USING THE STDPARM DD RATHER THAN THE STDIN DD.\n IEF142I JOARMCSC STEP0016 - STEP WAS EXECUTED - COND CODE 0000\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000133.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000134.?          SYSOUT\n IEF285I   JOARMC.JOARMCSC.JOB00810.D0000116.?          SYSIN\n IEF373I STEP/STEP0016/START 2016251.0918\n IEF032I STEP/STEP0016/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  00.00 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n         VIRT:   168K  SYS:   276K  EXT:      136K  SYS:    10872K\n         ATB- REAL:                     0K  SLOTS:                     0K\n              VIRT- ALLOC:      14M SHRD:       0M\n IEF375I  JOB/JOARMCSC/START 2016251.0918\n IEF033I  JOB/JOARMCSC/STOP  2016251.0918\n         CPU:     0 HR  00 MIN  02.44 SEC    SRB:     0 HR  00 MIN  00.00 SEC\n **(Error-1)* Environment:MVS is unsupported.\n **(Error-2)* Neither TSO nor UNIX shell environment.\n **(Error-3)* RCNVTCAT cannot allocate files, so terminating.\n1RCNVTCAT Report DSN:JOARMC.RCNVTCAT.REPORT.T9598\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1resolveLocation:/u/joarmc/junk1\n RCNVTCAT Report Path:/u/joarmc/junk1\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1RCNVTCAT Report DSN:JOARMC.JUNK\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1RCNVTCAT Report DSN:JOARMC.JUNK4\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1RCNVTCAT Report DSN:JOARMC.JUNK5\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1RCNVTCAT Report Path:/u/joarmc/junk1\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1RCNVTCAT Report Path:/u/joarmc/junk1\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1**(Error-1)* Invalid output destination:/u/rhoten/junk1\n **(Error-2)* One of the directories in the path does not exist.\n READY\n END\n1**(Error-1)* Invalid output destination:/u/joarmc/junk2\n **(Error-2)* One of the directories in the path does not exist.\n READY\n END\n1RCNVTCAT Report DSN:JOARMC.JUNK6\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1RCNVTCAT Report DSN:JOARMC.JUNK7\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1RCNVTCAT Report Path:/u/joarmc/junk3\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n READY\n END\n1**(Error-1)* Invalid output destination:/u/joarmc/JUNK3\n **(Error-2)* One of the directories in the path does not exist.\n READY\n END\n HOME is:/u/joarmc\n Temporary files go in:/u/joarmc/tmp\n resolveLocation:./junk1\n RCNVTCAT Report Path:./junk1\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n **(cat)** Processing CATALOG    MVSUSER.USERCAT\n **(csi)***** Fullword processing selected\n HOME is:/u/joarmc\n Temporary files go in:/u/joarmc/tmp\n RCNVTCAT requires either one or two parameters and can accept\n  three other optional arguments.\n  - RCNVTCAT catname       : produces MCNVTCAT type output\n  - RCNVTCAT oldcat newcat : produces catalog comparison output\n\n ==Debug Option:\n  Enabled with the debug argument. This argument has three forms:\n DEBUG(n)\n --debug n\n --debug=n\n This sets the debug value to \"n\". The only valid value at this\n time is 2. It just put out some diagnostics which I don't\n know the utility of.\n\n ==Output Option:\n  Enabled with the output argument. This argument has 6 variants,\n  but they all do the same thing. They say where to place the\n  output. They are all equivalent. The reason for so many variants\n  is to hopefully seem \"intuitive\" to a wide spectrum of users.\n\n  If an output option is not used, then the default output\n  location is to the data set allocated to the DD REPORT. If\n  this DD is not allocated, then the location used depends on\n  the execution environment.\n  Note that the specification of one of the output location\n  options will override the use of the DD REPORT even if it\n  is allocated.\n\n  When run as a UNIX shell program, the default output location\n  is the current working directory. Otherwise, the location is\n  a PDS with a generated name.\n  The output location is displayed to the user.\n OUTPUT(location)\n OUTPUT=location\n -O location\n -Olocation\n -o location\n -olocation\n  In the above \"location\" is where to put the output. It may be\n  either a z/OS data set name or a z/OS UNIX directory name.\n  The DSN need not exist. A PDS with the given name will be\n  created if necessary.\n  A UNIX directory must exist if it is specified.\n\n  When the location appears to be a data set name, as opposed to\n  a UNIX path, the name is prefixed by the user's TSO prefix as\n  is done in most TSO command processors, unless it is enclosed\n  within ' symbols.\n  The location is assumed to be a DSN unless it begins with a\n  / (slash), . (period), or ~ (tilde); in which case it is\n  assumed to be a UNIX directory name. As with most UNIX\n  commands, a file name which begins with a / is an absolute\n  path to the directory, a period indicates a path relative to\n  the current directory, and a ~ (tilde) indicates a path\n  relative to the UNIX HOME directory of the current user (if\n  immediately followed by a / (slash) ) or a given user (the\n  value after the tilde but before the first / (slash) ). In\n  either case, the user must have the appropriate authority to\n  the directory or DSN.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAKEINDX": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x17\\x00Y\\x00\\x97\\x00\\x1f\\x01\\x03\\x06/\\x10(\\x00\\x9b\\x00\\x00\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "02.23", "flags": 0, "createdate": "1997-01-01T00:00:00", "modifydate": "2003-03-03T10:28:59", "lines": 155, "newlines": 0, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - MAKEINDX : Create a $$$INDEX from standardised comments     */\n/**********************************************************************/\n/* MAKEINDX :                                                         */\n/* Creates an $$$INDEX member for an EXEC library based on a standard */\n/* comment structure - shown at the top of this member.               */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 17/01/1997 - Alastair Gray - Original version            */\n/* 1.0.1   - 25/02/2000 - Alastair Gray - Added DESC:                 */\n/* 1.0.2   - 25/02/2000 - Alastair Gray - Simplified code             */\n/* 1.0.3   - 28/02/2000 - Alastair Gray - Changed $$$INDEX comment    */\n/* 1.0.4   - 28/04/2000 - Alastair Gray - Added type TEXT             */\n/* 1.0.5   - 16/08/2000 - Alastair Gray - Added type DTL              */\n/* 1.0.6   - 14/03/2001 - Alastair Gray - Added type ASM and PARM     */\n/**********************************************************************/\nArg dsn                                     /*                        */\ndsn = Strip(dsn,B,\"'\")                      /* remove inverted commas */\nIf (dsn = 'DSN') |,                         /*                        */\n   (dsn = '') then                          /*                        */\n Exit 12                                    /*                        */\nTrace O                                     /*                        */\nX = Msg('OFF')                              /*                        */\n/**********************************************************************/\nolin.1 = 'Member   Description'             /* Set Index header       */\nolin.2 = '-------- -----------'             /*                        */\nocnt = 2                                    /* Set Output line count  */\n/**********************************************************************/\nX = Outtrap('MEM.')                         /*                        */\n\"LISTDS '\"dsn\"' MEMBERS\"                    /* List members in dataset*/\nX = Outtrap()                               /*                        */\nflag = 'NEXT'                               /*                        */\nIf (mem.0 > 6) Then                         /* process only if members*/\n Do                                         /*                        */\n  Do meml = 1 to mem.0                      /*  loop thru member list */\n   If (Substr(mem.meml,1,11) = '--MEMBERS--') Then\n    Do                                      /*                        */\n     flag = 'OK'                            /*                        */\n     Iterate                                /*                        */\n    End                                     /*                        */\n   If (flag = 'NEXT') then                  /*                        */\n    Iterate                                 /*                        */\n   memname = Strip(mem.meml,B)              /*  remove blanks         */\n   outmem  = Left(memname,9)                /*  pad for output        */\n   If (Substr(memname,1,8) = 'THE FOLL') Then /* check for bad aliass */\n    Leave                                   /*                        */\n   Address TSO \"ALLOC FI(MEMIN) DA('\"dsn\"(\"memname\")') SHR REU\"\n   Address TSO \"EXECIO * DISKR MEMIN (FINIS STEM LINE.)\"\n   Address TSO \"FREE FI(MEMIN)\"\n/**********************************************************************/\n   check1 = Word(line.1,2)                  /* check type 1           */\n   check2 = Word(line.1,1)                  /* check type 2           */\n   check3 = Substr(line.1,1,2)              /* check type 3           */\n   Upper check1                             /* put check1 upper case  */\n   Upper check2                             /* put check2 upper case  */\n   Upper check3                             /* put check3 upper case  */\n   Select                                   /*                        */\n    When (check1 = 'JOB')    Then type = 'JOB'\n    When (check1 = 'DTL')    Then type = 'DTL'\n    When (check2 = '<:--')   Then type = 'DTL'\n    When (check3 = '<!')     Then type = 'DTL'\n    When (check1 = 'PROC')   Then type = 'PROC'\n    When (check2 = ')PANEL') Then type = 'PANEL'\n    When (check2 = ')ATTR')  Then type = 'PANEL'\n    When (check2 = 'PROC')   Then type = 'CLIST'\n    When (check1 = 'REXX')   Then type = 'REXX'\n    When (check1 = 'SAS')    Then type = 'SAS'\n    When (check1 = 'SKEL')   Then type = 'SKEL'\n    When (check1 = 'MSG')    Then type = 'MSG'\n    When (check1 = 'TEXT')   Then type = 'TEXT'\n    When (check1 = 'PARM')   Then type = 'PARM'\n    When (check1 = 'ASM')    Then type = 'ASM'\n    Otherwise type = ''                     /*                        */\n   End                                      /*                        */\n   comment = ''                             /*                        */\n   If (type /= '') Then                     /*                        */\n    Do                                      /*                        */\n     Call MEMSCAN                           /*                        */\n     If (type = 'JOB') &,                   /*                        */\n        (comment = '') Then                 /*                        */\n      Do                                    /*                        */\n       type = 'DOC'                         /*                        */\n       Call MEMSCAN                         /*                        */\n       If (comment = '') Then               /*                        */\n        Do                                  /*                        */\n         type = 'DESC'                      /*                        */\n         Call MEMSCAN                       /*                        */\n        End                                 /*                        */\n       type = 'JOB'                         /*                        */\n      End                                   /*                        */\n    End                                     /*                        */\n   If (type = 'DTL') Then                   /*                        */\n    Do                                      /*                        */\n     colon_pos = Index(comment,\":\")         /*                        */\n     If (Word(comment,1) = 'DTL') &,        /*                        */\n        (colon_pos > 1) Then                /*                        */\n      Do                                    /*                        */\n       comment = Substr(comment,colon_pos+1)/*                        */\n       Call COMCLEAN                        /*                        */\n       output = outmem||comment             /*                        */\n      End                                   /*                        */\n     If (comment = '') Then                 /*                        */\n      Do                                    /*                        */\n       type = 'DOC'                         /*                        */\n       Call MEMSCAN                         /*                        */\n       type = 'DTL'                         /*                        */\n      End                                   /*                        */\n    End                                     /*                        */\n   If (type = '') Then                      /*                        */\n    If (Index(line.1,'REXX') > 0) Then      /*                        */\n     type = 'REXX'                          /*                        */\n   If (comment = '') Then                   /*                        */\n    output = outmem||'** Unknown 'type      /*                        */\n   If (memname = '$$$INDEX') Then           /*                        */\n    output = outmem||'This member - generated by MAKEINDX' /*         */\n   If (memname = '$$$COIBM') Then           /*                        */\n    output = outmem||'IBM IPOUPDTE check member' /*                   */\n   ocnt = ocnt + 1                          /*                        */\n   olin.ocnt = output                       /*                        */\n  End                                       /*                        */\n End                                        /*                        */\nAddress TSO \"ALLOC FI(INDOT) DA('\"dsn\"($$$INDEX)') SHR REU\"\nAddress TSO \"EXECIO \"ocnt\" DISKW INDOT (FINIS STEM OLIN.)\"\nAddress TSO \"FREE FI(INDOT)\"\nExit 0                                      /*                        */\n/**********************************************************************/\nMEMSCAN:                                    /*                        */\ntypel = Length(type)                        /*                        */\nDo loop = 1 to line.0                       /*                        */\n test = line.loop                           /*                        */\n Upper test                                 /*                        */\n If (Substr(Word(test,2),1,typel) = type) Then /*                     */\n  Do                                        /*                        */\n   colon_pos = Index(line.loop,\":\")         /*                        */\n   If (colon_pos > 0) Then                  /*                        */\n    Do                                      /*                        */\n     comment = Substr(line.loop,colon_pos+1,71-colon_pos) /*          */\n     Call COMCLEAN                          /*                        */\n     output = outmem||comment               /*                        */\n     Leave                                  /*                        */\n    End                                     /*                        */\n  End                                       /*                        */\nEnd                                         /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\nCOMCLEAN:                                   /*                        */\ncomment = Strip(comment,B,' ')              /*                        */\ncomment = Strip(comment,B,'>')              /*                        */\ncomment = Strip(comment,B,'-')              /*                        */\ncomment = Strip(comment,B,'/')              /*                        */\ncomment = Strip(comment,B,'*')              /*                        */\ncomment = Strip(comment,B,' ')              /*                        */\nReturn                                      /*                        */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RCNVTCA$": {"ttr": 4105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x05\\x01\\x02\\x01\\x0f\\x01\\x022o\\x11%\\x00\\x13\\x00\\x14\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2002-01-10T00:00:00", "modifydate": "2002-11-22T11:25:05", "lines": 19, "newlines": 20, "modlines": 0, "user": "EEIT045"}, "text": "//EEIT045  JOB (1,,N#X),'RCNVTCA$ EEIT045.MYC',\n//         CLASS=L,MSGCLASS=X,MSGLEVEL=(1,1),\n//         REGION=8M,NOTIFY=&SYSUID,COND=(4,LT)\n//*USERDATA=(RCNVTCA$ EEIT045.MYCBT.CODE)\n//*-----------------------------------------------------------------*\n//*   LIB : EEIT045.MYCBT.CODE(RCNVTCA$)\n//*  NOTE : 10/01/02 15:30:15\n//*   DOC : EXECUTE RCNVTCAT CATALOG CONVERSION PROCEDURE\n//*-----------------------------------------------------------------*\n//RCNVTCAT EXEC PGM=IRXJCL,COND=EVEN,\n//         PARM='RCNVTCAT CATALOG.EET.MASTER'\n//SYSEXEC  DD DISP=SHR,DSN=EEIT045.MYCBT.CODE\n//*REPORT   DD SYSOUT=*          * PDS REALLY RECOMMENDED\n//REPORT   DD DISP=(NEW,CATLG),DSN=EEIT045.MCAT.REPORT,\n//            UNIT=3390,SPACE=(TRK,(15,15,10),RLSE),\n//            DCB=(LRECL=133,RECFM=FB,BLKSIZE=13300)\n//SYSTSPRT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RCNVTCAT": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01J\\x00Y\\x01\\x16#\\x0f\\x01\\x162\\x1f\\x19D\\x07\\x03\\x06}\\x00\\x00\\xe2\\xe8\\xe2\\xd3\\xc2\\xc4@@@@'", "ispf": {"version": "01.74", "flags": 0, "createdate": "2016-08-17T00:00:00", "modifydate": "2016-11-16T19:44:59", "lines": 1795, "newlines": 1661, "modlines": 0, "user": "SYSLBD"}, "text": "/* REXX - RCNVTCAT : MCNVTCAT replacement in REXX                     */\n/**********************************************************************/\n/* RCNVTCAT : Uses Catalog Search Interface (CSI)                     */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* The report dataset will now always be dynamically allocated        */\n/* and will be userid/prefix.rcnvtcat.report.Tnnnn                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */\n/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */\n/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */\n/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */\n/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */\n/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */\n/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/\n/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */\n/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */\n/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */\n/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */\n/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */\n/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */\n/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */\n/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */\n/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/\n/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */\n/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */\n/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/\n/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */\n/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */\n/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */\n/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &           */\n/*                                        make UNIX shell compatible  */\n/* 1.7.2   - 08/11/2016 - Lionel Dyck   - Add TARGET keyword          */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This program writes out various error messages, the return and  */\n/*    reason codes can be checked using those found listed for the    */\n/*    IBM message IDC3009I. The module is the CSI internal reference  */\n/*    and probably isn't of much use to anyone outside IBM.           */\n/*                                                                    */\n/* 2. Two return codes are 'special' :                                */\n/*    RC=100, Reason=4                                                */\n/*    RC=44 , Reason=14                                               */\n/*    These relate to entries of greater than 65535 characters.       */\n/*    If you get these entries, then you need to enable fullword      */\n/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */\n/*                                                                    */\n/**********************************************************************/\n/* So how does this differ from the original MCNVTCAT ?               */\n/*                                                                    */\n/* 1. Well it's written in REXX and uses the Catalog Search Interface */\n/*                                                                    */\n/* 2. It doesn't check the actual devices available on the system     */\n/*    (So you may get a catalog entry for a non-present device type)  */\n/*                                                                    */\n/* 3. It doesn't add bits of LISTCAT messages into the report totals  */\n/*    or the generated members.                                       */\n/*                                                                    */\n/* 4. It DOES handle datasets cataloged on more than five volume !    */\n/*    (So doesn't write out an error message for that condition)      */\n/*                                                                    */\n/* 5. I'm pretty sure that it doesn't handle SYSCTLG properly. As     */\n/*    the manual states that OS CVOLs don't work after 01/01/2000 I   */\n/*    guess this shouldn't be an issue for many out there.            */\n/*                                                                    */\n/* 6. It writes its report to the REPORT member of the PDS rather     */\n/*    than to a SYSOUT.                                               */\n/*                                                                    */\n/* 7. It generates a RECAT member that contains statements to allow   */\n/*    the RECATALOG of PAGESPACE and SYS1.** datasets.                */\n/*                                                                    */\n/*    Currently this only supports VSAM clusters with the following   */\n/*    non-default attributes : LINEAR, REUSE                          */\n/*                                                                    */\n/* 8. It can be used to compare two catalogs and produces reports     */\n/*    showing the differences between the catalogs.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf Address() = 'SH' Then             /* test for UNIX shell environ   */\n sh_flag = 'SH'\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (sh_flag /= 'SH') &,              /* it not UNIX shell             */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no UNIX environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt = '**'                           /* Set the filter                */\ntyp = ' '                            /* Set entry types required      */\nct1 = ' '                            /* Set for 1 catalog only        */\nrcnvdsn = ''                         /* set dsn to null               */\n/**********************************************************************/\n/* Handle passed parameters                                           */\n/**********************************************************************/\nArg vals                             /* Get passed arguments          */\nargnum = 0                           /*                               */\ntarg_cat = ''                        /* set target catalog to null    */\n\n/* ------------------------------------- *\n | Check for TARGET(newcatalog) keyword: |\n | - not found then done here            |\n | - found then extract                  |\n |   - save target catalog name          |\n |   - remove from parameters            |\n * ------------------------------------- */\nif pos(\"TARGET(\",translate(vals)) > 0 then do\n   parse value translate(vals) with val_left \"TARGET(\"targ_cat\")\" val_right\n   vals = val_left val_right\n   if left(targ_cat,1) = \"'\" then\n      parse value targ_cat with \"'\"targ_cat\"'\"\n   end\n\nDo i = 1 to Words(vals)              /* loop thru arguments           */\n testarg = Strip(Word(vals,i),B,\"'\") /* remove inverted commas        */\n Upper testarg                       /* convert to upper case         */\n Select                              /*                               */\n  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */\n   Do                                /*                               */\n    debug = Substr(testarg,7,1)      /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End                               /*                               */\n  When (testarg = '?') Then          /*                               */\n   Do                                /*                               */\n    Say \"RCNVTCAT requires either one or two parameters\"\n    Say \" - RCNVTCAT catname       : produces MCNVTCAT type output\"\n    Say \" - RCNVTCAT oldcat newcat : produces catalog comparison output\"\n    Say \" - RCNVTCAT oldcat TARGET(newcat) : produce recatalog output\"*/\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    argnum = argnum + 1              /*                               */\n    cat.argnum = testarg             /*                               */\n   End                               /*                               */\n End                                 /*                               */\nEnd                                  /*                               */\nSelect                               /*                               */\n When (argnum = 0) Then              /*                               */\n  Do                                 /*                               */\n   Say '**(cat)** No entry provided for catalog name.'\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\n When (argnum = 1) Then              /* only one catalog              */\n  process = 'RCNVTCAT'               /* process as normal RCNVTCAT    */\n When (argnum = 2) Then              /* two catalogs                  */\n  process = 'CATCOMP'                /* process for Catalog compare   */\n Otherwise                           /* two catalogs                  */\n  Do                                 /*                               */\n   Say '**(cat)** Too many arguments - retry.'\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\nIf (DsExist(\"'\"cat.1\"'\") > 4) Then /*                               */\n Do                                /*                               */\n  Say '**(cat)** Bad entry provided for catalog name.'\n  Say '**(cat)** 'cat.1\n  Say '**(cat)** LISTDSI Return code = 'sysreason\n  Say '**(cat)** 'sysmsglvl1\n  Say '**(cat)** 'sysmsglvl2\n  Signal FINISH                    /* exit exec                     */\n End                               /*                               */\nIf (process = 'CATCOMP') &,        /* Catalog compare processing    */\n   (DsExist(\"'\"cat.2\"'\") > 4) Then /* bad return                    */\n Do                                /*                               */\n  Say '**(cat)** Bad entry provided for second catalog name.'\n  Say '**(cat)** 'cat.2\n  Say '**(cat)** LISTDSI Return code = 'sysreason\n  Say '**(cat)** 'sysmsglvl1\n  Say '**(cat)** 'sysmsglvl2\n  Signal FINISH                    /* exit exec                     */\n End                               /*                               */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nIf (process = 'RCNVTCAT') Then       /* Process as RCNVTCAT           */\n Do                                  /*                               */\n  count.id = 0                       /* initialise count              */\n  member = 'ALIAS'                   /* processing ALIAS              */\n  x = CSI(cat.1,'**','X','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'NONVSAM'                 /* processing NONVSAM            */\n  x = CSI(cat.1,'**','AH','Y')       /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYS1'                    /* processing SYS1               */\n  x = CSI(cat.1,'SYS1.**','AH','Y')  /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'IMPORT'                  /* processing IMPORT             */\n  x = CSI(cat.1,'**','U','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'GDG'                     /* processing GDG                */\n  x = CSI(cat.1,'**','B','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'MISC'                    /* processing MISC               */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'RECAT'                   /* processing RECAT (MISC+)      */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYSCTLG'                 /* processing SYSCTLG            */\n  x = CSI(cat.1,'SYSCTLG.**','AH','Y') /* Call CSI                    */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'REPORT'                  /* processing REPORT             */\n  Call MEM_REPORT                    /* generate report               */\n  Call WRITE_MEMBER                  /* write out member              */\n End                                 /*                               */\nElse                                 /* Process as Catalog compare    */\n Do                                  /*                               */\n  id = 'OLD'                         /* specify for 'old' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.old = cat.1                    /* retain catalog name           */\n  x = CSI(cat.1,flt,' ','Y')         /* Call CSI procedure            */\n  id = 'NEW'                         /* specify for 'NEW' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.new = cat.2                    /* retain catalog name           */\n  x = CSI(cat.2,flt,' ','Y')         /* Call CSI procedure            */\n  member = 'COMPFULL'                /* processing FULL comparison    */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'COMPSHRT'                /* processing SHORT comparison   */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'EXTRA'                   /* processing EXTRA member       */\n  Call NEW_EXT                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'CHANGED'                 /* processing CHANGED member     */\n  Call OLD_BAD                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n End                                 /*                               */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"rcnvdsn\"')\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword used        */\n Say '**(csi)***** Fullword processing selected'\nElse                                 /* check if fullword used        */\n Say '**(csi)***** Halfword processing - default'\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '000E'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */\ncsifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('ATTR1   ',8)        /* Attributes                    */\ncsifld09 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld10 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld11 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld12 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld13 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld14 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13||csifld14\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  If (debug = 2) Then                /*                               */\n   Do                                /*                               */\n    Say 'off=<'off'>'                /*                               */\n    Say 'entry =<'Substr(dwork,off,150)'>'\n    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'\n   End                               /*                               */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    Select                           /*                               */\n     When (csienter = '1') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     When (csiedata = '0') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* No data returned'\n       Say '**(Error-3)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     Otherwise                       /*                               */\n      Do                             /*                               */\n       If (csioptns = 'F') Then      /* check if fullword requested   */\n        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */\n       Else                          /* otherwise (default halfword)  */\n        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */\n       Call ENTRY                    /* Execute entry processing      */\n       plus = 46 + csitotln          /* length for normal entry       */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ngdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */\ngdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */\nattr1    = Substr(dwork,o_fld.8,l_fld.8)   /* attributes              */\ncattr    = Substr(dwork,o_fld.9,l_fld.9)   /* attribs page and swap   */\ndevtyp   = Substr(dwork,o_fld.10,l_fld.10) /* device type             */\nvolser   = Substr(dwork,o_fld.11,l_fld.11) /* volume serial           */\nfileseq  = Substr(dwork,o_fld.12,l_fld.12) /* file sequence           */\nvsamreus = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.14,l_fld.14) /* VSAM dataset information*/\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ATTR1') > 0) Then    /*                           */\n Call FLD_ATTR1                          /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /*                           */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /*                           */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ATTR1    - Process ATTR1    field                              */\n/**********************************************************************/\nFLD_ATTR1:                           /* ATTR1    field processing   ##*/\nattr1 = X2b(c2x(attr1))              /*                               */\nIf (Substr(attr1,1,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' SPEED'       /*                               */\nIf (Substr(attr1,3,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nIf (Substr(attr1,4,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' ERASE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nReturn                               /* duplicates ATTR1              */\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype /= 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nIf (entype /= 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\ndsn = rcnvdsn\nIf sh_flag = 'SH' Then\n Do\n  Address syscall getlogin sysuid\n  random_dsn = 'T'random(9999)\n  rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn\n  bpxparm = \"Alloc \",\n            \"Da(\"rcnvdsn\")\" ,\n            \"Fi(REPORT) \",\n            \"Lrecl(133) \",\n            \"Unit(SYSALLDA)\",\n            \"Space(2,2) \",\n            \"Dir(10) \",\n            \"Cyl \",\n            \"Blksize(1330) \",\n            \"Recfm(F,B) \",\n            \"New \",\n            \"Catalog \",\n            \"Reuse\"\n  rc=BPXWDYN(bpxparm)\n  If rc <> 0 Then\n   Do\n    Say '**(Error-1)* Allocation of DD:REPORT Failed.'\n    Select\n     When rc = 20 Then\n      Say '**(Error-2)* BPXWDYN Invalid Parameter List.'\n     When rc > 0 | rc <-1610612737 Then\n      Do\n       hexrc=right(d2x(rc),8,\"0\")\n       Say '**(Error-2)* Dynamic Allocation error code:'hexcode\n      End\n     When rc <= -21 & rc >= -9999 Then\n      Say '**(Error-2)* Error in key number 'abs(rc)-20\n     When rc <= -10000 & rc >= -10099 Then\n      Say '**(Error-2)* Message processing error. IEFDB476 returned code:',\n           abs(rc)-10000\n    End\n    Signal FINISH\n   End\n  dsn = rcnvdsn                      /*                               */\n  say 'RCNVTCAT Report DSN:' dsn\n  Return\n End\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    random_dsn = 'T'random(9999)\n    if sysvar('syspref') = ''\n       then rcnvdsn = sysvar('sysuid')'.RCNVTCAT.REPORT.'random_dsn\n       else rcnvdsn = sysvar('syspref')'.RCNVTCAT.REPORT.'random_dsn\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Dataset('\"rcnvdsn\"')\" ,\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                 \"Da('\"rcnvdsn\"')\" ,\n                \"Blksize(1330) Recfm(F,B) New Reuse Catalog\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    dsn = rcnvdsn                    /*                               */\n   End                               /*                               */\nsay 'RCNVTCAT Report DSN:' dsn\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nali_tot = 0                          /* Total Aliases                 */\nasy_tot = 0                          /* Total Aliases SYSCATLG        */\nanv_tot = 0                          /* Total Aliases NONVSAM         */\naxx_tot = 0                          /* interim alias total           */\navu_tot = 0                          /* Total Aliases VSAM UCAT       */\ngdg_tot = 0                          /* Total GDGs                    */\nivd_tot = 0                          /* Total invalid devices         */\nmsc_tot = 0                          /* Total MISC datasets           */\nnvd_tot = 0                          /* Total NONVSAM datasets        */\nnvo_tot = 0                          /* Total NONVSAM (not SYS1) dsns */\nnvv_tot = 0                          /* Total NONVSAM dsn volumes     */\nsyc_tot = 0                          /* Total SYSCTLG datasets        */\nsy1_tot = 0                          /* Total NONVSAM SYS1 datasets   */\nuct_tot = 0                          /* Total Usercatalog imports     */\nReturn                               /*                               */\n/**********************************************************************/\n\nDsExist: Procedure Expose sysreason sysmsglvl1 sysmsglvl2\nparse arg indsn\nsysreason=0\nsysmsglvl1=' Not Emulated '\nsysmsglvl2=' Not Emulated '\nIf indsn = '' Then\n Do\n   sysreason=29\n   return 16\n End\nxx=outtrap('junk.','*') /* I don't care */\nAddress TSO \"LISTCAT ENT(\"indsn\")\"\nlrc=rc\nsysreason=rc\nhexrc=right(d2x(rc),8,\"0\")\nxx=outtrap(\"OFF\")\nIf \"0438\" = left(hexrc,4) Then\n Do\n  sysreason=24\n  Return 16\n End\ndrop junk.\nreturn lrc\nLISTDD:   /* new routine */\nrc=bpxwdyn(\"INFO \",\n           \"DD(REPORT) \",\n           \"INRTDSN(rcnvdsn) \",\n           \"INRDSNT(dsntype) \",\n           \"INRTORG(dsorg) \",\n           \"MSG(message.)\")\nIf rc <> 0 Then\n Do\n  rcnvdsn=''\n  return 16\n End\nif dsntype <> \"PDS\" then return 8\nif 'PO' <> left(dsorg,2) then return 8\nreturn 0\n/* Old implementation */\n call outtrap 'x.'\n 'lista sta'\n call outtrap 'off'\n\n do i = 1 to x.0\n    if left(x.i,1) /= ' ' then iterate\n    if word(x.i,1) = 'REPORT' then do\n       id = i - 1\n       rcnvdsn = word(x.id,1)\n       leave\n       end\n    end\n  if rcnvdsn = '' then return 16\n  return 0\n*/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDDO:                                    /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\n                                     /*                               */\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n  Say '**(cat)** Processing 'Left('CATALOG',10) csicname\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  If (process = 'CATCOMP') Then      /** Catalog compare code        **/\n   Do                                /*                               */\n    count.id           = count.id+1  /* increment count               */\n    val                = count.id    /* save value                    */\n    entname.id.val     = entname     /* store entry name              */\n    entype.id.val      = entype      /* store entry type              */\n    name.id.val        = name        /* store assoc name              */\n    type.id.val        = type        /* store assoc type              */\n    pageswap.id.val    = pageswap    /* store pageswap                */\n    devices.id.val     = devices     /* store devices                 */\n    fils.id.val        = fils        /* store fils                    */\n    gdg_emp.id.val     = gdg_emp     /* store gdg_emp                 */\n    gdg_scr.id.val     = gdg_scr     /* store gdg_scr                 */\n    gdglimit.id.val    = gdglimit    /* store gdglimit                */\n    vsam_attr.id.val   = vsam_attr   /* store vsam_attr               */\n    vsam_type.id.val   = vsam_type   /* store vsam_attr               */\n    vsam_vvds.id.val   = vsam_vvds   /* store vsam_vvds               */\n    volsers.id.val     = volsers     /* store volsers by value        */\n                                     /** Back reference values       **/\n    volsers.id.entname = volsers     /* store volsers by entry name   */\n    name.id.entname    = name        /* store name by entry name      */\n    val.id.entname     = val         /* store value by entry name     */\n   End                               /** End Catalog compare code    **/\n  Else                               /*                               */\n   Do                                /*                               */\n    Select                           /*                               */\n     When (member = 'MISC') Then     /* MISC member                   */\n      Call MEM_MISC                  /*                               */\n     When (member = 'RECAT') Then    /* RECAT member                  */\n      Call MEM_RECAT                 /*                               */\n     When (member = 'ALIAS') Then    /* ALIAS member                  */\n      Call MEM_ALIAS                 /*                               */\n     When (member = 'GDG') Then      /* GDG member                    */\n      Call MEM_GDG                   /*                               */\n     When (member = 'IMPORT') Then   /* IMPORT member                 */\n      Call MEM_IMPORT                /*                               */\n     When (member = 'NONVSAM') Then  /* NONVSAM member                */\n      Do                             /*                               */\n       axx_tot = anv_tot             /* set intermim alias total      */\n       nvd_tot = nvd_tot + 1         /* increment total non-vsam      */\n       nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols        */\n       If (Substr(entname,1,4) /= 'SYS1') &,\n          (Substr(entname,1,7) /= 'SYSCTLG') Then /* not SYS1/SYSCTLG */\n        Do                           /*                               */\n         nvo_tot = nvo_tot + 1       /* increment non-vsam only total */\n         Call MEM_NONVSAM            /*                               */\n        End                          /*                               */\n       anv_tot = axx_tot             /* set non-vsam aliases total    */\n      End                            /*                               */\n     When (member = 'SYS1') Then     /* SYS1 member                   */\n      Do                             /*                               */\n       sy1_tot = sy1_tot + 1         /* increment sys1 total          */\n       Call MEM_NONVSAM              /*                               */\n      End                            /*                               */\n     When (member = 'SYSCTLG') Then  /* SYSCTLG member                */\n      Do                             /*                               */\n       axx_tot = asy_tot             /* interim = syscatlg aliases    */\n       syc_tot = syc_tot + 1         /* increment syscatlg total      */\n       Call MEM_NONVSAM              /*                               */\n       asy_tot = axx_tot             /* set syscatlg total            */\n      End                            /*                               */\n     Otherwise NOP                   /*                               */\n    End                              /*                               */\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_MISC - Generate MISC member lines                              */\n/**********************************************************************/\nMEM_MISC:                            /* Generate MISC member lines  ##*/\nIf (entype = 'CLUSTER') |,\n   (entype = 'PAGESPACE') Then\n Do\n  msc_tot = msc_tot + 1\n  l_cnt = l_cnt + 1\n  text = ' /* 'Left(entype' ',15,'-')\n  text = text' 'Left(entname,32)'  NOT PROCESSED */'\n  l.l_cnt = text\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_RECAT - Generate RECAT member lines                            */\n/**********************************************************************/\nMEM_RECAT:                           /* Generate RECAT member lines ##*/\nIf (entype = 'PAGESPACE') Then\n Do\n  page_name     = entname\n  page_swap     = pageswap\n  If (Index(type,'D') /= 0) Then\n   data_flag = 'DATA'\n  Else\n   data_flag = ''\n End\nIf (entype = 'CLUSTER') Then\n Do\n  If (Substr(entname,1,4) /= 'SYS1') Then\n   Do\n    cluster_name  = entname\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left(entype' ',15,'-')\n    text = text' 'Left(entname,34)' CANNOT RECAT */'\n    data_flag = ''\n    index_flag = ''\n    l.l_cnt = text\n   End\n  Else\n   Do\n    cluster_name  = entname\n    If (Index(type,'D') /= 0) Then\n     data_flag = 'DATA'\n    Else\n     data_flag = ''\n    If (Index(type,'I') /= 0) Then\n     index_flag = 'INDEX'\n    Else\n     index_flag = ''\n    cluster_bits  = type\n   End\n End\nIf (entype = 'DATA') &,\n   (data_flag = 'DATA') Then\n Select\n  When (vsam_vvds = 'Y') Then               /* use VVDS flag          */\n   Do\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left('VVDS ',15,'-')\n    text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'\n    l.l_cnt = text\n   End\n  When (Index(name,page_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF PAGESPACE(NAME('Left(page_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left(page_swap,57)' -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    if targ_cat /= ''\n    then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n    else l.l_cnt = '          CAT('Left(cat,44)'        )'\n   End\n  When (Index(name,cluster_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF   CLUSTER(NAME('Left(cluster_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    If (vsam_attr /= '') Then\n     Do\n      l_cnt = l_cnt + 1\n      l.l_cnt = '          'Left(vsam_attr,57)' -'\n     End\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '         DATA(NAME('Left(entname,44)'   ) ) -'\n    If (index_flag = '') Then\n     Do\n      l_cnt = l_cnt + 1\n      if targ_cat /= ''\n      then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n      else l.l_cnt = '          CAT('Left(cat,44)'        )'\n     End\n   End\n  Otherwise\n   Say '**(Error--1)* Unexpected condition for :'\n   Say '**(Error--2)* cluster_name = 'Strip(cluster_name,T)\n   Say '**(Error--3)* page_name    = 'Strip(page_name,T)\n   Say '**(Error--4)* entname      = 'Strip(entname,T)\n   Say '**(Error--5)* entype       = 'Strip(entype,T)\n   Say '**(Error--6)* name         = 'Strip(name,T)\n   Say '**(Error--7)* type         = 'Strip(type,T)\n   Say '**(Error--8)* data_flag    = 'Strip(data_flag,T)\n   Say '**(Error--9)* index_flag   = 'Strip(index_flag,T)\n   Say '**(Error-10)* vsam_byte1   = 'vsam_byte1\n   Say '**(Error-11)* vsam_byte2   = 'vsam_byte2\n   Say '**(Error-12)* vsamreus     = 'vsamreus\n End\nIf (entype = 'INDEX') &,\n   (index_flag = 'INDEX') Then\n Do\n  l_cnt = l_cnt + 1\n  l.l_cnt = '         INDEX(NAME('Left(entname,44)'  ) ) -'\n  l_cnt = l_cnt + 1\n  if targ_cat /= ''\n  then l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n  else l.l_cnt = '          CAT('Left(cat,44)'        )'\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_ALIAS - Generate ALIAS member lines                            */\n/**********************************************************************/\nMEM_ALIAS:                           /* Generate ALIAS member lines ##*/\nali_tot = ali_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '     DEF ALIAS(NAME('entname')  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          REL('name'))          -'\nl_cnt = l_cnt + 1\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'         )'\nelse l.l_cnt = '          CAT('Left(cat,44)'         )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_IMPORT - Generate IMPORT member lines                          */\n/**********************************************************************/\nMEM_IMPORT:                          /* Generate IMPORT member lins ##*/\nuct_tot = uct_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '    IMPORT   OBJ( ('entname'  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          DEVT('Left(devices,8)') VOL('volser')))'\nl.l_cnt = l.l_cnt' 'Left('CONNECT',26)' -'\nl_cnt = l_cnt + 1\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nelse l.l_cnt = '          CAT('Left(cat,44)'        )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_GDG - Generate GDG member lines                                */\n/**********************************************************************/\nMEM_GDG:                             /* Generate GDG member lines   ##*/\ngdg_tot = gdg_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  GDG  (NAME('entname') -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          LIMIT('Right(gdglimit,3)') 'Left(gdg_scr,16)\nl.l_cnt = l.l_cnt' 'Left(gdg_emp,24)' )  -'\nl_cnt = l_cnt + 1\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nelse l.l_cnt = '          CAT('Left(cat,44)'        )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_NONVSAM - Generate NONVSAM member lines                        */\n/**********************************************************************/\nMEM_NONVSAM:                         /* Generate NONVSAM member lins##*/\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  NVSAM(NAME('entname') -'\nIf (Words(devices) <= 5) Then        /* < 5 devices for dataset       */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          DEVT( 'Left(devices,47)') -'\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq /= '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = '          FSEQN('Left(fileseq,47)') -'\n   End                               /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          VOL(  'Left(volser,47)') )-'\n End                                 /*                               */\nElse                                 /* > 5 devices for dataset       */\n Do                                  /*                               */\n  item_lead = 'DEVT( '               /* devices header                */\n  item_end  = ') -'                  /* devices trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = devices                    /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq /= '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    item_lead = 'FSEQN('             /* fileseq header                */\n    item_end  = ') -'                /* fileseq trailer               */\n    item_pad  = Left('',7)           /* 7 spaces padding              */\n    items = fileseq                  /* pass data                     */\n    Call PLUS5_HANDLE                /* handle > 5 items              */\n   End                               /*                               */\n  item_lead = 'VOL(  '               /* volumes header                */\n  item_end  = ') ) -'                /* volumes trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = volser                     /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n End                                 /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nelse l.l_cnt = '          CAT('Left(cat,44)'        )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ASSOC_ENTRY - Process associated entries                           */\n/**********************************************************************/\nASSOC_ENTRY:                         /* Process associated entries  ##*/\nDo ali = 1 to Words(name)\n If (Substr(type,ali,1) = 'X') Then\n  Do\n   axx_tot = axx_tot + 1\n   l_cnt = l_cnt + 1\n   l.l_cnt = '     DEF ALIAS(NAME('Left(Word(name,ali),44)') -'\n   l_cnt = l_cnt + 1\n   l.l_cnt = '          REL('entname'))  -'\n   l_cnt = l_cnt + 1\n   if targ_cat /= ''\n   then l.l_cnt = '          CAT('Left(targ_cat,44)'         )'\n   else l.l_cnt = '          CAT('Left(cat,44)'         )'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM               */\n/**********************************************************************/\nPLUS5_HANDLE:                        /* Handle > 5 fields           ##*/\nl_cnt = l_cnt + 1\nw_end = Wordindex(items,6)\ndata = Left(Substr(items,1,w_end-1),47)\nl.l_cnt = '          'item_lead||data' -'\nDo mult = 6 to Words(items) by 5\n w_sta = Wordindex(items,mult)\n w_end = Wordindex(items,mult+5)\n If (w_end = 0) Then\n  item = Substr(items,w_sta)\n Else\n  item = Substr(items,w_sta,w_end-w_sta)\n l_cnt = l_cnt + 1\n item_length = 47 - Length(item_pad)\n l.l_cnt = '                '||item_pad||Left(item,item_length)' -'\nEnd\nl.l_cnt = Strip(l.l_cnt,T,'-')||item_end\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_REPORT - Generate REPORT member                                */\n/**********************************************************************/\nMEM_REPORT:                          /* Generate REPORT member      ##*/\nr.1  = 'OS CVOL CATALOG NAMES TO BE CONVERTED'\nr.2  = '*RCNVTCAT*  C O N V E R S I O N   R E P O R T'\nr.3  = ' '\nr.4  = 'TOTAL NUMBER OF ALIAS STMTS IN CATALOG                  '\nr.5  = 'ALIAS STMTS ASSOCIATED WITH OS CVOL CATALOGS            '\nr.6  = 'ALIAS STMTS ASSOCIATED WITH VSAM USER CATALOGS          '\nr.7  = 'ALIAS STMTS ASSOCIATED WITH NON VSAM DATA SETS          '\nr.8  = '                                                        '\nr.9  = 'NUMBER OF VSAM USER CATALOGS                            '\nr.10 = '                                                        '\nr.11 = 'TOTAL NUMBER OF NON VSAM DATA SETS  IN CATALOG          '\nr.12 = 'VOLUMES ASSOCIATED WITH NON VSAM DATA SETS. SEE NOTE 1  '\nr.13 = 'OS CVOL CATALOGS WITH THE FOLLOWING NAMES:              '\nr.14 = 'SYSCTLG.VXXXXXX  -  XXXXXX = VOLUME                     '\nr.15 = 'OS CVOL CATALOG NAMES CONVERTED TO                      '\nr.16 = 'SYSCTLG.VXXXXXX . SEE NOTE 2 AND SYSPRINT OUTPUT LISTING'\nr.17 = 'NON VSAM DATA SETS STARTING WITH SYS1.---               '\nr.18 = 'ALL OTHER NON VSAM DATA SETS                            '\nr.19 = '                                                        '\nr.20 = 'NUMBER OF GENERATION DATA GROUP STMTS                   '\nr.21 = '                                                        '\nr.22 = 'NUMBER OF STATEMENTS WHICH COULD  N O T  BE PROCESSED   '\nr.23 = '                                                        '\nr.24 = 'NUMBER OF STATEMENTS WHICH CONTAIN AN INVALID           '\nr.25 = 'DEVICE TYPE. SEE NOTE 3                                 '\nr.26 = 'TOTAL NUMBER OF STATEMENTS WHICH WERE PROCESSED         '\nr.27 = 'SUM OF STATEMENTS WHICH WERE PROCESSED FOR              '\nr.28 = 'ALIAS/IMPORT/NONVSAM/GDG AND MISC. SEE NOTE 4           '\ntot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot\nsta_tot = tot_tot + ali_tot\nr.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '||r.4\nr.5  = ' ALIAS  SYSCTLG ........... 'Right(asy_tot,8)'      '||r.5\nr.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '||r.6\nr.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '||r.7\nr.8  = '                                          '||r.8\nr.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '||r.9\nr.10 = '                                          '||r.10\nr.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '||r.11\nr.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '||r.12\nr.13 = ' OS CVOL SYSCTLG ....(M)... 'Right(syc_tot,8)'      '||r.13\nr.14 = '                                          '||r.14\nr.15 = ' SYSCTLG CONVERTED ........        0      '||r.15\nr.16 = '                                          '||r.16\nr.17 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '||r.17\nr.18 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '||r.18\nr.19 = '                                          '||r.19\nr.20 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '||r.20\nr.21 = '                                          '||r.21\nr.22 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '||r.22\nr.23 = '------------------------------------      '||r.23\nr.24 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '||r.24\nr.25 = '                                          '||r.25\nr.26 = 'NO. OF STMTS PROC ......... 'Right(sta_tot,8)'      '||r.26\nr.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '||r.27\nr.28 = '                                          '||r.28\nr.29 = '(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES'\nr.30 = 'NOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME '\nr.31 = 'NOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVER'\nr.32 = 'NOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!'\nr.33 = 'NOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. T'\nr.31 = r.31||'TED TO SYSCTLG.VXXXXXX, XXXXXX = VOLUME'\nr.32 = r.32||'. BETTER CHECK THE CODE !?!'\nr.33 = r.33||'HEY ARE PROCESSED TWICE'\nl_cnt = 33\nDo loop = 1 to 33\n l.loop = r.loop\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* COMP_REPORT - Produce the Catalog comparison report                */\n/**********************************************************************/\nCOMP_REPORT:                         /* Produce the catalog compare ##*/\nl_cnt = 0\nDo loop = 1 to count.OLD\n entname = entname.OLD.loop\n entype  = entype.OLD.loop\n name    = name.OLD.loop\n volsers = volsers.OLD.loop\n flag.entname = 'Y'\n If (member = 'COMPFULL') Then\n  Do\n   disp_ent = entname\n   disp_entype = Left(entype,8)\n  End\n Else\n  Do\n   disp_ent = Left(entname,36)\n   disp_entype = Left(substr(entype,1,3),4)\n  End\n disp_vol = Strip(volsers,B)\n If (Symbol('val.NEW.entname') = 'LIT') Then\n  Do\n   l_cnt = l_cnt + 1\n   Select\n    When (entype = 'ALIAS  '  ) Then\n     detail = Strip(name.OLD.loop,B)\n    When (entype = 'DATA'     ) |,\n         (entype = 'INDEX'    ) Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)||' ',\n              Strip(vsam_type.OLD.loop,B)||' ',\n              Strip(vsam_attr.OLD.loop,B)\n    When (entype = 'NONVSAM'  ) |,\n         (entype = 'GDG'      ) |,\n         (entype = 'UCAT'     ) |,\n         (entype = 'PAGESPACE') Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)\n    Otherwise NOP\n   End\n   l.l_cnt = disp_entype||disp_ent' --missing - 'detail\n   status.OLD.loop = 'MISSING'\n  End\n Else\n  Do\n   namenew = name.NEW.entname\n   volsnew = volsers.NEW.entname\n   Select\n    When (namenew /= name) Then\n     Do\n      If (entype = 'ALIAS') Then\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##catalog was 'Strip(name,B)' is 'Strip(namenew,B)\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADCAT'\n       End\n      Else\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##related entries do not match.'\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADENT'\n       End\n     End\n    When (volsnew /= volsers) Then\n     Do\n      l_cnt = l_cnt + 1\n      err_text = ' ##volser was 'disp_vol' is 'Strip(volsnew,B)\n      l.l_cnt = disp_entype||disp_ent||err_text\n      status.OLD.loop = 'BADVOL'\n     End\n    Otherwise\n     l_cnt = l_cnt + 1\n     l.l_cnt = disp_entype||disp_ent' **entry matches.'\n     status.OLD.loop = 'OK'\n   End\n  End\nEnd\nDo loop = 1 to count.NEW\n entname = entname.NEW.loop\n entype  = entype.NEW.loop\n volsers = volsers.NEW.loop\n If (flag.entname /= 'Y') Then\n  Do\n   If (member = 'COMPFULL') Then\n    Do\n     disp_ent = entname\n     disp_entype = Left(entype,8)\n    End\n   Else\n    Do\n     disp_ent = Left(entname,36)\n     disp_entype = Left(substr(entype,1,3),4)\n    End\n   disp_vol = Strip(volsers,B)\n   l_cnt = l_cnt + 1\n   l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol\n   status.NEW.loop = 'NEW'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* NEW_EXT - Process for new entries                                  */\n/**********************************************************************/\nNEW_EXT:                             /* Process new entries         ##*/\nDo loop = 1 to count.NEW             /*                               */\n If (status.NEW.loop = 'NEW') Then   /*                               */\n  Do                                 /*                               */\n   entname = entname.NEW.loop        /*                               */\n   entype  = entype.NEW.loop         /*                               */\n   If (entype = 'DATA') |,           /*                               */\n      (entype = 'INDEX') Then        /*                               */\n    Iterate                          /*                               */\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry not present in catalog \"cat.old\". */\"\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry present in catalog     \"cat.new\". */\"\n   Call ENTRY_DEL                    /* process an entry delete       */\n  End                                /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* OLD_BAD - Process for old entries                                  */\n/**********************************************************************/\nOLD_BAD:                             /* Process old entries         ##*/\nDo loop = 1 to count.OLD             /*                               */\n entname   = entname.OLD.loop        /*                               */\n entype    = entype.OLD.loop         /*                               */\n volsers   = volsers.OLD.loop        /*                               */\n volser    = Strip(volsers,B)        /*                               */\n name      = name.OLD.loop           /*                               */\n type      = type.OLD.loop           /*                               */\n pageswap  = pageswap.OLD.loop       /*                               */\n devices   = devices.OLD.loop        /*                               */\n fils      = fils.OLD.loop           /*                               */\n gdg_emp   = gdg_emp.OLD.loop        /*                               */\n gdg_scr   = gdg_scr.OLD.loop        /*                               */\n gdglimit  = gdglimit.OLD.loop       /*                               */\n vsam_attr = vsam_attr.OLD.loop      /*                               */\n vsam_type = vsam_type.OLD.loop      /*                               */\n vsam_vvds = vsam_vvds.OLD.loop      /*                               */\n namenew   = name.NEW.entname        /*                               */\n volsnew   = volsers.NEW.entname     /*                               */\n If (entype = 'DATA') |,             /*                               */\n    (entype = 'INDEX') Then          /*                               */\n  Iterate                            /*                               */\n Select                              /*                               */\n  When (status.OLD.loop = 'MISSING') Then /*                          */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Entry missing in catalog \"cat\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADCAT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Alias incorrectly pointing to \"namenew\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADENT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Related entries do not match */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* entry \"Strip(entname,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* old \"Strip(name,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* new \"Strip(namenew,T)\" */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADVOL') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Volume incorrect - was \"volsnew\". */\"\n   End                               /*                               */\n  Otherwise Iterate                  /*                               */\n End                                 /*                               */\n Call ENTRY_DEL                      /* process an entry delete       */\n Call ENTRY_CHG                      /* process an entry change       */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_DEL - Create a DELETE statement                              */\n/**********************************************************************/\nENTRY_DEL:                           /* Create an entry DELETE      ##*/\nIf (entype = 'NONVSAM') Then         /*                               */\n tparm = ''                          /*                               */\nElse                                 /*                               */\n tparm = entype                      /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      DELETE \"Strip(entname,T)\" \"tparm\" NOSCRATCH -\"\nl_cnt = l_cnt + 1                    /*                               */\nif targ_cat /= ''\nthen l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nelse l.l_cnt = '          CAT('Left(cat,44)'        )'\nl.l_cnt = \"             CAT(\"Left(cat,44)\"         )\"\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      SET MAXCC=0\"\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_CHG - Create a changed entry statement                       */\n/**********************************************************************/\nENTRY_CHG:                           /* Create a changed entry      ##*/\nSelect                               /*                               */\n When (entype = 'NONVSAM') Then      /*                               */\n  Call MEM_NONVSAM                   /*                               */\n When (entype = 'ALIAS') Then        /*                               */\n  Call MEM_ALIAS                     /*                               */\n When (entype = 'GDG') Then          /*                               */\n  Call MEM_GDG                       /*                               */\n Otherwise NOP                       /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RCNVTC00": {"ttr": 4871, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01=\\x00\\x12\\x01\\x02\\x04_\\x01\\x12'\\x1f\\x003\\x06}\\x03\\xbe\\x00\\x00\\xd6\\xd3\\xc4@@@@@@@\"", "ispf": {"version": "01.61", "flags": 0, "createdate": "2002-02-14T00:00:00", "modifydate": "2012-09-27T00:33:12", "lines": 1661, "newlines": 958, "modlines": 0, "user": "OLD"}, "text": "/* REXX - RCNVTCAT : MCNVTCAT replacement in REXX                     */\n/**********************************************************************/\n/* RCNVTCAT : Uses Catalog Search Interface (CSI)                     */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */\n/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */\n/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */\n/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */\n/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */\n/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */\n/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/\n/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */\n/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */\n/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */\n/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */\n/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */\n/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */\n/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */\n/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */\n/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/\n/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */\n/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */\n/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/\n/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */\n/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This program writes out various error messages, the return and  */\n/*    reason codes can be checked using those found listed for the    */\n/*    IBM message IDC3009I. The module is the CSI internal reference  */\n/*    and probably isn't of much use to anyone outside IBM.           */\n/*                                                                    */\n/* 2. Two return codes are 'special' :                                */\n/*    RC=100, Reason=4                                                */\n/*    RC=44 , Reason=14                                               */\n/*    These relate to entries of greater than 65535 characters.       */\n/*    If you get these entries, then you need to enable fullword      */\n/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */\n/*                                                                    */\n/**********************************************************************/\n/* So how does this differ from the original MCNVTCAT ?               */\n/*                                                                    */\n/* 1. Well it's written in REXX and uses the Catalog Search Interface */\n/*                                                                    */\n/* 2. It doesn't check the actual devices available on the system     */\n/*    (So you may get a catalog entry for a non-present device type)  */\n/*                                                                    */\n/* 3. It doesn't add bits of LISTCAT messages into the report totals  */\n/*    or the generated members.                                       */\n/*                                                                    */\n/* 4. It DOES handle datasets cataloged on more than five volume !    */\n/*    (So doesn't write out an error message for that condition)      */\n/*                                                                    */\n/* 5. I'm pretty sure that it doesn't handle SYSCTLG properly. As     */\n/*    the manual states that OS CVOLs don't work after 01/01/2000 I   */\n/*    guess this shouldn't be an issue for many out there.            */\n/*                                                                    */\n/* 6. It writes its report to the REPORT member of the PDS rather     */\n/*    than to a SYSOUT.                                               */\n/*                                                                    */\n/* 7. It generates a RECAT member that contains statements to allow   */\n/*    the RECATALOG of PAGESPACE and SYS1.** datasets.                */\n/*                                                                    */\n/*    Currently this only supports VSAM clusters with the following   */\n/*    non-default attributes : LINEAR, REUSE                          */\n/*                                                                    */\n/* 8. It can be used to compare two catalogs and produces reports     */\n/*    showing the differences between the catalogs.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no OMVS environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt = '**'                           /* Set the filter                */\ntyp = ' '                            /* Set entry types required      */\nct1 = ' '                            /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Handle passed parameters                                           */\n/**********************************************************************/\nArg vals                             /* Get passed arguments          */\nargnum = 0                           /*                               */\nDo i = 1 to Words(vals)              /* loop thru arguments           */\n testarg = Strip(Word(vals,i),B,\"'\") /* remove inverted commas        */\n Upper testarg                       /* convert to upper case         */\n Select                              /*                               */\n  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */\n   Do                                /*                               */\n    debug = Substr(testarg,7,1)      /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End                               /*                               */\n  When (testarg = '?') Then          /*                               */\n   Do                                /*                               */\n    Say \"RCNVTCAT requires either one or two parameters\"\n    Say \" - RCNVTCAT catname       : produces MCNVTCAT type output\"\n    Say \" - RCNVTCAT oldcat newcat : produces catalog comparison output\"\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    argnum = argnum + 1              /*                               */\n    cat.argnum = testarg             /*                               */\n   End                               /*                               */\n End                                 /*                               */\nEnd                                  /*                               */\nSelect                               /*                               */\n When (argnum = 0) Then              /*                               */\n  Do                                 /*                               */\n   Say '**(cat)** No entry provided for catalog name.'\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\n When (argnum = 1) Then              /* only one catalog              */\n  process = 'RCNVTCAT'               /* process as normal RCNVTCAT    */\n When (argnum = 2) Then              /* two catalogs                  */\n  process = 'CATCOMP'                /* process for Catalog compare   */\n Otherwise                           /* two catalogs                  */\n  Do                                 /*                               */\n   Say '**(cat)** Too many arguments - retry.'\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\nIf (Address() = 'TSO') Then\n Do                                  /*                               */\n  If (ListDSI(\"'\"cat.1\"'\") > 4) Then /*                               */\n   Do                                /*                               */\n    Say '**(cat)** Bad entry provided for catalog name.'\n    Say '**(cat)** 'cat.1\n    Say '**(cat)** LISTDSI Return code = 'sysreason\n    Say '**(cat)** 'sysmsglvl1\n    Say '**(cat)** 'sysmsglvl2\n    Signal FINISH                    /* exit exec                     */\n   End                               /*                               */\n  If (process = 'CATCOMP') &,        /* Catalog compare processing    */\n     (ListDSI(\"'\"cat.2\"'\") > 4) Then /* bad return                    */\n   Do                                /*                               */\n    Say '**(cat)** Bad entry provided for second catalog name.'\n    Say '**(cat)** 'cat.2\n    Say '**(cat)** LISTDSI Return code = 'sysreason\n    Say '**(cat)** 'sysmsglvl1\n    Say '**(cat)** 'sysmsglvl2\n    Signal FINISH                    /* exit exec                     */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /*                               */\n Do                                  /*                               */\n  Say '**(cat)** Catalog validation not carried out in non-TSO'\n  Say '**(cat)** address space.'\n End                                 /*                               */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nIf (process = 'RCNVTCAT') Then       /* Process as RCNVTCAT           */\n Do                                  /*                               */\n  count.id = 0                       /* initialise count              */\n  member = 'ALIAS'                   /* processing ALIAS              */\n  x = CSI(cat.1,'**','X','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'NONVSAM'                 /* processing NONVSAM            */\n  x = CSI(cat.1,'**','AH','Y')       /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYS1'                    /* processing SYS1               */\n  x = CSI(cat.1,'SYS1.**','AH','Y')  /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'IMPORT'                  /* processing IMPORT             */\n  x = CSI(cat.1,'**','U','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'GDG'                     /* processing GDG                */\n  x = CSI(cat.1,'**','B','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'MISC'                    /* processing MISC               */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'RECAT'                   /* processing RECAT (MISC+)      */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYSCTLG'                 /* processing SYSCTLG            */\n  x = CSI(cat.1,'SYSCTLG.**','AH','Y') /* Call CSI                    */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'REPORT'                  /* processing REPORT             */\n  Call MEM_REPORT                    /* generate report               */\n  Call WRITE_MEMBER                  /* write out member              */\n End                                 /*                               */\nElse                                 /* Process as Catalog compare    */\n Do                                  /*                               */\n  id = 'OLD'                         /* specify for 'old' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.old = cat.1                    /* retain catalog name           */\n  x = CSI(cat.1,flt,' ','Y')         /* Call CSI procedure            */\n  id = 'NEW'                         /* specify for 'NEW' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.new = cat.2                    /* retain catalog name           */\n  x = CSI(cat.2,flt,' ','Y')         /* Call CSI procedure            */\n  member = 'COMPFULL'                /* processing FULL comparison    */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'COMPSHRT'                /* processing SHORT comparison   */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'EXTRA'                   /* processing EXTRA member       */\n  Call NEW_EXT                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'CHANGED'                 /* processing CHANGED member     */\n  Call OLD_BAD                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n End                                 /*                               */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"sysdsname\"') VOLUME(\"sysvolume\")\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat.1,1,44)        /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword used        */\n Say '**(csi)***** Fullword processing selected'\nElse                                 /* check if fullword used        */\n Say '**(csi)***** Halfword processing - default'\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '000E'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */\ncsifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('ATTR1   ',8)        /* Attributes                    */\ncsifld09 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld10 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld11 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld12 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld13 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld14 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13||csifld14\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  If (debug = 2) Then                /*                               */\n   Do                                /*                               */\n    Say 'off=<'off'>'                /*                               */\n    Say 'entry =<'Substr(dwork,off,150)'>'\n    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'\n   End                               /*                               */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    Select                           /*                               */\n     When (csienter = '1') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     When (csiedata = '0') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* No data returned'\n       Say '**(Error-3)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     Otherwise                       /*                               */\n      Do                             /*                               */\n       If (csioptns = 'F') Then      /* check if fullword requested   */\n        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */\n       Else                          /* otherwise (default halfword)  */\n        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */\n       Call ENTRY                    /* Execute entry processing      */\n       plus = 46 + csitotln          /* length for normal entry       */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ngdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */\ngdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */\nattr1    = Substr(dwork,o_fld.8,l_fld.8)   /* attributes              */\ncattr    = Substr(dwork,o_fld.9,l_fld.9)   /* attribs page and swap   */\ndevtyp   = Substr(dwork,o_fld.10,l_fld.10) /* device type             */\nvolser   = Substr(dwork,o_fld.11,l_fld.11) /* volume serial           */\nfileseq  = Substr(dwork,o_fld.12,l_fld.12) /* file sequence           */\nvsamreus = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.14,l_fld.14) /* VSAM dataset information*/\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ATTR1') > 0) Then    /*                           */\n Call FLD_ATTR1                          /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /*                           */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /*                           */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ATTR1    - Process ATTR1    field                              */\n/**********************************************************************/\nFLD_ATTR1:                           /* ATTR1    field processing   ##*/\nattr1 = X2b(c2x(attr1))              /*                               */\nIf (Substr(attr1,1,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' SPEED'       /*                               */\nIf (Substr(attr1,3,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nIf (Substr(attr1,4,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' ERASE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nReturn                               /* duplicates ATTR1              */\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype /= 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nIf (entype /= 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                \"Blksize(1330) Recfm(F,B) New Reuse\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    x = Listdd(REPORT)               /*                               */\n    dsn = sysdsname                  /*                               */\n   End                               /*                               */\nElse                                 /*                               */\n dsn = sysdsname                     /* get dataset name from DD      */\nIf (sysvolume = '*JES**') Then       /*                               */\n Do                                  /*                               */\n  Say '**(Warning-1)* For execution in batch, it is recommended that'\n  Say '**(Warning-2)* a PDS is pre-allocated to DD name REPORT.'\n  Say '**(Warning-3)* Processing will continue with sequential output.'\n  outflag = 'JES'                    /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nali_tot = 0                          /* Total Aliases                 */\nasy_tot = 0                          /* Total Aliases SYSCATLG        */\nanv_tot = 0                          /* Total Aliases NONVSAM         */\naxx_tot = 0                          /* interim alias total           */\navu_tot = 0                          /* Total Aliases VSAM UCAT       */\ngdg_tot = 0                          /* Total GDGs                    */\nivd_tot = 0                          /* Total invalid devices         */\nmsc_tot = 0                          /* Total MISC datasets           */\nnvd_tot = 0                          /* Total NONVSAM datasets        */\nnvo_tot = 0                          /* Total NONVSAM (not SYS1) dsns */\nnvv_tot = 0                          /* Total NONVSAM dsn volumes     */\nsyc_tot = 0                          /* Total SYSCTLG datasets        */\nsy1_tot = 0                          /* Total NONVSAM SYS1 datasets   */\nuct_tot = 0                          /* Total Usercatalog imports     */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDD:                                     /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\n                                     /*                               */\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n  Say '**(cat)** Processing 'Left('CATALOG',10) csicname\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  If (process = 'CATCOMP') Then      /** Catalog compare code        **/\n   Do                                /*                               */\n    count.id           = count.id+1  /* increment count               */\n    val                = count.id    /* save value                    */\n    entname.id.val     = entname     /* store entry name              */\n    entype.id.val      = entype      /* store entry type              */\n    name.id.val        = name        /* store assoc name              */\n    type.id.val        = type        /* store assoc type              */\n    pageswap.id.val    = pageswap    /* store pageswap                */\n    devices.id.val     = devices     /* store devices                 */\n    fils.id.val        = fils        /* store fils                    */\n    gdg_emp.id.val     = gdg_emp     /* store gdg_emp                 */\n    gdg_scr.id.val     = gdg_scr     /* store gdg_scr                 */\n    gdglimit.id.val    = gdglimit    /* store gdglimit                */\n    vsam_attr.id.val   = vsam_attr   /* store vsam_attr               */\n    vsam_type.id.val   = vsam_type   /* store vsam_attr               */\n    vsam_vvds.id.val   = vsam_vvds   /* store vsam_vvds               */\n    volsers.id.val     = volsers     /* store volsers by value        */\n                                     /** Back reference values       **/\n    volsers.id.entname = volsers     /* store volsers by entry name   */\n    name.id.entname    = name        /* store name by entry name      */\n    val.id.entname     = val         /* store value by entry name     */\n   End                               /** End Catalog compare code    **/\n  Else                               /*                               */\n   Do                                /*                               */\n    Select                           /*                               */\n     When (member = 'MISC') Then     /* MISC member                   */\n      Call MEM_MISC                  /*                               */\n     When (member = 'RECAT') Then    /* RECAT member                  */\n      Call MEM_RECAT                 /*                               */\n     When (member = 'ALIAS') Then    /* ALIAS member                  */\n      Call MEM_ALIAS                 /*                               */\n     When (member = 'GDG') Then      /* GDG member                    */\n      Call MEM_GDG                   /*                               */\n     When (member = 'IMPORT') Then   /* IMPORT member                 */\n      Call MEM_IMPORT                /*                               */\n     When (member = 'NONVSAM') Then  /* NONVSAM member                */\n      Do                             /*                               */\n       axx_tot = anv_tot             /* set intermim alias total      */\n       nvd_tot = nvd_tot + 1         /* increment total non-vsam      */\n       nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols        */\n       If (Substr(entname,1,4) /= 'SYS1') &,\n          (Substr(entname,1,7) /= 'SYSCTLG') Then /* not SYS1/SYSCTLG */\n        Do                           /*                               */\n         nvo_tot = nvo_tot + 1       /* increment non-vsam only total */\n         Call MEM_NONVSAM            /*                               */\n        End                          /*                               */\n       anv_tot = axx_tot             /* set non-vsam aliases total    */\n      End                            /*                               */\n     When (member = 'SYS1') Then     /* SYS1 member                   */\n      Do                             /*                               */\n       sy1_tot = sy1_tot + 1         /* increment sys1 total          */\n       Call MEM_NONVSAM              /*                               */\n      End                            /*                               */\n     When (member = 'SYSCTLG') Then  /* SYSCTLG member                */\n      Do                             /*                               */\n       axx_tot = asy_tot             /* interim = syscatlg aliases    */\n       syc_tot = syc_tot + 1         /* increment syscatlg total      */\n       Call MEM_NONVSAM              /*                               */\n       asy_tot = axx_tot             /* set syscatlg total            */\n      End                            /*                               */\n     Otherwise NOP                   /*                               */\n    End                              /*                               */\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_MISC - Generate MISC member lines                              */\n/**********************************************************************/\nMEM_MISC:                            /* Generate MISC member lines  ##*/\nIf (entype = 'CLUSTER') |,\n   (entype = 'PAGESPACE') Then\n Do\n  msc_tot = msc_tot + 1\n  l_cnt = l_cnt + 1\n  text = ' /* 'Left(entype' ',15,'-')\n  text = text' 'Left(entname,32)'  NOT PROCESSED */'\n  l.l_cnt = text\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_RECAT - Generate RECAT member lines                            */\n/**********************************************************************/\nMEM_RECAT:                           /* Generate RECAT member lines ##*/\nIf (entype = 'PAGESPACE') Then\n Do\n  page_name     = entname\n  page_swap     = pageswap\n  If (Index(type,'D') /= 0) Then\n   data_flag = 'DATA'\n  Else\n   data_flag = ''\n End\nIf (entype = 'CLUSTER') Then\n Do\n  If (Substr(entname,1,4) /= 'SYS1') Then\n   Do\n    cluster_name  = entname\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left(entype' ',15,'-')\n    text = text' 'Left(entname,34)' CANNOT RECAT */'\n    data_flag = ''\n    index_flag = ''\n    l.l_cnt = text\n   End\n  Else\n   Do\n    cluster_name  = entname\n    If (Index(type,'D') /= 0) Then\n     data_flag = 'DATA'\n    Else\n     data_flag = ''\n    If (Index(type,'I') /= 0) Then\n     index_flag = 'INDEX'\n    Else\n     index_flag = ''\n    cluster_bits  = type\n   End\n End\nIf (entype = 'DATA') &,\n   (data_flag = 'DATA') Then\n Select\n  When (vsam_vvds = 'Y') Then               /* use VVDS flag          */\n   Do\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left('VVDS ',15,'-')\n    text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'\n    l.l_cnt = text\n   End\n  When (Index(name,page_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF PAGESPACE(NAME('Left(page_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left(page_swap,57)' -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          CAT('Left(cat,44)'        )'\n   End\n  When (Index(name,cluster_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF   CLUSTER(NAME('Left(cluster_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    If (vsam_attr /= '') Then\n     Do\n      l_cnt = l_cnt + 1\n      l.l_cnt = '          'Left(vsam_attr,57)' -'\n     End\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '         DATA(NAME('Left(entname,44)'   ) ) -'\n    If (index_flag = '') Then\n     Do\n      l_cnt = l_cnt + 1\n      l.l_cnt = '          CAT('Left(cat,44)'        )'\n     End\n   End\n  Otherwise\n   Say '**(Error--1)* Unexpected condition for :'\n   Say '**(Error--2)* cluster_name = 'Strip(cluster_name,T)\n   Say '**(Error--3)* page_name    = 'Strip(page_name,T)\n   Say '**(Error--4)* entname      = 'Strip(entname,T)\n   Say '**(Error--5)* entype       = 'Strip(entype,T)\n   Say '**(Error--6)* name         = 'Strip(name,T)\n   Say '**(Error--7)* type         = 'Strip(type,T)\n   Say '**(Error--8)* data_flag    = 'Strip(data_flag,T)\n   Say '**(Error--9)* index_flag   = 'Strip(index_flag,T)\n   Say '**(Error-10)* vsam_byte1   = 'vsam_byte1\n   Say '**(Error-11)* vsam_byte2   = 'vsam_byte2\n   Say '**(Error-12)* vsamreus     = 'vsamreus\n End\nIf (entype = 'INDEX') &,\n   (index_flag = 'INDEX') Then\n Do\n  l_cnt = l_cnt + 1\n  l.l_cnt = '         INDEX(NAME('Left(entname,44)'  ) ) -'\n  l_cnt = l_cnt + 1\n  l.l_cnt = '          CAT('Left(cat,44)'        )'\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_ALIAS - Generate ALIAS member lines                            */\n/**********************************************************************/\nMEM_ALIAS:                           /* Generate ALIAS member lines ##*/\nali_tot = ali_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '     DEF ALIAS(REL('name') -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          NAME('entname'))     -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,44)'         )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_IMPORT - Generate IMPORT member lines                          */\n/**********************************************************************/\nMEM_IMPORT:                          /* Generate IMPORT member lins ##*/\nuct_tot = uct_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '    IMPORT   OBJ( ('entname'  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          DEVT('Left(devices,8)') VOL('volser')))'\nl.l_cnt = l.l_cnt' 'Left('CONNECT',26)' -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_GDG - Generate GDG member lines                                */\n/**********************************************************************/\nMEM_GDG:                             /* Generate GDG member lines   ##*/\ngdg_tot = gdg_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  GDG  (NAME('entname') -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          LIMIT('Right(gdglimit,3)') 'Left(gdg_scr,16)\nl.l_cnt = l.l_cnt' 'Left(gdg_emp,24)' )  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_NONVSAM - Generate NONVSAM member lines                        */\n/**********************************************************************/\nMEM_NONVSAM:                         /* Generate NONVSAM member lins##*/\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  NVSAM(NAME('entname') -'\nIf (Words(devices) <= 5) Then        /* < 5 devices for dataset       */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          DEVT( 'Left(devices,47)') -'\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq /= '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = '          FSEQN('Left(fileseq,47)') -'\n   End                               /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          VOL(  'Left(volser,47)') )-'\n End                                 /*                               */\nElse                                 /* > 5 devices for dataset       */\n Do                                  /*                               */\n  item_lead = 'DEVT( '               /* devices header                */\n  item_end  = ') -'                  /* devices trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = devices                    /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq /= '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    item_lead = 'FSEQN('             /* fileseq header                */\n    item_end  = ') -'                /* fileseq trailer               */\n    item_pad  = Left('',7)           /* 7 spaces padding              */\n    items = fileseq                  /* pass data                     */\n    Call PLUS5_HANDLE                /* handle > 5 items              */\n   End                               /*                               */\n  item_lead = 'VOL(  '               /* volumes header                */\n  item_end  = ') ) -'                /* volumes trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = volser                     /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n End                                 /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ASSOC_ENTRY - Process associated entries                           */\n/**********************************************************************/\nASSOC_ENTRY:                         /* Process associated entries  ##*/\nDo ali = 1 to Words(name)\n If (Substr(type,ali,1) = 'X') Then\n  Do\n   axx_tot = axx_tot + 1\n   l_cnt = l_cnt + 1\n   l.l_cnt = '     DEF ALIAS(REL('entname') -'\n   l_cnt = l_cnt + 1\n   l.l_cnt = '          NAME('Left(Word(name,ali),44)'))     -'\n   l_cnt = l_cnt + 1\n   l.l_cnt = '          CAT('Left(cat,44)'         )'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM               */\n/**********************************************************************/\nPLUS5_HANDLE:                        /* Handle > 5 fields           ##*/\nl_cnt = l_cnt + 1\nw_end = Wordindex(items,6)\ndata = Left(Substr(items,1,w_end-1),47)\nl.l_cnt = '          'item_lead||data' -'\nDo mult = 6 to Words(items) by 5\n w_sta = Wordindex(items,mult)\n w_end = Wordindex(items,mult+5)\n If (w_end = 0) Then\n  item = Substr(items,w_sta)\n Else\n  item = Substr(items,w_sta,w_end-w_sta)\n l_cnt = l_cnt + 1\n item_length = 47 - Length(item_pad)\n l.l_cnt = '                '||item_pad||Left(item,item_length)' -'\nEnd\nl.l_cnt = Strip(l.l_cnt,T,'-')||item_end\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_REPORT - Generate REPORT member                                */\n/**********************************************************************/\nMEM_REPORT:                          /* Generate REPORT member      ##*/\nr.1  = 'OS CVOL CATALOG NAMES TO BE CONVERTED'\nr.2  = '*RCNVTCAT*  C O N V E R S I O N   R E P O R T'\nr.3  = ' '\nr.4  = 'TOTAL NUMBER OF ALIAS STMTS IN CATALOG                  '\nr.5  = 'ALIAS STMTS ASSOCIATED WITH OS CVOL CATALOGS            '\nr.6  = 'ALIAS STMTS ASSOCIATED WITH VSAM USER CATALOGS          '\nr.7  = 'ALIAS STMTS ASSOCIATED WITH NON VSAM DATA SETS          '\nr.8  = '                                                        '\nr.9  = 'NUMBER OF VSAM USER CATALOGS                            '\nr.10 = '                                                        '\nr.11 = 'TOTAL NUMBER OF NON VSAM DATA SETS  IN CATALOG          '\nr.12 = 'VOLUMES ASSOCIATED WITH NON VSAM DATA SETS. SEE NOTE 1  '\nr.13 = 'OS CVOL CATALOGS WITH THE FOLLOWING NAMES:              '\nr.14 = 'SYSCTLG.VXXXXXX  -  XXXXXX = VOLUME                     '\nr.15 = 'OS CVOL CATALOG NAMES CONVERTED TO                      '\nr.16 = 'SYSCTLG.VXXXXXX . SEE NOTE 2 AND SYSPRINT OUTPUT LISTING'\nr.17 = 'NON VSAM DATA SETS STARTING WITH SYS1.---               '\nr.18 = 'ALL OTHER NON VSAM DATA SETS                            '\nr.19 = '                                                        '\nr.20 = 'NUMBER OF GENERATION DATA GROUP STMTS                   '\nr.21 = '                                                        '\nr.22 = 'NUMBER OF STATEMENTS WHICH COULD  N O T  BE PROCESSED   '\nr.23 = '                                                        '\nr.24 = 'NUMBER OF STATEMENTS WHICH CONTAIN AN INVALID           '\nr.25 = 'DEVICE TYPE. SEE NOTE 3                                 '\nr.26 = 'TOTAL NUMBER OF STATEMENTS WHICH WERE PROCESSED         '\nr.27 = 'SUM OF STATEMENTS WHICH WERE PROCESSED FOR              '\nr.28 = 'ALIAS/IMPORT/NONVSAM/GDG AND MISC. SEE NOTE 4           '\ntot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot\nsta_tot = tot_tot + ali_tot\nr.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '||r.4\nr.5  = ' ALIAS  SYSCTLG ........... 'Right(asy_tot,8)'      '||r.5\nr.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '||r.6\nr.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '||r.7\nr.8  = '                                          '||r.8\nr.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '||r.9\nr.10 = '                                          '||r.10\nr.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '||r.11\nr.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '||r.12\nr.13 = ' OS CVOL SYSCTLG ....(M)... 'Right(syc_tot,8)'      '||r.13\nr.14 = '                                          '||r.14\nr.15 = ' SYSCTLG CONVERTED ........        0      '||r.15\nr.16 = '                                          '||r.16\nr.17 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '||r.17\nr.18 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '||r.18\nr.19 = '                                          '||r.19\nr.20 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '||r.20\nr.21 = '                                          '||r.21\nr.22 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '||r.22\nr.23 = '------------------------------------      '||r.23\nr.24 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '||r.24\nr.25 = '                                          '||r.25\nr.26 = 'NO. OF STMTS PROC ......... 'Right(sta_tot,8)'      '||r.26\nr.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '||r.27\nr.28 = '                                          '||r.28\nr.29 = '(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES'\nr.30 = 'NOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME '\nr.31 = 'NOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVER'\nr.32 = 'NOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!'\nr.33 = 'NOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. T'\nr.31 = r.31||'TED TO SYSCTLG.VXXXXXX, XXXXXX = VOLUME'\nr.32 = r.32||'. BETTER CHECK THE CODE !?!'\nr.33 = r.33||'HEY ARE PROCESSED TWICE'\nl_cnt = 33\nDo loop = 1 to 33\n l.loop = r.loop\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* COMP_REPORT - Produce the Catalog comparison report                */\n/**********************************************************************/\nCOMP_REPORT:                         /* Produce the catalog compare ##*/\nl_cnt = 0\nDo loop = 1 to count.OLD\n entname = entname.OLD.loop\n entype  = entype.OLD.loop\n name    = name.OLD.loop\n volsers = volsers.OLD.loop\n flag.entname = 'Y'\n If (member = 'COMPFULL') Then\n  Do\n   disp_ent = entname\n   disp_entype = Left(entype,8)\n  End\n Else\n  Do\n   disp_ent = Left(entname,36)\n   disp_entype = Left(substr(entype,1,3),4)\n  End\n disp_vol = Strip(volsers,B)\n If (Symbol('val.NEW.entname') = 'LIT') Then\n  Do\n   l_cnt = l_cnt + 1\n   Select\n    When (entype = 'ALIAS  '  ) Then\n     detail = Strip(name.OLD.loop,B)\n    When (entype = 'DATA'     ) |,\n         (entype = 'INDEX'    ) Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)||' ',\n              Strip(vsam_type.OLD.loop,B)||' ',\n              Strip(vsam_attr.OLD.loop,B)\n    When (entype = 'NONVSAM'  ) |,\n         (entype = 'GDG'      ) |,\n         (entype = 'UCAT'     ) |,\n         (entype = 'PAGESPACE') Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)\n    Otherwise NOP\n   End\n   l.l_cnt = disp_entype||disp_ent' --missing - 'detail\n   status.OLD.loop = 'MISSING'\n  End\n Else\n  Do\n   namenew = name.NEW.entname\n   volsnew = volsers.NEW.entname\n   Select\n    When (namenew /= name) Then\n     Do\n      If (entype = 'ALIAS') Then\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##catalog was 'Strip(name,B)' is 'Strip(namenew,B)\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADCAT'\n       End\n      Else\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##related entries do not match.'\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADENT'\n       End\n     End\n    When (volsnew /= volsers) Then\n     Do\n      l_cnt = l_cnt + 1\n      err_text = ' ##volser was 'disp_vol' is 'Strip(volsnew,B)\n      l.l_cnt = disp_entype||disp_ent||err_text\n      status.OLD.loop = 'BADVOL'\n     End\n    Otherwise\n     l_cnt = l_cnt + 1\n     l.l_cnt = disp_entype||disp_ent' **entry matches.'\n     status.OLD.loop = 'OK'\n   End\n  End\nEnd\nDo loop = 1 to count.NEW\n entname = entname.NEW.loop\n entype  = entype.NEW.loop\n volsers = volsers.NEW.loop\n If (flag.entname /= 'Y') Then\n  Do\n   If (member = 'COMPFULL') Then\n    Do\n     disp_ent = entname\n     disp_entype = Left(entype,8)\n    End\n   Else\n    Do\n     disp_ent = Left(entname,36)\n     disp_entype = Left(substr(entype,1,3),4)\n    End\n   disp_vol = Strip(volsers,B)\n   l_cnt = l_cnt + 1\n   l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol\n   status.NEW.loop = 'NEW'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* NEW_EXT - Process for new entries                                  */\n/**********************************************************************/\nNEW_EXT:                             /* Process new entries         ##*/\nDo loop = 1 to count.NEW             /*                               */\n If (status.NEW.loop = 'NEW') Then   /*                               */\n  Do                                 /*                               */\n   entname = entname.NEW.loop        /*                               */\n   entype  = entype.NEW.loop         /*                               */\n   If (entype = 'DATA') |,           /*                               */\n      (entype = 'INDEX') Then        /*                               */\n    Iterate                          /*                               */\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry not present in catalog \"cat.old\". */\"\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry present in catalog     \"cat.new\". */\"\n   Call ENTRY_DEL                    /* process an entry delete       */\n  End                                /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* OLD_BAD - Process for old entries                                  */\n/**********************************************************************/\nOLD_BAD:                             /* Process old entries         ##*/\nDo loop = 1 to count.OLD             /*                               */\n entname   = entname.OLD.loop        /*                               */\n entype    = entype.OLD.loop         /*                               */\n volsers   = volsers.OLD.loop        /*                               */\n volser    = Strip(volsers,B)        /*                               */\n name      = name.OLD.loop           /*                               */\n type      = type.OLD.loop           /*                               */\n pageswap  = pageswap.OLD.loop       /*                               */\n devices   = devices.OLD.loop        /*                               */\n fils      = fils.OLD.loop           /*                               */\n gdg_emp   = gdg_emp.OLD.loop        /*                               */\n gdg_scr   = gdg_scr.OLD.loop        /*                               */\n gdglimit  = gdglimit.OLD.loop       /*                               */\n vsam_attr = vsam_attr.OLD.loop      /*                               */\n vsam_type = vsam_type.OLD.loop      /*                               */\n vsam_vvds = vsam_vvds.OLD.loop      /*                               */\n namenew   = name.NEW.entname        /*                               */\n volsnew   = volsers.NEW.entname     /*                               */\n If (entype = 'DATA') |,             /*                               */\n    (entype = 'INDEX') Then          /*                               */\n  Iterate                            /*                               */\n Select                              /*                               */\n  When (status.OLD.loop = 'MISSING') Then /*                          */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Entry missing in catalog \"cat\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADCAT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Alias incorrectly pointing to \"namenew\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADENT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Related entries do not match */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* entry \"Strip(entname,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* old \"Strip(name,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* new \"Strip(namenew,T)\" */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADVOL') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Volume incorrect - was \"volsnew\". */\"\n   End                               /*                               */\n  Otherwise Iterate                  /*                               */\n End                                 /*                               */\n Call ENTRY_DEL                      /* process an entry delete       */\n Call ENTRY_CHG                      /* process an entry change       */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_DEL - Create a DELETE statement                              */\n/**********************************************************************/\nENTRY_DEL:                           /* Create an entry DELETE      ##*/\nIf (entype = 'NONVSAM') Then         /*                               */\n tparm = ''                          /*                               */\nElse                                 /*                               */\n tparm = entype                      /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      DELETE \"Strip(entname,T)\" \"tparm\" NOSCRATCH -\"\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"             CAT(\"Left(cat,44)\"         )\"\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      SET MAXCC=0\"\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_CHG - Create a changed entry statement                       */\n/**********************************************************************/\nENTRY_CHG:                           /* Create a changed entry      ##*/\nSelect                               /*                               */\n When (entype = 'NONVSAM') Then      /*                               */\n  Call MEM_NONVSAM                   /*                               */\n When (entype = 'ALIAS') Then        /*                               */\n  Call MEM_ALIAS                     /*                               */\n When (entype = 'GDG') Then          /*                               */\n  Call MEM_GDG                       /*                               */\n Otherwise NOP                       /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RCNVTC01": {"ttr": 5636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01G\\x00V\\x01\\x16#O\\x01\\x160\\x7f\\x15\\x18\\x06\\xde\\x06\\xdf\\x00\\x00\\xd6\\xd3\\xc4@@@@@@@'", "ispf": {"version": "01.71", "flags": 0, "createdate": "2016-08-21T00:00:00", "modifydate": "2016-11-02T15:18:56", "lines": 1758, "newlines": 1759, "modlines": 0, "user": "OLD"}, "text": "/* REXX - RCNVTCAT : MCNVTCAT replacement in REXX                     */\n/**********************************************************************/\n/* RCNVTCAT : Uses Catalog Search Interface (CSI)                     */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* The report dataset will now always be dynamically allocated        */\n/* and will be userid/prefix.rcnvtcat.report.Tnnnn                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */\n/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */\n/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */\n/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */\n/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */\n/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */\n/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/\n/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */\n/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */\n/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */\n/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */\n/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */\n/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */\n/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */\n/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */\n/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/\n/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */\n/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */\n/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/\n/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */\n/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */\n/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */\n/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &           */\n/*                                        make UNIX shell compatible  */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This program writes out various error messages, the return and  */\n/*    reason codes can be checked using those found listed for the    */\n/*    IBM message IDC3009I. The module is the CSI internal reference  */\n/*    and probably isn't of much use to anyone outside IBM.           */\n/*                                                                    */\n/* 2. Two return codes are 'special' :                                */\n/*    RC=100, Reason=4                                                */\n/*    RC=44 , Reason=14                                               */\n/*    These relate to entries of greater than 65535 characters.       */\n/*    If you get these entries, then you need to enable fullword      */\n/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */\n/*                                                                    */\n/**********************************************************************/\n/* So how does this differ from the original MCNVTCAT ?               */\n/*                                                                    */\n/* 1. Well it's written in REXX and uses the Catalog Search Interface */\n/*                                                                    */\n/* 2. It doesn't check the actual devices available on the system     */\n/*    (So you may get a catalog entry for a non-present device type)  */\n/*                                                                    */\n/* 3. It doesn't add bits of LISTCAT messages into the report totals  */\n/*    or the generated members.                                       */\n/*                                                                    */\n/* 4. It DOES handle datasets cataloged on more than five volume !    */\n/*    (So doesn't write out an error message for that condition)      */\n/*                                                                    */\n/* 5. I'm pretty sure that it doesn't handle SYSCTLG properly. As     */\n/*    the manual states that OS CVOLs don't work after 01/01/2000 I   */\n/*    guess this shouldn't be an issue for many out there.            */\n/*                                                                    */\n/* 6. It writes its report to the REPORT member of the PDS rather     */\n/*    than to a SYSOUT.                                               */\n/*                                                                    */\n/* 7. It generates a RECAT member that contains statements to allow   */\n/*    the RECATALOG of PAGESPACE and SYS1.** datasets.                */\n/*                                                                    */\n/*    Currently this only supports VSAM clusters with the following   */\n/*    non-default attributes : LINEAR, REUSE                          */\n/*                                                                    */\n/* 8. It can be used to compare two catalogs and produces reports     */\n/*    showing the differences between the catalogs.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nIf (Address() = 'TSO') Then          /* test if under TSO             */\n Do                                  /*                               */\n  x = Msg('Off')                     /* Disable messages              */\n  x = Prompt('Off')                  /* Disable prompts               */\n End                                 /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\ncvt      = Storage(10,4)             /* get the CVT address           */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16) /* get the prefix             */\nmvsfmid  = Substr(cvtpfx,9,7)        /* get the mvs fmid              */\nIf (Substr(mvsfmid,4,4) >= 6603) Then/* test for OS/390 R3 and greater*/\n omvs_flag = 'OMVS'                  /* set OMVS flag                 */\nIf Address() = 'SH' Then             /* test for UNIX shell environ   */\n sh_flag = 'SH'\nIf (Mvsvar(\"SYSSMS\") = 'ACTIVE') Then/* test for SMS environment      */\n sms_flag = 'SMS'                    /* set SMS flag                  */\nIf (Address() = 'TSO') Then          /* test for tso environment      */\n tso_flag = 'TSO'                    /* set TSO flag                  */\nIf (tso_flag = 'TSO') Then           /* if TSO environment            */\n Do                                  /*                               */\n  If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground           */\n   env_flag = 'FORE'                 /* set ENV flag                  */\n  If (Sysvar(\"SYSISPF\") = 'ACTIVE') Then/* test for ISPF              */\n   ispf_flag = 'ISPF'                /* set ISPF flag                 */\n End                                 /*                               */\nIf (omvs_flag /= 'OMVS') &,          /* if no OMVS                    */\n   (sh_flag /= 'SH') &,              /* it not UNIX shell             */\n   (tso_flag /= 'TSO') Then          /* and no TSO                    */\n Do                                  /*                               */\n  Say '**(Error-1)* No TSO environment and no UNIX environment.'\n  Say '**(Error-2)* RCNVTCAT cannot allocate files, so terminating.'\n  Signal FINISH                      /* leave the exec                */\n End                                 /*                               */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt = '**'                           /* Set the filter                */\ntyp = ' '                            /* Set entry types required      */\nct1 = ' '                            /* Set for 1 catalog only        */\nrcnvdsn = ''                         /* set dsn to null               */\n/**********************************************************************/\n/* Handle passed parameters                                           */\n/**********************************************************************/\nArg vals                             /* Get passed arguments          */\nargnum = 0                           /*                               */\nDo i = 1 to Words(vals)              /* loop thru arguments           */\n testarg = Strip(Word(vals,i),B,\"'\") /* remove inverted commas        */\n Upper testarg                       /* convert to upper case         */\n Select                              /*                               */\n  When (Substr(testarg,1,6) = 'DEBUG(') Then /* check for debug       */\n   Do                                /*                               */\n    debug = Substr(testarg,7,1)      /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End                               /*                               */\n  When (testarg = '?') Then          /*                               */\n   Do                                /*                               */\n    Say \"RCNVTCAT requires either one or two parameters\"\n    Say \" - RCNVTCAT catname       : produces MCNVTCAT type output\"\n    Say \" - RCNVTCAT oldcat newcat : produces catalog comparison output\"\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    argnum = argnum + 1              /*                               */\n    cat.argnum = testarg             /*                               */\n   End                               /*                               */\n End                                 /*                               */\nEnd                                  /*                               */\nSelect                               /*                               */\n When (argnum = 0) Then              /*                               */\n  Do                                 /*                               */\n   Say '**(cat)** No entry provided for catalog name.'\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\n When (argnum = 1) Then              /* only one catalog              */\n  process = 'RCNVTCAT'               /* process as normal RCNVTCAT    */\n When (argnum = 2) Then              /* two catalogs                  */\n  process = 'CATCOMP'                /* process for Catalog compare   */\n Otherwise                           /* two catalogs                  */\n  Do                                 /*                               */\n   Say '**(cat)** Too many arguments - retry.'\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\nIf (DsExist(\"'\"cat.1\"'\") > 4) Then /*                               */\n Do                                /*                               */\n  Say '**(cat)** Bad entry provided for catalog name.'\n  Say '**(cat)** 'cat.1\n  Say '**(cat)** LISTDSI Return code = 'sysreason\n  Say '**(cat)** 'sysmsglvl1\n  Say '**(cat)** 'sysmsglvl2\n  Signal FINISH                    /* exit exec                     */\n End                               /*                               */\nIf (process = 'CATCOMP') &,        /* Catalog compare processing    */\n   (DsExist(\"'\"cat.2\"'\") > 4) Then /* bad return                    */\n Do                                /*                               */\n  Say '**(cat)** Bad entry provided for second catalog name.'\n  Say '**(cat)** 'cat.2\n  Say '**(cat)** LISTDSI Return code = 'sysreason\n  Say '**(cat)** 'sysmsglvl1\n  Say '**(cat)** 'sysmsglvl2\n  Signal FINISH                    /* exit exec                     */\n End                               /*                               */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nIf (process = 'RCNVTCAT') Then       /* Process as RCNVTCAT           */\n Do                                  /*                               */\n  count.id = 0                       /* initialise count              */\n  member = 'ALIAS'                   /* processing ALIAS              */\n  x = CSI(cat.1,'**','X','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'NONVSAM'                 /* processing NONVSAM            */\n  x = CSI(cat.1,'**','AH','Y')       /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYS1'                    /* processing SYS1               */\n  x = CSI(cat.1,'SYS1.**','AH','Y')  /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'IMPORT'                  /* processing IMPORT             */\n  x = CSI(cat.1,'**','U','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'GDG'                     /* processing GDG                */\n  x = CSI(cat.1,'**','B','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'MISC'                    /* processing MISC               */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'RECAT'                   /* processing RECAT (MISC+)      */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYSCTLG'                 /* processing SYSCTLG            */\n  x = CSI(cat.1,'SYSCTLG.**','AH','Y') /* Call CSI                    */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'REPORT'                  /* processing REPORT             */\n  Call MEM_REPORT                    /* generate report               */\n  Call WRITE_MEMBER                  /* write out member              */\n End                                 /*                               */\nElse                                 /* Process as Catalog compare    */\n Do                                  /*                               */\n  id = 'OLD'                         /* specify for 'old' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.old = cat.1                    /* retain catalog name           */\n  x = CSI(cat.1,flt,' ','Y')         /* Call CSI procedure            */\n  id = 'NEW'                         /* specify for 'NEW' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.new = cat.2                    /* retain catalog name           */\n  x = CSI(cat.2,flt,' ','Y')         /* Call CSI procedure            */\n  member = 'COMPFULL'                /* processing FULL comparison    */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'COMPSHRT'                /* processing SHORT comparison   */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'EXTRA'                   /* processing EXTRA member       */\n  Call NEW_EXT                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'CHANGED'                 /* processing CHANGED member     */\n  Call OLD_BAD                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n End                                 /*                               */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag = 'FORE') &,            /*                               */\n   (ispf_flag = 'ISPF') Then         /*                               */\n Do                                  /*                               */\n  x = Listdd(REPORT)                 /*                               */\n  Address ISPEXEC \"EDIT DATASET('\"rcnvdsn\"')\"\n  Address TSO \"Free Fi(REPORT)\"      /* free the report file          */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit 0                               /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword used        */\n Say '**(csi)***** Fullword processing selected'\nElse                                 /* check if fullword used        */\n Say '**(csi)***** Halfword processing - default'\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '000E'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */\ncsifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('ATTR1   ',8)        /* Attributes                    */\ncsifld09 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld10 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld11 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld12 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld13 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld14 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13||csifld14\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  If (debug = 2) Then                /*                               */\n   Do                                /*                               */\n    Say 'off=<'off'>'                /*                               */\n    Say 'entry =<'Substr(dwork,off,150)'>'\n    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'\n   End                               /*                               */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    Select                           /*                               */\n     When (csienter = '1') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     When (csiedata = '0') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* No data returned'\n       Say '**(Error-3)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     Otherwise                       /*                               */\n      Do                             /*                               */\n       If (csioptns = 'F') Then      /* check if fullword requested   */\n        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */\n       Else                          /* otherwise (default halfword)  */\n        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */\n       Call ENTRY                    /* Execute entry processing      */\n       plus = 46 + csitotln          /* length for normal entry       */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ngdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */\ngdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */\nattr1    = Substr(dwork,o_fld.8,l_fld.8)   /* attributes              */\ncattr    = Substr(dwork,o_fld.9,l_fld.9)   /* attribs page and swap   */\ndevtyp   = Substr(dwork,o_fld.10,l_fld.10) /* device type             */\nvolser   = Substr(dwork,o_fld.11,l_fld.11) /* volume serial           */\nfileseq  = Substr(dwork,o_fld.12,l_fld.12) /* file sequence           */\nvsamreus = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.14,l_fld.14) /* VSAM dataset information*/\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ATTR1') > 0) Then    /*                           */\n Call FLD_ATTR1                          /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /*                           */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /*                           */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) /= 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ATTR1    - Process ATTR1    field                              */\n/**********************************************************************/\nFLD_ATTR1:                           /* ATTR1    field processing   ##*/\nattr1 = X2b(c2x(attr1))              /*                               */\nIf (Substr(attr1,1,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' SPEED'       /*                               */\nIf (Substr(attr1,3,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nIf (Substr(attr1,4,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' ERASE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nReturn                               /* duplicates ATTR1              */\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype /= 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nIf (entype /= 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member /= 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag /= 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Alloc Fi(MEMOT) Da('\"dsn\"(\"member\")') Shr Reuse\"\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  If (tso_flag = 'TSO') Then         /*                               */\n   Address TSO \"Free Fi(MEMOT)\"      /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    bpxparm = \"Free Fi(MEMOT)\"       /*                               */\n    Call BPXWDYN(bpxparm)            /*                               */\n   End                               /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /*                               */\ndsn = rcnvdsn\nIf sh_flag = 'SH' Then\n Do\n  Address syscall getlogin sysuid\n  random_dsn = 'T'random(9999)\n  rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn\n  bpxparm = \"Alloc \",\n            \"Da(\"rcnvdsn\")\" ,\n            \"Fi(REPORT) \",\n            \"Lrecl(133) \",\n            \"Unit(SYSALLDA)\",\n            \"Space(2,2) \",\n            \"Dir(10) \",\n            \"Cyl \",\n            \"Blksize(1330) \",\n            \"Recfm(F,B) \",\n            \"New \",\n            \"Catalog \",\n            \"Reuse\"\n  rc=BPXWDYN(bpxparm)\n  If rc <> 0 Then\n   Do\n    Say '**(Error-1)* Allocation of DD:REPORT Failed.'\n    Select\n     When rc = 20 Then\n      Say '**(Error-2)* BPXWDYN Invalid Parameter List.'\n     When rc > 0 | rc <-1610612737 Then\n      Do\n       hexrc=right(d2x(rc),8,\"0\")\n       Say '**(Error-2)* Dynamic Allocation error code:'hexcode\n      End\n     When rc <= -21 & rc >= -9999 Then\n      Say '**(Error-2)* Error in key number 'abs(rc)-20\n     When rc <= -10000 & rc >= -10099 Then\n      Say '**(Error-2)* Message processing error. IEFDB476 returned code:',\n           abs(rc)-10000\n    End\n    Signal FINISH\n   End\n  dsn = rcnvdsn                      /*                               */\n  say 'RCNVTCAT Report DSN:' dsn\n  Return\n End\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If (env_flag /= 'FORE') Then        /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* For execution in batch, please ensure that a PDS'\n   Say '**(Error-2)* is pre-allocated to DD name REPORT.'\n   Signal FINISH                     /*                               */\n  End                                /*                               */\n Else                                /*                               */\n  If (ispf_flag /= 'ISPF') Then      /*                               */\n   Do                                /*                               */\n    Say '**(Error-1)* For execution in foreground TSO, please ensure'\n    Say '**(Error-2)* that a PDS is pre-allocated to DD name REPORT.'\n    Signal FINISH                    /*                               */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    random_dsn = 'T'random(9999)\n    if sysvar('syspref') = ''\n       then rcnvdsn = sysvar('sysuid')'.RCNVTCAT.REPORT.'random_dsn\n       else rcnvdsn = sysvar('syspref')'.RCNVTCAT.REPORT.'random_dsn\n    If (tso_flag = 'TSO') Then       /*                               */\n     Address TSO \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                 \"Space(2,2) Dir(10) Cyl \",\n                 \"Dataset('\"rcnvdsn\"')\" ,\n                 \"Blksize(1330) Recfm(F,B) New Reuse\"\n    Else                             /*                               */\n     Do                              /*                               */\n      bpxparm = \"Alloc Fi(REPORT) Lrecl(133) Unit(SYSALLDA)\",\n                \"Space(2,2) Dir(10) Cyl \",\n                 \"Da('\"rcnvdsn\"')\" ,\n                \"Blksize(1330) Recfm(F,B) New Reuse Catalog\"\n      Call BPXWDYN(bpxparm)\n     End                             /*                               */\n    dsn = rcnvdsn                    /*                               */\n   End                               /*                               */\nsay 'RCNVTCAT Report DSN:' dsn\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nali_tot = 0                          /* Total Aliases                 */\nasy_tot = 0                          /* Total Aliases SYSCATLG        */\nanv_tot = 0                          /* Total Aliases NONVSAM         */\naxx_tot = 0                          /* interim alias total           */\navu_tot = 0                          /* Total Aliases VSAM UCAT       */\ngdg_tot = 0                          /* Total GDGs                    */\nivd_tot = 0                          /* Total invalid devices         */\nmsc_tot = 0                          /* Total MISC datasets           */\nnvd_tot = 0                          /* Total NONVSAM datasets        */\nnvo_tot = 0                          /* Total NONVSAM (not SYS1) dsns */\nnvv_tot = 0                          /* Total NONVSAM dsn volumes     */\nsyc_tot = 0                          /* Total SYSCTLG datasets        */\nsy1_tot = 0                          /* Total NONVSAM SYS1 datasets   */\nuct_tot = 0                          /* Total Usercatalog imports     */\nReturn                               /*                               */\n/**********************************************************************/\n\nDsExist: Procedure Expose sysreason sysmsglvl1 sysmsglvl2\nparse arg indsn\nsysreason=0\nsysmsglvl1=' Not Emulated '\nsysmsglvl2=' Not Emulated '\nIf indsn = '' Then\n Do\n   sysreason=29\n   return 16\n End\nxx=outtrap('junk.','*') /* I don't care */\nAddress TSO \"LISTCAT ENT(\"indsn\")\"\nlrc=rc\nsysreason=rc\nhexrc=right(d2x(rc),8,\"0\")\nxx=outtrap(\"OFF\")\nIf \"0438\" = left(hexrc,4) Then\n Do\n  sysreason=24\n  Return 16\n End\ndrop junk.\nreturn lrc\nLISTDD:   /* new routine */\nrc=bpxwdyn(\"INFO \",\n           \"DD(REPORT) \",\n           \"INRTDSN(rcnvdsn) \",\n           \"INRDSNT(dsntype) \",\n           \"INRTORG(dsorg) \",\n           \"MSG(message.)\")\nIf rc <> 0 Then\n Do\n  rcnvdsn=''\n  return 16\n End\nif dsntype <> \"PDS\" then return 8\nif 'PO' <> left(dsorg,2) then return 8\nreturn 0\n/* Old implementation */\n call outtrap 'x.'\n 'lista sta'\n call outtrap 'off'\n\n do i = 1 to x.0\n    if left(x.i,1) /= ' ' then iterate\n    if word(x.i,1) = 'REPORT' then do\n       id = i - 1\n       rcnvdsn = word(x.id,1)\n       leave\n       end\n    end\n  if rcnvdsn = '' then return 16\n  return 0\n*/\n\n/**********************************************************************/\n/* LISTDD   - Get the dataset and volume for a selected DD name       */\n/**********************************************************************/\nLISTDDO:                                    /*                        */\nArg dd                                      /*                        */\nNumeric Digits 20                           /*                        */\ndrc = 16                                    /*                        */\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\noffset   = 24                               /* establish tiot offset  */\nDo Forever                                  /*                        */\n tioelngh = Storage(D2x(C2d(tcbtio)+offset+0),1) /* length of DD entry*/\n tioestta = Storage(D2x(C2d(tcbtio)+offset+1),1) /* status byte A     */\n tioelink = Storage(D2x(C2d(tcbtio)+offset+3),1) /* flag byte         */\n tioeddnm = Storage(D2x(C2d(tcbtio)+offset+4),8) /* DD name           */\n tioejfcb = Storage(D2x(C2d(tcbtio)+offset+12),3) /* SWA for JFCB     */\n tioefsrt = Storage(D2x(C2d(tcbtio)+offset+17),3) /* UCB address      */\n If (bitand(tioestta,'80'x) == '00'x) Then  /* check 'freed' status   */\n  Do                                        /*                        */\n   If (tioelngh == '00'x) Then Leave        /* no more allocations    */\n   tioejfcb = SWAREQ(tioejfcb)              /* Call SWAREQ            */\n   jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44) /* get dataset name    */\n   jfcbvols = Storage(D2x(C2d(tioejfcb)+118),30) /* get volume list   */\n   tioelink = X2b(C2x(tioelink))            /* get bit pattern        */\n   Select                                   /*                        */\n    When (Substr(tioelink,3,1) = '1') Then  /* check for TERMINAL     */\n     jfcbvols = \"*TERM*\"                    /*                        */\n    When (Substr(tioelink,7,1) = '1') Then  /* check for subsys dsn   */\n     jfcbvols = \"*JES**\"                    /*                        */\n    Otherwise                               /*                        */\n     Do                                     /*                        */\n      ucbchan  = Storage(D2x(C2d(tioefsrt)+4),2) /* UCB channel (bin) */\n      ucbname  = Storage(D2x(C2d(tioefsrt)+13),3) /* UCB name (EBCDIC)*/\n      ucbvoli  = Storage(D2x(C2d(tioefsrt)+28),6) /* UCB volser       */\n     End                                    /*                        */\n   End                                      /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    conc = conc + 1                         /*  assume concatenation  */\n   else                                     /* otherwise              */\n    conc = 0                                /*  assume first          */\n   ucbname = \"\"                             /*                        */\n   If (tioeddnm = \"\") Then                  /* no ddname ?            */\n    Do                                      /*                        */\n     dsns = dsns||' '||jfcbdsnm             /*  assume concatenation  */\n     vols = vols||' '||Strip(jfcbvols,T)    /*  assume concatenation  */\n    End                                     /*                        */\n   else                                     /* otherwise              */\n    If (flag = dd) Then                     /* if already set         */\n     Do                                     /*                        */\n      Signal DDDone                         /* exit procedure         */\n     End                                    /* otherwise              */\n   If (tioeddnm = dd) Then                  /* ddname match           */\n    Do                                      /*                        */\n     drc = 0                                /*                        */\n     flag = dd                              /*  set flag              */\n     dsns = jfcbdsnm                        /*  initialiase dsn list  */\n     vols = Strip(jfcbvols,T)               /*  initialiase vol list  */\n    End                                     /*                        */\n  End                                       /*                        */\n offset = offset + C2d(tioelngh)            /*                        */\nEnd                                         /*                        */\n/**********************************************************************/\nDDDone:                                     /*                        */\nsysdsname = Strip(dsns,B)                   /* set LISTDSI values     */\nsysvolume = Strip(vols,B)                   /* set LISTDSI values     */\nReturn drc                                  /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva  = C2d(Arg(1))                          /* convert to decimal     */\ntcb  = C2d(Storage(21C,4))                  /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536                        /*                        */\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\n                                     /*                               */\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n  Say '**(cat)** Processing 'Left('CATALOG',10) csicname\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  If (process = 'CATCOMP') Then      /** Catalog compare code        **/\n   Do                                /*                               */\n    count.id           = count.id+1  /* increment count               */\n    val                = count.id    /* save value                    */\n    entname.id.val     = entname     /* store entry name              */\n    entype.id.val      = entype      /* store entry type              */\n    name.id.val        = name        /* store assoc name              */\n    type.id.val        = type        /* store assoc type              */\n    pageswap.id.val    = pageswap    /* store pageswap                */\n    devices.id.val     = devices     /* store devices                 */\n    fils.id.val        = fils        /* store fils                    */\n    gdg_emp.id.val     = gdg_emp     /* store gdg_emp                 */\n    gdg_scr.id.val     = gdg_scr     /* store gdg_scr                 */\n    gdglimit.id.val    = gdglimit    /* store gdglimit                */\n    vsam_attr.id.val   = vsam_attr   /* store vsam_attr               */\n    vsam_type.id.val   = vsam_type   /* store vsam_attr               */\n    vsam_vvds.id.val   = vsam_vvds   /* store vsam_vvds               */\n    volsers.id.val     = volsers     /* store volsers by value        */\n                                     /** Back reference values       **/\n    volsers.id.entname = volsers     /* store volsers by entry name   */\n    name.id.entname    = name        /* store name by entry name      */\n    val.id.entname     = val         /* store value by entry name     */\n   End                               /** End Catalog compare code    **/\n  Else                               /*                               */\n   Do                                /*                               */\n    Select                           /*                               */\n     When (member = 'MISC') Then     /* MISC member                   */\n      Call MEM_MISC                  /*                               */\n     When (member = 'RECAT') Then    /* RECAT member                  */\n      Call MEM_RECAT                 /*                               */\n     When (member = 'ALIAS') Then    /* ALIAS member                  */\n      Call MEM_ALIAS                 /*                               */\n     When (member = 'GDG') Then      /* GDG member                    */\n      Call MEM_GDG                   /*                               */\n     When (member = 'IMPORT') Then   /* IMPORT member                 */\n      Call MEM_IMPORT                /*                               */\n     When (member = 'NONVSAM') Then  /* NONVSAM member                */\n      Do                             /*                               */\n       axx_tot = anv_tot             /* set intermim alias total      */\n       nvd_tot = nvd_tot + 1         /* increment total non-vsam      */\n       nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols        */\n       If (Substr(entname,1,4) /= 'SYS1') &,\n          (Substr(entname,1,7) /= 'SYSCTLG') Then /* not SYS1/SYSCTLG */\n        Do                           /*                               */\n         nvo_tot = nvo_tot + 1       /* increment non-vsam only total */\n         Call MEM_NONVSAM            /*                               */\n        End                          /*                               */\n       anv_tot = axx_tot             /* set non-vsam aliases total    */\n      End                            /*                               */\n     When (member = 'SYS1') Then     /* SYS1 member                   */\n      Do                             /*                               */\n       sy1_tot = sy1_tot + 1         /* increment sys1 total          */\n       Call MEM_NONVSAM              /*                               */\n      End                            /*                               */\n     When (member = 'SYSCTLG') Then  /* SYSCTLG member                */\n      Do                             /*                               */\n       axx_tot = asy_tot             /* interim = syscatlg aliases    */\n       syc_tot = syc_tot + 1         /* increment syscatlg total      */\n       Call MEM_NONVSAM              /*                               */\n       asy_tot = axx_tot             /* set syscatlg total            */\n      End                            /*                               */\n     Otherwise NOP                   /*                               */\n    End                              /*                               */\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_MISC - Generate MISC member lines                              */\n/**********************************************************************/\nMEM_MISC:                            /* Generate MISC member lines  ##*/\nIf (entype = 'CLUSTER') |,\n   (entype = 'PAGESPACE') Then\n Do\n  msc_tot = msc_tot + 1\n  l_cnt = l_cnt + 1\n  text = ' /* 'Left(entype' ',15,'-')\n  text = text' 'Left(entname,32)'  NOT PROCESSED */'\n  l.l_cnt = text\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_RECAT - Generate RECAT member lines                            */\n/**********************************************************************/\nMEM_RECAT:                           /* Generate RECAT member lines ##*/\nIf (entype = 'PAGESPACE') Then\n Do\n  page_name     = entname\n  page_swap     = pageswap\n  If (Index(type,'D') /= 0) Then\n   data_flag = 'DATA'\n  Else\n   data_flag = ''\n End\nIf (entype = 'CLUSTER') Then\n Do\n  If (Substr(entname,1,4) /= 'SYS1') Then\n   Do\n    cluster_name  = entname\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left(entype' ',15,'-')\n    text = text' 'Left(entname,34)' CANNOT RECAT */'\n    data_flag = ''\n    index_flag = ''\n    l.l_cnt = text\n   End\n  Else\n   Do\n    cluster_name  = entname\n    If (Index(type,'D') /= 0) Then\n     data_flag = 'DATA'\n    Else\n     data_flag = ''\n    If (Index(type,'I') /= 0) Then\n     index_flag = 'INDEX'\n    Else\n     index_flag = ''\n    cluster_bits  = type\n   End\n End\nIf (entype = 'DATA') &,\n   (data_flag = 'DATA') Then\n Select\n  When (vsam_vvds = 'Y') Then               /* use VVDS flag          */\n   Do\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left('VVDS ',15,'-')\n    text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'\n    l.l_cnt = text\n   End\n  When (Index(name,page_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF PAGESPACE(NAME('Left(page_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left(page_swap,57)' -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          CAT('Left(cat,44)'        )'\n   End\n  When (Index(name,cluster_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF   CLUSTER(NAME('Left(cluster_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    If (vsam_attr /= '') Then\n     Do\n      l_cnt = l_cnt + 1\n      l.l_cnt = '          'Left(vsam_attr,57)' -'\n     End\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '         DATA(NAME('Left(entname,44)'   ) ) -'\n    If (index_flag = '') Then\n     Do\n      l_cnt = l_cnt + 1\n      l.l_cnt = '          CAT('Left(cat,44)'        )'\n     End\n   End\n  Otherwise\n   Say '**(Error--1)* Unexpected condition for :'\n   Say '**(Error--2)* cluster_name = 'Strip(cluster_name,T)\n   Say '**(Error--3)* page_name    = 'Strip(page_name,T)\n   Say '**(Error--4)* entname      = 'Strip(entname,T)\n   Say '**(Error--5)* entype       = 'Strip(entype,T)\n   Say '**(Error--6)* name         = 'Strip(name,T)\n   Say '**(Error--7)* type         = 'Strip(type,T)\n   Say '**(Error--8)* data_flag    = 'Strip(data_flag,T)\n   Say '**(Error--9)* index_flag   = 'Strip(index_flag,T)\n   Say '**(Error-10)* vsam_byte1   = 'vsam_byte1\n   Say '**(Error-11)* vsam_byte2   = 'vsam_byte2\n   Say '**(Error-12)* vsamreus     = 'vsamreus\n End\nIf (entype = 'INDEX') &,\n   (index_flag = 'INDEX') Then\n Do\n  l_cnt = l_cnt + 1\n  l.l_cnt = '         INDEX(NAME('Left(entname,44)'  ) ) -'\n  l_cnt = l_cnt + 1\n  l.l_cnt = '          CAT('Left(cat,44)'        )'\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_ALIAS - Generate ALIAS member lines                            */\n/**********************************************************************/\nMEM_ALIAS:                           /* Generate ALIAS member lines ##*/\nali_tot = ali_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '     DEF ALIAS(NAME('entname')  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          REL('name'))          -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,44)'         )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_IMPORT - Generate IMPORT member lines                          */\n/**********************************************************************/\nMEM_IMPORT:                          /* Generate IMPORT member lins ##*/\nuct_tot = uct_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '    IMPORT   OBJ( ('entname'  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          DEVT('Left(devices,8)') VOL('volser')))'\nl.l_cnt = l.l_cnt' 'Left('CONNECT',26)' -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_GDG - Generate GDG member lines                                */\n/**********************************************************************/\nMEM_GDG:                             /* Generate GDG member lines   ##*/\ngdg_tot = gdg_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  GDG  (NAME('entname') -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          LIMIT('Right(gdglimit,3)') 'Left(gdg_scr,16)\nl.l_cnt = l.l_cnt' 'Left(gdg_emp,24)' )  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_NONVSAM - Generate NONVSAM member lines                        */\n/**********************************************************************/\nMEM_NONVSAM:                         /* Generate NONVSAM member lins##*/\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  NVSAM(NAME('entname') -'\nIf (Words(devices) <= 5) Then        /* < 5 devices for dataset       */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          DEVT( 'Left(devices,47)') -'\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq /= '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = '          FSEQN('Left(fileseq,47)') -'\n   End                               /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          VOL(  'Left(volser,47)') )-'\n End                                 /*                               */\nElse                                 /* > 5 devices for dataset       */\n Do                                  /*                               */\n  item_lead = 'DEVT( '               /* devices header                */\n  item_end  = ') -'                  /* devices trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = devices                    /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq /= '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    item_lead = 'FSEQN('             /* fileseq header                */\n    item_end  = ') -'                /* fileseq trailer               */\n    item_pad  = Left('',7)           /* 7 spaces padding              */\n    items = fileseq                  /* pass data                     */\n    Call PLUS5_HANDLE                /* handle > 5 items              */\n   End                               /*                               */\n  item_lead = 'VOL(  '               /* volumes header                */\n  item_end  = ') ) -'                /* volumes trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = volser                     /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n End                                 /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ASSOC_ENTRY - Process associated entries                           */\n/**********************************************************************/\nASSOC_ENTRY:                         /* Process associated entries  ##*/\nDo ali = 1 to Words(name)\n If (Substr(type,ali,1) = 'X') Then\n  Do\n   axx_tot = axx_tot + 1\n   l_cnt = l_cnt + 1\n   l.l_cnt = '     DEF ALIAS(NAME('Left(Word(name,ali),44)') -'\n   l_cnt = l_cnt + 1\n   l.l_cnt = '          REL('entname')                 )     -'\n   l_cnt = l_cnt + 1\n   l.l_cnt = '          CAT('Left(cat,44)'         )'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM               */\n/**********************************************************************/\nPLUS5_HANDLE:                        /* Handle > 5 fields           ##*/\nl_cnt = l_cnt + 1\nw_end = Wordindex(items,6)\ndata = Left(Substr(items,1,w_end-1),47)\nl.l_cnt = '          'item_lead||data' -'\nDo mult = 6 to Words(items) by 5\n w_sta = Wordindex(items,mult)\n w_end = Wordindex(items,mult+5)\n If (w_end = 0) Then\n  item = Substr(items,w_sta)\n Else\n  item = Substr(items,w_sta,w_end-w_sta)\n l_cnt = l_cnt + 1\n item_length = 47 - Length(item_pad)\n l.l_cnt = '                '||item_pad||Left(item,item_length)' -'\nEnd\nl.l_cnt = Strip(l.l_cnt,T,'-')||item_end\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_REPORT - Generate REPORT member                                */\n/**********************************************************************/\nMEM_REPORT:                          /* Generate REPORT member      ##*/\nr.1  = 'OS CVOL CATALOG NAMES TO BE CONVERTED'\nr.2  = '*RCNVTCAT*  C O N V E R S I O N   R E P O R T'\nr.3  = ' '\nr.4  = 'TOTAL NUMBER OF ALIAS STMTS IN CATALOG                  '\nr.5  = 'ALIAS STMTS ASSOCIATED WITH OS CVOL CATALOGS            '\nr.6  = 'ALIAS STMTS ASSOCIATED WITH VSAM USER CATALOGS          '\nr.7  = 'ALIAS STMTS ASSOCIATED WITH NON VSAM DATA SETS          '\nr.8  = '                                                        '\nr.9  = 'NUMBER OF VSAM USER CATALOGS                            '\nr.10 = '                                                        '\nr.11 = 'TOTAL NUMBER OF NON VSAM DATA SETS  IN CATALOG          '\nr.12 = 'VOLUMES ASSOCIATED WITH NON VSAM DATA SETS. SEE NOTE 1  '\nr.13 = 'OS CVOL CATALOGS WITH THE FOLLOWING NAMES:              '\nr.14 = 'SYSCTLG.VXXXXXX  -  XXXXXX = VOLUME                     '\nr.15 = 'OS CVOL CATALOG NAMES CONVERTED TO                      '\nr.16 = 'SYSCTLG.VXXXXXX . SEE NOTE 2 AND SYSPRINT OUTPUT LISTING'\nr.17 = 'NON VSAM DATA SETS STARTING WITH SYS1.---               '\nr.18 = 'ALL OTHER NON VSAM DATA SETS                            '\nr.19 = '                                                        '\nr.20 = 'NUMBER OF GENERATION DATA GROUP STMTS                   '\nr.21 = '                                                        '\nr.22 = 'NUMBER OF STATEMENTS WHICH COULD  N O T  BE PROCESSED   '\nr.23 = '                                                        '\nr.24 = 'NUMBER OF STATEMENTS WHICH CONTAIN AN INVALID           '\nr.25 = 'DEVICE TYPE. SEE NOTE 3                                 '\nr.26 = 'TOTAL NUMBER OF STATEMENTS WHICH WERE PROCESSED         '\nr.27 = 'SUM OF STATEMENTS WHICH WERE PROCESSED FOR              '\nr.28 = 'ALIAS/IMPORT/NONVSAM/GDG AND MISC. SEE NOTE 4           '\ntot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot\nsta_tot = tot_tot + ali_tot\nr.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '||r.4\nr.5  = ' ALIAS  SYSCTLG ........... 'Right(asy_tot,8)'      '||r.5\nr.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '||r.6\nr.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '||r.7\nr.8  = '                                          '||r.8\nr.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '||r.9\nr.10 = '                                          '||r.10\nr.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '||r.11\nr.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '||r.12\nr.13 = ' OS CVOL SYSCTLG ....(M)... 'Right(syc_tot,8)'      '||r.13\nr.14 = '                                          '||r.14\nr.15 = ' SYSCTLG CONVERTED ........        0      '||r.15\nr.16 = '                                          '||r.16\nr.17 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '||r.17\nr.18 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '||r.18\nr.19 = '                                          '||r.19\nr.20 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '||r.20\nr.21 = '                                          '||r.21\nr.22 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '||r.22\nr.23 = '------------------------------------      '||r.23\nr.24 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '||r.24\nr.25 = '                                          '||r.25\nr.26 = 'NO. OF STMTS PROC ......... 'Right(sta_tot,8)'      '||r.26\nr.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '||r.27\nr.28 = '                                          '||r.28\nr.29 = '(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES'\nr.30 = 'NOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME '\nr.31 = 'NOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVER'\nr.32 = 'NOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!'\nr.33 = 'NOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. T'\nr.31 = r.31||'TED TO SYSCTLG.VXXXXXX, XXXXXX = VOLUME'\nr.32 = r.32||'. BETTER CHECK THE CODE !?!'\nr.33 = r.33||'HEY ARE PROCESSED TWICE'\nl_cnt = 33\nDo loop = 1 to 33\n l.loop = r.loop\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* COMP_REPORT - Produce the Catalog comparison report                */\n/**********************************************************************/\nCOMP_REPORT:                         /* Produce the catalog compare ##*/\nl_cnt = 0\nDo loop = 1 to count.OLD\n entname = entname.OLD.loop\n entype  = entype.OLD.loop\n name    = name.OLD.loop\n volsers = volsers.OLD.loop\n flag.entname = 'Y'\n If (member = 'COMPFULL') Then\n  Do\n   disp_ent = entname\n   disp_entype = Left(entype,8)\n  End\n Else\n  Do\n   disp_ent = Left(entname,36)\n   disp_entype = Left(substr(entype,1,3),4)\n  End\n disp_vol = Strip(volsers,B)\n If (Symbol('val.NEW.entname') = 'LIT') Then\n  Do\n   l_cnt = l_cnt + 1\n   Select\n    When (entype = 'ALIAS  '  ) Then\n     detail = Strip(name.OLD.loop,B)\n    When (entype = 'DATA'     ) |,\n         (entype = 'INDEX'    ) Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)||' ',\n              Strip(vsam_type.OLD.loop,B)||' ',\n              Strip(vsam_attr.OLD.loop,B)\n    When (entype = 'NONVSAM'  ) |,\n         (entype = 'GDG'      ) |,\n         (entype = 'UCAT'     ) |,\n         (entype = 'PAGESPACE') Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)\n    Otherwise NOP\n   End\n   l.l_cnt = disp_entype||disp_ent' --missing - 'detail\n   status.OLD.loop = 'MISSING'\n  End\n Else\n  Do\n   namenew = name.NEW.entname\n   volsnew = volsers.NEW.entname\n   Select\n    When (namenew /= name) Then\n     Do\n      If (entype = 'ALIAS') Then\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##catalog was 'Strip(name,B)' is 'Strip(namenew,B)\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADCAT'\n       End\n      Else\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##related entries do not match.'\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADENT'\n       End\n     End\n    When (volsnew /= volsers) Then\n     Do\n      l_cnt = l_cnt + 1\n      err_text = ' ##volser was 'disp_vol' is 'Strip(volsnew,B)\n      l.l_cnt = disp_entype||disp_ent||err_text\n      status.OLD.loop = 'BADVOL'\n     End\n    Otherwise\n     l_cnt = l_cnt + 1\n     l.l_cnt = disp_entype||disp_ent' **entry matches.'\n     status.OLD.loop = 'OK'\n   End\n  End\nEnd\nDo loop = 1 to count.NEW\n entname = entname.NEW.loop\n entype  = entype.NEW.loop\n volsers = volsers.NEW.loop\n If (flag.entname /= 'Y') Then\n  Do\n   If (member = 'COMPFULL') Then\n    Do\n     disp_ent = entname\n     disp_entype = Left(entype,8)\n    End\n   Else\n    Do\n     disp_ent = Left(entname,36)\n     disp_entype = Left(substr(entype,1,3),4)\n    End\n   disp_vol = Strip(volsers,B)\n   l_cnt = l_cnt + 1\n   l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol\n   status.NEW.loop = 'NEW'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* NEW_EXT - Process for new entries                                  */\n/**********************************************************************/\nNEW_EXT:                             /* Process new entries         ##*/\nDo loop = 1 to count.NEW             /*                               */\n If (status.NEW.loop = 'NEW') Then   /*                               */\n  Do                                 /*                               */\n   entname = entname.NEW.loop        /*                               */\n   entype  = entype.NEW.loop         /*                               */\n   If (entype = 'DATA') |,           /*                               */\n      (entype = 'INDEX') Then        /*                               */\n    Iterate                          /*                               */\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry not present in catalog \"cat.old\". */\"\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry present in catalog     \"cat.new\". */\"\n   Call ENTRY_DEL                    /* process an entry delete       */\n  End                                /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* OLD_BAD - Process for old entries                                  */\n/**********************************************************************/\nOLD_BAD:                             /* Process old entries         ##*/\nDo loop = 1 to count.OLD             /*                               */\n entname   = entname.OLD.loop        /*                               */\n entype    = entype.OLD.loop         /*                               */\n volsers   = volsers.OLD.loop        /*                               */\n volser    = Strip(volsers,B)        /*                               */\n name      = name.OLD.loop           /*                               */\n type      = type.OLD.loop           /*                               */\n pageswap  = pageswap.OLD.loop       /*                               */\n devices   = devices.OLD.loop        /*                               */\n fils      = fils.OLD.loop           /*                               */\n gdg_emp   = gdg_emp.OLD.loop        /*                               */\n gdg_scr   = gdg_scr.OLD.loop        /*                               */\n gdglimit  = gdglimit.OLD.loop       /*                               */\n vsam_attr = vsam_attr.OLD.loop      /*                               */\n vsam_type = vsam_type.OLD.loop      /*                               */\n vsam_vvds = vsam_vvds.OLD.loop      /*                               */\n namenew   = name.NEW.entname        /*                               */\n volsnew   = volsers.NEW.entname     /*                               */\n If (entype = 'DATA') |,             /*                               */\n    (entype = 'INDEX') Then          /*                               */\n  Iterate                            /*                               */\n Select                              /*                               */\n  When (status.OLD.loop = 'MISSING') Then /*                          */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Entry missing in catalog \"cat\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADCAT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Alias incorrectly pointing to \"namenew\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADENT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Related entries do not match */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* entry \"Strip(entname,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* old \"Strip(name,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* new \"Strip(namenew,T)\" */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADVOL') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Volume incorrect - was \"volsnew\". */\"\n   End                               /*                               */\n  Otherwise Iterate                  /*                               */\n End                                 /*                               */\n Call ENTRY_DEL                      /* process an entry delete       */\n Call ENTRY_CHG                      /* process an entry change       */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_DEL - Create a DELETE statement                              */\n/**********************************************************************/\nENTRY_DEL:                           /* Create an entry DELETE      ##*/\nIf (entype = 'NONVSAM') Then         /*                               */\n tparm = ''                          /*                               */\nElse                                 /*                               */\n tparm = entype                      /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      DELETE \"Strip(entname,T)\" \"tparm\" NOSCRATCH -\"\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"             CAT(\"Left(cat,44)\"         )\"\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      SET MAXCC=0\"\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_CHG - Create a changed entry statement                       */\n/**********************************************************************/\nENTRY_CHG:                           /* Create a changed entry      ##*/\nSelect                               /*                               */\n When (entype = 'NONVSAM') Then      /*                               */\n  Call MEM_NONVSAM                   /*                               */\n When (entype = 'ALIAS') Then        /*                               */\n  Call MEM_ALIAS                     /*                               */\n When (entype = 'GDG') Then          /*                               */\n  Call MEM_GDG                       /*                               */\n Otherwise NOP                       /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RDA": {"ttr": 6403, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x13\\x01\\x02\\x10\\x7f\\x01\\x03\\x06/\\x10)\\x01\\x1a\\x01\\x02\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2002-04-17T00:00:00", "modifydate": "2003-03-03T10:29:13", "lines": 282, "newlines": 258, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - RDA : SDSF DA 'replacement' code                            */\n/**********************************************************************/\n/* Written : A.J.Gray - 20/03/1997                                    */\n/* Updated : A.J.Gray - 15/04/2002 - Changed to be a standalone util  */\n/* Updated : A.J.Gray - 09/08/2002 - tweak before adding to CBT       */\n/* Updated : A.J.Gray - 14/11/2002 - Changed SYSDA to SYSALLDA        */\n/**********************************************************************/\n/* This function displays a number of fields that you would normally  */\n/* see using the SDSF DA command. It doesn't show all of them and it  */\n/* doesn't do anything else than display them.                        */\n/* See also RINIT                                                     */\n/**********************************************************************/\n/* Most people won't need this at all !                               */\n/* However I have had brief periods when this was useful, so I thought*/\n/* I'd add it anyway as you never know ;-)#                           */\n/**********************************************************************/\n/* display information                                                */\n/**********************************************************************/\nCall DEFINE_HEX                             /* define hex variables   */\nprc = 0                                     /* initialise panel return*/\nDo While prc = 0                            /* redisplay loop         */\n Call GET_INFO_DA                           /* Get the DA information */\n Call DEFINE_PANEL                          /* define the panel       */\n Call CREATE_MEMBER                         /* create the panel member*/\n Address ISPEXEC \"LibDef ISPPLIB Library Id(\"fil\") Stack\"\n Address ISPEXEC \"Display Panel(DAINFO)\"    /* display the panel      */\n prc = rc                                   /* get panel return       */\n Address ISPEXEC \"LibDef ISPPLIB\"           /* clear the temp alloc   */\n Address TSO     \"Free Fi(\"fil\")\"           /* free the temp dsn      */\nEnd                                         /*                        */\nExit 0                                      /* exit the exec          */\n/**********************************************************************/\n/**********************************************************************/\nGET_INFO_DA:                                /*                      ##*/\nNumeric Digits 20                           /*                        */\ncvt      = Storage(10,4)                    /* get CVT address        */\ncvtasvt  = Storage(D2x(C2d(cvt)+556),4)     /* get ASVT address       */\nasvtmaxu = Storage(D2x(C2d(cvtasvt)+516),4) /*                        */\nasvtaav  = Storage(D2x(C2d(cvtasvt)+480),4) /*                        */\nascb_cnt = 0                                /* initialise ascb_cnt    */\noffst = 528                                 /* set offset             */\nDo loop = 1 To C2d(asvtmaxu)                /*                        */\n ascbadd  = Storage(D2x(C2d(cvtasvt)+offst),4) /*                     */\n ascbascb = Storage(D2x(C2d(ascbadd)+0),4)  /*                        */\n If (ascbascb = 'ASCB') Then                /*                        */\n  Do                                        /*                        */\n   ascbdp   = Storage(D2x(C2d(ascbadd)+43),1)  /* get dispatching pri */\n   ascbdp   = Left(C2x(ascbdp),2)              /*                     */\n   dp       = ascbdp                           /*                     */\n   ascbjstl = Storage(D2x(C2d(ascbadd)+80),4)  /*                     */\n   ascbjstl = C2d(ascbjstl)                    /*                     */\n   ascbrctf = Storage(D2x(C2d(ascbadd)+102),1) /*                     */\n   ascbrctf = X2b(C2x(ascbrctf))               /*                     */\n   ascbflg1 = Storage(D2x(C2d(ascbadd)+103),1) /*                     */\n   ascbflg1 = X2b(C2x(ascbflg1))               /*                     */\n   ascbflg2 = Storage(D2x(C2d(ascbadd)+115),1) /*                     */\n   ascbflg2 = X2b(C2x(ascbflg2))               /*                     */\n   ascboucb = Storage(D2x(C2d(ascbadd)+144),4) /*                     */\n   oucbsfl  = Storage(D2x(C2d(ascboucb)+17),1) /*                     */\n   oucbsfl  = X2b(C2x(oucbsfl))                /*                     */\n   oucbsrc  = Storage(D2x(C2d(ascboucb)+41),1) /* swap out reason code*/\n   oucbusrd = Storage(D2x(C2d(ascboucb)+208),8)/* get owner           */\n   owner    = oucbusrd                         /*                     */\n   oucbspg  = Storage(D2x(C2d(ascboucb)+182),2)/* get pgn             */\n   pgn      = Right(C2d(oucbspg),3)            /*                     */\n   ascbjbni = Storage(D2x(C2d(ascbadd)+172),4) /* get the jobname addr*/\n   If (C2d(ascbjbni) > 0) Then\n    Do\n     jobnamei = Storage(D2x(C2d(ascbjbni)+0),8)/* get the jobname     */\n     /* ascbjbni = address of chname in cscx for job so ...           */\n     chcscbp  = Storage(D2x((C2d(ascbjbni)-24)+32),4) /* get cscb addr*/\n     j_cscb     = D2c(C2d(chcscbp)-8)       /*                        */\n     j_chkey    = Storage(D2x(C2d(chcscbp)+8),8)   /*                 */\n     j_chprocsn = Storage(D2x(C2d(chcscbp)+32),8)  /*                 */\n     j_chstep   = Storage(D2x(C2d(chcscbp)+64),8)  /*                 */\n     j_chjbflgs = Storage(D2x(C2d(chcscbp)+176),1) /*                 */\n     j_chjbflgs = X2b(C2x(j_chjbflgs))      /*                        */\n     If (Substr(j_chjbflgs,1,1) = '1') Then /* if jobname= on jobcard */\n      j_chmemnam = Storage(D2x(C2d(chcscbp)+224),8)/*                 */\n     Else                                   /*                        */\n      j_chmemnam = Left('',8)               /*                        */\n    End                                     /*                        */\n   ascbjbns = Storage(D2x(C2d(ascbadd)+176),4) /* get the jobname addr*/\n   jobnames = Storage(D2x(C2d(ascbjbns)+0),8)  /* get the jobname     */\n   test = C2x(Substr(jobnamei,1,2))         /*                        */\n   If (C2d(ascbjbni) = 0) Then              /*                        */\n    jobname = jobnames                      /*                        */\n   Else                                     /*                        */\n    jobname = jobnamei                      /*                        */\n   ascbrsme = Storage(D2x(C2d(ascbadd)+364),4) /* get the rax addr    */\n   raxfmct  = Storage(D2x(C2d(ascbrsme)+44),4) /* get the frame count */\n   real     = Right(C2d(raxfmct),4)         /*                        */\n   ascbcscb = Storage(D2x(C2d(ascbadd)+56),4)  /* get CSCB address    */\n   chain    = Storage(D2x(C2d(ascbcscb)+0),256)/*                     */\n   chsts    = Storage(D2x(C2d(ascbcscb)+6),1)  /*                     */\n   chsts    = X2b(C2x(chsts))                  /*                     */\n   chact    = Storage(D2x(C2d(ascbcscb)+7),1)  /*                     */\n   chact    = X2b(C2x(chact))                  /*                     */\n   chkey    = Storage(D2x(C2d(ascbcscb)+8),8)  /*                     */\n   chcls    = Storage(D2x(C2d(ascbcscb)+16),8) /*                     */\n   chprocsn = Storage(D2x(C2d(ascbcscb)+32),8) /*                     */\n   chrgnsz  = Storage(D2x(C2d(ascbcscb)+72),4) /*                     */\n   chjbflgs = Storage(D2x(C2d(ascbcscb)+176),1)/*                     */\n   chjbflgs = X2b(C2x(chjbflgs))            /*                        */\n   If (Substr(chjbflgs,1,1) = '1') Then     /* if jobname= on jobcard */\n    chmemnam = Storage(D2x(C2d(ascbcscb)+224),8) /*                   */\n   Else                                     /*                        */\n    chmemnam = Left('',8)                   /*                        */\n   sr   = '  '                              /*                        */\n   pos  = 'IN '                             /*                        */\n   hi   = x07                               /*                        */\n   If (Substr(oucbsfl,1,1) = '0') Then      /*                        */\n    Do                                      /*                        */\n     If (substr(ascbrctf,5,1) = '1') then   /*                        */\n      Do                                    /*                        */\n       pos  = 'LO '                         /*                        */\n       hi   = x06                           /*                        */\n       Select                               /* decode from IRASRCD map*/\n        When (C2x(oucbsrc) = '1')  Then sr = 'TO'\n        When (C2x(oucbsrc) = '2')  Then sr = 'TI'\n        When (C2x(oucbsrc) = '3')  Then sr = 'LW'\n        When (C2x(oucbsrc) = '4')  Then sr = 'XS'\n        When (C2x(oucbsrc) = '5')  Then sr = 'RS'\n        When (C2x(oucbsrc) = '6')  Then sr = 'DW'\n        When (C2x(oucbsrc) = '7')  Then sr = 'RQ'\n        When (C2x(oucbsrc) = '8')  Then sr = 'NQ'\n        When (C2x(oucbsrc) = '9')  Then sr = 'EX'\n        When (C2x(oucbsrc) = 'A')  Then sr = 'US'\n        When (C2x(oucbsrc) = 'B')  Then sr = 'TS'\n        When (C2x(oucbsrc) = 'C')  Then sr = 'IC'\n        When (C2x(oucbsrc) = 'D')  Then sr = 'IP'\n        When (C2x(oucbsrc) = 'E')  Then sr = 'MR'\n        When (C2x(oucbsrc) = 'F')  Then sr = 'AW'\n        When (C2x(oucbsrc) = '10') Then sr = 'IW'\n        When (C2x(oucbsrc) = '11') Then sr = 'OW'\n        Otherwise sr = '??'                 /*                        */\n       End                                  /*                        */\n      End                                   /*                        */\n     swap = 'Swappable'                     /*                        */\n    End                                     /*                        */\n   Else                                     /*                        */\n    Do                                      /*                        */\n     pos  = 'NS '                           /*                        */\n     sr   = '  '                            /*                        */\n     swap = 'non-Swappable'                 /*                        */\n    End                                     /*                        */\n   typ = 'STC'                              /*                        */\n   If (Substr(chact,2,1) = '1') Then        /*                        */\n    Do                                      /*                        */\n     typ = 'TSU'                            /*                        */\n     memname  = chmemnam                    /*                        */\n     procname = chcls                       /*                        */\n     stepname = chkey                       /*                        */\n    End                                     /*                        */\n   If (chmemnam = 'INIT') Then              /*                        */\n    Do                                      /*                        */\n     typ = 'JOB'                            /*                        */\n     memname  = j_chmemnam                  /*                        */\n     procname = chcls                       /*                        */\n     stepname = j_chstep                    /*                        */\n    End                                     /*                        */\n   If (typ = 'STC') Then                    /*                        */\n    Do                                      /*                        */\n     memname  = chmemnam                    /*                        */\n     If (C2d(ascbjbni) = 0) Then            /*                        */\n      Do                                    /*                        */\n       stepname = chkey                     /*                        */\n       procname = chprocsn                  /*                        */\n      End                                   /*                        */\n     Else                                   /*                        */\n      Do                                    /*                        */\n       stepname = j_chstep                  /*                        */\n       procname = chcls                     /*                        */\n      End                                   /*                        */\n    End                                     /*                        */\n   asid = Right(loop,4,'0')                 /*                        */\n   asidX = Right(D2x(loop),4,'0')           /*                        */\n   If (loop = 1) Then                       /*                        */\n    Do                                      /*                        */\n     procname = Left('',8)                  /*                        */\n     stepname = Left('',8)                  /*                        */\n    End                                     /*                        */\n   /*\n   Say jobname j_chprocsn j_chmemnam j_chstep chcls chmemnam chkey chprocsn\n   */\n   texl = hi||asid||' '||asidX||' '||jobname||' '||owner\n   texl = texl||' '||memname||' '||procname||' '||stepname\n   texl = texl||' '||dp||' '||pos||' '||sr||' '||typ\n   texl = texl||' '||real||' '||pgn\n   texl = texl||' '\n   If (jobname /= 'INIT') Then              /* skip unused initiators */\n    Do                                      /*                        */\n     ascb_cnt = ascb_cnt + 1                /* increment count        */\n     text.ascb_cnt = texl                   /*                        */\n    End                                     /*                        */\n  End                                       /*                        */\n offst = offst + 4                          /*                        */\nEnd                                         /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\nDEFINE_HEX:                                 /* Create display panel ##*/\nX01 = '01'X                                 /* set hex '01' variable  */\nX02 = '02'X                                 /* set hex '02' variable  */\nX03 = '03'X                                 /* set hex '03' variable  */\nX05 = '05'X                                 /* set hex '05' variable  */\nX06 = '06'X                                 /* set hex '06' variable  */\nX07 = '07'X                                 /* set hex '07' variable  */\nX09 = '09'X                                 /* set hex '09' variable  */\nX0A = '0A'X                                 /* set hex '0A' variable  */\nX0B = '0B'X                                 /* set hex '0B' variable  */\nX16 = '16'X                                 /* set hex '16' variable  */\nX19 = '19'X                                 /* set hex '19' variable  */\nX22 = '22'X                                 /* set hex '22' variable  */\nX08 = '08'X                                 /* set hex '08' variable  */\nX26 = '26'X                                 /* set hex '26' variable  */\nX27 = '27'X                                 /* set hex '27' variable  */\nReturn\n/**********************************************************************/\nDEFINE_PANEL:                               /* Create display panel ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'DAINFO'                           /* set panel name         */\nQueue \")PANEL KEYLIST(ISRSNAB,ISR)\"\nQueue \")ATTR DEFAULT(\"X01||X02||X03\") FORMAT(MIX)\"\nQueue \" 05 TYPE(PT)\"\nQueue \" 06 TYPE(ABSL)\"\nQueue \" 07 TYPE(SAC)\"\nQueue \" 08 TYPE(CH)\"\nQueue \" 09 TYPE(FP)\"\nQueue \" 0A TYPE(NT)\"\nQueue \" 0B TYPE(ET)\"\nQueue \" 16 TYPE(VOI) PADC(USER)\"\nQueue \" 19 TYPE(DT)\"\nQueue \" 22 TYPE(WASL) SKIP(ON)\"\nQueue \" 26 TYPE(NEF) CAPS(ON) PADC(USER)\"\nQueue \" 27 AREA(SCRL) EXTEND(ON)\"\nQueue \")BODY  CMD(ZCMD)\"\nQueue X0A||Centre(X05||\"Display Active\"||X0A,78)||X0A\ncomd = X09||\"Command ===>\"||X26||Left(\"ZCMD\",50)||X0A\ncomd = comd||\"Scroll ==>\"||X26||\"Z    \"X0A\nQueue comd\nhead = X06\" ASID ASDX JOBNAME  OWNER    MEMBER   PROCNAME STEPNAME\"\nhead = head||\" DP POS SR TYP REAL PGN\"\nQueue head\nQueue X27||Left(\"SAREA39\",78)||X27\nQueue X27||Left(\"\",78)||X27\nQueue \")AREA SAREA39\"\nDo loop = 1 to ascb_cnt\n Queue \" \"text.loop\nEnd\nQueue X22||X22\nQueue \")INIT\"\nQueue \" .ZVARS = '(ZSCROLLA)'\"\nQueue \" &ZCMD = ''\"\nQueue \" &ZSCROLLA = 'CSR'\"\nQueue \")PROC\"\nQueue \")END\"\nReturn                                      /*                        */\n/**********************************************************************/\nCREATE_MEMBER:                              /* Create Member in PDS ##*/\nDo loop = 1 To 50                           /* loop thru up to 50     */\n fil = 'DYNAM'||loop                        /*  build filename        */\n x = Listdsi(fil FILE)                      /*  test filename         */\n If (sysreason > 0) Then                    /*  if not present        */\n  Leave                                     /*   use it !             */\nEnd                                         /* end loop               */\nAddress TSO                                 /* set address            */\n\"Alloc Fi(\"fil\") \",                         /* Allocate dynamic       */\n      \"Lrecl(80) Blksize(0) RecFm(F B) \",   /*  dataset to selected   */\n      \"Cylinders Space(1,1) \",              /*   filename             */\n      \"Unit(SYSALLDA) Dir(20) New Reu\"      /*                        */\nX = Listdsi(fil FILE)                       /* get the file details   */\nstack = Queued()                            /*   get stack size       */\nIf (stack > 0) Then                         /*   if data on stack     */\n Do                                         /*                        */\n  \"Alloc Fi(MEMOUT) Shr Reu \",              /*    create member       */\n        \"Da('\"sysdsname\"(\"member\")')\"       /*                        */\n  \"ExecIO \"stack\" DiskW MEMOUT (Finis)\"     /*    write stack > member*/\n  \"Free Fi(MEMOUT)\"                         /*    free member         */\n End                                        /*                        */\nmember = Word(line,2)                       /*   get next member name */\n\"DelStack\"                                  /* Clear stack            */\nReturn                                      /*                        */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RINIT": {"ttr": 6409, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x18\\x00\\x19\\x00\\x950?\\x01\\x03\\x06/\\x10)\\x01\\x02\\x00\\xab\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.24", "flags": 0, "createdate": "1995-10-30T00:00:00", "modifydate": "2003-03-03T10:29:19", "lines": 258, "newlines": 171, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - RINIT : SDSF INIT 'replacement' code                        */\n/**********************************************************************/\n/* Written - A.J.Gray : 02/11/1995                                    */\n/* Updated : A.J.Gray - 19/04/2002 - Changed to be a standalone util  */\n/* Updated : A.J.Gray - 09/08/2002 - tweak before adding to CBT       */\n/* Updated : A.J.Gray - 14/11/2002 - Changed SYSDA to SYSALLDA        */\n/**********************************************************************/\n/* This function displays a number of fields that you would normally  */\n/* see using the SDSF INIT command. It doesn't show all of them and   */\n/* it doesn't do anything else than display them.                     */\n/* See also RDA                                                       */\n/**********************************************************************/\n/* Most people won't need this at all !                               */\n/* However I have had brief periods when this was useful, so I thought*/\n/* I'd add it anyway as you never know ;-)#                           */\n/**********************************************************************/\n/* display information                                                */\n/**********************************************************************/\nCall DEFINE_HEX                             /* define hex variables   */\nprc = 0                                     /* initialise panel return*/\nDo While prc = 0                            /* redisplay loop         */\n Call GET_INFO_INIT                         /* Get the DA information */\n Call DEFINE_PANEL                          /* define the panel       */\n Call CREATE_MEMBER                         /* create the panel member*/\n Address ISPEXEC \"LibDef ISPPLIB Library Id(\"fil\") Stack\"\n Address ISPEXEC \"Display Panel(INITINFO)\"  /* display the panel      */\n prc = rc                                   /* get panel return       */\n Address ISPEXEC \"LibDef ISPPLIB\"           /* clear the temp alloc   */\n Address TSO     \"Free Fi(\"fil\")\"           /* free the temp dsn      */\nEnd                                         /*                        */\nExit 0                                      /* exit the exec          */\n/**********************************************************************/\nGET_INFO_INIT:                              /*                      ##*/\nnumeric digits 20\ninit_cnt = 0                                /* Get address of cvt     */\ncvt      = Storage(10,4)                    /* Get address of cvt     */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* Get the PREFIX         */\nmvsver   = Substr(cvtpfx,1,7)               /* Get the MVS version    */\ncvtsmca  = Storage(D2x(C2d(cvt)+196),4)     /* Get cvtsmca            */\ncvtjesct = Storage(D2x(C2d(cvt)+296),4)     /* Get cvtjesct           */\njesssct  = Storage(D2x(C2d(cvtjesct)+24),4) /* Get jesssct (SScvt)    */\nssctscta = jesssct                          /*                        */\nDo While C2d(ssctscta) /= 0                 /*                        */\n ssctsnam = Storage(D2x(C2d(ssctscta)+8),4) /*                        */\n ssctssvt = Storage(D2x(C2d(ssctscta)+16),4)/*                        */\n ssctsus2 = Storage(D2x(C2d(jesssct)+28),4) /* point to $HCCT         */\n cctssnm  = Storage(D2x(C2d(ssctsus2)+696),4)/* jes name of subsystem */\n If (ssctsnam = cctssnm) Then\n  Do\n   ssvtfnum = Storage(D2x(C2d(ssctssvt)+2),2)\n   Select\n    When (mvsver = 'SP4.3.0') Then\n     cctpit   = Storage(D2x(C2d(ssctsus2)+1176),4) /* point to $PIT   */\n    When (mvsver = 'SP6.0.8') Then\n     cctpit   = Storage(D2x(C2d(ssctsus2)+1280),4) /* point to $PIT   */\n    Otherwise\n     cctpit   = Storage(D2x(C2d(ssctsus2)+1184),4) /* point to $PIT   */\n   End\n   Do While C2d(cctpit) /= 0\n    pitpatid = Storage(D2x(C2d(cctpit)+20),4)\n    pitclass = Storage(D2x(C2d(cctpit)+24),36)\n    pitclass = Left(pitclass,8)\n    pitflags = Storage(D2x(C2d(cctpit)+16),1)\n    pitflags = X2b(C2x(pitflags))\n    pitdupj  = Substr(pitflags,1,1)\n    pitsmver = Substr(pitflags,2,1)\n    pitsiver = Substr(pitflags,3,1)\n    pitstat  = Storage(D2x(C2d(cctpit)+17),1)\n    pitstat  = X2b(C2x(pitstat))\n    Do loop = 1 to 8\n     ps.loop = Substr(pitstat,loop,1)\n    End\n    pitsjb   = Storage(D2x(C2d(cctpit)+4),4)\n    sjbasid  = Storage(D2x(C2d(pitsjb)+226),2)\n    sjbasid  = c2x(sjbasid)\n    sjbasidd = Right(X2d(sjbasid),4)\n    hilite = x06\n    Select\n     When (ps.1 = '1') & (ps.2 = '1') & (ps.4 = '0') Then\n      Do\n       status = Left('Drained ',8)\n       type = 'BLANK'\n       sjbasid = Left(' ',4)\n       sjbasidd = Left(' ',4)\n      End\n     When (ps.1 = '0') & (ps.2 = '1') & (ps.4 = '0') Then\n      Do\n       status = Left('Drained ',8)\n       type = 'BLANK'\n       sjbasid = Left(' ',4)\n       sjbasidd = Left(' ',4)\n      End\n     When (ps.1 = '1') & (ps.2 = '1') & (ps.4 = '1') Then\n      Do\n       status = Left('Draining',8)\n       hilite = '|'\n       type = 'NORM'\n      End\n     When (ps.5 = '1') & (ps.6 = '1') & (ps.4 = '0') Then\n      Do\n       status = Left('Halted',8)\n       hilite = '|'\n       type = 'NORM'\n      End\n     When (ps.6 = '1') & (ps.7 = '1') & (ps.8 = '1') Then\n      Do\n       status = Left('Halted',8)\n       hilite = '|'\n       type = 'NORM'\n      End\n     When (ps.5 = '1') & (ps.6 = '1') & (ps.4 = '1') Then\n      Do\n       status = Left('Halting ',8)\n       hilite = '|'\n       type = 'NORM'\n      End\n     When (ps.1 = '0') & (ps.2 = '0') & (ps.5 = '0') & (ps.6 = '0') &,\n          (ps.4 = '0') & (pitsmver = '0') Then\n      Do\n       status = Left('Inactive',8)\n       type = 'BLANK'\n      End\n     When (ps.1 = '0') & (ps.2 = '0') & (ps.5 = '0') & (ps.6 = '0') &,\n          (ps.4 = '0') & (pitsmver = '1') Then\n      Do\n       status = Left('Starting',8)\n       hilite = x07\n       type = 'NORM'\n      End\n     When (ps.1 = '0') & (ps.2 = '0') & (ps.5 = '0') & (ps.6 = '0') &,\n          (ps.4 = '1') Then\n      Do\n       status = Left('Active',8)\n       hilite = x07\n       type = 'NORM'\n      End\n     Otherwise\n      Do\n       status = Left('Unknown',8)\n       type = 'NORM'\n      End\n    End\n    If (type = 'BLANK') Then\n     Do\n      sjbjobnm = Left('',8)\n      sjbjobid = Left('',8)\n      sjbusrid = Left('',8)\n      sjbjclas = ' '\n     End\n    Else\n     Do\n      /*\n      sjbjclas = Storage(D2x(C2d(pitsjb)+204),1)\n      sjbjobid = Storage(D2x(C2d(pitsjb)+216),8)\n      sjbjobnm = Storage(D2x(C2d(pitsjb)+224),8)\n      sjbusrid = Storage(D2x(C2d(pitsjb)+232),8)\n      */\n      sjbjclas = Storage(D2x(C2d(pitsjb)+224),1)\n      sjbjobid = Storage(D2x(C2d(pitsjb)+236),8)\n      sjbjobnm = Storage(D2x(C2d(pitsjb)+244),8)\n      sjbusrid = Storage(D2x(C2d(pitsjb)+252),8)\n     End\n    texl = pitpatid||' '||status||' '||pitclass' '\n    texl = texl||sjbjobnm||' '||sjbjobid||' '||sjbusrid||' '||sjbjclas\n    texl = texl||' '||sjbasidd||' '||sjbasid\n    texl = Left(hilite||texl,79)\n    text = text||texl\n    init_cnt = init_cnt + 1                 /* increment count        */\n    text.init_cnt = texl                    /*                        */\n    cctpit   = Storage(D2x(C2d(cctpit)),4)\n   End\n  End\n ssctscta = Storage(D2x(C2d(ssctscta)+4),4) /*                        */\nEnd                                         /*                        */\nReturn\n/**********************************************************************/\nDEFINE_HEX:                                 /* Create display panel ##*/\nX01 = '01'X                                 /* set hex '01' variable  */\nX02 = '02'X                                 /* set hex '02' variable  */\nX03 = '03'X                                 /* set hex '03' variable  */\nX05 = '05'X                                 /* set hex '05' variable  */\nX06 = '06'X                                 /* set hex '06' variable  */\nX07 = '07'X                                 /* set hex '07' variable  */\nX09 = '09'X                                 /* set hex '09' variable  */\nX0A = '0A'X                                 /* set hex '0A' variable  */\nX0B = '0B'X                                 /* set hex '0B' variable  */\nX16 = '16'X                                 /* set hex '16' variable  */\nX19 = '19'X                                 /* set hex '19' variable  */\nX22 = '22'X                                 /* set hex '22' variable  */\nX08 = '08'X                                 /* set hex '08' variable  */\nX26 = '26'X                                 /* set hex '26' variable  */\nX27 = '27'X                                 /* set hex '27' variable  */\nReturn\n/**********************************************************************/\nDEFINE_PANEL:                               /* Create display panel ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'INITINFO'                         /* set panel name         */\nQueue \")PANEL KEYLIST(ISRSNAB,ISR)\"\nQueue \")ATTR DEFAULT(\"X01||X02||X03\") FORMAT(MIX)\"\nQueue \" 05 TYPE(PT)\"\nQueue \" 06 TYPE(ABSL)\"\nQueue \" 07 TYPE(SAC)\"\nQueue \" 08 TYPE(CH)\"\nQueue \" 09 TYPE(FP)\"\nQueue \" 0A TYPE(NT)\"\nQueue \" 0B TYPE(ET)\"\nQueue \" 16 TYPE(VOI) PADC(USER)\"\nQueue \" 19 TYPE(DT)\"\nQueue \" 22 TYPE(WASL) SKIP(ON)\"\nQueue \" 26 TYPE(NEF) CAPS(ON) PADC(USER)\"\nQueue \" 27 AREA(SCRL) EXTEND(ON)\"\nQueue \")BODY  CMD(ZCMD)\"\nQueue X0A||Centre(X05||\"Initiators\"||X0A,78)||X0A\ncomd = X09||\"Command ===>\"||X26||Left(\"ZCMD\",50)||X0A\ncomd = comd||\"Scroll ==>\"||X26||\"Z    \"X0A\nQueue comd\nhead = X06\" ID   STATUS   CLASSES  JOBNAME  JOBID    USER     C\"\nhead = head\" ASID ASIDX\"\nQueue head\nQueue X27||Left(\"SAREA39\",78)||X27\nQueue X27||Left(\"\",78)||X27\nQueue \")AREA SAREA39\"\nDo loop = 1 to init_cnt\n Queue \" \"text.loop\nEnd\nQueue X22||X22\nQueue \")INIT\"\nQueue \" .ZVARS = '(ZSCROLLA)'\"\nQueue \" &ZCMD = ' '\"\nQueue \" &ZSCROLLA = 'CSR '\"\nQueue \")PROC\"\nQueue \")END\"\nReturn                                      /*                        */\n/**********************************************************************/\nCREATE_MEMBER:                              /* Create Member in PDS ##*/\nDo loop = 1 To 50                           /* loop thru up to 50     */\n fil = 'DYNAM'||loop                        /*  build filename        */\n x = Listdsi(fil FILE)                      /*  test filename         */\n If (sysreason > 0) Then                    /*  if not present        */\n  Leave                                     /*   use it !             */\nEnd                                         /* end loop               */\nAddress TSO                                 /* set address            */\n\"Alloc Fi(\"fil\") \",                         /* Allocate dyamic        */\n      \"Lrecl(80) Blksize(0) RecFm(F B) \",   /*  dataset to selected   */\n      \"Cylinders Space(1,1) \",              /*   filename             */\n      \"Unit(SYSALLDA) Dir(20) New Reu\"      /*                        */\nX = Listdsi(fil FILE)                       /* get the file details   */\nstack = Queued()                            /*   get stack size       */\nIf (stack > 0) Then                         /*   if data on stack     */\n Do                                         /*                        */\n  \"Alloc Fi(MEMOUT) Shr Reu \",              /*    create member       */\n        \"Da('\"sysdsname\"(\"member\")')\"       /*                        */\n  \"ExecIO \"stack\" DiskW MEMOUT (Finis)\"     /*    write stack > member*/\n  \"Free Fi(MEMOUT)\"                         /*    free member         */\n End                                        /*                        */\nmember = Word(line,2)                       /*   get next member name */\n\"DelStack\"                                  /* Clear stack            */\nReturn                                      /*                        */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SCNVTCAT": {"ttr": 6657, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x18\\x01\\x16#_\\x01\\x162\\x1f \\x08\\x08\\xd5\\x06\\xec\\x00\\x00\\xd1\\xd6\\xc1\\xd9\\xd4\\xc3@@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "2016-08-22T00:00:00", "modifydate": "2016-11-16T20:08:18", "lines": 2261, "newlines": 1772, "modlines": 0, "user": "JOARMC"}, "text": "/* REXX - RCNVTCAT : MCNVTCAT replacement in REXX, UNIX Support       */\n/**********************************************************************/\n/* RCNVTCAT : Uses Catalog Search Interface (CSI)                     */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/*                                                                    */\n/* This was an extension of previous work that was initially derived  */\n/* from the code found in 'SYS1.SAMPLIB(IGGCSIRX)'                    */\n/*                                                                    */\n/**********************************************************************/\n/* The report dataset will now always be dynamically allocated        */\n/* and will be userid/prefix.rcnvtcat.report.Tnnnn                    */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */\n/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */\n/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */\n/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */\n/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */\n/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */\n/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/\n/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */\n/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */\n/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */\n/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */\n/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */\n/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */\n/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */\n/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */\n/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */\n/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/\n/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */\n/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */\n/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/\n/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */\n/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */\n/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */\n/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */\n/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */\n/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */\n/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */\n/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */\n/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */\n/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */\n/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */\n/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */\n/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */\n/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */\n/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &           */\n/*                                        make UNIX shell compat      */\n/* 1.8.0   - 21/08/2016 - John McKown   - Enhance UNIX usefulness     */\n/*                                        Restructure some code       */\n/*                                        Remove obsolete code        */\n/**********************************************************************/\n/* Notes :                                                            */\n/*                                                                    */\n/* 1. This program writes out various error messages, the return and  */\n/*    reason codes can be checked using those found listed for the    */\n/*    IBM message IDC3009I. The module is the CSI internal reference  */\n/*    and probably isn't of much use to anyone outside IBM.           */\n/*                                                                    */\n/* 2. Two return codes are 'special' :                                */\n/*    RC=100, Reason=4                                                */\n/*    RC=44 , Reason=14                                               */\n/*    These relate to entries of greater than 65535 characters.       */\n/*    If you get these entries, then you need to enable fullword      */\n/*    processing by changing the value of CSIOPTNS to 'F' from ' '.   */\n/*                                                                    */\n/**********************************************************************/\n/* So how does this differ from the original MCNVTCAT ?               */\n/*                                                                    */\n/* 1. Well it's written in REXX and uses the Catalog Search Interface */\n/*                                                                    */\n/* 2. It doesn't check the actual devices available on the system     */\n/*    (So you may get a catalog entry for a non-present device type)  */\n/*                                                                    */\n/* 3. It doesn't add bits of LISTCAT messages into the report totals  */\n/*    or the generated members.                                       */\n/*                                                                    */\n/* 4. It DOES handle datasets cataloged on more than five volume !    */\n/*    (So doesn't write out an error message for that condition)      */\n/*                                                                    */\n/* 5. I'm pretty sure that it doesn't handle SYSCTLG properly. As     */\n/*    the manual states that OS CVOLs don't work after 01/01/2000 I   */\n/*    guess this shouldn't be an issue for many out there.            */\n/*                                                                    */\n/* 6. It writes its report to the REPORT member of the PDS rather     */\n/*    than to a SYSOUT.                                               */\n/*                                                                    */\n/* 7. It generates a RECAT member that contains statements to allow   */\n/*    the RECATALOG of PAGESPACE and SYS1.** datasets.                */\n/*                                                                    */\n/*    Currently this only supports VSAM clusters with the following   */\n/*    non-default attributes : LINEAR, REUSE                          */\n/*                                                                    */\n/* 8. It can be used to compare two catalogs and produces reports     */\n/*    showing the differences between the catalogs.                   */\n/*                                                                    */\n/**********************************************************************/\nTrace O                              /* Trace Off                     */\nexitRC = 0\nunix_CWD = ''\nunix_HOME=''\nunix_TMPDIR=''\nflag_syscall = 0                     /* Initialize flag to \"false\"    */\ntso_flag = 0                         /* Initialize flag to \"false\"    */\nenv_flag = 0                         /* Initialize flag to \"false\"    */\nispf_flag = 0                        /* Initialize flag to \"false\"    */\nsh_flag=0                            /* Initialize flag to \"false\"    */\nbadRC=20\noption_used. = 0                     /* flag for use of option        */\nParse SOURCE . . . . . . Environment AddrSpce .\nSelect\n When AddrSpce = 'MVS' Then\n  Do\n   Say \"**(Error-1)* Environment:\"Environment\" is unsupported.\"\n   Say '**(Error-2)* Neither TSO nor UNIX shell environment.'\n   Say '**(Error-3)* RCNVTCAT cannot allocate files, so terminating.'\n   exitRC = 16\n   Signal FINISH                      /* leave the exec               */\n  End\n When Environment = 'TSO' Then       /* test if under TSO             */\n  Do                                 /*                               */\n   tso_flag = 1                      /* set TSO flag                  */\n   x = Msg('Off')                    /* Disable messages              */\n   x = Prompt('Off')                 /* Disable prompts               */\n   If (Sysvar(\"SYSENV\") = 'FORE') Then/* test for foreground          */\n    env_flag = 1                      /* set ENV flag                 */\n   If AddrSpce = 'ISPF' Then          /* test for ISPF                */\n    ispf_flag = 1                     /* set ISPF flag                */\n   outputLocation='//'               /* Set TSO default output        */\n   If sysvar('syspref') = ''\n   Then sysuid = sysvar('sysuid')\n   Else sysuid = sysvar('syspref')\n   sysuid=strip(sysuid,\"T\",\" \");\n   badRC=8\n  End                                /*                               */\n/**********************************************************************/\n/* extract / check and set environment variables                      */\n/**********************************************************************/\n When AddrSpce = 'OMVS' Then\n  Do\n   If Environment = 'SH' Then\n    flag_syscall = 1 /* because SYSCALLS('ON') is in effect for shell */\n   sh_flag = 1\n   badRC = 1        /* The \"failed\" RC under UNIX is 1 not 4          */\n   Address SYSCALL \"getcwd unix_CWD\"\n   Address syscall getlogin sysuid\n   sysuid=strip(sysuid,\"T\",\" \");\n   /* Find the user's ${HOME} */\n   /*\n     Scan the user's shell environment variables looking\n     for HOME=, TMP=, and TMPDIR=. HOME is hopefully self\n     explanatory. In standard UNIX programs, any temporary\n     files are created in the directory specified in the\n     TMPDIR environment variable. If this is not set, then\n     the TMP environment variable is set. If it is also not\n     set, then /tmp is used.\n   */\n   Do i=1 to __environment.0 /* Scan the user's environment */\n      if 'HOME=' = left(__environment.i,5) Then\n       unix_HOME=substr(__environment.i,6)\n      if 'TMP=' = left(__environment.i,4) &,\n         unix_TMPDIR='' Then\n       unix_TMPDIR=substr(__environment.i,5)\n      if 'TMPDIR=' = left(__environment.i,7) Then\n       unix_TMPDIR=substr(__environment.i,8)\n   End\n   If unix_TMPDIR='' Then\n    unix_TMPDIR='/tmp'\n   If unix_HOME = '' Then /* No HOME environment variable? Weird */\n    unix_HOME = FindUNIXhome(sysuid)\n   If unix_HOME = '' Then /* Wow! No HOME directory at all? */\n     unix_HOME=unix_TMPDIR /* act like HOME is TMPDIR */\n   Say \"HOME is:\"unix_HOME\n   Say \"Temporary files go in:\"unix_TMPDIR\n   /*\n    For a UNIX shell, the default output location is the\n    current working directory\n   */\n   outputLocation=unix_CWD\n  End\n Otherwise\n  Do                                  /*                              */\n   Say \"**(Error-1)* Environment:\"Environment\"/\"AddrSpce||,\n       \" is unsupported.\"\n   Say '**(Error-2)* No TSO environment and '||,\n       'no UNIX shell environment.'\n   Say '**(Error-3)* RCNVTCAT cannot allocate files, so terminating.'\n   exitRC = 16\n   Signal FINISH                      /* leave the exec               */\n  End                                 /*                              */\nEnd   /* Select */\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt = '**'                           /* Set the filter                */\ntyp = ' '                            /* Set entry types required      */\nct1 = ' '                            /* Set for 1 catalog only        */\nrcnvdsn = ''                         /* set dsn to null               */\n/**********************************************************************/\n/* Handle passed parameters                                           */\n/**********************************************************************/\n/* This has been greatly changed from the original                    */\n/* In order to make things easier in general and to support UNIX      */\n/* as I believe it should be, I will emulate the initialization of    */\n/* the __argv. variable stem to contain the command's arguments.      */\n/* This is automatically done when the command is run in a UNIX       */\n/* shell. I must emulate it when invoked in other environments.       */\n/**********************************************************************/\nIf Datatype(__argv.0,\"W\") <> 1 Then  /* It's not a whole number       */\n Do\n  /* This parsing is actually too simplistic and needs to be fixed.   */\n  /* It does not proper handle the case where a blank is part of      */\n  /* a data value, such as being within ' marks, instead of being a   */\n  /* delimiter.                                                       */\n  Parse arg vals                     /* Get passed arguments          */\n  Parse source . . cmdName .\n  __argv.0=Words(vals) + 1\n  __argv.1 = cmdName\n  Do i = 2 to __argv.0\n   __argv.i = Word(vals,i-1)\n  End\n End\ncatNum = 0                           /*                               */\ntarg_cat=''\nDo argNum = 2 To __argv.0            /* loop thru arguments, ignore   */\n                                     /* command name (first argument) */\n testarg = Strip(__argv.argNum,\"B\",\"'\") /* remove inverted commas     */\n testargU = testarg                  /* Retain both original case &   */\n                                     /* upper case. UNIX commands     */\n                                     /* normally retain case and so   */\n                                     /* I will implement that way too.*/\n                                     /*                               */\n Upper testargU                      /* convert to upper case to ease */\n                                     /* testing.                      */\n Select                              /*                               */\n  When (Substr(testargU,1,9) = '--TARGET=') Then\n   Do\n    targ_cat=Substr(testargU,10)\n    targ_cat=strip(targ_cat,\"B\",\"'\")\n   End\n  When (Substr(testargU,1,7) = 'TARGET(') Then\n   Do\n    If ')' <> Right(testargU,1) Then\n     Do\n      Say '**(Error-1)* No trailing )'\n      exitRC = 16\n      Signal FINISH                      /* leave the exec               */\n     End\n    Parse var testargU '(' targ_cat ')'\n    targ_cat=strip(targ_cat,\"B\",\"'\")\n   End\n  When (testargU = '--TARGET') Then\n   Do\n    argNum = argNum + 1\n    targ_cat = __argv.argNum\n    targ_cat=strip(targ_cat,\"B\",\"'\")\n   End\n  When (Substr(testargU,1,6) = 'DEBUG(') Then /* check for TSO debug  */\n   Do                                /*                               */\n    debug = Substr(testargU,7,1)     /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End                               /*                               */\n  When ('--debug=' = left(testarg,8)) Then /* UNIX check for debug    */\n   Do\n    debug = substr(testarg,9)        /* get debug value               */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End\n  When ('--debug' = testarg) Then    /* UNIX check for debug          */\n   Do\n /* debug = Word(vals,argNum+1)       * Get debug value               */\n    argNum = argNum + 1              /* bypass next arg, if any       */\n    debug = __argv.argNum\n    If ('' = debug) Then             /* This happens if --debug is the*/\n                                     /* last argument on command line */\n     debug = 2                       /* Standard value                */\n    Say '**(Debug)*** Debug level 'debug' enabled.' /*                */\n   End\n  When (testargU = '?' |,            /* Normal for TSO                */\n        testarg = '-?' |,            /* Normal for UNIX               */\n        testarg = '-h' |,            /* Alternate for UNIX            */\n        testarg = '--help',          /* Alternate for GNU longopts    */\n       ) Then                        /*                               */\n   Call USAGE;\n  When (testargU = '-?TSO') Then\n   Call USAGE_TSO\n  When (testargU = '-?UNIX') Then\n   Call USAGE_UNIX\n  When (Left(testargU,7) = 'OUTPUT(') Then\n   Do\n    If ')' <> Right(testargU,1) Then\n     Do\n      Say '**(Error-1)* OUTPUT option syntax is invalid.'\n      Say '**(Error-2)* No end parenthesis.'\n      exitRC = badRC\n      signal FINISH\n     End\n    parse var testarg 'OUTPUT(' argvalue ')'\n    /* See if argument is inclosed in quotes */\n    If \"'\" = Left(argvalue,1) Then\n     Do\n      If \"'\" <> Right(argvalue,1) Then\n       Do\n        Say '**(Error-1)* Invalid output specification:'argvalue\n        exitRC = badRC\n        signal FINISH\n       End\n      Else\n       Do\n        t = substr(argvalue,2,1) /* test if possible UNIX file */\n        If t = '~' |,\n           t = '.' |,\n           t = '/' Then /* It should likely be UNIX */\n         argvalue = substr(argvalue,2,length(argvalue)-2)\n       End\n     End\n    Else /* Argument not in quotes - test for TSO */\n     If Environment = 'TSO' Then\n      upper argvalue /* only upper case when in TSO */\n    If argvalue <> '' Then\n     outputLocation = argvalue\n    Else\n     If sh_flag Then\n      outputLocation = unix_CWD\n     Else\n      outputLocation = '//'\n    If Left(outputLocation,1) <> '~' &,\n       Left(outputLocation,1) <> '.' &,\n       Left(outputLocation,1) <> '/' Then\n     outputLocation = '//'outputLocation\n    outputLocation = resolveLocation(outputLocation)\n   End\n  When (Left(testargU,8) = '--OUTPUT') Then\n   Do\n    parse var testarg '=' argvalue\n    If argvalue <> '' Then\n     outputLocation = argvalue\n    Else\n     If sh_flag Then\n      outputLocation = unix_CWD      /* In UNIX, current working dir  */\n     Else\n      outputLocation = '//'          /* In TSO, the random PDS name   */\n    outputLocation = resolveLocation(outputLocation)\n   End\n  When (Left(testargU,2) = '-O' ) Then/* Output Location            */\n   Do\n    If testargU = '-O' Then\n     Do\n/*    outputLocation = Word(vals,argNum+1)  */\n      argNum = argNum + 1            /* increment loop variable       */\n      outputLocation = __argv.argNum\n     End\n    Else\n     outputLocation = substr(testarg,3)\n    If '' = outputLocation Then      /* Set default location          */\n     If sh_flag Then\n      outputLocation = unix_CWD      /* In UNIX, current working dir  */\n     Else\n      outputLocation = '//'          /* In TSO, the random PDS name   */\n    Else\n     NOP\n    If sh_flag Then /* Special handling for UNIX shell */\n     Do\n      fChar = Left(outputLocation,1) /* simplify tests */\n      if fChar <> '~' &, /* Not UNIX home directory */\n         fChar <> '/' &, /* Not absolute directory or DSN */\n         fChar <> '.' Then /* Not UNIX relative directory */\n       outputLocation = './'outputLocation/* make UNIX relative & hope*/\n     End\n    outputLocation = resolveLocation(outputLocation)\n   End\n  When ('-' = left(testarg,1)) Then  /* Must be invalid argument      */\n   Do\n    Say \"**(Error-1)* Invalid option specified:\"testarg\n    exitRC = badRC\n    signal FINISH\n   End\n  Otherwise                          /* Must be one of the two catalog*/\n   Do                                /* name arguments                */\n    catNum = catNum + 1              /*                               */\n    cat.catNum = testargU            /*                               */\n   End\n End                                 /*                               */\nEnd                                  /*                               */\nSelect                               /*                               */\n When (catNum = 0) Then              /*                               */\n  Do                                 /*                               */\n   Say '**(cat)** No entry provided for catalog name.'\n   exitRC = badRC\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\n When (catNum = 1) Then              /* only one catalog              */\n  process = 'RCNVTCAT'               /* process as normal RCNVTCAT    */\n When (catNum = 2) Then              /* two catalogs                  */\n  process = 'CATCOMP'                /* process for Catalog compare   */\n Otherwise                           /* two catalogs                  */\n  Do                                 /*                               */\n   Say '**(cat)** Too many arguments='catNum' - retry.'\n   exitRC = badRC\n   Signal FINISH                     /* exit exec                     */\n  End                                /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\nIf (DsExist(\"'\"cat.1\"'\") > 0) Then /*                               */\n Do                                /*                               */\n  Say '**(cat)** Bad entry provided for catalog name.'\n  Say '**(cat)** 'cat.1\n  Say '**(cat)** LISTDSI Return code = 'sysreason\n  Say '**(cat)** 'sysmsglvl1\n  Say '**(cat)** 'sysmsglvl2\n  exitRC = badRC\n  Signal FINISH                    /* exit exec                     */\n End                               /*                               */\nIf (process = 'CATCOMP') &,        /* Catalog compare processing    */\n   (DsExist(\"'\"cat.2\"'\") > 0) Then /* bad return                    */\n Do                                /*                               */\n  Say '**(cat)** Bad entry provided for second catalog name.'\n  Say '**(cat)** 'cat.2\n  Say '**(cat)** LISTDSI Return code = 'sysreason\n  Say '**(cat)** 'sysmsglvl1\n  Say '**(cat)** 'sysmsglvl2\n  exitRC = badRC\n  Signal FINISH                    /* exit exec                     */\n End                               /*                               */\n/**********************************************************************/\n/* Setup for output of reports                                        */\n/**********************************************************************/\nCall DSN_HANDLING\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nIf (process = 'RCNVTCAT') Then       /* Process as RCNVTCAT           */\n Do                                  /*                               */\n  count.id = 0                       /* initialise count              */\n  member = 'ALIAS'                   /* processing ALIAS              */\n  x = CSI(cat.1,'**','X','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'NONVSAM'                 /* processing NONVSAM            */\n  x = CSI(cat.1,'**','AH','Y')       /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYS1'                    /* processing SYS1               */\n  x = CSI(cat.1,'SYS1.**','AH','Y')  /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'IMPORT'                  /* processing IMPORT             */\n  x = CSI(cat.1,'**','U','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'GDG'                     /* processing GDG                */\n  x = CSI(cat.1,'**','B','Y')        /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'MISC'                    /* processing MISC               */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'RECAT'                   /* processing RECAT (MISC+)      */\n  x = CSI(cat.1,'**','CGR','Y')      /* Call CSI                      */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'SYSCTLG'                 /* processing SYSCTLG            */\n  x = CSI(cat.1,'SYSCTLG.**','AH','Y') /* Call CSI                    */\n  Call WRITE_MEMBER                  /* write-out member              */\n  member = 'REPORT'                  /* processing REPORT             */\n  Call MEM_REPORT                    /* generate report               */\n  Call WRITE_MEMBER                  /* write out member              */\n End                                 /*                               */\nElse                                 /* Process as Catalog compare    */\n Do                                  /*                               */\n  id = 'OLD'                         /* specify for 'old' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.old = cat.1                    /* retain catalog name           */\n  x = CSI(cat.1,flt,' ','Y')         /* Call CSI procedure            */\n  id = 'NEW'                         /* specify for 'NEW' catalog     */\n  count.id = 0                       /* initialise count              */\n  cat.new = cat.2                    /* retain catalog name           */\n  x = CSI(cat.2,flt,' ','Y')         /* Call CSI procedure            */\n  member = 'COMPFULL'                /* processing FULL comparison    */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'COMPSHRT'                /* processing SHORT comparison   */\n  Call COMP_REPORT                   /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'EXTRA'                   /* processing EXTRA member       */\n  Call NEW_EXT                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n  member = 'CHANGED'                 /* processing CHANGED member     */\n  Call OLD_BAD                       /* Build the report              */\n  Call WRITE_MEMBER                  /* write the report              */\n End                                 /*                               */\n/**********************************************************************/\n/* Display output if foreground ISPF                                  */\n/**********************************************************************/\nIf (env_flag ) &,                    /*                               */\n   (ispf_flag ) Then                 /*                               */\n Do                                  /*                               */\n  If '//' = Left(outputLocation,2) Then\n   rcnvdsn=substr(outputLocation,3)\n  Else\n   rcnvdsn=outputLocation\n  If '/' = left(rcnvdsn,1) Then\n   Address ISPEXEC \"EDIT FILE(rcnvdsn)\"\n  Else\n   Address ISPEXEC \"EDIT DATASET('\"rcnvdsn\"')\"\n  bpxparm = \"Free Fi(REPORT)\"\n  Call BPXWDYN(bpxparm)              /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* Finish the REXX                                                    */\n/**********************************************************************/\nFINISH:                              /*                               */\nExit exitRC                          /* Exit the code                 */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat.1,1,44)        /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword used        */\n Say '**(csi)***** Fullword processing selected'\nElse                                 /* check if fullword used        */\n Say '**(csi)***** Halfword processing - default'\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '000E'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('GDGLIMIT',8)        /* GDG Limit                     */\ncsifld06 = Left('GDGATTR ',8)        /* GDG Attributes                */\ncsifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date         */\ncsifld08 = Left('ATTR1   ',8)        /* Attributes                    */\ncsifld09 = Left('CATTR   ',8)        /* Attributes page and swap      */\ncsifld10 = Left('DEVTYP  ',8)        /* UCB Device type               */\ncsifld11 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld12 = Left('FILESEQ ',8)        /* File Sequence number          */\ncsifld13 = Left('VSAMREUS',8)        /* VSAM dataset information      */\ncsifld14 = Left('VSAMTYPE',8)        /* VSAM dataset information      */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10\ncsifield = csifield||csifld11||csifld12||csifld13||csifld14\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  If (debug = 2) Then                /*                               */\n   Do                                /*                               */\n    Say 'off=<'off'>'                /*                               */\n    Say 'entry =<'Substr(dwork,off,150)'>'\n    Say 'entry X=<'C2x(Substr(dwork,off,150))'>'\n   End                               /*                               */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    Select                           /*                               */\n     When (csienter = '1') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     When (csiedata = '0') Then      /*                               */\n      Do                             /*                               */\n       Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n       Say '**(Error-2)* No data returned'\n       Say '**(Error-3)* Module='mod' Return='ret' Reason='res\n       plus = 50                     /* length for error entry        */\n      End                            /*                               */\n     Otherwise                       /*                               */\n      Do                             /*                               */\n       If (csioptns = 'F') Then      /* check if fullword requested   */\n        csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length */\n       Else                          /* otherwise (default halfword)  */\n        csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length */\n       Call ENTRY                    /* Execute entry processing      */\n       plus = 46 + csitotln          /* length for normal entry       */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\ngdglimit = Substr(dwork,o_fld.5,l_fld.5)   /* GDG limit               */\ngdgattr  = Substr(dwork,o_fld.6,l_fld.6)   /* GDG attributes          */\ndscrdt2  = Substr(dwork,o_fld.7,l_fld.7)   /* dataset creation date   */\nattr1    = Substr(dwork,o_fld.8,l_fld.8)   /* attributes              */\ncattr    = Substr(dwork,o_fld.9,l_fld.9)   /* attribs page and swap   */\ndevtyp   = Substr(dwork,o_fld.10,l_fld.10) /* device type             */\nvolser   = Substr(dwork,o_fld.11,l_fld.11) /* volume serial           */\nfileseq  = Substr(dwork,o_fld.12,l_fld.12) /* file sequence           */\nvsamreus = Substr(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/\nvsamtype = Substr(dwork,o_fld.14,l_fld.14) /* VSAM dataset information*/\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nvsam_attr = ''                           /* initialise vsam attributes*/\nIf (Index(csifield,'DEVTYP') > 0) Then   /*                           */\n Call FLD_DEVTYP                         /*                           */\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ATTR1') > 0) Then    /*                           */\n Call FLD_ATTR1                          /*                           */\nIf (Index(csifield,'CATTR') > 0) Then    /*                           */\n Call FLD_CATTR                          /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'GDGATTR') > 0) Then  /*                           */\n Call FLD_GDGATTR                        /*                           */\nIf (Index(csifield,'GDGLIMIT') > 0) Then /*                           */\n Call FLD_GDGLIMIT                       /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\nIf (Index(csifield,'VSAMTYPE') > 0) Then /*                           */\n Call FLD_VSAMTYPE                       /*                           */\nIf (Index(csifield,'VSAMREUS') > 0) Then /*                           */\n Call FLD_VSAMREUS                       /*                           */\nIf (Index(csifield,'DSCRDT2') > 0) Then  /*                           */\n Call FLD_DSCRDT2                        /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGLIMIT - Process GDGLIMIT field                              */\n/**********************************************************************/\nFLD_GDGLIMIT:                        /* GDGLIMIT field processing   ##*/\ngdglimit = X2d(C2x(gdglimit))        /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_GDGATTR  - Process GDGATTR  field                              */\n/**********************************************************************/\nFLD_GDGATTR:                         /* GDGATTR  field processing   ##*/\ngdgattr = X2b(C2x(gdgattr))          /*                               */\nIf (Substr(gdgattr,1,1) = '1') Then  /*                               */\n gdg_emp = 'EMPTY'                   /*                               */\nElse                                 /*                               */\n gdg_emp = 'NOEMPTY'                 /*                               */\nIf (Substr(gdgattr,2,1) = '1') Then  /*                               */\n gdg_scr = 'SCRATCH'                 /*                               */\nElse                                 /*                               */\n gdg_scr = 'NOSCRATCH'               /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DSCRDT2  - Process DSCRDT2  field                              */\n/**********************************************************************/\nFLD_DSCRDT2:                         /* DSCRDT2  field processing   ##*/\nIf (Substr(dscrdt2,1,2) <> 'FFFF'X) Then\n Do                                  /*                               */\n  yyddd = C2x(Substr(dscrdt2,1,3))   /*                               */\n  yy    = Substr(yyddd,1,2)          /*                               */\n  ddd   = Substr(yyddd,3,3)          /*                               */\n  cent  = C2x(Substr(dscrdt2,4,1))   /*                               */\n  If (cent = '00') Then              /*                               */\n   yyyy    = yy + 1900               /*                               */\n  Else                               /*                               */\n   yyyy    = yy + 2000               /*                               */\n  If (yyyy = '1900') Then            /* correct for '00'              */\n   yyyy = '2000'                     /*                               */\n  savcrdt2 = dscrdt2\n  dscrdt2 = yyyy'.'ddd               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ATTR1    - Process ATTR1    field                              */\n/**********************************************************************/\nFLD_ATTR1:                           /* ATTR1    field processing   ##*/\nattr1 = X2b(c2x(attr1))              /*                               */\nIf (Substr(attr1,1,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' SPEED'       /*                               */\nIf (Substr(attr1,3,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nIf (Substr(attr1,4,1) = '1') Then    /*                               */\n vsam_attr = vsam_attr' ERASE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_CATTR    - Process CATTR    field                              */\n/**********************************************************************/\nFLD_CATTR:                           /* CATTR    field processing   ##*/\ncattr = X2b(C2x(cattr))              /*                               */\nIf (entype = 'CLUSTER') Then         /*                               */\n Do                                  /*                               */\n  If (Substr(cattr,8,1) = '1') Then  /*                               */\n   entype = 'PAGESPACE'              /*                               */\n  If (Substr(cattr,7,1) = '1') Then  /*                               */\n   pageswap = 'SWAP'                 /*                               */\n  Else                               /*                               */\n   pageswap = 'NOSWAP'               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_DEVTYP   - Process DEVTYP   field to translate data            */\n/**********************************************************************/\nFLD_DEVTYP:                          /* DEVTYP   field processing   ##*/\ndevices = ''                         /* initialise devices            */\nDo d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field        */\n device   = Substr(devtyp,d_pos,4)   /* get device (UCB)              */\n d_model  = Substr(device,1,1)       /* get model byte                */\n d_option = Substr(device,2,1)       /* get option byte               */\n d_class  = Substr(device,3,1)       /* get class byte                */\n d_device = Substr(device,4,1)       /* get device byte               */\n Select                              /*                               */\n  When (d_class = '80'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'TAPE'               /* Tape device                   */\n    Select                           /*                               */\n     When (d_device = '03'x) Then dev_type = '3400' /* 3400/3420-3/5/7*/\n     When (d_device = '04'x) Then dev_type = '3420' /* 3420-4/6/8     */\n     When (d_device = '05'x) Then dev_type = '3410' /*                */\n     When (d_device = '06'x) Then dev_type = '8809' /*                */\n     When (d_device = '07'x) Then dev_type = '3430' /*                */\n     When (d_device = '08'x) Then dev_type = '7340' /*                */\n     When (d_device = '09'x) Then dev_type = '9374' /*                */\n     When (d_device = '80'x) Then dev_type = '3480' /*                */\n     When (d_device = '81'x) Then dev_type = '3490' /*                */\n     When (d_device = '83'x) Then dev_type = '3590' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End                               /*                               */\n  When (d_class = '20'x) Then        /*                               */\n   Do                                /*                               */\n    dev_class = 'DASD'               /* DASD device                   */\n    Select                           /*                               */\n     When (d_device = '04'x) Then dev_type = '9345' /*                */\n     When (d_device = '09'x) Then dev_type = '3330' /*                */\n     When (d_device = '0A'x) Then dev_type = '3340' /*                */\n     When (d_device = '0B'x) Then dev_type = '3350' /*                */\n     When (d_device = '0C'x) Then dev_type = '3375' /*                */\n     When (d_device = '0D'x) Then dev_type = '3330' /* 3330-11        */\n     When (d_device = '0E'x) Then dev_type = '3380' /*                */\n     When (d_device = '0F'x) Then dev_type = '3390' /*                */\n     When (device = '00000000'x) Then dev_type = '0000'     /*        */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n  Otherwise                          /*                               */\n   Do                                /*                               */\n    dev_class = 'UNKN'               /* Unknown device                */\n    Select                           /*                               */\n     When (device = '00000000'x) Then dev_type = '0000' /*            */\n     Otherwise                       /*                               */\n      dev_type = C2x(device)         /* show UCB if unknown           */\n      Say '**(Error-1)* Device type processing for 'Strip(entname,T)\n      Say '**(Error-2)* Device type = 'dev_type\n    End                              /*                               */\n   End\n End                                 /*                               */\n devices = devices||' '||Left(dev_type,8) /* build device list        */\nEnd                                  /*                               */\ndevices = Strip(devices,B,' ')       /* clean up device list          */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMREUS - Process VSAMREUS field - mainly duplicates ATTR1    */\n/**********************************************************************/\nFLD_VSAMREUS:                        /* VSAMREUS field processing   ##*/\nReturn                               /* duplicates ATTR1              */\nvsamreus = X2b(C2x(vsamreus))        /* show binary flags             */\nIf (Substr(vsamreus,3,1) = '1') Then /* Check REUSE flag              */\n vsam_attr = vsam_attr' REUSE'       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VSAMTYPE - Process VSAMTYPE field                              */\n/**********************************************************************/\nFLD_VSAMTYPE:                        /* VSAMTYPE field processing   ##*/\nvsam_byte1 = X2b(C2x(Substr(vsamtype,1,1))) /* get byte 1             */\nvsam_byte2 = X2b(C2x(Substr(vsamtype,2,1))) /* get byte 2             */\nSelect                               /*                               */\n When (Substr(vsam_byte1,1,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'KSDS'                /*                               */\n   vsam_attr = vsam_attr' INDEXED'   /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte1,7,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'RRDS'                /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,6,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'LDS'                 /*                               */\n   vsam_attr = vsam_attr' LINEAR'    /*                               */\n  End                                /*                               */\n When (Substr(vsam_byte2,8,1) = '1') Then /*                          */\n  Do                                 /*                               */\n   vsam_type = 'VRRDS'               /*                               */\n   vsam_attr = vsam_attr' NUMBERED'  /*                               */\n  End                                /*                               */\n Otherwise                           /*                               */\n  Do                                 /*                               */\n   vsam_type = 'ESDS'                /*                               */\n   If (entype <> 'INDEX') Then       /*                               */\n    vsam_attr = vsam_attr' NONINDEXED'/*                              */\n  End                                /*                               */\nEnd                                  /*                               */\nIf (Substr(vsam_byte1,2,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' WRITECHECK'  /*                               */\nIf (Substr(vsam_byte1,3,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' IMBED'       /*                               */\nIf (Substr(vsam_byte1,4,1) = '1') Then /*                             */\n vsam_attr = vsam_attr' REPLICATE'   /*                               */\nIf (entype <> 'INDEX') Then          /*                               */\n If (Substr(vsam_byte1,8,1) = '1') Then /*                            */\n  vsam_attr = vsam_attr' SPANNED'     /*                              */\nIf (Substr(vsam_byte2,2,1) = '1') Then /* undocumented VVDS indicator */\n vsam_vvds = 'Y'                     /* Set VVDS flag                 */\nElse                                 /*                               */\n vsam_vvds = 'N'                     /* Set VVDS flag off             */\nvsam_attr = Strip(vsam_attr,B)       /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* WRITE_MEMBER - Write out the generated lines to a PDS member       */\n/**********************************************************************/\nWRITE_MEMBER:                        /* Write out the report member ##*/\nIf (l_cnt = 0) Then                  /* if no output                  */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /* write a no output line        */\n  l.l_cnt = ' /*' no data produced '*/' /*                            */\n End                                 /*                               */\nIf (member <> 'REPORT') Then         /* if not a REPORT member        */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*  add a line                   */\n  l.l_cnt = ' /*'member'*/'          /*  add report name              */\n End                                 /*                               */\nIf (outflag <> 'JES') Then           /* if not jes queue              */\n Do                                  /*                               */\n  If '//' = left(outputLocation,2) Then\n   call AllocReportFile 'MEMOT',outputLocation'('member')'\n  Else\n   call AllocReportFile 'MEMOT',outputLocation'/'member'.txt'\n  Address MVS \"ExecIO \"l_cnt\" DiskW MEMOT (Finis Stem l.)\"\n  bpxparm = \"Free Fi(MEMOT)\"         /*                               */\n  Call BPXWDYN(bpxparm)              /*                               */\n End                                 /*                               */\nElse                                 /* otherwise                     */\n Address MVS \"ExecIO \"l_cnt\" DiskW REPORT (Finis Stem l.)\"\nl_cnt = 0                            /* re-init line count for next   */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DSN_HANDLING - Carry out processing for output dataset             */\n/**********************************************************************/\nDSN_HANDLING:                        /* 'Handle' the data produced  ##*/\nrc = Listdd(REPORT)                  /* sets variable:rcnvdsn         */\nIf (rc = 0) Then\n If rcvtpath = '' Then\n  outputLocation='//'||rcnvdsn\n Else\n  outputLocation=rcvtpath\nIf (rc = 16) Then                    /* REPORT not allocated          */\n If sh_flag Then\n  Do\n   Address syscall getlogin sysuid\n   sysuid=strip(sysuid,\"T\",\" \");\n   If '' = outputLocation Then\n    outputLocation=unix_CWD\n   If ('//' = Left(outputLocation,2)) Then\n    Do\n     If '//' = outputLocation Then\n      Do\n       random_dsn = 'T'random(9999)\n       rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn\n       outputLocation=\"//\"||rcnvdsn\n      End\n      Call AllocReportFile 'REPORT',outputLocation\n    End\n   Call bpxwdyn(\"free fi(REPORT)\")\n  End\n Else\n  Do /* Must be TSO */              /*                               */\n   If '' = outputLocation Then\n    outputLocation='//'\n   If '//' = Left(outputLocation,2) Then\n   Select\n    When '//' = Left(outputLocation,2) Then\n    Do\n     If '//' = outputLocation Then\n      Do\n       random_dsn = 'T'random(9999)\n       rcnvdsn = sysuid'.RCNVTCAT.REPORT.'random_dsn\n       outputLocation = \"//\"||rcnvdsn\n      End\n /*  rcnvdsn=substr(outputLocation,3) */\n     Call AllocReportFile 'REPORT',outputLocation\n    End\n   Otherwise /* better start with a single slash! */\n    Do\n      If '/' <> Left(outputLocation,1) Then\n       Do\n        Say \"**(Error-1)* Invalid output destination:\"outputLocation\n        exitRC = badRC\n        signal FINISH\n       End\n    End\n   End\n  End                               /*                               */\nIf '//' = Left(outputLocation,2) Then\n dsn=\"DSN:\"substr(outputLocation,3)\nElse\n Do\n  /*\n    Validate UNIX path for efficiency and better diagnostics\n  */\n  If flag_syscall <> 1 Then\n   If SYSCALLS('ON') > 3 Then\n    Do\n     Say \"Unable to establish a UNIX environment. Aborting\"\n     exit(8)\n    End\n  flag_syscall = 1\n  Address SYSCALL \"stat (outputLocation) st.\"\n/*Say \"!\"outputLocation\"!\"rc\"!\"retval\"!\"st.ST_TYPE\"!\"S_ISDIR\"!\",\n    unix_HOME\"|\" */\n  If retval = -1 Then\n   Do\n    Say '**(Error-1)* Invalid output destination:'outputLocation\n    Say '**(Error-2)* One of the directories in the path does'||,\n        ' not exist.'\n    exitRC = badRC\n    signal FINISH\n   End\n  If st.ST_TYPE <> S_ISDIR Then\n   Do\n    Say '**(Error-1)* Invalid output destination:'outputLocation\n    Say '**(Error-2)* 'outputLocation' is not a directory.'\n    exitRC = badRC\n    signal FINISH\n   End\n  dsn=\"Path:\"outputLocation\n End\nsay 'RCNVTCAT Report '||dsn /*'outputLocation:'outputLocation*/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nali_tot = 0                          /* Total Aliases                 */\nasy_tot = 0                          /* Total Aliases SYSCATLG        */\nanv_tot = 0                          /* Total Aliases NONVSAM         */\naxx_tot = 0                          /* interim alias total           */\navu_tot = 0                          /* Total Aliases VSAM UCAT       */\ngdg_tot = 0                          /* Total GDGs                    */\nivd_tot = 0                          /* Total invalid devices         */\nmsc_tot = 0                          /* Total MISC datasets           */\nnvd_tot = 0                          /* Total NONVSAM datasets        */\nnvo_tot = 0                          /* Total NONVSAM (not SYS1) dsns */\nnvv_tot = 0                          /* Total NONVSAM dsn volumes     */\nsyc_tot = 0                          /* Total SYSCTLG datasets        */\nsy1_tot = 0                          /* Total NONVSAM SYS1 datasets   */\nuct_tot = 0                          /* Total Usercatalog imports     */\nReturn                               /*                               */\n/**********************************************************************/\n\nDsExist: /*Procedure Expose sysreason sysmsglvl1 sysmsglvl2 badRC ,\n           (syscall_constants) */\nparse arg indsn\nsysreason=0\nsysmsglvl1=' Not Emulated '\nsysmsglvl2=' Not Emulated '\nIf indsn = '' Then\n Do\n   sysreason=29\n   return 16\n End\nxx=outtrap('junk.','*') /* I don't care */\nAddress TSO \"LISTCAT ENT(\"indsn\")\"\nxx=outtrap(\"OFF\")\nlrc=rc\nsysreason=rc\nhexrc=right(d2x(rc),8,\"0\")\nIf \"0438\" = left(hexrc,4) Then\n Do\n  sysreason=24\n  Return 16\n End\ndrop junk.\nreturn lrc\nLISTDD:   /* new routine */\nrc=bpxwdyn(\"INFO \",\n           \"DD(REPORT) \",\n           \"INRTDSN(rcnvdsn) \",\n           \"INRTPATH(rcvtpath) \",\n           \"MSG(message.)\")\n/*\n           \"INRDSNT(dsntype) \",\n           \"INRTORG(dsorg) \",\n*/\nIf rc <> 0 Then\n Do\n  rcnvdsn=''\n  return 16\n End\n If rcnvdsn='...PATH=.SPECIFIED...' Then\n  rcnvdsn = rcvtpath\nreturn 0\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nAllocReportFile: /* Procedure EXPOSE sysuid unix_HOME badRC ,\n                    (syscall_constants) */\n parse arg DDname,whereOutput,rest\n If rest<> '' |,\n    whereOutput = '' Then\n  Do\n   Say \"Invalid call to AllocReportFile.\"\n   exit(16)\n  End\n Select\n  When '//' = left(whereOutput,2) Then\n   Do\n    j = Pos('(',whereOutput)\n    If j = 0 Then\n     j = Length(whereOutput) + 1\n    If (DsExist(\"'\"substr(left(whereOutput,j-1),3)\"'\") <> 0) &,\n       (j >= Length(whereOutput)) Then\n     Allocation=\"Unit(SYSALLDA) Space(2,2) Dir(10) Cyl New Catalog\"\n    Else\n     Allocation='Old ' /* Original code had Shr */\n    varOutput = \"Da('\"substr(whereOutput,3)\"') Reuse \"Allocation\n   End\n  When '/' = Left(whereOutput,1) Then\n   varOutput = \"Path('\"whereOutput\"') \",\n               \"FILEDATA(TEXT) \",\n               \"PATHMODE(SIRWXU,SIRGRP,SIXGRP,SIROTH,SIRGRP) \",\n               \"PATHOPTS(OTRUNC,OWRONLY,OCREAT)\"\n /*\n */\n  When '~/' = Left(whereOutput,2) |,\n       '.' = Left(whereOutput,1) Then\n   Do\n    If Address() = 'TSO' &,\n       left(unix_HOME,1) <> '/'\n    Then\n     Do\n      If flag_syscall <> 1 Then\n       If SYSCALLS('ON') > 3 Then\n        Do\n         Say \"Unable to establish a UNIX environment. Aborting\"\n         exit(8)\n        End\n      flag_syscall = 1\n      Address SYSCALL \"setpwent\"\n      Do FOREVER\n       Address SYSCALL \"getpwent passwd.\"\n       If retval = 0 | retval = -1 Then\n        Do\n         exitRC = 1\n         say \"**(Error-1)* Cannot find user:\"sysuid\n         signal FINISH\n        End\n       If strip(passwd.PW_NAME,\"T\",\" \") = sysuid Then LEAVE\n      End\n      unix_HOME = passwd.PW_DIR /* Get the home directory from RACF */\n     End\n    If '~' = Left(whereOutput,1) Then\n     whereOutput=unix_HOME||Substr(whereOutput,2)\n    Else /* Must be a . */\n     whereOutput=unix_CWD||\"/\"||whereOutput\n    varOutput = \"Path('\"whereOutput\"') \",\n               \"PATHMODE(SIRWXU,SIRGRP,SIXGRP,SIROTH,SIRGRP) \",\n               \"FILEDATA(TEXT) \",\n               \"PATHOPTS(OTRUNC,OWRONLY,OCREAT)\"\n   End\n  When '~' = Left(whereOutput,1) Then\n   Do\n    j = Pos('/',whereOutput)\n    if (0 = j) Then\n     Do\n      whereOutput=whereOutput||'/'\n      j = length(whereOutput)\n     End\n    tuser=substr(left(whereOutput,j - 1),2)\n    upper tuser\n    If flag_syscall <> 1 Then\n     If SYSCALLS('ON') > 3 Then\n      Do\n       Say \"Unable to establish a UNIX environment. Aborting\"\n       exit(8)\n      End\n    flag_syscall = 1\n    Address SYSCALL \"setpwent\"\n    Do FOREVER\n     Address SYSCALL \"getpwent passwd.\"\n     If retval = 0 | retval = -1 Then\n      Do\n       exitRC = 1\n       say \"**(Error-1)* Cannot find user:\"tuser\n       signal FINISH\n      End\n     If strip(passwd.PW_NAME,\"T\",' ') = tuser Then LEAVE\n    End\n    unix_HOME=passwd.PW_DIR\n    whereOutput=passwd.PW_DIR||substr(whereOutput,j)\n    varOutput = \"Path('\"whereOutput\"') \",\n               \"PATHMODE(SIRWXU,SIRGRP,SIXGRP,SIROTH,SIRGRP) \",\n               \"FILEDATA(TEXT) \",\n               \"PATHOPTS(OTRUNC,OWRONLY,OCREAT)\"\n   End\n   Otherwise\n    Do\n     Say 'Unknown parameter value whereOutput='whereOutput\n     exit(8)\n    End\n End\n bpxparm = \"Alloc \",\n           varOutput,\n           \"Fi(\"DDname\") \",\n           \"Lrecl(133) \",\n           \"Blksize(1330) \",\n           \"Recfm(F,B) \"\n rc=BPXWDYN(bpxparm)\n If rc <> 0 Then\n  Do\n   Say \"Allocation string:\"bpxparm\n   bpxmtext=''\n   Say \"S99MSG messages:\"S99MSG.0\n   Do j=1 to S99MSG.0\n      Say S99MSG.j\n      parse var S99MSG.j . 'REASON CODE IS (' bpxmtext ')'\n      If '' <> bpxmtext Then\n       Do\n        stdin.0=0\n        rc=bpxwunix(\"/bin/bpxmtext \"||bpxmtext,stdin.,stdout.,stderr.)\n        Do k=1 to stdout.0\n         Say \"BPXMTEXT-1:\"||stdout.k\n        End\n        Do k=1 to stderr.0\n         Say \"BPXMTEXT-2:\"||stderr.k\n        End\n       End\n   End\n   Say '**(Error-1)* Allocation of DD:'DDname' Failed.'\n   Select\n    When rc = 20 Then\n     Say '**(Error-2)* BPXWDYN Invalid Parameter List.'\n    When rc > 0 | rc <-1610612737 Then\n     Do\n      hexrc=rc\n      Say '**(Error-2)* Dynamic Allocation error code:'hexrc\n     End\n    When rc <= -21 & rc >= -9999 Then\n     Do\n      Say '**(Error-2)* Error in key number 'abs(rc)-20\n      Say 'Call list:'bpxparm\n     End\n    When rc <= -10000 & rc >= -10099 Then\n     Do\n       Say '**(Error-2)* Message processing error. IEFDB476 returned code:',\n           abs(rc)-10000\n       Say 'Call list:'bpxparm\n     End\n    Otherwise\n     Say '**(Error-2)* Other error. Return code is 'rc\n   End\n   exitRC=badRC\n   signal FINISH\n  End\n Return\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\n                                     /*                               */\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n  Say '**(cat)** Processing 'Left('CATALOG',10) csicname\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  If (process = 'CATCOMP') Then      /** Catalog compare code        **/\n   Do                                /*                               */\n    count.id           = count.id+1  /* increment count               */\n    val                = count.id    /* save value                    */\n    entname.id.val     = entname     /* store entry name              */\n    entype.id.val      = entype      /* store entry type              */\n    name.id.val        = name        /* store assoc name              */\n    type.id.val        = type        /* store assoc type              */\n    pageswap.id.val    = pageswap    /* store pageswap                */\n    devices.id.val     = devices     /* store devices                 */\n    fils.id.val        = fils        /* store fils                    */\n    gdg_emp.id.val     = gdg_emp     /* store gdg_emp                 */\n    gdg_scr.id.val     = gdg_scr     /* store gdg_scr                 */\n    gdglimit.id.val    = gdglimit    /* store gdglimit                */\n    vsam_attr.id.val   = vsam_attr   /* store vsam_attr               */\n    vsam_type.id.val   = vsam_type   /* store vsam_attr               */\n    vsam_vvds.id.val   = vsam_vvds   /* store vsam_vvds               */\n    volsers.id.val     = volsers     /* store volsers by value        */\n                                     /** Back reference values       **/\n    volsers.id.entname = volsers     /* store volsers by entry name   */\n    name.id.entname    = name        /* store name by entry name      */\n    val.id.entname     = val         /* store value by entry name     */\n   End                               /** End Catalog compare code    **/\n  Else                               /*                               */\n   Do                                /*                               */\n    Select                           /*                               */\n     When (member = 'MISC') Then     /* MISC member                   */\n      Call MEM_MISC                  /*                               */\n     When (member = 'RECAT') Then    /* RECAT member                  */\n      Call MEM_RECAT                 /*                               */\n     When (member = 'ALIAS') Then    /* ALIAS member                  */\n      Call MEM_ALIAS                 /*                               */\n     When (member = 'GDG') Then      /* GDG member                    */\n      Call MEM_GDG                   /*                               */\n     When (member = 'IMPORT') Then   /* IMPORT member                 */\n      Call MEM_IMPORT                /*                               */\n     When (member = 'NONVSAM') Then  /* NONVSAM member                */\n      Do                             /*                               */\n       axx_tot = anv_tot             /* set intermim alias total      */\n       nvd_tot = nvd_tot + 1         /* increment total non-vsam      */\n       nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols        */\n       If (Substr(entname,1,4) <> 'SYS1') &,\n          (Substr(entname,1,7) <> 'SYSCTLG') Then /* not SYS1/SYSCTLG */\n        Do                           /*                               */\n         nvo_tot = nvo_tot + 1       /* increment non-vsam only total */\n         Call MEM_NONVSAM            /*                               */\n        End                          /*                               */\n       anv_tot = axx_tot             /* set non-vsam aliases total    */\n      End                            /*                               */\n     When (member = 'SYS1') Then     /* SYS1 member                   */\n      Do                             /*                               */\n       sy1_tot = sy1_tot + 1         /* increment sys1 total          */\n       Call MEM_NONVSAM              /*                               */\n      End                            /*                               */\n     When (member = 'SYSCTLG') Then  /* SYSCTLG member                */\n      Do                             /*                               */\n       axx_tot = asy_tot             /* interim = syscatlg aliases    */\n       syc_tot = syc_tot + 1         /* increment syscatlg total      */\n       Call MEM_NONVSAM              /*                               */\n       asy_tot = axx_tot             /* set syscatlg total            */\n      End                            /*                               */\n     Otherwise NOP                   /*                               */\n    End                              /*                               */\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_MISC - Generate MISC member lines                              */\n/**********************************************************************/\nMEM_MISC:                            /* Generate MISC member lines  ##*/\nIf (entype = 'CLUSTER') |,\n   (entype = 'PAGESPACE') Then\n Do\n  msc_tot = msc_tot + 1\n  l_cnt = l_cnt + 1\n  text = ' /* 'Left(entype' ',15,'-')\n  text = text' 'Left(entname,32)'  NOT PROCESSED */'\n  l.l_cnt = text\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_RECAT - Generate RECAT member lines                            */\n/**********************************************************************/\nMEM_RECAT:                           /* Generate RECAT member lines ##*/\nIf (entype = 'PAGESPACE') Then\n Do\n  page_name     = entname\n  page_swap     = pageswap\n  If (Index(type,'D') <> 0) Then\n   data_flag = 'DATA'\n  Else\n   data_flag = ''\n End\nIf (entype = 'CLUSTER') Then\n Do\n  If (Substr(entname,1,4) <> 'SYS1') Then\n   Do\n    cluster_name  = entname\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left(entype' ',15,'-')\n    text = text' 'Left(entname,34)' CANNOT RECAT */'\n    data_flag = ''\n    index_flag = ''\n    l.l_cnt = text\n   End\n  Else\n   Do\n    cluster_name  = entname\n    If (Index(type,'D') <> 0) Then\n     data_flag = 'DATA'\n    Else\n     data_flag = ''\n    If (Index(type,'I') <> 0) Then\n     index_flag = 'INDEX'\n    Else\n     index_flag = ''\n    cluster_bits  = type\n   End\n End\nIf (entype = 'DATA') &,\n   (data_flag = 'DATA') Then\n Select\n  When (vsam_vvds = 'Y') Then               /* use VVDS flag          */\n   Do\n    l_cnt = l_cnt + 1\n    text = ' /* 'Left('VVDS ',15,'-')\n    text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'\n    l.l_cnt = text\n   End\n  When (Index(name,page_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF PAGESPACE(NAME('Left(page_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left(page_swap,57)' -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    If targ_cat='' Then\n     l.l_cnt = '          CAT('Left(cat,44)'        )'\n    Else\n     l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n   End\n  When (Index(name,cluster_name) > 0) Then\n   Do\n    l_cnt = l_cnt + 1\n    l.l_cnt = '   DEF   CLUSTER(NAME('Left(cluster_name,44)') -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          VOL(  'Left(volser,50)') -'\n    If (vsam_attr <> '') Then\n     Do\n      l_cnt = l_cnt + 1\n      l.l_cnt = '          'Left(vsam_attr,57)' -'\n     End\n    l_cnt = l_cnt + 1\n    l.l_cnt = '          'Left('RECATALOG',55)' ) -'\n    l_cnt = l_cnt + 1\n    l.l_cnt = '         DATA(NAME('Left(entname,44)'   ) ) -'\n    If (index_flag = '') Then\n     Do\n      l_cnt = l_cnt + 1\n     If targ_cat='' Then\n      l.l_cnt = '          CAT('Left(cat,44)'        )'\n     Else\n      l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n     End\n   End\n  Otherwise\n   Say '**(Error--1)* Unexpected condition for :'\n   Say '**(Error--2)* cluster_name = 'Strip(cluster_name,T)\n   Say '**(Error--3)* page_name    = 'Strip(page_name,T)\n   Say '**(Error--4)* entname      = 'Strip(entname,T)\n   Say '**(Error--5)* entype       = 'Strip(entype,T)\n   Say '**(Error--6)* name         = 'Strip(name,T)\n   Say '**(Error--7)* type         = 'Strip(type,T)\n   Say '**(Error--8)* data_flag    = 'Strip(data_flag,T)\n   Say '**(Error--9)* index_flag   = 'Strip(index_flag,T)\n   Say '**(Error-10)* vsam_byte1   = 'vsam_byte1\n   Say '**(Error-11)* vsam_byte2   = 'vsam_byte2\n   Say '**(Error-12)* vsamreus     = 'vsamreus\n End\nIf (entype = 'INDEX') &,\n   (index_flag = 'INDEX') Then\n Do\n  l_cnt = l_cnt + 1\n  l.l_cnt = '         INDEX(NAME('Left(entname,44)'  ) ) -'\n  l_cnt = l_cnt + 1\n  l.l_cnt = '          CAT('Left(cat,44)'        )'\n  If targ_cat='' Then\n   l.l_cnt = '          CAT('Left(cat,44)'        )'\n  Else\n   l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\n End\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_ALIAS - Generate ALIAS member lines                            */\n/**********************************************************************/\nMEM_ALIAS:                           /* Generate ALIAS member lines ##*/\nali_tot = ali_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '     DEF ALIAS(NAME('entname')  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          REL('name'))          -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,44)'         )'\nIf targ_cat='' Then\n l.l_cnt = '          CAT('Left(cat,44)'         )'\nElse\n l.l_cnt = '          CAT('Left(targ_cat,44)'         )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_IMPORT - Generate IMPORT member lines                          */\n/**********************************************************************/\nMEM_IMPORT:                          /* Generate IMPORT member lins ##*/\nuct_tot = uct_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '    IMPORT   OBJ( ('entname'  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          DEVT('Left(devices,8)') VOL('volser')))'\nl.l_cnt = l.l_cnt' 'Left('CONNECT',26)' -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nIf targ_cat='' Then\n l.l_cnt = '          CAT('Left(cat,44)'        )'\nElse\n l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_GDG - Generate GDG member lines                                */\n/**********************************************************************/\nMEM_GDG:                             /* Generate GDG member lines   ##*/\ngdg_tot = gdg_tot + 1\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  GDG  (NAME('entname') -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          LIMIT('Right(gdglimit,3)') 'Left(gdg_scr,16)\nl.l_cnt = l.l_cnt' 'Left(gdg_emp,24)' )  -'\nl_cnt = l_cnt + 1\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nIf targ_cat='' Then\n l.l_cnt = '          CAT('Left(cat,44)'        )'\nElse\n l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_NONVSAM - Generate NONVSAM member lines                        */\n/**********************************************************************/\nMEM_NONVSAM:                         /* Generate NONVSAM member lins##*/\nl_cnt = l_cnt + 1\nl.l_cnt = '   DEF  NVSAM(NAME('entname') -'\nIf (Words(devices) <= 5) Then        /* < 5 devices for dataset       */\n Do                                  /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          DEVT( 'Left(devices,47)') -'\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq <> '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = '          FSEQN('Left(fileseq,47)') -'\n   End                               /*                               */\n  l_cnt = l_cnt + 1                  /*                               */\n  l.l_cnt = '          VOL(  'Left(volser,47)') )-'\n End                                 /*                               */\nElse                                 /* > 5 devices for dataset       */\n Do                                  /*                               */\n  item_lead = 'DEVT( '               /* devices header                */\n  item_end  = ') -'                  /* devices trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = devices                    /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n  If (dev_class = 'TAPE') &,         /* if devices is tape            */\n     (fileseq <> '0') Then           /* if fileseq number exist       */\n   Do                                /*                               */\n    item_lead = 'FSEQN('             /* fileseq header                */\n    item_end  = ') -'                /* fileseq trailer               */\n    item_pad  = Left('',7)           /* 7 spaces padding              */\n    items = fileseq                  /* pass data                     */\n    Call PLUS5_HANDLE                /* handle > 5 items              */\n   End                               /*                               */\n  item_lead = 'VOL(  '               /* volumes header                */\n  item_end  = ') ) -'                /* volumes trailer               */\n  item_pad  = ''                     /* no padding                    */\n  items = volser                     /* pass data                     */\n  Call PLUS5_HANDLE                  /* handle > 5 items              */\n End                                 /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = '          CAT('Left(cat,46)'       )'\nIf targ_cat='' Then\n l.l_cnt = '          CAT('Left(cat,44)'        )'\nElse\n l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nCall ASSOC_ENTRY                     /* process associated entries    */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ASSOC_ENTRY - Process associated entries                           */\n/**********************************************************************/\nASSOC_ENTRY:                         /* Process associated entries  ##*/\nDo ali = 1 to Words(name)\n If (Substr(type,ali,1) = 'X') Then\n  Do\n   axx_tot = axx_tot + 1\n   l_cnt = l_cnt + 1\n   l.l_cnt = '     DEF ALIAS(NAME('Left(Word(name,ali),44)') -'\n   l_cnt = l_cnt + 1\n   l.l_cnt = '          REL('entname'))  -'\n   l_cnt = l_cnt + 1\n   l.l_cnt = '          CAT('Left(cat,44)'         )'\nIf targ_cat='' Then\n l.l_cnt = '          CAT('Left(cat,44)'         )'\nElse\n l.l_cnt = '          CAT('Left(targ_cat,44)'         )'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM               */\n/**********************************************************************/\nPLUS5_HANDLE:                        /* Handle > 5 fields           ##*/\nl_cnt = l_cnt + 1\nw_end = Wordindex(items,6)\ndata = Left(Substr(items,1,w_end-1),47)\nl.l_cnt = '          'item_lead||data' -'\nDo mult = 6 to Words(items) by 5\n w_sta = Wordindex(items,mult)\n w_end = Wordindex(items,mult+5)\n If (w_end = 0) Then\n  item = Substr(items,w_sta)\n Else\n  item = Substr(items,w_sta,w_end-w_sta)\n l_cnt = l_cnt + 1\n item_length = 47 - Length(item_pad)\n l.l_cnt = '                '||item_pad||Left(item,item_length)' -'\nEnd\nl.l_cnt = Strip(l.l_cnt,T,'-')||item_end\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* MEM_REPORT - Generate REPORT member                                */\n/**********************************************************************/\nMEM_REPORT:                          /* Generate REPORT member      ##*/\nr.1  = 'OS CVOL CATALOG NAMES TO BE CONVERTED'\nr.2  = '*RCNVTCAT*  C O N V E R S I O N   R E P O R T'\nr.3  = ' '\nr.4  = 'TOTAL NUMBER OF ALIAS STMTS IN CATALOG                  '\nr.5  = 'ALIAS STMTS ASSOCIATED WITH OS CVOL CATALOGS            '\nr.6  = 'ALIAS STMTS ASSOCIATED WITH VSAM USER CATALOGS          '\nr.7  = 'ALIAS STMTS ASSOCIATED WITH NON VSAM DATA SETS          '\nr.8  = '                                                        '\nr.9  = 'NUMBER OF VSAM USER CATALOGS                            '\nr.10 = '                                                        '\nr.11 = 'TOTAL NUMBER OF NON VSAM DATA SETS  IN CATALOG          '\nr.12 = 'VOLUMES ASSOCIATED WITH NON VSAM DATA SETS. SEE NOTE 1  '\nr.13 = 'OS CVOL CATALOGS WITH THE FOLLOWING NAMES:              '\nr.14 = 'SYSCTLG.VXXXXXX  -  XXXXXX = VOLUME                     '\nr.15 = 'OS CVOL CATALOG NAMES CONVERTED TO                      '\nr.16 = 'SYSCTLG.VXXXXXX . SEE NOTE 2 AND SYSPRINT OUTPUT LISTING'\nr.17 = 'NON VSAM DATA SETS STARTING WITH SYS1.---               '\nr.18 = 'ALL OTHER NON VSAM DATA SETS                            '\nr.19 = '                                                        '\nr.20 = 'NUMBER OF GENERATION DATA GROUP STMTS                   '\nr.21 = '                                                        '\nr.22 = 'NUMBER OF STATEMENTS WHICH COULD  N O T  BE PROCESSED   '\nr.23 = '                                                        '\nr.24 = 'NUMBER OF STATEMENTS WHICH CONTAIN AN INVALID           '\nr.25 = 'DEVICE TYPE. SEE NOTE 3                                 '\nr.26 = 'TOTAL NUMBER OF STATEMENTS WHICH WERE PROCESSED         '\nr.27 = 'SUM OF STATEMENTS WHICH WERE PROCESSED FOR              '\nr.28 = 'ALIAS/IMPORT/NONVSAM/GDG AND MISC. SEE NOTE 4           '\ntot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot\nsta_tot = tot_tot + ali_tot\nr.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '||r.4\nr.5  = ' ALIAS  SYSCTLG ........... 'Right(asy_tot,8)'      '||r.5\nr.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '||r.6\nr.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '||r.7\nr.8  = '                                          '||r.8\nr.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '||r.9\nr.10 = '                                          '||r.10\nr.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '||r.11\nr.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '||r.12\nr.13 = ' OS CVOL SYSCTLG ....(M)... 'Right(syc_tot,8)'      '||r.13\nr.14 = '                                          '||r.14\nr.15 = ' SYSCTLG CONVERTED ........        0      '||r.15\nr.16 = '                                          '||r.16\nr.17 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '||r.17\nr.18 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '||r.18\nr.19 = '                                          '||r.19\nr.20 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '||r.20\nr.21 = '                                          '||r.21\nr.22 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '||r.22\nr.23 = '------------------------------------      '||r.23\nr.24 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '||r.24\nr.25 = '                                          '||r.25\nr.26 = 'NO. OF STMTS PROC ......... 'Right(sta_tot,8)'      '||r.26\nr.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '||r.27\nr.28 = '                                          '||r.28\nr.29 = '(M)    : A MEMBER WAS CREATED IN DATA SET  CONVERT.ENTRIES'\nr.30 = 'NOTE 1 : SOME DATA SETS NEED OF MORE THAN ONE VOLUME '\nr.31 = 'NOTE 2 : DATA SETS WHICH START WITH SYSCTLG WILL BE CONVER'\nr.32 = 'NOTE 3 : DEVICE TYPE IS NOT RECOGNISED BY RCNVTCAT !!'\nr.33 = 'NOTE 4 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL. T'\nr.31 = r.31||'TED TO SYSCTLG.VXXXXXX, XXXXXX = VOLUME'\nr.32 = r.32||'. BETTER CHECK THE CODE !?!'\nr.33 = r.33||'HEY ARE PROCESSED TWICE'\nl_cnt = 33\nDo loop = 1 to 33\n l.loop = r.loop\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* COMP_REPORT - Produce the Catalog comparison report                */\n/**********************************************************************/\nCOMP_REPORT:                         /* Produce the catalog compare ##*/\nl_cnt = 0\nDo loop = 1 to count.OLD\n entname = entname.OLD.loop\n entype  = entype.OLD.loop\n name    = name.OLD.loop\n volsers = volsers.OLD.loop\n flag.entname = 'Y'\n If (member = 'COMPFULL') Then\n  Do\n   disp_ent = entname\n   disp_entype = Left(entype,8)\n  End\n Else\n  Do\n   disp_ent = Left(entname,36)\n   disp_entype = Left(substr(entype,1,3),4)\n  End\n disp_vol = Strip(volsers,B)\n If (Symbol('val.NEW.entname') = 'LIT') Then\n  Do\n   l_cnt = l_cnt + 1\n   Select\n    When (entype = 'ALIAS  '  ) Then\n     detail = Strip(name.OLD.loop,B)\n    When (entype = 'DATA'     ) |,\n         (entype = 'INDEX'    ) Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)||' ',\n              Strip(vsam_type.OLD.loop,B)||' ',\n              Strip(vsam_attr.OLD.loop,B)\n    When (entype = 'NONVSAM'  ) |,\n         (entype = 'GDG'      ) |,\n         (entype = 'UCAT'     ) |,\n         (entype = 'PAGESPACE') Then\n     detail = Strip(volsers.old.loop,B)||' ',\n              Strip(devices.old.loop,B)\n    Otherwise NOP\n   End\n   l.l_cnt = disp_entype||disp_ent' --missing - 'detail\n   status.OLD.loop = 'MISSING'\n  End\n Else\n  Do\n   namenew = name.NEW.entname\n   volsnew = volsers.NEW.entname\n   Select\n    When (namenew <> name) Then\n     Do\n      If (entype = 'ALIAS') Then\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##catalog was 'Strip(name,B)' is 'Strip(namenew,B)\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADCAT'\n       End\n      Else\n       Do\n        l_cnt = l_cnt + 1\n        err_text = ' ##related entries do not match.'\n        l.l_cnt = disp_entype||disp_ent||err_text\n        status.OLD.loop = 'BADENT'\n       End\n     End\n    When (volsnew <> volsers) Then\n     Do\n      l_cnt = l_cnt + 1\n      err_text = ' ##volser was 'disp_vol' is 'Strip(volsnew,B)\n      l.l_cnt = disp_entype||disp_ent||err_text\n      status.OLD.loop = 'BADVOL'\n     End\n    Otherwise\n     l_cnt = l_cnt + 1\n     l.l_cnt = disp_entype||disp_ent' **entry matches.'\n     status.OLD.loop = 'OK'\n   End\n  End\nEnd\nDo loop = 1 to count.NEW\n entname = entname.NEW.loop\n entype  = entype.NEW.loop\n volsers = volsers.NEW.loop\n If (flag.entname <> 'Y') Then\n  Do\n   If (member = 'COMPFULL') Then\n    Do\n     disp_ent = entname\n     disp_entype = Left(entype,8)\n    End\n   Else\n    Do\n     disp_ent = Left(entname,36)\n     disp_entype = Left(substr(entype,1,3),4)\n    End\n   disp_vol = Strip(volsers,B)\n   l_cnt = l_cnt + 1\n   l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol\n   status.NEW.loop = 'NEW'\n  End\nEnd\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* NEW_EXT - Process for new entries                                  */\n/**********************************************************************/\nNEW_EXT:                             /* Process new entries         ##*/\nDo loop = 1 to count.NEW             /*                               */\n If (status.NEW.loop = 'NEW') Then   /*                               */\n  Do                                 /*                               */\n   entname = entname.NEW.loop        /*                               */\n   entype  = entype.NEW.loop         /*                               */\n   If (entype = 'DATA') |,           /*                               */\n      (entype = 'INDEX') Then        /*                               */\n    Iterate                          /*                               */\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry not present in catalog \"cat.old\". */\"\n   l_cnt = l_cnt + 1                 /*                               */\n   l.l_cnt = \"      /* Entry present in catalog     \"cat.new\". */\"\n   Call ENTRY_DEL                    /* process an entry delete       */\n  End                                /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* OLD_BAD - Process for old entries                                  */\n/**********************************************************************/\nOLD_BAD:                             /* Process old entries         ##*/\nDo loop = 1 to count.OLD             /*                               */\n entname   = entname.OLD.loop        /*                               */\n entype    = entype.OLD.loop         /*                               */\n volsers   = volsers.OLD.loop        /*                               */\n volser    = Strip(volsers,B)        /*                               */\n name      = name.OLD.loop           /*                               */\n type      = type.OLD.loop           /*                               */\n pageswap  = pageswap.OLD.loop       /*                               */\n devices   = devices.OLD.loop        /*                               */\n fils      = fils.OLD.loop           /*                               */\n gdg_emp   = gdg_emp.OLD.loop        /*                               */\n gdg_scr   = gdg_scr.OLD.loop        /*                               */\n gdglimit  = gdglimit.OLD.loop       /*                               */\n vsam_attr = vsam_attr.OLD.loop      /*                               */\n vsam_type = vsam_type.OLD.loop      /*                               */\n vsam_vvds = vsam_vvds.OLD.loop      /*                               */\n namenew   = name.NEW.entname        /*                               */\n volsnew   = volsers.NEW.entname     /*                               */\n If (entype = 'DATA') |,             /*                               */\n    (entype = 'INDEX') Then          /*                               */\n  Iterate                            /*                               */\n Select                              /*                               */\n  When (status.OLD.loop = 'MISSING') Then /*                          */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Entry missing in catalog \"cat\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADCAT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Alias incorrectly pointing to \"namenew\". */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADENT') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Related entries do not match */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* entry \"Strip(entname,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* old \"Strip(name,T)\" */\"\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* new \"Strip(namenew,T)\" */\"\n   End                               /*                               */\n  When (status.OLD.loop = 'BADVOL') Then /*                           */\n   Do                                /*                               */\n    l_cnt = l_cnt + 1                /*                               */\n    l.l_cnt = \"      /* Volume incorrect - was \"volsnew\". */\"\n   End                               /*                               */\n  Otherwise Iterate                  /*                               */\n End                                 /*                               */\n Call ENTRY_DEL                      /* process an entry delete       */\n Call ENTRY_CHG                      /* process an entry change       */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_DEL - Create a DELETE statement                              */\n/**********************************************************************/\nENTRY_DEL:                           /* Create an entry DELETE      ##*/\nIf (entype = 'NONVSAM') Then         /*                               */\n tparm = ''                          /*                               */\nElse                                 /*                               */\n tparm = entype                      /*                               */\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      DELETE \"Strip(entname,T)\" \"tparm\" NOSCRATCH -\"\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"             CAT(\"Left(cat,44)\"         )\"\nIf targ_cat='' Then\n l.l_cnt = '          CAT('Left(cat,44)'        )'\nElse\n l.l_cnt = '          CAT('Left(targ_cat,44)'        )'\nl_cnt = l_cnt + 1                    /*                               */\nl.l_cnt = \"      SET MAXCC=0\"\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* ENTRY_CHG - Create a changed entry statement                       */\n/**********************************************************************/\nENTRY_CHG:                           /* Create a changed entry      ##*/\nSelect                               /*                               */\n When (entype = 'NONVSAM') Then      /*                               */\n  Call MEM_NONVSAM                   /*                               */\n When (entype = 'ALIAS') Then        /*                               */\n  Call MEM_ALIAS                     /*                               */\n When (entype = 'GDG') Then          /*                               */\n  Call MEM_GDG                       /*                               */\n Otherwise NOP                       /*                               */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* CheckOption - Check that a given option is used at most once.      */\n/**********************************************************************/\nCheckOption: Procedure EXPOSE unix_HOME sysuid badRC ,\n             (syscall_constants)\n Parse arg optionName .\n option_used.optionName = 1\n Return\n\n/**********************************************************************/\n/* FindUNIXhome                                                       */\n/**********************************************************************/\nFindUNIXhome: /* Procedure  expose unix_HOME sysuid badRC\n                 (syscall_constants) */\n arg tuser2\n If tuser2 = sysuid &,\n    '/' = left(unix_HOME,1) Then\n  return unix_HOME\n  If flag_syscall <> 1 Then\n   If SYSCALLS('ON') > 3 Then\n    Do\n     Say \"Unable to establish a UNIX environment. Aborting\"\n     exit(8)\n    End\n  flag_syscall = 1\n  Address SYSCALL \"setpwent\"\n  Do FOREVER\n   Address SYSCALL \"getpwent passwd.\"\n   If retval = 0 | retval = -1 Then\n    Do\n     exitRC = badRC\n     say \"**(Error-1)* Cannot find user:\"tuser2\n     signal FINISH\n    End\n   If strip(passwd.PW_NAME,\"T\",\" \") = tuser2 Then LEAVE\n  End\n  return passwd.PW_DIR /* Get the home directory from RACF */\n\nresolveLocation:\n parse arg tempLocation rest\n If rest <> '' Then\n  Do\n   Say '**(Error-1)* Invalid call to resolveLocation,'\n   Say '**(Error-2)* extraneous parameter(s):'rest\n  End\n Select\n  When '//' = left(tempLocation,2) &,\n     Length(tempLocation) <> 2 Then\n   Do\n    upper tempLocation\n    If \"'\" <> substr(tempLocation,3,1) Then\n     tempLocation = \"//\"||sysuid||\".\"||substr(tempLocation,3)\n    Else\n     If \"'\" <> right(tempLocation,1) Then\n      Do\n       Say \"Invalid DSN specification, no ending quote:\"||,\n           tempLocation\n       exitRC = badRC\n       signal FINISH\n      End\n     Else\n      tempLocation=\"//\"||,\n       substr(tempLocation,4,Length(tempLocation)-4)\n   End\n /* Resolve UNIX home - just in case */\n  When '~' = left(tempLocation,1) Then\n   Do\n    parse var tempLocation '~' tuser '/' Directory\n    If tuser='' Then\n     tuser=sysuid\n    unix_HOME = FindUNIXhome(tuser)\n    If Directory = '' Then\n     tempLocation=unix_Home\n    Else\n     tempLocation=unix_Home||\"/\"||Directory\n   End\n  Otherwise\n   Do\n    Say \"resolveLocation:\"tempLocation\n   End\n  End\n return tempLocation\n/* End of UNIX home resolution */\n\n/**********************************************************************/\n/* USAGE     - Print appropriate USAGE information                    */\n/**********************************************************************/\nUSAGE: Procedure\n Call USAGE_TSO /* just use one help for now */\n exit(0)\n RunningState=Address()\n Select\n  When RunningState = 'SH' Then\n   Call USAGE_UNIX\n  When RunningState = 'TSO' Then\n   Call USAGE_TSO\n  Otherwise\n   Say \"Unsupported environment:\"RunningState\n exit(0)\n/**********************************************************************/\n\n/**********************************************************************/\n/* USAGE_TSO - Print TSO Usage information                            */\n/**********************************************************************/\nUSAGE_TSO: Procedure\n Say \"RCNVTCAT requires either one or two parameters and can accept\"\n Say \" three other optional arguments.\"\n Say \" - RCNVTCAT catname       : produces MCNVTCAT type output\"\n Say \" - RCNVTCAT oldcat newcat : produces catalog comparison output\"\n Say ' '\n Say '==Debug Option:'\n Say ' Enabled with the debug argument. This argument has three forms:'\n Say 'DEBUG(n)'\n Say '--debug n'\n Say '--debug=n'\n Say 'This sets the debug value to \"n\". The only valid value at this'\n Say \"time is 2. It just put out some diagnostics which I don't\"\n Say 'know the utility of.'\n Say ' '\n Say '==Output Option:'\n Say ' Enabled with the output argument. This argument has 6 variants,'\n Say ' but they all do the same thing. They say where to place the'\n Say ' output. They are all equivalent. The reason for so many variants'\n Say ' is to hopefully seem \"intuitive\" to a wide spectrum of users.'\n Say ' '\n Say ' If an output option is not used, then the default output'\n Say ' location is to the data set allocated to the DD REPORT. If'\n Say ' this DD is not allocated, then the location used depends on'\n Say ' the execution environment.'\n Say ' Note that the specification of one of the output location'\n Say ' options will override the use of the DD REPORT even if it'\n Say ' is allocated.'\n Say ' '\n Say ' When run as a UNIX shell program, the default output location'\n Say ' is the current working directory. Otherwise, the location is'\n Say ' a PDS with a generated name.'\n Say ' The output location is displayed to the user.'\n Say 'OUTPUT(location)'\n Say 'OUTPUT=location'\n Say '-O location'\n Say '-Olocation'\n Say '-o location'\n Say '-olocation'\n Say ' In the above \"location\" is where to put the output. It may be'\n Say ' either a z/OS data set name or a z/OS UNIX directory name.'\n Say ' The DSN need not exist. A PDS with the given name will be'\n Say ' created if necessary.'\n Say ' A UNIX directory must exist if it is specified.'\n Say ' '\n Say ' When the location appears to be a data set name, as opposed to'\n Say \" a UNIX path, the name is prefixed by the user's TSO prefix as\"\n Say ' is done in most TSO command processors, unless it is enclosed'\n Say \" within ' symbols.\"\n Say ' The location is assumed to be a DSN unless it begins with a'\n Say ' / (slash), . (period), or ~ (tilde); in which case it is'\n Say ' assumed to be a UNIX directory name. As with most UNIX'\n Say ' commands, a file name which begins with a / is an absolute'\n Say ' path to the directory, a period indicates a path relative to'\n Say ' the current directory, and a ~ (tilde) indicates a path'\n Say ' relative to the UNIX HOME directory of the current user (if'\n Say ' immediately followed by a / (slash) ) or a given user (the'\n Say ' value after the tilde but before the first / (slash) ). In'\n Say ' either case, the user must have the appropriate authority to'\n Say ' the directory or DSN.'\n Say ' '\n exit(0)\n\n/**********************************************************************/\n/* USAGE_UNIX- Print UNIX Usage information                           */\n/**********************************************************************/\nUSAGE_UNIX: Procedure\n exit(0)\n/**********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPACE": {"ttr": 7432, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x12\\x01\\x02\\x19\\x8f\\x01\\x04\\x01O\\x11%\\x05\\xe0\\x05\\x96\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "2002-07-17T00:00:00", "modifydate": "2004-01-14T11:25:12", "lines": 1504, "newlines": 1430, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - SPACE : DASD pool utilisation                               */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 13/05/2002 - Alastair Gray - Original version            */\n/* 1.0.1   - 15/05/2002 - Alastair Gray - Added CSICODE cat check     */\n/* 1.0.2   - 17/05/2002 - Alastair Gray - Added Unit into display     */\n/* 1.0.3   - 23/05/2002 - Alastair Gray - Added SORT option           */\n/* 1.0.4   - 24/05/2002 - Alastair Gray - Handles symbolic cataloging */\n/* 1.0.5   - 24/05/2002 - Alastair Gray - Added 'max' to scroll       */\n/* 1.0.6   - 27/05/2002 - Alastair Gray - Added ave % to pool display */\n/* 1.0.7   - 29/05/2002 - Alastair Gray - Updated help panels         */\n/* 1.0.8   - 31/05/2002 - Alastair Gray - Added 'End of List'         */\n/* 1.0.9   - 03/06/2002 - Alastair Gray - added dslist for group/vol  */\n/* 1.0.10  - 03/06/2002 - Alastair Gray - added row count             */\n/* 1.1.0   - 03/06/2002 - Alastair Gray - added 'warning' panel       */\n/* 1.1.1   - 13/06/2002 - Alastair Gray - added IDCAMS auth check     */\n/* 1.1.2   - 08/07/2002 - Alastair Gray - added FULLC/D/V options     */\n/* 1.1.3   - 17/07/2002 - Alastair Gray - corrected volume problem    */\n/* 1.1.4   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.1.5   - 13/08/2002 - Alastair Gray - changed idcams call         */\n/* 1.1.6   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.1.7   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.1.8   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/**********************************************************************/\n/* Description :                                                      */\n/* Uses DCOLLECT to obtain storage group details and allow review of  */\n/* volume/space usage.                                                */\n/* Also allows catalog validation using CSI for details.              */\n/**********************************************************************/\n/* Note: ISPF Table processing not used as I wanted to have individual*/\n/* highlighting and this approach seemed better (at the time).        */\n/**********************************************************************/\nTrace O                                     /*                        */\nNumeric Digits 20                           /*                        */\n/**********************************************************************/\nAddress ISPEXEC \"Control Errors Return\"     /* handle errors          */\n/**********************************************************************/\nArg vals                                    /*                        */\n/**********************************************************************/\nCall DEFINE_HEX                             /* define hex values      */\n/**********************************************************************/\nvals = Translate(vals,'  ','()')            /*                        */\nIf (Pos(vals,\"DEBUG(1)\") > 0) Then          /* debug option           */\n Do                                         /*                        */\n  debug = 1                                 /*                        */\n  Say '**(Debug)*** Debug level 1 enabled'  /*                        */\n End                                        /*                        */\nSelect                                      /*                        */\n When (Word(vals,1) = 'V') |,               /* volume option          */\n      (Word(vals,1) = 'VOL') |,             /*                        */\n      (Word(vals,1) = 'VOLUME') Then        /*                        */\n  Do                                        /*                        */\n   Call BASE_DATA                           /* get main data          */\n   sel_flag = 'VOLUME'                      /* set flag for volume    */\n   sel_group = Word(vals,2)                 /* set pattern from arg   */\n   Call PROCESS_GROUP                       /* process for group      */\n  End                                       /*                        */\n When (Word(vals,1) = 'P') |,               /* pool option            */\n      (Word(vals,1) = 'POOL') Then          /*                        */\n  Do                                        /*                        */\n   Call BASE_DATA                           /* get main data          */\n   sel_flag = 'POOL'                        /* set flag for pool      */\n   sel_group = Word(vals,2)                 /* set pattern from arg   */\n   Call PROCESS_GROUP                       /* process for group      */\n  End                                       /*                        */\n When (Word(vals,1) = '?') Then             /* help option            */\n  Do                                        /*                        */\n   Call CREATE_PDS                          /* build panel library    */\n   Call DEFINE_TUTOR0                       /* define tutorial        */\n   Call CREATE_MEMBER                       /* build panel            */\n   Address ISPEXEC \"LibDef ISPPLIB Library Id(\"fil\") Stack\"\n   Do While rc < 8                          /*                        */\n    Address ISPEXEC \"Display Panel(TSPACE00)\"/* display help screen   */\n   End                                      /*                        */\n   Address ISPEXEC \"LibDef ISPPLIB\"         /* clear the temp alloc   */\n  End                                       /*                        */\n When (Words(vals) = 0) Then                /* default option         */\n  Do                                        /*                        */\n   Call BASE_DATA                           /* get main data          */\n   Call PROCESS_GROUPS                      /* process groups         */\n  End                                       /*                        */\n Otherwise NOP                              /*                        */\nEnd                                         /*                        */\n                                            /*                        */\n/**********************************************************************/\n/**********************************************************************/\nFINISH:                                     /* exit the exec        ##*/\nExit 0                                      /*                        */\n/**********************************************************************/\nPROCESS_GROUPS:                             /* process groups       ##*/\nsort_parm1 = ''                             /*                        */\nCall DISP_GROUPS                            /* display group setup    */\nCall CREATE_PDS                             /* build panel library    */\nCall DEFINE_PANEL0                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_PANEL1                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR0                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR1                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nfil_pan1 = fil                              /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB Library Id(\"fil_pan1\") Stack\"\np1rc = 0                                    /*                        */\nstart1 = 1                                  /*                        */\ndata1 = Substr(save_data1,start1,4000)      /* max 50 lines ...       */\nDo While (p1rc < 8)                         /*                        */\n rown = (start1+79)/80                      /* row number             */\n rowm = (Length(save_data1)-240)/80         /* max rows               */\n rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */\n rowt = Right(rowt,79)                      /* row text               */\n Address ISPEXEC \"Display Panel(PSPACE01)\"  /* display the panel      */\n p1rc = rc                                  /*                        */\n If (rc > 8) Then                           /*                        */\n  Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"   /*                        */\n Address ISPEXEC \"PQuery Panel(PSPACE01) Areaname(DATA1) \",\n                        \"Width(d1wid) Depth(d1dep)\"\n If (zcmd = 'REFRESH') Then                 /*                        */\n  Do                                        /*                        */\n   Call BASE_DATA                           /* get main data          */\n   Call DISP_GROUPS                         /*                        */\n  End                                       /*                        */\n If (Word(zcmd,1) = 'SORT') Then            /*                        */\n  Do                                        /*                        */\n   Call SORT_DECODE                         /* translate SORT parms   */\n   sort_parm1 = sort_parm                   /*                        */\n   Call DISP_GROUPS                         /*                        */\n  End                                       /*                        */\n Address ISPEXEC \"VGet (zverb zscrolln zscrolla) Asis\"\n Do loop = 1 to Length(data1)-79 By 80      /*                        */\n  test = Substr(data1,loop,80)              /*                        */\n  If (strip(test,B) = '') Then Iterate      /*                        */\n  Upper test                                /*                        */\n  sel_g_char = Substr(test,2,1)             /*                        */\n  If (sel_g_char = 'S') Then                /*                        */\n   Do                                       /*                        */\n    data1 = Overlay(' ',data1,loop+1)       /*                        */\n    sel_group = Strip(Substr(test,4,8))     /*                        */\n    Call PROCESS_GROUP                      /*                        */\n   End                                      /*                        */\n  If (sel_g_char = 'C') |,                  /*                        */\n     (sel_g_char = 'D') |,                  /*                        */\n     (sel_g_char = 'V') Then                /*                        */\n   Do                                       /*                        */\n    chk = 'NO'                              /*                        */\n    Address ISPEXEC \"Display Panel(PSPACE00)\"/* display the panel     */\n    p0rc = rc                               /*                        */\n    If (rc > 8) Then                        /*                        */\n     Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"/*                        */\n    Upper chk                               /*                        */\n    If (chk = 'YES') Then                   /*                        */\n     Do                                     /*                        */\n      data1 = Overlay(' ',data1,loop+1)     /*                        */\n      sel_v_char = sel_g_char               /*                        */\n      sel_group = Strip(Substr(test,4,8))   /*                        */\n      If (Strip(sel_group) = '') Then       /*                        */\n       dco_parm  = 'VOL('null_vols')'       /*                        */\n      Else                                  /*                        */\n       dco_parm  = 'STOG('sel_group')'      /*                        */\n      sel_volume = Substr(test,4,6)         /*                        */\n      Call PROCESS_VOLUME                   /*                        */\n     End                                    /*                        */\n   End                                      /*                        */\n End                                        /*                        */\n If (zverb = 'DOWN') Then                   /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start1 = (Length(save_data1)-79)-((d1dep-1)*80) /*                 */\n  Else                                      /*                        */\n   start1 = start1 + (zscrolln*80)          /*                        */\n If (zverb = 'UP') Then                     /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start1 = 1                               /*                        */\n  Else                                      /*                        */\n   start1 = start1 - (zscrolln*80)          /*                        */\n If (start1 < 1) Then start1 = 1            /*                        */\n If (start1 > (Length(save_data1)-319)) Then/*                        */\n  start1 = Length(save_data1) - 319         /*                        */\n data1 = Substr(save_data1,start1,4000)     /* max 50 lines ...       */\nEnd                                         /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB\"            /* clear the temp alloc   */\nAddress TSO     \"Free Fi(\"fil_pan1\")\"       /* free the temp dsn      */\nReturn 0                                    /*                        */\n/**********************************************************************/\nPROCESS_GROUP:                              /* process single group ##*/\nsort_parm2 = ''                             /*                        */\nCall DISP_GROUP                             /* display vol setup      */\nCall CREATE_PDS                             /* build panel library    */\nCall DEFINE_PANEL0                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_PANEL2                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR0                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR2                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nfil_pan2 = fil                              /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB Library Id(\"fil_pan2\") Stack\"\np2rc = 0                                    /*                        */\nstart2 = 1                                  /*                        */\ndata2 = Substr(save_data2,start2,4000)      /* max 50 lines ...       */\nDo while p2rc < 8                           /*                        */\n rown = (start2+79)/80                      /* row number             */\n rowm = (Length(save_data2)-240)/80         /* max rows               */\n rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */\n rowt = Right(rowt,79)                      /* row text               */\n Address ISPEXEC \"Display Panel(PSPACE02)\"  /* display the panel      */\n p2rc = rc                                  /*                        */\n If (rc > 8) Then                           /*                        */\n  Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"   /*                        */\n Address ISPEXEC \"PQuery Panel(PSPACE02) Areaname(DATA2) \",\n                        \"Width(d2wid) Depth(d2dep)\"\n If (zcmd = 'REFRESH') Then                 /*                        */\n  Do                                        /*                        */\n   Call BASE_DATA                           /* get main data          */\n   Call DISP_GROUP                          /*                        */\n  End                                       /*                        */\n If (Word(zcmd,1) = 'SORT') Then            /*                        */\n  Do                                        /*                        */\n   Call SORT_DECODE                         /* translate SORT parms   */\n   sort_parm2 = sort_parm                   /*                        */\n   Call DISP_GROUP                          /*                        */\n  End                                       /*                        */\n If (zcmd = 'FULLC') |,                     /*                        */\n    (zcmd = 'FULLD') |,                     /*                        */\n    (zcmd = 'FULLV') Then                   /*                        */\n  Do                                        /*                        */\n   sel_v_char = Substr(zcmd,5,1)            /*                        */\n   chk = 'NO'                               /*                        */\n   Address ISPEXEC \"Display Panel(PSPACE00)\"/* display the panel      */\n   p0rc = rc                                /*                        */\n   If (rc > 8) Then                         /*                        */\n    Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\" /*                        */\n   Upper chk                                /*                        */\n   sel_volume = sel_group                   /*                        */\n   If (chk = 'YES') Then                    /*                        */\n    Do                                      /*                        */\n     If (Strip(sel_group) = '') Then        /*                        */\n      dco_parm  = 'VOL('null_vols')'        /*                        */\n     Else                                   /*                        */\n      dco_parm  = 'STOG('sel_group')'       /*                        */\n     Call PROCESS_VOLUME                    /*                        */\n    End                                     /*                        */\n  End                                       /*                        */\n Address ISPEXEC \"VGet (zverb zscrolln zscrolla) Asis\"\n Do loop = 1 to Length(data2)-79 By 80      /*                        */\n  test = Substr(data2,loop,80)              /*                        */\n  If (strip(test,B) = '') Then Iterate      /*                        */\n  Upper test                                /*                        */\n  sel_v_char = Substr(test,2,1)             /*                        */\n  If (sel_v_char = 'C')  |,                 /*                        */\n     (sel_v_char = 'D')  |,                 /*                        */\n     (sel_v_char = 'S')  |,                 /*                        */\n     (sel_v_char = 'V')  Then               /*                        */\n   Do                                       /*                        */\n    data2 = Overlay(' ',data2,loop+1)       /*                        */\n    sel_volume = Substr(test,4,6)           /*                        */\n    dco_parm   = 'VOL('sel_volume')'        /*                        */\n    Call PROCESS_VOLUME                     /*                        */\n   End                                      /*                        */\n End                                        /*                        */\n If (zverb = 'DOWN') Then                   /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start2 = (Length(save_data2)-79)-((d2dep-1)*80) /*                 */\n  Else                                      /*                        */\n   start2 = start2 + (zscrolln*80)          /*                        */\n If (zverb = 'UP') Then                     /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start2 = 1                               /*                        */\n  Else                                      /*                        */\n   start2 = start2 - (zscrolln*80)          /*                        */\n If (start2 < 1) Then start2 = 1            /*                        */\n If (start2 > (Length(save_data2)-319)) Then/*                        */\n  start2 = Length(save_data2) - 319         /*                        */\n data2 = Substr(save_data2,start2,4000)     /* max 50 lines ...       */\nEnd                                         /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB\"            /* clear the temp alloc   */\nAddress TSO     \"Free Fi(\"fil_pan2\")\"       /* free the temp dsn      */\nReturn 0                                    /*                        */\n/**********************************************************************/\nPROCESS_VOLUME:                             /* process single volume##*/\nsort_parm3 = ''                             /*                        */\nIf (sel_v_char = 'S') Then                  /*                        */\n Do                                         /*                        */\n  Address ISPEXEC \"LMDInit ListID(lid) Volume(\"sel_volume\")\" /*     */\n  If (rc > 0) Then                          /*                        */\n   Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"  /*                        */\n  Else                                      /*                        */\n   Address ISPEXEC \"LMDDisp ListID(\"lid\")\"  /*                        */\n  If (rc > 0) Then                          /*                        */\n   Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"  /*                        */\n  Address ISPEXEC \"LMDFree ListID(\"lid\")\"   /*                        */\n  Return 0                                  /*                        */\n End                                        /*                        */\nCall DISP_VOLUME                            /* display vol setup      */\nCall CREATE_PDS                             /* build panel library    */\nCall DEFINE_PANEL3                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR0                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR3                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nfil_pan3 = fil                              /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB Library Id(\"fil_pan3\") Stack\"\np3rc = 0                                    /*                        */\nstart3 = 1                                  /*                        */\ndata3 = Substr(save_data3,start3,4000)      /* max 50 lines ...       */\nDo while p3rc < 8                           /*                        */\n rown = (start3+79)/80                      /* row number             */\n rowm = (Length(save_data3)-80)/80          /* max rows               */\n rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */\n rowt = Right(rowt,79)                      /* row text               */\n Address ISPEXEC \"Display Panel(PSPACE03)\"  /* display the panel      */\n p3rc = rc                                  /*                        */\n If (rc > 8) Then                           /*                        */\n  Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"   /*                        */\n Address ISPEXEC \"PQuery Panel(PSPACE03) Areaname(DATA3) \",\n                        \"Width(d3wid) Depth(d3dep)\"\n If (zcmd = 'REFRESH') Then                 /*                        */\n  Call DISP_VOLUME                          /*                        */\n If (Word(zcmd,1) = 'SORT') Then            /*                        */\n  Do                                        /*                        */\n   Call SORT_DECODE                         /* translate SORT parms   */\n   sort_parm3 = sort_parm                   /*                        */\n   Call DISP_VOLUME                         /*                        */\n  End                                       /*                        */\n Address ISPEXEC \"VGet (zverb zscrolln zscrolla) Asis\"\n Do loop = 1 to Length(data3)-79 By 80      /*                        */\n  test = Substr(data3,loop,80)              /*                        */\n  If (strip(test,B) = '') Then Iterate      /*                        */\n  Upper test                                /*                        */\n  sel_d_char = Substr(test,2,1)             /*                        */\n  If (sel_d_char = 'B') |,                  /*                        */\n     (sel_d_char = 'E') |,                  /*                        */\n     (sel_d_char = 'S') |,                  /*                        */\n     (sel_d_char = 'V') Then                /*                        */\n   Do                                       /*                        */\n    rows = rown + ((loop-1)/80)             /*                        */\n    vols = Substr(datav,(rows*6)-5,6)       /*                        */\n    sel_volume  = vols                      /* get correct volume     */\n    data3 = Overlay(' ',data3,loop+1)       /*                        */\n    sel_dataset = Strip(Substr(test,4,44))  /*                        */\n    Call PROCESS_DATASET                    /*                        */\n   End                                      /*                        */\n End                                        /*                        */\n If (zverb = 'DOWN') Then                   /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start3 = (Length(save_data3)-79)-((d3dep-1)*80) /*                 */\n  Else                                      /*                        */\n   start3 = start3 + (zscrolln*80)          /*                        */\n If (zverb = 'UP') Then                     /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start3 = 1                               /*                        */\n  Else                                      /*                        */\n   start3 = start3 - (zscrolln*80)          /*                        */\n If (start3 < 1) Then start3 = 1            /*                        */\n If (start3 > Length(save_data3)) Then start3 = Length(save_data3) - 159\n data3 = Substr(save_data3,start3,4000)     /* max 50 lines ...       */\nEnd                                         /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB\"            /* clear the temp alloc   */\nAddress TSO     \"Free Fi(\"fil_pan3\")\"       /* free the temp dsn      */\nReturn 0                                    /*                        */\n/**********************************************************************/\nPROCESS_DATASET:                            /* process dataset      ##*/\nSelect                                      /*                        */\n When (sel_d_char = 'B') Then               /*                        */\n  Address ISPEXEC \"Browse Dataset('\"sel_dataset\"') Volume(\"sel_volume\")\"\n When (sel_d_char = 'E') Then               /*                        */\n  Address ISPEXEC \"Edit   Dataset('\"sel_dataset\"') Volume(\"sel_volume\")\"\n When (sel_d_char = 'S') Then               /*                        */\n  Address ISPEXEC \"Edit   Dataset('\"sel_dataset\"') Volume(\"sel_volume\")\"\n When (sel_d_char = 'V') Then               /*                        */\n  Address ISPEXEC \"View   Dataset('\"sel_dataset\"') Volume(\"sel_volume\")\"\n Otherwise NOP                              /*                        */\nEnd                                         /*                        */\nIf (rc > 0) Then                            /*                        */\n Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"    /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nBASE_DATA:                                  /* dcollect all vols    ##*/\nIf (idcams_check /= 'YES') Then             /* test IDCAMS authorised */\n Do                                         /*                        */\n  x = Outtrap('authpgm.')                   /*                        */\n  Address TSO \"PARMLIB LIST(AUTHPGM)\"       /* list authorised pgms   */\n  x = Outtrap()                             /*                        */\n  parms_loc = Strip(authpgm.3,B)            /*                        */\n  Do ids = 9 to authpgm.0                   /*                        */\n   If (Pos('IDCAMS',authpgm.ids) > 0) Then  /* check if IDCAMS present*/\n    Do                                      /*                        */\n     idcams_check = 'YES'                   /*                        */\n     Leave                                  /*                        */\n    End                                     /*                        */\n  End                                       /*                        */\n  If (idcams_check /= 'YES') Then           /*                        */\n   Do                                       /*                        */\n    zerralrm = 'YES'                        /*                        */\n    zerrsm = 'IDCAMS not authorised'        /*                        */\n    zerrlm = 'Check 'parms_loc' and add IDCAMS to AUTHPGM section.'\n    Address ISPEXEC \"Setmsg Msg(ISRZ002)\"   /* general error messageid*/\n    Signal FINISH                           /*                        */\n   End                                      /*                        */\n End                                        /*                        */\nAddress TSO                                 /*                        */\n\"NewStack\"                                  /*                        */\n\"Alloc Fi(SYSPRINT) Da('NULLFILE') Shr Reu\" /*                        */\n\"Alloc Fi(AMSDUMP) Da('NULLFILE') Shr Reu\"  /*                        */\n\"Alloc Fi(SYSIN) New Lrecl(80) Reuse\"       /*                        */\nQueue \" DCOLLECT VOL(*) OUTFILE(OUTDS) NOD\" /*                        */\nQueue \"\"                                    /*                        */\n\"ExecIO * DiskW SYSIN (Finis)\"              /*                        */\n\"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(340) Recfm(V B) Reu\"\n\"Call *(IDCAMS)\"                            /*                        */\n\"ExecIO * DiskR OUTDS (Stem l. Finis)\"      /*                        */\n\"Free Fi(OUTDS)\"                            /*                        */\ncnt_vols   = l.0                            /*                        */\ncnt_groups = 0                              /*                        */\ntot_cap    = 0                              /*                        */\ntot_alo    = 0                              /*                        */\nnull_vols  = ''                             /* init non-SMS vol list  */\nDrop cnt_group.                             /* drop for refresh       */\nDo loop = 1 To l.0                          /*                        */\n dcvvolsr.loop = Substr(l.loop,25,6)        /* volume serial number   */\n dcvperct.loop = C2d(Substr(l.loop,36,1))/* percent free space        */\n dcvfresp.loop = C2d(Substr(l.loop,37,4))/* free space     in kb      */\n dcvalloc.loop = C2d(Substr(l.loop,41,4))/* alloc space in kb         */\n dcvvlcap.loop = C2d(Substr(l.loop,45,4))/* capacity       in kb      */\n dcvfragi.loop = C2d(Substr(l.loop,49,4))/* fragmentation index       */\n dcvlgext.loop = C2d(Substr(l.loop,53,4))/* largest extent            */\n dcvdvtyp.loop = Strip(Substr(l.loop,69,8),B) /* device type          */\n If (dcvdvtyp.loop = '3390') Then size_cyl = '849960' /* cyl in bytes */\n If (dcvdvtyp.loop = '3380') Then size_cyl = '712140' /* cyl in bytes */\n If (dcvdvtyp.loop = '3390') Then size_trk = '56664'  /* trk in bytes */\n If (dcvdvtyp.loop = '3380') Then size_trk = '47476'  /* trk in bytes */\n Select                                     /* capacity    in kb      */\n  When (dcvvlcap.loop = '1846417') Then type = '3380-K' /*            */\n  When (dcvvlcap.loop = '1847666') Then type = '3390-2' /*            */\n  When (dcvvlcap.loop = '2771500') Then type = '3390-3' /*            */\n  Otherwise type = dcvdvtyp.loop            /*                        */\n End                                        /*                        */\n dcvvolsr      = dcvvolsr.loop              /* get volser             */\n type.dcvvolsr = type                       /* save type              */\n size_cyl.dcvvolsr = size_cyl               /* save cylinder size     */\n size_trk.dcvvolsr = size_trk               /* save track size        */\n dcvlgext.loop = (dcvlgext.loop*1024)/size_cyl /* convert to cyls     */\n dcvdvnum.loop = Right(D2x(C2d(Substr(l.loop,77,2))),4,'0')/*         */\n dcvsglng      = C2d(Substr(l.loop,81,2))/* storage group name leng*/\n If (dcvsglng = 0) Then                     /*                        */\n  null_vols = null_vols||dcvvolsr||' '      /* build non-sms vol list */\n dcvsgtcl.loop = Substr(l.loop,83,dcvsglng)/* storage group name      */\n dcvdptyp.loop = Substr(l.loop,113,8)       /* physical device type   */\n tot_cap       = tot_cap + dcvvlcap.loop    /* accumulate capacity    */\n tot_alo       = tot_alo + dcvalloc.loop    /* accumulate allocated   */\n dcvsgtcl      = dcvsgtcl.loop              /*                        */\n If (cnt_group.dcvsgtcl > 0) Then           /* test if group known    */\n  Do                                        /*                        */\n   cnt_group.dcvsgtcl = cnt_group.dcvsgtcl + 1 /*                     */\n   alo_group.dcvsgtcl = alo_group.dcvsgtcl + dcvalloc.loop /*         */\n   cap_group.dcvsgtcl = cap_group.dcvsgtcl + dcvvlcap.loop /*         */\n  End                                       /*                        */\n Else                                       /*                        */\n  Do                                        /* storage group unknown  */\n   cnt_groups = cnt_groups + 1              /*                        */\n   cnt_group.dcvsgtcl = 1                   /*                        */\n   alo_group.dcvsgtcl = dcvalloc.loop       /*                        */\n   cap_group.dcvsgtcl = dcvvlcap.loop       /*                        */\n   nam_group.cnt_groups = dcvsgtcl          /*                        */\n  End                                       /*                        */\nEnd                                         /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDISP_GROUPS:                                /*                      ##*/\ndata1 = ''                                  /*                        */\nDo loop = 1 to cnt_groups                   /*                        */\n nam_group = nam_group.loop                 /*                        */\n cnt_group = cnt_group.nam_group            /* get the group count    */\n alo_group = alo_group.nam_group            /* get total allocated    */\n cap_group = cap_group.nam_group            /* get total capacity     */\n fre_group = cap_group - alo_group          /* get total free         */\n per_group = (alo_group / cap_group) * 100  /* calculate percentage   */\n per_disp  = Left('',Trunc((per_group*31)/100,0),'*')\n alo_group = Trunc((alo_group*1024)/10**9,2)/* change to GB           */\n cap_group = Trunc((cap_group*1024)/10**9,2)/* change to GB           */\n fre_group = Trunc((fre_group*1024)/10**9,2)/* change to GB           */\n Select                                     /*                        */\n  When (per_group >= 85) Then high = X0F    /*                        */\n  When (per_group >= 75) Then high = X0E    /*                        */\n  Otherwise high = X0D                      /*                        */\n End                                        /*                        */\n display = X20\" \"X0C||Left(nam_group,19)\n display = display||Right(cnt_group,4)\n display = display||Right(cap_group,8)\n display = display||Right(fre_group,8)\n display = display||high||Right(Trunc(per_group,0),3)||\"% \"\n display = display||per_disp\n data1 = data1||Left(display,80)            /*                        */\nEnd                                         /*                        */\ndisp_pat = '   STOGROUP            VOL TOTAL   FREE    PCT  XXX'\ndata    = data1                             /*                        */\nsort_parm = sort_parm1                      /*                        */\nsort_leng = 80                              /* set sort length        */\nCall DATA_SORT                              /*                        */\ndata1   = data                              /*                        */\ndisplay = X0B||\"----------------------------------------------\"\ndata1   = data1||Left(display,80)           /*                        */\ntot_fre = tot_cap - tot_alo                 /* calculate total free   */\ntot@fre = Format((tot_fre*1024)/10**9,6,0)  /* change to GB           */\ntot@cap = Format((tot_cap*1024)/10**9,6,0)  /* change to GB           */\ndisplay = X0C\" \"X0B||Left('Total',19)||Right(cnt_vols,4)\ndisplay = display||Right(tot@cap,8)||Right(tot@fre,8)\ndata1   = data1||Left(display,80)           /*                        */\ndata1   = data1||X0C||Centre(' End of List ',79,'*')\nsave_data1 = data1                          /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDISP_GROUP:                                 /*                      ##*/\ndata2 = ''                                  /*                        */\ncnt_group = 0                               /*                        */\nalo_group = 0                               /*                        */\ncap_group = 0                               /*                        */\nDo loop = 1 to cnt_vols                     /*                        */\n dcvsgtcl  = dcvsgtcl.loop                  /*                        */\n dcvvolsr  = dcvvolsr.loop                  /* volume serial          */\n Select                                     /*                        */\n  When (sel_flag = 'POOL') Then             /* 'POOL' selection       */\n   Do                                       /*                        */\n    If (sel_group /= '') &,                 /* no value set           */\n       (sel_group /= '*') Then              /* wildcard for everything*/\n     Do                                     /*                        */\n      sel_mask = Strip(Translate(sel_group,' ','*'),B) /* remove wild */\n      len_mask = Length(sel_mask)           /* length of mask         */\n      len_sgrp = Length(dcvsgtcl)           /* length of stor group   */\n      test_pos = (len_sgrp-len_mask) + 1\n      If (Substr(sel_group,1,1) /= '*') Then  /*                      */\n       If (Pos(sel_mask,Strip(dcvsgtcl)) <> 1) Then Iterate\n      If (Substr(sel_group,Length(sel_group),1) /= '*') Then /*       */\n       If (Pos(sel_mask,Strip(dcvsgtcl)) <> test_pos) Then Iterate\n      If (Pos(sel_mask,Strip(dcvsgtcl)) = 0) Then Iterate\n     End                                    /*                        */\n   End                                      /*                        */\n  When (sel_flag = 'VOLUME') Then           /* 'POOL' selection       */\n   Do                                       /*                        */\n    If (sel_group /= '') &,                 /* no value set           */\n       (sel_group /= '*') Then              /* wildcard for everything*/\n     Do                                     /*                        */\n      sel_mask = Strip(Translate(sel_group,' ','*'),B) /* remove wild */\n      len_mask = Length(sel_mask)           /* length of mask         */\n      len_sgrp = Length(dcvvolsr)           /* length of volser       */\n      test_pos = (len_sgrp-len_mask) + 1\n      If (Substr(sel_group,1,1) /= '*') Then  /*                      */\n       If (Pos(sel_mask,Strip(dcvvolsr)) <> 1) Then Iterate\n      If (Substr(sel_group,Length(sel_group),1) /= '*') Then /*       */\n       If (Pos(sel_mask,Strip(dcvvolsr)) <> test_pos) Then Iterate\n      If (Pos(sel_mask,Strip(dcvvolsr)) = 0) Then Iterate\n     End                                    /*                        */\n   End                                      /*                        */\n  Otherwise                                 /* normal option          */\n   If (Strip(dcvsgtcl) /= sel_group) Then Iterate\n End                                        /*                        */\n cnt_group = cnt_group + 1                  /* members in group       */\n dcvperct  = dcvperct.loop                  /* percent free space     */\n dcvfresp  = Trunc((dcvfresp.loop*1024)/10**9,2) /* free space        */\n dcvalloc  = Trunc((dcvalloc.loop*1024)/10**9,2) /* allocated space   */\n dcvvlcap  = Trunc((dcvvlcap.loop*1024)/10**9,2) /* total capacity    */\n alo_group = alo_group + dcvalloc.loop\n cap_group = cap_group + dcvvlcap.loop\n dcvfragi  = dcvfragi.loop                  /* fragmentation index    */\n dcvlgext  = dcvlgext.loop                  /* largest extent         */\n dcvdvtyp  = dcvdvtyp.loop                  /* device type            */\n dcvdptyp  = dcvdptyp.loop                  /* physical device type   */\n dcvdvnum  = dcvdvnum.loop                  /* device number          */\n If (dcvvlcap > 0) Then                     /* check for zero capacity*/\n  per_vol   = (dcvalloc/dcvvlcap) * 100     /* calculate percentage   */\n Else                                       /*                        */\n  per_vol   = 0                             /* set percentage         */\n Select                                     /*                        */\n  When (per_vol >= 85) Then high = X0F      /*                        */\n  When (per_vol >= 75) Then high = X0E      /*                        */\n  Otherwise high = X0D                      /*                        */\n End                                        /*                        */\n per_disp  = Left('',Trunc((per_vol*31)/100,0),'*')\n display = X20\" \"X0C||Left(dcvvolsr,7)||Left(dcvdvnum,5)\n display = display||Left(dcvdvtyp,5)||Right(dcvvlcap,5)\" \"\n display = display||Right(dcvfresp,5)||Right(Trunc(dcvlgext,0),6)\n display = display||Right(Trunc(dcvfragi,0),5)\n display = display||high||Right(Trunc(per_vol,0),3)||\"% \"||per_disp\n data2 = data2||Left(display,80)            /*                        */\nEnd                                         /*                        */\nIf (cnt_group = 0) Then                     /*                        */\n Do                                         /*                        */\n  zerralrm = 'YES'                          /*                        */\n  zerrhm = 'TSPACE02'                       /*                        */\n  zerrsm = 'No volumes found'               /*                        */\n  zerrlm = 'No volumes matching 'sel_group' where found.' /*          */\n  Address ISPEXEC \"Setmsg Msg(ISRZ002)\"     /* general error messageid*/\n  save_data2 = Left('',4000)                /*                        */\n  Return                                    /*                        */\n End                                        /*                        */\ndisp_pat = '   VOLSER ADDR TYPE CAPA  FREE  CNTG  FRAG PCT  XXX'\ndata    = data2                             /*                        */\nsort_parm = sort_parm2                      /*                        */\nsort_leng = 80                              /* set sort length        */\nCall DATA_SORT                              /*                        */\ndata2   = data                              /*                        */\ndisplay = X0B||\"----------------------------------------------\"\ndata2   = data2||Left(display,80)           /*                        */\nfre_group = cap_group - alo_group           /* calculate total free   */\nper_group = ((alo_group/cap_group)*100)     /* get average percentage */\nfre_group = Format((fre_group*1024)/10**9,6,0) /* change to GB        */\ncap_group = Format((cap_group*1024)/10**9,6,0) /* change to GB        */\ndisplay = X0C\" \"X0B||Left('Total',16)       /*                        */\ndisplay = display||Right(cap_group,6)||Right(fre_group,6)\ndisplay = display||Right(Trunc(per_group,0),15)||'%'\ndata2   = data2||Left(display,80)           /*                        */\ndata2   = data2||X0C||Centre(' End of List ',79,'*')\nsave_data2 = data2                          /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDISP_VOLUME:                                /*                      ##*/\ndata3 = ''                                  /*                        */\nAddress TSO                                 /*                        */\n\"NewStack\"                                  /*                        */\n\"Alloc Fi(SYSPRINT) Da('NULLFILE') Shr Reu\" /*                        */\n\"Alloc Fi(AMSDUMP) Da('NULLFILE') Shr Reu\"  /*                        */\n\"Alloc Fi(SYSIN) New Lrecl(80) Reuse\"       /*                        */\nQueue \" DCOLLECT -\"                         /* dcollect               */\nDo parms = 1 to Words(dco_parm)             /*                        */\nQueue \"  \"Word(dco_parm,parms)\" -\"          /* dcollect selection     */\nEnd                                         /*                        */\nQueue \"  OUTFILE(OUTDS)\"                    /* dcollect output        */\nQueue \"\"                                    /*                        */\n\"ExecIO * DiskW SYSIN (Finis)\"              /*                        */\n\"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(340) Recfm(V B) Reu\"\n\"Call *(IDCAMS)\"                            /*                        */\n\"ExecIO * DiskR OUTDS (Stem l. Finis)\"      /*                        */\n\"Free Fi(OUTDS)\"                            /*                        */\nDo loop = 1 to l.0                          /*                        */\n dcurctyp.loop = Substr(l.loop,5,1)         /* record type            */\n If (dcurctyp.loop = 'V') Then              /* if 'V' type record     */\n  dcvvolsr = Substr(l.loop,25,6)            /* volume serial number   */\n If (dcurctyp.loop /= 'D') Then Iterate     /* none dataset record    */\n dcddsnam.loop = Substr(l.loop,25,44)       /* dataset name           */\n dcdflags.loop = Substr(l.loop,69,4)        /* information flags      */\n dcderror.loop = Substr(l.loop,69,1)        /* error information flag */\n dcdflag1.loop = Substr(l.loop,70,1)        /* information flag #1    */\n dcdflag1      = X2b(C2x(dcdflag1.loop))    /* flag #1 as bits        */\n dcdflag2.loop = Substr(l.loop,71,1)        /* information flag #2    */\n dcdflag3.loop = Substr(l.loop,72,1)        /* information flag #3    */\n dcdnovvr.loop = Substr(X2b(C2x(dcdflag2.loop)),1,1) /* no VVR flag   */\n dcddsorg.loop = Substr(l.loop,75,2)        /* dsorg                  */\n dcddsorg      = X2b(C2x(dcddsorg.loop))    /* dsorg as bits          */\n Select                                     /* decode dsorg           */\n  When (Substr(dcddsorg,1,1) = '1') Then dsorg = 'IS'\n  When (Substr(dcddsorg,2,1) = '1') Then dsorg = 'PS'\n  When (Substr(dcddsorg,3,1) = '1') Then dsorg = 'DA'\n  When (Substr(dcddsorg,7,1) = '1') Then dsorg = 'PO'\n  When (Substr(dcddsorg,8,1) = '1') Then dsorg = 'U '\n  When (Substr(dcddsorg,9,1) = '1') Then dsorg = 'GS'\n  When (Substr(dcddsorg,13,1) = '1') Then dsorg = 'VS'\n  Otherwise dsorg = '??'                    /*                        */\n End                                        /*                        */\n If (Substr(dcdflag1,4,1) = '1') Then dsorg = dsorg||'-E'\n dcdrecrd.loop = Substr(l.loop,77,1)        /* recfm                  */\n dcdrecrd      = X2b(C2x(dcdrecrd.loop))    /* recfm as bits          */\n Select                                     /* decode dsorg           */\n  When (Substr(dcdrecrd,1,2) = '10') Then recfm = 'F'\n  When (Substr(dcdrecrd,1,2) = '01') Then recfm = 'V'\n  When (Substr(dcdrecrd,1,2) = '11') Then recfm = 'U'\n  Otherwise recfm = '?'                     /*                        */\n End                                        /*                        */\n If (Substr(dcdrecrd,4,1) = '1') Then recfm = recfm||'B'\n If (Substr(dcdrecrd,3,1) = '1') Then recfm = recfm||'T'\n If (Substr(dcdrecrd,5,1) = '1') Then recfm = recfm||'S'\n If (Substr(dcdrecrd,6,1) = '1') Then recfm = recfm||'A'\n If (Substr(dcdrecrd,7,1) = '1') Then recfm = recfm||'M'\n dcdnmext.loop = Substr(l.loop,78,1)        /* number of extents      */\n dcdvolsr.loop = Substr(l.loop,79,6)        /* volume serial number   */\n dcdvolsr = dcdvolsr.loop                   /*                        */\n dcdnmext = C2d(dcdnmext.loop)              /*                        */\n dcdbklng.loop = Substr(l.loop,85,2)        /* block length           */\n dcdbklng = C2d(dcdbklng.loop)              /*                        */\n dcdlrecl.loop = Substr(l.loop,87,2)        /* lrecl                  */\n dcdlrecl = C2d(dcdlrecl.loop)              /*                        */\n dcdvolsq.loop = Substr(l.loop,123,2)       /* volume sequence number */\n dcdvolsq = C2d(dcdvolsq.loop)              /*                        */\n size_trk = size_trk.dcvvolsr               /* get track size         */\n cat_volume = dcvvolsr                      /* get catalog check vol  */\n dcdallsp.loop = C2d(Substr(l.loop,89,4))/* allocated space           */\n dcdusesp.loop = C2d(Substr(l.loop,93,4))/* used         space        */\n dcdscall.loop = C2d(Substr(l.loop,97,4))/* secondary space alloc     */\n dcdallsp = Format((dcdallsp.loop*1024)/size_trk,6,0) /* conv to trks */\n dcdusesp = Format((dcdusesp.loop*1024)/size_trk,6,0) /* conv to trks */\n dcdscall = Format((dcdscall.loop*1024)/size_trk,6,0) /* conv to trks */\n display = X20\" \"X0C||Left(dcddsnam.loop,44)/*                        */\n Select                                     /* normal selection       */\n  When (sel_v_char = 'C') Then              /* catalog selection      */\n   Do                                       /*                        */\n    display = display||Right(dcdvolsr,7)    /* add volser             */\n    dcddsnam      = dcddsnam.loop           /*                        */\n    dsn_cat.dcddsnam = '*Not Cataloged'     /* set cat flag to no     */\n    filter        = dcddsnam                /*                        */\n    Call CSICODE                            /*                        */\n     If (Substr(dsn_cat.dcddsnam,1,1) = '*') Then /*                  */\n      high = X0F                            /* highlight red          */\n     Else                                   /*                        */\n      high = X0D                            /* highlight green        */\n     display = display||high||dsn_cat.dcddsnam /* add catalog name    */\n   End                                      /*                        */\n  When (sel_v_char = 'D') Then              /* normal selection       */\n   Do                                       /*                        */\n    display = display||Left(\" \"dsorg,5)     /* add catalog name       */\n    display = display||Left(\" \"recfm,5)     /* add recfm              */\n    display = display||Right(dcdallsp,7)    /* add allocated space    */\n    display = display||Right(dcdnmext,4)    /* add extents            */\n    display = display||Right(dcdbklng,6)    /* add blksize            */\n    display = display||Right(dcdlrecl,6)    /* add lrecl              */\n   End                                      /*                        */\n  When (sel_v_char = 'V') Then              /* normal selection       */\n   Do                                       /*                        */\n    display = display||Right(dcdallsp,7)    /* add allocated space    */\n    display = display||Right(dcdnmext,4)    /* add extents            */\n    display = display||Right(dcdvolsq,3)    /* add volseq             */\n    display = display||Right(dcdvolsr,7)    /* add volser             */\n   End                                      /*                        */\n  Otherwise NOP                             /*                        */\n End\n data3 = data3||Left(display,80)||Left(dcdvolsr.loop,6) /*            */\nEnd                                         /*                        */\nSelect                                      /*                        */\n When (sel_v_char = 'C') Then              /* catalog selection      */\n  Do\n   disp_pat = '   DATASET                                      '\n   disp_pat = disp_pat||'VOLSER CATALOG                   XXX'\n  End\n When (sel_v_char = 'D') Then              /* normal selection       */\n  Do\n   disp_pat = '   DATASET                                      '\n   disp_pat = disp_pat||'DSRG RECF SPACE  XT  BLKSZ LRECL XXX'\n  End\n When (sel_v_char = 'V') Then              /* normal selection       */\n  Do\n   disp_pat = '   DATASET                                      '\n   disp_pat = disp_pat||'SPACE  XT  V# VOLSER XXX'\n  End\n Otherwise NOP\nEnd                                         /*                        */\ndata    = data3                             /*                        */\nsort_parm = sort_parm3                      /*                        */\nsort_leng = 86                              /* set sort length        */\nCall DATA_SORT                              /*                        */\ndatav   = over                              /* save volume list       */\ndata3   = data                              /*                        */\ndata3   = data3||X0C||Centre(' End of List ',79,'*')\nsave_data3 = data3                          /*                        */\nReturn 0                                    /*                        */\n\n/**********************************************************************/\nDEFINE_HEX:                                 /* define panel hex     ##*/\nX01 = '01'X                                 /* set hex '01' variable  */\nX02 = '02'X                                 /* set hex '02' variable  */\nX03 = '03'X                                 /* set hex '03' variable  */\nX04 = '04'X                                 /* set hex '04' variable  */\nX05 = '05'X                                 /* set hex '05' variable  */\nX06 = '06'X                                 /* set hex '06' variable  */\nX07 = '07'X                                 /* set hex '07' variable  */\nX08 = '08'X                                 /* set hex '08' variable  */\nX09 = '09'X                                 /* set hex '09' variable  */\nX0A = '0A'X                                 /* set hex '0A' variable  */\nX0B = '0B'X                                 /* set hex '0B' variable  */\nX0C = '0C'X                                 /* set hex '0C' variable  */\nX0D = '0D'X                                 /* set hex '0D' variable  */\nX0E = '0E'X                                 /* set hex '0E' variable  */\nX0F = '0F'X                                 /* set hex '0F' variable  */\nX16 = '16'X                                 /* set hex '16' variable  */\nX19 = '19'X                                 /* set hex '19' variable  */\nX20 = '20'X                                 /* set hex '20' variable  */\nX22 = '22'X                                 /* set hex '22' variable  */\nX25 = '25'X                                 /* set hex '25' variable  */\nX26 = '26'X                                 /* set hex '26' variable  */\nX27 = '27'X                                 /* set hex '27' variable  */\nX28 = '28'X                                 /* set hex '28' variable  */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_P_ATTR:                              /* Create attributes    ##*/\nQueue \")PANEL KEYLIST(ISRSNAB,ISR)\"\nQueue \")ATTR DEFAULT(\"X01||X02||X03\") FORMAT(MIX)\"\nQueue \" 04 AREA(DYNAMIC) SCROLL(ON)    EXTEND(ON)\"\nQueue \" 05 TYPE(TEXT)    COLOR(BLUE)\"\nQueue \" 06 TYPE(DATAOUT) COLOR(BLUE)   INTENS(LOW)\"\nQueue \" 07 TYPE(DATAOUT) COLOR(GREEN)  INTENS(HIGH)\"\nQueue \" 08 TYPE(TEXT)    COLOR(WHITE)\"\nQueue \" 09 TYPE(TEXT)    COLOR(RED)\"\nQueue \" 0A TYPE(TEXT)    COLOR(GREEN)\"\nQueue \" 0B TYPE(DATAOUT) COLOR(WHITE)  INTENS(HIGH)\"\nQueue \" 0C TYPE(DATAOUT) COLOR(BLUE)   INTENS(HIGH)\"\nQueue \" 0D TYPE(DATAOUT) COLOR(GREEN)  INTENS(HIGH)\"\nQueue \" 0E TYPE(DATAOUT) COLOR(YELLOW) INTENS(HIGH)\"\nQueue \" 0F TYPE(DATAOUT) COLOR(RED)    INTENS(HIGH)\"\nQueue \" 20 TYPE(DATAIN)  COLOR(TURQ)   HILITE(USCORE)\"\nQueue \" 22 TYPE(TEXT)    COLOR(WHITE)  HILITE(REVERSE)\"\nQueue \" 25 TYPE(OUTPUT)  COLOR(TURQ)   JUST(RIGHT) CAPS(OFF)\"\nQueue \" 26 TYPE(INPUT)   COLOR(TURQ)   HILITE(USCORE)\"\nQueue \" 27 AREA(SCRL)    EXTEND(ON)\"\nQueue \" 28 TYPE(INPUT)   COLOR(RED)\"\nQueue \" 16 TYPE(VOI)     PADC(USER)\"      /* variable output info  TL */\nQueue \" 19 TYPE(DT)\"                      /* descriptive text      GL */\nQueue \")BODY  CMD(ZCMD)\"\nReturn 0\n/**********************************************************************/\nDEFINE_P_PROC:                              /* Create processing    ##*/\nQueue \")INIT\"                               /*                        */\nQueue \"&ZCMD = ' '\"                         /*                        */\nQueue \".CURSOR = 'ZCMD'\"                    /*                        */\nQueue \".HELP = \"help                        /*                        */\nQueue \"VGET (SSCL) ASIS\"                    /*                        */\nQueue \"IF (&SSCL = '')\"                     /*                        */\nQueue \" &SSCL = 'CSR'\"                      /*                        */\nQueue \")PROC\"                               /*                        */\nQueue \"VPUT (SSCL) PROFILE\"                 /*                        */\nQueue \")END\"                                /*                        */\nReturn 0\n/**********************************************************************/\nDEFINE_PANEL0:                              /* Create display 0     ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'PSPACE00'                         /* set panel name         */\nhelp   = 'TSPACE00'                         /* set help panel name    */\nCall DEFINE_P_ATTR\nQueue X0A||Centre(X05||\"Storage Information\"||X0A,78)||X0A\nQueue X0A||\"Command ===>\"||X26||Left(\"ZCMD\",71)||X0A\nQueue X0A||\" \"\nQueue X0A||\" \"\nQueue X0A||\"  The option you have selected will almost certainly take :\"\nQueue X0A||\" \"\nQueue X0A||\"  a) Quite a long time.\"\nQueue X0A||\"  b) Quite a lot of CPU.\"\nQueue X0A||\" \"\nQueue X0A||\"  You have been warned ...\"\nQueue X0A||\" \"\nQueue X0A||\"  Are you absolutely certain that you want to do it ?\"\nQueue X0A||\" \"\nQueue X0A||Centre(\"        Type\"X09\"YES\"X0A\"to continue. \",78)\nQueue X0A||\" \"\nQueue X0A||Centre(X08||\">>>>\"||X28||\"CHK\"||X08||\"<<<<\"||X0A,78)\nQueue X0A||\" \"\nQueue \")INIT\"                               /*                        */\nQueue \"&ZCMD = ' '\"                         /*                        */\nQueue \".CURSOR = 'CHK'\"                     /*                        */\nQueue \".HELP = \"help                        /*                        */\nQueue \")PROC\"                               /*                        */\nQueue \")END\"                                /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_PANEL1:                              /* Create display 1     ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'PSPACE01'                         /* set panel name         */\nhelp   = 'TSPACE01'                         /* set help panel name    */\nCall DEFINE_P_ATTR\nQueue X0A||Centre(X05||\"Storage Information\"||X0A,78)||X0A\ntext = X0A||\"Command ===>\"||X26||Left(\"ZCMD\",49)||X0A||\"Scroll ===>\"\nQueue text||X26||Left(\"SSCL\",4)||X0A\nQueue X25||\"ROWT\"\ntext = X08||\"                      Vol   Total    Free  Pct\"\nQueue text||X22||\"0  1  2  3  4  5  6  7  8  9  1\"X08\ntext = X08||\"S StoGroup              #    (Gb)    (Gb)  Usd\"\nQueue text||X22||\"0  0  0  0  0  0  0  0  0  0  0\"X08\ntext = X08||\"_ ___________________ ___ _______ _______ ____\"\nQueue text||X22||\"+..+..+..+..+..+..+..+..+..+..0\"X08\nQueue X04||\"DATA1\"Left(\"\",73)||X04\nCall DEFINE_P_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_PANEL2:                              /* Create display 2     ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'PSPACE02'                         /* set panel name         */\nhelp   = 'TSPACE02'                         /* set help panel name    */\nCall DEFINE_P_ATTR\nQueue X0A||Centre(X05||\"Storage Information - \"sel_group||X0A,78)||X0A\ntext = X0A||\"Command ===>\"||X26||Left(\"ZCMD\",49)||X0A||\"Scroll ===>\"\nQueue text||X26||Left(\"SSCL\",4)||X0A\nQueue X25||\"ROWT\"\ntext = X08||\"         Dev  Dev   Capa  Free  Cntg Frag  Pct\"\nQueue text||X22||\"0  1  2  3  4  5  6  7  8  9  1\"X08\ntext = X08||\"S Volser Addr Type  (Gb)  (Gb)   Cyl Indx  Usd\"\nQueue text||X22||\"0  0  0  0  0  0  0  0  0  0  0\"X08\ntext = X08||\"_ ______ ____ ____ _____ _____ _____ ____ ____\"\nQueue text||X22||\"+..+..+..+..+..+..+..+..+..+..0\"X08\nQueue X04||\"DATA2\"Left(\"\",73)||X04\nCall DEFINE_P_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_PANEL3:                              /* Create display 3     ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'PSPACE03'                         /* set panel name         */\nhelp   = 'TSPACE03'                         /* set help panel name    */\nCall DEFINE_P_ATTR\nQueue X0A||Centre(X05||\"Storage Information - \"sel_volume||X0A,78)||X0A\ntext = X0A||\"Command ===>\"||X26||Left(\"ZCMD\",49)||X0A||\"Scroll ===>\"\nQueue text||X26||Left(\"SSCL\",4)||X0A\nQueue X25||\"ROWT\"\nSelect\n When (sel_v_char = 'C') Then\n  Do\n   text = X08||\"S Dataset Name                                 Volser\"\n   Queue text||\" Catalog\"X08\n   text = X08||\"_ ____________________________________________ ______\"\n   Queue text||\" ____________________________\"X08\n  End\n When (sel_v_char = 'D') Then\n  Do\n   text = X08||\"                                              \"\n   Queue text||\"           Space                 \"\n   text = X08||\"S Dataset Name                                \"\n   Queue text||\" DSrg RecF (trks) Xt  Blksz Lrecl\"\n   text = X08||\"_ ____________________________________________\"\n   Queue text||\" ____ ____ ______ ___ _____ _____\"X08\n  End\n When (sel_v_char = 'V') Then\n  Do\n   text = X08||\"                                              \"\n   Queue text||\" Space               \"\n   text = X08||\"S Dataset Name                                \"\n   Queue text||\" (trks) Xt  V# Volser\"\n   text = X08||\"_ ____________________________________________\"\n   Queue text||\" ______ ___ __ ______\"X08\n  End\n Otherwise NOP\nEnd\nQueue X04||\"DATA3\"Left(\"\",73)||X04\nCall DEFINE_P_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_T_ATTR:                              /* Create attributes    ##*/\nQueue \")PANEL KEYLIST (ISRHELP ISR)\"\nQueue \")ATTR\"\nQueue \"   % TYPE(ET)\"\nQueue \"   _ TYPE(NEF) PAD(USER) CAPS(ON)\"\nQueue \"   + TYPE(NT)\"\nQueue \"   # TYPE(SAC)\"\nQueue \"   $ TYPE(OUTPUT) JUST(RIGHT) INTENS(HIGH)\"\nQueue \")BODY CMD(ZCMD)\"\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_T_PROC:                              /* Create processing    ##*/\nQueue \")INIT\"\nQueue \"&ZCMD = ' '\"\nQueue \")PROC\"\nQueue \"&ZUP = TSPACE00\"\nQueue \")END\"\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_TUTOR0:                              /* Create tutorial 1    ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'TSPACE00'                         /* set panel name         */\nCall DEFINE_T_ATTR\nQueue \"%Tutorial \"||Centre(\"Storage Information\",62)||\"Tutorial%\"\nQueue \"%\"||Left(\"Option  ===>_ZCMD\",78)||\"+\"\nQueue \"% \"\nQueue \"%       This utility displays SMS storage groups and/or volume\"\nQueue \"%       detail for the system it is executed on.\"\nQueue \"% \"\nQueue \"%       It may be invoked using#SPACE%which will display all SMS\"\nQueue \"%       storage groups on the system. Together with the group of\"\nQueue \"%       non-SMS volumes on the system.\"\nQueue \"% \"\nQueue \"%       For a subset of volumes, invoke as#SPACE VOLUME(volser)%\"\nQueue \"%                                         #SPACE VOL(volser)%\"\nQueue \"%                                         #SPACE V(volser)%\"\nQueue \"% \"\nQueue \"%                                       or#SPACE POOL(sgname)%\"\nQueue \"%                                         #SPACE P(sgname)%\"\nQueue \"% \"\nQueue \"%       Wildcarding can be used e.g. *vol *vol* vol*\"\nQueue \"% \"\nQueue \"%       Type#REFRESH%to refresh the display\"\nCall DEFINE_T_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_TUTOR1:                              /* Create tutorial 1    ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'TSPACE01'                         /* set panel name         */\nCall DEFINE_T_ATTR\nQueue \"%Tutorial \"||Centre(\"Storage Information\",62)||\"Tutorial%\"\nQueue \"%\"||Left(\"Option  ===>_ZCMD\",78)||\"+\"\nQueue \"% \"\nQueue \"%       This panel displays all of the SMS Storage Groups available\"\nQueue \"%       on the system together with their volume count and usage.\"\nQueue \"% \"\nQueue \"%       Options available are :\"\nQueue \"% \"\nQueue \"%      #C%Catalog status\"\nQueue \"%      #D%Dataset Allocation Details\"\nQueue \"%      #S%Volume details (includes capacity/usage details)\"\nQueue \"%      #V%Dataset Space/Xt/Volume/Volseq details\"\nQueue \"% \"\nQueue \"%       The display can be sorted using#SORT field A/D%.\"\nQueue \"% \"\nQueue \"%       Valid fields are :\"\nQueue \"% \"\nQueue \"%      #STOGROUP VOL TOTAL FREE PCT%\"\nQueue \"% \"\nQueue \"%       Type#REFRESH%to refresh the display\"\nCall DEFINE_T_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_TUTOR2:                              /* Create tutorial 2    ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'TSPACE02'                         /* set panel name         */\nCall DEFINE_T_ATTR\nQueue \"%Tutorial \"||Centre(\"Storage Information\",62)||\"Tutorial%\"\nQueue \"%\"||Left(\"Option  ===>_ZCMD\",78)||\"+\"\nQueue \"% \"\nQueue \"%       Displays all of the volumes defined in a selected SMS Storage\"\nQueue \"%       Group together with their capacity and usage details.\"\nQueue \"% \"\nQueue \"%       Options available are :\"\nQueue \"% \"\nQueue \"%      #C%Catalog status\"\nQueue \"%      #D%Dataset Allocation Details\"\nQueue \"%      #S%Normal '3.4' display\"\nQueue \"%      #V%Dataset Space/Xt/Volume/Volseq details\"\nQueue \"% \"\nQueue \"%       The display can be sorted using#SORT field A/D%.\"\nQueue \"% \"\nQueue \"%       Valid fields are :\"\nQueue \"% \"\nQueue \"%      #VOLSER ADDR TYPE CAPA FREE CNTG FRAG PCT\"\nQueue \"% \"\nQueue \"%       Type#REFRESH  %to refresh the display\"\nQueue \"%       Type#FULLC/D/V%to list ALL datasets in the pool\"\nCall DEFINE_T_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_TUTOR3:                              /* Create tutorial 3    ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'TSPACE03'                         /* set panel name         */\nCall DEFINE_T_ATTR\nQueue \"%Tutorial \"||Centre(\"Storage Information\",62)||\"Tutorial%\"\nQueue \"%\"||Left(\"Option  ===>_ZCMD\",78)||\"+\"\nQueue \"% \"\nQueue \"%       Displays all of the datasets on selected volume/s.\"\nQueue \"% \"\nQueue \"%       Together with either their allocation details, their \"\nQueue \"%       space utilisation or their catalog status.\"\nQueue \"% \"\nQueue \"%       For all, the options available are :\"\nQueue \"% \"\nQueue \"%      #B%Browse\"\nQueue \"%      #E%Edit\"\nQueue \"%      #S%Edit\"\nQueue \"%      #V%View\"\nQueue \"% \"\nQueue \"%       The display can be sorted using#SORT field A/D%.\"\nQueue \"% \"\nQueue \"%       Valid fields are :\"\nQueue \"% \"\nQueue \"%      #DATASET VOLSER CATALOG DSRG RECF SPACE XT BLKSZ LRECL\"\nCall DEFINE_T_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nCREATE_PDS:                                 /* Create Member in PDS   */\nDo loop = 1 To 50                           /* loop thru up to 50     */\n fil = 'DYNAM'||loop                        /*  build filename        */\n x = Listdsi(fil FILE)                      /*  test filename         */\n If (sysreason > 0) Then                    /*  if not present        */\n  Leave                                     /*   use it !             */\nEnd                                         /* end loop               */\nAddress TSO                                 /* set address            */\n\"Alloc Fi(\"fil\") \",                         /* Allocate dyamic        */\n      \"Lrecl(80) Blksize(0) RecFm(F B) \",   /*  dataset to selected   */\n      \"Cylinders Space(1,1) \",              /*   filename             */\n      \"Unit(SYSDA) Dir(20) New Reu\"         /*                        */\nX = Listdsi(fil FILE)                       /* get the file details   */\nReturn 0                                    /*                        */\n/**********************************************************************/\nCREATE_MEMBER:                              /* Create Member in PDS   */\nstack = Queued()                            /*   get stack size       */\nIf (stack > 0) Then                         /*   if data on stack     */\n Do                                         /*                        */\n  \"Alloc Fi(MEMOUT) Shr Reu \",              /*    create member       */\n        \"Da('\"sysdsname\"(\"member\")')\"       /*                        */\n  \"ExecIO \"stack\" DiskW MEMOUT (Finis)\"     /*    write stack > member*/\n  \"Free Fi(MEMOUT)\"                         /*    free member         */\n End                                        /*                        */\n/* Debug code\nAddress ISPEXEC \"Edit Dataset('\"sysdsname\"') Volume(\"sysvolume\")\"\n*/\n\"DelStack\"                                  /* Clear stack            */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDATA_SORT:                                  /*                      ##*/\nscnt = 0                                    /*                        */\nlast_rec = (Length(data)-sort_leng)+1       /* calculate last record  */\nDo pass = 1 To last_rec By sort_leng        /*                        */\n scnt = scnt + 1                            /*                        */\n sort.scnt = Substr(data,pass,sort_leng)    /*                        */\nEnd                                         /*                        */\nAddress TSO                                 /*                        */\nIf (sort_parm = '') Then                    /*                        */\n sysin.1 = '  SORT FIELDS=(1,20,CH,A)'      /*                        */\nElse                                        /*                        */\n sysin.1 = '  SORT FIELDS=('sort_parm')'    /*                        */\n\"Alloc Fi(SYSIN)   Space(1 1) Cylinders Unit(3390) \",\n                             \"Lrecl(80) Blksize(0) New Reu\"\n\"ExecIO 1 DiskW SYSIN (Finis Stem sysin.)\"\n\"Alloc Fi(SORTIN)  Space(1 1) Cylinders Unit(3390) \",\n                             \"Lrecl(\"sort_leng\") Blksize(0) New Reu\"\n\"ExecIO \"scnt\" DiskW SORTIN (Finis Stem sort.)\"\n/* Debug code\nX = Listdsi(SORTIN FILE)                    /* get the file details   */\nAddress ISPEXEC \"Edit Dataset('\"sysdsname\"') Volume(\"sysvolume\")\"\n*/\n\"Alloc Fi(SORTOUT) Space(1 1) Cylinders Unit(3390) \",\n                             \"Lrecl(\"sort_leng\") Blksize(0) New Reu\"\n\"Alloc Fi(SYSOUT)  Space(1 1) Cylinders Unit(3390) \",\n                             \"Lrecl(80) Blksize(0) New Reu\"\nAddress ATTCHMVS \"SORT\"                     /*                        */\n\"ExecIO * DiskR SORTOUT (Finis Stem sort.)\" /*                        */\n\"Free Fi(SORTIN SORTOUT SYSIN SYSOUT)\"      /*                        */\ndata = ''                                   /*                        */\nover = ''                                   /* 'overspill' variable   */\nIf (sort_leng = 80) Then                    /*                        */\n Do pass = 1 To scnt                        /*                        */\n  data = data||sort.pass                    /*                        */\n End                                        /*                        */\nElse                                        /*                        */\n Do pass = 1 to scnt                        /*                        */\n  data = data||Substr(sort.pass,1,80)       /*                        */\n  over = over||Substr(sort.pass,81)         /* capture 'overspill'    */\n End                                        /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nSORT_DECODE:                                /* decode sort parms    ##*/\nfld = Word(zcmd,2)                          /*                        */\nord = Word(zcmd,3)                          /*                        */\nplc = WordPos(fld,disp_pat)                 /*                        */\nIf (plc = 0) Then                           /*                        */\n Do                                         /*                        */\n  If (fld /= '') Then                       /*                        */\n   Do                                       /*                        */\n    zerralrm = 'YES'                        /*                        */\n    zerrhm = 'TSPACE00'                     /*                        */\n    zerrsm = 'Not a valid name'             /*                        */\n    zerrlm = field' no a valid name, reselect and try again.' /*      */\n    Address ISPEXEC \"Setmsg Msg(ISRZ002)\"   /* general error messageid*/\n   End                                      /*                        */\n  Else                                      /*                        */\n   sort_parm = ''                           /*                        */\n End                                        /*                        */\nElse                                        /*                        */\n Do                                         /*                        */\n  col = Wordindex(disp_pat,plc)             /*                        */\n  nex = Wordindex(disp_pat,plc+1)-1         /*                        */\n  len = nex-col                             /*                        */\n  If (ord /= 'D') &,                        /*                        */\n     (ord /= 'A') Then                      /*                        */\n   ord = 'A'                                /*                        */\n  sort_parm = col','len',CH,'ord            /*                        */\n End                                        /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\n/**********************************************************************/\n/* CSICODE : Uses Catalog Search Interface (CSI)                      */\n/**********************************************************************/\nCSICODE:                             /* CSI processing              ##*/\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt   = filter                       /* Set the filter                */\ntyp   = ' '                          /* Set entry types required      */\nct1   = ' '                          /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nx = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */\n/**********************************************************************/\nReturn 0                             /* Return                        */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '0006'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld06 = Left('FILESEQ ',8)        /* File Sequence number          */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    If (csioptns = 'F') Then         /* check if fullword requested   */\n     csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length    */\n    Else                             /* otherwise (default halfword)  */\n     csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length    */\n    If (csienter = '1') Then         /* entry error                   */\n     Do\n      Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n      plus = 50                      /* length for error entry        */\n     End\n    Else                             /*                               */\n     Do                              /*                               */\n      Call ENTRY                     /* Execute entry processing      */\n      plus = 46 + csitotln           /* length for normal entry       */\n     End                             /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\nvolser   = Substr(dwork,o_fld.5,l_fld.5)   /* volume serial           */\nfileseq  = Substr(dwork,o_fld.6,l_fld.6)   /* file sequence           */\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  If (Pos(cat_volume,volser) > 0) Then /* If volser matches selected  */\n   Do                                /*                               */\n    dsn_cat.entname = csicname       /*  set catalog for dataset      */\n   End                               /*                               */\n  If (Pos('&',volser) > 0) Then      /* check for system symbolic     */\n   Do                                /*                               */\n    Do syms = 1 to Words(volser)     /*                               */\n     symchk = Word(volser,syms)      /*                               */\n     symres = MvsVar('SYMDEF',Strip(symchk,B,'&')) /*                 */\n     If (cat_volume = symres) Then   /*                               */\n      Do                             /*                               */\n       dsn_cat.entname = csicname    /*  set catalog for dataset      */\n       Leave                         /*                               */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPACENEW": {"ttr": 8195, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x01\\x01\\x11'\\x8f\\x01\\x11'\\x8f\\x17!\\x07{\\x07v\\x00\\x00\\xc6\\xd6\\xd9`\\xc5\\xc1\\xe5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2011-10-05T00:00:00", "modifydate": "2011-10-05T17:21:01", "lines": 1915, "newlines": 1910, "modlines": 0, "user": "FOR-EAV"}, "text": "/* REXX - SPACE : DASD pool utilisation                               */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 13/05/2002 - Alastair Gray - Original version            */\n/* 1.0.1   - 15/05/2002 - Alastair Gray - Added CSICODE cat check     */\n/* 1.0.2   - 17/05/2002 - Alastair Gray - Added Unit into display     */\n/* 1.0.3   - 23/05/2002 - Alastair Gray - Added SORT option           */\n/* 1.0.4   - 24/05/2002 - Alastair Gray - Handles symbolic cataloging */\n/* 1.0.5   - 24/05/2002 - Alastair Gray - Added 'max' to scroll       */\n/* 1.0.6   - 27/05/2002 - Alastair Gray - Added ave % to pool display */\n/* 1.0.7   - 29/05/2002 - Alastair Gray - Updated help panels         */\n/* 1.0.8   - 31/05/2002 - Alastair Gray - Added 'End of List'         */\n/* 1.0.9   - 03/06/2002 - Alastair Gray - added dslist for group/vol  */\n/* 1.0.10  - 03/06/2002 - Alastair Gray - added row count             */\n/* 1.1.0   - 03/06/2002 - Alastair Gray - added 'warning' panel       */\n/* 1.1.1   - 13/06/2002 - Alastair Gray - added IDCAMS auth check     */\n/* 1.1.2   - 08/07/2002 - Alastair Gray - added FULLC/D/V options     */\n/* 1.1.3   - 17/07/2002 - Alastair Gray - corrected volume problem    */\n/* 1.1.4   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.1.5   - 13/08/2002 - Alastair Gray - changed idcams call         */\n/* 1.1.6   - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */\n/* 1.1.7   - 05/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/\n/* 1.1.8   - 09/12/2003 - Alastair Gray - Added debug code            */\n/* 1.2.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */\n/* 1.3.0   - 22/09/2011 - A. Freybier   - EAV Support                 */\n/* Change Details:                                                    */\n/* - set limits for colouring with variables (Lim_Y / Lim_R)          */\n/*   for individual setting in DISP_GROUPS: and DISP_GROUP:           */\n/*                                                                    */\n/* - change all space values from GB base 1000**3 to GiB (1024**3)    */\n/*      to make it compatible to ISMF                                 */\n/*                                                                    */\n/* - POOL display with PROCESS_GROUPS instead PROCESS_GROUP           */\n/*                                                                    */\n/* - Subroutine BASE_DATA :                                           */\n/*     - if Vol or Pool is found -                                    */\n/*         setup DCOLLECT with valid VOL(__) and STOG(__) values      */\n/*     - on option 'POOL' with wildcards (not allowed by DCOLLECT):   */\n/*         select only volumes of masked pools                        */\n/*     - \"say\" messages showing collection progress                   */\n/*                                                                    */\n/* - Subroutine DISP_VOLUME :                                         */\n/*      set filesize of OUTDS to 410 for enlarged D-records           */\n/*                                                                    */\n/* - Panel TSPACE00 :                                                 */\n/*     - new calling options                                          */\n/*     - used in case of invalid call parms                           */\n/*                                                                    */\n/* - Panel PSPACE01 :                                                 */\n/*     - all volumes without storagegroup declared as 'non-sms' group */\n/*     - Total and Free GB columns adjusted                           */\n/*     - 'Used' changed to 'Percent Used' with 3 columns              */\n/*       TRK used percentage in Track Managed Space (EAV and non-EAV) */\n/*       CYL used percentage in Cylinder Managed Space with EAV only  */\n/*       VOL used percentage on volume                                */\n/*     - percentage visualisation width adjusted from 31 to 21 chars  */\n/*     - \"Total\" line adjusted                                        */\n/*                                                                    */\n/* - Panel TSPACE01 :                                                 */\n/*     - show new sort fields PTRK PCYL PVOL instead of PCT           */\n/*                                                                    */\n/* - Panel PSPACE02 :                                                 */\n/*     - DevType no longer displayed, 3390 is standard                */\n/*     - Capacity expanded to 6 digits                                */\n/*     - Freespace expanded to 6 digits                               */\n/*     - Contig Free : value above 100.000 displayed as nnnT          */\n/*     - 'Used' changed to 'Percent Used' with 3 columns              */\n/*       TRK used percentage in Track Managed Space (EAV and non-EAV) */\n/*       CYL used percentage in Cylinder Managed Space with EAV only  */\n/*       VOL used percentage on volume                                */\n/*     - percentage visualisation width adjusted from 31 to 21 chars  */\n/*     - \"Total\" line adjusted                                        */\n/*                                                                    */\n/* - Panel TSPACE02 :                                                 */\n/*     - show new sort fields PTRK PCYL PVOL instead of PCT           */\n/*                                                                    */\n/* x.x.x   - dd/mm/20jj - who? - what ?                               */\n/*                                                                    */\n/**********************************************************************/\n/* Description :                                                      */\n/* Uses DCOLLECT to obtain storage group details and allow review of  */\n/* volume/space usage.                                                */\n/* Also allows catalog validation using CSI for details.              */\n/**********************************************************************/\n/* Note: ISPF Table processing not used as I wanted to have individual*/\n/* highlighting and this approach seemed better (at the time).        */\n/**********************************************************************/\nTrace O                                     /*                        */\nNumeric Digits 20                           /*                        */\n/**********************************************************************/\nAddress ISPEXEC \"Control Errors Return\"     /* handle errors          */\n/**********************************************************************/\nArg vals                                    /*                        */\nPGM_name = 'SPACE'                          /* used in tutorials      */\nLim_Y    = 85                               /* % for Yellow           */\nLim_R    = 95                               /* % for RED              */\n/**********************************************************************/\nCall DEFINE_HEX                             /* define hex values      */\n/**********************************************************************/\nval2 = Translate(vals)                      /* save vals for PARSE    */\nvals = Translate(vals,'  ','()')            /* split words            */\nIf (Pos(val2,\"DEBUG(1)\") > 0) Then          /* debug option           */\n Do                                         /*                        */\n  debug = 1                                 /*                        */\n  Say '**(Debug)*** Debug level 1 enabled'  /*                        */\n End                                        /*                        */\nSelect                                      /*                        */\n When (Word(vals,1) = 'V') |,               /* volume option          */\n      (Word(vals,1) = 'VOL') |,             /*                        */\n      (Word(vals,1) = 'VOLUME') Then        /*                        */\n  Do                                        /*                        */\n   sel_flag = 'VOLUME'                      /* set flag for volume    */\n/*   sel_group = Word(vals,2)                  set pattern from arg   */\n   parse var val2 . '(' sel_group ')' .     /* set pattern from arg   */\n   sel_group = SPACE(sel_group,0)           /* remove all blanks      */\n   Call BASE_DATA                           /* get main data          */\n   Call PROCESS_GROUP                       /* process for group      */\n  End                                       /*                        */\n When (Word(vals,1) = 'P') |,               /* pool option            */\n      (Word(vals,1) = 'POOL') Then          /*                        */\n  Do                                        /*                        */\n   sel_flag = 'POOL'                        /* set flag for pool      */\n/* sel_group = Word(vals,2)                    set pattern from arg   */\n   parse var val2 . '(' sel_group ')' .     /* set pattern from arg   */\n   sel_group = SPACE(sel_group,0)           /* remove all blanks      */\n   Call BASE_DATA                           /* get main data          */\n   if pos(',',sel_group) > 0 |,\n      pos('*',sel_group) > 0 then do\n      Call PROCESS_GROUPS                   /* process multiple groups*/\n     end\n    else do\n      Call PROCESS_GROUP                    /* process one group only */\n     end\n  End                                       /*                        */\n/* When (Word(vals,1) = '?') Then              help option            */\n/*Do                                           solved by otherwise    */\n/*End                                                                 */\n When (Words(vals) = 0) Then                /* default option         */\n  Do                                        /*                        */\n   Call BASE_DATA                           /* get main data          */\n   Call PROCESS_GROUPS                      /* process groups         */\n  End                                       /*                        */\n/* Otherwise NOP                                                      */\n Otherwise do                               /*                        */\n   /* --------------------------------------------------------------- */\n   Call CREATE_PDS                          /* build panel library    */\n   Call DEFINE_TUTOR0                       /* define tutorial        */\n   Call CREATE_MEMBER                       /* build panel            */\n   Address ISPEXEC \"LibDef ISPPLIB\"         /* clear the temp alloc   */\n    zerralrm = 'YES'                        /*                        */\n    zerrhm = 'TSPACE00'                     /*                        */\n    zerrsm = 'Invalid Parameter'            /*                        */\n    zerrlm = vals' - Invalid Parameter, try again.'              /*   */\n    Address ISPEXEC \"Setmsg Msg(ISRZ002)\"   /* general error messageid*/\n   Address ISPEXEC \"LibDef ISPPLIB Library Id(\"fil\") Stack\"\n   Do While rc < 8                          /*                        */\n    Address ISPEXEC \"Display Panel(TSPACE00)\"/* display help screen   */\n   End                                      /*                        */\n  End                                       /*                        */\nEnd                                         /*                        */\n                                            /*                        */\n/**********************************************************************/\nFINISH:                                     /* exit the exec        ##*/\nExit 0                                      /*                        */\n/**********************************************************************/\nERROR:                                      /* exit the exec        ##*/\n   Call CREATE_PDS                          /* build panel library    */\n   Call DEFINE_TUTOR0                       /* define tutorial        */\n   Call CREATE_MEMBER                       /* build panel            */\n   Address ISPEXEC \"LibDef ISPPLIB\"         /* clear the temp alloc   */\n    zerralrm = 'YES'                        /*                        */\n    zerrhm = 'TSPACE00'                     /*                        */\n    zerrsm = 'Invalid Parameter'            /*                        */\n    zerrlm = val2' - No volumes found, try again.'               /*   */\n    Address ISPEXEC \"Setmsg Msg(ISRZ002)\"   /* general error messageid*/\n   Address ISPEXEC \"LibDef ISPPLIB Library Id(\"fil\") Stack\"\n   Do While rc < 8                          /*                        */\n    Address ISPEXEC \"Display Panel(TSPACE00)\"/* display help screen   */\n   End                                      /*                        */\nExit 8                                      /*                        */\n/**********************************************************************/\nPROCESS_GROUPS:                             /* process groups       ##*/\nsort_parm1 = ''                             /*                        */\nCall DISP_GROUPS                            /* display group setup    */\nCall CREATE_PDS                             /* build panel library    */\nCall DEFINE_PANEL0                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_PANEL1                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR0                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR1                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nfil_pan1 = fil                              /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB Library Id(\"fil_pan1\") Stack\"\np1rc = 0                                    /*                        */\nstart1 = 1                                  /*                        */\ndata1 = Substr(save_data1,start1,4000)      /* max 50 lines ...       */\nDo While (p1rc < 8)                         /*                        */\n rown = (start1+79)/80                      /* row number             */\n rowm = (Length(save_data1)-240)/80         /* max rows               */\n rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */\n rowt = Right(rowt,79)                      /* row text               */\n Address ISPEXEC \"Display Panel(PSPACE01)\"  /* display the panel      */\n p1rc = rc                                  /*                        */\n If (rc > 8) Then                           /*                        */\n  Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"   /*                        */\n Address ISPEXEC \"PQuery Panel(PSPACE01) Areaname(DATA1) \",\n                        \"Width(d1wid) Depth(d1dep)\"\n If (zcmd = 'REFRESH') Then                 /*                        */\n  Do                                        /*                        */\n   Call BASE_DATA                           /* get main data          */\n   Call DISP_GROUPS                         /*                        */\n  End                                       /*                        */\n If (Word(zcmd,1) = 'SORT') Then            /*                        */\n  Do                                        /*                        */\n   Call SORT_DECODE                         /* translate SORT parms   */\n   sort_parm1 = sort_parm                   /*                        */\n   Call DISP_GROUPS                         /*                        */\n  End                                       /*                        */\n Address ISPEXEC \"VGet (zverb zscrolln zscrolla) Asis\"\n Do loop = 1 to Length(data1)-79 By 80      /*                        */\n  test = Substr(data1,loop,80)              /*                        */\n  If (strip(test,B) = '') Then Iterate      /*                        */\n  Upper test                                /*                        */\n  sel_g_char = Substr(test,2,1)             /*                        */\n  If (sel_g_char = 'S') Then                /*                        */\n   Do                                       /*                        */\n    data1 = Overlay(' ',data1,loop+1)       /*                        */\n    sel_group = Strip(Substr(test,4,8))     /*                        */\n    Call PROCESS_GROUP                      /*                        */\n   End                                      /*                        */\n  If (sel_g_char = 'C') |,                  /*                        */\n     (sel_g_char = 'D') |,                  /*                        */\n     (sel_g_char = 'V') Then                /*                        */\n   Do                                       /*                        */\n    chk = 'NO'                              /*                        */\n    Address ISPEXEC \"Display Panel(PSPACE00)\"/* display the panel     */\n    p0rc = rc                               /*                        */\n    If (rc > 8) Then                        /*                        */\n     Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"/*                        */\n    Upper chk                               /*                        */\n    If (chk = 'YES') Then                   /*                        */\n     Do                                     /*                        */\n      data1 = Overlay(' ',data1,loop+1)     /*                        */\n      sel_v_char = sel_g_char               /*                        */\n      sel_group = Strip(Substr(test,4,8))   /*                        */\n      If (Strip(sel_group) = '') Then       /*                        */\n       dco_parm  = 'VOL('null_vols')'       /*                        */\n      Else                                  /*                        */\n       dco_parm  = 'STOG('sel_group')'      /*                        */\n      sel_volume = Substr(test,4,6)         /*                        */\n      Call PROCESS_VOLUME                   /*                        */\n     End                                    /*                        */\n   End                                      /*                        */\n End                                        /*                        */\n If (zverb = 'DOWN') Then                   /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start1 = (Length(save_data1)-79)-((d1dep-1)*80) /*                 */\n  Else                                      /*                        */\n   start1 = start1 + (zscrolln*80)          /*                        */\n If (zverb = 'UP') Then                     /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start1 = 1                               /*                        */\n  Else                                      /*                        */\n   start1 = start1 - (zscrolln*80)          /*                        */\n If (start1 < 1) Then start1 = 1            /*                        */\n If (start1 > (Length(save_data1)-319)) Then/*                        */\n  start1 = Length(save_data1) - 319         /*                        */\n data1 = Substr(save_data1,start1,4000)     /* max 50 lines ...       */\nEnd                                         /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB\"            /* clear the temp alloc   */\nAddress TSO     \"Free Fi(\"fil_pan1\")\"       /* free the temp dsn      */\nReturn 0                                    /*                        */\n/**********************************************************************/\nPROCESS_GROUP:                              /* process single group ##*/\nsort_parm2 = ''                             /*                        */\nCall DISP_GROUP                             /* display vol setup      */\nCall CREATE_PDS                             /* build panel library    */\nCall DEFINE_PANEL0                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_PANEL2                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR0                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR2                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nfil_pan2 = fil                              /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB Library Id(\"fil_pan2\") Stack\"\np2rc = 0                                    /*                        */\nstart2 = 1                                  /*                        */\ndata2 = Substr(save_data2,start2,4000)      /* max 50 lines ...       */\nDo while p2rc < 8                           /*                        */\n rown = (start2+79)/80                      /* row number             */\n rowm = (Length(save_data2)-240)/80         /* max rows               */\n rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */\n rowt = Right(rowt,79)                      /* row text               */\n Address ISPEXEC \"Display Panel(PSPACE02)\"  /* display the panel      */\n p2rc = rc                                  /*                        */\n If (rc > 8) Then                           /*                        */\n  Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"   /*                        */\n Address ISPEXEC \"PQuery Panel(PSPACE02) Areaname(DATA2) \",\n                        \"Width(d2wid) Depth(d2dep)\"\n If (zcmd = 'REFRESH') Then                 /*                        */\n  Do                                        /*                        */\n   Call BASE_DATA                           /* get main data          */\n   Call DISP_GROUP                          /*                        */\n  End                                       /*                        */\n If (Word(zcmd,1) = 'SORT') Then            /*                        */\n  Do                                        /*                        */\n   Call SORT_DECODE                         /* translate SORT parms   */\n   sort_parm2 = sort_parm                   /*                        */\n   Call DISP_GROUP                          /*                        */\n  End                                       /*                        */\n If (zcmd = 'FULLC') |,                     /*                        */\n    (zcmd = 'FULLD') |,                     /*                        */\n    (zcmd = 'FULLV') Then                   /*                        */\n  Do                                        /*                        */\n   sel_v_char = Substr(zcmd,5,1)            /*                        */\n   chk = 'NO'                               /*                        */\n   Address ISPEXEC \"Display Panel(PSPACE00)\"/* display the panel      */\n   p0rc = rc                                /*                        */\n   If (rc > 8) Then                         /*                        */\n    Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\" /*                        */\n   Upper chk                                /*                        */\n   sel_volume = sel_group                   /*                        */\n   If (chk = 'YES') Then                    /*                        */\n    Do                                      /*                        */\n     If (Strip(sel_group) = '') Then        /*                        */\n      dco_parm  = 'VOL('null_vols')'        /*                        */\n     Else                                   /*                        */\n      dco_parm  = 'STOG('sel_group')'       /*                        */\n     Call PROCESS_VOLUME                    /*                        */\n    End                                     /*                        */\n  End                                       /*                        */\n Address ISPEXEC \"VGet (zverb zscrolln zscrolla) Asis\"\n Do loop = 1 to Length(data2)-79 By 80      /*                        */\n  test = Substr(data2,loop,80)              /*                        */\n  If (strip(test,B) = '') Then Iterate      /*                        */\n  Upper test                                /*                        */\n  sel_v_char = Substr(test,2,1)             /*                        */\n  If (sel_v_char = 'C')  |,                 /*                        */\n     (sel_v_char = 'D')  |,                 /*                        */\n     (sel_v_char = 'S')  |,                 /*                        */\n     (sel_v_char = 'V')  Then               /*                        */\n   Do                                       /*                        */\n    data2 = Overlay(' ',data2,loop+1)       /*                        */\n    sel_volume = Substr(test,4,6)           /*                        */\n    dco_parm   = 'VOL('sel_volume')'        /*                        */\n    Call PROCESS_VOLUME                     /*                        */\n   End                                      /*                        */\n End                                        /*                        */\n If (zverb = 'DOWN') Then                   /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start2 = (Length(save_data2)-79)-((d2dep-1)*80) /*                 */\n  Else                                      /*                        */\n   start2 = start2 + (zscrolln*80)          /*                        */\n If (zverb = 'UP') Then                     /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start2 = 1                               /*                        */\n  Else                                      /*                        */\n   start2 = start2 - (zscrolln*80)          /*                        */\n If (start2 < 1) Then start2 = 1            /*                        */\n If (start2 > (Length(save_data2)-319)) Then/*                        */\n  start2 = Length(save_data2) - 319         /*                        */\n data2 = Substr(save_data2,start2,4000)     /* max 50 lines ...       */\nEnd                                         /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB\"            /* clear the temp alloc   */\nAddress TSO     \"Free Fi(\"fil_pan2\")\"       /* free the temp dsn      */\nReturn 0                                    /*                        */\n/**********************************************************************/\nPROCESS_VOLUME:                             /* process single volume##*/\nsort_parm3 = ''                             /*                        */\nIf (sel_v_char = 'S') Then                  /*                        */\n Do                                         /*                        */\n  Address ISPEXEC \"LMDInit ListID(lid) Volume(\"sel_volume\")\" /*     */\n  If (rc > 0) Then                          /*                        */\n   Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"  /*                        */\n  Else                                      /*                        */\n   Address ISPEXEC \"LMDDisp ListID(\"lid\")\"  /*                        */\n  If (rc > 0) Then                          /*                        */\n   Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"  /*                        */\n  Address ISPEXEC \"LMDFree ListID(\"lid\")\"   /*                        */\n  Return 0                                  /*                        */\n End                                        /*                        */\nCall DISP_VOLUME                            /* display vol setup      */\nCall CREATE_PDS                             /* build panel library    */\nCall DEFINE_PANEL3                          /* define panel           */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR0                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nCall DEFINE_TUTOR3                          /* define tutorial        */\nCall CREATE_MEMBER                          /* build panel            */\nfil_pan3 = fil                              /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB Library Id(\"fil_pan3\") Stack\"\np3rc = 0                                    /*                        */\nstart3 = 1                                  /*                        */\ndata3 = Substr(save_data3,start3,4000)      /* max 50 lines ...       */\nDo while p3rc < 8                           /*                        */\n rown = (start3+79)/80                      /* row number             */\n rowm = (Length(save_data3)-80)/80          /* max rows               */\n rowt = 'Row '||rown||' of '||rowm||' '     /* row text               */\n rowt = Right(rowt,79)                      /* row text               */\n Address ISPEXEC \"Display Panel(PSPACE03)\"  /* display the panel      */\n p3rc = rc                                  /*                        */\n If (rc > 8) Then                           /*                        */\n  Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"   /*                        */\n Address ISPEXEC \"PQuery Panel(PSPACE03) Areaname(DATA3) \",\n                        \"Width(d3wid) Depth(d3dep)\"\n If (zcmd = 'REFRESH') Then                 /*                        */\n  Call DISP_VOLUME                          /*                        */\n If (Word(zcmd,1) = 'SORT') Then            /*                        */\n  Do                                        /*                        */\n   Call SORT_DECODE                         /* translate SORT parms   */\n   sort_parm3 = sort_parm                   /*                        */\n   Call DISP_VOLUME                         /*                        */\n  End                                       /*                        */\n Address ISPEXEC \"VGet (zverb zscrolln zscrolla) Asis\"\n Do loop = 1 to Length(data3)-79 By 80      /*                        */\n  test = Substr(data3,loop,80)              /*                        */\n  If (strip(test,B) = '') Then Iterate      /*                        */\n  Upper test                                /*                        */\n  sel_d_char = Substr(test,2,1)             /*                        */\n  If (sel_d_char = 'B') |,                  /*                        */\n     (sel_d_char = 'E') |,                  /*                        */\n     (sel_d_char = 'S') |,                  /*                        */\n     (sel_d_char = 'V') Then                /*                        */\n   Do                                       /*                        */\n    rows = rown + ((loop-1)/80)             /*                        */\n    vols = Substr(datav,(rows*6)-5,6)       /*                        */\n    sel_volume  = vols                      /* get correct volume     */\n    data3 = Overlay(' ',data3,loop+1)       /*                        */\n    sel_dataset = Strip(Substr(test,4,44))  /*                        */\n    Call PROCESS_DATASET                    /*                        */\n   End                                      /*                        */\n End                                        /*                        */\n If (zverb = 'DOWN') Then                   /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start3 = (Length(save_data3)-79)-((d3dep-1)*80) /*                 */\n  Else                                      /*                        */\n   start3 = start3 + (zscrolln*80)          /*                        */\n If (zverb = 'UP') Then                     /*                        */\n  If (zscrolla = 'MAX') Then                /*                        */\n   start3 = 1                               /*                        */\n  Else                                      /*                        */\n   start3 = start3 - (zscrolln*80)          /*                        */\n If (start3 < 1) Then start3 = 1            /*                        */\n If (start3 > Length(save_data3)) Then start3 = Length(save_data3) - 159\n data3 = Substr(save_data3,start3,4000)     /* max 50 lines ...       */\nEnd                                         /*                        */\nAddress ISPEXEC \"LibDef ISPPLIB\"            /* clear the temp alloc   */\nAddress TSO     \"Free Fi(\"fil_pan3\")\"       /* free the temp dsn      */\nReturn 0                                    /*                        */\n/**********************************************************************/\nPROCESS_DATASET:                            /* process dataset      ##*/\nSelect                                      /*                        */\n When (sel_d_char = 'B') Then               /*                        */\n  Address ISPEXEC \"Browse Dataset('\"sel_dataset\"') Volume(\"sel_volume\")\"\n When (sel_d_char = 'E') Then               /*                        */\n  Address ISPEXEC \"Edit   Dataset('\"sel_dataset\"') Volume(\"sel_volume\")\"\n When (sel_d_char = 'S') Then               /*                        */\n  Address ISPEXEC \"Edit   Dataset('\"sel_dataset\"') Volume(\"sel_volume\")\"\n When (sel_d_char = 'V') Then               /*                        */\n  Address ISPEXEC \"View   Dataset('\"sel_dataset\"') Volume(\"sel_volume\")\"\n Otherwise NOP                              /*                        */\nEnd                                         /*                        */\nIf (rc > 0) Then                            /*                        */\n Address ISPEXEC \"SetMSG Msg(\"zerrmsg\")\"    /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nBASE_DATA:                                  /* dcollect all vols    ##*/\nIf (idcams_check /= 'YES') Then             /* test IDCAMS authorised */\n Do                                         /*                        */\n  x = Outtrap('authpgm.')                   /*                        */\n  Address TSO \"PARMLIB LIST(AUTHPGM)\"       /* list authorised pgms   */\n  x = Outtrap()                             /*                        */\n  parms_loc = Strip(authpgm.3,B)            /*                        */\n  Do ids = 9 to authpgm.0                   /*                        */\n   If (Pos('IDCAMS',authpgm.ids) > 0) Then  /* check if IDCAMS present*/\n    Do                                      /*                        */\n     idcams_check = 'YES'                   /*                        */\n     Leave                                  /*                        */\n    End                                     /*                        */\n  End                                       /*                        */\n  If (idcams_check /= 'YES') Then           /*                        */\n   Do                                       /*                        */\n    zerralrm = 'YES'                        /*                        */\n    zerrsm = 'IDCAMS not authorised'        /*                        */\n    zerrlm = 'Check 'parms_loc' and add IDCAMS to AUTHPGM section.'\n    Address ISPEXEC \"Setmsg Msg(ISRZ002)\"   /* general error messageid*/\n    Signal FINISH                           /*                        */\n   End                                      /*                        */\n End                                        /*                        */\n /* ----------------------------------------------------------------- */\n /*     setup IDCAMS DCOLLECT for volume data                         */\n /* ----------------------------------------------------------------- */\nsay ' DCOLLECT started'\nAddress TSO                                 /*                        */\n\"NewStack\"                                  /*                        */\n\"Alloc Fi(SYSPRINT) Da('NULLFILE') Shr Reu\" /*                        */\n\"Alloc Fi(AMSDUMP) Da('NULLFILE') Shr Reu\"  /*                        */\n\"Alloc Fi(SYSIN) New Lrecl(80) Reuse\"       /*                        */\nselect\n  when (sel_flag = 'POOL') &,\n       (pos('*',sel_group) = 0) then do\n     /* collect the data only for given storagegroup(s)             */\n     /* wildcard not allowed with STOG, selection done by DISP_GROUP*/\n     Queue \" DCOLLECT STOG(\"sel_group\") OUTFILE(OUTDS) NOD\"\n    end\n  when sel_flag = 'VOLUME' then do\n     /* collect the data for given volume(s) only                   */\n     /* wildcards and multiple volumes allowed                      */\n     Queue \" DCOLLECT VOL(\"sel_group\") OUTFILE(OUTDS) NOD\"\n    end\n  otherwise do\n     /* collect all volumes                                         */\n     Queue \" DCOLLECT VOL(*) OUTFILE(OUTDS) NOD\"\n    end\n end\nQueue \"\"                                    /*                        */\n\"ExecIO * DiskW SYSIN (Finis)\"              /*                        */\n\"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(340) Recfm(V B) Reu\"\n\"Call *(IDCAMS)\"                            /*                        */\n\"ExecIO * DiskR OUTDS (Stem l. Finis)\"      /*                        */\n\"Free Fi(OUTDS)\"                            /*                        */\n /* ----------------------------------------------------------------- */\nsay ' DCOLLECT finished - 'l.0' records found'\n/*cnt_vols   = l.0                             set by selection       */\nif cnt_vols = 0 then do\n   Signal ERROR\n  end\ncnt_groups = 0                              /*                        */\ntot_cap    = 0                              /*                        */\ntot_alo    = 0                              /*                        */\nloop       = 0\nnull_vols  = ''                             /* init non-SMS vol list  */\nDrop cnt_group.                             /* drop for refresh       */\nDo selvol = 1 To l.0                          /*                        */\n /* ----------------------------------------------------------------- */\n if selvol//100 = 0 then do\n    say ' 'selvol' records scanned of 'l.0\n   end\n /* ----------------------------------------------------------------- */\n dcvsglng      = C2d(Substr(l.selvol,81,2))   /* storage group name leng*/\n dcvsgtcl.selvol = Substr(l.selvol,83,dcvsglng) /* storage group name     */\n  dcvsgtcl  = dcvsgtcl.selvol\n  if   (sel_flag = 'POOL') Then do          /* 'POOL' selection       */\n    If (sel_group /= '') &,                 /* no value set           */\n       (sel_group /= '*') &,                /* wildcard for everything*/\n       (pos('*',sel_group) <> 0) Then       /* wildcard used          */\n     Do                                     /*                        */\n      sel_mask = Strip(Translate(sel_group,' ','*'),B) /* remove wild */\n      len_mask = Length(sel_mask)           /* length of mask         */\n      len_sgrp = Length(dcvsgtcl)           /* length of stor group   */\n      test_pos = (len_sgrp-len_mask) + 1\n      If (Substr(sel_group,1,1) /= '*') Then  /*                      */\n       If (Pos(sel_mask,Strip(dcvsgtcl)) <> 1) Then Iterate\n      If (Substr(sel_group,Length(sel_group),1) /= '*') Then /*       */\n       If (Pos(sel_mask,Strip(dcvsgtcl)) <> test_pos) Then Iterate\n      If (Pos(sel_mask,Strip(dcvsgtcl)) = 0) Then Iterate\n     End                                    /*                        */\n   End                                      /*                        */\n  loop = loop +1\n /* ----------------------------------------------------------------- */\n dcvvolsr.loop = Substr(l.selvol,25,6)      /* volume serial number   */\n dcvperct.loop = C2d(Substr(l.selvol,36,1)) /* percent free space     */\n dcvcylmg.loop = C2x(Substr(l.selvol,122,1)) /* bit1:0=trk, 1=cyl managd*/\n /* ----------------------------------------------------------------- */\n /* depending on dcvcylmg space values are  bit1: 0=kb , 1=mb         */\n /* ----------------------------------------------------------------- */\n dcvfresp.loop = C2d(Substr(l.selvol,37,4)) /* free space   volume    */\n dcvalloc.loop = C2d(Substr(l.selvol,41,4)) /* alloc space  volume    */\n dcvvlcap.loop = C2d(Substr(l.selvol,45,4)) /* capacity     volume    */\n dcvtrfsp.loop = C2d(Substr(l.selvol,125,4)) /* free space  trk mngd  */\n dcvtralc.loop = C2d(Substr(l.selvol,129,4)) /* alloc space trk mngd  */\n dcvtrvlc.loop = C2d(Substr(l.selvol,133,4)) /* capacity    trk mngd  */\n /* ----------------------------------------------------------------- */\n dcvfragi.loop = C2d(Substr(l.selvol,49,4)) /* fragmentation index    */\n dcvlgext.loop = C2d(Substr(l.selvol,53,4)) /* largest extent         */\n dcvdvtyp.loop = Strip(Substr(l.selvol,69,8),B) /* device type        */\n If (dcvdvtyp.loop = '3390') Then size_cyl = '849960' /* cyl in bytes */\n If (dcvdvtyp.loop = '3380') Then size_cyl = '712140' /* cyl in bytes */\n If (dcvdvtyp.loop = '3390') Then size_trk = '56664'  /* trk in bytes */\n If (dcvdvtyp.loop = '3380') Then size_trk = '47476'  /* trk in bytes */\n/* ------------------------------------------------------------------ */\n/*  ??? type not used                                                 */\n/*                                                                    */\n/*Select                                      * capacity         cyls */\n/*When (dcvvlcap.loop = '1846417')  Then type = '3380-K'  * kb        */\n/*When (dcvvlcap.loop = '923833')   Then type = 'm-01  '  * kb   1113 */\n/*When (dcvvlcap.loop = '1847666')  Then type = '3390-2'  * kb   2226 */\n/*When (dcvvlcap.loop = '2771500')  Then type = '3390-3'  * kb   3339 */\n/*When (dcvvlcap.loop = '8314501')  Then type = 'm-09  '  * kb  10017 */\n/*When (dcvvlcap.loop = '24943503') Then type = 'm-27  '  * kb  30051 */\n/*When (dcvvlcap.loop = '49887007') Then type = 'm-54  '  * kb  60102 */\n/*When (dcvvlcap.loop = '194871')   Then type = 'm-216 '  * mb 240408 */\n/*Otherwise type = dcvdvtyp.loop                                      */\n/*End                                                                 */\n/* ------------------------------------------------------------------ */\n dcvvolsr      = dcvvolsr.loop              /* get volser             */\n/* type.dcvvolsr = type                       save type, but not used */\n size_cyl.dcvvolsr = size_cyl               /* save cylinder size     */\n size_trk.dcvvolsr = size_trk               /* save track size        */\n if dcvcylmg.loop <  '80' then do           /* NON EAV    sizes in kb */\n    dcvlgext.loop = (dcvlgext.loop*1024)/size_cyl /* convert to cyls  */\n    tot_cap       = tot_cap + dcvvlcap.loop /* accumulate kb capacity */\n    tot_alo       = tot_alo + dcvalloc.loop /* accumulate kb allocated*/\n   end\n  else do                                   /* EAV        sizes in MB */\n    dcvlgext.loop = (dcvlgext.loop*2**20)/size_cyl    /* conv to cyls */\n    tot_cap = tot_cap +(dcvvlcap.loop*1024) /* accum cyl capacity (kb)*/\n    tot_cap = tot_cap +(dcvtrvlc.loop*1024) /* accum trk capacity (kb)*/\n    tot_alo = tot_alo +(dcvalloc.loop*1024) /* accum cyl alloc    (kb)*/\n    tot_alo = tot_alo +(dcvtralc.loop*1024) /* accum trk alloc    (kb)*/\n   end\n dcvdvnum.loop = Right(D2x(C2d(Substr(l.selvol,77,2))),4,'0')/*       */\n dcvdptyp.loop = Substr(l.selvol,113,8)     /* physical device type   */\n dcvsglng      = C2d(Substr(l.selvol,81,2)) /* storage group name leng*/\n If (dcvsglng = 0) Then                     /*                        */\n  null_vols = null_vols||dcvvolsr||' '      /* build non-sms vol list */\n dcvsgtcl.loop = Substr(l.selvol,83,dcvsglng) /* storage group name   */\n if strip(dcvsgtcl.loop) = '' then do\n    dcvsgtcl.loop = 'non-sms'\n    dcvsglng      = 7\n   end\n dcvsgtcl      = dcvsgtcl.loop              /*                        */\n/* ------------------------------------------------------------------ */\n If (cnt_group.dcvsgtcl > 0) Then           /* test if group known    */\n  Do                                        /*                        */\n   cnt_group.dcvsgtcl = cnt_group.dcvsgtcl + 1 /*                     */\n   if dcvcylmg.loop <  '80' then do         /* NON EAV    sizes in kb */\n      cap_group.dcvsgtcl = cap_group.dcvsgtcl + dcvvlcap.loop\n      cap_g_trk.dcvsgtcl = cap_g_trk.dcvsgtcl + dcvvlcap.loop\n   /* cap_g_cyl.dcvsgtcl :  no space to add                           */\n      alo_group.dcvsgtcl = alo_group.dcvsgtcl + dcvalloc.loop\n      alo_g_trk.dcvsgtcl = alo_g_trk.dcvsgtcl + dcvalloc.loop\n   /* alo_g_cyl.dcvsgtcl :  no space to add                           */\n   /* SG_w_EAVs.dcvsgtcl :  not an EAV                                */\n     end\n    else do                                 /* EAV        sizes in MB */\n      cap_group.dcvsgtcl = cap_group.dcvsgtcl + (dcvvlcap.loop*1024)\n      cap_g_trk.dcvsgtcl = cap_g_trk.dcvsgtcl + (dcvtrvlc.loop*1024)\n      cap_g_cyl.dcvsgtcl = cap_g_cyl.dcvsgtcl +,\n                           (dcvvlcap.loop-dcvtrvlc.loop)*1024\n      alo_group.dcvsgtcl = alo_group.dcvsgtcl + (dcvalloc.loop*1024)\n      alo_g_trk.dcvsgtcl = alo_g_trk.dcvsgtcl + (dcvtralc.loop*1024)\n      alo_g_cyl.dcvsgtcl = alo_g_cyl.dcvsgtcl +,\n                           (dcvalloc.loop-dcvtralc.loop)*1024\n      SG_w_EAVs.dcvsgtcl = SG_w_EAVs.dcvsgtcl +1  /* number of EAVs   */\n     end\n  End                                       /*                        */\n Else                                       /*                        */\n  Do                                        /* storage group unknown  */\n   cnt_groups = cnt_groups + 1              /*                        */\n   cnt_group.dcvsgtcl = 1                   /*                        */\n   if dcvcylmg.loop < '80' then do          /* NON EAV    sizes in kb */\n      cap_group.dcvsgtcl = dcvvlcap.loop    /*                        */\n      cap_g_trk.dcvsgtcl = dcvvlcap.loop    /*                        */\n      cap_g_cyl.dcvsgtcl = 0                /*                        */\n      alo_group.dcvsgtcl = dcvalloc.loop    /*                        */\n      alo_g_trk.dcvsgtcl = dcvalloc.loop    /*                        */\n      alo_g_cyl.dcvsgtcl = 0                /*                        */\n      SG_w_EAVs.dcvsgtcl = 0                /* count number of EAVs   */\n     end\n    else do                                 /* EAV        sizes in MB */\n      cap_group.dcvsgtcl =  dcvvlcap.loop*1024                  /* kb */\n      cap_g_trk.dcvsgtcl =  dcvtrvlc.loop*1024\n      cap_g_cyl.dcvsgtcl = (dcvvlcap.loop-dcvtrvlc.loop)*1024\n      alo_group.dcvsgtcl =  dcvalloc.loop*1024                  /* kb */\n      alo_g_trk.dcvsgtcl =  dcvtralc.loop*1024\n      alo_g_cyl.dcvsgtcl = (dcvalloc.loop-dcvtralc.loop)*1024\n      SG_w_EAVs.dcvsgtcl = 1                /* count number of EAVs   */\n     end\n   nam_group.cnt_groups = dcvsgtcl          /*                        */\n  End                                       /*                        */\nEnd                                         /*                        */\ncnt_vols = loop                             /* number of vols         */\nsay ' 'cnt_vols 'records selected'\nReturn 0                                    /*                        */\n/**********************************************************************/\nDISP_GROUPS:                                /*                      ##*/\ndata1 = ''                                  /*                        */\nDo loop = 1 to cnt_groups                   /*                        */\n nam_group = nam_group.loop                 /*                        */\n cnt_group = cnt_group.nam_group            /* get the group count    */\n                                            /* ---------------------- */\n alo_group = alo_group.nam_group            /* get total allocated    */\n alo_g_trk = alo_g_trk.nam_group            /* TRK mngd area          */\n alo_g_cyl = alo_g_cyl.nam_group            /* CYL mngd area          */\n                                            /* ---------------------- */\n cap_group = cap_group.nam_group            /* get total capacity (KB)*/\n cap_g_trk = cap_g_trk.nam_group            /* TRK mngd area          */\n cap_g_cyl = cap_g_cyl.nam_group            /* CYL mngd area          */\n                                            /* ---------------------- */\n fre_group = cap_group - alo_group          /* get total free         */\n                                            /* ---------------------- */\n per_group = 0\n per_g_trk = 0\n per_g_cyl = 0\n if cap_group > 0 then do\n    per_group = (alo_group / cap_group)*100 /* calculate percentage   */\n   end\n if cap_g_trk > 0 then do\n    per_g_trk = (alo_g_trk / cap_g_trk)*100 /* calculate percentage   */\n   end\n if cap_g_cyl > 0 then do\n    per_g_cyl = (alo_g_cyl / cap_g_cyl)*100 /* calculate percentage   */\n   end\n                                            /* ---------------------- */\n/* per_disp  = Left('',Trunc((per_group*31)/100,0),'*')               */\n per_disp  = Left('',Trunc((per_group*21)/100,0),'*')\n/* alo_group = Trunc((alo_group*1024)/10**9,2)   change to GB  1000**3*/\n alo_group = Trunc((alo_group)/2**20,1)     /* change to GiB, 1024**3 */\n/* cap_group = Trunc((cap_group*1024)/10**9,2)   change to GB, 1000**3*/\n cap_group = Trunc((cap_group)/2**20,1)     /* change to GiB, 1024**3 */\n/* fre_group = Trunc((fre_group*1024)/10**9,2)   change to GB  1000**3*/\n fre_group = Trunc((fre_group)/2**20,1)     /* change to GiB, 1024**3 */\n                                            /* ---------------------- */\n Select                                     /*                        */\n  When (per_group >= Lim_R) Then high = X0F /*                        */\n  When (per_group >= Lim_Y) Then high = X0E /*                        */\n  Otherwise high = X0D                      /*                        */\n End                                        /*                        */\n                                            /* ---------------------- */\n Select                                     /*                        */\n  When (per_g_trk >= Lim_R) Then high_t = X0F /*                      */\n  When (per_g_trk >= Lim_Y) Then high_t = X0E /*                      */\n  Otherwise high_t = X0D                    /*                        */\n End                                        /*                        */\n                                            /* ---------------------- */\n Select                                     /*                        */\n  When (per_g_cyl >= Lim_R) Then high_c = X0F /*                      */\n  When (per_g_cyl >= Lim_Y) Then high_c = X0E /*                      */\n  Otherwise high_c = X0D                    /*                        */\n End                                        /*                        */\n display = X20\" \"X0C||Left(nam_group,19)\n display = display||Right(cnt_group,4)\n display = display||Right(cap_group,8)\n display = display||Right(fre_group,8)\n /* --- */\n if SG_w_EAVs.nam_group > 0 then do\n    display = display||high_t||Right(Trunc(per_g_trk,0),3)||\"%\"\n    display = display||high_c||Right(Trunc(per_g_cyl,0),3)||\"%\"\n   end\n  else do\n    display = display||high_t||Right(' ',4)\n    display = display||high_c||Right(' ',4)\n   end\n display = display||high||Right(Trunc(per_group,0),3)||\"% \"\n display = display||per_disp\n data1 = data1||Left(display,80)            /*                        */\nEnd                                         /*                        */\n/*        ----+----1----+----2----+----3----+----4----+----5----+----6-*/\ndisp_pat='   STOGROUP            VOL TOTAL   FREE    PTRK PCYL PVOL XXX'\n/* disp_pat = '   STOGROUP            VOL TOTAL   FREE    PCT  XXX'   */\ndata    = data1                             /*                        */\nsort_parm = sort_parm1                      /*                        */\nsort_leng = 80                              /* set sort length        */\nCall DATA_SORT                              /*                        */\ndata1   = data                              /*                        */\n/* display = X0B||\"----------------------------------------------\"    */\ndisplay = X0B||substr('-',1,57,'-')\ndata1   = data1||Left(display,80)           /*                        */\ntot_fre = tot_cap - tot_alo                 /* calculate total free   */\n/* tot@fre = Format((tot_fre*1024)/10**9,6,0)  change to GB, 1000**3  */\n/* tot@cap = Format((tot_cap*1024)/10**9,6,0)  change to GB, 1000**3  */\ntot@fre = Format((tot_fre)/2**20,10,0)      /* change to GiB 1024**3  */\ntot@cap = Format((tot_cap)/2**20,10,0)      /* change to GiB 1024**3  */\ndisplay = X0C\" \"X0B||Left('Total',19)||Right(cnt_vols,4)\ndisplay = display||Right(tot@cap,8)||Right(tot@fre,8)\ndata1   = data1||Left(display,80)           /*                        */\ndata1   = data1||X0C||Centre(' End of List ',79,'*')\nsave_data1 = data1                          /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDISP_GROUP:                                 /*                      ##*/\ndata2 = ''                                  /*                        */\ncnt_group = 0                               /*                        */\nalo_group = 0                               /*                        */\ncap_group = 0                               /* SMS group capacity     */\ng_cap_trk = 0                               /* grp cap TRK mngd area  */\ng_cap_cyl = 0                               /* grp cap CYL mngd area  */\ng_alo_trk = 0                               /* grp alo TRK mngd area  */\ng_alo_cyl = 0                               /* grp alo CYL mngd area  */\ng_EAVs    = 0                               /* count EAV volumes      */\nDo loop = 1 to cnt_vols                     /*                        */\n dcvsgtcl  = dcvsgtcl.loop                  /*                        */\n\n dcvvolsr  = dcvvolsr.loop                  /* volume serial          */\n Select                                     /*                        */\n  When (sel_flag = 'POOL') Then             /* 'POOL' selection       */\n   Do                                       /*                        */\n    If (sel_group /= '') &,                 /* no value set           */\n       (sel_group /= '*') Then              /* wildcard for everything*/\n     Do                                     /*                        */\n      sel_mask = Strip(Translate(sel_group,' ','*'),B) /* remove wild */\n      len_mask = Length(sel_mask)           /* length of mask         */\n      len_sgrp = Length(dcvsgtcl)           /* length of stor group   */\n      test_pos = (len_sgrp-len_mask) + 1\n      If (Substr(sel_group,1,1) /= '*') Then  /*                      */\n       If (Pos(sel_mask,Strip(dcvsgtcl)) <> 1) Then Iterate\n      If (Substr(sel_group,Length(sel_group),1) /= '*') Then /*       */\n       If (Pos(sel_mask,Strip(dcvsgtcl)) <> test_pos) Then Iterate\n      If (Pos(sel_mask,Strip(dcvsgtcl)) = 0) Then Iterate\n     End                                    /*                        */\n   End                                      /*                        */\n  When (sel_flag = 'VOLUME') Then           /* 'POOL' selection       */\n   Do                                       /*                        */\n /* ----------------------------------------------------------------- */\n /*   nothing, selection already done by DCOLLECT                     */\n /* ----------------------------------------------------------------- */\n /* If (sel_group /= '') &,                 /* no value set           */\n       (sel_group /= '*') Then              /* wildcard for everything*/\n     Do                                     /*                        */\n      sel_mask = Strip(Translate(sel_group,' ','*'),B) /* remove wild */\n      len_mask = Length(sel_mask)           /* length of mask         */\n      len_sgrp = Length(dcvvolsr)           /* length of volser       */\n      test_pos = (len_sgrp-len_mask) + 1\n      If (Substr(sel_group,1,1) /= '*') Then  /*                      */\n       If (Pos(sel_mask,Strip(dcvvolsr)) <> 1) Then Iterate\n      If (Substr(sel_group,Length(sel_group),1) /= '*') Then /*       */\n       If (Pos(sel_mask,Strip(dcvvolsr)) <> test_pos) Then Iterate\n      If (Pos(sel_mask,Strip(dcvvolsr)) = 0) Then Iterate\n     End */                                 /*                        */\n /* ----------------------------------------------------------------- */\n   End                                      /*                        */\n  Otherwise                                 /* normal option          */\n   If (translate(Strip(dcvsgtcl)) /= translate(sel_group)) Then Iterate\n End                                        /*                        */\n cnt_group = cnt_group + 1                  /* members in group       */\n /* ----------------------------------------------------------------- */\n dcvperct  = dcvperct.loop                  /* percent free space     */\n per_trk   = 0\n per_cyl   = 0\n per_g_trk = 0\n per_g_cyl = 0\n high_t    = X0D\n high_c    = X0D\n if dcvcylmg.loop <  '80' then do           /* NON EAV    sizes in KB */\n    /* total capacity    */\n /* dcvvlcap  = Trunc((dcvvlcap.loop*1024)/10**9,2)  GB round decimal */\n    dcvvlcap  = Trunc((dcvvlcap.loop)/2**20,2) /* GiB = base 1024**3  */\n    cap_group = cap_group + dcvvlcap.loop\n    cap_trk   = dcvvlcap.loop                /* trk managed area   KB */\n    g_cap_trk = g_cap_trk +(cap_trk/1024)    /* Grp TRK mngd area MiB */\n    cap_cyl   = 0                            /* cyl managed area   KB */\n    /* allocated space   */\n /* dcvalloc  = Trunc((dcvalloc.loop*1024)/10**9,2)  GB round decimal */\n    dcvalloc  = Trunc((dcvalloc.loop)/2**20,2) /* GiB = base 1024**3  */\n    alo_group = alo_group + dcvalloc.loop\n    alo_trk   = dcvalloc.loop                /* trk managed area   KB */\n    g_alo_trk = g_alo_trk +(alo_trk/1024)    /* Grp TRK mngd area MiB */\n    alo_cyl   = 0                            /* cyl managed area   KB */\n    /* free space        */\n /* dcvfresp  = Trunc((dcvfresp.loop*1024)/10**9,2)  GB round decimal */\n    dcvfresp  = Trunc((dcvfresp.loop)/2**20,2) /* GiB = base 1024**3  */\n   end\n  else do                                   /* EAV        sizes in MB */\n    /* -------------------------------------------------------------- */\n    dcvvlcap  = Trunc((dcvvlcap.loop)/2**10,2) /* volume capacity GiB */\n    cap_group = cap_group + dcvvlcap.loop*1024 /* cumulate grp    KB  */\n    cap_trk   = dcvtrvlc.loop                /* trk managed area  MiB */\n    g_cap_trk = g_cap_trk + cap_trk          /* Grp TRK mngd area MiB */\n    cap_cyl   = dcvvlcap.loop-dcvtrvlc.loop  /* cyl managed area  MiB */\n    g_cap_cyl = g_cap_cyl + cap_cyl          /* Grp CYL mngd area MiB */\n    /* -------------------------------------------------------------- */\n    dcvalloc  = Trunc((dcvalloc.loop)/2**10,2) /* alloc on volume GiB */\n    alo_group = alo_group + dcvalloc.loop*1024 /* cumulate grp    KB  */\n    alo_trk   = dcvtralc.loop                /* trk managed area  MiB */\n    g_alo_trk = g_alo_trk + alo_trk          /* Grp TRK mngd area MiB */\n    alo_cyl   = dcvalloc.loop-dcvtralc.loop  /* cyl managed area  MiB */\n    g_alo_cyl = g_alo_cyl + alo_cyl          /* Grp CYL mngd area MiB */\n    /* --------------------------------------- trk managed area ----- */\n    If (cap_trk  > 0) Then DO               /* check for zero capacity*/\n       per_trk   = (alo_trk/cap_trk) * 100  /* calculate percentage   */\n       Select\n        When (per_trk >= Lim_R) Then high_t = X0F\n        When (per_trk >= Lim_Y) Then high_t = X0E\n        Otherwise high_t = X0D\n       End\n     End\n    /* --------------------------------------- cyl managed area ----- */\n    If (cap_cyl  > 0) Then Do               /* check for zero capacity*/\n       per_cyl   = (alo_cyl/cap_cyl) * 100  /* calculate percentage   */\n       Select\n        When (per_cyl >= Lim_R) Then high_c = X0F\n        When (per_cyl >= Lim_Y) Then high_c = X0E\n        Otherwise high_c = X0D\n       End\n     End\n    /* --------------------------------------- free space on volume - */\n    dcvfresp  = Trunc(dcvfresp.loop/2**10,2)                   /* GiB */\n    g_EAVs    = g_EAVs + 1\n   end\n /* ----------------- */\n dcvfragi  = dcvfragi.loop                  /* fragmentation index    */\n /* ----------------- */\n dcvlgext  = dcvlgext.loop                  /* largest extent         */\n if dcvlgext >= 100000 then do\n    dcvlgext = Trunc(dcvlgext/1000,0)||'T'\n   end\n  else do\n    dcvlgext = Trunc(dcvlgext,0)\n   end\n /* ----------------- */\n dcvdvtyp  = dcvdvtyp.loop                  /* device type            */\n /*dcvdptyp  = dcvdptyp.loop     not displayed physical device type   */\n dcvdvnum  = dcvdvnum.loop                  /* device number          */\n /* ----------------- */\n If (dcvvlcap > 0) Then                     /* check for zero capacity*/\n  per_vol   = (dcvalloc/dcvvlcap) * 100     /* calculate percentage   */\n Else                                       /*                        */\n  per_vol   = 0                             /* set percentage         */\n Select                                     /*                        */\n  When (per_vol >= Lim_R) Then high = X0F   /*                        */\n  When (per_vol >= Lim_Y) Then high = X0E   /*                        */\n  Otherwise high = X0D                      /*                        */\n End                                        /*                        */\n /* ----------------------------------------------------------------- */\n /* per_disp  = Left('',Trunc((per_vol*31)/100,0),'*')                */\n    per_disp  = Left('',Trunc((per_vol*21)/100,0),'*')\n/*    per_disp  = Left('',Trunc(((per_vol*20)/100)+1,0),'*') */\n /* ----------------------------------------------------------------- */\n /*   build VOLSER line                                               */\n /* ----------------------------------------------------------------- */\n display = X20\" \"X0C||Left(dcvvolsr,7)||Left(dcvdvnum,5)\n/*display = display||Left(dcvdvtyp,5)||Right(dcvvlcap,5)\" \"           */\n display = display||Right(dcvvlcap,6)\" \"\n/*display = display||Right(dcvfresp,5)||Right(Trunc(dcvlgext,0),6)    */\n display = display||Right(dcvfresp,6)||Right(dcvlgext,6)\n display = display||Right(Trunc(dcvfragi,0),5)\n if dcvcylmg.loop <  '80' then do            /* NON EAV                */\n    display = display||high||Right(Trunc(per_vol,1),5)     /* trk area */\n    display = display||high_c||Right(' ',5)  /*  no value for cyl area */\n   end\n  else do                                    /* EAV                    */\n    display = display||high_t||Right(Trunc(per_trk,1),5)   /* trk area */\n    display = display||high_c||Right(Trunc(per_cyl,1),5)   /* cyl area */\n   end\n display = display||high||Right(Trunc(per_vol,1),5)||' '||per_disp\n data2 = data2||Left(display,80)            /*                        */\nEnd                                         /*                        */\n /* ----------------------------------------------------------------- */\nIf (cnt_group = 0) Then                     /*                        */\n Do                                         /*                        */\n  zerralrm = 'YES'                          /*                        */\n  zerrhm = 'TSPACE02'                       /*                        */\n  zerrsm = 'No volumes found'               /*                        */\n  zerrlm = 'No volumes matching 'sel_group' where found.' /*          */\n  Address ISPEXEC \"Setmsg Msg(ISRZ002)\"     /* general error messageid*/\n  save_data2 = Left('',4000)                /*                        */\n  Return                                    /*                        */\n End                                        /*                        */\n/*disp_pat = '   VOLSER ADDR TYPE CAPA  FREE  CNTG  FRAG PCT  XXX'    */\ndisp_pat='   VOLSER ADDR CAPA   FREE   CNTG  FRAG PTRK  PCYL  PVOL XXX'\ndata    = data2                             /*                        */\nsort_parm = sort_parm2                      /*                        */\nsort_leng = 80                              /* set sort length        */\nCall DATA_SORT                              /*                        */\ndata2   = data                              /*                        */\n/* display = X0B||\"----------------------------------------------\"    */\ndisplay = X0B||substr('-',1,57,'-')\ndata2   = data2||Left(display,80)           /*                        */\nfre_group = cap_group - alo_group           /* calculate total free   */\nper_group = ((alo_group/cap_group)*100)     /* get average percentage */\nif g_cap_trk > 0 then do\n   per_g_trk = ((g_alo_trk/g_cap_trk)*100)  /* get average percentage */\n  end\nif g_cap_cyl > 0 then do\n   per_g_cyl = ((g_alo_cyl/g_cap_cyl)*100)  /* get average percentage */\n  end\n\n/* fre_group = Format((fre_group*1024)/10**9,6,0) change to GB        */\nfre_group = Format((fre_group)/2**20,8,1)   /* change to GiB 1024**3  */\n/* cap_group = Format((cap_group*1024)/10**9,6,0) change to GB 1000**3*/\ncap_group = Format((cap_group)/2**20,10,1)  /* change to GiB 1024**3  */\n /* ----------------------------------------------------------------- */\n /*   build Storage Group Total Line                                  */\n /* ----------------------------------------------------------------- */\n/*display = X0C\" \"X0B||Left('Total',16)                               */\ndisplay = X0C\" \"X0B||Left('Total',8)        /*                        */\n/* display = display||Right(cap_group,6)||Right(fre_group,6)          */\ndisplay = display||Right(cap_group,9)||Right(fre_group,7)\n/*display = display||Right(Trunc(per_group,0),15)||'%'                */\nif g_EAVs > 0 then do\n   display = display||Right(' ',12)\n   display = display||Right(Trunc(per_g_trk,0),4)||' %'\n   display = display||Right(Trunc(per_g_cyl,0),4)||' %'\n  end\n else do\n   display = display||Right(' ',12)\n   display = display||Right(' ',6)\n   display = display||Right(' ',6)\n  end\ndisplay = display||Right(Trunc(per_group,0),4)||' %'\ndata2   = data2||Left(display,80)           /*                        */\ndata2   = data2||X0C||Centre(' End of List ',79,'*')\nsave_data2 = data2                          /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDISP_VOLUME:                                /*                      ##*/\ndata3 = ''                                  /*                        */\nAddress TSO                                 /*                        */\n\"NewStack\"                                  /*                        */\n/*\"Alloc Fi(SYSPRINT) Da(*) Shr Reu\"            for debugging         */\n\"Alloc Fi(SYSPRINT) Da('NULLFILE') Shr Reu\" /*                        */\n\"Alloc Fi(AMSDUMP) Da('NULLFILE') Shr Reu\"  /*                        */\n\"Alloc Fi(SYSIN) New Lrecl(80) Reuse\"       /*                        */\nQueue \" DCOLLECT -\"                         /* dcollect               */\nDo parms = 1 to Words(dco_parm)             /*                        */\nQueue \"  \"Word(dco_parm,parms)\" -\"          /* dcollect selection     */\nEnd                                         /*                        */\nQueue \"  OUTFILE(OUTDS)\"                    /* dcollect output        */\nQueue \"\"                                    /*                        */\n\"ExecIO * DiskW SYSIN (Finis)\"              /*                        */\n\"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(410) Recfm(V B) Reu\"\n/*\"Alloc Fi(OUTDS) Cylinders Space(10 10) New Lrecl(340) Recfm(V B) Reu\" */\n\"Call *(IDCAMS)\"                            /*                        */\n\"ExecIO * DiskR OUTDS (Stem l. Finis)\"      /*                        */\n\"Free Fi(OUTDS)\"                            /*                        */\n\"Free Fi(SYSPRINT)\"                         /*                        */\nDo loop = 1 to cnt_vols                     /*                        */\n/*Do loop = 1 to l.0                                                  */\n dcurctyp.loop = Substr(l.loop,5,1)         /* record type            */\n If (dcurctyp.loop = 'V') Then              /* if 'V' type record     */\n  dcvvolsr = Substr(l.loop,25,6)            /* volume serial number   */\n If (dcurctyp.loop /= 'D') Then Iterate     /* none dataset record    */\n dcddsnam.loop = Substr(l.loop,25,44)       /* dataset name           */\n dcdflags.loop = Substr(l.loop,69,4)        /* information flags      */\n dcderror.loop = Substr(l.loop,69,1)        /* error information flag */\n dcdflag1.loop = Substr(l.loop,70,1)        /* information flag #1    */\n dcdflag1      = X2b(C2x(dcdflag1.loop))    /* flag #1 as bits        */\n dcdflag2.loop = Substr(l.loop,71,1)        /* information flag #2    */\n dcdflag3.loop = Substr(l.loop,72,1)        /* information flag #3    */\n dcdnovvr.loop = Substr(X2b(C2x(dcdflag2.loop)),1,1) /* no VVR flag   */\n dcddsorg.loop = Substr(l.loop,75,2)        /* dsorg                  */\n dcddsorg      = X2b(C2x(dcddsorg.loop))    /* dsorg as bits          */\n Select                                     /* decode dsorg           */\n  When (Substr(dcddsorg,1,1) = '1') Then dsorg = 'IS'\n  When (Substr(dcddsorg,2,1) = '1') Then dsorg = 'PS'\n  When (Substr(dcddsorg,3,1) = '1') Then dsorg = 'DA'\n  When (Substr(dcddsorg,7,1) = '1') Then dsorg = 'PO'\n  When (Substr(dcddsorg,8,1) = '1') Then dsorg = 'U '\n  When (Substr(dcddsorg,9,1) = '1') Then dsorg = 'GS'\n  When (Substr(dcddsorg,13,1) = '1') Then dsorg = 'VS'\n  Otherwise dsorg = '??'                    /*                        */\n End                                        /*                        */\n If (Substr(dcdflag1,4,1) = '1') Then dsorg = dsorg||'-E'\n dcdrecrd.loop = Substr(l.loop,77,1)        /* recfm                  */\n dcdrecrd      = X2b(C2x(dcdrecrd.loop))    /* recfm as bits          */\n Select                                     /* decode dsorg           */\n  When (Substr(dcdrecrd,1,2) = '10') Then recfm = 'F'\n  When (Substr(dcdrecrd,1,2) = '01') Then recfm = 'V'\n  When (Substr(dcdrecrd,1,2) = '11') Then recfm = 'U'\n  Otherwise recfm = '?'                     /*                        */\n End                                        /*                        */\n If (Substr(dcdrecrd,4,1) = '1') Then recfm = recfm||'B'\n If (Substr(dcdrecrd,3,1) = '1') Then recfm = recfm||'T'\n If (Substr(dcdrecrd,5,1) = '1') Then recfm = recfm||'S'\n If (Substr(dcdrecrd,6,1) = '1') Then recfm = recfm||'A'\n If (Substr(dcdrecrd,7,1) = '1') Then recfm = recfm||'M'\n dcdnmext.loop = Substr(l.loop,78,1)        /* number of extents      */\n dcdvolsr.loop = Substr(l.loop,79,6)        /* volume serial number   */\n dcdvolsr = dcdvolsr.loop                   /*                        */\n dcdnmext = C2d(dcdnmext.loop)              /*                        */\n dcdbklng.loop = Substr(l.loop,85,2)        /* block length           */\n dcdbklng = C2d(dcdbklng.loop)              /*                        */\n dcdlrecl.loop = Substr(l.loop,87,2)        /* lrecl                  */\n dcdlrecl = C2d(dcdlrecl.loop)              /*                        */\n dcdvolsq.loop = Substr(l.loop,123,2)       /* volume sequence number */\n dcdvolsq = C2d(dcdvolsq.loop)              /*                        */\n size_trk = size_trk.dcvvolsr               /* get track size         */\n cat_volume = dcvvolsr                      /* get catalog check vol  */\n dcdallsp.loop = C2d(Substr(l.loop,89,4))/* allocated space           */\n dcdusesp.loop = C2d(Substr(l.loop,93,4))/* used         space        */\n dcdscall.loop = C2d(Substr(l.loop,97,4))/* secondary space alloc     */\n dcdallsp = Format((dcdallsp.loop*1024)/size_trk,6,0) /* conv to trks */\n dcdusesp = Format((dcdusesp.loop*1024)/size_trk,6,0) /* conv to trks */\n dcdscall = Format((dcdscall.loop*1024)/size_trk,6,0) /* conv to trks */\n display = X20\" \"X0C||Left(dcddsnam.loop,44)/*                        */\n Select                                     /* normal selection       */\n  When (sel_v_char = 'C') Then              /* catalog selection      */\n   Do                                       /*                        */\n    display = display||Right(dcdvolsr,7)    /* add volser             */\n    dcddsnam      = dcddsnam.loop           /*                        */\n    dsn_cat.dcddsnam = '*Not Cataloged'     /* set cat flag to no     */\n    filter        = dcddsnam                /*                        */\n    Call CSICODE                            /*                        */\n     If (Substr(dsn_cat.dcddsnam,1,1) = '*') Then /*                  */\n      high = X0F                            /* highlight red          */\n     Else                                   /*                        */\n      high = X0D                            /* highlight green        */\n     display = display||high||dsn_cat.dcddsnam /* add catalog name    */\n   End                                      /*                        */\n  When (sel_v_char = 'D') Then              /* normal selection       */\n   Do                                       /*                        */\n    display = display||Left(\" \"dsorg,5)     /* add catalog name       */\n    display = display||Left(\" \"recfm,5)     /* add recfm              */\n    display = display||Right(dcdallsp,7)    /* add allocated space    */\n    display = display||Right(dcdnmext,4)    /* add extents            */\n    display = display||Right(dcdbklng,6)    /* add blksize            */\n    display = display||Right(dcdlrecl,6)    /* add lrecl              */\n   End                                      /*                        */\n  When (sel_v_char = 'V') Then              /* normal selection       */\n   Do                                       /*                        */\n    display = display||Right(dcdallsp,7)    /* add allocated space    */\n    display = display||Right(dcdnmext,4)    /* add extents            */\n    display = display||Right(dcdvolsq,3)    /* add volseq             */\n    display = display||Right(dcdvolsr,7)    /* add volser             */\n   End                                      /*                        */\n  Otherwise NOP                             /*                        */\n End\n data3 = data3||Left(display,80)||Left(dcdvolsr.loop,6) /*            */\nEnd                                         /*                        */\nSelect                                      /*                        */\n When (sel_v_char = 'C') Then              /* catalog selection      */\n  Do\n   disp_pat = '   DATASET                                      '\n   disp_pat = disp_pat||'VOLSER CATALOG                   XXX'\n  End\n When (sel_v_char = 'D') Then              /* normal selection       */\n  Do\n   disp_pat = '   DATASET                                      '\n   disp_pat = disp_pat||'DSRG RECF SPACE  XT  BLKSZ LRECL XXX'\n  End\n When (sel_v_char = 'V') Then              /* normal selection       */\n  Do\n   disp_pat = '   DATASET                                      '\n   disp_pat = disp_pat||'SPACE  XT  V# VOLSER XXX'\n  End\n Otherwise NOP\nEnd                                         /*                        */\ndata    = data3                             /*                        */\nsort_parm = sort_parm3                      /*                        */\nsort_leng = 86                              /* set sort length        */\nCall DATA_SORT                              /*                        */\ndatav   = over                              /* save volume list       */\ndata3   = data                              /*                        */\ndata3   = data3||X0C||Centre(' End of List ',79,'*')\nsave_data3 = data3                          /*                        */\nReturn 0                                    /*                        */\n\n/**********************************************************************/\nDEFINE_HEX:                                 /* define panel hex     ##*/\nX01 = '01'X                                 /* set hex '01' variable  */\nX02 = '02'X                                 /* set hex '02' variable  */\nX03 = '03'X                                 /* set hex '03' variable  */\nX04 = '04'X                                 /* set hex '04' variable  */\nX05 = '05'X                                 /* set hex '05' variable  */\nX06 = '06'X                                 /* set hex '06' variable  */\nX07 = '07'X                                 /* set hex '07' variable  */\nX08 = '08'X                                 /* set hex '08' variable  */\nX09 = '09'X                                 /* set hex '09' variable  */\nX0A = '0A'X                                 /* set hex '0A' variable  */\nX0B = '0B'X                                 /* set hex '0B' variable  */\nX0C = '0C'X                                 /* set hex '0C' variable  */\nX0D = '0D'X                                 /* set hex '0D' variable  */\nX0E = '0E'X                                 /* set hex '0E' variable  */\nX0F = '0F'X                                 /* set hex '0F' variable  */\nX16 = '16'X                                 /* set hex '16' variable  */\nX19 = '19'X                                 /* set hex '19' variable  */\nX20 = '20'X                                 /* set hex '20' variable  */\nX22 = '22'X                                 /* set hex '22' variable  */\nX25 = '25'X                                 /* set hex '25' variable  */\nX26 = '26'X                                 /* set hex '26' variable  */\nX27 = '27'X                                 /* set hex '27' variable  */\nX28 = '28'X                                 /* set hex '28' variable  */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_P_ATTR:                              /* Create attributes    ##*/\nQueue \")PANEL KEYLIST(ISRSNAB,ISR)\"\nQueue \")ATTR DEFAULT(\"X01||X02||X03\") FORMAT(MIX)\"\nQueue \" 04 AREA(DYNAMIC) SCROLL(ON)    EXTEND(ON)\"\nQueue \" 05 TYPE(TEXT)    COLOR(BLUE)\"\nQueue \" 06 TYPE(DATAOUT) COLOR(BLUE)   INTENS(LOW)\"\nQueue \" 07 TYPE(DATAOUT) COLOR(GREEN)  INTENS(HIGH)\"\nQueue \" 08 TYPE(TEXT)    COLOR(WHITE)\"\nQueue \" 09 TYPE(TEXT)    COLOR(RED)\"\nQueue \" 0A TYPE(TEXT)    COLOR(GREEN)\"\nQueue \" 0B TYPE(DATAOUT) COLOR(WHITE)  INTENS(HIGH)\"\nQueue \" 0C TYPE(DATAOUT) COLOR(BLUE)   INTENS(HIGH)\"\nQueue \" 0D TYPE(DATAOUT) COLOR(GREEN)  INTENS(HIGH)\"\nQueue \" 0E TYPE(DATAOUT) COLOR(YELLOW) INTENS(HIGH)\"\nQueue \" 0F TYPE(DATAOUT) COLOR(RED)    INTENS(HIGH)\"\nQueue \" 20 TYPE(DATAIN)  COLOR(TURQ)   HILITE(USCORE)\"\nQueue \" 22 TYPE(TEXT)    COLOR(WHITE)  HILITE(REVERSE)\"\nQueue \" 25 TYPE(OUTPUT)  COLOR(TURQ)   JUST(RIGHT) CAPS(OFF)\"\nQueue \" 26 TYPE(INPUT)   COLOR(TURQ)   HILITE(USCORE)\"\nQueue \" 27 AREA(SCRL)    EXTEND(ON)\"\nQueue \" 28 TYPE(INPUT)   COLOR(RED)\"\nQueue \" 16 TYPE(VOI)     PADC(USER)\"      /* variable output info  TL */\nQueue \" 19 TYPE(DT)\"                      /* descriptive text      GL */\nQueue \")BODY  CMD(ZCMD)\"\nReturn 0\n/**********************************************************************/\nDEFINE_P_PROC:                              /* Create processing    ##*/\nQueue \")INIT\"                               /*                        */\nQueue \"&ZCMD = ' '\"                         /*                        */\nQueue \".CURSOR = 'ZCMD'\"                    /*                        */\nQueue \".HELP = \"help                        /*                        */\nQueue \"VGET (SSCL) ASIS\"                    /*                        */\nQueue \"IF (&SSCL = '')\"                     /*                        */\nQueue \" &SSCL = 'CSR'\"                      /*                        */\nQueue \")PROC\"                               /*                        */\nQueue \"VPUT (SSCL) PROFILE\"                 /*                        */\nQueue \")END\"                                /*                        */\nReturn 0\n/**********************************************************************/\nDEFINE_PANEL0:                              /* Create display 0     ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'PSPACE00'                         /* set panel name         */\nhelp   = 'TSPACE00'                         /* set help panel name    */\nCall DEFINE_P_ATTR\nQueue X0A||Centre(X05||\"Storage Information\"||X0A,78)||X0A\nQueue X0A||\"Command ===>\"||X26||Left(\"ZCMD\",71)||X0A\nQueue X0A||\" \"\nQueue X0A||\" \"\nQueue X0A||\"  The option you have selected will almost certainly take :\"\nQueue X0A||\" \"\nQueue X0A||\"  a) Quite a long time.\"\nQueue X0A||\"  b) Quite a lot of CPU.\"\nQueue X0A||\" \"\nQueue X0A||\"  You have been warned ...\"\nQueue X0A||\" \"\nQueue X0A||\"  Are you absolutely certain that you want to do it ?\"\nQueue X0A||\" \"\nQueue X0A||Centre(\"        Type\"X09\"YES\"X0A\"to continue. \",78)\nQueue X0A||\" \"\nQueue X0A||Centre(X08||\">>>>\"||X28||\"CHK\"||X08||\"<<<<\"||X0A,78)\nQueue X0A||\" \"\nQueue \")INIT\"                               /*                        */\nQueue \"&ZCMD = ' '\"                         /*                        */\nQueue \".CURSOR = 'CHK'\"                     /*                        */\nQueue \".HELP = \"help                        /*                        */\nQueue \")PROC\"                               /*                        */\nQueue \")END\"                                /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_PANEL1:                              /* Create display 1     ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'PSPACE01'                         /* set panel name         */\nhelp   = 'TSPACE01'                         /* set help panel name    */\nCall DEFINE_P_ATTR\nQueue X0A||Centre(X05||\"Storage Information\"||X0A,78)||X0A\ntext = X0A||\"Command ===>\"||X26||Left(\"ZCMD\",49)||X0A||\"Scroll ===>\"\nQueue text||X26||Left(\"SSCL\",4)||X0A\nQueue X25||\"ROWT\"\n/* ------------------------------------------------------------------ */\n/* text = X08||\"                      Vol   Total    Free  Pct\"       */\n/* Queue text||X22||\"0  1  2  3  4  5  6  7  8  9  1\"X08              */\n/* text = X08||\"S StoGroup              #    (Gb)    (Gb)  Usd\"       */\n/* Queue text||X22||\"0  0  0  0  0  0  0  0  0  0  0\"X08              */\n/* text = X08||\"_ ___________________ ___ _______ _______ ____\"       */\n/* Queue text||X22||\"+..+..+..+..+..+..+..+..+..+..0\"X08              */\ntext = X08||\"                      Vol   Total    Free   Percent Used\"\nQueue text||X0A||\"0 1 2 3 4 5 6 7 8 9 1\"X08\ntext = X08||\"S StoGroup              #   (GiB)   (GiB)  TRK  CYL  VOL\"\nQueue text||X0A||\"0 0 0 0 0 0 0 0 0 0 0\"X08\ntext = X08||\"_ ___________________ ___ _______ _______ ____ ____ ____\"\nQueue text||X0A||\"+.+.+.+.+.+.+.+.+.+.+\"X08\n/* ------------------------------------------------------------------ */\nQueue X04||\"DATA1\"Left(\"\",73)||X04\nCall DEFINE_P_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_PANEL2:                              /* Create display 2     ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'PSPACE02'                         /* set panel name         */\nhelp   = 'TSPACE02'                         /* set help panel name    */\nCall DEFINE_P_ATTR\nQueue X0A||Centre(X05||\"Storage Information - \"sel_group||X0A,78)||X0A\ntext = X0A||\"Command ===>\"||X26||Left(\"ZCMD\",49)||X0A||\"Scroll ===>\"\nQueue text||X26||Left(\"SSCL\",4)||X0A\nQueue X25||\"ROWT\"\n/* ------------------------------------------------------------------ */\n/*  text = X08||\"         Dev  Dev   Capa  Free  Cntg Frag  Pct\"      */\n/* Queue text||X22||\"0  1  2  3  4  5  6  7  8  9  1\"X08              */\n/* text = X08||\"S Volser Addr Type  (Gb)  (Gb)   Cyl Indx  Usd\"       */\n/* Queue text||X22||\"0  0  0  0  0  0  0  0  0  0  0\"X08              */\n/* text = X08||\"_ ______ ____ ____ _____ _____ _____ ____ ____\"       */\n/* Queue text||X22||\"+..+..+..+..+..+..+..+..+..+..0\"X08              */\ntext = X08||\"         Dev   Capa   Free  Cntg  Frag    Percent Used  \"\nQueue text||X0A||\"0 1 2 3 4 5 6 7 8 9 1\"X08\ntext = X08||\"S Volser Addr  (Gib)  (Gib)  Cyl  Indx  TRK   CYL   VOL \"\nQueue text||X0A||\"0 0 0 0 0 0 0 0 0 0 0\"X08\ntext = X08||\"_ ______ ____ ______ ______ _____ ____ _____ _____ _____\"\nQueue text||X0A||\"+.+.+.+.+.+.+.+.+.+.0\"X08\n/* ------------------------------------------------------------------ */\nQueue X04||\"DATA2\"Left(\"\",73)||X04\nCall DEFINE_P_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_PANEL3:                              /* Create display 3     ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'PSPACE03'                         /* set panel name         */\nhelp   = 'TSPACE03'                         /* set help panel name    */\nCall DEFINE_P_ATTR\nQueue X0A||Centre(X05||\"Storage Information - \"sel_volume||X0A,78)||X0A\ntext = X0A||\"Command ===>\"||X26||Left(\"ZCMD\",49)||X0A||\"Scroll ===>\"\nQueue text||X26||Left(\"SSCL\",4)||X0A\nQueue X25||\"ROWT\"\nSelect\n When (sel_v_char = 'C') Then\n  Do\n   text = X08||\"S Dataset Name                                 Volser\"\n   Queue text||\" Catalog\"X08\n   text = X08||\"_ ____________________________________________ ______\"\n   Queue text||\" ____________________________\"X08\n  End\n When (sel_v_char = 'D') Then\n  Do\n   text = X08||\"                                              \"\n   Queue text||\"           Space                 \"\n   text = X08||\"S Dataset Name                                \"\n   Queue text||\" DSrg RecF (trks) Xt  Blksz Lrecl\"\n   text = X08||\"_ ____________________________________________\"\n   Queue text||\" ____ ____ ______ ___ _____ _____\"X08\n  End\n When (sel_v_char = 'V') Then\n  Do\n   text = X08||\"                                              \"\n   Queue text||\" Space               \"\n   text = X08||\"S Dataset Name                                \"\n   Queue text||\" (trks) Xt  V# Volser\"\n   text = X08||\"_ ____________________________________________\"\n   Queue text||\" ______ ___ __ ______\"X08\n  End\n Otherwise NOP\nEnd\nQueue X04||\"DATA3\"Left(\"\",73)||X04\nCall DEFINE_P_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_T_ATTR:                              /* Create attributes    ##*/\nQueue \")PANEL KEYLIST (ISRHELP ISR)\"\nQueue \")ATTR\"\nQueue \"   % TYPE(ET)\"\nQueue \"   _ TYPE(NEF) PAD(USER) CAPS(ON)\"\nQueue \"   + TYPE(NT)\"\nQueue \"   # TYPE(SAC)\"\nQueue \"   $ TYPE(OUTPUT) JUST(RIGHT) INTENS(HIGH)\"\nQueue \")BODY CMD(ZCMD)\"\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_T_PROC:                              /* Create processing    ##*/\nQueue \")INIT\"\nQueue \"&ZCMD = ' '\"\nQueue \")PROC\"\nQueue \"&ZUP = TSPACE00\"\nQueue \")END\"\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_TUTOR0:                              /* Create tutorial 1    ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'TSPACE00'                         /* set panel name         */\nCall DEFINE_T_ATTR\nQueue \"%Tutorial \"||Centre(\"Storage Information\",62)||\"Tutorial%\"\nQueue \"%\"||Left(\"Option  ===>_ZCMD\",78)||\"+\"\nQueue \"% \"\nQueue \"%       This utility displays SMS storage groups and/or volume\"\nQueue \"%       detail for the system it is executed on.\"\nQueue \"% \"\nQueue \"%       It may be invoked using#\"PGM_NAME\"%which will display all SMS\"\nQueue \"%       storage groups on the system, together with the group of\"\nQueue \"%       non-SMS volumes on the system.\"\nQueue \"% \"\nQueue \"%       For a subset of volumes, invoke as#\"PGM_NAME\" VOLUME(volser)%\"\nQueue \"%                                         #\"PGM_NAME\" VOL(volser)%\"\nQueue \"%                                         #\"PGM_NAME\" V(volser)%\"\nQueue \"%                                       or#\"PGM_NAME\" V(vols-1,vols-2)%\"\nQueue \"% \"\nQueue \"%                                       or#\"PGM_NAME\" POOL(sgname)%\"\nQueue \"%                                         #\"PGM_NAME\" P(sgname)%\"\nQueue \"% \"\n/*Queue \"%       Wildcarding can be used e.g. *vol *vol* vol*\" */\nQueue \"%       Wildcarding can be used for volume selection :#*vol *vol* vol*%\"\nQueue \"%       Wildcards with POOL is allowed but slow. \"\nQueue \"%       Better use multiple SG names like#P(sgnam1,sgnam2,sgnam3)%\"\nQueue \"% \"\nQueue \"%       Type#REFRESH%to refresh the display\"\nCall DEFINE_T_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_TUTOR1:                              /* Create tutorial 1    ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'TSPACE01'                         /* set panel name         */\nCall DEFINE_T_ATTR\nQueue \"%Tutorial \"||Centre(\"Storage Information\",62)||\"Tutorial%\"\nQueue \"%\"||Left(\"Option  ===>_ZCMD\",78)||\"+\"\nQueue \"% \"\nQueue \"%       This panel displays all of the SMS Storage Groups available\"\nQueue \"%       on the system together with their volume count and usage.\"\nQueue \"% \"\nQueue \"%       Options available are :\"\nQueue \"% \"\nQueue \"%      #C%Catalog status\"\nQueue \"%      #D%Dataset Allocation Details\"\nQueue \"%      #S%Volume details (includes capacity/usage details)\"\nQueue \"%      #V%Dataset Space/Xt/Volume/Volseq details\"\nQueue \"% \"\nQueue \"%       The display can be sorted using#SORT field A/D%.\"\nQueue \"%       Valid fields are :\"\nQueue \"%      #STOGROUP VOL TOTAL FREE PTRK PCYL PVOL%\"\n/* Queue \"%      #STOGROUP VOL TOTAL FREE PCT%\"                       */\nQueue \"% \"\nQueue \"%       PTRK := Usage of Track Managed Space (EAV and non-EAV)\"\nQueue \"%       PCYL := Usage of Cylinder Managed Space only (EAV)\"\nQueue \"%       PVOL := Usage of whole volume \"\nQueue \"% \"\nQueue \"%       Type#REFRESH%to refresh the display\"\nCall DEFINE_T_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_TUTOR2:                              /* Create tutorial 2    ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'TSPACE02'                         /* set panel name         */\nCall DEFINE_T_ATTR\nQueue \"%Tutorial \"||Centre(\"Storage Information\",62)||\"Tutorial%\"\nQueue \"%\"||Left(\"Option  ===>_ZCMD\",78)||\"+\"\nQueue \"% \"\nQueue \"%       Displays all of the volumes defined in a selected SMS Storage\"\nQueue \"%       Group together with their capacity and usage details.\"\nQueue \"% \"\nQueue \"%       Options available are :\"\nQueue \"% \"\nQueue \"%      #C%Catalog status\"\nQueue \"%      #D%Dataset Allocation Details\"\nQueue \"%      #S%Normal '3.4' display\"\nQueue \"%      #V%Dataset Space/Xt/Volume/Volseq details\"\nQueue \"% \"\nQueue \"%       The display can be sorted using#SORT field A/D%.\"\nQueue \"% \"\nQueue \"%       Valid fields are :\"\nQueue \"% \"\nQueue \"%      #VOLSER ADDR CAPA FREE CNTG FRAG PTRK PCYL PVOL\"\n/*Queue \"%      #VOLSER ADDR TYPE CAPA FREE CNTG FRAG PCT\" */\nQueue \"% \"\nQueue \"%       Type#REFRESH  %to refresh the display\"\nQueue \"%       Type#FULLC/D/V%to list ALL datasets in the pool\"\nCall DEFINE_T_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nDEFINE_TUTOR3:                              /* Create tutorial 3    ##*/\n\"NewStack\"                                  /* Create new stack       */\nmember = 'TSPACE03'                         /* set panel name         */\nCall DEFINE_T_ATTR\nQueue \"%Tutorial \"||Centre(\"Storage Information\",62)||\"Tutorial%\"\nQueue \"%\"||Left(\"Option  ===>_ZCMD\",78)||\"+\"\nQueue \"% \"\nQueue \"%       Displays all of the datasets on selected volume/s.\"\nQueue \"% \"\nQueue \"%       Together with either their allocation details, their \"\nQueue \"%       space utilisation or their catalog status.\"\nQueue \"% \"\nQueue \"%       For all, the options available are :\"\nQueue \"% \"\nQueue \"%      #B%Browse\"\nQueue \"%      #E%Edit\"\nQueue \"%      #S%Edit\"\nQueue \"%      #V%View\"\nQueue \"% \"\nQueue \"%       The display can be sorted using#SORT field A/D%.\"\nQueue \"% \"\nQueue \"%       Valid fields are :\"\nQueue \"% \"\nQueue \"%      #DATASET VOLSER CATALOG DSRG RECF SPACE XT BLKSZ LRECL\"\nCall DEFINE_T_PROC\nReturn 0                                    /*                        */\n/**********************************************************************/\nCREATE_PDS:                                 /* Create Member in PDS   */\nDo loop = 1 To 50                           /* loop thru up to 50     */\n fil = 'DYNAM'||loop                        /*  build filename        */\n x = Listdsi(fil FILE)                      /*  test filename         */\n If (sysreason > 0) Then                    /*  if not present        */\n  Leave                                     /*   use it !             */\nEnd                                         /* end loop               */\nAddress TSO                                 /* set address            */\n\"Alloc Fi(\"fil\") \",                         /* Allocate dyamic        */\n      \"Lrecl(80) Blksize(0) RecFm(F B) \",   /*  dataset to selected   */\n      \"Cylinders Space(1,1) \",              /*   filename             */\n      \"Unit(SYSDA) Dir(20) New Reu\"         /*                        */\nX = Listdsi(fil FILE)                       /* get the file details   */\nReturn 0                                    /*                        */\n/**********************************************************************/\nCREATE_MEMBER:                              /* Create Member in PDS   */\nstack = Queued()                            /*   get stack size       */\nIf (stack > 0) Then                         /*   if data on stack     */\n Do                                         /*                        */\n  \"Alloc Fi(MEMOUT) Shr Reu \",              /*    create member       */\n        \"Da('\"sysdsname\"(\"member\")')\"       /*                        */\n  \"ExecIO \"stack\" DiskW MEMOUT (Finis)\"     /*    write stack > member*/\n  \"Free Fi(MEMOUT)\"                         /*    free member         */\n End                                        /*                        */\n/* Debug code\nAddress ISPEXEC \"Edit Dataset('\"sysdsname\"') Volume(\"sysvolume\")\"\n*/\n\"DelStack\"                                  /* Clear stack            */\nReturn 0                                    /*                        */\n/**********************************************************************/\nDATA_SORT:                                  /*                      ##*/\nscnt = 0                                    /*                        */\nlast_rec = (Length(data)-sort_leng)+1       /* calculate last record  */\nDo pass = 1 To last_rec By sort_leng        /*                        */\n scnt = scnt + 1                            /*                        */\n sort.scnt = Substr(data,pass,sort_leng)    /*                        */\nEnd                                         /*                        */\nAddress TSO                                 /*                        */\nIf (sort_parm = '') Then                    /*                        */\n sysin.1 = '  SORT FIELDS=(1,20,CH,A)'      /*                        */\nElse                                        /*                        */\n sysin.1 = '  SORT FIELDS=('sort_parm')'    /*                        */\n\"Alloc Fi(SYSIN)   Space(1 1) Cylinders Unit(3390) \",\n                             \"Lrecl(80) Blksize(0) New Reu\"\n\"ExecIO 1 DiskW SYSIN (Finis Stem sysin.)\"\n\"Alloc Fi(SORTIN)  Space(1 1) Cylinders Unit(3390) \",\n                             \"Lrecl(\"sort_leng\") Blksize(0) New Reu\"\n\"ExecIO \"scnt\" DiskW SORTIN (Finis Stem sort.)\"\n/* Debug code\nX = Listdsi(SORTIN FILE)                    /* get the file details   */\nAddress ISPEXEC \"Edit Dataset('\"sysdsname\"') Volume(\"sysvolume\")\"\n*/\n\"Alloc Fi(SORTOUT) Space(1 1) Cylinders Unit(3390) \",\n                             \"Lrecl(\"sort_leng\") Blksize(0) New Reu\"\n\"Alloc Fi(SYSOUT)  Space(1 1) Cylinders Unit(3390) \",\n                             \"Lrecl(80) Blksize(0) New Reu\"\nAddress ATTCHMVS \"SORT\"                     /*                        */\n\"ExecIO * DiskR SORTOUT (Finis Stem sort.)\" /*                        */\n\"Free Fi(SORTIN SORTOUT SYSIN SYSOUT)\"      /*                        */\ndata = ''                                   /*                        */\nover = ''                                   /* 'overspill' variable   */\nIf (sort_leng = 80) Then                    /*                        */\n Do pass = 1 To scnt                        /*                        */\n  data = data||sort.pass                    /*                        */\n End                                        /*                        */\nElse                                        /*                        */\n Do pass = 1 to scnt                        /*                        */\n  data = data||Substr(sort.pass,1,80)       /*                        */\n  over = over||Substr(sort.pass,81)         /* capture 'overspill'    */\n End                                        /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\nSORT_DECODE:                                /* decode sort parms    ##*/\nfld = Word(zcmd,2)                          /*                        */\nord = Word(zcmd,3)                          /*                        */\nplc = WordPos(fld,disp_pat)                 /*                        */\nIf (plc = 0) Then                           /*                        */\n Do                                         /*                        */\n  If (fld /= '') Then                       /*                        */\n   Do                                       /*                        */\n    zerralrm = 'YES'                        /*                        */\n    zerrhm = 'TSPACE00'                     /*                        */\n    zerrsm = 'Not a valid name'             /*                        */\n    zerrlm = field' not a valid name, reselect and try again.' /*      */\n    Address ISPEXEC \"Setmsg Msg(ISRZ002)\"   /* general error messageid*/\n   End                                      /*                        */\n  Else                                      /*                        */\n   sort_parm = ''                           /*                        */\n End                                        /*                        */\nElse                                        /*                        */\n Do                                         /*                        */\n  col = Wordindex(disp_pat,plc)             /*                        */\n  nex = Wordindex(disp_pat,plc+1)-1         /*                        */\n  len = nex-col                             /*                        */\n  If (ord /= 'D') &,                        /*                        */\n     (ord /= 'A') Then                      /*                        */\n   ord = 'A'                                /*                        */\n  sort_parm = col','len',CH,'ord            /*                        */\n End                                        /*                        */\nReturn 0                                    /*                        */\n/**********************************************************************/\n/**********************************************************************/\n/* CSICODE : Uses Catalog Search Interface (CSI)                      */\n/**********************************************************************/\nCSICODE:                             /* CSI processing              ##*/\n/**********************************************************************/\n/* Initialise the relevant CSI variables                              */\n/**********************************************************************/\ncat.1 = ' '                          /* Set catalog name              */\nflt   = filter                       /* Set the filter                */\ntyp   = ' '                          /* Set entry types required      */\nct1   = ' '                          /* Set for 1 catalog only        */\n/**********************************************************************/\n/* Initialise the various totals variables                            */\n/**********************************************************************/\nCall TOT_INIT                        /* Initialise totals             */\n/**********************************************************************/\n/* CSI Processing section                                             */\n/**********************************************************************/\nx = CSI(cat.1,flt,typ,ct1)           /* Call CSI procedure            */\n/**********************************************************************/\nReturn 0                             /* Return                        */\n/**********************************************************************/\n/**********************************************************************/\n\n/**********************************************************************/\n/**********************************************************************/\nCSI:                                 /* CSI procedure start         ##*/\nArg cat,flt,typ,ct1                  /* get passed arguments          */\n/**********************************************************************/\n/* Initialise the parameter list                                      */\n/**********************************************************************/\nmodrsnrc = Substr(' ',1,4)           /* clear module/return/reason    */\ncsifiltk = Substr(flt,1,44)          /* move filter key into list     */\ncsicatnm = Substr(cat,1,44)          /* clear catalog name            */\ncsiresnm = Substr(' ',1,44)          /* clear resume name             */\ncsidtyps = Substr(typ,1,16)          /* clear entry types             */\ncsicldi  = Substr('Y',1,1)           /* indicate data and index       */\ncsiresum = Substr(' ',1,1)           /* clear resume flag             */\ncsis1cat = Substr(ct1,1,1)           /* indicate search > 1 catalogs  */\n/**********************************************************************/\nbcp = mvsvar('sysmvs')               /*                               */\nlev = Substr(bcp,3,1)||Substr(bcp,5,1)||Substr(bcp,7,1) /*            */\nIf (lev > 609) Then                  /* os/390 R10 and up for fullword*/\n csioptns = Substr('F',1,1)          /*'F'for fullword,' 'for halfword*/\nElse                                 /*                               */\n csioptns = Substr(' ',1,1)          /*'F'for fullword,' 'for halfword*/\n/**********************************************************************/\n/* Initialise requested fields                                        */\n/**********************************************************************/\ncsinumen = '0006'X                   /* init number of fields         */\ncsifld01 = Left('ENTYPE  ',8)        /* type of entry                 */\ncsifld02 = Left('ENTNAME ',8)        /* name of entry                 */\ncsifld03 = Left('TYPE    ',8)        /* type of associated entry      */\ncsifld04 = Left('NAME    ',8)        /* name of associated entry      */\ncsifld05 = Left('VOLSER  ',8)        /* Volume serial number          */\ncsifld06 = Left('FILESEQ ',8)        /* File Sequence number          */\n/**********************************************************************/\n/* Build the selection criteria fields part of parameter list         */\n/**********************************************************************/\ncsiopts  = csicldi ||csiresum||csis1cat||csioptns\ncsifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen\ncsifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05\ncsifield = csifield||csifld06\n/**********************************************************************/\n/* Initialise and build work are output part of parameter list        */\n/**********************************************************************/\ncsiusrln = 524288                    /* CSIUSRLN work area length     */\n                                     /* range from 1024 to 1048575    */\ndwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)\n/**********************************************************************/\n/* Initialise work variables                                          */\n/**********************************************************************/\ncsiresum = 'Y'\n/**********************************************************************/\n/* Set up loop for resume (if a resume is necessary)                  */\n/**********************************************************************/\nDo While csiresum = 'Y'\n/**********************************************************************/\n/* Issue link to CSI - Catalog Search Interface                       */\n/**********************************************************************/\n Address LinkPGM 'IGGCSI00 modrsnrc csifield dwork'\n r15 = rc                            /* get returned code             */\n mod = Substr(modrsnrc,1,2)          /* get module code               */\n res = C2d(Substr(modrsnrc,3,1))     /* get return code               */\n ret = C2d(Substr(modrsnrc,4,1))     /* get reason code               */\n If (r15 > 0) Then                   /* when error occured            */\n  Do\n   Say '**(Error-1)* CSI processing.'\n   Say '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res\n  End\n/**********************************************************************/\n csiresum = Substr(csifield,150,1)   /* Get resume flag for next loop */\n csiresnm = Substr(csifield,89,44)   /* Get resume name for next loop */\n csiusrln = C2D(Substr(dwork,1,4))   /* Get length of work area       */\n csireqln = C2D(Substr(dwork,5,4))   /* Get length of work area reqd  */\n csiusdln = C2D(Substr(dwork,9,4))   /* Get length of work area used  */\n If (csireqln > csiusrln) Then       /*                               */\n  Do                                 /*                               */\n   Say '**(Error-1)* Work Area defined  = 'csiusrln\n   Say '**(Error-2)* Work Area used     = 'csiusdln\n   Say '**(Error-3)* Work Area required = 'csireqln\n   Say '**(Error-4)* Increase the work area defined - CSIUSRLN.'\n  End                                /*                               */\n If (csiusdln < 65) Then Leave       /* No entries returned           */\n off = 15                            /* Starting position             */\n/**********************************************************************/\n/* Process data returned in work area                                 */\n/**********************************************************************/\n Do While off < csiusdln             /* do until all data is processed*/\n  csi_flag = Substr(dwork,off,1)     /* get the flag byte             */\n  csi_type = Substr(dwork,off+1,1)   /* get the entry type            */\n  csi_name = Substr(dwork,off+2,44)  /* get the entry name            */\n  csi_retn = Substr(dwork,off+46,4)  /* get the return code           */\n  mod = Substr(csi_retn,1,2)         /* get CSI module                */\n  res = C2d(Substr(csi_retn,3,1))    /* get reason code               */\n  ret = C2d(Substr(csi_retn,4,1))    /* get return code               */\n  If (csi_type = '0') Then           /* Catalog entry                 */\n   Do                                /*                               */\n    If (ret > 0) Then                /* test catalog return code      */\n     Do\n      Say '**(Error-1)* Catalog processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n     End\n    csicname = csi_name              /* set the catalog name          */\n    plus = 50                        /* length for catalog entry      */\n   End                               /*                               */\n  Else                               /*                               */\n   Do                                /*                               */\n    csiename = csi_name              /* use the entry name            */\n    csietype = csi_type              /* use the entry name            */\n    csieflag = X2b(C2x(csi_flag))    /* use the entry flag            */\n    csienter = Substr(csieflag,2,1)  /* get the entry error flag      */\n    csiedata = Substr(csieflag,3,1)  /* get the data indication flag  */\n    If (csioptns = 'F') Then         /* check if fullword requested   */\n     csitotln = C2d(Substr(csi_retn,1,4))/* get entry total length    */\n    Else                             /* otherwise (default halfword)  */\n     csitotln = C2d(Substr(csi_retn,1,2))/* get entry total length    */\n    If (csienter = '1') Then         /* entry error                   */\n     Do\n      Say '**(Error-1)* Entry processing - 'Strip(csi_name,B)'.'\n      Say '**(Error-2)* Module='mod' Return='ret' Reason='res\n      plus = 50                      /* length for error entry        */\n     End\n    Else                             /*                               */\n     Do                              /*                               */\n      Call ENTRY                     /* Execute entry processing      */\n      plus = 46 + csitotln           /* length for normal entry       */\n     End                             /*                               */\n   End                               /*                               */\n/**********************************************************************/\n/*                                                                    */\n/**********************************************************************/\n   Call DATA_HANDLING                /*                               */\n/**********************************************************************/\n/* increment for next entry                                           */\n/**********************************************************************/\n  off = off + plus                   /* build new offset              */\n End                                 /*                               */\nEnd                                  /*                               */\n/**********************************************************************/\n/* Complete CSI Procedure                                             */\n/**********************************************************************/\nReturn 0                             /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* Process entry fields to extract data                               */\n/**********************************************************************/\nENTRY:                               /* Start entry processing      ##*/\n/**********************************************************************/\n/* entry field size and location extraction                           */\n/**********************************************************************/\nIf (csioptns = 'F') Then             /* check if fullword requested   */\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+8,4)) /* get first field length    */\n  e_pos = 12                         /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,4)) /* get next length   */\n   e_pos = e_pos + 4                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\nElse                                 /* otherwise (default halfword)  */\n/**********************************************************************/\n Do                                  /* field length length of 4      */\n  e_off = off + 46                   /* get offset to entries         */\n  o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset        */\n  l_fld.1 = C2d(Substr(dwork,e_off+4,2)) /* get first field length    */\n  e_pos = 6                          /* set offset of second field    */\n  If (debug = 1) Then                /*                               */\n   Do                                /*                               */\n    Say \"e_off=\"e_off                /*                               */\n    Say \"C=<\"Substr(dwork,e_off,200)\">\" /*                            */\n    Say \"X=<\"C2x(Substr(dwork,e_off,200))\">\" /*                       */\n    Say \"o_fld.1=\"o_fld.1\",hex=\"C2x(o_flds.1) /*                      */\n    Say \"l_fld.1=\"l_fld.1\",hex=\"C2x(l_flds.1) /*                      */\n   End                               /*                               */\n  Do flds = 2 to C2d(csinumen)       /* loop through other fields     */\n   prv = flds - 1                    /* set 'previous' value          */\n   o_fld.flds = o_fld.prv + l_fld.prv/* get next offset               */\n   l_fld.flds = C2d(Substr(dwork,e_off+e_pos,2)) /* get next length   */\n   e_pos = e_pos + 2                 /*                               */\n   If (debug = 1) Then               /*                               */\n    Do                               /*                               */\n     Say \"o_fld.\"flds\"=\"o_fld.flds\",hex=\"C2x(o_flds.flds) /*          */\n     Say \"l_fld.\"flds\"=\"l_fld.flds\",hex=\"C2x(l_flds.flds) /*          */\n    End                              /*                               */\n  End                                /*                               */\n End                                 /*                               */\n/**********************************************************************/\n/* entry field extraction                                             */\n/**********************************************************************/\nentype   = Substr(dwork,o_fld.1,l_fld.1)   /* Type of entry           */\nentname  = Substr(dwork,o_fld.2,l_fld.2)   /* Name of entry           */\ntype     = Substr(dwork,o_fld.3,l_fld.3)   /* Type of assc entry      */\nname     = Substr(dwork,o_fld.4,l_fld.4)   /* Name of assc entry      */\nvolser   = Substr(dwork,o_fld.5,l_fld.5)   /* volume serial           */\nfileseq  = Substr(dwork,o_fld.6,l_fld.6)   /* file sequence           */\n/**********************************************************************/\n/* entry re-processing section                                        */\n/**********************************************************************/\nIf (Index(csifield,'ENTYPE') > 0) Then   /*                           */\n Call FLD_ENTYPE                         /*                           */\nIf (Index(csifield,'ENTNAME') > 0) Then  /*                           */\n Call FLD_ENTNAME                        /*                           */\nIf (Index(csifield,'FILESEQ') > 0) Then  /*                           */\n Call FLD_FILESEQ                        /*                           */\nIf (Index(csifield,'VOLSER') > 0) Then   /*                           */\n Call FLD_VOLSER                         /*                           */\n/**********************************************************************/\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTYPE   - Process ENTYPE   field                              */\n/**********************************************************************/\nFLD_ENTYPE:                          /* ENTYPE   field processing   ##*/\nSelect                               /* decode type flag              */\n When (entype = 'C') Then entype = 'CLUSTER'  /*                      */\n When (entype = 'D') Then entype = 'DATA'     /*                      */\n When (entype = 'I') Then entype = 'INDEX'    /*                      */\n When (entype = 'A') Then entype = 'NONVSAM'  /*                      */\n When (entype = 'H') Then entype = 'GDS'      /*                      */\n When (entype = 'B') Then entype = 'GDG'      /*                      */\n When (entype = 'R') Then entype = 'PATH'     /*                      */\n When (entype = 'G') Then entype = 'AIX'      /*                      */\n When (entype = 'X') Then entype = 'ALIAS'    /*                      */\n When (entype = 'U') Then entype = 'UCAT'     /*                      */\n Otherwise                           /*                               */\n  Say '**(Error-1)* Entry type processing for 'Strip(entname,T)\n  Say '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'\n  entype = ' '                       /* unknown type                  */\nEnd                                  /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_ENTNAME  - Process ENTNAME  field                              */\n/**********************************************************************/\nFLD_ENTNAME:                         /* ENTNAME  field processing   ##*/\nIf (Substr(entname,1,2) = '0000'x) Then /* If blank dsname            */\n entname = Left(C2x(entname),44)     /* Return hex value              */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_VOLSER   - Process VOLSER   field                              */\n/**********************************************************************/\nFLD_VOLSER:                          /* VOLSER   field processing   ##*/\nvolsers = ''                         /*                               */\nDo v_pos = 1 To Length(volser) By 6  /*                               */\n volume = Substr(volser,v_pos,6)     /*                               */\n If (Substr(volume,1,2) = '00'x) Then/*                               */\n  volume = '000000'                  /*                               */\n volume = Right(Strip(volume,B),6)' '/*                               */\n volsers = volsers||'  '||volume     /*                               */\nEnd                                  /*                               */\nvolser = Strip(volsers,B)            /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* FLD_FILESEQ  - Process FILESEQ  field                              */\n/**********************************************************************/\nFLD_FILESEQ:                         /* FILESEQ  field processing   ##*/\nbuild = ''                           /*                               */\nDo f_pos = 1 To Length(fileseq) By 2 /*                               */\n build = build||Right(X2d(C2x(Substr(fileseq,f_pos,2))),8)||' '\nEnd                                  /*                               */\nfileseq = build                      /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* TOT_INIT - Initialise the various totals variables                 */\n/**********************************************************************/\nTOT_INIT:                            /* Initialise totals variables ##*/\nl_cnt   = 0                          /* Initialise output line count  */\nReturn                               /*                               */\n/**********************************************************************/\n\n/**********************************************************************/\n/* DATA_HANDLING - Carry out whatever processing is required ...      */\n/**********************************************************************/\nDATA_HANDLING:                       /* 'Handle' the data produced  ##*/\nIf (csi_type = '0') Then             /* Catalog entries               */\n Do                                  /*                               */\n End                                 /*                               */\nElse                                 /* Non-Catalog entries           */\n Do                                  /*                               */\n  If (Pos(cat_volume,volser) > 0) Then /* If volser matches selected  */\n   Do                                /*                               */\n    dsn_cat.entname = csicname       /*  set catalog for dataset      */\n   End                               /*                               */\n  If (Pos('&',volser) > 0) Then      /* check for system symbolic     */\n   Do                                /*                               */\n    Do syms = 1 to Words(volser)     /*                               */\n     symchk = Word(volser,syms)      /*                               */\n     symres = MvsVar('SYMDEF',Strip(symchk,B,'&')) /*                 */\n     If (cat_volume = symres) Then   /*                               */\n      Do                             /*                               */\n       dsn_cat.entname = csicname    /*  set catalog for dataset      */\n       Leave                         /*                               */\n      End                            /*                               */\n    End                              /*                               */\n   End                               /*                               */\n End                                 /*                               */\nReturn                               /*                               */\n/**********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SWAREQ22": {"ttr": 8964, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00\\x07\\x01\\x15'_\\x01\\x185?\\x13$\\x00?\\x00P\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2015-10-02T00:00:00", "modifydate": "2018-12-19T13:24:07", "lines": 63, "newlines": 80, "modlines": 0, "user": "SBGOLOB"}, "text": "/*---- REXX ---- */ /*------------------------------------------------*\\\n|*                                                                    *|\n|* MODULE NAME = SWAREQ                                               *|\n|*                                                                    *|\n|* DESCRIPTIVE NAME = Convert an SVA to a 31-bit address              *|\n|*                                                                    *|\n|* STATUS = R200                                                      *|\n|*                                                                    *|\n|* FUNCTION = The SWAREQ function simulates the SWAREQ macro to       *|\n|*            convert an SWA Virtual Address (SVA) to a full 31-bit   *|\n|*            address which can be used to access SWA control blocks  *|\n|*            in the SWA=ABOVE environment.  The input is a 3-byte    *|\n|*            SVA; the output value is a 10-digit decimal number.     *|\n|*                                                                    *|\n|* AUTHOR   =  Gilbert Saint-Flour                                    *|\n|*             email:  Carlos Aguilera <carlos@gsf-soft.com>          *|\n|*                                                                    *|\n|* DEPENDENCIES = TSO/E V2                                            *|\n|*                                                                    *|\n|* SYNTAX   =  SWAREQ(sva)                                            *|\n|*                                                                    *|\n|*             sva must contain a 3-byte SVA.                         *|\n|*                                                                    *|\n|* Sample Invocation:                                                 *|\n|*                                                                    *|\n|*    NUMERIC DIGITS 10                                               *|\n|*    tcb = C2D(STORAGE(21C,4))         /* TCB          PSATOLD  */   *|\n|*    tiot= C2D(STORAGE(D2X(tcb+12),4)) /* TIOT         TCBTIO   */   *|\n|*    sva = STORAGE(D2X(tiot+36),3)     /* First JFCB   TIOEJFCB */   *|\n|*    jfcb=SWAREQ(sva)             /* convert SVA to 31-bit addr */   *|\n|*    dsn=STORAGE(D2X(jfcb),44)         /* dsname       JFCBDSNM */   *|\n|*    vol=STORAGE(D2X(jfcb+118),6)      /* volser       JFCBVOLS */   *|\n|*    SAY 'sva='C2X(sva) 'jfcb='D2X(jfcb) 'dsn='dsn 'vol='vol         *|\n|*                                                                    *|\n\\*--------------------------------------------------------------------*/\n/*SWAREQ: PROCEDURE */\nNUMERIC DIGITS 20                         /* allow up to 2**64    */\nsva=C2D(ARG(1))                           /* convert to decimal   */\ntcb = C2D(STORAGE(21C,4))                 /* TCB         PSATOLD  */\njscb = C2D(STORAGE(D2X(tcb+180),4))       /* JSCB        TCBJSCB  */\nqmpl = C2D(STORAGE(D2X(jscb+244),4))      /* QMPL        JSCBQMPI */\n/* See if qmat can be above the bar */\nqmsta= C2X(STORAGE(D2X(qmpl+16),1))       /* JOB STATUS BYTE      */\nif SUBSTR(X2B(qmsta),6,1) then            /* is QMQMAT64 bit on?  */\ndo                                        /* yes, qmat can be ATB */\n  IF RIGHT(X2B(C2X(ARG(1))),1) \\= '1' THEN/* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                 /* yes, return sva+16   */\n  qmat=C2D(STORAGE(D2X(qmpl+10),2))*(2**48) +,/* QMAT+0  QMADD01  */\n       C2D(STORAGE(D2X(qmpl+18),2))*(2**32) +,/* QMAT+2  QMADD23  */\n       C2D(STORAGE(D2X(qmpl+24),4))       /* QMAT+4      QMADD    */\n  RETURN C2D(STORAGE(D2X(qmat+(sva*12)+64),4))+16\nend\nelse\ndo                                        /* no, qmat is BTB      */\n  IF RIGHT(C2X(ARG(1)),1) \\= 'F' THEN     /* SWA=BELOW ?          */\n    RETURN C2D(ARG(1))+16                 /* yes, return sva+16   */\n  qmat = C2D(STORAGE(D2X(qmpl+24),4))     /* QMAT        QMADD    */\n  DO WHILE sva>65536\n    qmat = C2D(STORAGE(D2X(qmat+12),4))   /* next QMAT   QMAT+12  */\n    sva=sva-65536                         /* 010006F -> 000006F   */\n  END\n  RETURN C2D(STORAGE(D2X(qmat+sva+1),4))+16\nend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SYSINF": {"ttr": 8966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01&\\x00P\\x00\\x95)\\x8f\\x01\\x03\\x06/\\x10)\\x05S\\x00l\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.38", "flags": 0, "createdate": "1995-10-25T00:00:00", "modifydate": "2003-03-03T10:29:50", "lines": 1363, "newlines": 108, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - SYSINF : Displays sundry IPL info. etc.                     */\n/**********************************************************************/\n/* SYSINF - Gets a variety of system and user information.            */\n/*                                                                    */\n/* Based on an original Gray/Eastoe production in REXXOVISION called  */\n/* IPLINF and sundry other sources - especially reading the data area */\n/* manuals.                                                           */\n/*                                                                    */\n/* Changes :                                                          */\n/* 03/11/1995 - AJG - Initial version (with added RichE power !)      */\n/* 14/06/1996 - AJG - First full rewrite                              */\n/* 19/05/1999 - AJG - Updated with various new bits                   */\n/* 08/10/1999 - AJG - Added SWAREQ from Gilbert Saint-Flour           */\n/* 25/10/1999 - AJG - Added PRSM logical partition number             */\n/* 27/10/1999 - AJG - Added HID information                           */\n/* 04/01/2000 - AJG - Added user region size                          */\n/* 05/01/2000 - AJG - Imbedded the required panel                     */\n/* 07/01/2000 - AJG - Added Newstack/Delstack                         */\n/* 07/02/2000 - AJG - Allowed for multiple PARMLIBs                   */\n/* 07/02/2000 - AJG - Added Master JCL query/display                  */\n/* 06/05/2000 - AJG - other way for JOBNAME added                     */\n/* 18/07/2000 - AJG - Added performance/charging details              */\n/* 09/10/2001 - AJG - Added TCP/IP details                            */\n/* 17/10/2001 - AJG - Updated IPL time calculation and added UPTIME   */\n/* 18/10/2001 - AJG - Changed leap year calculation                   */\n/* 01/11/2001 - AJG - Added '()' removal for master JCL parm          */\n/* 09/01/2002 - AJG - Corrected elapsed time since IPL leapyear calc  */\n/* 28/02/2002 - AJG - Changed to a new dynamically built panel        */\n/* 01/03/2002 - AJG - Added a few new bits                            */\n/* 05/03/2002 - AJG - Added IEASYS parm details                       */\n/* 13/03/2002 - AJG - Added RACF group details                        */\n/* 15/03/2002 - AJG - Display if a group is revoked                   */\n/* 19/03/2002 - AJG - Change RACF groups to 5 per line                */\n/* 26/03/2002 - AJG - Added susbsystem command prefixes               */\n/* 27/03/2002 - AJG - Changed to procedures and tidied ipl/uptime     */\n/* 05/04/2002 - AJG - Corrected JES name                              */\n/* 12/04/2002 - AJG - Fixed the problem with the &env in master JCL   */\n/* 07/05/2002 - AJG - Added logon command                             */\n/* 22/05/2002 - AJG - Added HSA enquiry section                       */\n/* 12/07/2002 - AJG - Added user storage detail                       */\n/* 17/02/2003 - AJG - Added JES variation by MVS fmid                 */\n/*                                                                    */\n/**********************************************************************/\nNumeric Digits 25\n/**********************************************************************/\n/* Obtain information                                                 */\n/**********************************************************************/\nCall PROC_ADDR                              /* Address space info     */\nCall PROC_USER                              /* RACF user details      */\nCall PROC_ACCOUNT                           /* account detail         */\nCall PROC_REGION                            /* region detail          */\nCall PROC_JOB                               /* job detail             */\nCall PROC_MCAT                              /* mastercat detail       */\nCall PROC_IEASYS                            /* IEASYSxx details       */\nCall PROC_RACF                              /* RACF details           */\nCall PROC_IPLTIMES                          /* IPL time details       */\nCall PROC_IPL                               /* IPL details            */\nCall PROC_IODF                              /* IODF details           */\nCall PROC_HARD                              /* hardware details       */\nCall PROC_OS                                /* OS Details             */\nCall PROC_PAGE                              /* Page details           */\nCall PROC_STOR                              /* storage details        */\nCall PROC_SYMBOL                            /* static symbols         */\nCall PROC_JES                               /* JES details            */\nCall PROC_CPU                               /* CPU details            */\nCall PROC_HSA                               /* HSA details            */\nCall PROC_VERSION                           /* version details        */\nCall PROC_TCPIP                             /* TCPIP details          */\nCall PROC_OMVS                              /* OMVS details           */\nCall PROC_PERFORM                           /* performance details    */\nCall PROC_SUBSYS_PREFIX                     /* subsystem prefixes     */\n/**********************************************************************/\n/* display information                                                */\n/**********************************************************************/\nCall DEFINE_PANEL                           /* define the panel       */\nCall CREATE_MEMBER                          /* create the panel member*/\nAddress ISPEXEC \"LibDef ISPPLIB Library Id(\"fil\") Stack\"\nAddress ISPEXEC \"Display Panel(SYSINFO)\"    /* display the panel      */\nAddress ISPEXEC \"LibDef ISPPLIB\"            /* clear the temp alloc   */\nAddress TSO     \"Free Fi(\"fil\")\"            /* free the temp dsn      */\n/**********************************************************************/\nFINISH:                                     /*                        */\nExit 0                                      /*                        */\n/**********************************************************************/\n/* Address space info                                                 */\n/**********************************************************************/\nPROC_ADDR:                                  /* Address space info   ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtasvt  = Storage(D2x(C2d(cvt)+556),4)     /* get the ASVT address   */\nasvtmaxu = Storage(D2x(C2d(cvtasvt)+516),4) /* get max Address spaces */\nasvtaav  = Storage(D2x(C2d(cvtasvt)+480),4) /* get free Address spaces*/\nasvtast  = Storage(D2x(C2d(cvtasvt)+484),4) /* free slots SASI queue  */\nasvtanr  = Storage(D2x(C2d(cvtasvt)+488),4) /* free slots NONR queue  */\nasvtstrt = Storage(D2x(C2d(cvtasvt)+492),4) /* orig slots SASI queue  */\nasvtnonr = Storage(D2x(C2d(cvtasvt)+496),4) /* orig slots NONR queue  */\noffset   = 528                              /*                        */\nnonremk  = C2d(cvtasvt)+(C2d('80000000'x)+528) /*                     */\nduffcnt  = 0                                /* init non-reus count    */\nokcnt    = 0                                /* init in-use count      */\nDo loop = 1 To C2d(asvtmaxu)                /*                        */\n ascbadd  = Storage(D2x(C2d(cvtasvt)+offset),4) /*                    */\n If (C2d(ascbadd) = nonremk) Then           /*                        */\n  duffcnt = duffcnt + 1                     /*                        */\n ascbascb = Storage(D2x(C2d(ascbadd)+0),4)  /*                        */\n If (ascbascb = 'ASCB') Then                /*                        */\n  okcnt = okcnt + 1                         /*                        */\n offset = offset + 4                        /*                        */\nEnd                                         /*                        */\nasvtmaxu = C2d(asvtmaxu)                    /* maximum address spaces */\nasvtaav  = C2d(asvtaav)                     /* free address spaces    */\nasvtast  = C2d(asvtast)                     /* free slots SASI queue  */\nasvtanr  = C2d(asvtanr)                     /* free slots NONR queue  */\nasvtstrt = C2d(asvtstrt)                    /* orig slots SASI queue  */\nasvtnonr = C2d(asvtnonr)                    /* orig slots NONR queue  */\nReturn                                      /*                        */\n/**********************************************************************/\n/* racf info                                                          */\n/**********************************************************************/\nPROC_USER:                                  /* RACF user details    ##*/\npsaold   = Storage(224,4)                   /* get the ASCB address   */\nascbasxb = Storage(D2x(C2d(psaold)+108),4)  /* get the ASXB address   */\nasxbsenv = Storage(D2x(C2d(ascbasxb)+200),4)/*                        */\nasxblwa  = Storage(D2x(C2d(ascbasxb)+20),4) /* pointer to the LWA     */\nlwalgcmd = Storage(D2x(C2d(asxblwa)+186),80)/* get command line       */\nlwaacct  = Storage(D2x(C2d(asxblwa)+400),40)/* get account field      */\naceegrpn = Storage(D2x(C2d(asxbsenv)+30),8) /* get the connect group  */\naceeflg1 = Storage(D2x(C2d(asxbsenv)+38),1) /*                        */\nbits = x2b(C2x(aceeflg1))                   /*                        */\nracfacc  = ''                               /*                        */\nIf (Substr(bits,1,1) = '1') Then            /*                        */\n racfacc = racfacc||'Special '              /*                        */\nIf (Substr(bits,3,1) = '1') Then            /*                        */\n racfacc = racfacc||'Operations '           /*                        */\nIf (Substr(bits,4,1) = '1') Then            /*                        */\n racfacc = racfacc||'AudiTor'               /*                        */\nIf (racfacc = '') Then                      /*                        */\n racfacc = 'None'                           /*                        */\naceetrid = Storage(D2x(C2d(asxbsenv)+64),8) /* get the terminal ID    */\naceeunam = Storage(D2x(C2d(asxbsenv)+100),4)/* get the username addr  */\nusername = Storage(D2x(C2d(aceeunam)+1),20) /* get the username       */\naceefcgp = Storage(D2x(C2d(asxbsenv)+116),4)/* get the group list add */\ncgrplen  = Storage(D2x(C2d(aceefcgp)+5),3)  /* get the list length    */\ncgrplen  = C2d(cgrplen)                     /*                        */\ncgrpnum  = Storage(D2x(C2d(aceefcgp)+8),2)  /* get the list count     */\ncgrpnum  = C2d(cgrpnum)                     /*                        */\ncgrp     = Storage(D2x(C2d(aceefcgp)+32),(cgrplen-32)) /* get groups  */\ngrp_cnt = 0                                 /* initialise variable    */\nDo loop = 1 to cgrplen by 24                /* loop thru groups       */\n group = Substr(cgrp,loop,24)\n group = Strip(Substr(cgrp,loop,8))         /* extract the group name */\n If (group = 'FFFFFFFFFFFFFFFF'x) Then      /* revoked                */\n  group = '*REVOKED*'                       /* set revoked flag       */\n If (group /= '') Then                      /* blank                  */\n  Do                                        /*                        */\n   grp_cnt = grp_cnt + 1                    /* increment count        */\n   group.grp_cnt = group                    /* save group name        */\n  End                                       /*                        */\nEnd                                         /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* get tso account code routine                                       */\n/**********************************************************************/\nPROC_ACCOUNT:                               /* account detail       ##*/\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbjscbb = Storage(D2x(C2d(psatold)+181),3) /* pointer to jscb        */\njscbjcta = Storage(D2x(C2d(tcbjscbb)+261),3) /* pointer to the JCT    */\njscbjcta = SWAREQ(jscbjcta)                 /*                        */\njobname  = Storage(D2x(C2d(jscbjcta)+8),8)  /* get the jobname        */\njobname  = MvsVar('SYMDEF','JOBNAME')       /* get the jobname        */\njctactad = Storage(D2x(C2d(jscbjcta)+40),3) /* pointer to act         */\njctactad = SWAREQ(jctactad)                 /*                        */\nacct#l   = Storage(D2x(C2d(jctactad)+32),1) /* length of account      */\nacct#    = Storage(D2x(C2d(jctactad)+33),C2d(acct#l)) /* account id   */\nacctnum  = Strip(acct#,b)                   /* tidy up account number */\nReturn                                      /*                        */\n/**********************************************************************/\n/* get requested region size                                          */\n/**********************************************************************/\nPROC_REGION:                                /* region detail        ##*/\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbjscbb = Storage(D2x(C2d(psatold)+181),3) /* pointer to jscb        */\njscsctp  = Storage(D2x(C2d(tcbjscbb)+329),3) /* pointer to the SCT    */\njscsctp = SWAREQ(jscsctp)                   /*                        */\nsctpgmnm = Storage(D2x(C2d(jscsctp)+108),8) /* get the program name   */\nsctrgsz  = Storage(D2x(C2d(jscsctp)+173),3) /* get the region size    */\nregion   = C2d(sctrgsz)||'K'                /* convert to K bytes     */\nReturn                                      /*                        */\n/**********************************************************************/\n/* job information                                                    */\n/**********************************************************************/\nPROC_JOB:                                   /* job detail           ##*/\npsatold  = Storage(D2x(540),4)              /* pointer to current tcb */\ntcbjscb  = Storage(D2x(C2d(psatold)+180),4) /* pointer to jscb        */\njscbssib = Storage(D2x(C2d(tcbjscb)+316),4) /* pointer to ssib        */\nssibjbid = Storage(D2x(C2d(jscbssib)+12),8) /* get the jobid          */\ntcbtio   = Storage(D2x(C2d(psatold)+12),4)  /* pointer to tiot        */\ntiocnjob = Storage(D2x(C2d(tcbtio)+0),8)    /* pointer to jobname     */\ntiocstep = Storage(D2x(C2d(tcbtio)+8),8)    /* pointer to stepname    */\ntiocjstn = Storage(D2x(C2d(tcbtio)+16),8)   /* pointer to proc jobstep*/\nReturn\n/* This section isn't required for SYSINF, just here in case I need it*/\nddentry  = Storage(D2x(C2d(tcbtio)+24),8192) /* DD information -get 8K*/\nddpos    = 1                                /* start position         */\ntioelngh = C2d(Substr(ddentry,ddpos,1))     /* length of DD entry     */\nDo While tioelngh > 0                       /* loop thru until last   */\n tioeddnm = Substr(ddentry,ddpos+4,8)       /* get ddname             */\n tioejfcb = Substr(ddentry,ddpos+12,3)      /* get jfcb address       */\n tioejfcb = SWAREQ(tioejfcb)                /*                        */\n jfcbdsnm = Storage(D2x(C2d(tioejfcb)+0),44)/* get dataset name       */\n ddpos    = ddpos + tioelngh                /* update to next dd entry*/\n tioelngh = C2d(Substr(ddentry,ddpos,1))    /* get new length         */\nEnd                                         /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* master cat info                                                    */\n/**********************************************************************/\nPROC_MCAT:                                  /* mastercat detail     ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* get the prefix         */\nmvsfmid  = Substr(cvtpfx,9,7)               /* get the mvs fmid       */\nIf (Substr(mvsfmid,4,4) <= 6609) Then       /* CAXWA avail B4 R10     */\n Do                                         /*                        */\n  cvtcbsp  = Storage(D2x(C2d(cvt)+256),4)   /* get the AMCBS address  */\n  acb      = Storage(D2x(C2d(cvtcbsp)+8),4) /* get the acb Address    */\n  caxwa    = Storage(D2x(C2d(acb)+64),4)    /* get the caxwa Address  */\n  dsncat   = Storage(D2x(C2d(caxwa)+52),44) /* dsn of master cat      */\n  dsncat   = Strip(dsncat,T)                /*                        */\n  ucbcat   = Storage(D2x(C2d(caxwa)+28),4)  /* ucb name for master cat*/\n  volcat   = Storage(D2x(C2d(ucbcat)+28),6) /* volume for master cat  */\n End                                        /*                        */\nElse                                        /* OS/390 R10 and above   */\n Do                                         /*                        */\n  cvtecvt  = Storage(D2x(C2d(cvt)+140),4)   /* get the ECVT address   */\n  ecvtipa  = Storage(D2x(C2d(cvtecvt)+392),4)/* get the ihaipa Address*/\n  ipascat  = Storage(D2x(C2d(ecvtipa)+224),63) /* get the mcat details*/\n  dsncat   = Strip(Substr(ipascat,11,44))   /* master catalog dsn     */\n  volcat   = Substr(ipascat,1,6)            /* master catalog VOLSER  */\n End                                        /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* IEASYSxx paramemter details                                        */\n/*  additional pointers - thanks to Mark Zelden [mzelden@FLASH.NET]   */\n/**********************************************************************/\nPROC_IEASYS:                                /* IEASYSxx details     ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* get the prefix         */\nmvsfmid  = Substr(cvtpfx,9,7)               /* get the mvs fmid       */\npr =   'ALLOC   APF   APG      BLDL    BLDLF   CLOCK   CLPA    CMB '\npr = pr'CMD     CON   CONT     COUPLE  CPQE    CSA     CSCBLOC CVIO '\npr = pr'DEVSUP  DIAG  DUMP     DUPLEX  EXIT    FIX     GRS     GRSCNF '\npr = pr'GRSRNL  ICS   IOS      IPS     LNK     LNKAUTH LOGCLS  LOGLMT '\npr = pr'LOGREC  LPA   MAXCAD   MAXUSER MLPA    MSTRJCL NONVIO  NSYSLX '\npr = pr'NUCMAP  '\nIf (Substr(mvsfmid,4,4) >= 6603) Then       /*                        */\n pr = pr'OMVS    '\nElse\n pr = pr'RESERVED'\npr = pr'OPI     OPT   PAGE-OPR PAGE    PAGNUM  PAGTOTL PAK     PLEXCFG '\npr = pr'PROD    PROG  PURGE    RDE     REAL    RER     RSU     RSVNONR '\npr = pr'RSVSTRT SCH   SMF      SMS     SQA     SSN     SVC     SWAP    '\npr = pr'SYSNAME SYSP  VAL      VIODSN  VRREGN'\nIf (Substr(mvsfmid,4,4) >= 6604) Then       /*                        */\n pr = pr'RTLS    '\nIf (Substr(mvsfmid,4,4) >= 6602) Then       /* IHAIPA avail after R2  */\n Do                                         /*                        */\n  cvtecvt  = Storage(D2x(C2d(cvt)+140),4)   /* get the ECVT address   */\n  ecvtipa  = Storage(D2x(C2d(cvtecvt)+392),4)/* get the ihaipa Address*/\n  ipaplnum = Storage(D2x(C2d(ecvtipa)+2148),2) /* number of parms     */\n  ipasys   = Storage(D2x(C2d(ecvtipa)+2152),640) /*                   */\n  para_cnt = 0                              /*                        */\n  Do loop = 1 to 80                         /*                        */\n   parm_no = (loop * 8) - 7\n   ipapdes = Substr(ipasys,parm_no,8)       /*                        */\n   ipapdesa = Substr(ipapdes,1,4)           /*                        */\n   ipapdesl = Substr(ipapdes,5,2)           /*                        */\n   ipapdess = Substr(ipapdes,7,2)           /*                        */\n   ipapdedo = Substr(ipapdes,7,2)           /*                        */\n   If (C2d(ipapdesl) > 0) Then\n    Do\n     para_cnt = para_cnt + 1\n     parm.para_cnt = Storage(D2x(C2d(ipapdesa)),C2d(ipapdesl))\n     parm_nm.para_cnt = Word(pr,loop)\n     Select\n      When (C2x(ipapdedo) = '0000') Then parm_ty.para_cnt = 'Default '\n      When (C2x(ipapdedo) = 'FFFF') Then parm_ty.para_cnt = 'Operator'\n      Otherwise parm_ty.para_cnt = 'IEASYS'ipapdess\n     End\n    End\n  End                                       /*                        */\n End                                        /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* racf information                                                   */\n/**********************************************************************/\nPROC_RACF:                                  /* RACF details         ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtrac   = Storage(D2x(C2d(cvt)+992),4)     /* get the RCVT address   */\nrcvtvrmn = Storage(D2x(C2d(cvtrac)+616),4)  /* get the RACF version   */\ndsnrac   = ''                               /* reset racf dsn         */\nvolrac   = ''                               /* reset racf volume name */\nIf (C2d(cvtrac) /= 0) Then                  /* If the rcvt is not 0   */\n Do                                         /*                        */\n  dsnrac = Storage(D2x(C2d(cvtrac)+56),44)  /* get the racf dsn       */\n  dsnrac = Strip(dsnrac,t)                  /*                        */\n  ucbrac = Storage(D2x(C2d(cvtrac)+36),4)   /* get the racf ucb name  */\n  volrac = Storage(D2x(C2d(ucbrac)+28),6)   /* get the racf volume    */\n  rcvtidc = Storage(D2x(C2d(cvtrac)+0),4)   /* get the security type  */\n  If (rcvtidc = 'RCVT') Then sectype = 'RACF' /*                      */\n  If (rcvtidc = 'RTSS') Then sectype = 'TopSecret' /*                 */\n  If (rcvtidc = 'ACF2') Then sectype = 'ACF2' /*                      */\n End                                        /*                        */\nracf = Sysvar('sysracf')                    /*                        */\nracflev = Sysvar('syslracf')                /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* IPL time info                                                      */\n/**********************************************************************/\nPROC_IPLTIMES:                              /* IPL time details     ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtsmca  = Storage(D2x(C2d(cvt)+196),4)     /* get the SMCA address   */\nsmcaitme = Storage(D2x(C2d(cvtsmca)+336),4) /* get the smca ipl time  */\nsmcaidte = Storage(D2x(C2d(cvtsmca)+340),4) /* get the smca ipl date  */\nsmcasid  = Storage(D2x(C2d(cvtsmca)+16),4)  /* get the smca SID       */\niplsecs  = C2d(smcaitme) % 100              /* get IPL time in seconds*/\niplhr    = Right(iplsecs % 3600 ,2,'0')     /* get IPL hour           */\niplmin   = Right((iplsecs%60)-(iplhr*60),2,'0') /* get IPL minute     */\niplsec   = Right(iplsecs // 60 ,2,'0')      /* get IPL seconds        */\niplcent  = Substr(C2x(smcaidte),1,2)        /* get IPL century        */\niplyr    = Substr(C2x(smcaidte),3,2)        /* get IPL year           */\nipldy    = Substr(C2x(smcaidte),5,3)        /* get IPL day            */\nIf (iplcent = '01') Then iplyr = '20'iplyr  /* decode century indicat */\nIf (iplcent = '00') Then iplyr = '19'iplyr  /* decode century indicat */\nx = (iplyr/4=0) - (iplyr//100=0) + (iplyr//400=0) /* test leapyear    */\ndd = ipldy                                  /*                        */\nIf (dd > (59 + x)) Then                     /* convert to gregorian   */\n dd = dd+2-x                                /* \"                      */\nmm = (((dd+91)*100)%3055)                   /* \"                      */\ndd = dd+91-(mm*3055)%100                    /* \"                      */\nmm = mm - 2                                 /* \"                      */\ndd = Right(dd,2,'0')                        /*                        */\nmm = Right(mm,2,'0')                        /*                        */\nipljul   = iplyr||\".\"||ipldy                /*                        */\niplgrg   = \"(\"||dd||\"/\"||mm||\"/\"||iplyr||\")\"/*                        */\nipltim   = iplhr||\":\"||iplmin||\":\"||iplsec  /*                        */\nipldates = ipljul||' '||iplgrg||' '||ipltim /*                        */\ncuryr    = Substr(Date('S'),1,4)            /* get current year       */\ncurdy    = Substr(Date('J'),3,3)            /* get current day        */\ncursecs  = Time('S')                        /* get cur time in seconds*/\ncurjul   = curyr||\".\"||curdy                /* get current julian     */\ncurgrg   = \"(\"||Substr(Date('E'),1,6)||curyr||\")\" /* current gregorian*/\ncurtim   = Time()                           /* current time           */\ncurdates = curjul||' '||curgrg||' '||curtim /* build for display      */\noffdays  = 0                                /* initialise offdays     */\nIf (iplsecs < cursecs) Then                 /* if ipl less than cur   */\n offsecs = cursecs - iplsecs                /*  offset is cur - ipl   */\nElse                                        /* otherwise              */\n Do                                         /*                        */\n  offsecs = (cursecs + 86400) - iplsecs     /*  offset is cur+day-ipl */\n  offdays = offdays - 1                     /*  offdays is one less   */\n End                                        /*                        */\noffhr   = Right(offsecs % 3600 ,2,'0')      /* get offset hours       */\noffmin  = Right((offsecs%60)-(offhr*60),2,'0') /* get offset minute   */\noffsec  = Right(offsecs // 60 ,2,'0')       /* get offset seconds     */\nIf (iplyr = curyr) Then                     /* if same year           */\n offdays = offdays + (curdy - ipldy)        /*  offset days cur - ipl */\nElse                                        /* otherwise              */\n Do                                         /*                        */\n  Do year = iplyr To (curyr - 1) By 1       /* loop years             */\n   x = (year//4=0) - (year//100=0) + (year//400=0) /* test leapyear   */\n   If (x = 0) Then offdays = offdays + 365  /*  mod for normal year   */\n              Else offdays = offdays + 366  /*  mod for leap year     */\n  End                                       /*                        */\n  offdays = (curdy + offdays) - ipldy       /* get offset days        */\n End                                        /*                        */\noffdates = offdays' days(s) 'offhr' hours(s) 'offmin' minute(s) 'offsec\noffdates = offdates||' seconds(s)'\nReturn                                      /*                        */\n/**********************************************************************/\n/* other ipl info                                                     */\n/**********************************************************************/\nPROC_IPL:                                   /* IPL details          ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtsysad = Storage(D2x(C2d(cvt)+48),4)      /* get the SYSAD address  */\ncvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address   */\ncvtext2  = Storage(D2x(C2d(cvt)+328),4)     /* get the EXT2 address   */\nsysres   = Storage(D2x(C2d(cvtsysad)+28),6) /* get the sysres volser  */\nsysuad   = Storage(D2x(C2d(cvtsysad)+13),3) /* get the sysres UCBname */\nsyschan  = Storage(D2x(C2d(cvtsysad)+4),2)  /* get the sysres dev no  */\nIf (sysuad = 'UCB') Then sysuad = C2x(syschan) /* four char UCBs      */\necvtload = Storage(D2x(C2d(cvtecvt)+160),8) /*                        */\necvtipa  = Storage(D2x(C2d(cvtecvt)+392),4) /* get the ihaipa Address */\nipalparm = Storage(D2x(C2d(ecvtipa)+16),8)  /* get the loadparm       */\nipalpdsn = Storage(D2x(C2d(ecvtipa)+48),44) /* get the loadxx dataset */\nipalpdsn = Strip(ipalpdsn,b)||'(LOAD'||Substr(ipalparm,5,2)||')' /*   */\nipasplst = Storage(D2x(C2d(ecvtipa)+160),63)/* get the ieasysxx sufx  */\nIf (Substr(ipasplst,1,1) = '(') Then        /*                        */\n pref = Substr(ipasplst,2,2)                /*                        */\nElse                                        /*                        */\n pref = Substr(ipasplst,1,2)                /*                        */\nparm_cnt = 0                                /*                        */\nipaplnumx= Storage(D2x(C2d(ecvtipa)+2134),2)/* get the parmlib count  */\nipaplnumx = C2d(ipaplnumx)                  /*                        */\nIf (ipaplnumx = 0) Then ipaplnumx = 10      /* set if pre R10         */\nDo loop = 0 to ipaplnumx                    /* loop for parmlibs      */\n ipaplib = Storage(D2x(c2d(ecvtipa)+416+(loop*64)),64) /*             */\n ipapldsn = Substr(ipaplib,1,44)            /* parmlib dsname         */\n ipaplvol = Substr(ipaplib,46,6)            /* parmlib volume         */\n ipaplflg = X2b(C2x(Substr(ipaplib,64,1)))  /* parmlib flags          */\n If (Strip(ipapldsn,B) = '') Then Iterate   /*                        */\n parm_cnt = parm_cnt + 1                    /*                        */\n parmlib.parm_cnt = ipapldsn                /*                        */\n parmlin.parm_cnt = Left(ipapldsn,45)||Left(ipaplvol,7)\nEnd                                         /*                        */\nipapldsn = parmlib.1                        /* get the primary parmlib*/\nipapldsn = Strip(ipapldsn,b)||'(IEASYS'||pref||')' /*                 */\nipalpnam = Storage(D2x(C2d(ecvtipa)+32),8)  /* get the lpar name      */\nipahwnam = Storage(D2x(C2d(ecvtipa)+40),8)  /* get the hardware name  */\nipavmnam = Storage(D2x(C2d(ecvtipa)+48),8)  /* get the vmuserid name  */\n/**********************************************************************/\nipamstrj = Storage(D2x(C2d(ecvtipa)+2448),8)/* get master jcl PDE     */\nipapdesa = Substr(ipamstrj,1,4)             /* get master jcl address */\nipapdesl = Substr(ipamstrj,5,2)             /* get master jcl length  */\nmstrjcl  = Storage(D2x(c2d(ipapdesa)),C2d(ipapdesl)) /* mstrjcl parm  */\nmstrjcl = Strip(Strip(mstrjcl,B,')'),B,'(') /* strip brackets         */\nDo loop = 1 to parm_cnt\n parmlib = Strip(parmlib.loop,B)\n If (Sysdsn(\"'\"parmlib\"(MSTJCL\"mstrjcl\")'\") = 'OK') Then Leave\nEnd\nmstrjcl = parmlib||\"(MSTJCL\"||mstrjcl||\")\"\nAddress TSO\n\"Alloc Fi(MJCLIN) Da('\"mstrjcl\"') Shr Reu\"\n\"ExecIO * DiskR MJCLIN (Finis Stem mjcl)\"\n\"Free Fi(MJCLIN)\"\nReturn                                      /*                        */\n/**********************************************************************/\n/* IODF information                                                   */\n/**********************************************************************/\nPROC_IODF:                                  /* IODF details         ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtixavl = Storage(D2x(C2d(cvt)+124),4)     /* get the IOCOM address  */\ncvtext2  = Storage(D2x(C2d(cvt)+328),4)     /* get the EXT2 address   */\ncvtiocid = Storage(D2x(C2d(cvtext2)+6),2)   /* active IO config id    */\niociovtp = Storage(D2x(C2d(cvtixavl)+208),4)/* get the IOVT address   */\ncda      = Storage(D2x(C2d(iociovtp)+24),4) /* get the CDA address    */\niodfname = Storage(D2x(c2d(cda)+32),44)     /* get the IODF name      */\niodfcfgi = Storage(D2x(c2d(cda)+92),8)      /* get the IODF config id */\niodfedt  = Storage(D2x(c2d(cda)+104),2)     /* get the IODF EDT       */\niodfproc = Storage(D2x(c2d(cda)+124),8)     /* get the IODF Proc      */\niodfdate = Storage(D2x(c2d(cda)+156),8)     /* get the IODF Date      */\niodftime = Storage(D2x(c2d(cda)+164),8)     /* get the IODF Time      */\niodfdesc = Storage(D2x(c2d(cda)+172),16)    /* get the IODF Descriptn */\nReturn                                      /*                        */\n/**********************************************************************/\n/* System Host ID information                                         */\n/* Central Processing Complex Node Descriptor fields                  */\n/**********************************************************************/\nPROC_HARD:                                  /* hardware details     ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvthid   = Storage(D2x(C2d(cvt)+1068),4)    /* get the IOSDSHID addr  */\nflags  = Storage(D2x(C2d(cvthid)+22),1)     /* cpcnd_flags            */\nIf (flags /= x'40') Then                    /* test valid node descrip*/\n Do                                         /*                        */\n  type  = Storage(D2x(C2d(cvthid)+26),6)    /* cpcnd_type             */\n  model = Storage(D2x(C2d(cvthid)+32),3)    /* cpcnd_model            */\n  man   = Storage(D2x(C2d(cvthid)+35),3)    /* cpcnd_man              */\n  plant = Storage(D2x(C2d(cvthid)+38),2)    /* cpcnd_plant            */\n  seqno = Storage(D2x(C2d(cvthid)+40),12)   /* cpcnd_seqno            */\n End                                        /*                        */\nElse                                        /* invalid node descriptor*/\n Do                                         /*                        */\n  type  = ''                                /*                        */\n  model = ''                                /*                        */\n  man   = ''                                /*                        */\n  plant = ''                                /*                        */\n  seqno = ''                                /*                        */\n End                                        /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* os/mvs information                                                 */\n/**********************************************************************/\nPROC_OS:                                    /* OS Details           ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* get the prefix         */\ncvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address   */\ncvtcsd   = Storage(D2x(C2d(cvt)+660),4)     /* get the CSD address    */\necvtsplx = Storage(D2x(C2d(cvtecvt)+8),8)   /* sysplex name           */\necvthdnm = Storage(D2x(C2d(cvtecvt)+336),8) /* hardware name          */\necvtlpnm = Storage(D2x(C2d(cvtecvt)+344),8) /* lpar name              */\necvtvmnm = Storage(D2x(C2d(cvtecvt)+352),8) /* vmuserid name          */\necvtpown = Storage(D2x(C2d(cvtecvt)+480),16)/* product owner          */\necvtpnam = Storage(D2x(C2d(cvtecvt)+496),16)/* product name           */\necvtpver = Storage(D2x(C2d(cvtecvt)+512),2) /* product version        */\necvtprel = Storage(D2x(C2d(cvtecvt)+514),2) /* product release        */\necvtpmod = Storage(D2x(C2d(cvtecvt)+516),2) /* product mod level      */\nmvsver   = Substr(cvtpfx,1,7)               /* get the mvs version    */\nmvsfmid  = Substr(cvtpfx,9,7)               /* get the mvs fmid       */\necvtclon = Storage(D2x(C2d(cvtecvt)+264),2) /* sysplex identIfier     */\ncvtsname = Storage(D2x(C2d(cvt)+340),8)     /* get the GRS name       */\necvtgmod = Storage(D2x(C2d(cvtecvt)+266),1) /* grs mode of operation  */\ncsdplpn  = Storage(D2x(C2d(cvtcsd)+252),1)  /* PRSM logical partition */\ncsdplpn  = C2d(csdplpn)                     /*                        */\nSelect                                      /*                        */\n When (ecvtgmod = x'1') Then ecvtgmod = 'Ring' /*                     */\n When (ecvtgmod = x'2') Then ecvtgmod = 'Star' /*                     */\n Otherwise ecvtgmod = 'None'                   /*                     */\nEnd                                         /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* Page dataset information                                           */\n/**********************************************************************/\nPROC_PAGE:                                  /* Page details         ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtasmvt = Storage(D2x(C2d(cvt)+704),4)     /* get the ASMVT address  */\nasmpart  = Storage(D2x(C2d(cvtasmvt)+8),4)  /* Address of PART        */\npartsize = Storage(D2x(C2d(asmpart)+4),4)   /* Total entries in PART  */\npartdsnl = Storage(D2x(C2d(asmpart)+24),4)  /* Adress of page dsn list*/\npage_cnt = 0\nDo loop = 0 to C2d(partsize)-1\n parte    = Storage(D2x(C2d(asmpart)+81+(loop*96)),96)\n paretype = X2b(C2x(Substr(parte,8,1)))\n pareflg1 = X2b(C2x(Substr(parte,9,1)))\n If (Substr(pareflg1,1,1) = 1) Then Iterate /* slot not in use        */\n page_cnt = page_cnt + 1\n Select\n  When (Substr(paretype,1,1) = '1') Then pagetype = 'PLPA'\n  When (Substr(paretype,2,1) = '1') Then pagetype = 'Common'\n  When (Substr(paretype,3,1) = '1') Then pagetype = 'Duplex'\n  When (Substr(paretype,4,1) = '1') Then pagetype = 'Local'\n  Otherwise pagetype = '??????'\n End\n Select\n  When (Substr(paretype,7,1) = '1') Then\n   pagetype = Left(pagetype,7)||'PageDel'\n  When (Substr(paretype,8,1) = '1') Then\n   pagetype = Left(pagetype,7)||'Draining'\n  Otherwise NOP\n End\n pagedsn  = Storage(D2x(C2d(partdsnl)+(loop*44)),44)\n pareszsl = C2d(Substr(parte,16,4))\n pareslta = C2d(Substr(parte,20,4))\n pareucbp = Substr(parte,44,4)\n ucbchan  = Storage(D2x(C2d(pareucbp)+4),2)\n ucbchan  = C2x(ucbchan)\n ucbvoli  = Storage(D2x(C2d(pareucbp)+28),6)\n pareused = pareszsl - pareslta\n pareused = (pareused/pareszsl)*100\n pagetype = Left(pagetype,16)\n pareused = Right(Format(pareused,3,2)||'%',7)\n pareszsl = Right(pareszsl,7)\n pagedsn  = Left(pagedsn,44)\n ucbchan  = Left(ucbchan,5)\n ucbvoli  = Left(ucbvoli,7)\n text = pagetype||pareused||pareszsl||' '||ucbchan||ucbvoli||pagedsn\n pagelist.page_cnt = text\nEnd\nReturn                                      /*                        */\n/**********************************************************************/\n/* Storage information                                                */\n/*  additional pointers - thanks to Mark Zelden [mzelden@FLASH.NET]   */\n/**********************************************************************/\nPROC_STOR:                                  /* storage details      ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtprodi = Storage(D2x(C2d(cvt)-32),8)      /* get the product fmid   */\ncvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address   */\ncvtgda   = Storage(D2x(C2d(cvt)+560),4)     /* get the GDA  address   */\ncvtrcep  = Storage(D2x(C2d(cvt)+1168),4)    /* get the RCE address    */\ncvtsmext = Storage(D2x(C2d(cvt)+1196),4)    /* get the OS/VS2 Extensn */\necvtipa  = Storage(D2x(C2d(cvtecvt)+392),4) /* get the ihaipa Address */\nipaarchl = Storage(D2x(C2d(ecvtipa)+2143),1)/* get the architecture lv*/\npsaold   = Storage(224,4)                   /* get the ASCB address   */\nascblda  = Storage(D2x(C2d(psaold)+48),4)   /* get the LDA address    */\n\ncvtrlstg = Storage(D2x(C2d(cvt)+856),4)     /* get real Storage size  */\ncvtrlstg = (C2d(cvtrlstg)/1024)||'M'        /* convert To Mbytes      */\n\nrceespl  = Storage(D2x(C2d(cvtrcep)+160),4) /* get exp Storage frames */\nrceespl  = ((C2d(rceespl)*4)/1024)||'M'     /* convert To Mbytes      */\n\ngdacsa   = Storage(D2x(C2d(cvtgda)+108),4)  /* addr of CSA            */\ngdacsasz = Storage(D2x(C2d(cvtgda)+112),4)  /* size of CSA            */\ngdacsae  = C2d(gdacsa) + C2d(gdacsasz) - 1  /* end  of CSA            */\ngdaecsa  = Storage(D2x(C2d(cvtgda)+124),4)  /* addr of ECSA           */\ngdaecsas = Storage(D2x(C2d(cvtgda)+128),4)  /* size of ECSA           */\ngdaecsae = C2d(gdaecsa) + C2d(gdaecsas) - 1 /* end  of ECSA           */\ngdasqa   = Storage(D2x(C2d(cvtgda)+144),4)  /* addr of SQA            */\ngdasqasz = Storage(D2x(C2d(cvtgda)+148),4)  /* size of SQA            */\ngdasqae  = C2d(gdasqa) + C2d(gdasqasz) - 1  /* end  of SQA            */\ngdaesqa  = Storage(D2x(C2d(cvtgda)+152),4)  /* addr of ESQA           */\ngdaesqas = Storage(D2x(C2d(cvtgda)+156),4)  /* size of ESQA           */\ngdaesqae = C2d(gdaesqa) + C2d(gdaesqas) - 1 /* end  of ESQA           */\ngdapvt   = Storage(D2x(C2d(cvtgda)+160),4)  /* addr of PRIVATE        */\ngdapvtsz = Storage(D2x(C2d(cvtgda)+164),4)  /* size of PRIVATE        */\ngdaepvt  = Storage(D2x(C2d(cvtgda)+168),4)  /* addr of extended PRIV  */\ngdaepvts = Storage(D2x(C2d(cvtgda)+172),4)  /* size of extended PRIV  */\ngdaepvte = C2d(gdaepvt) + C2d(gdaepvts) - 1 /* end  of extended PRIV  */\ngdavr    = Storage(D2x(C2d(cvtgda)+192),4)  /* addr of global V=R     */\ngdavrsz  = Storage(D2x(C2d(cvtgda)+196),4)  /* size of global V=R     */\ngdavre   = C2d(gdavr) + C2d(gdavrsz) - 1    /* end  of global V=R     */\n\ncvtmlpas = Storage(D2x(C2d(cvtsmext)+8),4)  /* addr of MLPA           */\ncvtmlpae = Storage(D2x(C2d(cvtsmext)+12),4) /* end  of MLPA           */\ncvtmlpa  = C2d(cvtmlpae) - C2d(cvtmlpas)    /* size of MLPA           */\ncvtflpas = Storage(D2x(C2d(cvtsmext)+16),4) /* addr of FLPA           */\ncvtflpae = Storage(D2x(C2d(cvtsmext)+20),4) /* end  of FLPA           */\ncvtflpa  = C2d(cvtflpae) - C2d(cvtflpas)    /* size of FLPA           */\ncvtplpas = Storage(D2x(C2d(cvtsmext)+24),4) /* addr of PLPA           */\ncvtplpae = Storage(D2x(C2d(cvtsmext)+28),4) /* end  of PLPA           */\ncvtplpa  = C2d(cvtplpae) - C2d(cvtplpas)    /* size of PLPA           */\ncvtrwns  = Storage(D2x(C2d(cvtsmext)+32),4) /* addr of RW Nucleus     */\ncvtrwne  = Storage(D2x(C2d(cvtsmext)+36),4) /* end  of RW Nucleus     */\ncvtrwn   = C2d(cvtrwne) - C2d(cvtrwns)      /* size of RW Nucleus     */\ncvtrons  = Storage(D2x(C2d(cvtsmext)+40),4) /* addr of RO Nucleus     */\ncvtrone  = Storage(D2x(C2d(cvtsmext)+44),4) /* end  of RO Nucleus     */\nrons_b_e = Right('FFFFFF',8,'0')            /* 16M line 'below'       */\nrons_a_s = Right('1000000',8,'0')           /* 16M line 'above'       */\ncvtron_b = X2d(rons_b_e) - C2d(cvtrons)     /* size of RO Nucleus <16M*/\ncvtron_a = C2d(cvtrone) - X2d(rons_a_s)     /* size of RO Nucleus >16M*/\ncvtron   = C2d(cvtrone) - C2d(cvtrons)      /* size of RO Nucleus All */\ncvterwns = Storage(D2x(C2d(cvtsmext)+48),4) /* addr of E-RW Nucleus   */\ncvterwne = Storage(D2x(C2d(cvtsmext)+52),4) /* end  of E-RW Nucleus   */\ncvterwn  = C2d(cvterwne) - C2d(cvterwns)    /* size of E-RW Nucleus   */\ncvteplps = Storage(D2x(C2d(cvtsmext)+56),4) /* addr of E-PLPA         */\ncvteplpe = Storage(D2x(C2d(cvtsmext)+60),4) /* end  of E-PLPA         */\ncvteplp  = C2d(cvteplpe) - C2d(cvteplps)    /* size of E-PLPA         */\ncvteflps = Storage(D2x(C2d(cvtsmext)+64),4) /* addr of E-FLPA         */\ncvteflpe = Storage(D2x(C2d(cvtsmext)+68),4) /* end  of E-FLPA         */\ncvteflp  = C2d(cvteflpe) - C2d(cvteflps)    /* size of E-FLPA         */\ncvtemlps = Storage(D2x(C2d(cvtsmext)+72),4) /* addr of E-MLPA         */\ncvtemlpe = Storage(D2x(C2d(cvtsmext)+76),4) /* end  of E-MLPA         */\ncvtemlp  = C2d(cvtemlpe) - C2d(cvtemlps)    /* size of E-MLPA         */\n\nldastrta = Storage(D2x(C2d(ascblda)+60),4)  /* addr of addr space     */\nldasiza  = Storage(D2x(C2d(ascblda)+64),4)  /* size of addr space     */\nldastrtz = C2d(ldastrta) + C2d(ldasiza) - 1 /* end  of system region  */\nldastrts = Storage(D2x(C2d(ascblda)+92),4)  /* addr of system region  */\nldasizs  = Storage(D2x(C2d(ascblda)+96),4)  /* size of system region  */\nldastrte = C2d(ldastrts) + C2d(ldasizs) - 1 /* end  of system region  */\nldaregrq = Storage(D2x(C2d(ascblda)+204),4) /* region size requested  */\nldalimit = Storage(D2x(C2d(ascblda)+208),4) /* <16M V=V region limit  */\nldaelim  = Storage(D2x(C2d(ascblda)+216),4) /* >16M V=V region limit  */\nldaloal  = Storage(D2x(C2d(ascblda)+232),4) /* <16M user region alloc */\nldaeloal = Storage(D2x(C2d(ascblda)+240),4) /* >16M user region alloc */\n\ngda_csa_alloc  = Storage(D2x(C2d(cvtgda)+432),4) /* used CSA          */\ngda_ecsa_alloc = Storage(D2x(C2d(cvtgda)+436),4) /* used ECSA         */\ngda_sqa_alloc  = Storage(D2x(C2d(cvtgda)+440),4) /* used SQA          */\ngda_esqa_alloc = Storage(D2x(C2d(cvtgda)+444),4) /* used ESQA         */\ngda_csa_conv   = Storage(D2x(C2d(cvtgda)+448),4) /* converted CSA     */\ngda_ecsa_conv  = Storage(D2x(C2d(cvtgda)+452),4) /* converted ECSA    */\n\ngdacsa   = Right(C2x(gdacsa),8,'0')         /* pad with zeroes        */\ngdacsae  = Right(D2x(gdacsae),8,'0')        /* pad with zeroes        */\ngdaecsa  = Right(C2x(gdaecsa),8,'0')        /* pad with zeroes        */\ngdaecsae = Right(D2x(gdaecsae),8,'0')       /* pad with zeroes        */\ngdasqa   = Right(C2x(gdasqa),8,'0')         /* pad with zeroes        */\ngdasqae  = Right(D2x(gdasqae),8,'0')        /* pad with zeroes        */\ngdaesqa  = Right(C2x(gdaesqa),8,'0')        /* pad with zeroes        */\ngdaesqae = Right(D2x(gdaesqae),8,'0')       /* pad with zeroes        */\ngdapvt   = Right(C2x(gdapvt),8,'0')         /* pad with zeroes        */\ngdaepvt  = Right(C2x(gdaepvt),8,'0')        /* pad with zeroes        */\ngdaepvte = Right(D2x(gdaepvte),8,'0')       /* pad with zeroes        */\ngdavr    = Right(C2x(gdavr),8,'0')          /* pad with zeroes        */\ngdavre   = Right(D2x(gdavre),8,'0')         /* pad with zeroes        */\n\ngdacsasz = (C2d(gdacsasz)/1024)||'K'        /* convert To kbytes      */\ngdaecsas = (C2d(gdaecsas)/1024)||'K'        /* convert To kbytes      */\ngdasqasz = (C2d(gdasqasz)/1024)||'K'        /* convert To kbytes      */\ngdaesqas = (C2d(gdaesqas)/1024)||'K'        /* convert To kbytes      */\ngdapvtsz = (C2d(gdapvtsz)/1024)||'K'        /* convert To kbytes      */\ngdaepvts = (C2d(gdaepvts)/(1024*1024))||'M' /* convert To mbytes      */\ngdavrsz  = (C2d(gdavrsz)/1024)||'K'         /* convert To kbytes      */\n\ncvtmlpas = Right(C2x(cvtmlpas),8,'0')       /* pad with zeroes        */\ncvtmlpae = Right(C2x(cvtmlpae),8,'0')       /* pad with zeroes        */\ncvtflpas = Right(C2x(cvtflpas),8,'0')       /* pad with zeroes        */\ncvtflpae = Right(C2x(cvtflpae),8,'0')       /* pad with zeroes        */\ncvtplpas = Right(C2x(cvtplpas),8,'0')       /* pad with zeroes        */\ncvtplpae = Right(C2x(cvtplpae),8,'0')       /* pad with zeroes        */\ncvtrwns  = Right(C2x(cvtrwns),8,'0')        /* pad with zeroes        */\ncvtrwne  = Right(C2x(cvtrwne),8,'0')        /* pad with zeroes        */\ncvtrons  = Right(C2x(cvtrons),8,'0')        /* pad with zeroes        */\ncvtrone  = Right(C2x(cvtrone),8,'0')        /* pad with zeroes        */\ncvterwns = Right(C2x(cvterwns),8,'0')       /* pad with zeroes        */\ncvterwne = Right(C2x(cvterwne),8,'0')       /* pad with zeroes        */\ncvteplps = Right(C2x(cvteplps),8,'0')       /* pad with zeroes        */\ncvteplpe = Right(C2x(cvteplpe),8,'0')       /* pad with zeroes        */\ncvteflps = Right(C2x(cvteflps),8,'0')       /* pad with zeroes        */\ncvteflpe = Right(C2x(cvteflpe),8,'0')       /* pad with zeroes        */\ncvtemlps = Right(C2x(cvtemlps),8,'0')       /* pad with zeroes        */\ncvtemlpe = Right(C2x(cvtemlpe),8,'0')       /* pad with zeroes        */\n\ncvtmlpa  = Format(cvtmlpa/1024,,0)||'K'     /* convert to kbytes      */\ncvtflpa  = Format(cvtflpa/1024,,0)||'K'     /* convert to kbytes      */\ncvtplpa  = Format(cvtplpa/1024,,0)||'K'     /* convert to kbytes      */\ncvtrwn   = Format(cvtrwn/1024,,0)||'K'      /* convert to kbytes      */\ncvtron_b = Format(cvtron_b/1024,,0)||'K'    /* convert to kbytes      */\ncvtron_a = Format(cvtron_a/1024,,0)||'K'    /* convert to kbytes      */\ncvtron   = Format(cvtron/1024,,0)||'K'      /* convert to kbytes      */\ncvterwn  = Format(cvterwn/1024,,0)||'K'     /* convert to kbytes      */\ncvteplp  = Format(cvteplp/1024,,0)||'K'     /* convert to kbytes      */\ncvteflp  = Format(cvteflp/1024,,0)||'K'     /* convert to kbytes      */\ncvtemlp  = Format(cvtemlp/1024,,0)||'K'     /* convert to kbytes      */\n\nldastrta = Right(C2x(ldastrta),8,'0')       /* pad with zeroes        */\nldastrtz = Right(D2x(ldastrtz),8,'0')       /* pad with zeroes        */\nldastrts = Right(C2x(ldastrts),8,'0')       /* pad with zeroes        */\nldastrte = Right(D2x(ldastrte),8,'0')       /* pad with zeroes        */\n\nldasiza  = Format((C2d(ldasiza)/1024),,0)||'K' /* convert to kbytes   */\nldasizs  = Format((C2d(ldasizs)/1024),,0)||'K' /* convert to kbytes   */\nldaregrq = Format((C2d(ldaregrq)/1024),,0)||'K'/* convert to kbytes   */\nldalimit = Format((C2d(ldalimit)/1024),,0)||'K'/* convert to kbytes   */\nldaelim  = Format((C2d(ldaelim)/1024),,0)||'K' /* convert to kbytes   */\nldaloal  = Format((C2d(ldaloal)/1024),,0)||'K' /* convert to kbytes   */\nldaeloal = Format((C2d(ldaeloal)/1024),,0)||'K'/* convert to kbytes   */\n\ngda_csa_alloc  = Format((C2d(gda_csa_alloc)/1024),,0)||'K'\ngda_ecsa_alloc = Format((C2d(gda_ecsa_alloc)/1024),,0)||'K'\ngda_sqa_alloc  = Format((C2d(gda_sqa_alloc)/1024),,0)||'K'\ngda_esqa_alloc = Format((C2d(gda_esqa_alloc)/1024),,0)||'K'\ngda_csa_conv   = Format((C2d(gda_csa_conv)/1024),,0)||'K'\ngda_ecsa_conv  = Format((C2d(gda_ecsa_conv)/1024),,0)||'K'\n\nIf (ipaarchl = 2) Then\n stor_psa     = Left('00000000',9)||Left('00001FFF',9)||Right('8K',8)\nElse\n stor_psa     = Left('00000000',9)||Left('00000FFF',9)||Right('4K',8)\nstor_system  = Left(ldastrts,9)||Left(ldastrte,9)||Right(ldasizs,8)\nstor_priv_vr = Left(gdavr,9)||Left(gdavre,9)||Right(gdavrsz,8)\nstor_priv_vv = Left(ldastrta,9)||Left(ldastrtz,9)||Right(ldasiza,8)\nstor_csa     = Left(gdacsa,9)||Left(gdacsae,9)||Right(gdacsasz,8)\nstor_csa     = stor_csa||Right(gda_csa_alloc,8)||Right(gda_csa_conv,8)\nstor_mlpa    = Left(cvtmlpas,9)||Left(cvtmlpae,9)||Right(cvtmlpa,8)\nstor_flpa    = Left(cvtflpas,9)||Left(cvtflpae,9)||Right(cvtflpa,8)\nstor_plpa    = Left(cvtplpas,9)||Left(cvtplpae,9)||Right(cvtplpa,8)\nstor_sqa     = Left(gdasqa,9)||Left(gdasqae,9)||Right(gdasqasz,8)\nstor_sqa     = stor_sqa||Right(gda_sqa_alloc,8)\nstor_nuc_rw  = Left(cvtrwns,9)||Left(cvtrwne,9)||Right(cvtrwn,8)\nstor_nuc_ro  = Left(cvtrons,9)||Left(rons_b_e,9)||Right(cvtron_b,8)\nstor_nuc_ro  = stor_nuc_ro||' (Crosses 16M line)'\nstor_nuc_ero = Left(rons_a_s,9)||Left(cvtrone,9)||Right(cvtron_a,8)\nstor_nuc_ero = stor_nuc_ero||' (Total '||cvtron||')'\nstor_nuc_erw = Left(cvterwns,9)||Left(cvterwne,9)||Right(cvterwn,8)\nstor_e_sqa   = Left(gdaesqa,9)||Left(gdaesqae,9)||Right(gdaesqas,8)\nstor_e_sqa   = stor_e_sqa||Right(gda_esqa_alloc,8)\nstor_e_plpa  = Left(cvteplps,9)||Left(cvteplpe,9)||Right(cvteplp,8)\nstor_e_flpa  = Left(cvteflps,9)||Left(cvteflpe,9)||Right(cvteflp,8)\nstor_e_mlpa  = Left(cvtemlps,9)||Left(cvtemlpe,9)||Right(cvtemlp,8)\nstor_e_csa   = Left(gdaecsa,9)||Left(gdaecsae,9)||Right(gdaecsas,8)\nstor_e_csa   = stor_e_csa||Right(gda_ecsa_alloc,8)\nstor_e_csa   = stor_e_csa||Right(gda_ecsa_conv,8)\nstor_e_priv  = Left(gdaepvt,9)||Left(gdaepvte,9)||Right(gdaepvts,8)\nReturn                                      /*                        */\n/*********************************************************************/\n/* Symbol extraction thanks to Mark Zelden [mzelden@FLASH.NET]       */\n/*********************************************************************/\nPROC_SYMBOL:                                /* static symbols       ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtprodi = Storage(D2x(C2d(cvt)-32),8)      /* get the product fmid   */\ncvtecvt  = Storage(D2x(C2d(cvt)+140),4)     /* get the ECVT address   */\nIf (Substr(cvtprodi,4,4) >= 5520) Then\n Do\n  ecvtsymt = Storage(D2x(c2d(cvtecvt)+296),4) /* get addr of SYMT     */\n  symbtnumberofsymbols = Storage(D2x(c2d(ecvtsymt)+2),2)\n  Do loop = 1 to C2d(symbtnumberofsymbols)\n   offset = (loop-1)*16\n   symbtesymboloffset  = Storage(D2x(C2d(ecvtsymt)+4+offset),4)\n   symbtesymbollength  = Storage(D2x(c2d(ecvtsymt)+8+offset),4)\n   symbtesubtextoffset = Storage(D2x(C2d(ecvtsymt)+12+offset),4)\n   symbtesubtextlength = Storage(D2x(c2d(ecvtsymt)+16+offset),4)\n   name_o = C2d(symbtesymboloffset)\n   name_l = C2d(symbtesymbollength)\n   value_o = C2d(symbtesubtextoffset)\n   value_l = C2d(symbtesubtextlength)\n   sym_nam.loop = Storage(D2x(C2d(ecvtsymt)+4+name_o),name_l)\n   sym_val.loop = Storage(D2x(C2d(ecvtsymt)+4+value_o),value_l)\n  End\n End\nReturn                                      /*                        */\n/**********************************************************************/\n/* JES information                                                    */\n/**********************************************************************/\nPROC_JES:                                   /* JES details          ##*/\n/* 'Old' version */\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtpfx   = Storage(D2x(C2d(cvt)-40),16)     /* get the prefix         */\nmvsfmid  = Substr(cvtpfx,9,7)               /* get the mvs fmid       */\ncvtjesct = Storage(D2x(C2d(cvt)+296),4)     /* get the JESCT address  */\njesssct  = Storage(D2x(C2d(cvtjesct)+24),4) /* get jesssct (sscvt)    */\nssctsnam = Storage(D2x(C2d(jesssct)+8),4)   /* get sub-system name    */\nssctsus2 = Storage(D2x(C2d(jesssct)+28),4)  /* point To $hcct         */\nSelect                                      /*                        */\n When (Substr(mvsfmid,4,4) = 7703) Then     /* OS/390 R10 HBB7703     */\n  Do                                        /*                        */\n   cctcomch = Storage(D2x(C2d(ssctsus2)+306),1)/* jes command char    */\n   cctssnm  = Storage(D2x(C2d(ssctsus2)+616),4)/* jes name of subsys  */\n  End                                       /*                        */\n When (Substr(mvsfmid,4,4) = 7713) |,       /* Z/OS R1    JBB7713     */\n      (Substr(mvsfmid,4,4) = 7705) |,       /* Z/OS R2    HBB7705     */\n      (Substr(mvsfmid,4,4) = 7706) Then     /* Z/OS R3    HBB7706     */\n  Do                                        /*                        */\n   cctcomch = Storage(D2x(C2d(ssctsus2)+306),1)/* jes command char    */\n   cctssnm  = Storage(D2x(C2d(ssctsus2)+776),4)/* jes name of subsys  */\n  End                                       /*                        */\n When (Substr(mvsfmid,4,4) >= 7707) Then    /* Z/OS R4    HBB7707     */\n  Do                                        /*                        */\n   cctcomch = Storage(D2x(C2d(ssctsus2)+386),1)/* jes command char    */\n   cctssnm  = Storage(D2x(C2d(ssctsus2)+856),4)/* jes name of subsys  */\n  End                                       /*                        */\n Otherwise                                  /* set for R8 and prior   */\n  Do                                        /*                        */\n   cctcomch = Storage(D2x(C2d(ssctsus2)+242),1)/* jes command char    */\n   cctssnm  = Storage(D2x(C2d(ssctsus2)+696),4)/* jes name of subsys  */\n  End                                       /*                        */\nEnd                                         /*                        */\n                                            /* MVS/ESA SP5.2.2 JBB5522*/\n                                            /* OS/390 R1  HBB6601     */\n                                            /* OS/390 R2  JBB6602     */\n                                            /* OS/390 R3  HBB6603     */\n                                            /* OS/390 R4  JBB6604     */\n                                            /* OS/390 R5  HBB6605     */\n                                            /* OS/390 R6  HBB6606     */\n                                            /* OS/390 R7  JBB6607     */\n/* get JES node and version                                           */\ncctndenm = Sysvar('sysnode')                /* get the JES node name  */\njesname  = Word(Sysvar('sysjes'),1)         /* get the JES system name*/\ncctssvs  = Sysvar('sysjes')                 /* get the JES ver-lev-mod*/\nReturn                                      /*                        */\n/**********************************************************************/\n/* cpu information                                                    */\n/**********************************************************************/\nPROC_CPU:                                   /* CPU details          ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtpccat = Storage(D2x(C2d(cvt)+764),4)     /* get the PCCAVT address */\noffset = 0                                  /*                        */\ncpucnt = 0                                  /*                        */\nDo loop = 0 To 15                           /*                        */\n pcca = Storage(D2x(C2d(cvtpccat)+offset),4)/*                        */\n If (D2x(C2d(pcca)) /= 0) Then              /*                        */\n  Do                                        /*                        */\n   cpucnt = cpucnt + 1                      /*                        */\n   cpu.cpucnt = Storage(D2x(C2d(pcca)+4),12)/*                        */\n   ser.cpucnt = Substr(cpu.cpucnt,3,6)      /*                        */\n   mod.cpucnt = Substr(cpu.cpucnt,9,4)      /*                        */\n  End                                       /*                        */\n offset = offset + 4                        /*                        */\nEnd                                         /*                        */\ncpumod   = mod.1                            /* get cpu serial model   */\nReturn                                      /*                        */\n/**********************************************************************/\n/* cpu information                                                    */\n/**********************************************************************/\nPROC_HSA:                                   /* HSA details          ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtscpin = Storage(D2x(C2d(cvt)+832),4)     /* get the SCCB address   */\nsccbsar  = Storage(D2x(c2d(cvtscpin)+8),2)  /* real stor addr range   */\nsccbsai  = Storage(D2x(c2d(cvtscpin)+10),1) /* real stor addr incrmnt */\nsccbsbs  = Storage(D2x(c2d(cvtscpin)+11),1) /* real stor addr blksize */\nsccbncps = Storage(D2x(c2d(cvtscpin)+16),2) /* installed CPU count    */\nsccbnhsa = Storage(D2x(c2d(cvtscpin)+20),2) /* number of HSAs         */\nsccbohsa = Storage(D2x(c2d(cvtscpin)+22),2) /* HSA offset from SCCB   */\nsccbparm = Storage(D2x(c2d(cvtscpin)+24),8) /* load parm              */\nsccbmesi = Storage(D2x(c2d(cvtscpin)+32),4) /* ext  stor addr range   */\nsccbnxsb = Storage(D2x(c2d(cvtscpin)+36),4) /* ext  stor addr blocks  */\nsccbrcci = Storage(D2x(c2d(cvtscpin)+86),4) /* capacity               */\nstor_rel = C2d(sccbsar)*C2d(sccbsai)\nstor_ext = (C2d(sccbmesi)*((C2d(sccbnxsb)*4)))/1024\nhsaaddr  = D2c(C2d(cvtscpin)+C2d(sccbohsa))\nDo loop = 1 to C2d(sccbnhsa)\n offset = C2d(sccbohsa)+((loop*6)-6)\n sccbhssz = Storage(D2x(C2d(cvtscpin)+C2d(sccbohsa)+((loop*6)-6)),2)\n sccbahsa = Storage(D2x(C2d(cvtscpin)+C2d(sccbohsa)+((loop*6)-6)+2),4)\n hsa_size = (C2d(sccbhssz)*4)/1024\n hsa_size.loop = hsa_size\nEnd\nReturn                                      /*                        */\n/**********************************************************************/\n/* version information                                                */\n/**********************************************************************/\nPROC_VERSION:                               /* version details      ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtrac   = Storage(D2x(C2d(cvt)+992),4)     /* get the RCVT address   */\nrcvtvrmn = Storage(D2x(C2d(cvtrac)+616),4)  /* get the RACF version   */\nrcvtfmid = 'HRF'||rcvtvrmn                  /* create FMID name       */\nra = rcvtvrmn\nrcvtvrmn = Substr(ra,1,1)'.'Substr(ra,2,1)'.'Substr(ra,3,2)\ncvtjesct = Storage(D2x(C2d(cvt)+296),4)     /* get the JESCT address  */\njesssct  = Storage(D2x(C2d(cvtjesct)+24),4) /* get jesssct (sscvt)    */\nssctsus2 = Storage(D2x(C2d(jesssct)+28),4)  /* point To $hcct         */\ncctssvs  = Storage(D2x(C2d(ssctsus2)+700),4)/* jes version-level-mod  */\ncc = cctssvs\ncctssvs  = Substr(cc,2,1)'.'Substr(cc,3,1)'.'Substr(cc,4,1)\ncvttvt   = Storage(D2x(C2d(cvt)+156),4)     /* get the TSO VT address */\ntsvttsol = Storage(D2x(C2d(cvttvt)+100),4)  /* get the TSO version    */\nts = tsvttsol\ntsvttsol = Substr(ts,1,1)'.'Substr(ts,2,2)'.'Substr(ts,4,1)\ncvtdfa   = Storage(D2x(C2d(cvt)+1216),4)    /* get the DFP ID table   */\ncvtdfa   = Storage(D2x(C2d(cvt)+1216),4)    /* get the DFP ID table   */\ndfaprod  = Storage(D2x(C2d(cvtdfa)+16),1)   /* get the release byte   */\nIf (dfaprod = 0) Then                       /* DFP                    */\n Do                                         /*                        */\n  df     = Substr(C2x(Storage(D2x(C2d(cvtdfa)+2),2)),1,3)       /*    */\n  dfarel = Substr(df,1,1)'.'Substr(df,2,1)'.'Substr(df,3,1)\n  dfaprd = 'DFP'                            /*                        */\n End                                        /*                        */\nElse                                        /* DFSMS                  */\n Do                                         /*                        */\n  df     = Substr(C2x(Storage(D2x(C2d(cvtdfa)+16),4)),3,6)      /*    */\n  dfarel = Substr(df,1,2)'.'Substr(df,3,2)'.'Substr(df,5,2)\n  dfaprd = 'DFSMS'                          /*                        */\n End                                        /*                        */\ncvtext2  = Storage(D2x(C2d(cvt)+328),4)     /* get the EXT2 address   */\ncvtatcvt = Storage(D2x(C2d(cvtext2)+65),3)  /* get the VTAM AVT       */\nistatcvt = Storage(D2x(C2d(cvtatcvt)+0),4)  /* get the VTAM CVT       */\natcvtlvl = Storage(D2x(C2d(istatcvt)+0),8)  /* get the VTAM version   */\nvt = atcvtlvl\nvtamvers = Substr(vt,3,1)'.'Substr(vt,4,1)'.'Substr(vt,5,1)\nReturn                                      /*                        */\n/**********************************************************************/\n/* Get TCP/IP information - Ken Smith [kenneth.smith@VERIZON.COM]     */\n/*                          at Mon 08/10/2001 7:58 PM                 */\n/*                          on MVS-OE@VM.MARIST.EDU                   */\n/**********************************************************************/\nPROC_TCPIP:                                 /* TCPIP details        ##*/\nvers      = Socket('version')\ninit      = Socket('initialise','LEVELSYS')\nparse var init init_rc subtaskid maxdesc service\nhostid    = Socket('GETHOSTID')\nhostname  = Socket('GETHOSTNAME')\ndomain    = Socket('GETDOMAINNAME')\nportidt   = Socket('GETSERVBYNAME','TELNET','TCP')\nportidf   = Socket('GETSERVBYNAME','FTP','TCP')\nterm      = Socket('terminate')\n/* parse  ======>  ==========> ======>  */\nparse var hostid   return_code tcpaddr\nparse var hostname return_code tcpname\nparse var domain   return_code tcpdom\nparse var portidt  return_code tcp telport telnet\nparse var portidf  return_code tcp ftpport telnet\nReturn                                      /*                        */\n/**********************************************************************/\n/* Get OMVS details                                                   */\n/**********************************************************************/\nPROC_OMVS:                                  /* OMVS details         ##*/\nomvs = syscalls('ON')                       /*                        */\nIf (omvs = 0) Then                          /*                        */\n Do                                         /*                        */\n  Address SYSCALL \"getpwnam \"Userid()\" pw.\" /* get user details       */\n  pw_dir   = pw.pw_dir                      /*                        */\n  pw_gid   = pw.pw_gid                      /*                        */\n  pw_name  = pw.pw_name                     /*                        */\n  pw_shell = pw.pw_shell                    /*                        */\n  pw_uid   = pw.pw_uid                      /*                        */\n  Address SYSCALL \"getmntent mt.\"           /* get mount details      */\n  mount_cnt = mt.0                          /*                        */\n  Do loop = 1 to mount_cnt                  /*                        */\n   mt.loop = mt.mnte_fsname.loop mt.mnte_fstype.loop mt.mnte_dev.loop\n  End                                       /*                        */\n End                                        /*                        */\nx = syscalls('OFF')                         /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* get service unit / performance details                             */\n/**********************************************************************/\n/* Based on code on MXG-L : 13/07/2000                                */\n/* from - Edward(Ed) J. Finnell, III [efinnell@seebeck.ua.edu]        */\n/**********************************************************************/\nPROC_PERFORM:                               /* performance details  ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtopctp = Storage(D2x(C2d(cvt)+604),4)     /* get the RMCT address   */\ncvtpccat = Storage(D2x(C2d(cvt)+764),4)     /* get the PCCAVT address */\nrmctadjc = Storage(D2x(C2d(cvtopctp)+64),4) /* get CPU RATE ADJUSTMENT*/\noffset = 0                                  /*                        */\ncpucnt = 0                                  /*                        */\nDo loop = 0 To 15                           /*                        */\n pcca = Storage(D2x(C2d(cvtpccat)+offset),4)/*                        */\n If (D2x(C2d(pcca)) /= 0) Then              /*                        */\n  cpucnt = cpucnt + 1                       /*                        */\n offset = offset + 4                        /*                        */\nEnd                                         /*                        */\nsu       = 16000000/C2d(rmctadjc)           /* adjust for SUs         */\nunimips  = su/48.5                          /* calc for MIPS          */\nmips     = unimips * cpucnt                 /*                        */\nmsu      = su*cpucnt*3600/1000000           /*                        */\nsu       = Format(su,,2)                    /*                        */\nunimips  = Format(unimips,,2)               /*                        */\nmips     = Format(mips,,2)                  /*                        */\nmsu      = format(msu,,0)                   /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* Get sub-system prefix details - CPFT details from SHOWMVS          */\n/**********************************************************************/\nPROC_SUBSYS_PREFIX:                         /* subsystem prefixes   ##*/\ncvt      = Storage(10,4)                    /* get the CVT address    */\ncvtcucb  = Storage(D2x(C2d(cvt)+100),4)     /* get the UCM address    */\nucmbfext = Storage(D2x(C2d(cvtcucb)+240),4) /* get UCM Base extension */\nucmcpfta = Storage(D2x(C2d(ucmbfext)+176),4)/* get the CPFT address   */\ncpftacro = Storage(D2x(C2d(ucmcpfta)+0),4)  /* Get the CPFT eyecatcher*/\ncpftvrsn = Storage(D2x(C2d(ucmcpfta)+4),1)  /* Get the CPFT version   */\ncpftnume = Storage(D2x(C2d(ucmcpfta)+8),4)  /* Get the CPFT entry cnt */\ncpft1st  = Storage(D2x(C2d(ucmcpfta)+12),4) /* Get CPFT 1st entry off */\ncpftlast = Storage(D2x(C2d(ucmcpfta)+16),4) /* Get CPFT last entry off*/\ncpftent  = D2c(C2d(ucmcpfta)+C2d(cpft1st))  /* get entry address      */\nDo loop = 1 to C2d(cpftnume)                /* loop thru CPFT         */\n cpftflgs = Storage(D2x(C2d(cpftent)+0),1)  /* get the flags          */\n cpftflgs = X2b(C2x(cpftflgs))\n If (Substr(cpftflgs,1,1) = '1') Then cpftscop = 'Sysplex '\n                                 Else cpftscop = 'System  '\n If (Substr(cpftflgs,3,1) = '1') Then cpftfdp1 = 'Syspurge'\n                                 Else cpftfdp1 = 'Purge   '\n If (Substr(cpftflgs,4,1) = '1') Then cpftremv = 'Yes     '\n                                 Else cpftremv = 'No      '\n cpftprfx = Storage(D2x(C2d(cpftent)+4),8)  /* get the prefix         */\n cpftprln = Storage(D2x(C2d(cpftent)+12),1) /* get the prefix length  */\n cpftownr = Storage(D2x(C2d(cpftent)+16),8) /* get the owner          */\n cpftsys  = Storage(D2x(C2d(cpftent)+24),8) /* get the system         */\n cpftasid = Storage(D2x(C2d(cpftent)+28),4) /* get the ASID           */\n cpftent  = D2c(C2d(cpftent)+44)            /* set for next entry     */\n cpft.loop = cpftprfx cpftownr cpftsys cpftscop cpftremv cpftfdp1\nEnd                                         /*                        */\nReturn                                      /*                        */\n/**********************************************************************/\n/* Common procedures                                                  */\n/**********************************************************************/\nSWAREQ:                                     /* SWAREQ Procedure     ::*/\nIf (Right(C2x(Arg(1)),1) \\= 'F') Then       /* SWA=BELOW ?            */\n Return D2c(C2d(Arg(1))+16)                 /* yes, return sva+16     */\nsva=C2d(Arg(1))                             /* convert to decimal     */\ntcb = C2d(Storage(21C,4))                   /* TCB         PSATOLD    */\njscb = C2d(Storage(D2x(tcb+180),4))         /* JSCB        TCBJSCB    */\nqmpl = C2d(Storage(D2x(jscb+244),4))        /* QMPL        JSCBQMPI   */\nqmat = C2d(Storage(D2x(qmpl+24),4))         /* QMAT        QMADD      */\nDo While sva > 65536\n qmat = C2d(Storage(D2x(qmat+12),4))        /* next QMAT     QMAT+12  */\n sva=sva-65536                              /* 010006F -> 000006F     */\nEnd                                         /*                        */\nReturn D2c(C2d(Storage(D2x(qmat+sva+1),4))+16) /* return address      */\n/**********************************************************************/\nDEFINE_PANEL:                               /* Create display panel   */\nX01 = '01'X                                 /* set hex '01' variable  */\nX02 = '02'X                                 /* set hex '02' variable  */\nX03 = '03'X                                 /* set hex '03' variable  */\nX05 = '05'X                                 /* set hex '05' variable  */\nX09 = '09'X                                 /* set hex '09' variable  */\nX0A = '0A'X                                 /* set hex '0A' variable  */\nX0B = '0B'X                                 /* set hex '0B' variable  */\nX16 = '16'X                                 /* set hex '16' variable  */\nX19 = '19'X                                 /* set hex '19' variable  */\nX22 = '22'X                                 /* set hex '22' variable  */\nX08 = '08'X                                 /* set hex '08' variable  */\nX26 = '26'X                                 /* set hex '26' variable  */\nX27 = '27'X                                 /* set hex '27' variable  */\n\"NewStack\"                                  /* Create new stack       */\nmember = 'SYSINFO'                          /* set panel name         */\nQueue \")PANEL KEYLIST(ISRSNAB,ISR)\"\nQueue \")ATTR DEFAULT(\"X01||X02||X03\") FORMAT(MIX)\"\nQueue \" 05 TYPE(PT)\"\nQueue \" 09 TYPE(FP)\"\nQueue \" 0A TYPE(NT)\"\nQueue \" 16 TYPE(VOI) PADC(USER)\"\nQueue \" 19 TYPE(DT)\"\nQueue \" 22 TYPE(WASL) SKIP(ON)\"\nQueue \" 08 TYPE(CH)\"\nQueue \" 0B TYPE(ET)\"\nQueue \" 26 TYPE(NEF) CAPS(ON) PADC(USER)\"\nQueue \" 27 AREA(SCRL) EXTEND(ON)\"\nQueue \")BODY  CMD(ZCMD)\"\nQueue X0A||Centre(X05||\"System Information\"||X0A,78)||X0A\nQueue X09||\"Command ===>\"||X26||Left(\"ZCMD\",65)||X0A\nQueue X27||Left(\"SAREA39\",78)||X27\nQueue X27||Left(\"\",78)||X27\nQueue \")AREA SAREA39\"\nQueue \" User Information\"\nQueue \" \"X09\"Your RACF user-id . . :\"X0B||Left(Userid()  ,53)||X0A\nQueue \" \"X09\"Your RACF name is . . :\"X0B||Left(username  ,53)||X0A\nQueue \" \"X09\"Your RACF account . . :\"X0B||Left(acctnum   ,53)||X0A\nQueue \" \"X09\"Your Connect group  . :\"X0B||Left(aceegrpn  ,53)||X0A\nlead = \" \"X09\"Your RACF groups. . . :\"X0B\ngroups = ''\ngl_cnt = 0\nDo loop = 1 to grp_cnt\n groups = groups||Left(group.loop,10)\n gl_cnt = gl_cnt + 1\n If (gl_cnt = 5) Then\n  Do\n   Queue lead||groups\n   lead = \" \"X09\"                       \"X0B\n   groups = ''\n   gl_cnt = 0\n  End\nEnd\nIf (gl_cnt > 0) Then\n Queue lead||groups\nIf (Strip(team) /= '') & (Strip(team) /= 'TEAM') Then\n Queue \" \"X09\"Your logon team . . . :\"X16||Left(\"TEAM    \",53)||X0A\nQueue \" \"X09\"Your Terminal ID. . . :\"X0B||Left(aceetrid  ,53)||X0A\nQueue \" \"X09\"Your job ID . . . . . :\"X0B||Left(ssibjbid  ,53)||X0A\nQueue \" \"X09\"Your RACF Attributes. :\"X0B||Left(racfacc   ,53)||X0A\nIf (strip(lwalgcmd,B) /= '') Then\n Queue \" \"X09\"Your logon command. . :\"X0B||Left(lwalgcmd  ,53)||X0A\nQueue \" \"X09\"Your current APPLID . :\"X16||Left(\"ZAPPLID \",53)||X0A\nQueue \" \"X09\"Your current PREFIX . :\"X16||Left(\"ZPREFIX \",53)||X0A\nQueue \" \"X09\"Screens in use. . . . :\"X16||Left(\"ZSCRCUR \",53)||X0A\nQueue \" \"X09\"Maximum screens . . . :\"X16||Left(\"ZSCRMAX \",53)||X0A\nQueue \" \"X09\"Region Size . . . . . :\"X0B||Left(region    ,53)||X0A\nIf (omvs = 0) Then\n Do\n  Queue \" \"X09\"OMVS Initial Work Dir :\"X0B||Left(pw_dir    ,53)||X0A\n  Queue \" \"X09\"OMVS Group ID . . . . :\"X0B||Left(pw_gid    ,53)||X0A\n  Queue \" \"X09\"OMVS Shell. . . . . . :\"X0B||Left(pw_shell  ,53)||X0A\n  Queue \" \"X09\"OMVS UID. . . . . . . :\"X0B||Left(pw_uid    ,53)||X0A\n End\nQueue \" \"\nQueue \" System Information\"\nQueue \" \"X09\"System ID . . . . . . :\"X16||Left(\"ZSYSID  \",53)||X0A\nQueue \" \"X09\"SMF ID. . . . . . . . :\"X0B||Left(smcasid   ,53)||X0A\nQueue \" \"X09\"GRS Name. . . . . . . :\"X0B||Left(cvtsname  ,53)||X0A\nQueue \" \"X09\"GRS Mode. . . . . . . :\"X0B||Left(ecvtgmod  ,53)||X0A\nQueue \" \"X09\"Sysplex Identifier. . :\"X0B||Left(ecvtclon  ,53)||X0A\nQueue \" \"X09\"Sysplex Name  . . . . :\"X0B||Left(ecvtsplx  ,53)||X0A\nIf (Strip(ecvtlpnm) /= '') Then\n Queue \" \"X09\"LPAR name . . . . . . :\"X0B||Left(ecvtlpnm  ,53)||X0A\nIf (Strip(csdplpn) /= '') Then\n Queue \" \"X09\"LPAR number . . . . . :\"X0B||Left(csdplpn   ,53)||X0A\nIf (Strip(ecvthdnm) /= '') Then\n Queue \" \"X09\"Hardware name . . . . :\"X0B||Left(ecvthdnm  ,53)||X0A\nIf (Strip(ecvtvmnm) /= '') Then\n Queue \" \"X09\"VM Host name. . . . . :\"X0B||Left(ecvtvmnm  ,53)||X0A\nQueue \" \"X09\"Product Owner . . . . :\"X0B||Left(ecvtpown  ,53)||X0A\nQueue \" \"X09\"Product Name. . . . . :\"X0B||Left(ecvtpnam  ,53)||X0A\nQueue \" \"X09\"Product Version . . . :\"X0B||Left(ecvtpver  ,53)||X0A\nQueue \" \"X09\"Product Release . . . :\"X0B||Left(ecvtprel  ,53)||X0A\nQueue \" \"X09\"Product mod level . . :\"X0B||Left(ecvtpmod  ,53)||X0A\nQueue \" \"X09\"JES name. . . . . . . :\"X0B||Left(cctssnm   ,53)||X0A\nQueue \" \"X09\"JES node name . . . . :\"X0B||Left(cctndenm  ,53)||X0A\nQueue \" \"X09\"JES command character :\"X0B||Left(cctcomch  ,53)||X0A\nQueue \" \"X09\"RACF. . . . . . . . . :\"X0B||Left(racf      ,53)||X0A\ncurmastc = dsncat||' on '||volcat           /* build for display      */\nQueue \" \"X09\"Master Catalog  . . . :\"X0B||Left(curmastc  ,53)||X0A\ncurracfd = dsnrac||' on '||volrac           /* build for display      */\nQueue \" \"X09\"RACF Database . . . . :\"X0B||Left(curracfd  ,53)||X0A\nQueue \" \"\nQueue \" Sub-System Information\"\nQueue \" \"X09\"Prefix   Owner    System   Scope    Remove   Faildisp\"\nDo loop = 1 to C2d(cpftnume)\n Queue \" \"X0B||cpft.loop||X0A\nEnd\nQueue \" \"\nQueue \" Software Information\"\nQueue \"                          Version                  FMID\"\ntext = X09\"MVS . . . . . . . . . :\"X0B\nQueue \" \"text||Left(mvsver,25)||Left(mvsfmid,8)||X0A\ntext = X09\"RACF  . . . . . . . . :\"X0B\nQueue \" \"text||Left(rcvtvrmn,25)||rcvtfmid||X0A\ntext = X09\"JES . . . . . . . . . :\"X0B\nQueue \" \"text||Left(cctssvs,25)||X0A\ntext = X09\"ISPF  . . . . . . . . :\"X16\nQueue \" \"text||Left(\"ZISPFOS\",25)||X0A\npad = '. . . . . . . . . . . . . . :'\ndfaprd = dfaprd||' '\ndfa_len  = Length(dfaprd)\ntext = X09||dfaprd||Right(pad,23-dfa_len)||X0B\nQueue \" \"text||Left(dfarel,25)||X0A\ntext = X09\"TSO . . . . . . . . . :\"X0B\nQueue \" \"text||Left(tsvttsol,25)||X0A\ntext = X09\"VTAM  . . . . . . . . :\"X0B\nQueue \" \"text||Left(vtamvers,25)||X0A\nQueue \" \"\nQueue \" TCP/IP Information\"\nQueue \" \"X09\"Domain name . . . . . :\"X0B||Left(tcpdom    ,53)||X0A\nQueue \" \"X09\"Host ID . . . . . . . :\"X0B||Left(tcpaddr   ,53)||X0A\nQueue \" \"X09\"Host Name . . . . . . :\"X0B||Left(tcpname   ,53)||X0A\nQueue \" \"X09\"Telnet Port-ID  . . . :\"X0B||Left(telport   ,53)||X0A\nQueue \" \"X09\"FTP Port-ID . . . . . :\"X0B||Left(ftpport   ,53)||X0A\nQueue \" \"\nQueue \" Symbolic Information\"\nDo loop = 1 to C2d(symbtnumberofsymbols)\n pad = '. . . . . . . . . . . . . . :'\n sym_name = sym_nam.loop||' '\n sym_len  = Length(sym_name)\n sym_name = sym_name||Right(pad,23-sym_len)\n Queue \"  \"||sym_name||X0B||Left(sym_val.loop,53)||X0A\nEnd\nQueue \" \"\nQueue \" Storage Information\"\nQueue \" \"X09\"Real. . . . . . . . . :\"X0B||Left(cvtrlstg  ,53)||X0A\nbuff_rel = stor_rel - Strip(cvtrlstg,T,'M')\nIf (buff_rel > 0) Then\n Queue \" \"X09\"Buffer (Real) . . . . :\"X0B||Left(buff_rel'M',53)||X0A\nQueue \" \"X09\"Extended. . . . . . . :\"X0B||Left(rceespl   ,53)||X0A\nbuff_ext = stor_ext - Strip(rceespl,T,'M')\nIf (buff_ext > 0) Then\n Queue \" \"X09\"Buffer (Extended) . . :\"X0B||Left(buff_ext'M',53)||X0A\nQueue \" \"X09\"Private < 16M . . . . :\"X0B||Left(gdapvtsz  ,53)||X0A\nIf (C2d(sccbnhsa) > 0) Then\n Do loop =  1 to C2d(sccbnhsa)\n  text = \" \"X09\"HSA . . . . . . . . . :\"X0B||Right(loop,3)\n  text = text||hsa_size.loop||X0A\n  Queue text\n End\nQueue \" \"\nQueue \" User Storage\"\nQueue \" \"X09\"Region Requested. . . :\"X0B||Left(ldaregrq  ,53)||X0A\nQueue \" \"X09\"<16M Limit. . . . . . :\"X0B||Left(ldalimit  ,53)||X0A\nQueue \" \"X09\">16M Limit. . . . . . :\"X0B||Left(ldaelim   ,53)||X0A\nQueue \" \"X09\"<16M Used . . . . . . :\"X0B||Left(ldaloal   ,53)||X0A\nQueue \" \"X09\">16M Used . . . . . . :\"X0B||Left(ldaeloal  ,53)||X0A\nQueue \" \"\nQueue \" Virtual Storage Map\"\nQueue Left(' ',26)||\"Start    End          Size    Used Convert\"\nQueue \" \"X09\"             PSA  . . :\"X0B||Left(stor_psa      ,53)||X0A\nQueue \" \"X09\"          System  . . :\"X0B||Left(stor_system   ,53)||X0A\nQueue \" \"X09\"     Private V=R  . . :\"X0B||Left(stor_priv_vr  ,53)||X0A\nQueue \" \"X09\"     Private V=V  . . :\"X0B||Left(stor_priv_vv  ,53)||X0A\nQueue \" \"X09\"             CSA  . . :\"X0B||Left(stor_csa      ,53)||X0A\nQueue \" \"X09\"            MLPA  . . :\"X0B||Left(stor_mlpa     ,53)||X0A\nQueue \" \"X09\"            FLPA  . . :\"X0B||Left(stor_flpa     ,53)||X0A\nQueue \" \"X09\"            PLPA  . . :\"X0B||Left(stor_plpa     ,53)||X0A\nQueue \" \"X09\"             SQA  . . :\"X0B||Left(stor_sqa      ,53)||X0A\nQueue \" \"X09\"     R/W Nucleus  . . :\"X0B||Left(stor_nuc_rw   ,53)||X0A\nQueue \" \"X09\"     R/O Nucleus  . . :\"X0B||Left(stor_nuc_ro   ,53)||X0A\nQueue \" \"X09\"            16M  ---------------------------------\"||X0A\nQueue \" \"X09\"Ext. R/O Nucleus  . . :\"X0B||Left(stor_nuc_ero  ,53)||X0A\nQueue \" \"X09\"Ext. R/W Nucleus  . . :\"X0B||Left(stor_nuc_erw  ,53)||X0A\nQueue \" \"X09\"        Ext. SQA  . . :\"X0B||Left(stor_e_sqa    ,53)||X0A\nQueue \" \"X09\"       Ext. PLPA  . . :\"X0B||Left(stor_e_plpa   ,53)||X0A\nQueue \" \"X09\"       Ext. FLPA  . . :\"X0B||Left(stor_e_flpa   ,53)||X0A\nQueue \" \"X09\"       Ext. MLPA  . . :\"X0B||Left(stor_e_mlpa   ,53)||X0A\nQueue \" \"X09\"        Ext. CSA  . . :\"X0B||Left(stor_e_csa    ,53)||X0A\nQueue \" \"X09\"    Ext. Private  . . :\"X0B||Left(stor_e_priv   ,53)||X0A\nQueue \" \"\nQueue \" IPL Information\"\nQueue \" \"X09\"LOAD Parameter. . . . :\"X0B||Left(ipalparm  ,53)||X0A\nQueue \" \"X09\"LOAD Parm DSN . . . . :\"X0B||Left(ipalpdsn  ,53)||X0A\nQueue \" \"X09\"IEASYSxx suffix . . . :\"X0B||Left(ipasplst  ,53)||X0A\nQueue \" \"X09\"Parmlib/s . . . . . . :\"X0B||Left(parmlin.1 ,69)||X0A\nIf (parm_cnt > 1) Then\n Do loop = 2 to parm_cnt\n  Queue \" \"Right(X0B,25)||Left(parmlin.loop,69)||X0A\n End\nQueue \" \"X09\"Last IPL. . . . . . . :\"X0B||Left(ipldates  ,53)||X0A\nQueue \" \"X09\"Current Date  . . . . :\"X0B||Left(curdates  ,53)||X0A\nQueue \" \"X09\"Elapsed Since IPL . . :\"X0B||Left(offdates  ,53)||X0A\ncurres   = sysuad||' - '||sysres            /* build for display      */\nQueue \" \"X09\"RES Volume. . . . . . :\"X0B||Left(curres    ,53)||X0A\nQueue \" \"X09\"IO Config . . . . . . :\"X0B||Left(cvtiocid  ,53)||X0A\nQueue \" \"X09\"IODF Dataset. . . . . :\"X0B||Left(iodfname  ,53)||X0A\nQueue \" \"X09\"Configuration ID. . . :\"X0B||Left(iodfcfgi  ,53)||X0A\nQueue \" \"X09\"EDT . . . . . . . . . :\"X0B||Left(iodfedt   ,53)||X0A\nIf (Substr(iodfproc,1,1) <> '00'X) &,\n   (Substr(iodfproc,1,1) <> '40'X) Then\n Do\n  Queue \" \"X09\"IODF Processor. . . . :\"X0B||Left(iodfproc  ,53)||X0A\n  iodftext = iodfdate' 'iodftime\n  Queue \" \"X09\"IODF Date/Time. . . . :\"X0B||Left(iodftext  ,53)||X0A\n  Queue \" \"X09\"IODF Description. . . :\"X0B||Left(iodfdesc  ,53)||X0A\n End\nQueue \" \"X09\"Master JCL. . . . . . :\"X0B||Left(mstrjcl   ,53)||X0A\nQueue \" \"\nDo loop = 1 to mjcl0\n Queue \" \"Right(X0B,9)||Left(\"&mjcl\"loop,69)||X0A\nEnd\nQueue \" \"\nQueue \" Hardware Information - General\"\nQueue \" \"X09\"CPU Type. . . . . . . :\"X0B||Left(type      ,53)||X0A\nQueue \" \"X09\"CPU Model . . . . . . :\"X0B||Left(model     ,53)||X0A\nQueue \" \"X09\"CPU Manufacturer. . . :\"X0B||Left(man       ,53)||X0A\nQueue \" \"X09\"CPU Plant . . . . . . :\"X0B||Left(plant     ,53)||X0A\nQueue \" \"X09\"CPU Sequence Number . :\"X0B||Left(seqno     ,53)||X0A\nQueue \" \"X09\"CPU Serial Model. . . :\"X0B||Left(cpumod    ,53)||X0A\nQueue \" \"\nQueue \" Hardware Information - This complex\"\nQueue \" \"X09\"CPU Count . . . . . . :\"X0B||Left(cpucnt    ,53)||X0A\nQueue \" \"X09\"CPU Serials . . . . . :\"X0B\"#1 \"Left(CPU.1     ,50)||X0A\nDo loop = 2 to cpucnt\n no = '#'Left(loop,2)\n Queue \" \"X09\"                       \"X0B||no||Left(CPU.loop,50)||X0A\nEnd\nQueue \" \"X09||\"CPU SU/Sec. . . . . . :\"X0B||Left(su        ,53)||X0A\nQueue \" \"X09||\"CPU MIPS. . . . . . . :\"X0B||Left(mips      ,53)||X0A\nQueue \" \"X09||\"CPU MIPS (single) . . :\"X0B||Left(unimips   ,53)||X0A\nQueue \" \"X09||\"CPU MSU (not Amdahl). :\"X0B||Left(msu       ,53)||X0A\nQueue \" \"\nQueue \" Address Space Information\"\nQueue \" \"X09||\"Maximum ASIDs . . . . :\"X0B||Left(asvtmaxu  ,53)||X0A\nQueue \" \"X09||\"Available ASIDs . . . :\"X0B||Left(asvtaav   ,53)||X0A\nQueue \" \"X09||\"ASIDs in-use. . . . . :\"X0B||Left(okcnt     ,53)||X0A\nQueue \" \"X09||\"ASIDs non-reusable. . :\"X0B||Left(duffcnt   ,53)||X0A\nQueue \" \"X09||\"Free Slots SASI queue :\"X0B||Left(asvtast   ,53)||X0A\nQueue \" \"X09||\"Free Slots NonR queue :\"X0B||Left(asvtanr   ,53)||X0A\nQueue \" \"X09||\"Orig. size SASI queue :\"X0B||Left(asvtstrt  ,53)||X0A\nQueue \" \"X09||\"Orig. size NonR queue :\"X0B||Left(asvtnonr  ,53)||X0A\nQueue \" \"\nQueue \" Page Dataset Information\"\nQueue \"  type             used    slots addr volser dsname\"\nDo loop = 1 to page_cnt\n Queue \" \"X0B||Left(pagelist.loop,77)||X0A\nEnd\nQueue \" \"\nQueue \" IEASYSxx Parameter Details\"\nQueue \"  source         parm value\"\nDo loop = 1 to para_cnt\n If (loop < para_cnt) Then delim = ','\n                      Else delim = ' '\n If (parm_nm.loop = 'NONVIO')   |,\n    (parm_nm.loop = 'PAGE')     |,\n    (parm_nm.loop = 'PAGE-OPR') |,\n    (parm_nm.loop = 'SWAP')     Then\n  Do\n   dsns = Translate(parm.loop,' ',',')\n   dsns_cnt = Words(dsns)\n   parm_name = parm_nm.loop\n   parm_type = parm_ty.loop\n   parm_sign= '='\n   Do doop = 1 to dsns_cnt\n    parm_disp = Right(parm_name,10)||parm_sign||Word(dsns,doop)||\",\"\n    Queue \"  \"||parm_type||X0B||Left(parm_disp,60)||X0A\n    parm_name = Left('',10)\n    parm_sign = Left('',2)\n    parm_type = Left('',8)\n   End\n  End\n Else\n  Do\n   parm_disp = Right(parm_nm.loop,10)||'='||parm.loop||delim\n   Queue \"  \"||parm_ty.loop||X0B||Left(parm_disp,60)||X0A\n  End\nEnd\nQueue \" \"\nQueue X22||X22\nQueue \")INIT\"\nQueue \"&ZCMD = ' '\"\nQueue \")PROC\"\nQueue \")END\"\nReturn\n/**********************************************************************/\nCREATE_MEMBER:                              /* Create Member in PDS   */\nDo loop = 1 To 50                           /* loop thru up to 50     */\n fil = 'DYNAM'||loop                        /*  build filename        */\n x = Listdsi(fil FILE)                      /*  test filename         */\n If (sysreason > 0) Then                    /*  if not present        */\n  Leave                                     /*   use it !             */\nEnd                                         /* end loop               */\nAddress TSO                                 /* set address            */\n\"Alloc Fi(\"fil\") \",                         /* Allocate dyamic        */\n      \"Lrecl(80) Blksize(0) RecFm(F B) \",   /*  dataset to selected   */\n      \"Cylinders Space(1,1) \",              /*   filename             */\n      \"Unit(SYSDA) Dir(20) New Reu\"         /*                        */\nX = Listdsi(fil FILE)                       /* get the file details   */\nstack = Queued()                            /*   get stack size       */\nIf (stack > 0) Then                         /*   if data on stack     */\n Do                                         /*                        */\n  \"Alloc Fi(MEMOUT) Shr Reu \",              /*    create member       */\n        \"Da('\"sysdsname\"(\"member\")')\"       /*                        */\n  \"ExecIO \"stack\" DiskW MEMOUT (Finis)\"     /*    write stack > member*/\n  \"Free Fi(MEMOUT)\"                         /*    free member         */\n End                                        /*                        */\nmember = Word(line,2)                       /*   get next member name */\n\"DelStack\"                                  /* Clear stack            */\n/*\nAddress ISPEXEC \"EDIT DATASET('\"SYSDSNAME\"') VOLUME(\"SYSVOLUME\")\"\n*/\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TABLSTAT": {"ttr": 9479, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00T\\x00\\x98&\\x1f\\x01\\x03\\x06/\\x10)\\x00N\\x00\\x16\\x00\\x00\\xc5\\xc5\\xc9\\xe3\\xf0\\xf4\\xf5@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1998-09-18T00:00:00", "modifydate": "2003-03-03T10:29:54", "lines": 78, "newlines": 22, "modlines": 0, "user": "EEIT045"}, "text": "/* REXX - TABLSTAT : Add ISPF stats to all ISPF tables in a PDS       */\n/**********************************************************************/\n/* Author : Alastair Gray - a_j_gray@hotmail.com                      */\n/*                 (or the e-mail I use to post on TSO-REXX/IBM-MAIN) */\n/**********************************************************************/\n/* Changes :                                                          */\n/* 1.0.0   - 18/09/1998 - Alastair Gray - Original version            */\n/* 1.0.1   - 09/06/2002 - Alastair Gray                               */\n/* 1.0.2   - 13/09/2002 - Alastair Gray - Added comments              */\n/**********************************************************************/\nArg dsn                                /*                             */\ndsn = Strip(dsn,B,\"'\")                 /*                             */\nx = Msg(on)                            /*                             */\nx = Prompt(off)                        /*                             */\n/**********************************************************************/\nAddress ISPEXEC                        /*                             */\n\"Control Errors Return\"                /*                             */\n\"LibDef  TABSTAT Dataset Id('\"dsn\"')\"  /*                             */\n\"LMInit  DataID(table) Dataset('\"dsn\"') Enq(ShrW)\" /*                 */\n\"LMOpen  DataID(\"table\") Option(Input)\"/*                             */\nmember = ''                            /*                             */\nlrc = 0                                /* loop on members             */\nDo while lrc = 0                       /*                             */\n \"LMMList DataID(\"table\") Option(List) Member(member) Stats(yes)\"\n lrc = rc                              /*                             */\n member = Strip(member,T)              /* get member name             */\n If (zlvers = '') Then                 /* no version ?                */\n  Do                                   /*  get table stats            */\n   \"TBStats \"member\" CDate(zlcdate) UDate(zlmdate) Utime(zlmtime) \",\n            \"User(zluser) Library(TABSTAT) \",\n            \"Status1(stat1) Status2(stat2) Status3(stat3)\"\n   trc = rc                            /*                             */\n   zlvers = 1                          /*                             */\n   zlmod  = 0                          /*                             */\n   If (stat2 > 1) |,                   /* if 'old' table              */\n      (zlcdate = 'R1 TABLE') Then      /*  go to read direct          */\n    Do                                 /*                             */\n     Address TSO                       /*                             */\n     \"Alloc Fi(MEMIN) Da('\"dsn\"(\"member\")') Shr Reu\" /*               */\n     \"ExecIO 1 DiskR MEMIN (Finis Stem line.)\" /*                     */\n     \"Free Fi(MEMIN)\"                  /*                             */\n     Address ISPEXEC                   /*                             */\n     zluser = Substr(line.1,51,8)      /*  get userid                 */\n     zlcdate = Substr(line.1,39,3)     /*  get creation date          */\n     zlmdate = Substr(line.1,45,3)     /*  get modification date      */\n     zlmdate = Substr(C2x(zlmdate),1,5)/*                             */\n     zlmdate = Date('O',zlmdate,'J')   /*  convert date format        */\n     If (zlcdate = '   ') Then         /*  no creation                */\n      zlcdate = zlmdate                /*   use modification          */\n     Else                              /*                             */\n      Do                               /*                             */\n       zlcdate = Substr(C2x(zlcdate),1,5) /*                          */\n       zlcdate = Date('O',zlcdate,'J') /*  convert date format        */\n      End                              /*                             */\n     zlmtime = Substr(line.1,48,3)     /*  get modification time      */\n     zlmtime = C2x(zlmtime)            /*                             */\n     zlmtime = Substr(zlmtime,1,2)||':'||Substr(zlmtime,3,2)\n    End                                /*                             */\n   Else                                /* Tbstats OK                  */\n    If (zlcdate /= '') Then            /*                             */\n     Do                                /*                             */\n      zlmtime = Substr(zlmtime,1,2)||\":\"||Substr(zlmtime,4,2)\n      zluser = Strip(zluser,T)         /*                             */\n     End                               /*                             */\n   \"LMMStats DataID(\"table\") Member(\"member\") \",\n            \"Version(\"zlvers\") ModLevel(\"zlmod\") \",\n            \"Created(\"zlcdate\") \",     /*                             */\n            \"ModDate(\"zlmdate\") ModTime(\"zlmtime\") \",\n            \"User(\"zluser\") \"          /*                             */\n   src = rc                            /*                             */\n  End                                  /*                             */\nEnd                                    /*                             */\n\"LMMList DataID(\"table\") Option(Free)\" /*                             */\n\"LMClose DataID(\"table\")\"              /*                             */\n\"LMFree  DataID(\"tabls\")\"              /*                             */\n\"LibDef  TABSTAT\"                      /*                             */\n/**********************************************************************/\nExit 0                                 /*                             */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT542/FILE542.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT542", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}