{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013445000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE921.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE921.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x11'", "DS1TRBAL": "b'K\\xb4'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\tC\\x00\\x03\\tC\\x00\\n\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Y\\x00\\x05\\x01\\x14(o\\x01\\x14(o\\x13\\x17\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf9@@@'", "ispf": {"version": "04.89", "flags": 0, "createdate": "2014-10-13T00:00:00", "modifydate": "2014-10-13T13:17:05", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-489"}, "text": "REGULAR CBT TAPE - VERSION 489    FILE:  921\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT489.FILE921\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 17 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,320 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/13/14    13:17:05    UTC-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE921": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04Y\\x00Y\\x01\\x14(o\\x01\\x14(o\\x13\\x16\\x005\\x005\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf9@@@'", "ispf": {"version": "04.89", "flags": 0, "createdate": "2014-10-13T00:00:00", "modifydate": "2014-10-13T13:16:59", "lines": 53, "newlines": 53, "modlines": 0, "user": "CBT-489"}, "text": "//***FILE 921 is from Albert Cheng and contains TSO utility to      *   FILE 921\n//*           allocate ISPF datasets.                               *   FILE 921\n//*                                                                 *   FILE 921\n//*             email:   albertcpcheng@hotmail.com                  *   FILE 921\n//*                                                                 *   FILE 921\n//*    @GUIDE   - User Guide of ISPFDSN                             *   FILE 921\n//*                                                                 *   FILE 921\n//*    @SMPE    - Sample CLIST to invoke SMPE using LIBDEF if       *   FILE 921\n//*               SMPE ISPF datasets are not allocated              *   FILE 921\n//*                                                                 *   FILE 921\n//*    ASSEMBLE - Sample JCL to assemble and link-edit ISPFDSN      *   FILE 921\n//*                                                                 *   FILE 921\n//*    BATCH    - Sample JCL to test ISPFDSN in batch mode          *   FILE 921\n//*                                                                 *   FILE 921\n//*    DB2      - Sample DB2 ISPFDSN parameter in GLOBAL ISPFDSN    *   FILE 921\n//*               library                                           *   FILE 921\n//*                                                                 *   FILE 921\n//*    FILEMGR  - Sample FILEMGR ISPFDSN parameter in GLOBAL        *   FILE 921\n//*               ISPFDSN library                                   *   FILE 921\n//*                                                                 *   FILE 921\n//*    HISPFDSN - Help file of ISPFDSN                              *   FILE 921\n//*                                                                 *   FILE 921\n//*    INHOUSE  - Sample ISPFDSN parameter file (in-house ISPF      *   FILE 921\n//*               dataset allocation parameter)                     *   FILE 921\n//*                                                                 *   FILE 921\n//*    ISPFDSN  - TSO command processor to allocate ISPF datasets   *   FILE 921\n//*               in native TSO. ISPFDSN read the $ISPFDSN parmlib  *   FILE 921\n//*               to allocate ISPF datasets. It can also read your  *   FILE 921\n//*               TSO logon proc to allocate ISPF datasets for new  *   FILE 921\n//*               users which are not familiar with ISPFDSN.        *   FILE 921\n//*               Refer @GUIDE to implement ISPFDSN in your         *   FILE 921\n//*               installation.                                     *   FILE 921\n//*                                                                 *   FILE 921\n//*    ISPFMSGS - Messages of ISPFDSN                               *   FILE 921\n//*                                                                 *   FILE 921\n//*    ISPFDSNG - Sample ISPFDSN parameter file (global ISPF        *   FILE 921\n//*               dataset allocation parameter)                     *   FILE 921\n//*                                                                 *   FILE 921\n//*    ISPFDSNT - Sample ISPFDSN parameter file (team ISPF          *   FILE 921\n//*               dataset allocation parameter)                     *   FILE 921\n//*                                                                 *   FILE 921\n//*    ISPFDSNU - Sample ISPFDSN parameter file (user ISPF          *   FILE 921\n//*               dataset allocation parameter)                     *   FILE 921\n//*                                                                 *   FILE 921\n//*    LOGON    - Sample TSO Procedure to allocate ISPF profile     *   FILE 921\n//*               and invoke ISPFDSN.                               *   FILE 921\n//*                                                                 *   FILE 921\n//*    SYSTEM   - Sample ISPFDSN parameter that all the TSO users   *   FILE 921\n//*               refers. (note: update this member affects all     *   FILE 921\n//*               the TSO ISPF dataset allocation if you convert    *   FILE 921\n//*               all the TSO users to use ISPFDSN to perform ISPF  *   FILE 921\n//*               dataset allocation)                               *   FILE 921\n//*                                                                 *   FILE 921\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@GUIDE": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00A\\x01\\x14(o\\x01\\x14(o\\x17\\x13\\x01\\x83\\x01\\x83\\x00\\x00\\xe2\\xd7\\xe7\\xe7\\xc3\\xc3\\xd7@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "2014-10-13T00:00:00", "modifydate": "2014-10-13T17:13:41", "lines": 387, "newlines": 387, "modlines": 0, "user": "SPXXCCP"}, "text": "ISPFDSN is a TSO command processor to allocate ISPF datasets\ndynamically in native TSO.\n\nTSO logon procedures allocates the ISPF datasets require to execute ISPF.\nIf the ISPF datasets do not exist, you cannot logon TSO due to JCL error.\n\nFunction : ISPFDSN refers SYS1.$ISPFDSN.&SID($ISPFDSN) to perform\n           dataset allocation. ISPFDSN does not allocate the dataset\n           if any one of the following condition occurs:\n\n           1) The dataset is not catalogued\n           2) The dataset is catalogued but the volume is offline\n           3) The user has no RACF read authority to the dataset\n           4) If BYPHSM option is specified, migrated dataset is\n              ignored\n           5) If the dataset is already allocated under the same\n              DDNAME\n           6) The dataset is exclusive own by another task\n\nAdvantage:\n           1) It is faster than using REXX to allocate ISPF datasets\n           2) ISPFDSN does not allocate the dataset if the user does\n              not have read access right. ISPFDSN avoids S913.\n              Sensitive software product have RACF access protection\n              are defined in GLOBAL ISPFDSN parameter and only users\n              with read access to those product can access the\n              software product. It is no need to maintain a unique\n              TSO logon procedure to allocate those sensitive software\n              product ISPF datasets.\n           3) Avoid TSO logon procedure JCL errors as ISPFDSN ignores\n              non-exist datasets.\n           4) Avoid TSO logon failure if you catalogue the dataset in\n              one LPAR and forget to catalog the dataset at another\n              LPAR.\n           5) It is easy to implement as the synatx of ISPFDSN parameter\n              is same as MVS JCL. Make minor modification to your TSO\n              logon procedures and logon clist. New ISPFDSN users can\n              invoke ISPFDSN to access their TSO logon procedures to\n              allocate files.\n\n              Command : ISPFDSN LOGONPRC\n              ISPFDSN allocates files from TSO logon procedure\n              in SYS1.$ISPFDSN.PROCLIB(tsoproc)\n           6) TSO advanced users allocates ISPF dataset from ISPFDSN\n              parameters\n\n              Command : ISPFDSN\n              ISPFDSN allocates ISPF dataset in the following order\n              &SYSUID.ISPF.ISPPOF($ISPFDSN) or        <-- Optional\n                      &SYSUID.$ISPFDSN.user($ISPFDSN) <-- Compulsory\n              prefix.$ISPFDSN.&sid($ISPFDSN)\n              prefix.$ISPFDSN.racfgrp($ISPFDSN) or    <-- Optional\n                      prefix.$ISPFDSN.group($ISPFDSN)\n\n              It is easy to manage as the dataset allocation is by\n              means of software product. (ie change one ISPFDSN\n              member in global ISPFDSN parmlib affects all the TSO\n              logon pocedures if you convert all the TSO logon\n              procedures to ISPFDSN)\n           7) TSO advanced users can allocates their own private\n              datasets in &SYSUID.ISPF.ISPPROF($ISPFDSN). It is no\n              need to invoke CBTTAPE CONCAT to perform their private\n              ISPF datasets.\n\nPARMS :     GROUP(xxxxx)  - Process as if xxxxx is used as the RACF\n                            group. xxxxx can be an application project\n                            name or RACF group. The default group is\n                            the user's default RACF group.\n            LIST          - Report on any allocations that fail and\n                            migrated data set bypassed.\n            TRACE         - Generate trace messages for problem\n                            determination.\n            BYPHSM        - Bypass allocation of HSM migration dataset\n                            in case of HSM is inactive\n            LOGONPRC      - Use tso logon proc name as the member name\n                            of SYS1.$ISPFDSN.PROCLIB(&sysproc)\n                            (note: if LOGONPRC is specified, ISPFDSN\n                             does not access global ISPFDSN parmlib\n                             to allocate files)\n            DSN(xxxx)     - Data set name of TSO logon procedure\n                            (Note: Keyword DSN is mutally exclusive\n                             LOGONPRC. When LOGOBPRC is specified,\n                             DSN and MEMBER are ignored)\n            MEMBER(xxxx)  - Member name of TSO logon procedure\n                            (Note: works only if DSN keyword is\n                             specified).\n            PREFIX(SYS1)  - The prefix of ISPFDSN parmlib. Default is\n                            SYS1.\n            USER(xxxx)    - Suffix of your own personnel ISPFDSN.\n                            when it is specified, ISPFDSN allocates\n                            dataset in &SYSUID.$ISPFDSN.xxxx($ISPFDSN)\n                            Default personnel ISPFDSN parmlib member\n                            is &SYSUID.ISPF.ISPPROF($ISPFDSN).\n            GRPB4GLB      - Allocate group ISPFDSN datasets before\n                            global ISPFDSN datasets\n                            (Note: DEFAULT is global ISPFDSN datasets\n                                   before group ISPFDSN datasets)\n            NORACF        - Bypass RACHECK processing just in case\n                            the RACF data base is exclusive enqued\n                            by some tasks.\n\n\nISPFDSN can be executed with or without ISPFDSN parmlib. New users\nis recommended to implement ISPFDSN as suggested in the section of new\nusers if their TSO logon procedure does not have unsupported ddname\nand the DD statements only contain DISP and DSN keyword. For detail\nrefers the syntax of ISPFDSN parmlib. If your TSO logon procedure has\nSTEPLIB or JOBLIB, you have to keep STEPLIB and JOBLIB in your TSO\nprocedure.\n\nAfter you are familar with ISPFDSN, refer the section advanced user\nto convert your TSO logon procedures to ISPFDSN parameter which will\nsimplify the maintenance of TSO logon procedures.\n\nAssemble ISPFDSN and copy the load module into any linklist libraries.\nIssue MVS Command 'F LLA,REFRESH' to refresh the MVS linklist.\n\nSection (New users)\n1. Copy your TSO logon procedures to prefix.$ISPFDSN.PROCLIB. Amend\n   your original logon procedure using the following template\n   where dddd is the PDS of your logon procedure and ppppppp is the\n   logon clist name.\n\n//IKJACCNT PROC\n//IKJACCNT EXEC PGM=IKJEFT01,DYNAMNBR=600,\n//         PARM='EX ''dddd(ppppppp)'''\n//*\n   Amend CLIST ppppppp and add the following statement\n   ISPFDSN LOGONPRC\n\nA standard TSO logon procedure, allocate user ISPF profile. If it does\nnot exist, allocate a new ISPF profile.  Invoke 'ISPFDSN LOGONPRC' and\nthen invoke ISPF.\n\nRefer the following rules to modify your TSO logon procedres.\n\n 1) The following ddnames cannot be concatenated\n    DDNAME=STEPLIB,JOBLIB,STEPCAT,JOBCAT,ISPTABL,ISPPROF\n    ISPPROF and ISPTABL are supposed to be allocated by TSO              921\n    logon clist.\n\n 2) The following ddnames cannot be allocated as they are\n    restricted by SVC99.\n    DDNAME=STEPLIB,JOBLIB,STEPCAT,JOBCAT\n\n 3) DISP=NEW is not supported                                            921\n                                                                         921\n 4) GDG allocation is not supported                                      921\n                                                                         921\n 5) It only supports DISP=SHR,DSN=XXXX in one line                       921\n    Note : DSN=XXXX,DISP=SHR are not supported\n           UNIT and VOL=SER=XXXXXX are not supported\n                                                                         921\nAdvanced User\n1. Assume you are running sysplex and you want to each system has its\n   own global ISPFDSN parmlib.\n\n   Determine the first level quali1er of global ISPFDSN parmlib. The\n   default is SYS1.\n\n   ALLOCATE SYS1.$ISPFDSN.&SID where $SID is the system ID\n\n   If you want SYS2 as the first qualifer of global ISPFDSN parmlib,\n   then ALLOCATE SYS2.$ISPFDSN.&SID where $SID is the system ID\n\n2. If you only want to maintain a global ISPFDSN library for all the\n   LPARs within one sysplex. Define SYS1.$ISPFDSN.GLOBAL and define\n   SYS1.$ISPFDN.&SID as alias of the SYS1.$ISPFDSN.GLOBAL\n\n3. Review all your TSO logon procedure to determine which ISPF datasets\n   are used by the all TSO logon procedures. The rule of thumb allocates\n   as little as possible. Create ISPFDSN parameter calls SYSTEM in\n   your global ISPFDSN library.\n   Note : Refer sample member SYSTEM\n\n4. You can create a software product as a member within global ISPFDSN\n   library but it is not recommended. The software product like IPCS,\n   SMPE, RMF, HCD and etc can be invoked dynamically by means of\n   LIBDEF. Refer sample CLIST @SMPE, it checks whether SMPE datasets\n   are allocated. If they are not allocated, use LIBDEF to attach the\n   SMPE ISPF dataset.\n\n  EXAMPLE : 1) ISPFDSN DSN(SYS1.PROCLIB) MEMBER(IKJPROC)\n               REFERS SYS1.PROCLIB(IKJPROC) TO PERFORM DATASETS\n               ALLOCATION.\n            2) ISPFDSN LOGONPRC\n               ALLOCATE ISPF DATASETS IN\n               SYS1.$ISPFDSN.PROCLIB(&SYSPROC)\n               EG. IF YOUR LOGON PROCEDURE IS IKJPROC, THEN ISPFDSN\n               REFERS SYS1.$ISPFDSN.PROCLIB(IKJPROC) TO PERFORM\n               DATASETS ALLOCATION.\n            3) ISPFDSN\n               ALLOCATION SEQUENCE\n               &SYSUID.ISPF.ISPPROF($ISPFDSN)\n               SYS1.$ISPFDSN.&SID($ISPFDSN)  <-- It includes SYSTEM\n                                                 and INHOUSE\n               SYS1.$ISPFDSN.&SID(SYSTEM)\n               SYS1.$ISPFDSN.&SID(INHOUSE)\n               SYS1.$ISPFDSN.&RACFGRP($ISPFDSN) <-- It includes DB2\n                                                  and MQ\n               SYS1.$ISPFDSN.&SID(DB2)\n               SYS1.$ISPFDSN.&SID(MQ)\n            4) ISPFDSN PREFIX(SYS2)\n               ALLOCATION SEQUENCE\n               &SYSUID.ISPF.ISPPROF($ISPFDSN)\n               SYS2.$ISPFDSN.&SID($ISPFDSN)  <-- includes SYSTEM and\n                                                 INHOUSE\n               SYS2.$ISPFDSN.&SID(SYSTEM)\n               SYS2.$ISPFDSN.&SID(INHOUSE)\n               SYS2.$ISPFDSN.&RACFGRP($ISPFDSN) <-- includes DB2 and\n                                                  MQ\n               SYS2.$ISPFDSN.&SID(DB2)\n               SYS2.$ISPFDSN.&SID(MQ)\n            5) ISPFDSN GROUP(XXXX)\n               ALLOCATION SEQUENCE\n               &SYSUID.ISPF.ISPPROF($ISPFDSN)\n               SYS1.$ISPFDSN.&SID($ISPFDSN)  <-- includes SYSTEM and\n                                                 INHOUSE\n               SYS1.$ISPFDSN.&SID(SYSTEM)\n               SYS1.$ISPFDSN.&SID(INHOUSE)\n               SYS1.$ISPFDSN.XXXX($ISPFDSN) <-- includes DB2 and MQ\n               SYS1.$ISPFDSN.&SID(DB2)\n               SYS1.$ISPFDSN.&SID(MQ)\n            6) ISPFDSN GRPB4GLB\n               ALLOCATION SEQUENCE\n               &SYSUID.ISPF.ISPPROF($ISPFDSN)\n               SYS1.$ISPFDSN.&RACFGRP($ISPFDSN) <-- includes DB2 and\n                                                    MQ\n               SYS1.$ISPFDSN.&SID($ISPFDSN)  <-- includes SYSTEM and\n                                                    INHOUSE\n               SYS1.$ISPFDSN.&SID(DB2)\n               SYS1.$ISPFDSN.&SID(MQ)\n               SYS1.$ISPFDSN.&SID(SYSTEM)\n               SYS1.$ISPFDSN.&SID(INHOUSE)\n            7) ISPFDSN USER(MYISPF)\n               ALLOCATION SEQUENCE\n               &SYSUID.$ISPFDSN.MYISPF($ISPFDSN) <-- include SMPE\n                                                 <-- exclude DB2\n               SYS1.$ISPFDSN.&SID($ISPFDSN)      <-- include SYSTEM &\n                                                     INHOUSE\n               SYS1.$ISPFDSN.&SID(SMPE)\n               SYS1.$ISPFDSN.&SID(SYSTEM)\n               SYS1.$ISPFDSN.&SID(INHOUSE)\n               SYS1.$ISPFDSN.&RACFGRP($ISPFDSN)  <-- include DB2 & MQ\n               SYS1.$ISPFDSN.&SID(MQ)\n\n  2) THE FOLLOWING DDNAMES CANNOT BE CONCATENATED\n      DDNAME=STEPLIB,JOBLIB,STEPCAT,JOBCAT,ISPTABL,ISPPROF\n\n  3) THE FOLLOWING DDNAMES CANNOT BE ALLOCATED\n      DDNAME=STEPLIB,JOBLIB,STEPCAT,JOBCAT\n\n  4) SUPPORT VARIABLE &SYSUID IN DATASET FIRST LEVEL QUALIFIER.\n     SUPPORT VARIABLE &SID IN DATASET SECOND LEVEL QUALIFIER.\n\n   EXAMPLE:\n   SYS1.$ISPFDSN.&SID($ISPFDSN) <---  GLOBAL ISPFDSN PARMLIB\n   INCLUDE=SYSTEM\n   INCLUDE=INHOUSE\n\nSYS1.$ISPFDSN.&SID(SYSTEM)\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//SYSLBC   DD DISP=SHR,DSN=SYS1.BRODCAST\n//SYSPROC  DD DISP=SHR,DSN=SYS1.SISPCLIB\n//SYSEXEC  DD DISP=SHR,DSN=SYS1.SISPEXEC\n//         DD DISP=SHR,DSN=SYS1.SBPXEXEC\n//ISPPLIB  DD DISP=SHR,DSN=SYS1.SISPPENU\n//         DD DISP=SHR,DSN=SYS1.SISFPLIB\n//         DD DISP=SHR,DSN=SYS1.SBPXPENU\n//ISPMLIB  DD DISP=SHR,DSN=SYS1.SISPMENU\n//         DD DISP=SHR,DSN=SYS1.SISFMLIB\n//         DD DISP=SHR,DSN=SYS1.SBPXMENU\n//ISPSLIB  DD DISP=SHR,DSN=SYS1.SISPSENU\n//         DD DISP=SHR,DSN=SYS1.SISPSENU\n//         DD DISP=SHR,DSN=SYS1.SISPSLIB\n//         DD DISP=SHR,DSN=SYS1.SISFSLIB\n//ISPTLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPPROF\n//         DD DISP=SHR,DSN=SYS1.SISPTENU\n//         DD DISP=SHR,DSN=SYS1.SISFTLIB\n//         DD DISP=SHR,DSN=SYS1.SBPXTENU\n//ISPTABL  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPPROF\n\nExample: The default RACF group for storage support team is SYSSTOR\n  SYS1.$ISPFDSN.SYSSTOR($ISPFDSN)   <--- STORAGE SUPPORT ISPFDSN PARMLIB\n//ISPPLIB  DD DISP=SHR,DSN=SYS1.DFQPLIB\n//ISPMLIB  DD DISP=SHR,DSN=SYS1.DFQMLIB\n//ISPTLIB  DD DISP=SHR,DSN=SYS1.DFQTLIB\n\nExample: User's personnel ISPFDSN parameter\n  &SYSUID.ISPF.ISPPROF($ISPFDSN)\n//SYSPROC  DD DISP=SHR,DSN=&SYSUID.CLIST\n//ISPLLIB  DD DISP=SHR,DSN=&SYSUID.LOADLIB\n//ISPPLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPPLIB\n//ISPMLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPMLIB\n//ISPSLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPSLIB\n//ISPTLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPTLIB\n\nSYNTAX OF ISPFDSN PARAMETER FILE\nCOLS ===>   12345678901234567890123456789012345678901234567890\n            //SYSPROC  DD DISP=SHR,DSN=&SYSUID.CLIST\n            //ISPPLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPPLIB\n            //SYSUDUMP DD SYSOUT=X\n            EXCLUDE=DB2\n            INCLUDE=FILEMGR\n\nSyntax rules of ISPFDSN parameter\n1. INCLUDE=xxxxxxxx\n   Include member xxxxxxxx in &prefix.$ISPFDSN.&sid(xxxxxxxx) or\n                              &prefix.$ISPFDSN.&group(xxxxxxxx)\n   (Note : INCLUDE= xxxxxxxx is invalid and member name longer 8 is\n           truncated to 8)\n   INCLUDE only allows one member per line.\n   INCLUDE=MEM1,MEM2   <--  invalid\n   INCLUDE=MEM1 MEM2   <--  invalid\n\n2. EXCLUDE=xxxxxxxx\n   Ignore the member xxxxxxxx from &prefix.$ISPFDSN.&sid(xxxxxxxx).\n   For example you do not use DB2 in TSO and the global allocation\n   ISPFDSN parameter include DB2. Use EXCLUDE=DB2 control statement\n   to ignore the DB2 datasets allocation\n   (Note : EXCLUDE= xxxxxxxx is invalid and member name longer than\n           8 is truncated to 8)\n\n3. DD statment does not support multiple lines (ie only 1 line)\n   //SYSPROC  DD DISP=SHR,DSN=&SYSUID.CLIST  <--- Supported\n   //SYSEXEC  DD DSN=&SYSUID.CLIST,DISP=SHR  <--- May work and still\n                                                  under testing\n   //SYSPROC  DD DISP=SHR,                   <--- Not Supported\n   //            DSN=&SYSUID.CLIST\n\n   (Note : DD has a lot of sub keywords, ISPFDSN only supports\n    keyword DISP and DSN).\n4. DD statment only support DISP and DSN keyword\n   The following statement is not supported and it may be supported\n   later.\n   //SYSPROC  DD  DISP=SHR,DSN=USER.CLIST,UNIT=3390,VOL=SER=ZASYS1\n\n5. Only support DISP=SHR/OLD/MOD and DISP=NEW is not supported\n\n6. DSN supports PDS, PDSE and Sequential file. GDG is not supported.\n   PDS/PDSE member is supported.\n   //REPORT   DD  DISP=SHR,DSN=MY.REPORT(ABCD)   <--- valid\n\n7. SYSOUT is supported\n\n   //REPORT   DD  SYSOUT=*                   <--- invalid\n   //REPORT   DD  SYSOUT=A                   <--- valid\n   //REPORT   DD  SYSOUT=A,DEST=(nodename)   <--- valid\n\n8. TERM\n   //IPCSPRNT DD  TERM=TS                    <--- valid\n                                                  set SYSOUT=X\n   //IPCSPRNT DD  TERM=TS,SYSOUT=A           <--- valid\n   //IPCSPRNT DD  TERM=TS,SYSOUT=*           <--- change SYSOUT=X\n   //IPCSPRNT DD  SYSOUT=A,TERM=TS           <--- invalid\n\n9. Variables\n   A) &SYSUID is the TSO userid and it is only supported at the first\n      level qualifier.\n      &SYSUID.ISPF.ISPPROF  <--- valid\n      SYS1.&SYSUID.XXX      <--- invalid\n      SYS1.XXXX.&SYSUID     <--- invalid\n   B) &SID is the LPAR name and it is only supported at the second\n      level qualifier.\n      SYS1.&SID.XXXX        <--- valid\n      SYS1.XXXX.$SID        <--- invalid\n\nImplementation Tips\n1) Use LIBDEF to invoke infrequently used software product\n2) For performance reason, the number of permanent ISPF datasets\n   should be less than 100.\n3) Ownership of ISPFDSN parameter file\n   A) MVS support is the owner of global ISPFDSN dataset\n   B) MVS support is also the owner of team ISPFDSN dataset. If users\n      can update their team ISPFDSN parameter, don't allocate\n      software product ISPFDSN parameter file in team ISPFDSN library\n      because ISPFDSN will allocate files in team ISFDDSN library. If\n      the member does not exist, it accesses global ISPFDSN library.\n      Use unique ISPFDSN member to avoid error because duplicate name\n      may cause unforseeable problem during MVS system upgrade. For\n      example if you create ISPFDSN member DB2 in your team ISPFDSN\n      parmlib and team $ISPFDSN has INCLUDE=DB2. ISPFDSN will access\n      DB2 in your team ISPFDSN library to perform dataset allocation\n      and do not access the DB2 of the global ISPFDSN parmlib library.\n      During system upgrade, the DB2 ISPFDSN parmlib in global ISPFDSN\n      library is updated but you are still using an not up-to-date\n      version of DB2 in your team ISPFDSN library.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@SMPE": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00@\\x01\\x14'\\x9f\\x01\\x14'\\x9f\\x08X\\x00\\x13\\x00\\x13\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-10-06T00:00:00", "modifydate": "2014-10-06T08:58:40", "lines": 19, "newlines": 19, "modlines": 0, "user": "CLIST"}, "text": "PROC 0\n/* IF PANEL GIM@PRIM IS FOUND, SMPE ISPF DATASETS ARE ALLOCATED */\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC PQUERY PANEL(GIM@PRIM) AREANAME(DUMMY)\nIF &LASTCC = 12 THEN +\n   DO\n        /*  PERFORM DYNAMIC ALLOCATION  */\n        ALTLIB ACT APPLICATION(CLIST) DA('GIM.SGIMCLS0') COND QUIET\n        ISPEXEC LIBDEF ISPPLIB DATASET ID('GIM.SGIMPENU')\n        ISPEXEC LIBDEF ISPMLIB DATASET ID('GIM.SGIMMENU')\n        ISPEXEC LIBDEF ISPSLIB DATASET ID('GIM.SGIMSENU')\n        ISPEXEC LIBDEF ISPTLIB DATASET ID('GIM.SGIMTENU')\n        FREE FILE(SMPTABL)\n        ALLOC FILE(SMPTABL) DA('&SYSUID..ISPF.ISPPROF') SHR\n        FREE FILE(CIDTABL)\n        ALLOC FILE(CIDTABL) DA('&SYSUID..ISPF.ISPPROF') OLD\n   END\nISPEXEC SELECT PGM(GIMSTART)\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ASSEMBLE": {"ttr": 529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x006\\x01\\x14'\\x9f\\x01\\x14'\\x9f\\x173\\x00#\\x00#\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2014-10-06T00:00:00", "modifydate": "2014-10-06T17:33:36", "lines": 35, "newlines": 35, "modlines": 0, "user": "JCL"}, "text": "//XXXXXXXJ JOB XXX,'ASSEMBLE',CLASS=A,REGION=8M,\n//         MSGCLASS=X,MSGLEVEL=(1,1),NOTIFY=&SYSUID\n//*----------------------------------------------\n//* ASSEMBLE ISPFDSN\n//*----------------------------------------------\n//ISPFDSN  EXEC PGM=ASMA90,\n//             PARM='BATCH,NODECK,OBJECT,NOCOMPAT'\n//SYSLIB   DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//SYSIN    DD  DISP=SHR,DSN=XXXXXXX.CBT921.PDS(ISPFDSN)\n//         DD  DISP=SHR,DSN=XXXXXXX.CBT921.PDS(ISPFMSGS)\n//SYSUT1   DD  DSN=&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSDA,\n//             DCB=BUFNO=1\n//SYSPUNCH DD  DUMMY\n//SYSPRINT DD  SYSOUT=*\n//SYSLIN   DD  DSN=&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,\n//             DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n/*\n//LINK    EXEC PGM=IEWL,COND=(5,LT,ASMHCL),\n//             PARM='LIST,LET,XREF,MAP'\n//SYSLMOD  DD  DISP=SHR,DSN=XXXXXXX.LOADLIB <-- YOUR LOADLIB\n//SYSUT1   DD  DSN=&SYSUT1,SPACE=(1024,(120,120),,,ROUND),\n//             UNIT=SYSDA,\n//             DCB=BUFNO=1\n//SYSPRINT DD  SYSOUT=*\n//ISPLIB   DD  DISP=SHR,DSN=ISP.SISPLOAD  <-- YOUR ISPLOAD\n//SYSLIN   DD  DSN=&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSIN    DD  *\n  ENTRY ISPFDSN\n  INCLUDE ISPLIB(ISPLINK)\n  NAME ISPFDSN(R)\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BATCH": {"ttr": 531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x01\\x01\\x14'\\x9f\\x01\\x14'\\x9f\\x08W\\x00\\x10\\x00\\x10\\x00\\x00\\xd1\\xc3\\xd3@@@@@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-10-06T00:00:00", "modifydate": "2014-10-06T08:57:01", "lines": 16, "newlines": 16, "modlines": 0, "user": "JCL"}, "text": "//XXXXXXXJ JOB XXX,'ISPFDSN',CLASS=A,REGION=4M,\n//         MSGCLASS=X,MSGLEVEL=(1,1),NOTIFY=&SYSUID\n//* ---------------------\n//* TEST ISPFDSN IN BATCH MIODE\n//* ---------------------\n//IKJACCT EXEC PGM=IKJEFT01,REGION=4096K\n//STEPLIB  DD  DISP=SHR,DSN=YOUR.LOADLIB\n//SYSTSPRT DD  SYSOUT=*\n//SYSUDUMP DD  SYSOUT=*\n//SYSTSIN  DD  *\nISPFDSN TRACE PREFIX(SYS2)\nLISTA ST\n//\nISPFDSN DSN(SYS1.PROCLIB) MEMBER($SPPROF3) TRACE\nISPFDSN DSN(SYS2.$ISPFDSN.PROCLIB) MEMBER($TEST) TRACE\nISPFDSN LOGONPRC PREFIX(SYS2) TRACE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DB2": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00U\\x01\\x14'\\x8f\\x01\\x14'\\x8f\\x10(\\x00\\x07\\x00\\x07\\x00\\x00\\xc9\\xe2\\xd7\\xc6\\xc4\\xe2\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-10-05T00:00:00", "modifydate": "2014-10-05T10:28:55", "lines": 7, "newlines": 7, "modlines": 0, "user": "ISPFDSN"}, "text": "//SYSPROC  DD DISP=SHR,DSN=SYSD.DB2.SDSNCLST\n//ISPLLIB  DD DISP=SHR,DSN=SYSD.DB2.RUNLIB.LOAD\n//ISPSLIB  DD DISP=SHR,DSN=SYSD.DB2.SDSNSPFS\n//ISPPLIB  DD DISP=SHR,DSN=SYSD.DB2.SDSNSPFP\n//         DD DISP=SHR,DSN=SYSD.DB2.SDSNPFPE\n//ISPMLIB  DD DISP=SHR,DSN=SYSD.DB2.SDSNSPFM\n//ISPTLIB  DD DISP=SHR,DSN=SYS2.WLB.SCPPTENU\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILEMGR": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00U\\x01\\x14'\\x8f\\x01\\x14'\\x8f\\x10(\\x00\\x05\\x00\\x05\\x00\\x00\\xc9\\xe2\\xd7\\xc6\\xc4\\xe2\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-10-05T00:00:00", "modifydate": "2014-10-05T10:28:55", "lines": 5, "newlines": 5, "modlines": 0, "user": "ISPFDSN"}, "text": "//SYSEXEC  DD DISP=SHR,DSN=FMN.SFMNEXEC\n//ISPSLIB  DD DISP=SHR,DSN=FMN.SFMNSLIB\n//ISPPLIB  DD DISP=SHR,DSN=FMN.SFMNPENU\n//ISPMLIB  DD DISP=SHR,DSN=FMN.SFMNMENU\n//ISPTLIB  DD DISP=SHR,DSN=FMN.SFMNTENU\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HISPFDSN": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00Q\\x01\\x14'\\x9f\\x01\\x14'\\x9f\\x173\\x006\\x006\\x00\\x04\\xc8\\xc5\\xd3\\xd7@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-10-06T00:00:00", "modifydate": "2014-10-06T17:33:51", "lines": 54, "newlines": 54, "modlines": 4, "user": "HELP"}, "text": ")F FUNCTION\n  The ISPFDSN command allocates files dynamically\n)X SYNTAX -\n\n         ISPFDSN 'dsname(dsname)' 'member(member)'\n                PREFIX(SYS1) LOGONPRC USER(suffix)\n                BYPHSM NORACF GRPB4GLB TRACE/LIST\n\n  Required - Nil\n  Defaults - PREFIX - If no prefix is used, SYS1 is used as the default\n                      prefix.\n             GROUP  - If no group is used, default RACF group is the\n                      default.\n\n)O OPERANDS -\n))PREFIX   The prefix of the SYSTEM and GLOBAL ISPFDSN parameter file.\n           Default is SYS1. SYS1.$ISPFDSN.&SID($ISPFDSN) is the\n           global ISPF allocation parameter file.\n           Ex.  ISPFDSN PREFIX(SYS2)\n                SYS2.$ISPFDSN.&SID($ISPFDSN) is the global ISPF\n                allocation parameter file.\n\n))LIST     List ISPFDSN error message.\n\n))TRACE    Activate ISPFDSN internal trace for debugging ISPFDSN\n\n))LOGONPRC The LOGONPRC operand indicates ISPFDSN uses\n           prefix.$ISPFDSN.sid(tsoproc) to allocate files.\n\n))BYPHSM   All the migrated datasets are not allocated.\n\n))NORACF   Bypass RACHECK for all the allocated datasets.\n\n))GRPB4GLB Process group ISPFDSN parameter before global ISPFDSN\n           parameter. Default setting is process global ISPFDSN\n           parameter than group ISPFDSN parameter.\n\n)P'dsname(dsname)'\n           - The name of a partitioned data set which contains the\n             ISPFDSN parameters\n)P'member(member)'\n           - The name of a member specified in dsname\n)P'group(group)'\n           - The name of RACF group. Default is user's default RACF\n             group ie &PREFIX.$ISPFDSN.racfgrp($ISPFDSN)\n             Ex. ISPFDSN GROUP(ATM)\n                 The group ISPFDSN parameter file is\n                 &PREFIX.$ISPFDSN.ATM($ISPFDSN)\n)P'user(user)'\n           - The name of suffix of personnel ISPF parameter file. The\n             default name is &SYSUID.ISPF.ISPPROF($ISPFDSN)\n             Ex. ISPFDSN USER(TEST)\n                 The user's ISPFDSN parameter file is\n                 &SYSUID.$ISPFDSN.TEST($ISPFDSN)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INHOUSE": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x07\\x01\\x14'\\x8f\\x01\\x14'\\x8f\\x100\\x00\\x0c\\x00\\x0c\\x00\\x06\\xc9\\xe2\\xd7\\xc6\\xc4\\xe2\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-10-05T00:00:00", "modifydate": "2014-10-05T10:30:07", "lines": 12, "newlines": 12, "modlines": 6, "user": "ISPFDSN"}, "text": "//SYSPROC  DD DISP=SHR,DSN=SYS2.CLIB\n//         DD DISP=SHR,DSN=DEVPT.CLIB\n//         DD DISP=SHR,DSN=SYS2.INHOUSE.SCPPCENU\n//ISPLLIB  DD DISP=SHR,DSN=SYS2.INHOUSE.SCPPLOAD\n//ISPSLIB  DD DISP=SHR,DSN=SYS2.SLIB\n//         DD DISP=SHR,DSN=DEVPT.SLIB\n//         DD DISP=SHR,DSN=SYS2.INHOUSE.SCPPSENU\n//ISPPLIB  DD DISP=SHR,DSN=SYS2.PLIB\n//         DD DISP=SHR,DSN=DEVPT.PLIB\n//         DD DISP=SHR,DSN=SYS2.INHOUSE.SCPPPENU\n//ISPMLIB  DD DISP=SHR,DSN=SYS2.INHOUSE.SCPPMENU\n//ISPTLIB  DD DISP=SHR,DSN=SYS2.INHOUSE.SCPPTENU\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPFDSN": {"ttr": 777, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01/\\x00H\\x01\\x14(o\\x01\\x14(o\\x17\\x00\\tj\\tj\\tj\\xc1\\xe2\\xd4@@@@@@@'", "ispf": {"version": "01.47", "flags": 0, "createdate": "2014-10-13T00:00:00", "modifydate": "2014-10-13T17:00:48", "lines": 2410, "newlines": 2410, "modlines": 2410, "user": "ASM"}, "text": "*---------------------------------------------------------------------*\n*                         ISPFDSN                                     *\n*---------------------------------------------------------------------*\n*                                                                     *\n* DESC     : PERFORMS DYNAMIC ISPF DATASET ALLOCATION                 *\n*                                                                     *\n* FUNCTION : ISPFDSN REFERS SYS1.$ISPFDSN.&SID($ISPFDSN) TO PERFORM   *\n*            DATASET ALLOCATION. ISPFDSN DOES NOT ALLOCATE THE        *\n*            DATASET IF IT ENCOUNTERS ANY ONE OF THE FOLLOWING        *\n*            CONDITION                                                *\n*                                                                     *\n*            1) THE DATASET IS NOT CATALOGUED                         *\n*            2) IF THE DATASET IS CATALOGUED BUT THE VOLUME IS        *\n*               OFFLINE                                               *\n*            3) THE USER HAS NO RACF READ AUTHORITY TO THE DATASET    *\n*            4) IF BYPHSM OPTION IS SPECIFIED, MIGRATED DATASET IS    *\n*               IGNORED                                               *\n*            5) IF THE DATASET IS ALREADY ALLOCATED UNDER THE SAME    *\n*               DDNAME                                                *\n*            6) THE DATASET IS EXCLUSIVE OWN BY ANOTHER TASK          *\n*                                                                     *\n*  ADVANTAGE:                                                         *\n*            1) IT IS FASTER THAN USING REXX TO ALLOCATE DATASET      *\n*            2) AVOID S913                                            *\n*            3) AVOID DSNAME TYPO CAUSE TSO LOGON FAILURE             *\n*            4) AVOID TSO LOGON FAILURE IF YOU FORGET TO CATALOGUE    *\n*               THE DATASET UNDER SYSPLEX ENVIRONMENT                 *\n*            5) IT IS EASY TO MANAGE AS THE DATASET ALLOCATION IS BY  *\n*               MEANS OF SOFTWARE PRODUCT. (IE CHANGE ONE ISPFDSN     *\n*               MEMBER IN GLOBAL ISPFDSN PARMLIB AFFECTS ALL THE      *\n*               TSO LOGON POCEDURES)                                  *\n*                                                                     *\n* PARMS :     GROUP(XXXXX)  - PROCESS AS IF XXXXX IS USED AS THE RACF *\n*                             GROUP. THE DEFAULT GROUP IS THE USER'S  *\n*                             RACF GROUP.                             *\n*             LIST          - REPORT ON ANY ALLOCATIONS THAT FAIL     *\n*                             AND MIGRATED DATA SET BYPASSED.         *\n*             TRACE         - GENERATE TRACE MESSAGES                 *\n*             BYPHSM        - BYPASS ALLOCATION OF HSM MIGRATION      *\n*                             DATASET IN CASE OF HSM IS INACTIVE      *\n*             LOGONPRC      - USE TSO LOGON PROC NAME AS THE MEMBER   *\n*                             NAME OF SYS1.$ISPFDSN.PROCLIB(&SYSPROC) *\n*             DSN(XXXX)     - DATA SET NAME FOR TSO LOGON PROCEDURE   *\n*             MEMBER(XXXX)  - MEMBER NAME FOR PROC PROCESSING         *\n*             PREFIX(SYS1)  - THE PREFIX OF ISPFDSN. DEFAULT IS SYS1  *\n*             USER(XXXX)    - SUFFIX OF YOUR OWN PERSONNEL ISPFDSN.   *\n*                             WHEN IT IS SPECIFIED, ISPFDSN ALLOCATES *\n*                             DATASET IN &PREFIX.ISPFDSN.XXXX(ISPFDSN)*\n*             GRPB4GLB      - ALLOCATE GROUP ISPFDSN DATASETS BEFORE  *\n*                             GLOBAL ISPFDSN DATASETS                 *\n*             NORACF        - BYPASS RACHECK PROCESSING JUST IN CASE  *\n*                             THE RACF DATA BASE IS EXCLUSIVE ENQUED  *\n*                             BY SOME TASKS.                          *\n*                                                                     *\n* EXAMPLE FOR STATEMENTS IN ALLOCATION SPECIFICATION:                 *\n* COLS ===>   1234567890123456789012345678901234567890...             *\n*             EXCLUDE=DB2                                             *\n*             INCLUDE=FILEMGR                                         *\n*             PROC=SYS1.PROCLIB,MEMBER=$SYSTEAM                       *\n*             //SYSPROC  DD DISP=SHR,DSN=&SYSUID.PF.CLIST             *\n*             //ISPPLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPPLIB         *\n*             //SYSUDUMP DD SYSOUT=X                                  *\n*                                                                     *\n* ABENDS:     U100  -  RETURN CODE FROM DYNALLOC THAT THIS PGM        *\n*                      CANNOT HANDLE. RERUN USING TRACE TO OBTAIN     *\n*                      THE RETURN CODES FROM DYNALLOC, AND THE        *\n*                      ERROR MESSAGES.                                *\n*                                                                     *\n*                                                                     *\n* TABLES:     MBRTABLE : 50 ENTRIES (50*8)                            *\n*             DDNTABLE : 50 ENTRIES (50*8)                            *\n*             DSNTABLE :300 ENTRIES (30*52)                           *\n*                                                                     *\n* REGS :                                                              *\n*                R12 - PROGRAM BASE REGISTER FOR THE FOLLOWING ROUTINE*\n*                      PROCESS_PDS, PUTLINE                           *\n*                R11 - DATA REGISTER                                  *\n*                R10 - NOT IN USED                                    *\n*                R9  - NOT IN USED                                    *\n*                R8  - R0  - ROUTINE DEPENDANT                        *\n*                                                                     *\n* MODS :                                               MM/DD/YY       *\n* @A1    V1R0M1 - ADD BYPHSM OPTION TO BYPASS ALLOCATION OF HSM       *\n*                 MIGRATION                            05/23/92  AC   *\n* @A2    V1R0M2 - FIX PREFIX PROBLEM                   05/25/92  MM   *\n* @A3    V1R0M3 - CHANGE DATA SET NAME CONVENTION      05/26/92  MM   *\n* @A4    V1R0M4 - FIX BYPHSM PROBLEM                   05/27/92  MM   *\n* @A5    V1R0M5 - SUPPORT PDS MEMBER                   05/29/92  AC   *\n* @A6    V1R0M6 - FIX SYSOUT,DUMMY,TERM STARTING       08/27/92  AC   *\n*                 AT COLUMN 2                                         *\n* @A7    V1R0M7 - CHANGE SYNTAX OF NON-KEYWORD LINES   09/01/92  MM   *\n* @A8    V1R0M8 - ENHANCE PROGRAM TO USE IKJPARSE FOR  11/30/92  MM   *\n*                 PARSING AND ADD NEW PARAMETERS                      *\n*                 DSN(XXX) & MEMBER(XXX)                              *\n* @A9    V1R0M9 - ENHANCE PROGRAM ACCEPT THE SYMBOL    02/17/1993 MM  *\n*                 '/*' AS END OF FILE MARKER                          *\n* @B1    V2R0M1 - MVS VERSION 4                        06/24/1994 AC  *\n*                 ADD KEYWORD NORACF                                  *\n* @B2    V2R0M2 - REPLACE LM AND STM BY BAKR AND PR    09/03/2012 AC  *\n*                 . ISSUE SWAREQ TO SUPPORT SWA=ABOVE                 *\n*                 . SUPPORT VARIABLE &SYSUID.&SID.ISPPROF             *\n* @B3    V2R0M3 - CHANGE THE SYNTAX OF DDNAME SIMILAR   02/01/2014 AC *\n*                 TO ZOS JCL                                          *\n*                 . MOVE MESSAGES TO CSECT ISPFMSGS                   *\n*                 . USE R11 AS DATA REGISTER                          *\n*                 . SET DEFAULT OPTION TO ALLOCATE FILES IN GLOBAL    *\n*                   THEN RACF GROUP                                   *\n*                 . ADD KEYWORD GRPB4GLB                              *\n* @B4    V2R0M4 - REPLACE SWAREQ BY INTERNAL DSNTABLE   09/01/2014 AC *\n*                   AS SWAREQ REQUIRE APF AUTHORISED                  *\n*                 . ADD KEYWORD LOGONPRC                              *\n*                 . REPLACE TRT BY SRST INSTRUCTION                   *\n*---------------------------------------------------------------------*\n         EJECT\nISPFDSN  CSECT\n         J     MAIN000                 BRANCH AROUND EYECATCHER\n         DC    C'ISPFDSN V2R0M4  &SYSDATE &SYSTIME'                @B4C\n*---------------------------------------------------------------------*\n*                     MAINLINE                                        *\n*---------------------------------------------------------------------*\nMAIN000  DS    0H\n         BAKR  R14,0              SAVE REGISTERS INTO LINKAGE STACK\n         LARL  R11,WORKSTOR\n         USING WORKSTOR,R11            R11 IS DATA REGISTER\n         ST    R1,CPPLADDR             SAVE CPPL ADDR\n         BRAS  R14,INIT_RTN            INITIALIZATION AND PARM CHECKING\n         LTR   R15,R15                 RC = 0 ?\n         JNZ   EXIT4                   TERMINATE IF RC NOT 0\n         TM    DSNFLAG,DSNLIST         WAS LIST PARM SPECIFIED ?\n         JZ    MAIN010                 NO.  BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,4(,R8)               MSG01 (4*1)\n         BRAS  R14,PUTLINE             DISPLAY MSG01\nMAIN010  L     R15,VISPQRY             TEST FOR                    @B3A\n         BALR  R14,R15                   ISPF ENVIRONMENT          @A7A\n         LTR   R15,R15                     IS ACTIVE OR NOT        @A7A\n         JNZ   MAIN020                 IF RC > 0 ISPF IS INACTIVE  @A7A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @A7A\n         L     R8,124(,R8)             EMSG31 (4*31)               @A7A\n         BRAS  R14,PUTLINE             OUTPUT WARNING MESSAGE      @A7A\nMAIN020  DS    0H                                                  @A7A\n         BALR  R12,0                                               @B3A\n         USING *,R12                                               @B3A\n         L     R4,WORKSIZE             GET STORAGE 19362 BYTES FOR @B4A\n         GETMAIN R,LV=(R4)             RACF AND INTERNAL TABLES    @B4C\n         ST    R1,RACFWORK             SAVE ADDRESS OF WORK AREA   @A1A\n         AHI   R1,512                                              @B3A\n         ST    R1,DDNTABLE             ADDRESS OF DDNTABLE TABLE   @B3A\n         AHI   R1,400                  50 * 8                      @B3A\n         ST    R1,MBRTABLE             ADDRESS OF MBRTABLE TABLE   @B3A\n         AHI   R1,450                  50 * 9                      @B3A\n         ST    R1,DSNTABLE             ADDRESS OF DSNTABLE TABLE   @B4A\n         ST    R1,DSNTCURR             CURRENT ADDRESS OF DSNTABLE @B4A\n         MVC   0(52,R1),BLANKS         INIT 1ST RNETY TO BLANKS    @B4A\n         AHI   R1,16200                300 * 52                    @B4A\n         ST    R1,DSNT_END             END OF DSNTABLE TABLE       @B4A\n         L     R4,IOBUFSZ              GET STORAGE 32768 BYTES     @B3A\n         GETMAIN R,LV=(R4)               FOR INPUT BUFFER          @B3A\n         ST    R1,BUFFADDR             SAVE ADDR OF I/O BUFFER\n         DROP  R12\n         TM    DSNFLAG,DSNDSNM+DSNLGPRC   DSN OR LOGONPRC OPTION   @B4A\n         JZ    MAIN030                 NO, BRANCH                  @B4C\n         BRAS  R14,PROC_ISPFDSN        PROCESS TYPE-IN PROC        @B4C\n         J     MAIN050                                             @B4C\nMAIN030  BRAS  R14,PROFILE_ISPFDSN     PROCESS &USER.ISPF.ISPPROF  @B3A\n         TM    DSNFLAG,DSNGB4GL                                    @B3A\n         JO    MAIN040                                             @B3A\n         BRAS  R14,GLOBAL_ISPFDSN    PROCESS SYS1.$ISPFDSN.&SID    @B3A\n         OI    DSNFLAG2,DSNPASS1     TURN ON GLOBAL ISPFDSN PASS1  @B4A\nMAIN040  BRAS  R14,RACFGRP_ISPFDSN   PROCESS SYS1.$ISPFDSN.&RACFGRP@B3A\n         LH    R8,MBRCT                                            @B4A\n         LTR   R8,R8                                               @B4A\n         JNZ   MAIN045                                             @B4A\n         TM    DSNFLAG2,DSNPASS1     ISPFDSN PASS1?                @B4A\n         JO    MAIN050                                             @B4A\nMAIN045  DS    0H                                                  @B3A\n         BRAS  R14,GLOBAL_ISPFDSN    GET GLOBAL MEMBERS NOT IN &RACFGRP\nMAIN050  DS    0H                                                  @B3A\n         TM    DSNFLAG,DSNLIST         WAS LIST PARM SPECIFIED ?\n         JZ    MAIN070                 SKIP LIST MESSAGE IF LIST IS OFF\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,8(,R8)               MSG02 (4 * 2)\n         BRAS  R14,PUTLINE             DISPLAY ISPFDSN COMPLETE\nMAIN070  L     R3,RACFWORK             GET ADDR OF FREEMAIN        @A1A\n         L     R4,WORKSIZE             SIZE OF FREEMAIN            @B4A\n         FREEMAIN R,LV=(R4),A=(R3)     RELEASE WORK AREA           @B4C\n         L     R3,BUFFADDR             GET ADDR OF FREEMAIN        @B3A\n         L     R4,IOBUFSZ              SIZE OF FREEMAIN            @B3A\n         FREEMAIN R,LV=(R4),A=(R3)     RELEASE I/O WORK AREA       @B3A\n         SR    R15,R15                 SET RC TO 0\n         PR                            RETURN TO TSO\nEXIT4    DS    0H                                                  @B4A\n         PR                            RETURN TO TSO               @B4A\n         EJECT\n*---------------------------------------------------------------------*\n*                      INITIALIZATION                                 *\n*---------------------------------------------------------------------*\nINIT_RTN DS    0H\n         BAKR  R14,0                   SAVE CALLERS REGS\n*---------------------------------------------------------------------*\n*        GET MY SYSUID AND RACF GROUP NAME FROM ACCE                  *\n*---------------------------------------------------------------------*\n         USING PSA,0                         MAP PSA\n         L     R2,PSAAOLD                    GET MY ASCB ADDR\n         L     R2,ASCBASXB-ASCB(R2)          GET ASXB ADDR\n         L     R2,ASXBSENV-ASXB(R2)          GET ACEE ADDR\n         MVC   SYSUID(7),ACEEUSRI-ACEE(R2)   GET SYSUID FROM ACEE\n         MVC   RACFGRP,ACEEGRPN-ACEE(R2)     GET GROUP FROM ACEE\n         LA    R0,C' '                 SET BLANK AS SEARCH STRING  @B4A\n         LA    R5,SYSUID                     STARTING SEARCH PTR   @B4A\n         LA    R6,SYSUID+7                   ENDING SEARCH PTR     @B4A\nSRST1    SRST  R6,R5                                               @B4A\n         JC    1,SRST1                 SEARCH UNTIL SPACE IS FOUND @B4A\n         SR    R6,R5                         LENGHT OF SYSUID      @B4A\n         STH   R6,SYSUIDL                    SAVE LENGTH OF SYSUID @B4A\n*---------------------------------------------------------------------*\n*        GET CURRENT PREFIX FROM TSO UPT                              *\n*---------------------------------------------------------------------*\n         L     R2,CPPLADDR                 GET MY CPPL ADDR\n         MVC   UPTADDR,CPPLUPT-CPPL(R2)    SAVE UPT ADDR FOR LATER\n         MVC   ECTADDR,CPPLECT-CPPL(R2)    SAVE ECT ADDR FOR LATER\n         L     R2,CPPLUPT-CPPL(R2)         GET UPT ADDR\n         L     R2,PSATOLD                  LOCATE CURRENT TCB      @B4A\n         L     R2,TCBTIO-TCB(R2)           LOCATE TIOT  CURRENT TCB@B4A\n         MVC   ALOC_MEM,8(R2)              GET TSO PROCEDURE NAME  @B4A\n*---------------------------------------------------------------------*\n*        PROCESS AND PARSE INPUT PARAMETER                            *\n*---------------------------------------------------------------------*\n         L     R2,CPPLADDR             GET CPPL ADDR\n         MVC   CMDCBUF,CPPLCBUF-CPPL(R2)   COPY ADDRESS OF COMMAND BUF\n         BALR  R12,0                                               @B4A\n         USING *,R12                                               @B4A\n         LA    R1,CMDPPL               PROVIDE LIST FOR PARSE      @A8A\n         LINK  EP=IKJPARS              PARSE COMMAND               @A8A\n         DROP  R12\n         LTR   R15,R15                 PARSE OK ?                  @A8A\n         JNZ   INIT_RTN_EXIT           NO, EXIT PROGRAM            @A8A\n*---------------------------------------------------------------------*\n*        PARSE INPUT PARAMETERS                                       *\n*---------------------------------------------------------------------*\n         L     R4,CMDANSR              GET POINTER TO ANSWER AREA  @A8A\n         USING IKJPARMD,R4             PROVIDE ADDRESSABILITY      @A8A\n         LH    R3,IKBYPHSM             GET KEYWORD INFORMATION     @A8A\n         LTR   R3,R3                   BYPHSM ENTERED ?            @A8A\n         JZ    INIT2250                                            @A8A\n         OI    DSNFLAG,DSNBPHSM        SET BYPASS HSM FLAG         @A8A\nINIT2250 DS    0H                                                  @A8A\n         LH    R3,IKGR4SYS             GET KEYWORD INFORMATION     @A8A\n         LTR   R3,R3                   BYPHSM ENTERED ?            @A8A\n         JZ    INIT2300                                            @A8A\n         OI    DSNFLAG,DSNGB4GL        SET ALLOC GROUP B4 GLOBAL   @A8A\nINIT2300 DS    0H                                                  @A8A\n         LH    R3,IKLIST               GET KEYWORD INFORMATION     @A8A\n         LTR   R3,R3                   LIST ENTERED ?              @A8A\n         JZ    INIT2350                                            @A8A\n         OI    DSNFLAG,DSNLIST         SET LIST FLAG               @A8A\nINIT2350 DS    0H                                                  @A8A\n         L     R1,IKSIPREX             ADDRESS ISPFDSN PREFIX      @B3A\n         LH    R2,IKSIPREX+4           LENGTH OF ISPFDSN PREFIX    @B3A\n         LTR   R2,R2                                               @B3A\n         JZ    INIT2370                                            @B3A\n         STH   R2,PREFIXL              SAVE LENGTH OF PREFIX       @B4A\n         BCTR  R2,0                    SUBTRACT 1 FOR MOVE         @A8A\n         EX    R2,MVCPREFX             COPY PREFIX                 @A8A\nINIT2370 DS    0H                                                  @A8A\n         L     R1,IKSIUSER             ADDRESS OF USER SUFFIX      @B3A\n         LH    R2,IKSIUSER+4           LENGTH OF USER SUFFIX       @B3A\n         LTR   R2,R2                                               @B3A\n         JZ    INIT2400                                            @B3A\n         BCTR  R2,0                    SUBTRACT 1 FOR MOVE         @B3A\n         EX    R2,MVCUSUFF             COPY USER'S ISPFDSN SUFFIX  @B3A\n         OI    DSNFLAG,DSNUSER         SET DSNUSER FLAG            @B3A\nINIT2400 DS    0H                                                  @A8A\n         LH    R3,IKTRACE              GET KEYWORD INFORMATION     @A8A\n         LTR   R3,R3                   DSNTRACE ENTERED ?          @A8A\n         JZ    INIT2500                                            @A8A\n         OI    DSNFLAG,DSNTRACE        SET DSNTRACE FLAG           @A8A\nINIT2500 DS    0H                                                  @B1A\n         LH    R3,IKNRACF              GET KEYWORD INFORMATION     @B1A\n         LTR   R3,R3                   NORACF ENTERED ?            @B1A\n         JZ    INIT2550                                            @B1A\n         OI    DSNFLAG,DSNNRACF        SET NORACF FLAG             @B1A\nINIT2550 DS    0H                                                  @B4A\n         LH    R3,IKLOGPRC             GET KEYWORD LOGONPRC        @B4A\n         LTR   R3,R3                   LOGONPRC ENTERED ?          @B4A\n         JZ    INIT2600                                            @B4A\n         OI    DSNFLAG,DSNLGPRC        SET LOGON PROC FLAG         @B4A\n         J     INIT2800                MUTALLY EXCLUSIVE WITH DSN  @B4A\nINIT2600 DS    0H                                                  @A8A\n         LH    R3,IKDSN                GET KEYWORD INFORMATION     @A8A\n         LTR   R3,R3                   DSN ENTERED ?               @A8A\n         JZ    INIT2800                                            @A8A\n         L     R1,IKSIADSN             GET ADDRESS OF DATA SET NAME@A8A\n         LH    R2,IKSIADSN+4           GET LENGTH OF DATA SET NAME @A8A\n         BCTR  R2,0                    SUBTRACT 1                  @A8A\n         EX    R2,MVCPROC              COPY PROC DSNAME            @A8A\nINIT2700 DS    0H                                                  @A8A\n         LH    R3,IKMEMBER             GET KEYWORD INFORMATION     @A8A\n         LTR   R3,R3                   MEMBER ENTERED ?            @A8A\n         JZ    INIT2750                BRANCH IF NO MEMBER NAME    @A8A\n         L     R1,IKSIAMEM             GET ADDRESS OF DATA SET NAME@A8A\n         LH    R2,IKSIAMEM+4           GET LENGTH OF DATA SET NAME @A8A\n         BCTR  R2,0                    SUBTRACT 1                  @A8A\n         EX    R2,MVCPROCM             COPY DSN MEMBER             @A8A\n         OI    DSNFLAG,DSNDSNM         TURN ON DSN OPTION          @B3A\n         J     INIT2800                                            @A8A\nINIT2750 L     R8,ISPFMSGS             MESSAGE CSECT               @B3A\n         L     R8,60(,R8)              EMSG15 (4*15)               @B3A\n         BRAS  R14,PUTLINE             DISPLAY NO MEMBER           @B3A\nINIT2800 DS    0H                                                  @A8A\n         LH    R3,IKGROUP              GET KEYWORD INFORMATION     @A8A\n         LTR   R3,R3                   PRE ENTERED ?               @A8A\n         JZ    INIT2900                                            @A8A\n         L     R1,IKSIGRP              GET ADDRESS OF GROUP NAME   @A8A\n         LH    R2,IKSIGRP+4            GET LENGTH OF GROUP NAME    @A8A\n         BCTR  R2,0                    SUBTRACT 1                  @A8A\n         EX    R2,MVCGROUP             COPY INPUT GROUP NAME       @A8A\nINIT2900 DS    0H\n         DROP  R4                                                  @A8A\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    INIT_RTN_EXIT           NO.  BRANCH\n         L     R8,ISPFMSGS                                         @B3C\n         L     R8,164(,R8)             AMSG41  (4*41)              @B3C\n         BRAS  R14,PUTLINE             DISPLAY TRACE ACTIVE        @B3C\n         L     R8,ISPFMSGS                                         @B3C\n         L     R8,168(,R8)             AMSG42  (4*42)              @B3C\n         MVC   26(8,R8),RACFGRP        GET RACFGRP\n         BRAS  R14,PUTLINE             DISPLAY RACF GROUP          @B3C\n         TM    DSNFLAG,DSNLIST         WAS LIST PARM SPECIFIED ?\n         JZ    INIT_RTN_EXIT           NO.  BRANCH\n         L     R8,ISPFMSGS                                         @B3C\n         L     R8,172(,R8)             MSG43  (4*43)               @B3C\n         BRAS  R14,PUTLINE             DISPLAY LIST OPTION         @B3C\nINIT_RTN_EXIT  DS  0H\n         PR                            RETURN TO CALLER\n         EJECT                                                     @A8A\n*---------------------------------------------------------------------*\n*        PROCESS THE &SYSUID.ISPF.ISPPROF($ISPFDSN) OR                *\n*                    &SYSUID.ISPF.&USER($ISPFDSN)                     *\n*---------------------------------------------------------------------*\nPROFILE_ISPFDSN  DS  0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B3A\n         MVC   ALOC_DSN(52),BLANKS     INIT TO BLANKS              @B3A\n         MVC   ALOC_DSN(8),SYSUID      COPY USERID                 @B3A\n         LA    R1,ALOC_DSN             STARTING POSITION           @B4C\n         AH    R1,SYSUIDL                                          @B4C\n         MVC   0(L'ISPPROF,R1),ISPPROF   COPY .ISPF.ISPPROF        @B3A\n         TM    DSNFLAG,DSNUSER         USER SUFFIX SPECIFIED ?     @B3A\n         JNO   PROF_CHK_DSN            BRANCH IF NO SUFFIX         @B3A\n         MVC   0(10,R1),CISPFDOT       COPY .$ISPFDSN.             @B4C\n         MVC   10(8,R1),USERSUFF       COPY USERSUFF               @B4C\nPROF_CHK_DSN   DS  0H\n         LA    R1,ALOC_DSN             GET ADDR OF DSNAME\n         BRAS  R14,CHECK_DSNAME        RACHECK AND LOCATE FILE\n         LTR   R15,R15                 RC = 0 ?\n         JNZ   PROFILE_EXIT0           NO. BRANCH\n         MVC   IUSE_DSN,ALOC_DSN       SET NAME OF PDS BEING PROCESSED\n         MVC   ALOC_DDN,CTEMPPDS       SET DDNAME TO TEMPPDS       @B3A\n         MVC   IUSE_DDN,ALOC_DDN       SET DDNAME IN USE\n         LA    R0,ALOC_DDN             GET ADDR OF DDNAME\n         LA    R1,ALOC_DSN             GET ADDR OF DSNAME\n         BRAS  R14,DYN_ALLOCATE        DYNALLOC USER ISPFDSN PDS\n         LTR   R15,R15                 RC = 0 ?\n         JZ    PROF_OPENPARM           BRANCH IF RC = 0\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    PROFILE_EXIT0           SKIP TRACE MSG IF TRACE IS OFF\n         L     R8,ISPFMSGS             LOAD MESSAGE TABLE          @B3C\n         L     R8,176(,R8)             AMSG44  (4*44)              @B3C\n         BRAS  R14,PUTLINE             USER ISPFDSN ALLOCATE FAILS @B3A\n         J     PROFILE_EXIT0           DELETE MEMBER FROM TABLE\nPROF_OPENPARM  DS   0H\n         LA    R1,$ISPFDSN             GET ADDR OF $ISPFDSN\n         MVC   IUSE_MBR,$ISPFDSN       SET MEMBER TO PROCESS\n         LA    R0,TEMPDD               GET ADDR OF DCB\n         LA    R2,ALLOCPH              ADDR OF\n         BRAS  R14,PROCESS_PDS         GET 1ST RECORD OF $ISPFDSN\n         LTR   R15,R15                 MEMBER FOUND ?\n         JZ    PROF_GETREC             YES. BRANCH\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    PROF_CLOSE_FILE         SKIP TRACE MSG IF TRACE IS OFF\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,56(,R8)              EMSG14 (4*14)  MEMBER NOT FIND\n         MVC   28(8,R8),$ISPFDSN       PUT MEMBER NAME IN MSG\n         MVC   46(8,R8),IUSE_DDN       PUT DDNAME IN MSG\n         MVC   61(44,R8),IUSE_DSN      PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY MSG14\n         J     PROF_CLOSE_FILE         BRANCH\nPROF_GETREC    DS  0H\n         BRAS  R14,ISPFDSN_PARMLIB     PROCESS PARMLIB RECORD\n         CHI   R15,8                   TERMINATE CURRENT MEMBER ?  @A9A\n         JE    PROFILE_EXIT            YES. BRANCH                 @B4C\n         LA    R0,TEMPDD               GET ADDR OF DCB\n         SR    R1,R1                   INDICATE GET NEXT RECORD\n         LA    R2,ALLOCPH              ADDR OF PLACEHOLDER\n         BRAS  R14,PROCESS_PDS         GET NEXT RECORD\n         LTR   R15,R15                 END OF MEMBER ?\n         JZ    PROF_GETREC             NO . LOOP THRU MEMBER\nPROF_CLOSE_FILE  DS  0H\n         BRAS  R14,CLOSE_TEMPPDS       DEALLOC USER ISPFDSN\nPROFILE_EXIT0  DS    0H\n         SR    R15,R15                 SET OK RETURN CODE\nPROFILE_EXIT   DS    0H\n         PR                            RETURN TO CALLER            @B2A\n         EJECT\n*---------------------------------------------------------------------*\n*        PROCESS &PREFIX.$ISPFDSN.&RACFGRP($ISPFDSN)                  *\n*---------------------------------------------------------------------*\nRACFGRP_ISPFDSN  DS  0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\n         LA    R2,ALOC_DSN             GET ADDR OF AREA FOR TEST DSN\n         MVC   ALOC_DSN(52),BLANKS     INIT TO BLANKS              @B2A\n         MVC   ALOC_DSN(8),PREFIX      COPY PREFIX                 @B2C\n         LA    R1,ALOC_DSN             STARTING POSITION           @B3C\n         AH    R1,PREFIXL              ADD PREFIX LENGTH           @B3C\n         MVC   0(10,R1),CISPFDOT       COPY .$ISPFDSN.             @B4A\n         AHI   R1,10                   POINT TO END OF &RACFGRP    @B3C\n         MVC   0(8,R1),RACFGRP         COPY &RACFGRP               @B3C\n         LA    R1,ALOC_DSN             GET ADDR OF DSNAME\n         BRAS  R14,CHECK_DSNAME        RACHECK AND LOCATE FILE\n         LTR   R15,R15                 RC = 0 ?\n         JNZ   RACFGRP_ISPFDSN_EXIT    NO. BRANCH\n         MVC   IUSE_DSN,ALOC_DSN       SET NAME OF PDS BEING PROCESSED\n         MVC   ALOC_DDN,CTEMPPDS       SET DDNAME TO TEMPDD        @B3A\n         MVC   IUSE_DDN,ALOC_DDN       SET DDNAME IN USE\n         LA    R0,ALOC_DDN             GET ADDR OF DDNAME\n         LA    R1,ALOC_DSN             GET ADDR OF DSNAME\n         BRAS  R14,DYN_ALLOCATE        ALLOCATE GROUP ISFPDSN\n         LTR   R15,R15                 RC = 0 ?\n         JZ    GRP_INDEX_MEM           BRANCH IF RC = 0\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    RACFGRP_ISPFDSN_EXIT    SKIP TRACE MSG IF TRACE IS OFF\n         L     R8,ISPFMSGS\n         L     R8,176(,R8)             AMSG44  (4*44)\n         MVC   11(5,R8),CGROUP                                     @B4A\n         BRAS  R14,PUTLINE             GROUP ISPFDSN ALLOCATION FAILS\n         J     RACFGRP_ISPFDSN_EXIT    BRANCH\nGRP_INDEX_MEM  DS  0H\n         LA    R1,$ISPFDSN             GET ADDR OF $ISPFDSN        @B3A\n         SR    R5,R5                   START FROM FIRST MEMBER\n         J     GRP_READ_MEM                                        @B4A\nGRP_NEXT_MEM   DS  0H\n         LA    R0,8                    SET GET NEXT MEMBER CODE\n         LR    R1,R5                   GET CURRENT MEMBER ADDR\n         BRAS  R14,PROCESS_MEMBER      GET NEXT MEMBER\n         LTR   R15,R15                 ANY MEMBERS LEFT ?\n         JNZ   GRP_CLOSE_FILE          BRANCH IF NO MEMBER LEFT\n         LR    R5,R1                   SAVE MEMBER PLACEHOLDER\nGRP_READ_MEM   DS  0H\n         MVC   IUSE_MBR,0(R1)          SET MEMBER TO PROCESS\n         LA    R0,TEMPDD               GET ADDR OF TEMPDD DCB\n         LA    R2,ALLOCPH              ADDR OF PLACEHOLDER\n         BRAS  R14,PROCESS_PDS         GET 1ST RECORD\n         LTR   R15,R15                 MEMBER FOUND ?\n         JZ    GRP_MEMDONE             YES. BRANCH\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    GRP_NEXT_MEM            SKIP TRACE MSG IF TRACE IS OFF\n         CLI   IUSE_MBR,X'00'          BLANK MEMBER ?\n         JE    GRP_CLOSE_FILE          YES. EXIT\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,56(,R8)              EMSG14 (4*14)\n         MVC   28(8,R8),IUSE_MBR       PUT MEMBER NAME IN MSG\n         MVC   46(8,R8),IUSE_DDN       PUT DDNAME IN MSG\n         MVC   61(44,R8),IUSE_DSN      PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY MEMBER NOT FOUND\n         J     GRP_NEXT_MEM            BRANCH\nGRP_MEMDONE    DS   0H\n         LTR   R5,R5                                               @B4A\n         JZ    GRP_GETREC                                          @B4A\n         MVI   8(R5),C'Y'              DELETE MEMBER FROM TABLE\nGRP_GETREC     DS   0H\n         BRAS  R14,ISPFDSN_PARMLIB     PROCESS THIS RECORD\n         CHI   R15,8                   TERMINATE CURRENT MEMBER ?  @A9A\n         JE    GRP_NEXT_MEM            YES. BRANCH                 @A9A\n         LA    R0,TEMPDD               GET ADDR OF DCB TEMPDD\n         SR    R1,R1                   INDICATE GET NEXT RECORD\n         LA    R2,ALLOCPH              ADDR OF PLACEHOLDER\n         BRAS  R14,PROCESS_PDS         GET NEXT RECORD\n         LTR   R15,R15                 END OF MEMBER ?\n         JZ    GRP_GETREC              NO . LOOP THRU MEMBER\n         J     GRP_NEXT_MEM            YES. BRANCH\n*\nGRP_CLOSE_FILE DS  0H\n         BRAS  R14,CLOSE_TEMPPDS       DEALLOC TEMP PDS\n*\nRACFGRP_ISPFDSN_EXIT DS 0H\n         LA    R0,4                    SET DELETE MEMBER NAME\n         LA    R1,RACFGRP              GET ADDR OF RACFGRP\n         BRAS  R14,PROCESS_MEMBER      DELETE RACFGRP FROM MEMBER TABLE\n         SR    R15,R15                 SET OK RETURN CODE\n         PR                            RETURN TO CALLER            @B2A\n         EJECT\n*---------------------------------------------------------------------*\n*        PROCESS &PREFIX.$ISPFDSN.&SID                                *\n*---------------------------------------------------------------------*\nGLOBAL_ISPFDSN DS 0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\n         MVC   ALOC_DSN(52),BLANKS     INITIALIZE                  @B2A\n         MVC   ALOC_DSN(8),PREFIX      PREFIX                      @B4A\n         LA    R1,ALOC_DSN             STASRTING POSITION          @B4C\n         AH    R1,PREFIXL                                          @B4C\n         MVC   0(10,R1),CISPFDOT       COPY .$ISPFDSN.             @B4C\n         L     R15,16                  CVT                         @B4A\n         MVC   10(4,R1),CVTSNAME-CVT(R15)  GET SMFID (SYSID)       @B4A\n         MVC   ALOC_DDN,CTEMPPDS       SET DDNAME FOR TEMPDD       @B3A\n         MVC   IUSE_DDN,ALOC_DDN       SET DDNAME IN USE\n         LA    R0,ALOC_DDN             GET ADDR OF DDNAME\n         LA    R1,ALOC_DSN             GET ADDR OF DSNAME\n         BRAS  R14,DYN_ALLOCATE        DYNALLOC PREFIX.ISPFDSN.&SID\n         LTR   R15,R15                 RC = 0 ?\n         JZ    GLB_1STMEM              YES. SKIP TRACE MESSAGE\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,176(,R8)             AMSG44 (4*44)\n         MVC   4(6,R8),CGLOBAL                                     @B4A\n         BRAS  R14,PUTLINE             GLOBAL ISPFDSN DATASET NOT FOUND\n         J     GLOBAL_ISPFDSN_EXIT     BRANCH\nGLB_1STMEM     DS   0H\n         SR    R5,R5                   START FROM FIRST MEMBER\n         LA    R1,$ISPFDSN             PROCESS MEMBER $ISPFDSN     @B3A\n         TM    DSNFLAG2,DSNPASS1       FIRST TIME EXECUTE ?        @B4A\n         JNO   GLB_PROCPDS             BRANCH IF FIRST TIME        @B4C\n*\nGLB_NEXTMEM    DS  0H\n         LA    R0,8                    SET GET MBR FLAG\n         LR    R1,R5                   GET CURRENT MEMBER ADDR\n         BRAS  R14,PROCESS_MEMBER      GET A MEMBER\n         LTR   R15,R15                 ANY MEMBERS LEFT ?\n         JNZ   GLB_CLOSE_FILE          NO. BRANCH\n         LR    R5,R1                   SAVE MEMBER PLACEHOLDER\nGLB_PROCPDS    DS  0H\n         MVC   IUSE_MBR,0(R1)          SAVE NAME OF MEMBER\n         MVC   IUSE_DSN,ALOC_DSN       SET NAME OF PDS BEING PROCESSED\n         LA    R0,TEMPDD               GET ADDR OF DCB\n         LA    R2,ALLOCPH              ADDR OF PLACEHOLDER\n         BRAS  R14,PROCESS_PDS         GET 1ST REC\n         LTR   R15,R15                 MEMBER FOUND ?\n         JZ    GLB_MEM_DONE            BRANCH IF YES\n         CLI   IUSE_MBR,X'00'               ??\n         JE    GLB_CLOSE_FILE          YES. EXIT\n         CLC   IUSE_MBR,$ISPFDSN       MEMBER = $ISPFDSN ?         @B4A\n         JNE   GLB_NEXTMEM             YES. BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,76(,R8)              MSG19 (4*19)\n         MVI   4(R8),C'G'              ROUTINE FOOTPRINT\n         MVC   23(44,R8),IUSE_DSN      PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY PROCESSING DSN = XXX\n         J     GLB_CLOSE_FILE          BRANCH\nGLB_MEM_DONE   DS   0H\n         LTR   R5,R5                                               @B4A\n         JZ    GLB_GET_REC                                         @B4A\n         MVI   8(R5),C'Y'              DELETE MEMBER FROM TABLE\n         LH    R8,MBRCT                                            @B4A\n         AHI   R8,-1                                               @B4A\n         STH   R8,MBRCT                                            @B4A\nGLB_GET_REC    DS   0H\n         BRAS  R14,ISPFDSN_PARMLIB     PROCESS THIS RECORD\n         CHI   R15,8                   TERMINATE CURRENT MEMBER ?  @A9A\n         JE    GLB_NEXTMEM             YES. BRANCH                 @A9A\n         LA    R0,TEMPDD               GET ADDR OF TEMPDD DCB\n         SR    R1,R1                   SET GET NEXT RECORD\n         LA    R2,ALLOCPH              ADDR OF PLACEHOLDER\n         BRAS  R14,PROCESS_PDS         GET NEXT RECORD\n         LTR   R15,R15                 END OF MEMBER ?\n         JZ    GLB_GET_REC             NO . READ NEXT RECORD\n         J     GLB_NEXTMEM             READ NEXT MEMBER\n*\nGLB_CLOSE_FILE DS 0H\n         BRAS  R14,CLOSE_TEMPPDS       DEALLOC TEMPPDS\nGLOBAL_ISPFDSN_EXIT DS 0H\n         SR    R15,R15                 SET RC TO 0\n         PR                            RETURN TO CALLER            @B2A\n         EJECT\n*---------------------------------------------------------------------*\n*        LOGONPRC AND DSN PROCESSING                                  *\n*---------------------------------------------------------------------*\nPROC_ISPFDSN   DS  0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B4A\n         TM    DSNFLAG,DSNDSNM         DSN KEYWORD ?               @B4A\n         JO    PROC_CHK_DSN                                        @B4A\n         MVC   ALOC_DSN(44),BLANKS     INIT TO BLANKS              @B4A\n         MVC   ALOC_DSN(8),PREFIX      COPY PREFIX                 @B4A\n         LA    R1,ALOC_DSN             STARTING POSITION           @B4A\n         AH    R1,PREFIXL              ADD PREFIX LENGTH           @B4A\n         MVC   0(17,R1),CISPFDOT       COPY .$ISPFDSN.PROCLIB      @B4A\nPROC_CHK_DSN   DS  0H\n         LA    R1,ALOC_DSN             GET ADDR OF DSNAME\n         BRAS  R14,CHECK_DSNAME        RACHECK AND LOCATE FILE\n         LTR   R15,R15                 RC = 0 ?\n         JNZ   PROC_ISPFDSN_EXIT       NO. EXIT\n         LA    R0,CTEMPPDS             R0 = ADDR OF DDNAME\n         LA    R1,ALOC_DSN             R1 = ADDR OF DSNAME\n         BRAS  R14,DYN_ALLOCATE        DYNALLOC ISPFDSN PROCLIB\n         LTR   R15,R15                 RC = 0 ?\n         JZ    PROC_OPENPARM           YES . BRANCH\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    PROC_ISPFDSN_EXIT       EXIT IF TRACE IS OFF\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,104(,R8)             EMSG26 (4*26)\n         MVC   59(44,R8),ALOC_DSN      PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY EMSG26\n         J     PROC_ISPFDSN_EXIT       BRANCH\nPROC_OPENPARM  DS  0H\n         MVC   IUSE_DSN,ALOC_DSN       SET NAME OF PDS BEING PROCESSED\n         MVC   IUSE_MBR,ALOC_MEM       SET MBR NAME BEING PROCESSED\n         LA    R0,TEMPDD               DCB ADDR OF TEMPDD\n         LA    R1,ALOC_MEM             POINT TO MEMBER TO PROCESS\n         LA    R2,ADDR_PH              ADDR OF PLACEHOLDER\n         BRAS  R14,PROCESS_PDS         GET 1ST RECORD\n         LTR   R15,R15                 MEMBER FOUND ?\n         JZ    PROC_GETREC             YES. BRANCH\n         TM    DSNFLAG,DSNTRACE        DSNTRACE FLAG ON ?\n         JZ    PROC_CLOSE_FILE         NO. SKIP TRACE MESSAGE\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R1,56(,R8)              EMSG14 (4*14)\n         MVC   28(8,R8),ALOC_MEM       PUT MEMBER NAME IN MSG\n         MVC   46(8,R8),ALOC_DDN       PUT DDNAME IN MSG           @B3A\n         MVC   61(44,R8),ALOC_DSN      PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY EMSG14\n         J     PROC_CLOSE_FILE         BRANCH\nPROC_GETREC    DS  0H\n         BRAS  R14,ISPFDSN_PARMLIB     PROCESS THIS RECORD\n         LA    R0,TEMPDD               DCB ADDR OF TEMPDD\n         SR    R1,R1                   INDICATE GET NEXT RECORD\n         LA    R2,ADDR_PH              ADDR OF PLACEHOLDER\n         BRAS  R14,PROCESS_PDS         GET NEXT RECORD\n         LTR   R15,R15                 END OF MEMBER ?\n         JZ    PROC_GETREC             READ NEXT RECORD\nPROC_CLOSE_FILE   DS  0H\n         BRAS  R14,CLOSE_TEMPPDS       UN-ALLOC PROC PDS\nPROC_ISPFDSN_EXIT DS  0H\n         PR                            RETURN\n*---------------------------------------------------------------------*\n*               PROCESS ISPFDSN RECORDS                               *\n*---------------------------------------------------------------------*\n* INPUT  R1 -> INPUT RECORD                                           *\n*---------------------------------------------------------------------*\n* OUTPUT R15 = 0 - ALL OK                                             *\n*            = 8 - TERMINATE PROCESSING OF CURRENT MEMBER             *\n*---------------------------------------------------------------------*\nISPFDSN_PARMLIB DS 0H\n         BAKR  R14,0                                               @B2A\n         SR    R15,R15                 ASSUME OK RETURN CODE\n         LR    R2,R1                   GET ADDR OF INPUT RECORD\n         LR    R5,R1                   GET ADDR OF INPUT RECORD    @B3A\n*---------------------------------------------------------------------*\n*              PROCESS END OF MEMBER CARD                             *\n*---------------------------------------------------------------------*\n         CLC   JCLCOMT+1(2),0(R2)      /*  END OF MEMBER CARD ?    @B3A\n         JNE   PARM1000                                            @A9A\n         LA    R15,8                   SET TERMINATE RET CODE      @A9A\n         PR                            EXIT                        @E4C\n*---------------------------------------------------------------------*\n*              IGNORE COMMENT CARDS AND BLANK RECORD                  *\n*---------------------------------------------------------------------*\nPARM1000 DS    0H                                                  @A9A\n         CLC   JCLCOMT,0(R2)           //*  COMMENT RECORD ?       @B3C\n         JE    PARMEXIT                YES. BRANCH\n         CLC   JCLCOMT+1(2),0(R2)      /*   COMMENT RECORD ?       @B3C\n         JE    PARMEXIT                YES. BRANCH\n         CLI   0(R2),C'*'              *    COMMENT RECORD ?       @B3C\n         JE    PARMEXIT                YES. BRANCH\n         CLC   BLANKS,0(R2)            BLANK RECORD ?\n         JE    PARMEXIT                YES. IGNORE IT\n*---------------------------------------------------------------------*\n*        PROCESS DDNAME                                               *\n*---------------------------------------------------------------------*\n         DS    0H\n         CLC   JCLCOMT(2),0(R2)        // KEYWORD ?                @B3A\n         JNE   PARM_CHK_KEYWORD        NO. BRANCH                  @B3A\n         LA    R1,2(,R2)               YES. POINT TO DDNAME        @B3A\n*---------------------------------------------------------------------*\n* OUTPUT  IF DDNAME INVALID THEN SET FLAG DSNDDNF IN DSNFLAG. THIS    *\n*         WILL IGNORE ALL THE DSNAMES UNDER THE INVALID DDNAME.       *\n*         EXAMPLE : STEPLIB IS INVALID DDNAME AND ALL THE DSNAMES     *\n*                   UNDER STEPLIB ARE IGNORED.                        *\n*         COPY DDNAME TO CURR_DDN FOR VALID DDNAME.                   *\n*---------------------------------------------------------------------*\n         CLC   CSTEPLIB,0(R1)          IS DDNAME STEPLIB ?         @B3C\n         JE    PARM_INV_DDN            YES. BRANCH\n         CLC   CJOBLIB,0(R1)           IS DDNAME JOBLIB ?          @B3C\n         JE    PARM_INV_DDN            YES. BRANCH\n         CLC   CSTEPCAT,0(R1)          IS DDNAME STEPCAT ?         @B3C\n         JE    PARM_INV_DDN            YES. BRANCH\n         CLC   CJOBCAT,0(R1)           IS DDNAME JOBCAT ?          @B3C\n         JE    PARM_INV_DDN            YES. BRANCH\n         CLI   0(R1),C' '                                          @B3A\n         JE    PARM_PROCDD                                         @B3A\n         LA    R0,C' '                 SET SPACE AS SEARCH STRING  @B3A\n         LA    R15,8(R1)               ENDING POSITION             @B3A\nSRST0    SRST  R15,R1                  SEARCH A SPACE              @B3A\n         JC    1,SRST0                 LOOP UNTIL A SPACE IS FOUND @B3A\n         JC    2,PARM_CHK_DDN8         BRANCH IF NOT FOUND         @B3A\n         J     PARM_CHK_DDN                                        @B4A\nPARM_CHK_DDN8  DS  0H                                              @B4A\n         CLI   8(R1),C' '              DDNAME LONGER THAN 8        @B4A\n         JNE   PARM_INV_DDN2           BRANCH IF YES               @B4A\nPARM_CHK_DDN   DS  0H                                              @B4A\n         SR    R15,R1                  GET LENGTH OF DDNAME        @B4A\n*        BCTR  R15,0                ??\n         MVC   CURR_DDN,BLANKS         INIT TO BLANKS              @B4A\n         EX    R15,MVCDDN              CURR_DDN,0(R1)              @B4A\n         NI    DSNFLAG2,255-DSNDDNF    RESET FLUSH FLAG\n         J     PARM_PROCDD             PROCESS DSNAME              @B3A\n*\nPARM_INV_DDN   DS  0H\n         OI    DSNFLAG2,DSNDDNF        ON FLUSH ALLOCS FLAG\n         MVC   CURR_DDN,BLANKS                                     @B4A\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    PARMEXIT                SKIP TRACE MSG IF TRACE IS OFF\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,64(,R8)              EMSG16 (4*16)\n         MVC   14(8,R8),0(R1)          PUT DDNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY EMSG16\n         J     PARMEXIT                SKIP TRACE MSG IF TRACE IS OFF\nPARM_INV_DDN2  DS  0H                                              @B4A\n         OI    DSNFLAG2,DSNDDNF        ON FLUSH ALLOCS FLAG        @B4A\n         MVC   CURR_DDN,BLANKS         INITIALIZE TO BLANKS        @B4A\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?             @B4A\n         JZ    PARMEXIT                SKIP TRACE MSG IF TRACE IS OFF\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4A\n         L     R8,216(,R8)             EMSG54 (4*54)               @B4A\n         BRAS  R14,PUTLINE             DISPLAY EMSG54              @B4A\n         J     PARMEXIT                                            @B4A\n*\n*---------------------------------------------------------------------*\n*              PROCESS INCLUDE KEYWORDS                               *\n*---------------------------------------------------------------------*\nPARM_CHK_KEYWORD  DS  0H\n         LA    R1,8(0,R2)              ASSUME INCLUDE KEYWORD\n         CLC   CINCLUDE,0(R2)          INCLUDE= KEYWORD ?          @B3A\n         JNE   PARM_EXCLUDE            NO. BRANCH                  @B4C\n         CLC   $ISPFDSN,0(R1)          MEMBER = $ISPFDSN ?         @B4A\n         JE    PARM_RSVMEM             BRANCH IF EQUAL             @B4A\n         CLI   0(R1),C' '                                          @B4A\n         JE    PARM_INVMEM             BRANCH IF EQUAL             @B4A\n         SR    R0,R0                   SET ADD INDICATOR\n         BRAS  R14,PROCESS_MEMBER      ADD MEMBER TO MEMBER TABLE\n         CHI   R15,4                   IS MEMBER ALREADY EXIST?\n         JNE   PARM2300                NO. BRANCH\n         TM    DSNFLAG,DSNTRACE        TRACE OPTION SPECIFIED?\n         JZ    PARM2300                NO SKIP TRACE MSG\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,68(,R8)              EMSG17 (4*17)\n         MVC   14(8,R8),0(R1)          YES. PUT MBR NAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY EMSG17\nPARM2300 DS    0H\n         CHI   R15,20                  DUPLICATE ENTRY\n         JNE   PARMEXIT                BRANCH IF RC IS NOT 20\n         TM    DSNFLAG,DSNTRACE        TRACE OPTION SPECIFIED?\n         JZ    PARM2400                NO SKIP TRACE MSG\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,16(,R8)              EMSG04 (4*4)\n         MVC   20(8,R8),0(R1)          YES. PUT MBR NAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY EMSG04\nPARM2400 DS    0H\n         CHI   R15,16                  IS TABLE FULL ?\n         JNE   PARMEXIT                YES. BRANCH\n         L     R8,100(,R8)             EMSG25 (4*25)\n         MVC   56(8,R8),0(R1)          YES. PUT MBR NAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY REACH 50 MEMBERS\n         J     PARMEXIT                NO. BRANCH\n*---------------------------------------------------------------------*\n*              PROCESS EXCLUDE KEYWORD                                *\n*---------------------------------------------------------------------*\n*      ADDS MEMBER NAME TO MEMBER TABLE THEN MARKS IT DELETED.        *\n*      THIS WILL PREVENT IT BEING ADDED OR PROCESSED LATER.           *\n*---------------------------------------------------------------------*\nPARM_EXCLUDE   DS  0H\n         CLC   CEXCLUDE,0(R2)          EXCLUDE= KEYWORD ?          @B3A\n         JNE   PARMEXIT                NO. BRANCH                  @B3C\n         CLC   $ISPFDSN,0(R1)          MEMBER = $ISPFDSN ?         @B4A\n         JE    PARM_RSVMEM             BRANCH IF EQUAL             @B4A\n         CLI   0(R1),C' '              MEMBER = BLANK  ?           @B4A\n         JE    PARM_INVMEM             BRANCH IF EQUAL             @B4A\n         SR    R0,R0                   SET ADD MEMBER\n         BRAS  R14,PROCESS_MEMBER      ADD MEMBER INTO TABLE\n         LA    R1,8(0,R2)              POINT TO MEMBER NAME\n         LA    R0,4                    DELETE MEMBER\n         BRAS  R14,PROCESS_MEMBER      DELETE MEMBER FROM TABLE\n         J     PARMEXIT                BRANCH\nPARM_INVMEM    DS  0H                                              @B4A\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?             @B4A\n         JZ    PARMEXIT                SKIP TRACE IF TRACE IS OFF  @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4A\n         L     R8,200(,R8)             AMSG50 (4*50)               @B4A\n         BRAS  R14,PUTLINE             DISPLAY MESSAGE MSG50       @B4A\n         J     PARMEXIT                BRANCH\nPARM_RSVMEM    DS  0H                                              @B4A\n         TM    DSNFLAG,DSNTRACE+DSNLIST     TRACE OR LIST OPTION   @B4A\n         JZ    PARMEXIT                SKIP TRACE MSG IF TRACE OFF @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4A\n         L     R8,20(,R8)              MSG05 (4*49)                @B4A\n         BRAS  R14,PUTLINE         DISPLAY $ISPFDSN IS PROHIBITED  @B4A\n         J     PARMEXIT                BRANCH\n*---------------------------------------------------------------------*\n*        PROCESS DD  DSNAME/SYSOUT/TERM/DUMMY                         *\n*---------------------------------------------------------------------*\nPARM_PROCDD    DS  0H                                              @B4A\n         TM    DSNFLAG2,DSNDDNF    ARE WE FLUSHING TILL NEXT DDNAME\n         JO    PARMEXIT                YES. BRANCH\n         LR    R1,R5                   R1 = INPUT RECORD           @B3A\n         BRAS  R14,PROCESS_DD_STMT     PROCESS DSNAME RECORD\nPARMEXIT DS    0H\n         SR    R15,R15                 SET RC = 0\n         PR                            RETURN TO CALLER            @B2A\n         EJECT\n*---------------------------------------------------------------------*\n*                  PARTITIONED DATASET PROCESSING                     *\n*---------------------------------------------------------------------*\n* INPUT  R0 =  DCB ADDR                                               *\n*        R1 -> MEMBER NAME TO LOCATE                                  *\n*           =  0 - GET NEXT RECORD OF CURRENT MEMBER                  *\n*        R2 -> PLACE HOLDER CONTROL BLOCK                             *\n*---------------------------------------------------------------------*\n* OUTPUT R15 = 4   MEMBER NOT FOUND OR EOF ON MEMBER                  *\n*            = 0   MEMBER FOUND AND R1 POINTS TO NEXT RECORD          *\n*---------------------------------------------------------------------*\nPROCESS_PDS DS 0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\n         BALR  R12,0                   ESTABLISH ADDRESSIBILITY    @B3A\n         USING *,R12\n         USING PH,R2                   MAP PLACE HOLDER\n         LR    R3,R1                   SAVE ADDR OF MEMBER NAME\n         LR    R7,R0                   GET ADDR OF PDS DCB\n         USING IHADCB,R7               MAP PDS DCB\n         TM    DCBOFLGS,DCBOFOPN       IS THE PDS OPEN ?\n         JO    PDS0100                 YES. BRANCH\n*--------------------------------------------------------------------*\n*              LOCATE THE DESIRED MEMBER                             *\n*--------------------------------------------------------------------*\n         OPEN  ((R7),INPUT)            OPEN THE TEMP DATASET\nPDS0100  DS    0H\n         LTR   R3,R3                   LOCATE MEMBER ?\n         JZ    PDS_GET_RECORD          BRANCH IF ZERO\n         FIND  (R7),(R3),D             LOCATE MEMBER\n         LTR   15,15                   MEMBER EXIST ?\n         JNZ   PROCESS_PDS_EXIT4       NO. BRANCH\n         MVC   CURRMEM,0(R3)           SAVE NAME OF MBR BEING PROCESSED\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    PDS0300                 NO.  BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,196(,R8)             MSG49 (4*49) PROCESS MEMBER\n         MVC   22(8,R8),0(R3)          PUT MEMBER NAME IN MSG\n         MVC   37(44,R8),ALOC_DSN      PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY MESSAGE MSG49\nPDS0300  DS    0H\n         LH    R4,DCBBLKSI             GET BLKSIZE OF PDS\n         XC    NEXTREC,NEXTREC         FORCE READ OF BLOCK\n*--------------------------------------------------------------------*\n*              GET NEXT RECORD FROM CURRENT PDS MEMBER               *\n*--------------------------------------------------------------------*\nPDS_GET_RECORD DS 0H\n         L     R4,NEXTREC              GET ADDR OF NEXT RECORD\n         LTR   R4,R4                   DO WE NEED NEXT BLOCK ?\n         JNZ   PDS_REC_DISPLAY         NO . BRANCH\n         L     R4,BUFFADDR             LOAD BUFFER ADDRESS\n         READ  DECB,SF,(R7),(R4),'S'   READ A BLOCK INTO BUFFER\n         CHECK DECB\n*--------------------------------------------------------------------*\n*          DETERMINE THE SIZE OF THE BLOCK THAT HAS BEEN READ        *\n*--------------------------------------------------------------------*\n         LH    R5,DCBBLKSI             GET BLKSIZE OF PDS\n         LARL  R6,DECB+16              GET ADDR OF DECB\n         L     R6,0(R6)                GET IOB ADDR\n         SH    R5,14(,R6)              CALC SIZE OF BLOCK READ\n         ST    R5,REMAINS              SAVE COUNT OF BYTES IN BLOCK\n*--------------------------------------------------------------------*\n*        DISPLAY ISPFDSN RECORD                                      *\n*--------------------------------------------------------------------*\nPDS_REC_DISPLAY  DS   0H\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    PDS_DEBLOCK_REC         NO.  BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,152(,R8)             MSG38 (4*38)\n         MVC   14(72,R8),0(R4)         COPY INPUT REC TO MSG38\n         BRAS  R14,PUTLINE     DISPLAY A RECORD FROM ISPFDSN PARMLIB\nPDS_DEBLOCK_REC  DS    0H\n         LR    R1,R4                   POINT R1 AT RECORD\n         AHI   R4,80                   POINT TO NEXT RECORD IN BLOCK\n         ST    R4,NEXTREC              SAVE ADDR OF NEXT RECORD\n         L     R5,REMAINS              GET COUNT OF BYTES LEFT IN BLK\n         AHI   R5,-80                  CALC # OF BYTES LEFT IN BLOCK\n         ST    R5,REMAINS              SAVE NEW BYTE COUNT\n         JNZ   PROCESS_PDS_EXIT        BRANCH IF BYES LEFT\n         XC    NEXTREC,NEXTREC         END OF BLOCK. FORCE READ\n         J     PROCESS_PDS_EXIT        BRANCH NO MORE BYES LEFT\n*\n*--------------------------------------------------------------------*\n*        END OF MEMBER                                               *\n*--------------------------------------------------------------------*\nPDS_EOFM DS    0H\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    PROCESS_PDS_EXIT4       BRANCH IF OFF\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,148(,R8)             EMSG37 (4*37)\n         MVC   18(8,R8),CURRMEM        PUT MEMBER NAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY MSG EMSG37 EOF MEMBER\nPROCESS_PDS_EXIT4  DS  0H\n         LA    R15,4                   SET NON ZERO RETCODE\n         PR                            RETURN TO CALLER\nPROCESS_PDS_EXIT   DS  0H\n         SR    R15,R15                 SET 0 RETURN CODE\n         PR                            RETURN TO CALLER            @B2A\n         DROP  R2\n         DROP  R7\n         EJECT\n*---------------------------------------------------------------------*\n*  R1 ->  INPUT RECORD                                                *\n*              PROCESS DSNAME/SYSOUT/TERM/DUMMY                       *\n*---------------------------------------------------------------------*\n*        PROCESS SYSOUT                                               *\n*---------------------------------------------------------------------*\nPROCESS_DD_STMT  DS  0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\n         LR    R3,R1                   GET START OF RECORD ADDR\n         CLC   CPROC,10(R3)            PROC ?                      @B3A\n         JE    PDD_DSN_EXIT            EXIT IF PROC STATEMENT      @B3A\n         CLC   CEXEC,10(R3)            EXEC ?                      @B3A\n         JE    PDD_DSN_EXIT            EXIT IF EXEC STATEMENT      @B3A\n         LA    R12,5(R3)               START OF SEARCH STRING      @B4A\n         LA    R15,71(R3)              END OF SEARCH STRING        @B4A\nPDD_FIND_DD    DS    0H                                            @B4A\n         CLC   DDJCL,0(R12)            ' DD ' ?                    @B4A\n         JE    PDD_ESYSOUT             BRANCH IF EQUAL             @B4A\n         AHI   R12,1                   NEXT POSTION                @B4A\n         CR    R12,R15                                             @B4A\n         JH    PDD_DSN_EXIT                                        @B4A\n         J     PDD_FIND_DD                                         @B4A\nPDD_ESYSOUT    DS    0H                                            @B4A\n         LA    R12,3(,R12)             SAVE POSITION OF DDNAME     @B4A\n         LR    R3,R12                  SAVE POSITION OF DDNAME     @B4A\nPDD_FSYSOUT    DS    0H                                            @B4A\n         CLC   CSYSOUT,0(R12)          ' SYSOUT=' ?                @B3A\n         JE    PDD_SYSOUT              BRANCH IF YES               @B4A\n         AHI   R12,1                                               @B4A\n         CR    R12,R15                 END OF RECORD?              @B4A\n         JH    PDD_TERM                BRANCH IF YES               @B4A\n         J     PDD_FSYSOUT             NO. BRANCH\nPDD_SYSOUT     DS    0H                                            @B4A\n         LA    R1,1(,R12)              GET ADDR OF SYSOUT STMT     @B4C\n         CLI   7(R1),C'*'              SYSOUT=* ??                 @B4A\n         JE    PDD_SYSOUT_ER1          BRANCH IF YES               @B4A\n         CLC   CTERM+1(7),9(R1)        TERM=TS                     @B4A\n         JE    PDD_SYSOUT_ER2          BRANCH IF YES               @B4A\n         BRAS  R14,ALLOC_SYSOUT        PROCESS SYSOUT ALLOCATIONS\n         J     PDD_DSN_EXIT            BRANCH\nPDD_SYSOUT_ER1 DS    0H                                            @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4A\n         L     R8,208(,R8)             EMSG52 (4*52)               @B4A\n         BRAS  R14,PUTLINE             DISPLAY INVALID SYSOUT CLASS@B4A\n         J     PDD_DSN_EXIT            BRANCH                      @B4A\nPDD_SYSOUT_ER2 DS    0H                                            @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4A\n         L     R8,220(,R8)             EMSG55 (4*55)               @B4A\n         BRAS  R14,PUTLINE             DISPLAY INVALID SYSOUT CLASS@B4A\n         J     PDD_DSN_EXIT            BRANCH                      @B4A\n*---------------------------------------------------------------------*\n*              PROCESS TERMINAL ALLOCATIONS                           *\n*---------------------------------------------------------------------*\nPDD_TERM DS    0H\n         LR    R12,R3                  RESTORE R12                 @B3A\nPDD_FIND_TERM  DS    0H\n         CLC   CTERM,0(R12)            ' TERM=TS,SYSOUT='          @B3A\n*                                        1234567890123456\n         JE    PDD_TERM_ALOC           BRANCH IF YES               @B4A\n         AHI   R12,1                                               @B4A\n         CR    R12,R15                 END OF RECORD ?             @B4A\n         JH    PDD_DMY                 BRANCH IF YES               @B4A\n         J     PDD_FIND_TERM\n*---------------------------------------------------------------------*\n*        PROCESS DD TERM                                              *\n*---------------------------------------------------------------------*\nPDD_TERM_ALOC  DS  0H\n         MVC   TERM_DDNAME,CURR_DDN    PUT DDNAME IN DYNALLOC      @B4C\n         CLC   CSYSOUT+1(7),9(R12)     'SYSOUT='                   @B4A\n         MVI   TERM_SYSO,C'X'          ASSUME CLASS X              @B4A\n         JNE   PDD_TERM_RETRY                                      @B4A\n         CLI   16(R12),C'*'                                        @B4A\n         JE    PDD_TERM_RETRY                                      @B4A\n         MVC   TERM_SYSO,16(R12)       GET SYSOUT                  @B4A\nPDD_TERM_RETRY DS  0H\n         LA    R1,TERM_RBP             GET ADDR OF ALLOC PARM LIST\n         DYNALLOC                      DYNALLOC THE TERMINAL\n         LTR   R15,R15                 RC = 0 ?\n         JZ    PDD_TERM_EXIT           YES. BRANCH\n         L     R12,RACFWORK\n         ST    R15,0(,12)              SAVE DYNALLOC ERROR CODE\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',TERM_ERCD    GET ERROR CODE FROM RB\n         ST    R1,4(,12)               SAVE RB ERROR CODE\n         SR    R2,R2                   CLEAR R1\n         ICM   R2,B'0011',TERM_INFO    GET INFO CODE FROM RB\n         ST    R2,8(,12)               SAVE RB INFO CODE\n         XC    12(4,R12),12(R12)       NO DSNAME\n         LA    R4,TERM_DDNAME          GET ADDR OF FAILING DDNANE\n         ST    R4,16(,R12)             SAVE ADDR OF FAILING DDNANE\n         LA    R5,CDYNALLO             DYNALLOC                    @B3C\n         ST    R5,20(,R12)             SAVE DYNALLOC FUNCTION CODE @B3C\n         BRAS  R14,DYN_ERROR_MSG       FORMAT DYNAMIC ERROR MESSAGE\n         CLC   X0410,TERM_ERCD         DDNAME IN USE ?             @B3A\n         JNE   PDD_TERM_EXIT8          NO.  BRANCH\n         LA    R1,TERM_DDNAME          YES. GET DDNAME TO DEALLOC\n         BRAS  R14,UN_ALLOCATE         DEALLOC DDNAME\n         LTR   R15,R15                 DEALLOC OK ?\n         JZ    PDD_TERM_RETRY          YES. RETRY ALLOC\nPDD_TERM_EXIT8 DS  0H\n         LA    R15,8                   SET DYNALLOC FAILED CODE\n         J     PDD_DSN_EXIT\nPDD_TERM_EXIT  DS  0H\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?            @B3A\n         JZ    PDD_DSN_EXIT            SKIP TRACE IF TRACE IS OFF @B3A\n         L     R8,ISPFMSGS             MESSAGE CSECT              @B3A\n         L     R8,184(,R8)             MSG46 (4*46)               @B3A\n         MVC   29(8,R8),TERM_DDNAME    PUT DDNAME IN MSG          @B3A\n         BRAS  R14,PUTLINE             DISPLAY PROCESSING TERM\n         XR    R15,R15\n         J     PDD_DSN_EXIT            BRANCH\n*---------------------------------------------------------------------*\n*        PROCESS DD DUMMY KEYWORD                                     *\n*---------------------------------------------------------------------*\nPDD_DMY  DS    0H\n         LR    R12,R3                  RESTORE R12                 @B3A\nPDD_DMY_FIND   DS   0H\n         CLC   CDUMMY,0(R12)           DD DUMMY KEYWORD ?          @B3A\n         JE    PDD_DMY_DDN                                         @B4A\n         AHI   R12,1                                               @B4A\n         CR    R12,R15                                             @B4A\n         JH    PDD_DSN                                             @B4A\n         J     PDD_DMY_FIND\nPDD_DMY_DDN    DS   0H\n         MVC   DMY_TXT_DDN,CURR_DDN    PUT DDNAME IN DYNALLOC\nPDD_DMY_RETRY  DS   0H\n         LA    R1,DMY_RBP              GET ADDR OF ALLOC PARM LIST\n         DYNALLOC                      DYNALLOC TO DUMMY\n         LTR   R15,R15                 DYNALLOC OK ?\n         JZ    PDD_DMY_EXIT            YES. BRANCH\n         L     R12,RACFWORK\n         ST    R15,0(,R12)             SAVE DYNALLOC ERROR CODE\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',DMY_ERCD     GET ERROR CODE FROM RB\n         ST    R1,4(,R12)              SAVE RB ERROR CODE\n         SR    R2,R2                   CLEAR R2\n         ICM   R2,B'0011',DMY_INFO     GET INFO CODE FROM RB\n         ST    R2,8(,R12)              SAVE RB INFO CODE\n         XC    12(4,R12),12(R12)       NO DSNAME\n         LA    R4,DMY_TXT_DDN          GET ADDR OF FAILING DDNANE\n         ST    R4,16(,R12)             SAVE ADDR OF FAILING DDNANE\n         LA    R5,CDYNALLO             DYNALLOC                    @B3C\n         ST    R5,20(,R12)             SAVE DYNALLOC FUNCTION CODE @B3C\n         BRAS  R14,DYN_ERROR_MSG       FORMAT DYNAMIC ERROR MESSAGE\n         CLC   X0410,DMY_ERCD          DDNAME IN USE ?             @B3C\n         JNE   PDD_DMY_ERROR           NO.  BRANCH\n         LA    R1,DMY_TXT_DDN          YES. GET DDNAME TO DEALLOC\n         BRAS  R14,UN_ALLOCATE         DEALLOC DDNAME\n         LTR   R15,R15                 DEALLOC OK ?\n         JZ    PDD_DMY_RETRY           YES. RETRY ALLOC\nPDD_DMY_ERROR  DS  0H\n         LA    R15,8                   SET DYNALLOC FAILED CODE\nPDD_DMY_EXIT   DS  0H\n         J     PDD_DSN_EXIT            BRANCH\n*---------------------------------------------------------------------*\n*        PROCESS DD DSN KEYWORD                                       *\n*---------------------------------------------------------------------*\n*  R1 -> INPUT RECORD                                                 *\n*---------------------------------------------------------------------*\nPDD_DSN  DS    0H\n         LR    R12,R3                  RESTORE R12                 @B3A\n         NI    DSNFLAG2,255-DSN1DSN    TURN OFF DSN B4 DISP        @B4A\nPDD_DSN_DISP   DS   0H\n         CLC   CDISP,0(R12)            ' DISP=' ?                  @B3A\n         JE    PDD_DSN_DISPS                                       @B4A\n         CLC   CDSNE+1(4),0(R12)       'DSN='  ?                   @B4A\n         JE    PDD_DSN_DSN1                                        @B4A\n         AHI   R12,1                                               @B4A\n         CR    R12,R15                                             @B4A\n         JH    PDD_DSN_EXIT            NO DISPOSITION              @B4A\n         J     PDD_DSN_DISP\nPDD_DSN_DISPS  DS  0H\n         LA    R8,6(R12)                                           @B4A\n         BRAS  R14,DISPOSTN            PROCESS DISP KEYWORD        @B4A\n         LTR   R15,R15                 RC = 0                      @B4A\n         JNZ   PDD_DSN_EXIT                                        @B4A\n         CLC   CDSNE,9(R12)            ',DSN=' ?                   @B3A\n         JE    PDD_DSN_DSN2            BRANCH IF YES               @A7A\nPDD_DSN_ERROR  DS  0H                                              @A7A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @A7A\n         L     R8,36(,R8)              EMSG09   (4*9)              @B3A\n         MVC   19(60,R8),0(R1)  ?      COPY 1ST 60 BYTES ??        @A7A\n         BRAS  R14,PUTLINE             DISPLAY SYNATX ERROR        @A7A\n         J     PDD_DSN_EXIT                                        @A7A\nPDD_DSN_DSN1   DS   0H                                             @B4A\n         LA    R3,4(,R12)              LOCATE DATA SET NAME        @B4A\n         OI    DSNFLAG2,DSN1DSN        TURN ON DSN B4 DISP         @B4A\n         J     PDD_DSN_TMP                                         @B4A\nPDD_DSN_DSN2   DS   0H                                             @B4C\n         LA    R3,14(,R12)             LOCATE DATA SET NAME        @B3A\nPDD_DSN_TMP    DS   0H                                             @B4A\n         LA    R2,TEMP_DSN             GET ADDR OF DSNAME SAVE AREA\n         MVC   TEMP_DSN(52),BLANKS     INITIALIASE TO BLANK        @A5C\n         TM    DSNFLAG2,DSN1DSN        DSN B4 DISP ?               @B4A\n         JO    PDD_DSN_DSNL            YES, GET LENGTH OF DSNAME   @B4A\n         CLI   0(R3),C'&&'             & SYMBOLIC USED IN DSNAME ?\n         JE    PDD_DSN_GETDS2          NO.  BRANCH\nPDD_DSN_DSNL   DS   0H                                             @B4A\n         LA    R0,C','                 SET , AS THE SEARCH CHAR    @B4A\n         LA    R12,45(R3)              ENDING POSITION             @B4A\nSRST2    SRST  R12,R3                  FIND A COMMA                @B4A\n         JC    1,SRST2                 LOOP UNTIL COMMA IS FOUND   @B4A\n         JC    2,PDD_DSN_GETDS0        BRANCH IF COMMA NOT FOUND   @B4A\n         TM    DSNFLAG2,DSN1DSN                                    @B4A\n         JNO   PDD_DSN_EXIT                                        @B4A\n         CLC   CDISP+1(5),1(R12)       'DISP='                     @B4A\n         JNE   PDD_DSN_EXIT                                        @B4A\n         CLI   9(R12),C','                                         @B4A\n         JE    PDD_DSN_EXIT                                        @B4A\n         MVI   0(R12),C' '                                         @B4A\n         LA    R8,6(R12)               POINT TO DISP               @B4A\n         BRAS  R14,DISPOSTN            PROCESS DISP KEYWORD        @B4A\n         LTR   R15,R15                 RC = 0                      @B4A\n         JNZ   PDD_DSN_EXIT            BRANCH IF RC NOT ZER0       @B4A\n         CLI   0(R3),C'&&'             & SYMBOLIC USED IN DSNAME ?\n         JE    PDD_DSN_GETDS2          NO.  BRANCH\nPDD_DSN_GETDS0 DS    0H                                            @B4A\n         LA    R0,C'('                 SET ( AS THE SEARCH CHAR    @B4A\n         LA    R12,45(R3)              ENDING POSITION             @B4A\nSRST3    SRST  R12,R3                  FIND A BLANK                @B4A\n         JC    1,SRST3                 LOOP UNTIL A ( IS FOUND     @B4A\n         JC    2,PDD_DSN_GETDS1        BRANCH IF ( NOT FIND        @B4A\n         LA    R0,C')'                 SET ( AS THE SEARCH CHAR    @B4A\n         AHI   R12,1                                               @B4A\n         CLI   0(R12),C')'             EMPTY MEMBER ?              @B4A\n         JE    PDD_DSN_INVMEM          BRANCH IF YES               @B4A\n         TM    0(R12),X'F0'            GDG 0 ?                     @B4A\n         JO    PDD_DSN_INVMEM          BRANCH IF YES               @B4A\n         CLI   0(R12),C'-'             '-' ?                       @B4A\n         JE    PDD_DSN_INVMEM          BRANCH IF YES               @B4A\n         LA    R15,8(R12)              ENDING POSITION             @B4A\nSRST4    SRST  R15,R12                 FIND A )                    @B4A\n         JC    1,SRST4                 LOOP UNTIL A ) IS FOUND     @B4A\n         JC    2,PDD_DSN_INVMEM        ) NOT FOUND                 @B4A\n         SR    R15,R12                 LENGTH OF MEMBER            @B4A\n         CHI   R15,9                   MEMBER NAME > 8             @B4A\n         JH    PDD_DSN_INVMEM          BRANCH IF YES               @B4A\n         AHI   R15,-1                  MINUS 1 FOR EX MOVE         @B4A\n         EX    R15,MVCMEMBR            TEMP_MEM(0),0(R12)          @B4A\n         LA    R0,C'('                 SET ( AS THE SEARCH CHAR    @B4A\n         J     PDD_DSN_GETDSM                                      @B4A\nPDD_DSN_GETDS1 DS    0H                                            @B4A\n         LA    R0,C' '                 SET   AS THE SEARCH CHAR    @B4A\nPDD_DSN_GETDSM DS    0H                                            @B4A\n         LA    R12,45(R3)              DSNAME ENDING POSITION      @B4A\nSRST5    SRST  R12,R3                  FIND A BLANK OR (           @B4A\n         JC    1,SRST5                 LOOP UNTIL IT IS FOUND      @B4A\n         JC    2,PDD_DSN_INVDSN        BRANCH IF NOT FOUND         @B4A\n         SR    R12,R3                  GET DSNAME LENGTH           @B4A\n         AHI   R12,-1                  MINUS 1 FOR EXECUTE MOVE    @B4A\n         EX    R12,MVCDSN              TEMP_DSN(0),0(R3)           @B4A\n         LA    R0,C'&&'                SET & AS THE SEARCH STRING  @B4A\n         LA    R15,TEMP_DSN+1                                      @B4A\n         LA    R12,42(R15)                                         @B4A\nSRST7    SRST  R12,R15                                             @B4A\n         JC    1,SRST7                 LOOP UNTIL CHAR & IS FOUND  @B4A\n         JC    2,PDD_DSN_DSNCHK                                    @B4A\n         CLC   CSID(5),0(R12)          &SID ?                      @B4A\n         JNE   PDD_DSN_INVSM2          BRANCH IF NOT &SID          @B4A\n         L     R15,16                  CVT                         @B4A\n         MVC   0(4,R12),CVTSNAME-CVT(R15)   GET &SID               @B4A\n         J     PDD_DSN_DSNCHK                                      @B4A\nPDD_DSN_GETDS2 DS    0H                &SYSUID.XXXXX.XXXX          @B4A\n         CLC   CSYSUID,1(R3)           SYSUID ?                    @B4A\n         JNE   PDD_DSN_INVSM1          BRANCH IF NOT &SYSUID       @B4A\n         LA    R2,TEMP_DSN                                         @B4A\n         MVC   0(8,R2),SYSUID          GET SYSUID                  @B4A\n         AH    R2,SYSUIDL              POINTS TO 2ND LEVEL QUALI   @B4A\n         MVI   0(R2),C'.'                                          @B4A\n         AHI   R2,1                                                @B4A\n         AHI   R3,8                                                @B4A\n         CLC   CSID(5),0(R3)           &SID ?                      @B4A\n         JNE   PDD_DSN_GETDS3                                      @B4A\n*---------------------------------------------------------------------*\n*        RESOLVE SYMBOLIC &SID                                        *\n*---------------------------------------------------------------------*\n         L     R15,16                  CVT\n         MVC   0(4,R2),CVTSNAME-CVT(R15)   GET SMFID\n         AHI   R2,4\n         AHI   R3,4\nPDD_DSN_GETDS3 DS    0H                                            @B4A\n         LA    R0,C' '                 SET BLANK AS SEARCH STRING  @B4A\n         LA    R12,37(R3)              ENDING POSITION             @B4A\nSRST8    SRST  R12,R3                  SEARCH A BLANK              @B4A\n         JC    1,SRST8                 LOOP UNTIL A BLANK IS FOUND @B4A\n         SR    R12,R3                  GET REMAINING LENGTH        @B4A\n         AHI   R12,-1                  MINUS 1 FOR MOVE            @B4A\n         EX    R12,MVCLEFT             MOVE REMAINING DSNAME       @B4A\nPDD_DSN_DSNCHK DS  0H\n         LA    R1,TEMP_DSN             GET ADDR OF DSNAME\n         BRAS  R14,CHECK_DSNAME        RACHECK DATASET ?\n         LTR   R15,R15                 ACCESS OK ?\n         JNZ   PDD_DSN_EXIT            NO.  BRANCH\n*DD_DSN_ALLOC  DS  0H                  ALLOCATE THE DATASET        @A5A\n         LA    R0,TEMP_DSN             GET ADDR OF DSNAME\n         LA    R1,CURR_DDN             GET DDNAME FOR ALLOC\n         BRAS  R14,ALLOCATE_DSN        ALLOC OR CONCAT\nPDD_DSN_EXIT   DS  0H\n         SR    R15,R15                 SET RC TO 0\n         PR                                                        @B2A\nPDD_DSN_INVSM1 DS    0H                INVALID SYMBOLIC            @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,72(,R8)              EMSG18 (4*18)\n         BRAS  R14,PUTLINE             DISPLAY INVALID SYMBOLIC\n         J     PDD_DSN_EXIT4           TERMINATE THIS MEMBER\nPDD_DSN_INVSM2 DS    0H                INVALID SYMBOLIC            @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,212(,R8)             EMSG53 (4*53)\n         BRAS  R14,PUTLINE             DISPLAY INVALID SYMBOLIC\n         J     PDD_DSN_EXIT4           TERMINATE THIS MEMBER\nPDD_DSN_INVMEM DS  0H                                              @B4A\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?             @B4A\n         JZ    PDD_DSN_SKPTM1          SKIP TRACE IF TRACE IS OFF  @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4A\n         L     R8,200(,R8)             AMSG50 (4*50)               @B4A\n         BRAS  R14,PUTLINE             DISPLAY MESSAGE MSG50       @B4A\nPDD_DSN_SKPTM1 DS  0H                                              @B4A\n         J     PDD_DSN_EXIT4           SET RC TO 4                 @B4A\nPDD_DSN_INVDSN DS  0H                                              @B4A\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?             @B4A\n         JZ    PDD_DSN_EXIT4           SKIP TRACE IF TRACE IS OFF  @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4A\n         L     R8,204(,R8)             AMSG50 (4*51)               @B4A\n         BRAS  R14,PUTLINE             DISPLAY MESSAGE MSG51       @B4A\nPDD_DSN_EXIT4  DS  0H                                              @B4A\n         LA    R15,4                   SET RC TO 4                 @B4A\n         PR                                                        @B4A\n         EJECT\n*---------------------------------------------------------------------*\n*        PROCESS DISPOSTION                                           *\n*---------------------------------------------------------------------*\n*       INPUT   R8  = ADDR OF DISP                                    *\n*       OUTPUT  R15 = 0     DISP=SHR/MOD/OLD                          *\n*               R15 = 4     DISP=NEW                                  *\n*               R15 = 8     INVALID DISPOSITION                       *\n*---------------------------------------------------------------------*\nDISPOSTN DS    0H\n         BAKR  R14,0                                               @B4A\n         CLC   CSHR,0(R8)              DISP=SHR ?                  @B3A\n         JNE   DISP_OLD                BRANCH IF NOT EQUAL         @A7A\n         MVI   ALC_TXT3+6,X'08'        SET TEXT UNIT TO DISP=SHR   @A7A\n         J     DISPOST0                                            @B4A\nDISP_OLD DS    0H                                                  @A7A\n         CLC   COLD,0(R8)              DISP=OLD ?                  @B3A\n         JNE   DISP_MOD                BRANCH IF NOT EQUAL         @A7A\n         MVI   ALC_TXT3+6,X'01'        SET TEXT UNIT TO DISP=OLD   @A7A\n         J     DISPOST0                                            @B4A\nDISP_MOD DS    0H                                                  @B4A\n         CLC   CMOD,0(R8)              DISP=MOD ?                  @B4A\n         JNE   DISP_NEW                BRANCH IF NOT EQUAL         @B4A\n         MVC   ALC_TXT3+6,X'02'        SET TEXT UNIT TO DISP=MOD   @B4A\n         J     DISPOST0                                            @B4A\nDISP_NEW DS    0H                                                  @A7A\n         CLC   CNEW,0(R8)              DISP=NEW ?                  @B3A\n         JE    DISPOST4                IGNORE THIS RECORD          @A7A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @A7A\n         L     R8,40(,R8)              EMSG10   (4*10)             @A7A\n         MVC   19(60,R8),0(R1)                                     @A7A\n         BRAS  R14,PUTLINE             INVALID DISPOSITION         @A7A\n         LA    R15,8                                               @B4A\n         PR                                                        @B4A\nDISPOST4 DS    0H                                                  @B4A\n         LA    R15,4                                               @B4A\n         PR                                                        @B4A\nDISPOST0 DS    0H                                                  @B4A\n         SR    R15,R15                                             @B4A\n         PR                                                        @B4A\n*---------------------------------------------------------------------*\n*                 ALLOCATE (AND CONCATENATE)                          *\n*---------------------------------------------------------------------*\n*       INPUT   R0 ->  DSNAME                                         *\n*               R1 ->  DDNAME                                         *\n*---------------------------------------------------------------------*\nALLOCATE_DSN   DS  0H\n         BAKR  R14,0                                              @B2A\n         LR    R2,R0                   SAVE DSNAME ADDR\n         LR    R3,R1                   SAVE DDNAME ADDR\n         L     R4,DDNTABLE             CHECK IF ALREADY ALLOC'ED   @B3C\n         LA    R5,50                   NO. OF TABLE ELEMENTS       @B3C\nADSN_SEARCH_DD DS  0H\n         CLC   0(8,R3),0(R4)           DDNAME ALLOCATED ?\n         JE    ADSN_CONCAT             YES. BRANCH TO CONCAT\n         CLI   0(R4),X'00'             END OF DDNAME TABLE ?       @B3C\n         JE    ADSN_ALC                YES. BRANCH TO ALLOCATE\n         LA    R4,8(0,R4)              POINT TO NEXT ENTRY\n         BRCT  R5,ADSN_SEARCH_DD       LOOP THRU DDNAME TABLE\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,92(,R8)              EMSG23 (4*23)\n         BRAS  R14,PUTLINE             50 DDNAMES ARE ALLOCATED\n         J     ALLOCATE_DSN_EXIT       EXIT\nADSN_ALC DS    0H                      PRIMARY ALLOCATION\n         MVC   ALOC_DDN,0(R3)          DDNAME FOR ALLOCATION\n         MVC   ALOC_DSN(52),0(R2)      DSNAME FOR ALLOCATION       @A5C\n         LA    R0,ALOC_DDN             GET ADDR OF DDNAME\n         LA    R1,ALOC_DSN             GET ADDR OF DSNAME\n         BRAS  R14,DYN_ALLOCATE        DYNALLOC DATASET\n         LTR   R15,R15                 RC = 0 ?\n         JNZ   ADSN_ERROR              NO. BRANCH\n         MVC   0(8,R4),0(R3)           PUT DDNAME IN TABLE\n         PR                            RETURN\nADSN_ERROR     DS  0H                  ERROR HANDLING ROUTINE\n         CHI   R0,X'0210'              DATASET IN USE ?            @B3C\n         JNE   ADSN_NOT0210            NO.  BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,96(,R8)              EMSG24 (4*24)\n         MVC   26(8,R8),0(R3)          PUT DDNAME IN MSG\n         MVC   31(44,R8),0(R2)         PUT DSNAME IN MSG\n         J     ALLOCATE_DSN_EXIT       DISPLAY MSG AND RETURN\nADSN_NOT0210   DS 0H                   UNKNOWN DYNALLOC ERROR\n         CHI   R0,X'1708'              LOCATE ERROR ?              @B3C\n         JNE   ADSN_NOT1708            NO.  BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,80(,R8)              EMSG30 (4*20)\n         MVC   37(44,R8),0(R2)         PUT DSNAME IN MSG\n         TM    DSNFLAG,DSNLIST+DSNTRACE    LIST OR TRACE ACTIVE ?\n         JNZ   ALLOCATE_DSN_EXIT       YES. DISPAY MSG AND RETURN\n         PR\nADSN_NOT1708   DS 0H                   CHECK DYNALLOC ERROR CODE\n         CHI   R0,X'0410'              DDNAME IN USE . SKIP IT     @B3C\n         JNE   ADSN_NOT0410            NO.  BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,180(,R8)             EMSG45 (4*45)\n         MVC   6(8,R8),0(R3)           PUT DDNAME IN MSG\n         TM    DSNFLAG,DSNLIST+DSNTRACE    LIST OR TRACE ACTIVE ?\n         JNZ   ALLOCATE_DSN_EXIT       YES. DISPLAY MSG AND RETURN\n         PR                            RETURN\nADSN_NOT0410   DS 0H                   CHECK DYNALLOC ERROR CODE\n         CHI   R0,X'0420'              DATASET OPEN. SKIP IT       @B3C\n         JNE   ADSN_NOT0420            NO.  BRANCH                 @A7C\n         PR                            RETURN\nADSN_NOT0420   DS 0H                   CHECK DYNALLOC ERROR CODE   @A7A\n         CHI   R0,X'035C'              INVALID PARM. SKIP IT       @B3A\n         JNE   ADSN_UNKNOWN_ERROR      NO.  BRANCH                 @A7A\n         CLI   0(R3),X'00'             BLANK DDNAME ?              @A7A\n         JNE   ADSN_INV_PARM           NO.  BRANCH                 @A7A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @A7A\n         L     R8,132(,R8)             EMSG33 (4*33) BLANK DDNAME  @A7A\n         MVC   26(9,R8),0(R3)          PUT DDNAME IN MSG           @A7A\n         MVC   31(44,R8),0(R2)         PUT DSNAME IN MSG           @A7A\n         J     ALLOCATE_DSN_EXIT\nADSN_INV_PARM  DS  0H                                              @A7A\n         TM    DSNFLAG,DSNTRACE                                    @B4A\n         JO    ALLOCATE_DSN_EXIT                                   @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4C\n         L     R8,128(,R8)             EMSG32 (4*32) INVALID PARM  @B4C\n         MVC   26(8,R8),0(R3)          PUT DDNAME IN MSG           @B4C\n         MVC   41(44,R8),0(R2)         PUT DSNAME IN MSG           @B4C\n         J     ALLOCATE_DSN_EXIT\nADSN_UNKNOWN_ERROR   DS   0H           UNKNOWN DYNAMIC ALLOCATION ERROR\n         LR    R7,R0                   SAVE DYNALLOC ERROR CODE\n         LR    R5,R1                   SAVE DYNALLOC INFO CODE\n         LR    R6,R15                  SAVE DYNALLOC RET CODE\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,48(,R8)              EMSG12 (4*12)\n         MVC   4(8,R8),CALLOCAT        ALLOCATE FUNCTION NAME      @B3A\n         MVC   29(8,R8),0(R3)          PUT DDNAME IN EMSG12\n         MVC   42(44,R8),0(R2)         PUT DSNAME IN EMSG12\n         BRAS  R14,PUTLINE             DISPLAY\n         LR    R0,R6                   GET RETURN CODE\n         BRAS  R14,HEX2CHAR            CONVERT HEX TO CHAR\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,52(,R8)              EMSG13 (4*13)\n         MVC   10(4,R8),OUTSTRNG       PUT RET CODE IN EMSG13\n         LR    R0,R7                   GET ERROR CODE\n         BRAS  R14,HEX2CHAR            CONVERT HEX TO CHAR\n         ST    R0,28(R8)               PUT ERROR CODE IN EMSG13\n         LR    R0,R5                   GET INFO CODE\n         BRAS  R14,HEX2CHAR            CONVERT HEX TO CHAR\n         ST    R0,48(R8)               PUT INFO CODE IN MSG\n         BRAS  R14,PUTLINE             DISPLAY ERROR MESSAGE EMSG13\n         ABEND 100,DUMP                USER ABEND 100\n*\nADSN_CONCAT    DS   0H                 CONCAT TO EXISTING DDNAME\n         LA    R1,CISPTABL             ASSUME ERROR                @B3A\n         CLC   CISPTABL,0(R3)          IS DDNAME=ISPTABL ?         @B3A\n         JE    ADSN_CONCAT_ERROR       YES. BRANCH\n         LA    R1,ISPPROF              ASSUME ERROR\n         CLC   ISPPROF,0(R3)           IS DDNAME=ISPPROF ?\n         JE    ADSN_CONCAT_ERROR       YES. BRANCH\n         LA    R1,CURR_DDN             LOAD DDNAME ADDRESS         @B4A\n         L     R3,DSNTABLE             LOAD ADDRESS OF DSNTABLE    @B4A\nADSN_DUP_CHK   DS   0H                 CHECK DUPLICATE DSNAME      @B4A\n         CLI   8(R3),X'40'             END OF DSNTABLE ?           @B4A\n         JE    ADSN_DUP_CHK_EXIT       BRANCH IF YES               @B4A\n         CLC   0(8,R1),0(R3)           DDNAME FIND ??              @B4A\n         JNE   ADSN_DUP_CHK_NEXT       NOT MATCH TRY NEXT ENTRY    @B4A\n         CLC   0(44,R2),8(R3)          DSNAME FIND ??              @B4A\n         JE    ADSN_CONCAT_ERROR       BRANCH IF DSNAME MATCH      @B4A\nADSN_DUP_CHK_NEXT   DS  0H             LOCATE NEXT DSNTABLE ENTRY  @B4A\n         AHI   R3,52                   NEXT DSNTABLE ENTRY         @B4A\n         J     ADSN_DUP_CHK            END LOOP THRU ALL DSNAME    @B4A\nADSN_DUP_CHK_EXIT   DS  0H                                         @B4A\n         MVC   ALOC_DDN,$ISPFDSN       DDNAME FOR ALLOCATION\n         MVC   ALOC_DSN,0(R2)          DSNAME FOR ALLOCATION\n         LA    R0,ALOC_DDN             GET ADDR OF DDNAME\n         LA    R1,ALOC_DSN             GET ADDR OF DSNAME\n         BRAS  R14,DYN_ALLOCATE        DYNALLOC CONCAT\n         LTR   R15,R15                 RC = 0 ?\n         JNZ   ADSN_CONCAT_ERROR       BRANCH IF RC IS NOT 0\n         MVC   CON_DDN,0(R3)           PUT DDN IN PARM LIST\n         LA    R1,CON_RBP              GET ADDR OF ALLOC PARM LIST\n         DYNALLOC                      CONCAT\n         LTR   R15,R15                 RC = 0 ?\n         JZ    ADSN_CONCAT_OK          YES. BRANCH\n         L     R12,RACFWORK\n         ST    R15,0(,R12)             SAVE DYNALLOC ERROR CODE\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',CON_ERCD     GET ERROR CODE FROM RB\n         ST    R1,4(,R12)              SAVE RB ERROR CODE\n         SR    R2,R2                   CLEAR R1\n         ICM   R2,B'0011',CON_INFO     GET INFO CODE FROM RB\n         ST    R2,8(,R12)              SAVE RB INFO CODE\n         XC    12(4,R12),12(R12)       NO DSNAME\n         LA    R5,CCONCAT              CONCAT FUNCTION             @B3C\n         ST    R4,16(,R12)             SAVE ADDR OF DDNAME         @B3C\n         ST    R5,20(,R12)             FUNCTION IN ERROR           @B3C\n         BRAS  R14,DYN_ERROR_MSG       FORMAT DYNAMIC ERROR MESSAGE\n         SR    R0,R0                   CLEAR R0\n         ICM   R0,B'0011',CON_ERCD     GET ERROR CODE FROM RB\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',CON_INFO     GET INFO CODE FROM RB\n         LA    R15,4                   SET RC = 4\n         PR                                                       @B2A\n*\nADSN_CONCAT_OK DS   0H\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    ADSN_SKIPTRC2           SKIP TRACE IF TRACE IS OFF\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,32(,R8)              AMSG08 (4*8)\n         MVC   23(8,R8),0(R4)          PUT DDNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY MESSAGE MSG08\nADSN_SKIPTRC2  DS   0H\n         SR    R15,R15                 SET OK RETURN CODE\n         PR                            RETURN\nADSN_CONCAT_ERROR  DS  0H\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,44(,R8)              MSG11 (4*11)\n         MVC   13(8,R8),0(R3)          PUT DDNAME IN MSG           @B2A\n         MVC   57(44,R8),0(R2)         PUT DSN IN MSG              @B4C\nALLOCATE_DSN_EXIT  DS  0H\n         BRAS  R14,PUTLINE             DISPLAY MESSAGE MSG11\n         PR                            RETURN                      @B2A\n         EJECT\n*---------------------------------------------------------------------*\n*              PROCESS SYSOUT STATEMENTS                              *\n*---------------------------------------------------------------------*\n*        INPUT  R1 -> SYSOUT                                          *\n*---------------------------------------------------------------------*\n*        OUTPUT R15 = 0  DYNALLOC OK                                  *\n*                   = 8  DYNALLOC FAILED                              *\n*---------------------------------------------------------------------*\nALLOC_SYSOUT DS 0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\n*\n         MVC   SO_DDN,CURR_DDN         PUT DDNAME IN DYNALLOC\n         AHI   R1,7                    GET ADDR OF SYSOUT CLASS    @B3C\n         MVC   SO_CLASS,0(R1)          PUT SYSOUT CLASS IN DYNALLOC\n         AHI   R1,2                    POINT TO DEST (IF PRESENT)  @A7C\n         CLC   CDEST,0(R1)             DEST( KEYWORD HERE ?        @B3C\n         JNE   SOUT1200                NO.  BRANCH\n*                                      YES. EXTRACT DEST\n         MVC   SO_TXTS3,ASO_TXT3       ACTIVATE DEST TEXT UNIT     @B3C\n         MVC   SO_DEST,BLANKS          CLEAR DEST FIELD\n         LA    R3,8                    MAX 8 CHARS FOR DEST\n         LA    R4,SO_DEST              TARGET\n         LA    R5,5(0,R2)              SOURCE\nSOUT1000 DS    0H\n         CLI   0(R5),C')'              END OF DEST ?\n         JE    SOUT1200                YES. BRANCH\n         MVC   0(1,R4),0(R5)           EXTRACT A DEST CHAR\n         AHI   R4,1                    INCREMENT TARGET\n         AHI   R5,1                    INCREMENT SOURCE\n         BRCT  R3,SOUT1000             LOOP FOR 8 CHARS\nSOUT1200 DS    0H\n         LA    R1,SO_RBP               SYSOUT REQUEST BLOCK\n         DYNALLOC\n         LTR   R15,R15                 DYNALOLOC OK ?\n         JZ    SOUT1600                YES. BRANCH\n         L     R12,RACFWORK\n         ST    R15,0(,R12)             SAVE DYNALLOC ERROR CODE\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',SO_ERCD      GET ERROR CODE FROM RB\n         ST    R1,4(,R12)              SAVE RB ERROR CODE\n         SR    R2,R2                   CLEAR R1\n         ICM   R2,B'0011',SO_INFO      GET INFO CODE FROM RB\n         ST    R2,8(,R12)              SAVE RB INFO CODE\n*        SR    R3,R3                   NO DSNAME\n         XC    12(4,R12),12(R12)       NO DSNAME\n         LA    R4,SO_DDN               GET ADDR OF FAILING DDNANE\n         ST    R4,16(,R12)             SAVE ADDR OF FAILING DDNAME\n         LA    R5,CDYNALLO             DYNALLOC                    @B3C\n         ST    R5,20(,R12)             SAVE DYNALLOC FUNCTION CODE\n         BRAS  R14,DYN_ERROR_MSG       FORMAT DYNAMIC ERROR MESSAGE\n         CLC   X0410,SO_ERCD           DDNAME IN USE ?             @B3C\n         JNE   SOUT1400                NO.  BRANCH\n         LA    R1,SO_DDN               YES. GET DDNAME TO DEALLOC\n         BRAS  R14,UN_ALLOCATE         DEALLOC DDNAME\n         LTR   R15,R15                 DEALLOC OK ?\n         JZ    SOUT1200                YES. RETRY ALLOC\n*\nSOUT1400 DS    0H\n         LA    R15,8                   SET DYNALLOC FAILED CODE\n         PR\n*\nSOUT1600 DS    0H\n         XC    SO_TXTS3,SO_TXTS3       RESET DE-ACTIVATE DEST TEXT UNIT\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?             @B3A\n         JZ    ALLOC_SYSOUT_EXIT       SKIP TRACE IF TRACE IS OFF  @B3A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B3A\n         L     R8,188(,R8)             MSG47 (4*47)                @B3A\n         MVC   31(8,R8),SO_DDN         PUT DDNAME IN MSG           @B3A\n         BRAS  R14,PUTLINE             DISPLAY PROCESSING SYSOUT   @B3A\n         XR    R15,R15                                             @B3A\nALLOC_SYSOUT_EXIT DS 0H\n         PR                            RETURN TO CALLER            @B2A\n*\n         EJECT\n*---------------------------------------------------------------------*\n*              DYNAMICALLY ALLOCATE A DATASET                         *\n*---------------------------------------------------------------------*\n*              INPUT   R0 -> DDNAME FOR ALLOCATE                      *\n*                      R1 -> DSNAME AND MEMBER FOR ALLOCATE           *\n*---------------------------------------------------------------------*\n*              OUTPUT  R15 = 00   ALLOCATE OK                         *\n*                          = 04   ALLOCATE FAILED                     *\n*                      R0  = DYNALLOC ERROR CODE                      *\n*                      R1  = DYNALLOC INFO CODE                       *\n*---------------------------------------------------------------------*\nDYN_ALLOCATE   DS   0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\n         LR    R2,R0                   GET ADDR OF DDNAME\n         MVC   ALC_DDNAME,0(R2)        PUT DDNAME IN ALLOC PARM LIST\n         MVC   ALC_DSNAME,0(R1)        PUT DSN IN ALLOC PARM LIST\n         MVC   ALC_MEMBER,44(R1)       PUT MEM IN ALLOC PARM LIST  @A5A\n         MVI   ALC_TXTS+12,X'80'       INDICATE PDS MEM ALLOCATION @A5A\n         MVI   ALC_TXTS+8,X'00'        CLEAR DSN ALLOCATION        @A5A\n         CLI   ALC_MEMBER,C' '         MEMBER SPECIFIED            @A5A\n         JNE   ALLC2000                BRANCH IF DSN ALLOCATION    @A5A\n         MVI   ALC_TXTS+8,X'80'        INDICATE DSN ALLOCATION ONLY@A5A\n         MVI   ALC_TXTS+12,X'00'       CLEAR PDS MEM ALLOCATION    @A5A\nALLC2000 DS    0H\n         LA    R1,ALC_RBP              ADDR OF ALLOCATION RB\n         DYNALLOC\n         LTR   R15,R15                 DYNALOLOC OK ?\n         JZ    ALLC4000                BRANCH IF RC = 0\n         L     R12,RACFWORK\n         ST    R15,0(,R12)             SAVE DYNALLOC ERROR CODE\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',ALC_ERCD     GET ERROR CODE FROM RB\n         ST    R1,4(,R12)              SAVE RB ERROR CODE\n         SR    R2,R2                   CLEAR R1\n         ICM   R2,B'0011',ALC_INFO     GET INFO CODE FROM RB\n         ST    R2,8(,R12)              SAVE RB INFO CODE\n         LA    R3,ALC_DSNAME           GET ADDR OF FAILING DSNANE\n         ST    R3,12(,R12)             SAVE ADDR OF FAILING DSNANE\n         LA    R4,ALC_DDNAME           GET ADDR OF FAILING DDNANE\n         ST    R4,16(,R12)             SAVE ADDR OF FAILING DDNANE\n         LA    R5,CDYNALLO             DYNALLOC                   @B3C\n         ST    R5,20(,R12)             SAVE DYNALLOC FUNC CODE    @B3C\n         BRAS  R14,DYN_ERROR_MSG       FORMAT DYNAMIC ERROR MESSAGE\n         CLC   X0410,ALC_ERCD          DDNAME IN USE ?            @B3C\n         JNE   ALLC6000                NO.  BRANCH\n         LA    R1,ALC_DDNAME           YES. GET DDNAME TO DEALLOC\n         BRAS  R14,UN_ALLOCATE         DEALLOC DDNAME\n         LTR   R15,R15                 DEALLOC OK ?\n         JZ    ALLC2000                YES. RETRY ALLOC\n         OI    DSNFLAG2,DSNDDNF        FLUSH ALLOCS FOR THIS DDNAME\n         TM    DSNFLAG,DSNTRACE+DSNLIST   LIST OR TRACE ACTIVE ?\n         JZ    ALLC3000                NO . SKIP MSGS\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,24(,R8)              MSG06 (4*6)\n         MVC   46(8,R8),ALC_DDNAME     PUT DDNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY MSG06\nALLC3000 DS    0H\n         SR    R0,R0                   CLEAR R0\n         ICM   R0,B'0011',UA_ERCD      GET ERROR CODE FROM RB\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',UA_INFO      GET INFO CODE FROM RB\n         LA    R15,4                   SET DYNALLOC ERROR RET CODE\n         PR                            RETURN TO CALLER            @B2A\n*\nALLC4000 DS    0H\n         CLI   CURR_DDN,C' '                                       @B4A\n         JE    ALLC4500                                            @B4A\n         L     R8,DSNTCURR             CURRENT ADDRESS OF DSNTABLE @B4A\n         MVC   0(L'ALC_DDNAME,R8),CURR_DDN                         @B4A\n         MVC   8(L'ALC_DSNAME,R8),ALC_DSNAME                       @B4A\n         AHI   R8,52                   POINT TO NEXT ENTRY         @B4A\n         C     R8,DSNT_END             END OF DSNTABLE ?           @B4A\n         JH    ALLC5000                YES, DENIED THE REQUEST     @B4A\n         ST    R8,DSNTCURR             SAVE CURRENT ADDRESS        @B4A\n         MVC   0(52,R8),BLANKS         INIT NEXT ENTRY TO BLANKS   @B4A\nALLC4500 DS    0H\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    ALLC9000                NO. SKIP TRACE MESSAGE\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,28(,R8)              MSG07 (4*7)\n         MVC   20(L'ALC_DDNAME,R8),ALC_DDNAME   PUT DDNAME IN MSG  @B4C\n         MVC   35(L'ALC_DSNAME,R8),ALC_DSNAME   PUT DSNAME IN MSG  @B4C\n         BRAS  R14,PUTLINE             DISPLAY MESSAGE MSG07\n         J     ALLC9000                BRANCH\n*\nALLC5000 DS    0H                                                  @B4A\n         L     R8,ISPFMSGS             MESSAGE CSECT               @B4A\n         L     R8,192(,R8)             MSG48 (4*48)                @B4A\n         BRAS  R14,PUTLINE             DISPLAY MESSAGE MSG48       @B4A\n         LA    R15,4                   SET DYNALLOC ERROR RET CODE @B4A\n         PR                            RETURN TO CALLER            @B4A\n\nALLC6000 DS    0H\n         SR    R0,R0                   CLEAR R1\n         ICM   R0,B'0011',ALC_ERCD     GET ERROR CODE FROM RB\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',ALC_INFO     GET INFO CODE FROM RB\n         LA    R15,4                   SET DYNALLOC ERROR RET CODE\n         PR                            RETURN TO CALLER            @B2A\n*\nALLC9000 DS    0H\n         SR    R15,R15                 SET OK RETURN CODE\n         PR                            RETURN TO CALLER            @B2A\n         EJECT\n*---------------------------------------------------------------------*\n*              CLOSE TEMPDD                                           *\n*---------------------------------------------------------------------*\n* INPUT        R1 -> DDNAME TO CLOSE AND UN-ALLOCATE                  *\n*---------------------------------------------------------------------*\nCLOSE_TEMPPDS  DS    0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B4A\n         BALR  R12,0                                               @B4A\n         USING *,R12\n         CLOSE TEMPDD                  CLOSE TEMPDD                @B4A\n         DROP  R12\n         LA    R1,CTEMPPDS             SET DDNAME TO TEMPDD        @B4A\n         J     DYN_UN_MAIN                                         @B4A\n*---------------------------------------------------------------------*\n*              DYNAMIC UN-ALLOCATE DDN                                *\n*---------------------------------------------------------------------*\n* INPUT        R1 -> DDNAME TO DEALLOC                                *\n*---------------------------------------------------------------------*\n* OUTPUT       R15  = 0     UNALLOC OK                                *\n*                   = 4     UNALLOC FAILED                            *\n*---------------------------------------------------------------------*\nUN_ALLOCATE    DS   0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\nDYN_UN_MAIN    DS   0H\n         LR    R2,R1                   LOAD DDNAME PTR\n         TM    DSNFLAG,DSNTRACE        TRACE FLAG ON ?\n         JZ    DYN_UN_SKIPTM1          SKIP TRACE MSG IF TRACE IS OFF\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,156(,R8)             MSG39 (4*39)\n         MVC   26(8,R8),0(R2)          PUT DDNAME IN MSG\n         BRAS  R14,PUTLINE             ISSUE DEALLOC MESSAGE\nDYN_UN_SKIPTM1 DS   0H\n         MVC   UA_DDNAME,0(R2)         PUT DDNAME IN DYNALLOC LIST\n         LA    R1,UA_RBP               GET ADDR OF RB POINTER\n         DYNALLOC                      UN-ALLOCATE THE DDNAME\n         LTR   R15,R15                 RC = 0 ?\n         JZ    UN_ALLOCATE_EXIT        YES. BRANCH\n         L     R12,RACFWORK\n         ST    R15,0(,R12)             SAVE DYNALLOC ERROR CODE\n         SR    R1,R1                   CLEAR R1\n         ICM   R1,B'0011',UA_ERCD      GET ERROR CODE FROM RB\n         ST    R1,4(,R12)              SAVE RB ERROR CODE\n         SR    R2,R2                   CLEAR R2\n         ICM   R2,B'0011',UA_INFO      GET INFO CODE FROM RB\n         ST    R2,8(,R12)              SAVE RB INFO CODE\n*        SR    R3,R3                   DONT KNOW FAILING DSNAME\n         XC    12(4,R12),12(R12)       NO DSNAME\n         LA    R4,UA_DDNAME            GET ADDR OF FAILING DDNANE\n         ST    R4,16(,R12)             SAVE ADDR OF FAILING DDNAME\n         LA    R5,CDEALLOC             FUNCTION NAME IN ERROR      @B3A\n         ST    R5,20(,R12)             SAVE DYNALLOC ERROR CODE\n         BRAS  R14,DYN_ERROR_MSG       FORMAT DYNAMIC ERROR MESSAGE\n         LA    R15,4                   SET RC =04\nUN_ALLOCATE_EXIT DS 0H\n         PR                            RETURN\n         EJECT\n*---------------------------------------------------------------------*\n*              FROMAT DYNAMIC ALLOCATION ERROR CODE                   *\n*---------------------------------------------------------------------*\n*     INPUT   R12 = ADDRESS OF PARAMETER                              *\n*               0 = DYNALLOC RETURN CODE  (R15 FROM DYNALLOC)         *\n*               4 = DYNALLOC ERROR  CODE                              *\n*               8 = DYNALLOC REASON CODE                              *\n*              12 = DSNAME ADDRESS                                    *\n*              16 = DDNAME ADDRESS                                    *\n*              20 = FUNCTION IN ERROR                                 *\n*---------------------------------------------------------------------*\nDYN_ERROR_MSG  DS    0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\n         TM    DSNFLAG,DSNTRACE        DSNTRACE OR LIST ACTIVE ?\n         JZ    DYNE9000                NO.  BRANCH\n         LM    R0,R5,0(R12)\n         CHI   R0,8                    RC = 8 ?\n         JE    DYNE5000                YES. BRANCH\n         CHI   R0,12                   RC = 12 ?\n         JE    DYNE1000                YES. BRANCH\n*                                      RC = 4\n*        BRAS  R14,DYNE0200            DISPLAY ERROR MSGS\n*---------------------------------------------------------------------*\n*       FORMAT AND DISPLAY DYNAMIC ALLOCATION ERROR MSGS              *\n*---------------------------------------------------------------------*\n         MVC   FAILDSN,12(R12)         SAVE ADDR OF DSN            @B3C\n         MVC   FAILDDN,16(R12)         SAVE ADDR OF DDN            @B3C\n         LR    R3,R1                   GET DYNALLOC ERROR CODE\n         SRL   R3,8                    GET 2ND BYTE\n         CHI   R3,23                   LOCATE ERROR ?\n         JNE   DYNE0500                NO . UNKNOWN ERROR\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,160(,R8)             EMSG40 (4*40)\n         BRAS  R14,PUTLINE             DISPALY DATASET LOCATE ERROR\nDYNE0500 DS    0H\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,48(,R8)              EMSG12 (4*12)\n         MVC   4(8,R8),0(R5)           PUT FUNCTION NAME IN MSG\n         L     R5,FAILDDN              GET ADDR OF FAILING DDNAME\n         MVC   29(8,R8),0(R5)          PUT DDNAME IN MSG\n         MVC   43(44,R8),BLANKS        CLEAR DSNAME IN MSG\n         ICM   R5,B'1111',FAILDSN      GET ADDR OF FAILING DDNAME\n         JZ    DYNE0600                BRANCH\n         MVC   43(44,R8),0(R5)         PUT DSNAME IN MSG\nDYNE0600 DS    0H\n         BRAS  R14,PUTLINE             DISPLAY EMSG12\n         L     R0,0(,R12)              GET RETURN CODE\n         BRAS  R14,HEX2CHAR            CONVERT HEX TO CHAR\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,52(,R8)              EMSG13 (4*13)\n         MVC   10(4,R8),OUTSTRNG       RETURN CODE IN MSG\n         L     R0,4(,R12)              GET RB ERROR CODE\n         BRAS  R14,HEX2CHAR            CONVERT HEX TO CHAR\n         ST    R0,29(R8)               PUT ERROR CODE IN MSG\n         L     R0,8(,R12)              GET RB INFO CODE\n         BRAS  R14,HEX2CHAR            CONVERT HEX TO CHAR\n         ST    R0,48(R8)               PUT INFO CODE IN MSG\n         BRAS  R14,PUTLINE             DISPLAY EMSG13\n*              R15 = XXXX  ERROR CODE = XXXX REASON CODE = XXXX\n         L     R8,ISPFMSGS             GET ADDR OF MSG00\n         L     R8,0(,R8)               MSG00\n         BRAS  R14,PUTLINE             DISPLAY MSG MSG00\n         J     DYNE9000                BRANCH\nDYNE1000 DS    0H\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,48(,R8)              EMSG12 (4*12)\n         MVC   4(8,R8),0(R5)           PUT FUNCTION IN MSG\n         MVC   29(8,R8),0(R4)          PUT DDNAME IN MSG\n         MVC   43(44,R8),0(R3)         PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             DISPLAY MSG12\n*        LR    R0,R1                   GET ERROR CODE\n         L     R0,4(R12)               GET ERROR CODE\n         BRAS  R14,HEX2CHAR            CONVERT TO CHARACTER\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,52(,R8)              EMSG13 (4*13)\n         MVC   10(4,R8),C0012          PUT RET CODE IN MSG\n         ST    R0,28(R8)               PUT ERROR CODE IN MSG\n         LR    R0,R2                   GET INFO CODE\n         BRAS  R14,HEX2CHAR            CONVERT TO CHARACTER\n         ST    R0,48(R8)               PUT INFO CODE IN MSG\n         BRAS  R14,PUTLINE             WRITE MESSAGE EMSG13\n*        L     R8,ISPFMSGS             MESSAGE CSECT\n*        L     R8,12(,R8)              MSG03 (4*3)\n*        L     R15,FAILDSN                                        @B4A\n*        MVC   44(33,R8),0(R15)        GET DSNAME                 @B4A\n*        BRAS  R14,PUTLINE             DISPLAY MSG MSG03\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,136(,R8)             EMSG34 (4*34)\n         BRAS  R14,PUTLINE     DISPLAY DYNAMIC ALLOCATION PARM ERROR\n         J     DYNE9000                BRANCH\nDYNE5000 DS    0H\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,140(,R8)             EMSG35 (4*35)\n         BRAS  R14,PUTLINE     DISPLAY RETURN CODE 08 FROM DYNALLOC\nDYNE9000 DS    0H\n         SR    R15,R15                 RC = 0\n         PR                            RETURN TO CALLER            @B2A\n         EJECT\n*---------------------------------------------------------------------*\n*         VERIFY A DATASET EXISTS AND USER HAS READ ACCESS TO IT      *\n*---------------------------------------------------------------------*\n*       INPUT   R1 -> DSNAME                                          *\n*---------------------------------------------------------------------*\n*       OUTPUT  R15 =  0 = DATASET EXISTS AND CAN BE READ             *\n*               R15 =  4 = DATASET NOT CATALOGED                      *\n*               R15 =  8 = DATASET NOT ON VOLUME                      *\n*               R15 = 12 = NO READ ACCESS TO DATASET                  *\n*---------------------------------------------------------------------*\nCHECK_DSNAME DS 0H\n         BAKR  R14,0                   SAVE REGISTERS             @B2A\n         LR    R2,R1                   SAVE DSNAME POINTER\n         L     R3,RACFWORK                                         @A1A\n*---------------------------------------------------------------------*\n*              CHECK FOR READ AUTHORITY TO DATASET                    *\n*---------------------------------------------------------------------*\n         TM    DSNFLAG,DSNNRACF        NO RACF CHECK ??            @B1A\n         JO    CHKD0100                                            @B1A\n         TM    DSNFLAG,DSNTRACE        TRACE OPTION ??\n         JZ    CHKD0050                NO. SKIP TRACE MESSAGE\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,76(,R8)              MSG19 (4*19)\n         MVI   4(R8),C'R'              SET ROUTINE INDICATOR\n         MVC   23(44,R8),0(R2)         PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             WRITE MESSAGE AID022I\nCHKD0050 DS    0H\n         BALR  R12,0                                               @B3A\n         USING *,R12                                               @B3A\n         RACROUTE REQUEST=AUTH,ENTITY=((R2)),MF=(E,RACHECK),           X\n               WORKA=(3),RELEASE=1.9                               @A1A\n         LTR   R15,R15                 DO WE HAVE READ AUTH ?\n         JZ    CHKD0100                YES. BRANCH\n         DROP  R12\n         LA    R15,12                  NO.  SET NOT AUTH RET CODE\n         TM    DSNFLAG,DSNLIST+DSNTRACE     LIST OR TRACE OPTION ??\n         JZ    CHECK_DSNAME_EXIT       NO. BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,88(,R8)              EMSG22 (4*22)\n         MVC   59(44,R8),0(R2)         YES. PUT DSNAME IN MSG\n         BRAS  R14,PUTLINE             WRITE MESSAGE AID022I\n         LA    R15,12                  SET NOT AUTH RET CODE\n         PR                            RETURN\n*\nCHKD0100 DS    0H\n         ST    R2,DSCAMLST+4           PUT DSNAME PTR IN CAMLST\n         LOCATE DSCAMLST               ISSUE LOCATE\n         LTR   R15,R15                 IS IT CATALOGUED ?\n         JNZ   CHKD0200                NO.  BRANCH\n         MVC   VOLUME,LOCAREA+6        YES. EXTRACT VOLSER\n         CLC   CARCIVE,VOLUME          IS IT ARCHIVED ? (DMS)      @A3A\n         JE    CHECK_DSNAME_EXIT       BRANCH IF ARCHIVED BY DMS\n         CLC   CMIGRAT,VOLUME          IS IT ARCHIVED ? (HSM)      @B3A\n         JE    CHKD0300                BRANCH IF MIGRATED BY HSM   @A4A\n         ST    R2,OBCAMLST+4           PUT DSNAME PTR IN CAMLST\n         OBTAIN OBCAMLST               NO . CHECK VTOC ?\n         LTR   R15,R15                 IS DSN ON VOLUME ?\n         JZ    CHECK_DSNAME_EXIT       YES. BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,84(,R8)              EMSG21 (4*21)\n         MVC   42(44,R8),0(R2)         PUT DSN IN MSG\n         MVC   93(6,R8),VOLUME         PUT VOLSER IN MSG\n         BRAS  R14,PUTLINE             DISPLAY DATASET NOT IN VOLUME\n         LA    R15,8                   SET RETURN CODE\n         PR                            RETURN\n*\nCHKD0200 DS    0H                      DATASET NO CATALOGUED\n         LA    R15,4                   SET DATASET NOT CATLGED RET CODE\n         TM    DSNFLAG,DSNLIST+DSNTRACE     LIST OR TRACE OPTION ?\n         JZ    CHECK_DSNAME_EXIT       NO.  BRANCH\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,80(,R8)              EMSG20 (4*20)\n         MVC   38(44,R8),0(R2)         YES. PUT DSN IN MSG\n         BRAS  R14,PUTLINE             DISPLAY DATASET NOT IN CATALOG\n         LA    R15,4                   SET RC TO 4\n         PR                            RETURN\n*\nCHKD0300 DS    0H\n         TM    DSNFLAG,DSNBPHSM        BYPASS HSM ??              @A1A\n         JZ    CHKD0500                BRANCH IF NOBYPASS         @A4A\n         TM    DSNFLAG,DSNTRACE+DSNLIST    LIST OR TRACE ACTIVE ? @A4A\n         JZ    CHKD0400                NO. BRANCH                 @A4A\n         L     R8,ISPFMSGS             MESSAGE CSECT\n         L     R8,120(,R8)             EMSG30 (4*30)\n         MVC   39(44,R8),0(R2)         YES. PUT DSN IN MSG        @A4A\n         BRAS  R14,PUTLINE             DISPLAY EMSG30             @A4A\nCHKD0400 LA    R15,16                  BYPASS HSM DATA SET        @A1A\n         PR                            RETURN                     @A4A\nCHKD0500 SR    R15,R15                                            @A4A\nCHECK_DSNAME_EXIT DS  0H                                          @A4A\n         PR\n         EJECT\n*---------------------------------------------------------------------*\n*                  PROCESS MEMBER ROUTINE                             *\n*---------------------------------------------------------------------*\n*        INPUT     R0 =  0 = ADD MEMBER NAME TO TABLE                 *\n*                        4 = DELETE MEMBER NAME FROM TABLE            *\n*                        8 = GET NEXT ENTRY OFF TABLE                 *\n*                       12 = UNCONDITIONAL ADD                        *\n*                  R1 ->  MEMBER NAME                                 *\n*---------------------------------------------------------------------*\n*        OUTPUT    R1 ->  MEMBER NAME                       (GET)     *\n*                  R15  = 0    ALL OK                                 *\n*                  R15  = 4    MEMBER NAME DONE/EXCLUDE     (ADD)     *\n*                  R15  = 8    MEMBER NAME NOT IN TABLE     (DELETE)  *\n*                  R15  = 12   TABLE IS EMPTY               (GET)     *\n*                  R15  = 16   TABLE IS FULL                (ADD)     *\n*                  R15  = 20   MEMBER NAME EXIST            (ADD)     *\n*---------------------------------------------------------------------*\nPROCESS_MEMBER DS 0H\n         BAKR  R14,0                   SAVE REGISTERS              @B2A\n         LR    R2,R0                   SAVE FUNCTION TYPE\n         LR    R3,R1                   SAVE MEMBER NAME ADDR\n         L     R4,MBRTABLE             GET ADDR OF MEMBER TABLE    @B3C\n         LA    R5,50                   GET NUMBER OF ENTRIES\n         XR    R6,R6                   INIT FREE SLOT POINTER\n         CHI   R2,8                    GET REQUEST ?\n         JE    PMEM_GET_MEMBER         YES. BRANCH\nPMEM_NEXT_MEMBER1  DS   0H\n         CLC   0(8,R3),0(R4)           IS ENTRY IN TABLE ?\n         JE    PMEM2000                YES. BRANCH\n         CLI   0(R4),X'00'             END OF MEMBER TABLE ?\n         JE    PMEM4000                YES. BRANCH\n         AHI   R4,9                    POINT TO NEXT ENTRY\n         BRCT  R5,PMEM_NEXT_MEMBER1    LOOP THRU THE MEMBER TABLE\n*                                      END OF TABLE\n         J     PMEM4000                MEMBER NOT IN TABLE\nPMEM2000 DS    0H                      MEMBER IS IN TABLE\n         LA    R15,4                   ASSUME ADD REQUEST\n         CLI   8(R4),C'N'              NOT PROCESSED ?             @B3A\n         JNE   PMEM2500                BRANCH IF NOT PROCESSED     @B3A\n         LA    R15,20                  RESET RC TO 20              @B3A\nPMEM2500 DS    0H                      MEMBER IS IN TABLE\n         LTR   R2,R2                   IS THIS AN ADD REQUEST ?\n         JZ    PROCESS_MEMBER_EXIT     BRANCH IF YES\n         CHI   R2,12                   IS IT UNCOND ADD ?\n         JNE   PMEM3000                NO.  BRANCH FOR DELETE\n         MVI   8(R4),C'N'              YES. RESET USED INDICATOR\n         SR    R15,R15                 SET RC = 0\n         PR                            RETURN\nPMEM3000 DS    0H                      DELETE MEMBER FROM TABLE\n         MVI   8(R4),C'Y'              SET MEMBER ALREADY PROCESSED\n         LH    R8,MBRCT                                            @B4A\n         AHI   R8,-1                                               @B4A\n         STH   R8,MBRCT                                            @B4A\n         SR    R15,R15                 SET RC = 0\n         PR                            RETURN\nPMEM4000 DS    0H                      MEMBER NOT IN TABLE\n         LA    R15,8                   ASSUME MEMBER NOT FOUND\n         CHI   R2,4                    DELETE REQUEST ?\n         JE    PROCESS_MEMBER_EXIT     YES. BRANCH\n         LTR   R5,R5                   END OF TABLE ?\n         JNZ   PMEM_ADD_MEMBER         NO.  BRANCH\n         LA    R15,16                  SET RC 0 (TABLE IS FULL)\n         PR                            RETURN\nPMEM_ADD_MEMBER      DS  0H\n         MVC   0(8,R4),0(R3)           ADD MEMBER TO TABLE\n         MVI   8(R4),C'N'              SET MEMBER NOT PROCESSED FLAG\n         LH    R8,MBRCT                                            @B4A\n         AHI   R8,1                                                @B4A\n         STH   R8,MBRCT                                            @B4A\n         SR    R15,R15                 SET RC = 0\n         PR                            RETURN\nPMEM_GET_MEMBER      DS  0H            GET NEXT ENTRY OFF TABLE\n         LTR   R3,R3                   GET 1ST ENTRY OFF STACK ?\n         JZ    PMEM_CHK_MEMBER         YES. BRANCH\n         LR    R4,R3                   NO. START FROM THIS MEMBER\n         AHI   R4,9                    POINT TO NEXT ENTRY\nPMEM_CHK_MEMBER      DS  0H            GET ENTRY OFF TABLE\n         CLI   0(R4),C' '              END OF MEMBER TABLE ?\n         JE    PMEM_EMPTY_TABLE        BRANCH IF YES\n         CLI   8(R4),C'Y'              MEMBER DONE/EXCLUDE ?\n         JE    PMEM_NEXT_MEMBER2       YES. SKIP IT\n         LR    R1,R4                   ADDR OF MEMBER ENTRY\n         SR    R15,R15                 SET RC = 0\n         PR                            RETURN\nPMEM_NEXT_MEMBER2    DS  0H\n         AHI   R4,9                    POINT TO NEXT MEMBER ENTRY\n         BRCT  R5,PMEM_CHK_MEMBER      PROCESS NEXT MEMBER\nPMEM_EMPTY_TABLE     DS  0H\n         LA    R15,12                  SET RC = 12 (TABLE EMPTY)\nPROCESS_MEMBER_EXIT  DS  0H                                        @B2A\n         PR                            RETURN                      @B2A\n*---------------------------------------------------------------------*\n*                PUTLINE ROUTINE                                      *\n*---------------------------------------------------------------------*\n*                INPUT - R8 -> MSG TO DISPLAY                         *\n*---------------------------------------------------------------------*\nPUTLINE  DS    0H\n         BAKR  R14,0                   SAVE CALLERS REGS           @B2A\n         BALR  R12,0                   ESTABLISH ADDRESSIBILITY    @B3A\n         USING *,R12\n         L     R5,UPTADDR              GET UPT ADDR\n         L     R4,ECTADDR              GET ECT ADDR\n         XC    ECB,ECB                 CLEAR THE ECB\n         XC    IOPLADS,IOPLADS         CLEAR PUTLINE WORK AREA\n         PUTLINE PARM=PUTBLOCK,                                        X\n               UPT=(R5),               UPT ADDR                        X\n               ECT=(R4),               ECT ADDR                        X\n               ECB=ECB,                ECB ADDR                        X\n               OUTPUT=((R8),TERM,SINGLE,DATA),                         X\n               MF=(E,IOPLADS)\n         PR                            RETURN TO CALLER            @B2A\n         DROP  R12\n         EJECT\n*---------------------------------------------------------------------*\n*             CONVERT HEX STRING TO CHARACTER                         *\n*---------------------------------------------------------------------*\n*            INPUT  R0 = 2 BYTE BINARY                                *\n*           OUTPUT  R0 = 4 CHARACTER STRING                           *\n*---------------------------------------------------------------------*\nHEX2CHAR DS    0H\n         BAKR  R14,0                   RESTORE CALLERS REGS        @B2A\n         STH   R0,INSTRING             GET STRING TO CONVERT\n         LA    R2,INSTRING             GET ADDR OF INPUT STRING\n         LA    R3,OUTSTRNG             GET ADDR OF OUTPUT STRING\n         LA    R4,HEX_TBL              GET ADDR OF HEX CHAR TABLE\n         LA    R7,2                    PROCESS 2 BYTES\n         SR    R5,R5                   CLEAR R5\nHEXLOOP  DS    0H\n         IC    R5,0(0,R2)              GET AN INPUT BYTE\n         SRL   R5,4                    GET 1ST NIBBLE ONLY\n         LA    R6,0(R5,R4)             GET ADDR OF HEX DIGIT\n         MVC   0(1,R3),0(R6)           EXTRACT HEX DIGIT\n         IC    R5,0(0,R2)              GET AN INPUT BYTE\n         SLL   R5,28                   REMOVE 1ST NIBBLE\n         SRL   R5,28                   GET 2ND NIBBLE\n         LA    R6,0(R5,R4)             GET ADDR OF HEX DIGIT\n         MVC   1(1,R3),0(R6)           EXTRACT HEX DIGIT\n         AHI   R2,1                    POINT TO NEXT INPUT CHAR\n         AHI   R3,2                    POINT TO NEXT OUTPUT CHAR\n         BRCT  R7,HEXLOOP              LOOP THRU STRING\n         L     R0,OUTSTRNG             LOAD THE RESULT\n         SR    R15,R15                 SET OK RETURN CODE\n         PR                            RETURN TO CALLER            @B2A\n         EJECT\n*\nWORKSTOR DC    C'DATA AREA OF ISPFDSN =>'\nSYSUID   DC    CL8' '                  TSO USER ID\nRACFGRP  DC    CL8' '                  RACF CONNECT GROUP          @A1A\n*---------------------------------------------------------------------*\n*        DYNAMIC ALLOCATION REQUEST BLOCKS                            *\n*---------------------------------------------------------------------*\n         DS    0F\nALC_RBP  DC    X'80',AL3(ALC_RB)\n*\nALC_RB   DS    0F\n         DC    AL1(20),X'01'                DSNAME ALLOCATION VERB CODE\n         DC    H'0'                         ALLOCATION FLAGS1\nALC_ERCD DC    H'0'                         ERROR CODE\nALC_INFO DC    H'0'                         INFORMATION CODE\n         DC    A(ALC_TXTS)                  TEXT UNIT POINTER\n         DC    F'0'                         REQUEST BLOCK EXTENSION\n         DC    F'0'                         ALLOCATION FLAGS2\n*\nALC_TXTS DC    A(ALC_TXT1)\n         DC    A(ALC_TXT2)\n         DC    A(ALC_TXT3)                                         @A5C\n         DC    A(ALC_TXT4)                                         @A5A\n*\nALC_TXT1    DS  0F                      DDNAME TEXT UNIT\n            DC  XL2'01',XL2'01',AL2(8)  KEY,#,LENGTH\nALC_DDNAME  DS  CL8                     DDNAME\n*\nALC_TXT2    DS  0F                      DSNAME TEXT UNIT\n            DC  XL2'02',XL2'01',AL2(44) KEY,#,LENGTH\nALC_DSNAME  DS  CL44                    DSNAME\n*\nALC_TXT3    DS  0F                      DISP TEXT UNIT\n            DC  XL2'04',XL2'01',XL2'01',X'08'   KEY,#,LENGTH,DISP=SHR\nALC_TXT4    DS  0F                      MEMBER TEXT UNIT           @A5A\n            DC  XL2'03',XL2'01',XL2'08'                            @A5A\nALC_MEMBER  DC  CL8' '                  MEMBER                     @A5A\n*\n         EJECT\n*---------------------------------------------------------------------*\n*              DUMMY ALLOCATION REQUEST BLOCK                         *\n*---------------------------------------------------------------------*\n         DS    0F\nDMY_RBP  DC    X'80',AL3(DMY_RB)\n*\nDMY_RB   DS    0F\n         DC    AL1(20),X'01'           DSNAME ALLOCATION VERB CODE\n         DC    H'0'                    ALLOCATION FLAGS1\nDMY_ERCD DC    H'0'\nDMY_INFO DC    H'0'\n         DC    A(DMY_TXTS)             TEXT UNIT POINTER\n         DC    F'0'                    REQUEST BLOCK EXTENSION\n         DC    F'0'                    ALLOCATION FLAGS2\n*\nDMY_TXTS DC    A(DMY_TXT1)\n         DC    A(DMY_TXT2)\n         DC    X'80',AL3(DMY_TXT3)     LAST TEXT UNIT\n*\nDMY_TXT1 DS    0F                      DDNAME TEXT UNIT\n         DC    XL2'01',XL2'01',AL2(8)  KEY,#,LENGTH\nDMY_TXT_DDN DS CL8                     DDNAME\n*\nDMY_TXT2 DS    0F                      DUMMY TEXT UNIT\n         DC    XL2'24',XL2'00'         KEY,#\n*\nDMY_TXT3 DS    0F                      PERM ALLOC TEXT UNIT\n         DC    XL2'52',XL2'00'         KEY,#\n         EJECT\n*---------------------------------------------------------------------*\n*              SYSOUT ALLOCATION REQUEST BLOCK                        *\n*---------------------------------------------------------------------*\n         DS    0F\nSO_RBP   DC    X'80',AL3(SO_RB)\n*\nSO_RB    DS    0F\n         DC    AL1(20),X'01'           DSNAME ALLOCATION VERB CODE\n         DC    H'0'                    ALLOCATION FLAG1\nSO_ERCD  DC    H'0'\nSO_INFO  DC    H'0'\n         DC    A(SO_TXTS)              TEXT POINTER\n         DC    F'0'\n         DC    F'0'                    ALLOCATION FLAG2\n*\nSO_TXTS  DC    A(SO_TXT1)\n         DC    A(SO_TXT2)\nSO_TXTS3 DC    A(0)\n         DC    X'80',AL3(SO_TXT4)      LAST TEXT UNIT\n*\nSO_TXT1  DS    0F                      DDNAME TEXT UNIT\n         DC    XL2'01',XL2'01',AL2(8)  KEY,#,LENGTH\nSO_DDN   DS    CL8                     DDNAME\n*\nSO_TXT2  DS    0F                      SYSOUT TEXT UNIT\n         DC    XL2'18',XL2'01',AL2(01) KEY,#,LENGTH\nSO_CLASS DS    C                       SYSOUT CLASS\n*\nSO_TXT3  DS    0F                      DEST TEXT UNIT\n         DC    XL2'58',XL2'01',XL2'08' KEY,#,LENGTH\nSO_DEST  DS    CL8                     DEST\n*\nSO_TXT4  DS    0F                      PERM ALLOC TEXT UNIT\n         DC    XL2'52',XL2'00'         KEY,#\n         EJECT\nASO_TXT3 DC    A(SO_TXT3)                                          @B3A\n*---------------------------------------------------------------------*\n*              TERMINAL ALLOCATION REQUEST BLOCK                      *\n*---------------------------------------------------------------------*\n          DS   0F\nTERM_RBP  DC   X'80',AL3(TERM_RB)\n*\nTERM_RB   DS   0F\n          DC   AL1(20),X'01'           DSNAME ALLOCATION VERB CODE\n          DC   H'0'                    ALLOCATION FLAGS1\nTERM_ERCD DC   H'0'\nTERM_INFO DC   H'0'\n          DC   A(TERM_TXTS)            TEXT POINTER\n          DC   F'0'\n          DC   F'0'                    ALLOCATION FLAGS2\n*\nTERM_TXTS DC   A(TERM_TXT1)            DDNAME\n          DC   A(TERM_TXT2)\n          DC   A(TERM_TXT3)                                        @B4A\n          DC   X'80',AL3(TERM_TXT4)    PERM ALLOCATION TEXT UNIT\n*\nTERM_TXT1 DS   0F                      DDNAME TEXT UNIT\n          DC   XL2'01',XL2'01',AL2(8)  KEY,#,LENGTH\nTERM_DDNAME    DS  CL8                 DDNAME\n*\nTERM_TXT2 DS   0F                      DUMMY TEXT UNIT\n          DC   XL2'28',XL2'00'         KEY,#\n*\nTERM_TXT3 DS   0F                      DUMMY TEXT UNIT             @B4A\n          DC   XL2'18',AL2(1,1)      SYSOUT CLASS KEY, NUM, PARMLEN@B4A\nTERM_SYSO DC   CL1'X'                SYSOUT CLASS FIELD            @B4A\n*\nTERM_TXT4 DS   0F                      PERM ALLOCATION TEXT UNIT\n          DC   XL2'52',XL2'00'         KEY,#\n          EJECT\n*---------------------------------------------------------------------*\n*              DYNAMIC UN-ALLOCATE REQUEST BLOCK                      *\n*---------------------------------------------------------------------*\n          DS   0F\nUA_RBP    DC   X'80',AL3(UA_RB)\n*\nUA_RB     DS   0F\n          DC   AL1(20),X'02'           UN-ALLOCATION VERB\n          DC   H'0'                    DE-ALLOCATION FLAGS1\nUA_ERCD   DC   H'0'\nUA_INFO   DC   H'0'\n          DC   A(UA_TXTS)              TEXT POINTER\n          DC   F'0'                    REQUEST BLOCK EXTENSION\n          DC   F'0'                    DE-ALLOCATION FLAGS2\n*\nUA_TXTS   DC   A(UA_TXT1)\n          DC   X'80',AL3(UA_TXT2)\n*\nUA_TXT1   DS   0F                      DDNAME TEXT UNIT\n          DC   XL2'07',XL2'00'         KEY,#\nUA_TXT2   DS   0F                      DDNAME TEXT UNIT\n          DC   XL2'01',XL2'01',AL2(8)  KEY,#,LENGTH\nUA_DDNAME DS   CL8                     DDNAME\n*\n         EJECT\n*---------------------------------------------------------------------*\n*              CONCATENATE REQUEST BLOCK                              *\n*---------------------------------------------------------------------*\n         DS    0F\nCON_RBP  DC    X'80',AL3(CON_RB)\n*\nCON_RB   DS    0F\n         DC    AL1(20),X'03'           CONCATENATE VERB\n         DC    H'0'                    CONCATENATE FLAGS1\nCON_ERCD DC    H'0'\nCON_INFO DC    H'0'\n         DC    A(CON_TXTS)             TEXT POINTER\n         DC    F'0'\n         DC    F'0'                    CONCATENATE FLAGS2\n*\nCON_TXTS DC    A(CON_TXT1)\n         DC    X'80',AL3(CON_TXT2)     LAST TEXT UNIT\n*\nCON_TXT1 DS    0F                      DDNAME TEXT UNIT\n         DC    XL2'01',XL2'02'         KEY,#\n         DC    AL2(8)\nCON_DDN  DS    CL8\n         DC    AL2(8),CL8'$ISPFDSN'\n*\nCON_TXT2 DS    0F                      PERM CONCAT ATTR\n         DC    XL2'04',XL2'00'         KEY,#,\n*\n*---------------------------------------------------------------------*\n*                   EXECUTE MOVE INSTRUCTION                          *\n*---------------------------------------------------------------------*\nMVCGROUP MVC   RACFGRP(0),0(R1)                                    @A8A\nMVCPREFX MVC   PREFIX(0),0(R1)                                     @B3C\nMVCUSUFF MVC   USERSUFF(0),0(R1)                                   @B3A\nMVCPROC  MVC   ALOC_DSN(0),0(R1)                                   @B3C\nMVCPROCM MVC   ALOC_MEM(0),0(R1)                                   @A8A\nMVCMEMBR MVC   TEMP_MEM(0),0(R12)                                  @A8A\nMVCDSN   MVC   TEMP_DSN(0),0(R3)                                   @A8A\nMVCDDN   MVC   CURR_DDN(0),0(R1)                                   @B4A\nMVCLEFT  MVC   0(0,R2),0(R3)                                       @B4A\n*\n*---------------------------------------------------------------------*\n*                   PROGRAM VARIABLES                                 *\n*---------------------------------------------------------------------*\nDSNFLAG  DC    X'00'                   INPUT OPTION FLAG\nDSNLIST  EQU   X'80'                   LIST\nDSNTRACE EQU   X'40'                   TRACE\nDSNDSNM  EQU   X'20'                   PROC                        @B3A\nDSNLGPRC EQU   X'10'                   LOGON PROCEDURE NAME        @B3A\nDSNUSER  EQU   X'08'                   USER ISPFDSN SUFFIX         @B3A\nDSNGB4GL EQU   X'04'                   ALLOC GROUP THEN GLOBAL     @B3A\nDSNBPHSM EQU   X'02'                   BYPASS MIGRATED DATA SET    @A1A\nDSNNRACF EQU   X'01'                   NO RACHECK                  @B1A\nDSNFLAG2 DC    X'00'                   FLAG2                       @B4A\nDSNDDNF EQU    X'80'             FLUSH ALLOC FOR CURRENT DDNAME    @B3A\nDSNPASS1 EQU   X'40'                   GLOBAL ISPFDSN PASS 1 COMP  @B4A\nDSN1DSN  EQU   X'20'                   DSN BEFORE DISP             @B4A\n*DEBUG1  EQU   X'01'                   USED FOR DEBUG              @B3A\n*\nBUFFADDR DS    A                       ADDR OF I/O BUFFER\nRACFWORK DS    A                       ADDRESS POINTER FOR RACF    @A1A\nDDNTABLE DS    A                       50 X 8 DDNAME TABLE         @B3A\nMBRTABLE DS    A                       50 X 9 MEMBER NAME TABLE    @B3A\nDSNTABLE DS    A                       300 X 60 (DD + DSN + MEM)   @B4A\nDSNTCURR DS    A                       ADDRESS OF CURRENT DSNTABLE @B4A\nDSNT_END DS    A                       END OF DSNTABLE             @B4A\nX0410    DC    X'0410'                                             @B3A\nDDJCL    DC    C' DD '                                             @B3A\nCEXEC    DC    C' EXEC '                                           @B3A\nCPROC    DC    C' PROC '                                           @B3A\nJCLCOMT  DC    C'//*'                                              @B3A\nCISPFDOT DC    C'.'                                                @B4A\n$ISPFDSN DC    C'$ISPFDSN'                                         @B3A\n         DC    C'.PROCLIB'                                         @B4A\nUSERSUFF DC    CL8' '                  ISPFDSN USER SUFFIX         @B3A\nCSTEPLIB DC    C'STEPLIB '                                         @B3A\nCJOBLIB  DC    C'JOBLIB '                                          @B3A\nCSTEPCAT DC    C'STEPCAT '                                         @B3A\nCJOBCAT  DC    C'JOBLIB '                                          @B3A\nCISPTABL DC    C'ISPTABL'                                          @B3A\nCDEALLOC DC    C'DEALLOC'                                          @B3A\nCRMM     DC    C'RMM '                                             @B3A\nCINCLUDE DC    C'INCLUDE='                                         @B3A\nCEXCLUDE DC    C'EXCLUDE='                                         @B3A\nCTERM    DC    C' TERM=TS'                                         @B3A\nCDUMMY   DC    C' DUMMY'                                           @B3A\nCSYSOUT  DC    C' SYSOUT='                                         @B3A\nCDEST    DC    C'DEST('                                            @B3A\nCCONCAT  DC    C'CONCAT  '                                         @B3A\n*CMEMBER DC    C',MEMBER='                                         @B3A\nCDISP    DC    C' DISP='                                           @B3A\nCGLOBAL  DC    C'GLOBAL'                                           @B3A\nCARCIVE  DC    C'ARCIVE'                                           @B3A\nCMIGRAT  DC    C'MIGRAT'                                           @B3A\nCSHR     DC    C'SHR'                                              @B3A\nCOLD     DC    C'OLD'                                              @B3A\nCNEW     DC    C'NEW'                                              @B3A\nCMOD     DC    C'MOD'                                              @B3A\nCDSNE    DC    C',DSN='                                            @B3A\nCGROUP   DC    C'GROUP'                                            @B4A\n*USERID  DC    C'USERID'                                           @B3A\nCSYSUID  DC    C'SYSUID'                                           @B3A\nSYSUIDL  DC    H'7'                                                @B3A\nPREFIXL  DC    H'4'                    LENGTH OF PREFIX\nPREFIX   DC    CL8'SYS1'               ISPFDSN PREFIX\nCDYNALLO DC    C'DYNALLOC'                                         @B3A\nCALLOCAT DC    C'ALLOCATE'                                         @B3A\nCTEMPPDS DC    C'TEMPPDS '                                         @B3A\nC0012    DC    C'0012'                                             @B2A\nECB      DS    F                       REQUIRED FOR PUTLINE MACRO\nIOPLADS  DS    4F                      REQUIRED FOR PUTLINE MACRO\nCMDANSR  DC    F'0'                    PARSE ANSWER AREA POINTER\nCMDPPL   DS    0F                      PARSE COMMAND PPL:\nUPTADDR  DS    A                         ADDR OF USERS UPT\nECTADDR  DS    A                         ADDR OF USERS ECT\nCMDECB   DC    A(ECB)                    ECB POINTER\nCMDPCL   DC    A(IKJPCL)                 ADDRESS OF IKJPARM\nCMDANS   DC    A(CMDANSR)                PLACE TO PUT ANSWER\nCMDCBUF  DC    F'0'                    POINTER TO COMMAND BUFFER\nCPPLADDR DS    A                       ADDR OF CPPL\nFAILDDN  DS    A                       ADDR FAILING DYNALLOC DDNAME\nFAILDSN  DS    A                       ADDR FAILING DYNALLOC DSNAME\nCURR_DDN DC    CL8' '                  CURRENT DDNAME\nALOC_DDN DC    CL8' '                  DDNAME FOR DYNALLOC\nALOC_DSN DC    CL44' '                 DSNAME FOR DYNALLOC\nALOC_MEM DC    CL8' '                  MEMBER FOR DYNALLOC         @A5A\nIUSE_DSN DC    CL44' '                 DSN BEING PROCESSED\nIUSE_MBR DC    CL8' '                  MEMBER NAME BEING PROCESSED\nIUSE_DDN DC    CL8' '                  DDNAME BEING PROCESSED\nTEMP_DSN DC    CL44' '                 DSN WORK AREA\nTEMP_MEM DC    CL8' '                  MEMBER WORK AREA            @A5A\nHEX_TBL  DC    C'0123456789ABCDEF'     HEX TO CHAR CONVERSION TABLE\nBLANKS   DC    60C' '                  BLANKS\nLOCAREA  DS    265C                    CAMLST WORK AREA\nOUTSTRNG DC    CL4' '                  OUTPUT FROM HEX HEX2CHAR ROUTINE\nINSTRING DS    H                       INPUT TO HEX HEX2CHAR ROUTINE\nVOLUME   DC    CL6' '\nADDR_PH  DS    (PHL)C                  PROCPDS PLACE HOLDER\nALLOCPH  DS    (PHL)C                  TEMP LIB PLACE HOLDER\nWORKSIZE DC    F'16962'                                            @B4A\nIOBUFSZ  DC    F'32768'                                            @B3A\nSTMTEND  DC    H'0'                    ENDING POSITION OF STATEMENT@A8A\nMBRCT    DC    H'0'                    NUMBER OF UNPROCESSED MEMBER@B4A\n*---------------------------------------------------------------------*\n*                   MACRO LIST FORMS                                  *\n*---------------------------------------------------------------------*\nRACHECK  RACROUTE REQUEST=AUTH,ENTITY=(0),CLASS='DATASET',RACFIND=NO,  X\n               VOLSER=VOLUME,MSGSUPP=YES,                              X\n               RELEASE=1.9,MF=L                                    @A1A\nDSCAMLST CAMLST NAME,0,,LOCAREA\nOBCAMLST CAMLST SEARCH,0,VOLUME,LOCAREA\nPUTBLOCK PUTLINE MF=L\n*--------------------------------------------------------------------*\n*                   INPUT DATASET DCB                                *\n*--------------------------------------------------------------------*\nTEMPDD   DCB   DSORG=PO,MACRF=R,EODAD=PDS_EOFM,DDNAME=TEMPPDS\n         EJECT\n*ROFILE  DC    C'SYSUID.'\nCSID     DC    X'50'                        &\n         DC    C'SID.'\nISPPROF  DC    C'.ISPF.ISPPROF'\n         DC    XL2'00'                      END OF MSG LIST\n*\nISPFMSGS DC    V(ISPFMSGS)\nVISPQRY  DC    V(ISPQRY)                                           @B3A\n         EJECT\n*---------------------------------------------------------------------*\n*                      IKJPARSE                                       *\n*---------------------------------------------------------------------*\nIKJPCL   IKJPARM                                                   @A8A\nIKPREFX  IKJKEYWD                                                  @B1A\n         IKJNAME   'PREFIX',SUBFLD=IKSPREFX                        @B1A\nIKGROUP  IKJKEYWD                                                  @A8A\n         IKJNAME   'GROUP',SUBFLD=IKSGROUP                         @A8A\nIKUSER   IKJKEYWD                                                  @B3A\n         IKJNAME   'USER',SUBFLD=IKSUSER                           @B3A\nIKLIST   IKJKEYWD                                                  @B3A\n         IKJNAME   'LIST'                                          @A8A\nIKTRACE  IKJKEYWD                                                  @A8A\n         IKJNAME   'TRACE'                                         @A8A\nIKBYPHSM IKJKEYWD                                                  @A8A\n         IKJNAME   'BYPHSM'                                        @A8A\nIKLOGPRC IKJKEYWD                                                  @A8A\n         IKJNAME   'LOGONPRC'                                      @B3A\nIKGR4SYS IKJKEYWD                                                  @A8A\n         IKJNAME   'GRPB4GLB'                                      @B3A\nIKNRACF  IKJKEYWD                                                  @B1A\n         IKJNAME   'NORACF'                                        @B1A\nIKDSN    IKJKEYWD                                                  @A8A\n         IKJNAME   'DSN',SUBFLD=IKSADSN                            @A8A\nIKMEMBER IKJKEYWD                                                  @A8A\n         IKJNAME   'MEMBER',SUBFLD=IKSMEMBR                        @A8A\nIKSADSN  IKJSUBF                                                   @A8A\nIKSIADSN IKJIDENT  'DSNAME',FIRST=ALPHA,OTHER=ANY,                     C\n               PROMPT='DSNAME',MAXLNTH=44                          @A8A\nIKSMEMBR IKJSUBF                                                   @A8A\nIKSIAMEM IKJIDENT  'MEMBER',FIRST=ALPHA,OTHER=ALPHANUM,                C\n               PROMPT='PROC MEMBER',MAXLNTH=8                      @A8A\nIKSGROUP IKJSUBF                                                   @A8A\nIKSIGRP  IKJIDENT  'GROUP',FIRST=ALPHA,OTHER=ALPHANUM,                 C\n               PROMPT='RACF GROUP NAME',MAXLNTH=8                  @A8A\nIKSPREFX IKJSUBF                                                   @B3A\nIKSIPREX IKJIDENT  'PREFIX',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8   @B3A\nIKSUSER  IKJSUBF                                                   @B3A\nIKSIUSER IKJIDENT  'USER',FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8,        C\n               PROMPT='SUFFIX OF YOUR PRIVATE ISPFDSN'             @B3A\n         IKJENDP                                                   @A8A\n         EJECT\n*\n*---------------------------------------------------------------------*\n*              DSECTS                                                 *\n*---------------------------------------------------------------------*\nPH       DSECT\nCURRMEM  DS    CL8                 PDS MEMBER NAME\nNEXTREC  DS    F                   ADDR OF NEXT RECORD IN BLOCK\nREMAINS  DS    F                   # OF BYTES LEFT IN CURRENT BLOCK\nPHL      EQU   *-PH                LENGTH OF THIS BLOCK\n         EJECT\n*---------------------------------------------------------------------*\n*              DSECTS                                                 *\n*---------------------------------------------------------------------*\n         CVT  DSECT=YES,LIST=NO\n         IKJTCB DSECT=YES,LIST=NO\n         DCBD DSORG=PS\n         IKJCPPL\n         IHAASCB\n         IHAASXB\n         IHAACEE\n         IHAPSA\n         IKJUPT\n         YREGS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPFDSNG": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00U\\x01\\x14'\\x8f\\x01\\x14'\\x8f\\x10(\\x00\\x04\\x00\\x04\\x00\\x01\\xc9\\xe2\\xd7\\xc6\\xc4\\xe2\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-10-05T00:00:00", "modifydate": "2014-10-05T10:28:55", "lines": 4, "newlines": 4, "modlines": 1, "user": "ISPFDSN"}, "text": "INCLUDE=SYSTEM        /* ISPF,ISPF/PDF,SDSF,BPX     */\nINCLUDE=INHOUSE       /* INHOUSE UTILITY            */\n/*\nINCLUDE=RMM           /* RMM                        */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPFDSNT": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00U\\x01\\x14'\\x8f\\x01\\x14'\\x8f\\x10(\\x00\\x01\\x00\\x01\\x00\\x01\\xc9\\xe2\\xd7\\xc6\\xc4\\xe2\\xd5@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2014-10-05T00:00:00", "modifydate": "2014-10-05T10:28:55", "lines": 1, "newlines": 1, "modlines": 1, "user": "ISPFDSN"}, "text": "INCLUDE=DB2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPFDSNU": {"ttr": 1799, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00U\\x01\\x14'\\x8f\\x01\\x14'\\x8f\\x10(\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xe2\\xd7\\xc6\\xc4\\xe2\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-10-05T00:00:00", "modifydate": "2014-10-05T10:28:55", "lines": 9, "newlines": 9, "modlines": 0, "user": "ISPFDSN"}, "text": "//SYSPROC  DD DISP=SHR,DSN=&SYSUID.CLIST\n//         DD DISP=SHR,DSN=&SYSUID.EDMACRO\n//SYSEXEC  DD DISP=SHR,DSN=&SYSUID.SYSEXEC\n//ISPLLIB  DD DISP=SHR,DSN=&SYSUID.LOAD\n//ISPPLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPPLIB\n//ISPMLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPMLIB\n//ISPTLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPTLIB\n//ISPSLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPSLIB\nEXCLUDE=DB2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ISPFMSGS": {"ttr": 1801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01V\\x00H\\x01\\x14(o\\x01\\x14(o\\x17\\x00\\x00\\xf2\\x00\\xf2\\x00\\xf2\\xc1\\xe2\\xd4@@@@@@@'", "ispf": {"version": "01.86", "flags": 0, "createdate": "2014-10-13T00:00:00", "modifydate": "2014-10-13T17:00:48", "lines": 242, "newlines": 242, "modlines": 242, "user": "ASM"}, "text": "ISPFMSGS CSECT\nAMSG00   DC  A(MSG00)   AID000I: FOR DETAIL REFER AUTHORISED ASSE\nAMSG01   DC  A(MSG01)   AID001I: ISPFDSN STARTED\nAMSG02   DC  A(MSG02)   AID002I: ISPFDSN COMPLETE\nAMSG03   DC  A(MSG03)   AID003I: MBR = XXXXXXX DSN =\nAMSG04   DC  A(MSG04)   AID004I: MEMBER XXXXXXX ALREADY ADDEDD\nAMSG05   DC  A(MSG05)   AID005W: MEMBER $ISPFDSN IS PROHIBITED\nAMSG06   DC  A(MSG06)   AID006W: ISPF ACTIVE OR FILE OPEN\nAMSG07   DC  A(MSG07)   DYNALLOC  DDNAME = XXXXXXXX DSN = '\nAMSG08   DC  A(MSG08)   CONCAT    DDNAME = XXXXXXXX'\nAEMSG09  DC  A(EMSG09)  SYNTAX ERROR - XXXXXXXXXXXXX\nAEMSG10  DC  A(EMSG10)  INVALID DISP - XXXXXXXXXXXXX\nAEMSG11  DC  A(EMSG11)  AID011I: XXXXXXX CONCAT FAILS. DUPLICATE\nAEMSG12  DC  A(EMSG12)\nAEMSG13  DC  A(EMSG13)  R15 = XXXX  ERROR CODE = XXXX REASON CODE\nAEMSG14  DC  A(EMSG14)\nAEMSG15  DC  A(EMSG15)\nAEMSG16  DC  A(EMSG16)  AID016E:  DDNAME   CAN NOT BE DYNAMIC ALLOCATE\nAEMSG17  DC  A(EMSG17)  AID017W:  MEMBER   ALREADY PROCESSED OR\nAEMSG18  DC  A(EMSG18)  AID018E: SECOND LEVEL QUALIFIER ONLY SUPPORTS\nAMSG19   DC  A(MSG19)\nAEMSG20  DC  A(EMSG20)  AID020I: DATASET NOT IN CATALOG -\nAEMSG21  DC  A(EMSG21)\nAEMSG22  DC  A(EMSG22)\nAEMSG23  DC  A(EMSG23)\nAEMSG24  DC  A(EMSG24)\nAEMSG25  DC  A(EMSG25)  AID025E: REACH 50 MEMBERS.\nAEMSG26  DC  A(EMSG26)  AID026W: 300 DDNAMES ARE ALLOCATED.\nAEMSG27  DC  A(EMSG27)\nAEMSG28  DC  A(EMSG28)  AID028E: ISPFDSN PARM MEMBER XXX NOT FOUND\nAEMSG29  DC  A(EMSG29)\nAEMSG30  DC  A(EMSG30)\nAEMSG31  DC  A(EMSG31)\nAEMSG32  DC  A(EMSG32)\nAEMSG33  DC  A(EMSG33)\nAEMSG34  DC  A(EMSG34)\nAEMSG35  DC  A(EMSG35)  RETURN CODE 08 FROM DYNALLOC\nAMSG36   DC  A(MSG36)   MEMBER XXXXXXX IS REMOVED\nAMSG37   DC  A(MSG37)   EOF ON MEMBER\nAMSG38   DC  A(MSG38)   INPUT RECORD\nAMSG39   DC  A(MSG39)   DEALLOCATING DDNAME = XXXXXXXX\nAEMSG40  DC  A(EMSG40)  DATASET LOCATE ERROR\nAMSG41   DC  A(MSG41)   TRACE MODE IS ACTIVATED\nAMSG42   DC  A(MSG42)   RACFGRP TO BE USED\nAMSG43   DC  A(MSG43)   LIST OPTION SPECIFIED\nAEMSG44  DC  A(EMSG44)  DATASET ALLOCATION FAILS\nAEMSG45  DC  A(EMSG45)  DDNAME IS IN USED\nAMSG46   DC  A(MSG46)   PROCESSING TERM DDNAME\nAMSG47   DC  A(MSG47)   PROCESSING SYSOUT DDNAME\nAMSG48   DC  A(MSG48)   UNABLE TO OPEN ISPFDSN PARMLIB\nAMSG49   DC  A(MSG49)   PROCESSING MEMBER XXXXXXXX DSN =\nAMSG50   DC  A(MSG50)   AID050E: INVALID MEMBER NAME\nAMSG51   DC  A(MSG51)   AID051E: DSNAME IS LONGER THAN 44 CHARACTERS\nAMSG52   DC  A(MSG52)   AID052E: SYSOUT=* IS NOT SUPPORTED\nAMSG53   DC  A(MSG53)   AID053E: FIRST LEVEL QUALIFIER ONLY SUPPORTS\nAMSG54   DC  A(MSG54)   AID054E: INVALID DDNAME\nAMSG55   DC  A(MSG55)   AID055E: DD SYSOUT=?,TERM=TS NOT SUPPORT\n*\nMSG00    DC  AL2(L'MSG00T+4),AL2(0)\nMSG00T   DC  C'AID000I: FOR DETAIL REFER AUTHORISED ASSEMBLER SERVICE GX\n               UIDE'\n*\nMSG01    DC  AL2(L'MSG01T+4),AL2(0)\nMSG01T   DC  C'AID001I: ISPFDSN STARTED'\n*\nMSG02    DC  AL2(L'MSG02T+4),AL2(0)\nMSG02T   DC  C'AID002I: ISPFDSN COMPLETE'\n*\nMSG03    DC  AL2(L'MSG03T+4),AL2(0)\nMSG03T   DC  CL78'AID003I: MBR = XXXXXXX DSN = '\n*\nMSG04    DC  AL2(L'MSG04T+4),AL2(0)\nMSG04T   DC  C'AID004I: MEMBER XXXXXXX ALREADY ADDED'\n*\nMSG05    DC  AL2(L'MSG05T+4),AL2(0)                                @B4A\nMSG05T   DC  C'AID005W: MEMBER $ISPFDSN IS PROHIBITED'             @B4A\n*               1234567890123456\nMSG06    DC  AL2(L'MSG06+4),AL2(0)\nMSG06T   DC  C'AID006W: ISPF ACTIVE OR FILE OPEN, DDNAME 12345678'\n*\nMSG07    DC  AL2(L'MSG07T+4),AL2(0)\nMSG07T   DC  CL87'DYNALLOC  DDN = 12345678 DSN = X'\n*SG07T   DC  CL94'DYNALLOC  MEMBER = XXXXXXXX DDN = 12345678 DSN = X'\n*                  12345678901234567890123456789012345678901234567890\nMSG08    DC  AL2(L'MSG08T+4),AL2(0)\nMSG08T   DC     C'CONCAT TO DDNAME = XXXXXXXX'\n*   9\nEMSG09   DC  AL2(L'EMSG09T+4),AL2(0)                               @A7A\nEMSG09T  DC  C'SYNTAX ERROR - 12345678901234567890123456789012345678901X\n               2345678901234567890'\n*  10\nEMSG10   DC  AL2(L'EMSG10T+4),AL2(0)                               @A7A\nEMSG10T  DC  C'INVALID DISP - 12345678901234567890123456789012345678901X\n               2345678901234567890'\nEMSG11   DC  AL2(L'EMSG11T+4),AL2(0)                               @B4C\nEMSG11T  DC  C'AID011I: XXXXXXX CONCAT FAILS. DUPLICATE ENTRY DSN = 123X\n               45678901234567890123456789012345678901234'\n*              012345678901234567890123456789012345678901234567890123\nEMSG12   DC  AL2(L'EMSG12T+4),AL2(0)\nEMSG12T  DC  CL88'12345678 ERROR  DDNAME = XXXXXXXX DSN= '\n*                  123456789012345678901234567890123456789\nEMSG13   DC  AL2(L'EMSG13T+4),AL2(0)\nEMSG13T  DC  C'R15 = XXXX  ERROR CODE = XXXX REASON CODE = XXXX'\n*              0123456789012345678901234567890123456789012345678\nEMSG14   DC  AL2(L'EMSG14T+4),AL2(0)\nEMSG14T  DC  CL106'MEMBER NOT FOUND. MBR = XXXXXXXX DDNAME = XXXXXXXX DX\n               SN = '\n*\nEMSG15   DC  AL2(L'EMSG15T+4),AL2(0)\nEMSG15T  DC  C'AID015E NO MEMBER OPERAND. PROCESS ABORTED!'\n*\nEMSG16   DC  AL2(L'EMSG16T+4),AL2(0)\nEMSG16T  DC  C'AID016E:  DDNAME   CAN NOT BE DYNAMIC ALLOCATED'\n*\nEMSG17   DC  AL2(L'EMSG17T+4),AL2(0)\nEMSG17T  DC  C'AID017W:  MEMBER   ALREADY PROCESSED OR EXCLUDED'\n*\nEMSG18   DC  AL2(L'EMSG18T+4),AL2(0)\nEMSG18T  DC  C'AID018E: SECOND LEVEL QUALIFIER ONLY SUPPORT &&SID'\n*\nMSG19    DC  AL2(L'MSG19T+4),AL2(0)\nMSG19T   DC  CL68'X PROCESSING DSN = '\n*                 01234567890123456789\nEMSG20   DC  AL2(L'EMSG20T+4),AL2(0)\nEMSG20T  DC  CL83'AID020I: DATASET NOT IN CATALOG - '\n*                 01234567890123456789012345678901234\nEMSG21   DC  AL2(L'EMSG21T+4),AL2(0)\nEMSG21T  DC  C'ALC021I: DATASET NOT ON VOLUME. DSN = 123456789012345678X\n               90123456789012345678901234 VOL = 123456'\n*\nEMSG22   DC  AL2(L'EMSG22T+4),AL2(0)\nEMSG22T  DC  CL104'AID022E: RACF AUTHORIZATION FAILED, DATASET BYPASSEDX\n                - '\n*\nEMSG23   DC  AL2(L'EMSG23T+4),AL2(0)\nEMSG23T  DC  C'AID023E: 50 DDNAMES ARE ALLOCATED. REACH MAXIMUM LIMIT'\n* 24\nEMSG24   DC  AL2(L'EMSG24T+4),AL2(0)\nEMSG24T  DC  CL76'DATASET IN USE. DDN = XXXXXXXX DSN = '\n* 25\nEMSG25   DC  AL2(L'EMSG25T+4),AL2(0)\nEMSG25T  DC  C'AID025E: REACH 50 MEMBERS. UNABLE TO PROCESS MEMBER 1234X\n               5678 , WILL BE BYPASSED'\n* 26\nEMSG26   DC  AL2(L'EMSG26T+4),AL2(0)                               @B4A\nEMSG26T  DC  C'AID026W: 300 DDNAMES ARE ALLOACTED. REACH MAXIMUM LIMIT'\n* 27\nEMSG27   DC  AL2(L'EMSG27T+4),AL2(0)\nEMSG27T  DC  C'AID027W: EMPTY MEMBER'\n* 28\nEMSG28   DC  AL2(L'EMSG28T+4),AL2(0)\nEMSG28T  DC  CL80'AID028E: ISPFDSN PARM MEMBER XXXXXXXX NOT FOUND '\n* 29              012345678901234567890123456789\nEMSG29   DC  AL2(L'EMSG29T+4),AL2(0)\nEMSG29T  DC  C'AID029E: NO MEMBERS FOUND IN SYSTEM ISPFDSN, ALLOCATIONSX\n                MAY BE INCOMPLETE'\n*\nEMSG30   DC  AL2(L'EMSG30T+4),AL2(0)\nEMSG30T  DC  CL84'AID030I: MIGRAT DATA SET SKIPPED - '\n*\nEMSG31   DC  AL2(L'EMSG31T+4),AL2(0)                               @A7A\nEMSG31T  DC  C'AID031W: ISPF IS ACTIVE! ISPF LIBRARIES WILL NOT BE ALLOX\n               CATED'                                              @A7A\n*\nEMSG32   DC  AL2(L'EMSG32T+4),AL2(0)                               @A7A\nEMSG32T  DC  C'INVALID PARM.   DDN = XXXXXXXX DSN = 1234567890123456789X\n               0123456789012345678901234'                          @A7A\n*\nEMSG33   DC  AL2(L'EMSG33T+4),AL2(0)                               @A7A\nEMSG33T  DC  CL76'BLANK DDNAME.   DDN = XXXXXXXX DSN = '\n*\nEMSG34   DC  AL2(L'EMSG34T+4),AL2(0)\nEMSG34T  DC  C'DYNAMIC ALLOCATION PARAMETER ERROR'\n*\nEMSG35   DC  AL2(L'EMSG35T+4),AL2(0)\nEMSG35T  DC  C'RETURN CODE 08 FROM DYNALLOC - INSTALLATION VALIDATION EX\n               XIT DENIED THIS REQUEST'\n*\nMSG36    DC  AL2(L'MSG36+4),AL2(0)\nMSG36T   DC  C'MEMBER XXXXXXX IS REMOVED FROM MEMBER TABLE'\n*\nMSG37    DC  AL2(L'MSG37T+4),AL2(0)\nMSG37T   DC  C'EOF ON MEMBER 12345678'\n*\nMSG38    DC  AL2(L'MSG38T+4),AL2(0)\nMSG38T   DC  C'--------> 1234567890123456789012345678901234567890123456X\n               78901234567890123456789012'\n*\nMSG39    DC  AL2(L'MSG39T+4),AL2(0)\nMSG39T   DC  C'DEALLOCATING DDNAME = XXXXXXXX'\n*              01234567890123456789012\n* 40\nEMSG40   DC  AL2(L'EMSG40T+4),AL2(0)\nEMSG40T  DC  C'DATASET LOCATE ERROR'\n*  41\nMSG41    DC  AL2(L'MSG41T+4),AL2(0)\nMSG41T   DC  C'TRACE MODE IS ACTIVATED'\n*  42\nMSG42    DC  AL2(L'MSG42T+4),AL2(0)\nMSG42T   DC  C'RACFGRP TO BE USED IS ########'\n*  43\nMSG43    DC  AL2(L'MSG43T+4),AL2(0)\nMSG43T   DC  C'LIST OPTION SPECIFIED'\n*  44\nEMSG44   DC  AL2(L'EMSG44T+4),AL2(0)\nEMSG44T  DC  C'USER   ISPFDSN DATASET ALLOCATION FAILS'\n*  45          01234567\nEMSG45   DC  AL2(L'EMSG45T+4),AL2(0)\nEMSG45T  DC  C'DDN = XXXXXXXX IS IN USED'\n*  46                                                              @B3A\nMSG46    DC  AL2(L'MSG46T+4),AL2(0)                                @B3A\nMSG46T   DC  C'DYALLOC    TERM DDNAME = XXXXXXXX '                 @B3A\n*  47\nMSG47    DC  AL2(L'MSG47T+4),AL2(0)                                @B3A\nMSG47T   DC  C'DYALLOC    SYSOUT DDNAME = XXXXXXXX '               @B3A\n*  48\nMSG48    DC  AL2(L'MSG48T+4),AL2(0)                                @B3A\nMSG48T   DC  C'AID048E: UNABLE TO ACCESS ISPFDSN PARMLIB'          @B3A\n*  49\nMSG49    DC  AL2(L'MSG49T+4),AL2(0)\nMSG49T   DC  CL77'PROCESSING MEMBER XXXXXXXX DSN = '\n*                  123456789012345678901234567890123\n*  50                                                              @B4A\nMSG50    DC  AL2(L'MSG50T+4),AL2(0)                                @B4A\nMSG50T   DC  C'AID050E: INVALID MEMBER NAME'                       @B4A\n*  51                                                              @B4A\nMSG51    DC  AL2(L'MSG51T+4),AL2(0)                                @B4A\nMSG51T   DC  C'AID051E: DSNAME IS LONGER THAN 44 CHARACTERS'       @B4A\n*  52\nMSG52    DC  AL2(L'MSG52T+4),AL2(0)                                @B4A\nMSG52T   DC  C'AID052E: SYSOUT=* IS NOT SUPPORTED'                 @B4A\n*  53\nMSG53    DC  AL2(L'MSG53T+4),AL2(0)                                @B4A\nMSG53T   DC  C'AID053E: FIRST LEVEL QUALIFIER ONLY SUPPORT &&SYSUID'\n*  54\nMSG54    DC  AL2(L'MSG54T+4),AL2(0)                                @B4A\nMSG54T   DC  C'AID054E: INVALID DDNAME'\n*  55\nMSG55    DC  AL2(L'MSG55T+4),AL2(0)                                @B4A\nMSG55T   DC  C'AID055E: TERM=TS MUST BE THE FIRST KEYWORD'\n*\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LOGON": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x04\\x00@\\x01\\x14'\\x9f\\x01\\x14'\\x9f\\x179\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc3\\xd3\\xc9\\xe2\\xe3@@@@@\"", "ispf": {"version": "01.04", "flags": 0, "createdate": "2014-10-06T00:00:00", "modifydate": "2014-10-06T17:39:40", "lines": 30, "newlines": 30, "modlines": 0, "user": "CLIST"}, "text": "PROC 0 PANEL(ISP@SYS2)\nSET &DSNAME = &SYSUID..ISPF.ISPPROF /* SET DEFAULT NAME  */\nCONTROL NOMSG NOFLUSH\nFREE FI(ISPPROF)\nALLOC DA('&DSNAME') F(ISPPROF) SHR\nIF &LASTCC ^= 0 THEN       /* DOES PROFILE DS EXIST ?  */  +\n    DO                     /* DATA SET DOES NOT EXIST  */\n      FREE F(ISPCRTE)\n      CONTROL MSG\n      ATTRIB ISPCRTE DSORG(PO) RECFM( F B ) LRECL(80) BLKSIZE(6160)\n      ALLOC DA('&DSNAME') SP (15,3) TRACKS DIR(20) USING (ISPCRTE) +\n        F(ISPPROF) UNIT(SYSDA)\n      IF &LASTCC = 0 THEN  +\n         WRITE *** ISPF PROFILE DATA SET '&DSNAME.' HAS BEEN CREATED\n      ELSE  +\n        DO\n          WRITE *** UNABLE TO ALLOCATE ISPF PROFILE DATASET '&DSNAME.'\n          FREE F(ISPCRTE)\n          EXIT CODE(12)\n        END\n      FREE F(ISPCRTE)\nEND\nSET &LG = 0\nDO UNTIL &LG = 8\n    ISPFDSN BYPHSM\n    ISPF PANEL(&PANEL)\n    SET &LG = &LASTCC\n    IF &LG = 0 THEN LOGOFF\n    IF &LG = 4 THEN WRITE RE-ALLOCATE ISPF DIALOG DATASETS\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSTEM": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00U\\x01\\x14'\\x8f\\x01\\x14'\\x8f\\x10(\\x00\\x18\\x00\\x18\\x00\\x00\\xc9\\xe2\\xd7\\xc6\\xc4\\xe2\\xd5@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2014-10-05T00:00:00", "modifydate": "2014-10-05T10:28:55", "lines": 24, "newlines": 24, "modlines": 0, "user": "ISPFDSN"}, "text": "//SYSLBC   DD DISP=SHR,DSN=SYS1.BRODCAST\n//SYSHELP  DD DISP=SHR,DSN=SYS1.HELP\n//         DD DISP=SHR,DSN=ISP.SISPHELP\n//         DD DISP=SHR,DSN=SYS1.SBDTHELP\n//SYSPROC  DD DISP=SHR,DSN=CPAC.CMDPROC\n//         DD DISP=SHR,DSN=ISP.SISPCLIB\n//SYSEXEC  DD DISP=SHR,DSN=ISF.SISFEXEC\n//         DD DISP=SHR,DSN=ISP.SISPEXEC\n//         DD DISP=SHR,DSN=SYS1.SBPXEXEC\n//         DD DISP=SHR,DSN=EOY.SEOYCLIB       BOOK MANAGER\n//ISPPLIB  DD DISP=SHR,DSN=CPAC.ISPPLIB\n//         DD DISP=SHR,DSN=ISP.SISPPENU\n//         DD DISP=SHR,DSN=ISF.SISFPLIB\n//ISPMLIB  DD DISP=SHR,DSN=ISP.SISPMENU\n//         DD DISP=SHR,DSN=ISF.SISFMLIB\n//         DD DISP=SHR,DSN=SYS1.SBPXMENU\n//ISPSLIB  DD DISP=SHR,DSN=ISP.SISPSLIB\n//         DD DISP=SHR,DSN=ISF.SISFSLIB\n//         DD DISP=SHR,DSN=ISP.SISPSENU\n//ISPTABL  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPPROF\n//ISPTLIB  DD DISP=SHR,DSN=&SYSUID.ISPF.ISPPROF\n//         DD DISP=SHR,DSN=ISP.SISPTENU\n//         DD DISP=SHR,DSN=ISF.SISFTLIB\n//         DD DISP=SHR,DSN=SYS1.SBPXTENU\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT921/FILE921.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT921", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}